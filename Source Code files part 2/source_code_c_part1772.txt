 if (plv->fGroupView &&
                    !LISTITEM_HASGROUP(pitem))
                {
                    continue;   // Don't paint items not in a group.
                }
            }
            else
                i2 = i;


            plv->iItemDrawing = i2;

            lvdi.nmcd.nmcd.dwItemSpec = i2;

            // these may get changed
            lvdi.lpptOrg = NULL;
            lvdi.flags = 0;
            lvdi.nmcd.clrText = plv->clrText;
            lvdi.nmcd.clrTextBk = plv->clrTextBk;
            lvdi.nmcd.clrFace = plv->clrBk;
            lvdi.nmcd.iIconEffect = ILD_NORMAL;
            lvdi.nmcd.iIconPhase = 0;


            bSuccess = ListView_DrawItem(&lvdi);

            if (!bSuccess) 
            {
                break;
            }
        }

        if (ListView_IsRearrangeableView(plv) && 
            (ListView_IsOwnerData(plv)) && 
            plv->iFocus != -1) 
        {
            // since there's no zorder in ownerdata, we explicitly draw the focus guy last (again)
            // so that it'll appear on top
            // we may potentially want to do this for all items that are selected
            plv->iItemDrawing = plv->iFocus;

            lvdi.nmcd.nmcd.dwItemSpec = plv->iItemDrawing;

            // these may get changed
            lvdi.lpptOrg = NULL;
            lvdi.flags = 0;
            lvdi.nmcd.clrText = plv->clrText;
            lvdi.nmcd.clrTextBk = plv->clrTextBk;

            ListView_DrawItem(&lvdi);
        }

            
        // this is an NT5/Memphis feature.

        if (ListView_Count(plv) == 0)
        {
            // there're no items in this view
            // check if we need to display some text in this case.

            if (ListView_GetEmptyText(plv))
            {
                RECT rcClip;
                UINT flags = 0;

                // Put some edging between the text and the border of the
                // window so we don't slam up against the border.
                // This keeps DBCS from looking horrid.
                rcClip.left = g_cxEdge;
                rcClip.top = g_cyEdge;

                if (plv->dwExStyle & WS_EX_RTLREADING)
                    flags |= SHDT_RTLREADING;

                // if its a report view && we have a header then move the text down
                if (ListView_IsReportView(plv) && (!(plv->ci.style & LVS_NOCOLUMNHEADER)))
                    rcClip.top += plv->cyItem;

                // Note: Use the full sizeClient.cx as the right margin
                // in case pszEmptyText is wider than the client rectangle.

                rcClip.left -= (int)plv->ptlRptOrigin.x;
                rcClip.right = plv->sizeClient.cx;
                rcClip.bottom = rcClip.top + plv->cyItem;

                SHDrawText(hdc, plv->pszEmptyText,
                    &rcClip, LVCFMT_LEFT, flags,
                    plv->cyLabelChar, plv->cxEllipses,
                    plv->clrText, plv->clrBk);
            }
        }

        plv->iItemDrawing = -1;

        // post painting.... this is to do any extra (non item) painting
        // such a grid lines
        switch (plv->wView) 
        {
        case LV_VIEW_DETAILS:
            ListView_RAfterRedraw(plv, hdc);
            break;
        }

        // Insert mark
        {
            RECT rcInsertMark;
            if (ListView_OnGetInsertMarkRect(plv, &rcInsertMark))
            {
                OffsetRect(&rcInsertMark, -plv->ptOrigin.x, -plv->ptOrigin.y);
                CCDrawInsertMark(hdc,
                                 &rcInsertMark,
                                 ((plv->ci.style & LVS_ALIGNMASK) == LVS_ALIGNTOP),
                                 ListView_OnGetInsertMarkColor(plv));
            }
        }

        // notify parent afterwards if they want us to
        if (plv->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) 
        {
            CICustomDrawNotify(&plv->ci, CDDS_POSTPAINT, &nmcd);
        }
    }
}

BOOL ListView_DrawItem(PLVDRAWITEM plvdi)
{
    BOOL fAllowHotSelection = FALSE;
    BOOL bRet = TRUE;
    UINT state;

    if (!ListView_IsOwnerData(plvdi->plv) && (!plvdi->plv->hdpa || plvdi->nmcd.nmcd.dwItemSpec > (UINT)DPA_GetPtrCount(plvdi->plv->hdpa)))
        return FALSE;

    if (!ListView_IsOwnerData(plvdi->plv)) 
    {
        plvdi->pitem = ListView_FastGetItemPtr(plvdi->plv, plvdi->nmcd.nmcd.dwItemSpec);
    }

    // notify on custom draw then do it!
    plvdi->nmcd.nmcd.uItemState = 0;
    plvdi->nmcd.nmcd.lItemlParam = (plvdi->pitem)? plvdi->pitem->lParam : 0;

    if (!(plvdi->flags & LVDI_NOWAYFOCUS))
    {
        if (plvdi->plv->flags & LVF_FOCUSED) 
        {

            // if we're ownerdraw or asked to callback, go
            // fetch the state
            if (!plvdi->pitem || (plvdi->plv->stateCallbackMask & (LVIS_SELECTED | LVIS_FOCUSED)))
            {
                state = (WORD) ListView_OnGetItemState(plvdi->plv, (int) plvdi->nmcd.nmcd.dwItemSpec,
                                                LVIS_SELECTED | LVIS_FOCUSED);
            } 
            else 
            {
                state = plvdi->pitem->state;
            }


            if (state & LVIS_FOCUSED) 
            {
                plvdi->nmcd.nmcd.uItemState |= CDIS_FOCUS;
            }

            if (state & LVIS_SELECTED) 
            {
                plvdi->nmcd.nmcd.uItemState |= CDIS_SELECTED;
            }
        }

        // NOTE:  This is a bug.  We should set CDIS_SELECTED only if the item
        // really is selected.  But this bug has existed forever so who knows
        // what apps are relying on it.  Standard workaround is for the client
        // to do a GetItemState and reconfirm the LVIS_SELECTED flag.
        // That's what we do in ListView_DrawImageEx.
        if (plvdi->plv->ci.style & LVS_SHOWSELALWAYS)
        {
            plvdi->nmcd.nmcd.uItemState |= CDIS_SELECTED;
        }
    }

    if (!(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS))
    {
        plvdi->nmcd.nmcd.uItemState |= CDIS_SHOWKEYBOARDCUES;
    }

    plvdi->nmcd.clrText = plvdi->plv->clrText;
    plvdi->nmcd.clrTextBk = (plvdi->plv->ci.style & WS_DISABLED ? plvdi->plv->clrBk : plvdi->plv->clrTextBk);


    if ((plvdi->plv->exStyle & LVS_EX_UNDERLINEHOT) &&
        plvdi->plv->iHot == (int)plvdi->nmcd.nmcd.dwItemSpec &&
        (plvdi->plv->exStyle & LVS_EX_ONECLICKACTIVATE) ||
        ((plvdi->plv->exStyle & LVS_EX_TWOCLICKACTIVATE) &&
         ListView_OnGetItemState(plvdi->plv, (int) plvdi->nmcd.nmcd.dwItemSpec, LVIS_SELECTED))) 
    {

        fAllowHotSelection = TRUE;
        // Handle the HOT case
        if (plvdi->plv->clrHotlight != CLR_DEFAULT)
        {
            plvdi->nmcd.clrText = plvdi->plv->clrHotlight;
        }
        else
        {
            plvdi->nmcd.clrText = GetSysColor(COLOR_HOTLIGHT);
        }

        // if hotlight color is the same as the background
        // color you don't see the text -- slam to a visible color in this case.
        if (plvdi->nmcd.clrText == plvdi->nmcd.clrTextBk)
        {
            if (COLORISLIGHT(plvdi->nmcd.clrTextBk))
                plvdi->nmcd.clrText = 0x000000; // black
            else
                plvdi->nmcd.clrText = 0xFFFFFF; // white
        }

        SelectFont(plvdi->nmcd.nmcd.hdc, plvdi->plv->hFontHot);

        plvdi->nmcd.nmcd.uItemState |= CDIS_HOT;
    } 
    else if ((plvdi->plv->exStyle & LVS_EX_ONECLICKACTIVATE) ||
               ((plvdi->plv->exStyle & LVS_EX_TWOCLICKACTIVATE) &&
                ListView_OnGetItemState(plvdi->plv, (int) plvdi->nmcd.nmcd.dwItemSpec, LVIS_SELECTED))) 
    {
                    
        // Handle the non-hot webview case
        if ((plvdi->plv->exStyle & LVS_EX_UNDERLINECOLD) && 
            plvdi->plv->hFontHot)
        {
            SelectFont(plvdi->nmcd.nmcd.hdc, plvdi->plv->hFontHot);
        }
        else
        {
            SelectFont(plvdi->nmcd.nmcd.hdc, plvdi->plv->hfontLabel);
        }
    } 
    else 
    {
        // Handle the non-webview case
        SelectFont(plvdi->nmcd.nmcd.hdc, plvdi->plv->hfontLabel);
    }


    plvdi->dwCustom = CICustomDrawNotify(&plvdi->plv->ci, CDDS_ITEMPREPAINT, &plvdi->nmcd.nmcd);

    plvdi->flags &= ~(LVDI_FOCUS | LVDI_SELECTED);
    if (plvdi->nmcd.nmcd.uItemState & CDIS_FOCUS)
        plvdi->flags |= LVDI_FOCUS;

    if (plvdi->nmcd.nmcd.uItemState & CDIS_SELECTED)
    {
        if (plvdi->plv->flags & LVF_FOCUSED)
            plvdi->flags |= LVDI_SELECTED;
        else
            plvdi->flags |= LVDI_SELECTNOFOCUS;
        if (plvdi->plv->iHot == (int)plvdi->nmcd.nmcd.dwItemSpec && fAllowHotSelection)
            plvdi->flags |= LVDI_HOTSELECTED;
    }

    if (!(plvdi->dwCustom & CDRF_SKIPDEFAULT)) 
    {

        if (!ListView_IsOwnerData(plvdi->plv)) 
        {
            if (plvdi->dwCustom & CDRF_NEWFONT) 
            {
                _ListView_RecomputeLabelSize(plvdi->plv, plvdi->pitem, (int) plvdi->nmcd.nmcd.dwItemSpec, plvdi->nmcd.nmcd.hdc, FALSE);
            }
        }

        bRet = _ListView_DrawItem(plvdi);


        if (plvdi->dwCustom & CDRF_NOTIFYPOSTPAINT) 
        {
            plvdi->nmcd.iSubItem = 0;
            CICustomDrawNotify(&plvdi->plv->ci, CDDS_ITEMPOSTPAINT, &plvdi->nmcd.nmcd);
        }

        if (plvdi->dwCustom & CDRF_NEWFONT)
        {
            SelectObject(plvdi->nmcd.nmcd.hdc, plvdi->plv->hfontLabel);
            plvdi->plv->flags |= LVF_CUSTOMFONT;
        }
    }
    return bRet;
}

void WINAPI SHThemeDrawText(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCTSTR pszText, RECT* prc, int fmt,
                UINT flags, int cyChar, int cxEllipses, COLORREF clrText, COLORREF clrTextBk)
{
    int cchText;
    COLORREF clrSave = GetTextColor(hdc), clrSaveBk = 0;
    RECT rc;
    UINT uETOFlags = 0;
    BOOL fForeOnly = FALSE;
    TCHAR ach[CCHLABELMAX + CCHELLIPSES];
    int align;
    BOOL fUseShadowedText = (flags & SHDT_SHADOWTEXT) && (!g_fHighContrast);

    if (!pszText)
        return;

    if (IsRectEmpty(prc))
        return;

    if (flags & SHDT_RTLREADING) 
    {
        align = GetTextAlign(hdc);
        SetTextAlign(hdc, align | TA_RTLREADING);
    }


    rc = *prc;

    if (fUseShadowedText)
    {
        if (!AreAllMonitorsAtLeast(16))
            fUseShadowedText = FALSE;
    }

    // If needed, add in a little extra margin...
    //
    if (flags & SHDT_EXTRAMARGIN)
    {
        rc.left  += g_cxLabelMargin * 3;
        rc.right -= g_cxLabelMargin * 3;
    }
    else if (!(flags & SHDT_NOMARGIN))
    {
        rc.left  += g_cxLabelMargin;
        rc.right -= g_cxLabelMargin;
    }

    if ((rc.left >= rc.right) && !(flags & (SHDT_SELECTED | SHDT_DESELECTED | SHDT_SELECTNOFOCUS)))
        return;

    if ((flags & SHDT_ELLIPSES) &&
            ListView_NeedsEllipses(hdc, pszText, &rc, &cchText, cxEllipses))
    {
        // In some cases cchText was comming back bigger than
        // ARRYASIZE(ach), so we need to make sure we don't overflow the buffer

        // if cchText is too big for the buffer, truncate it down to size
        if (cchText >= ARRAYSIZE(ach) - CCHELLIPSES)
            cchText = ARRAYSIZE(ach) - CCHELLIPSES - 1;

        memcpy(ach, pszText, cchText * sizeof(TCHAR));
        lstrcpy(ach + cchText, c_szEllipses);

        pszText = ach;

        // Left-justify, in case there's no room for all of ellipses
        //
        fmt = LVCFMT_LEFT;

        cchText += CCHELLIPSES;
    }
    else
    {
        cchText = lstrlen(pszText);
    }

    if (((clrTextBk == CLR_NONE) && !(flags & (SHDT_SELECTED | SHDT_SELECTNOFOCUS))) || (flags & SHDT_TRANSPARENT))
    {
        fForeOnly = TRUE;
        clrSave = SetTextColor(hdc, (flags & SHDT_TRANSPARENT) ? 0 : clrText);
    }
    else if (!hTheme || clrTextBk != CLR_NONE)
    {
        HBRUSH hbrUse = NULL;
        HBRUSH hbrDelete = NULL;

        uETOFlags |= ETO_OPAQUE;

        if ((flags & SHDT_SELECTED || flags & SHDT_SELECTNOFOCUS) && !(flags & SHDT_NOSELECTED))
        {
            fUseShadowedText = FALSE;
            if (flags & SHDT_SELECTNOFOCUS)
            {
                clrText = g_clrBtnText;
                clrTextBk = g_clrBtnFace;
                if (flags & SHDT_DRAWTEXT)
                {
                    hbrUse = g_hbrBtnFace;
                }
            }
            else
            {
                clrText = g_clrHighlightText;
                if (flags & SHDT_HOTSELECTED)
                    clrTextBk = GetSysColor(COLOR_HOTLIGHT);
                else
                    clrTextBk = g_clrHighlight;

                if (flags & SHDT_DRAWTEXT)
                    hbrUse = (flags & SHDT_HOTSELECTED)?GetSysColorBrush(COLOR_HOTLIGHT): g_hbrHighlight;
            }
        }
        else if (clrText == CLR_DEFAULT && clrTextBk == CLR_DEFAULT)
        {
            fUseShadowedText = FALSE;
            clrText = g_clrWindowText;
            clrTextBk = g_clrWindow;

            if ((flags & (SHDT_DRAWTEXT | SHDT_DESELECTED)) ==
               (SHDT_DRAWTEXT | SHDT_DESELECTED))
            {
                hbrUse = g_hbrWindow;
            }
        }
        else
        {
            if (clrText == CLR_DEFAULT)
                clrText =  g_clrWindowText;

            if (clrTextBk == CLR_DEFAULT)
                clrTextBk = g_clrWindow;

            if (fUseShadowedText == FALSE &&
                ((flags & (SHDT_DRAWTEXT | SHDT_DESELECTED)) ==
               (SHDT_DRAWTEXT | SHDT_DESELECTED) || hTheme))
            {
                hbrUse = CreateSolidBrush(GetNearestColor(hdc, clrTextBk));
                if (hbrUse)
                {
                    hbrDelete = hbrUse;
                }
                else
                    hbrUse = GetStockObject(WHITE_BRUSH);
            }
        }

        // now set it
        clrSave = SetTextColor(hdc, clrText);
        clrSaveBk = SetBkColor(hdc, clrTextBk);
        if (hbrUse)
        {
            FillRect(hdc, prc, hbrUse);
            if (hbrDelete)
                DeleteObject(hbrDelete);
        }
    }

    // If we want the item to display as if it was depressed, we will
    // offset the text rectangle down and to the left
    if (flags & SHDT_DEPRESSED)
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    if (flags & SHDT_DRAWTEXT || hTheme)
    {
        HRESULT hr = E_FAIL;
        UINT uDTFlags;
        if (flags & SHDT_DRAWTEXT)
        {
            uDTFlags= DT_LVWRAP | DT_END_ELLIPSIS;
        }
        else
        {
            uDTFlags = DT_END_ELLIPSIS | DT_SINGLELINE | DT_VCENTER;
            if (fmt & LVCFMT_CENTER)
                uDTFlags |= DT_CENTER;
            else if (fmt & LVCFMT_RIGHT)
                uDTFlags |= DT_RIGHT;
        }

        if (flags & SHDT_DTELLIPSIS)
            uDTFlags |= DT_WORD_ELLIPSIS;

        if (!(flags & SHDT_CLIPPED))
            uDTFlags |= DT_NOCLIP;

        if (flags & SHDT_NODBCSBREAK)
            uDTFlags |= DT_NOFULLWIDTHCHARBREAK;

        if (flags & SHDT_VCENTER)
            uDTFlags |= DT_VCENTER | DT_SINGLELINE;

        if (flags & SHDT_LEFT)
            uDTFlags = DT_LEFT | uDTFlags & ~DT_CENTER;

        if (fUseShadowedText)
        {
            DrawShadowText(hdc, pszText, cchText, &rc, uDTFlags, RGB(255,255,255), RGB(0,0,0), 2, 2);
        }
        else
        {
            if (hTheme)
                hr = DrawThemeText(hTheme, hdc, iPartId, iStateId, pszText, -1, uDTFlags, 0, &rc);

            if (FAILED(hr))
            DrawText(hdc, pszText, cchText, &rc, uDTFlags);
        }
    }
    else
    {
        if (fmt != LVCFMT_LEFT)
        {
            SIZE siz;

            GetTextExtentPoint(hdc, pszText, cchText, &siz);

            if (fmt == LVCFMT_CENTER)
                rc.left = (rc.left + rc.right - siz.cx) / 2;
            else    // fmt == LVCFMT_RIGHT
                rc.left = rc.right - siz.cx;
        }

        // Center vertically in case the bitmap (to the left) is larger than
        // the height of one line
        rc.top += (rc.bottom - rc.top - cyChar) / 2;

        if (flags & SHDT_CLIPPED)
           uETOFlags |= ETO_CLIPPED;

        // HACK:  ExtTextOut() has an off-by-one bug in its rendering of RTL
        //        text.  We need this hack to render properly (RAID 439915).
        //        Note that this bug is NOT present in the DrawText() API.
        if (flags & SHDT_RTLREADING)
            rc.left--;

        ExtTextOut(hdc, rc.left, rc.top, uETOFlags, prc, pszText, cchText, NULL);
    }

    if (flags & (SHDT_SELECTED | SHDT_DESELECTED | SHDT_TRANSPARENT))
    {
        SetTextColor(hdc, clrSave);
        if (!fForeOnly)
            SetBkColor(hdc, clrSaveBk);
    }

    if (flags & SHDT_RTLREADING)
        SetTextAlign(hdc, align);
}

void WINAPI SHDrawText(HDC hdc, LPCTSTR pszText, RECT* prc, int fmt,
                UINT flags, int cyChar, int cxEllipses, COLORREF clrText, COLORREF clrTextBk)
{
    SHThemeDrawText(NULL, hdc, 0, 0, pszText, prc, fmt,
                flags, cyChar, cxEllipses, clrText, clrTextBk);
}



/*----------------------------------------------------------------
** Create an imagelist to be used for dragging.
**
** 1) create mask and image bitmap matching the select bounds size
** 2) draw the text to both bitmaps (in black for now)
** 3) create an imagelist with these bitmaps
** 4) make a dithered copy of the image onto the new imagelist
**----------------------------------------------------------------*/
HIMAGELIST ListView_OnCreateDragImage(LV *plv, int iItem, LPPOINT lpptUpLeft)
{
    HWND hwndLV = plv->ci.hwnd;
    RECT rcBounds, rcImage, rcLabel;
    HDC hdcMem = NULL;
    HBITMAP hbmImage = NULL;
    HBITMAP hbmMask = NULL;
    HBITMAP hbmOld;
    HIMAGELIST himl = NULL;
    int dx, dy;
    HIMAGELIST himlSrc;
    LV_ITEM item;
    POINT ptOrg;
    LVDRAWITEM lvdi = {0};
    RECT rcSelBounds;
    BOOL bMirroredWnd = (plv->ci.dwExStyle&RTL_MIRRORED_WINDOW);
    int iImageList;

    if (!lpptUpLeft)
        return NULL;

    if (iItem >= ListView_Count(plv))
        return NULL;

    if (plv->iHot == iItem)
    {
        ListView_OnSetHotItem(plv, -1);
        UpdateWindow(plv->ci.hwnd);
    }

    ListView_GetRects(plv, iItem, QUERY_DEFAULT, &rcImage, &rcLabel, &rcBounds, &rcSelBounds);

    if (ListView_IsIconView(plv)) 
    {
        ListView_UnfoldRects(plv, iItem, &rcImage, &rcLabel,
                                         &rcBounds, &rcSelBounds);
        InflateRect(&rcImage, -g_cxIconMargin, -g_cyIconMargin);
    }

    // chop off any extra filler above icon
    ptOrg.x = rcBounds.left - rcSelBounds.left;
    ptOrg.y = rcBounds.top - rcImage.top;
    dx = rcSelBounds.right - rcSelBounds.left;
    dy = rcSelBounds.bottom - rcImage.top;

    lpptUpLeft->x = rcSelBounds.left;
    lpptUpLeft->y = rcImage.top;

    if (!(hdcMem = CreateCompatibleDC(NULL)))
        goto CDI_Exit;
    if (!(hbmImage = CreateColorBitmap(dx, dy)))
        goto CDI_Exit;
    if (!(hbmMask = CreateMonoBitmap(dx, dy)))
        goto CDI_Exit;

    //
    // Mirror the memory DC so that the transition from
    // mirrored(memDC)->non-mirrored(imagelist DCs)->mirrored(screenDC)
    // is consistent. [samera]
    //
    if (bMirroredWnd)
    {
        SET_DC_RTL_MIRRORED(hdcMem);
    }

    // prepare for drawing the item
    SelectObject(hdcMem, plv->hfontLabel);
    SetBkMode(hdcMem, TRANSPARENT);

    lvdi.plv = plv;
    lvdi.nmcd.nmcd.dwItemSpec = iItem;
    lvdi.pitem = NULL;  // make sure it is null as Owner data uses this to trigger things...
    lvdi.nmcd.nmcd.hdc = hdcMem;
    lvdi.lpptOrg = &ptOrg;
    lvdi.prcClip = NULL;
    lvdi.flags = LVDI_NOIMAGE | LVDI_TRANSTEXT | LVDI_NOWAYFOCUS | LVDI_UNFOLDED;
    lvdi.nmcd.clrFace = CLR_NONE;
    /*
    ** draw the text to both bitmaps
    */
    hbmOld = SelectObject(hdcMem, hbmImage);
    // fill image with black for transparency
    PatBlt(hdcMem, 0, 0, dx, dy, BLACKNESS);
    ListView_DrawItem(&lvdi);
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmImage);

    lvdi.flags = LVDI_NOIMAGE | LVDI_TRANSTEXT | LVDI_NOWAYFOCUS | LVDI_UNFOLDED;
    SelectObject(hdcMem, hbmMask);
    // fill mask with white for transparency
    PatBlt(hdcMem, 0, 0, dx, dy, WHITENESS);
    ListView_DrawItem(&lvdi);
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmMask);

    // unselect objects that we used
    SelectObject(hdcMem, hbmOld);
    SelectObject(hdcMem, g_hfontSystem);

    if (ListView_IsIconView(plv) || ListView_IsTileView(plv))
        iImageList = LVSIL_NORMAL;
    else
        iImageList = LVSIL_SMALL;


    himlSrc = ListView_OnGetImageList(plv, iImageList);

    /*
    ** make an image list that for now only has the text
    ** we use ImageList_Clone so we get a imagelist that
    ** the same color depth as our own imagelist
    */
    if (!(himl = ImageList_Clone(himlSrc, dx, dy, ILC_MASK, 1, 0)))
        goto CDI_Exit;

    ImageList_SetBkColor(himl, CLR_NONE);
    ImageList_Add(himl, hbmImage, hbmMask);

    /*
    ** make a dithered copy of the image part onto our bitmaps
    ** (need both bitmap and mask to be dithered)
    */
    if (himlSrc)
    {
        item.iItem = iItem;
        item.iSubItem = 0;
        item.mask = LVIF_IMAGE |LVIF_STATE;
        item.stateMask = LVIS_OVERLAYMASK;
        ListView_OnGetItem(plv, &item);

        ImageList_CopyDitherImage(himl, 0, rcImage.left - rcSelBounds.left, 0, himlSrc, item.iImage, ((plv->ci.dwExStyle & dwExStyleRTLMirrorWnd) ? ILD_MIRROR : 0L) | (item.state & LVIS_OVERLAYMASK));
    }

CDI_Exit:
    if (hdcMem)
        DeleteObject(hdcMem);
    if (hbmImage)
        DeleteObject(hbmImage);
    if (hbmMask)
        DeleteObject(hbmMask);

    return himl;
}

// ListView_OnGetTopIndex -- Gets the index of the first visible item
// For list view and report view this calculates the actual index
// for iconic views it alway returns 0
//
int ListView_OnGetTopIndex(LV* plv)
{
    if (ListView_IsReportView(plv) && !plv->fGroupView)
        return (int)((plv->ptlRptOrigin.y) / plv->cyItem);
    else if (ListView_IsListView(plv))
        return (plv->xOrigin / plv->cxItem) * plv->cItemCol;
    else
        return 0;
}


// ListView_OnGetCountPerPage -- Gets the count of items that will fit
// on a page For list view and report view this calculates the
// count depending on the size of the window and for Iconic views it
// will always return the count of items in the list view.
//
int ListView_OnGetCountPerPage(LV* plv)
{
    if (ListView_IsReportView(plv))
        return (plv->sizeClient.cy - plv->yTop) / plv->cyItem;

    else if (ListView_IsListView(plv))
        return ((plv->sizeClient.cx)/ plv->cxItem)
                * plv->cItemCol;
    else
        return (ListView_Count(plv));
}


/* Purpose:
/   Provides support for invalidating items within list views.
/
/ Notes:
/   Copes with invalidating the extra region in the list view that requires
/   us to erase the background.  Design to optimise out the ERASURE of the
/   background.
/
/   For details on the API see ListView_InvalidateItem.
/
/ In:
/   plv->ListView structure to work with
/   iItem = item number
/   bSrelectionOnly = refesh the selection
/   fRedraw = Flags for RedrawWindow
/ Out:
/   -
*/

void ListView_InvalidateFoldedItem(LV* plv, int iItem, BOOL fSelectionOnly, UINT fRedraw)
{
    ListView_InvalidateItem(plv, iItem, fSelectionOnly, fRedraw);

    if (ListView_IsIconView(plv) &&
        (!ListView_IsItemUnfolded(plv, iItem) || (fRedraw & RDW_ERASE)))
    {
        RECT rcLabel;

        if (ListView_GetUnfoldedRect(plv, iItem, &rcLabel))
        {
            RedrawWindow(plv->ci.hwnd, &rcLabel, NULL, fRedraw|RDW_ERASE);
        }
    }
}


/*
/ Purpose:
/   Having previously called get rects, then call this function to ensure
/   that they are correctly unfolded.
/
/ Notes:
/   -
/
/ In:
/   plv-> list view to unfold on
/   iItem = item number
/   prcIcon -> icon bounding box
/   prcLabel -> rectangle for the label structure
/   prcBounds -> bounds rectangle / == NULL for none    / These are currently the same for large icons
/   prcSelectBounds -> selection bounds / == NULL       /
/ Out: TRUE if unfolding the item was worth anything
/   -
*/
BOOL ListView_UnfoldRects(LV* plv, int iItem,
                               RECT * prcIcon, RECT * prcLabel,
                               RECT * prcBounds, RECT * prcSelectBounds)
{
    LISTITEM item;
    LISTITEM* pitem = &item;
    BOOL fRc = FALSE;

    if (!ListView_IsIconView(plv))
        return fRc;

    // If we have a label pointer then expand as required
    // nb - different paths for owner data

    if (prcLabel)
    {
        if (!ListView_IsOwnerData(plv))
        {
            pitem = ListView_GetItemPtr(plv, iItem);
            if (!EVAL(pitem))
            {
                // DavidShi was able to get us into here with an invalid
                // item number during a delete notification.  So if the
                // item number is invalid, just return a blank rectangle
                // instead of faulting.
                SetRectEmpty(prcLabel);
                goto doneLabel;
            }
        }
        else
        {
            _ListView_RecomputeLabelSize(plv, pitem, iItem, NULL, FALSE);
        }

        if (prcLabel->bottom != prcLabel->top + max(pitem->cyUnfoldedLabel, pitem->cyFoldedLabel))
            fRc = TRUE;

        // In HideLabel mode it's always "worthwhile" to "unfold" the rects because the label is not shown
        // by default.  By returning TRUE we cause the item's label to display in a tooltip where the label
        // would normally be.
        if (ListView_HideLabels(plv))
            fRc = TRUE;

        prcLabel->bottom = prcLabel->top + pitem->cyUnfoldedLabel;
    }
doneLabel:

    // Build the unions if required
    if (prcBounds && prcIcon && prcLabel)
    {
        ListView_CalcBounds(plv, QUERY_UNFOLDED, prcIcon, prcLabel, prcBounds);
    }
    if (prcSelectBounds && prcIcon && prcLabel)
    {
        if (ListView_HideLabels(plv))
            *prcBounds = *prcIcon;
        else
            UnionRect(prcSelectBounds, prcIcon, prcLabel);
    }

    return fRc;
}



void ListView_InvalidateMark(LV* plv)
{
    RECT rc;

    if (ListView_OnGetInsertMarkRect(plv, &rc))
    {
        OffsetRect(&rc, -plv->ptOrigin.x, -plv->ptOrigin.y);
        InvalidateRect(plv->ci.hwnd, &rc, TRUE);
    }
}


// Returns the insertmark rect in listview coordinates. Returns FALSE if there is no insertmarkrect
BOOL ListView_OnGetInsertMarkRect(LV* plv, LPRECT prc)
{
    BOOL fVert;
    RECT rcSlot;
    LISTITEM *pitem;

    if (plv->iInsertItem == -1)
        return FALSE;

    pitem = ListView_GetItemPtr(plv, plv->iInsertItem);
    if (!pitem)
    {
        return FALSE;
    }

    fVert = !((plv->ci.style & LVS_ALIGNMASK) == LVS_ALIGNTOP);

    ListView_CalcItemSlotAndRect(plv, pitem, NULL, &rcSlot);

    if (fVert)
    {
        int iY;
        prc->left = rcSlot.left;
        prc->right = rcSlot.right;
        iY = (plv->fInsertAfter) ? rcSlot.bottom : rcSlot.top;
        prc->top = iY - INSERTMARKSIZE/2;
        prc->bottom = iY + INSERTMARKSIZE/2 + 1;
    }
    else
    {
        int iX;
        prc->top = rcSlot.top;
        prc->bottom = rcSlot.bottom;
        iX = (plv->fInsertAfter) ? rcSlot.right : rcSlot.left;
        prc->left = iX - INSERTMARKSIZE/2;
        prc->right = iX + INSERTMARKSIZE/2 + 1;
    }
    return TRUE;

}

COLORREF ListView_OnGetInsertMarkColor(LV* plv)
{
    if (plv->clrim == CLR_DEFAULT)
        return plv->clrText;
    else
        return plv->clrim;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\lvlist.c ===
// list view (small icons, multiple columns)

#include "ctlspriv.h"
#include "listview.h"

BOOL ListView_LDrawItem(PLVDRAWITEM plvdi)
{
    RECT rcIcon;
    RECT rcLabel;
    RECT rcBounds;
    RECT rcT;
    LV_ITEM item;
    TCHAR ach[CCHLABELMAX];
    LV* plv = plvdi->plv;
    int i = (int) plvdi->nmcd.nmcd.dwItemSpec;
    COLORREF clrTextBk = plvdi->nmcd.clrTextBk;

    if (plv->pImgCtx || ListView_IsWatermarked(plv))
    {
        clrTextBk = CLR_NONE;
    }

    // moved here to reduce call backs in OWNERDATA case
    //
    item.iItem = i;
    item.iSubItem = 0;
    item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
    item.stateMask = LVIS_ALL;
    item.pszText = ach;
    item.cchTextMax = ARRAYSIZE(ach);

    ListView_OnGetItem(plv, &item);

    ListView_LGetRects(plv, i, &rcIcon, &rcLabel, &rcBounds, NULL);

    if (!plvdi->prcClip || IntersectRect(&rcT, &rcBounds, plvdi->prcClip))
    {
        UINT fText;

        if (plvdi->lpptOrg)
        {
            OffsetRect(&rcIcon, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
            OffsetRect(&rcLabel, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
        }


        fText = ListView_DrawImage(plv, &item, plvdi->nmcd.nmcd.hdc,
            rcIcon.left, rcIcon.top, plvdi->flags) | SHDT_ELLIPSES;

        // Don't draw the label if it is being edited.
        if (plv->iEdit != i)
        {
            int ItemCxSingleLabel;
            UINT ItemState;

            if (ListView_IsOwnerData( plv ))
            {
               LISTITEM listitem;

               // calculate lable sizes from iItem
                   listitem.pszText = ach;
               ListView_IRecomputeLabelSize( plv, &listitem, i, plvdi->nmcd.nmcd.hdc, TRUE );

               ItemCxSingleLabel = listitem.cxSingleLabel;
               ItemState = item.state;
            }
            else
            {
               ItemCxSingleLabel = plvdi->pitem->cxSingleLabel;
               ItemState = plvdi->pitem->state;
            }

            if (plvdi->flags & LVDI_TRANSTEXT)
                fText |= SHDT_TRANSPARENT;

            if (ItemCxSingleLabel == SRECOMPUTE) 
            {
                ListView_IRecomputeLabelSize(plv, plvdi->pitem, i, plvdi->nmcd.nmcd.hdc, FALSE);
                ItemCxSingleLabel = plvdi->pitem->cxSingleLabel;
            }

            if (ItemCxSingleLabel < rcLabel.right - rcLabel.left)
                rcLabel.right = rcLabel.left + ItemCxSingleLabel;

            if ((fText & SHDT_SELECTED) && (plvdi->flags & LVDI_HOTSELECTED))
                fText |= SHDT_HOTSELECTED;

#ifdef WINDOWS_ME
            if( plv->dwExStyle & WS_EX_RTLREADING)
                fText |= SHDT_RTLREADING;
#endif

            SHDrawText(plvdi->nmcd.nmcd.hdc, item.pszText, &rcLabel, LVCFMT_LEFT, fText,
                       plv->cyLabelChar, plv->cxEllipses,
                       plvdi->nmcd.clrText, clrTextBk);

            if ((plvdi->flags & LVDI_FOCUS) && (ItemState & LVIS_FOCUSED) && 
                !(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS))
            {
                DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcLabel);
            }
        }
    }
    return TRUE;
}

DWORD ListView_LApproximateViewRect(LV* plv, int iCount, int iWidth, int iHeight)
{
    int cxItem = plv->cxItem;
    int cyItem = plv->cyItem;
    int cCols;
    int cRows;

    cRows = iHeight / cyItem;
    cRows = min(cRows, iCount);

    if (cRows == 0)
        cRows = 1;
    cCols = (iCount + cRows - 1) / cRows;

    iWidth = cCols * cxItem;
    iHeight = cRows * cyItem;

    return MAKELONG(iWidth + g_cxEdge, iHeight + g_cyEdge);
}



int ListView_LItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem)
{
    int iHit;
    int i;
    int iCol;
    int xItem; //where is the x in relation to the item
    UINT flags;
    LISTITEM* pitem;

    if (piSubItem)
        *piSubItem = 0;

    flags = LVHT_NOWHERE;
    iHit = -1;

    i = y / plv->cyItem;
    if (i >= 0 && i < plv->cItemCol)
    {
        iCol = (x + plv->xOrigin) / plv->cxItem;
        i += iCol * plv->cItemCol;
        if (i >= 0 && i < ListView_Count(plv))
        {
            iHit = i;

            xItem = x + plv->xOrigin - iCol * plv->cxItem;
            if (xItem < plv->cxState) {
                flags = LVHT_ONITEMSTATEICON;
            } else if (xItem < (plv->cxState + plv->cxSmIcon)) {
                    flags = LVHT_ONITEMICON;
            }
            else
            {
            int ItemCxSingleLabel;

            if (ListView_IsOwnerData( plv ))
            {
               LISTITEM item;

               // calculate lable sizes from iItem
               ListView_IRecomputeLabelSize( plv, &item, i, NULL, FALSE );
               ItemCxSingleLabel = item.cxSingleLabel;
            }
            else
            {
                pitem = ListView_FastGetItemPtr(plv, i);
                if (pitem->cxSingleLabel == SRECOMPUTE)
                {
                    ListView_IRecomputeLabelSize(plv, pitem, i, NULL, FALSE);
                }
                ItemCxSingleLabel = pitem->cxSingleLabel;
            }

            if (xItem < (plv->cxSmIcon + plv->cxState + ItemCxSingleLabel))
                flags = LVHT_ONITEMLABEL;
            }
        }
    }

    *pflags = flags;
    return iHit;
}

void ListView_LGetRects(LV* plv, int i, RECT* prcIcon,
        RECT* prcLabel, RECT *prcBounds, RECT* prcSelectBounds)
{
    RECT rcIcon;
    RECT rcLabel;
    int x, y;
    int cItemCol = plv->cItemCol;

    if (cItemCol == 0)
    {
        // Called before other data has been initialized so call
        // update scrollbars which should make sure that that
        // we have valid data...
        ListView_UpdateScrollBars(plv);

        // but it's possible that updatescrollbars did nothing because of
        // LVS_NOSCROLL or redraw
        // REARCHITECT raymondc v6.0:  Get it right even if no redraw. Fix for v6.
        if (plv->cItemCol == 0)
            cItemCol = 1;
        else
            cItemCol = plv->cItemCol;
    }

    x = (i / cItemCol) * plv->cxItem;
    y = (i % cItemCol) * plv->cyItem;
    rcIcon.left   = x - plv->xOrigin + (plv->cxState + LV_ICONTOSTATEOFFSET(plv));
    rcIcon.top    = y;

    rcIcon.right  = rcIcon.left + plv->cxSmIcon;
    rcIcon.bottom = rcIcon.top + plv->cyItem;

    if (prcIcon)
        *prcIcon = rcIcon;

    rcLabel.left  = rcIcon.right;
    rcLabel.right = rcIcon.left + plv->cxItem - (plv->cxState + LV_ICONTOSTATEOFFSET(plv));
    rcLabel.top   = rcIcon.top;
    rcLabel.bottom = rcIcon.bottom;
    if (prcLabel)
        *prcLabel = rcLabel;

    if (prcBounds)
    {
        *prcBounds = rcLabel;
        prcBounds->left = rcIcon.left - (plv->cxState + LV_ICONTOSTATEOFFSET(plv));
    }

    if (prcSelectBounds)
    {
        *prcSelectBounds = rcLabel;
        prcSelectBounds->left = rcIcon.left;
    }
}


void ListView_LUpdateScrollBars(LV* plv)
{
    RECT rcClient;
    int cItemCol;
    int cCol;
    int cColVis;
    int nPosHold;
    SCROLLINFO si;

    ASSERT(plv);

    ListView_GetClientRect(plv, &rcClient, FALSE, NULL);

    cColVis = (rcClient.right - rcClient.left) / plv->cxItem;
    cItemCol = max(1, (rcClient.bottom - rcClient.top) / plv->cyItem);
    cCol     = (ListView_Count(plv) + cItemCol - 1) / cItemCol;

    // Make the client area smaller as appropriate, and
    // recompute cCol to reflect scroll bar.
    //
    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
    si.nPage = cColVis;
    si.nMin = 0;

    rcClient.bottom -= ListView_GetCyScrollbar(plv);

    cItemCol = max(1, (rcClient.bottom - rcClient.top) / plv->cyItem);
    cCol = (ListView_Count(plv) + cItemCol - 1) / cItemCol;

    si.nPos = nPosHold = plv->xOrigin / plv->cxItem;
    si.nMax = cCol - 1;

    ListView_SetScrollInfo(plv, SB_HORZ, &si, TRUE);

    // SetScrollInfo changes si.nPos to 0 if si.nMax == 0 and si.nPos > 0.
    // That can prevent the list view items from scrolling into position if the
    // view goes from 1 column to zero.
    si.nPos = nPosHold;

    // Update number of visible lines...
    //
    if (plv->cItemCol != cItemCol)
    {
        plv->cItemCol = cItemCol;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    // make sure our position and page doesn't hang over max
    if ((si.nPos + (LONG)si.nPage - 1 > si.nMax) && si.nPos > 0) {
        int iNewPos, iDelta;
        iNewPos = (int)si.nMax - (int)si.nPage + 1;
        if (iNewPos < 0) iNewPos = 0;
        if (iNewPos != si.nPos) {
            iDelta = iNewPos - (int)si.nPos;
            ListView_LScroll2(plv, iDelta, 0, 0);
            ListView_LUpdateScrollBars(plv);
        }
    }

    // never have the other scrollbar
    ListView_SetScrollRange(plv, SB_VERT, 0, 0, TRUE);
}

//
//  We need a smoothscroll callback so our background image draws
//  at the correct origin.  If we don't have a background image,
//  then this work is superfluous but not harmful either.
//
int CALLBACK ListView_LScroll2_SmoothScroll(
    HWND hwnd,
    int dx,
    int dy,
    CONST RECT *prcScroll,
    CONST RECT *prcClip,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags)
{
    LV* plv = ListView_GetPtr(hwnd);
    if (plv)
    {
        plv->xOrigin -= dx;
    }

    // Now do what SmoothScrollWindow would've done if we weren't
    // a callback

    if (ListView_IsWatermarkedBackground(plv) || 
        ListView_IsWatermarked(plv))
    {
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        return TRUE;
    }
    else
        return ScrollWindowEx(hwnd, dx, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
}



void ListView_LScroll2(LV* plv, int dx, int dy, UINT uSmooth)
{
    if (dx)
    {
        SMOOTHSCROLLINFO si;

        dx *= plv->cxItem;

        si.cbSize = sizeof(si);
        si.fMask = SSIF_SCROLLPROC;
        si.hwnd =plv->ci.hwnd ;
        si.dx =-dx ;
        si.dy = 0;
        si.lprcSrc = NULL;
        si.lprcClip = NULL;
        si.hrgnUpdate = NULL;
        si.lprcUpdate = NULL;
        si.fuScroll = SW_INVALIDATE | SW_ERASE | SSW_EX_UPDATEATEACHSTEP;
        si.pfnScrollProc = ListView_LScroll2_SmoothScroll;
        SmoothScrollWindow(&si);
        UpdateWindow(plv->ci.hwnd);
    }
}

void ListView_LOnScroll(LV* plv, UINT code, int posNew, UINT sb)
{
    RECT rcClient;
    int cPage;

    if (plv->hwndEdit)
        ListView_DismissEdit(plv, FALSE);

    ListView_GetClientRect(plv, &rcClient, TRUE, NULL);

    cPage = (rcClient.right - rcClient.left) / plv->cxItem;
    ListView_ComOnScroll(plv, code, posNew, SB_HORZ, 1,
                         cPage ? cPage : 1);

}

int ListView_LGetScrollUnitsPerLine(LV* plv, UINT sb)
{
    return 1;
}

//------------------------------------------------------------------------------
//
// Function: ListView_LCalcViewItem
//
// Summary: This function will calculate which item slot is at the x, y location
//
// Arguments:
//    plv [in] -  The list View to work with
//    x [in] - The x location
//    y [in] - The y location
//
// Returns: the valid slot the point was within.
//
//  Notes:
//
//  History:
//    Nov-3-94 MikeMi   Created
//
//------------------------------------------------------------------------------

int ListView_LCalcViewItem( LV* plv, int x, int y )
{
   int iItem;
   int iRow = 0;
   int iCol = 0;

   ASSERT( plv );

   iRow = y / plv->cyItem;
   iRow = max( iRow, 0 );
   iRow = min( iRow, plv->cItemCol - 1 );
   iCol = (x + plv->xOrigin) / plv->cxItem;
   iItem = iRow + iCol * plv->cItemCol;

   iItem = max( iItem, 0 );
   iItem = min( iItem, ListView_Count(plv) - 1);

   return( iItem );
}

int LV_GetNewColWidth(LV* plv, int iFirst, int iLast)
{
    int cxMaxLabel = 0;

    // Don't do anything if there are no items to measure

    if ((iFirst <= iLast) && (iLast < ListView_Count(plv)))
    {
        LVFAKEDRAW lvfd;
        LV_ITEM lvitem;
        LISTITEM item;

        if (ListView_IsOwnerData( plv ))
        {
            int iViewFirst;
            int iViewLast;


            iViewFirst = ListView_LCalcViewItem( plv, 1, 1 );
            iViewLast = ListView_LCalcViewItem( plv,
                                               plv->sizeClient.cx - 1,
                                               plv->sizeClient.cy - 1 );
            if ((iLast - iFirst) > (iViewLast - iViewFirst))
            {
                iFirst = max( iFirst, iViewFirst );
                iLast = min( iLast, iViewLast );
            }

            iLast = min( ListView_Count( plv ), iLast );
            iFirst = max( 0, iFirst );
            iLast = max( iLast, iFirst );

            ListView_NotifyCacheHint( plv, iFirst, iLast );
        }

        ListView_BeginFakeCustomDraw(plv, &lvfd, &lvitem);
        lvitem.iSubItem = 0;
        lvitem.mask = LVIF_PARAM;
        item.lParam = 0;

        while (iFirst <= iLast)
        {
            LISTITEM* pitem;

            if (ListView_IsOwnerData( plv ))
            {
                pitem = &item;
                pitem->cxSingleLabel = SRECOMPUTE;
            }
            else
            {
                pitem = ListView_FastGetItemPtr(plv, iFirst);
            }

            if (pitem->cxSingleLabel == SRECOMPUTE)
            {
                lvitem.iItem = iFirst;
                lvitem.lParam = pitem->lParam;
                ListView_BeginFakeItemDraw(&lvfd);
                ListView_IRecomputeLabelSize(plv, pitem, iFirst, lvfd.nmcd.nmcd.hdc, FALSE);
                ListView_EndFakeItemDraw(&lvfd);
            }

            if (pitem->cxSingleLabel > cxMaxLabel)
                cxMaxLabel = pitem->cxSingleLabel;

            iFirst++;
        }

        ListView_EndFakeCustomDraw(&lvfd);
    }

    // We have the max label width, see if this plus the rest of the slop will
    // cause us to want to resize.
    //
    cxMaxLabel += plv->cxSmIcon + g_cxIconMargin + plv->cxState + LV_ICONTOSTATEOFFSET(plv);
    if (cxMaxLabel > g_cxScreen)
        cxMaxLabel = g_cxScreen;

    return cxMaxLabel;
}


//------------------------------------------------------------------------------
// This function will see if the size of column should be changed for the listview
// It will check to see if the items between first and last exceed the current width
// and if so will see if the columns are currently big enough.  This wont happen
// if we are not currently in listview or if the caller has set an explicit size.
//
// OWNERDATA CHANGE
// This function is normally called with the complete list range,
// This will has been changed to be called only with currently visible
// to the user when in OWNERDATA mode.  This will be much more effiencent.
//
BOOL ListView_MaybeResizeListColumns(LV* plv, int iFirst, int iLast)
{
    HDC hdc = NULL;
    int cxMaxLabel;

    if (!ListView_IsListView(plv) || (plv->flags & LVF_COLSIZESET))
        return(FALSE);

    cxMaxLabel = LV_GetNewColWidth(plv, iFirst, iLast);

    // Now see if we should resize the columns...
    if (cxMaxLabel > plv->cxItem)
    {
        int iScroll = plv->xOrigin / plv->cxItem;
        TraceMsg(TF_LISTVIEW, "LV Resize Columns: %d", cxMaxLabel);
        ListView_ISetColumnWidth(plv, 0, cxMaxLabel, FALSE);
        plv->xOrigin = iScroll * plv->cxItem;
        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\listview.h ===
// LISTVIEW PRIVATE DECLARATIONS

#ifndef _INC_LISTVIEW
#define _INC_LISTVIEW

#include "selrange.h"
#include <urlmon.h>
#define COBJMACROS
#include <iimgctx.h>

//#define USE_SORT_FLARE

//
//  Apps steal our userdata space so make sure we don't use it.
//
#undef GWLP_USERDATA
#undef GWL_USERDATA

// define this to get single click activate to activate immediately.
// if a second click comes to the same window within a double-click-timeout
// period, we blow it off. we try to keep focus on the app that launched,
// but we can't figure out how to do that yet... with this not defined,
// the single-click-activate waits a double-click-timeout before activating.
//
//#define ONECLICKHAPPENED

// REVIEW: max items in a OWNERDATA listview
// due to currently unknown reasons the listview will not handle much more
// items than this.  Since this number is very high, no time has yet been
// spent on finding the reason(s).
//
#define MAX_LISTVIEWITEMS (100000000)

#define CLIP_HEIGHT                ((plv->cyLabelChar * 2) + g_cyEdge)
#define CLIP_HEIGHT_DI             ((plvdi->plv->cyLabelChar * 2) + g_cyEdge)

#define CLIP_WIDTH                 ((plv->cxIconSpacing - g_cxLabelMargin * 2))

// Timer IDs
#define IDT_NAMEEDIT    42
#define IDT_SCROLLWAIT  43
#define IDT_MARQUEE     44
#define IDT_ONECLICKOK  45
#define IDT_ONECLICKHAPPENED 46
#define IDT_SORTFLARE   47
#define IDT_TRACKINGTIP 48      // Keyboard tracking tooltip display pause

//
//  use g_cxIconSpacing   when you want the the global system metric
//  use _GetCurrentItemSize  when you want the padded size of "icon" in a ListView
//
extern BOOL g_fListviewAlphaSelect;
extern BOOL g_fListviewShadowText;
extern BOOL g_fListviewWatermarkBackgroundImages;
extern BOOL g_fListviewEnableWatermark;

extern int g_cxIcon;
extern int g_cyIcon;

#define  g_cxIconOffset ((g_cxIconSpacing - g_cxIcon) / 2)
#define  g_cyIconOffset (g_cyBorder * 2)    // NOTE: Must be >= cyIconMargin!

#define DT_LV       (DT_CENTER | DT_SINGLELINE | DT_NOPREFIX | DT_EDITCONTROL)
#define DT_LVWRAP   (DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)
#define DT_LVTILEWRAP           (DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)
#define CCHLABELMAX MAX_PATH 
#define CCMAX_TILE_COLUMNS 20 // Max number of slots per tile. Having a value means the drawing code doesn't need to Alloc
#define BORDERSELECT_THICKNESS 3


#define IsEqualRect(rc1, rc2) ( ((rc1).left==(rc2).left) && ((rc1).top==(rc2).top) && ((rc1).right==(rc2).right) && ((rc1).bottom==(rc2).bottom) )

BOOL ListView_Init(HINSTANCE hinst);


LRESULT CALLBACK _export ListView_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#define ListView_DefProc  DefWindowProc

typedef struct _IMAGE IMAGE;

typedef struct tagLISTGROUP
{
    LPWSTR  pszHeader;
    LPWSTR  pszFooter;

    UINT    state;
    UINT    uAlign;
    int     iGroupId;    

    HDPA hdpa;
    RECT rc;

    int    cyTitle;
} LISTGROUP, *PLISTGROUP;

#define LISTGROUP_HEIGHT(plv, pgrp) (max((plv)->rcBorder.top, (pgrp)->cyTitle + 6) + (plv)->paddingTop)


#define LISTITEM_HASASKEDFORGROUP(plvi) ((plvi)->pGroup != (LISTGROUP*)I_GROUPIDCALLBACK)
#define LISTITEM_HASGROUP(plvi) ((plvi)->pGroup != NULL && LISTITEM_HASASKEDFORGROUP(plvi))
#define LISTITEM_SETASKEDFORGROUP(plvi) ((plvi)->pGroup = NULL)
#define LISTITEM_SETHASNOTASKEDFORGROUP(plvi) ((plvi)->pGroup = (LISTGROUP*)I_GROUPIDCALLBACK)
#define LISTITEM_GROUP(plvi) (LISTITEM_HASGROUP(plvi)? (plvi)->pGroup: NULL)


typedef struct _LISTITEM    // li
{
    LPTSTR pszText;
    POINT pt;
    short iImage;
    short cxSingleLabel;
    short cxMultiLabel;
    short cyFoldedLabel;
    short cyUnfoldedLabel;
    short iWorkArea;        // Which workarea do I belong

    WORD state;     // LVIS_*
    short iIndent;
    LPARAM lParam;

    // Region listview stuff
    HRGN hrgnIcon;      // Region which describes the icon for this item
    POINT ptRgn;        // Location that this item's hrgnIcon was calculated for
    RECT rcTextRgn;

    LISTGROUP* pGroup;
    
    // Tile column info
    UINT cColumns;
    PUINT puColumns;

    DWORD   dwId;
    
} LISTITEM;

// Report view sub-item structure

typedef struct _LISTSUBITEM
{
    LPTSTR pszText;
    short iImage;
    WORD state;
    SIZE sizeText;
} LISTSUBITEM, *PLISTSUBITEM;

#define COLUMN_VIEW

#define LV_HDPA_GROW   16  // Grow chunk size for DPAs
#define LV_HIML_GROW   8   // Grow chunk size for ImageLists

typedef struct _LV
{
    CCONTROLINFO ci;     // common control header info

    BITBOOL fNoDismissEdit:1;  // don't dismiss in-place edit control
    BITBOOL fButtonDown:1;     // we're tracking the mouse with a button down
    BITBOOL fOneClickOK:1;     // true from creation to double-click-timeout
    BITBOOL fOneClickHappened:1; // true from item-activate to double-click-timeout
    BITBOOL fPlaceTooltip:1;   // should we do the placement of tooltip over the text?
    BITBOOL fImgCtxComplete:1; // TRUE if we have complete bk image
    BITBOOL fNoEmptyText:1;    // we don't have text for an empty view.
    BITBOOL fGroupView:1;
    BITBOOL fIconsPositioned:1;
    BITBOOL fInsertAfter:1;    // insert after (or before) iInsertSlot slot.
    BITBOOL fListviewAlphaSelect:1;
    BITBOOL fListviewShadowText:1;
    BITBOOL fListviewWatermarkBackgroundImages:1;
    BITBOOL fListviewEnableWatermark:1;
    BITBOOL fInFixIScrollPositions:1;

    WORD wView;           // Which view are we in?

    HDPA hdpa;          // item array structure
    DWORD flags;        // LVF_ state bits
    DWORD exStyle;      // the listview LVM_SETEXTENDEDSTYLE
    DWORD dwExStyle;    // the windows ex style
    HFONT hfontLabel;   // font to use for labels
    COLORREF clrBk;     // Background color
    COLORREF clrBkSave; // Background color saved during disable
    COLORREF clrText;   // text color
    COLORREF clrTextBk; // text background color
    COLORREF clrOutline; // focus rect outline color
    HBRUSH hbrBk;
    HANDLE hheap;        // The heap to use to allocate memory from.
    int cyLabelChar;    // height of '0' in hfont
    int cxLabelChar;    // width of '0'
    int cxEllipses;     // width of "..."
    int iDrag;          // index of item being dragged
    int iFocus;         // index of currently-focused item
    int iMark;          // index of "mark" for range selection
    int iItemDrawing;   // item currently being drawn
    int iFirstChangedNoRedraw;  // Index of first item added during no redraw.
    UINT stateCallbackMask; // item state callback mask
    SIZE sizeClient;      // current client rectangle
    int nWorkAreas;                            // Number of workareas
    LPRECT prcWorkAreas;      // The workarea rectangles -- nWorkAreas of them.
    UINT nSelected;
    int iPuntChar;
    HRGN hrgnInval;
    HWND hwndToolTips;      // handle of the tooltip window for this view
    int iTTLastHit;         // last item hit for text
    int iTTLastSubHit;      // last subitem hit for text
    LPTSTR pszTip;          // buffer for tip

#ifdef USE_SORT_FLARE
    int iSortFlare;
#endif

    // Small icon view fields

    HIMAGELIST himlSmall;   // small icons
    int cxSmIcon;          // image list x-icon size
    int cySmIcon;          // image list y-icon size
    int xOrigin;        // Horizontal scroll posiiton
    int cxItem;         // Width of small icon items
    int cyItem;         // item height
    int cItemCol;       // Number of items per column

    int cxIconSpacing;
    int cyIconSpacing;

    // Icon view fields

    HIMAGELIST himl;
    int cxIcon;             // image list x-icon size
    int cyIcon;             // image list y-icon size
    HDPA hdpaZOrder;        // Large icon Z-order array

    // Some definitions, to help make sense of the next two variables:
    //
    // Lets call the pitem->pt coordinate values "listview coordinates".
    //
    // Lets use rcClient as short-hand for the client area of the listview window.
    //
    // (1) ptOrigin is defined as the listview coordinate that falls on rcClient's 0,0 position.
    //
    // i.e., here's how to calculate the x,y location on rcClient for some item:
    //   * pitem->pt.x - ptOrigin.x , pitem->pt.y - ptOrigin.y
    // Let's call that these values "window coordinates".
    //
    // (2) rcView is defined as the bounding rect of: each item's unfolded rcview bounding rect and a bit of buffer
    // note: ListView_ValidatercView() checks this
    //
    // (3) For scrolling listviews (!LVS_NOSCROLL), there are two scrolling cases to consider:
    //   First, where rcClient is smaller than rcView:
    //      * rcView.left <= ptOrigin.x <= ptOrigin.x+RECTWIDTH(rcClient) <= rcView.right
    //   Second, where rcClient is larger than rcView (no scrollbars visible):
    //      * ptOrigin.x <= rcView.left <= rcView.right <= ptOrigin.x+RECTWIDTH(rcClient)
    // note: ListView_ValidateScrollPositions() checks this
    //
    // (4) For non scrolling listviews (LVS_NOSCROLL), we have some legacy behavior to consider:
    //   For clients that persist icon positions but not the ptOrigin value, we must ensure:
    //      * 0 == ptOrigin.x
    // note: ListView_ValidateScrollPositions() checks this
    //
    POINT ptOrigin;         // Scroll position
    RECT rcView;            // Bounds of all icons (ptOrigin relative)
    int iFreeSlot;          // Most-recently found free icon slot since last reposition (-1 if none)
    int cSlots;

    HWND hwndEdit;          // edit field for edit-label-in-place
    int iEdit;              // item being edited
    WNDPROC pfnEditWndProc; // edit field subclass proc

    NMITEMACTIVATE nmOneClickHappened;

#define SMOOTHSCROLLLIMIT 10

    int iScrollCount; // how many times have we gotten scroll messages before an endscroll?

    // Report view fields

    int iLastColSort;
    int cCol;
    HDPA hdpaSubItems;
    HWND hwndHdr;           // Header control
    int yTop;               // First usable pixel (below header)
    int xTotalColumnWidth;  // Total width of all columns
    POINTL ptlRptOrigin;    // Origin of Report.
    int iSelCol;            // to handle column width changing. changing col
    int iSelOldWidth;       // to handle column width changing. changing col width
    int cyItemSave;        // in ownerdrawfixed mode, we put the height into cyItem.  use this to save the old value

    // Tile View fields
    SIZE sizeTile;          // the size of a tile
    int  cSubItems;         // Count of the number of sub items to display in a tile
    DWORD dwTileFlags;      // LVTVIF_FIXEDHEIGHT | LVTVIF_FIXEDWIDTH
    RECT rcTileLabelMargin; // addition space to reserve around label

    // Group View fields
    HDPA hdpaGroups;        // Groups
    RECT rcBorder;          // Border thickness
    COLORREF crHeader;
    COLORREF crFooter;
    COLORREF crTop;
    COLORREF crBottom;
    COLORREF crLeft;
    COLORREF crRight;
    HFONT hfontGroup;
    UINT paddingLeft;
    UINT paddingTop;
    UINT paddingRight;
    UINT paddingBottom;
    TCHAR szItems[50];

    // state image stuff
    HIMAGELIST himlState;
    int cxState;
    int cyState;

    // OWNERDATA stuff
    ILVRange *plvrangeSel;  // selection ranges
    ILVRange *plvrangeCut;  // Cut Range    
    int cTotalItems;        // number of items in the ownerdata lists
    int iDropHilite;        // which item is drop hilited, assume only 1
    int iMSAAMin, iMSAAMax; // keep track of what we told accessibility

    UINT uUnplaced;     // items that have been added but not placed (pt.x == RECOMPUTE)

    int iHot;  // which item is hot
    HFONT hFontHot; // the underlined font .. assume this has the same size metrics as hFont
    int iNoHover; // don't allow hover select on this guy because it's the one we just hover selected (avoids toggling)
    DWORD dwHoverTime;      // Defaults to HOVER_DEFAULT
    HCURSOR hCurHot; // the cursor when we're over a hot item

    // BkImage stuff
    IImgCtx *pImgCtx;       // Background image interface
    ULONG ulBkImageFlags;   // LVBKIF_*
    HBITMAP hbmBkImage;     // Background bitmap (LVBKIF_SOURCE_HBITMAP)
    LPTSTR pszBkImage;      // Background URL (LVBKIF_SOURCE_URL)
    int xOffsetPercent;     // X offset for LVBKIF_STYLE_NORMAL images
    int yOffsetPercent;     // Y offset for LVBKIF_STYLE_NORMAL images
    HPALETTE hpalHalftone;  // Palette for drawing bk images 

    LPTSTR pszEmptyText;    // buffer for empty view text.

    COLORREF clrHotlight;     // Hot light color set explicitly for this listview.
    POINT ptCapture;

    //incremental search stuff
    ISEARCHINFO is;

    // Themes
    HTHEME hTheme;

    // Insertmark
    int iInsertItem;        // The item to insert next to
    int clrim;              // The color of the insert mark.

    int iTracking;          // Used for tooltips via keyboard (current item in focus for info display, >= 0 is tracking active)
    LPARAM lLastMMove;      // Filter out mouse move messages that didn't result in an actual move (for track tooltip canceling)

    // Frozen Slot
    int iFrozenSlot;        // The slot that should not be used by anyone other than the frozen item
    LISTITEM *pFrozenItem;  // Pointer to the frozen item.

    RECT rcViewMargin; // the EnsureVisible margine around an item -- the rcView margin

    RECT rcMarquee;

    // Watermarks
    HBITMAP hbmpWatermark;
    SIZE    szWatermark;

    // Id Tracking
    DWORD   idNext;         // Stores the next ID.
    DWORD   iLastId;         // Stores the index to the previous item for searches
    DWORD   iIncrement;

} LV;

#define LV_StateImageValue(pitem) ((int)(((DWORD)((pitem)->state) >> 12) & 0xF))
#define LV_StateImageIndex(pitem) (LV_StateImageValue(pitem) - 1)

// listview flag values
#define LVF_FOCUSED             0x00000001
#define LVF_VISIBLE             0x00000002
#define LVF_ERASE               0x00000004 // is hrgnInval to be erased?
#define LVF_NMEDITPEND          0x00000008
#define LVF_REDRAW              0x00000010 // Value from WM_SETREDRAW message
#define LVF_ICONPOSSML          0x00000020 // X, Y coords are in small icon view
#define LVF_INRECOMPUTE         0x00000040 // Check to make sure we are not recursing
#define LVF_UNFOLDED            0x00000080
#define LVF_FONTCREATED         0x00000100 // we created the LV font
#define LVF_SCROLLWAIT          0x00000200 // we're waiting to scroll
#define LVF_COLSIZESET          0x00000400 // Has the caller explictly set width for list view
#define LVF_USERBKCLR           0x00000800 // user set the bk color (don't follow syscolorchange)
#define LVF_ICONSPACESET        0x00001000 // the user has set the icon spacing
#define LVF_CUSTOMFONT          0x00002000 // there is at least one item with a custom font
#define LVF_DONTDRAWCOMP        0x00004000 // do not draw IME composition if true
#define LVF_INSERTINGCOMP       0x00008000 // Avoid recursion
#define LVF_INRECALCREGION      0x00010000 // prevents recursion in RecalcRegion
#define LVF_DRAGIMAGE           0x00020000 // Generating a drag image
#define LVF_MARQUEE             0x00040000

#define ENTIRE_REGION   1

// listview DrawItem flags
#define LVDI_NOIMAGE            0x0001  // don't draw image
#define LVDI_TRANSTEXT          0x0002  // draw text transparently in black
#define LVDI_NOWAYFOCUS         0x0004  // don't allow focus to drawing
#define LVDI_FOCUS              0x0008  // focus is set (for drawing)
#define LVDI_SELECTED           0x0010  // draw selected text
#define LVDI_SELECTNOFOCUS      0x0020
#define LVDI_HOTSELECTED        0x0040
#define LVDI_UNFOLDED           0x0080  // draw the item unfolded (forced)
#define LVDI_NOICONSELECT       0x0100
#define LVDI_GLOW               0x0200
#define LVDI_SHADOW             0x0400
#define LVDI_NOEFFECTS          0x0800

// listview private insertmark flags (Note: these must not conflict with the public ones in commctrl.w)
#define LVIM_SETFROMINFO        0x80000000

typedef struct {
    LV* plv;
    LPPOINT lpptOrg;
    LPRECT prcClip;
    UINT flags;

    LISTITEM* pitem;

    DWORD dwCustom;
    NMLVCUSTOMDRAW nmcd;
} LVDRAWITEM, *PLVDRAWITEM;

// listview child control ids
#define LVID_HEADER             0

// listview keyboard tooltip tracking
#define LVKTT_NOTRACK           -1

// When there is no frozen slot, it is -1.
#define LV_NOFROZENSLOT         -1
// When no item is frozen, the index of the frozen item is -1.
#define LV_NOFROZENITEM         -1

// Instance data pointer access functions

#define ListView_GetPtr(hwnd)      (LV*)GetWindowPtr(hwnd, 0)
#define ListView_SetPtr(hwnd, p)   (LV*)SetWindowPtr(hwnd, 0, p)

// view type check functions

#define ListView_IsIconView(plv)    ((plv)->wView == LV_VIEW_ICON)
#define ListView_IsTileView(plv)    ((plv)->wView == LV_VIEW_TILE)
#define ListView_IsSmallView(plv)   ((plv)->wView == LV_VIEW_SMALLICON)
#define ListView_IsListView(plv)    ((plv)->wView == LV_VIEW_LIST)
#define ListView_IsReportView(plv)  ((plv)->wView == LV_VIEW_DETAILS)
#define ListView_IsAutoArrangeView(plv) ((((plv)->wView == LV_VIEW_ICON) || ((plv)->wView == LV_VIEW_SMALLICON) || ((plv)->wView == LV_VIEW_TILE)))
#define ListView_IsSlotView(plv) ((((plv)->wView == LV_VIEW_ICON) || ((plv)->wView == LV_VIEW_SMALLICON) || ((plv)->wView == LV_VIEW_TILE)))
#define ListView_UseLargeIcons(plv) (((plv)->wView == LV_VIEW_ICON) || ((plv)->wView == LV_VIEW_TILE))
#define ListView_IsRearrangeableView(plv) (((plv)->wView == LV_VIEW_ICON) || ((plv)->wView == LV_VIEW_SMALLICON) || ((plv)->wView == LV_VIEW_TILE))
#define ListView_IsIScrollView(plv) (((plv)->wView == LV_VIEW_ICON) || ((plv)->wView == LV_VIEW_SMALLICON) || ((plv)->wView == LV_VIEW_TILE))
#define ListView_IsGroupedView(plv) ((plv)->wView != LV_VIEW_LIST)

#define ListView_IsOwnerData( plv )     (plv->ci.style & (UINT)LVS_OWNERDATA)
#define ListView_CheckBoxes(plv)        (plv->exStyle & LVS_EX_CHECKBOXES)
#define ListView_FullRowSelect(plv)     (plv->exStyle & LVS_EX_FULLROWSELECT)
#define ListView_IsInfoTip(plv)         (plv->exStyle & LVS_EX_INFOTIP)
#define ListView_OwnerDraw(plv)         (plv->ci.style & LVS_OWNERDRAWFIXED)
#define ListView_IsLabelTip(plv)        (plv->exStyle & LVS_EX_LABELTIP)

#define ListView_SingleRow(plv)         (plv->exStyle & LVS_EX_SINGLEROW)
#define ListView_HideLabels(plv)        (plv->exStyle & LVS_EX_HIDELABELS)
#define ListView_IsBorderSelect(plv)    (plv->exStyle & LVS_EX_BORDERSELECT)
#define ListView_IsWatermarked(plv)     ((plv)->fListviewEnableWatermark && (plv)->hbmpWatermark)
#define ListView_IsWatermarkedBackground(plv)     ((plv)->fListviewWatermarkBackgroundImages && (plv)->pImgCtx && (plv)->fImgCtxComplete)
#define ListView_IsSimpleSelect(plv)    (plv->exStyle & LVS_EX_SIMPLESELECT)
#ifdef DPITEST
#define ListView_IsDPIScaled(plv)        TRUE
#else
#define ListView_IsDPIScaled(plv)       (CCDPIScale((plv)->ci))
#endif

#ifdef DEBUG_PAINT
#define ListView_IsDoubleBuffer(plv)    (FALSE)
#else
#define ListView_IsDoubleBuffer(plv)    (plv->exStyle & LVS_EX_DOUBLEBUFFER)
#endif

#define ListView_IsKbdTipTracking(plv)  (plv->iTracking != LVKTT_NOTRACK)

// Some helper macros for checking some of the flags...
#define ListView_RedrawEnabled(plv) ((plv->flags & (LVF_REDRAW | LVF_VISIBLE)) == (LVF_REDRAW|LVF_VISIBLE))

// The hdpaZorder is acutally an array of DWORDS which contains the
// indexes of the items and not actual pointers...
// NOTE: linear search! this can be slow
#define ListView_ZOrderIndex(plv, i) DPA_GetPtrIndex((plv)->hdpaZOrder, IntToPtr(i))

// Message handler functions (listview.c):

LRESULT CALLBACK _export ListView_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

BOOL ListView_NotifyCacheHint( LV* plv, int iFrom, int iTo );
void ListView_NotifyRecreate(LV *plv);
BOOL ListView_OnCreate(LV* plv, CREATESTRUCT* lpCreateStruct);
void ListView_OnNCDestroy(LV* plv);
void ListView_OnPaint(LV* plv, HDC hdc);
BOOL ListView_OnEraseBkgnd(LV* plv, HDC hdc);
void ListView_OnCommand(LV* plv, int id, HWND hwndCtl, UINT codeNotify);
void ListView_OnEnable(LV* plv, BOOL fEnable);
BOOL ListView_OnWindowPosChanging(LV* plv, WINDOWPOS* lpwpos);
void ListView_OnWindowPosChanged(LV* plv, const WINDOWPOS* lpwpos);
void ListView_OnSetFocus(LV* plv, HWND hwndOldFocus);
void ListView_OnKillFocus(LV* plv, HWND hwndNewFocus);
void ListView_OnKey(LV* plv, UINT vk, BOOL fDown, int cRepeat, UINT flags);
BOOL ListView_OnImeComposition(LV* plv, WPARAM wParam, LPARAM lParam);
#ifndef UNICODE
BOOL SameDBCSChars(LPTSTR lpsz, WORD w);
#endif
void ListView_OnChar(LV* plv, UINT ch, int cRepeat);
void ListView_OnButtonDown(LV* plv, BOOL fDoubleClick, int x, int y, UINT keyFlags);
void ListView_OnLButtonUp(LV* plv, int x, int y, UINT keyFlags);
void ListView_OnCancelMode(LV* plv);
void ListView_OnTimer(LV* plv, UINT id);
void ListView_SetupPendingNameEdit(LV* plv);
#define ListView_CancelPendingEdit(plv) ListView_CancelPendingTimer(plv, LVF_NMEDITPEND, IDT_NAMEEDIT)
#define ListView_CancelScrollWait(plv) ListView_CancelPendingTimer(plv, LVF_SCROLLWAIT, IDT_SCROLLWAIT)
BOOL ListView_CancelPendingTimer(LV* plv, UINT fFlag, int idTimer);
void ListView_OnHScroll(LV* plv, HWND hwndCtl, UINT code, int pos);
void ListView_OnVScroll(LV* plv, HWND hwndCtl, UINT code, int pos);
BOOL ListView_CommonArrange(LV* plv, UINT style, HDPA hdpaSort);
BOOL ListView_CommonArrangeEx(LV* plv, UINT style, HDPA hdpaSort, int iWorkArea);
BOOL ListView_OnSetCursor(LV* plv, HWND hwndCursor, UINT codeHitTest, UINT msg);
UINT ListView_OnGetDlgCode(LV* plv, MSG* lpmsg);
HBRUSH ListView_OnCtlColor(LV* plv, HDC hdc, HWND hwndChild, int type);
void ListView_OnSetFont(LV* plvCtl, HFONT hfont, BOOL fRedraw);
HFONT ListView_OnGetFont(LV* plv);
void ListViews_OnTimer(LV* plv, UINT id);
void ListView_OnWinIniChange(LV* plv, WPARAM wParam, LPARAM lParam);
void ListView_OnSysColorChange(LV* plv);
void ListView_OnSetRedraw(LV* plv, BOOL fRedraw);
BOOL ListView_OnSetTileViewInfo(LV* plv, PLVTILEVIEWINFO pTileViewInfo);
BOOL ListView_OnGetTileViewInfo(LV* plv, PLVTILEVIEWINFO pTileViewInfo);
BOOL ListView_OnSetTileInfo(LV* plv, PLVTILEINFO pTileInfo);
BOOL ListView_OnGetTileInfo(LV* plv, PLVTILEINFO pTileInfo);
HIMAGELIST ListView_OnCreateDragImage(LV *plv, int iItem, LPPOINT lpptUpLeft);
BOOL ListView_ISetColumnWidth(LV* plv, int iCol, int cx, BOOL fExplicit);

typedef void (*SCROLLPROC)(LV*, int dx, int dy, UINT uSmooth);
void ListView_ComOnScroll(LV* plv, UINT code, int posNew, int sb,
                                     int cLine, int cPage);

#ifdef UNICODE
BOOL ListView_OnGetItemA(LV* plv, LV_ITEMA* plvi);
BOOL ListView_OnSetItemA(LV* plv, LV_ITEMA* plvi);
int ListView_OnInsertItemA(LV* plv, LV_ITEMA* plvi);
int  ListView_OnFindItemA(LV* plv, int iStart, LV_FINDINFOA* plvfi);
int ListView_OnGetStringWidthA(LV* plv, LPCSTR psz, HDC hdc);
BOOL ListView_OnGetColumnA(LV* plv, int iCol, LV_COLUMNA* pcol);
BOOL ListView_OnSetColumnA(LV* plv, int iCol, LV_COLUMNA* pcol);
int ListView_OnInsertColumnA(LV* plv, int iCol, LV_COLUMNA* pcol);
int ListView_OnGetItemTextA(LV* plv, int i, LV_ITEMA *lvitem);
BOOL WINAPI ListView_OnSetItemTextA(LV* plv, int i, int iSubItem, LPCSTR pszText);
BOOL WINAPI ListView_OnGetBkImageA(LV* plv, LPLVBKIMAGEA pbiA);
BOOL WINAPI ListView_OnSetBkImageA(LV* plv, LPLVBKIMAGEA pbiA);
#endif

BOOL ListView_IsItemUnfolded2(LV* plv, int iItem, int iSubItem, LPTSTR pszText, int cchTextMax);
BOOL WINAPI ListView_OnSetBkImage(LV* plv, LPLVBKIMAGE pbi);
BOOL WINAPI ListView_OnGetBkImage(LV* plv, LPLVBKIMAGE pbi);
BOOL ListView_OnSetBkColor(LV* plv, COLORREF clrBk);
HIMAGELIST ListView_OnSetImageList(LV* plv, HIMAGELIST himl, BOOL fSmallImages);
BOOL ListView_OnDeleteAllItems(LV* plv);
LISTITEM* ListView_InsertItemInternal(LV* plv, const LV_ITEM* plvi, int* pi);
int  ListView_OnInsertItem(LV* plv, const LV_ITEM* plvi);
BOOL ListView_OnDeleteItem(LV* plv, int i);
BOOL ListView_OnReplaceItem(LV* plv, const LV_ITEM* plvi);
int  ListView_OnFindItem(LV* plv, int iStart, const LV_FINDINFO* plvfi);
BOOL ListView_OnSetItemPosition(LV* plv, int i, int x, int y);
BOOL ListView_OnSetItem(LV* plv, const LV_ITEM* plvi);
BOOL ListView_OnGetItem(LV* plv, LV_ITEM* plvi);
BOOL ListView_OnGetItemPosition(LV* plv, int i, POINT* ppt);
BOOL ListView_OnEnsureVisible(LV* plv, int i, BOOL fPartialOK);
BOOL ListView_OnScroll(LV* plv, int dx, int dy);
int ListView_OnHitTest(LV* plv, LV_HITTESTINFO* pinfo);
int ListView_OnGetStringWidth(LV* plv, LPCTSTR psz, HDC hdc);
BOOL ListView_OnGetItemRect(LV* plv, int i, RECT* prc);
BOOL ListView_OnRedrawItems(LV* plv, int iFirst, int iLast);
int ListView_OnGetNextItem(LV* plv, int i, UINT flags);
BOOL ListView_OnSetColumnWidth(LV* plv, int iCol, int cx);
int ListView_OnGetColumnWidth(LV* plv, int iCol);
void ListView_OnStyleChanging(LV* plv, UINT gwl, LPSTYLESTRUCT pinfo);
void ListView_OnStyleChanged(LV* plv, UINT gwl, LPSTYLESTRUCT pinfo);
int ListView_OnGetTopIndex(LV* plv);
int ListView_OnGetCountPerPage(LV* plv);
BOOL ListView_OnGetOrigin(LV* plv, POINT* ppt);
int ListView_OnGetItemText(LV* plv, int i, LV_ITEM *lvitem);
BOOL WINAPI ListView_OnSetItemText(LV* plv, int i, int iSubItem, LPCTSTR pszText);
HIMAGELIST ListView_OnGetImageList(LV* plv, int iImageList);

UINT ListView_OnGetItemState(LV* plv, int i, UINT mask);
BOOL ListView_OnSetItemState(LV* plv, int i, UINT data, UINT mask);

LRESULT WINAPI ListView_OnSetInfoTip(LV *plv, PLVSETINFOTIP plvSetInfoTip);

// Private functions (listview.c):

#define QUERY_DEFAULT   0x0
#define QUERY_FOLDED    0x1
#define QUERY_UNFOLDED  0x2
#define QUERY_RCVIEW  0x4
#define IsQueryFolded(dw) (((dw)&(QUERY_FOLDED|QUERY_UNFOLDED)) == QUERY_FOLDED)
#define IsQueryUnfolded(dw) (((dw)&(QUERY_FOLDED|QUERY_UNFOLDED)) == QUERY_UNFOLDED)
#define IsQueryrcView(dw) (((dw)&(QUERY_RCVIEW)) == QUERY_RCVIEW)

BOOL ListView_Notify(LV* plv, int i, int iSubItem, int code);
void ListView_GetRects(LV* plv, int i, UINT fQueryLabelRects,
        RECT* prcIcon, RECT* prcLabel,
        RECT* prcBounds, RECT* prcSelectBounds);
BOOL ListView_DrawItem(PLVDRAWITEM);

#define ListView_InvalidateItem(p,i,s,r) ListView_InvalidateItemEx(p,i,s,r,0)
void ListView_InvalidateItemEx(LV* plv, int i, BOOL fSelectionOnly,
    UINT fRedraw, UINT maskChanged);

void ListView_TypeChange(LV* plv, WORD wViewOld, BOOL fOwnerDrawFixed);
void ListView_DeleteHrgnInval(LV* plv);

void ListView_Redraw(LV* plv, HDC hdc, RECT* prc);
void ListView_RedrawSelection(LV* plv);
BOOL ListView_FreeItem(LV* plv, LISTITEM* pitem);
void ListView_FreeSubItem(PLISTSUBITEM plsi);
LISTITEM* ListView_CreateItem(LV* plv, const LV_ITEM* plvi);
void ListView_UpdateScrollBars(LV* plv);

int ListView_SetFocusSel(LV* plv, int iNewFocus, BOOL fSelect, BOOL fDeselectAll, BOOL fToggleSel);

void ListView_GetRectsOwnerData(LV* plv, int iItem,
        RECT* prcIcon, RECT* prcLabel, RECT* prcBounds,
        RECT* prcSelectBounds, LISTITEM* pitem);

void ListView_CalcMinMaxIndex( LV* plv, PRECT prcBounding, int* iMin, int* iMax );
int ListView_LCalcViewItem( LV* plv, int x, int y );
void LVSeeThruScroll(LV *plv, LPRECT lprcUpdate);

BOOL ListView_UnfoldRects(LV* plv, int iItem,
                               RECT* prcIcon, RECT* prcLabel,
                               RECT* prcBounds, RECT* prcSelectBounds);

BOOL ListView_FindWorkArea(LV * plv, POINT pt, short * piWorkArea);

__inline int ListView_Count(LV *plv)
{
    ASSERT(ListView_IsOwnerData(plv) || plv->cTotalItems == DPA_GetPtrCount(plv->hdpa));
    return plv->cTotalItems;
}

// Forcing (i) to UINT lets us catch bogus negative numbers, too.
#define ListView_IsValidItemNumber(plv, i) ((UINT)(i) < (UINT)ListView_Count(plv))


#define ListView_GetItemPtr(plv, i)         ((LISTITEM*)DPA_GetPtr((plv)->hdpa, (i)))

#ifdef DEBUG
#define ListView_FastGetItemPtr(plv, i)     ((LISTITEM*)DPA_GetPtr((plv)->hdpa, (i)))
#define ListView_FastGetZItemPtr(plv, i)    ((LISTITEM*)DPA_GetPtr((plv)->hdpa, \
                                                  (int)OFFSETOF(DPA_GetPtr((plv)->hdpaZOrder, (i)))))

#else
#define ListView_FastGetItemPtr(plv, i)     ((LISTITEM*)DPA_FastGetPtr((plv)->hdpa, (i)))
#define ListView_FastGetZItemPtr(plv, i)    ((LISTITEM*)DPA_FastGetPtr((plv)->hdpa, \
                                                  (int)OFFSETOF(DPA_FastGetPtr((plv)->hdpaZOrder, (i)))))

#endif

BOOL ListView_OnGetInsertMarkRect(LV* plv, LPRECT prc);
COLORREF ListView_OnGetInsertMarkColor(LV* plv);
void ListView_InvalidateMark(LV* plv);
BOOL ListView_OnInsertMarkHitTest(LV* plv, int x, int y, LPLVINSERTMARK ptbim);
LRESULT ListView_OnSetInsertMark(LV* plv, LPLVINSERTMARK plvim);

BOOL ListView_CalcMetrics();
void ListView_ColorChange();
void ListView_DrawBackground(LV* plv, HDC hdc, RECT *prcClip);

BOOL ListView_NeedsEllipses(HDC hdc, LPCTSTR pszText, RECT* prc, int* pcchDraw, int cxEllipses);
int ListView_CompareString(LV* plv, int i, LPCTSTR pszFind, UINT flags, int iLen);
int ListView_GetLinkedTextWidth(HDC hdc, LPCTSTR psz, UINT cch, BOOL bLink);

int ListView_GetCxScrollbar(LV* plv);
int ListView_GetCyScrollbar(LV* plv);
DWORD ListView_GetWindowStyle(LV* plv);
#define ListView_GetScrollInfo(plv, flag, lpsi)                             \
    ((plv)->exStyle & LVS_EX_FLATSB ?                                       \
        FlatSB_GetScrollInfo((plv)->ci.hwnd, (flag), (lpsi)) :              \
        GetScrollInfo((plv)->ci.hwnd, (flag), (lpsi)))
int ListView_SetScrollInfo(LV *plv, int fnBar, LPSCROLLINFO lpsi, BOOL fRedraw);
#define ListView_SetScrollRange(plv, flag, min, max, fredraw)               \
    ((plv)->exStyle & LVS_EX_FLATSB ?                                       \
        FlatSB_SetScrollRange((plv)->ci.hwnd, (flag), (min), (max), (fredraw)) : \
        SetScrollRange((plv)->ci.hwnd, (flag), (min), (max), (fredraw)))

// lvicon.c functions

BOOL ListView_OnArrange(LV* plv, UINT style);
HWND ListView_OnEditLabel(LV* plv, int i, LPTSTR pszText);

int ListView_IItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem);
void ListView_IGetRects(LV* plv, LISTITEM* pitem, UINT fQueryLabelRects, RECT* prcIcon,
        RECT* prcLabel, LPRECT prcBounds);
void ListView_IGetRectsOwnerData(LV* plv, int iItem, RECT* prcIcon,
        RECT* prcLabel, LISTITEM* pitem, BOOL fUsepitem);
void _ListView_GetRectsFromItem(LV* plv, BOOL bSmallIconView,
                                            LISTITEM *pitem, UINT fQueryLabelRects,
                                            LPRECT prcIcon, LPRECT prcLabel, LPRECT prcBounds, LPRECT prcSelectBounds);

__inline void ListView_SetSRecompute(LISTITEM *pitem)
{
    pitem->cxSingleLabel = SRECOMPUTE;
    pitem->cxMultiLabel = SRECOMPUTE;
    pitem->cyFoldedLabel = SRECOMPUTE;
    pitem->cyUnfoldedLabel = SRECOMPUTE;
}

void ListView_RecomputeLabelSize(LV* plv, LISTITEM FAR* pitem, int i, HDC hdc, BOOL fUsepitem);

BOOL ListView_SetIconPos(LV* plv, LISTITEM* pitem, int iSlot, int cSlot);
BOOL ListView_IsCleanRect(LV * plv, RECT * prc, int iExcept, UINT fQueryLabelRect, BOOL * pfUpdate, HDC hdc);
int ListView_FindFreeSlot(LV* plv, int i, int iSlot, int cSlot, UINT fQueryLabelRect, BOOL* pfUpdateSB, BOOL* pfAppend, HDC hdc, int iWidth, int iHeight);
int ListView_CalcHitSlot( LV* plv, POINT pt, int cslot, int iWidth, int iHeight );

BOOL ListView_OnGetViewRect(LV* plv, RECT* prcView);
void ListView_GetViewRect2(LV* plv, RECT* prcView, int cx, int cy);
int CALLBACK ArrangeIconCompare(LISTITEM* pitem1, LISTITEM* pitem2, LPARAM lParam);
int ListView_GetSlotCountEx(LV* plv, BOOL fWithoutScroll, int iWorkArea, int *piWidth, int *piHeight);
int ListView_GetSlotCount(LV* plv, BOOL fWithoutScroll, int *piWidth, int *piHeight);
void ListView_CalcSlotRect(LV* plv, LISTITEM *pItem, int iSlot, int cSlot, BOOL fBias, int iWidth, int iHeight, LPRECT lprc);
void ListView_IUpdateScrollBars(LV* plv);
DWORD ListView_GetStyleAndClientRectGivenViewRect(LV* plv, RECT *prcViewRect, RECT* prcClient);
DWORD ListView_GetClientRect(LV* plv, RECT* prcClient, BOOL fSubScrolls, RECT *prcViewRect);

void ListView_SetEditSize(LV* plv);
BOOL ListView_DismissEdit(LV* plv, BOOL fCancel);
LRESULT CALLBACK _export ListView_EditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


UINT ListView_DrawImageEx(LV* plv, LV_ITEM* pitem, HDC hdc, int x, int y, COLORREF crBk, UINT fDraw, int xMax);
UINT ListView_DrawImageEx2(LV* plv, LV_ITEM* pitem, HDC hdc, int x, int y, COLORREF crBk, UINT fDraw, int xMax, int iIconEffect, int iFrame);
#define ListView_DrawImage(plv, pitem, hdc, x, y, fDraw) \
        ListView_DrawImageEx(plv, pitem, hdc, x, y, plv->clrBk, fDraw, -1)

#if defined(FE_IME) || !defined(WINNT)
void ListView_SizeIME(HWND hwnd);
void ListView_InsertComposition(HWND hwnd, WPARAM wParam, LPARAM lParam, LV *plv);
void ListView_PaintComposition(HWND hwnd, LV *plv);
#endif

// lvsmall.c functions:


void ListView_SGetRects(LV* plv, LISTITEM* pitem, RECT* prcIcon,
        RECT* prcLabel, LPRECT prcBounds);
void ListView_SGetRectsOwnerData(LV* plv, int iItem, RECT* prcIcon,
        RECT* prcLabel, LISTITEM* pitem, BOOL fUsepitem);
int ListView_SItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem);

int ListView_LookupString(LV* plv, LPCTSTR lpszLookup, UINT flags, int iStart);

// lvlist.c functions:


void ListView_LGetRects(LV* plv, int i, RECT* prcIcon,
        RECT* prcLabel, RECT *prcBounds, RECT* prcSelectBounds);
int ListView_LItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem);
void ListView_LUpdateScrollBars(LV* plv);
BOOL ListView_MaybeResizeListColumns(LV* plv, int iFirst, int iLast);

// lvrept.c functions:

int ListView_OnSubItemHitTest(LV* plv, LPLVHITTESTINFO lParam);
void ListView_GetSubItem(LV* plv, int i, int iSubItem, PLISTSUBITEM plsi);
BOOL LV_ShouldItemDrawGray(LV* plv, UINT fText);
int ListView_OnInsertColumn(LV* plv, int iCol, const LV_COLUMN* pcol);
BOOL ListView_OnDeleteColumn(LV* plv, int iCol);
BOOL ListView_OnGetColumn(LV* plv, int iCol, LV_COLUMN* pcol);
BOOL ListView_OnSetColumn(LV* plv, int iCol, const LV_COLUMN* pcol);
BOOL ListView_ROnEnsureVisible(LV* plv, int i, BOOL fPartialOK);
void ListView_RInitialize(LV* plv, BOOL fInval);
BOOL ListView_OnGetSubItemRect(LV* plv, int i, LPRECT lprc);
int ListView_RYHitTest(plv, cy);

BOOL ListView_SetSubItem(LV* plv, const LV_ITEM* plvi);
void ListView_RAfterRedraw(LV* plv, HDC hdc);

int ListView_RGetColumnWidth(LV* plv, int iCol);
BOOL ListView_RSetColumnWidth(LV* plv, int iCol, int cx);
LPTSTR ListView_GetSubItemText(LV* plv, int i, int iCol);

void ListView_RDestroy(LV* plv);
LPTSTR ListView_RGetItemText(LV* plv, int i, int iCol);
int ListView_RItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem);
void ListView_RUpdateScrollBars(LV* plv);
void ListView_RGetRects(LV* plv, int iItem, RECT* prcIcon,
        RECT* prcLabel, RECT* prcBounds, RECT* prcSelectBounds);

LRESULT ListView_HeaderNotify(LV* plv, HD_NOTIFY *pnm);
int ListView_FreeColumnData(LPVOID d, LPVOID p);

BOOL SameChars(LPTSTR lpsz, TCHAR c);

#define ListView_GetSubItemDPA(plv, idpa) \
    ((HDPA)DPA_GetPtr((plv)->hdpaSubItems, (idpa)))

int  ListView_Arrow(LV* plv, int iStart, UINT vk);

BOOL ListView_IsItemUnfolded(LV *plv, int item);
BOOL ListView_IsItemUnfoldedPtr(LV *plv, LISTITEM *pitem);

// lvtile.c functions:
int ListView_TItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem);
void ListView_TGetRectsOwnerData( LV* plv,
        int iItem,
        RECT* prcIcon,
        RECT* prcLabel,
        LISTITEM* pitem,
        BOOL fUsepitem );

void ListView_TGetRects(LV* plv, LISTITEM* pitem, RECT* prcIcon, RECT* prcLabel, LPRECT prcBounds);
BOOL TCalculateSubItemRect(LV* plv, LISTITEM *pitem, LISTSUBITEM* plsi, int i, int iSubItem, HDC hdc, RECT* prc, BOOL *pbUnfolded);

typedef struct LVTILECOLUMNSENUM
{
    int iColumnsRemainingMax;
    int iTotalSpecifiedColumns;
    UINT *puSpecifiedColumns;
    int iCurrentSpecifiedColumn;
    int iSortedColumn;
    BOOL bUsedSortedColumn;
} LVTILECOLUMNSENUM, *PLVTILECOLUMNSENUM;

int _GetNextColumn(PLVTILECOLUMNSENUM plvtce);
void _InitTileColumnsEnum(PLVTILECOLUMNSENUM plvtce, LV* plv, UINT cColumns, UINT *puColumns, BOOL fOneLessLine);
BOOL Tile_Set(UINT **ppuColumns, UINT *pcColumns, UINT *puColumns, UINT cColumns);




// Fake customdraw.  See comment block in lvrept.c

typedef struct LVFAKEDRAW {
    NMLVCUSTOMDRAW nmcd;
    LV* plv;
    DWORD dwCustomPrev;
    DWORD dwCustomItem;
    DWORD dwCustomSubItem;
    LV_ITEM *pitem;
    HFONT hfontPrev;
} LVFAKEDRAW, *PLVFAKEDRAW;

void ListView_BeginFakeCustomDraw(LV* plv, PLVFAKEDRAW plvfd, LV_ITEM *pitem);
DWORD ListView_BeginFakeItemDraw(PLVFAKEDRAW plvfd);
void ListView_EndFakeItemDraw(PLVFAKEDRAW plvfd);
void ListView_EndFakeCustomDraw(PLVFAKEDRAW plvfd);

//============ External declarations =======================================

//extern HFONT g_hfontLabel;
extern HBRUSH g_hbrActiveLabel;
extern HBRUSH g_hbrInactiveLabel;
extern HBRUSH g_hbrBackground;


// function tables
#define LV_TYPEINDEX(plv) ((plv)->wView)

BOOL ListView_RDrawItem(PLVDRAWITEM);
BOOL ListView_IDrawItem(PLVDRAWITEM);
BOOL ListView_LDrawItem(PLVDRAWITEM);
BOOL ListView_TDrawItem(PLVDRAWITEM);

typedef BOOL (*PFNLISTVIEW_DRAWITEM)(PLVDRAWITEM);
extern const PFNLISTVIEW_DRAWITEM pfnListView_DrawItem[5];
#define _ListView_DrawItem(plvdi) \
        pfnListView_DrawItem[LV_TYPEINDEX(plvdi->plv)](plvdi)


void ListView_RUpdateScrollBars(LV* plv);

typedef void (*PFNLISTVIEW_UPDATESCROLLBARS)(LV* plv);
extern const PFNLISTVIEW_UPDATESCROLLBARS pfnListView_UpdateScrollBars[5];
#define _ListView_UpdateScrollBars(plv) \
        pfnListView_UpdateScrollBars[LV_TYPEINDEX(plv)](plv)


typedef DWORD (*PFNLISTVIEW_APPROXIMATEVIEWRECT)(LV* plv, int, int, int);
extern const PFNLISTVIEW_APPROXIMATEVIEWRECT pfnListView_ApproximateViewRect[5];
#define _ListView_ApproximateViewRect(plv, iCount, iWidth, iHeight) \
        pfnListView_ApproximateViewRect[LV_TYPEINDEX(plv)](plv, iCount, iWidth, iHeight)


typedef int (*PFNLISTVIEW_ITEMHITTEST)(LV* plv, int, int, UINT *, int *);
extern const PFNLISTVIEW_ITEMHITTEST pfnListView_ItemHitTest[5];
#define _ListView_ItemHitTest(plv, x, y, pflags, piSubItem) \
        pfnListView_ItemHitTest[LV_TYPEINDEX(plv)](plv, x, y, pflags, piSubItem)


BOOL ListView_SendScrollNotify(LV* plv, BOOL fBegin, int dx, int dy);

void ListView_IOnScroll(LV* plv, UINT code, int posNew, UINT fVert);
void ListView_LOnScroll(LV* plv, UINT code, int posNew, UINT sb);
void ListView_ROnScroll(LV* plv, UINT code, int posNew, UINT sb);

typedef void (*PFNLISTVIEW_ONSCROLL)(LV* plv, UINT, int, UINT );
extern const PFNLISTVIEW_ONSCROLL pfnListView_OnScroll[5];
#define _ListView_OnScroll(plv, x, y, pflags) \
        pfnListView_OnScroll[LV_TYPEINDEX(plv)](plv, x, y, pflags)


void ListView_IRecomputeLabelSize(LV* plv, LISTITEM* pitem, int i, HDC hdc, BOOL fUsepitem);
void ListView_TRecomputeLabelSize(LV* plv, LISTITEM* pitem, int i, HDC hdc, BOOL fUsepitem);

typedef void (*PFNLISTVIEW_RECOMPUTELABELSIZE)(LV* plv, LISTITEM* pitem, int i, HDC hdc, BOOL fUsepitem);
extern const PFNLISTVIEW_RECOMPUTELABELSIZE pfnListView_RecomputeLabelSize[5];
#define _ListView_RecomputeLabelSize(plv, pitem, i, hdc, fUsepitem) \
        pfnListView_RecomputeLabelSize[LV_TYPEINDEX(plv)](plv, pitem, i, hdc, fUsepitem)


void ListView_Scroll2(LV* plv, int dx, int dy);
void ListView_IScroll2(LV* plv, int dx, int dy, UINT uSmooth);
void ListView_LScroll2(LV* plv, int dx, int dy, UINT uSmooth);
void ListView_RScroll2(LV* plv, int dx, int dy, UINT uSmooth);

typedef void (*PFNLISTVIEW_SCROLL2)(LV* plv, int, int, UINT );
extern const PFNLISTVIEW_SCROLL2 pfnListView_Scroll2[5];
#define _ListView_Scroll2(plv, x, y, pflags) \
        pfnListView_Scroll2[LV_TYPEINDEX(plv)](plv, x, y, pflags)

int ListView_IGetScrollUnitsPerLine(LV* plv, UINT sb);
int ListView_LGetScrollUnitsPerLine(LV* plv, UINT sb);
int ListView_RGetScrollUnitsPerLine(LV* plv, UINT sb);

typedef int (*PFNLISTVIEW_GETSCROLLUNITSPERLINE)(LV* plv, UINT sb);
extern const PFNLISTVIEW_GETSCROLLUNITSPERLINE pfnListView_GetScrollUnitsPerLine[5];
#define _ListView_GetScrollUnitsPerLine(plv, sb) \
        pfnListView_GetScrollUnitsPerLine[LV_TYPEINDEX(plv)](plv, sb)

UINT ListView_GetTextSelectionFlags(LV* plv, LV_ITEM *pitem, UINT fDraw);

BOOL NEAR ListView_IRecomputeEx(LV* plv, HDPA hdpaSort, int iFrom, BOOL fForce);
BOOL NEAR ListView_RRecomputeEx(LV* plv, HDPA hdpaSort, int iFrom, BOOL fForce);
BOOL NEAR ListView_NULLRecomputeEx(LV* plv, HDPA hdpaSort, int iFrom, BOOL fForce);
typedef int (*PFNLISTVIEW_RECOMPUTEEX)(LV* plv, HDPA hdpaSort, int iFrom, BOOL fForce);
extern const PFNLISTVIEW_RECOMPUTEEX pfnListView_RecomputeEx[5];
#define _ListView_RecomputeEx(plv, hdpaSort, iFrom, fForce)\
        pfnListView_RecomputeEx[LV_TYPEINDEX(plv)](plv, hdpaSort, iFrom, fForce);
#define ListView_Recompute(plv) _ListView_RecomputeEx(plv, NULL, 0, FALSE)
LISTGROUP* ListView_FindFirstVisibleGroup(LV* plv);
UINT LV_IsItemOnViewEdge(LV* plv, LISTITEM *pitem);

void _GetCurrentItemSize(LV* plv, int * pcx, int *pcy);
void ListView_CalcItemSlotAndRect(LV* plv, LISTITEM* pitem, int* piSlot, RECT* prcSlot);

// Expand the "rcIcon" by this much for glow
#define GLOW_EXPAND 10

// pixel offset from the state image to the 
#define LV_ICONTOSTATECX 3

// list view state offset, this is the gap between the icon and the 
#define LV_ICONTOSTATEOFFSET(plv) ((plv->cxState > 0) ? LV_ICONTOSTATECX:0)

//#define DEBUG_PAINT

#ifdef DEBUG_PAINT
void ListView_DebugDrawInvalidRegion(LV* plv, RECT* prc, HRGN hrgn);
void ListView_DebugDisplayClipRegion(LV* plv, RECT* prc, HRGN hrgn);
#else
#define ListView_DebugDrawInvalidRegion(plv, prc, hrgn)
#define ListView_DebugDisplayClipRegion(plv, prc, hrgn)
#endif

#define LVMI_PLACEITEMS (WM_USER)

int ListView_GetIconBufferX(LV* plv);
int ListView_GetIconBufferY(LV* plv);
BOOL ListView_ICalcViewRect(LV* plv, BOOL fNoRecalc, RECT* prcView);
void ListView_CalcBounds(LV* plv, UINT fQueryLabelRects, RECT *prcIcon, RECT *prcLabel, RECT *prcBounds);
void ListView_AddViewRectBuffer(LV* plv, RECT* prcView);
BOOL ListView_FixIScrollPositions(LV *plv, BOOL fNoScrollbarUpdate, RECT* prcClient);
void ListView_InvalidateWindow(LV* plv);
BOOL ListView_OnScrollSelectSmooth(LV* plv, int dx, int dy, UINT uSmooth);
#ifdef DEBUG
BOOL ListView_ValidateScrollPositions(LV* plv, RECT* prcClient);
BOOL ListView_ValidatercView(LV* plv, RECT* prcView, BOOL fRecalcDone);
#endif

#endif  //!_INC_LISTVIEW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\makefile.inc ===
..\commctrl.rc : $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc

# Format the message so build.exe recognizes it as an error.
COMCTL_BUILD_ERROR_MSG=NMAKE : U1234: 'COMCTL_BUILD' (\nt\shell\comctl32\...\makefile.inc)

# $(TARGET) at this point includes obj\i386, so use its leaf's pieces instead.
# And watch for the fact that in pass 1 TARGETEXT is .lib instead of .dll.
!if defined(SXS_BINPLACE_SLASH_DIR3)
BINPLACED_COMCTL_DLL=$(_NTTREE)$(SXS_BINPLACE_SLASH_DIR3)\$(TARGETNAME).$(TARGETEXT:lib=dll)
!else
BINPLACED_COMCTL_DLL=$(O)\$(TARGETNAME).$(TARGETEXT:lib=dll)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\mem.c ===
#include "ctlspriv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "comctlv6"
#define SZ_MODULE           "comctlv6"

#define DECLARE_DEBUG
#include <debug.h>

//========== Memory Management =============================================


//----------------------------------------------------------------------------
// Define a Global Shared Heap that we use allocate memory out of that we
// Need to share between multiple instances.
#ifndef WINNT
HANDLE g_hSharedHeap = NULL;
#define GROWABLE        0
#define MAXHEAPSIZE     GROWABLE
#define HEAP_SHARED	0x04000000		/* put heap in shared memory */
#endif

void Mem_Terminate()
{
#ifndef WINNT
    // Assuming that everything else has exited
    //
    if (g_hSharedHeap != NULL)
        HeapDestroy(g_hSharedHeap);
    g_hSharedHeap = NULL;
#endif
}

#ifndef WINNT
HANDLE InitSharedHeap(void)
{
    ENTERCRITICAL;
    if (g_hSharedHeap == NULL)
    {
        g_hSharedHeap = HeapCreate(HEAP_SHARED, 1, MAXHEAPSIZE);
    }
    LEAVECRITICAL;
    return g_hSharedHeap;
}
#endif

void * WINAPI Alloc(long cb)
{
    // I will assume that this is the only one that needs the checks to
    // see if the heap has been previously created or not
#if defined(WINNT) || defined(MAINWIN)
    return (void *)LocalAlloc(LPTR, cb);
#else
    HANDLE hHeap = GetSharedHeapHandle();

    // If still NULL we have problems!
    if (hHeap == NULL)
        return(NULL);

    return HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cb);
#endif
}

void * WINAPI ReAlloc(void * pb, long cb)
{
    if (pb == NULL)
        return Alloc(cb);
#if defined(WINNT) || defined(MAINWIN)
    return (void *)LocalReAlloc((HLOCAL)pb, cb, LMEM_ZEROINIT | LMEM_MOVEABLE);
#else
    return HeapReAlloc(g_hSharedHeap, HEAP_ZERO_MEMORY, pb, cb);
#endif
}

BOOL WINAPI Free(void * pb)
{
#if defined(WINNT) || defined(MAINWIN)
    return (LocalFree((HLOCAL)pb) == NULL);
#else
    return HeapFree(g_hSharedHeap, 0, pb);
#endif
}

DWORD_PTR WINAPI GetSize(void * pb)
{
#if defined(WINNT) || defined(MAINWIN)
    return LocalSize((HLOCAL)pb);
#else
    return HeapSize(g_hSharedHeap, 0, pb);
#endif
}

//----------------------------------------------------------------------------
// The following functions are for debug only and are used to try to
// calculate memory usage.
//
#ifdef DEBUG
typedef struct _HEAPTRACE
{
    DWORD   cAlloc;
    DWORD   cFailure;
    DWORD   cReAlloc;
    ULONG_PTR cbMaxTotal;
    DWORD   cCurAlloc;
    ULONG_PTR cbCurTotal;
} HEAPTRACE;

HEAPTRACE g_htShell = {0};      // Start of zero...

LPVOID WINAPI ControlAlloc(HANDLE hheap, DWORD cb)
{
    LPVOID lp = HeapAlloc(hheap, HEAP_ZERO_MEMORY, cb);;
    if (lp == NULL)
    {
        g_htShell.cFailure++;
        return NULL;
    }

    // Update counts.
    g_htShell.cAlloc++;
    g_htShell.cCurAlloc++;
    g_htShell.cbCurTotal += cb;
    if (g_htShell.cbCurTotal > g_htShell.cbMaxTotal)
        g_htShell.cbMaxTotal = g_htShell.cbCurTotal;

    return lp;
}

LPVOID WINAPI ControlReAlloc(HANDLE hheap, LPVOID pb, DWORD cb)
{
    LPVOID lp;
    SIZE_T cbOld;

    cbOld = HeapSize(hheap, 0, pb);

    lp = HeapReAlloc(hheap, HEAP_ZERO_MEMORY, pb,cb);
    if (lp == NULL)
    {
        g_htShell.cFailure++;
        return NULL;
    }

    // Update counts.
    g_htShell.cReAlloc++;
    g_htShell.cbCurTotal += cb - cbOld;
    if (g_htShell.cbCurTotal > g_htShell.cbMaxTotal)
        g_htShell.cbMaxTotal = g_htShell.cbCurTotal;

    return lp;
}

BOOL  WINAPI ControlFree(HANDLE hheap, LPVOID pb)
{
    SIZE_T cbOld = HeapSize(hheap, 0, pb);
    BOOL fRet = HeapFree(hheap, 0, pb);
    if (fRet)
    {
        // Update counts.
        g_htShell.cCurAlloc--;
        g_htShell.cbCurTotal -= cbOld;
    }

    return(fRet);
}

SIZE_T WINAPI ControlSize(HANDLE hheap, LPVOID pb)
{
    return (DWORD) HeapSize(hheap, 0, pb);
}
#endif  // DEBUG

#if defined(FULL_DEBUG) && defined(WIN32)
#include "../inc/deballoc.c"
#endif // defined(FULL_DEBUG) && defined(WIN32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\mem.h ===
#ifndef _INC_MEM
#define _INC_MEM

// wrappers for private allocations, near in 16 bits

#define NearAlloc(cb)       ((void*)LocalAlloc(LPTR, (cb)))
#define NearReAlloc(pb, cb) ((void*)LocalReAlloc((HLOCAL)(pb), (cb), LMEM_MOVEABLE | LMEM_ZEROINIT))
#define NearFree(pb)        (LocalFree((HLOCAL)(pb)) ? FALSE : TRUE)
#define NearSize(pb)        LocalSize(pb)

#ifdef WIN32
//
// These macros are used in our controls, that in 32 bits we simply call
// LocalAlloc as to have the memory associated with the process that created
// it and as such will be cleaned up if the process goes away.
//
#ifdef DEBUG
LPVOID WINAPI ControlAlloc(HANDLE hheap, DWORD cb);
LPVOID WINAPI ControlReAlloc(HANDLE hheap, LPVOID pb, DWORD cb);
BOOL   WINAPI ControlFree(HANDLE hheap, LPVOID pb);
SIZE_T WINAPI ControlSize(HANDLE hheap, LPVOID pb);
#else // DEBUG
#define ControlAlloc(hheap, cb)       HeapAlloc((hheap), HEAP_ZERO_MEMORY, (cb))
#define ControlReAlloc(hheap, pb, cb) HeapReAlloc((hheap), HEAP_ZERO_MEMORY, (pb),(cb))
#define ControlFree(hheap, pb)        HeapFree((hheap), 0, (pb))
#define ControlSize(hheap, pb)        HeapSize((hheap), 0, (LPCVOID)(pb))
#endif // DEBUG

BOOL Str_Set(LPTSTR *ppsz, LPCTSTR psz);  // in the process heap

#else // WIN32

//
// In 16 bit code we need the Allocs to go from our heap code as we do not
// want to limit them to 64K of data.  If we have some type of notification of
// 16 bit application termination, We may want to see if we can
// dedicate different heaps for different processes to cleanup...
//
#define ControlAlloc(hheap, cb)       Alloc(cb)  /* calls to verify heap exists */
#define ControlReAlloc(hheap, pb, cb) ReAlloc(pb, cb)
#define ControlFree(hheap, pb)        Free(pb)
#define ControlSize(hheap, pb)        GetSize((LPCVOID)pb)
#define Str_Set(p, s)                 Str_SetPtr(p, s)  // use shared heap for win16

#endif // WIN32

#ifndef WINNT

extern HANDLE g_hSharedHeap;

HANDLE InitSharedHeap(void);

__inline HANDLE
GetSharedHeapHandle(void)
{
    if (g_hSharedHeap)
    {
        return g_hSharedHeap;
    }
    else
    {
        return InitSharedHeap();
    }
}

#endif

#endif  // !_INC_MEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\markup.cpp ===
//-------------------------------------------------------------------------//
//  markup.cpp - implementation of CMarkup
//

#include <ctlspriv.h>
#include <shpriv.h>
#include <markup.h>
#include <oleacc.h>

#define DllAddRef()
#define DllRelease()

typedef WCHAR TUCHAR, *PTUCHAR;

#define IS_LINK(pBlock)     ((pBlock) && (pBlock)->iLink != INVALID_LINK_INDEX)

#ifndef POINTSPERRECT
#define POINTSPERRECT       (sizeof(RECT)/sizeof(POINT))
#endif

#ifndef MIN
#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#endif

#define TESTKEYSTATE(vk)   ((GetKeyState(vk) & 0x8000)!=0)

#define LINKCOLOR_ENABLED   GetSysColor(COLOR_HOTLIGHT)
#define LINKCOLOR_DISABLED  GetSysColor(COLOR_GRAYTEXT)
#define SZ_ATTRIBUTE_HREF   TEXT("HREF")
#define SZ_ATTRIBUTE_ID     TEXT("ID")

#define LINKTAG1    TEXT("<A")
#define cchLINKTAG1  (ARRAYSIZE(LINKTAG1) - 1)
#define CH_ENDTAG    TEXT('>')

#define LINKTAG2    TEXT("</A>")
#define cchLINKTAG2  (ARRAYSIZE(LINKTAG2) - 1)

#define Markup_DestroyMarkup(hMarkup)\
    ((IUnknown*)hMarkup)->Release();

struct RECTLISTENTRY          // rect list member
{
    RECT            rc;
    UINT            uCharStart;
    UINT            uCharCount; 
    UINT            uLineNumber;
    RECTLISTENTRY*  next;
};

struct TEXTBLOCK              // text segment data
{
    friend class    CMarkup;
    int             iLink;   // index of link (INVALID_LINK_INDEX if static text)
    DWORD           state;   // state bits
    TCHAR           szID[MAX_LINKID_TEXT]; // link identifier.
    TEXTBLOCK*      next;    // next block
    RECTLISTENTRY*  rgrle;   // list of bounding rectangle(s)
    TCHAR*          pszText; // text
    TCHAR*          pszUrl;  // URL.

    TEXTBLOCK();
    ~TEXTBLOCK();
    void AddRect(const RECT& rc, UINT uMyCharStart = 0, UINT uMyCharCount = 0, UINT uMyLineNumber = 0);
    void FreeRects();
};


class CMarkup : IControlMarkup
{
public:

    // API
    friend HRESULT Markup_Create(IMarkupCallback *pMarkupCallback, HFONT hf, HFONT hfu, REFIID riid, void **ppv);

    // IControlMarkup 
    STDMETHODIMP SetCallback(IUnknown* punk);
    STDMETHODIMP GetCallback(REFIID riid, void** ppvUnk);
    STDMETHODIMP SetFonts(HFONT hFont, HFONT hFontUnderline);
    STDMETHODIMP GetFonts(HFONT* phFont, HFONT* phFontUnderline);
    STDMETHODIMP SetText(LPCWSTR pwszText);
    STDMETHODIMP GetText(BOOL bRaw, LPWSTR pwszText, DWORD *pdwCch);
    STDMETHODIMP SetLinkText(int iLink, UINT uMarkupLinkText, LPCWSTR pwszText);
    STDMETHODIMP GetLinkText(int iLink, UINT uMarkupLinkText, LPWSTR pwszText, DWORD *pdwCch);
    STDMETHODIMP SetRenderFlags(UINT uDT);
    STDMETHODIMP GetRenderFlags(UINT *puDT, HTHEME *phTheme, int *piPartId, int *piStateIdNormal, int *piStateIdLink);
    STDMETHODIMP SetThemeRenderFlags(UINT uDT, HTHEME hTheme, int iPartId, int iStateIdNormal, int iStateIdLink);   
    STDMETHODIMP GetState(int iLink, UINT uStateMask, UINT* puState);    
    STDMETHODIMP SetState(int iLink, UINT uStateMask, UINT uState); 

    STDMETHODIMP DrawText(HDC hdcClient, LPCRECT prcClient);
    STDMETHODIMP SetLinkCursor();
    STDMETHODIMP CalcIdealSize(HDC hdc, UINT uMarkUpCalc, RECT* prc);
    STDMETHODIMP SetFocus();
    STDMETHODIMP KillFocus();
    STDMETHODIMP IsTabbable();

    STDMETHODIMP OnButtonDown(POINT pt);
    STDMETHODIMP OnButtonUp(POINT pt);
    STDMETHODIMP OnKeyDown(UINT uVitKey);
    STDMETHODIMP HitTest(POINT pt, UINT* pidLink);

    // commented out of IControlMarkup?
    STDMETHODIMP HandleEvent(BOOL keys, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

private:

    // private constructor
    CMarkup(IMarkupCallback *pMarkupCallback);
    CMarkup();
    ~CMarkup();

    friend struct TEXTBLOCK;

    HCURSOR GetLinkCursor();

    BOOL IsMarkupState(UINT uState)
    {
        return _pMarkupCallback && _pMarkupCallback->GetState(uState) == S_OK;
    }

    BOOL IsFocused()
    {
        return IsMarkupState(MARKUPSTATE_FOCUSED);
    }

    BOOL IsMarkupAllowed()
    {
        return IsMarkupState(MARKUPSTATE_ALLOWMARKUP);
    }

    void        Parse(LPCTSTR pszText);
    BOOL        Add(TEXTBLOCK* pAdd);
    TEXTBLOCK*  FindLink(int iLink) const;
    void        FreeBlocks();

    void DoNotify(int nCode, int iLink);
    int ThemedDrawText(HDC hdc, LPCTSTR lpString, int nCount, LPRECT lpRect, UINT uFormat, BOOL bLink);

    void    Paint(HDC hdc, IN OPTIONAL LPCRECT prcClient = NULL, BOOL bDraw = TRUE);    
    BOOL    WantTab(int* biFocus = NULL) const;
    void    AssignTabFocus(int nDirection);
    int     GetNextEnabledLink(int iStart, int nDir) const;
    int     StateCount(DWORD dwStateMask, DWORD dwState) const;
    HRESULT _GetNextAnchorTag(LPCTSTR * ppszBlock, int * pcBlocks, LPTSTR pszURL, int cchSize, LPTSTR pszID, int cchID);

    static  TEXTBLOCK* CreateBlock(LPCTSTR pszStart, LPCTSTR pszEnd, int iLink);


    //  Data
    BOOL         _bButtonDown;      // true when button is clicked on a link but not yet released
    TEXTBLOCK*   _rgBlocks;        // linked list of text blocks
    int          _cBlocks;         // block count
    int          _Markups;          // link count
    int          _iFocus;          // index of focus link
    int          _cyIdeal;
    int          _cxIdeal; 
    LPTSTR       _pszCaption;          
    HFONT        _hfStatic, 
                 _hfLink;    
    HCURSOR      _hcurHand;
    IMarkupCallback *_pMarkupCallback; 
    LONG         _cRef;
    UINT         _uDrawTextFlags;
    BOOL         _bRefreshText;
    RECT         _rRefreshRect;
    HTHEME       _hTheme;           // these 3 for theme compatible drawing
    int          _iThemePartId;
    int          _iThemeStateIdNormal;
    int          _iThemeStateIdLink;

    // static helper methods
    static LPTSTR SkipWhite(LPTSTR);
    static BOOL _AssignBit(const DWORD , DWORD& , const DWORD);
    static BOOL IsStringAlphaNumeric(LPCTSTR);
    static HRESULT _GetNextValueDataPair(LPTSTR * , LPTSTR , int , LPTSTR , int);
    static int _IsLineBreakChar(LPCTSTR , int , TCHAR , OUT BOOL* , BOOL fIgnoreSpace);
    BOOL static _FindLastBreakChar(IN LPCTSTR , IN int , IN TCHAR , OUT int* , OUT BOOL*);
    BOOL _FindFirstLineBreak(IN LPCTSTR pszText, IN int cchText, OUT int* piLast, OUT int* piLineBreakSize);
};

CMarkup::CMarkup() :
        _cRef(1),
        _iFocus(INVALID_LINK_INDEX),
        _uDrawTextFlags(DT_LEFT | DT_WORDBREAK),
        _bRefreshText(TRUE),
        _iThemeStateIdLink(1)
{
}

CMarkup::~CMarkup()
{
    FreeBlocks();
    SetText(NULL);
    if (_pMarkupCallback)
    {
        _pMarkupCallback->Release(); 
        _pMarkupCallback = NULL;
    }
}

inline void MakePoint(LPARAM lParam, OUT LPPOINT ppt)
{
    POINTS pts = MAKEPOINTS(lParam);
    ppt->x = pts.x;
    ppt->y = pts.y;
}

STDAPI Markup_Create(IMarkupCallback *pMarkupCallback, HFONT hf, HFONT hfUnderline, REFIID riid, void **ppv)
{
    // Create CMarkup
    HRESULT hr = E_FAIL;
    CMarkup* pThis = new CMarkup();
    if (pThis)
    {
        pThis->SetCallback(pMarkupCallback);

        // init fonts
        pThis->SetFonts(hf, hfUnderline);

        // COM stuff        
        hr = pThis->QueryInterface(riid, ppv);
        pThis->Release();
    }

    return hr;
}

HRESULT CMarkup::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CMarkup, IControlMarkup),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CMarkup::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CMarkup::Release()
{
    if (InterlockedDecrement(&_cRef))
    {
        return _cRef;
    }

    delete this;
    return 0;
}

STDMETHODIMP CMarkup::SetCallback(IUnknown* punk)
{
    if (_pMarkupCallback)
    {
        _pMarkupCallback->Release();
        _pMarkupCallback = NULL;
    }

    if (punk)
        return punk->QueryInterface(IID_PPV_ARG(IMarkupCallback, &_pMarkupCallback));


    // To break reference, pass NULL.
    return S_OK;
}

STDMETHODIMP CMarkup::GetCallback(REFIID riid, void** ppvUnk)
{
    if (_pMarkupCallback)
        return _pMarkupCallback->QueryInterface(riid, ppvUnk);

    return E_NOINTERFACE;
}


//  IControlMarkup interface implementation
STDMETHODIMP CMarkup::SetFocus()
{
    AssignTabFocus(0);
    _pMarkupCallback->InvalidateRect(NULL); 
    return S_OK;
}

STDMETHODIMP CMarkup::KillFocus()
{
    // Reset the focus position on request
    _iFocus=INVALID_LINK_INDEX;
    _pMarkupCallback->InvalidateRect(NULL); 
    return S_OK;
}

STDMETHODIMP CMarkup::IsTabbable()
{
    HRESULT hr = S_FALSE;
    int nDir  = TESTKEYSTATE(VK_SHIFT) ? -1 : 1;
    if (GetNextEnabledLink(_iFocus, nDir) != INVALID_LINK_INDEX)
    {
        hr = S_OK;
    }
    return hr;
}

//bugs: calculating ideal 'width' returns bogus valuez
STDMETHODIMP CMarkup::CalcIdealSize(HDC hdc, UINT uMarkUpCalc, RECT* prc)
{
    // prc is changed (prc.height or prc.width) only if hr = S_OK
    /* currently:
        MARKUPSIZE_CALCHEIGHT: takes an initial max width (right-left) and calculates
            and ideal height (bottom=ideal_height+top) and the actual width used, which
            is always less than the maximum (right=width_used+left).
        MARKUPSIZE_CALCWIDTH: doesn't do anything correctly. don't try it.              */

    HRESULT hr = E_FAIL;
    BOOL bQuitNow = FALSE;

    if (prc == NULL)
        return E_INVALIDARG;

    if (NULL != _rgBlocks && 0 != _cBlocks)
    {
        int   cyRet = -1;            
        SIZE  sizeDC;
        RECT  rc;

        if (uMarkUpCalc == MARKUPSIZE_CALCWIDTH)
        {
            //  Come up with a conservative estimate for the new width.
            sizeDC.cx = MulDiv(prc->right-prc->left, 1, prc->top-prc->bottom) * 2;            
            sizeDC.cy = prc->bottom - prc->top;
            if (sizeDC.cy < 0) 
            {
                bQuitNow = TRUE;
            }
        }

        if (uMarkUpCalc == MARKUPSIZE_CALCHEIGHT)
        {
            //  Come up with a conservative estimate for the new height.
            sizeDC.cy = MulDiv(prc->top-prc->bottom, 1, prc->right-prc->left) * 2;            
            sizeDC.cx = prc->right-prc->left;
            if (sizeDC.cx < 0) 
            {
                bQuitNow = TRUE;
            }
            // If no x size is specified, make a big estimate
            // (i.e. the estimate is the x size of the unparsed text)            
            if (sizeDC.cx == 0) 
            {
                if (!_hTheme)
                {
                    GetTextExtentPoint(hdc, _pszCaption, lstrlen(_pszCaption), &sizeDC);
                }

                if (_hTheme)
                {
                    // Get theme font size estimate for the larger part-font type
                    RECT rcTemp;
                    GetThemeTextExtent(_hTheme, hdc, _iThemePartId, _iThemeStateIdNormal, _pszCaption, -1, 0, NULL, &rcTemp);
                    sizeDC.cx = rcTemp.right - rcTemp.left;
                    GetThemeTextExtent(_hTheme, hdc, _iThemePartId, _iThemeStateIdLink, _pszCaption, -1, 0, NULL, &rcTemp);
                    if ((rcTemp.right - rcTemp.left) > sizeDC.cx)
                    {
                        sizeDC.cx = rcTemp.right - rcTemp.left;
                    }
                    
                }
            }
        }

        hr = E_FAIL;

        if (!bQuitNow)
        {
            int cyPrev = _cyIdeal;   // push ideal
            int cxPrev = _cxIdeal;

            SetRect(&rc, 0, 0, sizeDC.cx, sizeDC.cy);
            Paint(hdc, &rc, FALSE);

            // save the result
            hr = S_OK;

            if (uMarkUpCalc == MARKUPSIZE_CALCHEIGHT) 
            {
                prc->bottom = prc->top + _cyIdeal;
                prc->right = prc->left + _cxIdeal;
            }
            if (uMarkUpCalc == MARKUPSIZE_CALCWIDTH) 
            {
                // not implemented -- need to do              
            }
    
            _cyIdeal = cyPrev;       // pop ideal
            _cxIdeal = cxPrev;
        }                
    }

    if (FAILED(hr))
    {
        SetRect(prc, 0, 0, 0, 0);
    }
    return hr;
}

STDMETHODIMP CMarkup::SetLinkCursor()
{  
    SetCursor(GetLinkCursor());
    return S_OK;
}

STDMETHODIMP CMarkup::GetFonts(HFONT* phFont, HFONT* phFontUnderline)
{
    ASSERTMSG(IsBadWritePtr(phFont, sizeof(*phFont)), "Invalid phFont passed to CMarkup::GetFont");
    HRESULT hr = E_FAIL;
    *phFont = NULL;
    *phFontUnderline = NULL;
    
    if (_hfStatic)
    {
        LOGFONT lf;
        if (GetObject(_hfStatic, sizeof(lf), &lf))
        {
            *phFont = CreateFontIndirect(&lf);

            if (GetObject(_hfLink, sizeof(lf), &lf))
                *phFontUnderline = CreateFontIndirect(&lf);

            hr = S_OK;    
        }
    }
    return hr;
}

HRESULT CMarkup::SetFonts(HFONT hFont, HFONT hFontUnderline)
{
    HRESULT hr = S_FALSE;    

    _bRefreshText = TRUE;

    _hfStatic = hFont;

    _hfLink = hFontUnderline;

    if (_hfLink != NULL && _hfStatic != NULL) 
    {
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CMarkup::HandleEvent(BOOL keys, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    /* this function handles:
        WM_KEYDOWN
        WM_BUTTONDOWN
        WM_BUTTONUP
        WM_MOUSEMOVE
       pass it:
        keys - TRUE if you want to handle WM_KEYDOWN
        others - the params from the WndProc
       returns: S_OK if event handled, S_FALSE if no event handled */

    HRESULT hr = S_FALSE;

    if (!hwnd)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        switch (uMsg)
        {
            case WM_KEYDOWN:
            {
                if (keys==TRUE)
                {
                    OnKeyDown((UINT)wParam);
                    hr = S_OK;
                }
                break;
            }

            case WM_LBUTTONDOWN:
            {
                POINT pt;
                MakePoint(lParam, &pt);
                OnButtonDown(pt);
                hr = S_OK;
                break;
            }

            case WM_LBUTTONUP:
            {
                POINT pt;
                MakePoint(lParam, &pt);
                OnButtonUp(pt);
                hr = S_OK; 
                break;
            }

            case WM_MOUSEMOVE:
            {
                POINT pt;
                UINT pidLink;
                MakePoint(lParam, &pt);
                if (HitTest(pt, &pidLink) == S_OK) 
                {
                    SetLinkCursor();
                }

                hr = S_OK; 
                break;
            }
        }
    }
    return hr;
}

STDMETHODIMP CMarkup::DrawText(HDC hdcClient, LPCRECT prcClient)
{
    HRESULT hr = E_INVALIDARG;

    if (prcClient != NULL && hdcClient != NULL)
    {
        Paint(hdcClient, prcClient);
        hr = S_OK;   
    }
    return hr;
}

STDMETHODIMP CMarkup::GetText(BOOL bRaw, LPWSTR pwszText, DWORD *pcchText)
{
    // if passed pwszText==NULL, return the number of characters needed in pcchText
    if (!pwszText)
    {
        // for now, always return raw text, as it will always be larger than necessary
        *pcchText = lstrlen(_pszCaption)+1;
    }
    else
    {
        *pwszText = 0;

        if (bRaw)
        {
            if (_pszCaption)
            {
                lstrcpyn(pwszText, _pszCaption, *pcchText);
            }
        }
        else
        {
            for (TEXTBLOCK* pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
            {
                if (pBlock->pszText)
                    StrCatBuff(pwszText, pBlock->pszText, *pcchText);
            }
        }
        *pcchText = lstrlen(pwszText);
    }

    return S_OK;
}

STDMETHODIMP CMarkup::SetText(LPCWSTR pwszText)
{
    // Note: we don't reparse in the case of same strings
    if (pwszText && 0 == lstrcmp(pwszText, _pszCaption))
    {
        return S_FALSE; // nothing to do.
    }

    // set the text
    _bRefreshText = TRUE;

    if (_pszCaption)
    {
        LocalFree(_pszCaption);
        _pszCaption = NULL;
    }

    _iFocus = INVALID_LINK_INDEX;

    if (pwszText && *pwszText)
    {
        _pszCaption = StrDup(pwszText); // StrDup gets free'd with LocalFree
        if (_pszCaption)
        {
            Parse(pwszText);
        }
        else 
            return E_OUTOFMEMORY;
    }
    return S_OK;
}


STDMETHODIMP CMarkup::SetRenderFlags(UINT uDT)
{
    HRESULT hr = E_INVALIDARG;
    
    _bRefreshText = TRUE;

    // Set drawtext flags, but filter out unsupported modes
    _uDrawTextFlags = uDT;
    _uDrawTextFlags &= ~(DT_CALCRECT | DT_INTERNAL | DT_NOCLIP | DT_NOFULLWIDTHCHARBREAK | DT_EDITCONTROL);

    // Turn off themedraw
    _hTheme = NULL;

    hr = S_OK;

    return hr;        
}

STDMETHODIMP CMarkup::SetThemeRenderFlags(UINT uDT, HTHEME hTheme, int iPartId, int iStateIdNormal, int iStateIdLink)
{
    HRESULT hr = SetRenderFlags(uDT);
    if (hr == S_OK)
    {
        // Turn on themedraw
        _hTheme = hTheme;
        _iThemePartId = iPartId;
        _iThemeStateIdNormal = iStateIdNormal;
        _iThemeStateIdLink = iStateIdLink;
    }

    return hr;        
}

HRESULT CMarkup::GetRenderFlags(UINT *puDT, HTHEME *phTheme, int *piPartId, int *piStateIdNormal, int *piStateIdLink)
{
    *puDT = _uDrawTextFlags;
    *phTheme = _hTheme;
    *piPartId = _iThemePartId;
    *piStateIdNormal = _iThemeStateIdNormal;
    *piStateIdLink  = _iThemeStateIdLink;

    return S_OK;
}



//  WM_KEYDOWN handler - exposed as COM
STDMETHODIMP CMarkup::OnKeyDown(UINT virtKey)
{
    // returns: S_FALSE unless key handled, then S_OK
    // (so if you pass a VK_TAB and it isn't handled, pass on focus)
    HRESULT hr = S_FALSE;

    switch(virtKey)
    {
        case VK_TAB:
            if (WantTab(&_iFocus))
            {                
                hr = S_OK;
            }
            _pMarkupCallback->InvalidateRect(NULL); 
            break;
        
        case VK_RETURN:
        case VK_SPACE:
        {
            TEXTBLOCK * pBlock = FindLink(_iFocus);
            if (pBlock)
            {               
                DoNotify (MARKUPMESSAGE_KEYEXECUTE, _iFocus);
                hr = S_OK;
            }
        }
        break;
    }

    return hr;
}

HRESULT CMarkup::OnButtonDown(const POINT pt)
{
    // returns: S_FALSE unless button down on link, then S_OK
    // note: OnButtonDown no longer turns on capturing all mouse events. Not sure if this will have any negative effect.

    HRESULT hr = S_FALSE;

    UINT iLink;

    if (HitTest(pt, &iLink) == S_OK)
    {
        hr = S_OK; 
        SetLinkCursor();
        _iFocus = iLink;               
        _bButtonDown = TRUE;
        
        if (! (IsFocused()))
        {   
            /* this is our way of telling the host we want focus. */
            DoNotify (MARKUPMESSAGE_WANTFOCUS, _iFocus); 
        }        
        _pMarkupCallback->InvalidateRect(NULL);
    }

    return hr;
}

HRESULT CMarkup::OnButtonUp(const POINT pt)
{
    // returns: S_FALSE unless notification sent, then S_OK
    HRESULT hr = S_FALSE;

    if (_bButtonDown == TRUE)
    {
        _bButtonDown = FALSE;
       
        //  if the focus link contains the point, we can 
        //  notify the callback of a click event.
        INT iHit;
        HitTest(pt, (UINT*) &iHit);
        TEXTBLOCK* pBlock = FindLink(_iFocus);
        if (pBlock && 
            (pBlock->state & LIS_ENABLED) != 0 &&
            _iFocus == iHit)
        {
            hr = S_OK;
            DoNotify (MARKUPMESSAGE_CLICKEXECUTE, _iFocus);
        }
    }
    
    return hr;
}

HRESULT CMarkup::HitTest(const POINT pt, UINT* pidLink)
{
    // returns S_OK only if pidLink is not INVALID_LINK_INDEX
    HRESULT hr = S_FALSE;
    *pidLink = INVALID_LINK_INDEX;

    //  Walk blocks until we find a link rect that contains the point
    TEXTBLOCK* pBlock;
    for(pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
    {
        if (IS_LINK(pBlock) && (pBlock->state & LIS_ENABLED)!=0)
        {
            RECTLISTENTRY* prce;
            for(prce = pBlock->rgrle; prce; prce = prce->next)
            {
                if (PtInRect(&prce->rc, pt))
                {
                    hr = S_OK;
                    *pidLink = pBlock->iLink;
                }
            }
        }
    }
    return hr;
}

HRESULT CMarkup::SetLinkText(int iLink, UINT uMarkupLinkText, LPCWSTR pwszText)
{
    HRESULT     hr = E_INVALIDARG;
    TEXTBLOCK*  pBlock = FindLink(iLink);

    if (pBlock)
    {
        hr = S_OK;

        switch (uMarkupLinkText)
        {
            case MARKUPLINKTEXT_ID:
                lstrcpyn(pBlock->szID, pwszText, ARRAYSIZE(pBlock->szID));
                break;

            case MARKUPLINKTEXT_URL:
                Str_SetPtr(&pBlock->pszUrl, pwszText); 
                break;

            case MARKUPLINKTEXT_TEXT:
                Str_SetPtr(&pBlock->pszText, pwszText); 
                break;
            default:
                hr = S_FALSE;
                break;
        }
    }

    return hr;
}

HRESULT CMarkup::GetLinkText(int iLink, UINT uMarkupLinkText, LPWSTR pwszText, DWORD *pdwCch)
{
    HRESULT hr = E_INVALIDARG;
    TEXTBLOCK*  pBlock = FindLink(iLink);

    if (pBlock)
    {
        LPCTSTR pszSource;

        switch (uMarkupLinkText)
        {
            case MARKUPLINKTEXT_ID:
                pszSource = pBlock->szID;
                hr = S_OK;
                break;

            case MARKUPLINKTEXT_URL:
                pszSource = pBlock->pszUrl; 
                hr = S_OK;
                break;

            case MARKUPLINKTEXT_TEXT:
                pszSource = pBlock->pszText; 
                hr = S_OK;
                break;
        }
        if (hr == S_OK)
        {
            if (pwszText)
            {
                if (pszSource == NULL)
                    pszSource = TEXT("");
                lstrcpyn(pwszText, pszSource, *pdwCch);
                *pdwCch = lstrlen(pwszText);            // fill in number of characters actually copied
            }
            else
                *pdwCch = lstrlen(pszSource)+1;           // fill in number of characters needed, including NULL
        }

    }

    return hr;
}

#define MARKUPSTATE_VALID (MARKUPSTATE_ENABLED | MARKUPSTATE_VISITED | MARKUPSTATE_FOCUSED)

HRESULT CMarkup::SetState(int iLink, UINT uStateMask, UINT uState)
{
    BOOL        bRedraw = FALSE;
    HRESULT     hr = E_FAIL;
    TEXTBLOCK*  pBlock = FindLink(iLink);
    
    if (uStateMask & ~MARKUPSTATE_VALID)
        return E_INVALIDARG;

    if (pBlock)
    {
        hr = S_OK;
        if (uStateMask & MARKUPSTATE_ENABLED)
        {
            bRedraw |= _AssignBit(MARKUPSTATE_ENABLED, pBlock->state, uState);            
            int  cEnabledLinks = StateCount(MARKUPSTATE_ENABLED, MARKUPSTATE_ENABLED);
        }

        if (uStateMask & MARKUPSTATE_VISITED)
        {
            bRedraw |= _AssignBit(MARKUPSTATE_VISITED, pBlock->state, uState);
        }

        if (uStateMask & MARKUPSTATE_FOCUSED)
        {
            //  Focus assignment is handled differently;
            //  one and only one link can have focus...
            if (uState & MARKUPSTATE_FOCUSED)
            {
                bRedraw |= (_iFocus != iLink);
                _iFocus = iLink;
            }
            else
            {
                bRedraw |= (_iFocus == iLink);
                _iFocus = INVALID_LINK_INDEX;
            }
        }
    }

    if (bRedraw)
    {
        _pMarkupCallback->InvalidateRect(NULL);        
    }

    return hr;
}

HRESULT CMarkup::GetState(int iLink, UINT uStateMask, UINT* puState)
{
    HRESULT hr = E_FAIL;
    TEXTBLOCK*  pBlock = FindLink(iLink);

    if (pBlock && puState != NULL)
    {
        hr = S_FALSE;
        *puState = 0;
        if (uStateMask & MARKUPSTATE_FOCUSED)
        {
            if (_iFocus == iLink)
                *puState |= MARKUPSTATE_FOCUSED;
            hr = S_OK;
        }

        if (uStateMask & MARKUPSTATE_ENABLED)
        {
            if (pBlock->state & MARKUPSTATE_ENABLED)
                *puState |= MARKUPSTATE_ENABLED;
            hr = S_OK;
        }

        if (uStateMask & MARKUPSTATE_VISITED)
        {
            if (pBlock->state & MARKUPSTATE_VISITED)
                *puState |= MARKUPSTATE_VISITED;
            hr = S_OK;
        }
    }

    return hr;
}


//-------------------------------------------------------------------------//
//  CMarkup internal implementation
//-------------------------------------------------------------------------//

void CMarkup::FreeBlocks()
{
    for(TEXTBLOCK* pBlock = _rgBlocks; pBlock; )
    {
        TEXTBLOCK* pNext = pBlock->next;
        delete pBlock;
        pBlock = pNext;
    }
    _rgBlocks = NULL;
    _cBlocks = _Markups = 0;
}

TEXTBLOCK* CMarkup::CreateBlock(LPCTSTR pszStart, LPCTSTR pszEnd, int iLink)
{
    TEXTBLOCK* pBlock = NULL;
    int cch = (int)(pszEnd - pszStart) + 1;
    if (cch > 0)
    {
        pBlock = new TEXTBLOCK;
        if (pBlock)
        {
            pBlock->pszText = new TCHAR[cch];
            if (pBlock->pszText == NULL)
            {
                delete pBlock;
                pBlock = NULL;
            }
            else
            {
                lstrcpyn(pBlock->pszText, pszStart, cch);
                pBlock->iLink = iLink;
            }
        }
    }
    return pBlock;
}

HCURSOR CMarkup::GetLinkCursor()
{
    if (!_hcurHand)
    {
        _hcurHand = LoadCursor(NULL, IDC_HAND);
    }

    return _hcurHand;
}

HRESULT CMarkup::_GetNextAnchorTag(LPCTSTR * ppszBlock, int * pcBlocks, LPTSTR pszURL, int cchSize, LPTSTR pszID, int cchID)
{
    HRESULT hr = E_FAIL;
    LPTSTR pszStartOfTag;
    LPTSTR pszIterate = (LPTSTR)*ppszBlock;
    LPTSTR pszStartTry = (LPTSTR)*ppszBlock;    // We start looking for "<A" at the beginning.

    pszURL[0] = 0;
    pszID[0] = 0;

    // While we find a possible start of a tag.
    while ((pszStartOfTag = StrStrI(pszStartTry, LINKTAG1)) != NULL)
    {
        // See if the rest of the string completes the tag.
        pszIterate = pszStartOfTag;
        pszStartTry = CharNext(pszStartOfTag);    // Do this so the while loop will end when we finish don't find any more "<A".

        if (pszIterate[0])
        {
            pszIterate += cchLINKTAG1;  // Skip past the start of the tag.

            // Walk thru the Value/Data pairs in the tag
            TCHAR szValue[MAX_PATH];
            TCHAR szData[L_MAX_URL_LENGTH];

            pszIterate = SkipWhite(pszIterate);     // SkipWhiteSpace
            while ((CH_ENDTAG != pszIterate[0]) &&
                    SUCCEEDED(_GetNextValueDataPair(&pszIterate, szValue, ARRAYSIZE(szValue), szData, ARRAYSIZE(szData))))
            {
                if (0 == StrCmpI(szValue, SZ_ATTRIBUTE_HREF))
                {
                    StrCpyN(pszURL, szData, cchSize);
                }
                else if (0 == StrCmpI(szValue, SZ_ATTRIBUTE_ID))
                {
                    StrCpyN(pszID, szData, cchID);
                }
                else
                {
                    // We ignore other pairs in order to be back-compat with future
                    // supported attributes.
                }

                pszIterate = SkipWhite(pszIterate);
            }

            if (CH_ENDTAG == pszIterate[0])
            {
                hr = S_OK;
            }
        }

        if (SUCCEEDED(hr))
        {
            //  Add run between psz1 and pszBlock as static text
            if (pszStartOfTag > *ppszBlock)
            {
                TEXTBLOCK * pBlock = CreateBlock(*ppszBlock, pszStartOfTag, INVALID_LINK_INDEX);
                if (NULL != pBlock)
                {
                    Add(pBlock);
                    (*pcBlocks)++;
                }
            }
        
            *ppszBlock = CharNext(pszIterate);  // Skip past the tag's ">"
            // We found an entire tag.  Stop looking.
            break;
        }
        else
        {
            // The "<A" we tried wasn't a valid tag.  Are we at the end of the string?
            // If not, let's keep looking for other "<A" that may be valid.
        }
    }

    return hr;
}

void CMarkup::Parse(LPCTSTR pszText)
{
    TEXTBLOCK*  pBlock;
    int         cBlocks = 0, Markups  = 0;
    LPCTSTR     psz1, psz2, pszBlock;
    LPTSTR      pszBuf = NULL;

    FreeBlocks(); // free existing blocks
    
    pszBuf = (LPTSTR)pszText;
    
    if (!(pszBuf && *pszBuf))
    {
        goto exit;
    }

    for(pszBlock = pszBuf; pszBlock && *pszBlock;)
    {
        TCHAR szURL[L_MAX_URL_LENGTH];
        TCHAR szID[MAX_LINKID_TEXT];

        //  Search for "<a>" tag
        if (IsMarkupAllowed() &&
            SUCCEEDED(_GetNextAnchorTag(&pszBlock, &cBlocks, szURL, ARRAYSIZE(szURL), szID, ARRAYSIZE(szID))))
        {
            psz1 = pszBlock;    // After _GetNextAnchorTag(), pszBlock points to the char after the start tag.
            if (psz1 && *psz1)
            {
                if ((psz2 = StrStrI(pszBlock, LINKTAG2)) != NULL)
                {
                    if ((pBlock = CreateBlock(psz1, psz2, Markups)) != NULL)
                    {
                        if (szURL[0])
                        {
                            Str_SetPtr(&pBlock->pszUrl, szURL);
                        }
                        if (szID[0])
                        {
                            StrCpyN(pBlock->szID, szID, ARRAYSIZE(pBlock->szID));
                        }

                        Add(pBlock);
                        cBlocks++;
                        Markups++;
                    }

                    //  safe-skip over tag
                    for(int i = 0; 
                         i < cchLINKTAG2 && psz2 && *psz2; 
                         i++, psz2 = CharNext(psz2));

                    pszBlock = psz2;
                }
                else // syntax error; mark trailing run is static text.
                {
                    psz2 = pszBlock + lstrlen(pszBlock);
                    if ((pBlock = CreateBlock(psz1, psz2, INVALID_LINK_INDEX)) != NULL)
                    {
                        Add(pBlock);
                        cBlocks++;
                    }
                    pszBlock = psz2;
                }
            }
        }
        else // no more tags.  Mark the last run of static text
        {
            psz2 = pszBlock + lstrlen(pszBlock);
            if ((pBlock = CreateBlock(pszBlock, psz2, INVALID_LINK_INDEX)) != NULL)
            {
                Add(pBlock);
                cBlocks++;
            }
            pszBlock = psz2;
        }
    }

    ASSERT(cBlocks == _cBlocks);
    ASSERT(Markups  == _Markups);

exit:
    if (!pszText && pszBuf) // delete text buffer if we had alloc'd it.
    {
        delete [] pszBuf;
    }
}

BOOL CMarkup::Add(TEXTBLOCK* pAdd)
{
    BOOL bAdded = FALSE;
    pAdd->next = NULL;

    if (!_rgBlocks)    
    {
        _rgBlocks = pAdd;
        bAdded = TRUE;
    }
    else   
    {    
        for(TEXTBLOCK* pBlock = _rgBlocks; pBlock && !bAdded; pBlock = pBlock->next) 
        {
            if (!pBlock->next)
            {
                pBlock->next = pAdd;
                bAdded = TRUE;
            }
        }
    }

    if (bAdded)   
    {
        _cBlocks++;
        if (IS_LINK(pAdd))
        {
            _Markups++;
        }
    }

    return bAdded;
}

TEXTBLOCK*  CMarkup::FindLink(int iLink) const
{
    if (iLink == INVALID_LINK_INDEX)
    {
        return NULL;
    }

    for(TEXTBLOCK* pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
    {
        if (IS_LINK(pBlock) && pBlock->iLink == iLink)
            return pBlock;
    }
    return NULL;
}

// NOTE: optimizatation! skip drawing loop when called for calcrect!
void CMarkup::Paint(HDC hdcClient, LPCRECT prcClient, BOOL bDraw)
{    
    HDC             hdc = hdcClient; 
    COLORREF        rgbOld = GetTextColor(hdc);  // save text color
    HFONT           hFontOld = (HFONT) GetCurrentObject(hdc, OBJ_FONT);
    TEXTBLOCK*      pBlock;
    BOOL            fFocus = IsFocused();
    if (_cBlocks == 1)
    {
        pBlock = _rgBlocks;
        HFONT hFont = _hfStatic;

        pBlock->FreeRects();   // free hit/focus rects; we're going to recompute.
        

        if (IS_LINK(pBlock))
        {
            SetTextColor(hdc, (pBlock->state & LIS_ENABLED) ? LINKCOLOR_ENABLED : LINKCOLOR_DISABLED);
            hFont = _hfLink;
        }

        if (hFont) 
        {
            SelectObject(hdc, hFont);
        }

        RECT rc = *prcClient;
        int cch =  lstrlen(pBlock->pszText);

        ThemedDrawText(hdc, pBlock->pszText, cch, &rc, _uDrawTextFlags | DT_CALCRECT, IS_LINK(pBlock));

        pBlock->AddRect(rc, 0, cch, 0);

        _cyIdeal = RECTHEIGHT(rc);
        _cxIdeal = RECTWIDTH(rc);
        
        if (bDraw)
        {
            ThemedDrawText(hdc, pBlock->pszText, cch, &rc, _uDrawTextFlags, IS_LINK(pBlock));

            if (fFocus)
            {
                SetTextColor(hdc, rgbOld);   // restore text color
			    DrawFocusRect(hdc, &rc);
            }
        }
    }
    else
    {
        TEXTMETRIC      tm;
        int             iLineWidth[255]; // line index offset   
        int             iLine = 0,  // current line index         
                        cyLine = 0, // line height.
                        cyLeading = 0, // internal leading
                        _cchOldDrawn = 1; // get out of infinite loop if window too small t-jklann
        RECT            rcDraw = *prcClient;             // initialize line rect
        _cxIdeal = 0;

        // Initialize iLineWidth (just index 0, others init on use)
        iLineWidth[0]=0;
    
        //  Get font metrics into cyLeading
        if (!_hTheme)
        {
            SelectObject(hdc, _hfLink);
            GetTextMetrics(hdc, &tm);
            if (tm.tmExternalLeading > cyLeading)
            {
                cyLeading = tm.tmExternalLeading;
            }
            SelectObject(hdc, _hfStatic);
            GetTextMetrics(hdc, &tm);
            if (tm.tmExternalLeading > cyLeading)
            {
                cyLeading = tm.tmExternalLeading;
            }
        }
        else
        {
            GetThemeTextMetrics(_hTheme, hdc, _iThemePartId, _iThemeStateIdNormal, &tm);
            if (tm.tmExternalLeading > cyLeading)
            {
                cyLeading = tm.tmExternalLeading;
            }
            GetThemeTextMetrics(_hTheme, hdc, _iThemePartId, _iThemeStateIdLink, &tm);
            if (tm.tmExternalLeading > cyLeading)
            {
                cyLeading = tm.tmExternalLeading;
            }
        }

        // Save us a lot of time if text hasn't changed...
        if (_bRefreshText == TRUE || !EqualRect(&_rRefreshRect, prcClient))
        {
            UINT uDrawTextCalc = _uDrawTextFlags | DT_CALCRECT | DT_SINGLELINE;
            uDrawTextCalc &= ~(DT_CENTER | DT_LEFT | DT_RIGHT | DT_VCENTER | DT_BOTTOM);

            BOOL bKillingLine = FALSE;

            //  For each block of text (calculation loop)...
            for(pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
            {
                //  font select (so text will draw correctly)
                if (!_hTheme)
                {
                    BOOL bLink = IS_LINK(pBlock);
                    HFONT hFont = bLink ? _hfLink : _hfStatic;
                    if (hFont) 
                    {
                        SelectObject(hdc, hFont);
                    }
                }
                
                int  cchDraw = lstrlen(pBlock->pszText); // chars to draw, this block
                int  cchDrawn = 0;  // chars to draw, this block
                LPTSTR pszText = &pBlock->pszText[cchDrawn];
                LPTSTR pszTextOriginal = &pBlock->pszText[cchDrawn];

                pBlock->FreeRects();   // free hit/focus rects; we're going to recompute.
        
                //  while text remains in this block...
                _cchOldDrawn = 1;
                while(cchDraw > 0 && !((_uDrawTextFlags & DT_SINGLELINE) && (iLine>0)))
                {
                    //  compute line height and maximum text width to rcBlock
                    RECT rcBlock;
                    int  cchTry = cchDraw;            
                    int  cchTrySave = cchTry;
                    int  cchBreak = 0;          
                    int  iLineBreakSize;
                    BOOL bRemoveBreak = FALSE;
                    BOOL bRemoveLineBreak = FALSE;
                    RECT rcCalc; 
                    CopyRect(&rcCalc, &rcDraw);

                    // support multiline text phrases                   
                    bRemoveLineBreak = _FindFirstLineBreak(pszText, cchTry, &cchBreak, &iLineBreakSize);
                    if (bRemoveLineBreak)
                    {
                        cchTry = cchBreak;                  
                    }                   

                    // find out how much we can fit on this line within the rectangle
                    // calc rect breaking at breakpoints (or -1 char) until rectangle fits inside drawing rect.
                    for(;;)
                    {
                        // choose codepath: themes or normal drawtext (no exttextout path)
                    
                        // now we use drawtext to preserve formatting options (tabs/underlines)                                                                         
                        ThemedDrawText(hdc, pszText, cchTry, &rcCalc, uDrawTextCalc, IS_LINK(pBlock));                 
                        cyLine = RECTHEIGHT(rcCalc);

                        // special case: support \n as only character on line (we need a valid line width & length)
                        if (cchTry == 0 && bRemoveLineBreak==TRUE)
                        {
                            // these two lines adjust drawing to within a valid range when the \n is barely cut off
                            rcCalc.left = prcClient->left; 
                            rcCalc.right = prcClient->right;
                            cyLine = ThemedDrawText(hdc, TEXT("a"), 1, &rcCalc, uDrawTextCalc, IS_LINK(pBlock));                    
                                // the "a" could be any text. It exists because passing "\n" to DrawText doesn't return a valid line height.
                            rcCalc.right = rcCalc.left;
                        }

                        if (RECTWIDTH(rcCalc) > RECTWIDTH(rcDraw))
                        {
                            // too big
                            cchTrySave = cchTry;
                            BOOL fBreak = _FindLastBreakChar(pszText, cchTry, tm.tmBreakChar, &cchTry, &bRemoveBreak);

                            // case that our strings ends with a valid break char
                            if (cchTrySave == cchTry && cchTry > 0) 
                            {
                                cchTry--;
                            }

                            // this code allows character wrapping instead of just word wrapping.
                            // keep it in case we want to change the behavior.
                            if (!fBreak && prcClient->left == rcDraw.left)
                            {
                                // no break character found, so force a break if we can.
                                if (cchTrySave > 0) 
                                {
                                    cchTry = cchTrySave - 1;
                                }
                            }
                            if (cchTry > 0)
                            {
                                continue;
                            }
                        }
                        break;
                    }
                                    
                    // if our line break got clipped, turn off line break..
                    if (bRemoveLineBreak && cchBreak > cchTry)
                    {
                        bRemoveLineBreak = FALSE;
                    }
                
                    // Count the # chars drawn, account for clipping
                    cchDrawn = cchTry;
                    if ((cchTry < cchDraw) && bRemoveLineBreak) 
                    {
                        cchDrawn+=iLineBreakSize;
                    }

                    // DT_WORDBREAK off support
                    // Kill this line if bKillingLine is true; i.e. pretend we drew it, but do nothing
                    if (bKillingLine)
                    {
                        pszText += cchDrawn;
                    }
                    else
                    {
                        //  initialize drawing rectangle and block rectangle
                        SetRect(&rcBlock, rcCalc.left , 0, rcCalc.right , RECTHEIGHT(rcCalc));                           
                        rcDraw.right  = min(rcDraw.left + RECTWIDTH(rcBlock), prcClient->right);
                        rcDraw.bottom = rcDraw.top + cyLine;

                        //  Add rectangle to block's list and update line width and ideal x width
                        // (Only if we're actually going to draw this line, though)
                        if (cchTry)
                        {
                            // DT_SINGLELINE support
                            if (!((_uDrawTextFlags & DT_SINGLELINE) == DT_SINGLELINE) || (iLine == 0))
                            {
                                pBlock->AddRect(rcDraw, (UINT) (pszText-pszTextOriginal), cchDrawn, iLine);
                            }
                            iLineWidth[iLine] = max(iLineWidth[iLine], rcDraw.left - prcClient->left + RECTWIDTH(rcBlock));                 
                            _cxIdeal = max(_cxIdeal, iLineWidth[iLine]);
                        }

                        if (cchTry < cchDraw) // we got clipped
                        {
                            if (bRemoveBreak) 
                            {
                                cchDrawn++;
                            }
                            pszText += cchDrawn;

                            // advance to next line and init next linewidth
                            iLine++;
                            iLineWidth[iLine]=0;                        

                            // t-jklann 6/00: added support for line wrap in displaced text (left&top)
                            rcDraw.left = prcClient->left;
                            if (!(_uDrawTextFlags & DT_SINGLELINE))
                            {
                                rcDraw.top  = prcClient->top + iLine * cyLine;                      
                            }
                            else
                            {
                                rcDraw.top  = prcClient->top;                                                   
                            }
                            rcDraw.bottom = rcDraw.top + cyLine + cyLeading;
                            rcDraw.right = prcClient->right;
                        }
                        else //  we were able to draw the entire text
                        {
                            //  adjust drawing rectangle
                            rcDraw.left += RECTWIDTH(rcBlock);
                            rcDraw.right = prcClient->right;
                        }
                    
                        // Update ideal y width
                        _cyIdeal = rcDraw.bottom - prcClient->top;
                    }

                    // support for: DT_WORDBREAK turned off
                    // Kill the next line if we got clipped and there's no wordbreak
                    if (((_uDrawTextFlags & DT_WORDBREAK) != DT_WORDBREAK))
                    {
                        if (cchTry < cchDraw )
                        {
                            bKillingLine = TRUE;
                        }
                        if (bRemoveLineBreak)
                        {
                            bKillingLine = FALSE;
                        }
                    } 

                    // Update calculation of chars drawn
                    cchDraw -= cchDrawn;

                    // bug catch: get out if we really can't draw
                    if (_cchOldDrawn == 0 && cchDrawn == 0) 
                    { 
                        iLine--; 
                        rcDraw.top = prcClient->top + iLine * cyLine; 
                        cchDraw = 0; 
                    } 
                    _cchOldDrawn = cchDrawn; 
                }
            }

            // Handle justification issues (DT_VCENTER, DT_TOP, DT_BOTTOM)
            if (((_uDrawTextFlags & DT_SINGLELINE) == DT_SINGLELINE) &&
                 ((_uDrawTextFlags & (DT_VCENTER | DT_BOTTOM)) > 0)) 
            {
                // Calc offset
                int cyOffset = 0;
                if ((_uDrawTextFlags & DT_VCENTER) == DT_VCENTER)
                {
                    cyOffset = (RECTHEIGHT(*prcClient) - _cyIdeal)/2;           
                }
                if ((_uDrawTextFlags & DT_BOTTOM) == DT_BOTTOM)
                {
                    cyOffset = (RECTHEIGHT(*prcClient) - _cyIdeal);         
                }
        
                // Offset every rectangle
                for(pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
                {
                    for(RECTLISTENTRY* prce = pBlock->rgrle; prce; prce = prce->next)
                    {
                        prce->rc.top += cyOffset;
                        prce->rc.bottom += cyOffset;
                    }
                }   
            }

            // Handle justification issues (DT_CENTER, DT_LEFT, DT_RIGHT)
            if (((_uDrawTextFlags & DT_CENTER) == DT_CENTER) || ((_uDrawTextFlags & DT_RIGHT) == DT_RIGHT))
            {
                // Step 1: turn iLineWidth into an offset vector
                for (int i = 0; i <= iLine; i++)
                {
                    if (RECTWIDTH(*prcClient) > iLineWidth[i])
                    {
                        if ((_uDrawTextFlags & DT_CENTER) == DT_CENTER)  
                        {                       
                            iLineWidth[i] = (RECTWIDTH(*prcClient)-iLineWidth[i])/2;
                        }
                        if ((_uDrawTextFlags & DT_RIGHT) == DT_RIGHT)  
                        {
                            iLineWidth[i] = (RECTWIDTH(*prcClient)-iLineWidth[i]);
                        }                           
                    }
                    else
                    {
                        iLineWidth[i] = 0;
                    }
                }

                // Step 2: offset every rect-angle
                for(pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
                {
                    for(RECTLISTENTRY* prce = pBlock->rgrle; prce; prce = prce->next)
                    {
                        prce->rc.left += iLineWidth[prce->uLineNumber];
                        prce->rc.right += iLineWidth[prce->uLineNumber];
                    }
                }   
            }

            CopyRect(&_rRefreshRect, prcClient);
            _bRefreshText = FALSE;
        }

        if (bDraw)
        {
            //  For each block of text (drawing loop)...    
            UINT uDrawTextDraw = _uDrawTextFlags | DT_SINGLELINE;
            uDrawTextDraw &= ~(DT_CENTER | DT_LEFT | DT_RIGHT | DT_CALCRECT | DT_VCENTER | DT_BOTTOM);
            LRESULT dwCustomDraw=0;
            _pMarkupCallback->OnCustomDraw(CDDS_PREPAINT, hdc, prcClient, 0, 0, &dwCustomDraw);

            for(pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
            {
                BOOL bLink = IS_LINK(pBlock);
                BOOL bEnabled = pBlock->state & LIS_ENABLED;

                //  font select                            
                if (!_hTheme)
                {
                    HFONT hFont = bLink ? _hfLink : _hfStatic;
                    if (hFont) 
                    {
                        SelectObject(hdc, hFont);
                    }
                }

                //  initialize foreground color
                if (!_hTheme)
                {
                    if (bLink)
                    {
                        SetTextColor(hdc, bEnabled ? LINKCOLOR_ENABLED : LINKCOLOR_DISABLED);
                    }
                    else
                    {
                        SetTextColor(hdc, rgbOld);   // restore text color
                    }
                }
                if (dwCustomDraw & CDRF_NOTIFYITEMDRAW)
                {
                    _pMarkupCallback->OnCustomDraw(CDDS_ITEMPREPAINT, hdc, NULL, pBlock->iLink, bEnabled ? CDIS_DEFAULT : CDIS_DISABLED, NULL);
                }

                //  draw the text 
                LPTSTR pszText = pBlock->pszText;
                LPTSTR pszTextOriginal = pBlock->pszText;

                for(RECTLISTENTRY* prce = pBlock->rgrle; prce; prce = prce->next)
                {
                    RECT rc = prce->rc; 
                    pszText = pszTextOriginal + prce->uCharStart;
                    ThemedDrawText(hdc, pszText, prce->uCharCount, &rc, uDrawTextDraw, IS_LINK(pBlock));
                }

                //  Draw focus rect(s)
                if (fFocus && pBlock->iLink == _iFocus && IS_LINK(pBlock))
                {
                    SetTextColor(hdc, rgbOld);   // restore text color
				    for(RECTLISTENTRY* prce = pBlock->rgrle; prce; prce = prce->next)
				    {
					    DrawFocusRect(hdc, &prce->rc);
				    }
                }

                if (dwCustomDraw & CDRF_NOTIFYITEMDRAW)
                {
                    _pMarkupCallback->OnCustomDraw(CDDS_ITEMPOSTPAINT, hdc, NULL, pBlock->iLink, bEnabled ? CDIS_DEFAULT : CDIS_DISABLED, NULL);
                }
            }
            if (dwCustomDraw & CDRF_NOTIFYPOSTPAINT)
            {
                _pMarkupCallback->OnCustomDraw(CDDS_POSTPAINT, hdc, NULL, 0, 0, NULL);
            }
        }    
    }

    SetTextColor(hdc, rgbOld);   // restore text color

    if (hFontOld)
    {
        SelectObject(hdc, hFontOld);
    }
}

int CMarkup::GetNextEnabledLink(int iStart, int nDir) const
{
    ASSERT(-1 == nDir || 1 == nDir);

    if (_Markups > 0)
    {
        if (INVALID_LINK_INDEX == iStart)
        {
            iStart = nDir > 0 ? -1 : _Markups;
        }

        for(iStart += nDir; iStart >= 0; iStart += nDir)
        {
            TEXTBLOCK* pBlock = FindLink(iStart);
            if (!pBlock)
            {
                return INVALID_LINK_INDEX;
            }

            if (pBlock->state & LIS_ENABLED)
            {
                ASSERT(iStart == pBlock->iLink);
                return iStart;
            }
        }
    }
    return INVALID_LINK_INDEX;
}

int CMarkup::StateCount(DWORD dwStateMask, DWORD dwState) const
{
    TEXTBLOCK* pBlock;
    int cnt = 0;

    for(pBlock = _rgBlocks; pBlock; pBlock = pBlock->next)
    {
        if (IS_LINK(pBlock) && 
            (pBlock->state & dwStateMask) == dwState)
        {
            cnt++;
        }
    }
    return cnt;
}

BOOL CMarkup::WantTab(int* biFocus) const
{
    int nDir  = TESTKEYSTATE(VK_SHIFT) ? -1 : 1;
    int iFocus = GetNextEnabledLink(_iFocus, nDir);

    if (INVALID_LINK_INDEX != iFocus)
    {
        if (biFocus)
        {
            *biFocus = iFocus;
        }
        return TRUE;
    }
    else 
    {
        // if we can't handle the focus, prepare for the next round
        //iFocus = GetNextEnabledLink(-1, nDir);
        *biFocus = -1;
        return FALSE;
    }
}

void CMarkup::AssignTabFocus(int nDirection)
{
    if (_Markups)
    {
        if (0 == nDirection)
        {
            if (INVALID_LINK_INDEX != _iFocus)
            {
                return;
            }
            nDirection = 1;
        }
        _iFocus = GetNextEnabledLink(_iFocus, nDirection);
    }
}

//-------------------------------------------------------------------------//
TEXTBLOCK::TEXTBLOCK()
    :   iLink(INVALID_LINK_INDEX), 
        next(NULL), 
        state(LIS_ENABLED),
        pszText(NULL),
        pszUrl(NULL),
        rgrle(NULL)
{
    *szID = 0;
}

TEXTBLOCK::~TEXTBLOCK()
{
    //  free block text
    Str_SetPtr(&pszText, NULL);
    Str_SetPtr(&pszUrl, NULL);

    //  free rectangle(s)
    FreeRects();
}

void TEXTBLOCK::AddRect(const RECT& rc, UINT uMyCharStart, UINT uMyCharCount, UINT uMyLineNumber)
{
    RECTLISTENTRY* prce;
    if ((prce = new RECTLISTENTRY) != NULL)
    {
        CopyRect(&(prce->rc), &rc);
        prce->next = NULL;
        prce->uCharStart = uMyCharStart;
        prce->uCharCount = uMyCharCount;
        prce->uLineNumber = uMyLineNumber;
    }

    if (rgrle == NULL)
    {
        rgrle = prce;
    }
    else
    {
        for(RECTLISTENTRY* p = rgrle; p; p = p->next)
        {
            if (p->next == NULL)
            {
                p->next = prce;
                break;
            }
        }
    }
}

void TEXTBLOCK::FreeRects()
{
    for(RECTLISTENTRY* p = rgrle; p;)
    {
        RECTLISTENTRY* next = p->next;
        delete p;
        p = next;
    }
    rgrle = NULL;
}

//-------------------------------------------------------------------------//
// t-jklann 6/00: added these formerly global methods to the CMarkup class

// Returns a pointer to the first non-whitespace character in a string.
LPTSTR CMarkup::SkipWhite(LPTSTR lpsz)
{
    /* prevent sign extension in case of DBCS */
    while (*lpsz && (TUCHAR)*lpsz <= TEXT(' '))
        lpsz++;

    return(lpsz);
}

BOOL CMarkup::_AssignBit(const DWORD dwBit, DWORD& dwDest, const DWORD dwSrc)  // returns TRUE if changed
{
    if (((dwSrc & dwBit) != 0) != ((dwDest & dwBit) != 0))
    {
        if (((dwSrc & dwBit) != 0))
        {
            dwDest |= dwBit;
        }
        else
        {
            dwDest &= ~dwBit;
        }
        return TRUE;
    }
    return FALSE;
}

BOOL CMarkup::IsStringAlphaNumeric(LPCTSTR pszString)
{
    while (pszString[0])
    {
        if (!IsCharAlphaNumeric(pszString[0]))
        {
            return FALSE;
        }

        pszString = CharNext(pszString);
    }

    return TRUE;
}

// We are looking for the next value/data pair.  Formated like this:
// VALUE="<data>"
HRESULT CMarkup::_GetNextValueDataPair(LPTSTR * ppszBlock, LPTSTR pszValue, int cchValue, LPTSTR pszData, int cchData)
{
    HRESULT hr = E_FAIL;
    LPCTSTR pszIterate = *ppszBlock;
    LPCTSTR pszEquals = StrStr(pszIterate, TEXT("=\""));

    if (pszEquals)
    {
        cchValue = MIN(cchValue, (pszEquals - *ppszBlock + 1));
        StrCpyN(pszValue, *ppszBlock, cchValue);

        pszEquals += 2; // Skip past the ="
        if (IsStringAlphaNumeric(pszValue))
        {
            LPTSTR pszEndOfData = StrChr(pszEquals, TEXT('\"'));

            if (pszEndOfData)
            {
                cchData = MIN(cchData, (pszEndOfData - pszEquals + 1));
                StrCpyN(pszData, pszEquals, cchData);

                *ppszBlock = CharNext(pszEndOfData);
                hr = S_OK;
            }
        }
    }

    return hr;
}


//-------------------------------------------------------------------------
//
// IsFEChar - Detects East Asia FullWidth character.
// borrowed from UserIsFullWidth in ntuser\rtl\drawtext.c
//
BOOL IsFEChar(WCHAR wChar)
{
    static struct
    {
        WCHAR wchStart;
        WCHAR wchEnd;
    } rgFullWidthUnicodes[] =
    {
        { 0x4E00, 0x9FFF }, // CJK_UNIFIED_IDOGRAPHS
        { 0x3040, 0x309F }, // HIRAGANA
        { 0x30A0, 0x30FF }, // KATAKANA
        { 0xAC00, 0xD7A3 }  // HANGUL
    };

    BOOL fRet = FALSE;

    //
    // Early out for ASCII. If the character < 0x0080, it should be a halfwidth character.
    //
    if (wChar >= 0x0080) 
    {
        int i;

        //
        // Scan FullWdith definition table... most of FullWidth character is
        // defined here... this is faster than call NLS API.
        //
        for (i = 0; i < ARRAYSIZE(rgFullWidthUnicodes); i++) 
        {
            if ((wChar >= rgFullWidthUnicodes[i].wchStart) &&
                (wChar <= rgFullWidthUnicodes[i].wchEnd)) 
            {
                fRet = TRUE;
                break;
            }
        }
    }

    return fRet;
}


//-------------------------------------------------------------------------
BOOL IsFEString(IN LPCTSTR psz, IN int cchText)
{
    for(int i=0; i < cchText; i++)
    {
        if (IsFEChar(psz[i])) 
        {
            return TRUE;
        }
    }

    return FALSE;
}


//-------------------------------------------------------------------------
int CMarkup::_IsLineBreakChar(LPCTSTR psz, int ich, TCHAR chBreak, OUT BOOL* pbRemove, BOOL fIgnoreSpace)
{
    LPTSTR pch;
    *pbRemove = FALSE;

    ASSERT(psz != NULL)
    ASSERT(psz[ich] != 0);
    
    //  Try caller-provided break character (assumed a 'remove' break char).
    if (!(fIgnoreSpace && (chBreak == 0x20)) && (psz[ich] == chBreak))
    {
        *pbRemove = TRUE;
        return ich;
    }

    #define MAX_LINEBREAK_RESOURCE   128
    static TCHAR _szBreakRemove   [MAX_LINEBREAK_RESOURCE] = {0};
    static TCHAR _szBreakPreserve [MAX_LINEBREAK_RESOURCE] = {0};
    #define LOAD_BREAKCHAR_RESOURCE(nIDS, buff) \
        if (0==*buff) { LoadString(HINST_THISDLL, nIDS, buff, ARRAYSIZE(buff)); }

    //  Try 'remove' break chars
    LOAD_BREAKCHAR_RESOURCE(IDS_LINEBREAK_REMOVE, _szBreakRemove);
    for (pch = _szBreakRemove; *pch; pch = CharNext(pch))
    {
        if (!(fIgnoreSpace && (*pch == 0x20)) && (psz[ich] == *pch))
        {
            *pbRemove = TRUE;
            return ich;
        }
    }

    //  Try 'preserve prior' break chars:
    LOAD_BREAKCHAR_RESOURCE(IDS_LINEBREAK_PRESERVE, _szBreakPreserve);
    for(pch = _szBreakPreserve; *pch; pch = CharNext(pch))
    {
        if (!(fIgnoreSpace && (*pch == 0x20)) && (psz[ich] == *pch))
        {
            return ++ich;
        }
    }

    return -1;
}


//-------------------------------------------------------------------------
BOOL CMarkup::_FindLastBreakChar(
    IN LPCTSTR pszText, 
    IN int cchText, 
    IN TCHAR chBreak,   // official break char (from TEXTMETRIC).
    OUT int* piLast, 
    OUT BOOL* pbRemove)
{
    *piLast   = 0;
    *pbRemove = FALSE;

    // 338710: Far East writing doesn't use the space character to separate 
    // words, ignore the space char as a possible line delimiter.
    BOOL fIgnoreSpace = IsFEString(pszText, cchText);

    for(int i = cchText-1; i >= 0; i--)
    {
        int ich = _IsLineBreakChar(pszText, i, chBreak, pbRemove, fIgnoreSpace);
        if (ich >= 0)
        {
            *piLast = ich;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CMarkup::_FindFirstLineBreak(
    IN LPCTSTR pszText, 
    IN int cchText, 
    OUT int* piLast, 
    OUT int* piLineBreakSize)
{
    *piLast   = 0;
    *piLineBreakSize = 0;

    // Searches for \n, \r, or \r\n
    for(int i = 0; i < cchText; i++)
    {
        if ((*(pszText+i)=='\n') || (*(pszText+i)=='\r'))
        {
            *piLast = i;
            if ((*(pszText+i)=='\r') && (*(pszText+i+1)=='\n'))
            {
                *piLineBreakSize = 2;
            }
            else 
            {
                *piLineBreakSize = 1;               
            }           
            return TRUE;
        }
    }
    return FALSE;
}

void CMarkup::DoNotify(int nCode, int iLink)
{
    _pMarkupCallback->Notify(nCode, iLink);
}

int CMarkup::ThemedDrawText(HDC hdc, LPCTSTR lpString, int nCount, LPRECT lpRect, UINT uFormat, BOOL bLink)
{
    if (!_hTheme)
    {
        // NORMAL DRAWTEXT
        return ::DrawText(hdc, lpString, nCount, lpRect, uFormat);
    }
    else
    {
        int iThemeStateId;
        iThemeStateId = bLink ? _iThemeStateIdLink : _iThemeStateIdNormal;

        if (uFormat & DT_CALCRECT)
        {
            // THEME CALC RECT SUPPORT
            LPRECT lpBoundRect = lpRect;
            if (RECTWIDTH(*lpRect)==0 && RECTHEIGHT(*lpRect)==0) 
            {
                lpBoundRect = NULL;
            }
            GetThemeTextExtent(_hTheme, hdc, _iThemePartId, iThemeStateId, lpString, nCount, uFormat, lpBoundRect, lpRect);
        }
        else
        {
            // THEME DRAW SUPPORT
            DrawThemeText(_hTheme, hdc, _iThemePartId, iThemeStateId, lpString, nCount, uFormat, 0, lpRect);
        }

        return (RECTHEIGHT(*lpRect));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\markup.h ===
//  declaration of Markup
//
//  Markup supports HTML-like embedded links in the caption text.
//  (e.g. "<a>Click Here</a> to see something cool"
//
//  An unlimited number of embedded links are supported.
//
//  scotthan: author/owner
//  dsheldon: moved this to shlobjp.h. Eventually destined for comctl32.
//  jklann: moved to markup as pseudo-COM object

#include <commctrl.h>
#include <shpriv.h>

#define INVALID_LINK_INDEX  (-1)
#define MAX_LINKID_TEXT     48

STDAPI Markup_Create(IMarkupCallback *pMarkupCallback, HFONT hf, HFONT hfUnderline, REFIID refiid, void **ppv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\mirror.c ===
/****************************** Module*Header *****************************\
* Module Name: mirror.c                                                    *
*                                                                          *
* This module contains all the Right-To-Left (RTL) Mirroring support       *
* routines used to Right-To-Left mirror an icon on the fly so that         *
* it would be displayed normal on a RTL mirrored localized OS. This is     *
* mainly a concern for 3rd party Apps.                                     *
*                                                                          *
*                                                                          *
* Created: 01-Feb-1998 8:41:18 pm                                          *
* Author: Samer Arafeh [samera]                                            *
*                                                                          *
* Copyright (c) 1998 Microsoft Corporation                                 *
\**************************************************************************/

#include "ctlspriv.h"
#include "image.h"




/***************************************************************************\
* MirrorIcon
*
* Mirror an Icon , given an Icon handle so that when these icons are displayed
* on a Mirrored DC, they end would be displayed normal.
*
* History:
* 04-Feb-1998 samera    Created
\***************************************************************************/
BOOL WINAPI MirrorIcon(HICON* phiconSmall, HICON* phiconLarge)
{
    HDC      hdcScreen;
    HBITMAP  hbm, hbmMask, hbmOld,hbmOldMask;
    BITMAP   bm;
    HICON    hicon[2] = {NULL,NULL};
    HICON    hiconNew[2] = {NULL,NULL};
    ICONINFO ii ;
    int      i;
    //
    // Synchronize access to global DCs now!
    // Allocate DCs if we didn't so far.
    //  
    ENTERCRITICAL;
    
    if (!g_hdc && !g_hdcMask)
    {
        g_hdc = CreateCompatibleDC(NULL);
        if (g_hdc)
        {
            g_hdcMask = CreateCompatibleDC(NULL);

            if( g_hdcMask )
            {
                SET_DC_RTL_MIRRORED(g_hdc);
                SET_DC_RTL_MIRRORED(g_hdcMask);
            }
            else
            {
                DeleteDC( g_hdc );
                g_hdc = NULL;
            }
        }
    }

    if (phiconSmall)
        hicon[0] = *phiconSmall;

    if (phiconLarge)
        hicon[1] = *phiconLarge;

    //
    // Acquire the screen DC
    //
    hdcScreen = GetDC(NULL);

    if (g_hdc && g_hdcMask && hdcScreen) 
    {
        for( i=0 ; i<(sizeof(hicon)/sizeof(HICON)) ; i++ )
        {
            if( hicon[i] )
            {
                if( GetIconInfo(hicon[i], &ii) &&
                    GetObject(ii.hbmColor, sizeof(BITMAP), &bm))
                {
                    //
                    // I don't want these.
                    //
                    DeleteObject( ii.hbmMask );
                    DeleteObject( ii.hbmColor );
                    ii.hbmMask = ii.hbmColor = NULL;

                    if (bm.bmBitsPixel == 32)
                    {
                        hbm = CreateDIB(hdcScreen, bm.bmWidth, bm.bmHeight, NULL);
                    }
                    else
                    {
                        hbm = CreateCompatibleBitmap(hdcScreen, bm.bmWidth, bm.bmHeight);
                    }
                    hbmMask = CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);
                    hbmOld = (HBITMAP)SelectObject(g_hdc, hbm);
                    hbmOldMask = (HBITMAP)SelectObject(g_hdcMask, hbmMask);
        
                    DrawIconEx(g_hdc, 0, 0, hicon[i], bm.bmWidth, bm.bmHeight, 0,
                               NULL, DI_IMAGE);

                    DrawIconEx(g_hdcMask, 0, 0, hicon[i], bm.bmWidth, bm.bmHeight, 0,
                               NULL, DI_MASK);

                    SelectObject(g_hdc, hbmOld);
                    SelectObject(g_hdcMask, hbmOldMask);

                    //
                    // create the new mirrored icon, and delete bmps
                    //
                    ii.hbmMask  = hbmMask;
                    ii.hbmColor = hbm;
                    hiconNew[i] = CreateIconIndirect(&ii);

                    DeleteObject(hbm);
                    DeleteObject(hbmMask);
                }
            }
        }
    }

    ReleaseDC(NULL, hdcScreen);

    //
    // Now we can reuse the global DCs
    //
    LEAVECRITICAL;

    //
    // Update icons if needed, and destroy old ones!
    //
    if (hicon[0] && hiconNew[0])
    {
        *phiconSmall = hiconNew[0];
        DestroyIcon(hicon[0]);
    }

    if (hicon[1] && hiconNew[1])
    {
        *phiconLarge = hiconNew[1];

        //
        // Don't delete twice
        //
        if (hicon[1] != hicon[0]) 
            DestroyIcon(hicon[1]);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\menuhelp.c ===
#include "ctlspriv.h"

#define MAININSYS

#ifndef WIN32
/* This returns the index of a submenu in a parent menu.  The return is
 * < 0 if the submenu does not exist in the parent menu
 */
int GetMenuIndex(HMENU hMenu, HMENU hSubMenu)
{
  int i;

  if (!hMenu || !hSubMenu)
      return(-1);

  for (i=GetMenuItemCount(hMenu)-1; i>=0; --i)
    {
      if (hSubMenu == GetSubMenu(hMenu, i))
          break;
    }

  return(i);
}
#endif // WIN32


BOOL IsMaxedMDI(HMENU hMenu)
{
  return(GetMenuItemID(hMenu, GetMenuItemCount(hMenu)-1) == SC_RESTORE);
}


/* Note that if iMessage is WM_COMMAND, it is assumed to have come from
 * a header bar or toolbar; do not pass in WM_COMMAND messages from any
 * other controls.
 */

#define MS_ID           GET_WM_MENUSELECT_CMD
#define MS_FLAGS        GET_WM_MENUSELECT_FLAGS
#define MS_MENU         GET_WM_MENUSELECT_HMENU

#define CMD_NOTIFY      GET_WM_COMMAND_CMD
#define CMD_ID          GET_WM_COMMAND_ID
#define CMD_CTRL        GET_WM_COMMAND_HWND


void WINAPI MenuHelp(UINT iMessage, WPARAM wParam, LPARAM lParam,
      HMENU hMainMenu, HINSTANCE hAppInst, HWND hwndStatus, UINT *lpwIDs)
{
  UINT wID;
  UINT *lpwPopups;
  int i;
  TCHAR szString[256];
  BOOL bUpdateNow = TRUE;
#if defined(WINDOWS_ME)
  MENUITEMINFO mii;
#endif

  switch (iMessage)
    {
      case WM_MENUSELECT:
        if ((WORD)MS_FLAGS(wParam, lParam)==(WORD)-1 && MS_MENU(wParam, lParam)==0)
          {
#ifndef WIN32
EndMenuHelp:
#endif
            SendMessage(hwndStatus, SB_SIMPLE, 0, 0L);
            break;
          }

          szString[0] = TEXT('\0');
#if defined(WINDOWS_ME)
          i = MS_ID(wParam, lParam);

          memset(&mii, 0, SIZEOF(MENUITEMINFO ));
          mii.cbSize = sizeof(mii);
          mii.fMask = MIIM_TYPE;
          mii.cch = 0;  //If we ask for MIIM_TYPE, this must be set to zero!
                        //Otherwise, win95 attempts to copy the string too!
          if (GetMenuItemInfo((HMENU)MS_MENU(wParam, lParam), i, TRUE, &mii))
              mii.fState = mii.fType & MFT_RIGHTORDER ?SBT_RTLREADING :0;
#endif
        if (!(MS_FLAGS(wParam, lParam)&MF_SEPARATOR))
          {
            if (MS_FLAGS(wParam, lParam)&MF_POPUP)
              {
                /* We don't want to update immediately in case the menu is
                 * about to pop down, with an item selected.  This gets rid
                 * of some flashing text.
                 */
                bUpdateNow = FALSE;

                /* First check if this popup is in our list of popup menus
                 */
                for (lpwPopups=lpwIDs+2; *lpwPopups; lpwPopups+=2)
                  {
                    /* lpwPopups is a list of string ID/menu handle pairs
                     * and MS_ID(wParam, lParam) is the menu handle of the selected popup
                     */
                    if (*(lpwPopups+1) == (UINT)MS_ID(wParam, lParam))
                      {
                        wID = *lpwPopups;
                        goto LoadTheString;
                      }
                  }

                /* Check if the specified popup is in the main menu;
                 * note that if the "main" menu is in the system menu,
                 * we will be OK as long as the menu is passed in correctly.
                 * In fact, an app could handle all popups by just passing in
                 * the proper hMainMenu.
                 */
                if ((HMENU)MS_MENU(wParam, lParam) == hMainMenu)
                  {
#ifdef  WIN32
                    i = MS_ID(wParam, lParam);
#else   // WIN32
                    i = GetMenuIndex((HMENU)MS_MENU(wParam, lParam), (HMENU)MS_ID(wParam, lParam));
                    if (i >= 0)
#endif  // WIN32
                      {
                        if (IsMaxedMDI(hMainMenu))
                          {
                            if (!i)
                              {
                                wID = IDS_SYSMENU;
                                hAppInst = HINST_THISDLL;
                                goto LoadTheString;
                              }
                            else
                                --i;
                          }
                        wID = (UINT)(i + lpwIDs[1]);
                        goto LoadTheString;
                      }
                  }

                /* This assumes all app defined popups in the system menu
                 * have been listed above
                 */
                if ((MS_FLAGS(wParam, lParam)&MF_SYSMENU))
                  {
                    wID = IDS_SYSMENU;
                    hAppInst = HINST_THISDLL;
                    goto LoadTheString;
                  }

                goto NoString;
              }
            else if (MS_ID(wParam, lParam) >= MINSYSCOMMAND)
              {
                wID = (UINT)(MS_ID(wParam, lParam) + MH_SYSMENU);
                hAppInst = HINST_THISDLL;
              }
            else
              {
                wID = (UINT)(MS_ID(wParam, lParam) + lpwIDs[0]);
              }

LoadTheString:
            if (hAppInst == HINST_THISDLL)
                LocalizedLoadString(wID, szString, ARRAYSIZE(szString));
            else
                LoadString(hAppInst, wID, szString, ARRAYSIZE(szString));
          }

NoString:
#if defined(WINDOWS_ME)
        SendMessage(hwndStatus, SB_SETTEXT, mii.fState|SBT_NOBORDERS|255,
              (LPARAM)(LPSTR)szString);
#else
        SendMessage(hwndStatus, SB_SETTEXT, SBT_NOBORDERS|255,
              (LPARAM)(LPTSTR)szString);
#endif
        SendMessage(hwndStatus, SB_SIMPLE, 1, 0L);

        if (bUpdateNow)
            UpdateWindow(hwndStatus);
        break;

#ifndef WIN32

      case WM_COMMAND:
        switch (CMD_NOTIFY(wParam, lParam))
          {
#ifdef WANT_SUCKY_HEADER
            case HBN_BEGINDRAG:
              bUpdateNow = FALSE;
              wID = IDS_HEADER;
              goto BeginSomething;

            case HBN_BEGINADJUST:
              wID = IDS_HEADERADJ;
              goto BeginSomething;
#endif
            case TBN_BEGINADJUST:
              /* We don't want to update immediately in case the operation is
               * aborted immediately.
               */
              bUpdateNow = FALSE;
              wID = IDS_TOOLBARADJ;
              goto BeginSomething;

BeginSomething:
              SendMessage(hwndStatus, SB_SIMPLE, 1, 0L);
              hAppInst = HINST_THISDLL;
              goto LoadTheString;

            case TBN_BEGINDRAG:
              MenuHelp(WM_MENUSELECT, (WPARAM)CMD_CTRL(wParam, lParam), 0L,
                    hMainMenu, hAppInst, hwndStatus, lpwIDs);
              break;
#ifdef WANT_SUCKY_HEADER
            case HBN_ENDDRAG:
            case HBN_ENDADJUST:
#endif
            case TBN_ENDDRAG:
            case TBN_ENDADJUST:
              goto EndMenuHelp;

            default:
              break;
          }
        break;
#endif  // !WIN32

      default:
        break;
    }
}


BOOL WINAPI ShowHideMenuCtl(HWND hWnd, WPARAM wParam, LPINT lpInfo)
{
  HWND hCtl;
  UINT uTool, uShow = MF_UNCHECKED | MF_BYCOMMAND;
  HMENU hMainMenu;
  BOOL bRet = FALSE;

  hMainMenu = IntToPtr_(HMENU, lpInfo[1]);

  for (uTool=0; ; ++uTool, lpInfo+=2)
    {
      if ((WPARAM)lpInfo[0] == wParam)
          break;
      if (!lpInfo[0])
          goto DoTheCheck;
    }

  if (!(GetMenuState(hMainMenu, (UINT) wParam, MF_BYCOMMAND)&MF_CHECKED))
      uShow = MF_CHECKED | MF_BYCOMMAND;

  switch (uTool)
    {
      case 0:
        bRet = SetMenu(hWnd, (HMENU)((uShow&MF_CHECKED) ? hMainMenu : 0));
        break;

      default:
        hCtl = GetDlgItem(hWnd, lpInfo[1]);
        if (hCtl)
          {
            ShowWindow(hCtl, (uShow&MF_CHECKED) ? SW_SHOW : SW_HIDE);
            bRet = TRUE;
          }
        else
            uShow = MF_UNCHECKED | MF_BYCOMMAND;
        break;
    }

DoTheCheck:
  CheckMenuItem(hMainMenu, (UINT) wParam, uShow);

#ifdef MAININSYS
  hMainMenu = GetSubMenu(GetSystemMenu(hWnd, FALSE), 0);
  if (hMainMenu)
      CheckMenuItem(hMainMenu, (UINT) wParam, uShow);
#endif

  return(bRet);
}


void WINAPI GetEffectiveClientRect(HWND hWnd, LPRECT lprc, LPINT lpInfo)
{
  RECT rc;
  HWND hCtl;

  GetClientRect(hWnd, lprc);

  /* Get past the menu
   */
  for (lpInfo+=2; lpInfo[0]; lpInfo+=2)
    {
      hCtl = GetDlgItem(hWnd, lpInfo[1]);
      /* We check the style bit because the parent window may not be visible
       * yet (still in the create message)
       */
      if (!hCtl || !(GetWindowStyle(hCtl) & WS_VISIBLE))
          continue;

      GetWindowRect(hCtl, &rc);

      //
      // This will do the ScrrenToClient functionality, plus
      // it will return a good rect (left < right) when the
      // hWnd parent is RTL mirrored. [samera]
      //
      MapWindowPoints(HWND_DESKTOP, hWnd, (PPOINT)&rc, 2);

      SubtractRect(lprc, lprc, &rc);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\monthcal.h ===
#define CAL_COLOR_TODAY     0x000000ff

#define CALMONTHMAX     12
#define CALROWMAX       6
#define CALCOLMAX       7
#define CAL_DEF_SELMAX  7

// Bug#94368 - these metrics do not scale with user settings
#define CALBORDER       6

//  The formulas for DX_ARROWMARGIN and D[XY]_CALARROW are chosen so on most
//  systems they come out approximately equal to the values you got
//  in IE4.  (The IE4 values were hard-coded and therefore incompatible
//  with accessibility.)

#define DX_ARROWMARGIN      (5 * g_cxBorder)
#define DX_CALARROW         (g_cyHScroll * 4 / 3)
#define DY_CALARROW         g_cyHScroll

#define DXRING_SPIRAL       8
#define DXEDGE_SPIRAL       8

// Bug#94368 - msecautospin should scale on doubleclicktime
#define CAL_MSECAUTOSPIN        350
#define CAL_SECTODAYTIMER       (2 * 60)
#define CAL_IDAUTOSPIN          1
#define CAL_TODAYTIMER          2

#define CCHMAXMONTH     42
#define CCHMAXABBREVDAY 11
#define CCHMAXMARK      10

#define SEL_BEGIN       1
#define SEL_END         2
#define SEL_DOT         3
#define SEL_MID         4

//
//  For each month we display, we have to compute a bunch of metrics
//  to track the stuff we put into the header area.
//
//  The five values represent the following points in the string:
//
//          Mumble January Mumble 1999 Mumble
//         |      |       |      |    |
//         |      |     MonthEnd |    YearEnd
//         Start  MonthStart     YearStart
//
//  Note that it is possible for YearStart to be less than MonthStart if the
//  year comes before the month.  (e.g., "1999 January")
//
//  These values already take RTL mirroring into account.
//
//  NOTE!  IMM_MONTHSTART and IMM_YEARSTART are also used as flags,
//  so they both need to be powers of 2.
//
#define IMM_START        0
#define IMM_DATEFIRST    1
#define IMM_MONTHSTART   1
#define IMM_YEARSTART    2
#define IMM_MONTHEND     3
#define IMM_YEAREND      4
#define IMM_DATELAST     4
#define DMM_STARTEND    2           // Difference between START and END
#define CCH_MARKERS      4          // There are four markers

typedef struct MONTHMETRICS {
    int     rgi[5];
} MONTHMETRICS, *PMONTHMETRICS;

// This stuff used to be global
typedef struct tagLOCALEINFO {
    TCHAR szToday[32];        // "Today:"
    TCHAR szGoToToday[64];    // "&Go to today"

    TCHAR szMonthFmt[8];      // "MMMM"
    TCHAR szMonthYearFmt[16+CCH_MARKERS]; // "\1MMMM\3 \2yyyy\4" -- see MCInsertMarkers

    TCHAR rgszMonth[12][CCHMAXMONTH];
    TCHAR rgszDay[7][CCHMAXABBREVDAY];
    int dowStartWeek;       // LOCALE_IFIRSTDAYOFWEEK (0 = mon, 1 = tue, 6 = sat)
    int firstWeek;          // LOCALE_IFIRSTWEEKOFYEAR

    TCHAR *rgpszMonth[12];  // pointers into rgszMonth
    TCHAR *rgpszDay[7];     // pointers into rgszDay
} LOCALEINFO, *PLOCALEINFO, *LPLOCALEINFO;


//
// SUBEDITCONTROL stuff
//

//
// Note: SECIncrFocus assumes that SUBEDIT_NONE is numerical value -1
//
#define SUBEDIT_NONE -1 // no field is being edited
#define SUBEDIT_ALL  -2 // all fields are being edited (DTS_APPCANPARSE)
enum {
    SE_ERA = 1,    
    SE_YEAR,
    SE_YEARALT,         // see SEGetTimeDateFormat
    SE_MONTH,
    SE_MONTHALT,        // see SEGetTimeDateFormat
    SE_DAY,
    SE_DATELAST = SE_DAY,
    SE_MARK,            // "AM" or "PM" indicator
    SE_HOUR,
    SE_MINUTE,
    SE_SECOND,
    SE_STATIC,
    SE_APP,
    SE_MAX
};

#define SE_YEARLIKE(s)      ((s) == SE_YEAR || (s) == SE_YEARALT)
#define SE_DATELIKE(s)      InRange(s, SE_ERA, SE_DATELAST)

#include <pshpack8.h>
typedef struct tagSUBEDIT {
    int     id;         // SE_ value above
    RECT    rc;         // bounding box for display

    LPWORD  pval;       // current value (in a SYSTEMTIME struct)
    UINT    min;        // min value
    UINT    max;        // max value
    int     cIncrement; // increment value

    int     cchMax;     // max allowed chars
    int     cchEdit;    // current number chars entered so far
    UINT    valEdit;    // value entered so far
    UINT    flDrawText; // flags for DrawText

    LPCTSTR pv;         // formatting string

    BOOL    fReadOnly;  // can this subedit be edited (receive focus)?
} SUBEDIT, * PSUBEDIT, *LPSUBEDIT;
#include <poppack.h>

//
//  There are three types of calendars we support
//
//  -   Gregorian (Western).  Any calendar not otherwise supported is forced
//      into Gregorian mode.
//
//  -   Offset.  The year is merely a fixed offset from the Gregorian year.
//      This is the style used by the Korean and Thai calendars.
//
//  -   Era.  The calendar consists of multiple eras, and the year is
//      relative to the start of the enclosing era.  This is the style
//      used by the Japan and Taiwan calendars.  Eras are strangest because
//      an era need not start on January 1!
//
typedef struct tagCALENDARTYPE {
    CALID   calid;        // Calendar id number (CAL_GREGORIAN, etc.)
    LCID    lcid;         // Usually LOCALE_USER_DEFAULT, but forced to US for unsupported calendars
    int     dyrOffset;    // The calendar offset (0 for Gregorian and Era)
    HDPA    hdpaYears;    // If fEra, then array of year info
    HDPA    hdpaEras;     // If fEra, then array of era names
} CALENDARTYPE, *PCALENDARTYPE;

#define BUDDHIST_BIAS   543
#define KOREAN_BIAS     2333

#define ISERACALENDAR(pct)            ((pct)->hdpaEras)

#define GregorianToOther(pct, yr)     ((yr) + (pct)->dyrOffset)
#define OtherToGregorian(pct, yr)     ((yr) - (pct)->dyrOffset)

typedef struct tagSUBEDITCONTROL {
    LPCCONTROLINFO pci;  // looks like this guy needs access to the hwnd
    BOOL fNone;         // allow scrolling into SUBEDIT_NONE
    HFONT hfont;        // font to draw text with
    RECT rc;            // rect for subedits
    int xScroll;        // amount pse array is scrolled
    int iseCur;         // subedit with current selection (SUBEDIT_NONE for no selection)
    int cse;            // count of subedits in pse array
    SYSTEMTIME st;      // current time pse represents (pse points into this)
    LPTSTR szFormat;    // format string as parsed (pse points into this)
    PSUBEDIT pse;       // subedit array
    TCHAR   cDelimeter; // delimiter between subedits (parsed from fmt string)
    TCHAR szDelimeters[15]; // delimiters between date/time fields (from resfile)
    CALENDARTYPE ct;    // information about the calendar
    BITBOOL fMirrorSEC:1; // Whether or not to mirror the SubEditControls
    BITBOOL fSwapTimeMarker:1; // Whether we need to swap the AM/PM symbol around or not
} SUBEDITCONTROL, * PSUBEDITCONTROL, *LPSUBEDITCONTROL;

#define SECYBORDER 2
#define SECXBORDER 2

/*
 *    Multiple Month Calendar Control
 */
typedef struct tagMONTHCAL {
    CCONTROLINFO ci;     // all controls start with this
    LOCALEINFO li;      // stuff that used to be global

    HINSTANCE hinstance;

    HWND    hwndEdit;   // non-NULL iff dealing with user-click on year
    HWND    hwndUD;     // UpDown control associated with the hwndEdit

    HPEN    hpen;
    HBRUSH  hbrushToday;

    HFONT   hfont;                // stock font, don't destroy
    HFONT   hfontBold;            // created font, so we need to destroy
    
    COLORREF clr[MCSC_COLORCOUNT];    
    
    int     dxCol;             // font info, based on bold to insure that we get enough space
    int     dyRow;
    int     dxMonth;
    int     dyMonth;
    int     dxYearMax;
    int     dyToday;
    int     dxToday;

    int     dxArrowMargin;
    int     dxCalArrow;
    int     dyCalArrow;

    HMENU   hmenuCtxt;
    HMENU   hmenuMonth;

    SYSTEMTIME  stMin;          // minimum selectable date
    SYSTEMTIME  stMax;          // maximum selectable date

    DWORD   cSelMax;

    SYSTEMTIME  stToday;
    SYSTEMTIME  st;             // the selection if not multiselect
                                // the beginning of the selection if multiselect
    SYSTEMTIME  stEndSel;       // the end of the selection if multiselect
    SYSTEMTIME  stStartPrev;    // prev selection beginning (only in multiselect)
    SYSTEMTIME  stEndPrev;      // prev selection end (only in multiselect)

    SYSTEMTIME  stAnchor;       // anchor date in shift-click selection

    SYSTEMTIME  stViewFirst;    // first visible date (DAYSTATE - grayed out)
    SYSTEMTIME  stViewLast;     // last visible date (DAYSTATE - grayed out)
    
    SYSTEMTIME  stMonthFirst;   // first month (stMin adjusted)
    SYSTEMTIME  stMonthLast;    // last month (stMax adjusted)
    int         nMonths;        // number of months being shown (stMonthFirst..stMonthLast)

    UINT_PTR    idTimer;
    UINT_PTR    idTimerToday;

    int     nViewRows;          // number of rows of months shown
    int     nViewCols;          // number of columns of months shown

    RECT    rcPrev;             // rect for prev month button (in window coords)
    RECT    rcNext;             // rect for next month button (in window coords)

    RECT    rcMonthName;        // rect for the month name (in relative coords)
                                // (actually, the rect for the titlebar area of
                                // each month).

    RECT    rcDow;              // rect for days of week (in relative coords)
    RECT    rcWeekNum;          // rect for week numbers (in relative coords)
    RECT    rcDayNum;           // rect for day numbers  (in relative coords)

    int     iMonthToday;
    int     iRowToday;
    int     iColToday;

    RECT    rcDayCur;            // rect for the current selected day
    RECT    rcDayOld;

    RECT    rc;                  // window rc.
    RECT    rcCentered;          // rect containing the centered months

    // The following 4 ranges hold info about the displayed (DAYSTATE) months:
    // They are filled in from 0 to nMonths+1 by MCUpdateStartEndDates
    // NOTE: These are _one_ based indexed arrays of the displayed months    
    int     rgcDay[CALMONTHMAX + 2];    // # days in this month
    int     rgnDayUL[CALMONTHMAX + 2];  // last day in this month NOT visible when viewing next month

    int     dsMonth;             // first month stored in rgdayState
    int     dsYear;              // first year stored in rgdayState
    int     cds;                 // number of months stored in rgdayState
    MONTHDAYSTATE   rgdayState[CALMONTHMAX + 2];

    int     nMonthDelta;        // the amount to move on button press

    BOOL    fControl;
    BOOL    fShift;
    
    CALENDARTYPE ct;            // information about the calendar

    WORD    fFocus:1;
    WORD    fEnabled:1;
    WORD    fCapture:1;         // mouse captured

    WORD    fSpinPrev:1;
    WORD    fFocusDrawn:1;      // is focus rect currently drawn?
    WORD    fToday:1;           // today's date currently visible in calendar
    WORD    fNoNotify:1;        // don't notify parent window
    WORD    fMultiSelecting:1;  // Are we actually in the process of selecting?
    WORD    fForwardSelect:1;
    WORD    fFirstDowSet:1;
    WORD    fTodaySet:1;
    WORD    fMinYrSet:1;        // stMin has been set
    WORD    fMaxYrSet:1;        // stMax has been set
    WORD    fMonthDelta:1;      // nMonthDelta has been set
    WORD    fHeaderRTL:1;       // Is header string RTL ?
    HTHEME hThemeScroll;

    //
    //  Metrics for each month we display.
    //
    MONTHMETRICS rgmm[CALMONTHMAX];

} MONTHCAL, * PMONTHCAL, *LPMONTHCAL;


#define MonthCal_GetPtr(hwnd)      (MONTHCAL*)GetWindowPtr(hwnd, 0)
#define MonthCal_SetPtr(hwnd, p)   (MONTHCAL*)SetWindowPtr(hwnd, 0, p)

#define MonthCal_IsMultiSelect(pmc)     ((pmc)->ci.style & MCS_MULTISELECT)
#define MonthCal_IsDayState(pmc)        ((pmc)->ci.style & MCS_DAYSTATE)
#define MonthCal_ShowWeekNumbers(pmc)   ((pmc)->ci.style & MCS_WEEKNUMBERS)
#define MonthCal_ShowTodayCircle(pmc)   (!((pmc)->ci.style & MCS_NOTODAYCIRCLE))
#define MonthCal_ShowToday(pmc)         (!((pmc)->ci.style & MCS_NOTODAY))


//
// DATEPICK stuff
//

#define DPYBORDER       2
#define DPXBUFFER       2
#define DP_DXBUTTON     15
#define DP_DYBUTTON     15
#define DP_IDAUTOSPIN   1
#define DP_MSECAUTOSPIN 200
#define DATEPICK_UPDOWN 1000

#define DTP_FORMATLENGTH 128

enum {
    DP_SEL_DOW = 0,
    DP_SEL_YEAR,
    DP_SEL_MONTH,
    DP_SEL_DAY,
    DP_SEL_SEP1,
    DP_SEL_SEP2,
    DP_SEL_NODATE,
    DP_SEL_MAX
};

typedef struct tagDATEPICK 
{
    CCONTROLINFO ci;     // all controls start with this

    HWND        hwndUD;
    HWND        hwndMC;
    HFONT       hfontMC;    // font for drop down cal

    COLORREF clr[MCSC_COLORCOUNT];

    // HACK! stMin and stMax must remain in order and adjacent
    SYSTEMTIME  stMin;      // minimum date we allow
    SYSTEMTIME  stMax;      // maximum date we allow
    SYSTEMTIME  stPrev;     // most recent date notified
    SUBEDITCONTROL sec;     // current date

    RECT        rcCheck;    // location of checkbox iff fShowNone
    RECT        rc;         // size of SEC space
    RECT        rcBtn;      // location of dropdown or updown
    int         iseLastActive; // which subedit was active when we were last active?
    WPARAM      gdtr;       // Did app set min and/or max? (GDTR_MIN|GDTR_MAX)

    BITBOOL         fEnabled:1;
    BITBOOL         fUseUpDown:1;
    BITBOOL         fFocus:1;
    BITBOOL         fNoNotify:1;
    BITBOOL         fCapture:1;
    BITBOOL         fShow:1;        // TRUE iff we should continue to show MonthCal

    BITBOOL         fCheck:1;       // TRUE iff the checkbox is checked
    BITBOOL         fCheckFocus:1;  // TRUE iff the checkbox has focus

    BITBOOL         fLocale:1;      // TRUE iff the format string is LOCALE dependent
    BITBOOL         fHasMark:1;      // true iff has am/pm in current format
    BITBOOL         fFreeEditing:1; // TRUE if in the middle of a free-format edit
    HTHEME          hThemeCombo;
    HTHEME          hThemeCheck;
} DATEPICK, * PDATEPICK, *LPDATEPICK;

#define DatePick_ShowCheck(pdp)     ((pdp)->ci.style & DTS_SHOWNONE)
#define DatePick_AppCanParse(pdp)   ((pdp)->ci.style & DTS_APPCANPARSE)
#define DatePick_RightAlign(pdp)    ((pdp)->ci.style & DTS_RIGHTALIGN)

#define DatePick_GetPtr(hwnd)      (DATEPICK*)GetWindowPtr(hwnd, 0)
#define DatePick_SetPtr(hwnd, p)   (DATEPICK*)SetWindowPtr(hwnd, 0, p)

#define CopyDate(stS, stD)  ((stD).wYear = (stS).wYear,(stD).wMonth = (stS).wMonth,(stD).wDay = (stS).wDay)
#define CopyTime(stS, stD)  ((stD).wHour = (stS).wHour,(stD).wMinute = (stS).wMinute,(stD).wSecond = (stS).wSecond)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\monthcal.c ===
#include "ctlspriv.h"

#include "scdttime.h"
#include "monthcal.h"
#include "prshti.h"         // for StrDup_AtoW

// TODO
//
// #6329: When Min/Max range is set, then dates before the min
// or after the max are painted in the normal date color. They
// should be painted with MCSC_TRAILINGTEXT color. (Or we should
// add a new color to cover this case.) Feature requested by Jobi George
//
// 9577: We want a DAYSTATE like structure for the background
// color of dates. For highlighting. Perhaps a COLORSTATE per
// registered background color.
//

// private message
#define MCMP_WINDOWPOSCHANGED (MCM_FIRST - 1) // MCM_FIRST is way over WM_USER
#define DTMP_WINDOWPOSCHANGED (DTM_FIRST - 1) // DTM_FIRST is way over WM_USER

// MONTHCAL
LRESULT CALLBACK MonthCalWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT MCNcCreateHandler(HWND hwnd);
LRESULT MCCreateHandler(MONTHCAL *pmc, HWND hwnd, LPCREATESTRUCT lpcs);
LRESULT MCOnStyleChanging(MONTHCAL *pmc, UINT gwl, LPSTYLESTRUCT pinfo);
LRESULT MCOnStyleChanged(MONTHCAL *pmc, UINT gwl, LPSTYLESTRUCT pinfo);
void MCCalcSizes(MONTHCAL *pmc);
void MCHandleSetFont(MONTHCAL *pmc, HFONT hfont, BOOL fRedraw);
void MCPaint(MONTHCAL *pmc, HDC hdc);
void MCPaintMonth(MONTHCAL *pmc, HDC hdc, RECT *prc, int iMonth, int iYear, int iIndex,
                  BOOL fDrawPrev, BOOL fDrawNext, HBRUSH hbrSelect);
void MCNcDestroyHandler(HWND hwnd, MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
void MCRecomputeSizing(MONTHCAL *pmc, RECT *prect);
LRESULT MCSizeHandler(MONTHCAL *pmc, RECT *prc);
void MCUpdateMonthNamePos(MONTHCAL *pmc);
void MCUpdateStartEndDates(MONTHCAL *pmc, SYSTEMTIME *pstStart);
void MCGetRcForDay(MONTHCAL *pmc, int iMonth, int iDay, RECT *prc);
void MCGetRcForMonth(MONTHCAL *pmc, int iMonth, RECT *prc);
void MCUpdateToday(MONTHCAL *pmc);
void MCUpdateRcDayCur(MONTHCAL *pmc, SYSTEMTIME *pst);
void MCUpdateDayState(MONTHCAL *pmc);
int MCGetOffsetForYrMo(MONTHCAL *pmc, int iYear, int iMonth);
int MCIsSelectedDayMoYr(MONTHCAL *pmc, int iDay, int iMonth, int iYear);
BOOL MCIsBoldOffsetDay(MONTHCAL *pmc, int nDay, int iIndex);
BOOL FGetOffsetForPt(MONTHCAL *pmc, POINT pt, int *piOffset);
BOOL FGetRowColForRelPt(MONTHCAL *pmc, POINT ptRel, int *piRow, int *piCol);
BOOL FGetDateForPt(MONTHCAL *pmc, POINT pt, SYSTEMTIME *pst, 
                   int* piDay, int* piCol, int* piRow, LPRECT prcMonth);
LRESULT MCContextMenu(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
LRESULT MCLButtonDown(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
LRESULT MCLButtonUp(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
LRESULT MCMouseMove(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
LRESULT MCHandleTimer(MONTHCAL *pmc, WPARAM wParam);
LRESULT MCHandleKeydown(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
LRESULT MCHandleChar(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
int MCIncrStartMonth(MONTHCAL *pmc, int nDelta, BOOL fDelayDayChange);
void MCGetTitleRcsForOffset(MONTHCAL* pmc, int iOffset, LPRECT prcMonth, LPRECT prcYear);
BOOL MCSetDate(MONTHCAL *pmc, SYSTEMTIME *pst);
void MCNotifySelChange(MONTHCAL *pmc, UINT uMsg);
void MCInvalidateDates(MONTHCAL *pmc, SYSTEMTIME *pst1, SYSTEMTIME *pst2);
void MCInvalidateMonthDays(MONTHCAL *pmc);
void MCSetToday(MONTHCAL* pmc, SYSTEMTIME* pst);
void MCGetTodayBtnRect(MONTHCAL *pmc, RECT *prc);
void GetYrMoForOffset(MONTHCAL *pmc, int iOffset, int *piYear, int *piMonth);
BOOL FScrollIntoView(MONTHCAL *pmc);
void MCFreeCalendarInfo(PCALENDARTYPE pct);
void MCGetCalendarInfo(PCALENDARTYPE pct);
BOOL MCIsDateStringRTL(TCHAR tch);

// DATEPICK
LRESULT CALLBACK DatePickWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT DPNcCreateHandler(HWND hwnd);
LRESULT DPCreateHandler(DATEPICK *pdp, HWND hwnd, LPCREATESTRUCT lpcs);
LRESULT DPOnStyleChanging(DATEPICK *pdp, UINT gwl, LPSTYLESTRUCT pinfo);
LRESULT DPOnStyleChanged(DATEPICK *pdp, UINT gwl, LPSTYLESTRUCT pinfo);
void DPHandleLocaleChange(DATEPICK *pdp);
void DPDestroyHandler(HWND hwnd, DATEPICK *pdp, WPARAM wParam, LPARAM lParam);
void DPHandleSetFont(DATEPICK *pdp, HFONT hfont, BOOL fRedraw);
void DPPaint(DATEPICK *pdp, HDC hdc);
void DPLBD_MonthCal(DATEPICK *pdp, BOOL fLButtonDown);
LRESULT DPLButtonDown(DATEPICK *pdp, WPARAM wParam, LPARAM lParam);
LRESULT DPLButtonUp(DATEPICK *pdp, WPARAM wParam, LPARAM lParam);
void DPRecomputeSizing(DATEPICK *pdp, RECT *prect);
LRESULT DPHandleKeydown(DATEPICK *pdp, WPARAM wParam, LPARAM lParam);
LRESULT DPHandleChar(DATEPICK *pdp, WPARAM wParam, LPARAM lParam);
void DPNotifyDateChange(DATEPICK *pdp);
BOOL DPSetDate(DATEPICK *pdp, SYSTEMTIME *pst, BOOL fMungeDate);
void DPDrawDropdownButton(DATEPICK *pdp, HDC hdc, BOOL fPressed);
void SECGetSystemtime(LPSUBEDITCONTROL psec, LPSYSTEMTIME pst);

static TCHAR const g_rgchMCName[] = MONTHCAL_CLASS;
static TCHAR const g_rgchDTPName[] = DATETIMEPICK_CLASS;

// MONTHCAL globals
#define g_szTextExtentDef TEXT("0000")
#define g_szNumFmt TEXT("%d")

//
//  Epoch = the beginning of the universe (the earliest date we support)
//  Armageddon = the end of the universe (the latest date we support)
//
//  Epoch is 14-sep-1752 because that's when the Gregorian calendar
//  kicked in.  The day before 14-sep-1752 was 2-sep-1752 (in British
//  and US history; other countries switched at other times).
//
//  Armageddon is 31-dec-9999 because we assume four digits for years
//  is enough.  (Oh no, the Y10K problem...)
//
const SYSTEMTIME c_stEpoch      = { 1752,  9, 0, 14,  0,  0,  0,   0 };
const SYSTEMTIME c_stArmageddon = { 9999, 12, 0, 31, 23, 59, 59, 999 };

BOOL InitDateClasses(HINSTANCE hinst)
{
    WNDCLASS wndclass;
    
    wndclass.style          = CS_GLOBALCLASS;
    wndclass.lpfnWndProc    = MonthCalWndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = sizeof(LPVOID);
    wndclass.hInstance      = hinst;
    wndclass.hIcon          = NULL;
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = g_rgchMCName;

    if (!RegisterClass(&wndclass))
    {
        return GetClassInfo(hinst, g_rgchMCName, &wndclass);
    }

    wndclass.lpfnWndProc    = DatePickWndProc;
    wndclass.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    wndclass.lpszClassName  = g_rgchDTPName;

    if (!RegisterClass(&wndclass))
    {
        return GetClassInfo(hinst, g_rgchDTPName, &wndclass);
    }

    return(TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
// MonthCal stuff
//
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////
//
// MCInsert/RemoveMarkers
//
// QuickSummary:  Convert the string "MMMM yyyy" into "\1MMMM\3 \2yyyy\4".
//
// In order to lay out the month/year info in the header, we have to be
// able to extract the month and year out of the formatted string so we
// know what their rectangles are.  We do this by wrapping the month and
// year inserts with markers so we can extract them after formatting.
//
// Since \1 through \4 are control characters, they won't conflict with
// displayable characters in the actual format string.  And just to play it
// safe, if we actually see a format character, we erase it from the string.
//
// MCInsertMarkers inserts the markers into the output string so we can
// extract the substrings later.  Quotation marks are funky since you can
// write a format of "'The' mm'''th month of' yyyy".  Note that a simple
// even-odd test works for detecting whether we are inside or outside
// quotation marks, even in the nested quotation mark case.
//
void MCInsertMarkers(LPTSTR pszOut, LPCTSTR pszIn)
{
    BOOL fInQuote = FALSE;
    UINT flSeen = 0;
    UINT flThis;

    for (;;)
    {
        TCHAR ch = *pszIn;
        switch (ch) {

        // At end of string, terminate the output buffer and go home
        case TEXT('\0'):
            *pszOut = TEXT('\0');
            return;

        case TEXT('m'):
        case TEXT('M'):
            flThis = IMM_MONTHSTART;
            goto CheckMarker;

        case TEXT('y'):
            flThis = IMM_YEARSTART;
            goto CheckMarker;

        CheckMarker:
            // If inside a quotation mark or we've already done this guy,
            // then just treat it as a regular character.
            if (fInQuote || (flSeen & flThis))
                goto CopyChar;

            flSeen |= flThis;

            *pszOut++ = (TCHAR)flThis;
            // Don't need to use CharNext because we know *pszIn is "m" "M" or "y"
            for ( ; *pszIn == ch; pszIn++)
            {
                *pszOut++ = ch;
            }
            *pszOut++ = (TCHAR)(flThis + DMM_STARTEND);

            // Restart the loop so we re-parse the character at *pszIn
            continue;

        // Toggle the quotation mark gizmo if we see one, and then just
        // copy it.
        case '\'':
            fInQuote ^= TRUE;
            goto CopyChar;

        //
        //  Don't let these sneak into the output format or it
        //  will confuse us.
        //
        case IMM_MONTHSTART:
        case IMM_YEARSTART:
        case IMM_MONTHEND:
        case IMM_YEAREND:
            break;

        default:
        CopyChar:
            *pszOut++ = ch;
#ifndef UNICODE
            if (IsDBCSLeadByte(ch) && pszIn[1]) {
                *pszOut++ = *++pszIn;
            }
#endif
            break;

        }

        pszIn++;            // We handled the DBCS case already
    }

    // NOTREACHED
}

//
//  MCRemoveMarkers hunts down the marker characters and strips them out,
//  recording their locations in the optional MONTHMETRICS (as character
//  indices).
//

void MCRemoveMarkers(LPTSTR pszBuf, PMONTHMETRICS pmm)
{
    int iWrite, iRead;

    //
    //  If by some horrid error we can't find our markers, just pretend
    //  they were at the start of the string.
    //
    if (pmm) {
        pmm->rgi[IMM_MONTHSTART] = 0;
        pmm->rgi[IMM_YEARSTART ] = 0;
        pmm->rgi[IMM_MONTHEND  ] = 0;
        pmm->rgi[IMM_YEAREND   ] = 0;
    }

    iWrite = iRead = 0;
    for (;;)
    {
        TCHAR ch = pszBuf[iRead];
        switch (ch)
        {
        // At end of string, terminate the output buffer and go home
        case TEXT('\0'):
            pszBuf[iWrite] = TEXT('\0');
            return;

        // If we find a marker, eat it and remember its location
        case IMM_MONTHSTART:
        case IMM_YEARSTART:
        case IMM_MONTHEND:
        case IMM_YEAREND:
            if (pmm)
                pmm->rgi[ch] = iWrite;
            break;

        // Otherwise, just copy it to the output
        default:
            pszBuf[iWrite++] = ch;
#ifndef UNICODE
            if (IsDBCSLeadByte(ch) && pszBuf[iRead+1]) {
                pszBuf[iWrite++] = pszBuf[++iRead];
            }
#endif
            break;

        }
        iRead++;
    }
    // NOTREACHED
}

////////////////////////////////////
//
// Like LocalizedLoadString, except that we get the string from
// LOCAL_USER_DEFAULT instead of GetUserDefaultUILanguage().
//
// LOCALE_USER_DEFAULT is the same as GetUserDefaultLCID(), and
// LANGIDFROMLCID(GetUserDefaultLCID()) is the same as GetUserDefaultLangID().
//
// So we pass GetUserDefaultLangID() as the language.
//

int MCLoadString(UINT uID, LPWSTR lpBuffer, int nBufferMax)
{
    return CCLoadStringEx(uID, lpBuffer, nBufferMax, GetUserDefaultLangID());
}

////////////////////////////////////
//
// Get the localized calendar info
//
BOOL UpdateLocaleInfo(MONTHCAL* pmc, LPLOCALEINFO pli)
{
    int    i;
    TCHAR  szBuf[64];
    int    cch;
    LPTSTR pc = szBuf;


    //
    // Get information about the calendar (e.g., is it supported?)
    //
    MCGetCalendarInfo(&pmc->ct);

    //
    // Check if the calendar title is an RTL string
    //
    GetDateFormat(pmc->ct.lcid, 0, NULL, TEXT("MMMM"), szBuf, ARRAYSIZE(szBuf));
    pmc->fHeaderRTL = (WORD) MCIsDateStringRTL(szBuf[0]);

    //
    // get the short date format and sniff it to see if it displays the year
    // or month first
    //
    MCLoadString(IDS_MONTHFMT, pli->szMonthFmt, ARRAYSIZE(pli->szMonthFmt));

    //
    //  Try to get the MONTHYEAR format from NLS.  If not supported by NLS,
    //  then use the hard-coded value in our resources.  Note that we
    //  subtract 4 from the buffer size because we may insert up to four
    //  marker characters.
    //
    COMPILETIME_ASSERT(ARRAYSIZE(szBuf) >= ARRAYSIZE(pli->szMonthYearFmt));
    szBuf[0] = TEXT('\0');

    GetLocaleInfo(pmc->ct.lcid, LOCALE_SYEARMONTH,
                 szBuf, ARRAYSIZE(pli->szMonthYearFmt) - CCH_MARKERS);
    if (!szBuf[0]) {
        MCLoadString(IDS_MONTHYEARFMT, szBuf, ARRAYSIZE(pli->szMonthYearFmt) - CCH_MARKERS);
    }

    MCInsertMarkers(pli->szMonthYearFmt, szBuf);

    //
    //  REARCHITECT this code needs to change to use CAL_ values when we
    //  want to support multiple calendars.
    //

    //
    // Get the month names
    //
    for (i = 0; i < 12; i++)
    {
        cch = GetLocaleInfo(pmc->ct.lcid, LOCALE_SMONTHNAME1 + i,
                            pli->rgszMonth[i], CCHMAXMONTH);
        if (cch == 0)
            // the calendar is pretty useless without month names...
            return(FALSE);
    }

    //
    // Get the days of the week
    //
    for (i = 0; i < 7; i++)
    {
        cch = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SABBREVDAYNAME1 + i,
                            pli->rgszDay[i], CCHMAXABBREVDAY);
        if (cch == 0)
            // the calendar is pretty useless without day names...
            return(FALSE);
    }

    //
    // If we haven't already set what the first day of the week is, get the
    // localized setting.
    // 
    if (!pmc->fFirstDowSet)
    {
        cch = GetLocaleInfo(pmc->ct.lcid, LOCALE_IFIRSTDAYOFWEEK, szBuf, ARRAYSIZE(szBuf));
        if (cch > 0)
            pli->dowStartWeek = szBuf[0] - TEXT('0');
    }

    //
    // Get the first week of the year
    //
    cch = GetLocaleInfo(pmc->ct.lcid, LOCALE_IFIRSTWEEKOFYEAR, szBuf, ARRAYSIZE(szBuf));
    if (cch > 0)
        pli->firstWeek = szBuf[0] - TEXT('0');
    
    // Set up pointers
    for (i = 0; i < 12; i++)
        pli->rgpszMonth[i] = pli->rgszMonth[i];

    for (i = 0; i < 7; i++)
        pli->rgpszDay[i] = pli->rgszDay[i];

    // Get static strings
    MCLoadString(IDS_TODAY, pli->szToday, ARRAYSIZE(pli->szToday));
    MCLoadString(IDS_GOTOTODAY, pli->szGoToToday, ARRAYSIZE(pli->szGoToToday));

    // if we've been initialized
    if (pmc->hinstance)
    {
        SYSTEMTIME st;
        CopyDate(pmc->stMonthFirst, st);
        MCUpdateStartEndDates(pmc, &st);
    }
    return(TRUE);
}

void MCReloadMenus(MONTHCAL *pmc)
{
    int i;

    if (pmc->hmenuCtxt)
        DestroyMenu(pmc->hmenuCtxt);
    if (pmc->hmenuMonth)
        DestroyMenu(pmc->hmenuMonth);

    pmc->hmenuCtxt = CreatePopupMenu();
    if (pmc->hmenuCtxt)
        AppendMenu(pmc->hmenuCtxt, MF_STRING, 1, pmc->li.szGoToToday);

    pmc->hmenuMonth = CreatePopupMenu();
    if (pmc->hmenuMonth)
    {
        for (i = 0; i < 12; i++)
            AppendMenu(pmc->hmenuMonth, MF_STRING, i + 1, pmc->li.rgszMonth[i]);
    }
}

BOOL MCHandleEraseBkgnd(MONTHCAL* pmc, HDC hdc)
{
    RECT rc;

    GetClipBox(hdc, &rc);
    FillRectClr(hdc, &rc, pmc->clr[MCSC_BACKGROUND]);
    return TRUE;   
}


LRESULT MCHandleHitTest(MONTHCAL* pmc, PMCHITTESTINFO phti)
{
    int iMonth;
    RECT rc;
    
    if (!phti || phti->cbSize != sizeof(MCHITTESTINFO))
        return -1;

    phti->uHit = MCHT_NOWHERE;

    MCGetTodayBtnRect(pmc, &rc);
    if (PtInRect(&rc, phti->pt) && MonthCal_ShowToday(pmc))
    {
        phti->uHit = MCHT_TODAYLINK;
    }
    else if (pmc->fSpinPrev = (WORD) PtInRect(&pmc->rcPrev, phti->pt))
    {
        phti->uHit = MCHT_TITLEBTNPREV;        
    }
    else if (PtInRect(&pmc->rcNext, phti->pt))
    {
        phti->uHit = MCHT_TITLEBTNNEXT;        
    }
    else if (FGetOffsetForPt(pmc, phti->pt, &iMonth))
    {
        RECT  rcMonth;   // bounding rect for month containg phti->pt
        POINT ptRel;     // relative point in a month
        int   month;
        int   year;

        MCGetRcForMonth(pmc, iMonth, &rcMonth);
        ptRel.x = phti->pt.x - rcMonth.left;
        ptRel.y = phti->pt.y - rcMonth.top;

        GetYrMoForOffset(pmc, iMonth, &year, &month);
        phti->st.wMonth = (WORD) month;
        phti->st.wYear  = (WORD) year;
            
        // 
        // if calendar is showing week numbers and the point lies in the
        // the week numbers, get the date for day immediately to the right
        // of the week number containing the point
        //
        if (MonthCal_ShowWeekNumbers(pmc) && PtInRect(&pmc->rcWeekNum, ptRel))
        {            
            phti->uHit |= MCHT_CALENDARWEEKNUM;
            phti->pt.x += pmc->rcDayNum.left;
            FGetDateForPt(pmc, phti->pt, &phti->st, NULL, NULL, NULL, NULL);
        }

        //
        // if the point lies in the days of the week header, then return
        // the day of the week containing the point
        //
        else if (PtInRect(&pmc->rcDow, ptRel))
        {            
            int iRow;
            int iCol;
            
            phti->uHit |= MCHT_CALENDARDAY;
            ptRel.y = pmc->rcDayNum.top;
            FGetRowColForRelPt(pmc, ptRel, &iRow, &iCol);
            phti->st.wDayOfWeek = (WORD) iCol;            
        }

        //
        // if the point lies in the actually calendar part, then return the
        // date containg the point
        //
        else if (PtInRect(&pmc->rcDayNum, ptRel))
        {
            int iDay;
            
            // we're in the calendar part!
            phti->uHit |= MCHT_CALENDAR;

            if (FGetDateForPt(pmc, phti->pt, &phti->st, &iDay, NULL, NULL, NULL))
            {                
                phti->uHit |= MCHT_CALENDARDATE;
                
                // if it was beyond the bounds of the days we're showing
                // and also FGetDateForPt returns TRUE, then we're on the boundary
                // of the displayed months
                if (iDay <= 0)
                {
                    phti->uHit |= MCHT_PREV;
                }
                else if (iDay > pmc->rgcDay[iMonth + 1])
                {
                    phti->uHit |= MCHT_NEXT;
                }
            }            
        }
        else
        {
            RECT rcMonthTitle;
            RECT rcYearTitle;

            // otherwise we're in the title
            
            phti->uHit |= MCHT_TITLE;
            MCGetTitleRcsForOffset(pmc, iMonth, &rcMonthTitle, &rcYearTitle);

            if (PtInRect(&rcMonthTitle, phti->pt))
            {
                phti->uHit |= MCHT_TITLEMONTH;
            }
            else if (PtInRect(&rcYearTitle, phti->pt))
            {
                phti->uHit |= MCHT_TITLEYEAR;
            }
        }
    }    

    DebugMsg(TF_MONTHCAL, TEXT("mc: Hittest returns : %d %d %d %d)"), 
             (int)phti->st.wDay,
             (int)phti->st.wMonth, 
             (int)phti->st.wYear,
             (int)phti->st.wDayOfWeek
             );
    
    return phti->uHit;
}

void MonthCal_OnPaint(MONTHCAL *pmc, HDC hdc)
{
    if (hdc)
    {
        MCPaint(pmc, hdc);
    }
    else
    {
        PAINTSTRUCT ps;
        hdc = BeginPaint(pmc->ci.hwnd, &ps);
        MCPaint(pmc, hdc);
        EndPaint(pmc->ci.hwnd, &ps);
    }
}

BOOL MCGetDateFormatWithTempYear(PCALENDARTYPE pct, SYSTEMTIME *pst, LPCTSTR pszFormat, UINT uYear, LPTSTR pszBuf, UINT cchBuf)
{
    BOOL fRc;
    WORD wYear = pst->wYear;
    pst->wYear = (WORD)uYear;
    fRc = GetDateFormat(pct->lcid, 0, pst, pszFormat, pszBuf, cchBuf);
    if (!fRc)
    {
        // AIGH!  I hate Feburary 29.  In case we are Feb 29 1996 and the
        // user changes to a non-leap year, force the day to something valid
        // in February 1997 (or whatever year the user finally picked).
        //
        // We can't blindly smash the day to 1 because the era might change
        // in the middle of the month.
        WORD wDay = pst->wDay;

        ASSERT(pst->wDay == 29);
        pst->wDay = 28;
        fRc = GetDateFormat(pct->lcid, 0, pst, pszFormat, pszBuf, cchBuf);
        pst->wDay = wDay;
    }
    pst->wYear = wYear;
    return fRc;
}

void MCUpdateEditYear(MONTHCAL *pmc)
{
    TCHAR rgch[64];

    ASSERT(pmc->hwndEdit);

    EVAL(MCGetDateFormatWithTempYear(&pmc->ct, &pmc->st, TEXT("yyyy"), pmc->st.wYear, rgch, ARRAYSIZE(rgch)));

    SendMessage(pmc->hwndEdit, WM_SETTEXT, 0, (LPARAM)rgch);
}


LRESULT CALLBACK MonthCalWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    MONTHCAL *pmc;
    LRESULT lres = 0;
        
    if (uMsg == WM_NCCREATE)
        return(MCNcCreateHandler(hwnd));
    
    pmc = MonthCal_GetPtr(hwnd);
    if (pmc == NULL)
        return(DefWindowProc(hwnd, uMsg, wParam, lParam));

    // Dispatch the various messages we can receive
    switch (uMsg)
    {
        
    case WM_CREATE:
        lres = MCCreateHandler(pmc, hwnd, (LPCREATESTRUCT)lParam);
        break;
        
        HANDLE_MSG(pmc, WM_ERASEBKGND, MCHandleEraseBkgnd);

    case WM_PRINTCLIENT:
    case WM_PAINT:
        MonthCal_OnPaint(pmc, (HDC)wParam);
        return(0);

    case WM_KEYDOWN:
        MCHandleKeydown(pmc, wParam, lParam);
        break;

    case WM_KEYUP:
        switch (wParam)
        {   
        case VK_CONTROL:
            pmc->fControl = FALSE;
            break;

        case VK_SHIFT:
            pmc->fShift = FALSE;
            break;
        }
        break;    

        
#if 0
    case WM_CHAR:
        MCHandleChar(pmc, wParam, lParam);
        break;
#endif
                
    case WM_CONTEXTMENU:
        MCContextMenu(pmc, wParam, lParam);
        break;

    case WM_LBUTTONDOWN:
        MCLButtonDown(pmc, wParam, lParam);
        break;

    case WM_LBUTTONUP:
        MCLButtonUp(pmc, wParam, lParam);
        break;

    case WM_MOUSEMOVE:
        MCMouseMove(pmc, wParam, lParam);
        break;

    case WM_GETFONT:
        lres = (LRESULT)pmc->hfont;
        break;

    case WM_SETFONT:
        MCHandleSetFont(pmc, (HFONT)wParam, (BOOL)LOWORD(lParam));
        MCSizeHandler(pmc, &pmc->rc);
        MCUpdateMonthNamePos(pmc);
        break;

    case WM_TIMER:
        MCHandleTimer(pmc, wParam);
        break;

    case WM_NCDESTROY:
        MCNcDestroyHandler(hwnd, pmc, wParam, lParam);
        break;

    case WM_ENABLE:
    {
        BOOL fEnable = wParam ? TRUE:FALSE;
        if (pmc->fEnabled != fEnable)
        {
            pmc->fEnabled = (WORD) fEnable;
            InvalidateRect(pmc->ci.hwnd, NULL, TRUE);
        }
        break;
    }

    case MCMP_WINDOWPOSCHANGED:
    case WM_SIZE:
    {
        RECT rc;

        if (uMsg==MCMP_WINDOWPOSCHANGED)
        {
            GetClientRect(pmc->ci.hwnd, &rc);
        }
        else
        {
            rc.left   = 0;
            rc.top    = 0;
            rc.right  = GET_X_LPARAM(lParam);
            rc.bottom = GET_Y_LPARAM(lParam);
        }

        lres = MCSizeHandler(pmc, &rc);
        break;
    }

    case WM_CANCELMODE:
        PostMessage(pmc->ci.hwnd, WM_LBUTTONUP, 0, 0xFFFFFFFF);
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);

        if (lParam == 0 ||
#ifdef UNICODE_WIN9x
            !lstrcmpiA((LPSTR)lParam, "Intl")
#else
            !lstrcmpi((LPTSTR)lParam, TEXT("Intl"))
#endif
           )
        {
            UpdateLocaleInfo(pmc, &pmc->li);
            MCReloadMenus(pmc);
            InvalidateRect(hwnd, NULL, TRUE);
            wParam = 0;             // force MCCalcSizes to happen
        }
        if (wParam == 0 || wParam == SPI_SETNONCLIENTMETRICS)
        {
            MCCalcSizes(pmc);
            PostMessage(pmc->ci.hwnd, MCMP_WINDOWPOSCHANGED, 0, 0);
        }

        break;

    case WM_THEMECHANGED:
        if (pmc->hThemeScroll)
        {
            CloseThemeData(pmc->hThemeScroll);
        }

        pmc->hThemeScroll = OpenThemeData(pmc->ci.hwnd, L"ScrollBar");
        InvalidateRect(pmc->ci.hwnd, NULL, TRUE);
        break;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&pmc->ci, lParam);
        break;

    case WM_STYLECHANGING:
        lres = MCOnStyleChanging(pmc, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        break;

    case WM_STYLECHANGED:
        lres = MCOnStyleChanged(pmc, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        break;

    case WM_NOTIFY: {
        LPNMHDR pnm = (LPNMHDR)lParam;
        switch (pnm->code)
        {
        case UDN_DELTAPOS:
            if (pnm->hwndFrom == pmc->hwndUD)
            {
                // A notification from the UpDown control buddied
                // with the currently popped up monthcal, adjust the
                // edit box appropriately.  We use UDN_DELTAPOS instad
                // of WM_VSCROLL because we care only about the delta and
                // not the absolute number. The absolute number causes us
                // problems in localized calendars.
                LPNM_UPDOWN pnmdp = (LPNM_UPDOWN)lParam;
                UINT yr = pmc->st.wYear + pnmdp->iDelta;
                UINT yrMin, yrMax;
                int delta;

                yrMin = pmc->stMin.wYear;
                if (yr < yrMin)
                    yr = yrMin;

                yrMax = pmc->stMax.wYear;
                if (yr > yrMax)
                    yr = yrMax;

                delta = yr - pmc->st.wYear;
                pmc->st.wYear = (WORD)yr;
                if (delta) {
                    MCIncrStartMonth(pmc, delta * 12, FALSE);
                    MCNotifySelChange(pmc,MCN_SELCHANGE);

                }
            }
            break;
        }
    } // WM_NOTIFY switch
        break;

    case WM_VSCROLL:
        // this must be coming from our UpDown control buddied
        // with the currently popped up monthcal, adjust the
        // edit box appropriately
        // We must do this on WM_VSCROLL rather than UDN_DELTAPOS
        // since we need to fix the selection after the updown mangled it
        MCUpdateEditYear(pmc);
        break;


    //
    // MONTHCAL specific messages
    //


    // MCM_GETCURSEL wParam=void lParam=LPSYSTEMTIME
    //   sets *lParam to the currently selected SYSTEMTIME
    //   returns TRUE on success, FALSE on error (such as multi-select MONTHCAL)
    case MCM_GETCURSEL:
        if (!MonthCal_IsMultiSelect(pmc))
        {
            LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;
            if (pst)
            {
                ZeroMemory(pst, sizeof(SYSTEMTIME));
                // Bug#94368 raymondc v6. Need to zero out the time fields instead of
                // setting them to garbage.  This confuses MFC.
                *pst = pmc->st;
                pst->wDayOfWeek = (DowFromDate(pst)+1) % 7;  // this returns 0==sun
                lres = 1;
            }
        }
        break;

    // MCM_SETCURSEL wParam=void lParam=LPSYSTEMTIME
    //   sets the currently selected SYSTEMTIME to *lParam
    //   returns TRUE on success, FALSE on error (such as multi-select MONTHCAL or bad parameters)
    case MCM_SETCURSEL:
    {
        LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;

        if (MonthCal_IsMultiSelect(pmc) ||
            !IsValidDate(pst))
        {
            break;
        }

        if (0 == CmpDate(pst, &pmc->st))
        {
            // if no change, just return
            lres = 1;
            break;
        }

        pmc->rcDayOld = pmc->rcDayCur;

        pmc->fNoNotify = TRUE;
        lres = MCSetDate(pmc, pst);
        pmc->fNoNotify = FALSE;

        if (lres)
        {
            InvalidateRect(pmc->ci.hwnd, &pmc->rcDayOld, FALSE);     // erase old highlight
            InvalidateRect(pmc->ci.hwnd, &pmc->rcDayCur, FALSE);     // draw new highlight
        }

        UpdateWindow(pmc->ci.hwnd);
        break;
    }

    // MCM_GETMAXSELCOUNT wParam=void lParam=void
    //   returns the max number of selected days allowed
    case MCM_GETMAXSELCOUNT:
        lres = (LRESULT)(MonthCal_IsMultiSelect(pmc) ? pmc->cSelMax : 1);
        break;

    // MCM_SETMAXSELCOUNT wParam=int lParam=void
    //   sets the maximum selectable date range to wParam days
    //   returns TRUE on success, FALSE on error (such as single-select MONTHCAL)
    case MCM_SETMAXSELCOUNT:
        if (!MonthCal_IsMultiSelect(pmc) || (int)wParam < 1)
            break;

        pmc->cSelMax = (int)wParam;
        lres = 1;
        break;

    // MCM_GETSELRANGE wParam=void lParam=LPSYSTEMTIME[2]
    //   sets *lParam to the first date of the range, *(lParam+1) to the second date
    //   returns TRUE on success, FALSE otherwise (such as single-select MONTHCAL)
    case MCM_GETSELRANGE:
    {
        LPSYSTEMTIME pst;

        pst = (LPSYSTEMTIME)lParam;

        if (!pst)
            break;

        ZeroMemory(pst, sizeof(SYSTEMTIME) * 2);

        if (!MonthCal_IsMultiSelect(pmc))
            break;

        *pst = pmc->st;
        pst->wDayOfWeek = (DowFromDate(pst)+1) % 7;  // this returns 0==sun
        pst++;
        *pst = pmc->stEndSel;
        pst->wDayOfWeek = (DowFromDate(pst)+1) % 7;  // this returns 0==sun
        lres = 1;

        break;
    }

    // MCM_SETSELRANGE wParam=void lParam=LPSYSTEMTIME[2]
    //   sets the currently selected day range to *lparam to *(lParam+1)
    //   returns TRUE on success, FALSE otherwise (such as single-select MONTHCAL or bad params)
    case MCM_SETSELRANGE:
    {
        LPSYSTEMTIME pstStart = (LPSYSTEMTIME)lParam;
        LPSYSTEMTIME pstEnd = &pstStart[1];
        SYSTEMTIME stStart;
        SYSTEMTIME stEnd;

        if (!MonthCal_IsMultiSelect(pmc) ||
            !IsValidDate(pstStart) ||
            !IsValidDate(pstEnd))
            break;

        // IE3 shipped without validating the time portion of this message.
        // Make sure our stored systemtimes are always valid (so we will
        // always give out valid systemtime structs).
        //
        if (!IsValidTime(pstStart))
            CopyTime(pmc->st, *pstStart);
        if (!IsValidTime(pstEnd))
            CopyTime(pmc->stEndSel, *pstEnd);

        if (CmpDate(pstStart, pstEnd) > 0)
        {
            stEnd = *pstStart;
            stStart = *pstEnd;
            pstStart = &stStart;
            pstEnd = &stEnd;
        }

        if (CmpDate(pstStart, &pmc->stMin) < 0)
            break;

        if (CmpDate(pstEnd, &pmc->stMax) > 0)
            break;

        if (DaysBetweenDates(pstStart, pstEnd) >= pmc->cSelMax)
            break;


        if (0 == CmpDate(pstStart, &pmc->st) &&
            0 == CmpDate(pstEnd, &pmc->stEndSel))
        {
            // if no change, just return
            lres = 1;
            break;
        }

        pmc->stStartPrev = pmc->st;
        pmc->stEndPrev = pmc->stEndSel;

        pmc->fNoNotify = TRUE;

        lres = MCSetDate(pmc, pstEnd);
        if (lres)
        {
            pmc->st = *pstStart;
            pmc->stEndSel = *pstEnd;

            MCInvalidateDates(pmc, &pmc->stStartPrev, &pmc->stEndPrev);
            MCInvalidateDates(pmc, &pmc->st, &pmc->stEndSel);
            UpdateWindow(pmc->ci.hwnd);
        }

        pmc->fNoNotify = FALSE;

        break;
    }
    
    // MCM_GETMONTHRANGE wParam=GMR_flags lParam=LPSYSTEMTIME[2]
    // if GMR_VISIBLE, returns the range of selectable (non-grayed) displayed
    // days. if GMR_DAYSTATE, returns the range of every (incl grayed) days.
    // returns the number of months the above range spans.
    case MCM_GETMONTHRANGE:
    {
        LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;

        if (pst)
        {
            ZeroMemory(pst, 2 * sizeof(SYSTEMTIME));

            if (wParam == GMR_VISIBLE)
            {
                pst[0] = pmc->stMonthFirst;
                pst[1] = pmc->stMonthLast;
            }
            else if (wParam == GMR_DAYSTATE)
            {
                pst[0] = pmc->stViewFirst;
                pst[1] = pmc->stViewLast;
            }
        }

        lres = (LRESULT)pmc->nMonths;
        if (wParam == GMR_DAYSTATE)
            lres += 2;
        
        break;
    }

    // MCM_SETDAYSTATE wParam=int lParam=LPDAYSTATE
    // updates the MONTHCAL's DAYSTATE, only for MONTHCALs with DAYSTATE enabled
    // the range of months represented in the DAYSTATE array passed in lParam 
    // should match that of the MONTHCAL
    // wParam count of items in DAYSTATE array
    // lParam pointer to array of DAYSTATE items 
    // returns FALSE if not DAYSTATE enabled or if an error occurs, TRUE otherwise
    case MCM_SETDAYSTATE:
    {
        MONTHDAYSTATE *pmds = (MONTHDAYSTATE *)lParam;
        int i;

        if (!MonthCal_IsDayState(pmc) ||
            (int)wParam != (pmc->nMonths + 2))
            break;

        for (i = 0; i < (int)wParam; i++)
        {
            pmc->rgdayState[i] = *pmds;
            pmds++;
        }
        MCInvalidateMonthDays(pmc);
        lres = 1;

        break;
    }

    // MCM_GETMINREQRECT wParam=void lParam=LPRECT
    //   sets *lParam to the minimum size required to display one month in full.
    //   Note: this is dependent upon the currently selected font.
    //   Apps can take the returned size and double the width to get two calendars
    //   displayed.
    case MCM_GETMINREQRECT:
    {
        LPRECT prc = (LPRECT)lParam;

        prc->left   = 0;
        prc->top    = 0;
        prc->right  = pmc->dxMonth;
        prc->bottom = pmc->dyMonth;
        if (MonthCal_ShowToday(pmc))
        {
            prc->bottom += pmc->dyToday;
        }

        AdjustWindowRect(prc, pmc->ci.style, FALSE);

        // This is a bogus message, lParam should really be LPSIZE.
        // Make sure left and top are 0 (AdjustWindowRect will make these negative).
        prc->right  -= prc->left;
        prc->bottom -= prc->top;
        prc->left    = 0;
        prc->top     = 0;

        lres = 1;

        break;
    }

    // MCM_GETMAXTODAYWIDTH wParam=void lParam=LPDWORD
    //   sets *lParam to the width of the "today" string, so apps
    //   can figure out how big to make the calendar (max of MCM_GETMINREQRECT
    //   and MCM_GETMAXTODAYWIDTH).
    case MCM_GETMAXTODAYWIDTH:
    {
        RECT rc;

        rc.left = 0;
        rc.top = 0;
        rc.right = pmc->dxToday;
        rc.bottom = pmc->dyToday;

        AdjustWindowRect(&rc, pmc->ci.style, FALSE);

        lres = rc.right - rc.left;
        break;
    }

    case MCM_HITTEST:
        return MCHandleHitTest(pmc, (PMCHITTESTINFO)lParam);
        
    case MCM_SETCOLOR:

        if (wParam < MCSC_COLORCOUNT) 
        {
            COLORREF clr = pmc->clr[wParam];
            pmc->clr[wParam] = (COLORREF)lParam;
            InvalidateRect(hwnd, NULL, wParam == MCSC_BACKGROUND);
            return clr;
        }
        return -1;
        
    case MCM_GETCOLOR:
        if (wParam < MCSC_COLORCOUNT) 
            return pmc->clr[wParam];
        return -1;
        
    case MCM_SETFIRSTDAYOFWEEK:
    {
        lres = MAKELONG(pmc->li.dowStartWeek, (BOOL)pmc->fFirstDowSet);
        if (lParam == (LPARAM)-1) {
            pmc->fFirstDowSet = FALSE;
        } else if (lParam < 7) {
            pmc->fFirstDowSet = TRUE;
            pmc->li.dowStartWeek = (TCHAR)lParam;
        }
        UpdateLocaleInfo(pmc, &pmc->li);
        InvalidateRect(hwnd, NULL, FALSE);
        return lres;
    }
        
    case MCM_GETFIRSTDAYOFWEEK:
        return MAKELONG(pmc->li.dowStartWeek, (BOOL)pmc->fFirstDowSet);
        
    case MCM_SETTODAY:
        MCSetToday(pmc, (SYSTEMTIME*)lParam);
        break;
        
    case MCM_GETTODAY:
        if (lParam) {
            *((SYSTEMTIME*)lParam) = pmc->stToday;
            return TRUE;
        }
        return FALSE;

    case MCM_GETRANGE:
        if (lParam)
        {
            LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;

            ZeroMemory(pst, sizeof(SYSTEMTIME)*2);

            ASSERT(lres == 0);
            if (pmc->fMinYrSet)
            {
                pst[0] = pmc->stMin;
                lres = GDTR_MIN;
            }
            if (pmc->fMaxYrSet)
            {
                pst[1] = pmc->stMax;
                lres |= GDTR_MAX;
            }
        }
        break;

    case MCM_SETRANGE:
        if (lParam)
        {
            LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;

            if (((wParam & GDTR_MIN) && !IsValidDate(pst)) ||
                ((wParam & GDTR_MAX) && !IsValidDate(&pst[1])))
                break;

            // IE3 did not validate the time portion of this struct
            // use stToday time fields cuz pmc->stMin/Max may be zero
            if ((wParam & GDTR_MIN) && !IsValidTime(pst))
                CopyTime(pmc->stToday, pst[0]);
            if ((wParam & GDTR_MAX) && !IsValidTime(&pst[1]))
                CopyTime(pmc->stToday, pst[1]);

            if (wParam & GDTR_MIN)
            {
                pmc->stMin = *pst;
                pmc->fMinYrSet = TRUE;
            }
            else
            {
                pmc->stMin = c_stEpoch;
                pmc->fMinYrSet = FALSE;
            }
            pst++;
            if (wParam & GDTR_MAX)
            {
                pmc->stMax = *pst;
                pmc->fMaxYrSet = TRUE;
            }
            else
            {
                pmc->stMax = c_stArmageddon;
                pmc->fMaxYrSet = FALSE;
            }
            
            if (pmc->fMaxYrSet && pmc->fMinYrSet && CmpDate(&pmc->stMin, &pmc->stMax) > 0)
            {
                SYSTEMTIME stTemp = pmc->stMin;
                pmc->stMin = pmc->stMax;
                pmc->stMax = stTemp;
            }
            lres = TRUE;
        }
        break;

    case MCM_GETMONTHDELTA:
        if (pmc->fMonthDelta)
            lres = pmc->nMonthDelta;
        else
            lres = pmc->nMonths;
        break;

    case MCM_SETMONTHDELTA:
        if (pmc->fMonthDelta)
            lres = pmc->nMonthDelta;
        else
            lres = 0;
        if ((int)wParam==0)
            pmc->fMonthDelta = FALSE;
        else
        {
            pmc->fMonthDelta = TRUE;
            pmc->nMonthDelta = (int)wParam;
        }
        break;

    default:
        if (CCWndProc(&pmc->ci, uMsg, wParam, lParam, &lres))
            return lres;
        
        lres = DefWindowProc(hwnd, uMsg, wParam, lParam);
        break;
    } /* switch (uMsg) */

    return(lres);
}

LRESULT MCNcCreateHandler(HWND hwnd)
{
    MONTHCAL *pmc;

    // Allocate storage for the dtpick structure
    pmc = (MONTHCAL *)NearAlloc(sizeof(MONTHCAL));
    if (!pmc)
    {
        DebugMsg(DM_WARNING, TEXT("mc: Out Of Near Memory"));
        return(0L);
    }

    MonthCal_SetPtr(hwnd, pmc);

    return(1L);
}

void MCInitColorArray(COLORREF* pclr)
{
    pclr[MCSC_BACKGROUND]   = g_clrWindow;
    pclr[MCSC_MONTHBK]      = g_clrWindow;
    pclr[MCSC_TEXT]         = g_clrWindowText;
    pclr[MCSC_TITLEBK]      = GetSysColor(COLOR_ACTIVECAPTION);
    pclr[MCSC_TITLETEXT]    = GetSysColor(COLOR_CAPTIONTEXT);
    pclr[MCSC_TRAILINGTEXT] = g_clrGrayText;
}

LRESULT MCCreateHandler(MONTHCAL *pmc, HWND hwnd, LPCREATESTRUCT lpcs)
{
    HFONT      hfont;
    SYSTEMTIME st;

    // Validate data
    //
    if (lpcs->style & MCS_INVALIDBITS)
        return(-1);

    CIInitialize(&pmc->ci, hwnd, lpcs);
    UpdateLocaleInfo(pmc, &pmc->li);   

    // Initialize our data.
    //
    pmc->hinstance = lpcs->hInstance;
    
    pmc->fEnabled  = !(pmc->ci.style & WS_DISABLED);
    
    pmc->hbrushToday = CreateSolidBrush(CAL_COLOR_TODAY);

    MCReloadMenus(pmc);

    // Default minimum date is the epoch
    pmc->stMin = c_stEpoch;

    // Default maximum date is armageddon
    pmc->stMax = c_stArmageddon;

    GetLocalTime(&pmc->stToday);
    pmc->st = pmc->stToday;
    if (MonthCal_IsMultiSelect(pmc))
        pmc->stEndSel = pmc->st;

    // make sure the time portions of these are valid. they are never
    // touched after this point
    pmc->stMonthFirst = pmc->st;
    pmc->stMonthLast = pmc->st;
    pmc->stViewFirst = pmc->st;
    pmc->stViewLast = pmc->st;

    pmc->cSelMax = CAL_DEF_SELMAX;

    hfont = NULL;
    if (lpcs->hwndParent)
        hfont = (HFONT)SendMessage(lpcs->hwndParent, WM_GETFONT, 0, 0);
    if (hfont == NULL)
        hfont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    MCHandleSetFont(pmc, hfont, FALSE);
    
    CopyDate(pmc->st, st);
    // Can we start at January?
    if (st.wMonth <= (pmc->nViewRows * pmc->nViewCols))
        st.wMonth = 1;
    
    MCUpdateStartEndDates(pmc, &st);
    
    pmc->idTimerToday = SetTimer(pmc->ci.hwnd, CAL_TODAYTIMER, CAL_SECTODAYTIMER * 1000, NULL);

    MCInitColorArray(pmc->clr);

    pmc->hThemeScroll = OpenThemeData(pmc->ci.hwnd, L"ScrollBar");

    return(0);
}

LRESULT MCOnStyleChanging(MONTHCAL *pmc, UINT gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE)
    {
        DWORD changeFlags = pmc->ci.style ^ pinfo->styleNew;

        // Don't allow these bits to change
        changeFlags &= MCS_MULTISELECT | MCS_DAYSTATE | MCS_INVALIDBITS;

        pinfo->styleNew ^= changeFlags;
    }

    return(0);
}

LRESULT MCOnStyleChanged(MONTHCAL *pmc, UINT gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE)
    {
        DWORD changeFlags = pmc->ci.style ^ pinfo->styleNew;

        ASSERT(!(changeFlags & (MCS_MULTISELECT|MCS_DAYSTATE|MCS_INVALIDBITS)));

        pmc->ci.style = pinfo->styleNew;

        if (changeFlags & MCS_WEEKNUMBERS)
        {
            MCCalcSizes(pmc);
            MCUpdateRcDayCur(pmc, &pmc->st);
            //MCUpdateToday(pmc);
        }

        // save a touch of code and share the MCUpdateToday
        // call with MCS_WEEKNUMBERS above
        if (changeFlags & (MCS_NOTODAY|MCS_NOTODAYCIRCLE|MCS_WEEKNUMBERS))
        {
            MCUpdateToday(pmc);
        }

        if (changeFlags & (WS_BORDER | WS_CAPTION | WS_THICKFRAME)) {
            // the changing of these bits affect the size of the window
            // but not until after this message is handled
            // so post ourself a message.
            PostMessage(pmc->ci.hwnd, MCMP_WINDOWPOSCHANGED, 0, 0);
        }

        if (changeFlags)
            InvalidateRect(pmc->ci.hwnd, NULL, TRUE);
    }
    else if (gwl == GWL_EXSTYLE)
    {
        if ((pinfo->styleOld ^ pinfo->styleNew) & RTL_MIRRORED_WINDOW)
        {
            MCUpdateMonthNamePos(pmc);
        }
    }

    return(0);
}

void MCCalcSizes(MONTHCAL *pmc)
{
    HDC   hdc;
    HFONT hfontOrig;
    int   i, dxMax, dyMax, dxExtra;
    RECT  rect;
    TCHAR szBuf[128];
    TCHAR szDateFmt[64];

    // get sizing info for bold font...
    hdc = GetDC(pmc->ci.hwnd);
    hfontOrig = SelectObject(hdc, (HGDIOBJ)pmc->hfontBold);

    MGetTextExtent(hdc, g_szTextExtentDef, 2, &dxMax, &dyMax);
    MGetTextExtent(hdc, g_szTextExtentDef, 4, &pmc->dxYearMax, NULL);

    GetDateFormat(pmc->ct.lcid, DATE_SHORTDATE, &pmc->stToday,
        NULL, szDateFmt, ARRAYSIZE(szDateFmt));
    wsprintf(szBuf,TEXT("%s %s"),pmc->li.szToday,szDateFmt);
    MGetTextExtent(hdc, szBuf, -1, &pmc->dxToday, &pmc->dyToday);
    // REARCHITECT raymondc - hard-coded numbers are accessibility-incompatible
    pmc->dyToday += 4;

    //
    //  Cache these values so we don't go wacko if the app fails to
    //  forward WM_WININCHANGE messages into us and the user changes
    //  scrollbar widths.  We'll draw with the wrong width, but at
    //  least they will be consistently wrong.
    //
    pmc->dxArrowMargin = DX_ARROWMARGIN;
    pmc->dxCalArrow    = DX_CALARROW;
    pmc->dyCalArrow    = DY_CALARROW;

    //
    //  The banner bar consists of
    //
    //  margin + scrollbutton + spacer +
    //                      MonthName yyyy +
    //                        + spacer + scrollbutton + margin
    //
    //  Margin is dxArrowMargin
    //
    //  Scrollbutton = dxCalArrow
    //
    //  Spacer = border + CXVSCROLL + border
    //
    //  The spacer needs to be large enough for us to insert an updown
    //  control when it comes time to spin the year.  We don't need to
    //  cache the spacer anywhere - its value is implicit from the others.
    //
    //  The actual width is divided by the number of columns we need
    //  (typically 7, but perhaps 8 if we are also displaying week numbers).
    //
    //  We round the division down - later, we'll add some random futz
    //  to compensate.
    //
    dxExtra = pmc->dxArrowMargin + pmc->dxCalArrow +
                        (g_cxBorder + g_cxVScroll + g_cxBorder);
    dxExtra = dxExtra + dxExtra; // left + right

    for (i = 0; i < 12; i++)
    {
        int dxTemp;

        // REARCHITECT raymondc - not localization safe for languages which change
        // month forms based on context
        wsprintf(szBuf,TEXT("%s %s"),pmc->li.rgszMonth[i],g_szTextExtentDef);
        
        MGetTextExtent(hdc, szBuf, -1, &dxTemp, NULL);
        dxTemp += dxExtra;
        dxTemp = dxTemp / (CALCOLMAX + (MonthCal_ShowWeekNumbers(pmc) ? 1:0));
        if (dxTemp > dxMax)
            dxMax = dxTemp;                    
    }
        
    SelectObject(hdc, (HGDIOBJ)pmc->hfont);
    for (i = 0; i < 7; i++)
    {
        SIZE  size;
        MGetTextExtent(hdc, pmc->li.rgszDay[i], -1, (LPINT)&size.cx, (LPINT)&size.cy);
        if (size.cx > dxMax)
            dxMax = size.cx;
        if (size.cy > dyMax)
            dyMax = size.cy;
    }

    if (dyMax < pmc->dyCalArrow / 2)
        dyMax = pmc->dyCalArrow / 2;

    SelectObject(hdc, (HGDIOBJ)hfontOrig);
    ReleaseDC(pmc->ci.hwnd, hdc);

    pmc->dxCol = dxMax + 2;
    pmc->dyRow = dyMax + 2;
    pmc->dxMonth = pmc->dxCol * (CALCOLMAX + (MonthCal_ShowWeekNumbers(pmc) ? 1:0)) + 1;
    pmc->dyMonth = pmc->dyRow * (CALROWMAX + 3) + 1; // we add 2 for the month name and day names

    pmc->dxToday += pmc->dxCol+6+CALBORDER; // +2 for -1 at ends and 4 for shift of circle 
    if (pmc->dxMonth > pmc->dxToday)
        pmc->dxToday = pmc->dxMonth;
     
    // Space for month name (tile bar area of each month)
    pmc->rcMonthName.left   = 0;
    pmc->rcMonthName.top    = 0;
    pmc->rcMonthName.right  = pmc->dxMonth;
    pmc->rcMonthName.bottom = pmc->rcMonthName.top + (pmc->dyRow * 2);

    // Space for day-of-week
    pmc->rcDow.left   = 0;
    pmc->rcDow.top    = pmc->rcMonthName.bottom;
    pmc->rcDow.right  = pmc->dxMonth;
    pmc->rcDow.bottom = pmc->rcDow.top + pmc->dyRow;

    // Space for week numbers
    if (MonthCal_ShowWeekNumbers(pmc))
    {
        pmc->rcWeekNum.left   = pmc->rcDow.left;
        pmc->rcWeekNum.top    = pmc->rcDow.bottom;
        pmc->rcWeekNum.right  = pmc->rcWeekNum.left + pmc->dxCol;
        pmc->rcWeekNum.bottom = pmc->dyMonth;

        pmc->rcDow.left  += pmc->dxCol;          // shift days of week
    }

    // Space for the day numbers
    pmc->rcDayNum.left   = pmc->rcDow.left;
    pmc->rcDayNum.top    = pmc->rcDow.bottom;
    pmc->rcDayNum.right  = pmc->rcDayNum.left + (CALCOLMAX * pmc->dxCol);
    pmc->rcDayNum.bottom = pmc->dyMonth;

    GetClientRect(pmc->ci.hwnd, &rect);

    MCRecomputeSizing(pmc, &rect);
}

void MCHandleSetFont(MONTHCAL *pmc, HFONT hfont, BOOL fRedraw)
{
    LOGFONT lf;
    HFONT   hfontBold;

    if (hfont == NULL)
        hfont = (HFONT)GetStockObject(SYSTEM_FONT);

    GetObject(hfont, sizeof(LOGFONT), (LPVOID)&lf);
    // we want to make sure that the bold days are obviously different
    // from the non-bold days...
    CCAdjustForBold(&lf);
    hfontBold = CreateFontIndirect(&lf);

    if (hfontBold == NULL)
        return;

    if (pmc->hfontBold)
        DeleteObject((HGDIOBJ)pmc->hfontBold);

    pmc->hfont     = hfont;
    pmc->hfontBold = hfontBold;
    pmc->ci.uiCodePage = GetCodePageForFont(hfont);

    // calculate the new row and column sizes
    MCCalcSizes(pmc);

    if (fRedraw)
    {
        InvalidateRect(pmc->ci.hwnd, NULL, TRUE);
        UpdateWindow(pmc->ci.hwnd);
    }
}

#if 0       // why is this here?  it's not called anywhere??

// Stolen from the windows tips help file 
void DrawTransparentBitmap(HDC hdc, HBITMAP hbmp, RECT *prc, COLORREF cTransparentColor)
{
    COLORREF cColor;
    BITMAP bm;
    HBITMAP hbmAndBack, hbmAndObject, hbmAndMem, hbmSave;
    HGDIOBJ hbmBackOld, hbmObjectOld, hbmMemOld, hbmSaveOld;
    HDC hdcMem, hdcBack, hdcObject, hdcTemp, hdcSave;
    POINT ptSize;
    int d;

    hdcTemp = CreateCompatibleDC(hdc);
    SelectObject(hdcTemp, (HGDIOBJ)hbmp);   // Select the bitmap

    GetObject(hbmp, sizeof(BITMAP), &bm);
    ptSize.x = bm.bmWidth;            // Get width of bitmap
    ptSize.y = bm.bmHeight;           // Get height of bitmap
    DPtoLP(hdcTemp, &ptSize, 1);      // Convert from device to logical points

    d = prc->right - prc->left;
    if (d < ptSize.x)
        ptSize.x = d;
    d = prc->bottom - prc->top;
    if (d < ptSize.y)
        ptSize.y = d;

    // Create some DCs to hold temporary data.
    hdcBack = CreateCompatibleDC(hdc);
    hdcObject = CreateCompatibleDC(hdc);
    hdcMem = CreateCompatibleDC(hdc);
    hdcSave = CreateCompatibleDC(hdc);

    // Create a bitmap for each DC. DCs are required for a number of
    // GDI functions.

    // Monochrome DC
    hbmAndBack = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);

    // Monochrome DC
    hbmAndObject = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);

    hbmAndMem = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);
    hbmSave = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);

    // Each DC must select a bitmap object to store pixel data.
    hbmBackOld = SelectObject(hdcBack, (HGDIOBJ)hbmAndBack);
    hbmObjectOld = SelectObject(hdcObject, (HGDIOBJ)hbmAndObject);
    hbmMemOld = SelectObject(hdcMem, (HGDIOBJ)hbmAndMem);
    hbmSaveOld = SelectObject(hdcSave, (HGDIOBJ)hbmSave);

    // Set proper mapping mode.
    SetMapMode(hdcTemp, GetMapMode(hdc));

    // Save the bitmap sent here, because it will be overwritten.
    BitBlt(hdcSave, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY);

    // Set the background color of the source DC to the color.
    // contained in the parts of the bitmap that should be transparent
    cColor = SetBkColor(hdcTemp, cTransparentColor);

    // Create the object mask for the bitmap by performing a BitBlt
    // from the source bitmap to a monochrome bitmap.
    BitBlt(hdcObject, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY);

    // Set the background color of the source DC back to the original
    // color.
    SetBkColor(hdcTemp, cColor);

    // Create the inverse of the object mask.
    BitBlt(hdcBack, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, NOTSRCCOPY);

    // Copy the background of the main DC to the destination.
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdc, prc->left, prc->top, SRCCOPY);

    // Mask out the places where the bitmap will be placed.
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, SRCAND);

    // Mask out the transparent colored pixels on the bitmap.
    BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcBack, 0, 0, SRCAND);

    // XOR the bitmap with the background on the destination DC.
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCPAINT);

    // Copy the destination to the screen.
    BitBlt(hdc, prc->left, prc->top, ptSize.x, ptSize.y, hdcMem, 0, 0, SRCCOPY);

    // Place the original bitmap back into the bitmap sent here.
    BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcSave, 0, 0, SRCCOPY);

    // Delete the memory bitmaps.
    SelectObject(hdcBack, hbmBackOld);
    DeleteObject(hbmAndBack);
    SelectObject(hdcObject, hbmObjectOld);
    DeleteObject(hbmAndObject);
    SelectObject(hdcMem, hbmMemOld);
    DeleteObject(hbmAndMem);
    SelectObject(hdcSave, hbmSaveOld);
    DeleteObject(hbmSave);

    // Delete the memory DCs.
    DeleteDC(hdcMem);
    DeleteDC(hdcBack);
    DeleteDC(hdcObject);
    DeleteDC(hdcSave);
    DeleteDC(hdcTemp);
}

#endif      // DEAD CODE

void MCDrawTodayCircle(MONTHCAL *pmc, HDC hdc, RECT *prc)
{
    FrameRect(hdc, prc, pmc->hbrushToday);
}

void MCInvalidateMonthDays(MONTHCAL *pmc)
{
    InvalidateRect(pmc->ci.hwnd, &pmc->rcCentered, FALSE);
}

void MCGetTodayBtnRect(MONTHCAL *pmc, RECT *prc)
{    
    if (pmc->dxToday > pmc->rcCentered.right - pmc->rcCentered.left)
    {
        prc->left   = pmc->rc.left + 1;
        prc->right  = pmc->rc.right - 1;
    }
    else
    {
        prc->left   = pmc->rcCentered.left + 1;
        prc->right  = pmc->rcCentered.right - 1;
    }
    prc->top    = pmc->rcCentered.bottom - pmc->dyToday;
    prc->bottom = pmc->rcCentered.bottom;

    // center the today rect when we only have 1 col and it will fit in window
    if ((pmc->nViewCols == 1) && (pmc->dxToday <= pmc->rc.right - pmc->rc.left))
    {
        int dx =  ((pmc->rcCentered.right - pmc->rcCentered.left) - pmc->dxToday) / 2 - 1;
        prc->left   += dx;
        prc->right  -= dx;
    }
}

void MCPaintArrowBtn(MONTHCAL *pmc, HDC hdc, BOOL fPrev, BOOL fPressed)
{
    int iStateId;
    LPRECT prc;
    UINT   dfcs;
    if (fPrev)
    {
        iStateId = ABS_LEFTNORMAL;
        dfcs = DFCS_SCROLLLEFT;        
        prc  = &pmc->rcPrev;
    }
    else
    {
        iStateId = ABS_RIGHTNORMAL;
        dfcs = DFCS_SCROLLRIGHT;        

        prc  = &pmc->rcNext;
    }

    if (pmc->fEnabled)
    {
        if (fPressed)
        {
            iStateId += 2;
            dfcs |= DFCS_PUSHED | DFCS_FLAT;
        }
    }
    else
    {
        iStateId += 3;       // Disabled
        dfcs |= DFCS_INACTIVE;
    }

    if (pmc->hThemeScroll)
    {
        DrawThemeBackground(pmc->hThemeScroll, hdc, SBP_ARROWBTN, iStateId, prc, 0);

    }
    else
    {
        DrawFrameControl(hdc, prc, DFC_SCROLL, dfcs);
    }
}

void MCPaint(MONTHCAL *pmc, HDC hdc)
{
    RECT    rc, rcT;
    int     irow, icol, iMonth, iYear, iIndex, dx, dy;
    HBRUSH  hbrSelect;
    HGDIOBJ hgdiOrig, hpenOrig;

    pmc->hpen = CreatePen(PS_SOLID, 0, pmc->clr[MCSC_TEXT]);
    hbrSelect = CreateSolidBrush(pmc->clr[MCSC_TITLEBK]);

    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, pmc->clr[MCSC_TEXT]);
    hpenOrig = SelectObject(hdc, GetStockObject(BLACK_PEN));

    rc = pmc->rcCentered;

    FillRectClr(hdc, &rc, pmc->clr[MCSC_MONTHBK]);

    SelectObject(hdc, (HGDIOBJ)pmc->hpen);

    // get the place for top left month
    rc.left   = pmc->rcCentered.left;
    rc.right  = rc.left + pmc->dxMonth;
    rc.top    = pmc->rcCentered.top;
    rc.bottom = rc.top + pmc->dyMonth;

    iMonth = pmc->stMonthFirst.wMonth;
    iYear  = pmc->stMonthFirst.wYear;

    dx = pmc->dxMonth + CALBORDER;
    dy = pmc->dyMonth + CALBORDER;

    iIndex = 0;
    for (irow = 0; irow < pmc->nViewRows; irow++)
    {
        rcT = rc;
        for (icol = 0; icol < pmc->nViewCols; icol++)
        {                
            if (RectVisible(hdc, &rcT))
            {
                MCPaintMonth(pmc, hdc, &rcT, iMonth, iYear, iIndex,
                    iIndex == 0, 
                    iIndex == (pmc->nMonths - 1), hbrSelect);
            }

            rcT.left  += dx;
            rcT.right += dx;

            if (++iMonth > 12)
            {
                iMonth = 1;
                iYear++;
            }

            iIndex++;
        }

        rc.top    += dy;
        rc.bottom += dy;
    }

    // draw the today stuff
    if (MonthCal_ShowToday(pmc))
    {
        MCGetTodayBtnRect(pmc, &rc);
        if (RectVisible(hdc, &rc))
        {
            TCHAR   szDateFmt[32];
            TCHAR   szBuf[64];

            rcT.right = rc.left + 2; // a bit extra border space
    
            if (MonthCal_ShowTodayCircle(pmc)) // this turns on/off the red circle
            {
                rcT.left   = rcT.right + 2;
                rcT.right  = rcT.left + pmc->dxCol - 2;
                rcT.top    = rc.top + 2;
                rcT.bottom = rc.bottom - 2;
                MCDrawTodayCircle(pmc, hdc, &rcT);
            }
    
            rcT.left   = rcT.right + 2;
            rcT.right  = rc.right - 2;
            rcT.top    = rc.top;
            rcT.bottom = rc.bottom;
            hgdiOrig = SelectObject(hdc, (HGDIOBJ)pmc->hfontBold);
            SetTextColor(hdc, pmc->clr[MCSC_TEXT]);
    
            GetDateFormat(pmc->ct.lcid, DATE_SHORTDATE, &pmc->stToday,
                            NULL, szDateFmt, ARRAYSIZE(szDateFmt));
            wsprintf(szBuf, TEXT("%s %s"), pmc->li.szToday, szDateFmt);
            DrawText(hdc, szBuf, lstrlen(szBuf), &rcT,
                        DT_LEFT | DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);
            
            SelectObject(hdc, hgdiOrig);
        }
    }

    // Draw the spin buttons
    if (RectVisible(hdc, &pmc->rcPrev))
        MCPaintArrowBtn(pmc, hdc, TRUE, (pmc->idTimer && pmc->fSpinPrev));
    if (RectVisible(hdc, &pmc->rcNext))
        MCPaintArrowBtn(pmc, hdc, FALSE, (pmc->idTimer && !pmc->fSpinPrev));

    SelectObject(hdc, hpenOrig);

    DeleteObject((HGDIOBJ)hbrSelect);
    DeleteObject((HGDIOBJ)pmc->hpen);
}

//
//  MCGetMonthFormat gets the string to display for the month/year
//  in the passed-in SYSTEMTIME.  This is tricky because of eras.
//  If pmm is non-NULL, it receives the metrics of the
//  formatted month/year string.
//
void MCGetMonthFormat(MONTHCAL *pmc, SYSTEMTIME *pst, LPTSTR rgch, UINT cch, PMONTHMETRICS pmm)
{
    // For all months, we display the name appropriate to the first
    // day of the month.  Note that this means that the title of the
    // month in which the era changes may be confusing.  If the era
    // changes in the middle of a month, we name the month after the
    // previous era, even if the current selection belongs to the next
    // era.  I hope nobody will mind.

#if 0 // code that tried to track the era based on where the selection is
      // but before you can turn this on, you have to find everybody who
      // changes the selection, and that's hard because the monthcal control
      // doesn't have a centralizesd selection changer; people just party on
      // the selection directly
    if (pst->wMonth == pmc->st.wMonth &&
        pst->wYear == pmc->st.wYear) {
        pst->wDay = pmc->st.wDay;
    } else {
        pst->wDay = 1;
    }
#else
    pst->wDay = 1;
#endif

    //
    //  Get the string (all marked up), then extract the markers
    //  to locate the month and year substrings.
    //

    rgch[0] = TEXT('\0');       // In case something horrible happens
    GetDateFormat(pmc->ct.lcid, 0, pst,
                  pmc->li.szMonthYearFmt,
                  rgch, cch);
    MCRemoveMarkers(rgch, pmm);
}

void MCPaintMonth(MONTHCAL *pmc, HDC hdc, RECT *prc, int iMonth, int iYear, int iIndex,
                    BOOL fDrawPrev, BOOL fDrawNext, HBRUSH hbrSelect)
{
    BOOL fBold, fView, fReset;
    RECT rc, rcT;
    int nDay, cdy, irow, icol, crowShow, nweek, isel;
    TCHAR rgch[64];
    LPTSTR psz;
    HGDIOBJ hfontOrig;
    COLORREF clrGrayText, clrHiliteText, clrOld, clrText;
    SYSTEMTIME st = {0};
    int iIndexSave = iIndex;

    clrText       = pmc->clr[MCSC_TEXT];
    clrGrayText   = pmc->clr[MCSC_TRAILINGTEXT];
    clrHiliteText = pmc->clr[MCSC_TITLETEXT];

    hfontOrig = SelectObject(hdc, (HGDIOBJ)pmc->hfont);
    SelectObject(hdc, (HGDIOBJ)pmc->hpen);

    //
    // Draw the Month and Year
    //
    // translate the relative coords to window coords 
    rc = pmc->rcMonthName;
    rc.left   += prc->left;
    rc.right  += prc->left;
    rc.top    += prc->top;
    rc.bottom += prc->top;
    if (RectVisible(hdc, &rc))
    {
        FillRectClr(hdc, &rc, pmc->clr[MCSC_TITLEBK]);

        SetTextColor(hdc, pmc->clr[MCSC_TITLETEXT]);
        SelectObject(hdc, (HGDIOBJ)pmc->hfontBold);

        st.wYear = (WORD) iYear;
        st.wMonth = (WORD) iMonth;
        MCGetMonthFormat(pmc, &st, rgch, ARRAYSIZE(rgch), NULL);

        DrawText(hdc, rgch, lstrlen(rgch), &rc, DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);

#ifdef MARKER_DEBUG
        //
        //  When debugging MCInsertMarker and MCRemoveMarker, draw colored
        //  bars where we think the markers were.
        //
        { RECT rcT = rc;
            rcT.top = rcT.bottom - 2;
            rcT.left  = rc.left + pmc->rgmm[iIndex].rgi[IMM_MONTHSTART];
            rcT.right = rc.left + pmc->rgmm[iIndex].rgi[IMM_MONTHEND];
            FillRectClr(hdc, &rcT, RGB(0xFF, 0, 0));

            rcT.left  = rc.left + pmc->rgmm[iIndex].rgi[IMM_YEARSTART];
            rcT.right = rc.left + pmc->rgmm[iIndex].rgi[IMM_YEAREND];
            FillRectClr(hdc, &rcT, RGB(0, 0xFF, 0));
        }
#endif
        SelectObject(hdc, (HGDIOBJ)pmc->hfont);
    }

    SetTextColor(hdc, pmc->clr[MCSC_TITLEBK]);

    //
    // Draw the days of the month
    //
    // translate the relative coords to window coords 
    rc = pmc->rcDow;
    rc.left   += prc->left;
    rc.right  += prc->left;
    rc.top    += prc->top;
    rc.bottom += prc->top;
    if (RectVisible(hdc, &rc))
    {
        MoveToEx(hdc, rc.left + 4, rc.bottom - 1, NULL);
        LineTo(hdc, rc.right - 4, rc.bottom - 1);

        rc.right = rc.left + pmc->dxCol;

        for (icol = 0; icol < CALCOLMAX; icol++)
        {
            psz = pmc->li.rgszDay[(icol + pmc->li.dowStartWeek) % 7];

            DrawText(hdc, psz, lstrlen(psz), &rc, DT_CENTER | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);
            rc.left  += pmc->dxCol;
            rc.right += pmc->dxCol;
        }
    }

    
    // Check to see how many days from the previous month exist in this months calendar
    nDay = pmc->rgnDayUL[iIndex];   // last day in prev month that won't be shown in this month
    cdy  = pmc->rgcDay[iIndex];     // # of days in prev month

    // Calculate the number of weeks to display
    if (fDrawNext)
        crowShow = CALROWMAX;
    else
        crowShow = ((cdy - nDay) + pmc->rgcDay[iIndex + 1] + 6/* round up */) / 7;

    if (nDay != cdy)
    {
        // start at previous month
        iMonth--;
        if(iMonth <= 0)
        {
            iMonth = 12;
            iYear--;
        }
        nDay++;

        fView = FALSE;
    }
    else
    {
        // start at this month
        iIndex++;                   // this month

        nDay = 1;
        cdy = pmc->rgcDay[iIndex];

        fView = TRUE;
    }

    //
    // Draw the week numbers
    //
    if (MonthCal_ShowWeekNumbers(pmc))
    {
        // translate the relative coords to window coords 
        rc = pmc->rcWeekNum;
        rc.left   += prc->left;
        rc.top    += prc->top;
        rc.right  += prc->left;
        rc.bottom = rc.top + (pmc->dyRow * crowShow);

        // draw the week numbers
        if (RectVisible(hdc, &rc))
        {
            MoveToEx(hdc, rc.right - 1, rc.top + 4, NULL);
            LineTo(hdc, rc.right - 1, rc.bottom - 4);

            st.wYear  = (WORD) iYear;
            st.wMonth = (WORD) iMonth;
            st.wDay   = (WORD) nDay;
            nweek = GetWeekNumber(&st, pmc->li.dowStartWeek, pmc->li.firstWeek);

            rc.bottom = rc.top + pmc->dyRow;

            for (irow = 0; irow < crowShow; irow++)
            {
                wsprintf(rgch, g_szNumFmt, nweek);
                DrawText(hdc, rgch, (nweek > 9 ? 2 : 1), &rc,
                        DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);
                
                rc.top    += pmc->dyRow;
                rc.bottom += pmc->dyRow;
                IncrSystemTime(&st, &st, 1, INCRSYS_WEEK);
                nweek = GetWeekNumber(&st, pmc->li.dowStartWeek, pmc->li.firstWeek);
            }
        }
    }

    if (!fView)
        SetTextColor(hdc, clrGrayText);
    else
        SetTextColor(hdc, clrText);

    rc = pmc->rcDayNum;
    rc.left   += prc->left;
    rc.top    += prc->top;
    rc.right  =  rc.left + pmc->dxCol;
    rc.bottom =  rc.top  + pmc->dyRow;

    fReset = FALSE;
    fBold  = FALSE;

    for (irow = 0; irow < crowShow; irow++)
    {
        rcT = rc;

        for (icol = 0; icol < CALCOLMAX; icol++)
        {
            if ((fView || fDrawPrev) && RectVisible(hdc, &rcT))
            {
                wsprintf(rgch, g_szNumFmt, nDay);

                if (MonthCal_IsDayState(pmc))
                {
                    // if we're in a dropdown we don't display 
                    if (MCIsBoldOffsetDay(pmc, nDay, iIndex))
                    {
                        if (!fBold)
                        {
                            SelectObject(hdc, (HGDIOBJ)pmc->hfontBold);
                            fBold = TRUE;
                        }
                    }
                    else
                    {
                        if (fBold)
                        {
                            SelectObject(hdc, (HGDIOBJ)pmc->hfont);
                            fBold = FALSE;
                        }
                    }
                }

                if (isel = MCIsSelectedDayMoYr(pmc, nDay, iMonth, iYear))
                {
                    int x1, x2;

                    clrOld    = SetTextColor(hdc, clrHiliteText);
                    fReset    = TRUE;

                    SelectObject(hdc, GetStockObject(NULL_PEN));
                     
                    x1 = 0;
                    x2 = 0;
                    if (isel & SEL_DOT)
                    {
                        FillRect(hdc, &rcT, hbrSelect);
                        if (isel == SEL_BEGIN)
                        {
                            x1 = rcT.left + (rcT.right - rcT.left) / 2;
                            x2 = rcT.right;
                        }
                        else if (isel == SEL_END)
                        {
                            x1 = rcT.left;
                            x2 = rcT.left + (rcT.right - rcT.left) / 2;
                        }
                    }
                    else
                    {
                        x1 = rcT.left;
                        x2 = rcT.right;
                    }

                    if (x1 && x2)
                    {
                        Rectangle(hdc, x1, rcT.top + 2, x2 + 1, rcT.bottom - 1);
                    }
                }

                DrawText(hdc, rgch, (nDay > 9 ? 2 : 1), &rcT,
                        DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);

                if (MonthCal_ShowTodayCircle(pmc) && pmc->fToday && iIndexSave == pmc->iMonthToday &&
                    icol == pmc->iColToday && irow == pmc->iRowToday)
                {
                    MCDrawTodayCircle(pmc, hdc, &rcT);
                }

                if (fReset)
                {
                    SetTextColor(hdc, clrOld);
                    fReset = FALSE;
                }
            }

            rcT.left  += pmc->dxCol;
            rcT.right += pmc->dxCol;

            nDay++;
            if (nDay > cdy)
            {
                if (!fDrawNext && iIndex > iIndexSave)
                    goto doneMonth;

                nDay = 1;
                iIndex++;
                cdy = pmc->rgcDay[iIndex];
                iMonth++;
                if (iMonth > 12)
                {
                    iMonth = 1;
                    iYear++;
                }

                fView = !fView;
                SetTextColor(hdc, fView ? clrText : clrGrayText);

                fDrawPrev = fDrawNext;
            }
        }

        rc.top    += pmc->dyRow;
        rc.bottom += pmc->dyRow;
    }

doneMonth:

    SelectObject(hdc, hfontOrig);

    return;
}

int MCIsSelectedDayMoYr(MONTHCAL *pmc, int iDay, int iMonth, int iYear)
{
    SYSTEMTIME st;
    int iBegin, iEnd;
    int iret = 0;

    st.wYear  = (WORD) iYear;
    st.wMonth = (WORD) iMonth;
    st.wDay   = (WORD) iDay;

    iBegin = CmpDate(&st, &pmc->st);

    if (MonthCal_IsMultiSelect(pmc))
    {
        iEnd = CmpDate(&st, &pmc->stEndSel);

        if (iBegin > 0 && iEnd< 0)
            iret = SEL_MID;
        else
        {
            if (iBegin == 0)
                iret |= SEL_BEGIN;
        
            if (iEnd == 0)
                iret |= SEL_END;
        }
    }
    else if (iBegin == 0)
    {
        iret = SEL_DOT;
    }

    return(iret);
}

BOOL MCIsBoldOffsetDay(MONTHCAL *pmc, int nDay, int iIndex)
{
    return(pmc->rgdayState && (pmc->rgdayState[iIndex] & (1L << (nDay - 1))) != 0);
}

void MCNcDestroyHandler(HWND hwnd, MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    if (pmc)
    {
        if (pmc->hThemeScroll)
            CloseThemeData(pmc->hThemeScroll);

        if (pmc->hbrushToday)
            DeleteObject((HGDIOBJ)pmc->hbrushToday);
        if (pmc->hfontBold)
            DeleteObject((HGDIOBJ)pmc->hfontBold);
        
        if (pmc->hmenuCtxt)
            DestroyMenu(pmc->hmenuCtxt);
        if (pmc->hmenuMonth)
            DestroyMenu(pmc->hmenuMonth);

        if (pmc->idTimer)
            KillTimer(pmc->ci.hwnd, pmc->idTimer);
        if (pmc->idTimerToday)
            KillTimer(pmc->ci.hwnd, pmc->idTimerToday);

        MCFreeCalendarInfo(&pmc->ct);

        GlobalFreePtr(pmc);
    }

    // In case rogue messages float through after we have freed the pdtpick, set
    // the handle in the window structure to FFFF and test for this value at 
    // the top of the WndProc 
    MonthCal_SetPtr(hwnd, NULL);

    // Call DefWindowProc32 to free all little chunks of memory such as szName 
    // and rgwScroll.  
    DefWindowProc(hwnd, WM_NCDESTROY, wParam, lParam);
}


/* Computes the following:
 *  nViewCols
 *  nViewRows
 *  rcCentered
 *  rcPrev
 *  rcNext
 */
void MCRecomputeSizing(MONTHCAL *pmc, RECT *prect)
{
    RECT rc;
    int dx, dy, dCal;

    // Space for entire calendar
    pmc->rc = *prect;

    dx = prect->right  - prect->left;
    dy = prect->bottom - prect->top;

    pmc->nViewCols = 1 + (dx - pmc->dxMonth) / (pmc->dxMonth + CALBORDER);
    pmc->nViewRows = 1 + (dy - pmc->dyMonth - pmc->dyToday) / (pmc->dyMonth + CALBORDER);

    // if dx < dxMonth or dy < dyMonth, these can be zero. That's bad...
    if (pmc->nViewCols < 1)
        pmc->nViewCols = 1;
    if (pmc->nViewRows < 1)
        pmc->nViewRows = 1;

    // Make sure we don't display more than CALMONTHMAX months
    while ((pmc->nViewRows * pmc->nViewCols) > CALMONTHMAX)
    {
        if (pmc->nViewRows > pmc->nViewCols)
            pmc->nViewRows--;
        else
            pmc->nViewCols--;
    }

    // RC for the months, centered within the client window
    dCal = pmc->nViewCols * (pmc->dxMonth + CALBORDER) - CALBORDER;
    pmc->rcCentered.left = (dx - dCal) / 2;
    if (pmc->rcCentered.left < 0)
        pmc->rcCentered.left = 0;
    pmc->rcCentered.right = pmc->rcCentered.left + dCal;

    dCal = pmc->nViewRows * (pmc->dyMonth + CALBORDER) - CALBORDER + pmc->dyToday;
    pmc->rcCentered.top = (dy - dCal) / 2;
    if (pmc->rcCentered.top < 0)
        pmc->rcCentered.top = 0;
    pmc->rcCentered.bottom = pmc->rcCentered.top + dCal;

    // Calculate and set RCs for the spin buttons
    rc.top    = pmc->rcCentered.top + (pmc->dyRow * 2 - pmc->dyCalArrow) /2;
    rc.bottom = rc.top + pmc->dyCalArrow;

    rc.left  = pmc->rcCentered.left + pmc->dxArrowMargin;
    rc.right = rc.left + pmc->dxCalArrow;
    pmc->rcPrev = rc;

    rc.right = pmc->rcCentered.right - pmc->dxArrowMargin;
    rc.left  = rc.right - pmc->dxCalArrow;
    pmc->rcNext = rc;
}

LRESULT MCSizeHandler(MONTHCAL *pmc, RECT *prc)
{
    int nMax;
    SYSTEMTIME st;
    int cmo, dmo;

    MCRecomputeSizing(pmc, prc);

    nMax = pmc->nViewRows * pmc->nViewCols;

    
    // Compute new start date
    CopyDate(pmc->stMonthFirst, st);

    // REARCHITECT: this doesn't consider stEndSel
    cmo = (pmc->stMonthLast.wYear - (int)pmc->st.wYear) * 12 +
        (pmc->stMonthLast.wMonth - (int)pmc->st.wMonth);
    dmo = nMax - pmc->nMonths;

    if (-dmo > cmo)
    {
        // Selected mon/yr not in view
        IncrSystemTime(&st, &st, -(cmo + dmo), INCRSYS_MONTH);
        cmo = 0;
    }

    // If the # of months being displayed has changed, then lets try to
    // start the calendar from January.
    if ((dmo != 0) && (cmo + dmo >= pmc->stMonthFirst.wMonth - 1))
        st.wMonth = 1;

    MCUpdateStartEndDates(pmc, &st);

    InvalidateRect(pmc->ci.hwnd, NULL, TRUE);
    UpdateWindow(pmc->ci.hwnd);

    return(0);
}

//
//  For each month being displayed, compute the precise locations of all
//  the gizmos we draw into the month header area.
//
void MCUpdateMonthNamePos(MONTHCAL *pmc)
{
    HDC hdc;
    int iCount;
    SYSTEMTIME st;
    TCHAR rgch[64];
    SIZE size;
    HGDIOBJ hfontOrig;

    hdc = GetDC(pmc->ci.hwnd);
    hfontOrig = SelectObject(hdc, (HGDIOBJ)pmc->hfontBold);

    st = pmc->stMonthFirst;

    for (iCount = 0; iCount < pmc->nMonths; iCount++)
    {
        PMONTHMETRICS pmm = &pmc->rgmm[iCount];
        int i;

        MCGetMonthFormat(pmc, &st, rgch, ARRAYSIZE(rgch), pmm);

        GetTextExtentPoint32(hdc, rgch, lstrlen(rgch), &size);
        pmm->rgi[IMM_START] = (pmc->dxMonth - size.cx) / 2;

        //
        //  Now convert the indices into pixels so we can figure out where
        //  all the strings ended up.
        //
        for (i = IMM_DATEFIRST; i <= IMM_DATELAST; i++) {
            SIZE sizeT;
            // In case of horrible error, pretend the marker was at the
            // beginning of the string.
            sizeT.cx = 0;
            GetTextExtentPoint32(hdc, rgch, pmm->rgi[i], &sizeT);
            pmm->rgi[i] = pmm->rgi[IMM_START] + sizeT.cx;
        }

        //
        //  Now flip the coordinates for RTL.
        //
        if (pmc->fHeaderRTL || IS_WINDOW_RTL_MIRRORED(pmc->ci.hwnd))
        {
            int dxStart, dxEnd;

            // Flip the month...
            dxStart = pmm->rgi[IMM_MONTHSTART] - pmm->rgi[IMM_START];
            dxEnd   = pmm->rgi[IMM_MONTHEND  ] - pmm->rgi[IMM_START];
            pmm->rgi[IMM_MONTHSTART] = pmm->rgi[IMM_START] + size.cx - dxEnd;
            pmm->rgi[IMM_MONTHEND  ] = pmm->rgi[IMM_START] + size.cx - dxStart;

            // Flip the year...
            dxStart = pmm->rgi[IMM_YEARSTART] - pmm->rgi[IMM_START];
            dxEnd   = pmm->rgi[IMM_YEAREND  ] - pmm->rgi[IMM_START];
            pmm->rgi[IMM_YEARSTART] = pmm->rgi[IMM_START] + size.cx - dxEnd;
            pmm->rgi[IMM_YEAREND  ] = pmm->rgi[IMM_START] + size.cx - dxStart;

        }

        //  On to the next month

        if(++st.wMonth > 12)
        {
            st.wMonth = 1;
            st.wYear++;
        }
    }

    SelectObject(hdc, hfontOrig);
    ReleaseDC(pmc->ci.hwnd, hdc);
}

/*
 * Computes the following, given the number of rows & columns available:
 *        stMonthFirst.wMonth
 *        stMonthFirst.wYear
 *        stMonthLast.wMonth
 *        stMonthLast.wYear
 *        nMonths
 *
 * Trashes *pstStart
 */
void MCUpdateStartEndDates(MONTHCAL *pmc, SYSTEMTIME *pstStart)
{
    int iCount, iMonth, iYear;
    int nMonthsToEdge;

    pmc->nMonths = pmc->nViewRows * pmc->nViewCols;

    // make sure pstStart to pstStart+nMonths is within range
    nMonthsToEdge = ((int)pmc->stMax.wYear - (int)pstStart->wYear) * 12 +
                        ((int)pmc->stMax.wMonth - (int)pstStart->wMonth) + 1;
    if (nMonthsToEdge < pmc->nMonths)
        IncrSystemTime(pstStart, pstStart, nMonthsToEdge - pmc->nMonths, INCRSYS_MONTH);

    if (CmpDate(pstStart, &pmc->stMin) < 0)
    {
        CopyDate(pmc->stMin, *pstStart);
    }

    nMonthsToEdge = ((int)pmc->stMax.wYear - (int)pstStart->wYear) * 12 +
                        ((int)pmc->stMax.wMonth - (int)pstStart->wMonth) + 1;
    if (nMonthsToEdge < pmc->nMonths)
        pmc->nMonths = nMonthsToEdge;

    pmc->stMonthFirst.wYear  = pstStart->wYear;
    pmc->stMonthFirst.wMonth = pstStart->wMonth;
    pmc->stMonthFirst.wDay   = 1;
    if (CmpDate(&pmc->stMonthFirst, &pmc->stMin) < 0)
    {
        pmc->stMonthFirst.wDay = pmc->stMin.wDay;
        ASSERT(0==CmpDate(&pmc->stMonthFirst, &pmc->stMin));
    }

    // these ranges are CALMONTHMAX+2 and nMonths <= CALMONTHMAX, so we are safe
    // index 0 corresponds to stViewFirst (DAYSTATE) info
    // index 1..nMonths correspond to stMonthFirst..stMonthLast info
    // index nMonths+1 corresponds to stViewLast (DAYSTATE) info
    //
    iYear  = pmc->stMonthFirst.wYear;
    iMonth = pmc->stMonthFirst.wMonth - 1;
    if(iMonth == 0)
    {
        iMonth = 12;
        iYear--;
    }
    for (iCount = 0; iCount <= pmc->nMonths+1; iCount++)
    {
        int cdy, dow, ddow;

        // number of days in this month
        cdy = GetDaysForMonth(iYear, iMonth);
        pmc->rgcDay[iCount] = cdy;

        // move to "this" month
        if(++iMonth > 12)
        {
            iMonth = 1;
            iYear++;
        }

        // last day of this month NOT visible when viewing NEXT month
        dow = GetStartDowForMonth(iYear, iMonth);
        ddow = dow - pmc->li.dowStartWeek;
        if(ddow < 0)
            ddow += CALCOLMAX;
        pmc->rgnDayUL[iCount] = cdy  - ddow;
    }

    // we want to always have days visible on the previous month
    if (pmc->rgnDayUL[0] == pmc->rgcDay[0])
        pmc->rgnDayUL[0] -= CALCOLMAX;

    IncrSystemTime(&pmc->stMonthFirst, &pmc->stMonthLast, pmc->nMonths - 1, INCRSYS_MONTH);
    pmc->stMonthLast.wDay = (WORD) pmc->rgcDay[pmc->nMonths];
    if (pmc->fMaxYrSet && CmpDate(&pmc->stMonthLast, &pmc->stMax) > 0)
    {
        pmc->stMonthLast.wDay = pmc->stMax.wDay;
        ASSERT(0==CmpDate(&pmc->stMonthLast, &pmc->stMax));
    }
    
    pmc->stViewFirst.wYear  = pmc->stMonthFirst.wYear;
    pmc->stViewFirst.wMonth = pmc->stMonthFirst.wMonth - 1;
    if (pmc->stViewFirst.wMonth == 0)
    {
        pmc->stViewFirst.wMonth = 12;
        pmc->stViewFirst.wYear--;
    }
    pmc->stViewFirst.wDay = pmc->rgnDayUL[0] + 1;

    pmc->stViewLast.wYear  = pmc->stMonthLast.wYear;
    pmc->stViewLast.wMonth = pmc->stMonthLast.wMonth + 1;
    if (pmc->stViewLast.wMonth == 13)
    {
        pmc->stViewLast.wMonth = 1;
        pmc->stViewLast.wYear++;
    }
    // total days - (days in last month + remaining days in previous month)
    pmc->stViewLast.wDay = CALROWMAX * CALCOLMAX -
        (pmc->rgcDay[pmc->nMonths] +
         pmc->rgcDay[pmc->nMonths-1] - pmc->rgnDayUL[pmc->nMonths-1]);

    MCUpdateDayState(pmc);
    MCUpdateRcDayCur(pmc, &pmc->st);
    MCUpdateToday(pmc);
    MCUpdateMonthNamePos(pmc);
}

void MCUpdateToday(MONTHCAL *pmc)
{
    if (MonthCal_ShowTodayCircle(pmc))
    {
        int iMonth;

        iMonth = MCGetOffsetForYrMo(pmc, pmc->stToday.wYear, pmc->stToday.wMonth);
        if (iMonth < 0)
        {
            // today is not visible in the displayed months
            pmc->fToday = FALSE;
        }
        else
        {
            int iDay;

            // today is visible in the displayed months
            pmc->fToday = TRUE;
            
            iDay = pmc->rgcDay[iMonth] - pmc->rgnDayUL[iMonth] + pmc->stToday.wDay - 1;
    
            pmc->iMonthToday = iMonth;
            pmc->iRowToday   = iDay / CALCOLMAX;
            pmc->iColToday   = iDay % CALCOLMAX;
        }
    }
}

BOOL FUpdateRcDayCur(MONTHCAL *pmc, POINT pt)
{
    int iRow, iCol;
    RECT rc;
    SYSTEMTIME st;
    
    if (!FGetDateForPt(pmc, pt, &st, NULL, &iCol, &iRow, &rc))
        return FALSE;

    if (CmpDate(&st, &pmc->stMin) < 0)
        return FALSE;

    if (CmpDate(&st, &pmc->stMax) > 0)
        return FALSE;

    // calculate the day rc
    pmc->rcDayCur.left   = rc.left + pmc->rcDayNum.left + iCol * pmc->dxCol;
    pmc->rcDayCur.top    = rc.top + pmc->rcDayNum.top + iRow * pmc->dyRow;
    pmc->rcDayCur.right  = pmc->rcDayCur.left + pmc->dxCol;
    pmc->rcDayCur.bottom = pmc->rcDayCur.top + pmc->dyRow;

    return(TRUE);
}

void MCUpdateDayState(MONTHCAL *pmc)
{
    HWND hwndParent;

    if (!MonthCal_IsDayState(pmc))
        return;

    hwndParent = GetParent(pmc->ci.hwnd);
    if (hwndParent)
    {
        int i, mon, yr, cmonths;

        yr      = pmc->stViewFirst.wYear;
        mon     = pmc->stViewFirst.wMonth;
        cmonths = pmc->nMonths + 2;

        // don't do anything unless we need to
        if (cmonths != pmc->cds || mon != pmc->dsMonth || yr != pmc->dsYear)
        {
            // this is a small enough to not deal with allocating it
            NMDAYSTATE    nmds;
            MONTHDAYSTATE buffer[CALMONTHMAX+2];

            ZeroMemory(&nmds, sizeof(nmds));
            nmds.stStart.wYear  = (WORD) yr;
            nmds.stStart.wMonth = (WORD) mon;
            nmds.stStart.wDay   = 1;
            nmds.cDayState      = cmonths;
            nmds.prgDayState    = buffer;

            CCSendNotify(&pmc->ci, MCN_GETDAYSTATE, &nmds.nmhdr);

            for (i = 0; i < cmonths; i++)
                pmc->rgdayState[i] = nmds.prgDayState[i];

            pmc->cds     = cmonths;
            pmc->dsMonth = mon;
            pmc->dsYear  = yr;
        }
    }
}

void MCNotifySelChange(MONTHCAL *pmc, UINT uMsg)
{
    HWND hwndParent;

    if (pmc->fNoNotify)
        return;

    hwndParent = GetParent(pmc->ci.hwnd);
    if (hwndParent)
    {
        NMSELCHANGE nmsc;
        ZeroMemory(&nmsc, sizeof(nmsc));

        CopyDate(pmc->st, nmsc.stSelStart);
        if (MonthCal_IsMultiSelect(pmc))
            CopyDate(pmc->stEndSel, nmsc.stSelEnd);

        CCSendNotify(&pmc->ci, uMsg, &nmsc.nmhdr);
    }
}

void MCUpdateRcDayCur(MONTHCAL *pmc, SYSTEMTIME *pst)
{
    int iOff;

    iOff = MCGetOffsetForYrMo(pmc, pst->wYear, pst->wMonth);
    if (iOff >= 0)
        MCGetRcForDay(pmc, iOff, pst->wDay, &pmc->rcDayCur);
}

// returns zero-based index into DISPLAYED months for month
// if month is not in DISPLAYED months, then -1 is returned...
int MCGetOffsetForYrMo(MONTHCAL *pmc, int iYear, int iMonth)
{
    int iOff;

    iOff = ((int)iYear - pmc->stMonthFirst.wYear) * 12 + (int)iMonth - pmc->stMonthFirst.wMonth;

    if (iOff < 0 || iOff >= pmc->nMonths)
        return(-1);

    return(iOff);
}

// iMonth is a zero-based index relative to the DISPLAYED months.
// iDay is a 1-based index of the day of the month,
void MCGetRcForDay(MONTHCAL *pmc, int iMonth, int iDay, RECT *prc)
{
    RECT rc;
    int iPlace, iRow, iCol;

    MCGetRcForMonth(pmc, iMonth, &rc);

    iPlace = pmc->rgcDay[iMonth] - pmc->rgnDayUL[iMonth] + iDay - 1;
    iRow = iPlace / CALCOLMAX;
    iCol = iPlace % CALCOLMAX;

    prc->left   = rc.left   + pmc->rcDayNum.left + (pmc->dxCol * iCol);
    prc->top    = rc.top    + pmc->rcDayNum.top  + (pmc->dyRow * iRow);
    prc->right  = prc->left + pmc->dxCol;
    prc->bottom = prc->top  + pmc->dyRow;
}

//
// This routine gets the bounding rect for the iMonth of the displayed months.
// NOTE: iMonth is a zero-based index relative to the DISPLAYED months,
// counting along the rows.
//
void MCGetRcForMonth(MONTHCAL *pmc, int iMonth, RECT *prc)
{
    int iRow, iCol, d;

    iRow = iMonth / pmc->nViewCols;
    iCol = iMonth % pmc->nViewCols;

    // intialize the rect to be the bounding rect for the month in the
    // top left corner
    prc->left   = pmc->rcCentered.left;
    prc->right  = prc->left + pmc->dxMonth;
    prc->top    = pmc->rcCentered.top;
    prc->bottom = prc->top + pmc->dyMonth;

    if (iCol)       // slide the rect across to the correct column
    {
        d = (pmc->dxMonth + CALBORDER) * iCol;
        prc->left  += d;
        prc->right += d;
    }
    if (iRow)       // slide the rect down to the correct row
    {
        d = (pmc->dyMonth + CALBORDER) * iRow;
        prc->top    += d;
        prc->bottom += d;
    }
}

// Changes starting month by nDelta
// returns number of months actually changed
int FIncrStartMonth(MONTHCAL *pmc, int nDelta, BOOL fNoCurDayChange)
{
    SYSTEMTIME stStart;

    int nOldStartYear  = pmc->stMonthFirst.wYear;
    int nOldStartMonth = pmc->stMonthFirst.wMonth;

    IncrSystemTime(&pmc->stMonthFirst, &stStart, nDelta, INCRSYS_MONTH);

    // MCUpdateStartEndDates takes stMin/stMax into account
    MCUpdateStartEndDates(pmc, &stStart);

    if (!fNoCurDayChange)
    {
        int cday;

        // REARCHITECT: we arbitrarily set the currently selected day
        // to be in the new stMonthFirst, but given the way the
        // control works, I doubt we ever hit this code. what's it for??

        if (MonthCal_IsMultiSelect(pmc))
            cday = DaysBetweenDates(&pmc->st, &pmc->stEndSel);

        // need to set date for focus here
        pmc->st.wMonth = pmc->stMonthFirst.wMonth;
        pmc->st.wYear  = pmc->stMonthFirst.wYear;

        // Check to see if the day is in range, eg, Jan 31 -> Feb 28
        if (pmc->st.wDay > pmc->rgcDay[1])
            pmc->st.wDay = (WORD) pmc->rgcDay[1];

        if (MonthCal_IsMultiSelect(pmc))
            IncrSystemTime(&pmc->st, &pmc->stEndSel, cday, INCRSYS_DAY);

        MCNotifySelChange(pmc, MCN_SELCHANGE);

        MCUpdateRcDayCur(pmc, &pmc->st);
    }

    MCInvalidateMonthDays(pmc);

    return((pmc->stMonthFirst.wYear-nOldStartYear)*12 + (pmc->stMonthFirst.wMonth-nOldStartMonth));
}

// FIncrStartMonth with a beep when it doesn't change.
int MCIncrStartMonth(MONTHCAL *pmc, int nDelta, BOOL fDelayDayChange)
{
    int cmoSpun;

    // FIncrStartMonth takes stMin/stMax into account
    cmoSpun = FIncrStartMonth(pmc, nDelta, fDelayDayChange);

    if (cmoSpun==0)
        MessageBeep(0);

    return(cmoSpun);
}

//
// Determines in which month the given point lies.  In other words, if the
// calendar control is currently sized to show six months, this routine
// determines in which which of those six months the point lies.  It returns
// the zero based index of the month, counting along the rows.
//
BOOL FGetOffsetForPt(MONTHCAL *pmc, POINT pt, int *piOffset)
{
    int iRow, iCol, i;

    // check to see if point is within the centered months
    if (!PtInRect(&pmc->rcCentered, pt))
        return(FALSE);

    // calculate the month row and column
    // (we're really fudging a little here, since the point could
    // actually be within the space between months...)
    iCol = (pt.x - pmc->rcCentered.left) / (pmc->dxMonth + CALBORDER);
    iRow = (pt.y - pmc->rcCentered.top) / (pmc->dyMonth + CALBORDER);

    i = iRow * pmc->nViewCols + iCol;
    if (i >= pmc->nMonths)
        return(FALSE);

    *piOffset = i;

    return(TRUE);
}

//
// This routine returns the row and column of day containing the given point
//
BOOL FGetRowColForRelPt(MONTHCAL *pmc, POINT ptRel, int *piRow, int *piCol)
{
    if (!PtInRect(&pmc->rcDayNum, ptRel))
        return(FALSE);

    ptRel.x -= pmc->rcDayNum.left;
    ptRel.y -= pmc->rcDayNum.top;

    *piCol = ptRel.x / pmc->dxCol;
    *piRow = ptRel.y / pmc->dyRow;

    return(TRUE);
}

//
// This routine returns the month and year of the iMonth in the displayed
// months.  NOTE: iMonth is a zero-based index of the displayed months
//
void GetYrMoForOffset(MONTHCAL *pmc, int iMonth, int *piYear, int *piMonth)
{
    SYSTEMTIME st;

    st.wDay   = 1;
    st.wMonth = pmc->stMonthFirst.wMonth;
    st.wYear  = pmc->stMonthFirst.wYear;
    
    IncrSystemTime(&st, &st, iMonth, INCRSYS_MONTH);

    *piYear  = st.wYear;
    *piMonth = st.wMonth;
}

//
// This routine returns, the day, month, and year of day containing the
// given point.  It will optionally return the day of the month, the row and
// column in the month, and the bounding rect of the month containing the point.
// NOTE: the day returned in piDay can be less than 1 (to indicate a day in the
// previous month) or greater than the number of days in the month (to indicate
// a day in the next month).
//
BOOL FGetDateForPt(MONTHCAL *pmc, POINT pt, SYSTEMTIME *pst, int *piDay,
                   int* piCol, int* piRow, LPRECT prcMonth)
{
    int iOff, iRow, iCol, iDay, iMon, iYear;
    RECT rcMonth;

    if (!FGetOffsetForPt(pmc, pt, &iOff))
        return(FALSE);

    MCGetRcForMonth(pmc, iOff, &rcMonth);
    pt.x -= rcMonth.left;
    pt.y -= rcMonth.top;
    if (!FGetRowColForRelPt(pmc, pt, &iRow, &iCol))
        return(FALSE);

    // get the day containing the point by subtracting the number of days
    // that are visible from the previous month, and then add one, since
    // we are zero-based and the days of the month are 1-based.
    //
    iDay = iRow * CALCOLMAX + iCol - (pmc->rgcDay[iOff] - pmc->rgnDayUL[iOff]) + 1;
    if (piDay)
        *piDay = iDay;
    
    if (iDay <= 0)
    {
        if (iOff)
            return(FALSE);      // dont accept days in prev month unless
                                // this happens to be the first month
                                
        iDay += pmc->rgcDay[iOff];  // add the cnt of days in the prev month,
        --iOff;                     // then incr the month to get day in new month
    }
    else if (iDay > pmc->rgcDay[iOff+1])
    {
        if (iOff < (pmc->nMonths - 1))  // dont accept days in next month unless
            return(FALSE);              // this happens to be the last month
        
        ++iOff;                         // increment the month, and then sub the
        iDay -= pmc->rgcDay[iOff];      // count of days to get day in new month
    }

    GetYrMoForOffset(pmc, iOff, &iYear, &iMon);
    pst->wDay   = (WORD) iDay;
    pst->wMonth = (WORD) iMon;
    pst->wYear  = (WORD) iYear;

    if (piCol)
        *piCol = iCol;
    
    if (piRow)
        *piRow = iRow;
    
    if (prcMonth)
        *prcMonth = rcMonth;
    
    return(TRUE);
}

BOOL MCSetDate(MONTHCAL *pmc, SYSTEMTIME *pst)
{
    int nDelta = 0;
    
    //
    // Can't set date outside of min/max range
    //
    if (CmpDate(pst, &pmc->stMin) < 0)
        return FALSE;
    if (CmpDate(pst, &pmc->stMax) > 0)
        return FALSE;

    //
    // Set new day
    //
    pmc->st = *pst;
    if (MonthCal_IsMultiSelect(pmc))
        pmc->stEndSel = *pst;

    FScrollIntoView(pmc);
    
    MCNotifySelChange(pmc, MCN_SELCHANGE);

    MCUpdateRcDayCur(pmc, pst);

    return(TRUE);
}

void MCSetToday(MONTHCAL* pmc, SYSTEMTIME* pst)
{
    SYSTEMTIME st;
    RECT rc;
    
    if (!pst)
    {
        GetLocalTime(&st);
        pmc->fTodaySet = FALSE;
    }
    else
    {
        st = *pst;
        pmc->fTodaySet = TRUE;
    }
    
    if (CmpDate(&st, &pmc->stToday) != 0)
    {
        MCGetRcForDay(pmc, pmc->iMonthToday, pmc->stToday.wDay, &rc);
        InvalidateRect(pmc->ci.hwnd, &rc, FALSE);

        pmc->stToday = st;

        MCUpdateToday(pmc);

        MCGetRcForDay(pmc, pmc->iMonthToday, pmc->stToday.wDay, &rc);
        InvalidateRect(pmc->ci.hwnd, &rc, FALSE);

        if (MonthCal_ShowToday(pmc))
        {
            MCGetTodayBtnRect(pmc, &rc);
            InvalidateRect(pmc->ci.hwnd, &rc, FALSE);
        }

        UpdateWindow(pmc->ci.hwnd);
    }
}

LRESULT MCHandleTimer(MONTHCAL *pmc, WPARAM wParam)
{
    if (wParam == CAL_IDAUTOSPIN)
    {
        int nDelta = pmc->fMonthDelta ? pmc->nMonthDelta : pmc->nMonths;

        // REARCHITECT: pass last parameter TRUE if multiselect! else you
        // can't multiselect across months
        MCIncrStartMonth(pmc, (pmc->fSpinPrev ? -nDelta : nDelta), FALSE);

        if (pmc->idTimer == 0)
            pmc->idTimer = SetTimer(pmc->ci.hwnd, CAL_IDAUTOSPIN, CAL_MSECAUTOSPIN, NULL);

        pmc->rcDayOld = pmc->rcDayCur;
        UpdateWindow(pmc->ci.hwnd);
    }
    else if (wParam == CAL_TODAYTIMER)
    {
        if (!pmc->fTodaySet)
            MCSetToday(pmc, NULL);
    }
    
    MCNotifySelChange(pmc, MCN_SELCHANGE);     // our date has changed
    
    return((LRESULT)TRUE);
}

void MCInvalidateDates(MONTHCAL *pmc, SYSTEMTIME *pst1, SYSTEMTIME *pst2)
{
    int iMonth, ioff, icol, irow;
    RECT rc, rcMonth;
    SYSTEMTIME st, stEnd;

    if (CmpDate(pst1, &pmc->stViewLast) > 0 ||
        CmpDate(pst2, &pmc->stViewFirst) < 0)
        return;
        
    if (CmpDate(pst1, &pmc->stViewFirst) < 0)
        CopyDate(pmc->stViewFirst, st);
    else
        CopyDate(*pst1, st);

    if (CmpDate(pst2, &pmc->stViewLast) > 0)
        CopyDate(pmc->stViewLast, stEnd);
    else
        CopyDate(*pst2, stEnd);

    iMonth = MCGetOffsetForYrMo(pmc, st.wYear, st.wMonth);
    if (iMonth == -1)
    {
        if (st.wMonth == pmc->stViewFirst.wMonth)
        {
            iMonth = 0;
            ioff = st.wDay - pmc->rgnDayUL[0] - 1;
        }
        else
        {
            iMonth = pmc->nMonths - 1;
            ioff = st.wDay + pmc->rgcDay[pmc->nMonths] +
                pmc->rgcDay[iMonth] - pmc->rgnDayUL[iMonth] - 1;
        }
    }
    else
    {
        ioff = st.wDay + (pmc->rgcDay[iMonth] - pmc->rgnDayUL[iMonth]) - 1;
    }

    MCGetRcForMonth(pmc, iMonth, &rcMonth);

    // TODO: make it more efficient...
    while (CmpDate(&st, &stEnd) <= 0)
    {
        irow = ioff / CALCOLMAX;
        icol = ioff % CALCOLMAX;
        rc.left   = rcMonth.left + pmc->rcDayNum.left + (pmc->dxCol * icol);
        rc.top    = rcMonth.top  + pmc->rcDayNum.top  + (pmc->dyRow * irow);
        rc.right  = rc.left      + pmc->dxCol;
        rc.bottom = rc.top       + pmc->dyRow;

        InvalidateRect(pmc->ci.hwnd, &rc, FALSE);

        IncrSystemTime(&st, &st, 1, INCRSYS_DAY);
        ioff++;

        if (st.wDay == 1)
        {
            if (st.wMonth != pmc->stMonthFirst.wMonth &&
                st.wMonth != pmc->stViewLast.wMonth)
            {
                iMonth++;
                MCGetRcForMonth(pmc, iMonth, &rcMonth);

                ioff = ioff % CALCOLMAX;
            }
        }
    }
}

void MCHandleMultiSelect(MONTHCAL *pmc, SYSTEMTIME *pst)
{
    int i;
    DWORD cday;
    SYSTEMTIME stStart, stEnd;

    if (!pmc->fMultiSelecting)
    {
        CopyDate(*pst, stStart);
        CopyDate(*pst, stEnd);

        pmc->fMultiSelecting = TRUE;
        pmc->fForwardSelect = TRUE;

        CopyDate(pmc->st, pmc->stStartPrev);
        CopyDate(pmc->stEndSel, pmc->stEndPrev);
    }
    else
    {
        if (pmc->fForwardSelect)
        {
            i = CmpDate(pst, &pmc->st);
            if (i >= 0)
            {
                CopyDate(pmc->st, stStart);
                CopyDate(*pst, stEnd);
            }
            else
            {
                CopyDate(*pst, stStart);
                CopyDate(pmc->st, stEnd);
                pmc->fForwardSelect = FALSE;
            }
        }
        else
        {
            i = CmpDate(pst, &pmc->stEndSel);
            if (i < 0)
            {
                CopyDate(*pst, stStart);
                CopyDate(pmc->stEndSel, stEnd);
            }
            else
            {
                CopyDate(pmc->stEndSel, stStart);
                CopyDate(*pst, stEnd);
                pmc->fForwardSelect = TRUE;
            }
        }
    }
    
    // check to make sure not exceeding cSelMax
    cday = DaysBetweenDates(&stStart, &stEnd) + 1;
    if (cday > pmc->cSelMax)
    {
        if (pmc->fForwardSelect)
            IncrSystemTime(&stStart, &stEnd, pmc->cSelMax - 1, INCRSYS_DAY);
        else
            IncrSystemTime(&stEnd, &stStart, 1 - pmc->cSelMax, INCRSYS_DAY);
    }

    if (0 == CmpDate(&stStart, &pmc->st) &&
        0 == CmpDate(&stEnd, &pmc->stEndSel))
        return;

    // TODO: do this more effeciently..
    MCInvalidateDates(pmc, &pmc->st, &pmc->stEndSel);
    MCInvalidateDates(pmc, &stStart, &stEnd);

    CopyDate(stStart, pmc->st);
    CopyDate(stEnd, pmc->stEndSel);

    MCNotifySelChange(pmc, MCN_SELCHANGE);

    UpdateWindow(pmc->ci.hwnd);
}

void MCGotoToday(MONTHCAL *pmc)
{
    pmc->rcDayOld = pmc->rcDayCur;

    // force old selection to get repainted
    if (MonthCal_IsMultiSelect(pmc))
        MCInvalidateDates(pmc, &pmc->st, &pmc->stEndSel);
    else
        InvalidateRect(pmc->ci.hwnd, &pmc->rcDayOld, FALSE);

    MCSetDate(pmc, &pmc->stToday);
    
    MCNotifySelChange(pmc, MCN_SELECT);    
    
    // force new selection to get repainted
    InvalidateRect(pmc->ci.hwnd, &pmc->rcDayCur, FALSE);
    UpdateWindow(pmc->ci.hwnd);
}

LRESULT MCContextMenu(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    POINT pt;
    int click;

    if (!pmc->fEnabled || !MonthCal_ShowToday(pmc))
        return(0);

    // ignore double click since this makes us advance twice
    // since we already had a leftdown before the leftdblclk
    if (!pmc->fCapture)
    {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);

        //
        //  If the context menu was generated from the keyboard,
        //  then put it at the focus rectangle.
        //
        if (pt.x == -1 && pt.y == -1)
        {
            pt.x = (pmc->rcDayCur.left + pmc->rcDayCur.right ) / 2;
            pt.y = (pmc->rcDayCur.top  + pmc->rcDayCur.bottom) / 2;
            ClientToScreen(pmc->ci.hwnd, &pt);
        }

        click = TrackPopupMenu(pmc->hmenuCtxt,
                    TPM_LEFTBUTTON | TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
                    pt.x, pt.y, 0, pmc->ci.hwnd, NULL);
        if (click >= 1)
            MCGotoToday(pmc);
    }

    return(0);
}

//
// Computes the bounding rects for the month and the year in the title area of
// the month.
//
void MCGetTitleRcsForOffset(MONTHCAL* pmc, int iOffset, LPRECT prcMonth, LPRECT prcYear)
{
    RECT rcT;
    RECT rc;
    MCGetRcForMonth(pmc, iOffset, &rc);
    
    rcT.top    = rc.top + (pmc->dyRow / 2);
    rcT.bottom = rcT.top + pmc->dyRow;

    rcT.left  = rc.left + pmc->rcMonthName.left + pmc->rgmm[iOffset].rgi[IMM_MONTHSTART];
    rcT.right = rc.left + pmc->rcMonthName.left + pmc->rgmm[iOffset].rgi[IMM_MONTHEND];
    *prcMonth = rcT;

    rcT.left  = rc.left + pmc->rcMonthName.left + pmc->rgmm[iOffset].rgi[IMM_YEARSTART];
    rcT.right = rc.left + pmc->rcMonthName.left + pmc->rgmm[iOffset].rgi[IMM_YEAREND];
    *prcYear  = rcT;

}

LRESULT MCLButtonDown(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    HDC        hdc;
    POINT      pt;
    SYSTEMTIME st;
    RECT       rc, rcCal;
    BOOL       fShow;
    MSG        msg;
    int        offset, imonth, iyear;

    if (!pmc->fEnabled)
        return(0);

    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);
  
    // treat a shift click like an LMouseDown at the prev location and
    // a MouseMove to the new location
    if (MonthCal_IsMultiSelect(pmc) && ((wParam & MK_SHIFT) == MK_SHIFT) && (!PtInRect(&pmc->rcDayCur, pt)))
    {
        SetCapture(pmc->ci.hwnd);
        pmc->fCapture = TRUE;
        
        pmc->fForwardSelect = (CmpDate(&pmc->stAnchor, &pmc->st) != 0) ? FALSE : TRUE;
        pmc->fMultiSelecting = TRUE;

        hdc = GetDC(pmc->ci.hwnd);
        DrawFocusRect(hdc, &pmc->rcDayCur);    // draw focus rect
        pmc->fFocusDrawn = TRUE;
        ReleaseDC(pmc->ci.hwnd, hdc);
        
        MCMouseMove(pmc, wParam, lParam);      // draw the highlight to new date

        return 0;
    }
    
    // ignore double click since this makes us advance twice
    // since we already had a leftdown before the leftdblclk
    if (!pmc->fCapture)
    {
        SetCapture(pmc->ci.hwnd);
        pmc->fCapture = TRUE;

        // check for spin buttons
        if ((pmc->fSpinPrev = (WORD) PtInRect(&pmc->rcPrev, pt)) || PtInRect(&pmc->rcNext, pt))
        {
            MCHandleTimer(pmc, CAL_IDAUTOSPIN);

            return(0);
        }
                      
        // check for valid day
        pmc->rcDayOld = pmc->rcDayCur;   // rcDayCur should always be valid now

        if (MonthCal_IsMultiSelect(pmc))
        {
            // need to cache these values because these are how
            // we determine if the selection has changed and we
            // need to notify the parent
            CopyDate(pmc->st, pmc->stStartPrev);
            CopyDate(pmc->stEndSel, pmc->stEndPrev);
        }

                
        if (FUpdateRcDayCur(pmc, pt))
        {
            if (MonthCal_IsMultiSelect(pmc))
            {
                if (FGetDateForPt(pmc, pt, &st, NULL, NULL, NULL, NULL))
                    MCHandleMultiSelect(pmc, &st);
            }

            hdc = GetDC(pmc->ci.hwnd);
            DrawFocusRect(hdc, &pmc->rcDayCur);    // draw focus rect
            pmc->fFocusDrawn = TRUE;
            ReleaseDC(pmc->ci.hwnd, hdc);

            CopyDate(st, pmc->stAnchor);           // new Anchor point
        }
        else
        {
            RECT rcMonth, rcYear;
            int delta, year, month;
            
            // is this a click in the today area...
            if (MonthCal_ShowToday(pmc))
            {
                MCGetTodayBtnRect(pmc, &rc);
                if (PtInRect(&rc, pt))
                {
                    CCReleaseCapture(&pmc->ci);
                    pmc->fCapture = FALSE;
    
                    MCGotoToday(pmc);
                    return(0);
                }
            }

            // figure out if the click was in a month name or a year

            if (!FGetOffsetForPt(pmc, pt, &offset))
                return(0);

            GetYrMoForOffset(pmc, offset, &year, &month);

            // calculate where the month name and year are,
            // so we can figure out if they clicked in them...
            MCGetTitleRcsForOffset(pmc, offset, &rcMonth, &rcYear);
            
            delta = 0;
            if (PtInRect(&rcMonth, pt))
            {
                CCReleaseCapture(&pmc->ci);
                pmc->fCapture = FALSE;

                ClientToScreen(pmc->ci.hwnd, &pt);
                imonth = TrackPopupMenu(pmc->hmenuMonth,
                    TPM_LEFTALIGN | TPM_TOPALIGN |
                    TPM_NONOTIFY | TPM_RETURNCMD | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                    pt.x, pt.y, 0, pmc->ci.hwnd, NULL);
                if (imonth >= 1)
                    delta = imonth - month;
                goto ChangeMonth;
            }                

            if (PtInRect(&rcYear, pt))
            {
                HWND hwndEdit, hwndUD, hwndFocus;
                int yrMin, yrMax;
                DWORD dwExStyle = 0L;
                CCReleaseCapture(&pmc->ci);
                pmc->fCapture = FALSE;

                
                //
                // If the year is in a RTL string, then numeric control
                // is to the left. 
                //
                if (pmc->fHeaderRTL)
                {
                    rcYear.left = (rcYear.right - (pmc->dxYearMax + 6));
                }
                else
                {
                    rcYear.right = rcYear.left + pmc->dxYearMax + 6;
                }
                rcYear.top--;
                rcYear.bottom++;
                if(((pmc->fHeaderRTL) && !(IS_WINDOW_RTL_MIRRORED(pmc->ci.hwnd))) ||
                  (!(pmc->fHeaderRTL) && (IS_WINDOW_RTL_MIRRORED(pmc->ci.hwnd))))
                {
                    // not mirrored force RTL, mirrored force LTR (for mirroring RTLis LTR!!)
                    dwExStyle|= WS_EX_RTLREADING;
                }
                hwndEdit = CreateWindowEx(dwExStyle, TEXT("EDIT"), NULL,
                    WS_CHILD | WS_VISIBLE | WS_BORDER | ES_READONLY | ES_LEFT | ES_AUTOHSCROLL,
                    rcYear.left, rcYear.top, rcYear.right - rcYear.left, rcYear.bottom - rcYear.top,
                    pmc->ci.hwnd, (HMENU)0, pmc->hinstance, NULL);
                if (hwndEdit == NULL)
                    return(0);

                pmc->hwndEdit = hwndEdit;

                SendMessage(hwndEdit, WM_SETFONT, (WPARAM)pmc->hfontBold, (LPARAM)FALSE);
                SendMessage(hwndEdit, EM_SETMARGINS, EC_LEFTMARGIN | EC_RIGHTMARGIN,
                            (LPARAM)MAKELONG(1, 1));
                MCUpdateEditYear(pmc);

                //
                //  Convert from Gregorian to display years.
                //
                year = GregorianToOther(&pmc->ct, year);
                yrMin = GregorianToOther(&pmc->ct, pmc->stMin.wYear);
                yrMax = 9999;
                if (pmc->fMaxYrSet)
                    yrMax = GregorianToOther(&pmc->ct, pmc->stMax.wYear);

                hwndUD = CreateUpDownControl(
                    WS_CHILD | WS_VISIBLE | WS_BORDER | 
                    UDS_NOTHOUSANDS | UDS_ARROWKEYS,// | UDS_SETBUDDYINT,
                    pmc->fHeaderRTL ? (rcYear.left - 1 - (rcYear.bottom-rcYear.top)): (rcYear.right + 1), 
                    rcYear.top, 
                    rcYear.bottom - rcYear.top, rcYear.bottom - rcYear.top, pmc->ci.hwnd,
                    1, pmc->hinstance, hwndEdit, yrMax, yrMin, year);
                if (hwndUD == NULL)
                {
                    DestroyWindow(hwndEdit);
                    return(0);
                }

                pmc->hwndUD = hwndUD;

                hwndFocus = SetFocus(hwndEdit);

                //
                // Widen the area depending on the string direction.
                //
                if (pmc->fHeaderRTL)
                    rcYear.left -= (1 + rcYear.bottom - rcYear.top);
                else
                    rcYear.right += 1 + rcYear.bottom - rcYear.top;
                // Use MapWindowRect, It works in a mirrored and unmirrored windows.
                MapWindowRect(pmc->ci.hwnd, NULL, (LPPOINT)&rcYear);

                rcCal = pmc->rc;
                MapWindowRect(pmc->ci.hwnd, NULL, (LPPOINT)&rcCal);

                fShow = TRUE;

                while (fShow && GetFocus() == hwndEdit)
                {
                    if (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
                    {
                        // Check for events that cause the calendar to go away

                        if (msg.message == WM_KILLFOCUS ||
                            (msg.message >= WM_SYSKEYDOWN &&
                            msg.message <= WM_SYSDEADCHAR))
                        {
                            fShow = FALSE;
                        }
                        else if ((msg.message == WM_LBUTTONDOWN ||
                            msg.message == WM_NCLBUTTONDOWN ||
                            msg.message == WM_RBUTTONDOWN ||
                            msg.message == WM_NCRBUTTONDOWN ||
                            msg.message == WM_MBUTTONDOWN ||
                            msg.message == WM_NCMBUTTONDOWN) &&
                            !PtInRect(&rcYear, msg.pt))
                        {
                            fShow = FALSE;
                            
                            // if its a button down inside the calendar, eat it
                            // so the calendar doesn't do anything strange when
                            // the user is just trying to get rid of the year edit
                            if (PtInRect(&rcCal, msg.pt))
                                GetMessage(&msg, NULL, 0, 0);
                            
                            break;    // do not dispatch
                        }
                        else if (msg.message == WM_QUIT)
                        {   // Don't dispatch a WM_QUIT; leave it in the queue
                            break;    // do not dispatch
                        }
                        else if (msg.message == WM_CHAR)
                        {
                            if (msg.wParam == VK_ESCAPE)
                            {
                                goto NoYearChange;
                            }
                            else if (msg.wParam == VK_RETURN)
                            {
                                fShow = FALSE;
                            }
                        }

                        GetMessage(&msg, NULL, 0, 0);
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                    else
                        WaitMessage();
                }

                iyear = (int) SendMessage(hwndUD, UDM_GETPOS, 0, 0);
                if (HIWORD(iyear) == 0)
                    delta = (iyear - year) * 12;

NoYearChange:
                DestroyWindow(hwndUD);
                DestroyWindow(hwndEdit);

                pmc->hwndUD = NULL;
                pmc->hwndEdit = NULL;

                UpdateWindow(pmc->ci.hwnd);

                if (hwndFocus != NULL)
                    SetFocus(hwndFocus);
            }
ChangeMonth:
            if (delta != 0)
            {
                MCIncrStartMonth(pmc, delta, FALSE);
                MCNotifySelChange(pmc,MCN_SELCHANGE);
            }
            
        }
    }

    return(0);
}

LRESULT MCLButtonUp(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    SYSTEMTIME st;
    POINT pt;
        
    if (pmc->fCapture)
    {
        CCReleaseCapture(&pmc->ci);
        pmc->fCapture = FALSE;

        if (pmc->idTimer)
        {
            KillTimer(pmc->ci.hwnd, pmc->idTimer);
            pmc->idTimer = 0;

            hdc = GetDC(pmc->ci.hwnd);
            MCPaintArrowBtn(pmc, hdc, pmc->fSpinPrev, FALSE);
            ReleaseDC(pmc->ci.hwnd, hdc);

            return(0);
        }


        if (pmc->fFocusDrawn)
        {
            hdc = GetDC(pmc->ci.hwnd);
            DrawFocusRect(hdc, &pmc->rcDayCur); // erase old focus rect
            pmc->fFocusDrawn = FALSE;
            ReleaseDC(pmc->ci.hwnd, hdc);
        }

        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);

        if (MonthCal_IsMultiSelect(pmc))
        {
            FUpdateRcDayCur(pmc, pt);

            if (!EqualRect(&pmc->rcDayOld, &pmc->rcDayCur))
            {
                if (FGetDateForPt(pmc, pt, &st, NULL, NULL, NULL, NULL))
                    MCHandleMultiSelect(pmc, &st);
            }

            pmc->fMultiSelecting = FALSE;
            if (0 != CmpDate(&pmc->stStartPrev, &pmc->st) ||
                0 != CmpDate(&pmc->stEndPrev, &pmc->stEndSel))
            {
                FScrollIntoView(pmc);
            }
            MCNotifySelChange(pmc, MCN_SELECT);
        }
        else
        {
            if (FUpdateRcDayCur(pmc, pt))
            {
                if (!EqualRect(&pmc->rcDayOld, &pmc->rcDayCur) && (FGetDateForPt(pmc, pt, &st, NULL, NULL, NULL, NULL)))
                {
                    InvalidateRect(pmc->ci.hwnd, &pmc->rcDayOld, FALSE);
                    InvalidateRect(pmc->ci.hwnd, &pmc->rcDayCur, FALSE);

                    MCSetDate(pmc, &st);
                }
                
                MCNotifySelChange(pmc, MCN_SELECT);
            }
        }
    }

    return(0);
}

LRESULT MCMouseMove(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    BOOL fPrev;
    HDC hdc;
    POINT pt;
    SYSTEMTIME st;

    if (pmc->fCapture)
    {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);

        // check spin buttons
        if ((fPrev = PtInRect(&pmc->rcPrev, pt)) || PtInRect(&pmc->rcNext, pt))
        {
            if (pmc->idTimer == 0)
            {
                pmc->fSpinPrev = (WORD) fPrev;
                MCHandleTimer(pmc, CAL_IDAUTOSPIN);
            }

            return(0);
        }
        else
        {
            hdc = GetDC(pmc->ci.hwnd);

            if (pmc->idTimer)
            {
                KillTimer(pmc->ci.hwnd, pmc->idTimer);
                pmc->idTimer = 0;
                MCPaintArrowBtn(pmc, hdc, pmc->fSpinPrev, FALSE);
            }
        }

        // check days
        if (!PtInRect(&pmc->rcDayCur, pt))
        {
            if (pmc->fFocusDrawn)
                DrawFocusRect(hdc, &pmc->rcDayCur);         // erase focus rect

            if (pmc->fFocusDrawn = (WORD) FUpdateRcDayCur(pmc, pt))
            {
                // moved into a new valid day
                if (pmc->fMultiSelecting)
                {
                    if (FGetDateForPt(pmc, pt, &st, NULL, NULL, NULL, NULL))
                        MCHandleMultiSelect(pmc, &st);
                }

                DrawFocusRect(hdc, &pmc->rcDayCur);
            }
            else
            {
                // moved into an invalid position
                pmc->rcDayCur = pmc->rcDayOld;
            }
        }
        else if (!pmc->fFocusDrawn)
        {
            // handle case where we just moved back into rcDayCur from invalid area
            DrawFocusRect(hdc, &pmc->rcDayCur);
            pmc->fFocusDrawn = TRUE;
        }

        ReleaseDC(pmc->ci.hwnd, hdc);
    }

    return(0);
}


LRESULT MCHandleKeydown(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    LONG       lIncrement;
    int        iDirection;
    SYSTEMTIME st;
    BOOL       fRet = FALSE;
    HDC        hdc = NULL;
    RECT       rcCurFocus;

    // REARCHITECT: raymondc ERA - need to invalidate month title when selection
    // moves in/out/within

    switch (wParam)
    {
        case VK_CONTROL:
            pmc->fControl = TRUE;           // we'll clear this on WM_KEYUP
            return TRUE;
            break;

        case VK_SHIFT:
            pmc->fShift = TRUE;             // we'll clear this on WM_KEYUP
            return TRUE;
            break;
            
        case VK_LEFT:                       // goto previous day
            iDirection = -1;
            lIncrement = INCRSYS_DAY;
            break;
            
        case VK_RIGHT:                      // goto next day
            iDirection = 1;
            lIncrement = INCRSYS_DAY;
            break;

        case VK_UP:                         // goto previous week
            iDirection = -1;
            lIncrement = INCRSYS_WEEK;
            break;

        case VK_DOWN:                       // goto next week
            iDirection = 1;
            lIncrement = INCRSYS_WEEK;
            break;

        case VK_NEXT:               
            iDirection = 1;
            if (pmc->fControl)              // goto next year
                lIncrement = INCRSYS_YEAR;
            else                            // goto next month
                lIncrement = INCRSYS_MONTH;
            break;

        case VK_PRIOR:
            iDirection = -1;
            if (pmc->fControl)              // goto previous year
                lIncrement = INCRSYS_YEAR;  
            else
                lIncrement = INCRSYS_MONTH; // goto next month
            break;

        case VK_HOME:
            if (pmc->fControl)              // goto first visible month
            {
                CopyDate(pmc->stMonthFirst, st);
            }
            else                            // goto first day of current month
            {
                CopyDate(pmc->st, st);
                st.wDay = 1;
            }
            goto setDate;                  
            break;

        case VK_END:
            if (pmc->fControl)              // goto last visible month
            {
                CopyDate(pmc->stMonthLast, st);
            }
            else                            // goto last day of current month
            {                       
                CopyDate(pmc->st, st);
                st.wDay = (WORD) GetDaysForMonth(st.wYear, st.wMonth);
            }
            goto setDate;
            break;
            
            
        default:
            return FALSE;
    }

    // if we're multiselecting, we need to know which "end" of the selection
    // the user is moving.

    if (pmc->fMultiSelecting && pmc->fForwardSelect)
        CopyDate(pmc->stEndSel, st);
    else
        CopyDate(pmc->st, st);

    IncrSystemTime(&st, &st, iDirection, lIncrement);


setDate:

    // based on the window style and the shift key state,
    // we'll do a multi-select (or not)
    if (MonthCal_IsMultiSelect(pmc) && pmc->fShift)
    {
        pmc->fForwardSelect = (CmpDate(&pmc->st, &pmc->stAnchor) >= 0) ? TRUE : FALSE;
        pmc->fMultiSelecting = TRUE;
    }

    // otherwise, we'll end multiselect, and set the new anchor
    else
    {
        pmc->fMultiSelecting = FALSE;
        CopyDate(st, pmc->stAnchor);
    }
        
    if (pmc->fFocusDrawn)   // erase the focus rect, but don't clear the bit
    {                       // so we know to put it back
        hdc = GetDC(pmc->ci.hwnd);
        DrawFocusRect(hdc, &pmc->rcDayCur);
        ReleaseDC(pmc->ci.hwnd, hdc);
        rcCurFocus = pmc->rcDayCur;
    }
    else
    {
        pmc->rcDayOld = pmc->rcDayCur;
    }

    if (MonthCal_IsMultiSelect(pmc))
    {
        int nDelta = 0;

        MCHandleMultiSelect(pmc, &st);                

        FScrollIntoView(pmc);
    }                                                
    else if (fRet = MCSetDate(pmc, &st))
    {
        InvalidateRect(pmc->ci.hwnd, &pmc->rcDayOld, FALSE);
        InvalidateRect(pmc->ci.hwnd, &pmc->rcDayCur, FALSE);
        UpdateWindow(pmc->ci.hwnd);
    }
    
    if (pmc->fFocusDrawn)   // put the focus rect back
    {
        pmc->rcDayOld = pmc->rcDayCur;
        pmc->rcDayCur = rcCurFocus;
        hdc = GetDC(pmc->ci.hwnd);
        DrawFocusRect(hdc, &pmc->rcDayCur);
        ReleaseDC(pmc->ci.hwnd, hdc);
    }

    return fRet;
}

#if 0 // coming soon

LRESULT MCHandleChar(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{


    return 0;
}

#endif

//
//  Era information is kept in a DPA of LocalAlloc'd strings.
//
int MCDPAEnumCallback(LPVOID d, LPVOID p)
{
    UNREFERENCED_PARAMETER(p);
    if (d)
        LocalFree(d);
    return TRUE;
}

void MCDPADestroy(HDPA hdpa)
{
    if (hdpa)
        DPA_DestroyCallback(hdpa, MCDPAEnumCallback, 0);
}

//
//  Collect era information.
//
//  Since EnumCalendarInfo is not thread-safe, we have to take the critical
//  section.

HDPA g_hdpaCal;

#ifdef WINNT
BOOL MCEnumCalInfoProc(LPWSTR psz)
#else
BOOL MCEnumCalInfoProc(LPSTR psz)
#endif
{
#ifdef UNICODE_WIN9x
    LPWSTR pwszSave = StrDup_AtoW((LPCWSTR)psz);
#else
    LPWSTR pwszSave = StrDup(psz);
#endif
    if (pwszSave) {
        if (DPA_AppendPtr(g_hdpaCal, pwszSave) >= 0) {
            return TRUE;
        }
        LocalFree(pwszSave);
    }

    //
    //  Out of memory.  Bail.
    //
    MCDPADestroy(g_hdpaCal);
    g_hdpaCal = NULL;
    return FALSE;
}

HDPA MCGetCalInfoDPA(CALID calid, CALTYPE calType)
{
    HDPA hdpa = DPA_Create(4);

    ENTERCRITICAL;
    ASSERT(g_hdpaCal == NULL);
    g_hdpaCal = hdpa;
#ifdef WINNT
    EnumCalendarInfoW(MCEnumCalInfoProc, LOCALE_USER_DEFAULT, calid, calType);
#else
    EnumCalendarInfoA(MCEnumCalInfoProc, LOCALE_USER_DEFAULT, calid, calType);
#endif
    hdpa = g_hdpaCal;
    g_hdpaCal = NULL;
    LEAVECRITICAL;

    return hdpa;
}

void MCFreeCalendarInfo(PCALENDARTYPE pct)
{
    MCDPADestroy(pct->hdpaYears);
    MCDPADestroy(pct->hdpaEras);
    pct->hdpaYears = 0;
    pct->hdpaEras = 0;
}

//
//  Get all the era info and validate it so we don't fault when we try to
//  use them.
//
BOOL MCGetEraInfo(PCALENDARTYPE pct)
{
    int i;

    pct->hdpaYears = MCGetCalInfoDPA(pct->calid, CAL_IYEAROFFSETRANGE);
    if (!pct->hdpaYears)
        goto Bad;

    pct->hdpaEras = MCGetCalInfoDPA(pct->calid, CAL_SERASTRING);
    if (!pct->hdpaEras)
        goto Bad;

    // There must be at least one era...
    if (!DPA_GetPtrCount(pct->hdpaEras))
        goto Bad;

    // The number of eras must be equal to the number of era names
    if (DPA_GetPtrCount(pct->hdpaEras) != DPA_GetPtrCount(pct->hdpaYears))
        goto Bad;

    // The era dates must be in descending order.
    for (i = 1; i < DPA_GetPtrCount(pct->hdpaYears); i++)
    {
        if (StrToInt(DPA_FastGetPtr(pct->hdpaYears, i)) >
            StrToInt(DPA_FastGetPtr(pct->hdpaYears, i - 1)))
            goto Bad;
    }
    return TRUE;

Bad:
    /*
     *  Something went wrong, so clean up.
     */
    MCFreeCalendarInfo(pct);
    return FALSE;
}


//
// Check to see if this calendar is not supported currently
//
// Return FALSE for Hijri, Hebrew calendars, since these are
// Lunar calndars. This is hack so that this control behaves well when the calendar
// is any of the non-supported till we add this support to this control. [samera]
//
void MCGetCalendarInfo(PCALENDARTYPE pct)
{
    TCHAR tchCalendar[32];
    CALTYPE defCalendar = CAL_GREGORIAN;

    if (GetLocaleInfo(LOCALE_USER_DEFAULT,
                      LOCALE_ICALENDARTYPE,
                      tchCalendar,
                      ARRAYSIZE(tchCalendar)))
    {
        defCalendar = StrToInt(tchCalendar);
    }


    //
    //  Start with a clean slate.  Assume we don't have to do funky
    //  offset stuff (dyrOFfset = 0) or era stuff (hdpaEras = NULL),
    //  and that we don't need to do locale munging (LOCALE_USER_DEFAULT).
    //
    MCFreeCalendarInfo(pct);
    ZeroMemory(pct, sizeof(CALTYPE));
    pct->calid = defCalendar;
    pct->lcid = LOCALE_USER_DEFAULT;

    switch (pct->calid) {
    case CAL_GREGORIAN:
    case CAL_GREGORIAN_US:
    case CAL_GREGORIAN_ME_FRENCH:
    case CAL_GREGORIAN_ARABIC:
    case CAL_GREGORIAN_XLIT_ENGLISH:
    case CAL_GREGORIAN_XLIT_FRENCH:
        break;                          // Gregorian calendars are just fine

    case CAL_JAPAN:
    case CAL_TAIWAN:
        //
        //  These are era calendars.  Go get the era info.  Get hdpaEras
        //  last so we can use it to test whether we have a supported era
        //  calendar.
        //
        // If not enough memory to support traditional calendar, then just
        // force Gregorian.  Hey, at least we display *something*.
        //
        if (!MCGetEraInfo(pct))
            goto ForceGregorian;
        break;

    case CAL_THAI:
        pct->dyrOffset = BUDDHIST_BIAS; // You Just Have To Know this number
        break;

    case CAL_KOREA:
        pct->dyrOffset = KOREAN_BIAS;   // You Just Have To Know this number
        break;

    default:
        //
        // If the calenday isn't supported, then treat it as Gregorian. [samera]
        //
    ForceGregorian:
        pct->calid = CAL_GREGORIAN;
        pct->lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
        break;
    }

}

//
// Check whether the date string returned accorind to the
// current user-locale and calendar setting is Right-To-Left (RTL),
// and is so the RECTs for month year (@LBUTTONDOWN and NCHITTEST)
// needs to be adjusted. [samera]
//
BOOL MCIsDateStringRTL(TCHAR tch)
{
    WORD wAttrib=0;
    LCID lcidUserDefault;
    BOOL fRTL = FALSE;

    lcidUserDefault = GetUserDefaultLCID();

    if (lcidUserDefault)
    {
        //
        // Return TRUE if the 1st character is a RTL string.
        // A RTL char followed by a european number will
        // display visually as "european-num RTL-string" since the
        // BiDi layout algorithm of the language-pack will do
        // this. [samera]
        //
        if(GetStringTypeEx(lcidUserDefault,
                           CT_CTYPE2,
                           &tch,
                           1,
                           &wAttrib))
        {
            if(C2_RIGHTTOLEFT == wAttrib)
            {
                fRTL = TRUE;
            }

        }
    }

    return fRTL;
}

////////////////////////////////////////////////////////////////////////////
//
// Date/Time Picker
//
////////////////////////////////////////////////////////////////////////////

//
//  Subedit wrapper for the various weird things we need to get from NLS.
//
//  SE_YEARALT means that the year field is only two digits wide
//  in the format string, so we need to perform special Y2K enhancements.
//  For these fields, the field is displayed in two-digit format, but
//  when you go to edit the field, it temporarily changes to four-digit
//  format so you can change the century too.  Then when you complete the
//  edit, it returns to two-digit format.
//
//  The SE_YEARLIKE macro detects either SE_YEAR or SE_YEARALT.
//
//  SE_MONTHALT is just like SE_MONTH except that it is used
//  when the day (dd) comes before the month (mmm).  This is
//  important for languages like Russian where "12 October"
//  and "October 12" use different strings for the word
//  "October".  There is no way to get the alternate string
//  directly, except by creating a bogus date format that also
//  has the day before the month, then throwing away the day.
//
//  For example, if the incoming date string is
//
//      "MMMM dd yyyy"
//
//  we break it up into
//
//      "MMMM"      SE_MONTH
//      " "         SE_STATIC
//      "dd"        SE_DAY
//      " "         SE_STATIC
//      "yyyy"      SE_YEAR
//
//  However, if the incoming date is
//
//      "dd MMMM yyyy"
//
//  we break it up into
//
//      "dd"        SE_DAY
//      " "         SE_STATIC
//      "ddMMMM"    SE_MONTHALT
//      " "         SE_STATIC
//      "yyyy"      SE_YEAR
//
//  The extra "dd" at the beginning of SE_MONTHALT is stripped out below.
//
//  Y2K weirdness:  If we are getting the date format for the year,
//  and the year is being edited (either due to a SUBEDIT_ALL or because
//  it is the active subedit), and the format year is only
//  two digits, then force a four-digit year for editing purposes.
//
//
void SEGetTimeDateFormat(LPSUBEDIT pse, LPSUBEDITCONTROL psec, LPTSTR pszBuf, DWORD cchBuf)
{
    int cch;

    ASSERT(cchBuf >= 2);    // We assume it can hold at least space and a null
    pszBuf[0] = TEXT('\0');             // In case something fails

    if (pse->id == SE_MONTHALT) {
        TCHAR tszBuf[DTP_FORMATLENGTH + 3];
        //
        //  When we parsed the date string and realized that we needed
        //  the Alternate Month format, we created a date format of
        //  the form "ddMMM...", where "MMM..." is the
        //  the original month format.  Here we strip off the digits.
        //
        cch = GetDateFormat(psec->ct.lcid, 0, &psec->st, pse->pv, tszBuf, ARRAYSIZE(tszBuf));
        if (cch >= 2) {
            // [msadek] For Hebrew calander, day format "dd" is actually
            // two OR THREE characters. Don't hardcode it as 2.
            int cchDay = GetDateFormat(psec->ct.lcid, 0, &psec->st, TEXT("dd"), NULL, 0);
            lstrcpyn(pszBuf, tszBuf + cchDay - 1, cchBuf);
        }
    } else if (pse->id == SE_YEARALT &&
               (psec->iseCur == SUBEDIT_ALL || pse == &psec->pse[psec->iseCur])) {
        GetDateFormat(psec->ct.lcid, 0, &psec->st, TEXT("yyyy"), pszBuf, cchBuf);
    } else if (SE_DATELIKE(pse->id)) {
        GetDateFormat(psec->ct.lcid, 0, &psec->st, pse->pv, pszBuf, cchBuf);

        // Change a blank era to a space so the user can see it
        if (pse->id == SE_ERA && pszBuf[0] == TEXT('\0')) {
            pszBuf[0] = TEXT(' ');
            pszBuf[1] = TEXT('\0');
        }

    } else if (pse->id != SE_APP) {
        GetTimeFormat(LOCALE_USER_DEFAULT, 0, &psec->st, pse->pv, pszBuf, cchBuf);
    } else {

        NMDATETIMEFORMAT nmdtf = { 0 };
        nmdtf.pszFormat  = pse->pv;
        SECGetSystemtime(psec, &nmdtf.st);
        nmdtf.pszDisplay = nmdtf.szDisplay;

        CCSendNotify(psec->pci, DTN_FORMAT, &nmdtf.nmhdr);

        lstrcpyn(pszBuf, nmdtf.pszDisplay, cchBuf);

#ifdef UNICODE
        //
        // If the parent is an ANSI window, and pszDisplay
        // does not equal szDisplay, the then thunk had to
        // allocated memory for pszDisplay.  We need to
        // free it here.
        //

        if (!psec->pci->bUnicode && nmdtf.pszDisplay &&
            nmdtf.pszDisplay != nmdtf.szDisplay) {
            LocalFree ((LPSTR)nmdtf.pszDisplay);
        }
#endif
    }
}

//
// SUBEDIT stuff for DateTimePicker
//
// NOTE: Now that the DatePicker and TimePicker are combined,
// this could be moved back into the parent structure.
//

//
//  Used in an era calendar to get the length of the longest era name.
//  Also leaves a random heigth in psize->cy because that's what the
//  non-era code does, too.
//
int SECGetMaxEraLength(PCALENDARTYPE pct, HDC hdc, PSIZE psize)
{
    int i;
    int wid = 0;
    for (i = 0; i < DPA_GetPtrCount(pct->hdpaEras); i++)
    {
        LPCTSTR ptsz = DPA_FastGetPtr(pct->hdpaEras, i);
        if (GetTextExtentPoint32(hdc, ptsz, lstrlen(ptsz), psize) &&
            psize->cx > wid)
        {
            wid = psize->cx;
        }
    }
    return wid;
}


// SECRecomputeSizing needs to calculate the maximum rectangle each subedit can be. Ugh.
//
// The size of the SE_YEARALT field changes depending on whether or not it is
// the current psec->iseCur.  Double ugh.

void SECRecomputeSizing(LPSUBEDITCONTROL psec, LPRECT prc)
{
    HDC       hdc;
    HGDIOBJ   hfontOrig;
    int       i;
    LPSUBEDIT pse;
    int       left = prc->left;

    psec->rc = *prc;

    hdc       = GetDC(psec->pci->hwnd);
    hfontOrig = SelectObject(hdc, (HGDIOBJ)psec->hfont);

    for (i=0, pse=psec->pse; i < psec->cse ; i++, pse++)
    {
        TCHAR   szTmp[DTP_FORMATLENGTH];
        LPCTSTR sz;
        int     min, max;
        SIZE    size;
        int     wid;

        min = pse->min;
        max = pse->max;
        if (pse->id == SE_STATIC)
        {
            ASSERT(pse->fReadOnly);
            sz = pse->pv;
        }
        else
        {
            sz = szTmp;

            // make some assumptions so we don't loop more than we have to
            switch (pse->id)
            {
                
            // we only need seven for the text days of the week
            case SE_DAY:
                min = 10; // make them all double-digit
                max = 17;
                break;

            // Assume we only have numeric output with all chars same width
            case SE_MARK:
                min = 11;
                max = 12;
                break;

            case SE_HOUR:
            case SE_YEAR:
            case SE_YEARALT:
            case SE_MINUTE:
            case SE_SECOND:
                min = max;
                break;

            case SE_ERA:
                if (ISERACALENDAR(&psec->ct)) {
                    wid = SECGetMaxEraLength(&psec->ct, hdc, &size);
                    goto HaveWidth;
                } else {
                    min = max = *pse->pval; // current value is good enough
                }
                break;
            }
        }

        // now get max width
        if (pse->id == SE_APP)
        {
            NMDATETIMEFORMATQUERY nmdtfq = {0};

            nmdtfq.pszFormat = pse->pv;

            CCSendNotify(psec->pci, DTN_FORMATQUERY, &nmdtfq.nmhdr);

            size = nmdtfq.szMax;
            wid  = nmdtfq.szMax.cx;
        }
        else
        {
            SYSTEMTIME st = psec->st;

            /*
             *  SUBTLE - Munge the month/day to January 1.  This solves
             *  lots of problems, such as "Today is Feb 29 1996, and
             *  when we iterate through year = 1997, we get Feb 29 1997,
             *  which is invalid."   Or "Today is Jan 31 1999, and when
             *  we iterate through the months, we get Sep 31 1999, which
             *  is invalid."
             *
             *  We choose "January 1" because
             *
             *  1. Every year has a "January 1", so the year can vary.
             *  2. Every month has a "first", so the month can vary.
             *  3. Every day up to 31 is valid in January, so the day can vary.
             */
            psec->st.wMonth = psec->st.wDay = 1;

            for (wid = 0 ; min <= max ; min++)
            {
                if (pse->id != SE_STATIC)
                {
                    *pse->pval = (WORD) min;

                    SEGetTimeDateFormat(pse, psec, szTmp, ARRAYSIZE(szTmp));
                    if (szTmp[0] == TEXT('\0'))
                    {
                        DebugMsg(TF_ERROR, TEXT("SECRecomputeSizing: GetDate/TimeFormat([%s] y=%d m=%d d=%d h=%d m=%d s=%d) = ERROR %d"),
                            pse->pv, psec->st.wYear, psec->st.wMonth, psec->st.wDay, psec->st.wHour, psec->st.wMinute, psec->st.wSecond,
                            GetLastError());

                    }
                }
                if (!GetTextExtentPoint32(hdc, sz, lstrlen(sz), &size))
                {
                    size.cx = 0;
                    DebugMsg(TF_MONTHCAL,TEXT("SECRecomputeSizing: GetTextExtentPoint32(%s) = ERROR %d"), sz, GetLastError());
                }
                if (size.cx > wid)
                    wid = size.cx;
            }
            psec->st = st;
        }
HaveWidth:
        // now set up subedit's bounding rectangle
        pse->rc.top    = prc->top + SECYBORDER;
        pse->rc.bottom = pse->rc.top + size.cy;
        pse->rc.left   = left;
        pse->rc.right  = left + wid;
        left = pse->rc.right;
    }

    SelectObject(hdc, hfontOrig);
    ReleaseDC(psec->pci->hwnd, hdc);
}

// InitSubEditControl parses szFormat into psec, setting the time to pst.
TCHAR c_szFormats[] = TEXT("gyMdthHmsX");
BOOL SECParseFormat(DATEPICK* pdp, LPSUBEDITCONTROL psec, LPCTSTR szFormat)
{
    LPCTSTR   pFmt;
    LPTSTR    psecFmt;
    int       cse, cchExtra;
    int       nTmp;
    LPSUBEDIT pse;
    BOOL      fDaySeen = FALSE;
    BOOL      fForceCentury = FALSE;
    int       iLen, i;
    TCHAR     tch;
    LPTSTR    pFmtTemp;
    TCHAR szFormatTemp[DTP_FORMATLENGTH];
    
    //
    //  We need to force the century if the format is
    //  DTS_SHORTDATECENTURYFORMAT.
    //
    if (pdp->fLocale &&
        (pdp->ci.style & DTS_FORMATMASK) == DTS_SHORTDATECENTURYFORMAT)
    {
        fForceCentury = TRUE;
    }

    // [msadek]; If we need to mirror the format and the
    // cleint passed a read only buffer, we will AV (W2k bug# 354533)
    // Let's copy it first

    if (psec->fMirrorSEC)
    {
        lstrcpyn(szFormatTemp, szFormat, ARRAYSIZE(szFormatTemp));
        szFormat = szFormatTemp;
    }
 
    // count szFormat sections so we know what to allocate
    pFmt = szFormat;
    cse = 0;
    cchExtra = 0;
    while (*pFmt)
    {
        if (StrChr(c_szFormats, *pFmt)) // format string
        {
            TCHAR c = *pFmt;
            while (c == *pFmt)
                pFmt++;
            cse++;

            // If it was a string Month format, reserve 2 more chars for
            // the possible "dd" leader, in case we need SE_MONTHALT.
            if (c == TEXT('M'))
                cchExtra += 2;

        }
        else if (*pFmt == TEXT('\'')) // quoted static string
        {
KeepSearching:
            pFmt++;
            while (*pFmt && *pFmt != TEXT('\''))
                pFmt++;
            if (*pFmt) // handle poorly quoted strings
            {
                pFmt++;
                if (*pFmt == TEXT('\'')) // quoted quote, not end of quote
                    goto KeepSearching;
            }
            cse++;
        }
        else // static string probably a delimiter
        {
            while (*pFmt && *pFmt!=TEXT('\'') && !StrChr(c_szFormats, *pFmt))
                pFmt++;
            cse++;
        }
    }

    // Allocate space
    nTmp = cse + lstrlen(szFormat) + cchExtra + 1; // number of chars
    nTmp = nTmp * sizeof(TCHAR); // size in BYTES
    nTmp = ROUND_TO_POINTER(nTmp); // round up to POINTER boundary
    psecFmt = (LPTSTR)LocalAlloc(LPTR, nTmp + cse * sizeof(SUBEDIT));
    if (!psecFmt)
    {
        DebugMsg(TF_MONTHCAL, TEXT("SECParseFormat failed to allocate memory"));
        return FALSE; // use whatever we already have
    }
    
    if (psec->szFormat)
        LocalFree(psec->szFormat);
    
    psec->szFormat   = psecFmt;
    psec->cDelimeter = '\0';
    psec->pse        = (LPSUBEDIT)((LPBYTE)psecFmt + nTmp);

    // Fill psec
    psec->iseCur = SUBEDIT_NONE;
    psec->cse    = cse;
    pse          = psec->pse;
    ZeroMemory(pse, cse * sizeof(SUBEDIT));
    pFmt = szFormat;
    pdp->fHasMark = FALSE;


    //
    // Before start parsing the format string, let's mirror it if requested. 
    //
    if (psec->fMirrorSEC)
    {
        pFmtTemp = (LPTSTR)pFmt;
        iLen = lstrlen(pFmtTemp);
        for( i=0 ; i<iLen/2 ; i++ )
        {
            tch = pFmtTemp[i];
            pFmtTemp[i] = pFmtTemp[iLen-i-1];
            pFmtTemp[iLen-i-1] = tch;
        }
    }


    while (*pFmt)
    {
        pse->flDrawText = DT_CENTER;

        if (*pFmt == TEXT('y') || *pFmt == TEXT('g')) // y=year g=era
        {
            TCHAR ch = *pFmt;

            // If the calendar doesn't use eras, then the era field is just
            // for show and can't be changed.
            if (ch == TEXT('g') && !ISERACALENDAR(&psec->ct)) {
                pse->fReadOnly = TRUE;
            }

            pse->id     = ch == TEXT('y') ? SE_YEAR : SE_ERA;
            pse->pval   = &psec->st.wYear;
            pse->min    = c_stEpoch.wYear;
            pse->max    = c_stArmageddon.wYear;
            pse->cchMax = 0;
            
            pse->pv = psecFmt;
            while (*pFmt == ch) {
                pse->cchMax++;
                *psecFmt++ = *pFmt++;
            }

            if (pse->id == SE_YEAR)
            {
                pse->flDrawText = DT_RIGHT;

                if (fForceCentury)
                {
                    pse->pv = TEXT("yyyy");
                    pse->cchMax = 4;
                }
                else
                {
                    switch (pse->cchMax)
                    {
                    case 1:                 //  "y" is a SE_YEARALT
                    case 2:                 // "yy" is a SE_YEARALT
                        pse->id = SE_YEARALT;
                        pse->cchMax = 4;    // Force four-digit editing
                        break;

                    case 3:                 // "yyy" is an alias for "yyyy".
                        pse->cchMax = 4;
                        break;
                    }
                }
            }

            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('M')) // month
        {
            pse->pv = psecFmt;

            // If the day has been seen, then we need to use the alternate
            // month format, so set up the gratuitous "dd" prefix.
            // See SEGetTimeDateFormat.
            //
            if (fDaySeen) {
                pse->id = SE_MONTHALT;
                *psecFmt++ = TEXT('d');
                *psecFmt++ = TEXT('d');
            } else {
                pse->id = SE_MONTH;
            }
            pse->pval   = &psec->st.wMonth;
            pse->min    = 1;
            pse->max    = 12;
            pse->cchMax = 2;

            while (*pFmt == TEXT('M'))
                *psecFmt++ = *pFmt++;
            if (psecFmt - pse->pv <= 2)
                pse->flDrawText = DT_RIGHT;
            *psecFmt++ = TEXT('\0');
        }
        
#if 0 // if we ever do week-of-year format
        else if (*pFmt == TEXT('w')) // week
        {
            // REARCHITECT: NLS date functions can modify the displayed YEAR if the displayed WEEK overflows
            // into the next or prior year!
            // REARCHITECT: We need to make the week increment move beyond month boundries...
            // In order to do this, we need to add an "overflow" flag so day increments will
            // carry into month increments etc.

            pse->id         = SE_DAY;
            pse->pval       = &psec->st.wDay;
            pse->min        = 1;
            pse->max        = GetDaysForMonth(psec->st.wYear, psec->st.wMonth);
            pse->cIncrement = 7;
            pse->cchMax     = 2;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('w'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
#endif
        else if (*pFmt == TEXT('d')) // day or day of week
        {
            fDaySeen    = TRUE;     // See SEGetTimeDateFormat
            pse->id     = SE_DAY;
            pse->pval   = &psec->st.wDay;
            pse->min    = 1;
            pse->max    = GetDaysForMonth(psec->st.wYear, psec->st.wMonth);
            pse->cchMax = 2;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('d'))
                *psecFmt++ = *pFmt++;
            if (psecFmt - pse->pv <= 2)
                pse->flDrawText = DT_RIGHT;     // day
            else
                pse->fReadOnly = TRUE;          // day of week
            *psecFmt++ = TEXT('\0');

        }
        else if (*pFmt == TEXT('t')) // marker
        {
            pdp->fHasMark = TRUE;
            pse->id         = SE_MARK;
            pse->pval       = &psec->st.wHour;
            pse->min        = 0;
            pse->max        = 23;
            pse->cIncrement = 12;
            pse->cchMax     = 2;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('t'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('h')) // (12) hour
        {
            pse->id     = SE_HOUR;
            pse->pval   = &psec->st.wHour;
            pse->min    = 0;
            pse->max    = 23;
            pse->cchMax = 2;
            pse->flDrawText = DT_RIGHT;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('h'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');

        }
        else if (*pFmt == TEXT('H')) // (24) hour
        {
            pse->id     = SE_HOUR;
            pse->pval   = &psec->st.wHour;
            pse->min    = 0;
            pse->max    = 23;
            pse->cchMax = 2;
            pse->flDrawText = DT_RIGHT;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('H'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('m')) // minute
        {
            pse->id     = SE_MINUTE;
            pse->pval   = &psec->st.wMinute;
            pse->min    = 0;
            pse->max    = 59;
            pse->cchMax = 2;
            pse->flDrawText = DT_RIGHT;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('m'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('s')) // second
        {
            pse->id     = SE_SECOND;
            pse->pval   = &psec->st.wSecond;
            pse->min    = 0;
            pse->max    = 59;
            pse->cchMax = 2;
            pse->flDrawText = DT_RIGHT;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('s'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('X')) // app specified field
        {
            pse->id = SE_APP;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('X'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('\'')) // quoted static string
        {
            pse->id      = SE_STATIC;
            pse->fReadOnly = TRUE;

            pse->pv = psecFmt;
SearchSomeMore:
            pFmt++;
            while (*pFmt && *pFmt != TEXT('\''))
                *psecFmt++ = *pFmt++;
            if (*pFmt) // handle poorly quoted strings
            {
                pFmt++;
                if (*pFmt == TEXT('\'')) // quoted quote, not end of quote
                {
                    *psecFmt++ = *pFmt;
                    goto SearchSomeMore;
                }
            }
            *psecFmt++ = TEXT('\0');
        }
        else // unknown non-editable stuff (most likely a delimeter)
        {
            // FEATURE: even though it's unknown, we should probably pass
            // it off to GetDateFormat so we will be forward compatible
            // with future date formats...
            //
            pse->id      = SE_STATIC;
            pse->fReadOnly = TRUE;

            if (!psec->cDelimeter)
                psec->cDelimeter = *pFmt;

            pse->pv = psecFmt;
            while (*pFmt && *pFmt!=TEXT('\'') && !StrChr(c_szFormats, *pFmt))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');

            // we'll assume that the first not formatting char is the
            // delimeter...maybe not a great assumption, but it will work
            // most of the time.
            //
        }
        pse++;
    }

#ifdef DEBUG
{
    TCHAR sz[200];
    LPTSTR psz;
    psz = sz;
    sz[0]=TEXT('\0');
    pse = psec->pse;
    cse = psec->cse;
    while (cse > 0)
    {
        wsprintf(psz, TEXT("[%s] "), pse->pv);
        psz = psz + lstrlen(psz);
        cse--;
        pse++;
    }
    DebugMsg(TF_MONTHCAL, TEXT("SECParseFormat: %s"), sz);
}
#endif

    //
    // Let restore the original format
    //
    if (psec->fMirrorSEC)
    {
        pFmtTemp = (LPTSTR)szFormat;
        for( i=0 ; i<iLen/2 ; i++ )
        {
            tch = pFmtTemp[i];
            pFmtTemp[i] = pFmtTemp[iLen-i-1];
            pFmtTemp[iLen-i-1] = tch;
        }
    }


    //
    // If this is a time-only DTP control and we need to swap the AM/PM symbol
    // to the other side, then let's do it.
    //
    if (psec->fSwapTimeMarker)
    {
        SUBEDIT se;
        pse = psec->pse;
        cse = psec->cse;

        if ((cse > 1) && (psec->pse[0].id == SE_MARK))
        {
            se = psec->pse[0];
            i = 0;
            while( i < (cse-1) )
            {
                pse[i] = pse[i+1];
                i++;
            }
            pse[psec->cse-1] = se;
        }
    }

    // The subedits have changed, recompute sizes
    SECRecomputeSizing(psec, &psec->rc);

    // We're going to need to redraw this
    InvalidateRect(psec->pci->hwnd, NULL, TRUE);

    // Changing the format also changes the window text.
    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, pdp->ci.hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    return TRUE;
}

void SECDestroy(LPSUBEDITCONTROL psec)
{
    if (psec->szFormat)
    {
        LocalFree(psec->szFormat);
        psec->szFormat = NULL;
    }
}
void SECSetFont(LPSUBEDITCONTROL psec, HFONT hfont)
{
    if (hfont == NULL)
        hfont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    psec->hfont = hfont;
}

void InvalidateScrollRect(HWND hwnd, RECT *prc, int xScroll)
{
    RECT rc;

    if (xScroll)
    {
        rc = *prc;
        OffsetRect(&rc, -xScroll, 0);
        prc = &rc;
    }
    InvalidateRect(hwnd, prc, TRUE);
}

void SECSaveResetSubeditEdit(DATEPICK *pdp, BOOL fReset);
#define SECSaveSubeditEdit(pdp) SECSaveResetSubeditEdit(pdp, FALSE)
#define SECResetSubeditEdit(pdp) SECSaveResetSubeditEdit(pdp, TRUE)

// Set the current subedit, scrolling things into view as needed
void SECSetCurSubed(DATEPICK *pdp, int isubed)
{
    LPSUBEDITCONTROL psec = &pdp->sec;

    // validate the arguments
    ASSERT(isubed < psec->cse);
    
    // if the subedit is changing, we need to invalidate stuff
    if (isubed != psec->iseCur)
    {
        int isePre;
        if (psec->iseCur >= 0)
        {
            SECResetSubeditEdit(pdp);
            InvalidateScrollRect(psec->pci->hwnd, &psec->pse[psec->iseCur].rc, psec->xScroll);
        }

        isePre = psec->iseCur;
        psec->iseCur = isubed;
        // For perf reasons, do a full recompute only if SE_YEARALT or
        // SUBEDIT_ALL was involved, since those are the only cases
        // where SE_YEARALT fields change size.

        #define YearAffected(psec, ise)                             \
                (ise == SUBEDIT_ALL ||                              \
                 (ise >= 0 && psec->pse[ise].id == SE_YEARALT))

        if (YearAffected(psec, isePre) || YearAffected(psec, isubed))
        {
            SECRecomputeSizing(psec, &psec->rc);
            InvalidateRect(psec->pci->hwnd, NULL, TRUE);
        }
        #undef YearAffected

        if (psec->iseCur >= 0)
        {
            RECT rc = psec->pse[psec->iseCur].rc;
            OffsetRect(&rc, -psec->xScroll, 0);
            if (rc.left < psec->rc.left)
            {
                psec->xScroll += rc.left - psec->rc.left;
                InvalidateRect(psec->pci->hwnd, NULL, TRUE);
            }
            else if (rc.right > psec->rc.right)
            {
                psec->xScroll += rc.right - psec->rc.right;
                InvalidateRect(psec->pci->hwnd, NULL, TRUE);
            }
            else
            {
                InvalidateRect(psec->pci->hwnd, &rc, TRUE);
            }
        }
    }
}

int SECIncrFocus(DATEPICK *pdp, int delta)
{
    int ise, loop;
    LPSUBEDITCONTROL psec = &pdp->sec;

    ASSERT(-1 == delta || 1 == delta);  

    ise = psec->iseCur;
    if (ise < 0 && delta < 0)
        ise = psec->cse;

    for (loop = 0 ; loop < psec->cse ; loop++)
    {
        int oldise = ise;
        ise = (ise + delta + psec->cse) % psec->cse;
        if (ise != oldise+delta && psec->fNone)
        {
            // we wrapped and we allow scrolling into SUBEDIT_NONE state
            break;
        }
        if (!psec->pse[ise].fReadOnly)
        {
            goto Found;
        }
    }
    ise = SUBEDIT_NONE;
Found:
    SECSetCurSubed(pdp, ise);
    return ise;
}

void SECInvalidate(LPSUBEDITCONTROL psec, int id);

//
//  Given a Gregorian year, get the local name for that year.
//
UINT SECGetYearValue(DATEPICK *pdp, UINT uYear)
{
    UINT uiRc = 0;
    TCHAR rgch[64];
    if (EVAL(MCGetDateFormatWithTempYear(&pdp->sec.ct, &pdp->sec.st, TEXT("yyyy"), uYear, rgch, ARRAYSIZE(rgch)))) {
        uiRc = StrToInt(rgch);
    }
    return uiRc;
}

//
//  SECAdjustByEra
//
//  pct - PCALENDARTYPE structure to use for conversion
//
//  uInput - the value the user typed (to be interpreted as local calendar)
//
//  The basic idea is that if you type a year, it is interpreted relative
//  to the era you were in previously.  If the number you typed isn't valid
//  for that era, then reject it (by returning the original year unchanged).
//
UINT SECAdjustByEra(DATEPICK *pdp, UINT uInput)
{
    UINT uResult = pdp->sec.st.wYear;

    //
    //  Find the delta between the current local year and the current
    //  Gregorian year.  We don't use any of the era transition dates
    //  since they aren't reliable at the boundaries.  Just convert it
    //  to a display name and re-parse it back.
    //
    UINT uDelta = pdp->sec.st.wYear - SECGetYearValue(pdp, pdp->sec.st.wYear);

    //
    //  Apply that delta to the year the user typed in.  This converts the
    //  local year into a Gregorian year.
    //
    UINT uNewVal = uInput + uDelta;

    // uNewVal is the value we want to change it to.  If it's valid for that
    // era, then use it.  We detect that it's okay for the era by converting
    // it to a display name and seeing if it matches.  It can fail for being
    // too large (past the end of the era) or too small (trying to change to
    // January 1 local year 1 when the era didn't change until March).

    if (SECGetYearValue(pdp, uNewVal) == uInput) {
        uResult = uNewVal;
    }

    return uResult;
}

//
//  SECAdjustByType
//
//  Some field types are special.
//
//  SE_YEAR or SE_YEARALT if user typed only two digits
//
//      Use the "implied century for two-digit years" logic
//      as described in GetCalendarInfoA.
//
//  SE_YEAR or SE_YEARALT if user typed more than two digits
//
//      Use that number.
//
//  BONUS FEATURE!
//
//      Some calendars run parallel to the Gregorian year,
//      but with different years.  Use GregorianToOther and
//      OtherToGregorian to convert.
//
//      The input value is the local year (Gregorian, Buddhist, whatever)
//      but the return value is always the Gregorian year, since that's
//      what SYSTEMTIME uses.
//
//  SE_HOUR
//
//      If the clock is in 12-hour format, then preserve AM/PM ness of
//      the hour.  For example, if it was 3pm and somebody is changing
//      the hour to 4, use 4pm instead of 4am.
//
UINT SECAdjustByType(DATEPICK *pdp, LPSUBEDIT psubed, UINT uNewValue)
{

    if (SE_YEARLIKE(psubed->id))
    {
        if (uNewValue < 100)
        {
            // Get the preferred century of the preferred calendar
            // (in the localized year, not Gregorian.)
            DWORD dwMax2DigitYear;
            if (!GetCalendarInfoA(pdp->sec.ct.lcid, pdp->sec.ct.calid, CAL_RETURN_NUMBER + CAL_ITWODIGITYEARMAX,
                                   NULL, 0, &dwMax2DigitYear))
            {
                // default in the absence of all information
                dwMax2DigitYear = GregorianToOther(&pdp->sec.ct, 2029);

                // if the current year in this era is less than 100, then the 2 digits typed
                // may be the real date, so set the max to 99 (i.e., no conversion)
                //
                if (dwMax2DigitYear < 99)
                    dwMax2DigitYear = 99;
            }

            //
            //  Copy the century of dwMax2DigitYear into uNewValue.
            //
            uNewValue += (dwMax2DigitYear - dwMax2DigitYear % 100);
            //
            //  If it exceeds the max, then drop to previous century.
            //
            if (uNewValue > dwMax2DigitYear)
                uNewValue -= 100;

        }

        //
        //  Finally, convert back to Gregorian as necessary.
        //
        uNewValue = OtherToGregorian(&pdp->sec.ct, uNewValue);

        //
        //  If we are in an Era calendar, then we need to adjust the
        //  year relative to the ambient era.
        //
        if (ISERACALENDAR(&pdp->sec.ct)) {
            uNewValue = SECAdjustByEra(pdp, uNewValue);
        }

    } else if (psubed->id == SE_HOUR && psubed->pv[0] == TEXT('h')) {
        if (*psubed->pval >= 12 && uNewValue < 12)
            uNewValue += 12;
    }

    return uNewValue;
}


void SECSetSubeditValue(DATEPICK *pdp, LPSUBEDIT psubed, UINT uNewValue, BOOL fForce)
{
    LPSUBEDITCONTROL psec = &pdp->sec;
    UINT uOldValue;

    uNewValue = SECAdjustByType(pdp, psubed, uNewValue);

    //
    //  Must do a full-on range check in addition to the simple psubed->min
    //  psubed->max range check because the new value might be valid
    //  for our range but not in the global scheme of things.  For example,
    //  the minimum date is Sep 14 1752, but if today is Jan 1 1995 and
    //  the user types "1752", that will pass the simple min/max year test,
    //  but it's not a valid date since Jan 1 1752 is out of range.
    //

    uOldValue = *psubed->pval;
    *psubed->pval = (WORD)uNewValue;
    if (uNewValue >= psubed->min && uNewValue <= psubed->max &&
        CmpSystemtime(&pdp->sec.st, &pdp->stMin) >= 0 &&
        CmpSystemtime(&pdp->sec.st, &pdp->stMax) <= 0)
    {
        if (fForce || uNewValue != uOldValue)
        {
            SECInvalidate(psec, SE_APP);
            InvalidateScrollRect(psec->pci->hwnd, &psubed->rc, psec->xScroll);

            DPNotifyDateChange(pdp);
        }
    }
    else
    {
        // Oops, not valid, put the old value back
        *psubed->pval = (WORD)uOldValue;
    }
}

// This saves the current pending value and also resets the edit state
// if fReset is TRUE
void SECSaveResetSubeditEdit(DATEPICK *pdp, BOOL fReset)
{
    LPSUBEDITCONTROL psec = &pdp->sec;

    if (psec->iseCur >= 0)
    {
        LPSUBEDIT psubed = &psec->pse[psec->iseCur];

        if (psubed->cchEdit)
        {
            SECSetSubeditValue(pdp, psubed, psubed->valEdit, FALSE);
        }
        if (fReset)
            psubed->cchEdit = 0;
    }
}

// SECInvalidate invalidates the display for each subedit affected by a change
// to ID.  NOTE: as a side affect, it recalculates MAX fields for all subedits
// affected by a change to ID.
//
// SE_APP invalidates everything, anything invalidates SE_APP
// SE_MARK (am/pm) invalidate SE_HOUR, SE_HOUR invalides SE_MARK
// 
void SECInvalidate(LPSUBEDITCONTROL psec, int id)
{
    BOOL fAdjustDayMax = (id == SE_MONTH || id == SE_MONTHALT || id == SE_YEAR || id == SE_YEARALT || id == SE_APP || id == SE_ERA);
    LPSUBEDIT pse;
    int i;

    // If we changed any date field and we are in a era-like calendar,
    // then invalidate all, since changing the month, day or year may
    // change the era or vice versa.
    if (ISERACALENDAR(&psec->ct) && SE_DATELIKE(id))
    {
        id = SE_APP;
    }

    for (pse=psec->pse, i=0 ; i < psec->cse ; pse++, i++)
    {
        // we need to invalidate all fields that changed
        if (id == pse->id || pse->id == SE_APP || id == SE_APP || (id == SE_MARK && pse->id == SE_HOUR) || (id == SE_HOUR && pse->id == SE_MARK))
        {
            InvalidateScrollRect(psec->pci->hwnd, &pse->rc, psec->xScroll);
        }

        // the month or year changed, fix max field for SE_DAY
        if (fAdjustDayMax && pse->id == SE_DAY)
        {
            pse->max = GetDaysForMonth(psec->st.wYear, psec->st.wMonth);
            if (*pse->pval > pse->max)
            {
                *pse->pval = (WORD) pse->max;
            }
            SECInvalidate(psec, SE_DAY);
        }
    }
}

__inline
BOOL
SECGetEraName(LPSUBEDITCONTROL psec, LPSUBEDIT pse, UINT uYear, LPTSTR ptszBuf, UINT cchBuf)
{
    return MCGetDateFormatWithTempYear(&psec->ct, &psec->st, pse->pv, uYear, ptszBuf, cchBuf);
}

//
//  SECIncrementEra increments/decrements the era field.  ERAs are strange
//  since they aren't a field unto themselves but are rather an artifact
//  of the other fields.  Returns the new year to use.
//
UINT SECIncrementEra(LPSUBEDITCONTROL psec, LPSUBEDIT pse, int delta)
{
    TCHAR rgch[64];
    TCHAR rgch2[64];
    int i;
    int cEras = DPA_GetPtrCount(psec->ct.hdpaEras);

    UINT uNewYear;

    ASSERT(pse->pval == &psec->st.wYear);
    uNewYear = psec->st.wYear;

    //
    //  First find the era that encloses the current year.
    //  Do this by comparing the era string, because it's possible
    //  for the era to change twice within the same calendar year
    //  (if an emperor ascends to the throne and then dies the next week)
    //  so comparing against hdpaYear won't help.
    //
    SECGetEraName(psec, pse, uNewYear, rgch, ARRAYSIZE(rgch));

    //
    //  If the era string is blank, it means we're in the "before the
    //  first era" scenario, so we use the "virtual" last element that
    //  represents "minus infinity".
    //
    if (rgch[0] == TEXT('\0'))
    {
        i = cEras;
        goto FoundEra;
    }

    for (i = 0; i < cEras; i++)
    {
        if (lstrcmp(rgch, DPA_FastGetPtr(psec->ct.hdpaEras, i)) == 0)
            goto FoundEra;
    }

    //
    //  Eek!  Couldn't find the era!  Just increment/decrement the
    //  year instead.
    //
    uNewYear += delta;
    goto Finish;

FoundEra:

    //
    //  The era list is stored backwards, so incrementing the era means
    //  decrementing the index (i).
    //

    if (delta > 0) // Incrementing
    {
        //
        //  Don't go off the end of the list.  Note that if we were in
        //  the "virtual era" at minus infinity, this decrement will move
        //  us into the first "real" era.
        //
        if (--i < 0)
            goto Finish;

        //   Increment to first year of the next era.
        uNewYear = StrToInt(DPA_FastGetPtr(psec->ct.hdpaYears, i));
    }
    else
    {
        //
        //  Don't go off the end of the list.  Note that this also
        //  catches the "virtual era" at minus infinity.
        //
        if (i >= cEras)
            goto Finish;

        //
        //  Move to the last year of the previous era.  Do this by
        //  starting with the first year of the current era and
        //  decrementing it if necessary.
        //
        uNewYear = StrToInt(DPA_FastGetPtr(psec->ct.hdpaYears, i));
    }

    //
    //  We have a year that might be in the next/prev era.  Try it.
    //  If we're still in the original era, then inc/dec one more time
    //  to get there for good.
    //
    SECGetEraName(psec, pse, uNewYear, rgch2, ARRAYSIZE(rgch2));
    if (lstrcmp(rgch, rgch2) == 0)
        uNewYear += delta;

Finish:
    if (uNewYear < pse->min)
        uNewYear = pse->min;
    if (uNewYear > pse->max)
        uNewYear = pse->max;
    return uNewYear;
}

// SECIncrementSubedit increments currently selected subedit by delta
// Returns TRUE iff the value changed
BOOL SECIncrementSubedit(LPSUBEDITCONTROL psec, int delta)
{
    LPSUBEDIT psubed;
    UINT val;

    if (psec->iseCur < 0)
        return(FALSE);

    psubed = &psec->pse[psec->iseCur];

    if (psubed->id == SE_APP)
        return(FALSE);

    //
    //  Only numeric fields should accelerate.  Text fields should always
    //  increment/decrement by exactly one position.
    //
    if (psubed->flDrawText & DT_CENTER) {
        if (delta < 0) delta = -1;
        if (delta > 0) delta = +1;
    }

    //
    //  Incrementing/decrementing ERAs is strange.
    //
    if (psubed->id == SE_ERA)
    {
        val = SECIncrementEra(psec, psubed, delta);
    }
    else
    {
        // delta isn't a REAL delta -- it's a directional thing. Here's the REAL delta:
        if (psubed->cIncrement > 0)
            delta = delta * psubed->cIncrement;
        if(!psubed->pval)
            return (FALSE);
            
        val = *psubed->pval + delta;
        while (1) {
            if ((int)val < (int)psubed->min)
            {
                // don't wrap years
                if (SE_YEARLIKE(psubed->id)) {
                    val = psubed->min;
                    break;
                }
                val = psubed->min - val - 1;
                val = psubed->max - val;
            }
            else if (val > psubed->max)
            {
                // don't wrap years
                if (SE_YEARLIKE(psubed->id)) {
                    val = psubed->max;
                    break;
                }
                val = val - psubed->max - 1;
                val = psubed->min + val;
            } else
                break;
        }
    }

    if (*psubed->pval != val)
    {
        *psubed->pval = (WORD) val;

        SECInvalidate(psec, psubed->id);
        return(TRUE);
    }

    return(FALSE);
}

// returns TRUE if a value has changed, FALSE otherwise
BOOL SECHandleKeydown(DATEPICK *pdp, WPARAM wParam, LPARAM lParam)
{
    int delta = 1;
    LPSUBEDITCONTROL psec = &pdp->sec;

    switch (wParam)
    {
    case VK_LEFT:
        delta = -1;
        // fall through...
    case VK_RIGHT:
        SECResetSubeditEdit(pdp);
        SECIncrFocus(pdp, delta);
        return(FALSE);
    }

    if (psec->iseCur >= 0 &&
        psec->pse[psec->iseCur].id == SE_APP)
    {
        NMDATETIMEWMKEYDOWN nmdtkd = {0};

        nmdtkd.nVirtKey  = (int) wParam;
        nmdtkd.pszFormat = psec->pse[psec->iseCur].pv;
        SECGetSystemtime(psec,&nmdtkd.st);

        CCSendNotify(psec->pci, DTN_WMKEYDOWN, &nmdtkd.nmhdr);

        if (psec->st.wYear   != nmdtkd.st.wYear   ||
            psec->st.wMonth  != nmdtkd.st.wMonth  ||
            psec->st.wDay    != nmdtkd.st.wDay    ||
            psec->st.wHour   != nmdtkd.st.wHour   ||
            psec->st.wMinute != nmdtkd.st.wMinute ||
            psec->st.wSecond != nmdtkd.st.wSecond) // skip wDayOfWeek and wMilliseconds
        {
            psec->st = nmdtkd.st;
            SECInvalidate(psec, SE_APP);
            return(TRUE);
        }
    }
    else
    {
        MSG msg;
        switch (wParam)
        {
        case VK_DOWN:
        case VK_SUBTRACT:
            delta = -1;
            // fall through...
        case VK_UP:
        case VK_ADD:
            PeekMessage(&msg, NULL, WM_CHAR, WM_CHAR, PM_REMOVE);  // eat this message
            SECResetSubeditEdit(pdp);
            return(SECIncrementSubedit(psec, delta));
            break;

        case VK_HOME:
        case VK_END:
            if (psec->iseCur >= 0)
            {
                LPSUBEDIT psubed;
                int valT;
                
                SECResetSubeditEdit(pdp);

                psubed = &psec->pse[psec->iseCur];
                valT = *psubed->pval;
                *psubed->pval = (wParam == VK_HOME ? psubed->min : psubed->max);
                delta = *psubed->pval - valT;
                if (delta != 0)
                {
                    SECInvalidate(psec, psubed->id);
                    return(TRUE);
                }
            }
            break;
        }
    }
    
    return(FALSE);
}

// returns TRUE if a value has changed, FALSE otherwise
// This function performs a DPNotifyDateChange() if applicable.
BOOL SECHandleChar(DATEPICK *pdp, TCHAR ch)
{
    LPSUBEDIT psubed;
    UINT uCurDigit;             // current digit hit
    UINT uCurSubValue;          // current displayed subvalue in edit field
    UINT uCurValue;             // current value of the subedit
    LPSUBEDITCONTROL psec = &pdp->sec;

    // NOTE: In almost all cases, uCurSubValue will be the same as uCurValue
    // since most fields don't have shortened displays.  However, for years
    // we can display two digits of a 4 digit number, which makes for
    // complications.
    
    if (psec->iseCur < 0)
        return(FALSE);
    
    psubed = &psec->pse[psec->iseCur];

    if (psubed->cchMax == 0)
        return(FALSE);
    
    if (ch == psec->cDelimeter || StrChr(psec->szDelimeters, ch))
    {
        SECResetSubeditEdit(pdp);
        SECIncrFocus(pdp, 1);
        return(FALSE);
    }

    // allow 'a' and 'p' to set the AM/PM fields.  we need to do some
    // funky stuff to get this to work right, so here it is.
    else if (psubed->id == SE_MARK)
    {
        if ((ch == TEXT('p') || ch == TEXT('P')) && (*psubed->pval < 12))
        {
            int valNew = *psubed->pval+12;
            
            ch = (valNew) % 10 + TEXT('0');
            psubed->valEdit = (valNew) / 10;
            psubed->cchEdit = 1;
        }
        else if ((ch == TEXT('a') || ch == TEXT('A')) && (*psubed->pval >= 12))
        {
            int valNew = *psubed->pval-12;
            ch = (valNew) % 10 + TEXT('0');
            psubed->valEdit = (valNew) / 10;
            psubed->cchEdit = 1;
        }
        else
        {
            return(FALSE);
        }
    }
    else if (ch < TEXT('0') || ch > TEXT('9'))
    {
        MessageBeep(MB_ICONHAND);
        return(FALSE);
    }
    else if (psubed->id == SE_ERA)
    {
        // I don't know what to do with this field, so bail out
        return(FALSE);
    }

    uCurDigit = ch - TEXT('0');
    if (psubed->cchEdit)
        uCurSubValue = psubed->valEdit * 10 + uCurDigit;
    else
        uCurSubValue = uCurDigit;

    uCurValue = SECAdjustByType(pdp, psubed, uCurSubValue);

    // Allow bogus values for years since you might need to type
    // in a bogus value on the way to a valid four-digit value.

    if (uCurValue > psubed->max && !SE_YEARLIKE(psubed->id))
    {
        // the number has exceeded the max, so no point in continuing
        psubed->cchEdit = 0;

        // If we're going to exceed the max, then reset the edit
        // and make this the first number instead of beeping

        uCurValue    = uCurValue - uCurSubValue + uCurDigit;
        uCurSubValue = uCurDigit;
    }

    // Allow 0 to be valEdit for subedits, even though it may be
    // illegal for that field (e.g., month).
    // This lets people type "09" and get the "expected" result.

    SECInvalidate(psec, psubed->id);

    psubed->valEdit = uCurSubValue;
    psubed->cchEdit++;
    if (psubed->cchEdit == psubed->cchMax)
        psubed->cchEdit = 0;

    if (psubed->cchEdit == 0)
    {
        // SECSetSubeditValue will do the validation
        SECSetSubeditValue(pdp, psubed, uCurSubValue, TRUE);
        return(TRUE);
    }

    if(psubed->valEdit != *psubed->pval)
        InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
    return(FALSE);
}

// SECFormatSubed returns pointer to correct string
LPTSTR SECFormatSubed(LPSUBEDITCONTROL psec, LPSUBEDIT psubed, LPTSTR szTmp, UINT cch)
{
    LPTSTR sz;

    if (psubed->id == SE_STATIC)
    {
        sz = (LPTSTR)psubed->pv;
    }
    else
    {
        sz = szTmp;
        SEGetTimeDateFormat(psubed, psec, szTmp, cch);
    }

    return sz;
}

//  Returns TRUE if this subedit displays as digits (rather than text).

BOOL SECIsNumeric(LPSUBEDIT psubed)
{
    switch (psubed->id)
    {
    case SE_ERA:        return FALSE;           // g never
    case SE_YEAR:       return TRUE;            // yyyy always digits
    case SE_YEARALT:    return TRUE;            // yy always digits
    case SE_MONTH:      return lstrlen(psubed->pv) <= 2; // MM yes, but not MMM
    case SE_MONTHALT:   return lstrlen(psubed->pv) <= 4; // ddMM yes, but not ddMMM
    case SE_DAY:        return TRUE;            // dd always digits
    case SE_MARK:       return FALSE;           // tt never
    case SE_HOUR:       return TRUE;            // hh always digits
    case SE_MINUTE:     return TRUE;            // mm always digits
    case SE_SECOND:     return TRUE;            // ss always digits
    case SE_STATIC:     return FALSE;           // static text
    case SE_APP:        return FALSE;           // app's job to format this
    }
    return FALSE;
}

// SECDrawSubedits draws subedits and updates their bounding rectangles
void SECDrawSubedits(HDC hdc, LPSUBEDITCONTROL psec, BOOL fFocus, BOOL fEnabled)
{
    HGDIOBJ hfontOrig;
    int i, iseCur;
    LPTSTR sz;
    TCHAR szTmp[DTP_FORMATLENGTH];
    LPSUBEDIT psubed;

    hfontOrig = SelectObject(hdc, (HGDIOBJ)psec->hfont);

    // Do this cuz the xScroll stuff can send text into visible area that it shouldn't be in
    IntersectClipRect(hdc, psec->rc.left, psec->rc.top, psec->rc.right, psec->rc.bottom);

    SetBkColor(hdc, g_clrHighlight);

    iseCur = psec->iseCur;
    if (!fFocus)
        iseCur = SUBEDIT_NONE;

    for (i = 0, psubed = psec->pse; i < psec->cse; i++, psubed++)
    {
        RECT rc = psubed->rc;
        if (psec->xScroll)
            OffsetRect(&rc, -psec->xScroll, 0);

        if (!fEnabled)
        {
            SetBkMode(hdc, TRANSPARENT);
            SetTextColor(hdc, g_clrGrayText);
        }
        else if (iseCur == i)
        {
            SetBkMode(hdc, OPAQUE);
            SetTextColor(hdc, g_clrHighlightText);
        }
        else
        {
            SetBkMode(hdc, TRANSPARENT);
            SetTextColor(hdc, g_clrWindowText);
        }

        //HACK
        //if subedit control is being edited then we display the 
        //value in psubed->valEdit because it is not being updated 
        //until psubed->cchMax is reached or SECSave/ResetSubeditEdit is
        //called
        if(i == psec->iseCur && psubed->cchEdit != 0)
        {
            //
            //  If the field is numeric, then display it raw including the
            //  leading zero.  People really want to see that leading zero,
            //  so give the public what it wants.  (And even if they didn't,
            //  we need this special case anyway because the value might not
            //  yet be a valid value because the user is still typing it.
            //  This is particular true for SE_YEARLIKE fields.)
            //
            if (SECIsNumeric(psubed))
            {
                TCHAR szFormat[10];
                wsprintf(szFormat, TEXT("%%0%dd"), psubed->cchEdit);
                wsprintf(szTmp, szFormat, psubed->valEdit);
                sz = szTmp;
            }
            else
            {
                // The day-of-month might not be valid for the temporary month
                // or year in psubed->valEdit, so force the day-of-month to 1
                // so the month will always come out okay.
                //
                // This is tricky, because if the item being edited is the
                // day-of-month itself, we want to display valEdit, not 1!
                // So we force it to 1, then slam in the valEdit, then do
                // our SECFormatSubed, then restore the original values.
                //
                UINT uTmp = *psubed->pval; //save the original value
                WORD wOldDay = psec->st.wDay;
                psec->st.wDay = 1;
                // Don't change to zero in case user is typing a leading zero
                // into an alphabetic field.  (Stranger things have happened.)
                if (psubed->valEdit)
                    *psubed->pval = (WORD) psubed->valEdit;
                sz = SECFormatSubed(psec, psubed, szTmp, ARRAYSIZE(szTmp));
                psec->st.wDay = wOldDay;
                *psubed->pval = (WORD) uTmp; //restore the original value
            }
        }
        else
            sz = SECFormatSubed(psec, psubed, szTmp, ARRAYSIZE(szTmp));

        DrawText(hdc, sz, -1, &rc,
                 psubed->flDrawText | DT_TOP | DT_NOPREFIX | DT_SINGLELINE);
    }

    // we know no clip region was selected before this function
    SelectClipRgn(hdc, NULL);

    SelectObject(hdc, hfontOrig);
}

// DON'T need to worry about xScroll here because pt is offset
int SECSubeditFromPt(LPSUBEDITCONTROL psec, POINT pt)
{
    int isubed;

    for (isubed = psec->cse - 1; isubed >= 0; isubed--)
    {
        if (!psec->pse[isubed].fReadOnly &&
            pt.x >= psec->pse[isubed].rc.left)
        {
            break;
        }
    }

    return(isubed);
}

void SECGetSystemtime(LPSUBEDITCONTROL psec, LPSYSTEMTIME pst)
{
    *pst = psec->st;

    // we don't keep doy up to date, set it now (0==sun, 6==sat)
    pst->wDayOfWeek = (DowFromDate(pst)+1) % 7;  // this returns 0==sun
}

BOOL SECSetSystemtime(DATEPICK *pdp, LPSYSTEMTIME pst)
{
    pdp->sec.st = *pst;

    return TRUE; // assume something changed
}

// SECEdit: Start a free-format edit return result in szOutput.
BOOL SECEdit(DATEPICK *pdp, LPTSTR szOutput, int cchOutput)
{
    HWND      hwndEdit;
    TCHAR     szBuf[DTP_FORMATLENGTH];
    LPTSTR    pszBuf;
    int       cchBuf;
    int       i;
    int       isePrev;
    LPSUBEDIT pse;
    BOOL      fRet = FALSE;
    LPSUBEDITCONTROL psec = &pdp->sec;

    // Build the string that we hand to the app.
    // For the duration of the string build, set the current subedit
    // to SUBEDIT_ALL so that
    //  1. partial edits are applied before building the string, and
    //  2. SE_YEARALT can format appropriately.

    isePrev = psec->iseCur;
    SECSetCurSubed(pdp, SUBEDIT_ALL);
    pszBuf = szBuf;
    cchBuf = ARRAYSIZE(szBuf);

    
    //
    // Need to mirror the format since the Edit control will take
    // of the origianl format with RTL mirroring. 
    //
    if (psec->fMirrorSEC)
        pse = (psec->pse + (psec->cse - 1));
    else
        pse = psec->pse;

    for (i = 0 ; i < psec->cse ; i++)
    {
        int nTmp;

        if (pse->id == SE_STATIC)
        {
            lstrcpyn(pszBuf, pse->pv, cchBuf);
        }
        else
        {
            SEGetTimeDateFormat(pse, psec, pszBuf, cchBuf);
        }

        nTmp = lstrlen(pszBuf);

        cchBuf -= nTmp;
        pszBuf += nTmp;

        //
        // If this control is mirrored, then read contents backward.
        //
        if (psec->fMirrorSEC)
            pse--;
        else
            pse++;
    }
    SECSetCurSubed(pdp, isePrev);

    hwndEdit = CreateWindowEx(0, TEXT("EDIT"), szBuf, WS_CHILD | ES_AUTOHSCROLL,
            psec->rc.left + 2, psec->rc.top + 2,
            psec->rc.right - psec->rc.left,
            psec->rc.bottom - psec->rc.top,
            psec->pci->hwnd, NULL, HINST_THISDLL, NULL);

    if (hwndEdit)
    {
        RECT rcEdit = psec->rc;

        MapWindowRect(psec->pci->hwnd, NULL, &rcEdit); // ClientToScreen
        pdp->fFreeEditing = TRUE;
        InvalidateRect(psec->pci->hwnd, NULL, TRUE);

        Edit_LimitText(hwndEdit, ARRAYSIZE(szBuf) - 1);
        FORWARD_WM_SETFONT(hwndEdit, psec->hfont, FALSE, SendMessage);
        SetFocus(hwndEdit);
        RescrollEditWindow(hwndEdit);
        ShowWindow(hwndEdit, SW_SHOWNORMAL);

        //
        //  The basic idea:
        //
        //      Process messages until we receive a cancel message,
        //      or an accept message, or some implicit accept-like
        //      thing happens (namely, a sent WM_KILLFOCUS).
        //
        //      If the accept or cancel was implicit, then leave the
        //      cancelling message in the queue for somebody else
        //      to process.  Otherwise, if the accept/cancel was
        //      explicit, eat the message so nobody else gets
        //      confused by it.
        //
        for (;;)
        {
            MSG msg;
            BOOL fPeek;

            fPeek = PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

            // That PeekMessage may have dispatched a sent WM_KILLFOCUS,
            // in which case the change is considered to have been Accepted.
            // Leave the message we peeked in the queue because the accept
            // was implicit.
            if (GetFocus() != hwndEdit)
            {
                DebugMsg(TF_MONTHCAL, TEXT("SECEdit accept (killfocus)"));
                fRet = TRUE;
                break;

            }

            if (fPeek) {

                //
                //  Messages that cause us to cancel implicitly.
                //  These messages stay in the queue.
                //

                if (msg.message == WM_SYSCOMMAND  ||
                    msg.message == WM_SYSCHAR     ||
                    msg.message == WM_SYSDEADCHAR ||
                    msg.message == WM_DEADCHAR    ||
                    msg.message == WM_SYSKEYDOWN  ||
                    msg.message == WM_QUIT) {
                    DebugMsg(TF_MONTHCAL, TEXT("SECEdit got a message to terminate (%d)"), msg.message);
                    fRet = FALSE;
                    break;
                }

                //
                //  Messages that cause us to accept implicitly.
                //  These messages stay in the queue.
                //
                if ((msg.message == WM_LBUTTONDOWN   ||
                     msg.message == WM_NCLBUTTONDOWN ||
                     msg.message == WM_RBUTTONDOWN   ||
                     msg.message == WM_NCRBUTTONDOWN ||
                     msg.message == WM_LBUTTONDBLCLK) &&
                     !PtInRect(&rcEdit, msg.pt))
                {
                    DebugMsg(TF_MONTHCAL, TEXT("SECEdit got a message to accept (%d)"), msg.message);
                    fRet = TRUE;
                    break;
                }


                // We are now committed to eating or processing the message

                GetMessage(&msg, NULL, 0, 0);

                //
                //  Messages that cause us to cancel explicitly.
                //
                if (msg.message == WM_KEYDOWN && msg.wParam  == VK_ESCAPE)
                {
                    DebugMsg(TF_MONTHCAL, TEXT("SECEdit explicit cancel (%d)"), msg.message);
                    fRet = FALSE;
                    break;

                }

                //
                //  Messages that cause us to accept explicitly.
                //
                if (msg.message == WM_KEYDOWN && msg.wParam  == VK_RETURN)
                {
                    DebugMsg(TF_MONTHCAL, TEXT("SECEdit explicit accept (%d)"), msg.message);
                    fRet = TRUE;
                    break;
                }

                //
                //  All other messages just get dispatched.
                //
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            } else {
                WaitMessage();
            }
        } // for (;;)

        if (fRet)
        {
            Edit_GetText(hwndEdit, szOutput, cchOutput);
        }
        DestroyWindow(hwndEdit);
        pdp->fFreeEditing = FALSE;
        InvalidateRect(psec->pci->hwnd, NULL, TRUE);
    }

    return(fRet);
}

//
// returns true if months were scrolled, false otherwise
//
BOOL FScrollIntoView(MONTHCAL *pmc)
{
    int nDelta = 0;
    SYSTEMTIME stEnd;

    if (MonthCal_IsMultiSelect(pmc))
        CopyDate(pmc->stEndSel, stEnd);
    else
        CopyDate(pmc->st, stEnd);
    
    //
    // If the month/yr for the new date is not in view, bring it
    // into view
    //
    if ((stEnd.wYear < pmc->stMonthFirst.wYear) ||
        ((stEnd.wYear == pmc->stMonthFirst.wYear) && (stEnd.wMonth < pmc->stMonthFirst.wMonth)))
    {
        nDelta = - (pmc->stMonthFirst.wYear - (int)stEnd.wYear) * 12 - (pmc->stMonthFirst.wMonth - (int)stEnd.wMonth);
    }
    else if ((pmc->st.wYear > pmc->stMonthLast.wYear) ||
        ((pmc->st.wYear == pmc->stMonthLast.wYear) && (pmc->st.wMonth > pmc->stMonthLast.wMonth)))
    {
        nDelta = ((int)pmc->st.wYear - pmc->stMonthLast.wYear) * 12 + ((int)pmc->st.wMonth - pmc->stMonthLast.wMonth);
    }
    
    if (nDelta)
        return FIncrStartMonth(pmc, nDelta, TRUE /* dont change day */);
    else
        return FALSE;
}

//
//  Validates the isubed to make sure we aren't setting it to something
//  bogus.  If necessary, we pick a field at random.
//
void SECSafeSetCurSubed(DATEPICK *pdp, int ise)
{
    if (ise >= pdp->sec.cse ||
        (ise >= 0 && pdp->sec.pse[ise].fReadOnly))
    {
        SECSetCurSubed(pdp, SUBEDIT_NONE);
        SECIncrFocus(pdp, 1);
    }
    else
        SECSetCurSubed(pdp, ise);
}

LRESULT DTM_OnSetFormat(DATEPICK *pdp, LPCTSTR szFormat)
{

    // remember the field that has focus so we can restore it later
    //
    int iseCur = pdp->sec.iseCur;

    if (!szFormat || !*szFormat)
    {
        pdp->fLocale = TRUE;
        DPHandleLocaleChange(pdp);
    }
    else
    {
        pdp->fLocale = FALSE;
        SECParseFormat(pdp, &pdp->sec, szFormat);
    }

    // restore focus. it might be cool to do extra validation
    // to see if iseCur is the same type that it used to be,
    // maybe even validating that cse is constant. the case we're
    // really trying to fix is changing "1st" to "2nd" to "3rd",
    // so only a text portion is really changing...
    //
    SECSafeSetCurSubed(pdp, iseCur);

    return((LRESULT)TRUE);
}
    
//
// DATEPICKER stuff
//

LRESULT CALLBACK DatePickWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DATEPICK *pdp;
    NMHDR    nmhdr;
    LRESULT  lres = 0;

    if (message == WM_NCCREATE)
        return(DPNcCreateHandler(hwnd));
    
    pdp = DatePick_GetPtr(hwnd);
    if (pdp == NULL)
        return(DefWindowProc(hwnd, message, wParam, lParam));

    // Dispatch the various messages we can receive
    switch (message)
    {
    case WM_CREATE:
        lres = DPCreateHandler(pdp, hwnd, (LPCREATESTRUCT)lParam);
        break;

    case WM_ERASEBKGND:
        if (!pdp->fEnabled) 
        {
            RECT rc;
            HDC hdc = (HDC)wParam;

            GetClipBox(hdc, &rc);
            FillRectClr(hdc, &rc, g_clrBtnFace);
            
        } else
            goto DoDefault;
        break;

    case WM_NCPAINT:
        if (pdp->hThemeCombo && GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_CLIENTEDGE)
        {
            HRGN hrgn = (wParam != 1) ? (HRGN)wParam : NULL;
            HBRUSH hbr = (HBRUSH)GetClassLongPtr(hwnd, GCLP_HBRBACKGROUND);

            if (CCDrawNonClientTheme(pdp->hThemeCombo, hwnd, hrgn, hbr, 0, CBXS_NORMAL))
            {
                break;
            }
        }

        goto DoDefault;

    case WM_PRINTCLIENT:
    case WM_PAINT:

    {
        PAINTSTRUCT ps;
        HDC hdc;

        hdc = (HDC)wParam;

        if (hdc) {
            DPPaint(pdp, hdc);
        } else {

            hwnd = pdp->ci.hwnd;
            hdc = BeginPaint(hwnd, &ps);
            DPPaint(pdp, hdc);
            EndPaint(hwnd, &ps);
        }
        break;
    }

    case WM_LBUTTONDOWN:
        DPLButtonDown(pdp, wParam, lParam);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case MCN_SELCHANGE:
        case MCN_SELECT:
        {
            LPNMSELECT pnms = (LPNMSELECT)lParam;

            DebugMsg(TF_MONTHCAL,TEXT("MonthCal notified DateTimePick of SELECT"));
            if (!DPSetDate(pdp, &pnms->stSelStart, TRUE))
            {
                DebugMsg(DM_WARNING,TEXT("MonthCal cannot set selected date!"));
                MessageBeep(MB_ICONHAND);
            }
            pdp->fShow = (((LPNMHDR)lParam)->code == MCN_SELCHANGE);
            break;
        }

        case UDN_DELTAPOS:
            if ((int)wParam == DATEPICK_UPDOWN)
            {
                LPNM_UPDOWN pnmdp = (LPNM_UPDOWN)lParam;

                if (!pdp->fFocus)
                    SetFocus(pdp->ci.hwnd);

                SECResetSubeditEdit(pdp);

                if (SECIncrementSubedit(&pdp->sec, -pnmdp->iDelta))
                    DPNotifyDateChange(pdp);
            }
            break;
        } // WM_NOTIFY switch
        break;

    case WM_GETFONT:
        lres = (LRESULT)pdp->sec.hfont;
        break;

    case WM_SETFONT:
        DPHandleSetFont(pdp, (HFONT)wParam, (BOOL)LOWORD(lParam));
        break;

    case WM_DESTROY:
        DPDestroyHandler(hwnd, pdp, wParam, lParam);
        break;
        
    case WM_KILLFOCUS:
    case WM_SETFOCUS:
    {
        BOOL fGotFocus = (message == WM_SETFOCUS);
        if (BOOLIFY(fGotFocus) != BOOLIFY(pdp->fFocus))
        {
            pdp->fFocus = (WORD) fGotFocus;
            if (pdp->sec.iseCur >= 0)
            {
                InvalidateScrollRect(pdp->ci.hwnd, &pdp->sec.pse[pdp->sec.iseCur].rc, pdp->sec.xScroll);
            }
            else if (DatePick_ShowCheck(pdp))
            {
                pdp->fCheckFocus = (WORD) fGotFocus;
                InvalidateRect(pdp->ci.hwnd, &pdp->rcCheck, TRUE);
            }
            else if (fGotFocus) // nothing has focus, bring it to something
            {
                SECIncrFocus(pdp, 1);
            }
            
            CCSendNotify(&pdp->ci, (fGotFocus ? NM_SETFOCUS : NM_KILLFOCUS), &nmhdr);
        }

        if (fGotFocus)
        {
            // Revalidate iseLastActive because the app might've changed
            // the format while we were nonfocus
            SECSafeSetCurSubed(pdp, pdp->iseLastActive);
        }
        else
        {
            pdp->iseLastActive = pdp->sec.iseCur;
            SECSetCurSubed(pdp, SUBEDIT_NONE);
        }

        break;
    }

    case WM_ENABLE:
    {
        BOOL fEnabled = wParam ? TRUE:FALSE;
        if (BOOLIFY(pdp->fEnabled) != fEnabled)
        {
            pdp->fEnabled = (WORD) fEnabled;
            if (pdp->hwndUD)
                EnableWindow(pdp->hwndUD, fEnabled);
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        }
        break;
    }

    case DTMP_WINDOWPOSCHANGED:
    case WM_SIZE:
    {
        RECT rc;

        if (message == DTMP_WINDOWPOSCHANGED)
        {
            GetClientRect(pdp->ci.hwnd, &rc);
        }
        else
        {
            rc.left   = 0;
            rc.top    = 0;
            rc.right  = GET_X_LPARAM(lParam);
            rc.bottom = GET_Y_LPARAM(lParam);
        }

        DPRecomputeSizing(pdp, &rc);

        InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        UpdateWindow(pdp->ci.hwnd);
        break;
    }

    case WM_GETDLGCODE:
        lres = DLGC_WANTARROWS | DLGC_WANTCHARS;
        break;

    case WM_KEYDOWN:        
        if (pdp->fShow)
        {
            SendMessage(pdp->hwndMC, WM_KEYDOWN, wParam, lParam);
            return 0;
        }
        else
        {
            lres = DPHandleKeydown(pdp, wParam, lParam);
        }
        break;

    case WM_KEYUP:
        if (pdp->fShow)
            SendMessage(pdp->hwndMC, WM_KEYUP, wParam, lParam);
        break;
        
    case WM_SYSKEYDOWN:
        if (wParam == VK_DOWN && !pdp->fUseUpDown)
        {
            DPLBD_MonthCal(pdp, FALSE);
        }
        else
            goto DoDefault;
        break;

    case WM_CHAR:
        lres = DPHandleChar(pdp, wParam, lParam);
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        // Don't need to propagate to pdp->hwndMC because it is its own
        // top-level window.
        break;

    case WM_WININICHANGE:
        if (lParam == 0 || !lstrcmpi((LPTSTR)lParam, TEXT("Intl")))
        {
            DPHandleLocaleChange(pdp);
        }
        // Don't need to propagate to pdp->hwndMC because it is its own
        // top-level window.
        break;

    case WM_THEMECHANGED:
        if (pdp->hThemeCombo)
        {
            CloseThemeData(pdp->hThemeCombo);
        }

        if (pdp->hThemeCheck)
        {
            CloseThemeData(pdp->hThemeCheck);
        }
        
        pdp->hThemeCombo = OpenThemeData(hwnd, L"Combobox"); // This one kinda looks like a combobox
        pdp->hThemeCheck = OpenThemeData(hwnd, L"Button");
        InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        break;



    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&pdp->ci, lParam);
        break;

    // Cannot use WM_SETTEXT to change the text of a DTP
    case WM_SETTEXT:
        return -1;

    case WM_GETTEXT:
        if (!lParam || !wParam) {
            // previously this just failed and returned 0
            // in bogus input.  should be safe to convert to
            // gettextlength
            message = WM_GETTEXTLENGTH;
        } else 
            (*(LPTSTR)lParam) = 0;
        
        // fall through
        
    case WM_GETTEXTLENGTH:
    {
        TCHAR     szTmp[DTP_FORMATLENGTH];
        LPSUBEDIT psubed;
        int       i;
#ifdef UNICODE_WIN9x
        char *pszText = (char *)lParam;
#else
        TCHAR *pszText = (TCHAR *)lParam;
#endif
        UINT      nTextLen = 0;

        for (i = 0, psubed = pdp->sec.pse; i < pdp->sec.cse; i++, psubed++)
        {
            LPTSTR sz;
            UINT nLen;

            sz = SECFormatSubed(&pdp->sec, psubed, szTmp, ARRAYSIZE(szTmp));
            nLen = lstrlen(sz);

            if (message == WM_GETTEXT) {
                if (nTextLen + nLen >= wParam)
                    break;

#ifdef UNICODE_WIN9x
                // safe to pass wparam because we calculated above that it was ok
                ConvertWToAN(CP_ACP, pszText, wParam, sz, -1);
#else
                lstrcpy(pszText, sz);
#endif
                pszText  += nLen;
            }
            
            nTextLen += nLen;
        }
        lres = nTextLen;
    }
    break;

    case WM_STYLECHANGING:
        lres = DPOnStyleChanging(pdp, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        break;

    case WM_STYLECHANGED:
        lres = DPOnStyleChanged(pdp, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        break;

    case WM_CONTEXTMENU:
        if (pdp->hwndMC)
            lres = SendMessage(pdp->hwndMC, message, wParam, lParam);
        else
            goto DoDefault;
        break;


    //
    // DATETIMEPICK specific messages
    //

    // DTM_GETSYSTEMTIME wParam=void lParam=LPSYSTEMTIME
    //   returns GDT_NONE if no date selected (DTS_SHOWNONE only)
    //   returns GDT_VALID and modifies *lParam to be the selected date
    case DTM_GETSYSTEMTIME:
        if (!pdp->fCheck)
        {
            lres = GDT_NONE;
        }
        else
        {
            // If there is an edit pending, save it so the app sees
            // the absolute latest values.  This is important for app
            // compat, because IE4 wasn't Y2K compliant and people got
            // away with typing just two digits of the year and hitting
            // ENTER.  The "Find Files" dialog would then ask us for the
            // year, and in the Y2K case, we are still waiting for the
            // other two digits (for a four-digit year) and return the
            // wrong year.
            SECSaveSubeditEdit(pdp);
            SECGetSystemtime(&pdp->sec, (SYSTEMTIME *)lParam);
            lres = GDT_VALID;
        }
        break;

    // DTM_SETSYSTEMTIME wParam=GDT_flag lParam=LPSYSTEMTIME
    //   if wParam==GDT_NONE, sets datepick to None (DTS_SHOWNONE only)
    //   if wParam==GDT_VALID, sets datepick to *lParam
    //   returns TRUE on success, FALSE on error (such as bad params)
    case DTM_SETSYSTEMTIME:
    {
        LPSYSTEMTIME pst = ((LPSYSTEMTIME)lParam);

        if ((wParam != GDT_NONE  && wParam != GDT_VALID)      ||
            (wParam == GDT_NONE  && !DatePick_ShowCheck(pdp)) ||
            (wParam == GDT_VALID && !IsValidSystemtime(pst)))
        {
            break;
        }

        // reset subed in place edit
        SECResetSubeditEdit(pdp);

        pdp->fNoNotify = TRUE;
        if (DatePick_ShowCheck(pdp))
        {
            if ((wParam == GDT_NONE) || (pdp->fCheck))
            {
                // let checkbox have focus
                SECSetCurSubed(pdp, SUBEDIT_NONE);
                pdp->fCheckFocus = 1;
            }

            pdp->fCheck = (wParam == GDT_NONE ? 0 : 1);            
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        }
        if (wParam == GDT_VALID)
        {
            pdp->fNoNotify = TRUE;
            DPSetDate(pdp, pst, FALSE);
            pdp->fNoNotify = FALSE;
        }
        lres = TRUE;
        pdp->fNoNotify = FALSE;

        break;
    }

    // DTM_GETRANGE wParam=void lParam=LPSYSTEMTIME[2]
    //   modifies *lParam to be the minimum ALLOWABLE systemtime (or 0 if no minimum)
    //   modifies *(lParam+1) to be the maximum ALLOWABLE systemtime (or 0 if no maximum)
    //   returns GDTR_MIN|GDTR_MAX if there is a minimum|maximum limit
    case DTM_GETRANGE:
    {
        LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;

        ZeroMemory(pst, 2 * sizeof(SYSTEMTIME));
        lres = pdp->gdtr;
        if (lres & GDTR_MIN)
            pst[0] = pdp->stMin;
        if (lres & GDTR_MAX)
            pst[1] = pdp->stMax;
        break;
    }

    // DTM_SETRANGE wParam=GDR_flags lParam=LPSYSTEMTIME[2]
    //   if GDTR_MIN, sets the minimum ALLOWABLE systemtime to *lParam, otherwise removes minimum
    //   if GDTR_MAX, sets the maximum ALLOWABLE systemtime to *(lParam+1), otherwise removes maximum
    //   returns TRUE on success, FALSE on error (such as invalid parameters)
    case DTM_SETRANGE:
    {
        LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;
        const SYSTEMTIME *pstMin = (wParam & GDTR_MIN) ? pst+0 : &c_stEpoch;
        const SYSTEMTIME *pstMax = (wParam & GDTR_MAX) ? pst+1 : &c_stArmageddon;

        if (!IsValidDate(pstMin) || !IsValidDate(pstMax))
        {
            break;
        }

        // Save the flags so we can tell the app if it asks.
        // We personally don't care.
        pdp->gdtr = (UINT)wParam & (GDTR_MIN | GDTR_MAX);

        if (CmpDate(&pdp->stMin, &pdp->stMax) <= 0)
        {
            pdp->stMin = *pstMin;
            pdp->stMax = *pstMax;
        }
        else
        {
            pdp->stMin = *pstMax;
            pdp->stMax = *pstMin;
        }

        // we might now have an invalid date, if so, try to set the current
        // date and munge it to a max or min value if out of range.
        pdp->fNoNotify = TRUE;
        DPSetDate(pdp, &pdp->sec.st, TRUE);
        pdp->fNoNotify = FALSE;
        lres = TRUE;
        break;
    }

#ifdef UNICODE
    // DTM_SETFORMAT wParam=void lParam=LPCTSTR
    //   Sets the formatting string to a copy of lParam.
    case DTM_SETFORMATA:
    {
        LPCSTR pszFormat = (LPCSTR)lParam;
        LPWSTR pwszFormat = NULL;

        if (pszFormat && *pszFormat)
        {
            pwszFormat = ProduceWFromA(pdp->ci.uiCodePage, pszFormat);
        }

        lres = DTM_OnSetFormat(pdp, pwszFormat);

        if (pwszFormat)
        {
            FreeProducedString(pwszFormat);
        }
        break;
    }
#endif

    // DTM_SETFORMAT wParam=void lParam=LPCTSTR
    //   Sets the formatting string to a copy of lParam.
    case DTM_SETFORMAT:
    {
        lres = DTM_OnSetFormat(pdp, (LPCTSTR)lParam);
        break;
    }
        
    case DTM_SETMCCOLOR:
        if (wParam < MCSC_COLORCOUNT) 
        {
            COLORREF clr = pdp->clr[wParam];
            pdp->clr[wParam] = (COLORREF)lParam;
            if (pdp->hwndMC)
                SendMessage(pdp->hwndMC, MCM_SETCOLOR, wParam, lParam);
            return clr;
        }
        return -1;
        
    case DTM_GETMCCOLOR:
        if (wParam < MCSC_COLORCOUNT) 
            return pdp->clr[wParam];
        return -1;
        
    case DTM_GETMONTHCAL:
        return (LRESULT)(UINT_PTR)pdp->hwndMC;

    // wParam -- HFONT, LOWORD(lParam) -- fRedraw
    case DTM_SETMCFONT:
        pdp->hfontMC = (HFONT)wParam;
        if (pdp->hwndMC)
            SendMessage(pdp->hwndMC, WM_SETFONT, wParam, lParam);        
        break;

    // returns the font
    case DTM_GETMCFONT:
        return (LRESULT)pdp->hfontMC;
        break;

    default:
        if (CCWndProc(&pdp->ci, message, wParam, lParam, &lres))
            return lres;

DoDefault:
        lres = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    } /* switch (message) */

    return(lres);
}

LRESULT DPNcCreateHandler(HWND hwnd)
{
    DATEPICK *pdp;

    // Sink the datepick -- we may only want to do this if WS_BORDER is set
    SetWindowBits(hwnd, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);

    // Allocate storage for the dtpick structure
    pdp = (DATEPICK *)LocalAlloc(LPTR, sizeof(DATEPICK));
    if (pdp)
    {
        DatePick_SetPtr(hwnd, pdp);
        pdp->hThemeCombo = OpenThemeData(hwnd, L"Combobox"); // This one kinda looks like a combobox
        pdp->hThemeCheck = OpenThemeData(hwnd, L"Button");
    }

    return((LRESULT)pdp);
}

void DPDestroyHandler(HWND hwnd, DATEPICK *pdp, WPARAM wParam, LPARAM lParam)
{
    if (pdp)
    {
        if (pdp->hThemeCombo)
        {
            CloseThemeData(pdp->hThemeCombo);
        }

        if (pdp->hThemeCheck)
        {
            CloseThemeData(pdp->hThemeCheck);
        }

        SECDestroy(&pdp->sec);
        MCFreeCalendarInfo(&pdp->sec.ct);
        LocalFree(pdp);
    }

    DatePick_SetPtr(hwnd, NULL);
}

// set any locale-dependent values
#define DTS_TIMEFORMATONLY (DTS_TIMEFORMAT & ~DTS_UPDOWN) // remove the UPDOWN bit for testing

LRESULT DPCreateHandler(DATEPICK *pdp, HWND hwnd, LPCREATESTRUCT lpcs)
{
    HFONT      hfont;
    SYSTEMTIME st;
    LCID       lcid;

    // Initialize our data.
    CIInitialize(&pdp->ci, hwnd, lpcs);

    if (pdp->ci.style & DTS_INVALIDBITS)
        return(-1);

    if (pdp->ci.style & DTS_UPDOWN)
    {
        pdp->fUseUpDown = TRUE;
        pdp->hwndUD = CreateWindow(UPDOWN_CLASS, NULL,
            WS_CHILD | WS_VISIBLE | (pdp->ci.style & WS_DISABLED),
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, hwnd,
            (HMENU)DATEPICK_UPDOWN, HINST_THISDLL, NULL);
    }
    if (DatePick_ShowCheck(pdp))
    {
        pdp->sec.fNone = TRUE; // ugly: this SEC stuff should be merged back into DATEPICK
        pdp->iseLastActive = SUBEDIT_NONE;
    }

    pdp->fEnabled = !(pdp->ci.style & WS_DISABLED);
    pdp->fCheck   = TRUE; // start checked

    // Default minimum date is the epoch
    pdp->stMin = c_stEpoch;

    // Default maximum date is armageddon
    pdp->stMax = c_stArmageddon;

    pdp->gdtr = GDTR_MIN;           // We marked MIN as set in IE4, go figure

    //
    // See if the date/time picker supports this calendar. [samera]
    //
    MCGetCalendarInfo(&pdp->sec.ct);

    //
    // If the DTP is RTL mirrored and it's a Time-Only field, then
    // we need to mirror format string so that it's displayed correctly
    // on a RTL mirrored window. In case of Arabic, we need to swap the 
    // Time-Marker to the other side (visual left) so that it looks ok.
    // For the hebrew, we need to swap the field (whether it's date or time)
    // bacause unlike Arabic, it doesn't have its own digit so it reads
    // from LeftToRight. [samera]
    //
    lcid = GetUserDefaultLCID();
    pdp->sec.fMirrorSEC = pdp->sec.fSwapTimeMarker = FALSE;
    if (IS_WINDOW_RTL_MIRRORED(hwnd))
    {
        if (pdp->ci.style & DTS_TIMEFORMATONLY)
        {
            pdp->sec.fMirrorSEC = TRUE;

            if ((PRIMARYLANGID(LANGIDFROMLCID(lcid))) == LANG_ARABIC)
                pdp->sec.fSwapTimeMarker = TRUE;
        }
        else if((PRIMARYLANGID(LANGIDFROMLCID(lcid))) == LANG_HEBREW)
        {
            pdp->sec.fMirrorSEC = TRUE;
        }
    }


    // initialize SUBEDITCONTROL
    pdp->sec.pci = &pdp->ci;
    GetLocalTime(&st);
    SECSetSystemtime(pdp, &st);
    SECSetFont(&pdp->sec, NULL);
    pdp->fLocale = TRUE;
    DPHandleLocaleChange(pdp);
    MCLoadString(IDS_DELIMETERS, pdp->sec.szDelimeters, ARRAYSIZE(pdp->sec.szDelimeters));

    
    hfont = NULL;
    if (lpcs->hwndParent)
        hfont = (HFONT)SendMessage(lpcs->hwndParent, WM_GETFONT, 0, 0);
    DPHandleSetFont(pdp, hfont, FALSE);
    
    // initialize the colors
    MCInitColorArray(pdp->clr);
    return(0);
}

LRESULT DPOnStyleChanging(DATEPICK *pdp, UINT gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE)
    {
        DWORD changeFlags = pdp->ci.style ^ pinfo->styleNew;

        // Don't allow these bits to change
        changeFlags &= DTS_UPDOWN | DTS_SHOWNONE | DTS_INVALIDBITS;

        pinfo->styleNew ^= changeFlags;
    }

    return(0);
}

LRESULT DPOnStyleChanged(DATEPICK *pdp, UINT gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE)
    {
        DWORD changeFlags = pdp->ci.style ^ pinfo->styleNew;

        ASSERT(!(changeFlags & (DTS_UPDOWN|DTS_SHOWNONE)));

        pdp->ci.style = pinfo->styleNew;

        if (changeFlags & (DTS_SHORTDATEFORMAT|DTS_LONGDATEFORMAT|DTS_TIMEFORMAT|DTS_INVALIDBITS))
        {
            DPHandleLocaleChange(pdp);
        }

        if (changeFlags & (WS_BORDER | WS_CAPTION | WS_THICKFRAME)) {
            // the changing of these bits affect the size of the window
            // but not until after this message is handled
            // so post ourself a message.
            PostMessage(pdp->ci.hwnd, DTMP_WINDOWPOSCHANGED, 0, 0);
        }

    }

    return(0);
}


void DPHandleLocaleChange(DATEPICK *pdp)
{
    //
    // See if the date/time picker supports this new calendar, and refresh
    // era names as appropriate.
    //
    MCGetCalendarInfo(&pdp->sec.ct);

    if (pdp->fLocale)
    {
        TCHAR szFormat[DTP_FORMATLENGTH];

        switch (pdp->ci.style & DTS_FORMATMASK)
        {
        case DTS_TIMEFORMATONLY:
            GetLocaleInfo(pdp->sec.ct.lcid, LOCALE_STIMEFORMAT, szFormat, ARRAYSIZE(szFormat));
            break;

        case DTS_LONGDATEFORMAT:
            GetLocaleInfo(pdp->sec.ct.lcid, LOCALE_SLONGDATE, szFormat, ARRAYSIZE(szFormat));
            break;

        case DTS_SHORTDATEFORMAT:
        case DTS_SHORTDATECENTURYFORMAT:
            GetLocaleInfo(pdp->sec.ct.lcid, LOCALE_SSHORTDATE, szFormat, ARRAYSIZE(szFormat));
            break;
        }
        SECParseFormat(pdp, &pdp->sec, szFormat);
    }
}

void DPHandleSetFont(DATEPICK *pdp, HFONT hfont, BOOL fRedraw)
{
    SECSetFont(&pdp->sec, hfont);
    SECRecomputeSizing(&pdp->sec, &pdp->rc);
    pdp->ci.uiCodePage = GetCodePageForFont(hfont);

    if (fRedraw)
    {
        InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        UpdateWindow(pdp->ci.hwnd);
    }
}

void DPPaint(DATEPICK *pdp, HDC hdc)
{
    if (DatePick_ShowCheck(pdp))
    {
        if (RectVisible(hdc, &pdp->rcCheck))
        {
            RECT rc = pdp->rcCheck;

            if (pdp->hThemeCheck)
            {
                int iStateId = CBS_UNCHECKEDNORMAL;
                if (pdp->fCheck)
                    iStateId = CBS_CHECKEDNORMAL;

                if (pdp->fCheckFocus)
                    iStateId += 1;          // Hot == Check focus...
                if (!pdp->fEnabled)
                    iStateId += 3;        // Disabled

                DrawThemeBackground(pdp->hThemeCheck, hdc, BP_CHECKBOX, iStateId, &rc, 0);
            }
            else
            {
                UINT dfcs = DFCS_BUTTONCHECK;
                if (pdp->fCheck)
                    dfcs |= DFCS_CHECKED;
                if (!pdp->fEnabled)
                    dfcs |= DFCS_INACTIVE;

                InflateRect(&rc, -1 , -1);
                if (pdp->fCheckFocus)
                    DrawFocusRect(hdc, &rc);
                
                DrawFrameControl(hdc, &rc, DFC_BUTTON, dfcs);
            }

        }
    }

    if (!pdp->fFreeEditing)
        SECDrawSubedits(hdc, &pdp->sec, pdp->fFocus, pdp->fCheck ? pdp->fEnabled : FALSE);

    if (!pdp->fUseUpDown && RectVisible(hdc, &pdp->rcBtn))
        DPDrawDropdownButton(pdp, hdc, FALSE);
}

void _RecomputeMonthCalRect(DATEPICK *pdp, LPRECT prcCal, LPRECT prcCalT )
{
    RECT rcCal  = *prcCal;
    RECT rcCalT = *prcCalT;
    RECT rcWorkArea;
    MONITORINFO mi = {0};
    HMONITOR hMonitor;
    
    if (DatePick_RightAlign(pdp))
    {
        rcCal.left = rcCal.right - (rcCalT.right - rcCalT.left);
    }
    else
    {
        rcCal.right = rcCal.left + (rcCalT.right - rcCalT.left);
    }
    rcCal.bottom = rcCal.top + (rcCalT.bottom - rcCalT.top);

    // Get the information about the most appropriate monitor.
    // (This includes both the work area and the monitor size.
    hMonitor = MonitorFromRect(&rcCal, MONITOR_DEFAULTTONEAREST);
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &mi);
    
    // we need to know where to fit this rectangle into
    if (GetWindowLong(pdp->ci.hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
    {
        // if we're topmost, our limits are the screen limits (not the working area)
        rcWorkArea = mi.rcMonitor;
    }
    else
    {
        // otherwise it's the limits of the workarea
        rcWorkArea = mi.rcWork;
    }

    // slide left if off the right side of area
    if (rcCal.right > rcWorkArea.right)
    {
        int nTmp = rcCal.right - rcWorkArea.right;
        rcCal.left  -= nTmp;
        rcCal.right -= nTmp;
    }
    
    // slide right if off the left side of area
    if (rcCal.left < rcWorkArea.left)
    {
        int nTmp = rcWorkArea.left - rcCal.left;
        rcCal.left  += nTmp;
        rcCal.right += nTmp;
    }
    
    // move to top of control if off the bottom side of area
    if (rcCal.bottom > rcWorkArea.bottom)
    {
        RECT rcT = pdp->rc;
        int nTmp = rcCal.bottom - rcCal.top;

        MapWindowRect(pdp->ci.hwnd, NULL, (LPPOINT)&rcT); // 2 ClientToScreen

        rcCal.bottom = rcT.top;
        rcCal.top    = rcCal.bottom - nTmp;
    }
    
    *prcCal = rcCal;    
}

void DPLBD_MonthCal(DATEPICK *pdp, BOOL fLButtonDown)
{
    HDC  hdc;
    HWND hwndMC;
    RECT rcT, rcCalT;
    RECT rcBtn, rcCal;
    BOOL fBtnDown;      // Is the button drawn DOWN or UP
    BOOL fBtnActive;    // Is the button still active
    SYSTEMTIME st;
    SYSTEMTIME stOld;
    DWORD dwWidth;
    
    hdc = GetDC(pdp->ci.hwnd);

    // turn datetimepick on but remove all focus -- the MonthCal will have focus
    if (!pdp->fCheck)
    {
        pdp->fCheck = TRUE;
        InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        DPNotifyDateChange(pdp);
    }
    if (pdp->fCheckFocus)
    {
        pdp->fCheckFocus = FALSE;
        InvalidateRect(pdp->ci.hwnd, &pdp->rcCheck, TRUE);
    }
    SECSetCurSubed(pdp, SUBEDIT_NONE);

    if (fLButtonDown)
        DPDrawDropdownButton(pdp, hdc, TRUE);

    rcT = pdp->rc;
    MapWindowRect(pdp->ci.hwnd, NULL, &rcT); //2 ClientToScreen

    rcBtn = pdp->rcBtn;
    MapWindowRect(pdp->ci.hwnd, NULL, &rcBtn); //ClientToScreen

    rcCal = rcT;                       // this size is only temp until
    rcCal.top    = rcCal.bottom + 1;   // we ask the monthcal how big it
    rcCal.bottom = rcCal.top + 1;      // wants to be

    hwndMC = CreateWindow(g_rgchMCName, NULL, WS_POPUP | WS_BORDER,
                    rcCal.left, rcCal.top,
                    rcCal.right - rcCal.left, rcCal.bottom - rcCal.top,
                    pdp->ci.hwnd, NULL, HINST_THISDLL, NULL);
    if (hwndMC == NULL)
    {
        DebugMsg(DM_WARNING, TEXT("DPLBD_MonthCal could not create MONTHCAL"));
        return;
    }

    pdp->hwndMC = hwndMC;

    // set all the colors:
    {
        int i;
        for (i = 0; i < MCSC_COLORCOUNT; i++)
        {
            SendMessage(hwndMC, MCM_SETCOLOR, i, pdp->clr[i]);
        }
    }

    if (pdp->hfontMC)
        SendMessage(hwndMC, WM_SETFONT, (WPARAM)pdp->hfontMC, (LPARAM)FALSE);

    // set min/max dates
    // Relies on HACK! that stMin and stMax are adjacent
    MonthCal_SetRange(hwndMC, GDTR_MIN | GDTR_MAX, &pdp->stMin);

    SendMessage(hwndMC, MCM_GETMINREQRECT, 0, (LPARAM)&rcCalT);
    ASSERT(rcCalT.left == 0 && rcCalT.top == 0);
    dwWidth = (DWORD)SendMessage(hwndMC, MCM_GETMAXTODAYWIDTH, 0, 0);
    if (dwWidth > (DWORD)rcCalT.right)
        rcCalT.right = dwWidth;

    SECGetSystemtime(&pdp->sec, &st);
    SendMessage(hwndMC, MCM_SETCURSEL, 0, (LPARAM)&st);

    _RecomputeMonthCalRect(pdp, &rcCal, &rcCalT);
    MoveWindow(hwndMC, rcCal.left, rcCal.top,
        rcCal.right - rcCal.left, rcCal.bottom - rcCal.top, FALSE);

    CCSendNotify(&pdp->ci, DTN_DROPDOWN, NULL);

    //
    // HACK-- App may have resized the window during DTN_DROPDOWN,
    // so we need to get the new rcCal rect
    //
    {
        MONTHCAL *pmc = MonthCal_GetPtr(hwndMC);
        _RecomputeMonthCalRect(pdp, &rcCal, &pmc->rc);
        MoveWindow(hwndMC, rcCal.left, rcCal.top,
            rcCal.right - rcCal.left, rcCal.bottom - rcCal.top, FALSE);

#ifdef DEBUG
        if (GetAsyncKeyState(VK_CONTROL) < 0)
            (pmc)->ci.style |= MCS_MULTISELECT;
#endif
    }
    
    ShowWindow(hwndMC, SW_SHOWNA);
    
    pdp->fShow = TRUE;
    fBtnDown   = fLButtonDown;
    fBtnActive = fLButtonDown;

    stOld = pdp->sec.st;
    
    while (pdp->fShow)
    {
        MSG msg;

        pdp->fShow = (WORD) GetMessage(&msg, NULL, 0, 0);

        // Here's how button controls work as far as I can tell:
        // Until the "final button draw up", the button draws down when the
        // mouse is over it and it draws up when the mouse is not over it. This
        // entire time, the control is active.
        //
        // The "final button draw up" occurs at the first opportunity of:
        // the user releases the mouse button OR the user moves into the rect
        // of the control.  The control does it's action on a "mouse up".

        if (fBtnActive)
        {
            switch (msg.message) {
            case WM_MOUSEMOVE:
                if (PtInRect(&rcBtn, msg.pt))
                {
                    if (!fBtnDown)
                    {
                        DPDrawDropdownButton(pdp, hdc, TRUE);
                        fBtnDown = TRUE;
                    }
                }
                else
                {
                    if (fBtnDown)
                    {
                        DPDrawDropdownButton(pdp, hdc, FALSE);
                        fBtnDown = FALSE;
                    }
                    if (PtInRect(&rcCal, msg.pt))
                    {
                        fBtnActive = FALSE;
                        // let MonthCal think it got a button down
                        // IEUNIX: dumb compiler doesn't do well with comments in macros.
                        FORWARD_WM_LBUTTONDOWN(hwndMC, FALSE,
                            rcCal.left/2 + rcCal.right/2, 
                            rcCal.top/2 + rcCal.bottom/2, 
                            0, SendMessage);
                    }
                }
                continue; // the MonthCal doesn't need this message
                
            case WM_LBUTTONUP:
                if (fBtnDown)
                {
                    DPDrawDropdownButton(pdp, hdc, FALSE);
                    fBtnDown = FALSE;
                }
                fBtnActive = FALSE;
                continue; // the MonthCal doesn't need this message
            }
        } // if (fBtnActive)

        // Check for events that cause the calendar to go away

        //
        //  These events mean "I like it".  We allow Alt+Up or Enter
        //  to accept the changes.  (Alt+Up for compat with combo boxes.)
        //
        if (((msg.message == WM_LBUTTONDOWN   ||
              msg.message == WM_NCLBUTTONDOWN ||
              msg.message == WM_LBUTTONDBLCLK) && !PtInRect(&rcCal, msg.pt))  ||
              msg.message == WM_SYSCOMMAND    ||
              msg.message == WM_COMMAND       ||
              (msg.message == WM_SYSKEYDOWN && msg.wParam == VK_UP) ||
              (msg.message == WM_KEYDOWN && msg.wParam == VK_RETURN) ||
              msg.message == WM_KILLFOCUS)
        {
            DebugMsg(TF_MONTHCAL,TEXT("DPLBD_MonthCal got a message to accept (%d)"), msg.message);
            pdp->fShow = FALSE;
            continue;
        }

        //
        //  These events mean "I don't like it".
        //
        else if (((msg.message == WM_RBUTTONDOWN   ||
                   msg.message == WM_NCRBUTTONDOWN ||
                   msg.message == WM_RBUTTONDBLCLK) && !PtInRect(&rcCal, msg.pt)) ||
                (msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE))
        {
            DebugMsg(TF_MONTHCAL,TEXT("DPLBD_MonthCal got a message to cancel (%d)"), msg.message);
            pdp->fShow = FALSE;
            pdp->sec.st = stOld;
            DPNotifyDateChange(pdp);
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
            continue;
        }

       
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    } // while(fShow)

    CCSendNotify(&pdp->ci, DTN_CLOSEUP, NULL);

    pdp->hwndMC = NULL;
    DestroyWindow(hwndMC);
    ReleaseDC(pdp->ci.hwnd, hdc);
}

void DPHandleSECEdit(DATEPICK *pdp)
{
    TCHAR szBuf[DTP_FORMATLENGTH];

    if (SECEdit(pdp, szBuf, ARRAYSIZE(szBuf)))
    {
        NMDATETIMESTRING nmdts = {0};

        nmdts.pszUserString = szBuf;
        // just in case the app doesn't parse the string
        nmdts.st      = pdp->sec.st;
        nmdts.dwFlags = (pdp->fCheck==1) ? GDT_VALID : GDT_NONE;

        CCSendNotify(&pdp->ci, DTN_USERSTRING, &nmdts.nmhdr);

        // If the app gives us an invalid date, go back to the old date
        if (nmdts.dwFlags == GDT_VALID &&
            !IsValidSystemtime(&nmdts.st))
        {
            nmdts.st = pdp->sec.st;
        }

        if (nmdts.dwFlags == GDT_NONE)
        {
            if (DatePick_ShowCheck(pdp))
            {
                pdp->fCheck      = FALSE;
                pdp->fCheckFocus = TRUE;
                SECSetCurSubed(pdp, SUBEDIT_NONE);
                InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
                DPNotifyDateChange(pdp);
            }
        }
        else if (nmdts.dwFlags == GDT_VALID)
        {
            DPSetDate(pdp, &nmdts.st, FALSE);
        }
    }
}

LRESULT DPLButtonDown(DATEPICK *pdp, WPARAM wParam, LPARAM lParam)
{
    POINT pt;
    BOOL  fFocus;

    if (!pdp->fEnabled)
        return(0);

    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    // reset subed char count
    SECResetSubeditEdit(pdp);

    fFocus = pdp->fFocus;
    if (!fFocus)
        SetFocus(pdp->ci.hwnd);

    // display MONTHCAL iif we're not DTS_UPDOWN
    if (!pdp->fUseUpDown && PtInRect(&pdp->rcBtn, pt) && IsWindowVisible(pdp->ci.hwnd))
    {
        DPLBD_MonthCal(pdp, TRUE);
    }
    else if (!pdp->fCapture)
    {
        // Un/check checkbox
        if (DatePick_ShowCheck(pdp) && PtInRect(&pdp->rcCheck, pt))
        {
            pdp->fCheck      = !pdp->fCheck;
            pdp->fCheckFocus = 1;
            SECSetCurSubed(pdp, SUBEDIT_NONE);
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
            DPNotifyDateChange(pdp);
        }
        
        // Select a subedit
        else if (pdp->fCheck)
        {
            if (DatePick_AppCanParse(pdp) && fFocus)
            {
                // First click brings focus to a subedit, second click starts editing
                DPHandleSECEdit(pdp);
            }
            else
            {
                int isubed;
                pt.x += pdp->sec.xScroll;
                isubed = SECSubeditFromPt(&pdp->sec, pt);
                if (isubed >= 0)
                {
                    SECSetCurSubed(pdp, isubed);
                    if (DatePick_ShowCheck(pdp))
                    {
                        pdp->fCheckFocus = 0;
                        InvalidateRect(pdp->ci.hwnd, &pdp->rcCheck, TRUE);
                    }
                }
            }
        }
    }
    
    return(0);
}

void DPRecomputeSizing(DATEPICK *pdp, RECT *prect)
{
    RECT rcTmp;

    if (DatePick_ShowCheck(pdp))
    {
        pdp->rcCheck.top    = prect->top    + 1;
        pdp->rcCheck.bottom = prect->bottom - 1;
        pdp->rcCheck.left   = prect->left   + 1;
        pdp->rcCheck.right  = prect->left   + (pdp->rcCheck.bottom - pdp->rcCheck.top);
        
        // occupy at most half the width of the window
        if (pdp->rcCheck.right > prect->left + (prect->right - prect->left)/2)
        {
            pdp->rcCheck.right = prect->left + (prect->right - prect->left)/2;
        }
    }
    else
    {
        pdp->rcCheck.top    = prect->top;
        pdp->rcCheck.bottom = prect->top;
        pdp->rcCheck.left   = prect->left;
        pdp->rcCheck.right  = prect->left + DPXBUFFER - 1;
    }

    pdp->rcBtn = *prect;
    pdp->rcBtn.left = pdp->rcBtn.right - GetSystemMetrics(SM_CXVSCROLL);
    if (pdp->rcBtn.left < pdp->rcCheck.right)
        pdp->rcBtn.left = pdp->rcCheck.right;
    if (pdp->hwndUD)
        MoveWindow(pdp->hwndUD, pdp->rcBtn.left, pdp->rcBtn.top, pdp->rcBtn.right - pdp->rcBtn.left + 1, pdp->rcBtn.bottom - pdp->rcBtn.top + 1, FALSE);

    rcTmp = pdp->rc;
    pdp->rc.top    = prect->top;
    pdp->rc.bottom = prect->bottom;
    pdp->rc.left   = pdp->rcCheck.right + 1;
    pdp->rc.right  = pdp->rcBtn.left - 1;
    SECRecomputeSizing(&pdp->sec, &pdp->rc);
}

// deal with control codes
LRESULT DPHandleKeydown(DATEPICK *pdp, WPARAM wParam, LPARAM lParam)
{
    int delta = 1;
        
    if (wParam == VK_F4 && !pdp->fUseUpDown)
    {
        DPLBD_MonthCal(pdp, FALSE);
    }
    else if (DatePick_AppCanParse(pdp) && wParam == VK_F2)
    {
        DPHandleSECEdit(pdp);
    }        
    else if (pdp->fCheckFocus)
    {
        switch (wParam)
        {
        case VK_LEFT:
            delta = -1;
            // fall through...
        case VK_RIGHT:
            if (pdp->fCheck)
            {
                if (SUBEDIT_NONE != SECIncrFocus(pdp, delta))
                {
                    pdp->fCheckFocus = FALSE;
                    InvalidateRect(pdp->ci.hwnd, &pdp->rcCheck, TRUE);
                }
            }
            break;
        }
    }
    else
    {
        switch (wParam)
        {
        case VK_HOME:
            if (GetKeyState(VK_CONTROL) < 0)
            {
                SYSTEMTIME st;
                GetLocalTime(&st);
                DPSetDate(pdp, &st, TRUE);
                break;
            }
            // fall through...

        default:
            if (SECHandleKeydown(pdp, wParam, lParam))
            {
                DPNotifyDateChange(pdp);
            }
            else if (DatePick_ShowCheck(pdp))
            {
                if (pdp->sec.iseCur < 0)
                {
                    pdp->fCheckFocus = TRUE;
                    InvalidateRect(pdp->ci.hwnd, &pdp->rcCheck, TRUE);
                }
            }
            break;
        }
    }
    
    return(0);
}

// deal with characters
LRESULT DPHandleChar(DATEPICK *pdp, WPARAM wParam, LPARAM lParam)
{
    TCHAR ch = (TCHAR)wParam;

    if (pdp->fCheckFocus)
    {
        // this is the only character we care about in this case
        if (ch == TEXT(' '))
        {
            pdp->fCheck = 1-pdp->fCheck;
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
            DPNotifyDateChange(pdp);
        }
        else
        {
            MessageBeep(MB_ICONHAND);
        }
    }
    else
    {
        // let the subedit handle this -- a value can change
        SECHandleChar(pdp, ch);
    }
    return(0);
}

void DPNotifyDateChange(DATEPICK *pdp)
{
    NMDATETIMECHANGE nmdc = {0};
    BOOL fChanged;

    if (pdp->fNoNotify)
        return;

    if (pdp->fCheck == 0)
    {
        nmdc.dwFlags = GDT_NONE;
    }
    else
    {
        // validate date - do it here in only one place
        if (CmpSystemtime(&pdp->sec.st, &pdp->stMin) < 0)
        {
            pdp->sec.st = pdp->stMin;
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
            SECInvalidate(&pdp->sec, SE_APP);
        }
        else if (CmpSystemtime(&pdp->sec.st, &pdp->stMax) > 0)
        {
            pdp->sec.st = pdp->stMax;
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
            SECInvalidate(&pdp->sec, SE_APP);
        }

        nmdc.dwFlags = GDT_VALID;
        SECGetSystemtime(&pdp->sec, &nmdc.st);
    }

    fChanged = CmpSystemtime(&pdp->stPrev, &nmdc.st);
    if (fChanged) 
    {
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, pdp->ci.hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }

    //
    //  APP COMPAT:  IE4 always notified even if the date didn't change.
    //               I don't know of any apps that rely on this
    //               but I'm not gonna risk it.
    //
    if (fChanged || pdp->ci.iVersion < 5)
    {
        pdp->stPrev = nmdc.st;
        CCSendNotify(&pdp->ci, DTN_DATETIMECHANGE, &nmdc.nmhdr);
    }
}

BOOL DPSetDate(DATEPICK *pdp, SYSTEMTIME *pst, BOOL fMungeDate)
{
    BOOL fChanged = FALSE;

    // make sure that the new date is within the valid range
    if (CmpSystemtime(pst, &pdp->stMin) < 0)
    {
        if (!fMungeDate)
            return(FALSE);
        pst = &pdp->stMin;
    }
    if (CmpSystemtime(&pdp->stMax, pst) < 0)
    {
        if (!fMungeDate)
            return(FALSE);
        pst = &pdp->stMax;
    }

    if (fMungeDate)
    {
        // only copy the date portion
        CopyDate(*pst, pdp->sec.st);
        fChanged = TRUE;
    }
    else
    {
        fChanged = SECSetSystemtime(pdp, pst);
    }
    
    if (fChanged)
    {
        SECInvalidate(&pdp->sec, SE_APP); // SE_APP invalidates everything
        DPNotifyDateChange(pdp);   
    }
    
    return(TRUE);
}

void DPDrawDropdownButton(DATEPICK *pdp, HDC hdc, BOOL fPressed)
{
    if (pdp->hThemeCombo)
    {
        int iStateId = CBXS_NORMAL;
        if (fPressed)
            iStateId = CBXS_PRESSED;

        if (!pdp->fEnabled)
            iStateId = CBXS_DISABLED;

        DrawThemeBackground(pdp->hThemeCombo, hdc, CP_DROPDOWNBUTTON, iStateId, &pdp->rcBtn, 0);
    }
    else
    {
        UINT dfcs;
    
        dfcs = DFCS_SCROLLDOWN;
        if (fPressed)
            dfcs |= DFCS_PUSHED | DFCS_FLAT;
        if (!pdp->fEnabled)
            dfcs |= DFCS_INACTIVE;
        DrawFrameControl(hdc, &pdp->rcBtn, DFC_SCROLL, dfcs);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\pager.cpp ===
//---------------------------------------------------------------------------------------
//  File : Pager.cpp
//  Description :
//        This file implements the pager control
//---------------------------------------------------------------------------------------
#include "ctlspriv.h"
#include "pager.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

#define MINBUTTONSIZE   12

//Timer Flags
#define PGT_SCROLL       1

void DrawScrollArrow(HDC hdc, LPRECT lprc, WORD wControlState);

#ifdef DEBUG
#if 0
extern "C" {
extern void _InvalidateRect(HWND hwnd, LPRECT prc, BOOL fInval);
extern void _RedrawWindow(HWND hwnd, LPRECT prc, HANDLE hrgn, UINT uFlags);
extern void _SetWindowPos(HWND hwnd, HWND hwnd2, int x, int y, int cx, int cy, UINT uFlags);
};
#define InvalidateRect(hwnd, prc, fInval) _InvalidateRect(hwnd, prc, fInval)
#define RedrawWindow(hwnd, prc, hrgn, uFlags) _RedrawWindow(hwnd, prc, hrgn, uFlags)
#define SetWindowPos(hwnd, hwnd2, x, y, cx, cy, uFlags) _SetWindowPos(hwnd, hwnd2, x, y, cx, cy, uFlags)
#endif
#endif

//Public Functions
//---------------------------------------------------------------------------------------
extern "C" {

//This function registers  the pager window class
BOOL InitPager(HINSTANCE hinst)
{
    WNDCLASS wc;
    TraceMsg(TF_PAGER, "Init Pager");

    wc.lpfnWndProc     = CPager::PagerWndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = WC_PAGESCROLLER;
    wc.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1); // NULL;
    wc.style           = CS_GLOBALCLASS;
    wc.cbWndExtra      = sizeof(LPVOID);
    wc.cbClsExtra      = 0;

    if (!RegisterClass(&wc) && !GetClassInfo(hinst, WC_PAGESCROLLER, &wc))
        return FALSE;

    return TRUE;
}


}; // extern "C"

//---------------------------------------------------------------------------------------
CPager::CPager()
{
    _clrBk = g_clrBtnFace;
    
    //Initialize Static Members
    _iButtonSize = (int) g_cxScrollbar * 3 / 4;
    if (_iButtonSize < MINBUTTONSIZE) {
        _iButtonSize = MINBUTTONSIZE;
    }

    _ptLastMove.x = -1;
    _ptLastMove.y = -1;

    _cLinesPerTimeout = 0;
    _cPixelsPerLine = 0;
    _cTimeout = GetDoubleClickTime() / 8;
}

//---------------------------------------------------------------------------------------
// Static Pager Window Procedure


LRESULT CPager::PagerWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CPager *pp = (CPager*)GetWindowPtr(hwnd, 0);
    if (uMsg == WM_CREATE) {
        ASSERT(!pp);
        pp = new CPager();
        if (!pp)
            return 0L;
    }

    if (pp) {
        return pp->v_WndProc(hwnd, uMsg, wParam, lParam);
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
//---------------------------------------------------------------------------------------
LRESULT CPager::PagerDragCallback(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CPager *pp = (CPager*)GetWindowPtr(hwnd, 0);

    if (pp) {
        return pp->_DragCallback(hwnd, uMsg, wParam, lParam);
    }
    return -1;
}


//---------------------------------------------------------------------------------------
// CControl Class Implementation
//---------------------------------------------------------------------------------------


LRESULT CControl::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    if (uMsg == WM_THEMECHANGED)  // Check for theme changes
    {
        if (_hTheme)
            CloseThemeData(_hTheme);

        _hTheme = OpenThemeData(ci.hwnd, GetThemeClass());

        InvalidateRect(ci.hwnd, NULL, TRUE);
    }

    switch (uMsg) {

    case WM_CREATE:
        SetWindowPtr(hwnd, 0, this);
        CIInitialize(&ci, hwnd, (CREATESTRUCT*)lParam);

        _hTheme = OpenThemeData(ci.hwnd, GetThemeClass());

        return v_OnCreate();

    case WM_NCCALCSIZE:
        if (v_OnNCCalcSize(wParam, lParam, &lres))
            break;
        goto DoDefault;

    case WM_SIZE:
        v_OnSize(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        break;
        
    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&ci, lParam);

    case WM_NOTIFY:
        return v_OnNotify(wParam, lParam);
    
    case WM_STYLECHANGED:
        v_OnStyleChanged(wParam, lParam);
        break;

    case WM_COMMAND:
        return v_OnCommand(wParam, lParam);

    case WM_NCPAINT:
        v_OnNCPaint();
        goto DoDefault;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        _OnPaint((HDC)wParam);
        break;
        
    case WM_DESTROY:
        SetWindowLongPtr(hwnd, 0, 0);

        if (_hTheme)
            CloseThemeData(_hTheme);

        delete this;
        break;

    case TB_SETPARENT:
        {
            HWND hwndOld = ci.hwndParent;

            ci.hwndParent = (HWND)wParam;
            return (LRESULT)hwndOld;
        }


    default:
        if (CCWndProc(&ci, uMsg, wParam, lParam, &lres))
            return lres;
DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return lres;
}

//---------------------------------------------------------------------------------------
BOOL CControl::v_OnNCCalcSize(WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    return FALSE;
}

//---------------------------------------------------------------------------------------
DWORD CControl::v_OnStyleChanged(WPARAM wParam, LPARAM lParam)
{
    LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lParam;
    DWORD dwChanged = 0;    
    if (wParam == GWL_STYLE) {
        ci.style = lpss->styleNew;

        dwChanged = (lpss->styleOld ^ lpss->styleNew);
    } else if (wParam == GWL_EXSTYLE) {
        //
        // Save the new ex-style bits
        //
        dwChanged    = (lpss->styleOld ^ lpss->styleNew);
        ci.dwExStyle = lpss->styleNew;
    }

    TraceMsg(TF_PAGER, "cctl.v_osc: style=%x ret dwChged=%x", ci.style, dwChanged);
    return dwChanged;
}

//---------------------------------------------------------------------------------------
void CControl::_OnPaint(HDC hdc)
{
    if (hdc) 
    {
        v_OnPaint(hdc);
    } 
    else 
    {
        PAINTSTRUCT ps;
        hdc = BeginPaint(ci.hwnd, &ps);
        v_OnPaint(hdc);
        EndPaint(ci.hwnd, &ps);
    }
}

//---------------------------------------------------------------------------------------
//  CPager Class Implementation
//---------------------------------------------------------------------------------------
inline int CPager::_GetButtonSize()
{
    return _iButtonSize;
}

//---------------------------------------------------------------------------------------

LRESULT CPager::_DragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp)
{
    LRESULT lres = -1;
    switch (code)
    {
    case DPX_DRAGHIT:
        if (lp)
        {
            POINT pt; 
            int iButton;
            pt.x = ((POINTL *)lp)->x;
            pt.y = ((POINTL *)lp)->y;

            MapWindowPoints(NULL, ci.hwnd, &pt, 1);

            iButton = _HitTest(pt.x, pt.y);

            if (iButton >= 0) 
            {
                if(!_fTimerSet)
                {
                    _fTimerSet = TRUE;
                    _iButtonTrack = iButton;
                    SetTimer(ci.hwnd, PGT_SCROLL, _cTimeout, NULL);
                }

            } else {
                _KillTimer();
                _iButtonTrack = -1;
            }
        }
        else
            lres = -1;
        break;

    case DPX_LEAVE:
        _KillTimer();
        _iButtonTrack = -1;
        break;

    default: 
        lres = -1;
        break;
    }
    return lres;
}

//---------------------------------------------------------------------------------------
void CPager::_NeedScrollbars(RECT rc)
{  
    int parentheight;
    int childheight;
    POINT ptPos = _ptPos;
   
    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
        FlipPoint(&ptPos);
    }
    
    //Get Parent Window height
    parentheight = RECTHEIGHT(rc);

    //Get Child Window height
    rc = _rcChildIdeal;
    if (ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }
    
    childheight = RECTHEIGHT(rc);

    TraceMsg(TF_PAGER, "cps.nsb: cyChild=%d cyParent=%d _yPos=%d", childheight, parentheight, ptPos.y);

    if (childheight < parentheight ) 
    {
        ptPos.y = 0;
    }

    int iButton = _HitTestCursor();
    //See if we need top scrollbar
    if (ptPos.y > 0 ) {

        // if this button is the one that is hot tracked and the style is not PGS_AUTOSCROLL
        // then we set the state to PGF_HOT otherwise the state is set to PGF_NORMAL
        _dwState[PGB_TOPORLEFT] |= PGF_NORMAL;
        _dwState[PGB_TOPORLEFT] &= ~PGF_GRAYED;

    } else {
        if (!(ci.style & PGS_AUTOSCROLL) && (iButton == PGB_TOPORLEFT || _iButtonTrack == PGB_TOPORLEFT)) {
            _dwState[PGB_TOPORLEFT] |= PGF_GRAYED;
        } else {
            _dwState[PGB_TOPORLEFT] = PGF_INVISIBLE;
        }
    }

    if (_dwState[PGB_TOPORLEFT] != PGF_INVISIBLE)
    {
        parentheight -= _GetButtonSize();
    }
    
    //See if we need botton scrollbar
    if ((childheight - ptPos.y) > parentheight ) {
        //We need botton scroll bar

        // if this button is the one that is hot tracked and the style is not PGS_AUTOSCROLL
        // then we set the state to PGF_HOT otherwise the state is set to PGF_NORMAL
        _dwState[PGB_BOTTOMORRIGHT] |= PGF_NORMAL;
        _dwState[PGB_BOTTOMORRIGHT] &= ~PGF_GRAYED;
        
    } else {
        
        if (!(ci.style & PGS_AUTOSCROLL) && (iButton == PGB_BOTTOMORRIGHT || _iButtonTrack == PGB_BOTTOMORRIGHT)) {
            _dwState[PGB_BOTTOMORRIGHT] |= PGF_GRAYED;
        } else {
            _dwState[PGB_BOTTOMORRIGHT] = PGF_INVISIBLE;
        }
    }
}
//---------------------------------------------------------------------------------------
BOOL CPager::v_OnNCCalcSize(WPARAM wParam, LPARAM lParam, LRESULT *plres)
{    
    *plres = DefWindowProc(ci.hwnd, WM_NCCALCSIZE, wParam, lParam ) ;
    if (wParam) {
        BOOL bHorzMirror = ((ci.dwExStyle & RTL_MIRRORED_WINDOW) && (ci.style & PGS_HORZ));
        DWORD dwStateOld[2];
        NCCALCSIZE_PARAMS* pnp = (NCCALCSIZE_PARAMS*)lParam;
        _rcDefClient = pnp->rgrc[0];
        InflateRect(&_rcDefClient, -_iBorder, -_iBorder);
        _GetChildSize();
        
        dwStateOld[0] = _dwState[0];
        dwStateOld[1] = _dwState[1];
        _NeedScrollbars(pnp->rgrc[0]);

        // invalidate only if something has changed to force a new size
        if ((dwStateOld[0] != _dwState[0] && (dwStateOld[0] == PGF_INVISIBLE || _dwState[0] == PGF_INVISIBLE)) ||
            (dwStateOld[1] != _dwState[1] && (dwStateOld[1] == PGF_INVISIBLE || _dwState[1] == PGF_INVISIBLE)) 
           ) {
            RedrawWindow(ci.hwnd, NULL,NULL,RDW_INVALIDATE|RDW_ERASE);
        }

        // Check and change for horizontal mode
        if( ci.style & PGS_HORZ ) {
            FlipRect(&(pnp->rgrc[0]));
        }
    
        if( _dwState[PGB_TOPORLEFT] != PGF_INVISIBLE ) {
            //
            // Check for RTL mirrored window
            // 
            if (bHorzMirror)
                pnp->rgrc[0].bottom -= _GetButtonSize();
            else
                pnp->rgrc[0].top += _GetButtonSize();
        } else
            pnp->rgrc[0].top += _iBorder;

        if( _dwState[PGB_BOTTOMORRIGHT] != PGF_INVISIBLE ) {
            //
            // Check for RTL mirrored window
            // 
            if (bHorzMirror)
                pnp->rgrc[0].top += _GetButtonSize();
            else
                pnp->rgrc[0].bottom -= _GetButtonSize();
        } else
            pnp->rgrc[0].bottom -= _iBorder;
   
        if (pnp->rgrc[0].bottom < pnp->rgrc[0].top)
            pnp->rgrc[0].bottom = pnp->rgrc[0].top;
        
        //Change back
        if( ci.style & PGS_HORZ ) {
            FlipRect(&(pnp->rgrc[0]));
        }
    }

    return TRUE;
}

int CPager::_HitTestCursor()
{
    POINT pt;
    GetCursorPos(&pt);
    return _HitTestScreen(&pt);
}

int CPager::_HitTestScreen(POINT* ppt)
{
    RECT rc, rc1;
    GetWindowRect(ci.hwnd, &rc);

    if (!PtInRect(&rc, *ppt)) {
        return -1;
    }
    //Get the button Rects;
    rc  = _GetButtonRect(PGB_TOPORLEFT);
    rc1 = _GetButtonRect(PGB_BOTTOMORRIGHT);

    
    if (PtInRect(&rc, *ppt)) {
        return (_dwState[PGB_TOPORLEFT] != PGF_INVISIBLE ? PGB_TOPORLEFT : -1);
    }else if (PtInRect(&rc1, *ppt)) {
        return (_dwState[PGB_BOTTOMORRIGHT] != PGF_INVISIBLE ? PGB_BOTTOMORRIGHT : -1);
    }

    return -1;
}

//---------------------------------------------------------------------------------------
int CPager::_HitTest(int x, int y)
{
    POINT pt;

    pt.x = x;
    pt.y = y;
    
    ClientToScreen(ci.hwnd, &pt);
    return _HitTestScreen(&pt);
}

//---------------------------------------------------------------------------------------
// _DrawBlank is theme aware
void CPager::_DrawBlank(HDC hdc, int button)
{
    RECT rc;
    UINT uFlags = 0;
    int iHeight;
    BOOL fRelDC  = FALSE;
    
    if (!_hTheme)
    {
        if (hdc == NULL) {
            hdc = GetWindowDC(ci.hwnd);
            fRelDC = TRUE;
        }
     
        GetWindowRect(ci.hwnd, &rc);
        MapWindowRect(NULL, ci.hwnd, &rc);

        // client to window coordinates    
        OffsetRect(&rc, -rc.left, -rc.top);

        //Check for horizontal mode
        if( ci.style & PGS_HORZ ) {
            FlipRect(&rc);
        }

        iHeight = _dwState[button] == PGF_INVISIBLE ? _iBorder : _GetButtonSize();
        switch(button) {
        case PGB_TOPORLEFT:
            rc.bottom = rc.top + iHeight;
            break;

        case PGB_BOTTOMORRIGHT:
            rc.top = rc.bottom - iHeight;
            break;
        }

        if( ci.style & PGS_HORZ ) {
            FlipRect(&rc);
        }

        FillRectClr(hdc, &rc, _clrBk);
        if (fRelDC)
            ReleaseDC(ci.hwnd, hdc);
    }
}

//---------------------------------------------------------------------------------------
// _DrawButton is theme aware
void CPager::_DrawButton(HDC hdc, int button)
{
    RECT rc;
    UINT uFlags = 0;
    BOOL fRelDC = FALSE;
    GetWindowRect(ci.hwnd, &rc);
    MapWindowRect(NULL, ci.hwnd, &rc);
    int state = _dwState[button];

    int iPartId;
    int iStateId;
    
    if (state == PGF_INVISIBLE)
        return;
    
     if (hdc == NULL) {
        hdc = GetWindowDC(ci.hwnd);
        fRelDC = TRUE;
     }

    // All states for all Pager parts are the same enumeration value for
    // their meaning. Use the UP part version for all parts

    iStateId = UPS_NORMAL;
    
    if (state & PGF_GRAYED ) {
        uFlags |= DCHF_INACTIVE;

        iStateId = UPS_DISABLED;

    } else if (state & PGF_DEPRESSED ) {
        uFlags |= DCHF_PUSHED;

        iStateId = UPS_PRESSED;

    } else if (state & PGF_HOT ) {
        uFlags |=  DCHF_HOT;

        iStateId = UPS_HOT;
    }

    // screen to window coordinates    
    OffsetRect(&rc, -rc.left, -rc.top);

    //Check for horizontal mode
    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }
    
    if( ci.style & PGS_HORZ ) 
        uFlags |= DCHF_HORIZONTAL;
    
    if (button == PGB_BOTTOMORRIGHT) 
        uFlags |= DCHF_FLIPPED;

    switch(button) {
    case PGB_TOPORLEFT:
        rc.bottom = rc.top + _GetButtonSize();
        rc.left  += _iBorder;
        rc.right -= _iBorder;

        if (_hTheme)
        {
            iPartId = (ci.style & PGS_HORZ) ? PGRP_DOWNHORZ : PGRP_DOWN;
            rc.bottom += 1;
        }
        break;

    case PGB_BOTTOMORRIGHT:
        rc.top = rc.bottom - _GetButtonSize();
        rc.left  += _iBorder;
        rc.right -= _iBorder;

        if (_hTheme)
        {
            iPartId = (ci.style & PGS_HORZ) ? PGRP_UPHORZ : PGRP_UP;
            rc.top -= 1;
        }
        break;
    default:
        if (_hTheme)
            iPartId = PGRP_UP;
        ASSERT(FALSE);
    }

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }

    if (_hTheme)
    {
        DrawThemeBackground(_hTheme, hdc, iPartId, iStateId, &rc, 0);
    }
    else
    {
        SetBkColor(hdc, _clrBk);
        DrawScrollArrow(hdc, &rc, uFlags, CLR_INVALID);
    }

    if (fRelDC)
        ReleaseDC(ci.hwnd, hdc);
}

//---------------------------------------------------------------------------------------
void CPager::v_OnNCPaint()
{
    HDC hdc = GetWindowDC(ci.hwnd);
    _DrawBlank(hdc, PGB_TOPORLEFT);
    _DrawButton(hdc, PGB_TOPORLEFT);
    
    _DrawBlank(hdc, PGB_BOTTOMORRIGHT);                        
    _DrawButton(hdc, PGB_BOTTOMORRIGHT);
    ReleaseDC(ci.hwnd, hdc);
}

//---------------------------------------------------------------------------------------
void CPager::v_OnPaint(HDC hdc)
{
}
//---------------------------------------------------------------------------------------
BOOL CPager::_OnPrint(HDC hdc, UINT uFlags)
{
    //We'll be partying with the hdc in this function so save it.
    int iDC = SaveDC(hdc);

    //Print only the Non Client Area.
    if (uFlags & PRF_NONCLIENT) {        
        int cx = 0;
        int cy = 0;
        RECT rc;


         //Draw the top/left button 
        _DrawBlank(hdc, PGB_TOPORLEFT);
        _DrawButton(hdc, PGB_TOPORLEFT);

        //Draw the bottom/left button
        _DrawBlank(hdc, PGB_BOTTOMORRIGHT);                        
        _DrawButton(hdc, PGB_BOTTOMORRIGHT);

        //Is the top button visible
        if (_dwState[PGB_TOPORLEFT] != PGF_INVISIBLE) {
            //yes, find the space taken
            if ( ci.style & PGS_HORZ ) {
                cx = _GetButtonSize();
            }else {
                cy = _GetButtonSize();
            }

        }
        //Restrict the child draw area to our client area    
        GetClientRect(ci.hwnd, &rc);
        IntersectClipRect(hdc, cx, cy, cx + RECTWIDTH(rc), cy + RECTHEIGHT(rc));  

        //Since We have drawn the non client area, Nuke the PRF_NONCLIENT flag         
        uFlags &= ~PRF_NONCLIENT;
        
    }

    //Pass it to the def window proc for default processing
    DefWindowProc(ci.hwnd, WM_PRINT, (WPARAM)hdc, (LPARAM)uFlags);
    //Restore the saved  DC 
    RestoreDC(hdc, iDC);
    return TRUE;
}

//---------------------------------------------------------------------------------------
LRESULT CPager::v_OnCommand(WPARAM wParam, LPARAM lParam)
{
    // forward to parent
    return SendMessage(ci.hwndParent, WM_COMMAND, wParam, lParam);
}
//---------------------------------------------------------------------------------------
LRESULT CPager::v_OnNotify(WPARAM wParam, LPARAM lParam)
{
    // forward to parent
    LPNMHDR lpNmhdr = (LPNMHDR)lParam;
    
    return SendNotifyEx(ci.hwndParent, (HWND) -1,
                         lpNmhdr->code, lpNmhdr, ci.bUnicode);
}


//---------------------------------------------------------------------------------------
DWORD CPager::v_OnStyleChanged(WPARAM wParam, LPARAM lParam)
{
    DWORD dwChanged = CControl::v_OnStyleChanged(wParam, lParam);

    if (dwChanged & PGS_DRAGNDROP) {
        if ((ci.style & PGS_DRAGNDROP) && !_hDragProxy) {

            _hDragProxy = CreateDragProxy(ci.hwnd, PagerDragCallback, TRUE);

        } else  if (! (ci.style & PGS_DRAGNDROP)  && _hDragProxy) {

            DestroyDragProxy(_hDragProxy);
        }
    }
    
    if (dwChanged)
        CCInvalidateFrame(ci.hwnd);     // SWP_FRAMECHANGED etc.
    return dwChanged;
}


//---------------------------------------------------------------------------------------

LRESULT CPager::v_OnCreate()
{
    if (ci.style & PGS_DRAGNDROP)
        _hDragProxy = CreateDragProxy(ci.hwnd, PagerDragCallback, TRUE);

    return TRUE;
}
//---------------------------------------------------------------------------------------
void CPager::_GetChildSize()
{
    if (_hwndChild) {

        RECT rc;
        NMPGCALCSIZE nmpgcalcsize;
        int width , height;
        rc = _rcDefClient;

        if( ci.style & PGS_HORZ ) {
            nmpgcalcsize.dwFlag = PGF_CALCWIDTH;
        } else {
            nmpgcalcsize.dwFlag  = PGF_CALCHEIGHT;
        }
        nmpgcalcsize.iWidth  = RECTWIDTH(rc);    // pager width
        nmpgcalcsize.iHeight = RECTHEIGHT(rc);  // best-guess for child

        CCSendNotify(&ci, PGN_CALCSIZE, &nmpgcalcsize.hdr);

        if( ci.style & PGS_HORZ ) {
            width  = nmpgcalcsize.iWidth;
            height = RECTHEIGHT(rc);
        } else {
            width  = RECTWIDTH(rc);
            height = nmpgcalcsize.iHeight;
        }

        GetWindowRect(_hwndChild, &rc);
        MapWindowRect(NULL, ci.hwnd, &rc);
        if( ci.style & PGS_HORZ ) {
            rc.top = _iBorder;
        } else {
            rc.left = _iBorder;
        }
        rc.right = rc.left + width;
        rc.bottom = rc.top + height;
        _rcChildIdeal = rc;
    }
}

//---------------------------------------------------------------------------------------
void CPager::v_OnSize(int x, int y)
{
    if (_hwndChild) {
        RECT rc = _rcChildIdeal;
        _SetChildPos(&rc, 0);   // SetWindowPos
    }
}

//---------------------------------------------------------------------------------------
//***   _SetChildPos -- SetWindowPos of child, w/ validation
// NOTES
//  'validation' means in sane state -- min size, and not off end.
//  WARNING: we don't update *prcChild.
void CPager::_SetChildPos(IN RECT * prcChild, UINT uFlags)
{
    POINT ptPos = _ptPos;
    RECT rcChild = *prcChild;
    RECT rcPager;

    ASSERT(!(uFlags & SWP_NOMOVE));     // won't work

    ASSERT(IS_VALID_HANDLE(_hwndChild, WND));

    rcPager = _rcDefClient;


    if ( ci.style & PGS_HORZ ) {
        FlipPoint(&ptPos);
        FlipRect(&rcChild);
        FlipRect(&rcPager);
    }

    
    int yNew = ptPos.y;

    if (RECTHEIGHT(rcChild) < RECTHEIGHT(rcPager)) {
        // force to min height

        // this handles the case where: i have an ISFBand that fills up the
        // whole pager, i stretch the pager width, and the ISFBand reformats
        // to take less height, so it shrinks its height and ends up shorter
        // than the pager.
        TraceMsg(TF_PAGER, "cps.s: h=%d h'=%d", RECTHEIGHT(rcChild), RECTHEIGHT(rcPager));
        ASSERT(!(uFlags & SWP_NOSIZE));     // won't work
        rcChild.bottom = rcChild.top + RECTHEIGHT(rcPager);
        yNew = 0;
    }

    // Maximum we can scroll is child height minus pager height.
    // Here rcPager also includes scrollbutton so  we need to add that also
    /*
          ___________  Button Width
         |
         V  ---------------- Max we can scroll (yMax)
         __ |
        /  \V
         - ---------pager-----------
        |  |-------------------------|--------------------------------
        | ||                         |                                |
        | ||    child                |                                |
        |  |-------------------------|--------------------------------
         - -------------------------
        \/\/
Border  |  |
   <-----  -------------->We need to take care of this gap.
       \-----------------------------/
        ^
        |______  RECTHEIGHT(rcChild) - RECTHEIGHT(rcPager)
       
            rcPager
     We need to add the difference between the button size and border to 
    */
    int yMax = RECTHEIGHT(rcChild) - RECTHEIGHT(rcPager) + (_GetButtonSize() - _iBorder);

    // make sure we don't end up off the top/end, and we always show
    // at least 1 page worth (if we have that much)
    // n.b. pager can override client's policy
    if (yNew < 0) {
        // 1st page
        yNew = 0;
    } else if (yNew  > yMax) {
        // last page
        yNew = yMax;
    }

    int yOffset = yNew;
    
    // When the top button is grayed we do not want to display our child away from the button . 
    // it should be drawn right below the button. For this we tweak the position of the child window.

    //Check for the condition of grayed top button in which case we need to set position even behind
    // so that the child window falls below the grayed button
    if( _dwState[PGB_TOPORLEFT] & PGF_GRAYED )
    {
        yOffset += (_GetButtonSize() - _iBorder);
    }

    //yOffset is the tweaked value. Its just for making the child window to appear below the grayed button
    
    OffsetRect(&rcChild, 0, -yOffset - rcChild.top);

    //yNew is the actual logical positon of the window .
    ptPos.y = yNew;


    if (ci.style & PGS_HORZ) {
        // restore for copy and SWP
        FlipPoint(&ptPos);
        FlipRect(&rcChild);
    }

    _ptPos = ptPos;

    SetWindowPos(_hwndChild, NULL, rcChild.left, rcChild.top, RECTWIDTH(rcChild), RECTHEIGHT(rcChild), uFlags);

    return;
}
//---------------------------------------------------------------------------------------
//***   PGFToPGNDirection -- convert PGB_TOPORLEFT/btmorright to up/down/left/right
// NOTES
//  REARCHIT maybe PGN_* should we just take the PGF flags?
DWORD CPager::_PGFToPGNDirection(DWORD dwDir)
{
    ASSERT(dwDir == PGB_TOPORLEFT || dwDir == PGB_BOTTOMORRIGHT);
    if (ci.style & PGS_HORZ) {
        return (dwDir == PGB_TOPORLEFT) ? PGF_SCROLLLEFT : PGF_SCROLLRIGHT;
    }
    else {
        return (dwDir == PGB_TOPORLEFT) ? PGF_SCROLLUP : PGF_SCROLLDOWN;
    }
}
//---------------------------------------------------------------------------------------
void CPager::_Scroll(DWORD dwDirection)
{
    RECT rc;
    NMPGSCROLL nmpgscroll;
    int iXoffset =0, iYoffset=0;
    WORD fwKeys = 0;
    int iNewPos ;
    
    // if grayed, you can't scroll.
    if (_dwState[dwDirection] & PGF_GRAYED)
        return;

    if (GetKeyState(VK_CONTROL) < 0 )
        fwKeys |= PGK_CONTROL;

    if (GetKeyState(VK_SHIFT) < 0 )
        fwKeys |= PGK_SHIFT;

    if (GetKeyState(VK_MENU) < 0 )
        fwKeys |= PGK_MENU;

    dwDirection = _PGFToPGNDirection(dwDirection);

    // set some defaults
    GetClientRect(ci.hwnd, &rc);
    nmpgscroll.fwKeys  = fwKeys;
    nmpgscroll.rcParent = rc;
    nmpgscroll.iXpos  = _ptPos.x;
    nmpgscroll.iYpos  = _ptPos.y;
    nmpgscroll.iDir   = dwDirection;

    int iScroll = (ci.style & PGS_HORZ) ? RECTWIDTH(rc) : RECTHEIGHT(rc);
    if (_cLinesPerTimeout)
        iScroll = _cLinesPerTimeout  * _cPixelsPerLine;

    nmpgscroll.iScroll = iScroll;

    // let client override
    CCSendNotify(&ci, PGN_SCROLL, &nmpgscroll.hdr);

    // do it
    switch (dwDirection)
    {
        case PGF_SCROLLDOWN:
            iNewPos = _ptPos.y + nmpgscroll.iScroll;
            break;

        case PGF_SCROLLUP:
            iNewPos = _ptPos.y - nmpgscroll.iScroll;
            break;

        case PGF_SCROLLRIGHT:
            iNewPos = _ptPos.x + nmpgscroll.iScroll;
            break;

        case PGF_SCROLLLEFT:
            iNewPos = _ptPos.x - nmpgscroll.iScroll;
            break;
    }

    _OnSetPos(iNewPos);

}
//---------------------------------------------------------------------------------------
void CPager::_OnLButtonChange(UINT uMsg,LPARAM lParam)
{
    POINT pt;
    int iButton;
    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    iButton = _HitTest(pt.x, pt.y);
    
    if( uMsg == WM_LBUTTONDOWN ) {

        // Check the button is valid and is not grayed 
        // if it is grayed then dont do anything
        if (iButton >= 0) {
            SetCapture(ci.hwnd);
            _fOwnsButtonDown = TRUE;
            _iButtonTrack = iButton;
            _dwState[iButton] |= PGF_DEPRESSED;
            _DrawButton(NULL, iButton);
            _Scroll(iButton);
            SetTimer(ci.hwnd, PGT_SCROLL, _cTimeout * 4, NULL);
        }
            
    } else {
        if (_iButtonTrack >= 0) {
            _dwState[_iButtonTrack] &= ~PGF_DEPRESSED;
            _DrawButton(NULL, _iButtonTrack);
            _iButtonTrack = -1;
        }
        _KillTimer();
        
        if (iButton < 0)
            _OnMouseLeave();
    }
}
//---------------------------------------------------------------------------------------
RECT  CPager :: _GetButtonRect(int iButton)
{
    RECT rc;

    GetWindowRect(ci.hwnd, &rc);

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }

    //
    // Mirror the rects if the parent is mirrored
    //
    if (((ci.dwExStyle & RTL_MIRRORED_WINDOW) && (ci.style & PGS_HORZ))) {
        switch (iButton) {
        case PGB_TOPORLEFT:
            iButton = PGB_BOTTOMORRIGHT;
            break;

        case PGB_BOTTOMORRIGHT:
            iButton = PGB_TOPORLEFT;
            break;
        }
    }

    switch(iButton) {
    case PGB_TOPORLEFT:
        rc.bottom = rc.top +  _GetButtonSize();        
        rc.left  += _iBorder;
        rc.right -= _iBorder;
        break;
        
    case PGB_BOTTOMORRIGHT:
        rc.top  = rc.bottom - _GetButtonSize();
        rc.left  += _iBorder;
        rc.right -= _iBorder;
        break;
    }

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }
    return rc;
}

//---------------------------------------------------------------------------------------
void CPager :: _OnMouseLeave()
{
    //Whether we leave the window (WM_MOUSELEAVE) or Leave one of the scroll buttons (WM_MOUSEMOVE)
    // We do the same thing. 

    // We are leaving the pager window.
    if (GetCapture() == ci.hwnd) {
        CCReleaseCapture(&ci);
    }

    // if we are tracking some button then release that mouse and that button
    if (_iButtonTrack >= 0)  {
        _iButtonTrack = -1;
    }

    int iButton = _HitTest(_ptLastMove.x, _ptLastMove.y);
    _OnHotItemChange(iButton, FALSE);
    
    if (_dwState[PGB_TOPORLEFT] & (PGF_HOT | PGF_DEPRESSED)) {
        _dwState[PGB_TOPORLEFT] &= ~(PGF_HOT | PGF_DEPRESSED);
        _DrawButton(NULL, PGB_TOPORLEFT);
    }
    
    if (_dwState[PGB_BOTTOMORRIGHT] & (PGF_HOT | PGF_DEPRESSED)) {
        _dwState[PGB_BOTTOMORRIGHT] &= ~(PGF_HOT | PGF_DEPRESSED);
        _DrawButton(NULL, PGB_BOTTOMORRIGHT);
    }

    _KillTimer();
    _fOwnsButtonDown = FALSE;
    //If any of the button is in gray state then it needs to be removed.
    if ((_dwState[PGB_TOPORLEFT] & PGF_GRAYED) || (_dwState[PGB_BOTTOMORRIGHT] & PGF_GRAYED))  {
        //This forces a recalc for scrollbars and removes those that are not needed
        CCInvalidateFrame(ci.hwnd);
    }
}


//---------------------------------------------------------------------------------------
void CPager::_OnMouseMove(WPARAM wParam, LPARAM lparam) 
{
    RECT rc;
    POINT pt;
    int iButton;

    pt.x = GET_X_LPARAM(lparam);
    pt.y = GET_Y_LPARAM(lparam);

    // Ignore zero-mouse moves
    if (pt.x == _ptLastMove.x && pt.y == _ptLastMove.y)
        return;

    _ptLastMove = pt;
    iButton = _HitTest(pt.x, pt.y);

    if (_iButtonTrack >= 0 ) 
    {        
        
        if (_dwState[_iButtonTrack] != PGF_INVISIBLE)
        {
            //Some Button is pressed right now
            ClientToScreen(ci.hwnd,  &pt);
            rc = _GetButtonRect(_iButtonTrack);

            DWORD dwOldState = _dwState[_iButtonTrack];
            if (PtInRect(&rc, pt)) 
            {
                _dwState[_iButtonTrack] |= PGF_DEPRESSED;
            } 
            else 
            {
                _dwState[_iButtonTrack] &= ~PGF_DEPRESSED;
            }
        
            if (dwOldState != _dwState[_iButtonTrack]) 
                _DrawButton(NULL, _iButtonTrack);
        }
        
        // if we were tracking it, but the mouse is up and gone
        if (GetCapture() == ci.hwnd && !((wParam & MK_LBUTTON) || (ci.style & PGS_AUTOSCROLL)) && iButton != _iButtonTrack)
            _OnMouseLeave();

    } 
    else 
    { 
        // No button  is pressed .
        if( iButton >= 0 ) 
        {

            //Capture the mouse so that we can keep track of when the mouse is leaving our button            
            SetCapture(ci.hwnd);

            // notify parent that we entered a scroll button
            _OnHotItemChange(iButton, TRUE);
            
            // if the style is PGS_AUTOSCROLL then we dont make the button hot when hovering 
            // over button.

            //Is PGS_AUTOSCROLL set 
            _dwState[iButton] |= PGF_HOT;
            if (ci.style & PGS_AUTOSCROLL) 
            {
                _dwState[iButton] |= PGF_DEPRESSED;
            }

            //If the lbutton is down and the mouse is over one of the button then 
            // someone is trying to do drag and drop so autoscroll to help them.
            // Make sure the lbutton down did not happen in the  button before scrolling
            if ( ((wParam & MK_LBUTTON) && 
                  (_iButtonTrack < 0)) || 
                 (ci.style & PGS_AUTOSCROLL) ) 
            {
                _iButtonTrack = iButton;
                SetTimer(ci.hwnd, PGT_SCROLL, _cTimeout, NULL);
            }
            _DrawButton(NULL, iButton);
        }
        else
        {

            //Mouse is not over any button or it has left one of the scroll buttons.
            //In either case call _OnMouseLeave
           
            _OnMouseLeave();
        }
        
    }
}
//---------------------------------------------------------------------------------------
void CPager::_OnSetChild(HWND hwnd, HWND hwndChild)
{
    ASSERT(IS_VALID_HANDLE(hwndChild, WND));

    RECT rc;
    _hwndChild = hwndChild;
    _ptPos.x  = 0;
    _ptPos.y  = 0;
    _fReCalcSend = FALSE;
    if (GetCapture() == ci.hwnd)
    {
        CCReleaseCapture(&ci);
    }
    _iButtonTrack = -1;
    GetClientRect(hwnd, &rc);

    _OnReCalcSize();
}
//---------------------------------------------------------------------------------------
void CPager::_OnReCalcSize()
{
    RECT rc;
    CCInvalidateFrame(ci.hwnd);     // SWP_FRAMECHANGED etc.
    _fReCalcSend = FALSE;
    rc = _rcChildIdeal;
    _SetChildPos(&rc, 0);   // SetWindowPos

}
//---------------------------------------------------------------------------------------
void CPager::_OnSetPos(int iPos)
{
    RECT rc = _rcChildIdeal;

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
        FlipPoint(&_ptPos);
    }

    int height;
    if (iPos < 0)
        iPos = 0;

    height = RECTHEIGHT(rc);

    if( iPos < 0  ||  iPos >  height || _ptPos.y == iPos ) {
        //Invalid Position specified or no change . Igonore it.
        return;
    }

    _ptPos.y = iPos;

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
        FlipPoint(&_ptPos);
    }

    CCInvalidateFrame(ci.hwnd);
    _SetChildPos(&rc , 0);
}

//---------------------------------------------------------------------------------------
int  CPager::_OnGetPos()
{
    if( ci.style  & PGS_HORZ ) {
        return _ptPos.x;
    }else{
        return _ptPos.y;
    }
}
//---------------------------------------------------------------------------------------
DWORD CPager::_GetButtonState(int iButton)
{
    
    DWORD dwState = 0;
    // Is the button id valid ?
    if ((iButton == PGB_TOPORLEFT) || (iButton == PGB_BOTTOMORRIGHT))
    {
        //yes , Get the current state of the button
        dwState = _dwState[iButton];
    }
    return dwState;
}
//---------------------------------------------------------------------------------------
void CPager::_OnTimer(UINT id)
{
    switch (id)
    {
    case PGT_SCROLL:
        if (_iButtonTrack >= 0)
        {
            // set it again because we do it faster every subsequent time
            SetTimer(ci.hwnd, PGT_SCROLL, _cTimeout, NULL);
            if (_HitTestCursor() == _iButtonTrack)
            {
                _Scroll(_iButtonTrack);
            }
            else if (!_fOwnsButtonDown) 
            {
                // if we don't own the mouse tracking (ie, the user didn't button down on us to begin with,
                // then we're done once we leave the button
                _OnMouseLeave();
            }
        }
        break;
    }
}

void CPager::_KillTimer()
{
    KillTimer(ci.hwnd, PGT_SCROLL);
    _fTimerSet = FALSE;
}
//---------------------------------------------------------------------------------------
int  CPager::_OnSetBorder(int iBorder)
{
    int iOld = _iBorder;
    int iNew = iBorder;

    //Border can't be negative
    if (iNew < 0 )
    {
        iNew = 0;
    }

    //Border can't be bigger than the button size
    if (iNew > _GetButtonSize())
    {
       iNew = _GetButtonSize();
    }
    
    _iBorder = iNew;
    CCInvalidateFrame(ci.hwnd);
    RECT rc = _rcChildIdeal;
    _SetChildPos(&rc, 0);   // SetWindowPos
    return iOld;
}

//---------------------------------------------------------------------------------------
int  CPager::_OnSetButtonSize(int iSize)
{
    int iOldSize = _iButtonSize;
    _iButtonSize = iSize;
        
    if (_iButtonSize < MINBUTTONSIZE) 
    {
        _iButtonSize = MINBUTTONSIZE;
    }

    // Border can't be bigger than button size
    if (_iBorder > _iButtonSize)
    {
        _iBorder = _iButtonSize;
    }

    CCInvalidateFrame(ci.hwnd);
    RECT rc = _rcChildIdeal;
    _SetChildPos(&rc, 0);   // SetWindowPos
    return iOldSize;

}


//---------------------------------------------------------------------------------------
void CPager::_OnHotItemChange(int iButton, BOOL fEnter)
{
    NMPGHOTITEM nmhot = {0};

    if (fEnter)
    {
        nmhot.idNew = iButton;
        nmhot.dwFlags = HICF_ENTERING;
    }
    else
    {
        nmhot.idOld = iButton;
        nmhot.dwFlags = HICF_LEAVING;
    }

    CCSendNotify(&ci, PGN_HOTITEMCHANGE, &nmhot.hdr);
}


//---------------------------------------------------------------------------------------
LRESULT CPager::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
    case PGM_GETDROPTARGET:
        if (!_hDragProxy)
            _hDragProxy = CreateDragProxy(ci.hwnd, PagerDragCallback, FALSE);
        
        GetDragProxyTarget(_hDragProxy, (IDropTarget**)lParam);
        break;

    case PGM_SETSCROLLINFO:
        _cLinesPerTimeout = LOWORD(lParam);
        _cPixelsPerLine = HIWORD(lParam);
        _cTimeout = (UINT)wParam;
        break;
        
    case PGM_SETCHILD:
        _OnSetChild(hwnd, (HWND)lParam);
        break;

    case PGM_RECALCSIZE:
        if (!_fReCalcSend )
        {
            _fReCalcSend = TRUE;
            PostMessage(hwnd, PGMP_RECALCSIZE, wParam, lParam);
        }
        break;

    case PGMP_RECALCSIZE:
         _OnReCalcSize();
         break;

    case PGM_FORWARDMOUSE:
        // forward mouse messages
        _fForwardMouseMsgs = BOOLIFY(wParam);
        break;

        
    case PGM_SETBKCOLOR:
    {
        COLORREF clr = _clrBk;
        if ((COLORREF) lParam == CLR_DEFAULT)
            _clrBk = g_clrBtnFace;
        else
            _clrBk = (COLORREF)lParam;
        _fBkColorSet = TRUE;
        CCInvalidateFrame(ci.hwnd);
        //Force a paint
        RedrawWindow(ci.hwnd, NULL,NULL,RDW_INVALIDATE|RDW_ERASE);
        return clr;
    }

    case PGM_GETBKCOLOR:
        return (LRESULT)_clrBk;    

    case PGM_SETBORDER:
        return _OnSetBorder((int)lParam);

    case PGM_GETBORDER:
        return (LRESULT)_iBorder;
        
    case PGM_SETPOS:
        _OnSetPos((int)lParam);
        break;

    case PGM_GETPOS:
        return _OnGetPos();

    case PGM_SETBUTTONSIZE:
        return _OnSetButtonSize((int)lParam);

    case PGM_GETBUTTONSIZE:
        return _GetButtonSize();
    
    case PGM_GETBUTTONSTATE:
        return _GetButtonState((int)lParam);

    case WM_PRINTCLIENT:
        CCForwardPrint(&ci, (HDC)wParam);
        return 0;

    case WM_PRINT:
        return _OnPrint((HDC)wParam, (UINT)lParam);

    case WM_NCHITTEST:
    {
        POINT pt;
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        if (_HitTestScreen(&pt) == -1)
            return HTTRANSPARENT;
        return HTCLIENT;
    }

    case WM_SYSCOLORCHANGE:
        if (!_fBkColorSet)
        {
            InitGlobalColors();
            _clrBk = g_clrBtnFace;
            CCInvalidateFrame(ci.hwnd);
        }
        break;

    case WM_SETFOCUS:
        SetFocus(_hwndChild);
        return 0;

    case WM_LBUTTONDOWN:
        //Fall Through
    case WM_LBUTTONUP:
        if(!(ci.style & PGS_AUTOSCROLL)) {        
            _OnLButtonChange(uMsg,lParam);
        }
        break;

    case WM_MOUSEMOVE:
        // Only forward if the point is within the client rect of pager.
        if (_fForwardMouseMsgs && _hwndChild)
        {
            POINT pt;
            RECT rcClient;

            GetClientRect(ci.hwnd, &rcClient);

            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);

            // Is this point in our client rect?
            if (PtInRect(&rcClient, pt))
            {
                // Yes; then convert coords and forward it
                pt.x += _ptPos.x;
                pt.y += _ptPos.y;

                SendMessage(_hwndChild, WM_MOUSEMOVE, wParam, MAKELPARAM(pt.x, pt.y));
            }
        }

        _OnMouseMove(wParam,lParam);
        break;

    case WM_MOUSELEAVE :
        _OnMouseLeave();
        break;

    case WM_ERASEBKGND:
    {
        LRESULT lres = CCForwardEraseBackground(ci.hwnd, (HDC) wParam);

        if (_iBorder) {
            // paint the borders
            RECT rc;
            RECT rc2;
            GetClientRect(ci.hwnd, &rc);
            rc2 = rc;
        
            if( ci.style & PGS_HORZ ) {
                FlipRect(&rc2);
            }
            rc2.right = rc2.left + _iBorder + 1;

            if( ci.style & PGS_HORZ ) {
                FlipRect(&rc2);
            }            
            FillRectClr((HDC)wParam, &rc2, _clrBk);
            rc2 = rc;

            if( ci.style & PGS_HORZ ) {
                FlipRect(&rc2);
            }
            rc2.left = rc2.right - _iBorder - 1;

            if( ci.style & PGS_HORZ ) {
                FlipRect(&rc2);
            }

            FillRectClr((HDC)wParam, &rc2, _clrBk);
        }
        return TRUE;
    }

    case WM_TIMER:
        _OnTimer((UINT)wParam);
        return 0;       

    case WM_SETTINGCHANGE:
        InitGlobalMetrics(wParam);
        _iButtonSize = (int) g_cxScrollbar * 3 / 4;
        if (_iButtonSize < MINBUTTONSIZE) {
            _iButtonSize = MINBUTTONSIZE;
        }
        break;

    case WM_DESTROY:
        if (_hDragProxy)
            DestroyDragProxy(_hDragProxy);
        break;
    }
    return CControl::v_WndProc(hwnd, uMsg, wParam, lParam);
}

//---------------------------------------------------------------------------------------
// call with cyCh == 0 to specify auto vsizing
BOOL DrawChar(HDC hdc, LPRECT lprc, UINT wState, TCHAR ch, UINT cyCh, BOOL fAlwaysGrayed, BOOL fTopAlign, COLORREF rgbOveride)
{
    COLORREF rgb;
    BOOL    fDrawDisabled = !fAlwaysGrayed && (wState & DCHF_INACTIVE);
    BOOL    fDrawPushed = wState & DCHF_PUSHED;
    // Bad UI to have a pushed disabled button
    ASSERT (!fDrawDisabled || !fDrawPushed);
    RECT rc = *lprc;
    UINT uFormat = DT_CENTER | DT_SINGLELINE;

    if (fAlwaysGrayed)
        rgb = g_clrBtnShadow;
    else if (fDrawDisabled)
        rgb = g_clrBtnHighlight;
    else 
        rgb = g_clrBtnText;

    if (rgbOveride != CLR_INVALID)
    {
        rgb = rgbOveride;
    }
    
    rgb = SetTextColor(hdc, rgb);

    if (cyCh)
    {
        if (fTopAlign)
            rc.bottom = rc.top + cyCh;
        else
        {
            rc.top += ((RECTHEIGHT(rc) - cyCh) / 2);
            rc.bottom = rc.top + cyCh;
        }
        uFormat |= DT_BOTTOM;
    }
    else
        uFormat |= DT_VCENTER;

    if (fDrawDisabled || fDrawPushed)
        OffsetRect(&rc, 1, 1);

    DrawText(hdc, &ch, 1, &rc, uFormat);

    if (fDrawDisabled)
    {
        OffsetRect(&rc, -1, -1);
        SetTextColor(hdc, g_clrBtnShadow);
        DrawText(hdc, &ch, 1, &rc, uFormat);
    }

    SetTextColor(hdc, rgb);
    return(TRUE);
}

void DrawBlankButton(HDC hdc, LPRECT lprc, DWORD wControlState)
{
    BOOL fAdjusted;

    if (wControlState & (DCHF_HOT | DCHF_PUSHED) &&
        !(wControlState & DCHF_NOBORDER)) {
        COLORSCHEME clrsc;

        clrsc.dwSize = 1;
        if (GetBkColor(hdc) == g_clrBtnShadow) {
            clrsc.clrBtnHighlight = g_clrBtnHighlight;
            clrsc.clrBtnShadow = g_clrBtnText;
        } else
            clrsc.clrBtnHighlight = clrsc.clrBtnShadow = CLR_DEFAULT;

        // if button is both DCHF_HOT and DCHF_PUSHED, DCHF_HOT wins here
        CCDrawEdge(hdc, lprc, (wControlState & DCHF_HOT) ? BDR_RAISEDINNER : BDR_SUNKENOUTER,
                 (UINT) (BF_ADJUST | BF_RECT), &clrsc);
        fAdjusted = TRUE;
    } else {
        fAdjusted = FALSE;
    }

    if (!(wControlState & DCHF_TRANSPARENT))
        FillRectClr(hdc, lprc, GetBkColor(hdc));
    
    if (!fAdjusted)
        InflateRect(lprc, -g_cxBorder, -g_cyBorder);
}

//---------------------------------------------------------------------------------------
void DrawCharButton(HDC hdc, LPRECT lprc, UINT wControlState, TCHAR ch, UINT cyCh, BOOL fAlwaysGrayed, BOOL fTopAlign, COLORREF rgbOveride)
{
    RECT rc;
    CopyRect(&rc, lprc);

    DrawBlankButton(hdc, &rc, wControlState);

    if ((RECTWIDTH(rc) <= 0) || (RECTHEIGHT(rc) <= 0))
        return;

#if defined(UNIX)
    HBITMAP hbit;
    int x,y,width,height;

    x = rc.left + (rc.right  - rc.left) /2;
    y = rc.top  + (rc.bottom - rc.top ) /2;

    if (wControlState & (DCHF_INACTIVE | DCHF_PUSHED))
    {
        x++;
        y++;
    }

    UnixPaintArrow( hdc, 
         (wControlState & DCHF_HORIZONTAL), 
         (wControlState & DCHF_FLIPPED), 
         x,y,
         min(ARROW_WIDTH,  (rc.right  - rc.left)),
         min(ARROW_HEIGHT, (rc.bottom - rc.top ))
        );

#else
    
    int iOldBk = SetBkMode(hdc, TRANSPARENT);
    DrawChar(hdc, &rc, wControlState, ch, cyCh, fAlwaysGrayed, fTopAlign, rgbOveride);
    SetBkMode(hdc, iOldBk);

#endif

}

// --------------------------------------------------------------------------------------
//
//  DrawScrollArrow
//
// --------------------------------------------------------------------------------------
void DrawScrollArrow(HDC hdc, LPRECT lprc, UINT wControlState, COLORREF rgbOveride)
{
#define szfnMarlett  TEXT("MARLETT")
    TCHAR ch = (wControlState & DCHF_HORIZONTAL) ? TEXT('3') : TEXT('5');

    //
    // Flip the direction arrow in case of a RTL mirrored DC,
    // since it won't be flipped automatically (textout!)
    //
    if (IS_DC_RTL_MIRRORED(hdc) && (wControlState & DCHF_HORIZONTAL))
        wControlState ^= DCHF_FLIPPED;

    LONG lMin = min(RECTWIDTH(*lprc), RECTHEIGHT(*lprc)) - (2 * g_cxBorder);  // g_cxBorder fudge notches font size down

    HFONT hFont = CreateFont(lMin, 0, 0, 0, FW_NORMAL, 0, 0, 0, SYMBOL_CHARSET, 0, 0, 0, 0, szfnMarlett);
    
    HFONT hOldFont = (HFONT)SelectObject(hdc, hFont);
    
    if (wControlState & DCHF_FLIPPED)
        ch++;
    
    DrawCharButton(hdc, lprc, wControlState, ch, 0, FALSE, FALSE, rgbOveride);
    SelectObject(hdc, hOldFont);
    DeleteObject(hFont);   
}

//---------------------------------------------------------------------------------------

#define CX_INCREMENT    1
#define CX_DECREMENT    (-CX_INCREMENT)

#define MIDPOINT(x1, x2)        ((x1 + x2) / 2)
#define CHEVRON_WIDTH(dSeg)     (4 * dSeg)

// DrawChevron is theme-aware
void DrawChevron(HTHEME hTheme, int iPartId, HDC hdc, LPRECT lprc, DWORD dwFlags)
{
    RECT rc;
    CopyRect(&rc, lprc);

    if (hTheme)
    {
        // Get state id from dwFlags
        int iStateId = CHEVS_NORMAL;

        if (dwFlags & DCHF_HOT)
            iStateId = CHEVS_HOT;

        if (dwFlags & DCHF_PUSHED)
            iStateId = CHEVS_PRESSED;

        DrawThemeBackground(hTheme, hdc, iPartId, iStateId, &rc, 0);
    }
    else
    {
        // draw the border and background
        DrawBlankButton(hdc, &rc, dwFlags);

        // offset the arrow if pushed
        if (dwFlags & DCHF_PUSHED)
            OffsetRect(&rc, CX_INCREMENT, CX_INCREMENT);

        // draw the arrow
        HBRUSH hbrSave = SelectBrush(hdc, GetSysColorBrush(COLOR_BTNTEXT));

        int dSeg = (g_cxVScroll / 7);
        dSeg = max(2, dSeg);

        if (dwFlags & DCHF_HORIZONTAL)
        {
            // horizontal arrow
            int x = MIDPOINT(rc.left, rc.right - CHEVRON_WIDTH(dSeg));

            int yBase;
            if (dwFlags & DCHF_TOPALIGN)
                yBase = rc.top + (3 * dSeg);
            else
                yBase = MIDPOINT(rc.top, rc.bottom);


            for (int y = -dSeg; y <= dSeg; y++)
            {
                PatBlt(hdc, x, yBase + y, dSeg, CX_INCREMENT, PATCOPY);
                PatBlt(hdc, x + (dSeg * 2), yBase + y, dSeg, CX_INCREMENT, PATCOPY);

                x += (y < 0) ? CX_INCREMENT : CX_DECREMENT;
            }
        }
        else
        {
            // vertical arrow
            int y = rc.top + CX_INCREMENT;
            int xBase = MIDPOINT(rc.left, rc.right);

            for (int x = -dSeg; x <= dSeg; x++)
            {
                PatBlt(hdc, xBase + x, y, CX_INCREMENT, dSeg, PATCOPY);
                PatBlt(hdc, xBase + x, y + (dSeg * 2), CX_INCREMENT, dSeg, PATCOPY);

                y += (x < 0) ? CX_INCREMENT : CX_DECREMENT;
            }
        }

        // clean up
        SelectBrush(hdc, hbrSave);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\pager.h ===
//---------------------------------------------------------------------------------------
//  File : Pager.h
//  Description :
//        This is the header file for the pager control
//---------------------------------------------------------------------------------------
#include "ccontrol.h"

#define PGMP_RECALCSIZE  200

//---------------------------------------------------------------------------------------
class CPager : public CControl
{
public:
    //Function Memebers
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT PagerWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT PagerDragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp);
protected:
    
    CPager();
    
    //Function Members    
    DWORD _PGFToPGNDirection(DWORD dwDir);
    void _Scroll(DWORD dwDirection);
    void _SetChildPos(RECT * prcChild, UINT uFlags);
    void _NeedScrollbars(RECT rc);
    int  _GetPage(DWORD dwDirection);
    void _OnSetChild(HWND hwnd, HWND hwndChild);
    void _OnSetPos(int iPos);
    int  _OnGetPos();
    int  _OnSetBorder(int iBorder);
    int  _OnSetButtonSize(int iSize);
    void _OnHotItemChange(int iButton, BOOL fEnter);
    void _OnReCalcSize();
    void _OnLButtonChange(UINT uMsg,LPARAM lParam);
    void _OnMouseMove(WPARAM wParam,LPARAM lParam);
    void _DrawButton(HDC hdc,int button);
    void _DrawBlank(HDC hdc,int button);
    BOOL _OnPrint(HDC hdc,UINT uFlags);
    int  _HitTest(int x , int y);
    int  _HitTestScreen(LPPOINT ppt);
    int  _HitTestCursor();
    void _GetChildSize();
    RECT _GetButtonRect(int iButton);
    void _OnMouseLeave();
    inline _GetButtonSize();
    DWORD  _GetButtonState(int iButton);
    void _OnTimer(UINT id);
    LRESULT _DragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp);
    void _KillTimer();

    virtual void v_OnPaint(HDC hdc);
    virtual LRESULT v_OnCreate();
    virtual void v_OnSize(int x, int y);
    virtual void v_OnNCPaint();
    virtual LRESULT v_OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT v_OnNotify(WPARAM wParam, LPARAM lParam);
    virtual DWORD v_OnStyleChanged(WPARAM wParam, LPARAM lParam);    
    virtual BOOL v_OnNCCalcSize(WPARAM wParam, LPARAM lParam, LRESULT *plres);

    virtual LPCTSTR GetThemeClass() { return TEXT("Pager"); }

    //Data Members
    HWND    _hwndChild;    
    POINT   _ptPos;
    POINT   _ptLastMove;
    BITBOOL _fReCalcSend:1;
    BITBOOL _fForwardMouseMsgs:1;
    BITBOOL _fBkColorSet:1;
    BITBOOL _fTimerSet :1;
    BITBOOL _fOwnsButtonDown :1;
    int     _iButtonTrack;
    RECT    _rcDefClient; // this is our "natural" client rect if we didn't mess with nccalc
    DWORD   _dwState[2];  // State of the two scroll buttons
    RECT    _rcChildIdeal; // our child's ideal size
    int     _iButtonSize;
    HDRAGPROXY  _hDragProxy;

    COLORREF _clrBk;
    int _iBorder;

    UINT _cLinesPerTimeout;
    UINT _cPixelsPerLine;
    UINT _cTimeout;
};
//---------------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\mru.c ===
#include "ctlspriv.h"
#include <memory.h>

#define MRU_ORDERDIRTY 0x1000

#define DM_MRULAZY  DM_TRACE

#define MAX_CHAR    126
#define BASE_CHAR   TEXT('a')

typedef struct tagMRUDATA
{
    UINT fFlags;
    UINT uMax;
    LPVOID lpfnCompare;
    HKEY hKey;
#ifdef DEBUG
    TCHAR szSubKey[32];
#endif
    LPTSTR cOrder;
} MRUDATA, *PMRUDATA;

#define c_szMRU     TEXT("MRUList")

#define NTHSTRING(p, n) (*((LPTSTR *)((LPBYTE)p+sizeof(MRUDATA))+n))
#define NTHDATA(p, n) (*((LPBYTE *)((LPBYTE)p+sizeof(MRUDATA))+n))
#define NUM_OVERHEAD 3


#ifdef VSTF

/*----------------------------------------------------------
Purpose: Validate the MRU structure
*/
BOOL IsValidPMRUDATA(PMRUDATA pmru)
{
    return (IS_VALID_WRITE_PTR(pmru, MRUDATA) &&
            (NULL == pmru->lpfnCompare || IS_VALID_CODE_PTR(pmru->lpfnCompare, void)));
}

#endif // VSTF

//----------------------------------------------------------------------------
// Internal memcmp - saves loading crt's, cdecl so we can use
// as MRUCMPDATAPROC

int CDECL _mymemcmp(const void *pBuf1, const void *pBuf2, size_t cb)
{
    // Take advantage of the intrinsic version from crtfree.h
    return memcmp(pBuf1, pBuf2, cb);
}


// Use this macro to get the original size of the data.
#define DATASIZE(p)     (*((LPDWORD)p))
// And this to get a pointer to the original data.
#define DATAPDATA(p)    (p+sizeof(DWORD))

//----------------------------------------------------------------------------
//  For binary data we stick the size of the data at the begining and store the
//  whole thing in one go.
BOOL MRUIsSameData(PMRUDATA pMRU, BYTE* pVal, const void *lpData, UINT cbData)
{
    int cbUseSize;
    MRUCMPDATAPROC lpfnCompare;

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    lpfnCompare = pMRU->lpfnCompare;

    ASSERT(IS_VALID_CODE_PTR(lpfnCompare, MRUCMPDATAPROC));

    // if there's something other than a mem compare,
    // don't require the sizes to be equal in order for the
    // data to be equivalent.

    if (pMRU->lpfnCompare == _mymemcmp)
    {
        if (DATASIZE(pVal) != cbData)
            return FALSE;

        cbUseSize = cbData;
    }
    else
        cbUseSize = min(DATASIZE(pVal), cbData);

    return ((*lpfnCompare)(lpData, DATAPDATA(pVal), cbUseSize) == 0);
}


//----------------------------------------------------------------------------
HANDLE WINAPI CreateMRUListLazy(LPMRUINFO lpmi, const void *lpData, UINT cbData, LPINT lpiSlot)
{
    PTSTR pOrder, pNewOrder, pTemp;
    LPBYTE pVal;
    LONG cbVal;
    DWORD dwDisposition;
    DWORD dwType;
    PMRUDATA pMRU = NULL;
    HKEY hkeySubKey = NULL;
    TCHAR szTemp[2];
    UINT uMax = lpmi->uMax;
    HKEY hKey = lpmi->hKey;
    LPCTSTR lpszSubKey = lpmi->lpszSubKey;
    MRUCMPPROC lpfnCompare = lpmi->lpfnCompare;
    int cb;

#ifdef DEBUG
    DWORD dwStart = GetTickCount();
#endif
    if (!lpfnCompare) 
    {
        lpfnCompare = (lpmi->fFlags & MRU_BINARY) ? (MRUCMPPROC)_mymemcmp :
                      ((lpmi->fFlags & MRU_ANSI) ? (MRUCMPPROC)lstrcmpiA :
                       (MRUCMPPROC)lstrcmpi);
    }

    //  limit to 126 so that we don't use extended chars
    if (uMax > MAX_CHAR-BASE_CHAR)
        uMax = MAX_CHAR-BASE_CHAR;

    if (RegCreateKeyEx(hKey, lpszSubKey, 0L, (LPTSTR)c_szShell, REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkeySubKey, &dwDisposition) != ERROR_SUCCESS)
    {
        goto Error1;
    }

    pOrder = (PTSTR)Alloc((uMax + 1) * sizeof(TCHAR));
    if (!pOrder)
    {
        goto Error1;
    }

    cbVal = ((LONG)uMax + 1) * sizeof(TCHAR);

    if (RegQueryValueEx(hkeySubKey, (LPTSTR)c_szMRU, NULL, &dwType, (LPBYTE)pOrder, &cbVal) != ERROR_SUCCESS)
    {
        // if not already in the registry, then start fresh
        *pOrder = 0;
    }

    // Uppercase is not allowed
    CharLower(pOrder);

    // We allocate room for the MRUDATA structure, plus the order list,
    // and the list of strings.
    cb = (lpmi->fFlags & MRU_BINARY) ? sizeof(LPBYTE) : sizeof(LPTSTR);
    pMRU = (PMRUDATA)Alloc(sizeof(MRUDATA)+(uMax*cb));
    if (!pMRU)
    {
        goto Error2;
    }

    // Allocate space for the order list
    pMRU->cOrder = (LPTSTR)Alloc((uMax+1)*sizeof(TCHAR));
    if (!pMRU->cOrder) 
    {
        Free(pMRU);
        pMRU = NULL;
        goto Error2;
    }

    pMRU->fFlags = lpmi->fFlags;
    pMRU->uMax = uMax;
    pMRU->lpfnCompare = lpfnCompare;
    pMRU->hKey = hkeySubKey;
#ifdef DEBUG
    lstrcpyn(pMRU->szSubKey, lpszSubKey, ARRAYSIZE(pMRU->szSubKey));
#endif

    // Traverse through the MRU list, adding strings to the end of the
    // list.
    szTemp[1] = TEXT('\0');
    for (pTemp = pOrder, pNewOrder = pMRU->cOrder; ; ++pTemp)
    {
        // Stop when we get to the end of the list.
        szTemp[0] = *pTemp;
        if (!szTemp[0]) 
        {
            break;
        }

        if (lpmi->fFlags & MRU_BINARY) 
        {
            // Check if in range and if we have already used this letter.
            if ((UINT)(szTemp[0]-BASE_CHAR)>=uMax || NTHDATA(pMRU, szTemp[0]-BASE_CHAR)) 
            {
                continue;
            }
            // Get the value from the registry
            cbVal = 0;
            // first find the size
            if ((RegQueryValueEx(hkeySubKey, szTemp, NULL, &dwType, NULL, &cbVal)
                 != ERROR_SUCCESS) || (dwType != REG_BINARY))
            {
                continue;
            }

            // Binary data has the size at the begining so we'll need a little extra room.
            pVal = (LPBYTE)Alloc(cbVal + sizeof(DWORD));

            if (!pVal) 
            {
                // REARCHITECT perhaps sort of error is in order.
                continue;
            }

            // now really get it
            DATASIZE(pVal) = cbVal;
            if (RegQueryValueEx(hkeySubKey, szTemp, NULL, &dwType, pVal+sizeof(DWORD),
                                (LPDWORD)pVal) != ERROR_SUCCESS)
            {
                continue;
            }

            // Note that blank elements ARE allowed in the list.
            NTHDATA(pMRU, szTemp[0]-BASE_CHAR) = pVal;
            *pNewOrder++ = szTemp[0];

            //
            // OPTIMIZATION
            //   If lpData and lpiSlot are specified, we stop the enumeratation
            //  when we find the item.
            //
            if (lpData && lpiSlot) 
            {
                // Check if we have the specified one or not.
                if (MRUIsSameData(pMRU, pVal, lpData, cbData)) 
                {
                    // Found it.
                    *lpiSlot = (INT) (pNewOrder - pMRU->cOrder);

                    TraceMsg(DM_MRULAZY, "CreateMRUListLazy found it. Copying %s", pTemp);

                    pMRU->fFlags |= MRU_LAZY;
                    //
                    // Copy the rest of slot. Notice that we don't load
                    // data for those slot.
                    //
                    for (pTemp++; *pTemp; pTemp++) 
                    {
                        *pNewOrder++ = *pTemp;
                    }
                    break;
                }
            }
        } 
        else 
        {

            // Check if in range and if we have already used this letter.
            if ((UINT)(szTemp[0]-BASE_CHAR)>=uMax || NTHSTRING(pMRU, szTemp[0]-BASE_CHAR)) 
            {
                continue;
            }
            // Get the value from the registry
            cbVal = 0;
            // first find the size
            if ((RegQueryValueEx(hkeySubKey, szTemp, NULL, &dwType, NULL, &cbVal)
                 != ERROR_SUCCESS) || (dwType != REG_SZ))
            {
                continue;
            }

            cbVal *= sizeof(TCHAR);
            pVal = (LPBYTE)Alloc(cbVal);

            if (!pVal) 
            {
                // REARCHITECT perhaps sort of error is in order.
                continue;
            }
            // now really get it
            if (RegQueryValueEx(hkeySubKey, szTemp, NULL, &dwType, (LPBYTE)pVal, &cbVal) != ERROR_SUCCESS)
            {
                continue;
            }

            // Note that blank elements are not allowed in the list.
            if (*((LPTSTR)pVal)) 
            {
                NTHSTRING(pMRU, szTemp[0]-BASE_CHAR) = (LPTSTR)pVal;
                *pNewOrder++ = szTemp[0];
            } 
            else 
            {
                Free(pVal);
                pVal = NULL;
            }
        }
    }
    /* NULL terminate the order list so we can tell how many strings there
     * are.
     */
    *pNewOrder = TEXT('\0');

    if (lpData && lpiSlot) 
    {
        TraceMsg(DM_MRULAZY, "CreateMRUListLazy. End of loop. %s", pMRU->cOrder);
        // If we failed to find, put -1 in it.
        if (!(pMRU->fFlags & MRU_LAZY)) 
        {
            *lpiSlot = -1;
        }
    }

    /* Actually, this is success rather than an error.
     */
    goto Error2;

Error2:
    if (pOrder)
    {
        Free((HLOCAL)pOrder);
        pOrder = NULL;
    }

Error1:
    if (!pMRU && hkeySubKey)
        RegCloseKey(hkeySubKey);

    return((HANDLE)pMRU);
}

HANDLE WINAPI CreateMRUList(LPMRUINFO lpmi)
{
    return CreateMRUListLazy(lpmi, NULL, 0, NULL);
}

#ifdef UNICODE

//
// ANSI thunk
//

HANDLE WINAPI CreateMRUListLazyA(LPMRUINFOA lpmi, const void *lpData, UINT cbData, LPINT lpiSlot)
{
    MRUINFOW MRUInfoW;
    HANDLE hMRU;

    MRUInfoW.cbSize       = sizeof (MRUINFOW);
    MRUInfoW.uMax         = lpmi->uMax;
    MRUInfoW.fFlags       = lpmi->fFlags;
    MRUInfoW.hKey         = lpmi->hKey;
    MRUInfoW.lpszSubKey   = ProduceWFromA(CP_ACP, lpmi->lpszSubKey);
    MRUInfoW.lpfnCompare  = (MRUCMPPROCW)lpmi->lpfnCompare;

    MRUInfoW.fFlags |= MRU_ANSI;

    hMRU = CreateMRUListLazy(&MRUInfoW, lpData, cbData, lpiSlot);

    FreeProducedString((LPWSTR)MRUInfoW.lpszSubKey);

    return hMRU;
}

HANDLE WINAPI CreateMRUListA(LPMRUINFOA lpmi)
{
    return CreateMRUListLazyA(lpmi, NULL, 0, NULL);
}
#else

//
// Unicode stub when this code is built ANSI
//

HANDLE WINAPI CreateMRUListW(LPMRUINFOW lpmi)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return NULL;
}

HANDLE WINAPI CreateMRUListLazyW(LPMRUINFOW lpmi, const void *lpData, UINT cbData, LPINT lpiSlot)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return NULL;
}
#endif


//----------------------------------------------------------------------------
STDAPI_(void) FreeMRUList(HANDLE hMRU)
{
    int i;
    LPVOID *pTemp;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (pMRU)
    {
        pTemp = (pMRU->fFlags & MRU_BINARY) ?
            &NTHDATA(pMRU, 0) : (LPBYTE *)&NTHSTRING(pMRU, 0);

        if (pMRU->fFlags & MRU_ORDERDIRTY)
        {
            RegSetValueEx(pMRU->hKey, c_szMRU, 0L, REG_SZ, (CONST BYTE *)pMRU->cOrder,
                          sizeof(TCHAR) * (lstrlen(pMRU->cOrder) + 1));
        }

        for (i=pMRU->uMax-1; i>=0; --i, ++pTemp)
        {
            if (*pTemp)
            {
                if (pMRU->fFlags & MRU_BINARY)
                {
                    Free((LPBYTE)*pTemp);
                    *pTemp = NULL;
                }
                else
                    Str_SetPtr((LPTSTR *)pTemp, NULL);
            }
        }
        RegCloseKey(pMRU->hKey);
        Free(pMRU->cOrder);
        Free((HLOCAL)pMRU);
    }
}


/* Add a string to an MRU list.
 */
STDAPI_(int) AddMRUString(HANDLE hMRU, LPCTSTR szString)
{
    /* The extra +1 is so that the list is NULL terminated.
    */
    TCHAR cFirst;
    int iSlot = -1;
    LPTSTR lpTemp;
    LPTSTR * pTemp;
    int i;
    UINT uMax;
    MRUCMPPROC lpfnCompare;
    BOOL fShouldWrite;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

#ifdef DEBUG
    DWORD dwStart = GetTickCount();
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (hMRU == NULL)
        return(-1);     // Error

    fShouldWrite = !(pMRU->fFlags & MRU_CACHEWRITE);
    uMax = pMRU->uMax;
    lpfnCompare = (MRUCMPPROC)pMRU->lpfnCompare;

    /* Check if the string already exists in the list.
    */
    for (i=0, pTemp=&NTHSTRING(pMRU, 0); (UINT)i<uMax; ++i, ++pTemp)
    {
        if (*pTemp)
        {
            int iResult;

#ifdef UNICODE
            if (pMRU->fFlags & MRU_ANSI)
            {
                LPSTR lpStringA, lpTempA;

                lpStringA = ProduceAFromW (CP_ACP, szString);
                lpTempA = ProduceAFromW (CP_ACP, (LPWSTR)*pTemp);

                iResult = (*lpfnCompare)((const void *)lpStringA, (const void *)lpTempA);

                FreeProducedString (lpStringA);
                FreeProducedString (lpTempA);
            }
            else
#endif
            {
                iResult = (*lpfnCompare)((const void *)szString, (const void *)*pTemp);
            }

            if (!iResult)
            {
                // found it, so don't do the write out
                cFirst = i + BASE_CHAR;
                iSlot = i;
                goto FoundEntry;
            }
        }
    }

    /* Attempt to find an unused entry.  Count up the used entries at the
    * same time.
    */
    for (i=0, pTemp=&NTHSTRING(pMRU, 0); ; ++i, ++pTemp)
    {
        if ((UINT)i >= uMax)    // If we got to the end of the list.
        {
            // use the entry at the end of the cOrder list
            cFirst = pMRU->cOrder[uMax-1];
            pTemp = &NTHSTRING(pMRU, cFirst-BASE_CHAR);
            break;
        }

        // Is the entry not used?
        if (!*pTemp)
        {
            // yes
            cFirst = i+BASE_CHAR;
            break;
        }
    }

    if (Str_SetPtr(pTemp, szString))
    {
        TCHAR szTemp[2];

        iSlot = (int)(cFirst-BASE_CHAR);

        szTemp[0] = cFirst;
        szTemp[1] = TEXT('\0');

        RegSetValueEx(pMRU->hKey, szTemp, 0L, REG_SZ, (CONST BYTE *)szString,
            sizeof(TCHAR) * (lstrlen(szString) + 1));

        fShouldWrite = TRUE;
    }
    else
    {
        /* Since iSlot == -1, we will remove the reference to cFirst
        * below.
        */
    }

FoundEntry:
    /* Remove any previous reference to cFirst.
    */
    lpTemp = StrChr(pMRU->cOrder, cFirst);
    if (lpTemp)
    {
        lstrcpy(lpTemp, lpTemp+1);
    }

    if (iSlot != -1)
    {
        // shift everything over and put cFirst at the front
        hmemcpy(pMRU->cOrder+1, pMRU->cOrder, pMRU->uMax*sizeof(TCHAR));
        pMRU->cOrder[0] = cFirst;
    }

    if (fShouldWrite)
    {
        RegSetValueEx(pMRU->hKey, c_szMRU, 0L, REG_SZ, (CONST BYTE *)pMRU->cOrder,
            sizeof(TCHAR) * (lstrlen(pMRU->cOrder) + 1));
        pMRU->fFlags &= ~MRU_ORDERDIRTY;
    } else
        pMRU->fFlags |= MRU_ORDERDIRTY;

#ifdef DEBUG
    // DebugMsg(DM_TRACE, TEXT("AddMRU: %d msec"), LOWORD(GetTickCount()-dwStart));
#endif
    return(iSlot);
}


#ifdef UNICODE
//
// ANSI thunk
//

STDAPI_(int) AddMRUStringA(HANDLE hMRU, LPCSTR szString)
{
    LPWSTR lpStringW;
    INT    iResult;

    lpStringW = ProduceWFromA(CP_ACP, szString);

    iResult = AddMRUString(hMRU, lpStringW);

    FreeProducedString (lpStringW);

    return iResult;
}

#else

//
// Unicode stub when this code is build ANSI
//

STDAPI_(int) AddMRUStringW(HANDLE hMRU, LPCWSTR szString)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return -1;
}

#endif


/* Remove a string from an MRU list.
 */
STDAPI_(int) DelMRUString(HANDLE hMRU, int nItem)
{
    BOOL bRet = FALSE;
    LPTSTR lpTemp;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (pMRU)
    {
        //
        // Make sure the index value is within the length of
        // the string so we don't pick up some random value.
        //
        if (!InRange(nItem, 0, pMRU->uMax) || nItem >= lstrlen(pMRU->cOrder))
            return FALSE;

        // Be easy -- just remove the entry from the cOrder list
        lpTemp = &pMRU->cOrder[nItem];
        if (lpTemp)
        {
            int iSlot = *lpTemp - BASE_CHAR;
            if (iSlot >= 0 && iSlot < MAX_CHAR - BASE_CHAR)
                Str_SetPtr(&NTHSTRING(pMRU, iSlot), NULL);
            lstrcpy(lpTemp, lpTemp+1);

            if (!(pMRU->fFlags & MRU_CACHEWRITE))
            {
                RegSetValueEx(pMRU->hKey, c_szMRU, 0L, REG_SZ, (CONST BYTE *)pMRU->cOrder,
                              sizeof(TCHAR) * (lstrlen(pMRU->cOrder) + 1));
                pMRU->fFlags &= ~MRU_ORDERDIRTY;
            }
            else
            {
                pMRU->fFlags |= MRU_ORDERDIRTY;
            }

            bRet = TRUE;
        }
    }

    return bRet;
}


//----------------------------------------------------------------------------
// Add data to an MRU list.
STDAPI_(int) AddMRUData(HANDLE hMRU, const void *lpData, UINT cbData)
{
    TCHAR cFirst;
    int iSlot = -1;
    LPTSTR lpTemp;
    LPBYTE *ppData;
    int i;
    UINT uMax;
    MRUCMPDATAPROC lpfnCompare;
    PMRUDATA pMRU = (PMRUDATA)hMRU;
    BOOL fShouldWrite;

#ifdef DEBUG
    DWORD dwStart = GetTickCount();
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (hMRU == NULL)
        return(-1);     // Error

    fShouldWrite = !(pMRU->fFlags & MRU_CACHEWRITE);

    uMax = pMRU->uMax;
    lpfnCompare = (MRUCMPDATAPROC)pMRU->lpfnCompare;

    // Check if the data already exists in the list.
    for (i=0, ppData=&NTHDATA(pMRU, 0); (UINT)i<uMax; ++i, ++ppData)
    {
        if (*ppData && MRUIsSameData(pMRU, *ppData, lpData, cbData))
        {
            // found it, so don't do the write out
            cFirst = i + BASE_CHAR;
            iSlot = i;
            goto FoundEntry;
        }
    }

    //
    // When created "lazy", we are not supposed to add a new item.
    //
    if (pMRU->fFlags & MRU_LAZY)
    {
        ASSERT(0);
        return -1;
    }

    // Attempt to find an unused entry.  Count up the used entries at the
    // same time.
    for (i=0, ppData=&NTHDATA(pMRU, 0); ; ++i, ++ppData)
    {
        if ((UINT)i >= uMax)
            // If we got to the end of the list.
        {
            // use the entry at the end of the cOrder list
            cFirst = pMRU->cOrder[uMax-1];
            ppData = &NTHDATA(pMRU, cFirst-BASE_CHAR);
            break;
        }

        if (!*ppData)
            // If the entry is not used.
        {
            cFirst = i+BASE_CHAR;
            break;
        }
    }

    *ppData = ReAlloc(*ppData, cbData+sizeof(DWORD));
    if (*ppData)
    {
        TCHAR szTemp[2];

        *((LPDWORD)(*ppData)) = cbData;
        hmemcpy(DATAPDATA(*ppData), lpData, cbData);

        iSlot = (int)(cFirst-BASE_CHAR);

        szTemp[0] = cFirst;
        szTemp[1] = TEXT('\0');

        RegSetValueEx(pMRU->hKey, szTemp, 0L, REG_BINARY, (LPVOID)lpData, cbData);
        fShouldWrite = TRUE;
    }
    else
    {
        // Since iSlot == -1, we will remove the reference to cFirst
        // below.
    }

FoundEntry:
    // Remove any previous reference to cFirst.
    lpTemp = StrChr(pMRU->cOrder, cFirst);
    if (lpTemp)
    {
        lstrcpy(lpTemp, lpTemp+1);
    }

    if (iSlot != -1)
    {
        // shift everything over and put cFirst at the front
        hmemcpy(pMRU->cOrder+1, pMRU->cOrder, pMRU->uMax*sizeof(TCHAR));
        pMRU->cOrder[0] = cFirst;
    }

    if (fShouldWrite)
    {
        RegSetValueEx(pMRU->hKey, c_szMRU, 0L, REG_SZ, (CONST BYTE *)pMRU->cOrder,
            sizeof(TCHAR) * (lstrlen(pMRU->cOrder) + 1));
        pMRU->fFlags &= ~MRU_ORDERDIRTY;
    } else
        pMRU->fFlags |= MRU_ORDERDIRTY;

#ifdef DEBUG
    // DebugMsg(DM_TRACE, TEXT("AddMRU: %d msec"), LOWORD(GetTickCount()-dwStart));
#endif
    return(iSlot);
}


//----------------------------------------------------------------------------
// Find data in an MRU list.
// Returns the slot number.
STDAPI_(int) FindMRUData(HANDLE hMRU, const void *lpData, UINT cbData, LPINT lpiSlot)
{
    TCHAR cFirst;
    int iSlot = -1;
    LPTSTR lpTemp;
    LPBYTE *ppData;
    int i;
    UINT uMax;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

#ifdef DEBUG
    DWORD dwStart = GetTickCount();
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (hMRU == NULL)
        return(-1); // Error state.

    // Can't call this API when it's created lazily.
    if (pMRU->fFlags & MRU_LAZY)
    {
        ASSERT(0);
        return -1;
    }

    uMax = pMRU->uMax;

    /* Find the item in the list.
    */
    for (i=0, ppData=&NTHDATA(pMRU, 0); (UINT)i<uMax; ++i, ++ppData)
    {
        if (!*ppData)
            continue;

        if (MRUIsSameData(pMRU, *ppData, lpData, cbData))
        {
            // So i now has the slot number in it.
            if (lpiSlot != NULL)
                *lpiSlot = i;

            // Now convert the slot number into an index number
            cFirst = i + BASE_CHAR;
            lpTemp = StrChr(pMRU->cOrder, cFirst);
            ASSERT(lpTemp);
            return((lpTemp == NULL)? -1 : (int)(lpTemp - (LPTSTR)pMRU->cOrder));
        }
    }

    return -1;
}


/* Find a string in an MRU list.
 */
STDAPI_(int) FindMRUString(HANDLE hMRU, LPCTSTR szString, LPINT lpiSlot)
{
    /* The extra +1 is so that the list is NULL terminated.
    */
    TCHAR cFirst;
    int iSlot = -1;
    LPTSTR lpTemp;
    LPTSTR *pTemp;
    int i;
    UINT uMax;
    MRUCMPPROC lpfnCompare;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

#ifdef DEBUG
    DWORD dwStart = GetTickCount();
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (hMRU == NULL)
        return(-1); // Error state.

    uMax = pMRU->uMax;
    lpfnCompare = (MRUCMPPROC)pMRU->lpfnCompare;

    /* Find the item in the list.
    */
    for (i=0, pTemp=&NTHSTRING(pMRU, 0); (UINT)i<uMax; ++i, ++pTemp)
    {
        if (*pTemp)
        {
            int iResult;

#ifdef UNICODE
            if (pMRU->fFlags & MRU_ANSI)
            {
                LPSTR lpStringA, lpTempA;

                lpStringA = ProduceAFromW (CP_ACP, szString);
                lpTempA = ProduceAFromW (CP_ACP, (LPWSTR)*pTemp);

                iResult = (*lpfnCompare)((const void *)lpStringA, (const void *)lpTempA);

                FreeProducedString (lpStringA);
                FreeProducedString (lpTempA);
            }
            else
#endif
            {
                iResult = (*lpfnCompare)((CONST VOID *)szString, (CONST VOID *)*pTemp);
            }

            if (!iResult)
            {
                // So i now has the slot number in it.
                if (lpiSlot != NULL)
                    *lpiSlot = i;

                // Now convert the slot number into an index number
                cFirst = i + BASE_CHAR;
                lpTemp = StrChr(pMRU->cOrder, cFirst);
                return((lpTemp == NULL)? -1 : (int)(lpTemp - (LPTSTR)pMRU->cOrder));
            }
        }
    }

    return(-1);
}


#ifdef UNICODE
//
// ANSI thunk
//

int WINAPI FindMRUStringA(HANDLE hMRU, LPCSTR szString, LPINT lpiSlot)
{
    LPWSTR lpStringW;
    INT    iResult;

    lpStringW = ProduceWFromA(CP_ACP, szString);

    iResult = FindMRUString(hMRU, lpStringW, lpiSlot);

    FreeProducedString (lpStringW);

    return iResult;
}

#else

//
// Unicode stub when build ANSI
//

int WINAPI FindMRUStringW(HANDLE hMRU, LPCWSTR szString, LPINT lpiSlot)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return -1;
}

#endif

/* If lpszString is NULL, then this returns the number of MRU items or less than
 * 0 on error.
 * if nItem < 0, we'll return the number of items currently in the MRU.
 * Otherwise, fill in as much of the buffer as possible (uLen includes the
 * terminating NULL) and return the actual length of the string (including the
 * terminating NULL) or less than 0 on error.
 */
STDAPI_(int) EnumMRUList(HANDLE hMRU, int nItem, LPVOID lpData, UINT uLen)
{
    PMRUDATA pMRU = (PMRUDATA)hMRU;
    int nItems = -1;
    LPTSTR pTemp;
    LPBYTE pData;

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (pMRU)
    {
        nItems = lstrlen(pMRU->cOrder);

        if (nItem < 0 || !lpData)
            return nItems;

        if (nItem < nItems)
        {
            if (pMRU->fFlags & MRU_BINARY)
            {
                pData = NTHDATA(pMRU, pMRU->cOrder[nItem]-BASE_CHAR);
                if (!pData)
                    return -1;

                uLen = min((UINT)DATASIZE(pData), uLen);
                hmemcpy(lpData, DATAPDATA(pData), uLen);

                nItems = uLen;

            }
            else
            {
                pTemp = NTHSTRING(pMRU, pMRU->cOrder[nItem]-BASE_CHAR);
                if (!pTemp)
                    return -1;

                lstrcpyn((LPTSTR)lpData, pTemp, uLen);

                nItems = lstrlen(pTemp);
            }
        }
        else  // revert to error condition
            nItems = -1;
    }

    return nItems;
}


#ifdef UNICODE

STDAPI_(int) EnumMRUListA(HANDLE hMRU, int nItem, LPVOID lpData, UINT uLen)
{
    int iResult = -1;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (pMRU)
    {
        LPVOID lpDataW;
        BOOL bAllocatedMemory = FALSE;

        //
        //  we need a temp buffer if the data is a string.
        //  but if it is binary, then we trust the callers buffer.
        //
        if (!(pMRU->fFlags & MRU_BINARY) && uLen && lpData)
        {
            lpDataW = LocalAlloc(LPTR, uLen * sizeof(TCHAR));

            if (!lpDataW)
                return -1;

            bAllocatedMemory = TRUE;
        }
        else
            lpDataW = lpData;

        //  call the real thing
        iResult = EnumMRUList(hMRU, nItem, lpDataW, uLen);

        //
        //  if the buffer was a string that we allocated
        //  then we need to thunk the string into the callers buffer
        //
        if (!(pMRU->fFlags & MRU_BINARY) && lpData && uLen && (iResult != -1))
        {
            WideCharToMultiByte(CP_ACP, 0, (LPWSTR)lpDataW, -1,
                (LPSTR)lpData, uLen, NULL, NULL);
        }

        if (bAllocatedMemory)
            LocalFree(lpDataW);
    }

    return iResult;
}

#else

STDAPI_(int) EnumMRUListW(HANDLE hMRU, int nItem, LPVOID lpData, UINT uLen)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return 0;
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\os.c ===
#include "ctlspriv.h"
#include <krnlcmn.h>

//========== OS Dependent Code =============================================

/*----------------------------------------------------------
Purpose: This export exists so SHDOCVW can call Kernel32's GetProcessDword,
         which is only exported on Win95.  In addition, it is exported
         by ordinal only.  Since GetProcAddress fails for ordinals
         to KERNEL32 directly, we have SHELL32 implicitly link to
         this export and SHDOCVW calls thru this private API.

Returns: 0 on failure
Cond:    --
*/

DWORD
SHGetProcessDword(
    IN DWORD idProcess,
    IN LONG  iIndex)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\notify.c ===
#include "ctlspriv.h"

#ifdef NEED_WOWGETNOTIFYSIZE_HELPER

#include <shsemip.h>                // SEN_* notifications
#include <commdlg.h>                // CDN_* notifications

// Miscellaneous hackery needed in order to include shlobjp.h
#define CCONTROLINFO     OAIDL_CONTROLINFO
#define LPCCONTROLINFO   LPOAIDL_CONTROLINFO
#include <shlobj.h>
#include <shlobjp.h>                // NMVIEWFOLDER structure
#undef CCONTROLINFO
#undef LPCCONTROLINFO

//
//  Helper function for WOW on NT.
//
//  WOW needs to know the size of the notify structure associated with a
//  notification.  If a 32-bit window has been subclassed by a 16-bit app,
//  WOW needs to copy the notify structure into 16-bit space, and then when
//  the 16-bit guy does a CallWindowProc(), they have to copy it back into
//  32-bit space.  Without the size information, you fault on the
//  32-bit side because the notify structure is incomplete.
//
//  Some notifications have multiple structures associated with them, in
//  which case you should return the largest possible valid structure.
//
STDAPI_(UINT) WOWGetNotifySize(UINT code)
{
    switch (code) {

    // Generic comctl32 notifications
    case NM_OUTOFMEMORY:        return sizeof(NMHDR);   // not used

    case NM_CLICK:              return max(max(
                        sizeof(NMHDR),       // tab, treeview
                        sizeof(NMCLICK)),    // toolbar, statusbar
                        sizeof(NMITEMACTIVATE)); // listview

    case NM_DBLCLK:             return max(max(
                        sizeof(NMHDR),       // tab, treeview
                        sizeof(NMCLICK)),    // toolbar, statusbar
                        sizeof(NMITEMACTIVATE)); // listview


    case NM_RETURN:             return sizeof(NMHDR);

    case NM_RCLICK:             return max(max(
                        sizeof(NMHDR),       // header, listview report mode, treeview
                        sizeof(NMCLICK)),    // toolbar, statusbar
                        sizeof(NMITEMACTIVATE)); // listview icon mode

    case NM_RDBLCLK:            return max(max(
                        sizeof(NMHDR),       // treeview
                        sizeof(NMCLICK)),    // toolbar, statusbar
                        sizeof(NMITEMACTIVATE)); // listview

    case NM_SETFOCUS:           return sizeof(NMHDR);
    case NM_KILLFOCUS:          return sizeof(NMHDR);
    case NM_STARTWAIT:          return sizeof(NMHDR);      // not used
    case NM_ENDWAIT:            return sizeof(NMHDR);      // not used
    case NM_BTNCLK:             return sizeof(NMHDR);      // not used
    case NM_CUSTOMDRAW:         return sizeof(NMCUSTOMDRAW);
    case NM_HOVER:              return sizeof(NMHDR);
    case NM_NCHITTEST:          return sizeof(NMMOUSE);
    case NM_KEYDOWN:            return sizeof(NMKEY);
    case NM_RELEASEDCAPTURE:    return sizeof(NMHDR);
    case NM_SETCURSOR:          return sizeof(NMMOUSE);
    case NM_CHAR:               return sizeof(NMCHAR);
    case NM_TOOLTIPSCREATED:    return sizeof(NMTOOLTIPSCREATED);
    case NM_LDOWN:              return sizeof(NMCLICK);
    case NM_RDOWN:              return sizeof(NMCLICK);     // not used

    // Listview notifications
    case LVN_ITEMCHANGING:      return sizeof(NMLISTVIEW);
    case LVN_ITEMCHANGED:       return sizeof(NMLISTVIEW);
    case LVN_INSERTITEM:        return sizeof(NMLISTVIEW);
    case LVN_DELETEITEM:        return sizeof(NMLISTVIEW);
    case LVN_DELETEALLITEMS:    return sizeof(NMLISTVIEW);
    case LVN_BEGINLABELEDITA:   return sizeof(NMLVDISPINFOA);
    case LVN_BEGINLABELEDITW:   return sizeof(NMLVDISPINFOW);
    case LVN_ENDLABELEDITA:     return sizeof(NMLVDISPINFOA);
    case LVN_ENDLABELEDITW:     return sizeof(NMLVDISPINFOW);
    case LVN_COLUMNCLICK:       return sizeof(NMLISTVIEW);
    case LVN_BEGINDRAG:         return sizeof(NMITEMACTIVATE);
    case LVN_BEGINRDRAG:        return sizeof(NMITEMACTIVATE); // not used
    case LVN_ENDDRAG:           return sizeof(NMITEMACTIVATE); // not used
    case LVN_ENDRDRAG:          return sizeof(NMITEMACTIVATE); // not used
    case LVN_ODCACHEHINT:       return sizeof(NMLVCACHEHINT);
    case LVN_ODFINDITEMA:       return sizeof(NMLVFINDITEMA);
    case LVN_ODFINDITEMW:       return sizeof(NMLVFINDITEMW);
    case LVN_ITEMACTIVATE:      return sizeof(NMITEMACTIVATE);
    case LVN_ODSTATECHANGED:    return sizeof(NMLVODSTATECHANGE);
//  case LVN_PEN:               // Pen Windows slackers
    case LVN_HOTTRACK:          return sizeof(NMLISTVIEW);
    case LVN_GETDISPINFOA:      return sizeof(NMLVDISPINFOA);
    case LVN_GETDISPINFOW:      return sizeof(NMLVDISPINFOW);
    case LVN_SETDISPINFOA:      return sizeof(NMLVDISPINFOA);
    case LVN_SETDISPINFOW:      return sizeof(NMLVDISPINFOW);
    case LVN_KEYDOWN:           return sizeof(NMLVKEYDOWN);
    case LVN_MARQUEEBEGIN:      return sizeof(NMITEMACTIVATE);
    case LVN_GETINFOTIPA:       return sizeof(NMLVGETINFOTIPA);
    case LVN_GETINFOTIPW:       return sizeof(NMLVGETINFOTIPW);
    case LVN_GETEMPTYTEXTA:     return sizeof(NMLVDISPINFOA);
    case LVN_GETEMPTYTEXTW:     return sizeof(NMLVDISPINFOW);
    case LVN_INCREMENTALSEARCHA:return sizeof(NMLVFINDITEMA);
    case LVN_INCREMENTALSEARCHW:return sizeof(NMLVFINDITEMW);

    // Property sheet notifications
    case PSN_SETACTIVE:         return sizeof(PSHNOTIFY);
    case PSN_KILLACTIVE:        return sizeof(PSHNOTIFY);
    case PSN_APPLY:             return sizeof(PSHNOTIFY);
    case PSN_RESET:             return sizeof(PSHNOTIFY);
    case PSN_HASHELP:           return sizeof(PSHNOTIFY);   // not used
    case PSN_HELP:              return sizeof(PSHNOTIFY);
    case PSN_WIZBACK:           return sizeof(PSHNOTIFY);
    case PSN_WIZNEXT:           return sizeof(PSHNOTIFY);
    case PSN_WIZFINISH:         return sizeof(PSHNOTIFY);
    case PSN_QUERYCANCEL:       return sizeof(PSHNOTIFY);
    case PSN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
    case PSN_LASTCHANCEAPPLY:   return sizeof(PSHNOTIFY);
    case PSN_TRANSLATEACCELERATOR:
                                return sizeof(PSHNOTIFY);
    case PSN_QUERYINITIALFOCUS: return sizeof(PSHNOTIFY);

    // Header notifications
    case HDN_ITEMCHANGINGA:     return sizeof(NMHEADERA);
    case HDN_ITEMCHANGINGW:     return sizeof(NMHEADERW);
    case HDN_ITEMCHANGEDA:      return sizeof(NMHEADERA);
    case HDN_ITEMCHANGEDW:      return sizeof(NMHEADERW);
    case HDN_ITEMCLICKA:        return sizeof(NMHEADERA);
    case HDN_ITEMCLICKW:        return sizeof(NMHEADERW);
    case HDN_ITEMDBLCLICKA:     return sizeof(NMHEADERA);
    case HDN_ITEMDBLCLICKW:     return sizeof(NMHEADERW);
    case HDN_DIVIDERDBLCLICKA:  return sizeof(NMHEADERA);
    case HDN_DIVIDERDBLCLICKW:  return sizeof(NMHEADERW);
    case HDN_BEGINTRACKA:       return sizeof(NMHEADERA);
    case HDN_BEGINTRACKW:       return sizeof(NMHEADERW);
    case HDN_ENDTRACKA:         return sizeof(NMHEADERA);
    case HDN_ENDTRACKW:         return sizeof(NMHEADERW);
    case HDN_TRACKA:            return sizeof(NMHEADERA);
    case HDN_TRACKW:            return sizeof(NMHEADERW);
    case HDN_GETDISPINFOA:      return sizeof(NMHDDISPINFOA);
    case HDN_GETDISPINFOW:      return sizeof(NMHDDISPINFOW);
    case HDN_BEGINDRAG:         return sizeof(NMHEADER); // No strings
    case HDN_ENDDRAG:           return sizeof(NMHEADER); // No strings
    case HDN_FILTERCHANGE:      return sizeof(NMHEADER); // No strings
    case HDN_FILTERBTNCLICK:    return sizeof(NMHDFILTERBTNCLICK);

    // Treeview notifications
    case TVN_SELCHANGINGA:      return sizeof(NMTREEVIEWA);
    case TVN_SELCHANGINGW:      return sizeof(NMTREEVIEWW);
    case TVN_SELCHANGEDA:       return sizeof(NMTREEVIEWA);
    case TVN_SELCHANGEDW:       return sizeof(NMTREEVIEWW);
    case TVN_GETDISPINFOA:      return sizeof(NMTVDISPINFOA);
    case TVN_GETDISPINFOW:      return sizeof(NMTVDISPINFOW);
    case TVN_SETDISPINFOA:      return sizeof(NMTVDISPINFOA);
    case TVN_SETDISPINFOW:      return sizeof(NMTVDISPINFOW);
    case TVN_ITEMEXPANDINGA:    return sizeof(NMTREEVIEWA);
    case TVN_ITEMEXPANDINGW:    return sizeof(NMTREEVIEWW);
    case TVN_ITEMEXPANDEDA:     return sizeof(NMTREEVIEWA);
    case TVN_ITEMEXPANDEDW:     return sizeof(NMTREEVIEWW);
    case TVN_BEGINDRAGA:        return sizeof(NMTREEVIEWA);
    case TVN_BEGINDRAGW:        return sizeof(NMTREEVIEWW);
    case TVN_BEGINRDRAGA:       return sizeof(NMTREEVIEWA);
    case TVN_BEGINRDRAGW:       return sizeof(NMTREEVIEWW);
    case TVN_DELETEITEMA:       return sizeof(NMTREEVIEWA);
    case TVN_DELETEITEMW:       return sizeof(NMTREEVIEWW);
    case TVN_BEGINLABELEDITA:   return sizeof(NMTVDISPINFOA);
    case TVN_BEGINLABELEDITW:   return sizeof(NMTVDISPINFOW);
    case TVN_ENDLABELEDITA:     return sizeof(NMTVDISPINFOA);
    case TVN_ENDLABELEDITW:     return sizeof(NMTVDISPINFOW);
    case TVN_KEYDOWN:           return sizeof(NMTVKEYDOWN);
    case TVN_GETINFOTIPA:       return sizeof(NMTVGETINFOTIPA);
    case TVN_GETINFOTIPW:       return sizeof(NMTVGETINFOTIPW);
    case TVN_SINGLEEXPAND:      return sizeof(NMTREEVIEW); // No strings

    // Rundll32 notifications
    case RDN_TASKINFO:          return sizeof(RUNDLL_NOTIFY);

    // Tooltip notifications
    case TTN_GETDISPINFOA:      return sizeof(NMTTDISPINFOA);
    case TTN_GETDISPINFOW:      return sizeof(NMTTDISPINFOW);
    case TTN_SHOW:              return sizeof(NMTTSHOWINFO);
    case TTN_POP:               return sizeof(NMHDR);

    // Tab control notifications

    // WE ARE SUCH HORRIBLE SLACKERS!
    //
    //  Even though commctrl.h says that the shell reserved range is from
    //  -580 to -589, shsemip.h defines SEN_FIRST as -550, which conflicts
    //  with TCN_KEYDOWN, so now TCN_KEYDOWN and SEN_DDEEXECUTE have the
    //  same value.

    case TCN_KEYDOWN:           return max(sizeof(NMTCKEYDOWN),
                                           sizeof(NMVIEWFOLDERW));
    case TCN_SELCHANGE:         return sizeof(NMHDR);
    case TCN_SELCHANGING:       return sizeof(NMHDR);
    case TCN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
    case TCN_FOCUSCHANGE:       return sizeof(NMHDR);

    // Comdlg32 notifications
    case CDN_INITDONE:          return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_SELCHANGE:         return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_FOLDERCHANGE:      return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_SHAREVIOLATION:    return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_HELP:              return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_FILEOK:            return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_TYPECHANGE:        return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_INCLUDEITEM:       return max(sizeof(OFNOTIFYEXA),
                                           sizeof(OFNOTIFYEXW));

    // Toolbar notifications
    case TBN_GETBUTTONINFOA:    return sizeof(NMTOOLBARA);
    case TBN_GETBUTTONINFOW:    return sizeof(NMTOOLBARW);
    case TBN_BEGINDRAG:         return sizeof(NMTOOLBAR); // No strings
    case TBN_ENDDRAG:           return sizeof(NMTOOLBAR); // No strings
    case TBN_BEGINADJUST:       return sizeof(NMHDR);
    case TBN_ENDADJUST:         return sizeof(NMHDR);
    case TBN_RESET:             return sizeof(NMTBCUSTOMIZEDLG);
    case TBN_QUERYINSERT:       return sizeof(NMTOOLBAR); // No strings
    case TBN_QUERYDELETE:       return sizeof(NMTOOLBAR); // No strings
    case TBN_TOOLBARCHANGE:     return sizeof(NMHDR);
    case TBN_CUSTHELP:          return sizeof(NMHDR);
    case TBN_DROPDOWN:          return sizeof(NMTOOLBAR); // No strings
    case TBN_CLOSEUP:           return sizeof(NMHDR);     // not used
    case TBN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
    case TBN_HOTITEMCHANGE:     return sizeof(NMTBHOTITEM);
    case TBN_DRAGOUT:           return sizeof(NMTOOLBAR); // No strings
    case TBN_DELETINGBUTTON:    return sizeof(NMTOOLBAR); // No strings
    case TBN_GETDISPINFOA:      return sizeof(NMTBDISPINFOA);
    case TBN_GETDISPINFOW:      return sizeof(NMTBDISPINFOW);
    case TBN_GETINFOTIPA:       return sizeof(NMTBGETINFOTIPA);
    case TBN_GETINFOTIPW:       return sizeof(NMTBGETINFOTIPW);
    case TBN_RESTORE:           return sizeof(NMTBRESTORE);

    // WE ARE SUCH HORRIBLE SLACKERS!
    //
    //  The TBN_FIRST/TBN_LAST range reserves 20 notifications for toolbar,
    //  and we overflowed that limit, so now UDN_DELTAPOS and
    //  TBN_SAVE have the same value.

    case TBN_SAVE:              return max(sizeof(NMTBSAVE),
                                           sizeof(NMUPDOWN));

    case TBN_INITCUSTOMIZE:     return sizeof(NMTBCUSTOMIZEDLG);
    case TBN_WRAPHOTITEM:       return sizeof(NMTBWRAPHOTITEM);
    case TBN_DUPACCELERATOR:    return sizeof(NMTBDUPACCELERATOR);
    case TBN_WRAPACCELERATOR:   return sizeof(NMTBWRAPACCELERATOR);
    case TBN_DRAGOVER:          return sizeof(NMTBHOTITEM);
    case TBN_MAPACCELERATOR:    return sizeof(NMCHAR);

    // Up-down control
#if 0 // see comment at TBN_SAVE
    case UDN_DELTAPOS:          return sizeof(NMUPDOWN);
#endif

    // Monthcal control
    case MCN_SELCHANGE:         return sizeof(NMSELCHANGE);
    case MCN_GETDAYSTATE:       return sizeof(NMDAYSTATE);
    case MCN_SELECT:            return sizeof(NMSELECT);

    // Date/time picker control
    case DTN_DATETIMECHANGE:    return sizeof(NMDATETIMECHANGE);
    case DTN_USERSTRINGA:       return sizeof(NMDATETIMESTRINGA);
    case DTN_USERSTRINGW:       return sizeof(NMDATETIMESTRINGW);
    case DTN_WMKEYDOWNA:        return sizeof(NMDATETIMEWMKEYDOWNA);
    case DTN_WMKEYDOWNW:        return sizeof(NMDATETIMEWMKEYDOWNW);
    case DTN_FORMATA:           return sizeof(NMDATETIMEFORMATA);
    case DTN_FORMATW:           return sizeof(NMDATETIMEFORMATW);
    case DTN_FORMATQUERYA:      return sizeof(NMDATETIMEFORMATQUERYA);
    case DTN_FORMATQUERYW:      return sizeof(NMDATETIMEFORMATQUERYW);
    case DTN_DROPDOWN:          return sizeof(NMHDR);
    case DTN_CLOSEUP:           return sizeof(NMHDR);

    // Comboex notifications
    case CBEN_GETDISPINFOA:     return sizeof(NMCOMBOBOXEXA);
    case CBEN_GETDISPINFOW:     return sizeof(NMCOMBOBOXEXW);
    case CBEN_INSERTITEM:       return sizeof(NMCOMBOBOXEX); // Random character set
    case CBEN_DELETEITEM:       return sizeof(NMCOMBOBOXEX); // No strings
    case CBEN_ITEMCHANGED:      return sizeof(NMCOMBOBOXEX); // Not used
    case CBEN_BEGINEDIT:        return sizeof(NMHDR);
    case CBEN_ENDEDITA:         return sizeof(NMCBEENDEDITA);
    case CBEN_ENDEDITW:         return sizeof(NMCBEENDEDITW);
    case CBEN_DRAGBEGINA:       return sizeof(NMCBEDRAGBEGINA);
    case CBEN_DRAGBEGINW:       return sizeof(NMCBEDRAGBEGINW);

    // Rebar notifications
    case RBN_HEIGHTCHANGE:      return sizeof(NMHDR);
    case RBN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
    case RBN_LAYOUTCHANGED:     return sizeof(NMHDR);
    case RBN_AUTOSIZE:          return sizeof(NMRBAUTOSIZE);
    case RBN_BEGINDRAG:         return sizeof(NMREBAR);
    case RBN_DELETINGBAND:      return sizeof(NMREBAR);
    case RBN_DELETEDBAND:       return sizeof(NMREBAR);
    case RBN_CHILDSIZE:         return sizeof(NMREBARCHILDSIZE);

    // IP address control notification
    case IPN_FIELDCHANGED:      return sizeof(NMIPADDRESS);

    // Status bar notifications
    case SBN_SIMPLEMODECHANGE:  return sizeof(NMHDR);

    // Pager control notifications
    case PGN_SCROLL:            return sizeof(NMPGSCROLL);
    case PGN_CALCSIZE:          return sizeof(NMPGCALCSIZE);

    default:
        break;
    }

    //
    //  Categories of notifications we explicitly know nothing about.
    //

    if (code >= WMN_LAST && code <= WMN_FIRST) { // Internet Mail and News
        return 0;
    }

    if ((int)code >= 0) { // Application-specific notifications
        return 0;
    }

    //
    //  IF THIS ASSERT FIRES, YOU MUST FIX IT OR YOU WILL BREAK WOW!
    //
    AssertMsg(0, TEXT("Notification code %d must be added to WOWGetNotifySize"));
    return 0;
}

#endif // NEED_WOWGETNOTIFYSIZE_HELPER

LRESULT WINAPI SendNotifyEx(HWND hwndTo, HWND hwndFrom, int code, NMHDR* pnmhdr, BOOL bUnicode)
{
    CCONTROLINFO ci;

    if (!hwndTo) {
        if (IsWindow(hwndFrom))
            hwndTo = GetParent(hwndFrom);
        if (!hwndTo)
            return 0;
    }


    ci.hwndParent = hwndTo;
    ci.hwnd = hwndFrom;
    ci.bUnicode = BOOLIFY(bUnicode);
    ci.uiCodePage = CP_ACP;

    return CCSendNotify(&ci, code, pnmhdr);
}


void StringBufferAtoW(UINT uiCodePage, LPVOID pvOrgPtr, DWORD dwOrgSize, CHAR **ppszText)
{
    if (pvOrgPtr == *ppszText)
    {
        // the pointer has not been changed by the callback...
        // must convert from A to W in-place

        if (dwOrgSize)
        {
            LPWSTR pszW = ProduceWFromA(uiCodePage, *ppszText);
            if (pszW)
            {
                lstrcpynW((WCHAR *)(*ppszText), pszW, dwOrgSize);   // this becomes a W buffer
                FreeProducedString(pszW);
            }
        }
    }
    else
    {
        // the pointer has been changed out from underneath us, copy
        // unicode back into the original buffer.

        ConvertAToWN(uiCodePage, pvOrgPtr, dwOrgSize, *ppszText, -1);
        *ppszText = pvOrgPtr;
    }
}

typedef struct tagTHUNKSTATE {
    LPVOID ts_pvThunk1;
    LPVOID ts_pvThunk2;
    DWORD ts_dwThunkSize;
} THUNKSTATE;

//
//  InOutWtoA/InOutAtoW is for thunking INOUT string parameters.
//
//  INOUT parameters always create a hassle.
//
// We need to save both the original ANSI and the
// original UNICODE strings, so that if the app doesn't
// change the ANSI string, we leave the original UNICODE
// string alone.  That way, UNICODE item names don't get
// obliterated by the thunk.
//
// The original buffer is saved in pvThunk1.
// We allocate two ANSI buffers.
// pvThunk2 contains the original ANSIfied string.
// pvThunk2+cchTextMax is the buffer we pass to the app.
// On the way back, we compare pvThunk2 with pvThunk2+cchTextMax.
// If they are different, then we unthunk the string; otherwise,
// we leave the original UNICODE buffer alone.

BOOL InOutWtoA(CCONTROLINFO *pci, THUNKSTATE *pts, LPWSTR *ppsz, DWORD cchTextMax)
{
    pts->ts_pvThunk1 = *ppsz;               // Save original buffer
    pts->ts_dwThunkSize = cchTextMax;

    if (!IsFlagPtr(pts->ts_pvThunk1))
    {
        pts->ts_pvThunk2 = LocalAlloc(LPTR, cchTextMax * 2 * sizeof(char));
        if (!ConvertWToAN(pci->uiCodePage, (LPSTR)pts->ts_pvThunk2, pts->ts_dwThunkSize, (LPWSTR)pts->ts_pvThunk1, -1))
        {
            LocalFree(pts->ts_pvThunk2);
            return 0;
        }
        *ppsz = (LPWSTR)((LPSTR)pts->ts_pvThunk2 + cchTextMax);
        lstrcpyA((LPSTR)*ppsz, pts->ts_pvThunk2);
    }
    return TRUE;
}

void InOutAtoW(CCONTROLINFO *pci, THUNKSTATE *pts, LPSTR *ppsz)
{
    if (!IsFlagPtr(pts->ts_pvThunk1))
    {
        if (!IsFlagPtr(*ppsz) &&
            lstrcmpA(pts->ts_pvThunk2, (LPSTR)*ppsz) != 0)
            StringBufferAtoW(pci->uiCodePage, pts->ts_pvThunk1, pts->ts_dwThunkSize, ppsz);
        LocalFree(pts->ts_pvThunk2);
    }
    *ppsz = pts->ts_pvThunk1;
}

LRESULT WINAPI CCSendNotify(CCONTROLINFO * pci, int code, LPNMHDR pnmhdr)
{
    NMHDR nmhdr;
    LONG_PTR id;
    THUNKSTATE ts = { 0 };
    #define pvThunk1 ts.ts_pvThunk1
    #define pvThunk2 ts.ts_pvThunk2
    #define dwThunkSize ts.ts_dwThunkSize
    LRESULT lRet;
    BOOL  bSet = FALSE;

    HWND hwndParent = pci->hwndParent;
    DWORD dwParentPid;

    // -1 means Requery on each notify
    if ( hwndParent == (HWND)-1 )
    {
        hwndParent = GetParent(pci->hwnd);
    }

    // unlikely but it can technically happen -- avoid the rips
    if ( hwndParent == NULL )
        return 0;

    //
    // If pci->hwnd is -1, then a WM_NOTIFY is being forwared
    // from one control to a parent.  EG:  Tooltips sent
    // a WM_NOTIFY to toolbar, and toolbar is forwarding it
    // to the real parent window.
    //

    if (pci->hwnd != (HWND) -1) {

        //
        // If this is a child then get its ID.  We need to go out of our way to
        // avoid calling GetDlgCtrlID on toplevel windows since it will return
        // a pseudo-random number (those of you who know what this number is
        // keep quiet).  Anyway it's kinda hard to figure this out in Windows
        // because of the following:
        //
        //  - a window can SetWindowLong(GWL_STYLE, WS_CHILD) but this only
        //    does about half the work - hence checking the style is out.
        //  - GetParent will return your OWNER if you are toplevel.
        //  - there is no GetWindow(...GW_HWNDPARENT) to save us.
        //
        // Hence we are stuck with calling GetParent and then checking to see
        // if it lied and gave us the owner instead.  Yuck.
        //
        id = 0;
        if (pci->hwnd) {
            HWND hwndParent = GetParent(pci->hwnd);

            if (hwndParent && (hwndParent != GetWindow(pci->hwnd, GW_OWNER))) {
                id = GetDlgCtrlID(pci->hwnd);
            }
        }

        if (!pnmhdr)
            pnmhdr = &nmhdr;

        pnmhdr->hwndFrom = pci->hwnd;
        pnmhdr->idFrom = id;
        pnmhdr->code = code;
    } else {

        id = pnmhdr->idFrom;
        code = pnmhdr->code;
    }


    // OLE in its massively componentized world sometimes creates
    // a control whose parent belongs to another process.  (For example,
    // when there is a local server embedding.)  WM_NOTIFY
    // messages can't cross process boundaries, so stop the message
    // from going there lest we fault the recipient.
    if (!GetWindowThreadProcessId(hwndParent, &dwParentPid) ||
        dwParentPid != GetCurrentProcessId())
    {
        TraceMsg(TF_WARNING, "nf: Not sending WM_NOTIFY %08x across processes", code);
        return 0;
    }

#ifdef NEED_WOWGETNOTIFYSIZE_HELPER
    ASSERT(code >= 0 || WOWGetNotifySize(code));
#endif // NEED_WOWGETNOTIFYSIZE_HELPER

    /*
     * All the thunking for Notify Messages happens here
     */
    if (!pci->bUnicode) {
        BOOL fThunked = TRUE;
        switch( code ) {
        case LVN_ODFINDITEMW:
            pnmhdr->code = LVN_ODFINDITEMA;
            goto ThunkLV_FINDINFO;

        case LVN_INCREMENTALSEARCHW:
            pnmhdr->code = LVN_INCREMENTALSEARCHA;
            goto ThunkLV_FINDINFO;

        ThunkLV_FINDINFO:
            {
                LV_FINDINFO *plvfi;

                // Hack Alert!  This code assumes that all fields of LV_FINDINFOA and
                // LV_FINDINFOW are exactly the same except for the string pointers.
                COMPILETIME_ASSERT(sizeof(LV_FINDINFOA) == sizeof(LV_FINDINFOW));

                // Since WCHARs are bigger than char, we will just use the
                // wchar buffer to hold the chars, and not worry about the extra
                // room at the end.
                COMPILETIME_ASSERT(sizeof(WCHAR) >= sizeof(char));

                plvfi = &((PNM_FINDITEM)pnmhdr)->lvfi;
                if (plvfi->flags & (LVFI_STRING | LVFI_PARTIAL | LVFI_SUBSTRING))
                {
                    pvThunk1 = (PVOID)plvfi->psz;
                    dwThunkSize = lstrlen(pvThunk1) + 1;
                    plvfi->psz = (LPWSTR)ProduceAFromW(pci->uiCodePage, plvfi->psz);
                }
            }
            break;

        case LVN_GETDISPINFOW: {
            LV_ITEMW *pitem;

            pnmhdr->code = LVN_GETDISPINFOA;

            // Hack Alert!  This code assumes that all fields of LV_DISPINFOA and
            // LV_DISPINFOW are exactly the same except for the string pointers.

            COMPILETIME_ASSERT(sizeof(LV_DISPINFOA) == sizeof(LV_DISPINFOW));

            // Since WCHARs are bigger than char, we will just use the
            // wchar buffer to hold the chars, and not worry about the extra
            // room at the end.
            COMPILETIME_ASSERT(sizeof(WCHAR) >= sizeof(char));

            //
            // Some sleazebag code (shell32.dll) just changes the pszText
            // pointer to point to the name, so capture the original pointer
            // so we can detect this and not smash their data.
            //
            pitem = &(((LV_DISPINFOW *)pnmhdr)->item);
            if (!IsFlagPtr(pitem) && (pitem->mask & LVIF_TEXT) && !IsFlagPtr(pitem->pszText)) {
                pvThunk1 = pitem->pszText;
                dwThunkSize = pitem->cchTextMax;
            }
            break;
        }


        // LVN_ENDLABELEDIT uses an INOUT parameter, never explicitly
        // documented as such, but it just happened to be that way,
        // and I don't want to take the chance that somebody was relying
        // on it.

        case LVN_ENDLABELEDITW:
            pnmhdr->code = LVN_ENDLABELEDITA;
            goto ThunkLV_DISPINFO;

        case LVN_BEGINLABELEDITW:
            pnmhdr->code = LVN_BEGINLABELEDITA;
            goto ThunkLV_DISPINFO;

        case LVN_SETDISPINFOW:
            pnmhdr->code = LVN_SETDISPINFOA;
            goto ThunkLV_DISPINFO;

        case LVN_GETEMPTYTEXTW:
            pnmhdr->code = LVN_GETEMPTYTEXTA;
            goto ThunkLV_DISPINFO;

        ThunkLV_DISPINFO: {
            LV_ITEMW *pitem;

            COMPILETIME_ASSERT(sizeof(LV_ITEMA) == sizeof(LV_ITEMW));
            pitem = &(((LV_DISPINFOW *)pnmhdr)->item);

            if (pitem->mask & LVIF_TEXT) {
                if (!InOutWtoA(pci, &ts, &pitem->pszText, pitem->cchTextMax))
                    return 0;
            }
            break;
        }

        case LVN_GETINFOTIPW: {
            NMLVGETINFOTIPW *pgit = (NMLVGETINFOTIPW *)pnmhdr;

            COMPILETIME_ASSERT(sizeof(NMLVGETINFOTIPA) == sizeof(NMLVGETINFOTIPW));
            pnmhdr->code = LVN_GETINFOTIPA;

            if (!InOutWtoA(pci, &ts, &pgit->pszText, pgit->cchTextMax))
                return 0;
        }
        break;


        case TVN_GETINFOTIPW:
            {
                NMTVGETINFOTIPW *pgit = (NMTVGETINFOTIPW *)pnmhdr;

                pnmhdr->code = TVN_GETINFOTIPA;

                pvThunk1 = pgit->pszText;
                dwThunkSize = pgit->cchTextMax;
            }
            break;

        case TBN_GETINFOTIPW:
            {
                NMTBGETINFOTIPW *pgit = (NMTBGETINFOTIPW *)pnmhdr;

                pnmhdr->code = TBN_GETINFOTIPA;

                pvThunk1 = pgit->pszText;
                dwThunkSize = pgit->cchTextMax;
            }
            break;

        case TVN_SELCHANGINGW:
            pnmhdr->code = TVN_SELCHANGINGA;
            bSet = TRUE;
            // fall through
            
        case TVN_SELCHANGEDW:
            if (!bSet) {
                pnmhdr->code = TVN_SELCHANGEDA;
                bSet = TRUE;
            }

            /*
             * These msgs have a NM_TREEVIEW with both TV_ITEMs filled in
             *
             * FALL THROUGH TO TVN_DELETEITEM to thunk itemOld then go on for
             * the other structure.
             */
             
            // fall through

        case TVN_DELETEITEMW: {
            /*
             * This message has a NM_TREEVIEW in lParam with itemOld filled in
             */
            LPTV_ITEMW pitem;

            if (!bSet) {
                pnmhdr->code = TVN_DELETEITEMA;
                bSet = TRUE;
            }

            pitem = &(((LPNM_TREEVIEWW)pnmhdr)->itemOld);

            // thunk itemOld
            if ( (pitem->mask & TVIF_TEXT) && !IsFlagPtr(pitem->pszText)) {
                pvThunk2 = pitem->pszText;
                pitem->pszText = (LPWSTR)ProduceAFromW(pci->uiCodePage, pvThunk2);
            }

            // if this is deleteitem then we are done
            if (pnmhdr->code == TVN_DELETEITEMA)
                break;

            /* FALL THROUGH TO TVN_ITEMEXPANDING to thunk itemNew */
        }
            // fall through

        case TVN_ITEMEXPANDINGW:
            if (!bSet) {
                pnmhdr->code = TVN_ITEMEXPANDINGA;
                bSet = TRUE;
            }
            // fall through

        case TVN_ITEMEXPANDEDW:
            if (!bSet) {
                pnmhdr->code = TVN_ITEMEXPANDEDA;
                bSet = TRUE;
            }
            // fall through

        case TVN_BEGINDRAGW:
            if (!bSet) {
                pnmhdr->code = TVN_BEGINDRAGA;
                bSet = TRUE;
            }
            // fall through

        case TVN_BEGINRDRAGW: {
            /* these msgs have a NM_TREEVIEW with itemNew TV_ITEM filled in */
            LPTV_ITEMW pitem;

            if (!bSet) {
                pnmhdr->code = TVN_BEGINRDRAGA;
            }

            pitem = &(((LPNM_TREEVIEWW)pnmhdr)->itemNew);

            if ( (pitem->mask & TVIF_TEXT) && !IsFlagPtr(pitem->pszText)) {
                pvThunk1 = pitem->pszText;
                pitem->pszText = (LPWSTR)ProduceAFromW(pci->uiCodePage, pvThunk1);
            }

            break;
        }

        case TVN_SETDISPINFOW:
            pnmhdr->code = TVN_SETDISPINFOA;
            goto ThunkTV_DISPINFO;

        case TVN_BEGINLABELEDITW:
            pnmhdr->code = TVN_BEGINLABELEDITA;
            goto ThunkTV_DISPINFO;


        // TVN_ENDLABELEDIT uses an INOUT parameter, never explicitly
        // documented as such, but it just happened to be that way,
        // and I don't want to take the chance that somebody was relying
        // on it.

        case TVN_ENDLABELEDITW:
            pnmhdr->code = TVN_ENDLABELEDITA;
            goto ThunkTV_DISPINFO;

        ThunkTV_DISPINFO: 
        {
            /*
             * All these messages have a TV_DISPINFO in lParam.
             */

            LPTV_ITEMW pitem;

            pitem = &(((TV_DISPINFOW *)pnmhdr)->item);

            if (pitem->mask & TVIF_TEXT) 
            {
                if (!InOutWtoA(pci, &ts, &pitem->pszText, pitem->cchTextMax))
                    return 0;
            }
            break;
        }

        case TVN_GETDISPINFOW: 
            {
             // All these messages have a TV_DISPINFO in lParam.
            LPTV_ITEMW pitem;

            pnmhdr->code = TVN_GETDISPINFOA;

            pitem = &(((TV_DISPINFOW *)pnmhdr)->item);

            if ((pitem->mask & TVIF_TEXT) && !IsFlagPtr(pitem->pszText) && pitem->cchTextMax) {
                pvThunk1 = pitem->pszText;
                dwThunkSize = pitem->cchTextMax;
                pvThunk2 = LocalAlloc(LPTR, pitem->cchTextMax * sizeof(char));
                pitem->pszText = pvThunk2;
                pitem->pszText[0] = TEXT('\0');
            }

            break;
        }

        case HDN_ITEMCHANGINGW:
            pnmhdr->code = HDN_ITEMCHANGINGA;
            bSet = TRUE;
            // fall through

        case HDN_ITEMCHANGEDW:
            if (!bSet) {
                pnmhdr->code = HDN_ITEMCHANGEDA;
                bSet = TRUE;
            }
            // fall through

        case HDN_ITEMCLICKW:
            if (!bSet) {
                pnmhdr->code = HDN_ITEMCLICKA;
                bSet = TRUE;
            }
            // fall through

        case HDN_ITEMDBLCLICKW:
            if (!bSet) {
                pnmhdr->code = HDN_ITEMDBLCLICKA;
                bSet = TRUE;
            }
            // fall through

        case HDN_DIVIDERDBLCLICKW:
            if (!bSet) {
                pnmhdr->code = HDN_DIVIDERDBLCLICKA;
                bSet = TRUE;
            }
            // fall through

        case HDN_BEGINTRACKW:
            if (!bSet) {
                pnmhdr->code = HDN_BEGINTRACKA;
                bSet = TRUE;
            }
            // fall through

        case HDN_ENDTRACKW:
            if (!bSet) {
                pnmhdr->code = HDN_ENDTRACKA;
                bSet = TRUE;
            }
            // fall through

        case HDN_TRACKW: {
            HD_ITEMW *pitem;

            if (!bSet) {
                pnmhdr->code = HDN_TRACKA;
            }

            pitem = ((HD_NOTIFY *)pnmhdr)->pitem;

            if ( !IsFlagPtr(pitem) && (pitem->mask & HDI_TEXT) && !IsFlagPtr(pitem->pszText)) {
                pvThunk1 = pitem->pszText;
                dwThunkSize = pitem->cchTextMax;
                pitem->pszText = (LPWSTR)ProduceAFromW(pci->uiCodePage, pvThunk1);
            }


            if ( !IsFlagPtr(pitem) && (pitem->mask & HDI_FILTER) && pitem->pvFilter )
            {
                if ( !(pitem->type & HDFT_HASNOVALUE) &&
                        ((pitem->type & HDFT_ISMASK)==HDFT_ISSTRING) )
                {
                    LPHD_TEXTFILTER ptextFilter = (LPHD_TEXTFILTER)pitem->pvFilter;
                    pvThunk2 = ptextFilter->pszText;
                    dwThunkSize = ptextFilter->cchTextMax;
                    ptextFilter->pszText = (LPWSTR)ProduceAFromW(pci->uiCodePage, pvThunk2);
                }
            }


            break;
        }

        case CBEN_ENDEDITW:
        {
            LPNMCBEENDEDITW peew = (LPNMCBEENDEDITW) pnmhdr;
            LPNMCBEENDEDITA peea = LocalAlloc(LPTR, sizeof(NMCBEENDEDITA));

            if (!peea)
               return 0;

            peea->hdr  = peew->hdr;
            peea->hdr.code = CBEN_ENDEDITA;

            peea->fChanged = peew->fChanged;
            peea->iNewSelection = peew->iNewSelection;
            peea->iWhy = peew->iWhy;
            ConvertWToAN(pci->uiCodePage, peea->szText, ARRAYSIZE(peea->szText),
                         peew->szText, -1);

            pvThunk1 = pnmhdr;
            pnmhdr = &peea->hdr;
            ASSERT((LPVOID)pnmhdr == (LPVOID)peea);
            break;
        }

        case CBEN_DRAGBEGINW:
        {
            LPNMCBEDRAGBEGINW pdbw = (LPNMCBEDRAGBEGINW) pnmhdr;
            LPNMCBEDRAGBEGINA pdba = LocalAlloc(LPTR, sizeof(NMCBEDRAGBEGINA));

            if (!pdba)
               return 0;

            pdba->hdr  = pdbw->hdr;
            pdba->hdr.code = CBEN_DRAGBEGINA;
            pdba->iItemid = pdbw->iItemid;
            ConvertWToAN(pci->uiCodePage, pdba->szText, ARRAYSIZE(pdba->szText),
                         pdbw->szText, -1);

            pvThunk1 = pnmhdr;
            pnmhdr = &pdba->hdr;
            ASSERT((LPVOID)pnmhdr == (LPVOID)pdba);
            break;
        }


        case CBEN_GETDISPINFOW: {
            PNMCOMBOBOXEXW pnmcbe = (PNMCOMBOBOXEXW)pnmhdr;

            pnmhdr->code = CBEN_GETDISPINFOA;

            if (pnmcbe->ceItem.mask  & CBEIF_TEXT
                && !IsFlagPtr(pnmcbe->ceItem.pszText) && pnmcbe->ceItem.cchTextMax) {
                pvThunk1 = pnmcbe->ceItem.pszText;
                dwThunkSize = pnmcbe->ceItem.cchTextMax;
                pvThunk2 = LocalAlloc(LPTR, pnmcbe->ceItem.cchTextMax * sizeof(char));
                pnmcbe->ceItem.pszText = pvThunk2;
                pnmcbe->ceItem.pszText[0] = TEXT('\0');
            }

            break;
        }

        case HDN_GETDISPINFOW: {
            LPNMHDDISPINFOW pHDDispInfoW;

            pnmhdr->code = HDN_GETDISPINFOA;

            pHDDispInfoW = (LPNMHDDISPINFOW) pnmhdr;

            pvThunk1 = pHDDispInfoW->pszText;
            dwThunkSize = pHDDispInfoW->cchTextMax;
            pHDDispInfoW->pszText = LocalAlloc (LPTR, pHDDispInfoW->cchTextMax * sizeof(char));

            if (!pHDDispInfoW->pszText) {
                pHDDispInfoW->pszText = (LPWSTR) pvThunk1;
                break;
            }

            WideCharToMultiByte(pci->uiCodePage, 0, (LPWSTR)pvThunk1, -1,
                               (LPSTR)pHDDispInfoW->pszText, pHDDispInfoW->cchTextMax,
                               NULL, NULL);
            break;
        }


        case TBN_GETBUTTONINFOW:
            {
            LPTBNOTIFYW pTBNW;

            pnmhdr->code = TBN_GETBUTTONINFOA;

            pTBNW = (LPTBNOTIFYW)pnmhdr;

            pvThunk1 = pTBNW->pszText;
            dwThunkSize = pTBNW->cchText;
            pvThunk2 = LocalAlloc (LPTR, pTBNW->cchText * sizeof(char));

            if (!pvThunk2) {
                break;
            }
            pTBNW->pszText = pvThunk2;

            WideCharToMultiByte(pci->uiCodePage, 0, (LPWSTR)pvThunk1, -1,
                               (LPSTR)pTBNW->pszText, pTBNW->cchText,
                               NULL, NULL);

            }
            break;

        case TTN_NEEDTEXTW:
            {
            LPTOOLTIPTEXTA lpTTTA;
            LPTOOLTIPTEXTW lpTTTW = (LPTOOLTIPTEXTW) pnmhdr;

            lpTTTA = LocalAlloc(LPTR, sizeof(TOOLTIPTEXTA));

            if (!lpTTTA)
               return 0;

            lpTTTA->hdr = lpTTTW->hdr;
            lpTTTA->hdr.code = TTN_NEEDTEXTA;

            lpTTTA->lpszText = lpTTTA->szText;
            lpTTTA->hinst    = lpTTTW->hinst;
            lpTTTA->uFlags   = lpTTTW->uFlags;
            lpTTTA->lParam   = lpTTTW->lParam;

            WideCharToMultiByte(pci->uiCodePage, 0, lpTTTW->szText, -1, lpTTTA->szText, ARRAYSIZE(lpTTTA->szText), NULL, NULL);
            pvThunk1 = pnmhdr;
            pnmhdr = (NMHDR *)lpTTTA;
            }
            break;

        case DTN_USERSTRINGW:
            {
            LPNMDATETIMESTRINGW lpDateTimeString = (LPNMDATETIMESTRINGW) pnmhdr;

            pnmhdr->code = DTN_USERSTRINGA;

            pvThunk1 = ProduceAFromW(pci->uiCodePage, lpDateTimeString->pszUserString);
            lpDateTimeString->pszUserString = (LPWSTR) pvThunk1;
            }
            break;

        case DTN_WMKEYDOWNW:
            {
            LPNMDATETIMEWMKEYDOWNW lpDateTimeWMKeyDown =
                                               (LPNMDATETIMEWMKEYDOWNW) pnmhdr;

            pnmhdr->code = DTN_WMKEYDOWNA;

            pvThunk1 = ProduceAFromW(pci->uiCodePage, lpDateTimeWMKeyDown->pszFormat);
            lpDateTimeWMKeyDown->pszFormat = (LPWSTR) pvThunk1;
            }
            break;

        case DTN_FORMATQUERYW:
            {
            LPNMDATETIMEFORMATQUERYW lpDateTimeFormatQuery =
                                               (LPNMDATETIMEFORMATQUERYW) pnmhdr;

            pnmhdr->code = DTN_FORMATQUERYA;

            pvThunk1 = ProduceAFromW(pci->uiCodePage, lpDateTimeFormatQuery->pszFormat);
            lpDateTimeFormatQuery->pszFormat = (LPWSTR) pvThunk1;
            }
            break;

        case DTN_FORMATW:
            {
            LPNMDATETIMEFORMATW lpDateTimeFormat =
                                               (LPNMDATETIMEFORMATW) pnmhdr;

            pnmhdr->code = DTN_FORMATA;

            pvThunk1 = ProduceAFromW(pci->uiCodePage, lpDateTimeFormat->pszFormat);
            lpDateTimeFormat->pszFormat = (LPWSTR) pvThunk1;
            }
            break;

        default:
            fThunked = FALSE;
            break;
        }

#ifdef NEED_WOWGETNOTIFYSIZE_HELPER
        ASSERT(code >= 0 || WOWGetNotifySize(code));
#endif // NEED_WOWGETNOTIFYSIZE_HELPER

        lRet = SendMessage(hwndParent, WM_NOTIFY, (WPARAM)id, (LPARAM)pnmhdr);

        /*
         * All the thunking for Notify Messages happens here
         */
        if (fThunked)
        {
        switch(pnmhdr->code) {
        case LVN_ODFINDITEMA:
        case LVN_INCREMENTALSEARCHA:
            {
                LV_FINDINFO *plvfi = &((PNM_FINDITEM)pnmhdr)->lvfi;
                if (pvThunk1)
                {
                    FreeProducedString((LPWSTR)plvfi->psz);
                    plvfi->psz = pvThunk1;
                }
            }
            break;

        case LVN_GETDISPINFOA:
            {
                LV_ITEMA *pitem = &(((LV_DISPINFOA *)pnmhdr)->item);

                if (!IsFlagPtr(pitem) && (pitem->mask & LVIF_TEXT) && !IsFlagPtr(pitem->pszText))
                {
                    StringBufferAtoW(pci->uiCodePage, pvThunk1, dwThunkSize, &pitem->pszText);
                }
            }
            break;

        case LVN_ENDLABELEDITA:
        case LVN_BEGINLABELEDITA:
        case LVN_SETDISPINFOA:
        case LVN_GETEMPTYTEXTA:
            {
                LV_ITEMA *pitem = &(((LV_DISPINFOA *)pnmhdr)->item);
                InOutAtoW(pci, &ts, &pitem->pszText);
            }
            break;

        case LVN_GETINFOTIPA:
            {
                NMLVGETINFOTIPA *pgit = (NMLVGETINFOTIPA *)pnmhdr;
                InOutAtoW(pci, &ts, &pgit->pszText);
            }
            break;

        case TVN_GETINFOTIPA:
            {
                NMTVGETINFOTIPA *pgit = (NMTVGETINFOTIPA *)pnmhdr;
                StringBufferAtoW(pci->uiCodePage, pvThunk1, dwThunkSize, &pgit->pszText);
            }
            break;

        case TBN_GETINFOTIPA:
            {
                NMTBGETINFOTIPA *pgit = (NMTBGETINFOTIPA *)pnmhdr;
                StringBufferAtoW(pci->uiCodePage, pvThunk1, dwThunkSize, &pgit->pszText);
            }
            break;
        case TVN_SELCHANGINGA:
        case TVN_SELCHANGEDA:
        case TVN_DELETEITEMA: {
            LPTV_ITEMW pitem;

            if ( !IsFlagPtr(pvThunk2) ) {
                pitem = &(((LPNM_TREEVIEWW)pnmhdr)->itemOld);

                FreeProducedString(pitem->pszText);
                pitem->pszText = pvThunk2;
            }

            // if this is delitem, then we are done
            if (code == TVN_DELETEITEM)
                break;

            /* FALL THROUGH TO TVN_ITEMEXPANDING to unthunk itemNew */
        }
            // fall through

        case TVN_ITEMEXPANDINGA:
        case TVN_ITEMEXPANDEDA:
        case TVN_BEGINDRAGA:
        case TVN_BEGINRDRAGA: {
            /* these msgs have a NM_TREEVIEW with itemNew TV_ITEM filled in */
            LPTV_ITEMW pitem;

            if (!IsFlagPtr(pvThunk1)) {
                pitem = &(((LPNM_TREEVIEWW)pnmhdr)->itemNew);

                FreeProducedString(pitem->pszText);
                pitem->pszText = pvThunk1;
            }

            break;
        }

        case TVN_SETDISPINFOA:
        case TVN_BEGINLABELEDITA:
        case TVN_ENDLABELEDITA:
            {
                LPTV_ITEMA pitem;
                pitem = &(((TV_DISPINFOA *)pnmhdr)->item);
                InOutAtoW(pci, &ts, &pitem->pszText);
            }
            break;

        case TVN_GETDISPINFOA: {
            /*
             * This message has a TV_DISPINFO in lParam that wass filled in
             * during the callback and needs to be unthunked.
             */
            LPTV_ITEMW pitem;

            pitem = &(((TV_DISPINFOW *)pnmhdr)->item);

            if (!IsFlagPtr(pvThunk1) && (pitem->mask & TVIF_TEXT) && !IsFlagPtr(pitem->pszText)) {
                ConvertAToWN(pci->uiCodePage, pvThunk1, dwThunkSize, (LPSTR)pitem->pszText, -1);
                pitem->pszText = pvThunk1;
                LocalFree(pvThunk2);
            }

            break;
        }

        case HDN_ITEMCHANGINGA:
        case HDN_ITEMCHANGEDA:
        case HDN_ITEMCLICKA:
        case HDN_ITEMDBLCLICKA:
        case HDN_DIVIDERDBLCLICKA:
        case HDN_BEGINTRACKA:
        case HDN_ENDTRACKA:
        case HDN_TRACKA: {
            HD_ITEMW *pitem;

            pitem = ((HD_NOTIFY *)pnmhdr)->pitem;

            if ( !IsFlagPtr(pitem) && (pitem->mask & HDI_TEXT) && !IsFlagPtr(pvThunk1)) {
                ConvertAToWN(pci->uiCodePage, pvThunk1, dwThunkSize, (LPSTR)(pitem->pszText), -1);

                FreeProducedString(pitem->pszText);
                pitem->pszText = pvThunk1;
            }

            if ( !IsFlagPtr(pitem) && (pitem->mask & HDI_FILTER) && pitem->pvFilter && pvThunk2 )
            {
                if ( !(pitem->type & HDFT_HASNOVALUE) &&
                        ((pitem->type & HDFT_ISMASK)==HDFT_ISSTRING) )
                {
                    LPHD_TEXTFILTER ptextFilter = (LPHD_TEXTFILTER)pitem->pvFilter;
                    ConvertAToWN(pci->uiCodePage, pvThunk2, dwThunkSize, (LPSTR)(ptextFilter->pszText), -1);
                    FreeProducedString(ptextFilter->pszText);
                    ptextFilter->pszText = pvThunk2;
                }
            }

            break;
        }

        case CBEN_ENDEDITA:
            {
            LPNMCBEENDEDITW peew = (LPNMCBEENDEDITW) pvThunk1;
            LPNMCBEENDEDITA peea = (LPNMCBEENDEDITA) pnmhdr;

            // Don't unthunk the string since that destroys unicode round-trip
            // and the client shouldn't be modifying it anyway.
            // ConvertAToWN(pci->uiCodePage, peew->szText, ARRAYSIZE(peew->szText),
            //              peea->szText, -1);
            LocalFree(peea);
            }
            break;

        case CBEN_DRAGBEGINA:
            {
            LPNMCBEDRAGBEGINW pdbw = (LPNMCBEDRAGBEGINW) pvThunk1;
            LPNMCBEDRAGBEGINA pdba = (LPNMCBEDRAGBEGINA) pnmhdr;

            // Don't unthunk the string since that destroys unicode round-trip
            // and the client shouldn't be modifying it anyway.
            // ConvertAToWN(pci->uiCodePage, pdbw->szText, ARRAYSIZE(pdbw->szText),
            //              pdba->szText, -1);
            LocalFree(pdba);
            }
            break;

        case CBEN_GETDISPINFOA:
        {
            PNMCOMBOBOXEXW pnmcbeW;

            pnmcbeW = (PNMCOMBOBOXEXW)pnmhdr;
            ConvertAToWN(pci->uiCodePage, pvThunk1, dwThunkSize, (LPSTR)(pnmcbeW->ceItem.pszText), -1);

            if (pvThunk2)
                LocalFree(pvThunk2);
            pnmcbeW->ceItem.pszText = pvThunk1;

        }
            break;


        case HDN_GETDISPINFOA:
            {
            LPNMHDDISPINFOW pHDDispInfoW;

            pHDDispInfoW = (LPNMHDDISPINFOW)pnmhdr;
            ConvertAToWN(pci->uiCodePage, pvThunk1, dwThunkSize, (LPSTR)(pHDDispInfoW->pszText), -1);

            LocalFree(pHDDispInfoW->pszText);
            pHDDispInfoW->pszText = pvThunk1;

            }
            break;

        case TBN_GETBUTTONINFOA:
            {
            LPTBNOTIFYW pTBNW;

            pTBNW = (LPTBNOTIFYW)pnmhdr;
            ConvertAToWN(pci->uiCodePage, pvThunk1, dwThunkSize, (LPSTR)(pTBNW->pszText), -1);

            pTBNW->pszText = pvThunk1;
            LocalFree(pvThunk2);

            }
            break;


        case TTN_NEEDTEXTA:
            {
            LPTOOLTIPTEXTA lpTTTA = (LPTOOLTIPTEXTA) pnmhdr;
            LPTOOLTIPTEXTW lpTTTW = (LPTOOLTIPTEXTW) pvThunk1;

            ThunkToolTipTextAtoW (lpTTTA, lpTTTW, pci->uiCodePage);
            LocalFree(lpTTTA);
            }
            break;

        case DTN_USERSTRINGA:
        case DTN_WMKEYDOWNA:
        case DTN_FORMATQUERYA:
            {
            FreeProducedString (pvThunk1);
            }
            break;

        case DTN_FORMATA:
            {
            LPNMDATETIMEFORMATA lpDateTimeFormat = (LPNMDATETIMEFORMATA) pnmhdr;

            FreeProducedString (pvThunk1);

            //
            // pszDisplay and szDisplay are special cases.
            //

            if (lpDateTimeFormat->pszDisplay && *lpDateTimeFormat->pszDisplay) {

                //
                // if pszDisplay still points at szDisplay then thunk
                // in place.  Otherwise allocate memory and copy the
                // display string.  This buffer will be freeded in monthcal.c
                //

                if (lpDateTimeFormat->pszDisplay == lpDateTimeFormat->szDisplay) {
                    CHAR szDisplay[64];

                    lstrcpynA (szDisplay, lpDateTimeFormat->szDisplay, 64);

                    ConvertAToWN (pci->uiCodePage, (LPWSTR)lpDateTimeFormat->szDisplay, 64,
                                  szDisplay, -1);
                } else {
                    lpDateTimeFormat->pszDisplay =
                             (LPSTR) ProduceWFromA (pci->uiCodePage, lpDateTimeFormat->pszDisplay);
                }

            }

            }
            break;

        default:
            /* No thunking needed */
            break;
        }
        }
        return lRet;
    } 
    else
        return(SendMessage(hwndParent, WM_NOTIFY, (WPARAM)id, (LPARAM)pnmhdr));

#undef pvThunk1
#undef pvThunk2
#undef dwThunkSize
}

LRESULT WINAPI SendNotify(HWND hwndTo, HWND hwndFrom, int code, NMHDR* pnmhdr)
{
    CCONTROLINFO ci;
    ci.hwndParent = hwndTo;
    ci.hwnd = hwndFrom;
    ci.bUnicode = FALSE;
    ci.uiCodePage = CP_ACP;

    //
    // SendNotify is obsolete.  New code should call CCSendNotify
    // instead.  However, if something does call SendNotify,
    // it will call SendNotifyEx with FALSE as the Unicode parameter,
    // because it probably is ANSI code.
    //

    return CCSendNotify(&ci, code, pnmhdr);
}


DWORD CICustomDrawNotify(LPCCONTROLINFO lpci, DWORD dwStage, LPNMCUSTOMDRAW lpnmcd)
{
    DWORD dwRet = CDRF_DODEFAULT;


    // bail if...


    // this is an item notification, but an item notification wasn't asked for
    if ((dwStage & CDDS_ITEM) && !(lpci->dwCustom & CDRF_NOTIFYITEMDRAW)) {
        return dwRet;
    }

    lpnmcd->dwDrawStage = dwStage;
    dwRet = (DWORD) CCSendNotify(lpci, NM_CUSTOMDRAW, &lpnmcd->hdr);

    // validate the flags
    if (dwRet & ~CDRF_VALIDFLAGS)
        return CDRF_DODEFAULT;

    return dwRet;
}

//
//  Too many apps encounter strange behavior when we send out
//  NM_CUSTOMDRAW messages at times unrelated to painting.
//  E.g., NetMeeting and MFC recurse back into ListView_RecomputeLabelSize.
//  CryptUI will fault if it's asked to NM_CUSTOMDRAW before it gets
//  WM_INITDIALOG.  So all this fake customdraw stuff is v5 only.
//
//  And since it is very popular to call back into the control during
//  the handling of NM_CUSTOMDRAW, we protect against recursing ourselves
//  to death by blowing off nested fake customdraw messages.


DWORD CIFakeCustomDrawNotify(LPCCONTROLINFO lpci, DWORD dwStage, LPNMCUSTOMDRAW lpnmcd)
{
    DWORD dwRet = CDRF_DODEFAULT;

    if (!lpci->bInFakeCustomDraw)
    {
        lpci->bInFakeCustomDraw = TRUE;
        dwRet = CICustomDrawNotify(lpci, dwStage, lpnmcd);
        ASSERT(lpci->bInFakeCustomDraw);
        lpci->bInFakeCustomDraw = FALSE;
    }

    return dwRet;
}

/*----------------------------------------------------------
Purpose: Release the capture and tell the parent we've done so.

Returns: Whether the control is still alive.
*/
BOOL CCReleaseCapture(CCONTROLINFO * pci)
{
    HWND hwndCtl = pci->hwnd;
    NMHDR nmhdr = {0};

    ReleaseCapture();

    // Tell the parent we've released the capture
    CCSendNotify(pci, NM_RELEASEDCAPTURE, &nmhdr);

    return IsWindow(hwndCtl);
}


/*----------------------------------------------------------
Purpose: Set the capture.  If the hwndSet is NULL, it means
         the capture is being released, so tell the parent
         we've done so.

         Use this function if there's a possibility that the
         hwnd may be NULL.

*/
void CCSetCapture(CCONTROLINFO * pci, HWND hwndSet)
{
    SetCapture(hwndSet);

    if (NULL == hwndSet)
    {
        NMHDR nmhdr = {0};

        // Tell the parent we've released the capture
        CCSendNotify(pci, NM_RELEASEDCAPTURE, &nmhdr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\progress.c ===
/*-----------------------------------------------------------------------
**
** Progress.c
**
** A "gas gauge" type control for showing application progress.
**
**-----------------------------------------------------------------------*/
#include "ctlspriv.h"

// REARCHITECT raymondc - should Process control support __int64 on Win64?
//                        Should it support this anyway? Used in the filesystem, 
//                        this would prevent the shell from having to fudge it

typedef struct {
    HWND hwnd;
    DWORD dwStyle;
    int iLow, iHigh;
    int iPos;
    int iMarqueePos;
    int iStep;
    HFONT hfont;
    COLORREF _clrBk;
    COLORREF _clrBar;
    HTHEME hTheme;
} PRO_DATA;

LRESULT CALLBACK ProgressWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);

BOOL InitProgressClass(HINSTANCE hInstance)
{
    WNDCLASS wc = {0};

    wc.lpfnWndProc      = ProgressWndProc;
    wc.lpszClassName    = s_szPROGRESS_CLASS;
    wc.style            = CS_GLOBALCLASS | CS_HREDRAW | CS_VREDRAW;
    wc.hInstance        = hInstance;    // use DLL instance if in DLL
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.cbWndExtra       = sizeof(PRO_DATA *);    // store a pointer

    if (!RegisterClass(&wc) && !GetClassInfo(hInstance, s_szPROGRESS_CLASS, &wc))
        return FALSE;

    return TRUE;
}

#define MARQUEE_TIMER 1

void ProEraseBkgnd(PRO_DATA *ppd, HDC hdc, RECT* prcClient)
{
    COLORREF clrBk = ppd->_clrBk;

    if (clrBk == CLR_DEFAULT)
        clrBk = g_clrBtnFace;

    FillRectClr(hdc, prcClient, clrBk);
}

void ProGetPaintMetrics(PRO_DATA *ppd, RECT* prcClient, RECT *prc, int *pdxSpace, int *pdxBlock)
{
    int dxSpace, dxBlock;
    RECT rc;

    GetClientRect(ppd->hwnd, prcClient);

    if (ppd->hTheme)
    {
        int iPartBar = (ppd->dwStyle & PBS_VERTICAL)? PP_BARVERT : PP_BAR;
        GetThemeBackgroundContentRect(ppd->hTheme, NULL, iPartBar, 0, prcClient, &rc);
    }
    else
    {
        //  give 1 pixel around the bar
        rc = *prcClient;
        InflateRect(&rc, -1, -1);
    }

    if (ppd->dwStyle & PBS_VERTICAL)
        dxBlock = (rc.right - rc.left) * 2 / 3;
    else
        dxBlock = (rc.bottom - rc.top) * 2 / 3;

    dxSpace = 2;
    if (dxBlock == 0)
        dxBlock = 1;    // avoid div by zero

    if (ppd->dwStyle & PBS_SMOOTH) 
    {
        dxBlock = 1;
        dxSpace = 0;
    }

    if (ppd->hTheme)
    {
        int dx;
        if (SUCCEEDED(GetThemeInt(ppd->hTheme, 0, 0, TMT_PROGRESSCHUNKSIZE, &dx)))
        {
            dxBlock = dx;
        }

        if (SUCCEEDED(GetThemeInt(ppd->hTheme, 0, 0, TMT_PROGRESSSPACESIZE, &dx)))
        {
            dxSpace = dx;
        }
    }

    *prc = rc;
    *pdxSpace = dxSpace;
    *pdxBlock = dxBlock;
}

int GetProgressScreenPos(PRO_DATA *ppd, int iNewPos, RECT *pRect)
{
    int iStart, iEnd;
    if (ppd->dwStyle & PBS_VERTICAL)
    {
        iStart = pRect->top;
        iEnd = pRect->bottom;
    }
    else
    {
        iStart = pRect->left;
        iEnd = pRect->right;
    }
    return MulDiv(iEnd - iStart, iNewPos - ppd->iLow, ppd->iHigh - ppd->iLow);
}

BOOL ProNeedsRepaint(PRO_DATA *ppd, int iOldPos)
{
    BOOL fRet = FALSE;
    RECT rc, rcClient;
    int dxSpace, dxBlock;
    int x, xOld;

    if (iOldPos != ppd->iPos)
    {
        ProGetPaintMetrics(ppd, &rcClient, &rc, &dxSpace, &dxBlock);

        x = GetProgressScreenPos(ppd, ppd->iPos, &rc);
        xOld = GetProgressScreenPos(ppd, iOldPos, &rc);

        if (x != xOld)
        {
            if (dxBlock == 1 && dxSpace == 0) 
            {
                fRet = TRUE;
            }
            else
            {
                int nBlocks, nOldBlocks;
                nBlocks = (x + (dxBlock + dxSpace) - 1) / (dxBlock + dxSpace); // round up
                nOldBlocks = (xOld + (dxBlock + dxSpace) - 1) / (dxBlock + dxSpace); // round up

                if (nBlocks != nOldBlocks)
                    fRet = TRUE;
            }
        }
    }
    return fRet;
}

int UpdatePosition(PRO_DATA *ppd, int iNewPos, BOOL bAllowWrap)
{
    int iOldPos = ppd->iPos;
    UINT uRedraw = RDW_INVALIDATE | RDW_UPDATENOW;
    BOOL fNeedsRepaint = TRUE;

    if (ppd->dwStyle & PBS_MARQUEE)
    {
        // Do an immediate repaint
        uRedraw |= RDW_ERASE;
    }
    else
    {
        if (ppd->iLow == ppd->iHigh)
            iNewPos = ppd->iLow;

        if (iNewPos < ppd->iLow) 
        {
            if (!bAllowWrap)
                iNewPos = ppd->iLow;
            else
                iNewPos = ppd->iHigh - ((ppd->iLow - iNewPos) % (ppd->iHigh - ppd->iLow));
        }
        else if (iNewPos > ppd->iHigh) 
        {
            if (!bAllowWrap)
                iNewPos = ppd->iHigh;
            else
                iNewPos = ppd->iLow + ((iNewPos - ppd->iHigh) % (ppd->iHigh - ppd->iLow));
        }

        // if moving backwards, erase old version
        if (iNewPos < iOldPos)
            uRedraw |= RDW_ERASE;

        ppd->iPos = iNewPos;
        fNeedsRepaint = ProNeedsRepaint(ppd, iOldPos);
    }

    if (fNeedsRepaint)
    {
        RedrawWindow(ppd->hwnd, NULL, NULL, uRedraw);
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ppd->hwnd, OBJID_CLIENT, 0);
    }

    return iOldPos;
}

/* MarqueeShowBlock

  iBlock = The block we're considering - returns TRUE if this block should be shown.
  iMarqueeBlock = The block at the center of the marquee pattern
  nBlocks = The number of blocks in the bar
*/
#define BLOCKSINMARQUEE 5
BOOL MarqueeShowBlock(int iBlock, int iMarqueeBlock, int nBlocks)
{
    int i;
    for (i = 0; i < BLOCKSINMARQUEE; i++)
    {
        if ((iMarqueeBlock + i - (BLOCKSINMARQUEE / 2)) % nBlocks == iBlock)
        {
            return TRUE;
        }
    }

    return FALSE;
}

#define HIGHBG g_clrHighlight
#define HIGHFG g_clrHighlightText
#define LOWBG g_clrBtnFace
#define LOWFG g_clrBtnText

void ProPaint(PRO_DATA *ppd, HDC hdcIn)
{
    int x, dxSpace, dxBlock, nBlocks, i;
    HDC    hdc, hdcPaint, hdcMem = NULL;
    HBITMAP hbmpOld = NULL;
    RECT rc, rcClient;
    PAINTSTRUCT ps;
    HRESULT hr = E_FAIL;
    int iPart;
    BOOL fTransparent = FALSE;
    BOOL fShowBlock;

    if (hdcIn == NULL)
    {
        hdc = hdcPaint = BeginPaint(ppd->hwnd, &ps);

        // Only make large enough for clipping region
        hdcMem = CreateCompatibleDC(hdc);
        if (hdcMem)
        {
            HBITMAP hMemBm = CreateCompatibleBitmap(hdc, RECTWIDTH(ps.rcPaint), RECTHEIGHT(ps.rcPaint));
            if (hMemBm)
            {
                hbmpOld = SelectObject(hdcMem, hMemBm);

                // Override painting DC with memory DC
                hdc = hdcMem;
            }
            else
                DeleteDC(hdcMem);
        }
    }
    else
        hdc = hdcIn;

    
    ProGetPaintMetrics(ppd, &rcClient, &rc, &dxSpace, &dxBlock);

    if (hdcMem)
    {
        // OffsetWindowOrgEx() doesn't work with the themes, need to change painting rects
        OffsetRect(&rcClient, -ps.rcPaint.left, -ps.rcPaint.top);
        OffsetRect(&rc, -ps.rcPaint.left, -ps.rcPaint.top);
    }

    x = GetProgressScreenPos(ppd, ppd->iPos, &rcClient);

    // Paint background
    if (ppd->hTheme)
    {
        int iPartBar = (ppd->dwStyle & PBS_VERTICAL)? PP_BARVERT : PP_BAR;
        iPart = (ppd->dwStyle & PBS_VERTICAL)? PP_CHUNKVERT: PP_CHUNK;

        DrawThemeBackground(ppd->hTheme, hdc, iPartBar, 0, &rcClient, 0);
    }
    else
    {
        ProEraseBkgnd(ppd, hdc, &rcClient);
    }

    if (dxBlock == 1 && dxSpace == 0 && ppd->hTheme != NULL)
    {
        if (ppd->dwStyle & PBS_VERTICAL) 
            rc.top = x;
        else
            rc.right = x;

        hr = DrawThemeBackground(ppd->hTheme, hdc, iPart, 0, &rc, 0);
    }
    else
    {
        if (ppd->dwStyle & PBS_MARQUEE)
        {
            // Consider the full bar
            if (ppd->dwStyle & PBS_VERTICAL)
            {
                nBlocks = ((rc.bottom - rc.top) + (dxBlock + dxSpace) - 1) / (dxBlock + dxSpace); // round up
            }
            else
            {
                nBlocks = ((rc.right - rc.left) + (dxBlock + dxSpace) - 1) / (dxBlock + dxSpace); // round up
            }

            ppd->iMarqueePos = (ppd->iMarqueePos + 1) % nBlocks;
        }
        else
        {
            nBlocks = (x + (dxBlock + dxSpace) - 1) / (dxBlock + dxSpace); // round up
        }

        for (i = 0; i < nBlocks; i++) 
        {
            if (ppd->dwStyle & PBS_VERTICAL) 
            {
                rc.top = rc.bottom - dxBlock;

                // are we past the end?
                if (rc.bottom <= rcClient.top)
                    break;

                if (rc.top <= rcClient.top)
                    rc.top = rcClient.top + 1;
            } 
            else 
            {
                rc.right = rc.left + dxBlock;

                // are we past the end?
                if (rc.left >= rcClient.right)
                    break;

                if (rc.right >= rcClient.right)
                    rc.right = rcClient.right - 1;
            }

            if (ppd->dwStyle & PBS_MARQUEE)
            {
                fShowBlock = MarqueeShowBlock(i, ppd->iMarqueePos, nBlocks);
            }
            else
            {
                fShowBlock = TRUE;
            }

            if (fShowBlock)
            {
                if (ppd->hTheme)
                {
                    hr = DrawThemeBackground(ppd->hTheme, hdc, iPart, 0, &rc, 0);
                }

                if (FAILED(hr))
                {
                    if (ppd->_clrBar == CLR_DEFAULT)
                        FillRectClr(hdc, &rc, g_clrHighlight);
                    else
                        FillRectClr(hdc, &rc, ppd->_clrBar);
                }
            }

            if (ppd->dwStyle & PBS_VERTICAL) 
            {
                rc.bottom = rc.top - dxSpace;
            } 
            else 
            {
                rc.left = rc.right + dxSpace;
            }
        }
    }

    if (hdcMem != NULL)
    {
        BitBlt(hdcPaint, ps.rcPaint.left, ps.rcPaint.top, RECTWIDTH(ps.rcPaint), RECTHEIGHT(ps.rcPaint),
            hdc, 0, 0, SRCCOPY);
        DeleteObject(SelectObject(hdcMem, hbmpOld));
        DeleteDC(hdcMem);
    }

    if (hdcIn == NULL)
        EndPaint(ppd->hwnd, &ps);
}

LRESULT Progress_OnCreate(HWND hWnd, LPCREATESTRUCT pcs)
{
    PRO_DATA *ppd = (PRO_DATA *)LocalAlloc(LPTR, sizeof(*ppd));
    if (!ppd)
        return -1;

    // remove ugly double 3d edge
    SetWindowPtr(hWnd, 0, ppd);
    ppd->hwnd = hWnd;
    ppd->iHigh = 100;        // default to 0-100
    ppd->iStep = 10;        // default to step of 10
    ppd->dwStyle = pcs->style;
    ppd->_clrBk = CLR_DEFAULT;
    ppd->_clrBar = CLR_DEFAULT;
    ppd->hTheme = OpenThemeData(hWnd, L"Progress");

    if (ppd->hTheme)
    {
        SetWindowLong(hWnd, GWL_EXSTYLE, (pcs->dwExStyle & ~(WS_EX_CLIENTEDGE | WS_EX_STATICEDGE | WS_BORDER)));
        SetWindowPos(hWnd, NULL, 0,0,0,0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
    }
    else
    {
        // hack of the 3d client edge that WS_BORDER implies in dialogs
        // add the 1 pixel static edge that we really want
        SetWindowLong(hWnd, GWL_EXSTYLE, (pcs->dwExStyle & ~WS_EX_CLIENTEDGE) | WS_EX_STATICEDGE);

        if (!(pcs->dwExStyle & WS_EX_STATICEDGE))
            SetWindowPos(hWnd, NULL, 0,0,0,0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
    }

    return 0;
}

LRESULT MarqueeSetTimer(PRO_DATA *ppd, BOOL fDoMarquee, UINT iMilliseconds)
{
    if (fDoMarquee)
    {
        SetTimer(ppd->hwnd, MARQUEE_TIMER, iMilliseconds ? iMilliseconds : 30, NULL);
        ppd->iMarqueePos = 0;
    }
    else
    {
        KillTimer(ppd->hwnd, MARQUEE_TIMER);
    }

    return 1;
}

LRESULT CALLBACK ProgressWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    int x;
    HFONT hFont;
    PRO_DATA *ppd = (PRO_DATA *)GetWindowPtr(hWnd, 0);

    switch (wMsg)
    {
    case WM_CREATE:
        return Progress_OnCreate(hWnd, (LPCREATESTRUCT)lParam);

    case WM_DESTROY:
        if (ppd)
        {
            if (ppd->hTheme)
            {
                CloseThemeData(ppd->hTheme);
            }

            KillTimer(hWnd, MARQUEE_TIMER);
            LocalFree((HLOCAL)ppd);
        }
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        InvalidateRect(hWnd, NULL, TRUE);
        break;

    case WM_SETFONT:
        hFont = ppd->hfont;
        ppd->hfont = (HFONT)wParam;
        return (LRESULT)(UINT_PTR)hFont;

    case WM_GETFONT:
            return (LRESULT)(UINT_PTR)ppd->hfont;

    case PBM_GETPOS:
        return ppd->iPos;

    case PBM_GETRANGE:
        if (lParam) {
            PPBRANGE ppb = (PPBRANGE)lParam;
            ppb->iLow = ppd->iLow;
            ppb->iHigh = ppd->iHigh;
        }
        return (wParam ? ppd->iLow : ppd->iHigh);

    case PBM_SETRANGE:
        // win95 compat
        wParam = LOWORD(lParam);
        lParam = HIWORD(lParam);
        // fall through

    case PBM_SETRANGE32:
    {
        LRESULT lret = MAKELONG(ppd->iLow, ppd->iHigh);

        // only repaint if something actually changed
        if ((int)wParam != ppd->iLow || (int)lParam != ppd->iHigh)
        {
            ppd->iHigh = (int)lParam;
            ppd->iLow  = (int)wParam;
            // force an invalidation/erase but don't redraw yet
            RedrawWindow(ppd->hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
            UpdatePosition(ppd, ppd->iPos, FALSE);
        }
        return lret;
    }

    case PBM_SETPOS:
        return (LRESULT)UpdatePosition(ppd, (int) wParam, FALSE);

    case PBM_SETSTEP:
        x = ppd->iStep;
        ppd->iStep = (int)wParam;
        return (LRESULT)x;

    case PBM_SETMARQUEE:
        return MarqueeSetTimer(ppd, (BOOL) wParam, (UINT) lParam);

    case WM_TIMER:
        // Pos doesn't move for PSB_MARQUEE mode
        UpdatePosition(ppd, ppd->iPos, TRUE);
        return 0;

    case PBM_STEPIT:
        return (LRESULT)UpdatePosition(ppd, ppd->iStep + ppd->iPos, TRUE);

    case PBM_DELTAPOS:
        return (LRESULT)UpdatePosition(ppd, ppd->iPos + (int)wParam, FALSE);

    case PBM_SETBKCOLOR:
    {
        COLORREF clr = ppd->_clrBk;
        ppd->_clrBk = (COLORREF)lParam;
        InvalidateRect(hWnd, NULL, TRUE);
        return clr;
    }

    case PBM_SETBARCOLOR:
    {
        COLORREF clr = ppd->_clrBar;
        ppd->_clrBar = (COLORREF)lParam;
        InvalidateRect(hWnd, NULL, TRUE);
        return clr;
    }

    case WM_PRINTCLIENT:
    case WM_PAINT:
        ProPaint(ppd,(HDC)wParam);
        break;

    case WM_ERASEBKGND:
        return 1;  // Filled in ProPaint

    case WM_GETOBJECT:
        if (lParam == OBJID_QUERYCLASSNAMEIDX)
            return MSAA_CLASSNAMEIDX_PROGRESS;
        goto DoDefault;

    case WM_THEMECHANGED:
        if (ppd->hTheme)
            CloseThemeData(ppd->hTheme);

        ppd->hTheme = OpenThemeData(hWnd, L"Progress");
        if (ppd->hTheme == NULL)
        {
            SetWindowLong(hWnd, GWL_EXSTYLE, GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_STATICEDGE);
            SetWindowPos(hWnd, NULL, 0,0,0,0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
        }

        InvalidateRect(hWnd, NULL, TRUE);
        break;

    case WM_STYLECHANGED:
        if (wParam == GWL_STYLE) 
        {
            ppd->dwStyle = ((STYLESTRUCT *)lParam)->styleNew;

            // change positions to force repaint
            ppd->iPos = ppd->iLow + 1;  
            UpdatePosition(ppd, ppd->iLow, TRUE);
        }
        break;

DoDefault:
    default:
        return DefWindowProc(hWnd,wMsg,wParam,lParam);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\prsht.c ===
#include "ctlspriv.h"
#include "help.h" // Help IDs
#include "prshti.h"

#include "dlgcvt.h"

#ifdef WX86
#include <wx86ofl.h>
#endif

#define FLAG_CHANGED    0x0001
#define DEFAULTHEADERHEIGHT    58   // in pixels
#define DEFAULTTEXTDIVIDERGAP  5
#define DEFAULTCTRLWIDTH       501   // page list window in new wizard style
#define DEFAULTCTRLHEIGHT      253   // page list window in new wizard style
#define TITLEX                 22
#define TITLEY                 10
#define SUBTITLEX              44
#define SUBTITLEY              25

// fixed sizes for the bitmap painted in the header section
#define HEADERBITMAP_Y            5
#define HEADERBITMAP_WIDTH        49
#define HEADERBITMAP_CXBACK       (5 + HEADERBITMAP_WIDTH)
#define HEADERBITMAP_HEIGHT       49                
#define HEADERSUBTITLE_WRAPOFFSET 10

// Fixed sizes for the watermark bitmap (Wizard97IE5 style)
#define BITMAP_WIDTH  164
#define BITMAP_HEIGHT 312

#define DRAWTEXT_WIZARD97FLAGS (DT_LEFT | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)

LPVOID WINAPI MapSLFix(HANDLE);
VOID WINAPI UnMapSLFixArray(int, HANDLE *);

LRESULT CALLBACK WizardWndProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData);

#if  !defined(WIN32)
#ifdef FE_IME
typedef void *PVOID;
DWORD WINAPI GetCurrentThreadID(VOID);
DWORD WINAPI GetCurrentProcessID(VOID);
PVOID WINAPI ImmFindThreadLink(DWORD dwThreadID);
BOOL WINAPI ImmCreateThreadLink(DWORD dwPid, DWORD dwTid);
#endif
#endif

void    ResetWizButtons(LPPROPDATA ppd);

typedef struct  // tie
{
    TC_ITEMHEADER   tci;
    HWND            hwndPage;
    UINT            state;
} TC_ITEMEXTRA;

#define CB_ITEMEXTRA (sizeof(TC_ITEMEXTRA) - sizeof(TC_ITEMHEADER))
#define IS_WIZARDPSH(psh) ((psh).dwFlags & (PSH_WIZARD | PSH_WIZARD97 | PSH_WIZARD_LITE))
#define IS_WIZARD(ppd) IS_WIZARDPSH(ppd->psh)

void PageChange(LPPROPDATA ppd, int iAutoAdj);
void RemovePropPageData(LPPROPDATA ppd, int nPage);
HRESULT GetPageLanguage(PISP pisp, WORD *pwLang);
UINT GetDefaultCharsetFromLang(LANGID wLang);
LANGID NT5_GetUserDefaultUILanguage(void);

//
// IMPORTANT:  The IDHELP ID should always be LAST since we just subtract
// 1 from the number of IDs if no help in the page.
// IDD_APPLYNOW should always be the FIRST ID for standard IDs since it
// is sometimes not displayed and we'll start with index 1.
//
const static int IDs[] = {IDOK, IDCANCEL, IDD_APPLYNOW, IDHELP};
const static int WizIDs[] = {IDD_BACK, IDD_NEXT, IDD_FINISH, IDCANCEL, IDHELP};
const static WORD wIgnoreIDs[] = {IDD_PAGELIST, IDD_DIVIDER, IDD_TOPDIVIDER};

// Prsht_PrepareTemplate action matrix. Please do not change without contacting [msadek]...

const PSPT_ACTION g_PSPT_Action [PSPT_TYPE_MAX][PSPT_OS_MAX][PSPT_OVERRIDE_MAX]={
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_MIRRORED, PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_MIRRORED, PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_WIN9XCOMPAT,  // PSPT_TYPE_MIRRORED, PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_WIN9XCOMPAT,  // PSPT_TYPE_MIRRORED, PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_FLIP,         // PSPT_TYPE_MIRRORED, PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_MIRRORED, PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_MIRRORED, PSPT_OS_WINNT5,     PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_MIRRORED, PSPT_OS_WINNT5,     PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_MIRRORED, PSPT_OS_OTHER,      PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOMIRRORING,  // PSPT_TYPE_MIRRORED, PSPT_OS_OTHER,      PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENABLED,  PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENABLED,  PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WINNT5,     PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WINNT5,     PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENABLED,  PSPT_OS_OTHER,      PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOMIRRORING,  // PSPT_TYPE_ENABLED,  PSPT_OS_OTHER,      PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENGLISH,  PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENGLISH,  PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_LOADENGLISH,  // PSPT_TYPE_ENGLISH,  PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENGLISH,  PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENGLISH,  PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENGLISH,  PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_LOADENGLISH,  // PSPT_TYPE_ENGLISH,  PSPT_OS_WINNT5,     PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENGLISH,  PSPT_OS_WINNT5,     PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENGLISH,  PSPT_OS_OTHER,      PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOMIRRORING,  // PSPT_TYPE_ENGLISH,  PSPT_OS_OTHER,      PSPT_OVERRIDE_USEPAGELANG
    };

// HACK FOR HIJAAK 95!
//
// Instead of creating
// property sheet pages with CreatePropertySheetPage, they merely
// take a pointer to a PROPSHEETPAGE structure and cast it to
// HPROPSHEETPAGE.  They got away with this on Win95 because Win95's
// HPROPSHEETPAGE actually was 95% identical to a PROPSHEETPAGE.
// (The missing 5% causes RIPs at property sheet destruction, which
// Hijaak no doubt ignored.)
//
// On NT and IE5, this coincidence is not true.
//
// So validate that what we have is really a property sheet
// structure by checking if it's on the heap at the
// right place.  If not, then make one.
//

HPROPSHEETPAGE WINAPI _Hijaak95Hack(LPPROPDATA ppd, HPROPSHEETPAGE hpage)
{
    if (hpage && !LocalSize(PropSheetBase(hpage))) {
        // SLACKERS!  Have to call CreatePropertySheetPage for them
        RIPMSG(0, "App passed HPROPSHEETPAGE not created by us; trying to cope");
        hpage = _CreatePropertySheetPage((LPCPROPSHEETPAGE)hpage,
                                         ppd->fFlags & PD_NEEDSHADOW,
                                         ppd->fFlags & PD_WX86);
    }
    return hpage;
}

void _SetTitle(HWND hDlg, LPPROPDATA ppd)
{
    TCHAR szFormat[50];
    TCHAR szTitle[128];
    TCHAR szTemp[128 + 50];
    LPCTSTR pCaption = ppd->psh.pszCaption;

    if (IS_INTRESOURCE(pCaption)) {
        LoadString(ppd->psh.hInstance, (UINT)LOWORD(pCaption), szTitle, ARRAYSIZE(szTitle));
        pCaption = (LPCTSTR)szTitle;
    }

    if (ppd->psh.dwFlags & PSH_PROPTITLE) {
        if (*pCaption == 0)
        {
            // Hey, no title, we need a different resource for localization
            LocalizedLoadString(IDS_PROPERTIES, szTemp, ARRAYSIZE(szTemp));
            pCaption = szTemp;
        }
        else
        {
            LocalizedLoadString(IDS_PROPERTIESFOR, szFormat, ARRAYSIZE(szFormat));
            if ((lstrlen(pCaption) + 1 + lstrlen(szFormat) + 1) < ARRAYSIZE(szTemp)) {
                wsprintf(szTemp, szFormat, pCaption);
                pCaption = szTemp;
            }
        }
    }
#ifdef WINDOWS_ME
    if(ppd->psh.dwFlags & PSH_RTLREADING) {
        SetWindowLong(hDlg, GWL_EXSTYLE, GetWindowLong(hDlg, GWL_EXSTYLE) | WS_EX_RTLREADING);
        }
#endif // WINDOWS_ME
    SetWindowText(hDlg, pCaption);
}

BOOL _SetHeaderFonts(HWND hDlg, LPPROPDATA ppd)
{
    HFONT   hFont;
    LOGFONT LogFont;

    GetObject(GetWindowFont(hDlg), sizeof(LogFont), &LogFont);

    CCAdjustForBold(&LogFont);
    if ((hFont = CreateFontIndirect(&LogFont)) == NULL)
    {
        ppd->hFontBold = NULL;
        return FALSE;
    }
    ppd->hFontBold = hFont;
    // Save the font as a window prop so we can delete it later
    return TRUE;
}

int _WriteHeaderTitle(LPPROPDATA ppd, HDC hdc, LPRECT prc, LPCTSTR pszTitle, BOOL bTitle, DWORD dwDrawFlags)
{
    LPCTSTR pszOut;
    int cch;
    int cx, cy;
    TCHAR szTitle[MAX_PATH*4];
    HFONT hFontOld = NULL;
    HFONT hFont;
    int yDrawHeight = 0;

    if (IS_INTRESOURCE(pszTitle))
    {
        LoadString(GETPPSP(ppd, ppd->nCurItem)->hInstance, (UINT)LOWORD(pszTitle), szTitle, ARRAYSIZE(szTitle));
        pszOut = szTitle;
    }
    else
        pszOut = pszTitle;

    cch = lstrlen(pszOut);

    if (bTitle && ppd->hFontBold)
        hFont = ppd->hFontBold;
    else
        hFont = GetWindowFont(ppd->hDlg);

    hFontOld = SelectObject(hdc, hFont);

    if (bTitle)
    {
        cx = TITLEX;
        cy = TITLEY;
        ExtTextOut(hdc, cx, cy, 0, prc, pszOut, cch, NULL);
    }
    else
    {
        RECT rcWrap;
        CopyRect(&rcWrap, prc);

        rcWrap.left = SUBTITLEX;
        rcWrap.top = ppd->ySubTitle;
        yDrawHeight = DrawText(hdc, pszOut, cch, &rcWrap, dwDrawFlags);
    }

    if (hFontOld)
        SelectObject(hdc, hFontOld);

    return yDrawHeight;
}

// In Wizard97 only:
// The subtitles user passed in could be larger than the two line spaces we give
// them, especially in localization cases. So here we go through all subtitles and
// compute the max space they need and set the header height so that no text is clipped
int _ComputeHeaderHeight(LPPROPDATA ppd, int dxMax)
{
    int dyHeaderHeight;
    int dyTextDividerGap;
    HDC hdc;
    dyHeaderHeight = DEFAULTHEADERHEIGHT;
    hdc = GetDC(ppd->hDlg);

    // First, let's get the correct text height and spacing, this can be used
    // as the title height and the between-lastline-and-divider spacing.
    {
        HFONT hFont, hFontOld;
        TEXTMETRIC tm;
        if (ppd->hFontBold)
            hFont = ppd->hFontBold;
        else
            hFont = GetWindowFont(ppd->hDlg);

        hFontOld = SelectObject(hdc, hFont);
        if (GetTextMetrics(hdc, &tm))
        {
            dyTextDividerGap = tm.tmExternalLeading;
            ppd->ySubTitle = max ((tm.tmHeight + tm.tmExternalLeading + TITLEY), SUBTITLEY);
        }
        else
        {
            dyTextDividerGap = DEFAULTTEXTDIVIDERGAP;
            ppd->ySubTitle = SUBTITLEY;
        }

        if (hFontOld)
            SelectObject(hdc, hFontOld);
    }

    // Second, get the subtitle text block height
    // should make into a function if shared
    {
        RECT rcWrap;
        UINT uPages;

        //
        //  WIZARD97IE5 subtracts out the space used by the header bitmap.
        //  WIZARD97IE4 uses the full width since the header bitmap
        //  in IE4 is a watermark and occupies no space.
        //
        if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
            rcWrap.right = dxMax;
        else
            rcWrap.right = dxMax - HEADERBITMAP_CXBACK - HEADERSUBTITLE_WRAPOFFSET;
        for (uPages = 0; uPages < ppd->psh.nPages; uPages++)
        {
            PROPSHEETPAGE *ppsp = GETPPSP(ppd, uPages);
            if (!(ppsp->dwFlags & PSP_HIDEHEADER) &&
                 (ppsp->dwFlags & PSP_USEHEADERSUBTITLE))
            {
                int iSubHeaderHeight = _WriteHeaderTitle(ppd, hdc, &rcWrap, ppsp->pszHeaderSubTitle,
                    FALSE, DT_CALCRECT | DRAWTEXT_WIZARD97FLAGS);
                if ((iSubHeaderHeight + ppd->ySubTitle) > dyHeaderHeight)
                    dyHeaderHeight = iSubHeaderHeight + ppd->ySubTitle;
            }
        }
    }

    // If the header height has been recomputed, set the correct gap between
    // the text and the divider.
    if (dyHeaderHeight != DEFAULTHEADERHEIGHT)
    {
        ASSERT(dyHeaderHeight > DEFAULTHEADERHEIGHT);
        dyHeaderHeight += dyTextDividerGap;
    }

    ReleaseDC(ppd->hDlg, hdc);
    return dyHeaderHeight;
}

void MoveAllButtons(HWND hDlg, const int *pids, int idLast, int dx, int dy)
{
    do {
        HWND hCtrl;
        RECT rcCtrl;

        int iCtrl = *pids;
        hCtrl = GetDlgItem(hDlg, iCtrl);
        GetWindowRect(hCtrl, &rcCtrl);

        //
        // If the dialog wizard window is mirrored, then rcl.right
        // in terms of screen coord is the near edge (lead). [samera]
        //
        if (IS_WINDOW_RTL_MIRRORED(hDlg))
            rcCtrl.left = rcCtrl.right;

        ScreenToClient(hDlg, (LPPOINT)&rcCtrl);
        SetWindowPos(hCtrl, NULL, rcCtrl.left + dx,
                     rcCtrl.top + dy, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
    } while(*(pids++) != idLast);
}

void RemoveButton(HWND hDlg, int idRemove, const int *pids)
{
    int idPrev = 0;
    HWND hRemove = NULL;
    HWND hPrev;
    RECT rcRemove, rcPrev;
    int iWidth = 0;
    const int *pidRemove;

    // get the previous id
    for (pidRemove = pids; *pidRemove != idRemove; pidRemove++)
        idPrev = *pidRemove;


    if (idPrev) {
        hRemove = GetDlgItem(hDlg, idRemove);
        hPrev = GetDlgItem(hDlg, idPrev);
        GetWindowRect(hRemove, &rcRemove);
        GetWindowRect(hPrev, &rcPrev);

        //
        // If the dialog window is mirrored, then the prev button
        // will be ahead (to the right) of the button-to-be-removed.
        // As a result, the subtraction will be definitely negative,
        // so let's convert it to be positive. [samera]
        //
        if (IS_WINDOW_RTL_MIRRORED(hDlg))
            iWidth = rcPrev.right - rcRemove.right;
        else
            iWidth = rcRemove.right - rcPrev.right;
    }

    MoveAllButtons(hDlg, pids, idRemove, iWidth, 0);

    if (hRemove)
        ShowWindow(hRemove, SW_HIDE);

    // Cannot disable the window; see Prsht_ButtonSubclassProc for explanation.
    // WRONG - EnableWindow(hRemove, FALSE);
}

typedef struct LOGPALETTE256 {
    WORD    palVersion;
    WORD    palNumEntries;
    union {
        PALETTEENTRY rgpal[256];
        RGBQUAD rgq[256];
    } u;
} LOGPALETTE256;

HPALETTE PaletteFromBmp(HBITMAP hbm)
{
    LOGPALETTE256 pal;
    int i,n;
    HDC hdc;
    HPALETTE hpl;

    hdc = CreateCompatibleDC(NULL);
    SelectObject(hdc, hbm);
    n = GetDIBColorTable(hdc, 0, 256, pal.u.rgq);

    if (n)                          // DIB section with color table
    {
        // Palettes are such a hassle.  GetDIBColorTable returns RGBQUADs, whereas
        // LOGPALETTE wants PALETTEENTRYss, and the two are reverse-endian
        // of each other.
        for (i= 0 ; i < n; i++)
        {
            PALETTEENTRY pe;
            pe.peRed = pal.u.rgq[i].rgbRed;
            pe.peGreen = pal.u.rgq[i].rgbGreen;
            pe.peBlue = pal.u.rgq[i].rgbBlue;
            pe.peFlags = 0;
            pal.u.rgpal[i] = pe;
        }

        pal.palVersion = 0x0300;
        pal.palNumEntries = (WORD)n;

        hpl = CreatePalette((LPLOGPALETTE)&pal);
    }
    else                            // Not a DIB section or no color table
    {
        hpl = CreateHalftonePalette(hdc);
    }

    DeleteDC(hdc);
    return hpl;
}

// -------------- stolen from user code -------------------------------------
//
//  GetCharDimensions(hDC, psiz)
//
//  This function loads the Textmetrics of the font currently selected into
//  the given hDC and saves the height and Average char width of the font
//  (NOTE: the
//  AveCharWidth value returned by the text metrics call is wrong for
//  proportional fonts -- so, we compute them).
//
// -------------- stolen from user code --------------------------------------
TCHAR AveCharWidthData[52+1] = TEXT("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
void GetCharDimensions(HDC hDC, SIZE *psiz)
{
    TEXTMETRIC  tm;

    // Store the System Font metrics info.
    GetTextMetrics(hDC, &tm);

    if (!(tm.tmPitchAndFamily & TMPF_FIXED_PITCH)) // the name is opposite:)
        psiz->cx = tm.tmAveCharWidth;
    else
    {
        // Change from tmAveCharWidth.  We will calculate a true average as
        // opposed to the one returned by tmAveCharWidth. This works better
        // when dealing with proportional spaced fonts. -- ROUND UP
        if (GetTextExtentPoint32(hDC, AveCharWidthData, 52, psiz) == TRUE)
        {
            psiz->cx = ((psiz->cx / 26) + 1) / 2;
        }
        else
            psiz->cx = tm.tmAveCharWidth;
    }

    psiz->cy = tm.tmHeight;
}

//
//  It is a feature that USER considers keyboard accelerators live even if
//  the control is hidden.  This lets you put a hidden static in front of
//  a custom control to get an accelerator attached to the custom control.
//
//  Unfortunately, it means that the &F accelerator for "Finish" activates
//  the Finish button even when the Finish button is hidden.  The normal
//  workaround for this is to disable the control, but that doesn't work
//  because Microsoft PhotoDraw runs around and secretly hides and shows
//  buttons without going through PSM_SETWIZBUTTONS, so they end up showing
//  a disabled window and their wizard stops working.
//
//  So instead, we subclass the buttons and customize their WM_GETDLGCODE
//  so that when the control is hidden, they disable their accelerators.
//
LRESULT CALLBACK Prsht_ButtonSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp, UINT_PTR uID, ULONG_PTR dwRefData)
{
    LRESULT lres;


    switch (wm)
    {

    case WM_GETDLGCODE:
        lres = DefSubclassProc(hwnd, wm, wp, lp);
        if (!IsWindowVisible(hwnd))
        {
            // To remove yourself from the mnemonic search, you have to
            // return DLGC_WANTCHAR if you are give a NULL LPMSG pointer.
            // Normally, the dialog manager sends a real LPMSG containing
            // the message that just got received, but when it's poking
            // around looking for accelerators, it doesn't give you a
            // message at all.  It is in that case that you want to
            // say, "Hey, I will process the (nonexistent) message".
            // This tricks USER into thinking you're an edit control, so
            // it won't scan your for mnemonics.
            if ((LPMSG)lp == NULL)
                lres |= DLGC_WANTCHARS;

        }
        break;

    case WM_NCDESTROY:
        // Clean up subclass
        RemoveWindowSubclass(hwnd, Prsht_ButtonSubclassProc, 0);
        lres = DefSubclassProc(hwnd, wm, wp, lp);
        break;

    default:
        lres = DefSubclassProc(hwnd, wm, wp, lp);
        break;
    }

    return lres;
}

void Prsht_SubclassButton(HWND hDlg, UINT idd)
{
    SetWindowSubclass(GetDlgItem(hDlg, idd), Prsht_ButtonSubclassProc, 0, 0);
}

BOOL CompareFontFaceW(LPCWSTR lpwz1, LPCWSTR lpwz2, BOOL fBitCmp)
{
    return lstrcmpiW(lpwz1, lpwz2);
}

// 
// GetPageFontMetrics
//
// synopsis: 
// 
// Get the real font metrics from PAGEFONTDATA. Used in InitPropSheetDlg() to
// calculate the physical page size based on the font specified in page templates
//
// fML is set if we are in here because of an ML scenario, in which case the
// font names need to be mapped.
//

BOOL GetPageFontMetrics(LPPROPDATA ppd, PPAGEFONTDATA ppfd, BOOL fML)
{
    LOGFONT    lf = {0};
    HFONT      hFont;
    HRESULT    fRc = FALSE;
    HDC        hdc;
    
    if (ppfd && (ppfd->PointSize > 0) && ppfd->szFace[0])
    {

        // font name mapping
        // should be done only for the platform less than NT5
        // NT5 is supposed to work with native typeface on any system locale.
        //
        if (!staticIsOS(OS_WIN2000ORGREATER) && fML)
        {
            // replace native font face name to single byte name for non-native platform
            typedef struct tagFontFace
            {
                BOOL fBitCmp;
                LPCWSTR lpEnglish;
                LPCWSTR lpNative;
            } FONTFACE, *LPFONTFACE;
    
            const static FONTFACE s_FontTbl[] = 
            {
                {   FALSE, L"MS Gothic", L"MS UI Gothic"                                   },
                {   TRUE,  L"MS Gothic", L"\xff2d\xff33 \xff30\x30b4\x30b7\x30c3\x30af"    },
                {   TRUE,  L"GulimChe",  L"\xad74\xb9bc"                                   },
                {   TRUE,  L"MS Song",   L"\x5b8b\x4f53"                                   },
                {   TRUE,  L"MingLiU",   L"\x65b0\x7d30\x660e\x9ad4"                       }
            };

            int i;

            for (i = 0; i < ARRAYSIZE(s_FontTbl); i++)
            {
                if (!CompareFontFaceW(ppfd->szFace, s_FontTbl[i].lpNative, s_FontTbl[i].fBitCmp))
                {
                    lstrcpynW(lf.lfFaceName, s_FontTbl[i].lpEnglish, ARRAYSIZE(lf.lfFaceName));
                    break;
                }
            }
            if (i >= ARRAYSIZE(s_FontTbl))
                lstrcpynW(lf.lfFaceName, ppfd->szFace, ARRAYSIZE(lf.lfFaceName));
        }
        else
            lstrcpynW(lf.lfFaceName, ppfd->szFace, ARRAYSIZE(lf.lfFaceName));

        // Try to use the cache
        if (ppfd->iCharset  == ppd->pfdCache.iCharset &&
            ppfd->bItalic   == ppd->pfdCache.bItalic &&
            ppfd->PointSize == ppd->pfdCache.PointSize &&
            lstrcmpiW(ppfd->szFace, ppd->pfdCache.szFace) == 0) {
            fRc = TRUE;
        } else {
            if (hdc = GetDC(ppd->hDlg))
            {
                lf.lfHeight = -MulDiv(ppfd->PointSize, GetDeviceCaps(hdc,LOGPIXELSY), 72);
                lf.lfCharSet = (BYTE)ppfd->iCharset;
                lf.lfItalic  = (BYTE)ppfd->bItalic;
                lf.lfWeight = FW_NORMAL;

                hFont = CreateFontIndirectW(&lf);
                if (hFont)
                {
                    HFONT hFontOld = SelectObject(hdc, hFont);

                    GetCharDimensions(hdc, &ppd->sizCache);
                    if (hFontOld)
                        SelectObject(hdc, hFontOld);

                    DeleteObject(hFont);

                    // Save these font metrics into the cache
                    ppd->pfdCache = *ppfd;
                    fRc = TRUE;
                }
                ReleaseDC(ppd->hDlg, hdc);

            }
        }
    }
    return fRc;
}

//
//  The "ideal page size" of a property sheet is the maximum size of all
//  pages.
//
//  GIPS_SKIPINTERIOR97HEIGHT and GIPS_SKIPEXTERIOR97HEIGHT selective
//  exclude Wiz97 pages from the height computation.  They are important
//  because interior pages are shorter than exterior pages by
//  ppd->cyHeaderHeight.
//

#define GIPS_SKIPINTERIOR97HEIGHT 1
#define GIPS_SKIPEXTERIOR97HEIGHT 2

void Prsht_GetIdealPageSize(LPPROPDATA ppd, PSIZE psiz, UINT flags)
{
    UINT uPages;

    *psiz = ppd->sizMin;

    for (uPages = 0; uPages < ppd->psh.nPages; uPages++)
    {
        PISP pisp = GETPISP(ppd, uPages);
        int cy = pisp->_pfx.siz.cy;

        if (ppd->psh.dwFlags & PSH_WIZARD97)
        {
            if (pisp->_psp.dwFlags & PSP_HIDEHEADER)
            {
                if (flags & GIPS_SKIPEXTERIOR97HEIGHT) goto skip;
            }
            else
            {
                if (flags & GIPS_SKIPINTERIOR97HEIGHT) goto skip;
            }
        }

        if (psiz->cy < cy)
            psiz->cy = cy;

    skip:;
        if (psiz->cx < pisp->_pfx.siz.cx)
            psiz->cx = pisp->_pfx.siz.cx;
    }

}

#define IsMSShellDlgMapped(langid) (PRIMARYLANGID(langid) == LANG_JAPANESE)

//
//  Given a page, decide what size it wants to be and save it in the
//  pisp->_pfx.siz.
//
void Prsht_ComputeIdealPageSize(LPPROPDATA ppd, PISP pisp, PAGEINFOEX *ppi)
{
    BOOL fUsePageFont;

    // pressume page and frame dialog are in same character set
    LANGID wPageLang = ppd->wFrameLang;
    int    iPageCharset = DEFAULT_CHARSET;

    if (SUCCEEDED(GetPageLanguage(pisp, &wPageLang)))
    {
        // GetPageLanguage fails if page is marked PSP_DLGINDIRECT;
        // we'll try to recover from that later.  For now,
        // we leave pagelang to DEFAULT_CHARSET and see if we can take
        // the charset info from template EX.
        //
        // if PSH_USEPAGELANG is specified, we can assume that
        // page charset == frame charset and no need for ML adjustment
        // *except for* the case of NT Japanese version that replaces
        // frame's MS Shell Dlg to their native font. We handle this
        // exception later where we set up fUsePageFont; 
        //
        if (!(ppd->psh.dwFlags & PSH_USEPAGELANG)
            && wPageLang != ppd->wFrameLang)
        {
            iPageCharset  = GetDefaultCharsetFromLang(wPageLang);
        }
        else
            iPageCharset  = ppd->iFrameCharset;
    }

    // Use the font in the page if any of these conditions are met:
    //
    // A) It's a SHELLFONT page.  Do this even if the font is not
    //    "MS Shell Dlg 2".  This gives apps a way to specify that
    //    their custom-font page should be measured against the
    //    font in the page rather than in the frame font.
    //
    // B) ML scenario - complicated original comment below...
    //
    //  1) we've detected lang in the caller's resource and
    //  it's different from the frame dialog
    //  2) the caller's page doesn't have lang info or we've
    //  failed to get it (iPageCharset == DEFAULT_CHARSET),
    // then we find the page is described with DLGTEMPLATEEX
    // and has meaningful charset specified (!= defaultcharset)
    // *and* the charset is different from frame's
    //  3) the exception for NT Japanese platform that maps
    //     MS Shell Dlg to their native font. For US Apps to
    //     work on these platforms they typically specify 
    //     PSH_USEPAGELANG to get English buttons on frame
    //     but they still need to get the frame sized based on
    //     page font
    //
    // Otherwise, IE4 compat **requires** that we use the frame font.
    // ISVs have hacked around this historical bug by having large
    // dialog templates with extra space in them.
    //
    fUsePageFont =
        /* --- A) It's a SHELLFONT page --- */
        IsPageInfoSHELLFONT(ppi) ||
        /* --- B) ML scenario --- */
        ((ppd->psh.dwFlags & PSH_USEPAGELANG) 
        && IsMSShellDlgMapped(NT5_GetUserDefaultUILanguage())) ||
        (ppd->iFrameCharset != iPageCharset
        && (iPageCharset != DEFAULT_CHARSET
            || (ppi->pfd.iCharset != DEFAULT_CHARSET
                && ppi->pfd.iCharset != ppd->iFrameCharset)));

    if (fUsePageFont &&
        GetPageFontMetrics(ppd, &ppi->pfd, MLIsMLHInstance(pisp->_psp.hInstance)))
    {
        // Compute Real Dialog Unit for the page
        pisp->_pfx.siz.cx = MulDiv(ppi->pt.x, ppd->sizCache.cx, 4);
        pisp->_pfx.siz.cy = MulDiv(ppi->pt.y, ppd->sizCache.cy, 8);
    } else {
        RECT rcT;
        // IE4 compat - Use the frame font
        rcT.top = rcT.left = 0;         // Win95 will fault if these are uninit
        rcT.right = ppi->pt.x;
        rcT.bottom = ppi->pt.y;
        MapDialogRect(ppd->hDlg, &rcT);
        pisp->_pfx.siz.cx = rcT.right;
        pisp->_pfx.siz.cy = rcT.bottom;

        //
        //  If this is PSP_DLGINDIRECT but the character set and face name
        //  say this is a "generic" property sheet, then take the frame
        //  font or the page font, whichever is bigger.
        //
        //  This fixes the Chinese MingLiu font, which is not as tall as
        //  the English MS Sans Serif font.  Without this fix, we would
        //  use MingLui (the frame font), and then your MS Shell Dlg pages
        //  would get truncated.
        //
        //  (Truncated property sheets is what you got in NT4, but I guess
        //  looking pretty is more important than bug-for-bug compatibility.
        //  Who knows what apps will be broken by this change.)
        //
        if ((pisp->_psp.dwFlags & PSP_DLGINDIRECT) &&
            ppi->pfd.iCharset == DEFAULT_CHARSET &&
            lstrcmpiW(ppi->pfd.szFace, L"MS Shell Dlg") == 0)
        {
            int i;
            GetPageFontMetrics(ppd, &ppi->pfd, FALSE);
            i = MulDiv(ppi->pt.x, ppd->sizCache.cx, 4);
            if (pisp->_pfx.siz.cx < i)
                pisp->_pfx.siz.cx = i;
            i = MulDiv(ppi->pt.y, ppd->sizCache.cy, 8);
            if (pisp->_pfx.siz.cy < i)
                pisp->_pfx.siz.cy = i;

        }
    }
}

void InitPropSheetDlg(HWND hDlg, LPPROPDATA ppd)
{
    PAGEINFOEX pi;
    int dxDlg, dyDlg, dyGrow, dxGrow;
    RECT rcMinSize, rcDlg, rcPage, rcOrigTabs;
    UINT uPages;
    HIMAGELIST himl = NULL;
    TC_ITEMEXTRA tie;
    TCHAR szStartPage[128];
    LPCTSTR pStartPage = NULL;
    UINT nStartPage;
    BOOL fPrematurePages = FALSE;
#ifdef DEBUG
    BOOL fStartPageFound = FALSE;
#endif
    LANGID langidMUI;
    MONITORINFO mMonitorInfo;
    HMONITOR hMonitor;
    BOOL bMirrored = FALSE;
    // set our instance data pointer
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)ppd);

    // Make sure this gets inited early on.
    ppd->nCurItem = 0;

    // By default we allow the "Apply" button to be enabled
    ppd->fAllowApply = TRUE;

    if (IS_WIZARD(ppd)) {
        // Subclass our buttons so their mnemonics won't mess up applications
        // that run around hiding and showing the buttons behind our back.
        Prsht_SubclassButton(hDlg, IDD_BACK);
        Prsht_SubclassButton(hDlg, IDD_NEXT);
        Prsht_SubclassButton(hDlg, IDD_FINISH);
    } else
        _SetTitle(hDlg, ppd);

    if (ppd->psh.dwFlags & PSH_USEICONID)
    {
        ppd->psh.H_hIcon = LoadImage(ppd->psh.hInstance, ppd->psh.H_pszIcon, IMAGE_ICON, g_cxSmIcon, g_cySmIcon, LR_DEFAULTCOLOR);
    }

    if ((ppd->psh.dwFlags & (PSH_USEICONID | PSH_USEHICON)) && ppd->psh.H_hIcon)
        SendMessage(hDlg, WM_SETICON, FALSE, (LPARAM)(UINT_PTR)ppd->psh.H_hIcon);

    ppd->hDlg = hDlg;

    // IDD_PAGELIST should definitely exist
    ppd->hwndTabs = GetDlgItem(hDlg, IDD_PAGELIST);
    ASSERT(ppd->hwndTabs);
    TabCtrl_SetItemExtra(ppd->hwndTabs, CB_ITEMEXTRA);

    // nStartPage is either ppd->psh.H_nStartPage or the page pStartPage
    nStartPage = ppd->psh.H_nStartPage;
    if (ppd->psh.dwFlags & PSH_USEPSTARTPAGE)
    {
        nStartPage = 0;                 // Assume we don't find the page
        pStartPage = ppd->psh.H_pStartPage;

        if (IS_INTRESOURCE(pStartPage))
        {
            szStartPage[0] = TEXT('\0');
            LoadString(ppd->psh.hInstance, (UINT)LOWORD(pStartPage),
                       szStartPage, ARRAYSIZE(szStartPage));
            pStartPage = szStartPage;
        }
    }

#ifndef WINDOWS_ME
    tie.tci.mask = TCIF_TEXT | TCIF_PARAM | TCIF_IMAGE;
#endif
    tie.hwndPage = NULL;
    tie.tci.pszText = pi.szCaption;
    tie.state = 0;

    SendMessage(ppd->hwndTabs, WM_SETREDRAW, FALSE, 0L);

    // load langid we chose for frame dialog template
    ppd->wFrameLang =  LANGIDFROMLCID(CCGetProperThreadLocale(NULL));
    
        // it's charset that really matters to font
    ppd->iFrameCharset = GetDefaultCharsetFromLang(ppd->wFrameLang);
    
    langidMUI = GetMUILanguage();

    for (uPages = 0; uPages < ppd->psh.nPages; uPages++)
    {
        PISP  pisp = GETPISP(ppd, uPages);

        if (GetPageInfoEx(ppd, pisp, &pi, langidMUI, GPI_ALL))
        {
            Prsht_ComputeIdealPageSize(ppd, pisp, &pi);

            // Add the page to the end of the tab list

            tie.tci.iImage = -1;
#ifdef WINDOWS_ME
            tie.tci.mask = TCIF_TEXT | TCIF_PARAM | TCIF_IMAGE | (pi.bRTL ? TCIF_RTLREADING : 0);
#endif
            if (pi.hIcon) {
                if (!himl) {
                    UINT flags = ILC_MASK;
                    if(IS_WINDOW_RTL_MIRRORED(ppd->hwndTabs)) {
                        flags |= ILC_MIRROR;
                    }    
                    himl = ImageList_Create(g_cxSmIcon, g_cySmIcon, flags, 8, 4);
                    TabCtrl_SetImageList(ppd->hwndTabs, himl);
                }

                tie.tci.iImage = ImageList_AddIcon(himl, pi.hIcon);
                // QUESTION raymondc - we always destroy even if PSP_USEHICON?
                DestroyIcon(pi.hIcon);
            }

            // QUESTION? What if this fails? Do we want to destroy the page?
            if (TabCtrl_InsertItem(ppd->hwndTabs, 1000, &tie.tci) >= 0)
            {
                // Nothing to do; all the code that was here got moved elsewhere
            }

            // remember if any page wants premature init
            if (pisp->_psp.dwFlags & PSP_PREMATURE)
                fPrematurePages = TRUE;

            // if the user is specifying the startpage via title, check it here
            if ((ppd->psh.dwFlags & PSH_USEPSTARTPAGE) &&
                !lstrcmpi(pStartPage, pi.szCaption))
            {
                nStartPage = uPages;
#ifdef DEBUG
                fStartPageFound = TRUE;
#endif
            }
        }
        else
        {
            DebugMsg(DM_ERROR, TEXT("PropertySheet failed to GetPageInfo"));
            RemovePropPageData(ppd, uPages--);
        }
    }

    SendMessage(ppd->hwndTabs, WM_SETREDRAW, TRUE, 0L);

    if (ppd->psh.pfnCallback) {
#ifdef WX86
        if (ppd->fFlags & PD_WX86)
            Wx86Callback(ppd->psh.pfnCallback, hDlg, PSCB_INITIALIZED, 0);
        else
#endif
            ppd->psh.pfnCallback(hDlg, PSCB_INITIALIZED, 0);
    }

    //
    // Now compute the size of the tab control.
    //

    // First get the rectangle for the whole dialog
    GetWindowRect(hDlg, &rcDlg);
    
    // For WIZARD_LITE style wizards, we stretch the tabs page and sunken divider
    // to cover the whole wizard (without the border)
    if (ppd->psh.dwFlags & PSH_WIZARD_LITE)
    {
        // Stretch the divider to the whole width of the wizard
        RECT rcDiv, rcDlgClient;
        HWND hDiv;

        // we allow both PSH_WIZARD and PSH_WIZARD_LITE to be set
        // it's exactly the same as setting just PSH_WIZARD_LITE
        RIPMSG(!(ppd->psh.dwFlags & PSH_WIZARD97),
               "Cannot combine PSH_WIZARD_LITE with PSH_WIZARD97");

        // but some people do it anyway, so turn off
        ppd->psh.dwFlags &= ~PSH_WIZARD97;

        // NOTE: GetDlgItemRect returns a rectangle relative to hDlg
        hDiv = GetDlgItemRect(hDlg, IDD_DIVIDER, &rcDiv);
        if (hDiv)
            SetWindowPos(hDiv, NULL, 0, rcDiv.top, RECTWIDTH(rcDlg),
                         RECTHEIGHT(rcDiv), SWP_NOZORDER | SWP_NOACTIVATE);

        GetClientRect(hDlg, &rcDlgClient);
        
        // Stretch the page list control to cover the whole wizard client area above
        // the divider
        SetWindowPos(ppd->hwndTabs, NULL, 0, 0, RECTWIDTH(rcDlgClient),
                     rcDiv.top, SWP_NOZORDER | SWP_NOACTIVATE);
    }

    //
    //  While we're thinking about it, don't let people set both
    //  WIZARD97IE4 *and* WIZARD97IE5.  That's just way too strange.
    //
    if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
        ppd->psh.dwFlags &= ~PSH_WIZARD97IE5;

    // Get the rectangle of the pagelist control in pixels.
    GetClientRect(ppd->hwndTabs, &rcOrigTabs);
    ppd->sizMin.cx = rcOrigTabs.right;
    ppd->sizMin.cy = rcOrigTabs.bottom;

    // Compute rcPage = Size of page area in pixels
    // For now, we only care about interior pages; we'll deal with exterior
    // pages later.
    rcPage.left = rcPage.top = 0;
    Prsht_GetIdealPageSize(ppd, (SIZE *)&rcPage.right, GIPS_SKIPEXTERIOR97HEIGHT);

    //
    //  IE4's Wizard97 assumed that all exterior pages were exactly
    //  DEFAULTHEADERHEIGHT dlu's taller than interior pages.  That's
    //  right, DEFAULTHEADERHEIGHT is a pixel count, but IE4 messed up
    //  and used it as a dlu count here.
    //
    if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
    {
        SIZE sizT;
        SetRect(&rcMinSize, 0, 0, 0, DEFAULTHEADERHEIGHT);
        MapDialogRect(hDlg, &rcMinSize);
        Prsht_GetIdealPageSize(ppd, &sizT, GIPS_SKIPINTERIOR97HEIGHT);
        if (rcPage.bottom < sizT.cy - rcMinSize.bottom)
            rcPage.bottom = sizT.cy - rcMinSize.bottom;
    }

    // Now compute the minimum size for the page region
    rcMinSize = rcPage;

    //
    //  If this is a wizard then set the size of the page area to the entire
    //  size of the control.  If it is a normal property sheet then adjust for
    //  the tabs, resize the control, and then compute the size of the page
    //  region only.
    //
    if (IS_WIZARD(ppd))
        // initialize
        rcPage = rcMinSize;
    else
    {
        int i;
        RECT rcAdjSize;

        // initialize

        for (i = 0; i < 2; i++) {
            rcAdjSize = rcMinSize;
            TabCtrl_AdjustRect(ppd->hwndTabs, TRUE, &rcAdjSize);

            rcAdjSize.right  -= rcAdjSize.left;
            rcAdjSize.bottom -= rcAdjSize.top;
            rcAdjSize.left = rcAdjSize.top = 0;

            if (rcAdjSize.right < rcMinSize.right)
                rcAdjSize.right = rcMinSize.right;
            if (rcAdjSize.bottom < rcMinSize.bottom)
                rcAdjSize.bottom = rcMinSize.bottom;

            SetWindowPos(ppd->hwndTabs, NULL, 0,0, rcAdjSize.right, rcAdjSize.bottom,
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
        rcPage = rcMinSize = rcAdjSize;
        TabCtrl_AdjustRect(ppd->hwndTabs, FALSE, &rcPage);
    }
    //
    // rcMinSize now contains the size of the control, including the tabs, and
    // rcPage is the rect containing the page portion (without the tabs).
    //

    // For wizard97:
    // Now we have the correct width for our wizard, let's compute the
    // header height based on that, shift the tab window and the pages
    // window down accordingly.
    //
    dyGrow = 0;
    if (ppd->psh.dwFlags & PSH_WIZARD97)
    {
        RECT rcTabs;
        SIZE sizT;

        // NOTE: we don't directly use rcPage because the verticle position for
        // ppd->hwndTabs is not determined, yet, even though the horizontal is
        // already computed. Therefore, we can only use rcPageCopy.right not
        // rcPageCopy.bottom in the following code.
        RECT rcTemp;
        CopyRect(&rcTemp, &rcPage);
        MapWindowPoints(ppd->hwndTabs, hDlg, (LPPOINT)&rcTemp, 2);

        GetWindowRect(ppd->hwndTabs, &rcTabs);
        MapWindowRect(NULL, hDlg, &rcTabs);

        // Set the header fonts first because we need to use the bold font
        // to compute the title height
        _SetHeaderFonts(hDlg, ppd);

        // Adjust the header height
        ppd->cyHeaderHeight = _ComputeHeaderHeight(ppd, rcTemp.right);

        // Since the app can change the subheader text on the fly,
        // our computation of the header height might end up wrong later.
        // Allow ISVs to precompensate for that by setting their exterior
        // pages larger than the interior pages by the amount they want
        // to reserve.  
        // So if the largest external page is larger than the largest internal
        // page, then expand to enclose the external pages too.
        // IE4 Wizard97 didn't do this and MFC relies on the bug.

        if (!(ppd->psh.dwFlags & PSH_WIZARD97IE4))
        {
            // A margin of 7dlu's is placed above the page, and another
            // margin of 7 dlu's is placed below.
            SetRect(&rcTemp, 0, 0, 0, 7+7);
            MapDialogRect(hDlg, &rcTemp);

            Prsht_GetIdealPageSize(ppd, &sizT, GIPS_SKIPINTERIOR97HEIGHT);

            if (ppd->cyHeaderHeight < sizT.cy - RECTHEIGHT(rcPage) - rcTemp.bottom)
                ppd->cyHeaderHeight = sizT.cy - RECTHEIGHT(rcPage) - rcTemp.bottom;
        }

        // Move the tab window right under the header
        dyGrow += ppd->cyHeaderHeight;
        SetWindowPos(ppd->hwndTabs, NULL, rcTabs.left, rcTabs.top + dyGrow,
                     RECTWIDTH(rcTabs), RECTHEIGHT(rcTabs), SWP_NOZORDER | SWP_NOACTIVATE);
    }

    //
    // Resize the dialog to make room for the control's new size.  This can
    // only grow the size.
    //
    dxGrow = rcMinSize.right - rcOrigTabs.right;
    dxDlg  = rcDlg.right - rcDlg.left + dxGrow;
    dyGrow += rcMinSize.bottom - rcOrigTabs.bottom;
    dyDlg  = rcDlg.bottom - rcDlg.top + dyGrow;

    //
    // Cascade property sheet windows (only for comctl32 and commctrl)
    //

    //
    // HACK: Putting CW_USEDEFAULT in dialog template does not work because
    //  CreateWindowEx ignores it unless the window has WS_OVERLAPPED, which
    //  is not appropriate for a property sheet.
    //
    {
        const TCHAR c_szStatic[] = TEXT("Static");
        UINT swp = SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE;
        if (!IsWindow(ppd->psh.hwndParent)) {
            HWND hwndT = CreateWindowEx(0, c_szStatic, NULL,
                                        WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT,
                                        0, 0, NULL, NULL, HINST_THISDLL, NULL);
            if (hwndT) {
                GetWindowRect(hwndT, &rcDlg);
                swp = SWP_NOZORDER | SWP_NOACTIVATE;
                DestroyWindow(hwndT);
            }
        } else {
            GetWindowRect(ppd->psh.hwndParent, &rcDlg);
            if (IsWindowVisible(ppd->psh.hwndParent)) {
                bMirrored = IS_WINDOW_RTL_MIRRORED(ppd->psh.hwndParent);
                
                rcDlg.top += g_cySmIcon;
                if(bMirrored)
                {
                    rcDlg.left = rcDlg.right - g_cxSmIcon - dxDlg;
                }
                else
                {
                    rcDlg.left += g_cxSmIcon;
                }    
            }
            swp = SWP_NOZORDER | SWP_NOACTIVATE;
        }
        hMonitor = MonitorFromWindow(hDlg, MONITOR_DEFAULTTONEAREST);
        mMonitorInfo.cbSize = sizeof(MONITORINFO);
        if (GetMonitorInfo(hMonitor, &mMonitorInfo))
        {
            if (mMonitorInfo.rcMonitor.right < (rcDlg.left + dxDlg))
            {
                // Move the Window left.
                rcDlg.left = mMonitorInfo.rcMonitor.right - dxDlg;
            }
            if (mMonitorInfo.rcMonitor.left > rcDlg.left)
            {
                // Move the Window Right.
                rcDlg.left = mMonitorInfo.rcMonitor.left;
            }
            if (mMonitorInfo.rcMonitor.bottom < (rcDlg.top + dyDlg))
            {
                // Move the Window Up.
                rcDlg.top = mMonitorInfo.rcMonitor.bottom - dyDlg;
            }
            if (mMonitorInfo.rcMonitor.top > rcDlg.top)
            {
                // Move the Window Down.
                rcDlg.top = mMonitorInfo.rcMonitor.top;
            }
        }
        SetWindowPos(hDlg, NULL, rcDlg.left, rcDlg.top, dxDlg, dyDlg, swp);
    }

    // Now we'll figure out where the page needs to start relative
    // to the bottom of the tabs.
    MapWindowRect(ppd->hwndTabs, hDlg, &rcPage);

    ppd->xSubDlg  = rcPage.left;
    ppd->ySubDlg  = rcPage.top;
    ppd->cxSubDlg = rcPage.right - rcPage.left;
    ppd->cySubDlg = rcPage.bottom - rcPage.top;

    //
    // move all the buttons down as needed and turn on appropriate buttons
    // for a wizard.
    //
    {
        RECT rcCtrl;
        HWND hCtrl;
        const int *pids;

        if (ppd->psh.dwFlags & PSH_WIZARD97)
        {
            hCtrl = GetDlgItemRect(hDlg, IDD_TOPDIVIDER, &rcCtrl);
            if (hCtrl)
                SetWindowPos(hCtrl, NULL, rcCtrl.left, ppd->cyHeaderHeight,
                             RECTWIDTH(rcCtrl) + dxGrow, RECTHEIGHT(rcCtrl), SWP_NOZORDER | SWP_NOACTIVATE);
        }

        if (IS_WIZARD(ppd)) {
            pids = WizIDs;

            hCtrl = GetDlgItemRect(hDlg, IDD_DIVIDER, &rcCtrl);
            if (hCtrl)
                SetWindowPos(hCtrl, NULL, rcCtrl.left, rcCtrl.top + dyGrow,
                             RECTWIDTH(rcCtrl) + dxGrow, RECTHEIGHT(rcCtrl),
                             SWP_NOZORDER | SWP_NOACTIVATE);

            EnableWindow(GetDlgItem(hDlg, IDD_BACK), TRUE);
            ppd->idDefaultFallback = IDD_NEXT;
        } else {
            pids = IDs;
            ppd->idDefaultFallback = IDOK;
        }


        // first move everything over by the same amount that
        // the dialog grew by.

        // If we flipped the buttons, it should be aligned to the left
        // No move needed
        MoveAllButtons(hDlg, pids, IDHELP, ppd->fFlipped ? 0 : dxGrow, dyGrow);
            

        // If there's no help, then remove the help button.
        if (!(ppd->psh.dwFlags & PSH_HASHELP)) {
            RemoveButton(hDlg, IDHELP, pids);
        }

        // If we are not a wizard, and we should NOT show apply now
        if ((ppd->psh.dwFlags & PSH_NOAPPLYNOW) &&
            !IS_WIZARD(ppd))
        {
            RemoveButton(hDlg, IDD_APPLYNOW, pids);
        }

        if (IS_WIZARD(ppd) &&
            (!(ppd->psh.dwFlags & PSH_WIZARDHASFINISH)))
        {
            DWORD dwStyle=0;

            RemoveButton(hDlg, IDD_FINISH, pids);

            // if there's no finish button showing, we need to place it where
            // the next button is
            GetWindowRect(GetDlgItem(hDlg, IDD_NEXT), &rcCtrl);
            MapWindowPoints(HWND_DESKTOP, hDlg, (LPPOINT)&rcCtrl, 2);
            SetWindowPos(GetDlgItem(hDlg, IDD_FINISH), NULL, rcCtrl.left, rcCtrl.top,
                         RECTWIDTH(rcCtrl), RECTHEIGHT(rcCtrl), SWP_NOZORDER | SWP_NOACTIVATE);
        }

    }

    // (dli) compute the Pattern Brush for the watermark
    // Note: This is done here because we need to know the size of the big dialog in
    // case the user wants to stretch the bitmap
    if (ppd->psh.dwFlags & PSH_WIZARD97)
    {
        int cx, cy;
        ASSERT(ppd->hbmHeader == NULL);
        ASSERT(ppd->hbmWatermark == NULL);

        //
        //  WIZARD97IE4 disabled the watermark and header bitmap
        //  if high contrast was turned on.
        //
        if (ppd->psh.dwFlags & PSH_WIZARD97IE4) {
            HIGHCONTRAST hc = {sizeof(hc)};
            if (SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0) &&
                (hc.dwFlags & HCF_HIGHCONTRASTON)) {
                ppd->psh.dwFlags &= ~(PSH_WATERMARK | PSH_USEHBMWATERMARK |
                                      PSH_USEHPLWATERMARK |
                                      PSH_HEADER | PSH_USEHBMHEADER);
            }
        }

        if ((ppd->psh.dwFlags & PSH_WATERMARK) && ppd->psh.H_hbmWatermark)
        {
            // Compute dimensions of final bitmap, which may be slightly
            // goofy due to stretching

            cx = cy = 0;            // Assume no stretching
            if (ppd->psh.dwFlags & PSH_STRETCHWATERMARK) {
                RECT rc;
                if (ppd->psh.dwFlags & PSH_WIZARD97IE4) {
                    // The WIZARD97IE4 watermark covers the entire dialog
                    if (GetDlgItemRect(hDlg, IDD_DIVIDER, &rc)) {
                        cx = dxDlg;
                        cy = rc.top;
                    }
                } else {
                    // The WIZARD97IE5 watermark does not stretch
                    // (Too many people passed this flag when converting
                    // from WIZARD97IE4 to WIZARD97IE5 and relied on
                    // the nonstretchability.)
                }
            }

            if (ppd->psh.dwFlags & PSH_USEHBMWATERMARK)
            {
                // LR_COPYRETURNORG means "If no stretching was needed,
                // then just return the original bitmap unaltered."
                // Note that we need special cleanup if a stretch occurred.
                ppd->hbmWatermark = (HBITMAP)CopyImage(ppd->psh.H_hbmWatermark,
                            IMAGE_BITMAP, cx, cy, LR_COPYRETURNORG);
            }
            else
            {
                ppd->hbmWatermark = (HBITMAP)LoadImage(ppd->psh.hInstance,
                        ppd->psh.H_pszbmWatermark,
                        IMAGE_BITMAP, cx, cy, LR_CREATEDIBSECTION);
            }

            if (ppd->hbmWatermark)
            {
                // If app provides custom palette, then use it,
                // else create one based on the bmp.  (And if the bmp
                // doesn't have a palette, PaletteFromBmp will use the
                // halftone palette.)

                if (ppd->psh.dwFlags & PSH_USEHPLWATERMARK)
                    ppd->hplWatermark = ppd->psh.hplWatermark;
                else
                    ppd->hplWatermark = PaletteFromBmp(ppd->hbmWatermark);

                // And WIZARD97IE4 needs to turn it into a bitmap brush.
                if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
                    ppd->hbrWatermark = CreatePatternBrush(ppd->hbmWatermark);

            }

        }

        if ((ppd->psh.dwFlags & PSH_HEADER) && ppd->psh.H_hbmHeader)
        {
            cx = cy = 0;            // Assume no stretching
            if (ppd->psh.dwFlags & PSH_STRETCHWATERMARK) {
                if (ppd->psh.dwFlags & PSH_WIZARD97IE4) {
                    // The WIZARD97IE4 header covers the entire header
                    cx = dxDlg;
                    cy = ppd->cyHeaderHeight;
                } else {
                    // The WIZARD97IE5 header does not stretch
                    // (Too many people passed this flag when converting
                    // from WIZARD97IE4 to WIZARD97IE5 and relied on
                    // the nonstretchability.)
                }
            }

            if (ppd->psh.dwFlags & PSH_USEHBMHEADER)
            {
                // LR_COPYRETURNORG means "If no stretching was needed,
                // then just return the original bitmap unaltered."
                // Note that we need special cleanup if a stretch occurred.
                ppd->hbmHeader = (HBITMAP)CopyImage(ppd->psh.H_hbmHeader,
                            IMAGE_BITMAP, cx, cy, LR_COPYRETURNORG);
            }
            else
            {
                ppd->hbmHeader = (HBITMAP)LoadImage(ppd->psh.hInstance,
                        ppd->psh.H_pszbmHeader,
                        IMAGE_BITMAP, cx, cy, LR_CREATEDIBSECTION);
            }

            // And WIZARD97IE4 needs to turn it into a bitmap brush.
            if (ppd->hbmHeader && (ppd->psh.dwFlags & PSH_WIZARD97IE4))
                ppd->hbrHeader = CreatePatternBrush(ppd->hbmHeader);

        }
        else
        {
            // In case the user does not specify a header bitmap
            // use the top portion of the watermark
            ppd->hbmHeader = ppd->hbmWatermark;
            ppd->hbrHeader = ppd->hbrWatermark;
        }

    }


    // force the dialog to reposition itself based on its new size

    SendMessage(hDlg, DM_REPOSITION, 0, 0L);

    // do this here instead of using DS_SETFOREGROUND so we don't hose
    // pages that do things that want to set the foreground window
    SetForegroundWindow(hDlg);

    // We set this to 1 if the user saves any changes.
    // do this before initting or switching to any pages
    ppd->nReturn = 0;

    // AppHack - Some people forgot to initialize nStartPage, and they were
    // lucky that the garbage value on the stack was zero.  Lucky no longer.
    if (nStartPage >= ppd->psh.nPages) {
        RIPMSG(0, "App forgot to initialize PROPSHEETHEADER.nStartPage field, assuming zero");
        nStartPage = 0;
    }

    // Now attempt to select the starting page.
    TabCtrl_SetCurSel(ppd->hwndTabs, nStartPage);
    PageChange(ppd, 1);

    // Now init any other pages that require it
    if (fPrematurePages)
    {
        int nPage;

        tie.tci.mask = TCIF_PARAM;
        for (nPage = 0; nPage < (int)ppd->psh.nPages; nPage++)
        {
            PISP pisp = GETPISP(ppd, nPage);

            if (!(pisp->_psp.dwFlags & PSP_PREMATURE))
                continue;

            TabCtrl_GetItem(ppd->hwndTabs, nPage, &tie.tci);

            if (tie.hwndPage)
                continue;

            if ((tie.hwndPage = _CreatePage(ppd, pisp, hDlg, langidMUI)) == NULL)
            {
                RemovePropPageData(ppd, nPage--);
                continue;
            }

            TabCtrl_SetItem(ppd->hwndTabs, nPage, &tie.tci);
        }
    }
}

HWND _Ppd_GetPage(LPPROPDATA ppd, int nItem)
{
    if (ppd->hwndTabs)
    {
        TC_ITEMEXTRA tie;
        tie.tci.mask = TCIF_PARAM;
        TabCtrl_GetItem(ppd->hwndTabs, nItem, &tie.tci);
        return tie.hwndPage;
    }
    return NULL;
}

BOOL _Ppd_IsPageHidden(LPPROPDATA ppd, int nItem)
{
    if (ppd->hwndTabs)
    {
        TCITEM tci;
        tci.mask = TCIF_STATE;
        tci.dwStateMask = TCIS_HIDDEN;
        if (TabCtrl_GetItem(ppd->hwndTabs, nItem, &tci))
            return tci.dwState;
    }
    return FALSE;
}

LRESULT _Ppd_SendNotify(LPPROPDATA ppd, int nItem, int code, LPARAM lParam)
{
    PSHNOTIFY pshn;

    pshn.lParam = lParam;
    return SendNotifyEx(_Ppd_GetPage(ppd,nItem), ppd->hDlg, code, (LPNMHDR)&pshn, FALSE);
}

//
//  dwFind = 0 means just move to the current item + iAutoAdjust
//  dwFind != 0 means it's a dialog resource identifier we should look for
//
int FindPageIndex(LPPROPDATA ppd, int nCurItem, ULONG_PTR dwFind, LONG_PTR iAutoAdj)
{
    LRESULT nActivate;

    if (dwFind == 0) {
        nActivate = nCurItem + iAutoAdj;
        if (((UINT)nActivate) <= ppd->psh.nPages) {
            return((int)nActivate);
        }
    } else {
        for (nActivate = 0; (UINT)nActivate < ppd->psh.nPages; nActivate++) {
            if ((DWORD_PTR)GETPPSP(ppd, nActivate)->P_pszTemplate == dwFind) {
                return((int)nActivate);
            }
        }
    }
    return(-1);
}

//
//  If hpage != NULL, then return the index of the page which matches it,
//  or -1 on failure.
//
int FindPageIndexByHpage(LPPROPDATA ppd, HPROPSHEETPAGE hpage)
{
    int i;

    //
    //  Notice that we explicitly do not do a InternalizeHPROPSHEETPAGE,
    //  because the app might be passing us garbage.  We just want to
    //  say "Nope, can't find garbage here, sorry."
    //

    for (i = ppd->psh.nPages - 1; i >= 0; i--) {
        if (hpage == GETHPAGE(ppd, i))
            break;
    }
    return i;
}


// This WM_NEXTDLGCTL stuff works, except for ACT!4.0 which faults randomly
// I don't know why.  The USER people said that removing a
// SetFocus(NULL) call from SetDlgFocus works, but I tried that
// and the app merely faulted in a different place.  so I'm going
// back to the old IE4 way, which means that there are scenarios
// where the DEFID can get out of sync with reality.
#undef WM_NEXTDLGCTL_WORKS

#ifdef WM_NEXTDLGCTL_WORKS

//
//  Helper function that manages dialog box focus in a manner that keeps
//  USER in the loop, so we don't get "two buttons both with the bold
//  defpushbutton border" problems.
//
//  We have to use WM_NEXTDLGCTL to fix defid problems, such as this one:
//
//      Right-click My Computer, Properties.
//      Go to Advanced tab. Click Environment Variables.
//      Click New. Type a name for a new dummy environment variable.
//      Click OK.
//
//  At this point (with the old code), the "New" button is a DEFPUSHBUTTON,
//  but the DEFID is IDOK.  The USER folks said I should use WM_NEXTDLGCTL
//  to avoid this problem.  But using WM_NEXTDLGCTL introduces its own big
//  hairy mess of problems.  All the code in this function aside from the
//  SendMessage(WM_NEXTDLGCTL) are to work around "quirks" in WM_NEXTDLGCTL
//  or workarounds for app bugs.
//
//  THIS CODE IS SUBTLE AND QUICK TO ANGER!
//
void SetDlgFocus(LPPROPDATA ppd, HWND hwndFocus)
{
    //
    //  HACK!  It's possible that by the time we get around to changing
    //  the dialog focus, the dialog box doesn't have focus any more!
    //  This happens because PSM_SETWIZBUTTONS is a posted message, so
    //  it can arrive *after* focus has moved elsewhere (e.g., to a
    //  MessageBox).
    //
    //  There is no way to update the dialog box focus without
    //  letting it change the real focus (another "quirk" of
    //  WM_NEXTDLGCTL), so instead we remember who used to have the
    //  focus, let the dialog box do its focus goo, and then restore
    //  the focus as necessary.
    //
    HWND hwndFocusPrev = GetFocus();

    //  If focus belonged to a window within our property sheet, then
    //  let the dialog box code push the focus around.  Otherwise,
    //  focus belonged to somebody outside our property sheet, so
    //  remember to restore it after we're done.

    if (hwndFocusPrev && IsChild(ppd->hDlg, hwndFocusPrev))
        hwndFocusPrev = NULL;

    //  USER forgot to revalidate hwndOldFocus at this point, so we have
    //  to exit USER (by returning to comctl32) then re-enter USER
    //  (in the SendMessage below) so parameter validation will happen
    //  again.  Sigh.

    //
    //  Bug in Win9x and NT:  WM_NEXTDLGCTL will crash if the previous
    //  focus window destroys itself in response to WM_KILLFOCUS.
    //  (WebTurbo by NetMetrics does this.)  There's a missed
    //  revalidation so USER ends up using a window handle after
    //  it has been destroyed.  Oops.
    //
    //  (The NT folks consider this "Won't fix, because the system stays
    //  up; just the app crashes".  The 9x folks will try to get the fix
    //  into Win98 OSR.)
    //

    //
    //  Do a manual SetFocus here to make the old focus (if any)
    //  do all its WM_KILLFOCUS stuff, and possibly destroy itself (grrr).
    //
    //  We have to SetFocus to NULL because some apps (e.g.,
    //  Visual C 6.0 setup) do funky things on SetFocus, and our early
    //  SetFocus interferes with the EM_SETSEL that WM_NEXTDLGCTL will
    //  do later.
    //
    //  APP HACK 2:  But not if the target focus is the same as the
    //  curreng focus, because ACT!4.0 crashes if it receives a
    //  WM_KILLFOCUS when it is not expecting one.

    if (hwndFocus != GetFocus())
        SetFocus(NULL);

    //
    //  Note that by manually shoving the focus around, we
    //  have gotten focus and DEFPUSHBUTTON and DEFID all out
    //  of sync, which is exactly the problem we're trying to
    //  avoid!  Fortunately, USER also contains special
    //  recovery code to handle the case where somebody "mistakenly" called
    //  SetFocus() to change the focus.  (I put "mistakenly" in quotes because
    //  in this case, we did it on purpose.)
    //

    SendMessage(ppd->hDlg, WM_NEXTDLGCTL, (WPARAM)hwndFocus, MAKELPARAM(TRUE, 0));

    //
    //  If WM_NEXTDLGCTL damaged the focus, fix it.
    //
    if (hwndFocusPrev)
        SetFocus(hwndFocusPrev);
}
#endif

void SetNewDefID(LPPROPDATA ppd)
{
    HWND hDlg = ppd->hDlg;
    HWND hwndFocus;
    hwndFocus = GetNextDlgTabItem(ppd->hwndCurPage, NULL, FALSE);
    ASSERT(hwndFocus);
    if (hwndFocus) {
#ifndef WM_NEXTDLGCTL_WORKS
        int id;
        if (((DWORD)SendMessage(hwndFocus, WM_GETDLGCODE, 0, 0L)) & DLGC_HASSETSEL)
        {
            // select the text
            Edit_SetSel(hwndFocus, 0, -1);
        }

        id = GetDlgCtrlID(hwndFocus);
#endif

        //
        //  See if the handle give to us by GetNextDlgTabItem was any good.
        //  (For compatibility reasons, if the dialog contains no tabstops,
        //  it returns the first item.)
        //
        if ((GetWindowLong(hwndFocus, GWL_STYLE) & (WS_VISIBLE | WS_DISABLED | WS_TABSTOP)) == (WS_VISIBLE | WS_TABSTOP))
        {
            //
            //  Give the page a chance to change the default focus.
            //
            HWND hwndT = (HWND)_Ppd_SendNotify(ppd, ppd->nCurItem, PSN_QUERYINITIALFOCUS, (LPARAM)hwndFocus);

            // The window had better be valid and a child of the page.
            if (hwndT && IsWindow(hwndT) && IsChild(ppd->hwndCurPage, hwndT))
            {
                hwndFocus = hwndT;
            }
        }
        else
        {
            // in prop sheet mode, focus on tabs,
            // in wizard mode, tabs aren't visible, go to idDefFallback
            if (IS_WIZARD(ppd))
                hwndFocus = GetDlgItem(hDlg, ppd->idDefaultFallback);
            else
                hwndFocus = ppd->hwndTabs;
        }

#ifdef WM_NEXTDLGCTL_WORKS
        //
        //  Aw-right.  Go for it.
        //
        SetDlgFocus(ppd, hwndFocus);

        //
        //  Hack for MFC:  MFC relies on DM_SETDEFID to know when to
        //  update its wizard buttons.
        //
        SendMessage(hDlg, DM_SETDEFID, SendMessage(hDlg, DM_GETDEFID, 0, 0), 0);
#else
        SetFocus(hwndFocus);
        ResetWizButtons(ppd);
        if (SendDlgItemMessage(ppd->hwndCurPage, id, WM_GETDLGCODE, 0, 0L) & DLGC_UNDEFPUSHBUTTON)
            SendMessage(ppd->hwndCurPage, DM_SETDEFID, id, 0);
        else {
            SendMessage(hDlg, DM_SETDEFID, ppd->idDefaultFallback, 0);
        }
#endif
    }
}


/*
 ** we are about to change pages.  what a nice chance to let the current
 ** page validate itself before we go away.  if the page decides not
 ** to be de-activated, then this'll cancel the page change.
 **
 ** return TRUE iff this page failed validation
 */
BOOL PageChanging(LPPROPDATA ppd)
{
    BOOL bRet = FALSE;
    if (ppd && ppd->hwndCurPage)
    {
        bRet = BOOLFROMPTR(_Ppd_SendNotify(ppd, ppd->nCurItem, PSN_KILLACTIVE, 0));
    }
    return bRet;
}

void PageChange(LPPROPDATA ppd, int iAutoAdj)
{
    HWND hwndCurPage;
    HWND hwndCurFocus;
    int nItem;
    HWND hDlg, hwndTabs;

    TC_ITEMEXTRA tie;
    UINT FlailCount = 0;
    LRESULT lres;

    if (!ppd)
    {
        return;
    }

    hDlg = ppd->hDlg;
    hwndTabs = ppd->hwndTabs;

    // NOTE: the page was already validated (PSN_KILLACTIVE) before
    // the actual page change.

    hwndCurFocus = GetFocus();

TryAgain:
    FlailCount++;
    if (FlailCount > ppd->psh.nPages)
    {
        DebugMsg(DM_TRACE, TEXT("PropSheet PageChange attempt to set activation more than 10 times."));
        return;
    }

    nItem = TabCtrl_GetCurSel(hwndTabs);
    if (nItem < 0)
    {
        return;
    }

    tie.tci.mask = TCIF_PARAM;

    TabCtrl_GetItem(hwndTabs, nItem, &tie.tci);
    hwndCurPage = tie.hwndPage;

    if (!hwndCurPage)
    {
        if ((hwndCurPage = _CreatePage(ppd, GETPISP(ppd, nItem), hDlg, GetMUILanguage())) == NULL)
        {
            /* Should we put up some sort of error message here?
             */
            RemovePropPageData(ppd, nItem);
            TabCtrl_SetCurSel(hwndTabs, 0);
            goto TryAgain;
        }

        // tie.tci.mask    = TCIF_PARAM;
        tie.hwndPage = hwndCurPage;
        TabCtrl_SetItem(hwndTabs, nItem, &tie.tci);

        if (HIDEWIZ97HEADER(ppd, nItem))
            // Subclass for back ground watermark painting.
            SetWindowSubclass(hwndCurPage, WizardWndProc, 0, (DWORD_PTR)ppd);
    }

    // THI WAS REMOVED as part of the fix for bug 18327.  The problem is we need to
    // send a SETACTIVE message to a page if it is being activated.
    //    if (ppd->hwndCurPage == hwndCurPage)
    //    {
    //        /* we should be done at this point.
    //        */
    //        return;
    //    }

    /* Size the dialog and move it to the top of the list before showing
     ** it in case there is size specific initializing to be done in the
     ** GETACTIVE message.
     */

    if (IS_WIZARD(ppd))
    {
        HWND hwndTopDivider= GetDlgItem(hDlg, IDD_TOPDIVIDER);

        if (ppd->psh.dwFlags & PSH_WIZARD97)
        {
            HWND hwndDivider;
            RECT rcDlg, rcDivider;
            GetClientRect(hDlg, &rcDlg);

            hwndDivider = GetDlgItemRect(hDlg, IDD_DIVIDER, &rcDivider);
            if (hwndDivider)
                SetWindowPos(hwndDivider, NULL, rcDlg.left, rcDivider.top,
                             RECTWIDTH(rcDlg), RECTHEIGHT(rcDivider),
                             SWP_NOZORDER | SWP_NOACTIVATE);

            if (GETPPSP(ppd, nItem)->dwFlags & PSP_HIDEHEADER)
            {
                // In this case, we give the whole dialog box except for the portion under the
                // Bottom divider to the property page
                RECT rcTopDivider;
                ShowWindow(hwndTopDivider, SW_HIDE);
                ShowWindow(ppd->hwndTabs, SW_HIDE);

                hwndTopDivider = GetDlgItemRect(hDlg, IDD_DIVIDER, &rcTopDivider);
                SetWindowPos(hwndCurPage, HWND_TOP, rcDlg.left, rcDlg.top, RECTWIDTH(rcDlg), rcTopDivider.top - rcDlg.top, 0);
            }
            else
            {
                ShowWindow(hwndTopDivider, SW_SHOW);
                ShowWindow(ppd->hwndTabs, SW_SHOW);
                SetWindowPos(hwndCurPage, HWND_TOP, ppd->xSubDlg, ppd->ySubDlg, ppd->cxSubDlg, ppd->cySubDlg, 0);
            }
        }
        else
        {
            ShowWindow(hwndTopDivider, SW_HIDE);
            SetWindowPos(hwndCurPage, HWND_TOP, ppd->xSubDlg, ppd->ySubDlg, ppd->cxSubDlg, ppd->cySubDlg, 0);
        }
    } else {
        RECT rcPage;
        GetClientRect(ppd->hwndTabs, &rcPage);
        TabCtrl_AdjustRect(ppd->hwndTabs, FALSE, &rcPage);
        MapWindowPoints(ppd->hwndTabs, hDlg, (LPPOINT)&rcPage, 2);
        SetWindowPos(hwndCurPage, HWND_TOP, rcPage.left, rcPage.top,
                     rcPage.right - rcPage.left, rcPage.bottom - rcPage.top, 0);
    }

    /* We want to send the SETACTIVE message before the window is visible
     ** to minimize on flicker if it needs to update fields.
     */

    //
    //  If the page returns non-zero from the PSN_SETACTIVE call then
    //  we will set the activation to the resource ID returned from
    //  the call and set activation to it.      This is mainly used by wizards
    //  to skip a step.
    //
    lres = _Ppd_SendNotify(ppd, nItem, PSN_SETACTIVE, 0);

    if (lres) {
        int iPageIndex = FindPageIndex(ppd, nItem,
                                       (lres == -1) ? 0 : lres, iAutoAdj);


        if ((lres == -1) &&
            (nItem == iPageIndex || iPageIndex >= TabCtrl_GetItemCount(hwndTabs))) {
            iPageIndex = ppd->nCurItem;
        }

        if (iPageIndex != -1) {
            TabCtrl_SetCurSel(hwndTabs, iPageIndex);
            ShowWindow(hwndCurPage, SW_HIDE);
            goto TryAgain;
        }
    }

    if (ppd->psh.dwFlags & PSH_HASHELP) {
        // PSH_HASHELP controls the "Help" button at the bottom
        // PSH_NOCONTEXTHELP controls the caption "?" button
        Button_Enable(GetDlgItem(hDlg, IDHELP),
                      (BOOL)(GETPPSP(ppd, nItem)->dwFlags & PSP_HASHELP));
    }

    //
    //  If this is a wizard then we'll set the dialog's title to the tab
    //  title.
    //
    if (IS_WIZARD(ppd)) {
        TC_ITEMEXTRA tie;
        TCHAR szTemp[128 + 50];
        szTemp[0] = 0;

        tie.tci.mask = TCIF_TEXT;
        tie.tci.pszText = szTemp;
        tie.tci.cchTextMax = ARRAYSIZE(szTemp);
        if (TabCtrl_GetItem(hwndTabs, nItem, &tie.tci))
        {
#ifdef WINDOWS_ME
            tie.tci.mask = TCIF_RTLREADING;
            tie.tci.cchTextMax = 0;
            // hack, use cchTextMax to query tab item reading order
            TabCtrl_GetItem(hwndTabs, nItem, &tie.tci);
            if( (ppd->psh.dwFlags & PSH_RTLREADING) || (tie.tci.cchTextMax))
                SetWindowLong(hDlg, GWL_EXSTYLE, GetWindowLong(hDlg, GWL_EXSTYLE) | WS_EX_RTLREADING);       
            else
                SetWindowLong(hDlg, GWL_EXSTYLE, GetWindowLong(hDlg, GWL_EXSTYLE) & ~WS_EX_RTLREADING);                   
#endif // WINDOWS_ME

            if (szTemp[0])
                SetWindowText(hDlg, szTemp);
        }
    }

    /* Disable all erasebkgnd messages that come through because windows
     ** are getting shuffled.  Note that we need to call ShowWindow (and
     ** not show the window in some other way) because DavidDs is counting
     ** on the correct parameters to the WM_SHOWWINDOW message, and we may
     ** document how to keep your page from flashing.
     */
    ppd->fFlags |= PD_NOERASE;
    ShowWindow(hwndCurPage, SW_SHOW);
    if (ppd->hwndCurPage && (ppd->hwndCurPage != hwndCurPage))
    {
        ShowWindow(ppd->hwndCurPage, SW_HIDE);
    }
    ppd->fFlags &= ~PD_NOERASE;

    ppd->hwndCurPage = hwndCurPage;
    ppd->nCurItem = nItem;

    /* Newly created dialogs seem to steal the focus, so we steal it back
     ** to the page list, which must have had the focus to get to this
     ** point.  If this is a wizard then set the focus to the dialog of
     ** the page.  Otherwise, set the focus to the tabs.
     */
    if (hwndCurFocus != hwndTabs)
    {
        SetNewDefID(ppd);
    }
    else
    {
        // The focus may have been stolen from us, bring it back
        SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hwndTabs, (LPARAM)TRUE);
    }

    // make sure the header is repaint
    if ((ppd->psh.dwFlags & PSH_WIZARD97) && (!(GETPPSP(ppd, nItem)->dwFlags & PSP_HIDEHEADER)))
        InvalidateRect(hDlg, NULL,TRUE);
}

#define DECLAREWAITCURSOR  HCURSOR hcursor_wait_cursor_save
#define SetWaitCursor()   hcursor_wait_cursor_save = SetCursor(LoadCursor(NULL, IDC_WAIT))
#define ResetWaitCursor() SetCursor(hcursor_wait_cursor_save)

//
// HACKHACK (reinerf)
//
// This function sends the PSN_LASTCHANCEAPPLY right after the property sheets have had "ok"
// pressed. This allows the "General" tab on the file/folder properties to do a rename, so that
// it wont rename the file out from under the other pages, and have them barf when they go to
// persist their info.
//
void SendLastChanceApply(LPPROPDATA ppd)
{
    TC_ITEMEXTRA tie;
    int nItem;
    int nItems = TabCtrl_GetItemCount(ppd->hwndTabs);

    tie.tci.mask = TCIF_PARAM;

    // we start with the last tab and count towards the first. This ensures
    // that the more important tabs (such as the "General" tab) will be the last
    // to recieve the PSN_LASTCHANCEAPPLY message.
    for (nItem = nItems - 1; nItem >= 0; nItem--)
    {
        TabCtrl_GetItem(ppd->hwndTabs, nItem, &tie.tci);

        if (tie.hwndPage)
        {
            // we ignore the return vale from the PSN_LASTCHANCEAPPLY message since
            // there are probably prop sheet extensions that return both TRUE and
            // FALSE for messages that they dont process...(sigh)
            _Ppd_SendNotify(ppd, nItem, PSN_LASTCHANCEAPPLY, (LPARAM)TRUE);
        }
    }
}


#ifdef MAINWIN
EXTERN_C HKEY HKEY_ROOT;
#endif

// return TRUE iff all sheets successfully handle the notification
BOOL ButtonPushed(LPPROPDATA ppd, WPARAM wParam)
{
    HWND hwndTabs;
    int nItems, nItem;
    int nNotify;
    TC_ITEMEXTRA tie;
    BOOL bExit = FALSE;
    int nReturnNew = ppd->nReturn;
    int fSuccess = TRUE;
    DECLAREWAITCURSOR;
    LRESULT lres = 0;
    LPARAM lParam = FALSE;
    LPARAM nButtonPressed = 0;

    switch (wParam)
    {
        case IDOK:
            nButtonPressed = PSBTN_OK;
            lParam = TRUE;
            bExit = TRUE;
            // Fall through...

        case IDD_APPLYNOW:
            if (IDD_APPLYNOW == wParam)
            {
                nButtonPressed = PSBTN_APPLYNOW;
            }

            // First allow the current dialog to validate itself.
            if (_Ppd_SendNotify(ppd, ppd->nCurItem, PSN_KILLACTIVE, 0))
                return FALSE;

            nReturnNew = 1;

            nNotify = PSN_APPLY;
            break;

        case IDCLOSE:
            nButtonPressed = PSBTN_FINISH;
            lParam = TRUE;
            // fall through
        case IDCANCEL:
            if (IDCANCEL == wParam)
            {
                nButtonPressed = PSBTN_CANCEL;
            }
            bExit = TRUE;
            nNotify = PSN_RESET;
            break;

        default:
            return FALSE;
    }

    if (ppd && ppd->psh.pfnCallback && nButtonPressed)
    {
        ppd->psh.pfnCallback(NULL, PSCB_BUTTONPRESSED, nButtonPressed);
    }

    SetWaitCursor();

    hwndTabs = ppd->hwndTabs;

    tie.tci.mask = TCIF_PARAM;

    nItems = TabCtrl_GetItemCount(hwndTabs);
    for (nItem = 0; nItem < nItems; ++nItem)
    {

        TabCtrl_GetItem(hwndTabs, nItem, &tie.tci);

        if (tie.hwndPage)
        {
            /* If the dialog fails a PSN_APPY call (by returning TRUE),
             ** then it has invalid information on it (should be verified
             ** on the PSN_KILLACTIVE, but that is not always possible)
             ** and we want to abort the notifications.  We select the failed
             ** page below.
             */
            lres = _Ppd_SendNotify(ppd, nItem, nNotify, lParam);

            if (lres)
            {
                fSuccess = FALSE;
                bExit = FALSE;
                break;
            } else {
                // if we need a restart (Apply or OK), then this is an exit
                if ((nNotify == PSN_APPLY) && !bExit && ppd->nRestart) {
                    DebugMsg(DM_TRACE, TEXT("PropertySheet: restart flags force close"));
                    bExit = TRUE;
                }
            }

            /* We have either reset or applied, so everything is
             ** up to date.
             */
            tie.state &= ~FLAG_CHANGED;
            // tie.tci.mask = TCIF_PARAM;    // already set
            TabCtrl_SetItem(hwndTabs, nItem, &tie.tci);
        }
    }

#ifdef MAINWIN
    // This is a temporary solution for saving the
    // registry options incase IE doesnot shutdown
    // normaly.
    if( nNotify == PSN_APPLY )
        RegSaveKey(HKEY_ROOT, NULL, NULL);
#endif

    /* If we leave ppd->hwndCurPage as NULL, it will tell the main
     ** loop to exit.
     */
    if (fSuccess)
    {
        ppd->hwndCurPage = NULL;
    }
    else if (lres != PSNRET_INVALID_NOCHANGEPAGE)
    {
        // Need to change to the page that caused the failure.
        // if lres == PSN_INVALID_NOCHANGEPAGE, then assume sheet has already
        // changed to the page with the invalid information on it
        TabCtrl_SetCurSel(hwndTabs, nItem);
    }

    if (fSuccess)
    {
        // Set to the cached value
        ppd->nReturn = nReturnNew;
    }

    if (!bExit)
    {
        // before PageChange, so ApplyNow gets disabled faster.
        if (fSuccess)
        {
            TCHAR szOK[30];
            HWND hwndApply;

            if (!IS_WIZARD(ppd)) {
                // The ApplyNow button should always be disabled after
                // a successfull apply/cancel, since no change has been made yet.
                hwndApply = GetDlgItem(ppd->hDlg, IDD_APPLYNOW);
                Button_SetStyle(hwndApply, BS_PUSHBUTTON, TRUE);
                EnableWindow(hwndApply, FALSE);
                ResetWizButtons(ppd);
                SendMessage(ppd->hDlg, DM_SETDEFID, IDOK, 0);
                ppd->idDefaultFallback = IDOK;
            }

            // Undo PSM_CANCELTOCLOSE for the same reasons.
            if (ppd->fFlags & PD_CANCELTOCLOSE)
            {
                ppd->fFlags &= ~PD_CANCELTOCLOSE;
                LocalizedLoadString(IDS_OK, szOK, ARRAYSIZE(szOK));
                SetDlgItemText(ppd->hDlg, IDOK, szOK);
                EnableWindow(GetDlgItem(ppd->hDlg, IDCANCEL), TRUE);
            }
        }

        /* Re-"select" the current item and get the whole list to
         ** repaint.
         */
        if (lres != PSNRET_INVALID_NOCHANGEPAGE)
            PageChange(ppd, 1);
    }

    ResetWaitCursor();

    return(fSuccess);
}

//  Win3.1 USER didn't handle DM_SETDEFID very well-- it's very possible to get
//  multiple buttons with the default button style look.  This has been fixed
//  for Win95, but the Setup wizard needs this hack when running from 3.1.

// it seems win95 doesn't handle it well either..
void ResetWizButtons(LPPROPDATA ppd)
{
    int id;

    if (IS_WIZARD(ppd)) {

        for (id = 0; id < ARRAYSIZE(WizIDs); id++)
            SendDlgItemMessage(ppd->hDlg, WizIDs[id], BM_SETSTYLE, BS_PUSHBUTTON, TRUE);
    }
}

void SetWizButtons(LPPROPDATA ppd, LPARAM lParam)
{
    int idDef;
    int iShowID = IDD_NEXT;
    int iHideID = IDD_FINISH;
    BOOL bEnabled;
    BOOL bResetFocus;
    HWND hwndShow;
    HWND hwndFocus = GetFocus();
    HWND hwndHide;
    HWND hwndBack;
    HWND hDlg = ppd->hDlg;

    idDef = (int)LOWORD(SendMessage(hDlg, DM_GETDEFID, 0, 0));

    // Enable/Disable the IDD_BACK button
    hwndBack = GetDlgItem(hDlg, IDD_BACK);
    bEnabled = (lParam & PSWIZB_BACK) != 0;
    EnableWindow(hwndBack, bEnabled);

    // Enable/Disable the IDD_NEXT button, and Next gets shown by default
    // bEnabled remembers whether hwndShow should be enabled or not
    hwndShow = GetDlgItem(hDlg, IDD_NEXT);
    bEnabled = (lParam & PSWIZB_NEXT) != 0;
    EnableWindow(hwndShow, bEnabled);

    // Enable/Disable Show/Hide the IDD_FINISH button
    if (lParam & (PSWIZB_FINISH | PSWIZB_DISABLEDFINISH)) {
        iShowID = IDD_FINISH;           // If Finish is being shown
        iHideID = IDD_NEXT;             // then Next isn't

        hwndShow = GetDlgItem(hDlg, IDD_FINISH);
        bEnabled = (lParam & PSWIZB_FINISH) != 0;
        EnableWindow(hwndShow, bEnabled);
    }

    if (!(ppd->psh.dwFlags & PSH_WIZARDHASFINISH)) {
        hwndHide = GetDlgItem(hDlg, iHideID);
        ShowWindow(hwndHide, SW_HIDE);
        // Cannot disable the window; see Prsht_ButtonSubclassProc for explanation.
        // WRONG - EnableWindow(hwndHide, FALSE);

        hwndShow = GetDlgItem(hDlg, iShowID);
        // Cannot disable the window; see Prsht_ButtonSubclassProc for explanation.
        // WRONG - EnableWindow(hwndShow, bEnabled);
        ShowWindow(hwndShow, SW_SHOW);
    }


    // bResetFocus keeps track of whether or not we need to set Focus to our button
    bResetFocus = FALSE;
    if (hwndFocus)
    {
        // if the dude that has focus is a button, we want to steal focus away
        // so users can just press enter all the way through a property sheet,
        // getting the default as they go. this also catches the case
        // of where focus is on one of our buttons which was turned off.
        if (SendMessage(hwndFocus, WM_GETDLGCODE, 0, 0L) & (DLGC_UNDEFPUSHBUTTON|DLGC_DEFPUSHBUTTON))
            bResetFocus = TRUE;
    }
    if (!bResetFocus)
    {
        // if there is no focus or we're focused on an invisible/disabled
        // item on the sheet, grab focus.
        bResetFocus = !hwndFocus ||  !IsWindowVisible(hwndFocus) || !IsWindowEnabled(hwndFocus) ;
    }

    // We used to do this code only if we nuked a button which had default
    // or if bResetFocus. Unfortunately, some wizards turn off BACK+NEXT
    // and then when they turn them back on, they want DEFID on NEXT.
    // So now we always reset DEFID.
    {
        static const int ids[4] = { IDD_NEXT, IDD_FINISH, IDD_BACK, IDCANCEL };
        int i;
        HWND hwndNewFocus = NULL;

        for (i = 0; i < ARRAYSIZE(ids); i++) {
            hwndNewFocus = GetDlgItem(hDlg, ids[i]);

            // can't do IsVisible because we may be doing this
            // before the prop sheet as a whole is shown
            if ((GetWindowLong(hwndNewFocus, GWL_STYLE) & WS_VISIBLE) &&
                IsWindowEnabled(hwndNewFocus)) {
                hwndFocus = hwndNewFocus;
                break;
            }
        }

        ppd->idDefaultFallback = ids[i];
        if (bResetFocus) {
            if (!hwndNewFocus)
                hwndNewFocus = hDlg;
#ifdef WM_NEXTDLGCTL_WORKS
            SetDlgFocus(ppd, hwndNewFocus);
#else
            // 337614 - Since PSM_SETWIZBUTTONS is often a posted message,
            // we may end up here when we don't even have focus at all
            // (caller went on and called MessageBox or something before
            // we got a chance to set the buttons).  So do this only if
            // focus belongs to our dialog box (or if it's nowhere).
            hwndFocus = GetFocus();
            if (!hwndFocus || (ppd->hDlg == hwndFocus || IsChild(ppd->hDlg, hwndFocus)))
                SetFocus(hwndNewFocus);
#endif
        }
        ResetWizButtons(ppd);
        SendMessage(hDlg, DM_SETDEFID, ids[i], 0);

    }
}

//
//  lptie = NULL means "I don't care about the other goop, just give me
//  the index."
//
int FindItem(HWND hwndTabs, HWND hwndPage,  TC_ITEMEXTRA * lptie)
{
    int i;
    TC_ITEMEXTRA tie;

    if (!lptie)
    {
        tie.tci.mask = TCIF_PARAM;
        lptie = &tie;
    }

    for (i = TabCtrl_GetItemCount(hwndTabs) - 1; i >= 0; --i)
    {
        TabCtrl_GetItem(hwndTabs, i, &lptie->tci);

        if (lptie->hwndPage == hwndPage)
        {
            break;
        }
    }

    //this will be -1 if the for loop falls out.
    return i;
}

// a page is telling us that something on it has changed and thus
// "Apply Now" should be enabled

void PageInfoChange(LPPROPDATA ppd, HWND hwndPage)
{
    int i;
    TC_ITEMEXTRA tie;

    tie.tci.mask = TCIF_PARAM;
    i = FindItem(ppd->hwndTabs, hwndPage, &tie);

    if (i == -1)
        return;

    if (!(tie.state & FLAG_CHANGED))
    {
        // tie.tci.mask = TCIF_PARAM;    // already set
        tie.state |= FLAG_CHANGED;
        TabCtrl_SetItem(ppd->hwndTabs, i, &tie.tci);
    }

    if (ppd->fAllowApply)
        EnableWindow(GetDlgItem(ppd->hDlg, IDD_APPLYNOW), TRUE);
}

// a page is telling us that everything has reverted to its last
// saved state.

void PageInfoUnChange(LPPROPDATA ppd, HWND hwndPage)
{
    int i;
    TC_ITEMEXTRA tie;

    tie.tci.mask = TCIF_PARAM;
    i = FindItem(ppd->hwndTabs, hwndPage, &tie);

    if (i == -1)
        return;

    if (tie.state & FLAG_CHANGED)
    {
        tie.state &= ~FLAG_CHANGED;
        TabCtrl_SetItem(ppd->hwndTabs, i, &tie.tci);
    }

    // check all the pages, if none are FLAG_CHANGED, disable IDD_APLYNOW
    for (i = ppd->psh.nPages-1 ; i >= 0 ; i--)
    {
        if (!TabCtrl_GetItem(ppd->hwndTabs, i, &tie.tci))
            break;
        if (tie.state & FLAG_CHANGED)
            break;
    }
    if (i<0)
        EnableWindow(GetDlgItem(ppd->hDlg, IDD_APPLYNOW), FALSE);
}

HDWP Prsht_RepositionControl(LPPROPDATA ppd, HWND hwnd, HDWP hdwp,
                             int dxMove, int dyMove, int dxSize, int dySize)
{
    if (hwnd) {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        MapWindowRect(HWND_DESKTOP, ppd->hDlg, &rc);
        hdwp = DeferWindowPos(hdwp, hwnd, NULL,
                    rc.left + dxMove, rc.top + dyMove,
                    RECTWIDTH(rc) + dxSize, RECTHEIGHT(rc) + dySize,
                    SWP_NOZORDER | SWP_NOACTIVATE);
    }
    return hdwp;
}

//
//  dxSize/(dySize+dyMove) is the amount by which to resize the tab control.
//  dxSize/dySize controls how much the dialog should be grown.
//  Buttons move by (dxSize, dySize+dyMove).
//

BOOL Prsht_ResizeDialog(LPPROPDATA ppd, int dxSize, int dySize, int dyMove)
{
    BOOL fChanged = dxSize || dySize || dyMove;
    if (fChanged)
    {
        int dxMove = 0;     // To make the code more symmetric in x and y
        int dxAll = dxSize + dxMove;
        int dyAll = dySize + dyMove;
        RECT rc;
        UINT i;
        const int *rgid;
        UINT cid;
        HDWP hdwp;
        HWND hwnd;

        // Use DeferWindowPos to avoid flickering.  We expect to move
        // the tab control, up to five buttons, two possible dividers,
        // plus the current page.  (And a partridge in a pear tree.)
        //

        hdwp = BeginDeferWindowPos(1 + 5 + 2 + 1);

        // The tab control just sizes.
        hdwp = Prsht_RepositionControl(ppd, ppd->hwndTabs, hdwp,
                                       0, 0, dxAll, dyAll);

        //
        //  Move and size the current page.  We can't trust its location
        //  or size, since PageChange shoves it around without updating
        //  ppd->ySubDlg.
        //
        if (ppd->hwndCurPage) {
            hdwp = DeferWindowPos(hdwp, ppd->hwndCurPage, NULL,
                        ppd->xSubDlg, ppd->ySubDlg,
                        ppd->cxSubDlg, ppd->cySubDlg,
                        SWP_NOZORDER | SWP_NOACTIVATE);
        }

        //
        //  And our buttons just move by both the size and move (since they
        //  lie below both the tabs and the pages).
        //
        if (IS_WIZARD(ppd)) {
            //
            //  Ooh, wait, reposition the separator lines, too.
            //  Moves vertically but resizes horizontally.
            //
            hwnd = GetDlgItem(ppd->hDlg, IDD_DIVIDER);
            hdwp = Prsht_RepositionControl(ppd, hwnd, hdwp,
                                           0, dyAll, dxAll, 0);

            //
            //  The top divider does not move vertically since it lies
            //  above the area that is changing.
            //
            hwnd = GetDlgItem(ppd->hDlg, IDD_TOPDIVIDER);
            hdwp = Prsht_RepositionControl(ppd, hwnd, hdwp,
                                           0, 0, dxAll, 0);

            rgid = WizIDs;
            cid = ARRAYSIZE(WizIDs);
        } else {
            rgid = IDs;
            cid = ARRAYSIZE(IDs);
        }

        for (i = 0 ; i < cid; i++)
        {
            hwnd = GetDlgItem(ppd->hDlg, rgid[i]);
            hdwp = Prsht_RepositionControl(ppd, hwnd, hdwp,
                                           dxAll, dyAll, 0, 0);
        }

        // All finished sizing and moving.  Let 'er rip!
        if (hdwp)
            EndDeferWindowPos(hdwp);

        // Grow ourselves as well
        GetWindowRect(ppd->hDlg, &rc);
        SetWindowPos(ppd->hDlg, NULL, 0, 0,
                     RECTWIDTH(rc) + dxAll, RECTHEIGHT(rc) + dyAll,
                     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    }
    return fChanged;
}

BOOL Prsht_RecalcPageSizes(LPPROPDATA ppd)
{
    SIZE siz;
    int dxSize = 0, dySize = 0, dyMove = 0;

    // After inserting or removing a page, the tab control may have
    // changed height.  If so, then we need to resize ourselves to
    // accomodate the growth or shrinkage, so that all the tabs remain
    // visible.
    //
    // APP COMPAT!  We cannot do this by default because Jamba 1.1
    // **FAULTS** if the property sheet changes size after creation.
    // Grrrrrr...

    // Wizards don't have a visible tab control,
    // so do this only for non-wizards
    if (!IS_WIZARD(ppd))
    {
        RECT rc;

        // Get the client rect of the tab control in dialog coords
        GetClientRect(ppd->hwndTabs, &rc);
        MapWindowRect(ppd->hwndTabs, ppd->hDlg, &rc);

        // See how many rows there are now
        TabCtrl_AdjustRect(ppd->hwndTabs, FALSE, &rc);

        // rc.top is the new ySubDlg.  Compute the amount we have to move.
        dyMove = rc.top - ppd->ySubDlg;
        ppd->ySubDlg = rc.top;
    }

    Prsht_GetIdealPageSize(ppd, &siz, GIPS_SKIPEXTERIOR97HEIGHT);
    dxSize = siz.cx - ppd->cxSubDlg;
    dySize = siz.cy - ppd->cySubDlg;
    ppd->cxSubDlg = siz.cx;
    ppd->cySubDlg = siz.cy;
    return Prsht_ResizeDialog(ppd, dxSize, dySize, dyMove);
}

//
//  InsertPropPage
//
//  hpage is the page being inserted.
//
//  hpageInsertAfter described where it should be inserted.
//
//  hpageInsertAfter can be...
//
//      MAKEINTRESOURCE(index) to insert at a specific index.
//
//      NULL to insert at the beginning
//
//      an HPROPSHEETPAGE to insert *after* that page
//
BOOL InsertPropPage(LPPROPDATA ppd, PSP * hpageInsertAfter,
                                PSP * hpage)
{
    TC_ITEMEXTRA tie;
    int nPage;
    HIMAGELIST himl;
    PAGEINFOEX pi;
    PISP pisp;
    int idx;

    hpage = _Hijaak95Hack(ppd, hpage);

    if (!hpage)
        return FALSE;

    if (ppd->psh.nPages >= MAXPROPPAGES)
        return FALSE; // we're full

    if (IS_INTRESOURCE(hpageInsertAfter))
    {
        // Inserting by index
        idx = (int) PtrToLong(hpageInsertAfter);

        // Attempting to insert past the end is the same as appending.
        if (idx > (int)ppd->psh.nPages)
            idx = (int)ppd->psh.nPages;
    }
    else
    {
        // Inserting by hpageInsertAfter.
        for (idx = 0; idx < (int)(ppd->psh.nPages); idx++) {
            if (hpageInsertAfter == GETHPAGE(ppd, idx))
                break;
        }

        if (idx >= (int)(ppd->psh.nPages))
            return FALSE; // hpageInsertAfter not found

        idx++; // idx Points to the insertion location (to the right of hpageInsertAfter)
        ASSERT(hpageInsertAfter == GETHPAGE(ppd, idx-1));
    }

    ASSERT(idx <= (int)(ppd->psh.nPages+1));

    // Shift all pages adjacent to the insertion point to the right
    for (nPage=ppd->psh.nPages - 1; nPage >= idx; nPage--)
        SETPISP(ppd, nPage+1, GETPISP(ppd, nPage));

    // Insert the new page
    pisp = InternalizeHPROPSHEETPAGE(hpage);
    SETPISP(ppd, idx, pisp);

    ppd->psh.nPages++;

    himl = TabCtrl_GetImageList(ppd->hwndTabs);

    if (!GetPageInfoEx(ppd, pisp, &pi, GetMUILanguage(),
                       GPI_ICON | GPI_BRTL | GPI_CAPTION | GPI_FONT | GPI_DIALOGEX))
    {
        DebugMsg(DM_ERROR, TEXT("InsertPropPage: GetPageInfo failed"));
        goto bogus;
    }

    Prsht_ComputeIdealPageSize(ppd, pisp, &pi);

#ifndef WINDOWS_ME
    tie.tci.mask = TCIF_TEXT | TCIF_PARAM | TCIF_IMAGE;
#else
    tie.tci.mask = TCIF_TEXT | TCIF_PARAM | TCIF_IMAGE | (pi.bRTL ? TCIF_RTLREADING : 0);
#endif
    tie.hwndPage = NULL;
    tie.tci.pszText = pi.szCaption;
    tie.state = 0;


    if (pi.hIcon) {
        if (himl)
            tie.tci.iImage = ImageList_AddIcon(himl, pi.hIcon);
        DestroyIcon(pi.hIcon);
    } else {
        tie.tci.iImage = -1;
    }

    // Insert the page into the tab list
    TabCtrl_InsertItem(ppd->hwndTabs, idx, &tie.tci);

    // If this page wants premature initialization then init it
    // do this last so pages can rely on "being there" at init time
    if (pisp->_psp.dwFlags & PSP_PREMATURE)
    {
        if ((tie.hwndPage = _CreatePage(ppd, pisp, ppd->hDlg, GetMUILanguage())) == NULL)
        {
            TabCtrl_DeleteItem(ppd->hwndTabs, idx);
            // don't free the pisp here let the caller do it
            // REARCHITECT raymondc - but caller doesn't know if hIcon has been destroyed
            goto bogus;
        }

        tie.tci.mask = TCIF_PARAM;
        TabCtrl_SetItem(ppd->hwndTabs, idx, &tie.tci);
    }

    // Adjust the internally track current item if it is to the right of our insertion point
    if (ppd->nCurItem >= idx)
        ppd->nCurItem++;

    return TRUE;

bogus:
    // Shift everything back
    for (nPage=idx; nPage < (int)(ppd->psh.nPages-1); nPage++)
        SETPISP(ppd, nPage, GETPISP(ppd, nPage+1));

    ppd->psh.nPages--;
    return FALSE;
}

#define AddPropPage(ppd, hpage) InsertPropPage(ppd, (LPVOID)MAKEINTRESOURCE(-1), hpage)

// removes property sheet hpage (index if NULL)
void RemovePropPage(LPPROPDATA ppd, int index, HPROPSHEETPAGE hpage)
{
    int i = -1;
    BOOL fReturn = TRUE;
    TC_ITEMEXTRA tie;

    //
    //  Notice that we explicitly do not do a InternalizeHPROPSHEETPAGE,
    //  because the app might be passing us garbage.  We just want to
    //  say "Nope, can't find garbage here, sorry."
    //

    tie.tci.mask = TCIF_PARAM;
    if (hpage) {
        i = FindPageIndexByHpage(ppd, hpage);
    }
    if (i == -1) {
        i = index;

        // this catches i < 0 && i >= (int)(ppd->psh.nPages)
        if ((UINT)i >= ppd->psh.nPages)
        {
            DebugMsg(DM_ERROR, TEXT("RemovePropPage: invalid page"));
            return;
        }
    }

    index = TabCtrl_GetCurSel(ppd->hwndTabs);
    if (i == index) {
        // if we're removing the current page, select another (don't worry
        // about this page having invalid information on it -- we're nuking it)
        PageChanging(ppd);

        if (index == 0)
            index++;
        else
            index--;

        if (SendMessage(ppd->hwndTabs, TCM_SETCURSEL, index, 0L) == -1) {
            // if we couldn't select (find) the new one, punt to 0th
            SendMessage(ppd->hwndTabs, TCM_SETCURSEL, 0, 0L);
        }
        PageChange(ppd, 1);
    }

    // REARCHITECT if removing a page below ppd->nCurItem, need to update
    // nCurItem to prevent it from getting out of sync with hwndCurPage?

    tie.tci.mask = TCIF_PARAM;
    TabCtrl_GetItem(ppd->hwndTabs, i, &tie.tci);
    if (tie.hwndPage) {
        if (ppd->hwndCurPage == tie.hwndPage)
            ppd->hwndCurPage = NULL;
        DestroyWindow(tie.hwndPage);
    }

    RemovePropPageData(ppd, i);
}

void RemovePropPageData(LPPROPDATA ppd, int nPage)
{
    ULONG_PTR dw = PropPageActivateContext(ppd, GETPISP(ppd, nPage));
    TabCtrl_DeleteItem(ppd->hwndTabs, nPage);
    DestroyPropertySheetPage(GETHPAGE(ppd, nPage));
    PropPageDeactivateContext(dw); 

    //
    //  Delete the HPROPSHEETPAGE from our table and slide everybody down.
    //
    ppd->psh.nPages--;
    hmemcpy(&ppd->psh.H_phpage[nPage], &ppd->psh.H_phpage[nPage + 1],
            sizeof(ppd->psh.H_phpage[0]) * (ppd->psh.nPages - nPage));
}

// returns TRUE iff the page was successfully set to index/hpage
// Note:  The iAutoAdj should be set to 1 or -1.  This value is used
//        by PageChange if a page refuses a SETACTIVE to either increment
//        or decrement the page index.
BOOL PageSetSelection(LPPROPDATA ppd, int index, HPROPSHEETPAGE hpage,
                                  int iAutoAdj)
{
    int i = -1;
    BOOL fReturn = FALSE;
    TC_ITEMEXTRA tie;

    tie.tci.mask = TCIF_PARAM;
    if (hpage) {
        for (i = ppd->psh.nPages - 1; i >= 0; i--) {
            if (hpage == GETHPAGE(ppd, i))
                break;
        }
    }
    if (i == -1) {
        if (index == -1)
            return FALSE;

        i = index;
    }
    if (i >= MAXPROPPAGES)
    {
        // don't go off the end of our HPROPSHEETPAGE array
        return FALSE;
    }

    fReturn = !PageChanging(ppd);
    if (fReturn)
    {
        index = TabCtrl_GetCurSel(ppd->hwndTabs);
        if (SendMessage(ppd->hwndTabs, TCM_SETCURSEL, i, 0L) == -1) {
            // if we couldn't select (find) the new one, fail out
            // and restore the old one
            SendMessage(ppd->hwndTabs, TCM_SETCURSEL, index, 0L);
            fReturn = FALSE;
        }
        PageChange(ppd, iAutoAdj);
    }
    return fReturn;
}

LRESULT QuerySiblings(LPPROPDATA ppd, WPARAM wParam, LPARAM lParam)
{
    UINT i;
    for (i = 0 ; i < ppd->psh.nPages ; i++)
    {
        HWND hwndSibling = _Ppd_GetPage(ppd, i);
        if (hwndSibling)
        {
            LRESULT lres = SendMessage(hwndSibling, PSM_QUERYSIBLINGS, wParam, lParam);
            if (lres)
                return lres;
        }
    }
    return FALSE;
}

// REVIEW HACK This gets round the problem of having a hotkey control
// up and trying to enter the hotkey that is already in use by a window.
BOOL HandleHotkey(LPARAM lparam)
{
    WORD wHotkey;
    TCHAR szClass[32];
    HWND hwnd;

    // What hotkey did the user type hit?
    wHotkey = (WORD)SendMessage((HWND)lparam, WM_GETHOTKEY, 0, 0);
    // Were they typing in a hotkey window?
    hwnd = GetFocus();
    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    if (lstrcmp(szClass, HOTKEY_CLASS) == 0)
    {
        // Yes.
        SendMessage(hwnd, HKM_SETHOTKEY, wHotkey, 0);
        return TRUE;
    }
    return FALSE;
}


//
//  Function handles Next and Back functions for wizards.  The code will
//  be either PSN_WIZNEXT or PSN_WIZBACK
//
BOOL WizNextBack(LPPROPDATA ppd, int code)
{
    LRESULT   dwFind;
    int iPageIndex;
    int iAutoAdj = (code == PSN_WIZNEXT) ? 1 : -1;

    dwFind = _Ppd_SendNotify(ppd, ppd->nCurItem, code, 0);

    if (dwFind == -1) {
        return(FALSE);
    }

    iPageIndex = FindPageIndex(ppd, ppd->nCurItem, dwFind, iAutoAdj);

    if (iPageIndex == -1) {
        return(FALSE);
    }

    return(PageSetSelection(ppd, iPageIndex, NULL, iAutoAdj));
}

BOOL Prsht_OnCommand(LPPROPDATA ppd, int id, HWND hwndCtrl, UINT codeNotify)
{

    //
    //  There's a bug in USER that when the user highlights a defpushbutton
    //  and presses ENTER, the WM_COMMAND is sent to the top-level dialog
    //  (i.e., the property sheet) instead of to the parent of the button.
    //  So if a property sheet page has a control whose ID coincidentally
    //  matches any of our own, we will think it's ours instead of theirs.
    if (hwndCtrl && GetParent(hwndCtrl) != ppd->hDlg)
        goto Forward;

    if (!hwndCtrl)
        hwndCtrl = GetDlgItem(ppd->hDlg, id);

    switch (id) {

        case IDCLOSE:
        case IDCANCEL:
            if (_Ppd_SendNotify(ppd, ppd->nCurItem, PSN_QUERYCANCEL, 0) == 0) {
                ButtonPushed(ppd, id);
            }
            break;

        case IDD_APPLYNOW:
        case IDOK:
            if (!IS_WIZARD(ppd)) {

                //ButtonPushed returns true if and only if all pages have processed PSN_LASTCHANCEAPPLY
                if (ButtonPushed(ppd, id))
                {

                    //Everyone has processed the PSN_APPLY Message.  Now send PSN_LASTCHANCEAPPLY message.

                    //
                    // HACKHACK (reinerF)
                    //
                    // We send out a private PSN_LASTCHANCEAPPLY message telling all the pages
                    // that everyone is done w/ the apply. This is needed for pages who have to do
                    // something after every other page has applied. Currently, the "General" tab
                    // of the file properties needs a last-chance to rename files as well as new print
                    // dialog in  comdlg32.dll.
                    SendLastChanceApply(ppd);
                }
            }
            break;


        case IDHELP:
            if (IsWindowEnabled(hwndCtrl))
            {
                _Ppd_SendNotify(ppd, ppd->nCurItem, PSN_HELP, 0);
            }
            break;

        case IDD_FINISH:
        {
            HWND hwndNewFocus;
            EnableWindow(ppd->hDlg, FALSE);
            hwndNewFocus = (HWND)_Ppd_SendNotify(ppd, ppd->nCurItem, PSN_WIZFINISH, 0);
            // b#11346 - dont let multiple clicks on FINISH.
            if (!hwndNewFocus)
            {
                ppd->hwndCurPage = NULL;
                ppd->nReturn = 1;
            }
            else
            {
                EnableWindow(ppd->hDlg, TRUE);
                if (IsWindow(hwndNewFocus) && IsChild(ppd->hDlg, hwndNewFocus))
#ifdef WM_NEXTDLGCTL_WORKS
                    SetDlgFocus(ppd, hwndNewFocus);
#else
                    SetFocus(hwndNewFocus);
#endif
            }
        }
        break;

        case IDD_NEXT:
        case IDD_BACK:
            ppd->idDefaultFallback = id;
            WizNextBack(ppd, id == IDD_NEXT ? PSN_WIZNEXT : PSN_WIZBACK);
            break;

        default:
Forward:
            FORWARD_WM_COMMAND(_Ppd_GetPage(ppd, ppd->nCurItem), id, hwndCtrl, codeNotify, SendMessage);
    }

    return TRUE;
}

BOOL Prop_IsDialogMessage(LPPROPDATA ppd, LPMSG32 pmsg32)
{
    // Don't fault if we don't have a pointer...
    if (!pmsg32)
        return FALSE;

    if ((pmsg32->message == WM_KEYDOWN) && (GetKeyState(VK_CONTROL) < 0))
    {
        BOOL bBack = FALSE;

        switch (pmsg32->wParam) {
            case VK_TAB:
                bBack = GetKeyState(VK_SHIFT) < 0;
                break;

            case VK_PRIOR:  // VK_PAGE_UP
            case VK_NEXT:   // VK_PAGE_DOWN
                bBack = (pmsg32->wParam == VK_PRIOR);
                break;

            default:
                goto NoKeys;
        }

        //notify of navigation key usage
        SendMessage(ppd->hDlg, WM_CHANGEUISTATE, 
            MAKELONG(UIS_CLEAR, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);

        if (IS_WIZARD(ppd))
        {
            int idWiz;
            int idDlg;
            HWND hwnd;

            if (bBack) {
                idWiz = PSN_WIZBACK;
                idDlg = IDD_BACK;
            } else {
                idWiz = PSN_WIZNEXT;
                idDlg = IDD_NEXT;
            }

            hwnd = GetDlgItem(ppd->hDlg, idDlg);
            if (IsWindowVisible(hwnd) && IsWindowEnabled(hwnd))
                WizNextBack(ppd, idWiz);
        }
        else
        {
            int iStart = TabCtrl_GetCurSel(ppd->hwndTabs);
            int iCur;

            //
            //  Skip over hidden tabs, but don't go into an infinite loop.
            //
            iCur = iStart;
            do {
                // tab in reverse if shift is down
                if (bBack)
                    iCur += (ppd->psh.nPages - 1);
                else
                    iCur++;

                iCur %= ppd->psh.nPages;
            } while (_Ppd_IsPageHidden(ppd, iCur) && iCur != iStart);
            PageSetSelection(ppd, iCur, NULL, 1);
        }
        return TRUE;
    }
NoKeys:

    //
    //  Since we now send out a PSN_TRANSLATEACCELERATOR, add a
    //  short-circuit so we don't do all this work for things
    //  that can't possibly be accelerators.
    //
    if (pmsg32->message >= WM_KEYFIRST && pmsg32->message <= WM_KEYLAST &&

    // And there had better be a target window...

        pmsg32->hwnd &&

    // and the target window must live either outside the propsheet
    // altogether or completely inside the propsheet page.
    // (This is so that the propsheet can display its own popup dialog,
    // but can't futz with the tab control or OK/Cancel buttons.)

            (!IsChild(ppd->hDlg, pmsg32->hwnd) ||
              IsChild(ppd->hwndCurPage, pmsg32->hwnd)) &&

    // Then ask the propsheet if he wants to eat it.
        _Ppd_SendNotify(ppd, ppd->nCurItem,
                        PSN_TRANSLATEACCELERATOR, (LPARAM)pmsg32) == PSNRET_MESSAGEHANDLED)
        return TRUE;

    if (IsDialogMessage32(ppd->hDlg, pmsg32, TRUE))
        return TRUE;

    return FALSE;
}

HRESULT Prsht_GetObject (LPPROPDATA ppd, HWND hDlg, int iItem, const IID *piid, void **pObject)
{
    TC_ITEMEXTRA tie;
    NMOBJECTNOTIFY non;
    PISP pisp = GETPISP(ppd, iItem);
    *pObject = NULL;

    tie.tci.mask = TCIF_PARAM;
    TabCtrl_GetItem(ppd->hwndTabs, iItem, &tie.tci);
    if (!tie.hwndPage && ((tie.hwndPage = _CreatePage(ppd, pisp, hDlg, GetMUILanguage())) == NULL))
    {
        RemovePropPageData(ppd, iItem);
        return E_UNEXPECTED;
    }
    TabCtrl_SetItem(ppd->hwndTabs, iItem, &tie.tci);

    non.iItem = -1;
    non.piid = piid;
    non.pObject = NULL;
    non.hResult = E_NOINTERFACE;
    non.dwFlags = 0;

    SendNotifyEx (tie.hwndPage, ppd->hwndTabs, PSN_GETOBJECT,
                  &non.hdr,
                  TRUE
                 );
    if (SUCCEEDED (non.hResult))
    {
        *pObject = non.pObject;
        if (pObject == NULL)
            non.hResult = E_UNEXPECTED;
    }
    else if (non.pObject)
    {
        ((LPDROPTARGET) non.pObject)->lpVtbl->Release ((LPDROPTARGET) non.pObject);
        non.pObject = NULL;
    }
    return non.hResult;
}

//
//  We would not normally need IDD_PAGELIST except that DefWindowProc() and
//  WinHelp() do hit-testing differently.  DefWindowProc() will do cool
//  things like checking against the SetWindowRgn and skipping over windows
//  that return HTTRANSPARENT.  WinHelp() on the other hand
//  ignores window regions and transparency.  So what happens is if you
//  click on the transparent part of a tab control, DefWindowProc() says
//  (correctly) "He clicked on the dialog background".  We then say, "Okay,
//  WinHelp(), go display context help for the dialog background", and it
//  says, "Hey, I found a tab control.  I'm going to display help for the
//  tab control now."  To keep a bogus context menu from appearing, we
//  explicitly tell WinHelp that "If you found a tab control (IDD_PAGELIST),
//  then ignore it (NO_HELP)."
//
const static DWORD aPropHelpIDs[] = {  // Context Help IDs
    IDD_APPLYNOW, IDH_COMM_APPLYNOW,
    IDD_PAGELIST, NO_HELP,
    0, 0
};


void HandlePaletteChange(LPPROPDATA ppd, UINT uMessage, HWND hDlg)
{
    HDC hdc;
    hdc = GetDC(hDlg);
    if (hdc)
    {
        BOOL fRepaint;
        SelectPalette(hdc,ppd->hplWatermark,(uMessage == WM_PALETTECHANGED));
        fRepaint = RealizePalette(hdc);
        if (fRepaint)
            InvalidateRect(hDlg,NULL,TRUE);
    }
    ReleaseDC(hDlg,hdc);
}

//
//  Paint a rectangle with the specified brush and palette.
//
void PaintWithPaletteBrush(HDC hdc, LPRECT lprc, HPALETTE hplPaint, HBRUSH hbrPaint)
{
    HBRUSH hbrPrev = SelectBrush(hdc, hbrPaint);
    UnrealizeObject(hbrPaint);
    if (hplPaint)
    {
        SelectPalette(hdc, hplPaint, FALSE);
        RealizePalette(hdc);
    }
    FillRect(hdc, lprc, hbrPaint);
    SelectBrush(hdc, hbrPrev);
}

//
//  lprc is the target rectangle.
//  Use as much of the bitmap as will fit into the target rectangle.
//  If the bitmap is smaller than the target rectangle, then fill the rest with
//  the pixel in the upper left corner of the hbmpPaint.
//
void PaintWithPaletteBitmap(HDC hdc, LPRECT lprc, HPALETTE hplPaint, HBITMAP hbmpPaint)
{
    HDC hdcBmp;
    BITMAP bm;
    int cxRect, cyRect, cxBmp, cyBmp;

    GetObject(hbmpPaint, sizeof(BITMAP), &bm);
    hdcBmp = CreateCompatibleDC(hdc);
    SelectObject(hdcBmp, hbmpPaint);

    if (hplPaint)
    {
        SelectPalette(hdc, hplPaint, FALSE);
        RealizePalette(hdc);
    }

    cxRect = RECTWIDTH(*lprc);
    cyRect = RECTHEIGHT(*lprc);

    //  Never use more pixels from the bmp as we have room in the rect.
    cxBmp = min(bm.bmWidth, cxRect);
    cyBmp = min(bm.bmHeight, cyRect);

    BitBlt(hdc, lprc->left, lprc->top, cxBmp, cyBmp, hdcBmp, 0, 0, SRCCOPY);

    // If bitmap is too narrow, then StretchBlt to fill the width.
    if (cxBmp < cxRect)
        StretchBlt(hdc, lprc->left + cxBmp, lprc->top,
                   cxRect - cxBmp, cyBmp,
                   hdcBmp, 0, 0, 1, 1, SRCCOPY);

    // If bitmap is to short, then StretchBlt to fill the height.
    if (cyBmp < cyRect)
        StretchBlt(hdc, lprc->left, cyBmp,
                   cxRect, cyRect - cyBmp,
                   hdcBmp, 0, 0, 1, 1, SRCCOPY);

    DeleteDC(hdcBmp);
}

void _SetHeaderTitles(HWND hDlg, LPPROPDATA ppd, UINT uPage, LPCTSTR pszNewTitle, BOOL bTitle)
{
    PISP pisp = NULL;

    // Must be for wizard97 
    if (ppd->psh.dwFlags & PSH_WIZARD97)
    {
        // Page number must be within range
        if (uPage < ppd->psh.nPages)
        {
            // Get the page structure
            pisp = GETPISP(ppd, uPage);

            // We should have this page if it's within range
            ASSERT(pisp);

            // Do this only if this page has header.
            if (!(pisp->_psp.dwFlags & PSP_HIDEHEADER))
            {
                LPCTSTR pszOldTitle = bTitle ? pisp->_psp.pszHeaderTitle : pisp->_psp.pszHeaderSubTitle; 

                if (!IS_INTRESOURCE(pszOldTitle))
                    LocalFree((LPVOID)pszOldTitle);

                // Set the new title
                if (bTitle)
                    pisp->_psp.pszHeaderTitle = pszNewTitle;
                else
                    pisp->_psp.pszHeaderSubTitle = pszNewTitle;

                // set pszNewTitle to NULL here so that we don't free it later
                pszNewTitle = NULL;
                
                // set the correct flags
                pisp->_psp.dwFlags |= bTitle ? PSP_USEHEADERTITLE : PSP_USEHEADERSUBTITLE;

                // force redrawing of the titles
                if (uPage == (UINT)ppd->nCurItem)
                {
                    RECT rcHeader;
                    GetClientRect(hDlg, &rcHeader);
                    rcHeader.bottom = ppd->cyHeaderHeight;

                    InvalidateRect(hDlg, &rcHeader, FALSE);
                }
            }
        }
    }

    if (pszNewTitle)
        LocalFree((LPVOID)pszNewTitle);
}

void PropSheetPaintHeader(LPPROPDATA ppd, PISP pisp, HWND hDlg, HDC hdc)
{
    RECT rcHeader;

    GetClientRect(hDlg, &rcHeader);
    if ((rcHeader.right > 0) && (rcHeader.bottom > 0))
    {
        RECT rcHeaderBitmap;

        rcHeader.bottom = ppd->cyHeaderHeight;

        // do we need to paint the header?
        if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
        {
            // Do it the WIZARD97IE4 way

            // Bug-for-bug compatibility:  WIZARD97IE4 tested the wrong flag here
            if ((ppd->psh.dwFlags & PSH_WATERMARK) && (ppd->hbrWatermark))
                PaintWithPaletteBrush(hdc, &rcHeader, ppd->hplWatermark, ppd->hbrHeader);
            SetBkMode(hdc, TRANSPARENT);
        }
        else
        {
            // Do it the WIZARD97IE5 way
            if ((ppd->psh.dwFlags & PSH_HEADER) && (ppd->hbmHeader))
            {
                // compute the rectangle for the bitmap depending on the size of the header
                int bx = RECTWIDTH(rcHeader) - HEADERBITMAP_CXBACK;
                ASSERT(bx > 0);
                FillRect(hdc, &rcHeader, g_hbrWindow);
                SetRect(&rcHeaderBitmap, bx, HEADERBITMAP_Y, bx + HEADERBITMAP_WIDTH, HEADERBITMAP_Y + HEADERBITMAP_HEIGHT);
                PaintWithPaletteBitmap(hdc, &rcHeaderBitmap, ppd->hplWatermark, ppd->hbmHeader);
                SetBkColor(hdc, g_clrWindow);
                SetTextColor(hdc, g_clrWindowText);
            }
            else
            {
                SendMessage(hDlg, WM_CTLCOLORSTATIC, (WPARAM)hdc, (LPARAM)hDlg);
            }
        }

        //
        //  WIZARD97IE5 subtracts out the space used by the header bitmap.
        //  WIZARD97IE4 uses the full width since the header bitmap
        //  in IE4 is a watermark and occupies no space.
        //
        if (!(ppd->psh.dwFlags & PSH_WIZARD97IE4))
        {
            rcHeader.right -= HEADERBITMAP_CXBACK + HEADERSUBTITLE_WRAPOFFSET;
        }

        ASSERT(rcHeader.right);

        if (HASHEADERTITLE(pisp))
        {
            _WriteHeaderTitle(ppd, hdc, &rcHeader, pisp->_psp.pszHeaderTitle,
                              TRUE, DRAWTEXT_WIZARD97FLAGS);
        }

        if (HASHEADERSUBTITLE(pisp))
        {
            _WriteHeaderTitle(ppd, hdc, &rcHeader, pisp->_psp.pszHeaderSubTitle,
                              FALSE, DRAWTEXT_WIZARD97FLAGS);
        }
    }
}

// Free the title if we need to
void Prsht_FreeTitle(LPPROPDATA ppd)
{
    if (ppd->fFlags & PD_FREETITLE) {
        ppd->fFlags &= ~PD_FREETITLE;
        if (!IS_INTRESOURCE(ppd->psh.pszCaption)) {
            LocalFree((LPVOID)ppd->psh.pszCaption);
        }
    }
}

//
//  pfnStrDup is the function that converts lParam into a native character
//  set string.  (Either StrDup or StrDup_AtoW).
//
void Prsht_OnSetTitle(LPPROPDATA ppd, WPARAM wParam, LPARAM lParam, STRDUPPROC pfnStrDup)
{
    LPTSTR pszTitle;

    //
    //  The ppd->psh.pszCaption is not normally LocalAlloc()d; it's
    //  just a pointer copy.  But if the app does a PSM_SETTITLE,
    //  then all of a sudden it got LocalAlloc()d and needs to be
    //  freed.  PD_FREETITLE is the flag that tell us that this has
    //  happened.
    //

    if (IS_INTRESOURCE(lParam)) {
        pszTitle = (LPTSTR)lParam;
    } else {
        pszTitle = pfnStrDup((LPTSTR)lParam);
    }

    if (pszTitle) {
        Prsht_FreeTitle(ppd);           // Free old title if necessary

        ppd->psh.pszCaption = pszTitle;
        ppd->fFlags |= PD_FREETITLE;    // Need to free this

        ppd->psh.dwFlags = ((((DWORD)wParam) & PSH_PROPTITLE) | (ppd->psh.dwFlags & ~PSH_PROPTITLE));
        _SetTitle(ppd->hDlg, ppd);
    }
}

BOOL_PTR CALLBACK PropSheetDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    HWND hwndT;
    LPPROPDATA ppd = (LPPROPDATA)GetWindowLongPtr(hDlg, DWLP_USER);
    LRESULT lres;

    if (!ppd && (uMessage != WM_INITDIALOG))
        return FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            InitPropSheetDlg(hDlg, (LPPROPDATA)lParam);
            return FALSE;

        case WM_SYSCOMMAND:
            if (wParam == SC_HOTKEY)
                return HandleHotkey(lParam);
            else if (wParam == SC_CLOSE)
            {
                UINT id = IDCLOSE;

                if (IS_WIZARD(ppd))
                    id = IDCANCEL;
                else if (ppd->fFlags & PD_CANCELTOCLOSE)
                    id = IDOK;

                // system menu close should be IDCANCEL, but if we're in the
                // PSM_CANCELTOCLOSE state, treat it as an IDOK (ie, "Close").
                return Prsht_OnCommand(ppd, id, NULL, 0);
            }

            return FALSE;      // Let default process happen

        case WM_NCDESTROY:
            {
                int iPage;

                ASSERT(GetDlgItem(hDlg, IDD_PAGELIST) == NULL);

                ppd->hwndTabs = NULL;

                // NOTE: all of the hwnds for the pages must be destroyed by now!

                // Release all page objects in REVERSE ORDER so we can have
                // pages that are dependant on eachother based on the initial
                // order of those pages
                //
                for (iPage = ppd->psh.nPages - 1; iPage >= 0; iPage--)
                {
                    ULONG_PTR dw = PropPageActivateContext(ppd, GETPISP(ppd, iPage));
                    DestroyPropertySheetPage(GETHPAGE(ppd, iPage));
                    PropPageDeactivateContext(dw); 
                }
                // hwndCurPage is no longer valid from here on
                ppd->hwndCurPage = NULL;

                if (ppd->hActCtxInit)
                    ReleaseActCtx(ppd->hActCtxInit);

                // If we are modeless, we need to free our ppd.  If we are modal,
                // we let _RealPropertySheet free it since one of our pages may
                // set the restart flag during DestroyPropertySheetPage above.
                if (ppd->psh.dwFlags & PSH_MODELESS)
                {
                    LocalFree(ppd);
                }
            }
            //
            // NOTES:
            //  Must return FALSE to avoid DS leak!!!
            //
            return FALSE;

        case WM_DESTROY:
            {
                int i;
                HIMAGELIST himl;
                int c = TabCtrl_GetItemCount(ppd->hwndTabs);

                for (i = 0; i < c; i++)
                {
                    EnableThemeDialogTexture(_Ppd_GetPage(ppd, i), ETDT_DISABLE);
                }

                // Destroy the image list we created during our init call.
                himl = TabCtrl_GetImageList(ppd->hwndTabs);
                if (himl)
                    ImageList_Destroy(himl);


                if (ppd->psh.dwFlags & PSH_WIZARD97)
                {

                    // Even if the PSH_USEHBMxxxxxx flag is set, we might
                    // need to delete the bitmap if we had to create a
                    // stretched copy.

                    if (ppd->psh.dwFlags & PSH_WATERMARK)
                    {
                        if ((!(ppd->psh.dwFlags & PSH_USEHBMWATERMARK) ||
                            ppd->hbmWatermark != ppd->psh.H_hbmWatermark) &&
                            ppd->hbmWatermark)
                            DeleteObject(ppd->hbmWatermark);

                        if (!(ppd->psh.dwFlags & PSH_USEHPLWATERMARK) &&
                            ppd->hplWatermark)
                            DeleteObject(ppd->hplWatermark);

                        if (ppd->hbrWatermark)
                            DeleteObject(ppd->hbrWatermark);
                    }

                    if ((ppd->psh.dwFlags & PSH_HEADER) && ppd->psh.H_hbmHeader)
                    {
                        if ((!(ppd->psh.dwFlags & PSH_USEHBMHEADER) ||
                            ppd->hbmHeader != ppd->psh.H_hbmHeader) &&
                            ppd->hbmHeader)
                        {
                            ASSERT(ppd->hbmHeader != ppd->hbmWatermark);
                            DeleteObject(ppd->hbmHeader);
                        }

                        if (ppd->hbrHeader)
                        {
                            ASSERT(ppd->hbrHeader != ppd->hbrWatermark);
                            DeleteObject(ppd->hbrHeader);
                        }
                    }

                    if (ppd->hFontBold)
                        DeleteObject(ppd->hFontBold);
                }

                if ((ppd->psh.dwFlags & PSH_USEICONID) && ppd->psh.H_hIcon)
                    DestroyIcon(ppd->psh.H_hIcon);

                Prsht_FreeTitle(ppd);
            }

            break;

        case WM_ERASEBKGND:
            return ppd->fFlags & PD_NOERASE;
            break;

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc;
            PISP pisp;

            hdc = BeginPaint(hDlg, &ps);

            // only paint if the invalid rect has a non-zero widht or height
            if (((ps.rcPaint.bottom - ps.rcPaint.top) > 0) &&
                ((ps.rcPaint.right - ps.rcPaint.left) > 0))
            {
                // (dli) paint the header
                if ((ppd->psh.dwFlags & PSH_WIZARD97) &&
                    (!((pisp = GETPISP(ppd, ppd->nCurItem))->_psp.dwFlags & PSP_HIDEHEADER)))
                {
                    PropSheetPaintHeader(ppd, pisp, hDlg, hdc);
                }

                if (ps.fErase) {
                    SendMessage (hDlg, WM_ERASEBKGND, (WPARAM) hdc, 0);
                }
            }

            EndPaint(hDlg, &ps);
        }
        break;

        case WM_COMMAND:
            // Cannot use HANDLE_WM_COMMAND, because we want to pass a result!
            return Prsht_OnCommand(ppd, GET_WM_COMMAND_ID(wParam, lParam),
                                   GET_WM_COMMAND_HWND(wParam, lParam),
                                   GET_WM_COMMAND_CMD(wParam, lParam));

        case WM_NOTIFY:
            switch (((NMHDR *)lParam)->code)
            {
                case TCN_SELCHANGE:
                    PageChange(ppd, 1);
                    break;

                case TCN_SELCHANGING:
                {
                    lres = PageChanging(ppd);
                    if (!lres) {
                        SetWindowPos(ppd->hwndCurPage, HWND_BOTTOM, 0,0,0,0, SWP_NOACTIVATE | SWP_NOSIZE |SWP_NOMOVE);
                    }
                    goto ReturnLres;
                }
                break;

                case TCN_GETOBJECT:
                {
                    LPNMOBJECTNOTIFY lpnmon = (LPNMOBJECTNOTIFY)lParam;

                    lpnmon->hResult = Prsht_GetObject(ppd, hDlg, lpnmon->iItem,
                        lpnmon->piid, &lpnmon->pObject);
                }
                break;

                default:
                    return FALSE;
            }
            return TRUE;

        case PSM_SETWIZBUTTONS:
            SetWizButtons(ppd, lParam);
            break;

        case PSM_SETFINISHTEXTA:
        case PSM_SETFINISHTEXT:
        {
            HWND    hFinish = GetDlgItem(hDlg, IDD_FINISH);
            HWND hwndFocus = GetFocus();
            HWND hwnd;
            BOOL fSetFocus = FALSE;

            if (!(ppd->psh.dwFlags & PSH_WIZARDHASFINISH)) {
                hwnd = GetDlgItem(hDlg, IDD_NEXT);
                if (hwnd == hwndFocus)
                    fSetFocus = TRUE;
                ShowWindow(hwnd, SW_HIDE);
            }

            hwnd = GetDlgItem(hDlg, IDD_BACK);
            if (hwnd == hwndFocus)
                fSetFocus = TRUE;
            ShowWindow(hwnd, SW_HIDE);

            if (lParam) 
            {
                if (uMessage == PSM_SETFINISHTEXTA) 
                {
                    SetWindowTextA(hFinish, (LPSTR)lParam);
                } 
                else
                    Button_SetText(hFinish, (LPTSTR)lParam);
            }
            ShowWindow(hFinish, SW_SHOW);
            Button_Enable(hFinish, TRUE);
            ResetWizButtons(ppd);
            SendMessage(hDlg, DM_SETDEFID, IDD_FINISH, 0);
            ppd->idDefaultFallback = IDD_FINISH;
            if (fSetFocus)
#ifdef WM_NEXTDLGCTL_WORKS
                SetDlgFocus(ppd, hFinish);
#else
                SetFocus(hFinish);
#endif
        }
        break;

        case PSM_SETTITLEA:
            Prsht_OnSetTitle(ppd, wParam, lParam, StrDup_AtoW);
            break;

        case PSM_SETTITLE:
            Prsht_OnSetTitle(ppd, wParam, lParam, StrDup);
            break;

        case PSM_SETHEADERTITLEA:
        {
            LPWSTR lpHeaderTitle = (lParam && HIWORD(lParam)) ?
                                   ProduceWFromA(CP_ACP, (LPCSTR)lParam) : StrDupW((LPWSTR)lParam);
            if (lpHeaderTitle) 
                _SetHeaderTitles(hDlg, ppd, (UINT)wParam, lpHeaderTitle, TRUE); 
        }
        break;
       
        case PSM_SETHEADERTITLE:
        {
            LPTSTR lpHeaderTitle = StrDup((LPCTSTR)lParam);
            if (lpHeaderTitle) 
                _SetHeaderTitles(hDlg, ppd, (UINT)wParam, lpHeaderTitle, TRUE); 
        }
        break;
            
        case PSM_SETHEADERSUBTITLEA:
        {
            LPWSTR lpHeaderSubTitle = (lParam && HIWORD(lParam)) ?
                                   ProduceWFromA(CP_ACP, (LPCSTR)lParam) : StrDupW((LPWSTR)lParam);
            if (lpHeaderSubTitle) 
                _SetHeaderTitles(hDlg, ppd, (UINT)wParam, lpHeaderSubTitle, FALSE); 
        }
        break;

        case PSM_SETHEADERSUBTITLE:
        {
            LPTSTR lpHeaderSubTitle = StrDup((LPCTSTR)lParam);
            if (lpHeaderSubTitle) 
                _SetHeaderTitles(hDlg, ppd, (UINT)wParam, lpHeaderSubTitle, FALSE); 
        }
        break;
            
        case PSM_CHANGED:
            PageInfoChange(ppd, (HWND)wParam);
            break;

        case PSM_RESTARTWINDOWS:
            ppd->nRestart |= ID_PSRESTARTWINDOWS;
            break;

        case PSM_REBOOTSYSTEM:
            ppd->nRestart |= ID_PSREBOOTSYSTEM;
            break;

        case PSM_DISABLEAPPLY:
            // the page is asking us to gray the "Apply" button and not let
            // anyone else re-enable it
            if (ppd->fAllowApply)
            {
                ppd->fAllowApply = FALSE;
                EnableWindow(GetDlgItem(ppd->hDlg, IDD_APPLYNOW), FALSE);
            }
            break;

        case PSM_ENABLEAPPLY:
            // the page is asking us to allow the the "Apply" button to be
            // once again enabled
            if (!ppd->fAllowApply)
                ppd->fAllowApply = TRUE;
            // REARCHITECT - raymondc - shouldn't we call EnableWindow?
            break;

        case PSM_CANCELTOCLOSE:
            if (!(ppd->fFlags & PD_CANCELTOCLOSE))
            {
                TCHAR szClose[20];
                ppd->fFlags |= PD_CANCELTOCLOSE;
                LocalizedLoadString(IDS_CLOSE, szClose, ARRAYSIZE(szClose));
                SetDlgItemText(hDlg, IDOK, szClose);
                EnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);
            }
            break;

        case PSM_SETCURSEL:
            lres = PageSetSelection(ppd, (int)wParam, (HPROPSHEETPAGE)lParam, 1);
            goto ReturnLres;

        case PSM_SETCURSELID:
        {
            int iPageIndex;

            iPageIndex =  FindPageIndex(ppd, ppd->nCurItem, (DWORD)lParam, 1);

            if (iPageIndex == -1)
                lres = 0;
            else
                lres = PageSetSelection(ppd, iPageIndex, NULL, 1);
            goto ReturnLres;
        }
        break;

        case PSM_REMOVEPAGE:
            RemovePropPage(ppd, (int)wParam, (HPROPSHEETPAGE)lParam);
            break;

        case PSM_ADDPAGE:
            lres = AddPropPage(ppd,(HPROPSHEETPAGE)lParam);
            goto ReturnLres;

        case PSM_INSERTPAGE:
            lres = InsertPropPage(ppd, (HPROPSHEETPAGE)wParam, (HPROPSHEETPAGE)lParam);
            goto ReturnLres;

        case PSM_QUERYSIBLINGS:
            lres = QuerySiblings(ppd, wParam, lParam);
            goto ReturnLres;

        case PSM_UNCHANGED:
            PageInfoUnChange(ppd, (HWND)wParam);
            break;

        case PSM_APPLY:
            // a page is asking us to simulate an "Apply Now".
            // let the page know if we're successful
            lres = ButtonPushed(ppd, IDD_APPLYNOW);
            goto ReturnLres;

        case PSM_GETTABCONTROL:
            lres = (LRESULT)ppd->hwndTabs;
            goto ReturnLres;

        case PSM_GETCURRENTPAGEHWND:
            lres = (LRESULT)ppd->hwndCurPage;
            goto ReturnLres;

        case PSM_PRESSBUTTON:
            if (wParam <= PSBTN_MAX)
            {
                const static int IndexToID[] = {IDD_BACK, IDD_NEXT, IDD_FINISH, IDOK,
                IDD_APPLYNOW, IDCANCEL, IDHELP};
                Prsht_OnCommand(ppd, IndexToID[wParam], NULL, 0);
            }
            break;

        case PSM_ISDIALOGMESSAGE:
            // returning TRUE means we handled it, do a continue
            // FALSE do standard translate/dispatch
            lres = Prop_IsDialogMessage(ppd, (LPMSG32)lParam);
            goto ReturnLres;

        case PSM_HWNDTOINDEX:
            lres = FindItem(ppd->hwndTabs, (HWND)wParam, NULL);
            goto ReturnLres;

        case PSM_INDEXTOHWND:
            if ((UINT)wParam < ppd->psh.nPages)
                lres = (LRESULT)_Ppd_GetPage(ppd, (int)wParam);
            else
                lres = 0;
            goto ReturnLres;

        case PSM_PAGETOINDEX:
            lres = FindPageIndexByHpage(ppd, (HPROPSHEETPAGE)lParam);
            goto ReturnLres;

        case PSM_INDEXTOPAGE:
            if ((UINT)wParam < ppd->psh.nPages)
                lres = (LRESULT)GETHPAGE(ppd, wParam);
            else
                lres = 0;
            goto ReturnLres;

        case PSM_INDEXTOID:
            if ((UINT)wParam < ppd->psh.nPages)
            {
                lres = (LRESULT)GETPPSP(ppd, wParam)->P_pszTemplate;

                // Need to be careful -- return a value only if pszTemplate
                // is an ID.  Don't return out our internal pointers!
                if (!IS_INTRESOURCE(lres))
                    lres = 0;
            }
            else
                lres = 0;
            goto ReturnLres;

        case PSM_IDTOINDEX:
            lres = FindPageIndex(ppd, ppd->nCurItem, (DWORD)lParam, 0);
            goto ReturnLres;

        case PSM_GETRESULT:
            // This is valid only after the property sheet is gone
            if (ppd->hwndCurPage)
            {
                lres = -1;      // you shouldn't be calling me yet
            } else {
                lres = ppd->nReturn;
                if (lres > 0 && ppd->nRestart)
                    lres = ppd->nRestart;
            }
            goto ReturnLres;
            break;

        case PSM_RECALCPAGESIZES:
            lres = Prsht_RecalcPageSizes(ppd);
            goto ReturnLres;

            // these should be relayed to all created dialogs
        case WM_WININICHANGE:
        case WM_SYSCOLORCHANGE:
        case WM_DISPLAYCHANGE:
            {
                int nItem, nItems = TabCtrl_GetItemCount(ppd->hwndTabs);
                for (nItem = 0; nItem < nItems; ++nItem)
                {

                    hwndT = _Ppd_GetPage(ppd, nItem);
                    if (hwndT)
                        SendMessage(hwndT, uMessage, wParam, lParam);
                }
                SendMessage(ppd->hwndTabs, uMessage, wParam, lParam);
            }
            break;

            //
            // send toplevel messages to the current page and tab control
            //
        case WM_PALETTECHANGED:
            //
            // If this is our window we need to avoid selecting and realizing
            // because doing so would cause an infinite loop between WM_QUERYNEWPALETTE
            // and WM_PALETTECHANGED.
            //
            if((HWND)wParam == hDlg) {
                return(FALSE);
            }
            //
            // FALL THROUGH
            //

        case WM_QUERYNEWPALETTE:
            // This is needed when another window which has different palette clips
            // us
            if ((ppd->psh.dwFlags & PSH_WIZARD97) &&
                (ppd->psh.dwFlags & PSH_WATERMARK) &&
                (ppd->psh.hplWatermark))
                HandlePaletteChange(ppd, uMessage, hDlg);

            //
            // FALL THROUGH
            //

        case WM_ENABLE:
        case WM_DEVICECHANGE:
        case WM_QUERYENDSESSION:
        case WM_ENDSESSION:
            if (ppd->hwndTabs)
                SendMessage(ppd->hwndTabs, uMessage, wParam, lParam);
            //
            // FALL THROUGH
            //

        case WM_ACTIVATEAPP:
        case WM_ACTIVATE:
            {
                hwndT = _Ppd_GetPage(ppd, ppd->nCurItem);
                if (hwndT && IsWindow(hwndT))
                {
                    //
                    // By doing this, we are "handling" the message.  Therefore
                    // we must set the dialog return value to whatever the child
                    // wanted.
                    //
                    lres = SendMessage(hwndT, uMessage, wParam, lParam);
                    goto ReturnLres;
                }
            }

            if ((uMessage == WM_PALETTECHANGED) || (uMessage == WM_QUERYNEWPALETTE))
                return TRUE;
            else
                return FALSE;

        case WM_CONTEXTMENU:
            // ppd->hwndTabs is handled by aPropHelpIDs to work around a USER bug.
            // See aPropHelpIDs for gory details.
            if ((ppd->hwndCurPage != (HWND)wParam) && (!IS_WIZARD(ppd)))
                WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID) aPropHelpIDs);
            break;

        case WM_HELP:
            hwndT = (HWND)((LPHELPINFO)lParam)->hItemHandle;
            if ((GetParent(hwndT) == hDlg) && (hwndT != ppd->hwndTabs))
                WinHelp(hwndT, NULL, HELP_WM_HELP, (ULONG_PTR)(LPVOID) aPropHelpIDs);
            break;

        default:
            return FALSE;
       }
    return TRUE;

ReturnLres:
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lres);
    return TRUE;

}

//
//  Draw the background for wizard pages.
//
BOOL Prsht_EraseWizBkgnd(LPPROPDATA ppd, HDC hdc)
{
    RECT rc;
    BOOL fPainted = FALSE;
    GetClientRect(ppd->hDlg, &rc);

    if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
    {
        if (ppd->hbrWatermark)
        {
            PaintWithPaletteBrush(hdc, &rc, ppd->hplWatermark, ppd->hbrWatermark);
            fPainted = TRUE;
        }
    }
    else                                // PSH_WIZARD97IE5
    {
        if (ppd->hbmWatermark)
        {
            // Right-hand side gets g_hbrWindow.
            rc.left = BITMAP_WIDTH;
            FillRect(hdc, &rc, g_hbrWindow);

            // Left-hand side gets watermark in top portion with autofill...
            rc.right = rc.left;
            rc.left = 0;
            PaintWithPaletteBitmap(hdc, &rc, ppd->hplWatermark, ppd->hbmWatermark);
            fPainted = TRUE;
        }
    }
    return fPainted;
}

LRESULT CALLBACK WizardWndProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData)
{
    LPPROPDATA ppd = (LPPROPDATA)dwRefData;
    switch (uMessage)
    {
        case WM_ERASEBKGND:
            if (Prsht_EraseWizBkgnd(ppd, (HDC)wParam))
                return TRUE;
            break;

        // Only PSH_WIZARD97IE4 cares about these messages
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORDLG:
            if (!(ppd->psh.dwFlags & PSH_WIZARD97IE4))
                break;
            // fall through

        case WM_CTLCOLOR:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
            if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
            {
              if (ppd->hbrWatermark) {
                POINT pt;
                // Bug-for-bug compatibility:  TRANSPARENT messes up edit
                // controls when they scroll, but that's what IE4 did.
                SetBkMode((HDC)wParam, TRANSPARENT);

                if (ppd->hplWatermark)
                {
                    SelectPalette((HDC)wParam, ppd->hplWatermark, FALSE);
                    RealizePalette((HDC)wParam);
                }
                UnrealizeObject(ppd->hbrWatermark);
                GetDCOrgEx((HDC)wParam, &pt);
                // Bug-for-bug compatibility:  We shouldn't use GetParent
                // because the notification might be forwarded up from an
                // embedded dialog child, but that's what IE4 did.
                ScreenToClient(GetParent((HWND)lParam), &pt);
                SetBrushOrgEx((HDC)wParam, -pt.x, -pt.y, NULL);
                return (LRESULT)(HBRUSH)ppd->hbrWatermark;
              }
            }
            else                        // PSH_WIZARD97IE5
            {
                if (ppd->hbmWatermark)
                {
                    LRESULT lRet = DefWindowProc(hDlg, uMessage, wParam, lParam);
                    if (lRet == DefSubclassProc(hDlg, uMessage, wParam, lParam))
                    {
                        SetTextColor((HDC)wParam, GetSysColor(COLOR_WINDOWTEXT));
                        SetBkColor((HDC)wParam, GetSysColor(COLOR_WINDOW));
                        return (LRESULT)g_hbrWindow;
                    }
                    else
                        return lRet;
                }
            }
            break;

        case WM_PALETTECHANGED:
            if((HWND)wParam == hDlg)
                return(FALSE);

        case WM_QUERYNEWPALETTE:
            HandlePaletteChange(ppd, uMessage, hDlg);
            return TRUE;

        case WM_DESTROY:
            // Clean up subclass
            RemoveWindowSubclass(hDlg, WizardWndProc, 0);
            break;

        default:
            break;
    }

    return DefSubclassProc(hDlg, uMessage, wParam, lParam);
}

//
// EnumResLangProc
//
// purpose: a callback function for EnumResourceLanguages().
//          look into the type passed in and if it is RT_DIALOG
//          copy the lang of the first resource to our buffer
//          this also counts # of lang if more than one of them
//          are passed in
//
//
typedef struct  {
    WORD wLang;
    BOOL fFoundLang;
    LPCTSTR lpszType;
} ENUMLANGDATA;

BOOL CALLBACK EnumResLangProc(HINSTANCE hinst, LPCTSTR lpszType, LPCTSTR lpszName, WORD wIdLang, LPARAM lparam)
{
    ENUMLANGDATA *pel = (ENUMLANGDATA *)lparam;
    BOOL fContinue = TRUE;

    ASSERT(pel);

    if (lpszType == pel->lpszType)
    {
        // When comctl's been initialized with a particular MUI language,
        // we pass in the langid to GetPageLanguage(), then it's given to this proc.
        // we want to look for a template that matches to the langid,
        // and if it's not found, we have to use the first instance of templates.
        // 
        if (pel->wLang == MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)
            || (pel->wLang == wIdLang))
        {
            pel->wLang = wIdLang;
            pel->fFoundLang = TRUE;
            fContinue = FALSE; 
        }
    }
    return fContinue;   // continue until we get langs...
}

// GetPageLanguage
//
// purpose: tries to retrieve language information out of
//          given page's dialog template. We get the first language
//          in which the template is localized in.
//          currently doesn't support PSP_DLGINDIRECT case
//
// we luck out with browselc since there's only one lang per resid,
// we should cache the langid we loaded up front and pull it out here.
//
HRESULT GetPageLanguage(PISP pisp, WORD *pwLang)
{
    if (pisp && pwLang)
    {
        if (pisp->_psp.dwFlags & PSP_DLGINDIRECT)
        {
            // try something other than dialog
            return E_FAIL; // not supported yet.
        }
        else
        {
            ENUMLANGDATA el;
            
            // the caller passes-in the langid with which we're initialized
            //
            el.wLang = *pwLang;
            el.fFoundLang = FALSE;
            el.lpszType = RT_DIALOG;
            // check with the dialog template specified
            EnumResourceLanguages(pisp->_psp.hInstance, RT_DIALOG, pisp->_psp.P_pszTemplate, EnumResLangProc, (LPARAM)&el);
            if (!el.fFoundLang)
            {
                // we couldn't find a matching lang in the given page's resource
                // so we'll take the first one
                el.wLang = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
                
                // it doesn't matter if this fails, because we'll then end up with 
                // the neutral langid, which is the best guess here after failing 
                // to get any page lang.
                //
                EnumResourceLanguages(pisp->_psp.hInstance, RT_DIALOG, 
                                      pisp->_psp.P_pszTemplate, EnumResLangProc, (LPARAM)&el);
            }
            *pwLang = el.wLang;
        }
        return S_OK;
    }
    return E_FAIL;
}

//
//  FindResourceExRetry
//
//  Just like FindResourceEx, except that if we can't find the resource,
//  we try again with MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL).
//
HRSRC FindResourceExRetry(HMODULE hmod, LPCTSTR lpType, LPCTSTR lpName, WORD wLang)
{
    HRSRC hrsrc = FindResourceEx(hmod, lpType, lpName, wLang);

    // if failed because we couldn't find the resouce in requested lang
    // and requested lang wasn't neutral, then try neutral.
    if (!hrsrc && wLang != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
    {
        wLang = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
        hrsrc = FindResourceEx(hmod, lpType, lpName, wLang);
    }


    return hrsrc;
}


WORD GetShellResourceLangID(void);

// NT5_GetUserDefaultUILanguage
//
//  NT5 has a new function GetUserDefaultUILanguage which returns the
//  language the user as selected for UI.
//
//  If the function is not available (e.g., NT4), then use the
//  shell resource language ID.
//

typedef LANGID (CALLBACK* GETUSERDEFAULTUILANGUAGE)(void);

GETUSERDEFAULTUILANGUAGE _GetUserDefaultUILanguage;

LANGID NT5_GetUserDefaultUILanguage(void)
{
    if (_GetUserDefaultUILanguage == NULL)
    {
        HMODULE hmod = GetModuleHandle(TEXT("KERNEL32"));

        //
        //  Must keep in a local to avoid thread races.
        //
        GETUSERDEFAULTUILANGUAGE pfn = NULL;

        if (hmod)
            pfn = (GETUSERDEFAULTUILANGUAGE)
                    GetProcAddress(hmod, "GetUserDefaultUILanguage");

        //
        //  If function is not available, then use our fallback
        //
        if (pfn == NULL)
            pfn = GetShellResourceLangID;

        ASSERT(pfn != NULL);
        _GetUserDefaultUILanguage = pfn;
    }

    return _GetUserDefaultUILanguage();
}


LCID CCGetSystemDefaultThreadLocale(LCID iLcidThreadOrig)
{
    UINT uLangThread, uLangThreadOrig;

    uLangThreadOrig = LANGIDFROMLCID(iLcidThreadOrig);

    

    // uLangThread is the language we think we want to use
    uLangThread = uLangThreadOrig;

    if (staticIsOS(OS_NT4ORGREATER) && !staticIsOS(OS_WIN2000ORGREATER))
    {
        int iLcidUserDefault = GetUserDefaultLCID();
        UINT uLangUD = LANGIDFROMLCID(iLcidUserDefault);

        //
        // If we are running on Enabled Arabic NT4, we should always
        // display the US English resources (since the UI is English), however NT4
        // Resource Loader will look for the current Thread Locale (which is Arabic).
        // This is no problem in NT5 since the Resource Loader will check for
        // the  UI Language (newly introduced) when loading such resources. To
        // fix this, we will change the thread locale to US English
        // and restore it back to Arabic/Hebrew if we are running on an Enabled Arabic/Hebrew NT4.
        // The check is done to make sure we are running within a Araic/Hebrew user locale
        // and the thread locale is still Arabic/Hebrew (i.e. nobody tried to SetThreadLocale).
        // [samera]
        //
        if( ((PRIMARYLANGID(uLangUD    ) == LANG_ARABIC) &&
             (PRIMARYLANGID(uLangThread) == LANG_ARABIC))   ||
            ((PRIMARYLANGID(uLangUD    ) == LANG_HEBREW) &&
             (PRIMARYLANGID(uLangThread) == LANG_HEBREW)))
        {
            uLangThread = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
        }
    }

    //
    //  Make locale match UI locale if not otherwise overridden.
    //
    if (uLangThread == uLangThreadOrig)
    {
        uLangThread = NT5_GetUserDefaultUILanguage();
    }

    //
    //  Now see if we actually changed the thread language.
    //
    if (uLangThread == uLangThreadOrig)
    {
        // No change, return the original locale, including sort stuff
        return iLcidThreadOrig;
    }
    else
    {
        // It changed, return a generic sort order, since we don't use
        // this information for sorting.
        return MAKELCID(uLangThread, SORT_DEFAULT);
    }
}

//
// GetAltFontLangId
// 
// used to detect "MS UI Gothic" on Jpn localized non NT5 platforms
// the font is shipped with IE5 for the language but comctl can't 
// always assume the font so we have a fake sublang id assigned to
// the secondary resource file for the language
//
int CALLBACK FontEnumProc(
  ENUMLOGFONTEX *lpelfe,    
  NEWTEXTMETRICEX *lpntme,  
  int FontType,             
  LPARAM lParam
)
{
    if (lParam)
    {
        *(BOOL *)lParam = TRUE;
    }
    return 0; // stop at the first callback
}
UINT GetDefaultCharsetFromLang(LANGID wLang)
{
    TCHAR    szData[6+1]; // 6 chars are max allowed for this lctype
    UINT     uiRet = DEFAULT_CHARSET;

    // JPN hack here: GetLocaleInfo() DOES return > 0 for Jpn altfont langid,
    // but doesn't get us any useful info. So for JPN, we ripout the SUBLANG
    // portion of id. we can't do this for other langs since sublang can affect
    // charset (ex. chinese)
    //
    if(PRIMARYLANGID(wLang) == LANG_JAPANESE)
        wLang = MAKELANGID(PRIMARYLANGID(wLang), SUBLANG_NEUTRAL);
    
    if (GetLocaleInfo(MAKELCID(wLang, SORT_DEFAULT), 
                      LOCALE_IDEFAULTANSICODEPAGE,
                      szData, ARRAYSIZE(szData)) > 0)
    {

        UINT uiCp = StrToInt(szData);
        CHARSETINFO   csinfo;

        if (TranslateCharsetInfo(IntToPtr_(DWORD *, uiCp), &csinfo, TCI_SRCCODEPAGE))
            uiRet = csinfo.ciCharset;
    }

    return uiRet;
}
BOOL IsFontInstalled(LANGID wLang, LPCTSTR szFace)
{
    BOOL     fInstalled = FALSE;
    HDC      hdc;
    LOGFONT  lf = {0};

    lstrcpyn(lf.lfFaceName, szFace, ARRAYSIZE(lf.lfFaceName));
    
    // retrieve charset from given language
    lf.lfCharSet = (BYTE)GetDefaultCharsetFromLang(wLang);
    
    // then see if we can enumrate the font
    hdc = GetDC(NULL);
    if (hdc)
    {
        EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)FontEnumProc, (LPARAM)&fInstalled, 0);
        ReleaseDC(NULL, hdc);
    }

     return fInstalled;
}

LANGID GetAltFontLangId(LANGID wLang)
{
     LPCTSTR pszTypeFace = NULL;
     USHORT  usAltSubLang = SUBLANG_NEUTRAL;
     const static TCHAR s_szUIGothic[] = TEXT("MS UI Gothic");
     static int iPrimaryFontInstalled = -1;

     // most of the case we return the lang just as is
     switch(PRIMARYLANGID(wLang))
     {
         case LANG_JAPANESE:
             pszTypeFace = s_szUIGothic;
             usAltSubLang   = SUBLANG_JAPANESE_ALTFONT;
             break;
         // add code here to handle any other cases like Jpn
         default:
             return wLang;
     }

     // check existence of the font if we haven't
     if (iPrimaryFontInstalled < 0 && pszTypeFace)
     {
        iPrimaryFontInstalled = IsFontInstalled(wLang, pszTypeFace);
     }

     // return secondary lang id if our alternative font *is* installed
     if (iPrimaryFontInstalled == 1) 
         wLang = MAKELANGID(PRIMARYLANGID(wLang), usAltSubLang);

     return wLang;
}
// GetShellResourceLangID
//
// On NT4, we want to match our ML resource to the one that OS is localized.
// this is to prevent general UI (buttons) from changing along with regional
// setting change.
// Win95 won't change system default locale, NT5 will load from matching satelite
// resource dll automatically so this won't be needed on these platforms.
// This function finds shell32.dll and gets the language in which the dll is
// localized, then cache the lcid so we won't have to detect it again.
//
WORD GetShellResourceLangID(void)
{
    static WORD langRes = 0L;

    // we do this only once
    if (langRes == 0L)
    {
        HINSTANCE hinstShell;
        ENUMLANGDATA el = {MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), FALSE, RT_DIALOG};

        hinstShell = LoadLibrary(TEXT("shell32.dll"));
        if (hinstShell)
        {
            EnumResourceLanguages(hinstShell, RT_DIALOG, MAKEINTRESOURCE(DLG_EXITWINDOWS), EnumResLangProc, (LPARAM)&el);

            FreeLibrary(hinstShell);
        }

        if (PRIMARYLANGID(el.wLang) == LANG_CHINESE
           || PRIMARYLANGID(el.wLang) == LANG_PORTUGUESE )
        {
            // these two languages need special handling
            langRes = el.wLang;
        }
        else
        {
            // otherwise we use only primary langid.
            langRes = MAKELANGID(PRIMARYLANGID(el.wLang), SUBLANG_NEUTRAL);
        }
    }
    return langRes;
}

//
//  CCGetProperThreadLocale
//
//  This function computes its brains out and tries to decide
//  which thread locale we should use for our UI components.
//
//  Returns the desired locale.
//
//  Adjustment - For Arabic / Hebrew - NT4 Only
//
//      Converts the thread locale to US, so that neutral resources
//      loaded by the thread will be the US-English one, if available.
//      This is used when the locale is Arabic/Hebrew and the system is
//      NT4 enabled ( There was no localized NT4), as a result we need
//      always to see the English resources on NT4 Arabic/Hebrew.
//      [samera]
//
//  Adjustment - For all languages - NT4 Only
//
//      Convert the thread locale to the shell locale if not otherwise
//      altered by previous adjustments.
//
//  Adjustment - For all languages - NT5 Only
//
//      Always use the default UI language.  If that fails, then use the
//      shell locale.
//
//  The last two adjustments are handled in a common function, because
//  the NT5 fallback turns out to be equal to the NT4 algorithm.
//
LCID CCGetProperThreadLocale(OPTIONAL LCID *plcidPrev)
{
    LANGID uLangAlt, uLangMUI;
    LCID lcidRet, iLcidThreadOrig; 

    iLcidThreadOrig = GetThreadLocale();
    if (plcidPrev)
        *plcidPrev = iLcidThreadOrig;

    uLangMUI = GetMUILanguage();
    if ( uLangMUI ==  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
    {
        // return adjusted system default locale if MUI isn't initialized
        //
        lcidRet = CCGetSystemDefaultThreadLocale(iLcidThreadOrig);
    }
    else
    {
        // our host has initialized us with prefered MUI language
        // 
        lcidRet = MAKELCID(uLangMUI, SORT_DEFAULT);
    }

    uLangAlt = GetAltFontLangId(LANGIDFROMLCID(lcidRet));
    if (uLangAlt != LANGIDFROMLCID(lcidRet))
    {
        // use secondary resource for the language
        // if the platform *does* have the alternative font
        lcidRet = MAKELCID(uLangAlt, SORTIDFROMLCID(lcidRet));
    }
    
    return lcidRet;
}

//
//  CCLoadStringEx
//
//  Just like LoadString, except you can specify the language, too.
//
//  This is harder than you think, because NT5 changed the way strings
//  are loaded.  Quote:
//
//      We changed the resource loader in NT5, to only load resources
//      in the language of the thread locale, if the thread locale is
//      different to the user locale. The reasoning behind this was
//      the "random" loading of the language of the user locale in
//      the UI. This breaks if you do a SetThreadLocale to the User
//      Locale, because then the whole step is ignored and the
//      InstallLanguage of the system is loaded.
//
//  Therefore, we have to use FindResourceEx.
//
//
int CCLoadStringEx(UINT uID, LPWSTR lpBuffer, int nBufferMax, WORD wLang)
{
    return CCLoadStringExInternal(HINST_THISDLL, uID, lpBuffer, nBufferMax, wLang);
}

int CCLoadStringExInternal(HINSTANCE hInst, UINT uID, LPWSTR lpBuffer, int nBufferMax, WORD wLang)
{
    PWCHAR pwch;
    HRSRC hrsrc;
    int cwch = 0;

    if (nBufferMax <= 0) return 0;                  // sanity check

    /*
     *  String tables are broken up into "bundles" of 16 strings each.
     */

    hrsrc = FindResourceExRetry(hInst, RT_STRING,
                                (LPCTSTR)(LONG_PTR)(1 + (USHORT)uID / 16),
                                wLang);
    if (hrsrc) {
        pwch = (PWCHAR)LoadResource(hInst, hrsrc);
        if (pwch) {
            /*
             *  Now skip over the strings in the resource until we
             *  hit the one we want.  Each entry is a counted string,
             *  just like Pascal.
             */
            for (uID %= 16; uID; uID--) {
                pwch += *pwch + 1;
            }
            cwch = min(*pwch, nBufferMax - 1);
            memcpy(lpBuffer, pwch+1, cwch * sizeof(WCHAR)); /* Copy the goo */
        }
    }
    lpBuffer[cwch] = L'\0';                 /* Terminate the string */
    return cwch;
}


//
//  LocalizedLoadString
//
//  Loads a string from our resources, using the correct language.
//

int LocalizedLoadString(UINT uID, LPWSTR lpBuffer, int nBufferMax)
{
    return CCLoadStringEx(uID, lpBuffer, nBufferMax,
                LANGIDFROMLCID(CCGetProperThreadLocale(NULL)));
}

//
// Determine if the prop sheet frame should use the new
// "MS Shell Dlg 2" font.  To do this, we examine each page's dlg template.
// If all pages have SHELLFONT enabled, then
// we want to use the new font.
//
BOOL ShouldUseMSShellDlg2Font(LPPROPDATA ppd)
{
    UINT iPage;
    PAGEINFOEX pi;
    LANGID langidMUI;

    if (!staticIsOS(OS_WIN2000ORGREATER))
        return FALSE;

    langidMUI = GetMUILanguage();
    for (iPage = 0; iPage < ppd->psh.nPages; iPage++)
    {
        if (GetPageInfoEx(ppd, GETPISP(ppd, iPage), &pi, langidMUI, GPI_DIALOGEX))
        {
            if (!IsPageInfoSHELLFONT(&pi))
            {
                return FALSE;
            }
        }
    }
    return TRUE;
}

PSPT_OS Prsht_GetOS()
{
    static PSPT_OS pspt_os = (PSPT_OS)-1;
    int iIsOSBiDiEnabled = 0;
    
    if (pspt_os != (PSPT_OS)-1)
    {
        return pspt_os;
    }


    iIsOSBiDiEnabled = GetSystemMetrics(SM_MIDEASTENABLED);
    
    if (staticIsOS(OS_WIN2000ORGREATER))
    {
        pspt_os = PSPT_OS_WINNT5;
    }
    else if (iIsOSBiDiEnabled && staticIsOS(OS_NT4ORGREATER) && (!staticIsOS(OS_WIN2000ORGREATER)))
    {
        pspt_os = PSPT_OS_WINNT4_ENA;        
    }
    else if (iIsOSBiDiEnabled && staticIsOS(OS_WIN95ORGREATER) && (!staticIsOS(OS_WIN98)))
    {
        pspt_os = PSPT_OS_WIN95_BIDI;
    }
    else if (iIsOSBiDiEnabled && staticIsOS(OS_WIN98))     
    {
        pspt_os = PSPT_OS_WIN98_BIDI;
    }
    else 
    {
        pspt_os = PSPT_OS_OTHER;
    }

    return pspt_os;
}

PSPT_OVERRIDE Prsht_GetOverrideState(LPPROPDATA ppd)
{
   // if passed bad argument, assume no override
   if(!ppd)
       return PSPT_OVERRIDE_NOOVERRIDE;
       
   if (ppd->psh.dwFlags & PSH_USEPAGELANG)
       return PSPT_OVERRIDE_USEPAGELANG;

   return PSPT_OVERRIDE_NOOVERRIDE; 
}

PSPT_TYPE Prsht_GetType(LPPROPDATA ppd, WORD wLang)
{

   PISP pisp = NULL;
   // if passed bad argument, give it the english resources
    if(!ppd)
        return PSPT_TYPE_ENGLISH;

    pisp = GETPISP(ppd, 0);
    if(pisp)
    {
        PAGEINFOEX pi = {0};

        if ((IS_PROCESS_RTL_MIRRORED()) || 
            (GetPageInfoEx(ppd, pisp, &pi, wLang, GPI_BMIRROR) && pi.bMirrored))
            return PSPT_TYPE_MIRRORED;

        else
        {
            WORD wLang = LANGIDFROMLCID(CCGetProperThreadLocale(NULL));
                        
            GetPageLanguage(pisp,&wLang);
            if((PRIMARYLANGID(wLang) == LANG_ARABIC) || (PRIMARYLANGID(wLang) == LANG_HEBREW))
                return PSPT_TYPE_ENABLED;
        }
    }

    return PSPT_TYPE_ENGLISH;
}

PSPT_ACTION Prsht_GetAction(PSPT_TYPE pspt_type, PSPT_OS pspt_os, PSPT_OVERRIDE pspt_override)
{
    if ((pspt_type < 0) || (pspt_type >= PSPT_TYPE_MAX)
        || (pspt_os < 0) || (pspt_os >= PSPT_OS_MAX)
        || (pspt_override < 0) || (pspt_override >= PSPT_OVERRIDE_MAX))
        return PSPT_ACTION_NOACTION;

    return g_PSPT_Action[pspt_type][pspt_os][pspt_override];   

}

void Prsht_PrepareTemplate(LPPROPDATA ppd, HINSTANCE hInst, HGLOBAL *phDlgTemplate, HRSRC *phResInfo, 
                          LPCSTR lpName, HWND hWndOwner, LPWORD lpwLangID)
{

    
    LPDLGTEMPLATE pDlgTemplate = NULL;
    PSPT_ACTION pspt_action;

    if (pDlgTemplate = (LPDLGTEMPLATE)LockResource(*phDlgTemplate))
    {   

        // We save BiDi templates as DIALOG (not DIALOGEX)
        // If we got an extended template then it is not ours
        
        if (((LPDLGTEMPLATEEX)pDlgTemplate)->wSignature == 0xFFFF)
            return;

        // Cut it short to save time
        //
        if (!(pDlgTemplate->dwExtendedStyle & (RTL_MIRRORED_WINDOW | RTL_NOINHERITLAYOUT)))
           return;
    }

    pspt_action = Prsht_GetAction(Prsht_GetType(ppd, *lpwLangID), Prsht_GetOS(), 
                                              Prsht_GetOverrideState(ppd));
                                              
    switch(pspt_action)
    {
        case PSPT_ACTION_NOACTION:
            return;

        case PSPT_ACTION_NOMIRRORING:
        {
            if (pDlgTemplate)
            {   
                EditBiDiDLGTemplate(pDlgTemplate, EBDT_NOMIRROR, NULL, 0);
            }    
        }
        break;

        case PSPT_ACTION_FLIP:
        {
            if (pDlgTemplate)
            {
                EditBiDiDLGTemplate(pDlgTemplate, EBDT_NOMIRROR, NULL, 0);
                EditBiDiDLGTemplate(pDlgTemplate, EBDT_FLIP, (PWORD)&wIgnoreIDs, ARRAYSIZE(wIgnoreIDs));
                ppd->fFlipped = TRUE;
            }    
        }
        break;

        case PSPT_ACTION_LOADENGLISH:
        {
            HGLOBAL hDlgTemplateTemp = NULL;
            HRSRC hResInfoTemp;

                            //
            //Try to load an English resource.
            //
            *lpwLangID = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

            if ((hResInfoTemp = FindResourceExA( hInst, (LPCSTR)RT_DIALOG, lpName, *lpwLangID)))
            {
                hDlgTemplateTemp = LoadResource(hInst, hResInfoTemp);
            }
            if (hDlgTemplateTemp)
            {
                //
                //And return it to the caller to use it.
                // Since we loaeded a new template, we should copy it to a local memory
                // in case there is a callback.
                //
  
                DWORD   cbTemplate = SizeofResource(hInst, hResInfoTemp);
                LPVOID  pTemplateMod;

                pTemplateMod = (LPVOID)LocalAlloc(LPTR, cbTemplate * 2);
                if (pTemplateMod)
                {
                    memmove(pTemplateMod, hDlgTemplateTemp, cbTemplate);
                    LocalFree(*phDlgTemplate);
                    *phResInfo     = hResInfoTemp;
                    *phDlgTemplate = pTemplateMod;
                }
             }

        }
        break;

        case PSPT_ACTION_WIN9XCOMPAT:
        {
            if (pDlgTemplate)
            {
                pDlgTemplate->style |= DS_BIDI_RTL;
            }   
        }
    }
}


INT_PTR _RealPropertySheet(LPPROPDATA ppd)
{
    HWND    hwndMain;
    MSG32   msg32;
    HWND    hwndTopOwner;
    int     nReturn = -1;
    HWND    hwndOriginalFocus;
    WORD    wLang, wUserLang;
    LCID    iLcidThread=0L;
    HRSRC   hrsrc = 0;
    LPVOID  pTemplate, pTemplateMod;
    LPTSTR  lpDlgId;
    if (ppd->psh.nPages == 0)
    {
        DebugMsg(DM_ERROR, TEXT("no pages for prop sheet"));
        goto FreePpdAndReturn;
    }

    ppd->hwndCurPage = NULL;
    ppd->nReturn     = -1;
    ppd->nRestart    = 0;

    hwndTopOwner = ppd->psh.hwndParent;
    hwndOriginalFocus = GetFocus();

#ifdef DEBUG
    if (GetAsyncKeyState(VK_CONTROL) < 0) {

        ppd->psh.dwFlags |= PSH_WIZARDHASFINISH;
    }
#endif

    if (!(ppd->psh.dwFlags & PSH_MODELESS))
    {
        //
        // Like dialog boxes, we only want to disable top level windows.
        // NB The mail guys would like us to be more like a regular
        // dialog box and disable the parent before putting up the sheet.
        if (hwndTopOwner)
        {
            while (GetWindowLong(hwndTopOwner, GWL_STYLE) & WS_CHILD)
                hwndTopOwner = GetParent(hwndTopOwner);

            ASSERT(hwndTopOwner);       // Should never get this!
            if ((hwndTopOwner == GetDesktopWindow()) ||
                (EnableWindow(hwndTopOwner, FALSE)))
            {
                //
                // If the window was the desktop window, then don't disable
                // it now and don't reenable it later.
                // Also, if the window was already disabled, then don't
                // enable it later.
                //
                hwndTopOwner = NULL;
            }
        }
    }

#if  !defined(WIN32)
#ifdef FE_IME
    // Win95d-B#754
    // When PCMCIA gets detected, NETDI calls DiCallClassInstaller().
    // The class installer of setupx calls PropertySheet() for msgsrv32.
    // We usually don't prepare thread link info in imm for that process as
    // it won't use IME normaly but we need to treat this case as special.
    //
    if (!ImmFindThreadLink(GetCurrentThreadID()))
    {
        ImmCreateThreadLink(GetCurrentProcessID(),GetCurrentThreadID());
    }
#endif
#endif

    //
    // WARNING! WARNING! WARNING! WARNING!
    //
    // Before you mess with any language stuff, be aware that MFC loads
    // resources directly out of comctl32.dll, so if you change the
    // way we choose the proper resource, you may break MFC apps.
    // See NT bug 302959.

    //
    // Support PSH_USEPAGELANG
    //

    // Presume we load our template based on thread lang id.
    wLang = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    wUserLang= MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    if (ppd->psh.dwFlags & PSH_USEPAGELANG)
    {
        // Get callers language version. We know we have at least one page
        if (FAILED(GetPageLanguage(GETPISP(ppd, 0), &wLang)))
        {
            // failed to get langid out of caller's resource
            // just pretend nothing happened.
            wLang = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
        }
        wUserLang = wLang;
    }
    else
        wLang = LANGIDFROMLCID(CCGetProperThreadLocale(NULL));

    //
    //  The only thing we need the thread locale for is to locate the
    //  correct dialog template.  We don't want it to affect page
    //  initialization or anything else like that, so get the template
    //  and quickly set the locale back before anyone notices.
    //
    //  If we can't get the requested language, retry with the neutral
    //  language.
    //


    // We have seperate dialog templates for Win95 BiDi localized
    // The code used to check to see if we are running on Win98 BiDi localized
    // and load this template.
    // We have a special case when running Office2000 with Arabic/Hebrew SKU on
    // BiDi win95 Enabled where we need to load this template as well
    if(Prsht_GetOS() == PSPT_OS_WIN95_BIDI)
    {
         lpDlgId = MAKEINTRESOURCE(IS_WIZARD(ppd) ? DLG_WIZARD95 : DLG_PROPSHEET95);
         hrsrc = FindResourceEx(
                           HINST_THISDLL, RT_DIALOG,
                           lpDlgId,
                           wLang );
         // we only have DLG_WIZARD95 and DLG_PROPSHEET95 in Arabic & Hebrew language
         // if we got any other language we will fail
         // In this case, let's use the normal templates
         if(hrsrc)
         {
             ppd->fFlipped = TRUE;
         }
         else
         {
             lpDlgId = MAKEINTRESOURCE(IS_WIZARD(ppd) ? DLG_WIZARD : DLG_PROPSHEET);
             hrsrc = FindResourceExRetry(
                               HINST_THISDLL, RT_DIALOG,
                               lpDlgId,
                                wLang );             
         }
    
    }
    else
    {
        lpDlgId = MAKEINTRESOURCE(IS_WIZARD(ppd) ? DLG_WIZARD : DLG_PROPSHEET);

        hrsrc = FindResourceExRetry(
                               HINST_THISDLL, RT_DIALOG,
                               lpDlgId,
                               wLang );
    }
    // Setup for failure
    hwndMain = NULL;

    if (hrsrc &&
        (pTemplate = (LPVOID)LoadResource(HINST_THISDLL, hrsrc)))
    {
        DWORD cbTemplate;

        cbTemplate = SizeofResource(HINST_THISDLL, hrsrc);

        pTemplateMod = (LPVOID)LocalAlloc(LPTR, cbTemplate * 2); //double it to give some play leeway

        if (pTemplateMod)
        {
            hmemcpy(pTemplateMod, pTemplate, cbTemplate);
            //Check the direction of this dialog and change it if it does not match the owner.
            Prsht_PrepareTemplate(ppd, HINST_THISDLL, &pTemplateMod, (HRSRC *)&hrsrc, 
                                 (LPSTR)lpDlgId,ppd->psh.hwndParent, &wUserLang);
        }
        else
        {
            pTemplateMod = pTemplate;       // no modifications
        }

        //
        //  Template editing and callbacks happen only if we were able
        //  to create a copy for modifying.
        //
        if (pTemplateMod != pTemplate)
        {
            if (ppd->psh.dwFlags & PSH_NOCONTEXTHELP)
            {
                if (((LPDLGTEMPLATEEX)pTemplateMod)->wSignature ==  0xFFFF){
                    ((LPDLGTEMPLATEEX)pTemplateMod)->dwStyle &= ~DS_CONTEXTHELP;
                } else {
                    ((LPDLGTEMPLATE)pTemplateMod)->style &= ~DS_CONTEXTHELP;
                }
            }

            if (IS_WIZARD(ppd) &&
                (ppd->psh.dwFlags & PSH_WIZARDCONTEXTHELP)) {

                if (((LPDLGTEMPLATEEX)pTemplateMod)->wSignature ==  0xFFFF){
                    ((LPDLGTEMPLATEEX)pTemplateMod)->dwStyle |= DS_CONTEXTHELP;
                } else {
                    ((LPDLGTEMPLATE)pTemplateMod)->style |= DS_CONTEXTHELP;
                }
            }

            // extra check for PSH_USEPAGELANG case
            if (ppd->psh.pfnCallback)
            {
#ifdef WX86
                if (ppd->fFlags & PD_WX86)
                    Wx86Callback(ppd->psh.pfnCallback, NULL, PSCB_PRECREATE, (LPARAM)(LPVOID)pTemplateMod);
                else
#endif
                    ppd->psh.pfnCallback(NULL, PSCB_PRECREATE, (LPARAM)(LPVOID)pTemplateMod);
            }
        }


        if (pTemplateMod)
        {
            //
            // For NT, we want to use MS Shell Dlg 2 font in the prop sheet if
            // all of the pages in the sheet use MS Shell Dlg 2.
            // To do this, we ensure the template is DIALOGEX and that the 
            // DS_SHELLFONT style bits (DS_SHELLFONT | DS_FIXEDSYS) are set.
            //
            if (ShouldUseMSShellDlg2Font(ppd))
            {
                if (((LPDLGTEMPLATEEX)pTemplateMod)->wSignature != 0xFFFF)
                {
                    //
                    // Convert DLGTEMPLATE to DLGTEMPLATEEX.
                    //
                    LPVOID pTemplateCvtEx;            
                    int    iCharset = GetDefaultCharsetFromLang(wLang);
                    if (SUCCEEDED(CvtDlgToDlgEx(pTemplateMod, (LPDLGTEMPLATEEX *)&pTemplateCvtEx, iCharset)))
                    {
                        LocalFree(pTemplateMod);
                        pTemplateMod = pTemplateCvtEx;
                    } else {
                        // Unable to convert to ShellFont; oh well
                        goto NotShellFont;
                    }
                }
                //
                // Set DS_SHELLFONT style bits so we get "MS Shell Dlg2" font.
                //
                ((LPDLGTEMPLATEEX)pTemplateMod)->dwStyle |= DS_SHELLFONT;
                ppd->fFlags |= PD_SHELLFONT;
        NotShellFont:;
            }

            // pTemplateMod is always unicode, even for the A function - no need to thunk
            hwndMain = CreateDialogIndirectParam(HINST_THISDLL, pTemplateMod,
                ppd->psh.hwndParent, PropSheetDlgProc, (LPARAM)(LPPROPDATA)ppd);

            // WORK AROUND WOW/USER BUG:  Even though InitPropSheetDlg sets
            // ppd->hDlg, in the WOW scenario, the incoming hDlg is WRONG!
            // The USER guys say "Tough.  You have to work around it."
            ppd->hDlg = hwndMain;
        }
        if (pTemplateMod != pTemplate)
            LocalFree(pTemplateMod);
    }

    if (!hwndMain)
    {
        int iPage;

        DebugMsg(DM_ERROR, TEXT("PropertySheet: unable to create main dialog"));

        if (hwndTopOwner && !(ppd->psh.dwFlags & PSH_MODELESS))
            EnableWindow(hwndTopOwner, TRUE);

        // Release all page objects in REVERSE ORDER so we can have
        // pages that are dependant on eachother based on the initial
        // order of those pages
        //
        for (iPage = (int)ppd->psh.nPages - 1; iPage >= 0; iPage--)
        {
            ULONG_PTR dw = PropPageActivateContext(ppd, GETPISP(ppd, iPage));
            DestroyPropertySheetPage(GETHPAGE(ppd, iPage));
            PropPageDeactivateContext(dw); 
        }

        goto FreePpdAndReturn;
    }

    if (ppd->psh.dwFlags & PSH_MODELESS)
        return (INT_PTR)hwndMain;

    while( ppd->hwndCurPage && GetMessage32(&msg32, NULL, 0, 0, TRUE) )
    {
        // if (PropSheet_IsDialogMessage(ppd->hDlg, (LPMSG)&msg32))
        if (Prop_IsDialogMessage(ppd, &msg32))
            continue;

        TranslateMessage32(&msg32, TRUE);
        DispatchMessage32(&msg32, TRUE);
    }

    if( ppd->hwndCurPage )
    {
        // GetMessage returned FALSE (WM_QUIT)
        DebugMsg( DM_TRACE, TEXT("PropertySheet: bailing in response to WM_QUIT (and reposting quit)") );
        ButtonPushed( ppd, IDCANCEL );  // nuke ourselves
        PostQuitMessage( (int) msg32.wParam );  // repost quit for next enclosing loop
    }

    // don't let this get mangled during destroy processing
    nReturn = ppd->nReturn ;

    if (ppd->psh.hwndParent && (GetActiveWindow() == hwndMain)) {
        DebugMsg(DM_TRACE, TEXT("Passing activation up"));
        SetActiveWindow(ppd->psh.hwndParent);
    }

    if (hwndTopOwner)
        EnableWindow(hwndTopOwner, TRUE);

    if (IsWindow(hwndOriginalFocus)) {
        SetFocus(hwndOriginalFocus);
    }

    DestroyWindow(hwndMain);

    // do pickup any PSM_REBOOTSYSTEM or PSM_RESTARTWINDOWS sent during destroy
    if ((nReturn > 0) && ppd->nRestart)
        nReturn = ppd->nRestart;

FreePpdAndReturn:

#ifdef WIN32
    LocalFree((HLOCAL)ppd);
#else
    LocalFree((HLOCAL)LOWORD(ppd));
#endif

    return nReturn;
}




HPROPSHEETPAGE WINAPI CreateProxyPage(HPROPSHEETPAGE hpage16, HINSTANCE hinst16)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return NULL;
}

// DestroyPropsheetPageArray
//
//  Helper function used during error handling.  It destroys the
//  incoming property sheet pages.

void DestroyPropsheetPageArray(LPCPROPSHEETHEADER ppsh)
{
    int iPage;

    if (!(ppsh->dwFlags & PSH_PROPSHEETPAGE))
    {
        // Release all page objects in REVERSE ORDER so we can have
        // pages that are dependant on eachother based on the initial
        // order of those pages

        for (iPage = (int)ppsh->nPages - 1; iPage >= 0; iPage--)
        {
            DestroyPropertySheetPage(ppsh->H_phpage[iPage]);
        }
    }
}

// PropertySheet API
//
// This function displays the property sheet described by ppsh.
//
// Since I don't expect anyone to ever check the return value
// (we certainly don't), we need to make sure any provided phpage array
// is always freed with DestroyPropertySheetPage, even if an error occurs.
//
//
//  The fNeedShadow parameter means "The incoming LPCPROPSHEETHEADER is in the
//  opposite character set from what you implement natively".
//
//  If we are compiling UNICODE, then fNeedShadow is TRUE if the incoming
//  LPCPROPSHEETHEADER is really an ANSI property sheet page.
//
//  If we are compiling ANSI-only, then fNeedShadow is always FALSE because
//  we don't support UNICODE in the ANSI-only version.
//

INT_PTR WINAPI _PropertySheet(LPCPROPSHEETHEADER ppsh, BOOL fNeedShadow)
{
    PROPDATA *ppd;
    int iPage;

    //
    // validate header
    //
    ASSERT(IsValidPROPSHEETHEADERSIZE(sizeof(PROPSHEETHEADER)));

    if (!IsValidPROPSHEETHEADERSIZE(ppsh->dwSize))
    {
        DebugMsg( DM_ERROR, TEXT("PropertySheet: dwSize is not correct") );
        goto invalid_call;
    }

    if (ppsh->dwFlags & ~PSH_ALL)
    {
        DebugMsg( DM_ERROR, TEXT("PropertySheet: invalid flags") );
        goto invalid_call;
    }

    if (ppsh->nPages >= MAXPROPPAGES)
    {
        DebugMsg( DM_ERROR, TEXT("PropertySheet: too many pages ( use MAXPROPPAGES )") );
        goto invalid_call;
    }

    ppd = (PROPDATA *)LocalAlloc(LPTR, sizeof(PROPDATA));
    if (ppd == NULL)
    {
        DebugMsg(DM_ERROR, TEXT("failed to alloc property page data"));

invalid_call:
        DestroyPropsheetPageArray(ppsh);
        return -1;
    }

    //  Initialize the flags.
    ppd->fFlags      = FALSE;

#ifdef WX86
    //
    //  If Wx86 is calling, set the flag that thunks the callbacks.
    //

    if ( Wx86IsCallThunked() ) {
        ppd->fFlags |= PD_WX86;
    }
#endif

    if (fNeedShadow)
        ppd->fFlags |= PD_NEEDSHADOW;

    // make a copy of the header so we can party on it
    hmemcpy(&ppd->psh, ppsh, ppsh->dwSize);

    // so we don't have to check later...
    if (!(ppd->psh.dwFlags & PSH_USECALLBACK))
        ppd->psh.pfnCallback = NULL;

    // fix up the page pointer to point to our copy of the page array
    ppd->psh.H_phpage = ppd->rghpage;

    GetCurrentActCtx(&ppd->hActCtxInit);

    if (ppd->psh.dwFlags & PSH_PROPSHEETPAGE)
    {
        // for lazy clients convert PROPSHEETPAGE structures into page handles
        LPCPROPSHEETPAGE ppsp = ppsh->H_ppsp;

        for (iPage = 0; iPage < (int)ppd->psh.nPages; iPage++)
        {
            ppd->psh.H_phpage[iPage] = _CreatePropertySheetPage(ppsp, fNeedShadow,
                ppd->fFlags & PD_WX86);
            if (!ppd->psh.H_phpage[iPage])
            {
                iPage--;
                ppd->psh.nPages--;
            }

            ppsp = (LPCPROPSHEETPAGE)((LPBYTE)ppsp + ppsp->dwSize);      // next PROPSHEETPAGE structure
        }
    }
    else
    {
        // The UNICODE build needs to hack around Hijaak 95.
        //
        ppd->psh.nPages = 0;
        for (iPage = 0; iPage < (int)ppsh->nPages; iPage++)
        {
            ppd->psh.H_phpage[ppd->psh.nPages] = _Hijaak95Hack(ppd, ppsh->H_phpage[iPage]);
            if (ppd->psh.H_phpage[ppd->psh.nPages])
            {
                ppd->psh.nPages++;
            }
        }
    }

    //
    //  Everybody else assumes that the HPROPSHEETPAGEs have been
    //  internalized, so let's do that before anybody notices.
    //
    for (iPage = 0; iPage < (int)ppd->psh.nPages; iPage++)
    {
        SETPISP(ppd, iPage, InternalizeHPROPSHEETPAGE(ppd->psh.H_phpage[iPage]));
    }

    //
    //  Walk all pages to see if any have help and if so, set the PSH_HASHELP
    //  flag in the header.
    //
    if (!(ppd->psh.dwFlags & PSH_HASHELP))
    {
        for (iPage = 0; iPage < (int)ppd->psh.nPages; iPage++)
        {
            if (GETPPSP(ppd, iPage)->dwFlags & PSP_HASHELP)
            {
                ppd->psh.dwFlags |= PSH_HASHELP;
                break;
            }
        }
    }

    return _RealPropertySheet(ppd);
}

INT_PTR WINAPI PropertySheetW(LPCPROPSHEETHEADERW ppsh)
{
    return _PropertySheet(ppsh, FALSE);
}

INT_PTR WINAPI PropertySheetA(LPCPROPSHEETHEADERA ppsh)
{
    PROPSHEETHEADERW pshW;
    INT_PTR iResult;

    //
    //  Most validation is done by _PropertySheet, but we need
    //  to validate the header size, or we won't survive the thunk.
    //
    if (!IsValidPROPSHEETHEADERSIZE(ppsh->dwSize))
    {
        DebugMsg( DM_ERROR, TEXT("PropertySheet: dwSize is not correct") );
        goto Error;
    }

    if (!ThunkPropSheetHeaderAtoW(ppsh, &pshW))
        goto Error;

    iResult = _PropertySheet(&pshW, TRUE);

    FreePropSheetHeaderW(&pshW);

    return iResult;

Error:
    DestroyPropsheetPageArray((LPCPROPSHEETHEADER)ppsh);
    return -1;
}

//
//  CopyPropertyPageStrings
//
//  We have a PROPSHEETPAGE structure that contains pointers to strings.
//  For each string, create a copy and smash the pointer-to-copy in the
//  place where the original static pointer used to be.
//
//  The method of copying varies depending on what kind of copy we want
//  to make, so we use a callback procedure.
//
//  UNICODE-to-UNICODE: StrDupW
//  ANSI-to-UNICODE:    StrDup_AtoW
//  ANSI-to-ANSI:       StrDupA
//
//  On failure, all strings that did not get properly duplicated are set
//  to NULL.  You still have to call FreePropertyPageStrings to clear
//  them out.  Notice that when we fail to allocate, we merely make a note
//  of the fact and continue onward.  This ensures that all string fields
//  are set to NULL if they could not be dup'd.
//
//  ppsp - A pointer to either a PROPSHEETPAGEA or PROPSHEETPAGEW.
//         The two structures are laid out identically, so it doesn't matter.
//
//  pfnStrDup - function that will make the appropriate copy.
//

BOOL CopyPropertyPageStrings(LPPROPSHEETPAGE ppsp, STRDUPPROC pfnStrDup)
{
    BOOL fSuccess = TRUE;

    if (!(ppsp->dwFlags & PSP_DLGINDIRECT) && !IS_INTRESOURCE(ppsp->P_pszTemplate))
    {
        ppsp->P_pszTemplate = pfnStrDup(ppsp->P_pszTemplate);
        if (!ppsp->P_pszTemplate)
            fSuccess = FALSE;
    }

    if ((ppsp->dwFlags & PSP_USEICONID) && !IS_INTRESOURCE(ppsp->P_pszIcon))
    {
        ppsp->P_pszIcon = pfnStrDup(ppsp->P_pszIcon);
        if (!ppsp->P_pszIcon)
            fSuccess = FALSE;
    }

    if ((ppsp->dwFlags & PSP_USETITLE) && !IS_INTRESOURCE(ppsp->pszTitle))
    {
        ppsp->pszTitle = pfnStrDup(ppsp->pszTitle);
        if (!ppsp->pszTitle)
            fSuccess = FALSE;
    }

    if ((ppsp->dwFlags & PSP_USEHEADERTITLE) && !IS_INTRESOURCE(ppsp->pszHeaderTitle))
    {
        ppsp->pszHeaderTitle = pfnStrDup(ppsp->pszHeaderTitle);
        if (!ppsp->pszHeaderTitle)
            fSuccess = FALSE;
    }

    if ((ppsp->dwFlags & PSP_USEHEADERSUBTITLE) && !IS_INTRESOURCE(ppsp->pszHeaderSubTitle))
    {
        ppsp->pszHeaderSubTitle = pfnStrDup(ppsp->pszHeaderSubTitle);
        if (!ppsp->pszHeaderSubTitle)
            fSuccess = FALSE;
    }

    return fSuccess;
}

//
//  FreePropertyPageStrings
//
//  Free the strings that live inside a property sheet page structure.
//
//  ppsp - A pointer to either a PROPSHEETPAGEA or PROPSHEETPAGEW.
//         The two structures are laid out identically, so it doesn't matter.
//

void FreePropertyPageStrings(LPCPROPSHEETPAGE ppsp)
{
    if (!(ppsp->dwFlags & PSP_DLGINDIRECT) && !IS_INTRESOURCE(ppsp->P_pszTemplate))
        LocalFree((LPVOID)ppsp->P_pszTemplate);

    if ((ppsp->dwFlags & PSP_USEICONID) && !IS_INTRESOURCE(ppsp->P_pszIcon))
        LocalFree((LPVOID)ppsp->P_pszIcon);

    if ((ppsp->dwFlags & PSP_USETITLE) && !IS_INTRESOURCE(ppsp->pszTitle))
        LocalFree((LPVOID)ppsp->pszTitle);

    if ((ppsp->dwFlags & PSP_USEHEADERTITLE) && !IS_INTRESOURCE(ppsp->pszHeaderTitle))
        LocalFree((LPVOID)ppsp->pszHeaderTitle);

    if ((ppsp->dwFlags & PSP_USEHEADERSUBTITLE) && !IS_INTRESOURCE(ppsp->pszHeaderSubTitle))
        LocalFree((LPVOID)ppsp->pszHeaderSubTitle);
}

//*************************************************************
//
//  ThunkPropSheetHeaderAtoW ()
//
//  Purpose:  Thunks the Ansi version of PROPSHEETHEADER to
//            Unicode.
//
//            Note that the H_phpage / H_ppsp field is not thunked.
//            We'll deal with that separately.
//
//*************************************************************

BOOL ThunkPropSheetHeaderAtoW (LPCPROPSHEETHEADERA ppshA,
                                LPPROPSHEETHEADERW ppsh)
{
    //
    //  Deciding whether an item should be freed or not is tricky, so we
    //  keep a private array of all the pointers we've allocated, so we
    //  know what to free when we fail.
    //
    LPTSTR Alloced[5] = { 0 };

    ASSERT(IsValidPROPSHEETHEADERSIZE(ppshA->dwSize));

    hmemcpy(ppsh, ppshA, ppshA->dwSize);

    ppsh->dwFlags |= PSH_THUNKED;
    if ((ppsh->dwFlags & PSH_USEICONID) && !IS_INTRESOURCE(ppsh->H_pszIcon))
    {
        ppsh->H_pszIcon = Alloced[0] = StrDup_AtoW(ppsh->H_pszIcon);
        if (!ppsh->H_pszIcon)
            goto ExitIcon;
    }

    if (!IS_WIZARDPSH(*ppsh) && !IS_INTRESOURCE(ppsh->pszCaption))
    {
        ppsh->pszCaption = Alloced[1] = StrDup_AtoW(ppsh->pszCaption);
        if (!ppsh->pszCaption)
            goto ExitCaption;
    }

    if ((ppsh->dwFlags & PSH_USEPSTARTPAGE) && !IS_INTRESOURCE(ppsh->H_pStartPage))
    {
        ppsh->H_pStartPage = Alloced[2] = StrDup_AtoW(ppsh->H_pStartPage);
        if (!ppsh->H_pStartPage)
            goto ExitStartPage;
    }

    if (ppsh->dwFlags & PSH_WIZARD97)
    {
        if ((ppsh->dwFlags & PSH_WATERMARK) &&
            !(ppsh->dwFlags & PSH_USEHBMWATERMARK) &&
            !IS_INTRESOURCE(ppsh->H_pszbmWatermark))
        {
            ppsh->H_pszbmWatermark = Alloced[3] = StrDup_AtoW(ppsh->H_pszbmWatermark);
            if (!ppsh->H_pszbmWatermark)
                goto ExitWatermark;
        }

        if ((ppsh->dwFlags & PSH_HEADER) &&
            !(ppsh->dwFlags & PSH_USEHBMHEADER) &&
            !IS_INTRESOURCE(ppsh->H_pszbmHeader))
        {
            ppsh->H_pszbmHeader = Alloced[4] = StrDup_AtoW(ppsh->H_pszbmHeader);
            if (!ppsh->H_pszbmHeader)
                goto ExitHeader;
        }
    }

    return TRUE;

ExitHeader:
    if (Alloced[3]) LocalFree(Alloced[3]);
ExitWatermark:
    if (Alloced[2]) LocalFree(Alloced[2]);
ExitStartPage:
    if (Alloced[1]) LocalFree(Alloced[1]);
ExitCaption:
    if (Alloced[0]) LocalFree(Alloced[0]);
ExitIcon:
    return FALSE;
}

void FreePropSheetHeaderW(LPPROPSHEETHEADERW ppsh)
{
    if ((ppsh->dwFlags & PSH_USEICONID) && !IS_INTRESOURCE(ppsh->H_pszIcon))
        LocalFree((LPVOID)ppsh->H_pszIcon);

    if (!IS_WIZARDPSH(*ppsh) && !IS_INTRESOURCE(ppsh->pszCaption))
        LocalFree((LPVOID)ppsh->pszCaption);

    if ((ppsh->dwFlags & PSH_USEPSTARTPAGE) && !IS_INTRESOURCE(ppsh->H_pStartPage))
        LocalFree((LPVOID)ppsh->H_pStartPage);

    if (ppsh->dwFlags & PSH_WIZARD97)
    {
        if ((ppsh->dwFlags & PSH_WATERMARK) &&
            !(ppsh->dwFlags & PSH_USEHBMWATERMARK) &&
            !IS_INTRESOURCE(ppsh->H_pszbmWatermark))
            LocalFree((LPVOID)ppsh->H_pszbmWatermark);

        if ((ppsh->dwFlags & PSH_HEADER) &&
            !(ppsh->dwFlags & PSH_USEHBMHEADER) &&
            !IS_INTRESOURCE(ppsh->H_pszbmHeader))
            LocalFree((LPVOID)ppsh->H_pszbmHeader);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\prpage.c ===
#include "ctlspriv.h"
#include "prshti.h"

#ifdef WX86
#include <wx86ofl.h>
#endif

#define _Rstrcpyn   lstrcpyn

//
//  Miracle of miracles - Win95 implements lstrlenW.
//
#define _Rstrlen    lstrlenW

#define RESCHAR WCHAR

#include <pshpack2.h>

typedef struct                           
{                                        
    WORD    wDlgVer;                     
    WORD    wSignature;                  
    DWORD   dwHelpID;                    
    DWORD   dwExStyle;                   
    DWORD   dwStyle;                     
    WORD    cDlgItems;
    WORD    x;                           
    WORD    y;                           
    WORD    cx;                          
    WORD    cy;                          
}   DLGEXTEMPLATE, *LPDLGEXTEMPLATE;

#include <poppack.h> /* Resume normal packing */

//
//  CallPropertyPageCallback
//
//  Call the callback for the property page, passing it the correct lParam
//  based on the character set it wants.
//
UINT CallPropertyPageCallback(PROPDATA* ppd, PISP pisp, UINT uMsg)
{
    UINT uiResult = TRUE;           // assume success

    if (HASCALLBACK(pisp) &&
        (pisp->_psp.dwSize > PROPSHEETPAGE_V1_SIZE ||
         uMsg == PSPCB_CREATE || uMsg == PSPCB_RELEASE))
    {
        ULONG_PTR dwCookie = PropPageActivateContext(ppd, pisp);

        if (HASANSISHADOW(pisp))
        {
#ifdef WX86
            if ( pisp->_pfx.dwInternalFlags & PSPI_WX86 )
                uiResult = Wx86Callback(pisp->_psp.pfnCallback, NULL, uMsg, (LPARAM) &pisp->_cpfx.pispShadow->_psp);
            else
#endif
                uiResult = pisp->_psp.pfnCallback(NULL, uMsg, &pisp->_cpfx.pispShadow->_psp);
        } 
        else
        {
#ifdef WX86
            if ( pisp->_pfx.dwInternalFlags & PSPI_WX86 )
                uiResult = Wx86Callback(pisp->_psp.pfnCallback, NULL, uMsg, (LPARAM) &pisp->_psp);
            else
#endif
                uiResult = pisp->_psp.pfnCallback(NULL, uMsg, &pisp->_psp);
        }

        PropPageDeactivateContext(dwCookie);

    }
    return uiResult;
}

//
//  FreePropertyPageStruct
//
//  Free the memory block that contains a property sheet page.
//  It is the caller's responsibility to have freed all the things
//  that were attached to it.
//
//
__inline void FreePropertyPageStruct(PISP pisp)
{
    LocalFree(PropSheetBase(pisp));
}

//
//  DestroyPropertySheetPage
//
//  Do the appropriate thing to destroy a property sheet page, whether
//  this entails talking to 16-bit thunks, sending the PSPCB_RELEASE,
//  or freeing the shadow page.
//
BOOL WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE hpage)
{
    PISP pisp = InternalizeHPROPSHEETPAGE(hpage);

    CallPropertyPageCallback(NULL, pisp, PSPCB_RELEASE);

    // Do the decrement *after* calling the callback for the last time

    if (HASREFPARENT(pisp))
        InterlockedDecrement((LPLONG)pisp->_psp.pcRefParent);

    if (HASANSISHADOW(pisp))
    {
        FreePropertyPageStrings(&pisp->_cpfx.pispShadow->_psp);
        FreePropertyPageStruct(pisp->_cpfx.pispShadow);
    }

    //
    //  Note that FreePropertyPageStrings will try to destroy strings for
    //  proxy pages, but that's okay, because the corresponding P_pszBlah
    //  fields are all NULL since we never initialized them.
    //
    FreePropertyPageStrings(&pisp->_psp);
    FreePropertyPageStruct(pisp);

    return TRUE;
}


//
// GetPageInfoEx
//
//  Extract information about a page into a PAGEINFOEX structure.
//
//  WARNING!  EVIL HORRIBLE RESTRICTION!
//
//  You are allowed to pass GPI_ICON only once per page.
//
BOOL WINAPI GetPageInfoEx(LPPROPDATA ppd, PISP pisp, PAGEINFOEX *ppi, LANGID langidMUI, DWORD flags)
{
    HRSRC hRes;
    LPDLGTEMPLATE pDlgTemplate;
    LPDLGEXTEMPLATE pDlgExTemplate;
    BOOL bResult = FALSE;
    HGLOBAL hDlgTemplate = 0;
    BOOL bSetFont;
    LPBYTE pszT;

    //
    // Init the output structure.
    //
    ZeroMemory(ppi, sizeof(*ppi));

#ifdef DEBUG
    //  Enforce the GPI_ICON rule.
    if (flags & GPI_ICON)
    {
        ASSERT(!(pisp->_pfx.dwInternalFlags & PSPI_FETCHEDICON));
        pisp->_pfx.dwInternalFlags |= PSPI_FETCHEDICON;
    }

    // For compatibility with 16-bit stuff, you are only allowed to
    // pass these combinations of flags.
    switch (LOWORD(flags)) {
    case GPI_PT | GPI_ICON | GPI_FONT | GPI_BRTL | GPI_CAPTION:
        break;
    case GPI_PT | GPI_ICON |            GPI_BRTL | GPI_CAPTION:
        break;
    case GPI_DIALOGEX:
        break;
    default:
        ASSERT(!"Invalid flags passed to GetPageInfoEx");
        break;
    }
#endif


    if (flags & GPI_ICON) {
        if (pisp->_psp.dwFlags & PSP_USEHICON)
            ppi->hIcon = pisp->_psp.P_hIcon;
        else if (pisp->_psp.dwFlags & PSP_USEICONID)
            ppi->hIcon = LoadImage(pisp->_psp.hInstance, pisp->_psp.P_pszIcon, IMAGE_ICON, g_cxSmIcon, g_cySmIcon, LR_DEFAULTCOLOR);
    }

    if (pisp->_psp.dwFlags & PSP_DLGINDIRECT)
    {
        pDlgTemplate = (LPDLGTEMPLATE)pisp->_psp.P_pResource;
        goto UseTemplate;
    }

    // We also need to stash away the langid that we actually found
    //         so we can later determine if we have to do any ML stuff...
    hRes = FindResourceExRetry(pisp->_psp.hInstance, RT_DIALOG, 
                               pisp->_psp.P_pszTemplate, langidMUI);
    if (hRes)
    {
        hDlgTemplate = LoadResource(pisp->_psp.hInstance, hRes);
        if (hDlgTemplate)
        {
            pDlgTemplate = (LPDLGTEMPLATE)LockResource(hDlgTemplate);
UseTemplate:
            if (pDlgTemplate)
            {
                pDlgExTemplate = (LPDLGEXTEMPLATE) pDlgTemplate;
                //
                // Get the width and the height in dialog units.
                //
                if (pDlgExTemplate->wSignature == 0xFFFF)
                {
                    // DIALOGEX structure
                    ppi->bDialogEx = TRUE;
                    ppi->dwStyle   = pDlgExTemplate->dwStyle;
                    ppi->pt.x      = pDlgExTemplate->cx;
                    ppi->pt.y      = pDlgExTemplate->cy;
                    // Get the RTL reading order for the caption
                    ppi->bRTL = (((pDlgExTemplate->dwExStyle) & WS_EX_RTLREADING) || (pisp->_psp.dwFlags & PSP_RTLREADING)) ? TRUE : FALSE;
                    ppi->bMirrored = ((pDlgExTemplate->dwExStyle) & (RTL_MIRRORED_WINDOW)) ? TRUE : FALSE;

                }
                else
                {
                    ppi->dwStyle = pDlgTemplate->style;
                    ppi->pt.x    = pDlgTemplate->cx;
                    ppi->pt.y    = pDlgTemplate->cy;
                    ppi->bRTL = (pisp->_psp.dwFlags & PSP_RTLREADING) ? TRUE : FALSE;
                }

                bResult = TRUE;

                if (flags & (GPI_CAPTION | GPI_FONT))
                {
                    if (pisp->_psp.dwFlags & PSP_USETITLE)
                    {
                        if (IS_INTRESOURCE(pisp->_psp.pszTitle))
                        {
                            CCLoadStringExInternal(pisp->_psp.hInstance,
                                                  (UINT)LOWORD(pisp->_psp.pszTitle),
                                                   ppi->szCaption,
                                                   ARRAYSIZE(ppi->szCaption),
                                                   langidMUI);
                        }
                        else
                        {
                            // Copy pszTitle
                            lstrcpyn(ppi->szCaption, pisp->_psp.pszTitle, ARRAYSIZE(ppi->szCaption));
                        }
                    }

                    // ML UI support for NT5
                    // Grab the font face and size in point from page so that
                    // we can calculate size of page in real screen pixel
                    // This is for NT5 MLUI but should not be any harm for Win95
                    // or even works better for the platform.

                    // 1. check if the page has font specified
                    if ( ppi->bDialogEx )
                        bSetFont = ((pDlgExTemplate->dwStyle & DS_SETFONT) != 0);
                    else
                        bSetFont = ((pDlgTemplate->style & DS_SETFONT) != 0);

                    // 2. Skip until after class name
                    //    only if either font is set or we want title
                    //
                    if (bSetFont || !(pisp->_psp.dwFlags & PSP_USETITLE))
                    {
                        // Get the caption string from the dialog template, only
                        //
                        if (ppi->bDialogEx)
                            pszT = (BYTE *) (pDlgExTemplate + 1);
                        else
                            pszT = (BYTE *) (pDlgTemplate + 1);

                        // The menu name is either 0xffff followed by a word,
                        // or a string.
                        switch (*(LPWORD)pszT) {
                        case 0xffff:
                            pszT += 2 * sizeof(WORD);
                            break;

                        default:
                            pszT += (_Rstrlen((LPTSTR)pszT) + 1) * sizeof(RESCHAR);
                            break;
                        }
                        //
                        // Now we are pointing at the class name.
                        //
                        pszT += (_Rstrlen((LPTSTR)pszT) + 1) * sizeof(RESCHAR);
                    }
                    // 3. grab the title from template if PSP_USETITLE isn't set
                    //
                    if (!(pisp->_psp.dwFlags & PSP_USETITLE))
                        _Rstrcpyn(ppi->szCaption, (LPTSTR)pszT, ARRAYSIZE(ppi->szCaption));

                    // 4. grab the point size and face name if DS_SETFONT
                    //
                    if (bSetFont && (flags & GPI_FONT))
                    {
                        // skip the title string
                        pszT += (_Rstrlen((LPTSTR)pszT)+1) * sizeof(RESCHAR);
                        ppi->pfd.PointSize = *((short *)pszT)++;
                        if (ppi->bDialogEx)
                        {
                            ((short *)pszT)++; // skip weight as we always use FW_NORMAL w/ DS_3DLOOK
                            ppi->pfd.bItalic  = *(BYTE *)pszT++;
                            ppi->pfd.iCharset = *(BYTE *)pszT++;
                        }
                        else
                        {
                            ppi->pfd.bItalic  = FALSE;
                            ppi->pfd.iCharset = DEFAULT_CHARSET;
                        }

                        _Rstrcpyn(ppi->pfd.szFace, (LPTSTR)pszT, ARRAYSIZE(ppi->pfd.szFace));

                        // But if this is a SHELLFONT page and the font name is "MS Shell Dlg",
                        // then its font secretly gets morphed into MS Shell Dlg 2 (if
                        // all the other pages agree)...  The wackiness continues...
                        if (staticIsOS(OS_WIN2000ORGREATER) &&
                            (ppd->fFlags & PD_SHELLFONT) &&
                            IsPageInfoSHELLFONT(ppi) &&
                            lstrcmpi(ppi->pfd.szFace, TEXT("MS Shell Dlg")) == 0)
                        {
                            _Rstrcpyn(ppi->pfd.szFace, TEXT("MS Shell Dlg 2"), ARRAYSIZE(ppi->pfd.szFace));
                        }
                        //
                        //  USER quirk #2: If the font height is 0x7FFF, then
                        //  USER really uses the MessageBox font and no font
                        //  information is stored in the dialog template.
                        //  Win95's dialog template converter doesn't support
                        //  this, so we won't either.

                    }
                }

                if (pisp->_psp.dwFlags & PSP_DLGINDIRECT)
                    return bResult;

                UnlockResource(hDlgTemplate);
            }
            FreeResource(hDlgTemplate);
        }
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("GetPageInfo - ERROR: FindResource() failed"));
    }
    return bResult;
}


//
//  Helper function that edits a dialog template in preparation for it
//  becoming a property sheet page.  This has been split out because
//  the legacy CreatePage function needs to do this, too.
//
//  Returns the place where the style was edited on success, or
//  NULL if we took an exception while editing the template.
//
//  The old style is returned in pdwSaveStyle so it can be replaced later.
//

LPDWORD
EditPropSheetTemplate(
    LPDLGTEMPLATE pDlgTemplate,
    LPDWORD pdwSaveStyle,
    BOOL fFlags)                        // PD_*
{
    DWORD lSaveStyle;
    DWORD dwNewStyle;
    LPDWORD pdwStyle;
    LPDLGEXTEMPLATE pDlgExTemplate = (LPDLGEXTEMPLATE) pDlgTemplate;

    try 
    {
        //
        // We need to save the SETFONT, LOCALEDIT, and CLIPCHILDREN
        // flags.
        //
        if (pDlgExTemplate->wSignature == 0xFFFF)
        {
            pdwStyle = &pDlgExTemplate->dwStyle;
        }
        else
        {
            pdwStyle = &pDlgTemplate->style;
        }

        lSaveStyle = *pdwStyle;
        *pdwSaveStyle = lSaveStyle;

        dwNewStyle = (lSaveStyle & (DS_SHELLFONT | DS_LOCALEDIT | WS_CLIPCHILDREN))
                                    | WS_CHILD | WS_TABSTOP | DS_3DLOOK | DS_CONTROL;

        // If SHELLFONT has been turned off and this page uses it, then turn
        // it off.
        if (!(fFlags & PD_SHELLFONT) &&
            (dwNewStyle & DS_SHELLFONT) == DS_SHELLFONT)
            dwNewStyle &= ~DS_FIXEDSYS;     // Leave DS_USEFONT but lose FIXEDSYS

        *pdwStyle = dwNewStyle;

    } except (UnhandledExceptionFilter( GetExceptionInformation() )) {
        return NULL;
    }
    __endexcept

    return pdwStyle;
}

void RethunkShadowStrings(PISP pisp)
{
    //
    //  Note:  Old code recomputed the entire UNICODE PROPSHEETHEADER
    //  from the ANSI shadow at certain points, in case
    //  the app edited the ANSI shadow.
    //
    //  So we do it too.  I need to ask Eric Flo why we did it in the
    //  first place.  Note that the algorithm is buggy - if the app
    //  edited any of the string fields (or any of the flags that
    //  gate the string fields), we both leak the original memory
    //  *and* fault when we try to free something that wasn't
    //  allocated via LocalAlloc.  We preserve the bug to be compatible
    //  with NT4.  (Snicker.)
    //
    DWORD dwSize = min(sizeof(PROPSHEETPAGE), pisp->_cpfx.pispShadow->_psp.dwSize);
    dwSize = min(dwSize, GETORIGINALSIZE(pisp));

    FreePropertyPageStrings(&pisp->_psp);
    hmemcpy(&pisp->_psp, &pisp->_cpfx.pispShadow->_psp, dwSize);
    //
    //  If this copy fails, we will carry on with happy NULL strings.
    //  So some strings are empty, boo-hoo.
    //
    EVAL(CopyPropertyPageStrings(&pisp->_psp, StrDup_AtoW));
}


ULONG_PTR PropPageActivateContext(LPPROPDATA ppd, PISP pisp)
{
    ULONG_PTR dwCookie = 0;
    // Activate the fusion context if available for this page.
    if (pisp &&
        pisp->_psp.dwFlags & PSP_USEFUSIONCONTEXT &&
        pisp->_psp.dwSize > PROPSHEETPAGE_V2_SIZE &&
        pisp->_psp.hActCtx)
    {
        ActivateActCtx(pisp->_psp.hActCtx, &dwCookie);
    }
    else if (ppd)
    {
        ActivateActCtx(ppd->hActCtxInit, &dwCookie);
    }

    return dwCookie;
}

void PropPageDeactivateContext(ULONG_PTR dw)
{
    if (dw)
        DeactivateActCtx(0, dw);
}

//
//  This function creates a dialog box from the specified dialog template
// with appropriate style flags.
//
HWND _CreatePageDialog(LPPROPDATA ppd, PISP pisp, HWND hwndParent, LPDLGTEMPLATE pDlgTemplate)
{
    HWND hwndPage;
    LPARAM lParam;
    LPDWORD pdwStyle;
    DWORD lSaveStyle;
    ULONG_PTR dwCookie = 0;

    DLGPROC pfnDlgProc;

    pdwStyle = EditPropSheetTemplate(pDlgTemplate, &lSaveStyle, ppd->fFlags);

    if (!pdwStyle)                  // error editing template
        return NULL;

    //
    //  Thunk the Dialog proc if we were created by x86 code on RISC.
    //

#ifdef WX86
    if (pisp->_pfx.dwInternalFlags & PSPI_WX86) {
        pfnDlgProc = (DLGPROC) Wx86ThunkProc( pisp->_psp.pfnDlgProc, (PVOID) 4, TRUE );

        if (pfnDlgProc == NULL)
            return NULL;
    }
    else
#endif
        pfnDlgProc = pisp->_psp.pfnDlgProc;

    //
    //  Decide what to pass as the lParam to the CreateDialogIndirectParam.
    //

    //
    // If the caller was ANSI, then use the ANSI PROPSHEETPAGE.
    //
    if (HASANSISHADOW(pisp))
    {
        lParam = (LPARAM) &pisp->_cpfx.pispShadow->_psp;
    }

    else if (pisp->_psp.dwFlags & PSP_SHPAGE)
    {
        //
        //  PSP_SHPAGE is a special flag used by pre-IE5 shell32 only.
        //  See prshti.h for gory details.  If we get this far, it means
        //  that we need to pass the CLASSICPREFIX instead of the
        //  PROPSHEETPAGE.
        //
        lParam = (LPARAM)&pisp->_cpfx;
    }
    else
    {
        //
        //  Normal UNICODE caller gets the UNICODE PROPSHEETPAGE.
        //
        lParam = (LPARAM)&pisp->_psp;
    }

    //
    //  All set - go create it.
    //

    dwCookie = PropPageActivateContext(ppd, pisp);

    if (HASANSISHADOW(pisp)) 
    {
        hwndPage = CreateDialogIndirectParamA(
                        pisp->_psp.hInstance,
                        (LPCDLGTEMPLATE)pDlgTemplate,
                        hwndParent,
                        pfnDlgProc, lParam);
        RethunkShadowStrings(pisp);
    } 
    else
    {
        hwndPage = SHNoFusionCreateDialogIndirectParam(
                        pisp->_psp.hInstance,
                        (LPCDLGTEMPLATE)pDlgTemplate,
                        hwndParent,
                        pfnDlgProc, lParam);
    }

    // Don't set the theme me style if it's a wizard page. The wizards have their own overrides that conflict
    // with the theme manager
    if (!((ppd->psh).dwFlags & (PSH_WIZARD | PSH_WIZARD97 | PSH_WIZARD_LITE)))
    {
        EnableThemeDialogTexture(hwndPage, ETDT_USETABTEXTURE);
    }

    PropPageDeactivateContext(dwCookie);


    //
    //  Restore the original dialog template style.
    //
    try
    {
        MwWriteDWORD((LPBYTE)pdwStyle, lSaveStyle);
    } except (UnhandledExceptionFilter( GetExceptionInformation() ))
    {

        if (hwndPage)
        {
            DestroyWindow(hwndPage);
        }
        return NULL;
    }
    __endexcept


    return hwndPage;
}


HWND _CreatePage(LPPROPDATA ppd, PISP pisp, HWND hwndParent, LANGID langidMUI)
{
    HWND hwndPage = NULL; // NULL indicates an error

    if (!CallPropertyPageCallback(ppd, pisp, PSPCB_CREATE))
    {
        return NULL;
    }

    if (HASANSISHADOW(pisp)) 
    {
        RethunkShadowStrings(pisp);
    }

    if (pisp->_psp.dwFlags & PSP_DLGINDIRECT)
    {
        hwndPage=_CreatePageDialog(ppd, pisp, hwndParent, (LPDLGTEMPLATE)pisp->_psp.P_pResource);
    }
    else
    {
        HRSRC hRes;
        hRes = FindResourceExRetry(pisp->_psp.hInstance, RT_DIALOG, 
                                   pisp->_psp.P_pszTemplate, langidMUI);
        if (hRes)
        {
            HGLOBAL hDlgTemplate;
            hDlgTemplate = LoadResource(pisp->_psp.hInstance, hRes);
            if (hDlgTemplate)
            {
                const DLGTEMPLATE * pDlgTemplate;
                pDlgTemplate = (LPDLGTEMPLATE)LockResource(hDlgTemplate);
                if (pDlgTemplate)
                {
                    ULONG cbTemplate=SizeofResource(pisp->_psp.hInstance, hRes);
                    LPDLGTEMPLATE pdtCopy = (LPDLGTEMPLATE)Alloc(cbTemplate);

                    ASSERT(cbTemplate>=sizeof(DLGTEMPLATE));

                    if (pdtCopy)
                    {
                        hmemcpy(pdtCopy, pDlgTemplate, cbTemplate);
                        hwndPage=_CreatePageDialog(ppd, pisp, hwndParent, pdtCopy);
                        Free(pdtCopy);
                    }

                    UnlockResource(hDlgTemplate);
                }
                FreeResource(hDlgTemplate);
            }
        }
    }

    return hwndPage;
}

//===========================================================================
//
//  Legacy
//
//  CreatePage is an internal entry point used by shell32 prior to NT5/IE5.
//
//  Win95's shell32 passes a PROPSHEETPAGEA.
//
//  WinNT's shell32 passes a CLASSICPREFIX + PROPSHEETPAGEW.
//
//  The kicker is that shell32 really doesn't need any property sheet page
//  features.  It's just too lazy to do some dialog style editing.
//
//

HWND WINAPI CreatePage(LPVOID hpage, HWND hwndParent)
{
    HWND hwndPage = NULL; // NULL indicates an error
    HRSRC hrsrc;
    LPPROPSHEETPAGE ppsp;

    //
    //  Move from the CLASSICPREFIX to the PROPSHEETHEADER.
    //
    ppsp = &CONTAINING_RECORD(hpage, ISP, _cpfx)->_psp;

    // Docfind2.c never passed these flags, so we don't need to implement them.
    ASSERT(!(ppsp->dwFlags & (PSP_USECALLBACK | PSP_IS16 | PSP_DLGINDIRECT)));

    hrsrc = FindResourceW(ppsp->hInstance, ppsp->P_pszTemplate, RT_DIALOG);

    if (hrsrc)
    {
        LPCDLGTEMPLATE pDlgTemplate = LoadResource(ppsp->hInstance, hrsrc);
        if (pDlgTemplate)
        {
            //
            //  Make a copy of the template so we can edit it.
            //

            DWORD cbTemplate = SizeofResource(ppsp->hInstance, hrsrc);
            LPDLGTEMPLATE pdtCopy = (LPDLGTEMPLATE)Alloc(cbTemplate);

            ASSERT(cbTemplate>=sizeof(DLGTEMPLATE));

            if (pdtCopy)
            {
                DWORD dwScratch;

                hmemcpy(pdtCopy, pDlgTemplate, cbTemplate);
                if (EditPropSheetTemplate(pdtCopy, &dwScratch, PD_SHELLFONT))
                {

                    hwndPage = CreateDialogIndirectParamW(
                                    ppsp->hInstance,
                                    pdtCopy,
                                    hwndParent,
                                    ppsp->pfnDlgProc, (LPARAM)hpage);
                }
                Free(pdtCopy);
            }
        }
    }

    return hwndPage;
}

//  End of legacy
//
//===========================================================================

//
//  AllocPropertySheetPage
//
//  Allocate the memory into which we will dump a property sheet page.
//
//  Nothing is actually copied into the buffer.  The only thing interesting
//  is that the external HPROPSHEETPAGE is set up on the assumption that
//  we will not require a shadow.
//
//  We assume that we are allocating the memory for a non-shadow page.
//
PISP AllocPropertySheetPage(DWORD dwClientSize)
{
    PISP pisp;
    LPBYTE pbAlloc;

    //
    //  An ISP consists of the "above" part, the "below" part, and
    //  the baggage passed by the app.  Negative baggage is okay;
    //  it means we have a down-level app that doesn't know about
    //  pszHeaderTitle.
    //

    pbAlloc = LocalAlloc(LPTR, sizeof(pisp->above) + sizeof(pisp->below) +
                               (dwClientSize - sizeof(PROPSHEETPAGE)));

    if (!pbAlloc)
        return NULL;

    pisp = (PISP)(pbAlloc + sizeof(pisp->above));

    //
    // Set up the CLASSICPREFIX fields.
    //
    pisp->_cpfx.pispMain = pisp;
    ASSERT(pisp->_cpfx.pispShadow == NULL);

    //
    //  Assume no shadow - The app gets the PISP itself.
    //

    pisp->_pfx.hpage = (HPROPSHEETPAGE)pisp;

    return pisp;
}

//
//  Helper function during page creation.  The incoming string is really
//  an ANSI string.  Thunk it to UNICODE.  Fortunately, we already have
//  another helper function that does the work.
//
STDAPI_(LPTSTR) StrDup_AtoW(LPCTSTR ptsz)
{
    return ProduceWFromA(CP_ACP, (LPCSTR)ptsz);
}

//
//  CreatePropertySheetPage
//
//  Where HPROPSHEETPAGEs come from.
//
//  The fNeedShadow parameter means "The incoming LPCPROPSHEETPAGE is in the
//  opposite character set from what you implement natively".
//
//  If we are compiling UNICODE, then fNeedShadow is TRUE if the incoming
//  LPCPROPSHEETPAGE is really an ANSI property sheet page.
//
//  If we are compiling ANSI-only, then fNeedShadow is always FALSE because
//  we don't support UNICODE in the ANSI-only version.
//
HPROPSHEETPAGE WINAPI _CreatePropertySheetPage(LPCPROPSHEETPAGE psp, BOOL fNeedShadow, BOOL fWx86)
{
    PISP pisp;
    DWORD dwSize;

    COMPILETIME_ASSERT(PROPSHEETPAGEA_V1_SIZE == PROPSHEETPAGEW_V1_SIZE);
    COMPILETIME_ASSERT(sizeof(PROPSHEETPAGEA) == sizeof(PROPSHEETPAGEW));

    if ((psp->dwSize < MINPROPSHEETPAGESIZE) ||
        (psp->dwSize > 4096) ||                         // or the second version     
        (psp->dwFlags & ~PSP_ALL))                      // bogus flag used
    {
        return NULL;
    }

    //
    // The PROPSHEETPAGE structure can be larger than the
    // defined size.  This allows ISV's to place private
    // data at the end of the structure.  The ISP structure
    // consists of some private fields and a PROPSHEETPAGE
    // structure.  Calculate the size of the private fields,
    // and then add in the dwSize field to determine the
    // amount of memory necessary.
    //

    //
    //  An ISP consists of the "above" part, the "below" part, and
    //  the baggage passed by the app.  Negative baggage is okay;
    //  it means we have a down-level app that doesn't know about
    //  pszHeaderTitle.
    //

    //
    //  If we have an "other" client, then the native side of the
    //  property sheet doesn't carry any baggage.  It's just a
    //  plain old PROPSHEETPAGE.
    //

    dwSize = fNeedShadow ? sizeof(PROPSHEETPAGE) : psp->dwSize;
    pisp = AllocPropertySheetPage(dwSize);

    if (pisp)
    {
        STRDUPPROC pfnStrDup;

#ifdef WX86
        //
        //  We we're being called by Wx86, set the flag so we remember.
        //

        if ( fWx86 ) {
            pisp->_pfx.dwInternalFlags |= PSPI_WX86;
        }
#endif

        SETORIGINALSIZE(pisp, dwSize);

        //
        // Bulk copy the contents of the PROPSHEETPAGE, or
        // as much of it as the app gave us.
        //
        hmemcpy(&pisp->_psp, psp, min(dwSize, psp->dwSize));

        //
        // Decide how to copy the strings
        //
        if (fNeedShadow)
            pfnStrDup = StrDup_AtoW;
        else
            pfnStrDup = StrDup;

        // Now copy them
        if (!CopyPropertyPageStrings(&pisp->_psp, pfnStrDup))
            goto ExitStrings;

        if (fNeedShadow)
        {
            PISP pispAnsi = AllocPropertySheetPage(psp->dwSize);
            if (!pispAnsi)
                goto ExitShadow;

            //
            //  Copy the entire client PROPSHEETPAGE, including the
            //  baggage.
            //
            hmemcpy(&pispAnsi->_psp, psp, psp->dwSize);

            //
            //  Hook the two copies to point to each other.
            //
            pisp->_cpfx.pispShadow = pispAnsi;
            pispAnsi->_cpfx.pispShadow = pispAnsi;
            pispAnsi->_cpfx.pispMain = pisp;

            //
            //  If there is a shadow, then the
            //  external handle is the ANSI shadow.
            //
            ASSERT(pispAnsi->_pfx.hpage == (HPROPSHEETPAGE)pispAnsi);
            pisp->_pfx.hpage = (HPROPSHEETPAGE)pispAnsi;

            //
            //  Okay, now StrDupA them strings.
            //
            if (!CopyPropertyPageStrings(&pispAnsi->_psp, (STRDUPPROC)StrDupA))
                goto ExitShadowStrings;
        }

        //
        // Increment the reference count to the parent object.
        //

        if (HASREFPARENT(pisp))
            InterlockedIncrement((LPLONG)pisp->_psp.pcRefParent);

        //
        //  Welcome to the world.
        //
        CallPropertyPageCallback(NULL, pisp, PSPCB_ADDREF);   // don't need because there is no hwnd

        return ExternalizeHPROPSHEETPAGE(pisp);
    }
    else
    {
        return NULL;
    }

ExitShadowStrings:
    FreePropertyPageStrings(&pisp->_cpfx.pispShadow->_psp);
    FreePropertyPageStruct(pisp->_cpfx.pispShadow);
ExitShadow:;
ExitStrings:
    FreePropertyPageStrings(&pisp->_psp);
    FreePropertyPageStruct(pisp);
    return NULL;
}

HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW psp)
{
    BOOL fWx86 = FALSE;

#ifdef WX86
    fWx86 = Wx86IsCallThunked();
#endif

    return _CreatePropertySheetPage(psp, FALSE, fWx86);
}

HPROPSHEETPAGE WINAPI CreatePropertySheetPageA(LPCPROPSHEETPAGEA psp)
{
    BOOL fWx86 = FALSE;

#ifdef WX86
    fWx86 = Wx86IsCallThunked();
#endif

    return _CreatePropertySheetPage((LPCPROPSHEETPAGE)psp, TRUE, fWx86);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\prshti.h ===
//
//  Internal data structures for property sheet support.
//

//
//  Sigh.  Wiz97 underwent a redesign between IE4 and IE5
//  so we have to treat them as two unrelated wizard styles that happen to
//  have frighteningly similar names.  So prsht.h contains both
//  PSH_WIZARD97IE4 and PSH_WIZARD97IE5, and defines PSH_WIZARD97 to be
//  the one appropriate to the version of the header file being included.
//
//  We redefine PSH_WIZARD97 to mean "Any form of Wizard97",
//
#undef  PSH_WIZARD97
#define PSH_WIZARD97        (PSH_WIZARD97IE4 | PSH_WIZARD97IE5)

//
//  The history of PROPSHEETHEADER
//
//  PROPSHEETHEADERSIZE_BETA
//
//      This is the property sheet header that shipped in an early
//      Win95 beta (sometime between Sep 1993 and Sep 1994, maybe M5).
//
//      It is just like the shipping Win95 property sheet header,
//      except that it lacks the PFNPROPSHEETCALLBACK at the end.
//      We grudgingly accept it but don't publicize the fact.
//
//      For some reason, we have always supported this wacky
//      ancient unreleased PROPSHEETHEADER, so there's no point
//      in dropping support for it now...  If you think it's not
//      worth retaining support for this ancient structure,
//      feel free to nuke it.  But you become responsible for the
//      potential app compat bugs from Norton Utilities for
//      Windows 95 v1.0.
//
//  PROPSHEETHEADERSIZE_V1
//
//      This is the property sheet header that shipped in Win95,
//      NT4, and IE3.  It is documented and lots of people use it.
//
//  PROPSHEETHEADERSIZE_V1a
//
//      This is an interim property sheet header that never shipped.
//      Support for it has been broken for a long time, so I dropped
//      the support altogether for IE5.
//
//  PROPSHEETHEADERSIZE_V2
//
//      This is the property sheet header that shipped in IE4.
//
#define PROPSHEETHEADERSIZE_BETA    CCSIZEOF_STRUCT(PROPSHEETHEADER, H_ppsp)
#define PROPSHEETHEADERSIZE_V1      CCSIZEOF_STRUCT(PROPSHEETHEADER, pfnCallback)
#define PROPSHEETHEADERSIZE_V2      CCSIZEOF_STRUCT(PROPSHEETHEADER, H_pszbmHeader)

#define IsValidPROPSHEETHEADERSIZE(dwSize) \
       ((dwSize) == PROPSHEETHEADERSIZE_BETA || \
        (dwSize) == PROPSHEETHEADERSIZE_V1   || \
        (dwSize) == PROPSHEETHEADERSIZE_V2)

// PropertySheetPage structure sizes:

#define MINPROPSHEETPAGESIZEA PROPSHEETPAGEA_V1_SIZE
#define MINPROPSHEETPAGESIZEW PROPSHEETPAGEW_V1_SIZE
#define MINPROPSHEETPAGESIZE  PROPSHEETPAGE_V1_SIZE

//  - COMPATIBILITY CONSTRAINT -
//
//  Shell32 prior to IE5 knows the internal structure of the HPROPSHEETPAGE,
//  so we have to give it what it wants.  (shell32\bitbuck.c, docfind2.c)
//
//  Win95 Golden - Shell32 expects the HPROPSHEETPAGE to be equal to
//  the lParam that is passed to the dialog proc's WM_INITDIALOG.
//  No special flags are passed in the PROPSHEETPAGE to indicate
//  that this assumption is being made.
//
//  Win95 IE4 Integrated - Same as Win95 Golden, except that
//  the shell sets the PSP_SHPAGE bit in the PROPSHEETPAGE.dwFlags
//  to indicate that it wants this wacky behavior.
//
//  WinNT Golden - Shell32 expects the HPROPSHEETPAGE to be equal
//  to a pointer to the internal PSP structure used by WinNT golden.
//  The internal PSP structure looked like a PROPSHEETPAGE, except
//  that it had two fields stuck in front.  (One DWORD and one pointer.)
//  The NT shell passes the PSP_SHPAGE flag.
//
//  WinNT IE4 Integrated - Same as WinNT Golden.
//
//  Furthermore, all versions of Shell32 prior to IE5 call the internal
//  CreatePage function (shell32\docfind2.c)
//
//  - Summary -
//
//                passes       expected      expects
//              PSP_SHPAGE       PSP         CLASSICPREFIX
//              ---------      -------       -------------
//  95 Gold                      ANSI
//  95/IE4          *            ANSI
//  NT Gold         *            UNI           *
//  NT/IE4          *            UNI           *
//
//  Note that Win95 Gold does not set the PSP_SHPAGE flag, so we have
//  to assume that any ANSI caller might be a Win95 Gold shell32.
//
//  WinNT is easier.  We return the WinNT Golden UNICODE version of
//  the PSP if (and only if) the PSP_SHPAGE flag is set.
//
//  The PSP_SHPAGE flag has been removed from the header file so nobody
//  can pass it ever again.
//
//  So our structures look like this.  The bracketed section is the
//  the memory block passed by the app to CreatePropertySheetPage
//  and whose layout cannot be altered.
//
//  ANSI Comctl32, ANSI application:
//
//            +---------------+
//            | PAGEPREFIX    |
//  hpage95->/+---------------+
//          / | PROPSHEETPAGE |
//          | |  (ANSI)       |
//          | |               |
//          | +---------------+
//          | |               |
//          | | app goo       |
//          \ |               |
//           \+---------------+
//
//  UNICODE Comctl32, ANSI application.
//
//
//          The authoritative page      The shadow page
//
//            +---------------+         + - - - - - - - +
//            | PAGEPREFIX    |         | PAGEPREFIX    |
//            +---------------+         +---------------+ <- hpageNT
//            | CLASSICPREFIX |<-\/-----| CLASSICPREFIX |
//            +---------------+<-/\---->+---------------+\<- hpage95
//            | PROPSHEETPAGE |         | PROPSHEETPAGE | \
//            |  (UNICODE)    |         |  (ANSI)       | |
//            |               |         |               | |
//            +---------------+         +---------------+ |
//                                      |               | |
//                                      | app goo       | |
//                                      |               | /
//                                      +---------------+/
//
//                                  (The dotted line around PAGEPREFIX
//                                   means that it is allocated but unused.)
//
//
//  UNICODE Comctl32, UNICODE application.
//
//            +---------------+
//            | PAGEPREFIX    |
//  hpageNT-> +---------------+
//            | CLASSICPREFIX |
//  hpage95->/+---------------+
//          / | PROPSHEETPAGE |
//          | |  (UNICODE)    |
//          | |               |
//          | +---------------+
//          | |               |
//          | | app goo       |
//          \ |               |
//           \+---------------+
//
//  Are we confused yet?  Let's try to explain.
//
//  REQUIREMENT
//
//      The app goo must be kept in the structure
//      corresponding to the character set of the application.
//
//      Notice that if the application is ANSI, then the app goo
//      is kept with the ANSI version of PROPSHEETPAGE.  If the
//      application is UNICODE, then the app goo is kept with the
//      UNICODE version of the PROPSHEETPAGE.
//
//      It doesn't hurt to "accidentally" put a copy of the app goo
//      on the version the app doesn't use; that just wastes memory.
//
//  REQUIREMENT
//
//      If a UNICODE app passed PSP_SHPAGE, then the hpage must
//      point to the CLASSICPREFIX structure.
//
//      To simplify matters (like HPROPSHEETPAGE validation), we
//      apply this rule even if the app didn't pass PSP_SHPAGE.
//
//  DESIGN
//
//      If the app is ANSI and we support UNICODE, then we create
//      a UNICODE copy of the ANSI property sheet structure,
//      and the ANSI PROPSHEETPAGE becomes a "shadow".
//      The UNICODE copy does not need to carry the app goo
//      since it will never be seen by the app.
//
//  REQUIREMENT
//
//      If an ANSI app creates a property sheet page, then the hpage
//      must point to the ANSI version of the PROPSHEETPAGE.
//      (Because the app might be shell32.)
//
//  >> CAUTION <<
//
//      The requirements on hpages rule means that any time an hpage
//      comes in from the outside world, we need to sniff it and decide
//      if it's the UNICODE version or the ANSI version; if it's
//      the ANSI version, then we switch the pointer to point to
//      the UNICODE version instead.
//
//  REMARK
//
//      Internally, we use only the UNICODE version of the PROPSHEETPAGE.
//      (Unless we're building Win95 ANSI-only, duh.)  The ANSI version
//      (the "shadow") is just for show to keep the app happy.  It is
//      the UNICODE version that is authoritative.
//
//      Only the authoritative PROPSHEETPAGE needs to have the PAGEPREFIX,
//      but we put one on both sides to simplify memory management,
//      because it means that all PROPSHEETPAGEs look the same (both
//      authoritative and shadow).

#define PSP_SHPAGE                 0x00000200  // Ewww; see above

//
//  CLASSICPREFIX
//
//  This structure is allocated ahead of the PROPSHEETPAGE when we
//  create an HPROPSHEETPAGE.  See the diagrams above.  Sometimes
//  the HPROPSHEETPAGE points to this structure, sometimes it doesn't.
//  See the diagrams above.
//
//  This structure can never change, due to backwards compatibility
//  constraints described above.  (Okay, you can change it once you
//  decide to drop support for versions of NT less than 5, like that'll
//  ever happen.)

//
//  pispMain
//
//      Points to the main copy of the HPROPSHEETPAGE.
//
//  pispShadow
//
//      Points to that shadow copy of the HPROPSHEETPAGE, or NULL if
//      there is no shadow copy.

typedef struct CLASSICPREFIX 
{
    union ISP *pispMain;
    union ISP *pispShadow;
} CLASSICPREFIX, *PCLASSICPREFIX;

//
//  PAGEPREFIX
//
//  Stuff that we track which isn't part of the CLASSICPREFIX.
//
//  hpage is the HPROPSHEETPAGE that we give out to applications.
//

typedef struct PAGEPREFIX 
{
    HPROPSHEETPAGE hpage;
    DWORD dwInternalFlags;
    SIZE siz;                           // Page ideal size
} PAGEPREFIX, *PPAGEPREFIX;

//
//  Flag values for dwInternalFlags
//

#define PSPI_WX86               1
#define PSPI_FETCHEDICON        2       // For debugging (GetPageInfoEx)
#define PSPI_SIZEMASK           0xFFFF0000

//
//  _PSP
//
//  This is the structure than the compiler thinks an HPROPSHEETPAGE
//  points to.  To make sure all our code goes through
//  InternalizeHPROPSHEETPAGE on the way in and
//  ExternalizeHPROPSHEETPAGE on the way out, we intentionally leave
//  it undefined.

typedef struct _PSP PSP, *PPSP;

//
//  ISP - Internal Sheet Page
//
//  Our internal structure for tracking property sheet pages.  This
//  is also what a native-character set HPROPSHEETPAGE points to.
//
//  Note the "union with an array of one element that we index with
//  the value -1 in order to access it at negative offsets" trick.
//
//  Note also that the CLASSICPREFIX goes above the HPROPSHEETPAGE
//  on Win95, but below it on WinNT.  See discussion at the top of this
//  file.
//
//  To save all the typing of union names and [-1]'s, access to fields
//  of an IPSP are encapsulated inside the _psp, _cpfx, and _pfx macros.

typedef union ISP 
{
    struct 
    {
        PAGEPREFIX pfx;             // lives above the HPROPSHEETPAGE
    } above[1];
    struct 
    {
        CLASSICPREFIX cpfx;         // lives below the HPROPSHEETPAGE
        PROPSHEETPAGE psp;          // lives below the HPROPSHEETPAGE
    } below;
} ISP, *PISP;

#define _pfx    above[-1].pfx
#define _psp    below.psp
#define _cpfx   below.cpfx

#define GETORIGINALSIZE(psp) (((psp)->_pfx.dwInternalFlags & PSPI_SIZEMASK) >> 16)
#define SETORIGINALSIZE(psp, iSize) ((psp)->_pfx.dwInternalFlags |= (iSize << 16))

#define PropSheetBase(pisp)     ((LPBYTE)(pisp) - sizeof((PISP)pisp)->above)

//
//  Converting an HPROPSHEETPAGE into a PSP means sniffing at the
//  _cpfx.dwFlags and seeing if it's an ANSI page or a UNICODE page.
//

__inline
PISP
InternalizeHPROPSHEETPAGE(HPROPSHEETPAGE hpage)
{
    PISP pisp = (PISP)hpage;
    return pisp->_cpfx.pispMain;
}

#define ExternalizeHPROPSHEETPAGE(pisp) ((pisp)->_pfx.hpage)

//
// Used for GetPageInfo(), prpage.c
//
typedef struct {
    short     PointSize;
    WCHAR     szFace[LF_FACESIZE];
    BOOL      bItalic;
    int       iCharset;
} PAGEFONTDATA, * PPAGEFONTDATA;

//
//  PROPDATA
//
//  The state of a property sheet.
//

typedef struct
{
    HWND hDlg;          // the dialog for this instance data
    PROPSHEETHEADER psh;

    HWND hwndCurPage;   // current page hwnd
    HWND hwndTabs;      // tab control window
    int nCurItem;       // index of current item in tab control
    int idDefaultFallback; // the default id to set as DEFID if page doesn't have one

    int nReturn;
    UINT nRestart;

    int xSubDlg, ySubDlg;       // dimensions of sub dialog
    int cxSubDlg, cySubDlg;

    BOOL fFlags;
    BOOL fFlipped;      // Property sheet not mirrored but with flipped buttons

    // Wizard97 IE4 vs. IE5 discrepancy:
    //
    //  Wizard 97 IE4 - "watermark" refers to the bitmap that is used to
    //                  paint the background of the dialog.
    //  Wizard 97 IE5 - "watermark" refers to the bitmap that goes on
    //                  on the left-hand side of Welcome/Finish screens.
    //
  
    HBITMAP hbmWatermark;
    HBRUSH  hbrWatermark;
    HPALETTE hplWatermark;

    int cyHeaderHeight;
    HFONT hFontBold;
    HBITMAP hbmHeader;
    HBRUSH  hbrHeader;
    int ySubTitle;      // The subtitle's starting Y position
    BOOL fAllowApply;

    // These fields are used by MLUI
    LANGID wFrameLang;      // langid of propsheet frame
    int iFrameCharset;      // charset of propsheet frame

    // These fields cache font metric information
    PAGEFONTDATA    pfdCache;           // Cached font descriptor
    SIZE            sizCache;           // Cached height and width go here
    SIZE            sizMin;             // Smallest we allow pages to get

    HPROPSHEETPAGE rghpage[MAXPROPPAGES];

    HANDLE hActCtxInit;
} PROPDATA, *LPPROPDATA;
// defines for fFlags
#define PD_NOERASE       0x0001
#define PD_CANCELTOCLOSE 0x0002
#define PD_DESTROY       0x0004
#define PD_WX86          0x0008
#define PD_FREETITLE     0x0010
#define PD_SHELLFONT     0x0020         // Is the frame using SHELLFONT?
#define PD_NEEDSHADOW    0x0040

//
//  Helper macros
//
//  UNIX does not support dummy unions, so we have to say
//  DUMMYUNION<n>_MEMBER all over the place.  Sigh.
//  So all these underscore macros do the grunky work for us.
//
//  H_blah means "the field in the PROPSHEETHEADER named blah".
//  P_blah means "the field in the PROPSHEETPAGE   named blah".
//
//
#define H_hIcon             DUMMYUNION_MEMBER(hIcon)
#define H_pszIcon           DUMMYUNION_MEMBER(pszIcon)
#define H_nStartPage        DUMMYUNION2_MEMBER(nStartPage)
#define H_pStartPage        DUMMYUNION2_MEMBER(pStartPage)
#define H_phpage            DUMMYUNION3_MEMBER(phpage)
#define H_ppsp              DUMMYUNION3_MEMBER(ppsp)
#define H_hbmWatermark      DUMMYUNION4_MEMBER(hbmWatermark)
#define H_pszbmWatermark    DUMMYUNION4_MEMBER(pszbmWatermark)
#define H_hbmHeader         DUMMYUNION5_MEMBER(hbmHeader)
#define H_pszbmHeader       DUMMYUNION5_MEMBER(pszbmHeader)

#define P_pszTemplate       DUMMYUNION_MEMBER(pszTemplate)
#define P_pResource         DUMMYUNION_MEMBER(pResource)
#define P_hIcon             DUMMYUNION2_MEMBER(hIcon)
#define P_pszIcon           DUMMYUNION2_MEMBER(pszIcon)

//
//  HASCALLBACK - We should call the callback for this page.
//

#define HASCALLBACK(pisp) \
       (((pisp)->_psp.dwFlags & PSP_USECALLBACK) && \
         (pisp)->_psp.pfnCallback)

//
//  HASREFPARENT - We should adjust the pcRefParent for this page.
//

#define HASREFPARENT(pisp) \
       (((pisp)->_psp.dwFlags & PSP_USEREFPARENT) && \
         (pisp)->_psp.pcRefParent)

//
//  HASHEADERTITLE - We should display a header title for this page.
//

#define HASHEADERTITLE(pisp) \
       (((pisp)->_psp.dwFlags & PSP_USEHEADERTITLE) && \
         (pisp)->_psp.pszHeaderTitle)

//
//  HASHEADERSUBTITLE - We should display a header subtitle for this page.
//

#define HASHEADERSUBTITLE(pisp) \
       (((pisp)->_psp.dwFlags & PSP_USEHEADERSUBTITLE) && \
         (pisp)->_psp.pszHeaderSubTitle)

//
//  GETPISP - Obtain the PISP for this page.  Once they have been
//            placed into the H_phpage, all the HPROPSHEETPAGEs are
//            already internalized, so we can just cast them over.
//

#define GETPISP(ppd, i) ((PISP)(ppd)->psh.H_phpage[i])

//
//  SETPISP - Change the PISP for this page.
//

#define SETPISP(ppd, i, v) ((ppd)->psh.H_phpage[i] = (HPROPSHEETPAGE)(v))

//
//  GETHPAGE - Obtain the external HPROPSHEETPAGE for this page.
//
#define GETHPAGE(ppd, i) ExternalizeHPROPSHEETPAGE(GETPISP(ppd, i))

//
//  GETPPSP - Obtain the PPSP for this page.  We get the PISP
//            and then retrieve the PROPSHEETHEADER part.
//

#define GETPPSP(ppd, i) (&GETPISP(ppd, i)->_psp)

//
//  HASANSISHADOW
//
//  Does this authoritative property sheet page have an ANSI shadow?
//
//  If we are built ANSI, then the canonical PSP is equal to the
//  ANSI version, so there is no shadow.  (It's already the real thing.)
//
#define HASANSISHADOW(pisp) ((pisp)->_cpfx.pispShadow)

//
//  HIDEWIZ97HEADER
//
//      Nonzero if we are a WIZARD97 property sheet but we should
//      hide the header for this page.

#define HIDEWIZ97HEADER(ppd, i) \
        (((ppd)->psh.dwFlags & PSH_WIZARD97) && \
          (GETPPSP(ppd, i)->dwFlags & PSP_HIDEHEADER))

//
//  Stub macros so we don't have to put "#ifdef BIG_ENDIAN" everywhere.
//
#ifndef BIG_ENDIAN
#define MwReadDWORD(lpByte)   *(LPDWORD)(lpByte)
#define MwWriteDWORD(lpByte, dwValue)   *(LPDWORD)(lpByte) = dwValue
#endif

//
//  End of helper macros
//

//
//  Functions shared between prsht.c and prpage.c
//
PISP AllocPropertySheetPage(DWORD dwClientSize);
HWND _CreatePage(LPPROPDATA ppd, PISP pisp, HWND hwndParent, LANGID langidMUI);
HPROPSHEETPAGE WINAPI _CreatePropertySheetPage(LPCPROPSHEETPAGE psp, BOOL fNeedShadow, BOOL fWx86);

typedef LPTSTR (STDMETHODCALLTYPE *STRDUPPROC)(LPCTSTR ptsz);

BOOL CopyPropertyPageStrings(LPPROPSHEETPAGE ppsp, STRDUPPROC pfnStrDup);
void FreePropertyPageStrings(LPCPROPSHEETPAGE ppsp);

BOOL ThunkPropSheetHeaderAtoW (LPCPROPSHEETHEADERA ppshA,
                                LPPROPSHEETHEADERW ppsh);
void FreePropSheetHeaderW(LPPROPSHEETHEADERW ppsh);

STDAPI_(LPTSTR) StrDup_AtoW(LPCTSTR ptsz);


typedef struct 
{
    POINT pt;               // Dialog box dimensions (DLU)
    HICON hIcon;            // Page icon
    PAGEFONTDATA pfd;       // Font info
    BOOL bRTL;              // If tab caption should be right to left reading
    BOOL bMirrored;            // if the page contains mirroring flags
    BOOL bDialogEx;         // Is it a DIALOGEX?
    DWORD dwStyle;          // Dialog style
    TCHAR szCaption[128 + 50];  // Caption as stored in template

} PAGEINFOEX;

//
//  These flags control which parts of the PAGEINFOEX get filled in.
//
#define GPI_PT          0x0000      // so cheap, we always fetch it
#define GPI_ICON        0x0001
#define GPI_FONT        0x0002      // PAGEFONTDATA
#define GPI_BRTL        0x0000      // so cheap, we always fetch it
#define GPI_BMIRROR     0x0000      // so cheap, we always fetch it
#define GPI_DIALOGEX    0x0000      // so cheap, we always fetch it
#define GPI_CAPTION     0x0004
#define GPI_ALL         0x0007

BOOL WINAPI GetPageInfoEx(LPPROPDATA ppd, PISP pisp, PAGEINFOEX *ppi, LANGID langidMUI, DWORD flags);

// SHELLFONT means that you are a DIALOGEX and have the DS_SHELLFONT bits set
// Although this is supported only on NT5, the flag is still meaningful on
// Win9x to indicate an implicit PSH_USEPAGEFONT.
#define IsPageInfoSHELLFONT(ppi) \
    ((ppi)->bDialogEx && DS_SHELLFONT == (DS_SHELLFONT & (ppi)->dwStyle))

// Prsht_PrepareTemplate operating systems types
// Used as array indices. Be careful !!

typedef enum {
    PSPT_OS_WIN95_BIDI,    // Win95  BiDi
    PSPT_OS_WIN98_BIDI,    // Win98  BiDi   (Or Higher)
    PSPT_OS_WINNT4_ENA,    // WinNT4 BiDi Ena, No Winnt4 BiDi loc
    PSPT_OS_WINNT5,        // WinNT5 (Or Higher)
    PSPT_OS_OTHER,         // Anything else ....
    PSPT_OS_MAX            
    } PSPT_OS;

// Prsht_PrepareTemplate property sheet type 
// Used as array indices. Be careful !!
typedef enum {
    PSPT_TYPE_MIRRORED,     // Mirrored first page OR mirrored Process
    PSPT_TYPE_ENABLED,      // First page Language is BiDi
    PSPT_TYPE_ENGLISH,      // Anything else ....
    PSPT_TYPE_MAX           
} PSPT_TYPE;

// Prsht_PrepareTemplate property sheet default behavior override
// Used as array indices. Be careful !!

typedef enum {
    PSPT_OVERRIDE_NOOVERRIDE,
    PSPT_OVERRIDE_USEPAGELANG,  // Overridden by PSH_USEPAGELANG
    PSPT_OVERRIDE_MAX
    } PSPT_OVERRIDE;

// Prsht_PrepareTemplate Preparation action
typedef enum {
    PSPT_ACTION_NOACTION,      // Don't touch whatever you've passed
    PSPT_ACTION_NOMIRRORING,   // Turn off mirroring
    PSPT_ACTION_FLIP,          // Turn off mirroring and flip
    PSPT_ACTION_LOADENGLISH,   // load English template
    PSPT_ACTION_WIN9XCOMPAT    // Tags the templae with DS_BIDI_RTL for Win9x compat
    } PSPT_ACTION;

ULONG_PTR PropPageActivateContext(LPPROPDATA ppd, PISP pisp);
void PropPageDeactivateContext(ULONG_PTR i);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\rcids.h ===
#define IDS_SPACE       0x0400
#define IDS_PLUS        0x0401
#define IDS_NONE        0x0402

/* System MenuHelp
 */
#define MH_SYSMENU      (0x8000U - MINSYSCOMMAND)
#define IDS_SYSMENU     (MH_SYSMENU-16)
#define IDS_HEADER      (MH_SYSMENU-15)
#define IDS_HEADERADJ   (MH_SYSMENU-14)
#define IDS_TOOLBARADJ  (MH_SYSMENU-13)

/* Cursor ID's
 */
#define IDC_SPLIT       100
#define IDC_MOVEBUTTON  102

#define IDC_STOP            103
#define IDC_COPY            104
#define IDC_MOVE            105
#define IDC_DIVIDER         106
#define IDC_DIVOPEN         107


/*
 * Cursor values 108 - 119 are used by
 * the ReaderMode cursors.  They are defined
 * in commctrl.w
 *
#define IDC_HAND_INTERNAL   108
#define IDC_VERTICALONLY    109
#define IDC_HORIZONTALONLY  110
#define IDC_MOVE2D          111
#define IDC_NORTH           112
#define IDC_SOUTH           113
#define IDC_EAST            114
#define IDC_WEST            115
#define IDC_NORTHEAST       116
#define IDC_NORTHWEST       117
#define IDC_SOUTHEAST       118
#define IDC_SOUTHWEST       119
 */

#define IDB_STDTB_SMALL_COLOR   120
#define IDB_STDTB_LARGE_COLOR   121



#define IDB_VIEWTB_SMALL_COLOR  124
#define IDB_VIEWTB_LARGE_COLOR  125

#define IDB_CAL_SPIRAL          126
#define IDB_CAL_PAGETURN        127

#define IDB_HISTTB_SMALL_COLOR  130
#define IDB_HISTTB_LARGE_COLOR  131

/*
 * Bitmap values 132-134 are used by
 * applications that use ReaderMode.
 * They are used for the "origin bitmap"
 * that is overlayed on the document they
 * are scrolling.
#define IDB_2DSCROLL    132
#define IDB_VSCROLL     133
#define IDB_HSCROLL     134
 */
#define IDC_DIVOPENV    135

/* Image used by the filter bar */
#define IDB_FILTERIMAGE 140

/* Icon ID's
 */
#define IDI_INSERT      150

/* AdjustDlgProc stuff
 */
#define ADJUSTDLG       200
#define IDC_BUTTONLIST  201
#define IDC_RESET       202
#define IDC_CURRENT     203
#define IDC_REMOVE      204
#define IDC_APPHELP     205
#define IDC_MOVEUP      206
#define IDC_MOVEDOWN    207

/// ================ WARNING: ====
/// these ids are loaded directly by ISV's.  do not change them.
// property sheet stuff
#define DLG_PROPSHEET           1006
#define DLG_PROPSHEETTABS       1007
#define DLG_PROPSHEET95         1008


// wizard property sheet stuff
#define DLG_WIZARD              1020
#define DLG_WIZARD95            1021
/// ================ WARNING: ====


// if this id changes, it needs to change in shelldll as well.
// we need to find a better way of dealing with this.
#define IDS_CLOSE               0x1040
#define IDS_OK                  0x1041
#define IDS_PROPERTIESFOR       0x1042

// stuff for the moth/datetime pickers
#define IDS_TODAY        0x1043
#define IDS_GOTOTODAY    0x1044
#define IDS_DELIMETERS   0x1045
#define IDS_MONTHFMT     0x1046
#define IDS_MONTHYEARFMT 0x1047

// stuff used by filter bar in header
#define IDS_ENTERTEXTHERE 0x1050

#define IDS_PROPERTIES          0x1051

#define IDD_PAGELIST            0x3020
#define IDD_APPLYNOW            0x3021
#define IDD_DLGFRAME            0x3022
#define IDD_BACK                0x3023
#define IDD_NEXT                0x3024
#define IDD_FINISH              0x3025
#define IDD_DIVIDER             0x3026
#define IDD_TOPDIVIDER          0x3027

// UxBehavior resources
#define IDR_UXBEHAVIORFACTORY   0x6000
#define IDR_UXCOMMANDSEARCH     0x6001

// Edit control context menu
#define ID_EC_PROPERTY_MENU      1

// Language pack specific context menu IDs
#define ID_CNTX_RTL         0x00008000L
#define ID_CNTX_DISPLAYCTRL 0x00008001L
#define ID_CNTX_INSERTCTRL  0x00008013L
#define ID_CNTX_ZWJ         0x00008002L
#define ID_CNTX_ZWNJ        0x00008003L
#define ID_CNTX_LRM         0x00008004L
#define ID_CNTX_RLM         0x00008005L
#define ID_CNTX_LRE         0x00008006L
#define ID_CNTX_RLE         0x00008007L
#define ID_CNTX_LRO         0x00008008L
#define ID_CNTX_RLO         0x00008009L
#define ID_CNTX_PDF         0x0000800AL
#define ID_CNTX_NADS        0x0000800BL
#define ID_CNTX_NODS        0x0000800CL
#define ID_CNTX_ASS         0x0000800DL
#define ID_CNTX_ISS         0x0000800EL
#define ID_CNTX_AAFS        0x0000800FL
#define ID_CNTX_IAFS        0x00008010L
#define ID_CNTX_RS          0x00008011L
#define ID_CNTX_US          0x00008012L

// Language pack specific string IDs
#define IDS_IMEOPEN         0x1052
#define IDS_IMECLOSE        0x1053
#define IDS_SOFTKBDOPEN     0x1054
#define IDS_SOFTKBDCLOSE    0x1055
#define IDS_RECONVERTSTRING 0x1056

// Hyperlink string resources
#define IDS_LINKWINDOW_DEFAULTACTION    0x1060
#define IDS_LINEBREAK_REMOVE            0x1061
#define IDS_LINEBREAK_PRESERVE          0x1062

// Group View
#define IDS_ITEMS               0x1065

// edit messages 
#define IDS_PASSWORDCUT_TITLE   0x1070
#define IDS_PASSWORDCUT_MSG     0x1071
#define IDS_NUMERIC_TITLE       0x1072
#define IDS_NUMERIC_MSG         0x1073
#define IDS_CAPSLOCK_TITLE      0x1074
#define IDS_CAPSLOCK_MSG        0x1075

#define IDS_PASSWORDCHAR        0x1076
#define IDS_PASSWORDCHARFONT    0x1077

// Tool Tip title icons
#define IDI_TITLE_ERROR     0x5000
#define IDI_TITLE_INFO      0x5001
#define IDI_TITLE_WARNING   0x5002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\reader.c ===
#include "ctlspriv.h"

static struct {
    WPARAM vk1;
    WPARAM vk2;
    int dx;
    int dy;
} arrNumMaps[] = 
{ 
    { VK_NUMPAD1, VK_END,   -RM_SCROLLUNIT, RM_SCROLLUNIT,},
    { VK_NUMPAD2, VK_DOWN,  0,              RM_SCROLLUNIT},
    { VK_NUMPAD3, VK_NEXT,  RM_SCROLLUNIT,  RM_SCROLLUNIT},
    { VK_NUMPAD4, VK_LEFT,  -RM_SCROLLUNIT, 0},
    { VK_NUMPAD5, VK_CLEAR, 0,              0},
    { VK_NUMPAD6, VK_RIGHT, RM_SCROLLUNIT,  0},
    { VK_NUMPAD7, VK_HOME,  -RM_SCROLLUNIT, -RM_SCROLLUNIT},
    { VK_NUMPAD8, VK_UP,    0,              -RM_SCROLLUNIT},
    { VK_NUMPAD9, VK_PRIOR, RM_SCROLLUNIT,  -RM_SCROLLUNIT},
};

// do some keyboard handling...
// this works like USER's arrow keys for resizing 
void RM_HandleKeyDown(LPRECT prcHot, WPARAM wParam, LPARAM lParam)
{
    int i;
    POINT pt;
    
    GetCursorPos(&pt);
    
    for (i = ARRAYSIZE(arrNumMaps) - 1 ; i >= 0; i--) {
        if (wParam == arrNumMaps[i].vk1 || 
            wParam == arrNumMaps[i].vk2) {
            break;
        }
    }
    
    if (i == -1) {
        ReleaseCapture();
        return;
    }

    // this deals with if the cursor is within the bounds of the rect
    if (pt.x < prcHot->right &&
        pt.x >= prcHot->left && 
        arrNumMaps[i].dx) {
        
        if (arrNumMaps[i].dx > 0)
            pt.x = prcHot->right - 2;
        else 
            pt.x = prcHot->left + 1;
        
    }
    
    if (pt.y < prcHot->bottom &&
        pt.y >= prcHot->top && 
        arrNumMaps[i].dy) {
        
        if (arrNumMaps[i].dy > 0)
            pt.y = prcHot->bottom - 2;
        else 
            pt.y = prcHot->top + 1;
        
    }
    
    pt.x += arrNumMaps[i].dx;
    pt.y += arrNumMaps[i].dy;

    if (!arrNumMaps[i].dx && !arrNumMaps[i].dy) {
        // special case this for centering
        pt.x = (prcHot->right + prcHot->left) / 2;
        pt.y = (prcHot->top + prcHot->bottom) / 2;
    }

    // all we do is move the cursor.. the RM_CheckScroll will do the actual
    // scrolling for us.
    SetCursorPos(pt.x, pt.y);
}

void RM_GetScrollXY(PREADERMODEINFO prmi, LPRECT prcHot, LPINT pdx, LPINT pdy)
{

    POINT pt;
    
    GetCursorPos(&pt);
    
    *pdx = 0;
    *pdy = 0;
    
    if (pt.x <= prcHot->left) {
        *pdx = ((pt.x - prcHot->left) / RM_SCROLLUNIT) - 1;
    } else if (pt.x >= prcHot->right) {
        *pdx = ((pt.x - prcHot->right) / RM_SCROLLUNIT) + 1;
    }
    
    if (pt.y <= prcHot->top) {
        *pdy = ((pt.y - prcHot->top) / RM_SCROLLUNIT) - 1;
    } else if (pt.y >= prcHot->bottom) {
        *pdy = ((pt.y - prcHot->bottom) / RM_SCROLLUNIT) + 1;
    }

    if (prmi->fFlags & RMF_VERTICALONLY)
        *pdx = 0;

    if (prmi->fFlags & RMF_HORIZONTALONLY)
        *pdy = 0;
}

void RM_CheckScroll(PREADERMODEINFO prmi, LPRECT prcHot)
{
    int dx;
    int dy;

    RM_GetScrollXY(prmi, prcHot, &dx, &dy);
    prmi->pfnScroll(prmi, dx, dy);
}

void RM_SetCursor(PREADERMODEINFO prmi, LPRECT prcHot)
{
    int dx;
    int dy;
    LPCTSTR pRes;
    
    RM_GetScrollXY(prmi, prcHot, &dx, &dy);

    // default is center
    if (prmi->fFlags & RMF_VERTICALONLY)
        pRes = IDC_VERTICALONLY;
    else if (prmi->fFlags & RMF_HORIZONTALONLY)
        pRes = IDC_HORIZONTALONLY;
    else
        pRes = IDC_MOVE2D;

    // multiply to figure out if either is zero and also the sign parity
    if (dy * dx) {
        // diagonal case
        if (dy > 0) {
            if (dx > 0)
                pRes = IDC_SOUTHEAST;
            else
                pRes = IDC_SOUTHWEST;
        } else {
            if (dx > 0)
                pRes = IDC_NORTHEAST;
            else
                pRes = IDC_NORTHWEST;
        }
    } else {
        // simple horizontal or vertical case
        if (dy > 0)
            pRes = IDC_SOUTH;
        else if (dy < 0)
            pRes = IDC_NORTH;
        else if (dx < 0)
            pRes = IDC_WEST;
        else if (dx > 0)
            pRes = IDC_EAST;
    }
    
    SetCursor(LoadCursor(HINST_THISDLL, pRes));
    
}

void DoReaderMode(PREADERMODEINFO prmi)
{
    RECT rcHot;
    
    if (!prmi->hwnd || prmi->cbSize != sizeof(*prmi))
        return;
    
    SetCapture(prmi->hwnd);
    
    // if they didn't pass in a rect, then use the window
    if (!prmi->prc) {
        GetWindowRect(prmi->hwnd, &rcHot );
    } else {
        rcHot = *prmi->prc;
        MapWindowPoints(prmi->hwnd, HWND_DESKTOP, (LPPOINT)&rcHot, 2);
    }
    
    
    // set the cursor to the center of the hot rect if they ask us to
    if (prmi->fFlags & RMF_ZEROCURSOR) {
        SetCursorPos((rcHot.left + rcHot.right)/2, 
                     (rcHot.top + rcHot.bottom)/2);
    }
    
    while (GetCapture() == prmi->hwnd) {
        
        BOOL  fMessage;
        MSG32 msg32;
        RM_CheckScroll(prmi, &rcHot);

        // Try to peek keyboard message first, then mouse message,
        // and finally, other message. This is for raid 44392.
        // During scrolling, Trident might generate too many WM_PAINT
        // messages that push keyboard/mouse message (that DoReaderMode()
        // uses to stop auto-scroll mode) down in message pump, and we can
        // not get those messages until we peek and process all these
        // WM_PAINT messages. This is way cuto-scroll mode can be stopped
        // only by moving cursor back to origin circle (Trident does not
        // scroll, so no need to paint). Trident's scroll performance
        // issue will be worked on after RTM (raid 33232).
        //
        fMessage = PeekMessage32(&msg32, NULL, WM_KEYFIRST, WM_KEYLAST,
                        PM_REMOVE, TRUE);
        if (!fMessage)
        {
            fMessage = PeekMessage32(&msg32, NULL, WM_MOUSEFIRST, WM_MOUSELAST,
                            PM_REMOVE, TRUE);
            if (!fMessage)
            {
                fMessage = PeekMessage32(&msg32, NULL, 0, 0, PM_REMOVE, TRUE);
            }
        }

        if (fMessage) {
            if (!prmi->pfnTranslateDispatch || 
                !prmi->pfnTranslateDispatch((LPMSG)&msg32)) {

                if (msg32.message == g_msgMSWheel)
                    goto BailOut;

                switch(msg32.message) {
                case WM_LBUTTONUP:
                case WM_RBUTTONUP:
                case WM_MBUTTONUP:
                case WM_LBUTTONDOWN:
                case WM_RBUTTONDOWN:
                case WM_MBUTTONDOWN:
                case WM_SYSKEYDOWN:
BailOut:
                    ReleaseCapture();
                    break;

                case WM_KEYDOWN:
                    // if it's an arrow key, move the mouse cursor
                    RM_HandleKeyDown(&rcHot, msg32.wParam, msg32.lParam);
                    break;

                case WM_MOUSEMOVE:
                case WM_SETCURSOR:
                    RM_SetCursor(prmi, &rcHot);
                    break;

                default:
                    TranslateMessage32(&msg32, TRUE);
                    DispatchMessage32(&msg32, TRUE);
                }
                
            }
        }
        else WaitMessage();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\readermode.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"

//---------------------------------------------------------------------------//
#define TIMERID         1

#define RDRMODE_VERT    0x00000001
#define RDRMODE_HORZ    0x00000002
#define RDRMODE_DIAG    0x00000004

#define RDRCODE_START   1
#define RDRCODE_SCROLL  2
#define RDRCODE_END     3

//
// Instance data pointer access functions
//
#define ReaderMode_GetPtr(hwnd)    \
            (PREADERINFO)GetWindowPtr(hwnd, 0)

#define ReaderMode_SetPtr(hwnd, p) \
            (PREADERINFO)SetWindowPtr(hwnd, 0, p)


//---------------------------------------------------------------------------//
typedef LONG (CALLBACK* READERMODEPROC)(LPARAM lParam, int nCode, int dx, int dy);


//---------------------------------------------------------------------------//
typedef struct tagREADERMODE 
{
    UINT    cbSize;
    DWORD   dwFlags;
    READERMODEPROC pfnReaderModeProc;
    LPARAM  lParam;
} READERMODE, *PREADERMODE;


//---------------------------------------------------------------------------//
typedef struct tagREADERINFO 
{
    READERMODE;
    READERMODE  rm;
    int         dx;
    int         dy;
    UINT        uCursor;
    HBITMAP     hbm;
    UINT        dxBmp;
    UINT        dyBmp;
} READERINFO, *PREADERINFO;


//---------------------------------------------------------------------------//
typedef struct tagREADERWND 
{
    HWND        hwnd;
    PREADERINFO prdr;
} READERWND, *PREADERWND;


//---------------------------------------------------------------------------//
__inline FReader2Dim(PREADERINFO prdr)
{
    return ((prdr->dwFlags & (RDRMODE_HORZ | RDRMODE_VERT)) ==
            (RDRMODE_HORZ | RDRMODE_VERT));
}
__inline FReaderVert(PREADERINFO prdr)
{
    return (prdr->dwFlags & RDRMODE_VERT);
}
__inline FReaderHorz(PREADERINFO prdr)
{
    return (prdr->dwFlags & RDRMODE_HORZ);
}
__inline FReaderDiag(PREADERINFO prdr)
{
    return (prdr->dwFlags & RDRMODE_DIAG);
}


//---------------------------------------------------------------------------//
void ReaderMode_SetCursor(PREADERINFO prdr, UINT uCursor)
{
    if (prdr->uCursor != uCursor) 
    {
        SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(uCursor)));
        prdr->uCursor = uCursor;
    }
}


//---------------------------------------------------------------------------//
//
// ReaderMode_MouseMove
//
// Calculate dx and dy based on the flags passed in.  Provide visual
// feedback for the reader mode by setting the correct cursor.
//
void ReaderMode_MouseMove(HWND hwnd, PREADERINFO prdr, LPARAM lParam)
{
    int dx = 0, dy = 0;
    RECT rc;
    UINT uCursor;
    POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};

    GetWindowRect(hwnd, &rc);

    ClientToScreen(hwnd, &pt);

    if (FReaderVert(prdr)) 
    {
        if (pt.y < rc.top) 
        {
            dy = pt.y - rc.top;
        } 
        else if (pt.y > rc.bottom) 
        {
            dy = pt.y - rc.bottom;
        }
    }

    if (FReaderHorz(prdr)) 
    {
        if (pt.x < rc.left) 
        {
            dx = pt.x - rc.left;
        } 
        else if (pt.x > rc.right) 
        {
            dx = pt.x - rc.right;
        }
    }

    if (FReader2Dim(prdr)) 
    {
        if (dx == 0 && dy == 0) 
        {
            ReaderMode_SetCursor(prdr, OCR_RDR2DIM);
            goto Exit;
        }

        if (!FReaderDiag(prdr)) 
        {
            if (prdr->dy != 0) 
            {
                if (abs(dx) > abs(prdr->dy)) 
                {
                    dy = 0;
                } 
                else 
                {
                    dx = 0;
                }
            } 
            else if (prdr->dx != 0) 
            {
                if (abs(dy) > abs(prdr->dx)) 
                {
                    dx = 0;
                } 
                else 
                {
                    dy = 0;
                }
            } 
            else if (dy != 0) 
            {
                dx = 0;
            }
        }
    } 
    else if (FReaderVert(prdr) && dy == 0) 
    {
        ReaderMode_SetCursor(prdr, OCR_RDRVERT);
        goto Exit;
    } 
    else if (FReaderHorz(prdr) && dx == 0) 
    {
        ReaderMode_SetCursor(prdr, OCR_RDRHORZ);
        goto Exit;
    }

    if (dx == 0) 
    {
        uCursor = (dy > 0) ? OCR_RDRSOUTH : OCR_RDRNORTH;
    } 
    else if (dx > 0) 
    {
        if (dy == 0) 
        {
            uCursor = OCR_RDREAST;
        } 
        else 
        {
            uCursor = (dy > 0) ? OCR_RDRSOUTHEAST : OCR_RDRNORTHEAST;
        }
    } 
    else if (dx < 0) 
    {
        if (dy == 0) 
        {
            uCursor = OCR_RDRWEST;
        } 
        else 
        {
            uCursor = (dy > 0) ? OCR_RDRSOUTHWEST : OCR_RDRNORTHWEST;
        }
    }

    ReaderMode_SetCursor(prdr, uCursor);

Exit:
    prdr->dx = dx;
    prdr->dy = dy;
}


//---------------------------------------------------------------------------//
void ReaderMode_Feedback(HWND hwnd, PREADERINFO prdr)
{
    if (prdr->dx || prdr->dy)
    {
        if (prdr->pfnReaderModeProc(prdr->lParam, RDRCODE_SCROLL, prdr->dx, prdr->dy) == 0) 
        {
            DestroyWindow(hwnd);
        }
    }
}


//---------------------------------------------------------------------------//
LRESULT CALLBACK ReaderMode_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HDC    hdc, hdcMem;
    HPEN   hpen, hpenOld;
    HBRUSH hbrOld;
    HRGN   hrgn;
    RECT   rc;
    POINT  pt;
    int    nBitmap, cx, cy;
    PREADERINFO    prdr;
    LPCREATESTRUCT pcs;
    PREADERMODE    prdrm;
    BITMAP bmp;

    prdr = ReaderMode_GetPtr(hwnd);

    if (prdr || msg == WM_CREATE)
    {
        switch (msg) 
        {
        case WM_TIMER:
            ReaderMode_Feedback(hwnd, prdr);
            return 0;

        case WM_MOUSEWHEEL:
        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_XBUTTONUP:
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_XBUTTONDOWN:
        case WM_KEYDOWN:
            ReleaseCapture();
            return 0;

        case WM_MOUSEMOVE:
            ReaderMode_MouseMove(hwnd, prdr, lParam);
            return 0;

        case WM_MBUTTONUP:
            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);
            GetClientRect(hwnd, &rc);
            if (!PtInRect(&rc, pt)) 
            {
                ReleaseCapture();
            }
            return 0;

        case WM_CAPTURECHANGED:
            DestroyWindow(hwnd);
            return 0;

        case WM_NCDESTROY:
            KillTimer(hwnd, TIMERID);

            prdr->pfnReaderModeProc(prdr->lParam, RDRCODE_END, 0, 0);

            if (prdr->hbm != NULL) 
            {
                DeleteObject(prdr->hbm);
            }
            UserLocalFree(prdr);
            return 0;

        case WM_CREATE:
            prdr = (PREADERINFO)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(READERINFO));
            if (prdr == NULL)
            {
                return -1;
            }

            pcs = (LPCREATESTRUCT)lParam;
            prdrm = (PREADERMODE)pcs->lpCreateParams;
            CopyMemory(prdr, prdrm, sizeof(READERMODE));
            ReaderMode_SetPtr(hwnd, prdr);

            if (prdr->pfnReaderModeProc == NULL) 
            {
                return -1;
            }

            if (FReader2Dim(prdr)) 
            {
                nBitmap = OBM_RDR2DIM;
            } 
            else if (FReaderVert(prdr)) 
            {
                nBitmap = OBM_RDRVERT;
            } 
            else if (FReaderHorz(prdr)) 
            {
                nBitmap = OBM_RDRHORZ;
            } 
            else 
            {
                return -1;
            }

            SetWindowLong(hwnd, GWL_EXSTYLE, WS_EX_TOOLWINDOW);
            SetWindowLong(hwnd, GWL_STYLE, WS_POPUP | WS_CLIPSIBLINGS);

            prdr->hbm = LoadBitmap(NULL, MAKEINTRESOURCE(nBitmap));
            if (prdr->hbm == NULL ||
                GetObject(prdr->hbm, sizeof(BITMAP), &bmp) == 0) 
            {
                return -1;
            }

            if (prdr->pfnReaderModeProc(prdr->lParam, RDRCODE_START, 0, 0) == 0) 
            {
                return -1;
            }

            prdr->dxBmp = bmp.bmWidth;
            prdr->dyBmp = bmp.bmHeight;

            cx = bmp.bmWidth + 1;
            cy = bmp.bmHeight + 1;

            GetCursorPos(&pt);
            pt.x -= cx/2;
            pt.y -= cy/2;

            if ((hrgn = CreateEllipticRgn(0, 0, cx, cy)) != NULL) 
            {
                SetWindowRgn(hwnd, hrgn, FALSE);
            }

            SetWindowPos(hwnd, HWND_TOPMOST, pt.x, pt.y, cx, cy,
                    SWP_SHOWWINDOW | SWP_NOACTIVATE);

            SetCapture(hwnd);
            SetFocus(hwnd);
            SetTimer(hwnd, TIMERID, 10, NULL);
            return 0;

        case WM_ERASEBKGND:
            hdc = (HDC)wParam;

            if ((hdcMem = CreateCompatibleDC(hdc)) == NULL)
            {
                return FALSE;
            }

            SelectObject(hdcMem, prdr->hbm);
            hpen = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));
            if (hpen)
            {
                hpenOld = (HPEN)SelectObject(hdc, hpen);
                hbrOld = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));

                BitBlt(hdc, 0, 0, prdr->dxBmp, prdr->dyBmp, hdcMem, 0, 0, SRCCOPY);
                Ellipse(hdc, 0, 0, prdr->dxBmp, prdr->dyBmp);

                SelectObject(hdc, hpenOld);
                SelectObject(hdc, hbrOld);

                DeleteObject(hpen);
            }
            DeleteObject(hdcMem);
            return TRUE;
        }
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}


//---------------------------------------------------------------------------//
LONG ReaderMode_InternalProc(LPARAM lParam, int nCode, int dx, int dy)
{
    DWORD dwDelay;
    UINT uMsg, uCode;
    int n, nAbs;

    if (nCode != RDRCODE_SCROLL)
        return TRUE;

    if (dy != 0) 
    {
        uCode = SB_LINEUP;
        uMsg = WM_VSCROLL;
        n = dy;
    } 
    else 
    {
        uCode = SB_LINELEFT;
        uMsg = WM_HSCROLL;
        n = dx;
    }

    nAbs = abs(n);
    if (nAbs >= 120) 
    {
        uCode += 2;
        dwDelay = 0;
    } 
    else 
    {
        dwDelay = 1000 - (nAbs / 2) * 15;
    }

    if (n > 0) 
    {
        uCode += 1;
    }

    SendMessage((HWND)lParam, uMsg, MAKELONG(uCode, dwDelay), 0);
    UpdateWindow((HWND)lParam);
    return TRUE;
}


//---------------------------------------------------------------------------//
BOOL InitReaderModeClass(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = ReaderMode_WndProc;
    wc.lpszClassName = WC_READERMODE;
    wc.style         = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(READERINFO);
    wc.hInstance     = hinst;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName  = NULL;

    if (!RegisterClass(&wc) && !GetClassInfo(hinst, WC_BUTTON, &wc))
        return FALSE;


    return TRUE;
}


//---------------------------------------------------------------------------//
BOOL ReaderMode_ScrollEnabled(HWND hwnd, BOOL fVert)
{
    SCROLLBARINFO sbi = {0};
    BOOL fResult = FALSE;

    sbi.cbSize = sizeof(sbi);
    if ( GetScrollBarInfo(hwnd, fVert ? OBJID_VSCROLL : OBJID_HSCROLL, &sbi) )
    {
        fResult = (sbi.rgstate[0] & (STATE_SYSTEM_UNAVAILABLE|STATE_SYSTEM_INVISIBLE|STATE_SYSTEM_OFFSCREEN)) ? FALSE : TRUE;
    }

    return fResult;
}

//---------------------------------------------------------------------------//
//
// EnterReaderMode - entry point to the ReaderMode control displayed when
//                   the user presses the scroll wheel. Renders an eliptical
//                   window that traps mouse movements in order to autoscroll
//                   the given hwnd.
//
BOOL EnterReaderMode(HWND hwnd)
{
    BOOL fResult = FALSE;

    if (GetCapture() == NULL)
    {
        READERMODE rdrm;

        rdrm.cbSize = sizeof(READERMODE);
        rdrm.pfnReaderModeProc = ReaderMode_InternalProc;
        rdrm.lParam = (LPARAM)hwnd;
        rdrm.dwFlags = 0;

        if (ReaderMode_ScrollEnabled(hwnd, TRUE)) 
        {
            rdrm.dwFlags |= RDRMODE_VERT;
        }

        if (ReaderMode_ScrollEnabled(hwnd, FALSE)) 
        {
            rdrm.dwFlags |= RDRMODE_HORZ;
        }

        if (rdrm.dwFlags)
        {
            fResult = (CreateWindowEx(0, 
                            WC_READERMODE, 
                            NULL, 
                            0, 0, 0, 0, 0, 
                            NULL, 
                            NULL, 
                            NULL, 
                            (LPVOID)&rdrm) != NULL);
        }
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\scdttime.h ===
#define INCRSYS_YEAR    0x0001
#define INCRSYS_MONTH   0x0002
#define INCRSYS_WEEK    0x0004
#define INCRSYS_DAY     0x0008
#define INCRSYS_HOUR    0x0010
#define INCRSYS_MINUTE  0x0020
#define INCRSYS_SECOND  0x0040

int GetWeekNumber(const SYSTEMTIME *pst, int dowFirst, int woyFirst);
int CmpDate(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2);
int CmpSystemtime(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2);
void IncrSystemTime(SYSTEMTIME *pstSrc, SYSTEMTIME *pstDest, LONG delta, LONG flags);
int GetDaysForMonth(int year, int month);
int GetStartDowForMonth(int year, int month);
DWORD DaysBetweenDates(const SYSTEMTIME *pstStart, const SYSTEMTIME *pstEnd);
int DowFromDate(const SYSTEMTIME *pst);

BOOL IsValidDate(const SYSTEMTIME *pst);
BOOL IsValidTime(const SYSTEMTIME *pst);
BOOL IsValidSystemtime(const SYSTEMTIME *pst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\rebar.cpp ===
#include "ctlspriv.h"
#include "image.h"

#define ANIMSTEPS 10
#define ANIMSTEPTIME 5
#define CX_CHEVRON (g_cxScrollbar)
#define CX_OFFSET (2 * g_cxEdge)
#define GRABWIDTH 5


//***   RBC_* -- commands
#define RBC_QUERY   0
#define RBC_SET     1


typedef struct tagREBARBAND
{
    UINT        fStyle;
    COLORREF    clrFore;
    COLORREF    clrBack;
    LPTSTR      lpText;
    int         cxText;         // width of header text
    int         iImage;
    int         cxMinChild;     // min width for hwndChild
    int         cyMinChild;     // min height for hwndChild
    int         cxBmp;
    int         cyBmp;
    int         x;              // left edge of band, relative to rebar
    int         y;              // top edge of band, relative to rebar
    int         cx;             // total width of band
    int         cy;             // height of band
    int         cxRequest;      // 'requested' width for band; either requested by host or used as temp var during size recalculation
    int         cxMin;          // min width for band
    int         cxIdeal;        // hwndChild's desired width
    int         cyMaxChild;     // hwndChild's max height
    int         cyIntegral;     // ??
    int         cyChild;        // this differs from cyMinChild only in RBBS_VARIABLEHEIGHT mode
    HWND        hwndChild;
    HBITMAP     hbmBack;
    UINT        wID;
    LPARAM      lParam;
    BOOL        fChevron;     // band is showing chevron button
    RECT        rcChevron;      // chevron button rect
    UINT        wChevState;     // chevron button state (DFCS_PUSHED, etc.)
} RBB, *PRBB;

class CReBar
{
public:


private:

    void _CacheThemeInfo(BOOL fOpenNew);
    int _GetGripperWidth();
    void _Realize(HDC hdcParam, BOOL fBackground, BOOL fForceRepaint);
    LRESULT _SendNotify(UINT uBand, int iCode);
    BOOL _InvalidateRect(RECT* prc);
    static LRESULT s_DragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp);
    BOOL _CanBandMove(PRBB prbb);
    void _BandCalcMinWidth(PRBB prbb);
    BOOL _ShouldDrawGripper(PRBB prbb);
    BOOL _BandCalcTextExtent(PRBB prbb, HDC hdcIn);
    int  _BandGetHeight(PRBB prbb);
    UINT _GetRowCount();
    int  _GetLineHeight(UINT iStart, UINT iEnd);
    void _BandRecalcChevron(PRBB prbb, BOOL fChevron);
    void _ResizeChildren();
    BOOL _MoveBand(UINT iFrom, UINT iTo);
    int  _Recalc(LPRECT prc, BOOL fForce = FALSE);
    void _ResizeNow();
    void _Resize(BOOL fForceHeightChange);
    void _SetRecalc(BOOL fRecalc);
    BOOL _SetRedraw(BOOL fRedraw);
    BOOL _AfterSetFont();
    BOOL _OnSetFont(HFONT hFont);
    BOOL _SetFont(WPARAM wParam);
    void _VertMungeGripperRect(LPRECT lprc);
    void _DrawChevron(PRBB prbb, HDC hdc);
    void _UpdateChevronState(PRBB prbb, WORD wControlState);
    void _DrawBand(PRBB prbb, HDC hdc);
    void _OnPaint(HDC hdcIn);
    void _BandTileBlt(PRBB prbb, int x, int y, int cx, int cy, HDC hdcDst, HDC hdcSrc);
    int _InternalHitTest(LPRBHITTESTINFO prbht, int x, int y);
    int _HitTest(LPRBHITTESTINFO prbht);
    BOOL _EraseBkgnd(HDC hdc, int iBand);
    BOOL _GetBarInfo(LPREBARINFO lprbi);
    BOOL _SetBarInfo(LPREBARINFO lprbi);
    BOOL _GetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi);
    BOOL _ValidateBandInfo(LPREBARBANDINFO *pprbbi, LPREBARBANDINFO prbbi);
    BOOL _SetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi, BOOL fAllowRecalc);
    BOOL _ReallocBands(UINT cBands);
    BOOL _RecalcFirst(int nCmd, PRBB prbbDelHide);
    BOOL _ShowBand(UINT uBand, BOOL fShow);
    BOOL _DeleteBand(UINT uBand);
    BOOL _InsertBand(UINT uBand, LPREBARBANDINFO lprbbi);
    PRBB _GetFirstInRow(PRBB prbbRow);
    PRBB _GetLastInRow(PRBB prbbRow, BOOL fStopAtFixed);
    PRBB _GetPrev(PRBB prbb, UINT uStyleSkip);
    PRBB _GetNext(PRBB prbb, UINT uStyleSkip);
    int _CountBands(UINT uStyleSkip);
    PRBB _EnumBand(int i, UINT uStyleSkip);
    int _MinX(PRBB prbb);
    int _MaxX(PRBB prbb);
    BOOL _MinimizeBand(UINT uBand, BOOL fAnim);
    BOOL _MaximizeBand(UINT uBand, BOOL fIdeal, BOOL fAnim);
    void _ToggleBand(BOOL fAnim);
    void _SetCursor(int x, int y, BOOL fMouseDown);
    BOOL _SetBandPos(PRBB prbb, int xLeft);
    BOOL _SetBandPosAnim(PRBB prbb, int xLeft);
    void _OnBeginDrag(UINT uBand);
    void _PassBreak(PRBB prbbSrc, PRBB prbbDest);
    void _GetClientRect(LPRECT prc);
    BOOL _RecalcIfMove(PRBB prbb);
    BOOL _RoomForBandVert(PRBB prbbSkip);
    BOOL _MakeNewRow(PRBB prbb, int y);
    void _DragBand(int x, int y);
    HPALETTE _SetPalette(HPALETTE hpal);
    BOOL _OnDestroy();
    void _InitPaletteHack();
    UINT _IDToIndex(UINT id);
    int _GetRowHeight(UINT uRow);
    int _GrowBand(PRBB prbb, int dy, BOOL fResize, int iLineHeight);
    int _SizeDifference(LPRECT prc);
    int _GetRowHeightExtra(PRBB *pprbb, PRBB prbbSkip);
    BOOL _BandsAtMinHeight();
    BOOL _SizeBandsToRect(LPRECT prc);
    void _SizeBandToRowHeight(int i, int uRowHeight);
    void _SizeBandsToRowHeight();
    BOOL _OkayToChangeBreak(PRBB prbb, UINT uMsg);
    LRESULT _SizeBarToRect(DWORD dwFlags, LPRECT prc);
    void _AutoSize();
    LRESULT _GetBandBorders(int wParam, LPRECT prc);
    void _OnStyleChanged(WPARAM wParam, LPSTYLESTRUCT lpss);
    void _OnMouseMove(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnPushChevron(HWND hwnd, PRBB prbb, LPARAM lParamNM);
    void _InvalidateBorders(PRBB prbb);

    void _OnCreate(HWND hwnd, LPCREATESTRUCT pcs);
    static LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    PRBB CReBar::_GetPrevVisible(PRBB prbb)
    {
        return _GetPrev(prbb, RBBS_HIDDEN);
    }

    PRBB CReBar::_GetNextVisible(PRBB prbb)
    {
        return _GetNext(prbb, RBBS_HIDDEN);
    }

    BOOL CReBar::_DragSize(int xLeft)
    {
        // adjust the captured band's starting location to the given location
        return _SetBandPos(_GetBand(_uCapture), xLeft);
    }

    int _FudgeWidth(int cx)
    {
        if (_UseBandBorders())
            cx += g_cxEdge;
        return cx + _mBand.cxLeftWidth + _mBand.cxRightWidth;
    }

    int _BandWidth(PRBB prbb)
    {
        ASSERT(!(prbb->fStyle & RBBS_HIDDEN));
        return _FudgeWidth(prbb->cx);
    }

    int _BandMinWidth(PRBB prbb)
    {
        ASSERT(!(prbb->fStyle & RBBS_HIDDEN));
        return _FudgeWidth(prbb->cxMin);
    }

    BOOL _UseBandBorders()
    {
        return _ci.style & RBS_BANDBORDERS;
    }

    BOOL _UseChevron(PRBB prbb)
    {
        return (prbb->fStyle & RBBS_USECHEVRON) &&
                !(prbb->fStyle & RBBS_FIXEDSIZE) &&
                (prbb->cxIdeal > prbb->cxMinChild);
    }

    BOOL _ShowText(PRBB prbb)
    {
        return !(prbb->fStyle & RBBS_HIDETITLE) && prbb->lpText && prbb->lpText[0];
    }

    BOOL _IsVertical()
    {
        return (_ci.style & CCS_VERT);
    }

    BOOL _IsVerticalGripper()
    {
        return _IsVertical() && (_ci.style & RBS_VERTICALGRIPPER);
    }

    PRBB _GetLastBand()
    {
        if (_cBands > 0)
            return _GetBand(_cBands - 1);
        return NULL;
    }

    BOOL _IsBandStartOfRow(PRBB prbb)
    {
        return (prbb->x == _mBand.cxLeftWidth) && !(prbb->fStyle & RBBS_HIDDEN);
    }
    
    PRBB _GetBand(UINT i)
    {
        _ValidateRangeInd(i);
        return &_rbbList[i];
    }
    
    UINT _BandToIndex(PRBB prbb)
    {
        return (UINT)(prbb - _rbbList);
    }

    int _GetHeaderWidth(PRBB prbb)
    {
        return (prbb->cxMin - (prbb->cxMinChild + (_UseChevron(prbb) ? CX_CHEVRON : 0)));
    }

    BOOL _IsBandVisible(PRBB prbb)
    {
        return !(prbb->fStyle & RBBS_HIDDEN);
    }
    
    BOOL _IsRowAtMinHeight(PRBB* pprbb)
    {
        return !_GetRowHeightExtra(pprbb, NULL);
    }

    int _GetBarHeight()
    {
        return (_cBands && _cy == 0) ? _Recalc(NULL, TRUE) : _cy;
    }

    BOOL _IsValidIndex(UINT i)
    {
        return (BOOL)(i < _cBands);
    }

    BOOL _IsValidBand(PRBB prbb)
    {
        return _IsValidIndex(_BandToIndex(prbb));
    }

    COLORREF _GetBkColor()
    {
        if (_clrBk == CLR_DEFAULT)
            return g_clrBtnFace;
        else
            return _clrBk;
    }

    COLORREF _GetTextColor()
    {
        if (_clrText == CLR_DEFAULT)
            return g_clrBtnText;
        else
            return _clrText;
    }

    COLORREF _BandGetBkColor(PRBB prbb)
    {
        switch(prbb->clrBack)
        {
        case CLR_NONE:
            // CLR_NONE means "use our dad's color"
            return _GetBkColor();

        case CLR_DEFAULT:
            return g_clrBtnFace;

        default:
            return prbb->clrBack;
        }
    }

    COLORREF _BandGetTextColor(PRBB prbb)
    {
        switch (prbb->clrFore)
        {
        case CLR_NONE:
            // CLR_NONE means "use our dad's color"
            return _GetTextColor();

        case CLR_DEFAULT:
            return g_clrBtnText;

        default:
            return prbb->clrFore;
        }
    }

    //
    // Our use of CLR_DEFAULT for the band background colors is new for 
    // version 5.01.  Since we don't want to confuse apps by returning
    // CLR_DEFAULT when they used to see a real colorref, we convert it
    // before returning it to them.  If the background color is CLR_NONE, 
    // though, we need to return it without conversion (like version 4 did).
    // The *External functions handle these cases.
    //
    COLORREF _BandGetTextColorExternal(PRBB prbb)
    {
        if (prbb->clrFore == CLR_NONE)
            return CLR_NONE;
        else
            return _BandGetTextColor(prbb);
    }

    COLORREF _BandGetBkColorExternal(PRBB prbb)
    {
        if (prbb->clrBack == CLR_NONE)
            return CLR_NONE;
        else
            return _BandGetBkColor(prbb);
    }

    BOOL _ValidateRangePtr(PRBB prbb)
    {
#ifdef DEBUG
        if (prbb < _GetBand(0)) {
            ASSERT(0);
            return FALSE;
        }

        if (_GetLastBand() + 1 < prbb) {
            // +1 to allow for "p = first; p < last+1; p++" kinds of loops
            ASSERT(0);
            return FALSE;
        }
#endif
        return TRUE;
    }

    BOOL _ValidateRangeInd(UINT i)
    {
#ifdef DEBUG
        if ( !IsInRange(i, 0, _cBands) ) { // if !(0 <= i <= _cBands)
            // +1 to allow for "p = first; p < last+1; p++" kinds of loops
            ASSERT(0);
            return FALSE;
        }
#endif
        return TRUE;
    }

    CCONTROLINFO _ci;
    HPALETTE    _hpal;
    BOOL     _fResizeRecursed;
    BOOL     _fResizePending;
    BOOL     _fResizeNotify;
    BOOL     _fRedraw;
    BOOL     _fRecalcPending;
    BOOL     _fRecalc;
    BOOL     _fParentDrag;
    BOOL     _fRefreshPending;
    BOOL     _fResizing;
    BOOL     _fUserPalette;
    BOOL     _fFontCreated;
    BOOL     _fFullOnDrag;
    BOOL     _fHasBorder;
    HDRAGPROXY  _hDragProxy;
    HWND        _hwndToolTips;
    int         _xBmpOrg;
    int         _yBmpOrg;
    int         _cyFont;
    int         _cy;
    int         _cxImage;
    int         _cyImage;
    int         _xStart;
    MARGINS     _mBand;
    HIMAGELIST  _himl;
    HFONT       _hFont;
    UINT        _cBands;
    UINT        _uCapture;
    UINT        _uResizeNext;    // this marks the next band to resize vertically if needed and allowed (VARIABLEHEIGHT set)
    POINT       _ptCapture;
    PRBB        _rbbList;
    COLORREF    _clrBk;
    COLORREF    _clrText;
    DWORD       _dwStyleEx;
    COLORSCHEME _clrsc;
    POINT       _ptLastDragPos;
    PRBB        _prbbHot;        // band w/ hot chevron
    HTHEME      _hTheme;

    friend BOOL InitReBarClass(HINSTANCE hInstance);
};

void CReBar::_CacheThemeInfo(BOOL fOpenNew)
{
    if (_hTheme)
        CloseThemeData(_hTheme);

    _hTheme = NULL;

    if (fOpenNew)
        _hTheme = OpenThemeData(_ci.hwnd, L"Rebar");

    if (_hTheme)
    {
        // Get the cached metrics. These are things that can be slow to get during a calculation
        GetThemeMargins(_hTheme, NULL, RP_BAND, 0, TMT_CONTENTMARGINS, NULL, &_mBand);
        SetWindowBits(_ci.hwnd, GWL_STYLE, WS_BORDER, 0);
    }
    else
    {
        if (_fHasBorder)
            SetWindowBits(_ci.hwnd, GWL_STYLE, WS_BORDER, WS_BORDER);
        ZeroMemory(&_mBand, sizeof(MARGINS));
    }

    _AfterSetFont();
}

int CReBar::_GetGripperWidth()
{
    BOOL fVert;
    RECT rcClient;
    RECT rc;

    if (!_hTheme)
        return GRABWIDTH;

    GetClientRect(_ci.hwnd, &rcClient);
    fVert = _IsVerticalGripper();
    SetRect(&rc, 0, 0, fVert?RECTWIDTH(rcClient):3, fVert?3:RECTHEIGHT(rcClient));
    GetThemeBackgroundExtent(_hTheme, NULL, RP_GRIPPER, 0, &rc, &rc);
    return fVert?RECTHEIGHT(rc):RECTWIDTH(rc);
}

///
//
// Map a rect to parent should be based on the visual right edge
// for calculating the client coordinates for a RTL mirrored windows.
// This routine should only be used when calculating client
// coordinates in a RTL mirrored window. [samera]
//
BOOL MapRectInRTLMirroredWindow( LPRECT lprc, HWND hwnd)
{
    int iWidth  = lprc->right - lprc->left;
    int iHeight = lprc->bottom- lprc->top;
    RECT rc={0,0,0,0};


    if (hwnd) {
        GetClientRect(hwnd, &rc);
        MapWindowPoints(hwnd, NULL, (LPPOINT)&rc.left, 2);
    }

    lprc->left = rc.right - lprc->right;
    lprc->top  = lprc->top-rc.top;

    lprc->bottom = lprc->top + iHeight;
    lprc->right  = lprc->left + iWidth;

    return TRUE;
}

void CReBar::_Realize(HDC hdcParam, BOOL fBackground, BOOL fForceRepaint)
{
    if (_hpal)
    {
        HDC hdc = hdcParam ? hdcParam : GetDC(_ci.hwnd);

        if (hdc)
        {
            BOOL fRepaint;
            
            SelectPalette(hdc, _hpal, fBackground);
            fRepaint = RealizePalette(hdc) || fForceRepaint;

            if (!hdcParam)
                ReleaseDC(_ci.hwnd, hdc);

            if (fRepaint)
            {
                InvalidateRect(_ci.hwnd, NULL, TRUE);
            }
        }
    }
}


//////////////////////////////////////////////////////////////////
// _SendNotify
//
// sends a wm_notify of code iCode and packages up all the data for you
// for band uBand
//
//////////////////////////////////////////////////////////////////
LRESULT CReBar::_SendNotify(UINT uBand, int iCode)
{
    NMREBAR nm = {0};
    
    nm.uBand = uBand;
    if (uBand != (UINT)-1) {
        nm.dwMask = RBNM_ID | RBNM_STYLE | RBNM_LPARAM;

        nm.wID = _GetBand(uBand)->wID;
        nm.fStyle = _GetBand(uBand)->fStyle;
        nm.lParam = _GetBand(uBand)->lParam;
    }
    return CCSendNotify(&_ci, iCode, &nm.hdr);
}


BOOL CReBar::_InvalidateRect(RECT* prc)
{
    if (_fRedraw) 
    {
        RECT rc;

        if (prc && _IsVertical())
        {
            CopyRect(&rc, prc);
            FlipRect(&rc);
            prc = &rc;
        }

        _fRefreshPending = FALSE;
        InvalidateRect(_ci.hwnd, prc, TRUE);
        return TRUE;
    }
    else 
    {
        _fRefreshPending = TRUE;
        return FALSE;
    }
}

LRESULT CReBar::s_DragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp)
{
    CReBar* prb = (CReBar*)GetWindowPtr(hwnd, 0);
    LRESULT lres;

    switch (code)
    {
    case DPX_DRAGHIT:
        if (lp)
        {
            int iBand;
            RBHITTESTINFO rbht;

            rbht.pt.x = ((POINTL *)lp)->x;
            rbht.pt.y = ((POINTL *)lp)->y;

            MapWindowPoints(NULL, prb->_ci.hwnd, &rbht.pt, 1);

            iBand = prb->_HitTest(&rbht);
            *(DWORD*)wp = rbht.flags;
            lres = (LRESULT)(iBand != -1 ? prb->_rbbList[iBand].wID : -1);
        }
        else
            lres = -1;
        break;

    case DPX_GETOBJECT:
        lres = (LRESULT)GetItemObject(&prb->_ci, RBN_GETOBJECT, &IID_IDropTarget, (LPNMOBJECTNOTIFY)lp);
        break;

    default:
        lres = -1;
        break;
    }

    return lres;
}

// ----------------------------------------------------------------------------
//
// _CanBandMove
//
// returns TRUE if the given band can be moved and FALSE if it cannot
//
// ----------------------------------------------------------------------------
BOOL CReBar::_CanBandMove(PRBB prbb)
{
    // If there is only one visible band it cannot move
    if (_EnumBand(1, RBBS_HIDDEN) > _GetLastBand())
        return FALSE;

    ASSERT(!(prbb->fStyle & RBBS_HIDDEN));
        
    if ((_ci.style & RBS_FIXEDORDER)
      && (prbb == _EnumBand(0, RBBS_HIDDEN)))
        // the first (visible) band in fixed order rebars can't be moved
        return(FALSE);
    
    // fixed size bands can't be moved
    return(!(prbb->fStyle & RBBS_FIXEDSIZE));
}

// ----------------------------------------------------------------------------
//
// _BandCalcMinWidth
//
// calculates minimum width for the given band
//
// ----------------------------------------------------------------------------
void CReBar::_BandCalcMinWidth(PRBB prbb)
{
    BOOL fDrawGripper = _ShouldDrawGripper(prbb);
    BOOL fVertical;
    int  cEdge;
    BOOL fEmpty = (prbb->iImage == -1 && !_ShowText(prbb));

    if (prbb->fStyle & RBBS_HIDDEN) 
    {
        ASSERT(0);
        return;
    }

    // did the user specify the size explicitly?
    if (prbb->fStyle & RBBS_FIXEDHEADERSIZE)
        return;

    prbb->cxMin = prbb->cxMinChild;

    if (_UseChevron(prbb))
        prbb->cxMin += CX_CHEVRON;

    if (!fDrawGripper && fEmpty)
        return;

    fVertical = (_ci.style & CCS_VERT);
    if (_IsVerticalGripper()) 
    {
        
        prbb->cxMin += 4 * g_cyEdge;
        prbb->cxMin += max(_cyImage, _cyFont);
        
    } 
    else 
    {
        cEdge = fVertical ? g_cyEdge : g_cxEdge;

        prbb->cxMin += 2 * cEdge;

        if (fDrawGripper)
        {
            prbb->cxMin += _GetGripperWidth() * (fVertical ? g_cyBorder : g_cxBorder);
            if (fEmpty)
                return;
        }

        prbb->cxMin += 2 * cEdge;

        if (prbb->iImage != -1)
            prbb->cxMin += (fVertical ? _cyImage : _cxImage);

        if (_ShowText(prbb))
        {
            if (fVertical)
                prbb->cxMin += _cyFont;
            else
                prbb->cxMin += prbb->cxText;
            if (prbb->iImage != -1)
                // has both image and text -- add in edge between 'em
                prbb->cxMin += cEdge;
        }
    }
}

BOOL CReBar::_ShouldDrawGripper(PRBB prbb)
{
    if (prbb->fStyle & RBBS_NOGRIPPER)
        return FALSE;

    if ((prbb->fStyle & RBBS_GRIPPERALWAYS) || _CanBandMove(prbb))
        return TRUE;
    
    return FALSE;
        
}

// ----------------------------------------------------------------------------
//
// _BandCalcTextExtent
//
// computes the horizontal extent of the given band's title text in the current
// title font for the rebar
//
// returns TRUE if text extent changed, FALSE otherwise
//
// ----------------------------------------------------------------------------
BOOL CReBar::_BandCalcTextExtent(PRBB prbb, HDC hdcIn)
{
    HDC     hdc = hdcIn;
    HFONT   hFontOld;
    int     cx;

    if (prbb->fStyle & RBBS_HIDDEN)
    {
        ASSERT(0);      // caller should have skipped
        return FALSE;
    }

    if (!_ShowText(prbb))
    {
        cx = 0;
    }
    else
    {
        RECT rc = {0,0,0,0};
        HRESULT hr = E_FAIL;
        if (!hdcIn && !(hdc = GetDC(_ci.hwnd)))
            return FALSE;

        hFontOld = SelectFont(hdc, _hFont);
        if (_hTheme)
            hr = GetThemeTextExtent(_hTheme, hdc, 0, 0, prbb->lpText, -1, DT_CALCRECT, &rc, &rc);

        if (FAILED(hr))
        {
            DrawText(hdc, prbb->lpText, lstrlen(prbb->lpText), &rc, DT_CALCRECT);
        }
        SelectObject(hdc, hFontOld);

        cx = RECTWIDTH(rc);

        if (!hdcIn)
            ReleaseDC(_ci.hwnd, hdc);
    }

    if (prbb->cxText != cx)
    {
        prbb->cxText = cx;
        _BandCalcMinWidth(prbb);

        return TRUE;
    }

    return FALSE;
}

// ----------------------------------------------------------------------------
//
// _BandGetHeight
//
// returns minimum height for the given band
// TODO: make this a field in the band structure instead of always calling this
//
// ----------------------------------------------------------------------------
int CReBar::_BandGetHeight(PRBB prbb)
{
    UINT cy = 0;
    BOOL fVertical = (_ci.style & CCS_VERT);
    UINT cyCheck, cyBorder;

    cyBorder = (fVertical ? g_cxEdge : g_cyEdge) * 2;

    if (prbb->hwndChild)
    {
        cy = prbb->cyChild;
        if (!(prbb->fStyle & RBBS_CHILDEDGE))
            // add edge to top and bottom of child window
            cy -= cyBorder;
    }

    if (_ShowText(prbb) && !fVertical)
    {
        cyCheck = _cyFont;

        if (cyCheck > cy)
            cy = cyCheck;
    }

    if (prbb->iImage != -1)
    {
        cyCheck = (fVertical) ? _cxImage : _cyImage;

        if (cyCheck > cy)
            cy = cyCheck;
    }

    return(cy + cyBorder);
}

// ----------------------------------------------------------------------------
//
// _GetRowCount
//
// returns the number of rows in the rebar's current configuration
//
// ----------------------------------------------------------------------------
UINT CReBar::_GetRowCount()
{
    UINT i;
    UINT cRows = 0;

    for (i = 0; i < _cBands; i++)
    {
        PRBB prbb = _GetBand(i);
        if (!(prbb->fStyle & RBBS_HIDDEN) &&
            _IsBandStartOfRow(prbb))
        {
            cRows++;
        }
    }

    return cRows;
}

// ----------------------------------------------------------------------------
//
// _GetLineHeight
//
// returns the height of the line of bands from iStart to iEnd, inclusively
//
// ----------------------------------------------------------------------------
int CReBar::_GetLineHeight(UINT iStart, UINT iEnd)
{
    int cy = 0;
    PRBB prbb;
    int cyMinChild = 0;
    int iMinExtra = -1;

    if (!(_ci.style & RBS_VARHEIGHT))
    {
        // for fixed height bars, line height is maximum height of ALL bands
        iStart = 0;
        iEnd = _cBands - 1;
    }

    UINT i = iStart;
    for (prbb = _rbbList + i; i <= iEnd; prbb++, i++)
    {
        if (prbb->fStyle & RBBS_HIDDEN)
            continue;
        cy = max(cy, (int)_BandGetHeight(prbb));
        if (prbb->cyMinChild > cyMinChild)
        {
            cyMinChild = prbb->cyMinChild;
        }
    }

    i = iStart;
    for (prbb = _rbbList + i; i <= iEnd; prbb++, i++)
    {
        if (prbb->fStyle & RBBS_HIDDEN)
            continue;

        if ((prbb->fStyle & RBBS_VARIABLEHEIGHT) && prbb->cyIntegral)
        {
            int iExtra = (cy - prbb->cyMinChild) % prbb->cyIntegral;
            if ((iMinExtra == -1) || (iExtra < iMinExtra))
            {
                iMinExtra = iExtra;
            }
        }
    }

    if (iMinExtra != -1)
    {
        cy -= iMinExtra;
    }

    if (cy < cyMinChild)
    {
        cy = cyMinChild; 
    }

    return cy;
}

// _BandRecalcChevron: update & refresh chevron
void CReBar::_BandRecalcChevron(PRBB prbb, BOOL fChevron)
{
    RECT rcChevron;

    if (fChevron)
    {
        rcChevron.right = prbb->x + prbb->cx;
        rcChevron.left = rcChevron.right - CX_CHEVRON;
        rcChevron.top = prbb->y;
        rcChevron.bottom = rcChevron.top + prbb->cy;
    }
    else
        SetRect(&rcChevron, -1, -1, -1, -1);

    if (!EqualRect(&rcChevron, &prbb->rcChevron))
    {
        if (prbb->fChevron)
            _InvalidateRect(&prbb->rcChevron);

        prbb->fChevron = fChevron;
        CopyRect(&prbb->rcChevron, &rcChevron);

        if (prbb->fChevron)
            _InvalidateRect(&prbb->rcChevron);
    }
}

void CReBar::_InvalidateBorders(PRBB prbb)
{
    if (_mBand.cxLeftWidth  || 
        _mBand.cyTopHeight  || 
        _mBand.cxRightWidth || 
        _mBand.cyBottomHeight)
    {
        RECT rcOuter = {prbb->x - _mBand.cxLeftWidth,
                        prbb->y - _mBand.cyTopHeight,
                        prbb->x + prbb->cx + _mBand.cxRightWidth,
                        prbb->y + prbb->cy + _mBand.cyBottomHeight};

        RECT rcInner = {prbb->x + _mBand.cxLeftWidth, 
                        prbb->y + _mBand.cyTopHeight, 
                        prbb->x + prbb->cx - _mBand.cxRightWidth, 
                        prbb->y + prbb->cy - _mBand.cyBottomHeight};

        if (_ci.style & CCS_VERT)
        {
            FlipRect(&rcOuter);
            FlipRect(&rcInner);
        }

        HRGN hrgnOuter = CreateRectRgnIndirect(&rcOuter);
        if (hrgnOuter)
        {
            HRGN hrgnInner = CreateRectRgnIndirect(&rcInner);
            if (hrgnInner)
            {
                CombineRgn(hrgnOuter, hrgnOuter, hrgnInner, RGN_DIFF);
                DeleteObject(hrgnInner);
            }

            InvalidateRgn(_ci.hwnd, hrgnOuter, FALSE);

            DeleteObject(hrgnOuter);
        }
    }
}

// ----------------------------------------------------------------------------
//
// _ResizeChildren
//
// resizes children to fit properly in their respective bands' bounding rects
//
// ----------------------------------------------------------------------------
void CReBar::_ResizeChildren()
{
    int     cx, cy, x, y, cxHeading;
    HDWP    hdwp;
    BOOL    fVertical = (_ci.style & CCS_VERT);
    PRBB prbb, prbbEnd;

    if (!_cBands || !_fRedraw)
        return;

    hdwp = BeginDeferWindowPos(_cBands);

    prbb = _GetBand(0);
    prbbEnd = _GetLastBand();

    for ( ; prbb <= prbbEnd ; prbb++)
    {
        NMREBARCHILDSIZE nm;
        BOOL fChevron = FALSE;

        if (prbb->fStyle & RBBS_HIDDEN)
            continue;
        
        if (!prbb->hwndChild)
            continue;

        cxHeading = _GetHeaderWidth(prbb);
        x = prbb->x + cxHeading;

        cx = prbb->cx - cxHeading;

        // if we're not giving child ideal size, make space for chevron button
        if ((cx < prbb->cxIdeal) && _UseChevron(prbb))
        {
            fChevron = TRUE;
            cx -= CX_CHEVRON;
        }

        if (!(prbb->fStyle & RBBS_FIXEDSIZE)) 
        {
            if (fVertical) 
            {
                PRBB prbbNext = _GetNextVisible(prbb);
                if (prbbNext && !_IsBandStartOfRow(prbbNext))
                    cx -= g_cyEdge * 2;
            }
            else 
                cx -= CX_OFFSET;
        }

        if (cx < 0)
            cx = 0;
        y = prbb->y;
        cy = prbb->cy;
        if (prbb->cyChild && (prbb->cyChild < cy))
        {
            if (!(prbb->fStyle & RBBS_TOPALIGN))
            {
                y += (cy - prbb->cyChild) / 2;
            }
            cy = prbb->cyChild;
        }

        nm.rcChild.left = x;
        nm.rcChild.top = y;
        nm.rcChild.right = x + cx;
        nm.rcChild.bottom = y + cy;
        nm.rcBand.left = prbb->x + _GetHeaderWidth(prbb);
        nm.rcBand.right = prbb->x + prbb->cx;
        nm.rcBand.top = prbb->y;
        nm.rcBand.bottom = prbb->y + prbb->cy;

        nm.uBand = _BandToIndex(prbb);
        nm.wID = prbb->wID;
        if (fVertical)
        {
            FlipRect(&nm.rcChild);
            FlipRect(&nm.rcBand);
        }
        
        CCSendNotify(&_ci, RBN_CHILDSIZE, &nm.hdr);

        if (!_IsValidBand(prbb))
        {
            // somebody responded to notify by nuking bands; bail
            break;
        }

        _BandRecalcChevron(prbb, fChevron);
        _InvalidateBorders(prbb);

        DeferWindowPos(hdwp, prbb->hwndChild, NULL, nm.rcChild.left, nm.rcChild.top, 
                       RECTWIDTH(nm.rcChild), RECTHEIGHT(nm.rcChild), SWP_NOZORDER);
    }

    EndDeferWindowPos(hdwp);

    //
    //  The SQL 7.0 Enterprise Manager Data Transformation Services MMC Snap-In
    //  (and the Visual Basic Coolbar Sample App, too) has problems.
    //  It hosts a rebar but doesn't set the WS_CLIPCHILDREN flag,
    //  so when it erases its background, it wipes out the rebar.  So don't
    //  call UpdateWindow() here, or we will paint *first*, then SQL will
    //  erase us by mistake.  We have to leave our paint pending, so that
    //  when SQL erases us by mistake, we will eventually get a WM_PAINT
    //  message afterwards.
    //
#if 0
    UpdateWindow(_ci.hwnd);
#endif
}

// ----------------------------------------------------------------------------
//
// _MoveBand
//
// moves the band from one position to another in the rebar's band array,
// updating the rebar's iCapture field as needed
//
// returns TRUE or FALSE if something moved
// ----------------------------------------------------------------------------
BOOL CReBar::_MoveBand(UINT iFrom, UINT iTo)
{
    RBB rbbMove;
    int iShift;
    BOOL fCaptureChanged = (_uCapture == -1);

    if (iFrom != iTo)
    {
        rbbMove = *_GetBand(iFrom);
        if (_uCapture == iFrom)
        {
            _uCapture = iTo;
            fCaptureChanged = TRUE;
        }

        iShift = (iFrom > iTo) ? -1 : 1;

        while (iFrom != iTo)
        {
            if (!fCaptureChanged && (_uCapture == (iFrom + iShift)))
            {
                _uCapture = iFrom;
                fCaptureChanged = TRUE;
            }

            *_GetBand(iFrom) = *_GetBand(iFrom + iShift);
            iFrom += iShift;
        }
        *_GetBand(iTo) = rbbMove;
        return TRUE;
    }
    return(FALSE);
}

// ----------------------------------------------------------------------------
//
// _Recalc
//
// recomputes bounding rects for all bands in given rebar
//
// ----------------------------------------------------------------------------
int CReBar::_Recalc(LPRECT prc, BOOL fForce /* = FALSE */)
{
    PRBB    prbb = _GetBand(0);
    PRBB    prbbWalk;
    UINT    cHidden;    // # of hidden guys we've seen in current row
    int     cxRow;
    int     cxMin;
    UINT    i;
    UINT    j;
    UINT    k;
    UINT    iFixed = 0xFFFF;
    int     cy;
    int     y;
    int     x;
    int     cxBar;
    RECT    rc;
    HWND    hwndSize;
    BOOL    fNewLine = FALSE;
    BOOL    fChanged;
    BOOL    fVertical = (_ci.style & CCS_VERT);
    BOOL    fBandBorders;
    int     iBarWidth;

    if (!_cBands)
        return(0);

    if ((_ci.style & CCS_NORESIZE) || (_ci.style & CCS_NOPARENTALIGN))
    {
        // size based on rebar window itself
        hwndSize = _ci.hwnd;
    }
    else if (!(hwndSize = _ci.hwndParent))
    {
        // size based on parent window -- if no parent window, bail now
        return(0);
    }

    if (!_fRecalc && !fForce)
    {
        // defer this recalc
        _fRecalcPending = TRUE;
        return 0;
    }
    else
    {
        _fRecalcPending = FALSE;
    }

    if (prc)
    {
        rc = *prc;
    }
    else
    {
        GetClientRect(hwndSize, &rc);
    }

    iBarWidth = (fVertical ? (rc.bottom - rc.top) : (rc.right - rc.left));
    // this can happen because we adjust the client rect, but wedon't change 
    // the getminmaxinfo.
    if (iBarWidth <= 0)
        iBarWidth = 1;

    cxBar = iBarWidth;    

    fBandBorders = _UseBandBorders();

    for (i = 0; i < _cBands; i++)
    {
        _rbbList[i].cx = _rbbList[i].cxRequest;
    }

    y = 0;
    i = 0;
    // Main Loop -- loop until all bands are calculated
    while (i < _cBands)
    {
        TraceMsg(TF_REBAR, "_Recalc: outer loop i=%d", i);
        
        if (fBandBorders && (y > 0))
            y += g_cyEdge;

        y += _mBand.cyTopHeight;

ReLoop:
        cxRow = 0;
        cxMin = _mBand.cxLeftWidth + _mBand.cxRightWidth;

        x = _mBand.cxLeftWidth;
        cHidden = 0;

        // Row Loop -- loop until hard line break is found or soft line break
        // is necessary
        for (j = i, prbbWalk = prbb; j < _cBands; j++, prbbWalk++)
        {
            TraceMsg(TF_REBAR, "_Recalc: inner loop j=%d", j);
            
            if (prbbWalk->fStyle & RBBS_HIDDEN)
            {
                ++cHidden;
                continue;
            }

            if (j > i + cHidden)
            {
                // not the first band in the row -- check for break style
                if ((prbbWalk->fStyle & RBBS_BREAK) && !(prbbWalk->fStyle & RBBS_FIXEDSIZE))
                    break;

                if (fBandBorders)
                    // add in space for vertical etch on palettized display
                    cxMin += g_cxEdge;
            }

            if (prbbWalk->fStyle & RBBS_FIXEDSIZE)
            {
                // remember location of branding brick
                iFixed = j;
             
                // if this is the first band, the next band cannot have a forced break.
                if (i + cHidden == j) 
                {
                    // if the first index in the row (i) plus the number of hidden items (cHidden) leaves us at this band,
                    // then it's the first visible in this row.
                    PRBB prbbNextVis = _GetNextVisible(prbbWalk);
                    if (prbbNextVis && (prbbNextVis->fStyle & RBBS_BREAK))
                    {
                        // can't do this unilaterally because on startup
                        // some folks (net meeting) initialize it in reverse order
                        // and we whack off this break bit incorrectly
                        if (_fRedraw && IsWindowVisible(_ci.hwnd))
                            prbbNextVis->fStyle &= ~RBBS_BREAK;
                    }
                }
                
                prbbWalk->cx = prbbWalk->cxMin;
            }

            if (prbbWalk->cx < prbbWalk->cxMin)
                prbbWalk->cx = prbbWalk->cxMin;

            cxMin += prbbWalk->cxMin; // update running total of min widths

            // read the assert comment below
            if (j > i + cHidden)
            {
                // not the first band in row -- check for need to autobreak
                if ((cxMin > cxBar) && (_OkayToChangeBreak(prbbWalk, RBAB_AUTOSIZE)))
                    // autobreak here
                    break;


                if (fBandBorders)
                {
                    // add in space for vertical etch on palettized display
                    cxRow += g_cxEdge;
                }
            }

            cxRow += prbbWalk->cx; // update running total of current widths
            cxRow += _mBand.cxLeftWidth + _mBand.cxRightWidth;
        }

        if (!i)
        {
            // first row -- handle proper placement of branding band
            if (iFixed == 0xFFFF)
            {
                // branding band not yet found; look in the remaining bands
                k = j;
                for ( ; j < _cBands; j++)
                {
                    if (_GetBand(j)->fStyle & RBBS_HIDDEN)
                        continue;

                    if (_GetBand(j)->fStyle & RBBS_FIXEDSIZE)
                    {
                        // branding band found; move to 1st row and recompute
                        ASSERT(j != k);                        
                        _MoveBand(j, k);
                        goto ReLoop;
                    }
                }
                // no branding band found -- reset j and continue on
                j = k;
            }
            else
            {
                // we have a branding band; move it to
                // the rightmost position in the row
                _MoveBand(iFixed, j - 1);
            }

            TraceMsg(TF_REBAR, "_Recalc: after brand i=%d", i);            
        }

        // variant:
        // now the current row of bands is from i to j - 1
        // n.b. i (and some following bands) might be hidden

        // assert that j != i because then the above variant won't be true
        ASSERT(j != i);

        if (cxRow > cxBar)
        {
            // bands are too long -- shrink bands from right to left
            for (k = i; k < j; k++)
            {
                prbbWalk--;
                if (prbbWalk->fStyle & RBBS_HIDDEN)
                    continue;

                if (prbbWalk->cx > prbbWalk->cxMin)
                {
                    cxRow -= prbbWalk->cx - prbbWalk->cxMin;
                    prbbWalk->cx = prbbWalk->cxMin;
                    if (cxRow <= cxBar)
                    {
                        prbbWalk->cx += cxBar - cxRow;
                        break;
                    }
                }
            }
            TraceMsg(TF_REBAR, "_Recalc: after shrink i=%d", i);            
        }
        else if (cxRow < cxBar)
        {
            // bands are too short -- grow rightmost non-minimized band
            for (k = j - 1; k >= i; k--)
            {
                ASSERT(k != (UINT)-1);  // catch infinite loop
                prbbWalk--;
                if ((k == i) || 
                    (!(prbbWalk->fStyle & (RBBS_HIDDEN | RBBS_FIXEDSIZE)) &&
                     (prbbWalk->cx > prbb->cxMin)))
                {
                    // the k == i check  means we've made it to the first
                    // band on this row and so he has to get the cx change
                    if (prbbWalk->fStyle & RBBS_HIDDEN) 
                    {
                        ASSERT(k == i);
                        prbbWalk = _GetNextVisible(prbbWalk);
                        if (!prbbWalk)
                            break;
                    }
                    prbbWalk->cx += cxBar - cxRow;
                    break;
                }
            }
            TraceMsg(TF_REBAR, "_Recalc: after grow i=%d", i);            
        }

        // items from index i to index j-1 (inclusive) WILL fit on one line
        cy = _GetLineHeight(i, j - 1);

        fChanged = FALSE; // set if any bands on current row changed position

        for ( ; i < j; i++, prbb++)
        {
            if (prbb->fStyle & RBBS_HIDDEN)
                continue;

            // go through row of bands, updating positions and heights,
            // invalidating as needed
            if ((prbb->y != y) || (prbb->x != x) || (prbb->cy != cy))
            {
                TraceMsg(TF_REBAR, "_Recalc: invalidate i=%d", _BandToIndex(prbb));
                fChanged = TRUE;
                rc.left = min(prbb->x, x);
                rc.top = min(prbb->y, y);
                rc.right = cxBar;
                rc.bottom = max(prbb->y + prbb->cy, y + cy);
                if (fBandBorders)
                {
                    // acount for etch line that will need to move
                    rc.left -= g_cxEdge;
                    rc.bottom += g_cyEdge/2;
                }
                else
                {
                    rc.left -= _mBand.cxLeftWidth;
                    rc.right += _mBand.cxRightWidth;
                    rc.top -= _mBand.cyTopHeight;
                    rc.bottom += _mBand.cyBottomHeight;
                }

                if (!prc)
                {
                    _InvalidateRect(&rc);
                }
            }

            prbb->x = x;
            prbb->y = y;
            prbb->cy = cy;

            x += _BandWidth(prbb);
        }

        // i and prbb now refer to the first band in the next row of bands
        y += cy + _mBand.cyBottomHeight;
    }

    _cy = y;

    return(y);
}

// ----------------------------------------------------------------------------
//
// _ResizeNow
//
// recomputes bounding rects for all bands and then resizes rebar and children
// based on these rects
//
// ----------------------------------------------------------------------------
void CReBar::_ResizeNow()
{
    RECT rc;
    BOOL bMirroredWnd=(_ci.dwExStyle&RTL_MIRRORED_WINDOW);

    if (!_ci.hwndParent)
        return;

    GetWindowRect(_ci.hwnd, &rc);

    //
    // If this is a mirrored window, we don't won't to refect the
    // coordinates since they are coming from the screen coord
    // which they are not mirrored. [samera]
    //
    if (bMirroredWnd)
        MapRectInRTLMirroredWindow(&rc, _ci.hwndParent);
    else 
        MapWindowPoints(HWND_DESKTOP, _ci.hwndParent, (LPPOINT)&rc, 2);

    _ResizeChildren();

    NewSize(_ci.hwnd, _cy, _ci.style, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc));

    if (_fResizeNotify) 
        CCSendNotify(&_ci, RBN_HEIGHTCHANGE, NULL);
    _fResizeNotify = FALSE;
    _fResizePending = FALSE;
}

void CReBar::_Resize(BOOL fForceHeightChange)
{
    int cy;

StartOver:
    // lots of the code relies on having cy calculated synchronously with _Resize,
    // but we're going to delay the actual changing of the window
    cy = _cy;

    _Recalc(NULL);    

    if (_fResizing)
    {
        _fResizeRecursed = TRUE;
        return;
    }
    _fResizing = TRUE;
    
    // true overrides always
    if (fForceHeightChange || (cy != _cy))
        _fResizeNotify = TRUE;

    if (_fRedraw) 
    {
        _ResizeNow();
    } 
    else 
    {
        _fResizePending = TRUE;
    }
        
    _fResizing = FALSE;
    
    // we do this to avoid infinite loop...  _Resize can cause NewSize which causes 
    // a notify in which the parent sizes us, which causes us to loop.
    // if the parent does any message pumping during the NewSize, we're in a loop 
    if (_fResizeRecursed) 
    {
        _fResizeRecursed = FALSE;
        fForceHeightChange = FALSE;
        goto StartOver;
    }     
}

void CReBar::_SetRecalc(BOOL fRecalc)
{
    _fRecalc = fRecalc;
    if (fRecalc) {
        if (_fRecalcPending)
            _Recalc(NULL);
    }
}

BOOL CReBar::_SetRedraw(BOOL fRedraw)
{
    BOOL fOld = _fRedraw;
    _fRedraw = fRedraw;
    if (fRedraw)
    {
        // save off _fRefreshPending since this can
        // get changed by call to _ResizeNow
        BOOL fRefreshPending = _fRefreshPending;

        if (_fResizePending)
            _ResizeNow();

        if (fRefreshPending)
            _InvalidateRect(NULL);
    }
    
    return fOld;
}

BOOL CReBar::_AfterSetFont()
{
    BOOL fChange = FALSE;
    UINT        i;
    HFONT hOldFont;
    
    HDC hdc = GetDC(_ci.hwnd);
    if (!hdc)
        return FALSE;

    hOldFont = SelectFont(hdc, _hFont);

    TEXTMETRIC tm;
    if (_hTheme)
    {
        GetThemeTextMetrics(_hTheme, hdc, 0, 0, &tm);
    }
    else
    {
        GetTextMetrics(hdc, &tm);
    }

    if (_cyFont != tm.tmHeight)
    {
        _cyFont = tm.tmHeight;
        fChange = TRUE;
    }

    // adjust bands
    for (i = 0; i < _cBands; i++)
    {
        if (_GetBand(i)->fStyle & RBBS_HIDDEN)
            continue;

        fChange |= _BandCalcTextExtent(_GetBand(i), hdc);
    }

    SelectObject(hdc, hOldFont);
    ReleaseDC(_ci.hwnd, hdc);

    if (fChange)
    {
        _Resize(FALSE);
        // invalidate, o.w. title doesn't redraw 1st time after font growth
        _InvalidateRect(NULL);
    }

    return TRUE;
}

BOOL CReBar::_OnSetFont(HFONT hFont)
{
    if (_fFontCreated) {
        DeleteObject(_hFont);
    }
    
    _hFont = hFont;
    _fFontCreated = FALSE;
    if (!_hFont)
        _SetFont(0);
    else 
        return _AfterSetFont();
    
    return TRUE;
}

// ----------------------------------------------------------------------------
//
// _SetFont
//
// sets the rebar band title font to the current system-wide caption font
//
// ----------------------------------------------------------------------------
BOOL CReBar::_SetFont(WPARAM wParam)
{
    NONCLIENTMETRICS ncm;
    HFONT hOldFont;

    if ((wParam != 0) && (wParam != SPI_SETNONCLIENTMETRICS))
        return(FALSE);

    ncm.cbSize = sizeof(NONCLIENTMETRICS);
    if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0))
        return(FALSE);

    hOldFont = _hFont;

    ncm.lfCaptionFont.lfWeight = FW_NORMAL;
    if (!(_hFont = CreateFontIndirect(&ncm.lfCaptionFont)))
    {
        _hFont = hOldFont;
        return(FALSE);
    }

    _fFontCreated = TRUE;
    if (hOldFont)
        DeleteObject(hOldFont);
    
    return _AfterSetFont();
}

// ----------------------------------------------------------------------------
//
//  Draws a horizontal or vertical dotted line from the given (x,y) location
//  for the given length (c). (From TReeView's TV_DrawDottedLine)
//
// ----------------------------------------------------------------------------

void CReBar::_VertMungeGripperRect(LPRECT lprc)
{
    if (_IsVerticalGripper()) {
        OffsetRect(lprc, -lprc->left + lprc->top, -lprc->top + lprc->left);
        lprc->bottom -= g_cyEdge;
    } else {
        FlipRect(lprc);
    }
}

void CReBar::_DrawChevron(PRBB prbb, HDC hdc)
{
    RECT rc;
    DWORD dwFlags = prbb->wChevState | DCHF_HORIZONTAL | DCHF_TRANSPARENT;

    CopyRect(&rc, &prbb->rcChevron);

    int iPart;

    if (_IsVertical())
    {
        FlipRect(&rc);
        iPart = RP_CHEVRONVERT;
    }
    else
    {
        dwFlags |= DCHF_TOPALIGN;
        iPart = RP_CHEVRON;
    }

    DrawChevron(_hTheme, iPart, hdc, &rc, dwFlags);
}

void CReBar::_UpdateChevronState(PRBB prbb, WORD wControlState)
{
    if (prbb)
    {
        // if no change in state, bail
        if (!(wControlState ^ prbb->wChevState))
            return;

        prbb->wChevState = wControlState;

        // if active (pushed or hottracked)
        if (!(wControlState & DCHF_INACTIVE)) {
            // then we're now the hot band
            _prbbHot = prbb;
        }
        // else if we were the hot band then clear
        else if (prbb == _prbbHot) {
            _prbbHot = NULL;
        }

        // clear background & repaint
        _InvalidateRect(&prbb->rcChevron);
        UpdateWindow(_ci.hwnd);
    }
}

// ----------------------------------------------------------------------------
//
// _DrawBand
//
// draws the title icon and title text of the given band into the given DC;
// also the band's chevron
//
// ----------------------------------------------------------------------------
void CReBar::_DrawBand(PRBB prbb, HDC hdc)
{
    COLORREF            clrBackSave, clrForeSave;
    int                 iModeSave;
    BOOL                fVertical = _IsVertical();
    BOOL                fDrawHorizontal = (!fVertical || _IsVerticalGripper());
    NMCUSTOMDRAW        nmcd;
    LRESULT             dwRet;

    if (prbb->fStyle & RBBS_HIDDEN) 
    {
        ASSERT(0);
        return;
    }

    clrForeSave = SetTextColor(hdc, _BandGetTextColor(prbb));
    clrBackSave = SetBkColor(hdc, _BandGetBkColor(prbb));
    if (prbb->hbmBack || _hTheme)
        iModeSave = SetBkMode(hdc, TRANSPARENT);

    nmcd.hdc = hdc;
    nmcd.dwItemSpec = prbb->wID;
    nmcd.uItemState = 0;
    nmcd.lItemlParam = prbb->lParam;
    nmcd.rc.top = prbb->y;
    nmcd.rc.left = prbb->x;
    nmcd.rc.bottom = nmcd.rc.top + prbb->cy;
    nmcd.rc.right = nmcd.rc.left + _GetHeaderWidth(prbb);
    if (_ci.style & CCS_VERT)
    {
        FlipRect(&nmcd.rc);
    }

    RECT rcTemp = {0, 0, 0, 0};
    HRGN hrgnOld = CreateRectRgnIndirect(&rcTemp);
    if (GetClipRgn(hdc, hrgnOld) == 0)
    {
        DeleteObject(hrgnOld);
        hrgnOld = NULL;
    }
    if (_ci.style & CCS_VERT)
    {
        IntersectClipRect(hdc, prbb->y, prbb->x, prbb->y + prbb->cy, prbb->x + prbb->cx);
    }
    else
    {
        IntersectClipRect(hdc, prbb->x, prbb->y, prbb->x + prbb->cx, prbb->y + prbb->cy);
    }
    
    if (_hTheme)
    {
        RECT rcBand = {prbb->x - _mBand.cxLeftWidth, 
                       prbb->y - _mBand.cyTopHeight, 
                       prbb->x + prbb->cx + _mBand.cxRightWidth, 
                       prbb->y + prbb->cy + _mBand.cyBottomHeight};

        if (_ci.style & CCS_VERT)
        {
            FlipRect(&rcBand);
        }

        DrawThemeBackground(_hTheme, hdc, RP_BAND, 0, &rcBand, 0);
    }

    dwRet = CICustomDrawNotify(&_ci, CDDS_ITEMPREPAINT, &nmcd);

    if (!(dwRet & CDRF_SKIPDEFAULT))
    {
        int cy = prbb->cy;
        int yCenter = prbb->y + (cy / 2);
        
        if (_IsVerticalGripper()) 
        {
            cy = _GetHeaderWidth(prbb);
            yCenter = prbb->x + (cy / 2);
        } 

        int xStart = prbb->x;

        if (_ShouldDrawGripper(prbb))
        {
            RECT rc;
            if (_hTheme)
            {
                int cxGripper = _GetGripperWidth();
                int iPart = RP_GRIPPER;
                SetRect(&rc, xStart, prbb->y, xStart + cxGripper, prbb->y + cy);
                if (fVertical)
                {
                    iPart = RP_GRIPPERVERT;
                    _VertMungeGripperRect(&rc);
                }

                DrawThemeBackground(_hTheme, hdc, iPart, 0, &rc, 0);
                xStart += cxGripper;
            }
            else
            {
                int  c;
                int dy;

                c = 3 * g_cyBorder;
                xStart += 2 * g_cxBorder;
                dy = g_cxEdge;

                SetRect(&rc, xStart, prbb->y + dy, xStart + c, prbb->y + cy - dy);

                if (fVertical)
                {
                    _VertMungeGripperRect(&rc);
                    if (_IsVerticalGripper())
                        xStart = rc.left;
                }

                CCDrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_RECT | BF_MIDDLE, &(_clrsc));

                xStart += c;
            }
        }

        xStart += 2 * (fVertical ? g_cyEdge : g_cxEdge);


        if (prbb->iImage != -1)
        { 
            int yStart;
            IMAGELISTDRAWPARAMS imldp = {0};

            yStart = yCenter - ((!fDrawHorizontal ? _cxImage : _cyImage) / 2);
            imldp.cbSize = sizeof(imldp);
            imldp.himl   = _himl;
            imldp.i      = prbb->iImage;
            imldp.hdcDst = hdc;
            imldp.x      = (!fDrawHorizontal ? yStart : xStart);
            imldp.y      = (!fDrawHorizontal ? xStart : yStart);
            imldp.rgbBk  = CLR_DEFAULT;
            imldp.rgbFg  = CLR_DEFAULT;
            imldp.fStyle = ILD_TRANSPARENT;
            imldp.fState = 0;

            ImageList_DrawIndirect(&imldp);
            xStart +=  (fDrawHorizontal ? (_cxImage + g_cxEdge) : (_cyImage + g_cyEdge));
        }

        if (_ShowText(prbb))
        {
            UINT uFormat=0;
            RECT rcText;
            HRESULT hr = E_FAIL;
            
            rcText.left = fDrawHorizontal ? xStart : yCenter - (prbb->cxText / 2);
            rcText.top = fDrawHorizontal ? yCenter - (_cyFont / 2) : xStart;
            if (fDrawHorizontal)
                rcText.top -= 1;    // fudge
            rcText.right = rcText.left + prbb->cxText;
            rcText.bottom = rcText.top + _cyFont;

            // for clients >= v5, we draw text with prefix processing (& underlines next char)
            if (CCGetUIState(&(_ci)) & UISF_HIDEACCEL)
               uFormat= DT_HIDEPREFIX;

            HFONT hFontSave = SelectFont(hdc, _hFont);
            if (_hTheme)
                hr = DrawThemeText(_hTheme, hdc, 0, 0, prbb->lpText, lstrlen(prbb->lpText), uFormat, 0, &rcText);

            if (FAILED(hr))
            {
                DrawText(hdc, prbb->lpText, lstrlen(prbb->lpText), &rcText, uFormat);
            }

            SelectObject(hdc, hFontSave);
        }

        // maybe draw chevron
        if (_UseChevron(prbb) && prbb->fChevron)
            _DrawChevron(prbb, hdc);
    }

    if (dwRet & CDRF_NOTIFYPOSTPAINT)
        CICustomDrawNotify(&_ci, CDDS_ITEMPOSTPAINT, &nmcd);

    if (prbb->hbmBack || _hTheme)
        SetBkMode(hdc, iModeSave);
    SetTextColor(hdc, clrForeSave);
    SetBkColor(hdc, clrBackSave);

    SelectClipRgn(hdc, hrgnOld);
    if (hrgnOld)
    {
        DeleteObject(hrgnOld);
    }
}

// ----------------------------------------------------------------------------
//
// _OnPaint
//
// processes WM_PAINT message
//
// ----------------------------------------------------------------------------
void CReBar::_OnPaint(HDC hdcIn)
{
    HDC         hdc = hdcIn;
    PAINTSTRUCT ps;
    UINT        i;
    NMCUSTOMDRAW    nmcd;

    if (!hdcIn)
    {
        hdc = BeginPaint(_ci.hwnd, &ps);
    }

    nmcd.hdc = hdc;
    nmcd.uItemState = 0;
    nmcd.lItemlParam = 0;
    nmcd.rc = ps.rcPaint;
    _ci.dwCustom = CICustomDrawNotify(&_ci, CDDS_PREPAINT, &nmcd);

    if (!(_ci.dwCustom & CDRF_SKIPDEFAULT))
    {
        for (i = 0; i < _cBands; i++) {
            if (_GetBand(i)->fStyle & RBBS_HIDDEN)
                continue;

            _DrawBand(_GetBand(i), hdc);
        }
    }

    if (_ci.dwCustom & CDRF_NOTIFYPOSTPAINT)
        CICustomDrawNotify(&_ci, CDDS_POSTPAINT, &nmcd);

    if (!hdcIn)
        EndPaint(_ci.hwnd, &ps);
}

// ----------------------------------------------------------------------------
//
// _BandTileBlt
//
// Fills the given rectangle with the rebar's background bitmap, tiling if
// necessary
//
// ----------------------------------------------------------------------------
void CReBar::_BandTileBlt(PRBB prbb, int x, int y, int cx, int cy, HDC hdcDst, HDC hdcSrc)
{
    int  xOff = 0;
    int  yOff = 0;
    BOOL fxTile, fyTile;
    int cxPart, cyPart;
    int iPixelOffset = 0;

    if (!(prbb->fStyle & RBBS_FIXEDBMP))
    {
        if (_ci.style & CCS_VERT)
        {
            xOff = -prbb->y;
            yOff = -prbb->x;
        }
        else
        {
            xOff = -prbb->x;
            yOff = -prbb->y;
        }
    }

    xOff += x;
    if (xOff >= prbb->cxBmp)
        xOff %= prbb->cxBmp;

    yOff += y;
    if (yOff >= prbb->cyBmp)
        yOff %= prbb->cyBmp;

ReCheck:
    fxTile = ((xOff + cx) > prbb->cxBmp);
    fyTile = ((yOff + cy) > prbb->cyBmp);

    if (!fxTile && !fyTile)
    {
        // no tiling needed -- blt and leave
        BitBlt(hdcDst, x , y, cx, cy, hdcSrc, xOff + iPixelOffset, yOff, SRCCOPY);
        return;
    }

    if (!fxTile)
    {
        // vertically tile
        cyPart = prbb->cyBmp - yOff;
        BitBlt(hdcDst, x, y, cx, cyPart, hdcSrc, xOff + iPixelOffset, yOff, SRCCOPY);
        y += cyPart;
        cy -= cyPart;
        yOff = 0;
        goto ReCheck;
    }

    if (!fyTile)
    {
        // horizontally tile
        cxPart = prbb->cxBmp - xOff;
        BitBlt(hdcDst, x, y, cxPart, cy, hdcSrc, xOff + iPixelOffset, yOff, SRCCOPY);
        x += cxPart;
        cx -= cxPart;
        xOff = 0;
        goto ReCheck;
    }

    // tile both ways
    cyPart = prbb->cyBmp - yOff;
    _BandTileBlt(prbb, x, y, cx, cyPart, hdcDst, hdcSrc);
    y += cyPart;
    cy -= cyPart;
    yOff = 0;
    goto ReCheck;
}

// this is using virtual coordinate space (internal always horizontal)
int CReBar::_InternalHitTest(LPRBHITTESTINFO prbht, int x, int y)
{
    BOOL fVert = (_ci.style & CCS_VERT);
    UINT i;
    PRBB prbb = _GetBand(0);
    int  cx;
    RBHITTESTINFO rbht;
    
    if (!prbht)
        prbht = &rbht;

    for (i = 0; i < _cBands; i++, prbb++)
    {
        if (prbb->fStyle & RBBS_HIDDEN)
            continue;

        if (x >= prbb->x - _mBand.cxLeftWidth && 
            y >= prbb->y - _mBand.cyTopHeight &&
            x <= prbb->x + prbb->cx + _mBand.cxRightWidth && 
            y <= prbb->y + prbb->cy + _mBand.cyTopHeight)
        {
            cx = _GetHeaderWidth(prbb);
            if (x <= prbb->x + cx + _mBand.cxRightWidth)
            {
                prbht->flags = RBHT_CAPTION;
                
                if (_IsVerticalGripper()) 
                {
                    if (y - prbb->y < _GetGripperWidth())
                        prbht->flags = RBHT_GRABBER;
                } 
                else 
                {
                    cx = _GetGripperWidth() * (fVert ? g_cyBorder : g_cxBorder);
                    if (_ShouldDrawGripper(_GetBand(i)) &&
                        (x <= prbb->x + cx + _mBand.cxRightWidth))
                    {
                        prbht->flags = RBHT_GRABBER;
                    }
                }
            }
            else
            {
                POINT pt;

                pt.x = x;
                pt.y = y;

                if (_UseChevron(prbb) && 
                    prbb->fChevron && 
                    PtInRect(&prbb->rcChevron, pt))
                {
                    prbht->flags = RBHT_CHEVRON;
                }
                else
                {
                    prbht->flags = RBHT_CLIENT;
                }
            }

            prbht->iBand = i;
            return i;
        }
    }

    prbht->flags = RBHT_NOWHERE;
    prbht->iBand = -1;
    return -1;
}

// ----------------------------------------------------------------------------
//
// _HitTest
//
// returns the index to the band that the given point lies in, or -1 if outside
// of all bands.  Also, sets flags to indicate which part of the band the
// point lies in.
//
// ----------------------------------------------------------------------------
int CReBar::_HitTest(LPRBHITTESTINFO prbht)
{
    BOOL fVert = (_ci.style & CCS_VERT);
    POINT pt;

    if (fVert)
    {
        pt.x = prbht->pt.y;
        pt.y = prbht->pt.x;
    }
    else
        pt = prbht->pt;
    
    return _InternalHitTest(prbht, pt.x, pt.y);
}


// ----------------------------------------------------------------------------
//
// _EraseBkgnd
//
// processes WM_ERASEBKGND message by drawing band borders, if necessary, and
// filling in the rebar bands with their background color
//
// ----------------------------------------------------------------------------
BOOL CReBar::_EraseBkgnd(HDC hdc, int iBand)
{
    BOOL fVertical = (_ci.style & CCS_VERT);
    NMCUSTOMDRAW    nmcd;
    LRESULT         dwItemRet;
    BOOL            fBandBorders = _UseBandBorders();
    RECT            rcClient;
    HDC             hdcMem = NULL;
    UINT            i;
    PRBB            prbb = _GetBand(0);

    nmcd.hdc = hdc;
    nmcd.uItemState = 0;
    nmcd.lItemlParam = 0;
    _ci.dwCustom = CICustomDrawNotify(&_ci, CDDS_PREERASE, &nmcd);

    if (!(_ci.dwCustom & CDRF_SKIPDEFAULT))
    {
        COLORREF clrBk;

        GetClientRect(_ci.hwnd, &rcClient);

        if (_hTheme)
        {
            RECT rcClip;
            if (GetClipBox(hdc, &rcClip) == NULLREGION)
                rcClip = rcClient;

            if (CCShouldAskForBits(&_ci, _hTheme, 0, 0))
                CCForwardPrint(&_ci, hdc);

            DrawThemeBackground(_hTheme, hdc, 0, 0, &rcClient, &rcClip);
        }
        else
        {
            clrBk = _GetBkColor();
            if (clrBk != CLR_NONE) 
            {
                FillRectClr(hdc, &rcClient, clrBk);
            }
        }

        for (i = 0; i < _cBands; i++, prbb++)
        {
            if (prbb->fStyle & RBBS_HIDDEN)
                continue;

            if (fVertical)
                SetRect(&nmcd.rc, prbb->y, prbb->x, prbb->y + prbb->cy, prbb->x + prbb->cx);
            else
                SetRect(&nmcd.rc, prbb->x, prbb->y, prbb->x + prbb->cx, prbb->y + prbb->cy);

            if (fBandBorders)
            {
                if (prbb->x != _mBand.cxLeftWidth)
                {
                    // draw etch between bands on same row
                    if (fVertical)
                    {
                        nmcd.rc.right += g_cxEdge / 2;
                        nmcd.rc.top -= g_cyEdge;
                        CCThemeDrawEdge(_hTheme, hdc, &nmcd.rc, RP_BAND, 0, EDGE_ETCHED, BF_TOP, &(_clrsc));
                        nmcd.rc.right -= g_cxEdge / 2;
                        nmcd.rc.top += g_cyEdge;
                    }
                    else
                    {
                        nmcd.rc.bottom += g_cyEdge / 2;
                        nmcd.rc.left -= g_cxEdge;
                        CCThemeDrawEdge(_hTheme, hdc, &nmcd.rc, RP_BAND, 0, EDGE_ETCHED, BF_LEFT, &(_clrsc));
                        nmcd.rc.bottom -= g_cyEdge / 2;
                        nmcd.rc.left += g_cxEdge;
                    }
                }
                else
                {
                    // draw etch between rows
                    if (fVertical)
                    {
                        rcClient.right = prbb->y + prbb->cy + g_cxEdge;
                        CCThemeDrawEdge(_hTheme, hdc, &rcClient, RP_BAND, 0, EDGE_ETCHED, BF_RIGHT, &(_clrsc));
                    }
                    else
                    {
                        rcClient.bottom = prbb->y + prbb->cy + g_cyEdge;
                        CCThemeDrawEdge(_hTheme, hdc, &rcClient, RP_BAND, 0, EDGE_ETCHED, BF_BOTTOM, &(_clrsc));
                    }
                }
            }

            nmcd.dwItemSpec = prbb->wID;
            nmcd.uItemState = 0;
            dwItemRet = CICustomDrawNotify(&_ci, CDDS_ITEMPREERASE, &nmcd);

            if (!(dwItemRet & CDRF_SKIPDEFAULT))
            {
                if (prbb->hbmBack)
                {
                    if (!hdcMem)
                    {
                        hdcMem = CreateCompatibleDC(hdc);
                        if (!hdcMem)
                            continue;

                        _Realize(hdc, TRUE, FALSE);
                    }

                    SelectObject(hdcMem, prbb->hbmBack);

                    _BandTileBlt(prbb, nmcd.rc.left, nmcd.rc.top, nmcd.rc.right - nmcd.rc.left,
                            nmcd.rc.bottom - nmcd.rc.top, hdc, hdcMem);
                }
                else if (_hTheme)
                {
                    DrawThemeBackground(_hTheme, hdc, RP_BAND, 0, &nmcd.rc, 0);
                }
                else
                {
                    // if the color for this band is the same as the 
                    // rebar's default background color, then we
                    // don't need to paint this specially
                    COLORREF clr = _BandGetBkColor(prbb);
                    if (clr != _GetBkColor()) 
                    {
                        FillRectClr(hdc, &nmcd.rc, clr);
                    }
                }
            }

            if (dwItemRet & CDRF_NOTIFYPOSTERASE)
                CICustomDrawNotify(&_ci, CDDS_ITEMPOSTERASE, &nmcd);
        }

        if (hdcMem)
        {
            DeleteDC(hdcMem);
        }
    }

    if (_ci.dwCustom & CDRF_NOTIFYPOSTERASE)
    {
        nmcd.uItemState = 0;
        nmcd.dwItemSpec = 0;
        nmcd.lItemlParam = 0;
        CICustomDrawNotify(&_ci, CDDS_POSTERASE, &nmcd);
    }

    return(TRUE);
}

// ----------------------------------------------------------------------------
//
// _GetBarInfo
//
// retrieves the indicated values from the rebar's internal structure
//
// ----------------------------------------------------------------------------
BOOL CReBar::_GetBarInfo(LPREBARINFO lprbi)
{
    if (lprbi->cbSize != sizeof(REBARINFO))
        return(FALSE);

    if (lprbi->fMask & RBIM_IMAGELIST)
        lprbi->himl = _himl;

    return(TRUE);
}


// ----------------------------------------------------------------------------
//
// _SetBarInfo
//
// sets the indicated values in the rebar's internal structure, recalculating
// and refreshing as needed
//
// ----------------------------------------------------------------------------
BOOL CReBar::_SetBarInfo(LPREBARINFO lprbi)
{
    if (lprbi->cbSize != sizeof(REBARINFO))
        return(FALSE);

    if (lprbi->fMask & RBIM_IMAGELIST)
    {
        HIMAGELIST himl = _himl;
        int    cxOld, cyOld;

        //todo:validate lprbi->himl
        _himl = lprbi->himl;
        cxOld = _cxImage;
        cyOld = _cyImage;
        ImageList_GetIconSize(_himl, (LPINT)&_cxImage, (LPINT)&_cyImage);
        if ((_cxImage != cxOld) || (_cyImage != cyOld))
        {
            UINT i;

            for (i = 0; i < _cBands; i++) {
                if (_GetBand(i)->fStyle & RBBS_HIDDEN)
                    continue;

                _BandCalcMinWidth(_GetBand(i));
            }

            _Resize(FALSE);
        }
        else
            _InvalidateRect(NULL);
        lprbi->himl = himl;
    }

    return(TRUE);
}

// ----------------------------------------------------------------------------
//
// _GetBandInfo
//
// retrieves the indicated values from the specified band's internal structure
//
// ----------------------------------------------------------------------------
BOOL CReBar::_GetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi)
{
    PRBB prbb;

    if (!_IsValidIndex(uBand) || lprbbi->cbSize > SIZEOF(REBARBANDINFO))
        return(FALSE);

    prbb = _GetBand(uBand);

    if (lprbbi->fMask & RBBIM_SIZE) {
        if (prbb->fStyle & RBBS_FIXEDSIZE)
            lprbbi->cx = prbb->cx;
        else 
            lprbbi->cx = prbb->cxRequest;
    }
    
    if (lprbbi->fMask & RBBIM_STYLE)
        lprbbi->fStyle = prbb->fStyle;

    if (lprbbi->fMask & RBBIM_COLORS)
    {
        lprbbi->clrFore = _BandGetTextColorExternal(prbb);
        lprbbi->clrBack = _BandGetBkColorExternal(prbb);
    }

    if (lprbbi->fMask & RBBIM_TEXT)
    {
        UINT cch = prbb->lpText ? lstrlen(prbb->lpText) : 0;

        if (!lprbbi->cch || !lprbbi->lpText || (lprbbi->cch <= cch))
            lprbbi->cch = cch + 1;
        else if (prbb->lpText)
            lstrcpy(lprbbi->lpText, prbb->lpText);
        else
            // no text -- so just make it an empty string
            lprbbi->lpText[0] = 0;
    }

    if (lprbbi->fMask & RBBIM_IMAGE)
        lprbbi->iImage = prbb->iImage;

    if (lprbbi->fMask & RBBIM_CHILD)
        lprbbi->hwndChild = prbb->hwndChild;

    if (lprbbi->fMask & RBBIM_CHILDSIZE)
    {
        // HACKHACK: (tjgreen) Subtract the offset we added in SetBandInfo (see
        // comments there).
        lprbbi->cxMinChild = prbb->cxMinChild ? prbb->cxMinChild - CX_OFFSET : 0;
        lprbbi->cyMinChild = prbb->cyMinChild;
    }

    if (lprbbi->fMask & RBBIM_BACKGROUND)
        lprbbi->hbmBack = prbb->hbmBack;

    if (lprbbi->fMask & RBBIM_ID)
        lprbbi->wID = prbb->wID;

    if (lprbbi->cbSize > REBARBANDINFO_V3_SIZE)
    {
        if ((lprbbi->fMask & RBBIM_CHILDSIZE) && (prbb->fStyle & RBBS_VARIABLEHEIGHT))
        {
            lprbbi->cyIntegral = prbb->cyIntegral;
            lprbbi->cyMaxChild = prbb->cyMaxChild;
            lprbbi->cyChild = prbb->cyChild;
        }

        if (lprbbi->fMask & RBBIM_HEADERSIZE) 
            lprbbi->cxHeader = _GetHeaderWidth(prbb);

        if (lprbbi->fMask & RBBIM_IDEALSIZE)
            // HACKHACK: (tjgreen) Subtract the offset we added in SetBandInfo (see 
            // comments there).
            lprbbi->cxIdeal = prbb->cxIdeal ? prbb->cxIdeal - CX_OFFSET : 0;

        if (lprbbi->fMask & RBBIM_LPARAM)
            lprbbi->lParam = prbb->lParam;
    }

    return(TRUE);
}

BOOL CReBar::_ValidateBandInfo(LPREBARBANDINFO *pprbbi, LPREBARBANDINFO prbbi)
{
    BOOL fRet = ((*pprbbi)->cbSize == sizeof(REBARBANDINFO));
    
    if (!fRet) {
        
        if ((*pprbbi)->cbSize < SIZEOF(REBARBANDINFO)) {
            hmemcpy(prbbi, (*pprbbi), (*pprbbi)->cbSize);
            (*pprbbi) = prbbi;
            prbbi->cbSize = SIZEOF(REBARBANDINFO);
            fRet = TRUE;
        }
    }

    return fRet;
}

// ----------------------------------------------------------------------------
//
// _SetBandInfo
//
// sets the indicated values in the specified band's internal structure,
// recalculating and refreshing as needed
//
// ----------------------------------------------------------------------------
BOOL CReBar::_SetBandInfo(UINT uBand, LPREBARBANDINFO lprbbi, BOOL fAllowRecalc)
{
    PRBB    prbb;
    BOOL    fRefresh = FALSE;
    BOOL    fRecalc  = FALSE;
    BOOL    fRecalcMin = FALSE;
    BOOL    fTextChanged = FALSE;
    REBARBANDINFO rbbi = {0};
    RECT    rc;

    if (!_IsValidIndex(uBand) || !_ValidateBandInfo(&lprbbi, &rbbi))
        return(FALSE);

    prbb = _GetBand(uBand);

    if (lprbbi->fMask & RBBIM_TEXT)
    {
        if (!lprbbi->lpText || !prbb->lpText || lstrcmp(lprbbi->lpText, prbb->lpText))
        {
            if (lprbbi->lpText != prbb->lpText) {
                Str_Set(&prbb->lpText, lprbbi->lpText);
                fTextChanged = TRUE;
            }
        }
    }

    if (lprbbi->fMask & RBBIM_STYLE)
    {
        UINT fStylePrev = prbb->fStyle;
        UINT fChanged = lprbbi->fStyle ^ fStylePrev;

        prbb->fStyle = lprbbi->fStyle;

        if (fChanged)
            fRecalc = TRUE;

        if ((prbb->fStyle & RBBS_FIXEDSIZE) && !(fStylePrev & RBBS_FIXEDSIZE))
            prbb->cxMin = prbb->cx;
        else if (fChanged & RBBS_FIXEDSIZE)
            fRecalcMin = TRUE;
        
        if (fChanged & RBBS_GRIPPERALWAYS)
            fRecalcMin = TRUE;
        
        if (fChanged & RBBS_HIDDEN) 
            _ShowBand(uBand, !(prbb->fStyle & RBBS_HIDDEN));

        if (fChanged & RBBS_HIDETITLE)
            fTextChanged = TRUE;

        // can't have both of these
        if (prbb->fStyle & RBBS_FIXEDSIZE)
            prbb->fStyle &= ~RBBS_BREAK;
        
    }

    // RBBIM_TEXT does calculations that want to take some RBBIM_STYLE bits
    // into account, so delay those calculations until we grab the style bits.
    //
    if (fTextChanged && !(prbb->fStyle & RBBS_HIDDEN))
    {
        if (_BandCalcTextExtent(prbb, NULL))
            fRecalc = TRUE;
        else
            fRefresh = TRUE;
    }

    if (lprbbi->fMask & RBBIM_IDEALSIZE)
    {
        // HACKHACK: (tjgreen) Add an offset to the width the caller specifies.
        // This offset gets clipped off in _ResizeChildren, so the child window is  
        // rendered with the width specified by caller, and we get a little space on 
        // the toolbar after the buttons.  If caller specifies zero-width, though, 
        // we don't want this extra space, so don't add offset.
        int cxIdeal = lprbbi->cxIdeal ? lprbbi->cxIdeal + CX_OFFSET : 0;
        if (cxIdeal != prbb->cxIdeal)
        {
            prbb->cxIdeal = cxIdeal;
            fRecalcMin = TRUE;
            fRecalc = TRUE;
        }
    }
    
    if (lprbbi->fMask & RBBIM_SIZE)
    {
        if (prbb->cxRequest != (int)lprbbi->cx)
        {
            fRecalc = TRUE;
            prbb->cxRequest = lprbbi->cx;
        }

        if (prbb->fStyle & RBBS_FIXEDSIZE)
            prbb->cxMin = prbb->cxRequest;
    }
    
    if (lprbbi->fMask & RBBIM_HEADERSIZE)
    {
        if ((lprbbi->cxHeader == -1) ||
            !(prbb->fStyle & RBBS_FIXEDHEADERSIZE) ||
            (prbb->cxMin != (int)lprbbi->cxHeader + prbb->cxMinChild)) 
        {

            if (lprbbi->cxHeader == -1) 
            {
                prbb->fStyle &= ~RBBS_FIXEDHEADERSIZE;
                fRecalcMin = TRUE;
            }
            else
            {
                prbb->fStyle |= RBBS_FIXEDHEADERSIZE;
                prbb->cxMin = lprbbi->cxHeader + prbb->cxMinChild;
            }

            fRecalc = TRUE;
            fRefresh = TRUE;
        }
    }

    if (lprbbi->fMask & RBBIM_COLORS)
    {
        prbb->clrFore = lprbbi->clrFore;
        prbb->clrBack = lprbbi->clrBack;
        fRefresh = TRUE;
    }

    if ((lprbbi->fMask & RBBIM_IMAGE) && (prbb->iImage != lprbbi->iImage))
    {
        BOOL fToggleBmp = ((prbb->iImage == -1) || (lprbbi->iImage == -1));

        prbb->iImage = lprbbi->iImage;

        if (fToggleBmp)
        {
            fRecalc = TRUE;
            fRecalcMin = TRUE;
        }
        else
            fRefresh = TRUE;
    }

    if (lprbbi->fMask & RBBIM_CHILD &&
        lprbbi->hwndChild != prbb->hwndChild &&
        (NULL == lprbbi->hwndChild || 
         !IsChild(lprbbi->hwndChild, _ci.hwnd)))
    {
        if (IsWindow(prbb->hwndChild))
            ShowWindow(prbb->hwndChild, SW_HIDE);        

        prbb->hwndChild = lprbbi->hwndChild;

        if (prbb->hwndChild)
        {
            SetParent(prbb->hwndChild, _ci.hwnd);
            ShowWindow(prbb->hwndChild, SW_SHOW);
        }
        fRecalc = TRUE;
    }

    if (lprbbi->fMask & RBBIM_CHILDSIZE)
    {
        int cyChildOld = prbb->cyChild;

        if (lprbbi->cyMinChild != -1)
            prbb->cyMinChild = lprbbi->cyMinChild;

        if (prbb->fStyle & RBBS_VARIABLEHEIGHT)
        {
            BOOL fIntegralLarger = FALSE;

            if (lprbbi->cyIntegral != -1)
            {
                fIntegralLarger = ((int)lprbbi->cyIntegral > prbb->cyIntegral); 
                prbb->cyIntegral = lprbbi->cyIntegral;
            }

            if (lprbbi->cyMaxChild != -1)
                prbb->cyMaxChild = lprbbi->cyMaxChild;
            
            if (lprbbi->cyChild != -1)
                prbb->cyChild = lprbbi->cyChild;

            if (prbb->cyChild < prbb->cyMinChild)
                prbb->cyChild = prbb->cyMinChild;
            if (prbb->cyChild > prbb->cyMaxChild)
                prbb->cyChild = prbb->cyMaxChild;

            // validate the child size.  cyChild must be cyMinChild plux n*cyIntegral
            if (prbb->cyIntegral) 
            {
                int iExtra;
                iExtra = (prbb->cyChild - prbb->cyMinChild) % prbb->cyIntegral;
                
                // Don't change cyChild if it is already an valid integral height
                if (iExtra)
                {
                    if (fIntegralLarger)
                    {
                        // Round up
                        prbb->cyChild += (prbb->cyIntegral - iExtra); 
                    }
                    else
                    {
                        // Round down
                        prbb->cyChild -= iExtra;
                    }
                }

            }
            
        }
        else 
        {
            // if we're not in variable height mode, then 
            // the cyChild is the same as cyMinChild.  
            // this is a little peculiar, but done this way for backcompat.
            // cyMinChild came before cyChild
            prbb->cyChild = lprbbi->cyMinChild;
        }

        if (lprbbi->cxMinChild != -1) 
        {
            // HACKHACK: (tjgreen) Add an offset to the width the caller specifies.
            // This offset gets clipped off in _ResizeChildren, so the child window is  
            // rendered with the width specified by caller, and we get a little space on 
            // the toolbar after the buttons.  However, if caller specifies zero-width or
            // if the band is fixed size, we don't want this extra space, so don't add offset.
            int cxMinChild = lprbbi->cxMinChild;
            if ((lprbbi->cxMinChild != 0) && !(prbb->fStyle & RBBS_FIXEDSIZE))
                cxMinChild += CX_OFFSET;

            if (prbb->cxMinChild != cxMinChild) 
            {
                int cxOldHeaderMin = _GetHeaderWidth(prbb);
                
                if (prbb->fStyle & RBBS_FIXEDSIZE)
                    fRecalc = TRUE;
                    
                prbb->cxMinChild = cxMinChild;
                
                if (prbb->fStyle & RBBS_FIXEDHEADERSIZE)
                    prbb->cxMin = cxOldHeaderMin + prbb->cxMinChild;
                
                fRecalcMin = TRUE;
            }
            
            if (cyChildOld != prbb->cyChild) 
            {
                // TODO:  revisit optimization:
                // if (_BandGetHeight(prbb) != prbb->cy)
                fRecalc = TRUE;
            }
        }
            
    }

    if (lprbbi->fMask & RBBIM_BACKGROUND)
    {
        DIBSECTION  dib;

        if (lprbbi->hbmBack && !GetObject(lprbbi->hbmBack, sizeof(DIBSECTION), &dib))
            return(FALSE);

        prbb->hbmBack = lprbbi->hbmBack;
        prbb->cxBmp = dib.dsBm.bmWidth;
        prbb->cyBmp = dib.dsBm.bmHeight;
        fRefresh = TRUE;
    }

    if (lprbbi->fMask & RBBIM_ID)
        prbb->wID = lprbbi->wID;

    if (lprbbi->fMask & RBBIM_LPARAM)
        prbb->lParam = lprbbi->lParam;

    if (fRecalcMin && !(prbb->fStyle & RBBS_HIDDEN))
        _BandCalcMinWidth(prbb);

    if (fAllowRecalc)
    {

        if (fRecalc)
            _Resize(FALSE);
        if (fRefresh || fRecalc)
        {
            // '|| fRecalc' so we catch add/grow of text.
            // testcase: remove title from band; add back; make sure the text
            // shows up (used to just leave old band contents there)
            SetRect(&rc, prbb->x, prbb->y, prbb->x + prbb->cx, prbb->y + prbb->cy);
            _InvalidateRect(&rc);
        }
    }
    
    return(TRUE);
}

// ----------------------------------------------------------------------------
//
// _ReallocBands
//
// reallocates the array of bands pointed to by _rbbList to the given
// number of bands
//
// ----------------------------------------------------------------------------
BOOL CReBar::_ReallocBands(UINT cBands)
{
    PRBB rbbList;

    if (!(rbbList = (PRBB) CCLocalReAlloc(_rbbList, sizeof(RBB) * cBands)) && cBands)
        return(FALSE);

    _rbbList = rbbList;
    return(TRUE);
}

//
// NOTES
//  for now caller does this in two calls (query, set).  eventually we
//  should be able to have it do everything up front.
BOOL CReBar::_RecalcFirst(int nCmd, PRBB prbbDelHide)
{
    switch (nCmd) {
    case RBC_QUERY:
    {
        BOOL fRecalcFirst;
        // if we're nuking the 1st visible guy,
        // and there are visible guys after us,
        // then we need to recompute stuff
        //
        // for a testcase, start w/:
        //  row1: 'standard buttons' + 'brand'
        //  row2: 'address' + 'links'
        // now hide 'standard buttons', you should end up w/:
        //  row1: 'address' + 'links' + 'brand'
        // if there's a bug, you'll end up w/ (since the break isn't recomputed):
        //  row1: 'brand'
        //  row2: 'address' + 'links'
        // fRecalcFirst = (!uBand && _cBands);

        // if brbbDelHide is the first non-hidden band, and there are other non-hidden bands after it, fRecalcFirst = TRUE;
        fRecalcFirst = (_EnumBand(0, RBBS_HIDDEN) == prbbDelHide) &&
                       _GetNextVisible(prbbDelHide);

        return fRecalcFirst;
    }

    case RBC_SET: // set
    {
        PRBB prbb1 = _EnumBand(0, RBBS_HIDDEN);
        if (_IsValidBand(prbb1) && (prbb1->fStyle & RBBS_FIXEDSIZE))
        {
            PRBB prbb2 = _EnumBand(1, RBBS_HIDDEN);
            if (_IsValidBand(prbb2))
            {
                // get rid of line break on NEW first item
                prbb2->fStyle &= ~RBBS_BREAK;
            }

            if (_ci.style & RBS_FIXEDORDER)
            {
                // this is because the min width is now based on it's movability --
                // and since we are deleting (or hiding) the first item,
                // the new first item becomes immovable
                _BandCalcMinWidth(prbb1);
            }
        }
        return TRUE;
    }
    
    default:
        ASSERT(0);
    }

    return FALSE;
}

// ----------------------------------------------------------------------------
//
// _ShowBand
//
// updates show/hide state for the indicated band in the rebar's band array
// (rbbList).
//
// ----------------------------------------------------------------------------
BOOL CReBar::_ShowBand(UINT uBand, BOOL fShow)
{
    PRBB prbb;
    BOOL fRecalcFirst;

    if (!_IsValidIndex(uBand))
        return(FALSE);

    prbb = _GetBand(uBand);

    // if we're nuking the 1st visible guy,
    // then we need to recompute stuff
    fRecalcFirst = _RecalcFirst(RBC_QUERY, prbb);

    if (fShow)
    {
        prbb->fStyle &= ~RBBS_HIDDEN;

        if (!_BandCalcTextExtent(prbb, NULL))
            _BandCalcMinWidth(prbb);

        if (prbb->hwndChild)
            ShowWindow(prbb->hwndChild, SW_SHOW);
    }
    else
    {
        prbb->fStyle |= RBBS_HIDDEN;
        if (prbb->hwndChild)
            ShowWindow(prbb->hwndChild, SW_HIDE);        
    }

    if (fRecalcFirst)
        _RecalcFirst(RBC_SET, NULL);

    _InvalidateRect(NULL);

    // Since _Resize is followed by _AutoSize,
    // redraw must be TRUE for _Resize to do anything.
    BOOL fRedrawOld = _SetRedraw(TRUE);
    _Resize(FALSE);
    _AutoSize();
    _SetRedraw(fRedrawOld);

    return(TRUE);
}


// ----------------------------------------------------------------------------
//
// _DeleteBand
//
// deletes the indicated band from the rebar's band array (rbbList) and
// decrements the rebar's band count (cBands)
//
// ----------------------------------------------------------------------------
BOOL CReBar::_DeleteBand(UINT uBand)
{
    PRBB prbb;
    PRBB prbbStop;
    BOOL fRecalcFirst;
    NMREBAR nm = {0};

    // we need to clean up
    //
    // a) captured band and
    // b) hottracked band
    //
    // before we delete this band

    if (_uCapture != -1) 
    {
        _SendNotify(_uCapture, RBN_ENDDRAG);
        _OnBeginDrag((UINT)-1);
    }

    if (!_IsValidIndex(uBand))
        return FALSE;

    prbb = _GetBand(uBand);

    // Notify the client of the delete
    _SendNotify(uBand, RBN_DELETINGBAND);

    nm.dwMask = RBNM_ID;
    nm.wID = _GetBand(uBand)->wID;        // Save this

    Str_Set(&prbb->lpText, NULL);

    // don't destroy the hbmBack 'cause it's given to us by app

    // if we're nuking the 1st visible guy,
    // then we need to recompute stuff

    // if this is the first visible guy and there are other visible bands after it, fRecalcFirst = TRUE
    fRecalcFirst = _RecalcFirst(RBC_QUERY, prbb);

    if (IsWindow(prbb->hwndChild))
        ShowWindow(prbb->hwndChild, SW_HIDE);    
    
    // prbbStop gets the address of the last band
    prbbStop = _GetLastBand();

    for ( ; prbb < prbbStop; prbb++)
        *prbb = *(prbb + 1);

    _cBands--;

    if (_uResizeNext >= uBand && _uResizeNext > 0)
    {
        // (defer RBBS_HIDDEN stuff to use of uResizeNext)
        _uResizeNext--;
    }


    // Notify the client of the delete
    CCSendNotify(&_ci, RBN_DELETEDBAND, &nm.hdr);

    if (fRecalcFirst)
        _RecalcFirst(RBC_SET, NULL);

    _ReallocBands(_cBands);

    _InvalidateRect(NULL);
    _Resize(FALSE);
    _AutoSize();
    return(TRUE);
}

// ----------------------------------------------------------------------------
//
// _InsertBand
//
// inserts a new band at the given position in the rebar's band array (rbbList),
// increments the rebar's band count (cBands), and sets the band's structure
// based on the given REBARBANDINFO structure.
//
// ----------------------------------------------------------------------------
BOOL CReBar::_InsertBand(UINT uBand, LPREBARBANDINFO lprbbi)
{
    PRBB prbb;
    REBARBANDINFO rbbi = {0};

    if (!_ValidateBandInfo(&lprbbi, &rbbi))
        return(FALSE);
    
    if (uBand == -1)
        uBand = _cBands;
    else if (uBand > _cBands)
        return(FALSE);

    if (!_ReallocBands(_cBands + 1))
        return(FALSE);

    ++_cBands;
    MoveMemory(_GetBand(uBand + 1), _GetBand(uBand), (_cBands-1-uBand) * sizeof(_rbbList[0]));

    prbb = _GetBand(uBand);

    // movememory does not zero init for us...
    ZeroMemory(prbb, SIZEOF(RBB));


    // Init text color
    if (_clrText == CLR_NONE)
    {
        // Default to system text color
        prbb->clrFore = CLR_DEFAULT;
    }
    else
    {
        // Default to rebar's custom text color
        prbb->clrFore = CLR_NONE;
    }


    // Init background color
    if (_clrBk == CLR_NONE)
    {
        // Default to system background color
        prbb->clrBack = CLR_DEFAULT;
    }
    else
    {
        // Default to rebar's custom background color
        prbb->clrBack = CLR_NONE;
    }

    
    prbb->iImage = -1;
    prbb->cyMaxChild = MAXINT;
    prbb->wChevState = DCHF_INACTIVE;
    
    ASSERT(prbb->fStyle == 0);
    ASSERT(prbb->lpText == NULL);
    ASSERT(prbb->cxText == 0);
    ASSERT(prbb->hwndChild == NULL);
    ASSERT(prbb->cxMinChild == 0);
    ASSERT(prbb->cyMinChild == 0);
    ASSERT(prbb->hbmBack == 0);
    ASSERT(prbb->x == 0);
    ASSERT(prbb->y == 0);
    ASSERT(prbb->cx == 0);
    ASSERT(prbb->cy == 0);
    
    if (!_SetBandInfo(uBand, lprbbi, FALSE))
    {
        _DeleteBand(uBand);
        return(FALSE);
    }
    
    if (!(prbb->fStyle & RBBS_HIDDEN)) 
    {
        PRBB prbbFirst = _EnumBand(0, RBBS_HIDDEN);
        
        if (!prbb->cxMin)
            _BandCalcMinWidth(prbb);

        if (prbbFirst != prbb)
        {
            int cxMin = prbbFirst->cxMin;
            _BandCalcMinWidth(prbbFirst);
        }
        _Resize(FALSE);
    }

    _SizeBandToRowHeight(uBand, -1);

    if (_CountBands(RBBS_HIDDEN) == 1) 
    {
        // typcially, when you insert a band, we put it in a row with another band.
        // thus the total bounding rect doesn't change.  however, on the addition of the first band,
        // the bound rect does change, so we need to autosize as necessary.
        _AutoSize();
    }

    return(TRUE);
}

BOOL InitReBarClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc  = CReBar::s_WndProc;
    wc.lpszClassName= c_szReBarClass;
    wc.style        = CS_GLOBALCLASS | CS_DBLCLKS;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = sizeof(CReBar*);
    wc.hInstance    = hInstance;   // use DLL instance if in DLL
    wc.hIcon        = NULL;
    wc.hCursor      = NULL;
    wc.hbrBackground= (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszMenuName = NULL;

    if (!RegisterClass(&wc) && !GetClassInfo(hInstance, c_szReBarClass, &wc))
        return FALSE;

    return(TRUE);
}


// get the first band in the same row as rbbRow
// n.b. we may return an RBBS_HIDDEN band!
PRBB CReBar::_GetFirstInRow(PRBB prbbRow)
{
    // n.b. we don't pay attention to hidden here, that's up to caller.
    // in fact we *can't*, since there might be no non-hidden guys left
    // (e.g. when _OnDestroy is deleting all the bands), in which case
    // we'd loop forever.
    while (prbbRow > _GetBand(0) && !_IsBandStartOfRow(prbbRow))
    {
        _ValidateRangePtr(prbbRow);
        prbbRow--;
    }
    
    return prbbRow;
}

// get the last band in the same row as rbbRow.
// fStopAtFixed says whether to continue over fixed bands or 
// stop at them
// n.b. we may return an RBBS_HIDDEN band!
PRBB CReBar::_GetLastInRow(PRBB prbbRow, BOOL fStopAtFixed)
{
    do 
    {
        prbbRow++;
    } 
    while (prbbRow <= _GetLastBand() && !_IsBandStartOfRow(prbbRow) && 
        (!fStopAtFixed || (prbbRow->fStyle & (RBBS_FIXEDSIZE|RBBS_HIDDEN)) == RBBS_FIXEDSIZE));

    // loop steps to the start of the NEXT line
    prbbRow--;
    
    return prbbRow;
}

//***   _GetPrev, _GetNext -- get prev (next) band, skipping guys
// of style uStyleSkip (e.g. RBBS_HIDDEN)
PRBB CReBar::_GetPrev(PRBB prbb, UINT uStyleSkip)
{
    while (--prbb >= _GetBand(0))
    {
        if (prbb->fStyle & uStyleSkip)
            continue;

        return prbb;
    }

    return NULL;
}

PRBB CReBar::_GetNext(PRBB prbb, UINT uStyleSkip)
{
    while (++prbb <= _GetLastBand())
    {
        if (prbb->fStyle & uStyleSkip)
            continue;

        return prbb;
    }

    return NULL;
}

//***   _CountBands -- get count of bands, skipping guys
// of style uStyleSkip (e.g. RBBS_HIDDEN)
int CReBar::_CountBands(UINT uStyleSkip)
{
    int i;
    PRBB prbb;

    if (_cBands == 0)
        return 0;

    i = 0;
    for (prbb = _GetBand(0); prbb <= _GetLastBand(); prbb++)
    {
        if (prbb->fStyle & uStyleSkip)
            continue;
        i++;
    }

    return i;
}

//***   _EnumBand -- get Nth band, skipping guys
// of style uStyleSkip (e.g. RBBS_HIDDEN)
// 'skipping' means don't include in count
PRBB CReBar::_EnumBand(int i, UINT uStyleSkip)
{
    PRBB prbb;

    for (prbb = _GetBand(0); prbb <= _GetLastBand(); prbb++)
    {
        if (prbb->fStyle & uStyleSkip)
            continue;
        if (i-- == 0)
            break;
    }

    // if we found it, this is the band;
    // if we ran out of bands, this is 1 past the end
    return prbb;
}

// returns the minimum x position prbb can be
int CReBar::_MinX(PRBB prbb)
{
    int xLimit = 0;

    ASSERT(!(prbb->fStyle & RBBS_HIDDEN));  // o.w. might loop forever
    while (!_IsBandStartOfRow(prbb))
    {
        prbb--;
        if (!(prbb->fStyle & RBBS_HIDDEN))
            xLimit += _FudgeWidth(prbb->cxMin);
    }
    
    return xLimit + _mBand.cxLeftWidth;
}

int CReBar::_MaxX(PRBB prbb)
{
    int xLimit = 0;
    if (prbb)
    {
        PRBB prbbLast = _rbbList + _cBands;
        PRBB prbbWalk;
        for (prbbWalk = prbb; prbbWalk < prbbLast; prbbWalk++)
        {
            if (prbbWalk->fStyle & RBBS_HIDDEN)
                continue;
            if (_IsBandStartOfRow(prbbWalk))
                break;

            if (prbbWalk != prbb)
                xLimit += _FudgeWidth(prbbWalk->cxMin);
            else 
                xLimit += prbbWalk->cxMin;
        }

        prbbWalk = _GetPrevVisible(prbbWalk);   // prbbWalk--;
        if (prbbWalk)
            xLimit = prbbWalk->x + prbbWalk->cx - xLimit;
    }

    return xLimit;
}

BOOL CReBar::_MinimizeBand(UINT uBand, BOOL fAnim)
{
    PRBB prbb;

    if (!_IsValidIndex(uBand))
        return FALSE;
    prbb = _GetBand(uBand);
    if (prbb->fStyle & RBBS_FIXEDSIZE)
        return FALSE;
    
    ASSERT(!(prbb->fStyle & RBBS_HIDDEN));
    if (_IsBandStartOfRow(prbb)) 
    {
        // if it's the start of a row, the way to minimize it is to maximize the next guy
        // if it's on the same row
        prbb = _GetNextVisible(prbb);
        if (!prbb || _IsBandStartOfRow(prbb)) 
            return FALSE;
        
        return _MaximizeBand(_BandToIndex(prbb), FALSE, fAnim);
    }
    if (fAnim)
        return _SetBandPosAnim(prbb, prbb->x + (prbb->cx - prbb->cxMin));
    else
        return _SetBandPos(prbb, prbb->x + (prbb->cx - prbb->cxMin));

}


// fIdeal - FALSE == full maximization...  
//          TRUE == go to cxIdeal
// fAnim - TRUE means we were called due to UI action (via _ToggleBand), so animate

BOOL CReBar::_MaximizeBand(UINT uBand, BOOL fIdeal, BOOL fAnim)
{
    int x, dx;
    BOOL fChanged = FALSE;
    PRBB prbbMaximize;

    if (!_IsValidIndex(uBand))
        return FALSE;

    prbbMaximize = _GetBand(uBand);

    if (prbbMaximize->fStyle & RBBS_FIXEDSIZE)
        return FALSE;

    dx = prbbMaximize->cxIdeal + _GetHeaderWidth(prbbMaximize) - prbbMaximize->cx;
    
    if (fIdeal && dx > 0) 
    {
        PRBB prbb;
        
        // first move the next guy over if possible.

        prbb = _GetNextVisible(prbbMaximize);
        if (prbb && (!_IsBandStartOfRow(prbb)))
        {
            int dxRbb;

            x = _MaxX(prbb);
            // dxRbb is the maximum that prbb can move
            dxRbb = x - prbb->x;

            if (dxRbb > dx) 
            {
                // if that's more than enough space, then limit dx
                dxRbb = dx;
            }

            x = prbb->x + dxRbb;
            fChanged |= (fAnim)?_SetBandPosAnim(prbb, x):_SetBandPos(prbb,x);
            dx -= dxRbb;
        }

        if (dx)
        {
            int dxRbb;

            // the one on the right didn't move enough.
            // now move us back
            x = _MinX(prbbMaximize);
            dxRbb = prbbMaximize->x - x;

            if (dxRbb > dx)
            {
                x = prbbMaximize->x - dx;
            }
            fChanged |= (fAnim)?_SetBandPosAnim(prbbMaximize, x):_SetBandPos(prbbMaximize, x);
        }
        
    } 
    else
    {    
        x = _MinX(prbbMaximize);
        fChanged |= (fAnim)?_SetBandPosAnim(prbbMaximize, x):_SetBandPos(prbbMaximize, x);
        prbbMaximize = _GetNextVisible(prbbMaximize);
        if (prbbMaximize && !_IsBandStartOfRow(prbbMaximize)) 
        {
            x = _MaxX(prbbMaximize);
            fChanged |= (fAnim)?_SetBandPosAnim(prbbMaximize, x):_SetBandPos(prbbMaximize, x);
        }
    }
            
    return fChanged;
}


// ----------------------------------------------------------------------------
//
// _ToggleBand
//
// switches a band between it's maximized and minimized state, based on where
// the user clicked
//
// ----------------------------------------------------------------------------
void CReBar::_ToggleBand(BOOL fAnim)
{
    BOOL fDidSomething = FALSE;

    // try to maximize this band.  if failed (meaning already maximize)
    // then minimize

    if (CCSendNotify(&_ci, RBN_MINMAX, NULL))
        return;            

    fDidSomething = _MaximizeBand(_uCapture, TRUE,fAnim);
    if (!fDidSomething)
        fDidSomething = _MinimizeBand(_uCapture,fAnim);

    if (fDidSomething)
        CCPlaySound(TEXT("ShowBand"));
}


// ----------------------------------------------------------------------------
//
// _SetCursor
//
// sets the cursor to either the move cursor or the arrow cursor, depending
// on whether or not the cursor is on a band's caption
//
// ----------------------------------------------------------------------------
void CReBar::_SetCursor(int x, int y, BOOL fMouseDown)
{

    int             iBand;
    RBHITTESTINFO   rbht;
    rbht.pt.x = x;
    rbht.pt.y = y;
    iBand = _HitTest(&rbht);
    if (rbht.flags == RBHT_GRABBER)
    {
        if (fMouseDown)
            SetCursor(LoadCursor(HINST_THISDLL, (_ci.style & CCS_VERT) ? MAKEINTRESOURCE(IDC_DIVOPENV) : MAKEINTRESOURCE(IDC_DIVOPEN) ));
        else
            SetCursor(LoadCursor(NULL, (_ci.style & CCS_VERT) ? IDC_SIZENS : IDC_SIZEWE));
        return;
    }

    if ((fMouseDown) && ((rbht.flags == RBHT_GRABBER) || (rbht.flags == RBHT_CAPTION) && _ShouldDrawGripper(_GetBand(iBand))))
    {
        // No longer IE3 compatible, per RichSt
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        return;
    }

    SetCursor(LoadCursor(NULL, IDC_ARROW));
}

// adjust's a band's (prbb) starting location to the given location
BOOL CReBar::_SetBandPos(PRBB prbb, int xLeft)
{
    RECT    rc;
    PRBB    prbbPrev;
    int     xRight;
    BOOL    fBandBorders = _UseBandBorders();
    BOOL    fRight;

    if (!prbb)
        return (FALSE);

    ASSERT(!(prbb->fStyle & RBBS_HIDDEN));
    ASSERT((xLeft >= 0)); // We've got problems if someone is trying to set us negative

    if (prbb->x == xLeft)
        return(FALSE);

    prbbPrev = _GetPrevVisible(prbb);

    // band has moved within valid range -- adjust band sizes and redraw
    // window
    fRight = (prbb->x < xLeft);

    SetRect(&rc, prbb->x - _mBand.cxLeftWidth, prbb->y- _mBand.cyTopHeight, prbb->x + prbb->cxMin + _mBand.cxRightWidth, prbb->y + prbb->cy + _mBand.cyBottomHeight);
    xRight = prbb->x + prbb->cx;
    prbb->x = xLeft;
    prbb->cx = xRight - xLeft;
    prbb->cxRequest = prbb->cx;

    if (fRight)
    {
        if (prbbPrev)
        {
            //moving right
            prbbPrev->cx = prbb->x - _mBand.cxRightWidth - prbbPrev->x - _mBand.cxLeftWidth;
            if (fBandBorders)
            {
                prbbPrev->cx -= g_cxEdge;
                rc.left -= g_cxEdge;
            }

            rc.left = rc.left - _mBand.cxRightWidth;

            prbbPrev->cxRequest = prbbPrev->cx;

            //check for compacting of following bands

            while (prbb && prbb->cx < prbb->cxMin)
            {
                prbb->cx = prbb->cxMin;
                prbb->cxRequest = prbb->cx;
                xLeft += _BandWidth(prbb);
                prbb = _GetNextVisible(prbb);   // prbb++;
                if (prbb)
                {
                    xRight = prbb->x + prbb->cx;
                    prbb->x = xLeft;
                    prbb->cx = xRight - xLeft;
                    prbb->cxRequest = prbb->cx;
                }
            }
            if (prbb)
                rc.right = xLeft + prbb->cxMin + _mBand.cxRightWidth;
        }
    }
    else
    {
        //moving left

        //check for compacting of preceding bands
        while (prbbPrev)
        {
            if (fBandBorders)
                xLeft -= g_cxEdge;

            prbbPrev->cx = xLeft - prbbPrev->x - _mBand.cxLeftWidth - _mBand.cxRightWidth;
            prbbPrev->cxRequest = prbbPrev->cx;
            if (prbbPrev->cx < prbbPrev->cxMin)
            {
                prbbPrev->x = xLeft - _mBand.cxLeftWidth - _mBand.cxRightWidth - prbbPrev->cxMin;
                prbbPrev->cx = prbbPrev->cxMin;
                prbbPrev->cxRequest = prbbPrev->cx;
                xLeft = prbbPrev->x;
                prbbPrev = _GetPrevVisible(prbbPrev);   // prbbPrev--
            }
            else
            {
                break;
            }
        }
        rc.left = xLeft - _mBand.cxLeftWidth - _mBand.cxRightWidth;
    }

    if (fBandBorders)
        rc.bottom += g_cyEdge / 2;

    _ResizeChildren();
    if (_InvalidateRect(&rc))
    {
        UpdateWindow(_ci.hwnd);
    }
    return(TRUE);

}

BOOL CReBar::_SetBandPosAnim(PRBB prbb, int xLeft)
{
    int ctr=0,dx, xCur = prbb->x;
    DWORD dwStartTime;

    if (xCur == xLeft)
        return FALSE;

    dwStartTime=GetTickCount();
    dx = (xLeft - xCur)/ANIMSTEPS;

    if (dx != 0)
    {
        if (xCur < xLeft) 
        {
            // move right
            for (; xCur < (xLeft-dx); ctr++,xCur += dx)
            {
                _SetBandPos(prbb, xCur);
                // If something caused us to take more than 10 times the time we
                // should be, break out, and let the final _SetBandPos finish
                if (GetTickCount() - dwStartTime > 10*ANIMSTEPS*ANIMSTEPTIME)
                    break;

                Sleep(ANIMSTEPTIME);
                // Start slowing us down 80% of the way through
                // Cut speed by 2/3 each time, but never move less than 4 pixels
                if ((ctr >= 4*ANIMSTEPS/5) && (dx >= 4))
                    dx = 2*dx/3; 
            }
        }
        else 
        {
            // move left
            for (; xCur > (xLeft-dx); ctr++, xCur += dx) 
            {
                _SetBandPos(prbb, xCur);
                if (GetTickCount() > (dwStartTime + 10*ANIMSTEPS*ANIMSTEPTIME))
                    break;
                Sleep(ANIMSTEPTIME);
                if ((ctr >= 4*ANIMSTEPS/5) && (dx <= -4))
                    dx = 2*dx/3;
            }
        }
    }
    _SetBandPos(prbb, xLeft);
    return TRUE;
}

void CReBar::_OnBeginDrag(UINT uBand)
{
    _uCapture = uBand;
    _ptLastDragPos.x = -1;
    _ptLastDragPos.y = -1;
    if (_uCapture == -1)
    {
       // aborting drag
        _fParentDrag = FALSE;
        _fFullOnDrag = FALSE;

        // we could have unwrapped rows, in which case, we need to grow bands (but not wrap)
        // to fill the empty space.
        if (_ci.style & RBS_AUTOSIZE)
        {
            _SizeBandsToRect(NULL);
            _SizeBandsToRowHeight();
        }
        
    } 
    else
    {
        _fParentDrag = TRUE;
        _fFullOnDrag = TRUE;
    }
}

int minmax(int x, int min, int max)
{
    x = max(x, min);
    x = min(x, max);
    return x;
}

// pass the break bit along
void CReBar::_PassBreak(PRBB prbbSrc, PRBB prbbDest)
{
    if (prbbSrc->fStyle & RBBS_BREAK)
    {
        prbbSrc->fStyle &= ~RBBS_BREAK;
        if (prbbDest)
            prbbDest->fStyle |= RBBS_BREAK;
    }
}

void CReBar::_GetClientRect(LPRECT prc)
{
    GetClientRect(_ci.hwnd, prc);
    if (_ci.style & CCS_VERT)
        FlipRect(prc);
}

//tells if prbb is the first band and the next band is fixed.
// if this is true then we need to do a recalc if we move prbb
BOOL CReBar::_RecalcIfMove(PRBB prbb)
{
    if (_EnumBand(0, RBBS_HIDDEN) == prbb)
    {
        PRBB prbbNext = _GetNextVisible(prbb);
        if (prbbNext && prbbNext->fStyle & RBBS_FIXEDSIZE)
            return TRUE;
    }
    return FALSE;
}

// find out if the prbb at it's min height could fit within the current window
// if all the others shrunk as much as they could
BOOL CReBar::_RoomForBandVert(PRBB prbbSkip)
{
    int yExtra = 0;
    UINT cBands = _cBands;
    int iNewRowHeight = prbbSkip->cyMinChild;
    PRBB prbb = _GetBand(0);
    
    if (_UseBandBorders())
        iNewRowHeight += g_cyEdge;
    iNewRowHeight += _mBand.cyBottomHeight + _mBand.cyTopHeight;
    
    while (prbb)
    {
        if (_IsBandVisible(prbb))
        {
            if (_IsBandStartOfRow(prbb))
            {
                yExtra += _GetRowHeightExtra(&prbb, prbbSkip);
                if (yExtra >= iNewRowHeight)
                    return TRUE;
                continue;
            }
        }
        prbb = _GetNextVisible(prbb);
    }
    
    return FALSE;
}

// we should make a new row if prbb isn't the start of the row already
// and we're off the end of the control
//
// poweruser hack of holding the control down will make a new row if you hit the border between lines

BOOL CReBar::_MakeNewRow(PRBB prbb, int y)
{
    BOOL fRet = FALSE;
    RECT rc;

    // if we're off the top of the control, move this band to the end (or beginning)
    _GetClientRect(&rc);
    InflateRect(&rc, 0, -g_cyEdge);

    if (!(_ci.style & RBS_FIXEDORDER))
    {

        int iOutsideLimit = g_cyEdge * 4; // how far do you have to move outside the bounds of the window to force a new row
        
        if (_RoomForBandVert(prbb)) 
        {
            iOutsideLimit = -g_cyEdge;
        }
        
        if (y < rc.top - iOutsideLimit) 
        { // top of control
            
            PRBB prbbNext = _EnumBand(0, RBBS_HIDDEN);
            if (prbbNext == prbb) 
                prbbNext = _GetNextVisible(prbb);
            fRet |= _MoveBand(_BandToIndex(prbb), 0);
            ASSERT(prbbNext <= _GetLastBand());
            if (prbbNext && !(prbbNext->fStyle & RBBS_BREAK))
            {
                prbbNext->fStyle |= RBBS_BREAK;
                fRet = TRUE;
            }
        }
        else if (y >= rc.bottom) 
        { 
            // move to the end
            if (!(prbb->fStyle & RBBS_BREAK))
            {
                prbb->fStyle |= RBBS_BREAK;
                fRet = TRUE;
            }

            prbb->cyChild = prbb->cyMinChild;

            fRet |= _MoveBand(_BandToIndex(prbb), _cBands-1);
        }
        else
        {

            // create a new row in the middle
            if (!_IsBandStartOfRow(prbb) && GetAsyncKeyState(VK_CONTROL) < 0) 
            {
                // make sure they're on different rows and on the border
                if (y > prbb->y + prbb->cy + _mBand.cyBottomHeight && 
                    y < prbb->y + prbb->cy + _mBand.cyBottomHeight + g_cyEdge) 
                {

                    PRBB prbbLast = _GetLastInRow(prbb, FALSE);  // move it right before the first in this row
                    prbb->fStyle |= RBBS_BREAK;
                    _MoveBand(_BandToIndex(prbb), _BandToIndex(prbbLast));
                    fRet = TRUE;
                }
            }
        }

    }
    else 
    {
        // fixed guys can't move, they can only make a new row
        if (!_IsBandStartOfRow(prbb)) 
        {
            if (y > prbb->y + prbb->cy + _mBand.cyBottomHeight) 
            {
                prbb->fStyle |= RBBS_BREAK;
                fRet = TRUE;
            }
        }
    }
    
    return fRet;
}


// ----------------------------------------------------------------------------
//
// _DragBand
//
// resizes the currently tracked band based on the user's mouse movement as
// indicated in the given point (x, y)
//
// ----------------------------------------------------------------------------
void CReBar::_DragBand(int x, int y)
{
    PRBB prbb = _GetBand(_uCapture);
    UINT iHit = -1;
    // Do nothing if the mouse didn't actually move
    // otherwise, multiple WM_MOUSEMOVE messages will be generated by resizing windows
    if (x==_ptLastDragPos.x && y==_ptLastDragPos.y)
        return;
    else
    {
        _ptLastDragPos.x = x;
        _ptLastDragPos.y = y;
    }

    if (_ci.style & CCS_VERT)
        SWAP(x,y, int);

    if (!_fFullOnDrag)
    {
        // don't begin dragging until mouse is moved outside of an edge-thick
        // tolerance border
        if ((y < (_ptCapture.y - g_cyEdge)) || (y > (_ptCapture.y + g_cyEdge)) ||
            (x < (_ptCapture.x - g_cxEdge)) || (x > (_ptCapture.x + g_cxEdge))) 
        {

            // did parent abort?
            if (_SendNotify(_uCapture, RBN_BEGINDRAG))
                return;

            if (!_IsValidBand(prbb)) 
            {
                // somebody responded to RBN_BEGINDRAG by nuking bands; bail
                return;
            }
            
            _fFullOnDrag = TRUE;
        } 
        else
            return;
    }
    
    // bail for right now on fRecalcIfMoved (ie3 did the same thing). nice feature for later
    if (!_CanBandMove(prbb))
        return;
    
   /* what type of drag operation depends on what we drag hit on.

        if we hit on the band before us, or ourself
          and it's the same row
          and we're not the first band of the row
             then we just to a size move
             
        otherwise if we hit on a band then we do a move 
        
        if we hit outside of any band, we grow to meet the cursor
        
        in all of the above, a band that's hit must be NOT fixed and not hidden
    */

    BOOL fResize = FALSE;

    RECT rc;
    _GetClientRect(&rc);
    if (y < rc.bottom - 1)
    {
         iHit = _InternalHitTest(NULL, x, y);
    }
    
    if (iHit != -1) 
    {
        PRBB prbbPrev = _GetPrevVisible(prbb);
        PRBB prbbHit = _GetBand(iHit);
        prbbHit = _GetPrev(++prbbHit, RBBS_FIXEDSIZE); // skip over fixed guys
        if (prbbHit)
        {
            ASSERT(prbbHit >= _rbbList);
            // this should never happen.
            if (prbbHit < _rbbList) 
                return;
            
            iHit = _BandToIndex(prbbHit);
            
            // if we're on the same row ...  and it's us or the previous one
            if (prbbHit->y == prbb->y && (prbbHit == prbb || prbbHit == prbbPrev))
            {

                if (x < _GetGripperWidth() + _mBand.cxLeftWidth && 
                    !(_ci.style & RBS_FIXEDORDER)) 
                {
                    // special case dragging to the far left. there's no other way to move to first in row
                    _PassBreak(prbbHit, prbb);
                    if (_MoveBand(_uCapture, iHit))                
                        fResize = TRUE;

                }
                else if (!_IsBandStartOfRow(prbb)) 
                {
                    // and we're not the first band of the row
                    // then just size it
                    int xLeft = _xStart + (x - _ptCapture.x);
                    xLeft = minmax(xLeft, _MinX(prbb), _MaxX(prbb));
                    _DragSize(xLeft);
                }

            } 
            else if (_MakeNewRow(prbb, y))
            {
                fResize = TRUE;
            } 
            else 
            {            // otherwise do a move if we're not in a fixed order
                if (!(_ci.style & RBS_FIXEDORDER)) 
                {
                    if (iHit < _BandToIndex(prbb)) 
                        iHit++; // +1 because if you hit a band, you're moving to the right of him

                    // if one with a break is moving, the next one inherits the break
                    _PassBreak(prbb, _GetNextVisible(prbb));
                    _MoveBand(_uCapture, iHit);
                } 
                else
                {
                    if (iHit < _BandToIndex(prbb))
                        _PassBreak(prbb, _GetNextVisible(prbb));
                }
                fResize = TRUE;
            }
        }
        
    } 
    else if (_MakeNewRow(prbb, y))
    {
        fResize = TRUE;
    }

    if (fResize)
    {
        _Resize(FALSE);
        _AutoSize();
    }
}

HPALETTE CReBar::_SetPalette(HPALETTE hpal)
{
    HPALETTE hpalOld = _hpal;

    if (hpal != hpalOld)
    {
        if (!_fUserPalette)
        {
            if (_hpal)
            {
                DeleteObject(_hpal);
                _hpal = NULL;
            }
        }

        if (hpal)
        {
            _fUserPalette = TRUE;
            _hpal = hpal;
        }

        _InvalidateRect(NULL);
    }
    return hpalOld;
}

// ----------------------------------------------------------------------------
//
// _OnDestroy
//
// frees all memory allocated by rebar
//
// ----------------------------------------------------------------------------
BOOL CReBar::_OnDestroy()
{
    UINT c = _cBands;

    _SetRedraw(FALSE);
    _SetRecalc(FALSE);
    
    while (c--)
        _DeleteBand(c);

    // so that we don't keep trying to autosize
    _ci.style &= ~RBS_AUTOSIZE;
    
    ASSERT(!_rbbList);

    _SetPalette(NULL);
    
    if (_hFont && _fFontCreated)
    {
        DeleteObject(_hFont);
    }

    if ((_ci.style & RBS_TOOLTIPS) && IsWindow(_hwndToolTips))
    {
        DestroyWindow (_hwndToolTips);
        _hwndToolTips = NULL;
    }


    // don't destroy the himl 'cause it's given to us by app

    if (_hDragProxy)
        DestroyDragProxy(_hDragProxy);

    if (_hTheme)
        CloseThemeData(_hTheme);

    return TRUE;
}

// ----------------------------------------------------------------------------
//
// _InitPaletteHack
//
// this is a hack to use the halftone palette until we have a way of asking
// the client what palette they are using
//
// ----------------------------------------------------------------------------
void CReBar::_InitPaletteHack()
{
    if (!_fUserPalette)
    {
        HDC hdc = CreateCompatibleDC(NULL);
        if (hdc)
        {
            if (GetDeviceCaps(hdc, BITSPIXEL) <= 8)
            {

                if (_hpal)
                    DeleteObject(_hpal);
                _hpal = CreateHalftonePalette(hdc);  // this is a hack
            }
            DeleteDC(hdc);
        }
    }
}

UINT CReBar::_IDToIndex(UINT id)
{
    UINT i;
    REBARBANDINFO   rbbi;

    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask = RBBIM_ID;

    for (i = 0; i < _cBands; i++) 
    {

        if (_GetBandInfo(i, &rbbi)) 
        {

            if (rbbi.wID == (WORD)id)
                return i;
        }
    }

    return -1;
}

int CReBar::_GetRowHeight(UINT uRow)
{
    if (uRow < _cBands)
    {
        // move back to start of line
        PRBB prbbFirst = _GetFirstInRow(_GetBand(uRow));
        PRBB prbbLast = _GetLastInRow(_GetBand(uRow), FALSE);

        return _GetLineHeight(_BandToIndex(prbbFirst), _BandToIndex(prbbLast));
    }

    return -1;
}

// fOneStep == whether to allow  only one cyIntegral or as many as will fit to 
//     fill dy
int CReBar::_GrowBand(PRBB prbb, int dy, BOOL fResize, int iLineHeight)
{
    int dyBand = 0; // how much the band changes

    if (prbb->cyIntegral) 
    {
        if (iLineHeight == -1)
        {
            iLineHeight = _GetRowHeight(_BandToIndex(prbb));
        }

        // get the proposed new size
        int cyDesiredHeight = min(iLineHeight + dy, prbb->cyMaxChild) - prbb->cyMinChild;
        // Limit new height to band's min and max
        int iNumOfIntegrals = max(cyDesiredHeight / prbb->cyIntegral, 0);
        int cyNewHeight     = prbb->cyMinChild + (iNumOfIntegrals * prbb->cyIntegral);

        DebugMsg(TF_REBAR, TEXT("REBAR._gb Band {%d}, Line Height {%d} Desired Height {%d} New Height {%d} Old Height {%d} dy {%d}"), _BandToIndex(prbb), iLineHeight, cyDesiredHeight + prbb->cyMinChild, cyNewHeight, prbb->cyChild, dy);

        dyBand = cyNewHeight - prbb->cyChild;
        prbb->cyChild = cyNewHeight;

        if (fResize)
        {
            _Resize(TRUE);
        }
    }
    return dyBand;
}



// returns the delta in size that the rebar is from prc.
// taking into account vertical mode
int CReBar::_SizeDifference(LPRECT prc)
{
    int d;

    d = (_IsVertical() ? RECTWIDTH(*prc) : RECTHEIGHT(*prc))
        - _cy;
    
    return d;
}

// returns how much this row could shrink
int CReBar::_GetRowHeightExtra(PRBB *pprbb, PRBB prbbSkip)
{
    // this is the largest minimum child size for the row. 
    // even if something is not at it's min size, if it's smaller than this
    // then it doesn't matter because someone else on that row can't be sized
    int yLimit = 0;
    int yExtra = 0;
    PRBB prbb = *pprbb;
            
    while (prbb)
    {
        
        if (prbb != prbbSkip) 
        {
            int yMin;
            int yExtraBand = 0;

            // the min height is the cyChild if it's not variable height
            yMin = prbb->cyChild;
            if (prbb->fStyle & RBBS_VARIABLEHEIGHT)
            {
                // if it is variable height, and there's still room to shrink, then cyMinChild is
                // the minimum.  
                if (prbb->cyChild >= prbb->cyMinChild + prbb->cyIntegral) 
                {
                    yMin = prbb->cyMinChild;
                    yExtraBand = prbb->cyChild - prbb->cyMinChild;
                }
            }

            if (yMin == yLimit) 
            {
                if (yExtraBand > yExtra)
                    yExtra = yExtraBand;
            } 
            else if (yMin > yLimit)
            {
                yExtra = yExtraBand;
            }
        }
        
        prbb = _GetNextVisible(prbb);
    }
    
    *pprbb = prbb;
    
    return yExtra;
}

// are allt he bands at the minimum size? 
BOOL CReBar::_BandsAtMinHeight()
{
    BOOL fRet = TRUE;
    
    PRBB prbb = _GetBand(0);
    while (prbb) 
    {
        if (_IsBandVisible(prbb)) 
        {
            if (_IsBandStartOfRow(prbb)) 
            {
                fRet = _IsRowAtMinHeight(&prbb);
                if (!fRet)
                    break;
                continue;
            }
        }
        prbb = _GetNextVisible(prbb);
    }
    
    return fRet;
}

// this is like _SizeBarToRect except that it resizes the actual bands if they
// are VARIABLEHEIGHT
BOOL CReBar::_SizeBandsToRect(LPRECT prc)
{
    int dy;
    RECT rc;
    BOOL fRedrawOld;
    BOOL fChanged = FALSE;
    
    // Turn recalc on to ensure calculations actually do something
    // (else we can loop forever since _cy never actually changes).
    _SetRecalc(TRUE);

    if (prc)
    {
        rc = *prc;
    }
    else 
    {
        GetClientRect(_ci.hwnd, &rc);
    }

    DebugMsg(TF_REBAR, TEXT("REBAR._sbandstr starting rect is {%d, %d, %d, %d}"), rc.left, rc.top, rc.right, rc.bottom);

    fRedrawOld = _SetRedraw(FALSE);

    dy = _SizeDifference(&rc);
    
    for (int iAttempt = 0; (iAttempt < 2) && dy; iAttempt++)
    {
        PRBB prbb = _rbbList;
        BOOL fValidBand = FALSE;
        while ((prbb - _rbbList < (int)_cBands) && !fValidBand)
        {
            if (!(prbb->fStyle & RBBS_HIDDEN) && (prbb->fStyle & RBBS_VARIABLEHEIGHT) && !(prbb->fStyle & RBBS_FIXEDSIZE))
            {
                fValidBand = TRUE;
            }
            else
            {
                prbb++;
            }
        }

        if ((prbb - _rbbList < (int)_cBands) && !(prbb->fStyle & RBBS_HIDDEN) && (prbb->fStyle & RBBS_VARIABLEHEIGHT) && !(prbb->fStyle & RBBS_FIXEDSIZE))
        {
            PRBB prbbMaxIntegral = prbb;
            do {
                if (!(prbb->fStyle & RBBS_HIDDEN) && (prbb->fStyle & RBBS_VARIABLEHEIGHT) && !(prbb->fStyle & RBBS_FIXEDSIZE))
                {
                    if (prbbMaxIntegral->cyIntegral < prbb->cyIntegral)
                    {
                        prbbMaxIntegral = prbb;
                    }
                }
                prbb++;
            }
            while ((prbb - _rbbList < (int)_cBands) && !_IsBandStartOfRow(prbb));

            int old_cyChild = prbbMaxIntegral->cyChild;

            if (prbbMaxIntegral->cyIntegral)
            {
                _GrowBand(prbbMaxIntegral, dy, FALSE, -1);
            }
            else
            {
                prbbMaxIntegral->cyChild += dy;
            }

            if (prbbMaxIntegral->cyChild != old_cyChild)
            {
                fChanged = TRUE;
            }

            UINT uFirst = _BandToIndex(_GetFirstInRow(prbbMaxIntegral));
            UINT uLast  = _BandToIndex(_GetLastInRow(prbbMaxIntegral, FALSE));
    
            for (UINT uBand = uFirst; uBand <= uLast; uBand++)
            {
                prbb = _GetBand(uBand);
    
                // if it's a variable height kind of guy, grow/shrink it
                if ((prbb != prbbMaxIntegral) && !(prbb->fStyle & RBBS_HIDDEN) && (prbb->fStyle & RBBS_VARIABLEHEIGHT) && !(prbb->fStyle & RBBS_FIXEDSIZE))
                {
                    old_cyChild = prbb->cyChild;

                    if (prbb->cyIntegral && prbbMaxIntegral->cyIntegral)
                    {
                        prbb->cyChild = prbbMaxIntegral->cyChild - ((prbbMaxIntegral->cyChild - prbb->cyMinChild) % prbb->cyIntegral);
                    }
                    else
                    {
                        prbb->cyChild = prbbMaxIntegral->cyChild;
                    }

                    if (prbb->cyChild != old_cyChild)
                    {
                        fChanged = TRUE;
                    }
                }
            }
            for (UINT uBand = uLast + 1; uBand < _cBands; uBand++)
            {
                prbb = _GetBand(uBand);
    
                if (!(prbb->fStyle & RBBS_HIDDEN) && (prbb->fStyle & RBBS_VARIABLEHEIGHT) && !(prbb->fStyle & RBBS_FIXEDSIZE))
                {
                    if (prbb->cyChild != prbb->cyMinChild)
                    {
                        prbb->cyChild = prbb->cyMinChild;
                        fChanged = TRUE;
                    }
                }
            }
        }

        if (fChanged)
        {
            _Resize(TRUE);
            dy = _SizeDifference(&rc);
        }
    }

    _SetRedraw(fRedrawOld);

    return fChanged;
}

void CReBar::_SizeBandToRowHeight(int i, int uRowHeight)
{
    PRBB prbb = _GetBand(i);
    
    if (prbb && prbb->fStyle & RBBS_VARIABLEHEIGHT)
    {
        if (uRowHeight == -1)
            uRowHeight = _GetRowHeight(i);

        if (uRowHeight > prbb->cyChild)
        {
            _GrowBand(prbb, 0, TRUE, uRowHeight);
        }
    }
}

// in the process of sizing, one band in a row of several bands might have
// grow pretty large.  we need to let the other bands have a chance to fill
// the extra space as well
void CReBar::_SizeBandsToRowHeight()
{
    UINT i;
    int iRowHeight = -1;
    
    for (i = 0; i < _cBands; i++)
    {
        PRBB prbb = _GetBand(i);

        if (prbb->fStyle & RBBS_HIDDEN)
            continue;
        
        if (_IsBandStartOfRow(prbb))
            iRowHeight = _GetRowHeight(i);

        _SizeBandToRowHeight(i, iRowHeight);
    }
}

BOOL CReBar::_OkayToChangeBreak(PRBB prbb, UINT uMsg)
{
    NMREBARAUTOBREAK nm;

    nm.uBand = _BandToIndex(prbb);
    nm.wID = prbb->wID;
    nm.lParam = prbb->lParam;
    nm.uMsg = uMsg;
    nm.fStyleCurrent = prbb->fStyle;
    nm.fAutoBreak = TRUE;

    CCSendNotify(&_ci, RBN_AUTOBREAK, &nm.hdr);

    return nm.fAutoBreak;
}

// this will add/remove rebar band breaks to get to the requested size.
// it returns TRUE/FALSE whether something was done or not.
LRESULT CReBar::_SizeBarToRect(DWORD dwFlags, LPRECT prc)
{
    BOOL fChanged = FALSE;
    RECT rc;
    BOOL fRedrawOld = _SetRedraw(FALSE);

    if (!prc)
    {
        GetClientRect(_ci.hwnd, &rc);
        prc = &rc;
    }
    
    if (_cBands) 
    {
        int c;
        UINT cBands = _cBands;
        BOOL fRearrangeBands = (_cBands > 0);
        BOOL fGrowing = TRUE;
        
        // if we're shrinking the rebar, we first want to shrink the bands before we start 
        // removing breaks
        c = _SizeDifference(prc);
        if (c < 0) 
            fGrowing = FALSE;
        
        fChanged = _SizeBandsToRect(prc);

        if (!fGrowing && !_BandsAtMinHeight()) 
        {
                // if we're shrinking and all the bands are not down to
                // the minimum height, don't try doing any of the breaking stuff
                goto Bail;
        }

        while (fRearrangeBands)
        {

            int cyRowHalf  = _GetRowHeight(_cBands-1) / 2 ;
            REBARBANDINFO   rbbi;
            PRBB prbb;

            fRearrangeBands = FALSE;

            rbbi.cbSize = sizeof(REBARBANDINFO);
            rbbi.fMask = RBBIM_STYLE;

            c = _SizeDifference(prc);

            if (c < -cyRowHalf)
            {

                // we've shrunk the rebar, try to remove breaks
                while (--cBands)
                {
                    prbb = _GetBand(cBands);
                    if (prbb->fStyle & RBBS_HIDDEN)
                        continue;

                    if ((prbb->fStyle & RBBS_BREAK) && (_OkayToChangeBreak(prbb, RBAB_AUTOSIZE)))
                    {
                        fChanged = TRUE;
                        fRearrangeBands = TRUE;
                        rbbi.fStyle = prbb->fStyle & ~RBBS_BREAK;
                        _SetBandInfo(cBands, &rbbi, TRUE);
                        break;
                    }
                }
            } 
            else if (c > cyRowHalf)
            {

                // we're enlarging the rebar
                while (--cBands)
                {
                    prbb = _GetBand(cBands);
                    if (prbb->fStyle & RBBS_HIDDEN)
                        continue;

                    if ((!(prbb->fStyle & (RBBS_BREAK | RBBS_FIXEDSIZE))) && (_OkayToChangeBreak(prbb, RBAB_AUTOSIZE)))
                    {
                        // no break here, add it
                        fChanged = TRUE;
                        fRearrangeBands = TRUE;
                        rbbi.fStyle = (prbb->fStyle | RBBS_BREAK);
                        _SetBandInfo(cBands, &rbbi, TRUE);
                        break;
                    }
                }
            } 
        }

        // if we did as much breaking as we could
        // and we walked all the way down to the 0th band (we start at the Nth band)
        // then we try to grow the bands that are VARIABLEHEIGHT
        // for fGrowing, see comment at top of function
        // 
        // wedo the % because cBands == _cBands if we didn't go through
        // any of the breaking loops at all
        if (!(cBands % _cBands) && fGrowing) 
            fChanged |= _SizeBandsToRect(prc);

    }

Bail:
    _SizeBandsToRowHeight();
    _SetRedraw(fRedrawOld);
    
    if (prc && (dwFlags & RBSTR_CHANGERECT))
    {
        if (_IsVertical())
        {
            prc->right = prc->left + _cy;
        }
        else
        {
            prc->bottom = prc->top + _cy;
        }
    }

    return (LRESULT)fChanged;
}

void CReBar::_AutoSize()
{
    NMRBAUTOSIZE nm;
    
    // if this is an internal autosize call, but we're not in autosize mode
    // do nothing
    
    if (!(_ci.style & RBS_AUTOSIZE))
        return;
    
    
    GetClientRect(_ci.hwnd, &nm.rcTarget);

    nm.fChanged = (BOOL) _SizeBarToRect(0, &nm.rcTarget);

    GetClientRect(_ci.hwnd, &nm.rcActual);
    CCSendNotify(&_ci, RBN_AUTOSIZE, &nm.hdr);
}

LRESULT CReBar::_GetBandBorders(int wParam, LPRECT prc)
{
    BOOL fBandBorders = _UseBandBorders();

    PRBB prbb = &_rbbList[wParam];
    prc->left = _GetHeaderWidth(prbb);
    
    if (fBandBorders) 
    {
        prc->left += 2*g_cxEdge;
        prc->right = 0;
        prc->top = g_cyEdge/2;
        prc->bottom = g_cyEdge /2;
    }
    else
    {
        prc->right = 0;
        prc->top = 0;
        prc->bottom = 0;
    }
    if (_ci.style & CCS_VERT)
        FlipRect(prc);
    return 0;
}

void CReBar::_OnStyleChanged(WPARAM wParam, LPSTYLESTRUCT lpss)
{
    if (wParam == GWL_STYLE)
    {
        DWORD dwChanged;
        
        _ci.style = lpss->styleNew;
        
        dwChanged = (lpss->styleOld ^ lpss->styleNew);
        // update to reflect style change
        if (dwChanged & CCS_VERT)
        {
            DebugMsg(TF_REBAR, TEXT("REBAR._osc ReBar is now {%s}"), (lpss->styleNew & CCS_VERT) ? TEXT("Horizontal") : TEXT("Vertical"));
            UINT i;
            for (i = 0; i < _cBands; i++) 
            {
                PRBB prbb = _GetBand(i);
                if (prbb->fStyle & RBBS_HIDDEN)
                    continue;

                if (!(lpss->styleNew & CCS_VERT))
                {
                    prbb->cyChild = 0;
                    _cy = 0;
                }

                _BandCalcMinWidth(prbb);
            }
        }
        
        if (dwChanged & RBS_REGISTERDROP) 
        {
            
            if (_ci.style & RBS_REGISTERDROP) 
            {
                ASSERT(!_hDragProxy);
                _hDragProxy = CreateDragProxy(_ci.hwnd, s_DragCallback, TRUE);
            } 
            else
            {
                ASSERT(_hDragProxy);
                DestroyDragProxy(_hDragProxy);
            }
        }
    }
    else if (wParam == GWL_EXSTYLE)
    {
        //
        // If the RTL_MIRROR extended style bit had changed, let's
        // repaint the control window
        //
        if ((_ci.dwExStyle&RTL_MIRRORED_WINDOW) !=  (lpss->styleNew&RTL_MIRRORED_WINDOW))
        {
            _InvalidateRect(NULL);
        }

        //
        // Save the new ex-style bits
        //
        _ci.dwExStyle = lpss->styleNew;
    }
}

void CReBar::_OnMouseMove(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RelayToToolTips(_hwndToolTips, hwnd, uMsg, wParam, lParam);

    if (_uCapture != -1)
    {
        // captured band -- mouse is down
        if (hwnd != GetCapture() && !_fParentDrag)
        {
            _SendNotify(_uCapture, RBN_ENDDRAG);
            _OnBeginDrag((UINT)-1);
        }
        else
            _DragBand(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
    }
    else
    {
        // hottracking
        int iBand;
        PRBB prbb = NULL;
        PRBB prbbHotOld = _prbbHot;
        RBHITTESTINFO rbht;

        rbht.pt.x = GET_X_LPARAM(lParam);
        rbht.pt.y = GET_Y_LPARAM(lParam);

        iBand = _HitTest(&rbht);
        if (iBand != -1)
            prbb = _GetBand(iBand);

        if (prbbHotOld && (prbbHotOld->wChevState & DCHF_PUSHED))
            return;

        if (prbb && (rbht.flags & RBHT_CHEVRON))
        {
            SetCapture(hwnd);
            _UpdateChevronState(prbb, DCHF_HOT);
            if (prbb == prbbHotOld)
                prbbHotOld = NULL;
        }

        if (prbbHotOld)
        {
            CCReleaseCapture(&_ci);
            _UpdateChevronState(prbbHotOld, DCHF_INACTIVE);
        }
    }
}

void CReBar::_OnPushChevron(HWND hwnd, PRBB prbb, LPARAM lParamNM)
{
    NMREBARCHEVRON nm;
    nm.uBand = _BandToIndex(prbb);
    nm.wID = prbb->wID;
    nm.lParam = prbb->lParam;
    nm.lParamNM = lParamNM;
    CopyRect(&nm.rc, &prbb->rcChevron);
    if (_IsVertical())
        FlipRect(&nm.rc);
    _UpdateChevronState(prbb, DCHF_PUSHED);
    CCReleaseCapture(&_ci);
    CCSendNotify(&_ci, RBN_CHEVRONPUSHED, &nm.hdr);
    _UpdateChevronState(_prbbHot, DCHF_INACTIVE);
}

void CReBar::_OnCreate(HWND hwnd, LPCREATESTRUCT pcs)
{
    InitGlobalColors();

    _uCapture = -1;
    _clrBk = CLR_NONE;
    _clrText = CLR_NONE;

    // Init the dwSize because we block-copy it back to the app
    _clrsc.dwSize = sizeof(COLORSCHEME);
    _clrsc.clrBtnHighlight = _clrsc.clrBtnShadow = CLR_DEFAULT;

    _fRedraw = TRUE;
    _fRecalc = TRUE;

    CIInitialize(&_ci, hwnd, pcs);

    _CacheThemeInfo(TRUE);

    if (!(_ci.style & (CCS_TOP | CCS_NOMOVEY | CCS_BOTTOM)))
    {
        _ci.style |= CCS_TOP;
        SetWindowLong(hwnd, GWL_STYLE, _ci.style);
    }

    if (_ci.style & WS_BORDER)
        _fHasBorder = TRUE;

    _SetFont(0);

    if (pcs->lpCreateParams)
        _SetBarInfo((LPREBARINFO) (pcs->lpCreateParams));
}

LRESULT CALLBACK CReBar::s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CReBar* prb = (CReBar*) GetWindowPtr(hwnd, 0);

    if (prb)
    {
        LRESULT lres = prb->_WndProc(hwnd, uMsg, wParam, lParam);
        if (uMsg == WM_NCDESTROY)
        {
            SetWindowPtr(hwnd, 0, 0);
            delete prb;
        }
        return lres;
    }
    else if (uMsg == WM_NCCREATE)
    {
        prb = new CReBar();
        if (prb)
        {
            SetWindowPtr(hwnd, 0, prb);
            return prb->_WndProc(hwnd, uMsg, wParam, lParam);
        }
        return FALSE;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CReBar::_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_SETREDRAW:
        _SetRecalc(BOOLFROMPTR(wParam));

        return _SetRedraw(BOOLFROMPTR(wParam));

    case WM_NCCREATE:
        _OnCreate(hwnd, (LPCREATESTRUCT)lParam);
        return TRUE;

    case WM_NCDESTROY:
        _OnDestroy();
        break;

    case WM_CREATE:
        // Do delayed stuff for speed.
        PostMessage(hwnd, RB_PRIV_DODELAYEDSTUFF, 0, 0);
        goto CallDWP;

    case RB_PRIV_DODELAYEDSTUFF:
        // Delay done stuff for speed:

        if (_ci.style & RBS_REGISTERDROP)
            _hDragProxy = CreateDragProxy(_ci.hwnd, s_DragCallback, TRUE);
                
        if (_ci.style & RBS_TOOLTIPS)
        {
            TOOLINFO ti;
            // don't bother setting the rect because we'll do it below
            // in FlushToolTipsMgr;
            ti.cbSize = sizeof(ti);
            ti.uFlags = TTF_IDISHWND;
            ti.hwnd = hwnd;
            ti.uId = (UINT_PTR)hwnd;
            ti.lpszText = 0;

            _hwndToolTips = CreateWindowEx(WS_EX_TRANSPARENT, c_szSToolTipsClass, NULL,
                    WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                    hwnd, NULL, (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE), NULL);

            SendMessage(_hwndToolTips, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO) &ti);
        }
        _InitPaletteHack();
        break;

    case WM_NCHITTEST:
        {
            RBHITTESTINFO rbht;
            int iBand;
            
            rbht.pt.x = GET_X_LPARAM(lParam);
            rbht.pt.y = GET_Y_LPARAM(lParam);
            ScreenToClient(_ci.hwnd, &rbht.pt);

            iBand = _HitTest(&rbht);
            {
                NMMOUSE nm;
                LRESULT lres;
                
                nm.dwItemSpec = iBand;
                nm.pt = rbht.pt;
                nm.dwHitInfo = rbht.flags;
                
                // send to the parent to give them a chance to override
                lres = CCSendNotify(&_ci, NM_NCHITTEST, &nm.hdr);
                if (lres)
                    return lres;
                
            }
        }
        return HTCLIENT;

    case WM_NCCALCSIZE:
        if (_ci.style & WS_BORDER)
        {
            InflateRect((LPRECT) lParam, -g_cxEdge, -g_cyEdge);
            break;
        }
        goto CallDWP;

    case WM_NCPAINT:
        if (_ci.style & WS_BORDER)
        {
            RECT rc;
            HDC hdc;

            GetWindowRect(hwnd, &rc);
            OffsetRect(&rc, -rc.left, -rc.top);
            hdc = GetWindowDC(hwnd);
            if (hdc)
            {
                CCDrawEdge(hdc, &rc, EDGE_ETCHED, BF_RECT, &(_clrsc));
                ReleaseDC(hwnd, hdc);
            }
            break;
        }
        goto CallDWP;

    case WM_PALETTECHANGED:
        if ((HWND)wParam == hwnd)
            break;

    case WM_QUERYNEWPALETTE:
        // Want to pass FALSE if WM_QUERYNEWPALETTE...
        _Realize(NULL, uMsg == WM_PALETTECHANGED, uMsg == WM_PALETTECHANGED);
        return TRUE;

    case WM_PAINT:
    case WM_PRINTCLIENT:
        _OnPaint((HDC)wParam);
        break;

    case WM_ERASEBKGND:
        if (_EraseBkgnd((HDC) wParam, -1))
            return(TRUE);
        goto CallDWP;

    case WM_SYSCOLORCHANGE:
        _InitPaletteHack();

        if (_hwndToolTips)
            SendMessage(_hwndToolTips, uMsg, wParam, lParam);

        InitGlobalColors();
        InvalidateRect(_ci.hwnd, NULL, TRUE);

        break;


    case RB_SETPALETTE:
        return (LRESULT)_SetPalette((HPALETTE)lParam);

    case RB_GETPALETTE:
        return (LRESULT)_hpal;

    case RB_GETBANDMARGINS:
        {
            MARGINS* pMargin = (MARGINS*)lParam;
            if (pMargin)
                *pMargin = _mBand;
            return 1;
        }

    case WM_SIZE:
        _AutoSize();
        _Resize(FALSE);
        break;

    case WM_GETFONT:
        return (LRESULT)_hFont;

    case WM_COMMAND:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_VKEYTOITEM:
    case WM_CHARTOITEM:
        SendMessage(_ci.hwndParent, uMsg, wParam, lParam);
        break;

    case WM_LBUTTONDBLCLK:  // DBLCLK sent in place of LBUTTONDOWN
    case WM_RBUTTONDOWN:    // right button drags too
    case WM_LBUTTONDOWN:
        {
            RBHITTESTINFO rbht;
            PRBB prbb = NULL;

            rbht.pt.x = GET_X_LPARAM(lParam);
            rbht.pt.y = GET_Y_LPARAM(lParam);

            RelayToToolTips(_hwndToolTips, hwnd, uMsg, wParam, lParam);

            int iBand = _HitTest(&rbht);
            if (iBand != -1)
                prbb = _GetBand(iBand);

            if (!prbb)
            {
                /* nothing */ ;
            }
            else if (rbht.flags & RBHT_CHEVRON)
            {
                _OnPushChevron(hwnd, prbb, 0);
            }
            else if (rbht.flags != RBHT_CLIENT && _ShouldDrawGripper(prbb))
            {
                _uCapture = iBand;
                _ptCapture = rbht.pt;
                if (_ci.style & CCS_VERT) 
                    SWAP(_ptCapture.x, _ptCapture.y, int);
                _xStart = prbb->x;
                SetCapture(hwnd);
                _fFullOnDrag = FALSE;

                if (uMsg == WM_LBUTTONDBLCLK && (_ci.style & RBS_DBLCLKTOGGLE))
                    _ToggleBand(TRUE);
            }
        }
        break;

    case WM_SETCURSOR:
        // Give the parent first crack, if it sets the cursor then
        // leave it at that.  Otherwise if the cursor is over our
        // window then set it to what we want it to be.
        if (!DefWindowProc(hwnd, uMsg, wParam, lParam) && (hwnd == (HWND)wParam))
        {
            POINT   pt;
            GetMessagePosClient(_ci.hwnd, &pt);
            _SetCursor(pt.x, pt.y,  (HIWORD(lParam) == WM_LBUTTONDOWN || HIWORD(lParam) == WM_RBUTTONDOWN));
        }
        return TRUE;

    case WM_MOUSEMOVE:
        _OnMouseMove(hwnd, uMsg, wParam, lParam);
        break;

    case WM_RBUTTONUP:
        if (!_fFullOnDrag && !_fParentDrag) {
            CCReleaseCapture(&_ci);

            // if we're not doing drag drop, go to def window proc so that
            // wm_contextmenu gets propagated
            _OnBeginDrag((UINT)-1);
            goto CallDWP;
        }
        // fall through

    case WM_LBUTTONUP:
        RelayToToolTips(_hwndToolTips, hwnd, uMsg, wParam, lParam);

        if (_uCapture != -1)
        {
            UINT uiIndex;

            if (!_fParentDrag)
                CCReleaseCapture(&_ci);
            // if there was no significant mouse motion, treat as a click
            if (!(_ci.style & RBS_DBLCLKTOGGLE) && !_fFullOnDrag)
                _ToggleBand(TRUE);

            _GetBand(_uCapture)->fStyle &= ~RBBS_DRAGBREAK;
            CCSendNotify(&_ci, RBN_LAYOUTCHANGED, NULL);
            _SendNotify(_uCapture, RBN_ENDDRAG);
            _OnBeginDrag((UINT)-1);
            for (uiIndex = 0; uiIndex < _cBands; uiIndex++) {
                if (_GetBand(uiIndex)->fStyle & RBBS_HIDDEN)
                    continue;

                _BandCalcMinWidth(_GetBand(uiIndex));
            }

            _SizeBandsToRect(NULL);
            _InvalidateRect(NULL);
        }
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        if (_fFontCreated)
            _SetFont(wParam);

        if (_hwndToolTips)
            SendMessage(_hwndToolTips, uMsg, wParam, lParam);

        
        for (DWORD dwIndex = 0; dwIndex < _cBands; dwIndex++)
        {
            PRBB prbb = _rbbList + dwIndex;
            SendMessage(prbb->hwndChild, WM_WININICHANGE, wParam, lParam);
        }

        break;

    case WM_SETFONT:
        _OnSetFont((HFONT)wParam);
        break;

    case WM_NOTIFYFORMAT:
        return(CIHandleNotifyFormat(&_ci, lParam));

    case WM_NOTIFY:
        // We are just going to pass this on to the real parent
        // Note that -1 is used as the hwndFrom.  This prevents SendNotifyEx
        // from updating the NMHDR structure.
        return(SendNotifyEx(_ci.hwndParent, (HWND) -1,
                 ((LPNMHDR) lParam)->code, (LPNMHDR) lParam, _ci.bUnicode));

    case WM_STYLECHANGED:
        _OnStyleChanged(wParam, (LPSTYLESTRUCT)lParam);
        break;

    case WM_UPDATEUISTATE:
        if (CCOnUIState(&(_ci), WM_UPDATEUISTATE, wParam, lParam))
        {
            InvalidateRect(hwnd, NULL, TRUE);
        }
        goto CallDWP;

    case RB_SETBANDINFOA:
    case RB_INSERTBANDA:
        if (EVAL(lParam))
        {
            LPWSTR lpStrings = NULL;
            LPSTR  lpAnsiString;
            int    iResult;

            // lParam starts out pointing to a REBARBANDINFOA, and
            // we secretly change it into a REBARBANDINFOW, and then
            // change it back.

            LPREBARBANDINFOW prbiW = (LPREBARBANDINFOW)lParam;
            LPREBARBANDINFOA prbiA = (LPREBARBANDINFOA)lParam;

            COMPILETIME_ASSERT(sizeof(REBARBANDINFOW) == sizeof(REBARBANDINFOA));

            // Bug#94345 - raymondc - Is it safe to modify the incoming
            // REBARBANDINFOA structure?

            lpAnsiString = prbiA->lpText;
            if ((prbiA->fMask & RBBIM_TEXT) && prbiA->lpText) {

                lpStrings = ProduceWFromA(_ci.uiCodePage, lpAnsiString);
                if (!lpStrings)
                    return -1;

                // Presto!  Now it's a REBARBANDINFOW!
                prbiW->lpText = lpStrings;
            }

            if (uMsg == RB_INSERTBANDA)
                iResult = _InsertBand((UINT) wParam, prbiW);
            else
                iResult = _SetBandInfo((UINT) wParam, prbiW, TRUE);

            // Change-o!  Now it's a REBARBANDINFOA!
            prbiA->lpText = lpAnsiString;

            if (lpStrings)
                FreeProducedString(lpStrings);

            return iResult;
        }

    case RB_INSERTBAND:
        return(_InsertBand((UINT) wParam, (LPREBARBANDINFO) lParam));

    case RB_DELETEBAND:
        return(_DeleteBand((UINT) wParam));

    case RB_SHOWBAND:
        return(_ShowBand((UINT) wParam, BOOLFROMPTR(lParam)));

    case RB_GETBANDINFOA:
        {
            LPREBARBANDINFOA prbbi = (LPREBARBANDINFOA)lParam;
            LPWSTR pszW = NULL;
            LPSTR  lpAnsiString = prbbi->lpText;
            int    iResult;

            if (prbbi->fMask & RBBIM_TEXT) {
                pszW = (LPWSTR)LocalAlloc(LPTR, prbbi->cch * sizeof(WCHAR));
                if (!pszW)
                    return 0;
                prbbi->lpText = (LPSTR)pszW;
            }

            iResult = _GetBandInfo((UINT)wParam, (LPREBARBANDINFO)lParam);

            if (pszW) {
                ConvertWToAN(_ci.uiCodePage, lpAnsiString, prbbi->cch, (LPWSTR)prbbi->lpText, -1);
                prbbi->lpText = lpAnsiString;
                LocalFree(pszW);
            }

            return iResult;
        }

        // we have getbandinfoold because in ie3, we did not thunk
        // and getbandinfo always return OS native string (dumb)
    case RB_GETBANDINFOOLD:
    case RB_GETBANDINFO:
        return(_GetBandInfo((UINT) wParam, (LPREBARBANDINFO) lParam));
            
    case RB_GETTOOLTIPS:
        return (LPARAM)_hwndToolTips;
            
    case RB_SETTOOLTIPS:
        _hwndToolTips = (HWND)wParam;
        break;
            
    case RB_SETBKCOLOR:
        {
            COLORREF clr = _clrBk;
            _clrBk = (COLORREF)lParam;
            if (clr != _clrBk)
                InvalidateRect(_ci.hwnd, NULL, TRUE);
            return clr;
        }
            
    case RB_GETBKCOLOR:
        return _clrBk;
            
    case RB_SETTEXTCOLOR:
        {
            COLORREF clr = _clrText;
            _clrText = (COLORREF)lParam;
            return clr;
        }
            
    case RB_GETTEXTCOLOR:
        return _clrText;

    case RB_IDTOINDEX:
        return _IDToIndex((UINT) wParam);

    case RB_GETROWCOUNT:
        return(_GetRowCount());

    case RB_GETROWHEIGHT:
        return _GetRowHeight((UINT)wParam);
        
    case RB_GETBANDBORDERS:
        return _GetBandBorders((UINT)wParam, (LPRECT)lParam);

    case RB_GETBANDCOUNT:
        return(_cBands);

    case RB_SETBANDINFO:
        return(_SetBandInfo((UINT) wParam, (LPREBARBANDINFO) lParam, TRUE));

    case RB_GETBARINFO:
        return(_GetBarInfo((LPREBARINFO) lParam));

    case RB_SETBARINFO:
        return(_SetBarInfo((LPREBARINFO) lParam));

    case RB_SETPARENT:
        {
            HWND hwndOld = _ci.hwndParent;
            _ci.hwndParent = (HWND) wParam;
            return (LRESULT)hwndOld;
        }
        break;

    case RB_GETRECT:
        if (_IsValidIndex((UINT)wParam))
        {
            PRBB prbb = _GetBand((UINT)wParam);
            LPRECT lprc = (LPRECT) lParam;

            lprc->left = prbb->x;
            lprc->top = prbb->y;
            lprc->right = prbb->x + prbb->cx;
            lprc->bottom = prbb->y + prbb->cy;

            return(TRUE);
        }
        break;

    case RB_HITTEST:
        return(_HitTest((LPRBHITTESTINFO) lParam));

    case RB_SIZETORECT:
        return _SizeBarToRect((DWORD)wParam, (LPRECT)lParam);

    case RB_BEGINDRAG:

        if (_IsValidIndex((UINT)wParam)) {
            // -1 means do it yourself.
            // -2 means use what you had saved before
            if (lParam != (LPARAM)-2) {
                if (lParam == (LPARAM)-1) {
                    GetMessagePosClient(_ci.hwnd, &_ptCapture);
                } else {
                    _ptCapture.x = GET_X_LPARAM(lParam);
                    _ptCapture.y = GET_Y_LPARAM(lParam);
                }
                if (_ci.style & CCS_VERT) 
                    SWAP(_ptCapture.x, _ptCapture.y, int);
            }

            _xStart = _GetBand((UINT)wParam)->x;

            _OnBeginDrag((UINT)wParam);
        }
        break;
        
    case RB_GETBARHEIGHT:
        return _GetBarHeight();
        
    case RB_ENDDRAG:
        _OnBeginDrag((UINT)-1);
        break;
        
    case RB_DRAGMOVE:
        if (_uCapture != -1) {
            if (lParam == (LPARAM)-1) {
                lParam = GetMessagePosClient(_ci.hwnd, NULL);
            }
            _DragBand(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        }
        break;
        
    case RB_MINIMIZEBAND:
        _MinimizeBand((UINT) wParam,FALSE);
        break;

    case RB_MAXIMIZEBAND:
        _MaximizeBand((UINT)wParam, BOOLFROMPTR(lParam),FALSE);
        break;

    case RB_MOVEBAND:
        if (!_IsValidIndex((UINT)wParam) || !_IsValidIndex((UINT)lParam))
            break;
        return _MoveBand((UINT) wParam, (UINT) lParam);

    case RB_GETDROPTARGET:
        if (!_hDragProxy)
            _hDragProxy = CreateDragProxy(_ci.hwnd, s_DragCallback, FALSE);

        GetDragProxyTarget(_hDragProxy, (IDropTarget**)lParam);
        break;

    case RB_GETCOLORSCHEME:
        {
            LPCOLORSCHEME lpclrsc = (LPCOLORSCHEME) lParam;
            if (lpclrsc) {
                if (lpclrsc->dwSize == sizeof(COLORSCHEME))
                    *lpclrsc = _clrsc;
            }
            return (LRESULT) lpclrsc;
        }

    case RB_SETCOLORSCHEME:
        if (lParam) {
            if (((LPCOLORSCHEME) lParam)->dwSize == sizeof(COLORSCHEME)) {
                _clrsc.clrBtnHighlight = ((LPCOLORSCHEME) lParam)->clrBtnHighlight;
                _clrsc.clrBtnShadow = ((LPCOLORSCHEME) lParam)->clrBtnShadow;        
                InvalidateRect(hwnd, NULL, FALSE);
                if (_ci.style & WS_BORDER)
                    CCInvalidateFrame(hwnd);
            }
        }
        break;

    case RB_PUSHCHEVRON:
        if (_IsValidIndex((UINT)wParam)) {
            PRBB prbb = _GetBand((UINT)wParam);
            _OnPushChevron(hwnd, prbb, lParam);
        }
        break;

    case RB_SETWINDOWTHEME:
        if (lParam)
        {
            SetWindowTheme(hwnd, (LPWSTR)lParam, NULL);
        }
        break;

    case WM_THEMECHANGED:
        _CacheThemeInfo((BOOL)wParam);

        InvalidateRect(_ci.hwnd, NULL, TRUE);
        return 0;

    default:
        LRESULT lres;
        if (CCWndProc(&_ci, uMsg, wParam, lParam, &lres))
            return lres;
        
CallDWP:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\selrange.h ===
//-------------------------------------------------------------------
//
// File: SelRange.h
//
// Contents:
//    This file contians Selection Range handling definitions.
//
// History:
//    14-Oct-94   MikeMi   Created
//
//-------------------------------------------------------------------

#ifndef __SELRANGE_H__
#define __SELRANGE_H__

#include <windows.h>
#include <limits.h>

#define SELRANGE_MINVALUE  0
#define SELRANGE_MAXVALUE  LONG_MAX - 2
#define SELRANGE_ERROR      LONG_MAX



typedef HANDLE HSELRANGE;

#ifdef __cplusplus
extern "C"
{
#endif

ILVRange *LVRange_Create( );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\scdttime.c ===
#include "ctlspriv.h"
#include "scdttime.h"

int mpcdymoAccum[13] =
{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };

/*
 -    LIncrWord
 -
 *    Purpose:
 *        Increment (or decrement) an integer by a specified amount,
 *        given the constraints nMic and nMac.
 *        Returns the amount of carry into the following (or preceding)
 *        field, or zero if none.
 *
 *        Intended for use with incrementing date/times.
 *
 *    Arguments:
 *        pn        Pointer to integer to be modified.
 *        nDelta    Amount by which to modify *pn; may be positive,
 *                negative or zero.
 *        nMic    Minimum value for *pn;  if decrementing below this,
 *                a carry is performed.
 *        nMac    Maximum value for *pn;  if incrementing above this,
 *                a carry is performed.
 *
 *    Returns:
 *        Zero if modification done within constraints, otherwise the
 *        amount of carry (positive in incrementing, negative if
 *        decrementing).
 *
 */
LONG LIncrWord(WORD *pn, LONG nDelta, int nMic, int nMac)
    {
    LONG lNew, lIncr;

    lIncr = 0;
    lNew = *pn + nDelta;

    while (lNew >= nMac)
        {
        lNew -= nMac - nMic;
        lIncr++;
        }

    if (!lIncr)
        {
        while (lNew < nMic)
            {
            lNew += nMac - nMic;
            lIncr--;
            }
        }

    *pn = (WORD)lNew;

    return(lIncr);
    }

void IncrSystemTime(SYSTEMTIME *pstSrc, SYSTEMTIME *pstDest, LONG nDelta, LONG flag)
    {
    int cdyMon;

    if (pstSrc != pstDest)
        *pstDest = *pstSrc;

    switch (flag)
        {
        case INCRSYS_SECOND:
            if (!(nDelta = LIncrWord(&pstDest->wSecond, nDelta, 0, 60)))
                break;

        case INCRSYS_MINUTE:
            if (!(nDelta = LIncrWord(&pstDest->wMinute, nDelta, 0, 60)))
                break;

        case INCRSYS_HOUR:
            if (!(nDelta = LIncrWord(&pstDest->wHour, nDelta, 0, 24)))
                break;

        case INCRSYS_DAY:
IDTday:
            if (nDelta >= 0)
                {
                cdyMon = GetDaysForMonth(pstDest->wYear, pstDest->wMonth);
                while (pstDest->wDay + nDelta > cdyMon)
                    {
                    nDelta -= cdyMon + 1 - pstDest->wDay;
                    pstDest->wDay = 1;
                    IncrSystemTime(pstDest, pstDest, 1, INCRSYS_MONTH);
                    cdyMon = GetDaysForMonth(pstDest->wYear, pstDest->wMonth);
                    }
                }
            else
                {
                while (pstDest->wDay <= -nDelta)
                    {
                    nDelta += pstDest->wDay;
                    IncrSystemTime(pstDest, pstDest, -1, INCRSYS_MONTH);
                    cdyMon = GetDaysForMonth(pstDest->wYear, pstDest->wMonth);
                    pstDest->wDay = (WORD) cdyMon;
                    }
                }

            pstDest->wDay += (WORD)nDelta;
            break;

        case INCRSYS_MONTH:
            if (!(nDelta = LIncrWord(&pstDest->wMonth, nDelta, 1, 13)))
                {
                cdyMon = GetDaysForMonth(pstDest->wYear, pstDest->wMonth);
                if (pstDest->wDay > cdyMon)
                    pstDest->wDay = (WORD) cdyMon;
                break;
                }

        case INCRSYS_YEAR:
            pstDest->wYear += (WORD)nDelta;
            cdyMon = GetDaysForMonth(pstDest->wYear, pstDest->wMonth);
            if (pstDest->wDay > cdyMon)
                pstDest->wDay = (WORD) cdyMon;
            break;

        case INCRSYS_WEEK:
            nDelta *= 7;
            goto IDTday;
            break;
        }
    }

CmpDate(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
    {
    int iRet;

    if (pst1->wYear < pst2->wYear)
        iRet = -1;
    else if (pst1->wYear > pst2->wYear)
        iRet = 1;
    else if (pst1->wMonth < pst2->wMonth)
        iRet = -1;
    else if (pst1->wMonth > pst2->wMonth)
        iRet = 1;
    else if (pst1->wDay < pst2->wDay)
        iRet = -1;
    else if (pst1->wDay > pst2->wDay)
        iRet = 1;
    else
        iRet = 0;

    return(iRet);
    }

CmpSystemtime(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
    {
    int iRet;

    if (pst1->wYear < pst2->wYear)
        iRet = -1;
    else if (pst1->wYear > pst2->wYear)
        iRet = 1;
    else if (pst1->wMonth < pst2->wMonth)
        iRet = -1;
    else if (pst1->wMonth > pst2->wMonth)
        iRet = 1;
    else if (pst1->wDay < pst2->wDay)
        iRet = -1;
    else if (pst1->wDay > pst2->wDay)
        iRet = 1;
    else if (pst1->wHour < pst2->wHour)
        iRet = -1;
    else if (pst1->wHour > pst2->wHour)
        iRet = 1;
    else if (pst1->wMinute < pst2->wMinute)
        iRet = -1;
    else if (pst1->wMinute > pst2->wMinute)
        iRet = 1;
    else if (pst1->wSecond < pst2->wSecond)
        iRet = -1;
    else if (pst1->wSecond > pst2->wSecond)
        iRet = 1;
    else
        iRet = 0;

    return(iRet);
    }

/*
 -    CdyBetweenYmd
 -
 *    Purpose:
 *        Calculate the number of days between two dates as expressed
 *        in YMD's.
 *
 *    Parameters:
 *        pymdStart        start day of range.
 *        pymdEnd            end day of range.
 *
 *    Returns:
 *        Number of days between two dates.  The number
 *        of days does not include the starting day, but does include
 *        the last day. ie 1/24/1990-1/25/1990 = 1 day.
 */
DWORD DaysBetweenDates(const SYSTEMTIME *pstStart, const SYSTEMTIME *pstEnd)
    {
    DWORD cday;
    WORD yr;

    // Calculate number of days between the start month/day and the
    // end month/day as if they were in the same year - since cday
    // is unsigned, cday could be really large if the end month/day
    // is before the start month.day.
    // This will be cleared up when we account for the days between
    // the years.
    ASSERT(pstEnd->wMonth >= 1 && pstEnd->wMonth <= 12);
    cday = mpcdymoAccum[pstEnd->wMonth - 1] - mpcdymoAccum[pstStart->wMonth - 1] +
             pstEnd->wDay - pstStart->wDay;
    yr = pstStart->wYear;

    // Check to see if the start year is before the end year,
    // and if the end month is after February and
    // if the end year is a leap year, then add an extra day
    // for to account for Feb. 29 in the end year.
    if ( ((yr < pstEnd->wYear) || (pstStart->wMonth <= 2)) &&
         pstEnd->wMonth > 2 &&
        (pstEnd->wYear & 03) == 0 &&
        (pstEnd->wYear <= 1750 || pstEnd->wYear % 100 != 0 || pstEnd->wYear % 400 == 0))
        {
        cday++;
        }

    // Now account for the leap years in between the start and end dates
    // as well as accounting for the days in each year.
    if (yr < pstEnd->wYear)
        {
        // If the start date is before march and the start year is
        // a leap year then add an extra day to account for Feb. 29.
        if ( pstStart->wMonth <= 2 &&
            (yr & 03) == 0 &&
            (yr <= 1750 || yr % 100 != 0 || yr % 400 == 0))
            {
            cday++;
            }

        // Account for the days in each year (disregarding leap years).
        cday += 365;
        yr++;

        // Keep on accounting for the days in each year including leap
        // years until we reach the end year.
        while (yr < pstEnd->wYear)
            {
            cday += 365;
            if ((yr & 03) == 0 && (yr <= 1750 || yr % 100 != 0 || yr % 400 == 0))
                cday++;
            yr++;
            }
        }

    return(cday);
    }

/*
 -    DowStartOfYrMo
 -
 *    Purpose:
 *        Find the day of the week the indicated month begins on
 *
 *    Parameters:
 *        yr        year, must be > 0
 *        mo        month, number 1-12
 *
 *    Returns:
 *        day of the week (0-6) on which the month begins
 *        (0 = Sunday, 1 = Monday etc.)
 */
int GetStartDowForMonth(int yr, int mo)
    {
    int dow;

    // we want monday = 0, sunday = 6
    // dow = 6 + (yr - 1) + ((yr - 1) >> 2);
    dow = 5 + (yr - 1) + ((yr - 1) >> 2);
    if (yr > 1752)
        dow += ((yr - 1) - 1600) / 400 - ((yr - 1) - 1700) / 100 - 11;
    else if (yr == 1752 && mo > 9)
        dow -= 11;
    dow += mpcdymoAccum[mo - 1];
    if (mo > 2 && (yr & 03) == 0 && (yr <= 1750 || yr % 100 != 0 || yr % 400 == 0))
        dow++;
    dow %= 7;

    return(dow);
    }

int DowFromDate(const SYSTEMTIME *pst)
    {
    int dow;

    dow = GetStartDowForMonth(pst->wYear, pst->wMonth);
    dow = (dow + pst->wDay - 1) % 7;

    return(dow);
    }

int GetDaysForMonth(int yr, int mo)
    {
    int cdy;

    if (yr == 1752 && mo == 9)
        return(19);
    cdy = mpcdymoAccum[mo] - mpcdymoAccum[mo - 1];
    if (mo == 2 && (yr & 03) == 0 && (yr <= 1750 || yr % 100 != 0 || yr % 400 == 0))
        cdy++;

    return(cdy);
    }

/*
 -    NweekNumber
 -
 *    Purpose:
 *        Calculates week number in which a given date occurs, based
 *        on a specified start-day of week.
 *        Adjusts based on how a calendar would show this week
 *        (ie. week 53 is probably week 1 on the calendar).
 *
 *    Arguments:
 *        pdtm            Pointer to date in question
 *        dowStartWeek    Day-of-week on which weeks starts (0 - 6).
 *
 *    Returns:
 *        Week number of the year, in which *pdtr occurs.
 *
 */
// TODO: this currently ignores woyFirst
// it uses the 1st week containing 4+ days as the first week (woyFirst = 2)
// need to make appropriate changes so it handles woyFirst = 0 and = 1...
int GetWeekNumber(const SYSTEMTIME *pst, int dowFirst, int woyFirst)
    {
    int day, ddow, ddowT, nweek;
    SYSTEMTIME st;
    
    st.wYear = pst->wYear;
    st.wMonth = 1;
    st.wDay = 1;

    ddow = GetStartDowForMonth(st.wYear, st.wMonth) - dowFirst;
    if (ddow < 0)
        ddow += 7;

    if (pst->wMonth == 1 && pst->wDay < 8 - ddow)
        {
        nweek = 0;
        }
    else
        {
        if (ddow)
            st.wDay = 8 - ddow;

        nweek = (DaysBetweenDates(&st, pst) / 7) + 1;
        }
    if (ddow && ddow <= 3)
        nweek++;

    // adjust if necessary for calendar
    if (!nweek)
        {
        if (!ddow)
            return(1);

        // check what week Dec 31 is on
        st.wYear--;
        st.wMonth = 12;
        st.wDay = 31;
        return(GetWeekNumber(&st, dowFirst, woyFirst));
        }
    else if (nweek >= 52)
        {
        ddowT = (GetStartDowForMonth(pst->wYear, pst->wMonth) +
                    pst->wDay - 1 + 7 -    dowFirst) % 7;
        day = pst->wDay + (7 - ddowT);
        if (day > 31 + 4)
            nweek = 1;
        }

    return(nweek);
    }

// ignores day of week and time-related fields...
BOOL IsValidDate(const SYSTEMTIME *pst)
    {
    int cDay;

    if (pst && pst->wMonth >= 1 && pst->wMonth <= 12)
        {
        cDay = GetDaysForMonth(pst->wYear, pst->wMonth);
        if (pst->wDay >= 1 && pst->wDay <= cDay)
            return(TRUE);
        }
    return(FALSE);
    }

// ignores milliseconds and date-related fields...
BOOL IsValidTime(const SYSTEMTIME *pst)
    {
    return(pst->wHour <= 23 &&
            pst->wMinute <= 59 &&
            pst->wSecond <= 59);
    }

// ignores day of week
BOOL IsValidSystemtime(const SYSTEMTIME *pst)
    {
    if (pst && pst->wMonth >= 1 && pst->wMonth <= 12)
        {
        int cDay = GetDaysForMonth(pst->wYear, pst->wMonth);
        if (pst->wDay >= 1 &&
            pst->wDay <= cDay &&
            pst->wHour <= 23 &&
            pst->wMinute <= 59 &&
            pst->wSecond <= 59 &&
            pst->wMilliseconds < 1000)
            return(TRUE);
        }
    return(FALSE);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\rlefile.h ===
//
//  handle AVI RLE files with custom code.
//
//  use this code to deal with .AVI files without the MCIAVI runtime
//
//  restrictions:
//
//          AVI file must be a native DIB format (RLE or none)
//          AVI file must fit into memory.
//

#define FOURCC DWORD
#if defined(WIN32) && !defined(WINNT)
#include <vfw.h>
#else
// HACK to build for now under NT
#include <avifmt.h>
#endif

#ifdef WIN32
#define PTR
#else
#define PTR _huge   /* or */
#endif

typedef struct _RLEFILE {
    int                 NumFrames;      // number of frames
    int                 Width;          // width in pixels
    int                 Height;         // height in pixels
    int                 Rate;           // mSec per frame

    HPALETTE            hpal;           // palete for drawing

    HANDLE              hRes;           // resource handle
    LPVOID              pFile;          // bits of file.

    int                 iFrame;         // current frame
    int                 iKeyFrame;      // nearest key
    int                 nFrame;         // index pos of frame.
    LPVOID              pFrame;         // current frame data
    DWORD               cbFrame;        // size in bytes of frame

    DWORD               FullSizeImage;  // full-frame size
    BITMAPINFOHEADER    bi;             // DIB format
    DWORD               rgbs[256];      // the colors
    MainAVIHeader PTR  *pMainHeader;    // main header
    int                 iStream;        // stream number of video
    AVIStreamHeader PTR*pStream;        // video stream
    LPBITMAPINFOHEADER  pFormat;        // format of video stream
    LPVOID              pMovie;         // movie chunk
    UNALIGNED AVIINDEXENTRY PTR * pIndex; // master index
    COLORREF            clrKey;

}   RLEFILE;

extern BOOL RleFile_OpenFromFile(RLEFILE *prle, LPCTSTR szFile);
extern BOOL RleFile_OpenFromResource(RLEFILE *prle, HINSTANCE hInstance, LPCTSTR szName, LPCTSTR szType);
extern BOOL RleFile_Close(RLEFILE  *prle);
extern BOOL RleFile_SetColor(RLEFILE  *prle, int iColor, COLORREF rgb);
extern BOOL RleFile_ChangeColor(RLEFILE  *prle, COLORREF rgbS, COLORREF rgbD);
extern BOOL RleFile_Seek(RLEFILE  *prle, int iFrame);
extern BOOL RleFile_Paint(RLEFILE  *prle, HDC hdc, int iFrame, int x, int y);
extern BOOL RleFile_Draw(RLEFILE  *prle, HDC hdc, int iFrame, int x, int y);

#define RleFile_New()       ((RLEFILE *)LocalAlloc(LPTR, sizeof(RLEFILE)))
#define RleFile_Free(pavi)  (RleFile_Close(pavi), LocalFree((HLOCAL)(pavi)))

#define RleFile_NumFrames(prle)     ((prle)->NumFrames)
#define RleFile_Width(prle)         ((prle)->Width)
#define RleFile_Height(prle)        ((prle)->Height)
#define RleFile_Rate(prle)          ((prle)->Rate)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\rlefile.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  handle AVI RLE files with custom code.
//
//  use this code to deal with .AVI files without the MCIAVI runtime
//
//  restrictions:
//          AVI file must be a simple DIB format (RLE or none)
//          AVI file must fit into memory.
//
//  ToddLa
//
//////////////////////////////////////////////////////////////////////////


#include "ctlspriv.h"
extern "C" 
{
#include "rlefile.h"
}
#include <lendian.hpp>

extern "C"
BOOL RleFile_Init(RLEFILE *prle, LPVOID pFile, HANDLE hRes, DWORD dwFileLen);

//////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////

LPVOID LoadFile(LPCTSTR szFile, DWORD * pFileLength)
{
    LPVOID pFile;
    HANDLE hFile;
    HANDLE h;
    DWORD  FileLength;

    hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

    if (hFile == INVALID_HANDLE_VALUE)
        return 0;

    FileLength = (LONG)GetFileSize(hFile, NULL);

    if (pFileLength)
       *pFileLength = FileLength ;

    h = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!h)
    {
        CloseHandle(hFile);
        return 0;
    }

    pFile = MapViewOfFile(h, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(hFile);
    CloseHandle(h);

    if (pFile == NULL)
        return 0;

    return pFile;
}


//////////////////////////////////////////////////////////////////////////
//
//  RleFile_OpenFromFile
//
//  load a .AVI file into memory and setup all of our pointers so we
//  know how to deal with it.
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_OpenFromFile(RLEFILE *prle, LPCTSTR szFile)
{
    DWORD dwFileLen;
    LPVOID pFile;

    // MAKEINTRESOURCE() things can't come from files
    if (IS_INTRESOURCE(szFile))	
	return FALSE;

    if (pFile = LoadFile(szFile, &dwFileLen))
        return RleFile_Init(prle, pFile, NULL, dwFileLen);
    else
        return FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_OpenFromResource
//
//  load a .AVI file into memory and setup all of our pointers so we
//  know how to deal with it.
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_OpenFromResource(RLEFILE *prle, HINSTANCE hInstance, LPCTSTR szName, LPCTSTR szType)
{
    HRSRC h;
    HANDLE hRes;

    // not a MAKEINTRESOURCE(), and points to NULL
    if (!IS_INTRESOURCE(szName) && (*szName == 0))
        return FALSE;

    h = FindResource(hInstance, szName, szType);

    if (h == NULL)
        return FALSE;

    if (hRes = LoadResource(hInstance, h))
        return RleFile_Init(prle, LockResource(hRes), hRes, 0);
    else
        return FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_Close
//
//  nuke all stuff we did to open the file.
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_Close(RLEFILE *prle)
{
    if (prle->hpal)
        DeleteObject(prle->hpal);

    if (prle->pFile)
    {
        if (prle->hRes)
        {
            FreeResource(prle->hRes);
        }
        else
            UnmapViewOfFile(prle->pFile);
    }

    prle->hpal = NULL;
    prle->pFile = NULL;
    prle->hRes = NULL;
    prle->pMainHeader = NULL;
    prle->pStream = NULL;
    prle->pFormat = NULL;
    prle->pMovie = NULL;
    prle->pIndex = NULL;
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_Init
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_Init(RLEFILE *prle, LPVOID pFile, HANDLE hRes, DWORD dwFileLen)
{
    DWORD_LENDIAN UNALIGNED *pdw;
    DWORD_LENDIAN UNALIGNED *pdwEnd;
    DWORD dwRiff;
    DWORD dwType;
    DWORD dwLength;
    int stream;

    if (prle->pFile == pFile)
        return TRUE;

    RleFile_Close(prle);
    prle->pFile = pFile;
    prle->hRes = hRes;

    if (prle->pFile == NULL)
        return FALSE;

    //
    //  now that the file is in memory walk the memory image filling in
    //  interesting stuff.
    //
    pdw = (DWORD_LENDIAN UNALIGNED *)prle->pFile;
    dwRiff = *pdw++;
    dwLength = *pdw++;
    dwType = *pdw++;

    if ((dwFileLen > 0) && (dwLength > dwFileLen)) 
    {
        // File is physically shorter than the length written in its header.
        // Can't handle it.
        goto exit;
    }

    if (dwRiff != mmioFOURCC('R', 'I', 'F', 'F'))
        goto exit;      // not even a RIFF file

    if (dwType != formtypeAVI)
        goto exit;      // not a AVI file

    pdwEnd = (DWORD_LENDIAN UNALIGNED *)((BYTE PTR *)pdw + dwLength-4);
    stream = 0;

    while (pdw < pdwEnd)
    {
        dwType = *pdw++;
        dwLength = *pdw++;

        switch (dwType)
        {
            case mmioFOURCC('L', 'I', 'S', 'T'):
                dwType = *pdw++;
                dwLength -= 4;

                switch (dwType)
                {
                    case listtypeAVIMOVIE:
                        prle->pMovie = (LPVOID)pdw;
                        break;

                    case listtypeSTREAMHEADER:
                    case listtypeAVIHEADER:
                        dwLength = 0;           // decend
                        break;

                    default:
                        break;                  // ignore
                }
                break;

            case ckidAVIMAINHDR:
            {
                prle->pMainHeader = (MainAVIHeader PTR *)pdw;
                prle->NumFrames = (int)prle->pMainHeader->dwTotalFrames;
                prle->Width     = (int)prle->pMainHeader->dwWidth;
                prle->Height    = (int)prle->pMainHeader->dwHeight;
                prle->Rate      = (int)(prle->pMainHeader->dwMicroSecPerFrame/1000);

                if (prle->pMainHeader->dwInitialFrames != 0)
                    goto exit;

                if (prle->pMainHeader->dwStreams > 2)
                    goto exit;

            }
                break;

            case ckidSTREAMHEADER:
            {
                stream++;

                if (prle->pStream != NULL)
                    break;

                if (((AVIStreamHeader PTR *)pdw)->fccType != streamtypeVIDEO)
                    break;
                prle->iStream = stream-1;

                prle->pStream = (AVIStreamHeader PTR*)pdw;
                if (prle->pStream->dwFlags & AVISF_VIDEO_PALCHANGES)
                    goto exit;
            }
            break;

            case ckidSTREAMFORMAT:
                if (prle->pFormat != NULL)
                    break;

                if (prle->pStream == NULL)
                    break;

                prle->pFormat = (LPBITMAPINFOHEADER)pdw;

                if (prle->pFormat->biSize != sizeof(BITMAPINFOHEADER))
                    goto exit;

                if (prle->pFormat->biCompression != 0 &&
                    prle->pFormat->biCompression != BI_RLE8)
                    goto exit;

                if (prle->pFormat->biWidth != prle->Width)
                    goto exit;

                if (prle->pFormat->biHeight != prle->Height)
                    goto exit;

                hmemcpy(&prle->bi, prle->pFormat, dwLength);
                prle->bi.biSizeImage = 0;
                prle->FullSizeImage = ((prle->bi.biWidth * prle->bi.biBitCount + 31) & ~31)/8U * prle->bi.biHeight;
                break;

            case ckidAVINEWINDEX:
                // we dont convert indexes because we dont know how many there are
                // but we will have to convert each usage of it
                prle->pIndex = (AVIINDEXENTRY PTR *)pdw;
                break;
        }

        pdw = (DWORD_LENDIAN *)((BYTE PTR *)pdw + ((dwLength+1)&~1));
    }

    //
    //  if the file has nothing in it we care about get out, note
    //  we dont need a index, we do need some data though.
    //
    if (prle->NumFrames == 0 ||
        prle->pMainHeader == NULL ||
        prle->pStream == NULL ||
        prle->pFormat == NULL ||
        prle->pMovie == NULL )
    {
        goto exit;
    }

    //
    //  if we cared about a palette we would create it here.
    //

    //
    //  file open'ed ok seek to the first frame.
    //
    prle->iFrame = -42;
    RleFile_Seek(prle, 0);
    return TRUE;

exit:
    RleFile_Close(prle);
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_ChangeColor
//
//  change the color table of the AVI
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_ChangeColor(RLEFILE *prle, COLORREF rgbS, COLORREF rgbD)
{
    prle->clrKey = rgbS;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_Seek
//
//  find the data for the specifed frame.
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_Seek(RLEFILE *prle, int iFrame)
{
    int n;

    if (prle == NULL || prle->pMovie == NULL)
        return FALSE;

    if (iFrame >= prle->NumFrames)
        return FALSE;

    if (iFrame < 0)
        return FALSE;

    if (iFrame == prle->iFrame)
        return TRUE;

    if (prle->iFrame >= 0 && prle->iFrame < iFrame)
    {
        n = prle->nFrame;       // start where you left off last time
    }
    else
    {
        n = -1;                 // start at the begining
        prle->iFrame = -1;      // current frame
        prle->iKeyFrame = 0;    // current key
    }

    while (prle->iFrame < iFrame)
    {
        n++;
        if (StreamFromFOURCC(*(DWORD_LENDIAN UNALIGNED *)(&prle->pIndex[n].ckid)) == (UINT)prle->iStream)
        {
            prle->iFrame++;         // new frame

            if ((long)(*(DWORD_LENDIAN UNALIGNED *)(&prle->pIndex[n].dwFlags)) & AVIIF_KEYFRAME)
                prle->iKeyFrame = prle->iFrame;     /* // new key frame */
        }
    }

    prle->nFrame = n;
/* warning this points to bitmap bits in wintel format ! */
    prle->pFrame = (BYTE PTR *)prle->pMovie +
	(int)(*(DWORD_LENDIAN UNALIGNED *)(&prle->pIndex[n].dwChunkOffset)) + 4;
    prle->cbFrame = *(DWORD_LENDIAN UNALIGNED *)(&prle->pIndex[n].dwChunkLength);

    ASSERT( (DWORD)(*(DWORD_LENDIAN UNALIGNED *)&(((DWORD PTR *)prle->pFrame)[-1])) == (DWORD)prle->cbFrame);
    ASSERT( (DWORD)(*(DWORD_LENDIAN UNALIGNED *)&(((DWORD PTR *)prle->pFrame)[-2])) == (DWORD)*(DWORD_LENDIAN UNALIGNED *)(&prle->pIndex[n].ckid));

    prle->bi.biSizeImage = prle->cbFrame;

    if (prle->cbFrame == prle->FullSizeImage)
        prle->bi.biCompression = 0;
    else
        prle->bi.biCompression = BI_RLE8;
		
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_Paint
//
//  draw the specifed frame, makes sure the entire frame is updated
//  dealing with non-key frames correctly.
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_Paint(RLEFILE *prle, HDC hdc, int iFrame, int x, int y)
{
    int i;
    BOOL f;

    if (prle == NULL || prle->pMovie == NULL)
        return FALSE;

    if (f = RleFile_Seek(prle, iFrame))
    {
        HDC h = CreateCompatibleDC(hdc);
        if (h)
        {
            HBITMAP hbmp = CreateCompatibleBitmap(hdc, prle->Width, prle->Height);
            if (hbmp)
            {
                HBITMAP hbmpOld = (HBITMAP)SelectObject(h, hbmp);

                iFrame = prle->iFrame;

                for (i=prle->iKeyFrame; i<=iFrame; i++)
                    RleFile_Draw(prle, h, i, 0, 0);

                GdiTransparentBlt(hdc, x, y, prle->Width, prle->Height, h,
                        0, 0, prle->Width, prle->Height, prle->clrKey);

                SelectObject(h, hbmpOld);
                DeleteObject(hbmp);
            }

            DeleteDC(h);
        }
    }

    return f;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_Draw
//
//  draw the data for a specifed frame
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_Draw(RLEFILE *prle, HDC hdc, int iFrame, int x, int y)
{
    BOOL f;

    if (prle == NULL || prle->pMovie == NULL)
        return FALSE;

    if (prle->hpal)
    {
        SelectPalette(hdc, prle->hpal, FALSE);
        RealizePalette(hdc);
    }

    if (f = RleFile_Seek(prle, iFrame))
    {
        if (prle->cbFrame > 0)
        {
                StretchDIBits(hdc,
                        x, y, prle->Width, prle->Height,
                        0, 0, prle->Width, prle->Height,
                        prle->pFrame, (LPBITMAPINFO)&prle->bi,
                        DIB_RGB_COLORS, SRCCOPY);

        }
    }

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\scroll.h ===
#ifndef __SBCTL_H__
#define __SBCTL_H__

//---------------------------------------------------------------------------
//  This is the scrollbar control code. Shouldn't
//  need to open non-client scrollbar theme
#define OpenNcThemeData(hwnd, lpszName)     NULL

#define THEMEATOM_SCROLLBAR g_atomThemeScrollBar

#define GetThemeAtom(x)     (x)

#undef RECTWIDTH
#undef RECTHEIGHT
#define RECTWIDTH(prc) ((prc)->right - (prc)->left)
#define RECTHEIGHT(prc) ((prc)->bottom - (prc)->top)

//---------------------------------------------------------------------------
//  Window scroll bar methods
void    WINAPI DrawSizeBox( HWND, HDC, int x, int y);
void    WINAPI DrawScrollBar( HWND, HDC, BOOL fVert);
void    WINAPI HandleScrollCmd( HWND hwnd, WPARAM wParam, LPARAM lParam );
void    WINAPI DetachScrollBars( HWND hwnd );
void    WINAPI AttachScrollBars( HWND hwnd );
LONG    WINAPI ThemeSetScrollInfo( HWND, int, LPCSCROLLINFO, BOOL );
BOOL    WINAPI ThemeGetScrollInfo( HWND, int, LPSCROLLINFO );
BOOL    WINAPI ThemeEnableScrollBar( HWND, UINT, UINT );

//---------------------------------------------------------------------------
inline void MIRROR_POINT( IN const RECT& rcWindow, IN OUT POINT& pt )
{
    pt.x = rcWindow.right + rcWindow.left - pt.x;
}

#endif  //__SBCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\srcc.inc ===
!include ..\comctl32.inc
SOURCES_USED    = $(SOURCES_USED) ..\comctl32.inc

TARGETNAME      = srcc
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = ..\animate.c   \
                  ..\button.c    \
                  ..\combo.c     \
                  ..\combodir.c  \
                  ..\comboex.c   \
                  ..\comboini.c  \
                  ..\commctrl.c  \
                  ..\cstrings.c  \
                  ..\cutils.c    \
                  ..\da.c        \
                  ..\draglist.c  \
                  ..\edit.c      \
                  ..\editml.c    \
                  ..\editrare.c  \
                  ..\editsl.c    \
                  ..\flat_sb.c   \
                  ..\header.c    \
                  ..\hotkey.c    \
                  ..\image.cpp   \
                  ..\imagestream.cpp\
                  ..\ipaddr.c    \
                  ..\listbox.c   \
                  ..\listbox_ctl1.c \
                  ..\listbox_ctl2.c \
                  ..\listbox_ctl3.c \
                  ..\listview.c  \
                  ..\lvicon.c    \
                  ..\lvlist.c    \
                  ..\lvrept.c    \
                  ..\lvsmall.c   \
                  ..\lvtile.c    \
                  ..\mem.c       \
                  ..\menuhelp.c  \
                  ..\mirror.c    \
                  ..\monthcal.c  \
                  ..\mru.c       \
                  ..\notify.c    \
                  ..\os.c        \
                  ..\progress.c  \
                  ..\prsht.c     \
                  ..\prpage.c    \
                  ..\reader.c    \
                  ..\readermode.c \
                  ..\scdttime.c  \
                  ..\static.c    \
                  ..\status.c    \
                  ..\strings.c   \
                  ..\subclass.c  \
                  ..\treeview.c  \
                  ..\tab.c       \
                  ..\tbcust.c    \
                  ..\thunk.c     \
                  ..\trackbar.c  \
                  ..\tvmem.c     \
                  ..\tvpaint.c   \
                  ..\tvscroll.c  \
                  ..\updown.c    \
                  ..\usrctl32.c
 
PRECOMPILED_INCLUDE = ..\ctlspriv.h
PRECOMPILED_PCH = ctlspriv.pch
PRECOMPILED_OBJ = ctlspriv.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\selrange.cpp ===
//-------------------------------------------------------------------
//
// File: SelRange.cpp
//
// Contents:
//      This file contians Selection Range handling code.
//
//-------------------------------------------------------------------

#include "ctlspriv.h"
#include "selrange.h"
#include "stdio.h"
#include <shguidp.h>

#define MINCOUNT 6      // number of sel ranges to start with amd maintain
#define GROWSIZE 150    // percent to grow when needed

#define COUNT_SELRANGES_NONE 2     // When count of selranges really means none

typedef struct tag_SELRANGEITEM
{
    LONG iBegin;
    LONG iEnd;
} SELRANGEITEM, *PSELRANGEITEM;


class CLVRange : public ILVRange

{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** ILVRange methods ***
    STDMETHODIMP IncludeRange(LONG iBegin, LONG iEnd);
    STDMETHODIMP ExcludeRange(LONG iBegin, LONG iEnd);    
    STDMETHODIMP InvertRange(LONG iBegin, LONG iEnd);
    STDMETHODIMP InsertItem(LONG iItem);
    STDMETHODIMP RemoveItem(LONG iItem);

    STDMETHODIMP Clear();
    STDMETHODIMP IsSelected(LONG iItem);
    STDMETHODIMP IsEmpty();
    STDMETHODIMP NextSelected(LONG iItem, LONG *piItem);
    STDMETHODIMP NextUnSelected(LONG iItem, LONG *piItem);
    STDMETHODIMP CountIncluded(LONG *pcIncluded);

protected:
    // Helper Functions.
    friend ILVRange *LVRange_Create();
                CLVRange();
                ~CLVRange();

    BOOL        _Enlarge();
    BOOL        _Shrink();
    BOOL        _InsertRange(LONG iAfterItem, LONG iBegin, LONG iEnd);
    HRESULT     _RemoveRanges(LONG iStartItem, LONG iStopItem, LONG *p);
    BOOL        _FindValue(LONG Value, LONG* piItem);
    void        _InitNew();

    int           _cRef;
    PSELRANGEITEM _VSelRanges;  // Vector of sel ranges
    LONG          _cSize;       // size of above vector in sel ranges
    LONG          _cSelRanges;  // count of sel ranges used
    LONG          _cIncluded;   // Count of Included items...
};

//-------------------------------------------------------------------
//
// Function: _Enlarge
//
// Summary:
//      This will enlarge the number of items the Sel Range can have.
//
// Arguments:
//      PSELRANGE [in]  - SelRange to Enlarge
//
// Return: FALSE if failed.
//
// Notes: Though this function may fail, pselrange structure is still valid
//
// History:
//      17-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL CLVRange::_Enlarge()
{
    LONG cNewSize;
    PSELRANGEITEM pTempSelRange;
    BOOL frt = FALSE;


    cNewSize = _cSize * GROWSIZE / 100;
    pTempSelRange = (PSELRANGEITEM) GlobalReAlloc( (HGLOBAL)_VSelRanges,
                                                   cNewSize * sizeof( SELRANGEITEM ),
                                                   GMEM_ZEROINIT | GMEM_MOVEABLE );
    if (NULL != pTempSelRange)
    {
        _VSelRanges = pTempSelRange;
        _cSize = cNewSize;
        frt = TRUE;
    }
    return( frt );
}

//-------------------------------------------------------------------
//
// Function: _Shrink
//
// Summary:
//      This will reduce the number of items the Sel Range can have.
//
// Arguments:
//
// Return: FALSE if failed
//
// Notes: Shrink only happens when a significant size below the next size
//  is obtained and the new size is at least the minimum size.
//      Though this function may fail, pselrange structure is still valid
//
// History:
//      17-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL CLVRange::_Shrink()
{
    LONG cNewSize;
    LONG cTriggerSize;
    PSELRANGEITEM pTempSelRange;
    BOOL frt = TRUE;


    // check if we are below last grow area by a small percent
    cTriggerSize = _cSize * 90 / GROWSIZE;
    cNewSize = _cSize * 100 / GROWSIZE;

    if ((_cSelRanges < cTriggerSize) && (cNewSize >= MINCOUNT))
    {
        pTempSelRange = (PSELRANGEITEM) GlobalReAlloc( (HGLOBAL)_VSelRanges,
                                                       cNewSize * sizeof( SELRANGEITEM ),
                                                       GMEM_ZEROINIT | GMEM_MOVEABLE );
        if (NULL != pTempSelRange)
        {
            _VSelRanges = pTempSelRange;
            _cSize = cNewSize;
        }
        else
        {
            frt = FALSE;
        }
    }
    return( frt );
}

//-------------------------------------------------------------------
//
// Function: _InsertRange
//
// Summary:
//      inserts a single range item into the range vector       
//
// Arguments:
//      iAfterItem [in] - Index to insert range after, -1 means insert as first item
//      iBegin [in]     - begin of range
//      iEnd [in]       - end of the range
//
// Return:
//      TRUE if succesful, otherwise FALSE
//
// Notes:
//
// History:
//      17-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL CLVRange::_InsertRange(LONG iAfterItem,
                             LONG iBegin,
                             LONG iEnd )
{
    LONG iItem;
    BOOL frt = TRUE;

    ASSERT( iAfterItem >= -1 );
    ASSERT( iBegin >= SELRANGE_MINVALUE );
    ASSERT( iEnd >= iBegin );
    ASSERT( iEnd <= SELRANGE_MAXVALUE );
    ASSERT( _cSelRanges < _cSize );

    // shift all over one
    for (iItem = _cSelRanges; iItem > iAfterItem + 1; iItem--)
    {
        _VSelRanges[iItem] = _VSelRanges[iItem-1];
    }
    _cSelRanges++;

    // make the insertion
    _VSelRanges[iAfterItem+1].iBegin = iBegin;
    _VSelRanges[iAfterItem+1].iEnd = iEnd;

    // make sure we have room next time
    if (_cSelRanges == _cSize)
    {
        frt = _Enlarge();
    }
    return( frt );
}

//-------------------------------------------------------------------
//
// Function: _RemoveRanges
//
// Summary:
//      Removes all ranged between and including the speicifed indexes      
//
// Arguments:
//      iStartItem [in] - Index to start removal
//      iStopItem [in]  - Index to stop removal
//
// Return:
//      SELRANGE_ERROR on memory allocation error
//      The number of items that are unselected by this removal
//
// Notes:
//
// History:
//      17-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::_RemoveRanges(LONG iStartItem, LONG iStopItem, LONG *pc )
{
    LONG iItem;
    LONG diff;
    LONG cUnSelected = 0;
    HRESULT hres = S_OK;

    ASSERT( iStartItem > 0 );
    ASSERT( iStopItem >= iStartItem );
    ASSERT( iStartItem < _cSelRanges - 1 );
    ASSERT( iStopItem < _cSelRanges - 1 );
    
    diff = iStopItem - iStartItem + 1;
        
    for (iItem = iStartItem; iItem <= iStopItem; iItem++)
        cUnSelected += _VSelRanges[iItem].iEnd -
                       _VSelRanges[iItem].iBegin + 1;

    // shift all over the difference
    for (iItem = iStopItem+1; iItem < _cSelRanges; iItem++, iStartItem++)
        _VSelRanges[iStartItem] = _VSelRanges[iItem];

    _cSelRanges -= diff;
    
    if (!_Shrink())
    {
        hres = E_FAIL;
    }
    else if (pc)
        *pc = cUnSelected;
    return( hres );
}


//-------------------------------------------------------------------
//
// Function: SelRange_FindValue
//
// Summary:
//      This function will search the ranges for the value, returning true
//  if the value was found within a range.  The piItem will contain the
//  the index at which it was found or the index before where it should be
//  The piItem may be set to -1, meaning that there are no ranges in the list
//      This functions uses a non-recursive binary search algorithm.
//
// Arguments:
//      piItem [out]    - Return of found range index, or one before
//      Value [in]      - Value to find within a range
//
// Return: True if found, False if not found
//
// Notes: The piItem will return one before if return is false.
//
// History:
//      14-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL CLVRange::_FindValue(LONG Value, LONG* piItem )
{
    LONG First;
    LONG Last;
    LONG Item;
    BOOL fFound = FALSE;

    ASSERT( piItem );
    ASSERT( _cSize >= COUNT_SELRANGES_NONE );
    ASSERT( Value >= SELRANGE_MINVALUE );
    ASSERT( Value <= SELRANGE_MAXVALUE );
    

    First = 0;
    Last = _cSelRanges - 1;
    Item = Last / 2;

    do
    {
        if (_VSelRanges[Item].iBegin > Value)
        {   // Value before this Item
            Last = Item;
            Item = (Last - First) / 2 + First;
            if (Item == Last)
            {
                Item = First;   
                break;
            }
        }
        else if (_VSelRanges[Item].iEnd < Value)
        {   // Value after this Item
            First = Item;
            Item = (Last - First) / 2 + First;
            if (Item == First)
            {
                break;
            }
        }
        else
        {   // Value at this Item
            fFound = TRUE;
        }
    } while (!fFound);

    *piItem = Item;
    return( fFound );
}

//-------------------------------------------------------------------
//
// Function: _InitNew
//
// Summary:
//      This function will initialize a SelRange object.
//
// Arguments:
//
// Return:
//
// Notes:
//              
// History:
//      18-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

void CLVRange::_InitNew()
{
    _cSize = MINCOUNT;
    _cSelRanges = COUNT_SELRANGES_NONE;

    _VSelRanges[0].iBegin = LONG_MIN;
    // -2 and +2 below are to stop consecutive joining of end markers
    _VSelRanges[0].iEnd = SELRANGE_MINVALUE - 2;  
    _VSelRanges[1].iBegin =  SELRANGE_MAXVALUE + 2;
    _VSelRanges[1].iEnd = SELRANGE_MAXVALUE + 2;
    _cIncluded = 0;
}

//-------------------------------------------------------------------
//
// Function: SelRange_Create
//
// Summary:
//      This function will create and initialize a SelRange object.
//
// Arguments:
//
// Return: HSELRANGE that is created or NULL if it failed.
//
// Notes:
//
// History:
//      14-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

ILVRange *LVRange_Create( )
{
    CLVRange *pselrange = new CLVRange;

    if (NULL != pselrange)
    {
        pselrange->_VSelRanges = (PSELRANGEITEM) GlobalAlloc( GPTR,
                                       sizeof( SELRANGEITEM ) * MINCOUNT );
        if (NULL != pselrange->_VSelRanges)
        {
            pselrange->_InitNew();
        }
        else
        {
            delete pselrange;
            pselrange = NULL;
        }
    }

    return( pselrange? SAFECAST(pselrange, ILVRange*) : NULL);
}


//-------------------------------------------------------------------
//
// Function: Constructor
//
//-------------------------------------------------------------------
CLVRange::CLVRange()
{
    _cRef = 1;
}

//-------------------------------------------------------------------
//
// Function: Destructor
//
//-------------------------------------------------------------------
CLVRange::~CLVRange()
{
    GlobalFree( _VSelRanges );
}


//-------------------------------------------------------------------
//
// Function: QueryInterface
//
//-------------------------------------------------------------------
HRESULT CLVRange::QueryInterface(REFIID iid, void **ppv)
{
    if (IsEqualIID(iid, IID_ILVRange) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = SAFECAST(this, ILVRange *);
    }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    _cRef++;
    return NOERROR;
}

//-------------------------------------------------------------------
//
// Function: AddRef
//
//-------------------------------------------------------------------
ULONG CLVRange::AddRef()
{
    return ++_cRef;
}

//-------------------------------------------------------------------
//
// Function: Release
//
//-------------------------------------------------------------------
ULONG CLVRange::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

                
//-------------------------------------------------------------------
//
// Function: IncludeRange
//
// Summary:
//      This function will include the range defined into the current
//  ranges, compacting as needed.
//
// Arguments:
//      hselrange [in]  - Handle to the SelRange
//      iBegin [in]     - Begin of new range
//      iEnd [in]       - End of new range
//
// Notes:
//
// History:
//      14-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::IncludeRange(LONG iBegin, LONG iEnd )
{
    LONG iFirst;   // index before or contains iBegin value
    LONG iLast;    // index before or contains iEnd value
    BOOL fExtendFirst;  // do we extend the iFirst or create one after it
    LONG iRemoveStart;  // start of ranges that need to be removed
    LONG iRemoveFinish; // end of ranges that need to be removed

    LONG iNewEnd;   // calculate new end value as we go
    BOOL fEndFound; // was the iEnd found in a range already
    BOOL fBeginFound; // was the iEnd found in a range already

    LONG cSelected = 0;
    HRESULT hres = S_OK;

    ASSERT( iEnd >= iBegin );
    ASSERT( iBegin >= SELRANGE_MINVALUE );
    ASSERT( iEnd <= SELRANGE_MAXVALUE );

    // find approximate locations
    fBeginFound = _FindValue( iBegin, &iFirst );
    fEndFound = _FindValue( iEnd, &iLast );


    //
    // Find First values
    //
    // check for consecutive End-First values
    if ((_VSelRanges[iFirst].iEnd == iBegin - 1) ||
        (fBeginFound))
    {
        // extend iFirst
        fExtendFirst = TRUE;
        iRemoveStart = iFirst + 1;  
    }
    else
    {   
        // create one after the iFirst
        fExtendFirst = FALSE;
        iRemoveStart = iFirst + 2;
    }

    //
    // Find Last values
    //
    if (fEndFound)
    {
        // Use [iLast].iEnd value
        iRemoveFinish = iLast;
        iNewEnd = _VSelRanges[iLast].iEnd;

    }
    else
    {
        // check for consecutive First-End values
        if (_VSelRanges[iLast + 1].iBegin == iEnd + 1)
        {
            // Use [iLast + 1].iEnd value
            iNewEnd = _VSelRanges[iLast+1].iEnd;
            iRemoveFinish = iLast + 1;
        }
        else
        {
            // Use iEnd value
            iRemoveFinish = iLast;
            iNewEnd = iEnd;
        }
    }

    //
    // remove condenced items if needed
    //
    if (iRemoveStart <= iRemoveFinish)
    {
        LONG cChange;

        hres = _RemoveRanges(iRemoveStart, iRemoveFinish, &cChange );
        if (FAILED(hres))
            return hres;
        else
        {
            cSelected -= cChange;
        }
    }
                
    //
    // insert item and reset values as needed
    //          
    if (fExtendFirst)
    {
        cSelected += iNewEnd - _VSelRanges[iFirst].iEnd;
        _VSelRanges[iFirst].iEnd = iNewEnd;   
    }
    else
    {
        if (iRemoveStart > iRemoveFinish + 1)
        {
            cSelected += iEnd - iBegin + 1;
            // create one
            if (!_InsertRange(iFirst, iBegin, iNewEnd ))
            {
                hres = E_FAIL;
            }
        }       
        else
        {
            cSelected += iNewEnd - _VSelRanges[iFirst+1].iEnd;
            cSelected += _VSelRanges[iFirst+1].iBegin - iBegin;
            // no need to create one since the Removal would have left us one
            _VSelRanges[iFirst+1].iEnd = iNewEnd; 
            _VSelRanges[iFirst+1].iBegin = iBegin;
        }
    }
    
    _cIncluded += cSelected;
    return( hres );
}



//-------------------------------------------------------------------
//
// Function: SelRange_ExcludeRange
//
// Summary:
//      This function will exclude the range defined from the current
//  ranges, compacting and enlarging as needed.
//
// Arguments:
//      hselrange [in]  - Handle to the SelRange
//      iBegin [in]     - Begin of range to remove
//      iEnd [in]       - End of range to remove
//
// Return:
//      SELRANGE_ERROR if memory allocation error
//      the number actual items that changed state
//
// Notes:
//
// History:
//      17-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::ExcludeRange( LONG iBegin, LONG iEnd )
{
    LONG iFirst;   // index before or contains iBegin value
    LONG iLast;    // index before or contains iEnd value
    LONG iRemoveStart;  // start of ranges that need to be removed
    LONG iRemoveFinish; // end of ranges that need to be removed

    LONG iFirstNewEnd;  // calculate new end value as we go
    BOOL fBeginFound; // was the iBegin found in a range already
    BOOL fEndFound;   // was the iEnd found in a range already
    LONG cUnSelected = 0;
    HRESULT hres = S_OK;

    ASSERT( iEnd >= iBegin );
    ASSERT( iBegin >= SELRANGE_MINVALUE );
    ASSERT( iEnd <= SELRANGE_MAXVALUE );

    // find approximate locations
    fBeginFound = _FindValue( iBegin, &iFirst );
    fEndFound = _FindValue( iEnd, &iLast );

    //
    // Find First values
    //

    // start removal after first
    iRemoveStart = iFirst + 1;
    // save FirstEnd as we may need to modify it
    iFirstNewEnd = _VSelRanges[iFirst].iEnd;

    if (fBeginFound)
    {
        // check for complete removal of first
        //    (first is a single selection or match?)
        if (_VSelRanges[iFirst].iBegin == iBegin)
        {
            iRemoveStart = iFirst;  
        }
        else
        {
            // otherwise truncate iFirst
            iFirstNewEnd = iBegin - 1;
        }
    }
    
    //
    // Find Last values
    //
                
    // end removal on last
    iRemoveFinish = iLast;

    if (fEndFound)
    {
        // check for complete removal of last
        //   (first/last is a single selection or match?)
        if (_VSelRanges[iLast].iEnd != iEnd)
        {   
            if (iFirst == iLast)
            {
                // split
                if (!_InsertRange(iFirst, iEnd + 1, _VSelRanges[iFirst].iEnd ))
                {
                    return( E_FAIL );
                }
                cUnSelected -= _VSelRanges[iFirst].iEnd - iEnd;
            }
            else
            {
                // truncate Last
                iRemoveFinish = iLast - 1;
                cUnSelected += (iEnd + 1) - _VSelRanges[iLast].iBegin;
                _VSelRanges[iLast].iBegin = iEnd + 1;
            }
        }
    }

    // Now set the new end, since Last code may have needed the original values
    cUnSelected -= iFirstNewEnd - _VSelRanges[iFirst].iEnd;
    _VSelRanges[iFirst].iEnd = iFirstNewEnd;


    //
    // remove items if needed
    //
    if (iRemoveStart <= iRemoveFinish)
    {
        LONG cChange;

        if (SUCCEEDED(hres = _RemoveRanges(iRemoveStart, iRemoveFinish, &cChange )))
            cUnSelected += cChange;
    }

    _cIncluded -= cUnSelected;
    return( hres );
}

//-------------------------------------------------------------------
//
// Function: SelRange_Clear
//
// Summary:
//      This function will remove all ranges within the SelRange object.
//
// Arguments:
//      hselrange [in]  - the hselrange object to clear
//
// Return:  FALSE if failed.
//
// Notes:
//      This function may return FALSE on memory allocation problems, but
//  will leave the SelRange object in the last state before this call.  
//
// History:
//      14-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::Clear()
{
    PSELRANGEITEM pNewItems;
    HRESULT hres = S_OK;

    pNewItems = (PSELRANGEITEM) GlobalAlloc( GPTR,
                                       sizeof( SELRANGEITEM ) * MINCOUNT );
    if (NULL != pNewItems)
    {
        GlobalFree( _VSelRanges );
        _VSelRanges = pNewItems;

        _InitNew();
    }
    else
    {
        hres = E_FAIL;
    }
    return( hres );
}

//-------------------------------------------------------------------
//
// Function: SelRange_IsSelected
//
// Summary:
//      This function will return if the value iItem is within a
//  selected range.
//
// Arguments:
//      hselrange [in]  - the hselrange object to use
//      iItem [in]      - value to check for
//
// Return:  TRUE if selected, FALSE if not.
//
// Notes:
//
// History:
//      17-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::IsSelected( LONG iItem )
{   
    LONG iFirst;

    ASSERT( iItem >= 0 );
    ASSERT( iItem <= SELRANGE_MAXVALUE );

    return( _FindValue( iItem, &iFirst ) ? S_OK : S_FALSE);
}


//-------------------------------------------------------------------
//
// Function: SelRange_IsEmpty
//
// Summary:
//      This function will return TRUE if the range is empty
//
// Arguments:
//      hselrange [in]  - the hselrange object to use
//
// Return:  TRUE if empty
//
// Notes:
//
// History:
//
//-------------------------------------------------------------------
HRESULT CLVRange::IsEmpty()
{   
    return (_cSelRanges == COUNT_SELRANGES_NONE)? S_OK : S_FALSE;
}

HRESULT CLVRange::CountIncluded(LONG *pcIncluded)
{
    *pcIncluded = _cIncluded;
    return S_OK;
}


//-------------------------------------------------------------------
//
// Function: SelRange_InsertItem
//
// Summary:
//      This function will insert a unselected item at the location,
//      which will push all selections up one index.
//
// Arguments:
//      hselrange [in]  - the hselrange object to use
//      iItem [in]      - value to check for
//
// Return:
//      False on memory allocation error
//      otherwise TRUE
//
// Notes:
//
// History:
//      20-Dec-94   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::InsertItem( LONG iItem )
{
    LONG iFirst;
    LONG i;
    LONG iBegin;
    LONG iEnd;

    ASSERT( iItem >= 0 );
    ASSERT( iItem <= SELRANGE_MAXVALUE );

    if (_FindValue( iItem, &iFirst ) )
    {
        // split it
        if ( _VSelRanges[iFirst].iBegin == iItem )
        {
            // but don't split if starts with value
            iFirst--;
        }
        else
        {
            if (!_InsertRange(iFirst, iItem, _VSelRanges[iFirst].iEnd ))
            {
                return( E_FAIL );
            }
            _VSelRanges[iFirst].iEnd = iItem - 1;
        }
    }

    // now walk all ranges past iFirst, incrementing all values by one
    for (i = _cSelRanges-2; i > iFirst; i--)
    {
        iBegin = _VSelRanges[i].iBegin;
        iEnd = _VSelRanges[i].iEnd;

        iBegin = min( SELRANGE_MAXVALUE, iBegin + 1 );
        iEnd = min( SELRANGE_MAXVALUE, iEnd + 1 );

        _VSelRanges[i].iBegin = iBegin;
        _VSelRanges[i].iEnd = iEnd;
    }
    return( S_OK );
}

//-------------------------------------------------------------------
//
// Function: SelRange_RemoveItem
//
// Summary:
//      This function will remove an item at the location,
//      which will pull all selections down one index.
//
// Arguments:
//      hselrange [in]  - the hselrange object to use
//      iItem [in]      - value to check for
//      pfWasSelected [out] - was the removed item selected before the removal
//
// Return:
//      TRUE if the item was removed
//      FALSE if the an error happend
//
// Notes:
//
// History:
//      20-Dec-94   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::RemoveItem(LONG iItem )
{
    LONG iFirst;
    LONG i;
    LONG iBegin;
    LONG iEnd;
    HRESULT hres = S_OK;

    ASSERT( iItem >= SELRANGE_MINVALUE );
    ASSERT( iItem <= SELRANGE_MAXVALUE );

    if (_FindValue( iItem, &iFirst ) )
    {
        // item within, change the end value
        iEnd = _VSelRanges[iFirst].iEnd;
        iEnd = min( SELRANGE_MAXVALUE, iEnd - 1 );
        _VSelRanges[iFirst].iEnd = iEnd;

        _cIncluded--;
    }
    else
    {
        // check for merge situation
        if ((iFirst < _cSelRanges - 1) &&
            (_VSelRanges[iFirst].iEnd == iItem - 1) &&
            (_VSelRanges[iFirst+1].iBegin == iItem + 1))
        {
            _VSelRanges[iFirst].iEnd =
                    _VSelRanges[iFirst + 1].iEnd - 1;
            if (FAILED(hres = _RemoveRanges(iFirst + 1, iFirst + 1, NULL )))
                return( hres );
        }
    }

    // now walk all ranges past iFirst, decrementing all values by one
    for (i = _cSelRanges-2; i > iFirst; i--)
    {
        iBegin = _VSelRanges[i].iBegin;
        iEnd = _VSelRanges[i].iEnd;

        iBegin = min( SELRANGE_MAXVALUE, iBegin - 1 );
        iEnd = min( SELRANGE_MAXVALUE, iEnd - 1 );

        _VSelRanges[i].iBegin = iBegin;
        _VSelRanges[i].iEnd = iEnd;
    }
    return( hres );
}

//-------------------------------------------------------------------
//
// Function: NextSelected
//
// Summary:
//      This function will start with given item and find the next
//      item that is selected.  If the given item is selected, that
//      item number will be returned.
//
// Arguments:
//      hselrange [in]  - the hselrange object to use
//      iItem [in]      - value to start check at
//
// Return:
//      -1 if none found, otherwise the item
//
// Notes:
//
// History:
//      04-Jan-95   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::NextSelected( LONG iItem, LONG *piItem )
{
    LONG i;

    ASSERT( iItem >= SELRANGE_MINVALUE );
    ASSERT( iItem <= SELRANGE_MAXVALUE );

    if (!_FindValue( iItem, &i ) )
    {
        i++;
        if (i < _cSelRanges-1)
        {
            iItem = _VSelRanges[i].iBegin;
        }
        else
        {
            iItem = -1;
        }
    }

    ASSERT( iItem >= -1 );
    ASSERT( iItem <= SELRANGE_MAXVALUE );
    *piItem = iItem;
    return S_OK;
}

//-------------------------------------------------------------------
//
// Function: NextUnSelected
//
// Summary:
//      This function will start with given item and find the next
//      item that is not selected.  If the given item is not selected, that
//      item number will be returned.
//
// Arguments:
//      hselrange [in]  - the hselrange object to use
//      iItem [in]      - value to start check at
//
// Return:
//      -1 if none found, otherwise the item
//
// Notes:
//
// History:
//      04-Jan-95   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::NextUnSelected( LONG iItem, LONG *piItem )
{
    LONG i;

    ASSERT( iItem >= SELRANGE_MINVALUE );
    ASSERT( iItem <= SELRANGE_MAXVALUE );

    if (_FindValue( iItem, &i ) )
    {
        if (i < _cSelRanges-1)
        {
            iItem = _VSelRanges[i].iEnd + 1;
            if (iItem > SELRANGE_MAXVALUE)
            {
                iItem = -1;
            }
        }
        else
        {
            iItem = -1;
        }
    }

    ASSERT( iItem >= -1 );
    ASSERT( iItem <= SELRANGE_MAXVALUE );

    *piItem = iItem;
    return S_OK;
}

//-------------------------------------------------------------------
//
// Function: InvertRange
//
// Summary:
//      This function will invert the range defined from the current
//  ranges, compacting and enlarging as needed.
//
// Arguments:
//      iBegin [in]     - Begin of range to invert
//      iEnd [in]       - End of range to invert
//
// Return:
//      SELRANGE_ERROR on memory error
//      The difference in items selected from previous to current.
//      negative values means less items are selected in that range now.
//
// Notes:
//
// History:
//      13-Dec-95   MikeMi  Created
//
//-------------------------------------------------------------------

LONG CLVRange::InvertRange( LONG iBegin, LONG iEnd )
{
    LONG iFirst;   // index before or contains iBegin value
    BOOL fSelect;  // are we selecting or unselecting
    LONG iTempE;
    LONG iTempB;
    HRESULT hres = S_OK;

    ASSERT( iEnd >= iBegin );
    ASSERT( iBegin >= SELRANGE_MINVALUE );
    ASSERT( iEnd <= SELRANGE_MAXVALUE );

    // find if first is selected or not
    fSelect = !_FindValue( iBegin, &iFirst );
    
    iTempE = iBegin - 1;

    do
    {
        iTempB = iTempE + 1;

        if (fSelect)
            NextSelected( iTempB, &iTempE );
        else
            NextUnSelected( iTempB, &iTempE );

        if (-1 == iTempE)
        {
            iTempE = SELRANGE_MAXVALUE;
        }
        else
        {
            iTempE--;
        }

        iTempE = min( iTempE, iEnd );

        if (fSelect)
        {
            if (FAILED(hres = IncludeRange( iTempB, iTempE )))
            {
                return( hres );
            }
        }
        else
        {
            if (FAILED(hres = ExcludeRange( iTempB, iTempE )))
            {
                return( hres );
            }
        }

        fSelect = !fSelect;
    } while (iTempE < iEnd );

    return( hres );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\sources.inc ===
BUILD_PRIVLIB   = 1

SELFREGNAME     = $(O)\selfreg_comctlv6.inf
NTTARGETFILE0   = $(SELFREGNAME)
MSCFILES        = $(MSCFILES) $(SELFREGNAME)

!include ..\comctl32.inc
SOURCES_USED    = $(SOURCES_USED) ..\comctl32.inc

NO_BROWSER_FILE = 1

SYNCHRONIZE_DRAIN = 1

TARGETLIBS      = $(SDK_LIB_PATH)\gdi32.lib         \
                  $(SDK_LIB_PATH)\kernel32.lib      \
                  $(SDK_LIB_PATH)\user32.lib        \
                  $(CCSHELL_DIR)\lib\$(O)\shguid.lib \
                  $(SDK_LIB_PATH)\advapi32.lib      \
                  $(CCSHELL_DIR)\lib\$(O)\shguidp.lib \
                  $(LIBRARY_PATH)\uuid.lib          \
                  $(SDK_LIB_PATH)\ole32.lib         \
                  $(SDK_LIB_PATH)\oleaut32.lib      \
                  $(PROJECT_LIB_PATH)\shlwapip.lib  \
                  $(SDK_LIB_PATH)\oleacc.lib        \
                  $(WINDOWS_LIB_PATH)\user32p.lib   \
                  $(WINDOWS_LIB_PATH)\gdi32p.lib    \
                  $(CCSHELL_DIR)\lib\$(O)\shfusioncc.lib \
                  $(SDK_LIB_PATH)\winmm.lib

#don't profile this yeti (you know, that strange nordic beast...)
#USE_LEGO        = 1

DLLDEF          = $(O)\comctl32.def
PRIVDEF         = $(O)\comctl32p.def
PRIVDEFSRC      = ..\comctl32.src
PRIVLIB         = comctlp.lib

DLLENTRY        = LibMain
DLLBASE         = 0x71A00000

LINKLIBS        = ..\ntcpp\$(O)\srccpp.lib          \
!ifdef BUILD_WOW6432
                  ..\ntc6432\$(O)\srcc.lib              \
!else
                  ..\ntc\$(O)\srcc.lib              \
!endif
                  $(SHELL_LIB_PATH)\UxThemep.lib    \
                  $(CCSHELL_DIR)\lib\$(O)\stock.lib


DELAYLOAD       = uxtheme.dll;ole32.dll;oleaut32.dll;oleacc.dll;\
                  winmm.dll

DLOAD_ERROR_HANDLER = kernel32

SOURCES         = ..\crtfree.cpp \
                  ..\commctrl.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\scroll.cpp ===
//---------------------------------------------------------------------------
#include "ctlspriv.h"
#include "scroll.h"

#if defined(_UXTHEME_)

// non-client scrollbar 
#include "nctheme.h"
#include "scrollp.h"

#else

// scrollbar control 
#include "usrctl32.h"

#endif _UXTHEME_

//  comment this out to visually match user32 scrollbar:
//#define _VISUAL_DELTA_

#ifdef _VISUAL_DELTA_
#define CARET_BORDERWIDTH   2
#endif _VISUAL_DELTA_

//-------------------------------------------------------------------------//
#define FNID_SCROLLBAR          0x0000029A      // UxScrollBarWndProc;
#define GetOwner(hwnd)          GetWindow(hwnd, GW_OWNER)
#define HW(x)                   x
#define HWq(x)                  x
#define RIPERR0(s1,s2,errno)
#define RIPMSG1(errno,fmt,arg1)
#define RIPMSG2(errno,fmt,arg1,arg2)
#define RIPMSG3(errno,fmt,arg1,arg2,arg3)
#define RIP_VERBOSE()
#define ClrWF                   ClearWindowState
#define SetWF                   SetWindowState
#define Lock(phwnd, hwnd)       InterlockedExchangePointer((PVOID*)(phwnd), (PVOID)hwnd)
#define Unlock(phwnd)           Lock(phwnd, NULL)
#define CheckLock(hwnd)
#define ThreadLock(w,t)
#define ThreadUnlock(t)
#define VALIDATECLASSANDSIZE
#define DTTIME                  (MulDiv( GetDoubleClickTime(), 4, 5 ))
#define _KillSystemTimer              KillTimer
#define _SetSystemTimer               SetTimer
#define IsWinEventNotifyDeferredOK()  TRUE
#define IsWinEventNotifyDeferred()    FALSE

//-------------------------------------------------------------------------//
//  scroll type flags userk.h
#define SCROLL_NORMAL   0
#define SCROLL_DIRECT   1
#define SCROLL_MENU     2

//-------------------------------------------------------------------------//
//  internal Scrollbar state/style bits
//#define SBFSIZEBOXTOPLEFT       0x0C02
//#define SBFSIZEBOXBOTTOMRIGHT   0x0C04
//#define SBFSIZEBOX              0x0C08
#define SBFSIZEGRIP             0x0C10


//----------------------------------//
//  Scrollbar arrow disable flags
#define LTUPFLAG    0x0001  // Left/Up arrow disable flag.
#define RTDNFLAG    0x0002  // Right/Down arrow disable flag.

//----------------------------------//
//  function forwards
UINT _SysToChar(UINT message, LPARAM lParam);

//-------------------------------------------------------------------------//
//  private hittest codes
//#define HTEXSCROLLFIRST     60
#define HTSCROLLUP          60
#define HTSCROLLDOWN        61
#define HTSCROLLUPPAGE      62
#define HTSCROLLDOWNPAGE    63
#define HTSCROLLTHUMB       64
//#define HTEXSCROLLLAST      64
//#define HTEXMENUFIRST       65
//#define HTMDISYSMENU        65
//#define HTMDIMAXBUTTON      66
//#define HTMDIMINBUTTON      67
//#define HTMDICLOSE          68
//#define HTMENUITEM          69
//#define HTEXMENULAST        69

#define IDSYS_SCROLL            0x0000FFFEL // timer ID, user.h

typedef HWND  SBHWND;
typedef HMENU PMENU;


//-------------------------------------------------------------------------//
//  SBDATA
typedef struct tagSBDATA 
{
    int     posMin;
    int     posMax;
    int     page;
    int     pos;
} SBDATA, *PSBDATA;

//-------------------------------------------------------------------------//
//  SBINFO is the set of values that hang off of a window structure, 
//  if the window has scrollbars.
typedef struct tagSBINFO 
{
    int     WSBflags;
    SBDATA  Horz;
    SBDATA  Vert;
} SBINFO, * PSBINFO;

//-------------------------------------------------------------------------//
//  SBCALC
//  Scrollbar metrics block.
typedef struct tagSBCALC
{
    SBDATA  data;               /* this must be first -- we cast structure pointers */
    int     pxTop;
    int     pxBottom;
    int     pxLeft;
    int     pxRight;
    int     cpxThumb;
    int     pxUpArrow;
    int     pxDownArrow;
    int     pxStart;         /* Initial position of thumb */
    int     pxThumbBottom;
    int     pxThumbTop;
    int     cpx;
    int     pxMin;
} SBCALC, *PSBCALC;

//-------------------------------------------------------------------------//
//  SBTRACK
//  Scrollbar thumb-tracking state block.
typedef struct tagSBTRACK {
    DWORD    fHitOld : 1;
    DWORD    fTrackVert : 1;
    DWORD    fCtlSB : 1;
    DWORD    fTrackRecalc: 1;
    HWND     hwndTrack;
    HWND     hwndSB;
    HWND     hwndSBNotify;
    RECT     rcTrack;
    VOID     (CALLBACK *pfnSB)(HWND, UINT, WPARAM, LPARAM, PSBCALC);
    UINT     cmdSB;
    UINT_PTR hTimerSB;
    int      dpxThumb;        /* Offset from mouse point to start of thumb box */
    int      pxOld;           /* Previous position of thumb */
    int      posOld;
    int      posNew;
    int      nBar;
    PSBCALC  pSBCalc;
} SBTRACK, *PSBTRACK;

//-------------------------------------------------------------------------//
//  Window scrollbars, control base.
class CUxScrollBar
//-------------------------------------------------------------------------//
{
public:
    CUxScrollBar();
    virtual ~CUxScrollBar() {}

    virtual BOOL          IsCtl() const { return FALSE;}
    operator HWND()       { return _hwnd; }
    static  CUxScrollBar* Calc(  HWND hwnd, PSBCALC pSBCalc, LPRECT prcOverrideClient, BOOL fVert); 
    virtual void          Calc2( PSBCALC pSBCalc, LPRECT lprc, CONST PSBDATA pw, BOOL fVert);
    virtual void          DoScroll( HWND hwndNotify, int cmd, int pos, BOOL fVert );

    virtual void          ClearTrack()  { ZeroMemory( &_track, sizeof(_track) ); }
    SBTRACK*              GetTrack()    { return &_track; }
    SBINFO*               GetInfo()     { return &_info; }
    HTHEME                GetTheme()    { return _hTheme; }
    BOOL                  IsAttaching() { return _fAttaching; }
    INT                   GetHotComponent(BOOL fVert) { return fVert ? _htVert : _htHorz; }
    VOID                  SetHotComponent(INT ht, BOOL fVert) { (fVert ? _htVert : _htHorz) = ht; }
    virtual void          ChangeSBTheme();
    virtual BOOL          FreshenSBData( int nBar, BOOL fRedraw );

    //  UxScrollBar API.
    static CUxScrollBar*  Attach( HWND hwnd, BOOL bCtl, BOOL fRedraw );
    static CUxScrollBar*  FromHwnd( HWND hwnd );
    static void           Detach( HWND hwnd );

    static SBTRACK*       GetSBTrack( HWND hwnd );
    static void           ClearSBTrack( HWND hwnd );
    static SBINFO*        GetSBInfo( HWND hwnd );
    static HTHEME         GetSBTheme( HWND hwnd );
    static INT            GetSBHotComponent( HWND hwnd, BOOL fVert);


protected:
    HWND        _hwnd;
    SBTRACK     _track;
    SBINFO      _info;
    INT         _htVert;            // Scroll bar part the mouse is currently over
    INT         _htHorz;            // Scroll bar part the mouse is currently over
    HTHEME      _hTheme;// Handle to theme manager
    BOOL        _fAttaching;
};

//-------------------------------------------------------------------------//
//  Scrollbar control
class CUxScrollBarCtl : public CUxScrollBar
//-------------------------------------------------------------------------//
{
public:
    CUxScrollBarCtl();

    virtual BOOL    IsCtl() const { return TRUE;}
    BOOL            AddRemoveDisableFlags( UINT wAdd, UINT wRemove );

    //  UxScrollBarCtl API.
    static CUxScrollBarCtl* FromHwnd( HWND hwnd );
    static UINT             GetDisableFlags( HWND hwnd );
    static SBCALC*          GetCalc( HWND hwnd );
    static BOOL             AddRemoveDisableFlags( HWND, UINT, UINT );
    static LRESULT CALLBACK WndProc( HWND, UINT, WPARAM, LPARAM );

    BOOL   _fVert;
    UINT   _wDisableFlags;      // Indicates which arrow is disabled;
    SBCALC _calc;
};

//-------------------------------------------------------------------------//
//  IsScrollBarControl
#ifdef PORTPORT
#define IsScrollBarControl(h) (GETFNID(h) == FNID_SCROLLBAR)
#else  //PORTPORT
inline BOOL IsScrollBarControl(HWND hwnd)   {
    return CUxScrollBarCtl::FromHwnd( hwnd ) != NULL;
}
#endif //PORTPORT

//-------------------------------------------------------------------------//
//  Forwards:
void           DrawScrollBar( HWND hwnd, HDC hdc, LPRECT prcOverrideClient, BOOL fVert);
HWND           SizeBoxHwnd( HWND hwnd );
VOID          _DrawPushButton( HWND hwnd, HDC hdc, LPRECT lprc, UINT state, UINT flags, BOOL fVert);
UINT          _GetWndSBDisableFlags(HWND, BOOL);
void CALLBACK _TrackThumb( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, PSBCALC pSBCalc);
void CALLBACK _TrackBox( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, PSBCALC pSBCalc);
void          _RedrawFrame( HWND hwnd );
BOOL          _FChildVisible( HWND hwnd );
LONG          _SetScrollBar( HWND hwnd, int code, LPSCROLLINFO lpsi, BOOL fRedraw);

HBRUSH        _UxGrayBrush(VOID);
void          _UxFreeGDIResources();

//-------------------------------------------------------------------------//
BOOL WINAPI InitScrollBarClass( HINSTANCE hInst )
{
    WNDCLASSEX wc;
    ZeroMemory( &wc, sizeof(wc) );
    wc.cbSize = sizeof(wc);
    wc.style = CS_GLOBALCLASS|CS_PARENTDC|CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS;
    wc.lpfnWndProc = CUxScrollBarCtl::WndProc;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hInstance = hInst;
    wc.lpszClassName = WC_SCROLLBAR;
    wc.cbWndExtra = max(sizeof(CUxScrollBar), sizeof(CUxScrollBarCtl));
    return RegisterClassEx( &wc ) != 0;
}

//-------------------------------------------------------------------------//
//  CUxScrollBar impl
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
CUxScrollBar::CUxScrollBar()
    :   _hwnd(NULL), 
        _hTheme(NULL), 
        _htVert(HTNOWHERE), 
        _htHorz(HTNOWHERE), 
        _fAttaching(FALSE)
{
    ClearTrack();
    ZeroMemory( &_info, sizeof(_info) );
    _info.Vert.posMax = 100;    // ported from _InitPwSB
    _info.Horz.posMax = 100;    // ported from _InitPwSB
}

//-------------------------------------------------------------------------//
CUxScrollBar* CUxScrollBar::Attach( HWND hwnd, BOOL bCtl, BOOL fRedraw )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( NULL == psb )
    {
        psb = bCtl ? new CUxScrollBarCtl : new CUxScrollBar;

        if( psb != NULL )
        {
            ASSERT( psb->IsCtl() == bCtl );

            if( (! hwnd) || (! SetProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_SCROLLBAR)), (HANDLE)psb ) ))
            {
                delete psb;
                psb = NULL;
            }
            else
            {
                psb->_hwnd = hwnd;
                psb->_fAttaching = TRUE;

                if (psb->IsCtl())
                {
                    psb->_hTheme = OpenThemeData(hwnd, L"ScrollBar");
                }
                else
                {
                    psb->_hTheme = OpenNcThemeData(hwnd, L"ScrollBar");

                    //
                    // window SBs must grovel for state data each 
                    // time attached [scotthan]
                    //
                    SCROLLINFO si;

                    ZeroMemory(&si, sizeof(si));
                    si.cbSize = sizeof(si);
                    si.fMask  = SIF_ALL;
                    if (GetScrollInfo(hwnd, SB_VERT, &si))
                    {
                        si.fMask |= SIF_DISABLENOSCROLL;
                        _SetScrollBar(hwnd, SB_VERT, &si, FALSE);
                    }

                    ZeroMemory(&si, sizeof(si));
                    si.cbSize = sizeof(si);
                    si.fMask  = SIF_ALL;
                    if (GetScrollInfo(hwnd, SB_HORZ, &si))
                    {
                        si.fMask |= SIF_DISABLENOSCROLL;
                        _SetScrollBar(hwnd, SB_HORZ, &si, FALSE);
                    }
                }

                psb->_fAttaching = FALSE;
            }
        }
    }

    return psb;
}

//-------------------------------------------------------------------------//
CUxScrollBar* CUxScrollBar::FromHwnd( HWND hwnd )
{
    if (! hwnd)
        return NULL;

    return (CUxScrollBar*)GetProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_SCROLLBAR)));
}

//-------------------------------------------------------------------------//
void CUxScrollBar::Detach( HWND hwnd )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if ( psb == NULL || !psb->_fAttaching )
    {
        if (hwnd)
        {
            RemoveProp( hwnd, MAKEINTATOM(GetThemeAtom(THEMEATOM_SCROLLBAR)));
        }

        if( psb != NULL )
        {
            if ( psb->_hTheme )
            {
                CloseThemeData(psb->_hTheme);
            }
            delete psb;
        }
    }
}

//-------------------------------------------------------------------------//
void WINAPI AttachScrollBars( HWND hwnd )
{
    ASSERT( GetWindowLong( hwnd, GWL_STYLE ) & (WS_HSCROLL|WS_VSCROLL) );
    CUxScrollBar::Attach( hwnd, FALSE, FALSE );
}

//-------------------------------------------------------------------------//
void WINAPI DetachScrollBars( HWND hwnd )
{
    CUxScrollBar::Detach( hwnd );
}

//-------------------------------------------------------------------------//
SBTRACK* CUxScrollBar::GetSBTrack( HWND hwnd )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( psb )
        return &psb->_track;
    return NULL;
}

//-------------------------------------------------------------------------//
void CUxScrollBar::ClearSBTrack( HWND hwnd )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( psb )
        psb->ClearTrack();
}

//-------------------------------------------------------------------------//
SBINFO* CUxScrollBar::GetSBInfo( HWND hwnd )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( psb )
        return &psb->_info;
    return NULL;
}

//-------------------------------------------------------------------------//
HTHEME CUxScrollBar::GetSBTheme( HWND hwnd )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( psb )
        return psb->_hTheme;
    return NULL;
}

//-------------------------------------------------------------------------//
INT CUxScrollBar::GetSBHotComponent( HWND hwnd, BOOL fVert )
{
    CUxScrollBar* psb = FromHwnd( hwnd );
    if( psb )
        return psb->GetHotComponent(fVert);
    return 0;
}

//-------------------------------------------------------------------------//
BOOL CUxScrollBar::FreshenSBData( int nBar, BOOL fRedraw )
{
#ifdef __POLL_FOR_SCROLLINFO__

    ASSERT(IsWindow(_hwnd));

    if( !IsCtl() )
    {
        // Note scrollbar ctls don't go stale because
        // they receive SBM notifications
        SCROLLINFO si;
        si.cbSize = sizeof(si);
        si.fMask  = SIF_ALL;

        switch(nBar)
        {
            case SB_VERT:
            case SB_HORZ:
                if( GetScrollInfo( _hwnd, nBar, &si ) )
                {
                    _SetScrollBar( _hwnd, nBar, &si, fRedraw );
                }
                break;

            case SB_BOTH:
                return FreshenSBData( SB_VERT, fRedraw ) &&
                       FreshenSBData( SB_HORZ, fRedraw );
                break;

            default: return FALSE;
        }
    }
#endif __POLL_FOR_SCROLLINFO__

    return TRUE;
}

//-------------------------------------------------------------------------//
void CUxScrollBar::ChangeSBTheme()
{
    if ( _hTheme )
    {
        CloseThemeData(_hTheme);
    }

    _hTheme = NULL;

    if (IsCtl())
        _hTheme = OpenThemeData(_hwnd, L"ScrollBar");
    else
        _hTheme = OpenNcThemeData(_hwnd, L"ScrollBar");
}

//-------------------------------------------------------------------------//
//  CUxScrollBarCtl impl
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
CUxScrollBarCtl::CUxScrollBarCtl()
    :   _wDisableFlags(0), _fVert(FALSE)
{
    ZeroMemory( &_calc, sizeof(_calc) );
}

//-------------------------------------------------------------------------//
CUxScrollBarCtl* CUxScrollBarCtl::FromHwnd( HWND hwnd )
{
    CUxScrollBarCtl* psb = (CUxScrollBarCtl*)CUxScrollBar::FromHwnd( hwnd );
    if( psb )
        return psb->IsCtl() ? psb : NULL;
    return NULL;
}

//-------------------------------------------------------------------------//
UINT CUxScrollBarCtl::GetDisableFlags( HWND hwnd )
{
    CUxScrollBarCtl* psb = FromHwnd( hwnd );
    if( psb )
        return psb->_wDisableFlags;
    return 0;
}

//-------------------------------------------------------------------------//
SBCALC* CUxScrollBarCtl::GetCalc( HWND hwnd )
{
    CUxScrollBarCtl* psb = FromHwnd( hwnd );
    if( psb )
        return &psb->_calc;
    return NULL;
}

//-------------------------------------------------------------------------//
//  CUxScrollBarCtl::AddRemoveDisableFlags() - static 
BOOL CUxScrollBarCtl::AddRemoveDisableFlags( HWND hwnd, UINT wAdd, UINT wRemove )
{
    CUxScrollBarCtl* psb = FromHwnd( hwnd );
    if( psb )
        return psb->AddRemoveDisableFlags( wAdd, wRemove );
    return FALSE;
}

//-------------------------------------------------------------------------//
//  CUxScrollBarCtl::AddRemoveDisableFlags() - instance member
BOOL CUxScrollBarCtl::AddRemoveDisableFlags( UINT wAdd, UINT wRemove )
{
    //  returns TRUE if flags changed, otherwise FALSE.
    UINT wOld = _wDisableFlags;
    _wDisableFlags |= wAdd;
    _wDisableFlags &= ~wRemove;
    return _wDisableFlags != wOld;
}

//-------------------------------------------------------------------------//
//  CUxScrollBar::Calc().  computes metrics for window SBs only.  
//  derives rect and calls Calc2.
CUxScrollBar* CUxScrollBar::Calc(
    HWND hwnd,
    PSBCALC pSBCalc,
    LPRECT prcOverrideClient,
    BOOL fVert)
{
    RECT    rcT;
#ifdef USE_MIRRORING
    int     cx, iTemp;
#endif

    //
    //  Get client rectangle in window-relative coords.  
    //  We know that window scrollbars always align to the right
    //  and to the bottom of the client area.
    //
    WINDOWINFO wi;
    wi.cbSize = sizeof(wi);
    if( !GetWindowInfo( hwnd, &wi ) )
        return NULL;
    OffsetRect( &wi.rcClient, -wi.rcWindow.left, -wi.rcWindow.top );

#ifdef USE_MIRRORING
    if (TestWF(hwnd, WEFLAYOUTRTL)) {
        cx                = wi.rcWindow.right - wi.rcWindow.left;
        iTemp             = wi.rcClient.left;
        wi.rcClient.left  = cx - wi.rcClient.right;
        wi.rcClient.right = cx - iTemp;
    }
#endif

    if (fVert) {
         // Only add on space if vertical scrollbar is really there.
        if (TestWF(hwnd, WEFLEFTSCROLL)) {
            rcT.right = rcT.left = wi.rcClient.left;
            if (TestWF(hwnd, WFVPRESENT))
                rcT.left -= SYSMET(CXVSCROLL);
        } else {
            rcT.right = rcT.left = wi.rcClient.right;
            if (TestWF(hwnd, WFVPRESENT))
                rcT.right += SYSMET(CXVSCROLL);
        }

        rcT.top = wi.rcClient.top;
        rcT.bottom = wi.rcClient.bottom;
    } else {
        // Only add on space if horizontal scrollbar is really there.
        rcT.bottom = rcT.top = wi.rcClient.bottom;
        if (TestWF(hwnd, WFHPRESENT))
            rcT.bottom += SYSMET(CYHSCROLL);

        rcT.left = wi.rcClient.left;
        rcT.right = wi.rcClient.right;
    }

    if (prcOverrideClient)
    {
        rcT = *prcOverrideClient;
    }
    // If InitPwSB stuff fails (due to our heap being full) there isn't anything reasonable
    // we can do here, so just let it go through.  We won't fault but the scrollbar won't work
    // properly either...
    CUxScrollBar* psb = CUxScrollBar::Attach( hwnd, FALSE, FALSE );
    if( psb )
    {
        SBDATA*  pData = fVert ? &psb->_info.Vert : &psb->_info.Horz;
        if( psb )
            psb->Calc2( pSBCalc, &rcT, pData, fVert );
        return psb;
    }
    return NULL;
}

//-------------------------------------------------------------------------//
// CUxScrollBar::Calc2().  computes metrics for window SBs or SB ctls.  
void CUxScrollBar::Calc2( PSBCALC pSBCalc, LPRECT lprc, CONST PSBDATA pw, BOOL fVert)
{
    int cpx;
    DWORD dwRange;
    int denom;

    if (fVert) {
        pSBCalc->pxTop = lprc->top;
        pSBCalc->pxBottom = lprc->bottom;
        pSBCalc->pxLeft = lprc->left;
        pSBCalc->pxRight = lprc->right;
        pSBCalc->cpxThumb = SYSMET(CYVSCROLL);
    } else {

        /*
         * For horiz scroll bars, "left" & "right" are "top" and "bottom",
         * and vice versa.
         */
        pSBCalc->pxTop = lprc->left;
        pSBCalc->pxBottom = lprc->right;
        pSBCalc->pxLeft = lprc->top;
        pSBCalc->pxRight = lprc->bottom;
        pSBCalc->cpxThumb = SYSMET(CXHSCROLL);
    }

    pSBCalc->data.pos = pw->pos;
    pSBCalc->data.page = pw->page;
    pSBCalc->data.posMin = pw->posMin;
    pSBCalc->data.posMax = pw->posMax;

    dwRange = ((DWORD)(pSBCalc->data.posMax - pSBCalc->data.posMin)) + 1;

    //
    // For the case of short scroll bars that don't have enough
    // room to fit the full-sized up and down arrows, shorten
    // their sizes to make 'em fit
    //
    cpx = min((pSBCalc->pxBottom - pSBCalc->pxTop) / 2, pSBCalc->cpxThumb);

    pSBCalc->pxUpArrow   = pSBCalc->pxTop    + cpx;
    pSBCalc->pxDownArrow = pSBCalc->pxBottom - cpx;

    if ((pw->page != 0) && (dwRange != 0)) {
        // JEFFBOG -- This is the one and only place where we should
        // see 'range'.  Elsewhere it should be 'range - page'.

        /*
         * The minimun thumb size used to depend on the frame/edge metrics.
         * People that increase the scrollbar width/height expect the minimun
         *  to grow with proportianally. So NT5 bases the minimun on
         *  CXH/YVSCROLL, which is set by default in cpxThumb.
         */
        /*
         * i is used to keep the macro "max" from executing MulDiv twice.
         */
        int i = MulDiv(pSBCalc->pxDownArrow - pSBCalc->pxUpArrow,
                                             pw->page, dwRange);
        pSBCalc->cpxThumb = max(pSBCalc->cpxThumb / 2, i);
    }

    pSBCalc->pxMin = pSBCalc->pxTop + cpx;
    pSBCalc->cpx = pSBCalc->pxBottom - cpx - pSBCalc->cpxThumb - pSBCalc->pxMin;

    denom = dwRange - (pw->page ? pw->page : 1);
    if (denom)
        pSBCalc->pxThumbTop = MulDiv(pw->pos - pw->posMin,
            pSBCalc->cpx, denom) +
            pSBCalc->pxMin;
    else
        pSBCalc->pxThumbTop = pSBCalc->pxMin - 1;

    pSBCalc->pxThumbBottom = pSBCalc->pxThumbTop + pSBCalc->cpxThumb;
}

//-------------------------------------------------------------------------//
void CUxScrollBar::DoScroll( HWND hwndNotify, int cmd, int pos, BOOL fVert )
{
    HWND hwnd = _hwnd;
    
    //
    // Send scroll notification to the scrollbar owner. If this is a control
    // the lParam is the control's handle, NULL otherwise.
    //
    SendMessage(hwndNotify, 
                (UINT)(fVert ? WM_VSCROLL : WM_HSCROLL),
                MAKELONG(cmd, pos), 
                (LPARAM)(IsCtl() ? _hwnd : NULL));

    //
    // The hwnd can have it's scrollbar removed as the result
    // of the previous sendmessge. 
    //
    if( CUxScrollBar::GetSBTrack(hwnd) && !IsCtl() )
    {
        FreshenSBData( fVert ? SB_VERT : SB_HORZ, TRUE );
    }
}


/*
 * Now it is possible to selectively Enable/Disable just one arrow of a Window
 * scroll bar; Various bits in the 7th word in the rgwScroll array indicates which
 * one of these arrows are disabled; The following masks indicate which bit of the
 * word indicates which arrow;
 */
#define WSB_HORZ_LF  0x0001  // Represents the Left arrow of the horizontal scroll bar.
#define WSB_HORZ_RT  0x0002  // Represents the Right arrow of the horizontal scroll bar.
#define WSB_VERT_UP  0x0004  // Represents the Up arrow of the vert scroll bar.
#define WSB_VERT_DN  0x0008  // Represents the Down arrow of the vert scroll bar.

#define WSB_VERT (WSB_VERT_UP | WSB_VERT_DN)
#define WSB_HORZ   (WSB_HORZ_LF | WSB_HORZ_RT)

void DrawCtlThumb( SBHWND );

/*
 * RETURN_IF_PSBTRACK_INVALID:
 * This macro tests whether the pSBTrack we have is invalid, which can happen
 * if it gets freed during a callback.
 * This protects agains the original pSBTrack being freed and no new one
 * being allocated or a new one being allocated at a different address.
 * This does not protect against the original pSBTrack being freed and a new
 * one being allocated at the same address.
 * If pSBTrack has changed, we assert that there is not already a new one
 * because we are really not expecting this.
 */
#define RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd) \
    if ((pSBTrack) != CUxScrollBar::GetSBTrack(hwnd)) {      \
        ASSERT(CUxScrollBar::GetSBTrack(hwnd) == NULL);  \
        return;                                    \
    }

/*
 * REEVALUATE_PSBTRACK
 * This macro just refreshes the local variable pSBTrack, in case it has
 * been changed during a callback.  After performing this operation, pSBTrack
 * should be tested to make sure it is not now NULL.
 */

#if (defined(DBG) || defined(DEBUG) || defined(_DEBUG))
    #define REEVALUATE_PSBTRACK(pSBTrack, hwnd, str)          \
        if ((pSBTrack) != CUxScrollBar::GetSBTrack(hwnd)) {             \
            RIPMSG3(RIP_WARNING,                              \
                    "%s: pSBTrack changed from %#p to %#p",   \
                    (str), (pSBTrack), CUxScrollBar::GetSBTrack(hwnd)); \
        }                                                     \
        (pSBTrack) = CUxScrollBar::GetSBTrack(hwnd)
#else
    #define REEVALUATE_PSBTRACK(pSBTrack, hwnd, str)          \
        (pSBTrack) = CUxScrollBar::GetSBTrack(hwnd)
#endif

/***************************************************************************\
* HitTestScrollBar
*
* 11/15/96      vadimg          ported from Memphis sources
\***************************************************************************/

int HitTestScrollBar(HWND hwnd, BOOL fVert, POINT pt)
{
    UINT wDisable;
    int px;
    CUxScrollBar*    psb    = CUxScrollBar::FromHwnd( hwnd );
    CUxScrollBarCtl* psbCtl = CUxScrollBarCtl::FromHwnd( hwnd );
    BOOL fCtl = psbCtl != NULL;

    SBCALC SBCalc = {0};
    SBCALC *pSBCalc = NULL;

    if (fCtl) {
        wDisable = psbCtl->_wDisableFlags;
    } else {
        RECT rcWindow;
        GetWindowRect( hwnd, &rcWindow );
#ifdef USE_MIRRORING
        //
        // Reflect the click coordinates on the horizontal
        // scroll bar if the window is mirrored
        //
        if (TestWF(hwnd,WEFLAYOUTRTL) && !fVert) {
            pt.x = rcWindow.right - pt.x;
        }
        else
#endif
        pt.x -= rcWindow.left;
        pt.y -= rcWindow.top;
        wDisable = _GetWndSBDisableFlags(hwnd, fVert);
    }

    if ((wDisable & SB_DISABLE_MASK) == SB_DISABLE_MASK) {
        return HTERROR;
    }

    if (fCtl) {
        pSBCalc = CUxScrollBarCtl::GetCalc(hwnd);
    } else {
        pSBCalc = &SBCalc;
        psb->FreshenSBData( SB_BOTH, FALSE );
        psb->Calc(hwnd, pSBCalc, NULL, fVert);
    }

    px = fVert ? pt.y : pt.x;

    if( pSBCalc )
    {
        if (px < pSBCalc->pxUpArrow) {
            if (wDisable & LTUPFLAG) {
                return HTERROR;
            }
            return HTSCROLLUP;
        } else if (px >= pSBCalc->pxDownArrow) {
            if (wDisable & RTDNFLAG) {
                return HTERROR;
            }
            return HTSCROLLDOWN;
        } else if (px < pSBCalc->pxThumbTop) {
            return HTSCROLLUPPAGE;
        } else if (px < pSBCalc->pxThumbBottom) {
            return HTSCROLLTHUMB;
        } else if (px < pSBCalc->pxDownArrow) {
            return HTSCROLLDOWNPAGE;
        }
    }
    return HTERROR;
}

BOOL _SBGetParms(
    HWND hwnd,
    int code,
    PSBDATA pw,
    LPSCROLLINFO lpsi)
{
    PSBTRACK pSBTrack;

    pSBTrack = CUxScrollBar::GetSBTrack(hwnd);

    if (lpsi->fMask & SIF_RANGE) {
        lpsi->nMin = pw->posMin;
        lpsi->nMax = pw->posMax;
    }

    if (lpsi->fMask & SIF_PAGE)
        lpsi->nPage = pw->page;

    if (lpsi->fMask & SIF_POS) {
        lpsi->nPos = pw->pos;
    }

    if (lpsi->fMask & SIF_TRACKPOS)
    {
        if (pSBTrack && (pSBTrack->nBar == code) && (pSBTrack->hwndTrack == hwnd)) {
            // posNew is in the context of psbiSB's window and bar code
            lpsi->nTrackPos = pSBTrack->posNew;
        } else {
            lpsi->nTrackPos = pw->pos;
        }
    }
    return ((lpsi->fMask & SIF_ALL) ? TRUE : FALSE);
}

//-------------------------------------------------------------------------//
BOOL WINAPI ThemeGetScrollInfo( HWND hwnd, int nBar, LPSCROLLINFO psi )
{
    CUxScrollBar* psb = CUxScrollBar::FromHwnd(hwnd);
    if((psb != NULL) && (psb->IsAttaching() == FALSE))
    {
#ifdef DEBUG
        if( psb->IsCtl() )
        {
            ASSERT(FALSE); // controls cooperate through an SBM_GETSCROLLINFO message.
        }
        else
#endif DEBUG
        {
            SBINFO* psbi;
            if( (psbi = psb->GetInfo()) != NULL )
            {
                SBDATA* psbd = SB_VERT == nBar ? &psbi->Vert :
                               SB_HORZ == nBar ? &psbi->Horz : NULL;
                if( psbd )
                    return _SBGetParms( hwnd, nBar, psbd, psi );
            }
        }
    }
    return FALSE;
}

/***************************************************************************\
* _GetWndSBDisableFlags
*
* This returns the scroll bar Disable flags of the scroll bars of a
*  given Window.
*
*
* History:
*  4-18-91 MikeHar Ported for the 31 merge
\***************************************************************************/

UINT _GetWndSBDisableFlags(
    HWND hwnd,  // The window whose scroll bar Disable Flags are to be returned;
    BOOL fVert)  // If this is TRUE, it means Vertical scroll bar.
{
    PSBINFO pw;

    if ((pw = CUxScrollBar::GetSBInfo( hwnd )) == NULL) {
        RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
        return 0;
    }

    return (fVert ? (pw->WSBflags & WSB_VERT) >> 2 : pw->WSBflags & WSB_HORZ);
}


/***************************************************************************\
*  xxxEnableSBCtlArrows()
*
*  This function can be used to selectively Enable/Disable
*     the arrows of a scroll bar Control
*
* History:
* 04-18-91 MikeHar      Ported for the 31 merge
\***************************************************************************/

BOOL xxxEnableSBCtlArrows(
    HWND hwnd,
    UINT wArrows)
{
    UINT wOldFlags = CUxScrollBarCtl::GetDisableFlags( hwnd ); // Get the original status
    BOOL bChanged  = FALSE;

    if (wArrows == ESB_ENABLE_BOTH) {      // Enable both the arrows
        bChanged = CUxScrollBarCtl::AddRemoveDisableFlags( hwnd, 0, SB_DISABLE_MASK );
    } else {
        bChanged = CUxScrollBarCtl::AddRemoveDisableFlags( hwnd, wArrows, 0 );
    }

    /*
     * Check if the status has changed because of this call
     */
    if (!bChanged)
        return FALSE;

    /*
     * Else, redraw the scroll bar control to reflect the new state
     */
    if (IsWindowVisible(hwnd))
        InvalidateRect(hwnd, NULL, TRUE);

    UINT wNewFlags = CUxScrollBarCtl::GetDisableFlags(hwnd);

    // state change notifications
    if ((wOldFlags & ESB_DISABLE_UP) != (wNewFlags & ESB_DISABLE_UP))
    {
        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEX_SCROLLBAR_UP);
    }

    if ((wOldFlags & ESB_DISABLE_DOWN) != (wNewFlags & ESB_DISABLE_DOWN))
    {
        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEX_SCROLLBAR_DOWN);
    }

    return TRUE;
}


/***************************************************************************\
* xxxEnableWndSBArrows()
*
*  This function can be used to selectively Enable/Disable
*     the arrows of a Window Scroll bar(s)
*
* History:
*  4-18-91 MikeHar      Ported for the 31 merge
\***************************************************************************/

BOOL xxxEnableWndSBArrows(
    HWND hwnd,
    UINT wSBflags,
    UINT wArrows)
{
    INT wOldFlags;
    PSBINFO pw;
    BOOL bRetValue = FALSE;
    HDC hdc;

    CheckLock(hwnd);
    ASSERT(IsWinEventNotifyDeferredOK());

    if ((pw = CUxScrollBar::GetSBInfo( hwnd )) != NULL)
    {
        wOldFlags = pw->WSBflags;
    }
    else
    {
        // Originally everything is enabled; Check to see if this function is
        // asked to disable anything; Otherwise, no change in status; So, must
        // return immediately;
        if(!wArrows)
            return FALSE;          // No change in status!

        wOldFlags = 0;    // Both are originally enabled;

        CUxScrollBar::Attach( hwnd, FALSE, FALSE );
        if((pw = CUxScrollBar::GetSBInfo(hwnd)) == NULL)  // Allocate the pSBInfo for hWnd
            return FALSE;
    }

    hdc = GetWindowDC(hwnd);
    if (hdc != NULL)
    {

        /*
         *  First Take care of the Horizontal Scroll bar, if one exists.
         */
        if((wSBflags == SB_HORZ) || (wSBflags == SB_BOTH)) {
            if(wArrows == ESB_ENABLE_BOTH)      // Enable both the arrows
                pw->WSBflags &= ~SB_DISABLE_MASK;
            else
                pw->WSBflags |= wArrows;

            /*
             * Update the display of the Horizontal Scroll Bar;
             */
            if(pw->WSBflags != wOldFlags) {
                bRetValue = TRUE;
                wOldFlags = pw->WSBflags;
                if (TestWF(hwnd, WFHPRESENT) && !TestWF(hwnd, WFMINIMIZED) &&
                        IsWindowVisible(hwnd)) {
                    DrawScrollBar(hwnd, hdc, NULL, FALSE);  // Horizontal Scroll Bar.
                }
            }

            // Left button
            if ((wOldFlags & ESB_DISABLE_LEFT) != (pw->WSBflags & ESB_DISABLE_LEFT))
            {
                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_HSCROLL, INDEX_SCROLLBAR_UP);
            }

            // Right button
            if ((wOldFlags & ESB_DISABLE_RIGHT) != (pw->WSBflags & ESB_DISABLE_RIGHT))
            {
                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_HSCROLL, INDEX_SCROLLBAR_DOWN);
            }
        }

        // Then take care of the Vertical Scroll bar, if one exists.
        if ((wSBflags == SB_VERT) || (wSBflags == SB_BOTH))
        {
            if (wArrows == ESB_ENABLE_BOTH)
            {
                // Enable both the arrows
                pw->WSBflags &= ~(SB_DISABLE_MASK << 2);
            }
            else
            {
                pw->WSBflags |= (wArrows << 2);
            }

            // Update the display of the Vertical Scroll Bar;
            if(pw->WSBflags != wOldFlags)
            {
                bRetValue = TRUE;
                if (TestWF(hwnd, WFVPRESENT) && !TestWF(hwnd, WFMINIMIZED) && IsWindowVisible(hwnd))
                {
                    // Vertical Scroll Bar
                    DrawScrollBar(hwnd, hdc, NULL, TRUE);
                }

                // Up button
                if ((wOldFlags & (ESB_DISABLE_UP << 2)) != (pw->WSBflags & (ESB_DISABLE_UP << 2)))
                {
                    NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_VSCROLL, INDEX_SCROLLBAR_UP);
                }

                // Down button
                if ((wOldFlags & (ESB_DISABLE_DOWN << 2)) != (pw->WSBflags & (ESB_DISABLE_DOWN << 2)))
                {
                    NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_VSCROLL, INDEX_SCROLLBAR_DOWN);
                }
            }
        }

        ReleaseDC(hwnd,hdc);
    }

    return bRetValue;
}


/***************************************************************************\
* EnableScrollBar()
*
* This function can be used to selectively Enable/Disable
*     the arrows of a scroll bar; It could be used with Windows Scroll
*     bars as well as scroll bar controls
*
* History:
*  4-18-91 MikeHar Ported for the 31 merge
\***************************************************************************/

BOOL xxxEnableScrollBar(
    HWND hwnd,
    UINT wSBflags,  // Whether it is a Window Scroll Bar; if so, HORZ or VERT?
                    // Possible values are SB_HORZ, SB_VERT, SB_CTL or SB_BOTH
    UINT wArrows)   // Which arrows must be enabled/disabled:
                    // ESB_ENABLE_BOTH = > Enable both arrows.
                    // ESB_DISABLE_LTUP = > Disable Left/Up arrow;
                    // ESB_DISABLE_RTDN = > DIsable Right/Down arrow;
                    // ESB_DISABLE_BOTH = > Disable both the arrows;
{
#define ES_NOTHING 0
#define ES_DISABLE 1
#define ES_ENABLE  2
    UINT wOldFlags;
    UINT wEnableWindow;

    CheckLock(hwnd);

    if(wSBflags != SB_CTL) {
        return xxxEnableWndSBArrows(hwnd, wSBflags, wArrows);
    }

    /*
     *  Let us assume that we don't have to call EnableWindow
     */
    wEnableWindow = ES_NOTHING;

    wOldFlags = CUxScrollBarCtl::GetDisableFlags( hwnd ) & (UINT)SB_DISABLE_MASK;

    /*
     * Check if the present state of the arrows is exactly the same
     *  as what the caller wants:
     */
    if (wOldFlags == wArrows)
        return FALSE ;          // If so, nothing needs to be done;

    /*
     * Check if the caller wants to disable both the arrows
     */
    if (wArrows == ESB_DISABLE_BOTH) {
        wEnableWindow = ES_DISABLE;      // Yes! So, disable the whole SB Ctl.
    } else {

        /*
         * Check if the caller wants to enable both the arrows
         */
        if(wArrows == ESB_ENABLE_BOTH) {

            /*
             * We need to enable the SB Ctl only if it was already disabled.
             */
            if(wOldFlags == ESB_DISABLE_BOTH)
                wEnableWindow = ES_ENABLE;// EnableWindow(.., TRUE);
        } else {

            /*
             * Now, Caller wants to disable only one arrow;
             * Check if one of the arrows was already disabled and we want
             * to disable the other;If so, the whole SB Ctl will have to be
             * disabled; Check if this is the case:
             */
            if((wOldFlags | wArrows) == ESB_DISABLE_BOTH)
                wEnableWindow = ES_DISABLE;      // EnableWindow(, FALSE);
         }
    }
    if(wEnableWindow != ES_NOTHING) {

        /*
         * EnableWindow returns old state of the window; We must return
         * TRUE only if the Old state is different from new state.
         */
        if(EnableWindow(hwnd, (BOOL)(wEnableWindow == ES_ENABLE))) {
            return !(TestWF(hwnd, WFDISABLED));
        } else {
            return TestWF(hwnd, WFDISABLED);
        }
    }

    return (BOOL)SendMessage(hwnd, SBM_ENABLE_ARROWS, (DWORD)wArrows, 0);
#undef ES_NOTHING
#undef ES_DISABLE
#undef ES_ENABLE
}

//-------------------------------------------------------------------------
BOOL WINAPI ThemeEnableScrollBar( HWND hwnd, UINT nSBFlags, UINT nArrows )
{
    return xxxEnableScrollBar( hwnd, nSBFlags, nArrows );
}


//-------------------------------------------------------------------------
//
// DrawSizeBox() - paints the scrollbar sizebox/gripper given top, left
// point in window coords.
//
void DrawSizeBox(HWND hwnd, HDC hdc, int x, int y)
{
    RECT rc;

    SetRect(&rc, x, y, x + SYSMET(CXVSCROLL), y + SYSMET(CYHSCROLL));
    FillRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));

    //
    // If we have a scrollbar control, or the sizebox is not associated with
    // a sizeable window, draw the flat gray sizebox.  Otherwise, use the
    // sizing grip.
    //

    if ((IsScrollBarControl(hwnd) && TestWF(hwnd, SBFSIZEGRIP)) || SizeBoxHwnd(hwnd))
    {
        HTHEME hTheme = CUxScrollBar::GetSBTheme(hwnd);

        if (!hTheme)
        {
            // Blt out the grip bitmap.
            DrawFrameControl( hdc, &rc, DFC_SCROLL,
                              TestWF(hwnd, WEFLEFTSCROLL) ? DFCS_SCROLLSIZEGRIPRIGHT : DFCS_SCROLLSIZEGRIP );
            
            //user: BitBltSysBmp(hdc, x, y, TestWF(hwnd, WEFLEFTSCROLL) ? OBI_NCGRIP_L : OBI_NCGRIP);
        }
        else
        {
            DrawThemeBackground(hTheme, hdc, SBP_SIZEBOX, TestWF(hwnd, WEFLEFTSCROLL) ? SZB_LEFTALIGN : SZB_RIGHTALIGN, &rc, 0);
        }
    }
}


//-------------------------------------------------------------------------
//
// _DrawSizeBoxFromFrame
//
// Calculates position and draws of sizebox/gripper at fixed offset from
// perimeter of host window frame.
//
// This, combined with implementation of DrawSizeBox(), 
// was the original DrawSize() port.  Needed to expost method to
// draw sizebox at absolute position.  [scotthan]
//
void _DrawSizeBoxFromFrame(HWND hwnd, HDC hdc, int cxFrame,int cyFrame )
{
    int     x, y;
    RECT    rcWindow;

    GetWindowRect(hwnd, &rcWindow);

    if (TestWF(hwnd, WEFLEFTSCROLL)) 
    {
        x = cxFrame;
    } 
    else 
    {
        x = rcWindow.right - rcWindow.left - cxFrame - SYSMET(CXVSCROLL);
    }

    y = rcWindow.bottom - rcWindow.top  - cyFrame - SYSMET(CYHSCROLL);

    DrawSizeBox(hwnd, hdc, x, y);
}


//-------------------------------------------------------------------------
HBRUSH ScrollBar_GetControlColor(
    HWND  hwndOwner,
    HWND  hwndCtl,
    HDC   hdc,
    UINT  uMsg,
    BOOL* pfOwnerBrush)
{
    HBRUSH hbrRet = (HBRUSH)DefWindowProc(hwndOwner, uMsg, (WPARAM)hdc, (LPARAM)hwndCtl);
    BOOL   fOwnerBrush = FALSE;

    if (hwndOwner && (GetWindowThreadProcessId(hwndOwner, NULL) == GetCurrentThreadId())) 
    {
        HBRUSH hbrOwner = (HBRUSH)SendMessage(hwndOwner, uMsg, (WPARAM)hdc, (LPARAM)hwndCtl);

        if (hbrOwner && (hbrOwner != hbrRet))
        {
            fOwnerBrush = TRUE;
            hbrRet = hbrOwner;
        }
    }

    if (pfOwnerBrush)
    {
        *pfOwnerBrush = fOwnerBrush;
    }

    return hbrRet;
}


//-------------------------------------------------------------------------
HBRUSH ScrollBar_GetControlBrush(HWND hwnd, HDC hdc, UINT uMsg, BOOL *pfOwnerBrush)
{
    HWND hwndSend;

    hwndSend = TESTFLAG(GetWindowStyle(hwnd), WS_POPUP) ? GetOwner(hwnd) : GetParent(hwnd);
    if (hwndSend == NULL)
    {
        hwndSend = hwnd;
    }

    return ScrollBar_GetControlColor(hwndSend, hwnd, hdc, uMsg, pfOwnerBrush);
}


//-------------------------------------------------------------------------
HBRUSH ScrollBar_GetColorObjects(HWND hwnd, HDC hdc, BOOL *pfOwnerBrush)
{
    HBRUSH hbrRet;

    CheckLock(hwnd);

    // Use the scrollbar color even if the scrollbar is disabeld.
    if (!IsScrollBarControl(hwnd))
    {
        hbrRet = (HBRUSH)DefWindowProc(hwnd, WM_CTLCOLORSCROLLBAR, (WPARAM)hdc, (LPARAM)HWq(hwnd));
    }
    else 
    {
        // B#12770 - GetControlBrush sends a WM_CTLCOLOR message to the
        // owner.  If the app doesn't process the message, DefWindowProc32
        // will always return the appropriate system brush. If the app.
        // returns an invalid object, GetControlBrush will call DWP for
        // the default brush. Thus hbrRet doesn't need any validation
        // here.
        hbrRet = ScrollBar_GetControlBrush(hwnd, hdc, WM_CTLCOLORSCROLLBAR, pfOwnerBrush);
    }

    return hbrRet;
}


//-------------------------------------------------------------------------
//
// ScrollBar_PaintTrack
//
// Draws lines & middle of thumb groove
// Note that pw points into prc.  Moreover, note that both pw & prc are
// pointers, so *prc better not be on the stack.
//
void ScrollBar_PaintTrack(HWND hwnd, HDC hdc, HBRUSH hbr, LPRECT prc, BOOL fVert, INT iPartId, BOOL fOwnerBrush)
{
    HTHEME hTheme = CUxScrollBar::GetSBTheme(hwnd);

    // If the scrollbar is unthemed or 
    // #374054 we've been passed an brush defined by the owner, paint 
    // the shaft using the brush 
    if ((hTheme == NULL) || (fOwnerBrush == TRUE))
    {
        if ((hbr == SYSHBR(3DHILIGHT)) || (hbr == SYSHBR(SCROLLBAR)) || (hbr == _UxGrayBrush()) )
        {
            FillRect(hdc, prc, hbr);
        }
        else
        {
    #ifdef PORTPORT // we need SystemParametersInfo for _UxGrayBrush
        // Draw sides
           CopyRect(&rc, prc);
           DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_ADJUST | BF_FLAT |
                    (fVert ? BF_LEFT | BF_RIGHT : BF_TOP | BF_BOTTOM));
    #endif PORTPORT

        // Fill middle
            FillRect(hdc, prc, hbr);
        }
    }
    else
    {
        INT iStateId;
        INT ht = CUxScrollBar::GetSBHotComponent(hwnd, fVert);
        
        if ((CUxScrollBarCtl::GetDisableFlags(hwnd) & ESB_DISABLE_BOTH) == ESB_DISABLE_BOTH)
        {
            iStateId = SCRBS_DISABLED;
        }
        else if ((((iPartId == SBP_LOWERTRACKHORZ) || (iPartId == SBP_LOWERTRACKVERT)) && (ht == HTSCROLLUPPAGE)) ||
                 (((iPartId == SBP_UPPERTRACKHORZ) || (iPartId == SBP_UPPERTRACKVERT)) && (ht == HTSCROLLDOWNPAGE)))
        {
            iStateId = SCRBS_HOT;
       }
        else
        {
            iStateId = SCRBS_NORMAL;
        }
        DrawThemeBackground(hTheme, hdc, iPartId, iStateId, prc, 0);
    }
}

/***************************************************************************\
* CalcTrackDragRect
*
* Give the rectangle for a scrollbar in pSBTrack->pSBCalc,
* calculate pSBTrack->rcTrack, the rectangle where tracking
* may occur without cancelling the thumbdrag operation.
*
\***************************************************************************/

void CalcTrackDragRect(PSBTRACK pSBTrack) {

    int     cx;
    int     cy;
    LPINT   pwX, pwY;

    //
    // Point pwX and pwY at the parts of the rectangle
    // corresponding to pSBCalc->pxLeft, pxTop, etc.
    //
    // pSBTrack->pSBCalc->pxLeft is the left edge of a vertical
    // scrollbar and the top edge of horizontal one.
    // pSBTrack->pSBCalc->pxTop is the top of a vertical
    // scrollbar and the left of horizontal one.
    // etc...
    //
    // Point pwX and pwY to the corresponding parts
    // of pSBTrack->rcTrack.
    //

    pwX = pwY = (LPINT)&pSBTrack->rcTrack;

    if (pSBTrack->fTrackVert) {
        cy = SYSMET(CYVTHUMB);
        pwY++;
    } else {
        cy = SYSMET(CXHTHUMB);
        pwX++;
    }
    /*
     * Later5.0 GerardoB: People keep complaining about this tracking region
     *  being too narrow so let's make it wider while PM decides what to do
     *  about it.
     * We also used to have some hard coded min and max values but that should
     *  depend on some metric, if at all needed.
     */
    cx = (pSBTrack->pSBCalc->pxRight - pSBTrack->pSBCalc->pxLeft) * 8;
    cy *= 2;

    *(pwX + 0) = pSBTrack->pSBCalc->pxLeft - cx;
    *(pwY + 0) = pSBTrack->pSBCalc->pxTop - cy;
    *(pwX + 2) = pSBTrack->pSBCalc->pxRight + cx;
    *(pwY + 2) = pSBTrack->pSBCalc->pxBottom + cy;
}

void RecalcTrackRect(PSBTRACK pSBTrack) {
    LPINT pwX, pwY;
    RECT rcSB;


    if (!pSBTrack->fCtlSB)
        CUxScrollBar::Calc(pSBTrack->hwndTrack, pSBTrack->pSBCalc, NULL, pSBTrack->fTrackVert);

    pwX = (LPINT)&rcSB;
    pwY = pwX + 1;
    if (!pSBTrack->fTrackVert)
        pwX = pwY--;

    *(pwX + 0) = pSBTrack->pSBCalc->pxLeft;
    *(pwY + 0) = pSBTrack->pSBCalc->pxTop;
    *(pwX + 2) = pSBTrack->pSBCalc->pxRight;
    *(pwY + 2) = pSBTrack->pSBCalc->pxBottom;

    switch(pSBTrack->cmdSB) {
    case SB_LINEUP:
        *(pwY + 2) = pSBTrack->pSBCalc->pxUpArrow;
        break;
    case SB_LINEDOWN:
        *(pwY + 0) = pSBTrack->pSBCalc->pxDownArrow;
        break;
    case SB_PAGEUP:
        *(pwY + 0) = pSBTrack->pSBCalc->pxUpArrow;
        *(pwY + 2) = pSBTrack->pSBCalc->pxThumbTop;
        break;
    case SB_THUMBPOSITION:
        CalcTrackDragRect(pSBTrack);
        break;
    case SB_PAGEDOWN:
        *(pwY + 0) = pSBTrack->pSBCalc->pxThumbBottom;
        *(pwY + 2) = pSBTrack->pSBCalc->pxDownArrow;
        break;
    }

    if (pSBTrack->cmdSB != SB_THUMBPOSITION) {
        CopyRect(&pSBTrack->rcTrack, &rcSB);
    }
}

//-------------------------------------------------------------------------
void DrawThumb2(
    HWND    hwnd,
    PSBCALC pSBCalc,
    HDC     hdc,
    HBRUSH  hbr,
    BOOL    fVert,
    UINT    wDisable,       // Disabled flags for the scroll bar
    BOOL    fOwnerBrush)
{
    int    *pLength;
    int    *pWidth;
    RECT   rcSB;
    PSBTRACK pSBTrack;
    HTHEME hTheme = CUxScrollBar::GetSBTheme(hwnd);

    //
    // Bail out if the scrollbar has an empty rect
    //
    if ((pSBCalc->pxTop >= pSBCalc->pxBottom) || (pSBCalc->pxLeft >= pSBCalc->pxRight))
    {
        return;
    }

    pLength = (LPINT)&rcSB;
    if (fVert)
    {
        pWidth = pLength++;
    }
    else
    {
        pWidth  = pLength + 1;
    }

    pWidth[0] = pSBCalc->pxLeft;
    pWidth[2] = pSBCalc->pxRight;

    // If were're not themed and both buttons are disabled OR there isn't
    // enough room to draw a thumb just draw the track and run.
    //
    // When we are themed the thumb can be drawn disabled.
    if (((wDisable & LTUPFLAG) && (wDisable & RTDNFLAG)) || 
        ((pSBCalc->pxDownArrow - pSBCalc->pxUpArrow) < pSBCalc->cpxThumb))
    {
        // draw the entire track
        pLength[0] = pSBCalc->pxUpArrow;
        pLength[2] = pSBCalc->pxDownArrow;

        ScrollBar_PaintTrack(hwnd, hdc, hbr, &rcSB, fVert, fVert ? SBP_LOWERTRACKVERT : SBP_LOWERTRACKHORZ, fOwnerBrush);
        return;
    }

    if (pSBCalc->pxUpArrow < pSBCalc->pxThumbTop)
    {
        // draw the track above the thumb
        pLength[0] = pSBCalc->pxUpArrow;
        pLength[2] = pSBCalc->pxThumbTop;

        ScrollBar_PaintTrack(hwnd, hdc, hbr, &rcSB, fVert, fVert ? SBP_LOWERTRACKVERT : SBP_LOWERTRACKHORZ, fOwnerBrush);
    }

    if (pSBCalc->pxThumbBottom < pSBCalc->pxDownArrow)
    {
        // draw the track below the thumb
        pLength[0] = pSBCalc->pxThumbBottom;
        pLength[2] = pSBCalc->pxDownArrow;

        ScrollBar_PaintTrack(hwnd, hdc, hbr, &rcSB, fVert, fVert ? SBP_UPPERTRACKVERT : SBP_UPPERTRACKHORZ, fOwnerBrush);
    }

    //
    // Draw elevator
    //
    pLength[0] = pSBCalc->pxThumbTop;
    pLength[2] = pSBCalc->pxThumbBottom;

    // Not soft!
    _DrawPushButton(hwnd, hdc, &rcSB, 0, 0, fVert);

#ifdef _VISUAL_DELTA_
    InflateRect( &rcSB, -CARET_BORDERWIDTH, -CARET_BORDERWIDTH);
    DrawEdge( hdc, &rcSB, EDGE_SUNKEN, BF_RECT );
#endif _VISUAL_DELTA_

    /*
     * If we're tracking a page scroll, then we've obliterated the hilite.
     * We need to correct the hiliting rectangle, and rehilite it.
     */
    pSBTrack = CUxScrollBar::GetSBTrack(hwnd);

    if (pSBTrack && (pSBTrack->cmdSB == SB_PAGEUP || pSBTrack->cmdSB == SB_PAGEDOWN) &&
            (hwnd == pSBTrack->hwndTrack) &&
            (BOOL)pSBTrack->fTrackVert == fVert) {

        if (pSBTrack->fTrackRecalc) {
            RecalcTrackRect(pSBTrack);
            pSBTrack->fTrackRecalc = FALSE;
        }

        pLength = (int *)&pSBTrack->rcTrack;

        if (fVert)
            pLength++;

        if (pSBTrack->cmdSB == SB_PAGEUP)
            pLength[2] = pSBCalc->pxThumbTop;
        else
            pLength[0] = pSBCalc->pxThumbBottom;

        if (pLength[0] < pLength[2])
        {
            if (!hTheme)
            {
                InvertRect(hdc, &pSBTrack->rcTrack);
            }
            else
            {
                DrawThemeBackground(hTheme, 
                                    hdc, 
                                    pSBTrack->cmdSB == SB_PAGEUP ? 
                                        (fVert ? SBP_LOWERTRACKVERT : SBP_LOWERTRACKHORZ) : 
                                        (fVert ? SBP_UPPERTRACKVERT : SBP_UPPERTRACKHORZ), 
                                    SCRBS_PRESSED, 
                                    &pSBTrack->rcTrack, 
                                    0);
            }
        }
    }
}

/***************************************************************************\
* xxxDrawSB2
*
*
*
* History:
\***************************************************************************/

void xxxDrawSB2(
    HWND hwnd,
    PSBCALC pSBCalc,
    HDC hdc,
    BOOL fVert,
    UINT wDisable)
{

    int      cLength;
    int      cWidth;
    int      *pwX;
    int      *pwY;
    HBRUSH   hbr;
    HBRUSH   hbrSave;
    int      cpxArrow;
    RECT     rc, rcSB;
    COLORREF crText, crBk;
    HTHEME   hTheme;
    INT      ht;
    INT      iStateId;
    BOOL     fOwnerBrush = FALSE;

    CheckLock(hwnd);

    cLength = (pSBCalc->pxBottom - pSBCalc->pxTop) / 2;
    cWidth = (pSBCalc->pxRight - pSBCalc->pxLeft);

    if ((cLength <= 0) || (cWidth <= 0)) {
        return;
    }

    if (fVert)
    {
        cpxArrow = SYSMET(CYVSCROLL);
    }
    else
    {
        cpxArrow = SYSMET(CXHSCROLL);
    }

    // Save background and DC color, since they get changed in
    // ScrollBar_GetColorObjects. Restore before we return.
    crBk = GetBkColor(hdc);
    crText = GetTextColor(hdc);

    hbr = ScrollBar_GetColorObjects(hwnd, hdc, &fOwnerBrush);

    if (cLength > cpxArrow)
    {
        cLength = cpxArrow;
    }

    pwX = (int *)&rcSB;
    pwY = pwX + 1;
    if (!fVert)
    {
        pwX = pwY--;
    }

    pwX[0] = pSBCalc->pxLeft;
    pwY[0] = pSBCalc->pxTop;
    pwX[2] = pSBCalc->pxRight;
    pwY[2] = pSBCalc->pxBottom;

    hbrSave = SelectBrush(hdc, SYSHBR(BTNTEXT));

    //
    // BOGUS
    // Draw scrollbar arrows as disabled if the scrollbar itself is
    // disabled OR if the window it is a part of is disabled?
    //
    hTheme = CUxScrollBar::GetSBTheme(hwnd);
    ht     = CUxScrollBar::GetSBHotComponent(hwnd, fVert);
    if (fVert) 
    {
        // up button
        CopyRect(&rc, &rcSB);
        rc.bottom = rc.top + cLength;
        if (!hTheme)
        {
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLUP | ((wDisable & LTUPFLAG) ? DFCS_INACTIVE : 0));
        }
        else
        {
            iStateId = (wDisable & LTUPFLAG) ? ABS_UPDISABLED : (ht == HTSCROLLUP) ? ABS_UPHOT : ABS_UPNORMAL;
            DrawThemeBackground(hTheme, hdc, SBP_ARROWBTN, iStateId, &rc, 0);
        }

        // down button
        rc.bottom = rcSB.bottom;
        rc.top = rcSB.bottom - cLength;
        if (!hTheme)
        {
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLDOWN | ((wDisable & RTDNFLAG) ? DFCS_INACTIVE : 0));
        }
        else
        {
            iStateId = (wDisable & RTDNFLAG) ? ABS_DOWNDISABLED : (ht == HTSCROLLDOWN) ? ABS_DOWNHOT : ABS_DOWNNORMAL;
            DrawThemeBackground(hTheme, hdc, SBP_ARROWBTN, iStateId, &rc, 0);
        }
    } 
    else 
    {
        // left button
        CopyRect(&rc, &rcSB);
        rc.right = rc.left + cLength;
        if (!hTheme)
        {
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLLEFT | ((wDisable & LTUPFLAG) ? DFCS_INACTIVE : 0));
        }
        else
        {
            iStateId = (wDisable & LTUPFLAG) ? ABS_LEFTDISABLED : (ht == HTSCROLLUP) ? ABS_LEFTHOT : ABS_LEFTNORMAL;
            DrawThemeBackground(hTheme, hdc, SBP_ARROWBTN, iStateId, &rc, 0);
        }

        // right button
        rc.right = rcSB.right;
        rc.left = rcSB.right - cLength;
        if (!hTheme)
        {
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLRIGHT | ((wDisable & RTDNFLAG) ? DFCS_INACTIVE : 0));
        }
        else
        {
            iStateId = (wDisable & RTDNFLAG) ? ABS_RIGHTDISABLED : (ht == HTSCROLLDOWN) ? ABS_RIGHTHOT : ABS_RIGHTNORMAL;
            DrawThemeBackground(hTheme, hdc, SBP_ARROWBTN, iStateId, &rc, 0);
        }
    }

    hbrSave = SelectBrush(hdc, hbrSave);
    DrawThumb2(hwnd, pSBCalc, hdc, hbr, fVert, wDisable, fOwnerBrush);
    SelectBrush(hdc, hbrSave);

    SetBkColor(hdc, crBk);
    SetTextColor(hdc, crText);
}

/***************************************************************************\
* zzzSetSBCaretPos
*
*
*
* History:
\***************************************************************************/

void zzzSetSBCaretPos(
    SBHWND hwndSB)
{

    if (GetFocus() == hwndSB) {
        CUxScrollBarCtl* psb = CUxScrollBarCtl::FromHwnd( hwndSB );
        if( psb )
        {
            int x = (psb->_fVert ? psb->_calc.pxLeft : psb->_calc.pxThumbTop) + SYSMET(CXEDGE);
            int y = (psb->_fVert ? psb->_calc.pxThumbTop : psb->_calc.pxLeft) + SYSMET(CYEDGE);

#ifdef _VISUAL_DELTA_
            x += CARET_BORDERWIDTH;
            y += CARET_BORDERWIDTH;
#endif _VISUAL_DELTA_

            SetCaretPos( x, y );
        }
    }
}

/***************************************************************************\
* CalcSBStuff2
*
*
*
* History:
\***************************************************************************/

void CalcSBStuff2(
    PSBCALC  pSBCalc,
    LPRECT lprc,
    CONST PSBDATA pw,
    BOOL fVert)
{
    int cpx;
    DWORD dwRange;
    int denom;

    if (fVert) {
        pSBCalc->pxTop = lprc->top;
        pSBCalc->pxBottom = lprc->bottom;
        pSBCalc->pxLeft = lprc->left;
        pSBCalc->pxRight = lprc->right;
        pSBCalc->cpxThumb = SYSMET(CYVSCROLL);
    } else {

        /*
         * For horiz scroll bars, "left" & "right" are "top" and "bottom",
         * and vice versa.
         */
        pSBCalc->pxTop = lprc->left;
        pSBCalc->pxBottom = lprc->right;
        pSBCalc->pxLeft = lprc->top;
        pSBCalc->pxRight = lprc->bottom;
        pSBCalc->cpxThumb = SYSMET(CXHSCROLL);
    }

    pSBCalc->data.pos = pw->pos;
    pSBCalc->data.page = pw->page;
    pSBCalc->data.posMin = pw->posMin;
    pSBCalc->data.posMax = pw->posMax;

    dwRange = ((DWORD)(pSBCalc->data.posMax - pSBCalc->data.posMin)) + 1;

    //
    // For the case of short scroll bars that don't have enough
    // room to fit the full-sized up and down arrows, shorten
    // their sizes to make 'em fit
    //
    cpx = min((pSBCalc->pxBottom - pSBCalc->pxTop) / 2, pSBCalc->cpxThumb);

    pSBCalc->pxUpArrow   = pSBCalc->pxTop    + cpx;
    pSBCalc->pxDownArrow = pSBCalc->pxBottom - cpx;

    if ((pw->page != 0) && (dwRange != 0)) {
        // JEFFBOG -- This is the one and only place where we should
        // see 'range'.  Elsewhere it should be 'range - page'.

        /*
         * The minimun thumb size used to depend on the frame/edge metrics.
         * People that increase the scrollbar width/height expect the minimun
         *  to grow with proportianally. So NT5 bases the minimun on
         *  CXH/YVSCROLL, which is set by default in cpxThumb.
         */
        /*
         * i is used to keep the macro "max" from executing MulDiv twice.
         */
        int i = MulDiv(pSBCalc->pxDownArrow - pSBCalc->pxUpArrow,
                                             pw->page, dwRange);
        pSBCalc->cpxThumb = max(pSBCalc->cpxThumb / 2, i);
    }

    pSBCalc->pxMin = pSBCalc->pxTop + cpx;
    pSBCalc->cpx = pSBCalc->pxBottom - cpx - pSBCalc->cpxThumb - pSBCalc->pxMin;

    denom = dwRange - (pw->page ? pw->page : 1);
    if (denom)
        pSBCalc->pxThumbTop = MulDiv(pw->pos - pw->posMin,
            pSBCalc->cpx, denom) +
            pSBCalc->pxMin;
    else
        pSBCalc->pxThumbTop = pSBCalc->pxMin - 1;

    pSBCalc->pxThumbBottom = pSBCalc->pxThumbTop + pSBCalc->cpxThumb;

}

/***************************************************************************\
* SBCtlSetup
*
*
*
* History:
\***************************************************************************/

CUxScrollBarCtl* SBCtlSetup(
    SBHWND hwndSB)
{
    RECT rc;
    GetClientRect( hwndSB, &rc );
    CUxScrollBarCtl* psb = (CUxScrollBarCtl*)CUxScrollBar::Attach( hwndSB, TRUE, FALSE );
    if( psb )
    {
        psb->Calc2( &psb->_calc, &rc, &psb->_calc.data, psb->_fVert );
    }
    return psb;
}

/***************************************************************************\
* HotTrackSB
*
\***************************************************************************/

#ifdef COLOR_HOTTRACKING

DWORD GetTrackFlags(int ht, BOOL fDraw)
{
    if (fDraw) {
        switch(ht) {
        case HTSCROLLUP:
        case HTSCROLLUPPAGE:
            return LTUPFLAG;

        case HTSCROLLDOWN:
        case HTSCROLLDOWNPAGE:
            return RTDNFLAG;

        case HTSCROLLTHUMB:
            return LTUPFLAG | RTDNFLAG;

        default:
            return 0;
        }
    } else {
        return 0;
    }
}

BOOL xxxHotTrackSB(HWND hwnd, int htEx, BOOL fDraw)
{
    SBCALC SBCalc;
    HDC  hdc;
    BOOL fVert = HIWORD(htEx);
    int ht = LOWORD(htEx);
    DWORD dwTrack = GetTrackFlags(ht, fDraw);

    CheckLock(hwnd);

    /*
     * xxxDrawSB2 does not callback or leave the critical section when it's
     * not a SB control and the window belongs to a different thread. It
     * calls DefWindowProc which simply returns the brush color.
     */
    CalcSBStuff(hwnd, &SBCalc, fVert);
    hdc = _GetDCEx(hwnd, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE);
    xxxDrawSB2(hwnd, &SBCalc, hdc, fVert, _GetWndSBDisableFlags(hwnd, fVert), dwTrack);
    ReleaseDC(hwnd, hdc);
    return TRUE;
}

void xxxHotTrackSBCtl(SBHWND hwndSB, int ht, BOOL fDraw)
{
    DWORD dwTrack = GetTrackFlags(ht, fDraw);
    HDC hdc;

    CheckLock(hwndSB);

    SBCtlSetup(hwndSB);
    hdc = _GetDCEx((HWND)hwndSB, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE);
    xxxDrawSB2((HWND)hwndSB, &psb->_calc, hdc, psb->_fVert, psb->_wDisableFlags, dwTrack);
    ReleaseDC(hwnd, hdc);
}
#endif // COLOR_HOTTRACKING

BOOL SBSetParms(PSBDATA pw, LPSCROLLINFO lpsi, LPBOOL lpfScroll, LPLONG lplres)
{
    // pass the struct because we modify the struct but don't want that
    // modified version to get back to the calling app

    BOOL fChanged = FALSE;

    if (lpsi->fMask & SIF_RETURNOLDPOS)
        // save previous position
        *lplres = pw->pos;

    if (lpsi->fMask & SIF_RANGE) {
        // if the range MAX is below the range MIN -- then treat is as a
        // zero range starting at the range MIN.
        if (lpsi->nMax < lpsi->nMin)
            lpsi->nMax = lpsi->nMin;

        if ((pw->posMin != lpsi->nMin) || (pw->posMax != lpsi->nMax)) {
            pw->posMin = lpsi->nMin;
            pw->posMax = lpsi->nMax;

            if (!(lpsi->fMask & SIF_PAGE)) {
                lpsi->fMask |= SIF_PAGE;
                lpsi->nPage = pw->page;
            }

            if (!(lpsi->fMask & SIF_POS)) {
                lpsi->fMask |= SIF_POS;
                lpsi->nPos = pw->pos;
            }

            fChanged = TRUE;
        }
    }

    if (lpsi->fMask & SIF_PAGE) {
        DWORD dwMaxPage = (DWORD) abs(pw->posMax - pw->posMin) + 1;

        // Clip page to 0, posMax - posMin + 1

        if (lpsi->nPage > dwMaxPage)
            lpsi->nPage = dwMaxPage;


        if (pw->page != (int)(lpsi->nPage)) {
            pw->page = lpsi->nPage;

            if (!(lpsi->fMask & SIF_POS)) {
                lpsi->fMask |= SIF_POS;
                lpsi->nPos = pw->pos;
            }

            fChanged = TRUE;
        }
    }

    if (lpsi->fMask & SIF_POS) {
        int iMaxPos = pw->posMax - ((pw->page) ? pw->page - 1 : 0);
        // Clip pos to posMin, posMax - (page - 1).

        if (lpsi->nPos < pw->posMin)
            lpsi->nPos = pw->posMin;
        else if (lpsi->nPos > iMaxPos)
            lpsi->nPos = iMaxPos;


        if (pw->pos != lpsi->nPos) {
            pw->pos = lpsi->nPos;
            fChanged = TRUE;
        }
    }

    if (!(lpsi->fMask & SIF_RETURNOLDPOS)) {
        // Return the new position
        *lplres = pw->pos;
    }

    /*
     * This was added by JimA as Cairo merge but will conflict
     * with the documentation for SetScrollPos
     */
/*
    else if (*lplres == pw->pos)
        *lplres = 0;
*/
    if (lpsi->fMask & SIF_RANGE) {
        *lpfScroll = (pw->posMin != pw->posMax);
        if (*lpfScroll)
            goto checkPage;
    } else if (lpsi->fMask & SIF_PAGE)
checkPage:
        *lpfScroll = (pw->page <= (pw->posMax - pw->posMin));

    return fChanged;
}


/***************************************************************************\
* CalcSBStuff
*
*
*
* History:
\***************************************************************************/
#if 0
void CalcSBStuff(
    HWND hwnd,
    PSBCALC pSBCalc,
    BOOL fVert)
{
    RECT    rcT;
    RECT    rcClient;
#ifdef USE_MIRRORING
    int     cx, iTemp;
#endif

    //
    // Get client rectangle.  We know that scrollbars always align to the right
    // and to the bottom of the client area.
    //
    GetClientRect( hwnd, &rcClient );
    ClientToScreen( hwnd, (LPPOINT)&rcClient.left );
    ClientToScreen( hwnd, (LPPOINT)&rcClient.right );
    MapWindowPoints( HWND_DESKTOP, hwnd, (LPPOINT)&rcClient, 2 );
    // GetRect(hwnd, &rcClient, GRECT_CLIENT | GRECT_WINDOWCOORDS);

#ifdef USE_MIRRORING
    if (TestWF(hwnd, WEFLAYOUTRTL)) {
        cx             = hwnd->rcWindow.right - hwnd->rcWindow.left;
        iTemp          = rcClient.left;
        rcClient.left  = cx - rcClient.right;
        rcClient.right = cx - iTemp;
    }
#endif

    if (fVert) {
         // Only add on space if vertical scrollbar is really there.
        if (TestWF(hwnd, WEFLEFTSCROLL)) {
            rcT.right = rcT.left = rcClient.left;
            if (TestWF(hwnd, WFVPRESENT))
                rcT.left -= SYSMET(CXVSCROLL);
        } else {
            rcT.right = rcT.left = rcClient.right;
            if (TestWF(hwnd, WFVPRESENT))
                rcT.right += SYSMET(CXVSCROLL);
        }

        rcT.top = rcClient.top;
        rcT.bottom = rcClient.bottom;
    } else {
        // Only add on space if horizontal scrollbar is really there.
        rcT.bottom = rcT.top = rcClient.bottom;
        if (TestWF(hwnd, WFHPRESENT))
            rcT.bottom += SYSMET(CYHSCROLL);

        rcT.left = rcClient.left;
        rcT.right = rcClient.right;
    }

    // If InitPwSB stuff fails (due to our heap being full) there isn't anything reasonable
    // we can do here, so just let it go through.  We won't fault but the scrollbar won't work
    // properly either...
    if (_InitPwSB(hwnd))
        CalcSBStuff2(pSBCalc, &rcT, (fVert) ? &CUxScrollBar::GetSBInfo( hwnd )->Vert :  &CUxScrollBar::GetSBInfo( hwnd )->Horz, fVert);

}
#endif 0

/***************************************************************************\
*
*  DrawCtlThumb()
*
\***************************************************************************/
void DrawCtlThumb(SBHWND hwnd)
{
    HBRUSH  hbr, hbrSave;
    HDC     hdc = (HDC) GetWindowDC(hwnd);

    if ( hdc != NULL )
    {
        CUxScrollBarCtl* psb = SBCtlSetup(hwnd);

        if (psb)
        {
            BOOL fOwnerBrush = FALSE;

            hbr = ScrollBar_GetColorObjects(hwnd, hdc, &fOwnerBrush);
            hbrSave = SelectBrush(hdc, hbr);

            DrawThumb2(hwnd, &psb->_calc, hdc, hbr, psb->_fVert, psb->_wDisableFlags, fOwnerBrush);

            SelectBrush(hdc, hbrSave);
        }

        ReleaseDC(hwnd, hdc);
    }
}


//-------------------------------------------------------------------------
void xxxDrawThumb(HWND hwnd, PSBCALC pSBCalc, BOOL fVert)
{
    HBRUSH hbr, hbrSave;
    HDC hdc;
    UINT wDisableFlags;
    SBCALC SBCalc;

    CheckLock(hwnd);

    if (!pSBCalc) 
    {
        pSBCalc = &SBCalc;
    }

    CUxScrollBar::Calc( hwnd, pSBCalc, NULL, fVert );
    wDisableFlags = _GetWndSBDisableFlags(hwnd, fVert);

    hdc = GetWindowDC(hwnd);
    if ( hdc != NULL )
    {
        BOOL fOwnerBrush = FALSE;

        hbr = ScrollBar_GetColorObjects(hwnd, hdc, &fOwnerBrush);
        hbrSave = SelectBrush(hdc, hbr);
        DrawThumb2(hwnd, pSBCalc, hdc, hbr, fVert, wDisableFlags, fOwnerBrush);
        SelectBrush(hdc, hbrSave);
        ReleaseDC(hwnd, hdc);
    }
}


//-------------------------------------------------------------------------
UINT _GetArrowEnableFlags(HWND hwnd, BOOL fVert)
{
    SCROLLBARINFO sbi = {0};
    UINT uFlags = ESB_ENABLE_BOTH;

    sbi.cbSize = sizeof(sbi);
    if ( GetScrollBarInfo(hwnd, fVert ? OBJID_VSCROLL : OBJID_HSCROLL, &sbi) )
    {
        if ( TESTFLAG(sbi.rgstate[INDEX_SCROLLBAR_UP], (STATE_SYSTEM_UNAVAILABLE|STATE_SYSTEM_INVISIBLE)) )
        {
            uFlags |= ESB_DISABLE_UP;
        }

        if ( TESTFLAG(sbi.rgstate[INDEX_SCROLLBAR_DOWN], (STATE_SYSTEM_UNAVAILABLE|STATE_SYSTEM_INVISIBLE)) )
        {
            uFlags |= ESB_DISABLE_DOWN;
        }
    }

    return uFlags;
}


/***************************************************************************\
* _SetScrollBar
*
*
*
* History:
\***************************************************************************/

LONG _SetScrollBar(
    HWND hwnd,
    int code,
    LPSCROLLINFO lpsi,
    BOOL fRedraw)
{
    BOOL        fVert;
    PSBDATA     pw;
    PSBINFO     pSBInfo;
    BOOL        fOldScroll;
    BOOL        fScroll;
    WORD        wfScroll;
    LONG        lres;
    BOOL        fNewScroll;

    CheckLock(hwnd);
    ASSERT(IsWinEventNotifyDeferredOK());

    if (fRedraw)
        // window must be visible to redraw
        fRedraw = IsWindowVisible(hwnd);

    if (code == SB_CTL)
#ifdef FE_SB // xxxSetScrollBar()
        // scroll bar control; send the control a message
        if(GETPTI(hwnd)->TIF_flags & TIF_16BIT) {
            //
            // If the target application is 16bit apps, we don't pass win40's message.
            // This fix for Ichitaro v6.3. It eats the message. It never forwards
            // the un-processed messages to original windows procedure via
            // CallWindowProc().
            //
            // Is this from xxxSetScrollPos() ?
            if(lpsi->fMask == (SIF_POS|SIF_RETURNOLDPOS)) {
                return (int)SendMessage(hwnd, SBM_SETPOS, lpsi->nPos, fRedraw);
            // Is this from xxxSetScrollRange() ?
            } else if(lpsi->fMask == SIF_RANGE) {
                SendMessage(hwnd, SBM_SETRANGE, lpsi->nMin, lpsi->nMax);
                return TRUE;
            // Others...
            } else {
                return (LONG)SendMessage(hwnd, SBM_SETSCROLLINFO, (WPARAM) fRedraw, (LPARAM) lpsi);
            }
        } else {
            return (LONG)SendMessage(hwnd, SBM_SETSCROLLINFO, (WPARAM) fRedraw, (LPARAM) lpsi);
        }
#else
        // scroll bar control; send the control a message
        return (LONG)SendMessage(hwnd, SBM_SETSCROLLINFO, (WPARAM) fRedraw, (LPARAM) lpsi);
#endif // FE_SB

    fVert = (code != SB_HORZ);

    wfScroll = (WORD)((fVert) ? WFVSCROLL : WFHSCROLL);

    fScroll = fOldScroll = (TestWF(hwnd, wfScroll)) ? TRUE : FALSE;

    /*
     * Don't do anything if we're setting position of a nonexistent scroll bar.
     */
    if (!(lpsi->fMask & SIF_RANGE) && !fOldScroll && (CUxScrollBar::GetSBInfo( hwnd ) == NULL)) {
        RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
        return 0;
    }

    pSBInfo = CUxScrollBar::GetSBInfo( hwnd );
    fNewScroll = !pSBInfo;

    if (fNewScroll) {
        CUxScrollBar* psb = CUxScrollBar::Attach( hwnd, FALSE, fRedraw );
        if( NULL == psb )
            return 0;
        
        pSBInfo = psb->GetInfo();
    }

    pw = (fVert) ? &(pSBInfo->Vert) : &(pSBInfo->Horz);

    if (!SBSetParms(pw, lpsi, &fScroll, &lres) && !fNewScroll) 
    {
        // no change -- but if REDRAW is specified and there's a scrollbar,
        // redraw the thumb
        if (fOldScroll && fRedraw)
        {
            goto redrawAfterSet;
        }

        if (lpsi->fMask & SIF_DISABLENOSCROLL)
        {
            xxxEnableWndSBArrows(hwnd, code, _GetArrowEnableFlags(hwnd, fVert));
        }

        return lres;
    }

    ClrWF(hwnd, wfScroll);

    if (fScroll)
        SetWF(hwnd, wfScroll);
    else if (!TestWF(hwnd, (WFHSCROLL | WFVSCROLL)))
    {
        // if neither scroll bar is set and both ranges are 0, then free up the
        // scroll info
        CUxScrollBar::Detach( hwnd );
    }

    if (lpsi->fMask & SIF_DISABLENOSCROLL) 
    {
        if (fOldScroll) 
        {
            SetWF(hwnd, wfScroll);
            xxxEnableWndSBArrows(hwnd, code, _GetArrowEnableFlags(hwnd, fVert));
        }
    } 
    else if (fOldScroll ^ fScroll) 
    {
        PSBTRACK pSBTrack = CUxScrollBar::GetSBTrack(hwnd);
        if (pSBTrack && (hwnd == pSBTrack->hwndTrack)) 
        {
            pSBTrack->fTrackRecalc = TRUE;
        }

        _RedrawFrame(hwnd);
        // Note: after xxx, pSBTrack may no longer be valid (but we return now)
        return lres;
    }

    if (fScroll && fRedraw && (fVert ? TestWF(hwnd, WFVPRESENT) : TestWF(hwnd, WFHPRESENT)))
    {
        PSBTRACK pSBTrack;
redrawAfterSet:
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE,
                       hwnd,
                       (fVert ? OBJID_VSCROLL : OBJID_HSCROLL),
                       INDEX_SCROLLBAR_SELF);

        pSBTrack = CUxScrollBar::GetSBTrack(hwnd);
        // Bail out if the caller is trying to change the position of
        // a scrollbar that is in the middle of tracking.  We'll hose
        // TrackThumb() otherwise.

        if (pSBTrack && (hwnd == pSBTrack->hwndTrack) &&
                ((BOOL)(pSBTrack->fTrackVert) == fVert) &&
                (pSBTrack->pfnSB == _TrackThumb)) {
            return lres;
        }

        xxxDrawThumb(hwnd, NULL, fVert);
        // Note: after xxx, pSBTrack may no longer be valid (but we return now)
    }

    return lres;
}

//-------------------------------------------------------------------------//
LONG WINAPI ThemeSetScrollInfo( HWND hwnd, int nBar, LPCSCROLLINFO psi, BOOL bRedraw )
{
    return _SetScrollBar( hwnd, nBar, (LPSCROLLINFO)psi, bRedraw );
}


//-------------------------------------------------------------------------//
BOOL WINAPI ScrollBar_MouseMove( HWND hwnd, LPPOINT ppt, BOOL fVert )
{
    BOOL fRet = FALSE;
    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );

    if (psb)
    {
        int htScroll = (ppt != NULL) ? HitTestScrollBar(hwnd, fVert, *ppt) : HTNOWHERE;

        //
        // Redraw the scroll bar if the mouse is over something different
        //
        if (htScroll != psb->GetHotComponent(fVert))
        {
            HDC hdc;

            //
            // save the hittest code of the Scrollbar element the mouse is 
            // currently over
            //
            psb->SetHotComponent(htScroll, fVert);

            hdc = GetDCEx(hwnd, NULL, DCX_USESTYLE|DCX_WINDOW|DCX_LOCKWINDOWUPDATE);
            if (hdc != NULL)
            {
                DrawScrollBar(hwnd, hdc, NULL, fVert);
                ReleaseDC(hwnd, hdc);
            }

            fRet = TRUE;
        }
    }
    
    return fRet;
}


//-------------------------------------------------------------------------//
void DrawScrollBar(HWND hwnd, HDC hdc, LPRECT prcOverrideClient, BOOL fVert)
{
    SBCALC SBCalc = {0};
    PSBCALC pSBCalc;
    PSBTRACK pSBTrack = CUxScrollBar::GetSBTrack(hwnd);

    CheckLock(hwnd);
    if (pSBTrack && (hwnd == pSBTrack->hwndTrack) && (pSBTrack->fCtlSB == FALSE)
         && (fVert == (BOOL)pSBTrack->fTrackVert)) 
    {
        pSBCalc = pSBTrack->pSBCalc;
    } 
    else 
    {
        pSBCalc = &SBCalc;
    }
    CUxScrollBar::Calc(hwnd, pSBCalc, prcOverrideClient, fVert);

    xxxDrawSB2(hwnd, pSBCalc, hdc, fVert, _GetWndSBDisableFlags(hwnd, fVert));
}

/***************************************************************************\
* SBPosFromPx
*
* Compute scroll bar position from pixel location
*
* History:
\***************************************************************************/

int SBPosFromPx(
    PSBCALC  pSBCalc,
    int px)
{
    if (px < pSBCalc->pxMin) {
        return pSBCalc->data.posMin;
    }
    if (px >= pSBCalc->pxMin + pSBCalc->cpx) {
        return (pSBCalc->data.posMax - (pSBCalc->data.page ? pSBCalc->data.page - 1 : 0));
    }
    if (pSBCalc->cpx)
        return (pSBCalc->data.posMin + MulDiv(pSBCalc->data.posMax - pSBCalc->data.posMin -
            (pSBCalc->data.page ? pSBCalc->data.page - 1 : 0),
            px - pSBCalc->pxMin, pSBCalc->cpx));
    else
        return (pSBCalc->data.posMin - 1);
}

/***************************************************************************\
* InvertScrollHilite
*
*
*
* History:
\***************************************************************************/

void InvertScrollHilite(
    HWND hwnd,
    PSBTRACK pSBTrack)
{
    HDC hdc;

    /*
     * Don't invert if the thumb is all the way at the top or bottom
     * or you will end up inverting the line between the arrow and the thumb.
     */
    if (!IsRectEmpty(&pSBTrack->rcTrack))
    {
        if (pSBTrack->fTrackRecalc) {
            RecalcTrackRect(pSBTrack);
            pSBTrack->fTrackRecalc = FALSE;
        }

        hdc = (HDC)GetWindowDC(hwnd);
        if( hdc )
        {
            HTHEME hTheme = CUxScrollBar::GetSBTheme(hwnd);
            if (!hTheme)
            {
                InvertRect(hdc, &pSBTrack->rcTrack);
            }
            else
            {
                DrawThemeBackground(hTheme, 
                                    hdc, 
                                    pSBTrack->cmdSB == SB_PAGEUP ? 
                                        (pSBTrack->fTrackVert ? SBP_LOWERTRACKVERT : SBP_LOWERTRACKHORZ) : 
                                        (pSBTrack->fTrackVert ? SBP_UPPERTRACKVERT : SBP_UPPERTRACKHORZ), 
                                    SCRBS_NORMAL, 
                                    &pSBTrack->rcTrack, 
                                    0);
            }
            ReleaseDC(hwnd, hdc);
        }
    }
}

/***************************************************************************\
* xxxDoScroll
*
* Sends scroll notification to the scroll bar owner
*
* History:
\***************************************************************************/

void xxxDoScroll(
    HWND hwnd,
    HWND hwndNotify,
    int cmd,
    int pos,
    BOOL fVert
)
{

    //
    // Send scroll notification to the scrollbar owner. If this is a control
    // the lParam is the control's handle, NULL otherwise.
    //
    SendMessage(hwndNotify, 
                (UINT)(fVert ? WM_VSCROLL : WM_HSCROLL),
                MAKELONG(cmd, pos), 
                (LPARAM)(IsScrollBarControl(hwnd) ? hwnd : NULL));
}

// -------------------------------------------------------------------------
//
//  CheckScrollRecalc()
//
// -------------------------------------------------------------------------
//void CheckScrollRecalc(HWND hwnd, PSBSTATE pSBState, PSBCALC pSBCalc)
//{
//    if ((pSBState->pwndCalc != hwnd) || ((pSBState->nBar != SB_CTL) && (pSBState->nBar != ((pSBState->fVertSB) ? SB_VERT : SB_HORZ))))
//    {
//        // Calculate SB stuff based on whether it's a control or in a window
//        if (pSBState->fCtlSB)
//            SBCtlSetup((SBHWND) hwnd);
//        else
//            CalcSBStuff(hwnd, pSBCalc, pSBState->fVertSB);
//    }
//}


/***************************************************************************\
* xxxMoveThumb
*
* History:
\***************************************************************************/

void xxxMoveThumb(
    HWND hwnd,
    PSBCALC  pSBCalc,
    int px)
{
    HBRUSH        hbr, hbrSave;
    HDC           hdc;
    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );
    PSBTRACK      pSBTrack = psb->GetTrack();

    CheckLock(hwnd);

    if ((pSBTrack == NULL) || (px == pSBTrack->pxOld))
        return;

pxReCalc:

    pSBTrack->posNew = SBPosFromPx(pSBCalc, px);

    /* Tentative position changed -- notify the guy. */
    if (pSBTrack->posNew != pSBTrack->posOld) {
        if (pSBTrack->hwndSBNotify != NULL) {
            psb->DoScroll(pSBTrack->hwndSBNotify, SB_THUMBTRACK, pSBTrack->posNew, pSBTrack->fTrackVert
            );

        }
        // After xxxDoScroll, re-evaluate pSBTrack
        REEVALUATE_PSBTRACK(pSBTrack, hwnd, "xxxMoveThumb(1)");
        if ((pSBTrack == NULL) || (pSBTrack->pfnSB == NULL))
            return;

        pSBTrack->posOld = pSBTrack->posNew;

        //
        // Anything can happen after the SendMessage above!
        // Make sure that the SBINFO structure contains data for the
        // window being tracked -- if not, recalculate data in SBINFO
        //
//        CheckScrollRecalc(hwnd, pSBState, pSBCalc);
        // when we yield, our range can get messed with
        // so make sure we handle this

        if (px >= pSBCalc->pxMin + pSBCalc->cpx)
        {
            px = pSBCalc->pxMin + pSBCalc->cpx;
            goto pxReCalc;
        }

    }

    hdc = GetWindowDC(hwnd);
    if ( hdc != NULL )
    {
        BOOL fOwnerBrush = FALSE;

        pSBCalc->pxThumbTop = px;
        pSBCalc->pxThumbBottom = pSBCalc->pxThumbTop + pSBCalc->cpxThumb;

        // at this point, the disable flags are always going to be 0 --
        // we're in the middle of tracking.
        hbr = ScrollBar_GetColorObjects(hwnd, hdc, &fOwnerBrush);
        hbrSave = SelectBrush(hdc, hbr);

        // After ScrollBar_GetColorObjects, re-evaluate pSBTrack
        REEVALUATE_PSBTRACK(pSBTrack, hwnd, "xxxMoveThumb(2)");
        if (pSBTrack == NULL) 
        {
            RIPMSG1(RIP_ERROR, "Did we use to leak hdc %#p?", hdc) ;
            ReleaseDC(hwnd, hdc);
            return;
        }
        DrawThumb2(hwnd, pSBCalc, hdc, hbr, pSBTrack->fTrackVert, 0, fOwnerBrush);
        SelectBrush(hdc, hbrSave);
        ReleaseDC(hwnd, hdc);
    }

    pSBTrack->pxOld = px;
}

/***************************************************************************\
* zzzDrawInvertScrollArea
*
*
*
* History:
\***************************************************************************/

void zzzDrawInvertScrollArea(
    HWND hwnd,
    PSBTRACK pSBTrack,
    BOOL fHit,
    UINT cmd)
{
    HDC hdc;
    RECT rcTemp;
    int cx, cy;
    HTHEME hTheme;

    if ((cmd != SB_LINEUP) && (cmd != SB_LINEDOWN))
    {
        // not hitting on arrow -- just invert the area and return
        InvertScrollHilite(hwnd, pSBTrack);

        if (cmd == SB_PAGEUP)
        {
            if (fHit)
                SetWF(hwnd, WFPAGEUPBUTTONDOWN);
            else
                ClrWF(hwnd, WFPAGEUPBUTTONDOWN);
        }
        else
        {
            if (fHit)
                SetWF(hwnd, WFPAGEDNBUTTONDOWN);
            else
                ClrWF(hwnd, WFPAGEDNBUTTONDOWN);
        }

        NotifyWinEvent(EVENT_OBJECT_STATECHANGE,
                       hwnd,
                       (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                       ((cmd == SB_PAGEUP) ? INDEX_SCROLLBAR_UPPAGE : INDEX_SCROLLBAR_DOWNPAGE));
        // Note: after zzz, pSBTrack may no longer be valid (but we return now)

        return;
    }

    if (pSBTrack->fTrackRecalc) {
        RecalcTrackRect(pSBTrack);
        pSBTrack->fTrackRecalc = FALSE;
    }

    CopyRect(&rcTemp, &pSBTrack->rcTrack);

    hdc = GetWindowDC(hwnd);
    if( hdc != NULL )
    {
        if (pSBTrack->fTrackVert) {
            cx = SYSMET(CXVSCROLL);
            cy = SYSMET(CYVSCROLL);
        } else {
            cx = SYSMET(CXHSCROLL);
            cy = SYSMET(CYHSCROLL);
        }

        hTheme = CUxScrollBar::GetSBTheme(hwnd);
        if (!hTheme)
        {
            DrawFrameControl(hdc, &rcTemp, DFC_SCROLL,
                ((pSBTrack->fTrackVert) ? DFCS_SCROLLVERT : DFCS_SCROLLHORZ) |
                ((fHit) ? DFCS_PUSHED | DFCS_FLAT : 0) |
                ((cmd == SB_LINEUP) ? DFCS_SCROLLMIN : DFCS_SCROLLMAX));
        }
        else
        {
            INT iStateId;

            // Determine the pressed state of the button
            iStateId = fHit ? SCRBS_PRESSED : SCRBS_NORMAL;

            // Determine which kind of button it is.
            // NOTE: (phellyar) this is dependant on the order of
            //                  the ARROWBTNSTATE enum
            if (pSBTrack->fTrackVert)
            {
                if (cmd == SB_LINEUP)
                {
                    // Up button states are the first four entries
                    // in the enum
                    iStateId += 0;
                }
                else
                {
                    // Down button states are the second four entries
                    // in the enum
                    iStateId += 4;
                }
            }
            else
            {
                if (cmd == SB_LINEUP)
                {
                    // Left button states are the third four entries
                    // in the enum
                    iStateId += 8;
                }
                else
                {
                    // Right button states are the last four entries
                    // in the enum
                    iStateId += 12;
                }
            }
            DrawThemeBackground(hTheme, hdc, SBP_ARROWBTN, iStateId, &rcTemp, 0);
        }

        ReleaseDC(hwnd, hdc);
    }

    if (cmd == SB_LINEUP) {
        if (fHit)
            SetWF(hwnd, WFLINEUPBUTTONDOWN);
        else
            ClrWF(hwnd, WFLINEUPBUTTONDOWN);
    } else {
        if (fHit)
            SetWF(hwnd, WFLINEDNBUTTONDOWN);
        else
            ClrWF(hwnd, WFLINEDNBUTTONDOWN);
    }

    NotifyWinEvent(EVENT_OBJECT_STATECHANGE,
                   hwnd,
                   (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                   (cmd == SB_LINEUP ? INDEX_SCROLLBAR_UP : INDEX_SCROLLBAR_DOWN));
    // Note: after zzz, pSBTrack may no longer be valid (but we return now)
}

/***************************************************************************\
* xxxEndScroll
*
*
*
* History:
\***************************************************************************/

void xxxEndScroll(
    HWND hwnd,
    BOOL fCancel)
{
    UINT oldcmd;
    PSBTRACK pSBTrack;
    CheckLock(hwnd);
    ASSERT(!IsWinEventNotifyDeferred());

    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );
    ASSERT(psb != NULL);
    pSBTrack = psb->GetTrack();

    if (pSBTrack && GetCapture() == hwnd && pSBTrack->pfnSB != NULL) {

        oldcmd = pSBTrack->cmdSB;
        pSBTrack->cmdSB = 0;
        ReleaseCapture();

        // After ReleaseCapture, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

        if (pSBTrack->pfnSB == _TrackThumb) {

            if (fCancel) {
                pSBTrack->posOld = pSBTrack->pSBCalc->data.pos;
            }

            /*
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            if (pSBTrack->hwndSBNotify != NULL) {
                psb->DoScroll( pSBTrack->hwndSBNotify,
                               SB_THUMBPOSITION, pSBTrack->posOld, pSBTrack->fTrackVert
                );
                // After xxxDoScroll, revalidate pSBTrack
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
            }

            if (pSBTrack->fCtlSB) {
                DrawCtlThumb((SBHWND) hwnd);
            } else {
                xxxDrawThumb(hwnd, pSBTrack->pSBCalc, pSBTrack->fTrackVert);
                // Note: after xxx, pSBTrack may no longer be valid
            }

        } else if (pSBTrack->pfnSB == _TrackBox) {
            DWORD lParam;
            POINT ptMsg;
            RECT  rcWindow;

            if (pSBTrack->hTimerSB != 0) {
                _KillSystemTimer(hwnd, IDSYS_SCROLL);
                pSBTrack->hTimerSB = 0;
            }
            lParam = GetMessagePos();
            GetWindowRect( hwnd, &rcWindow );
#ifdef USE_MIRRORING
            if (TestWF(hwnd, WEFLAYOUTRTL)) {
                ptMsg.x = rcWindow.right - GET_X_LPARAM(lParam);
            } else
#endif
            {
                ptMsg.x = GET_X_LPARAM(lParam) - rcWindow.left;
            }
            ptMsg.y = GET_Y_LPARAM(lParam) - rcWindow.top;
            if (PtInRect(&pSBTrack->rcTrack, ptMsg)) {
                zzzDrawInvertScrollArea(hwnd, pSBTrack, FALSE, oldcmd);
                // Note: after zzz, pSBTrack may no longer be valid
            }
        }

        /*
         * Always send SB_ENDSCROLL message.
         *
         * DoScroll does thread locking on these two pwnds -
         * this is ok since they are not used after this
         * call.
         */

        // After xxxDrawThumb or zzzDrawInvertScrollArea, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

        if (pSBTrack->hwndSBNotify != NULL) {
            psb->DoScroll( pSBTrack->hwndSBNotify,
                           SB_ENDSCROLL, 0, pSBTrack->fTrackVert);
            // After xxxDoScroll, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
        }

        ClrWF(hwnd, WFSCROLLBUTTONDOWN);
        ClrWF(hwnd, WFVERTSCROLLTRACK);

        NotifyWinEvent(EVENT_SYSTEM_SCROLLINGEND,
                       hwnd,
                       (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                       INDEXID_CONTAINER);

        // After NotifyWinEvent, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

        // If this is a Scroll Bar Control, turn the caret back on.
        if (pSBTrack->hwndSB != NULL)
        {
            ShowCaret(pSBTrack->hwndSB);
            // After zzz, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
        }

        pSBTrack->pfnSB = NULL;

        /*
         * Unlock structure members so they are no longer holding down windows.
         */
        
        Unlock(&pSBTrack->hwndSB);
        Unlock(&pSBTrack->hwndSBNotify);
        Unlock(&pSBTrack->hwndTrack);
        CUxScrollBar::ClearSBTrack( hwnd );
    }
}


//-------------------------------------------------------------------------//
VOID CALLBACK xxxContScroll(HWND hwnd, UINT message, UINT_PTR ID, DWORD dwTime)
{
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(ID);
    UNREFERENCED_PARAMETER(dwTime);

    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );

    if ( psb != NULL )
    {
        PSBTRACK pSBTrack = psb->GetTrack();

        if ( pSBTrack != NULL )
        {
            LONG pt;
            RECT rcWindow;

            CheckLock(hwnd);

            pt = GetMessagePos();
            GetWindowRect( hwnd, &rcWindow );

            if (TestWF(hwnd, WEFLAYOUTRTL)) 
            {
                pt = MAKELONG(rcWindow.right - GET_X_LPARAM(pt), GET_Y_LPARAM(pt) - rcWindow.top);
            } 
            else
            {
                pt = MAKELONG( GET_X_LPARAM(pt) - rcWindow.left, GET_Y_LPARAM(pt) - rcWindow.top);
            }

            _TrackBox(hwnd, WM_NULL, 0, pt, NULL);

            // After _TrackBox, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

            if (pSBTrack->fHitOld) 
            {
                pSBTrack->hTimerSB = _SetSystemTimer(hwnd, IDSYS_SCROLL, DTTIME/8, xxxContScroll);

                // DoScroll does thread locking on these two pwnds -
                // this is ok since they are not used after this call.
                if (pSBTrack->hwndSBNotify != NULL) 
                {
                    psb->DoScroll(pSBTrack->hwndSBNotify, pSBTrack->cmdSB, 0, pSBTrack->fTrackVert);
                    // Note: after xxx, pSBTrack may no longer be valid (but we return now)
                }
            }
        }
    }
}


//-------------------------------------------------------------------------//
void CALLBACK _TrackBox(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, PSBCALC pSBCalc)
{
    CUxScrollBar* psb = CUxScrollBar::FromHwnd(hwnd);

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(pSBCalc);

    CheckLock(hwnd);
    ASSERT(IsWinEventNotifyDeferredOK());

    if ( psb )
    {
        PSBTRACK pSBTrack = psb->GetTrack();

        if ( pSBTrack )
        {
            BOOL  fHit;
            POINT ptHit;
            int   cmsTimer;

            if ((uMsg != WM_NULL) && (HIBYTE(uMsg) != HIBYTE(WM_MOUSEFIRST)))
            {
                return;
            }

            if (pSBTrack->fTrackRecalc) 
            {
                RecalcTrackRect(pSBTrack);
                pSBTrack->fTrackRecalc = FALSE;
            }

            ptHit.x = GET_X_LPARAM(lParam);
            ptHit.y = GET_Y_LPARAM(lParam);
            fHit = PtInRect(&pSBTrack->rcTrack, ptHit);

            if (fHit != (BOOL)pSBTrack->fHitOld) 
            {
                zzzDrawInvertScrollArea(hwnd, pSBTrack, fHit, pSBTrack->cmdSB);
                // After zzz, pSBTrack may no longer be valid
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
            }

            cmsTimer = DTTIME/8;

            switch (uMsg) 
            {
            case WM_LBUTTONUP:
                xxxEndScroll(hwnd, FALSE);
                // Note: after xxx, pSBTrack may no longer be valid
                break;

            case WM_LBUTTONDOWN:
                pSBTrack->hTimerSB = 0;
                cmsTimer = DTTIME;

                //
                // FALL THRU
                //

            case WM_MOUSEMOVE:
                if (fHit && fHit != (BOOL)pSBTrack->fHitOld) 
                {
                    //
                    // We moved back into the normal rectangle: reset timer
                    //
                    pSBTrack->hTimerSB = _SetSystemTimer(hwnd, IDSYS_SCROLL,
                            cmsTimer, xxxContScroll);

                    //
                    // DoScroll does thread locking on these two pwnds -
                    // this is ok since they are not used after this
                    // call.
                    //
                    if (pSBTrack->hwndSBNotify != NULL) 
                    {
                        psb->DoScroll( pSBTrack->hwndSBNotify, pSBTrack->cmdSB, 
                                       0, pSBTrack->fTrackVert);
                        // Note: after xxx, pSBTrack may no longer be valid
                    }
                }

                break;
            }

            // After xxxDoScroll or xxxEndScroll, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
            pSBTrack->fHitOld = fHit;
        }
    }
}


/***************************************************************************\
* _TrackThumb
*
*
*
* History:
\***************************************************************************/

void CALLBACK _TrackThumb(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    PSBCALC pSBCalc)
{
    int px;
    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );
    ASSERT(psb);
    PSBTRACK pSBTrack = psb->GetTrack();
    POINT pt;

    UNREFERENCED_PARAMETER(wParam);

    CheckLock(hwnd);

    if (HIBYTE(message) != HIBYTE(WM_MOUSEFIRST))
        return;

    if (pSBTrack == NULL)
        return;

    // Make sure that the SBINFO structure contains data for the
    // window being tracked -- if not, recalculate data in SBINFO
//    CheckScrollRecalc(hwnd, pSBState, pSBCalc);
    if (pSBTrack->fTrackRecalc) {
        RecalcTrackRect(pSBTrack);
        pSBTrack->fTrackRecalc = FALSE;
    }


    pt.y = GET_Y_LPARAM(lParam);
    pt.x = GET_X_LPARAM(lParam);
    if (!PtInRect(&pSBTrack->rcTrack, pt))
        px = pSBCalc->pxStart;
    else {
        px = (pSBTrack->fTrackVert ? pt.y : pt.x) + pSBTrack->dpxThumb;
        if (px < pSBCalc->pxMin)
            px = pSBCalc->pxMin;
        else if (px >= pSBCalc->pxMin + pSBCalc->cpx)
            px = pSBCalc->pxMin + pSBCalc->cpx;
    }

    xxxMoveThumb(hwnd, pSBCalc, px);

    /*
     * We won't get the WM_LBUTTONUP message if we got here through
     * the scroll menu, so test the button state directly.
     */
    if (message == WM_LBUTTONUP || GetKeyState(VK_LBUTTON) >= 0) {
        xxxEndScroll(hwnd, FALSE);
    }

}

/***************************************************************************\
* _ClientToWindow
* History:
\***************************************************************************/
BOOL _ClientToWindow( HWND hwnd, LPPOINT ppt )
{
    WINDOWINFO wi;
    wi.cbSize = sizeof(wi);
    if( GetWindowInfo( hwnd, &wi ) )
    {
        ppt->x += (wi.rcClient.left - wi.rcWindow.left);
        ppt->y += (wi.rcClient.top -  wi.rcWindow.top);
        return TRUE;
    }
    return FALSE;
}

/***************************************************************************\
* xxxSBTrackLoop
*
*
*
* History:
\***************************************************************************/

void xxxSBTrackLoop(
    HWND hwnd,
    LPARAM lParam,
    PSBCALC pSBCalc)
{
    MSG msg;
    UINT cmd;
    VOID (*pfnSB)(HWND, UINT, WPARAM, LPARAM, PSBCALC);
    CUxScrollBar* psb = CUxScrollBar::FromHwnd( hwnd );
    PSBTRACK pSBTrack = psb->GetSBTrack(hwnd);

    CheckLock(hwnd);
    ASSERT(IsWinEventNotifyDeferredOK());


    if (pSBTrack == NULL)
        // mode cancelled -- exit track loop
        return;
    
    pfnSB = pSBTrack->pfnSB;
    if (pfnSB == NULL)
        // mode cancelled -- exit track loop
        return;

    if (pSBTrack->fTrackVert)
        SetWF(hwnd, WFVERTSCROLLTRACK);

    NotifyWinEvent(EVENT_SYSTEM_SCROLLINGSTART,
                   hwnd,
                   (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                   INDEXID_CONTAINER);
    // Note: after xxx, pSBTrack may no longer be valid

    (*pfnSB)(hwnd, WM_LBUTTONDOWN, 0, lParam, pSBCalc);
    // Note: after xxx, pSBTrack may no longer be valid

    while (GetCapture() == hwnd) {
        if (!GetMessage(&msg, NULL, 0, 0)) {
            // Note: after xxx, pSBTrack may no longer be valid
            break;
        }

        if (!CallMsgFilter(&msg, MSGF_SCROLLBAR))
        {
            BOOL bTrackMsg = FALSE;
            cmd = msg.message;
            lParam = msg.lParam;

            if (msg.hwnd == HWq(hwnd))
            {
                if( cmd >= WM_MOUSEFIRST && cmd <= WM_MOUSELAST )
                {
                    if( !psb->IsCtl() )
                    {
                        POINT pt;
                        pt.x = GET_X_LPARAM(msg.lParam);
                        pt.y = GET_Y_LPARAM(msg.lParam);
                        _ClientToWindow( hwnd, &pt );
                        lParam = MAKELPARAM(pt.x, pt.y);
                    }
                    bTrackMsg = TRUE;
                }
                else if( cmd >= WM_KEYFIRST && cmd <= WM_KEYLAST )
                {
                    cmd = _SysToChar(cmd, msg.lParam);
                    bTrackMsg = TRUE;
                }
            }

            if( bTrackMsg )
            {
                // After NotifyWinEvent, pfnSB, TranslateMessage or
                // DispatchMessage, re-evaluate pSBTrack.
                REEVALUATE_PSBTRACK(pSBTrack, hwnd, "xxxTrackLoop");
                if ((pSBTrack == NULL) || (NULL == (pfnSB = pSBTrack->pfnSB)))
                    // mode cancelled -- exit track loop
                    return;

                (*pfnSB)(hwnd, cmd, msg.wParam, lParam, pSBCalc);
            }
            else
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
}


/***************************************************************************\
* _SBTrackInit
*
* History:
\***************************************************************************/

void _SBTrackInit(
    HWND hwnd,
    LPARAM lParam,
    int curArea,
    UINT uType)
{
    int px;
    LPINT pwX;
    LPINT pwY;
    UINT wDisable;     // Scroll bar disable flags;
    SBCALC SBCalc = {0};
    PSBCALC pSBCalc;
    RECT rcSB;
    PSBTRACK pSBTrack;

    CheckLock(hwnd);

#ifdef PORTPORT // unneccessary dbgchk w/ port
    if (CUxScrollBar::GetSBTrack(hwnd)) {
        RIPMSG1(RIP_WARNING, "_SBTrackInit: CUxScrollBar::GetSBTrack(hwnd) == %#p",
                CUxScrollBar::GetSBTrack(hwnd));
        return;
    }
#endif PORTPORT

    CUxScrollBar*    psb = CUxScrollBar::Attach( hwnd, !curArea, TRUE );

    if (!psb)
    {
        return;
    }
     
    CUxScrollBarCtl* psbCtl = psb->IsCtl() ? (CUxScrollBarCtl*)psb : NULL;

    pSBTrack = psb->GetTrack();
    if (pSBTrack == NULL)
        return;

    pSBTrack->hTimerSB = 0;
    pSBTrack->fHitOld = FALSE;

    pSBTrack->pfnSB = _TrackBox;

    pSBTrack->hwndTrack = NULL;
    pSBTrack->hwndSB = NULL;
    pSBTrack->hwndSBNotify = NULL;
    Lock(&pSBTrack->hwndTrack, hwnd); // pSBTrack->hwndTrack = hwnd;  

    pSBTrack->fCtlSB = (!curArea);
    if (pSBTrack->fCtlSB)
    {
        /*
         * This is a scroll bar control.
         */
        ASSERT(psbCtl != NULL);

        pSBTrack->hwndSB = hwnd; //Lock(&pSBTrack->hwndSB, hwnd);
        pSBTrack->fTrackVert = psbCtl->_fVert;
        Lock(&pSBTrack->hwndSBNotify, GetParent(hwnd)); // pSBTrack->hwndSBNotify = GetParent( hwnd );
        wDisable = psbCtl->_wDisableFlags;
        pSBCalc = &psbCtl->_calc;
        pSBTrack->nBar = SB_CTL;
    } else {

        /*
         * This is a scroll bar that is part of the window frame.
         */
        RECT rcWindow;
        GetWindowRect( hwnd, &rcWindow );
        int x = GET_X_LPARAM(lParam);
        int y = GET_Y_LPARAM(lParam);

#ifdef USE_MIRRORING
        //
        // Mirror the window coord of the scroll bar,
        // if it is a mirrored one
        //
        if (TestWF(hwnd,WEFLAYOUTRTL)) {
            lParam = MAKELONG(
                    rcWindow.right - x,
                    y - rcWindow.top);
        }
        else {
#endif
        lParam = MAKELONG( x - rcWindow.left, y - rcWindow.top);

#ifdef USE_MIRRORING
        }
#endif
        Lock(&pSBTrack->hwndSBNotify, hwnd); // pSBTrack->hwndSBNotify = hwnd; //
        Lock(&pSBTrack->hwndSB, NULL);       // pSBTrack->hwndSB = NULL;
        
        pSBTrack->fTrackVert = (curArea - HTHSCROLL);
        wDisable = _GetWndSBDisableFlags(hwnd, pSBTrack->fTrackVert);
        pSBCalc = &SBCalc;
        pSBTrack->nBar = (curArea - HTHSCROLL) ? SB_VERT : SB_HORZ;
    }

    pSBTrack->pSBCalc = pSBCalc;
    /*
     *  Check if the whole scroll bar is disabled
     */
    if((wDisable & SB_DISABLE_MASK) == SB_DISABLE_MASK) {
        CUxScrollBar::Detach( hwnd );
        return;  // It is a disabled scroll bar; So, do not respond.
    }

    if (!pSBTrack->fCtlSB) {
        psb->FreshenSBData( pSBTrack->nBar, FALSE );
        CUxScrollBar::Calc(hwnd, pSBCalc, NULL, pSBTrack->fTrackVert);
    }

    pwX = (LPINT)&rcSB;
    pwY = pwX + 1;
    if (!pSBTrack->fTrackVert)
        pwX = pwY--;

    px = (pSBTrack->fTrackVert ? GET_Y_LPARAM(lParam) : GET_X_LPARAM(lParam));

    *(pwX + 0) = pSBCalc->pxLeft;
    *(pwY + 0) = pSBCalc->pxTop;
    *(pwX + 2) = pSBCalc->pxRight;
    *(pwY + 2) = pSBCalc->pxBottom;
    pSBTrack->cmdSB = (UINT)-1;
    if (px < pSBCalc->pxUpArrow) {

        /*
         *  The click occurred on Left/Up arrow; Check if it is disabled
         */
        if(wDisable & LTUPFLAG) {
            if(pSBTrack->fCtlSB) {   // If this is a scroll bar control,
                ShowCaret(pSBTrack->hwndSB);  // show the caret before returning;
                // After ShowCaret, revalidate pSBTrack
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
            }
            CUxScrollBar::Detach( hwnd );
            return;         // Yes! disabled. Do not respond.
        }

        // LINEUP -- make rcSB the Up Arrow's Rectangle
        pSBTrack->cmdSB = SB_LINEUP;
        *(pwY + 2) = pSBCalc->pxUpArrow;
    } else if (px >= pSBCalc->pxDownArrow) {

        /*
         * The click occurred on Right/Down arrow; Check if it is disabled
         */
        if (wDisable & RTDNFLAG) {
            if (pSBTrack->fCtlSB) {    // If this is a scroll bar control,
                ShowCaret(pSBTrack->hwndSB);  // show the caret before returning;
                // After ShowCaret, revalidate pSBTrack
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);
            }

            CUxScrollBar::Detach( hwnd );
            return;// Yes! disabled. Do not respond.
        }

        // LINEDOWN -- make rcSB the Down Arrow's Rectangle
        pSBTrack->cmdSB = SB_LINEDOWN;
        *(pwY + 0) = pSBCalc->pxDownArrow;
    } else if (px < pSBCalc->pxThumbTop) {
        // PAGEUP -- make rcSB the rectangle between Up Arrow and Thumb
        pSBTrack->cmdSB = SB_PAGEUP;
        *(pwY + 0) = pSBCalc->pxUpArrow;
        *(pwY + 2) = pSBCalc->pxThumbTop;
    } else if (px < pSBCalc->pxThumbBottom) {

DoThumbPos:
        /*
         * Elevator isn't there if there's no room.
         */
        if (pSBCalc->pxDownArrow - pSBCalc->pxUpArrow <= pSBCalc->cpxThumb) {
            CUxScrollBar::Detach( hwnd );
            return;
        }
        // THUMBPOSITION -- we're tracking with the thumb
        pSBTrack->cmdSB = SB_THUMBPOSITION;
        CalcTrackDragRect(pSBTrack);

        pSBTrack->pfnSB = _TrackThumb;
        pSBTrack->pxOld = pSBCalc->pxStart = pSBCalc->pxThumbTop;
        pSBTrack->posNew = pSBTrack->posOld = pSBCalc->data.pos;
        pSBTrack->dpxThumb = pSBCalc->pxStart - px;

        SetCapture( hwnd ); //xxxCapture(PtiCurrent(), hwnd, WINDOW_CAPTURE);
        
        // After xxxCapture, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

        /*
         * DoScroll does thread locking on these two pwnds -
         * this is ok since they are not used after this
         * call.
         */
        if (pSBTrack->hwndSBNotify != NULL) {
            psb->DoScroll( pSBTrack->hwndSBNotify, SB_THUMBTRACK, 
                           pSBTrack->posOld, pSBTrack->fTrackVert
            );
            // Note: after xxx, pSBTrack may no longer be valid
        }
    } else if (px < pSBCalc->pxDownArrow) {
        // PAGEDOWN -- make rcSB the rectangle between Thumb and Down Arrow
        pSBTrack->cmdSB = SB_PAGEDOWN;
        *(pwY + 0) = pSBCalc->pxThumbBottom;
        *(pwY + 2) = pSBCalc->pxDownArrow;
    }

    /*
     * If the shift key is down, we'll position the thumb directly so it's
     * centered on the click point.
     */
    if ((uType == SCROLL_DIRECT && pSBTrack->cmdSB != SB_LINEUP && pSBTrack->cmdSB != SB_LINEDOWN) ||
            (uType == SCROLL_MENU)) {
        if (pSBTrack->cmdSB != SB_THUMBPOSITION) {
            goto DoThumbPos;
        }
        pSBTrack->dpxThumb = -(pSBCalc->cpxThumb / 2);
    }

    SetCapture( hwnd ); // xxxCapture(PtiCurrent(), hwnd, WINDOW_CAPTURE);
    // After xxxCapture, revalidate pSBTrack
    RETURN_IF_PSBTRACK_INVALID(pSBTrack, hwnd);

    if (pSBTrack->cmdSB != SB_THUMBPOSITION) {
        CopyRect(&pSBTrack->rcTrack, &rcSB);
    }

    xxxSBTrackLoop(hwnd, lParam, pSBCalc);

    // After xxx, re-evaluate pSBTrack
    REEVALUATE_PSBTRACK(pSBTrack, hwnd, "xxxTrackLoop");
    if (pSBTrack) 
    {
        CUxScrollBar::ClearSBTrack( hwnd );
    }
}

/***************************************************************************\
* HandleScrollCmd
*
* History: added to support and encap SB tracking initialization originating
*          from WM_SYSCOMMAND::SC_VSCROLL/SC_HSCROLL [scotthan]
\***************************************************************************/
void WINAPI HandleScrollCmd( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    UINT uArea = (UINT)(wParam & 0x0F);
    _SBTrackInit( hwnd, lParam, uArea, 
                    (GetKeyState(VK_SHIFT) < 0) ? SCROLL_DIRECT : SCROLL_NORMAL);
}


//-------------------------------------------------------------------------
HMENU ScrollBar_GetMenu(HWND hwnd, BOOL fVert)
{
    static HMODULE hModUser = NULL;
    HMENU hMenu = NULL;

    if ( !hModUser )
    {
        hModUser = GetModuleHandle(TEXT("user32"));
    }

#define ID_HSCROLLMENU  0x40
#define ID_VSCROLLMENU  0x50

    if ( hModUser )
    {
        hMenu = LoadMenu(hModUser, MAKEINTRESOURCE((fVert ? ID_VSCROLLMENU : ID_HSCROLLMENU)));
        if ( hMenu ) 
        {
            hMenu = GetSubMenu(hMenu, 0);
        }
    }

    return hMenu;
}


//-------------------------------------------------------------------------
VOID ScrollBar_Menu(HWND hwndNotify, HWND hwnd, LPARAM lParam, BOOL fVert)
{
    CUxScrollBar*    psb    = CUxScrollBar::FromHwnd( hwnd );
    CUxScrollBarCtl* psbCtl = CUxScrollBarCtl::FromHwnd( hwnd );
    BOOL fCtl = (psbCtl != NULL);

    if ( psb || psbCtl )
    {
        UINT  wDisable;
        RECT  rcWindow;
        POINT pt;

        GetWindowRect(hwnd, &rcWindow);

        POINTSTOPOINT(pt, lParam);
        if ( TestWF(hwnd, WEFLAYOUTRTL) && !fVert ) 
        {
            MIRROR_POINT(rcWindow, pt);
        }
        pt.x -= rcWindow.left;
        pt.y -= rcWindow.top;

        if ( fCtl ) 
        {
            wDisable = psbCtl->_wDisableFlags;
        } 
        else 
        {
            wDisable = _GetWndSBDisableFlags(hwndNotify, fVert);
        }

        // Make sure the scrollbar isn't disabled.
        if ( (wDisable & SB_DISABLE_MASK) != SB_DISABLE_MASK) 
        {
            HMENU hMenu = ScrollBar_GetMenu(hwndNotify, fVert);

            // Put up a menu and scroll accordingly.
            if (hMenu != NULL) 
            {
                int iCmd;

                iCmd = TrackPopupMenuEx(hMenu,
                            TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
                            GET_X_LPARAM(lParam),
                            GET_Y_LPARAM(lParam),
                            hwndNotify,
                            NULL);

                DestroyMenu(hMenu);

                if (iCmd) 
                {
                    if ((iCmd & 0x00FF) == SB_THUMBPOSITION) 
                    {
                        if ( fCtl ) 
                        {
                            _SBTrackInit(hwnd, MAKELPARAM(pt.x, pt.y), 0, SCROLL_MENU);
                        }   
                        else 
                        {
                            _SBTrackInit(hwndNotify, lParam, fVert ? HTVSCROLL : HTHSCROLL, SCROLL_MENU);
                        }
                    } 
                    else 
                    {
                        xxxDoScroll(hwnd, hwndNotify, (iCmd & 0x00FF), 0, fVert);
                        xxxDoScroll(hwnd, hwndNotify, SB_ENDSCROLL, 0, fVert);
                    }
                }
            }
        }
    }
}


//-------------------------------------------------------------------------
LRESULT CUxScrollBarCtl::WndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    LONG         l;
    LONG         lres = 0;
    int          cx, cy;
    UINT         cmd;
    UINT         uSide;
    HDC          hdc;
    RECT         rc;
    POINT        pt;
    BOOL         fSizeReal;
    HBRUSH       hbrSave;
    BOOL         fSize;
    PAINTSTRUCT  ps;
    DWORD        dwStyle;
    SCROLLINFO   si;
    LPSCROLLINFO lpsi = &si;
    BOOL         fRedraw = FALSE;
    BOOL         fScroll;
    
    CUxScrollBarCtl* psb = CUxScrollBarCtl::FromHwnd( hwnd );
    if (!psb && uMsg != WM_NCCREATE)
    {
        goto CallDWP;
    }

    CheckLock(hwnd);
    ASSERT(IsWinEventNotifyDeferredOK());

    VALIDATECLASSANDSIZE(((HWND)hwnd), uMsg, wParam, lParam, FNID_SCROLLBAR, WM_CREATE);

    dwStyle = GetWindowStyle(hwnd);
    fSize = (((LOBYTE(dwStyle)) & (SBS_SIZEBOX | SBS_SIZEGRIP)) != 0);

    switch (uMsg) 
    {
    
    case WM_NCCREATE:
        
        if( NULL == psb )
        {
            psb = (CUxScrollBarCtl*)CUxScrollBar::Attach( hwnd, TRUE, FALSE );
        }

        goto CallDWP;
        
    case WM_NCDESTROY:
        CUxScrollBar::Detach(hwnd);
        psb = NULL;
        goto CallDWP;

    case WM_CREATE:
        /*
         * Guard against lParam being NULL since the thunk allows it [51986]
         */

        if (lParam) 
        {
            rc.right = (rc.left = ((LPCREATESTRUCT)lParam)->x) +
                    ((LPCREATESTRUCT)lParam)->cx;
            rc.bottom = (rc.top = ((LPCREATESTRUCT)lParam)->y) +
                    ((LPCREATESTRUCT)lParam)->cy;
            // This is because we can't just rev CardFile -- we should fix the
            // problem here in case anyone else happened to have some EXTRA
            // scroll styles on their scroll bar controls (jeffbog 03/21/94)
            if (!TestWF((HWND)hwnd, WFWIN40COMPAT))
                dwStyle &= ~(WS_HSCROLL | WS_VSCROLL);

            if (!fSize) 
            {
                l = PtrToLong(((LPCREATESTRUCT)lParam)->lpCreateParams);
                
                psb->_calc.data.pos = psb->_calc.data.posMin = LOWORD(l);
                psb->_calc.data.posMax = HIWORD(l);
                psb->_fVert = ((LOBYTE(dwStyle) & SBS_VERT) != 0);
                psb->_calc.data.page = 0;
            }

            if (dwStyle & WS_DISABLED)
                psb->_wDisableFlags = SB_DISABLE_MASK;

            if (LOBYTE(dwStyle) & (SBS_TOPALIGN | SBS_BOTTOMALIGN)) {
                if (fSize) {
                    if (LOBYTE(dwStyle) & SBS_SIZEBOXBOTTOMRIGHTALIGN) {
                        rc.left = rc.right - SYSMET(CXVSCROLL);
                        rc.top = rc.bottom - SYSMET(CYHSCROLL);
                    }

                    rc.right = rc.left + SYSMET(CXVSCROLL);
                    rc.bottom = rc.top + SYSMET(CYHSCROLL);
                } else {
                    if (LOBYTE(dwStyle) & SBS_VERT) {
                        if (LOBYTE(dwStyle) & SBS_LEFTALIGN)
                            rc.right = rc.left + SYSMET(CXVSCROLL);
                        else
                            rc.left = rc.right - SYSMET(CXVSCROLL);
                    } else {
                        if (LOBYTE(dwStyle) & SBS_TOPALIGN)
                            rc.bottom = rc.top + SYSMET(CYHSCROLL);
                        else
                            rc.top = rc.bottom - SYSMET(CYHSCROLL);
                    }
                }

                MoveWindow((HWND)hwnd, rc.left, rc.top, rc.right - rc.left,
                         rc.bottom - rc.top, FALSE);
            }
        } /* if */

        else {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING,
                    "UxScrollBarCtlWndProc - NULL lParam for WM_CREATE\n") ;
        } /* else */

        break;

    case WM_SIZE:
        if (GetFocus() != (HWND)hwnd)
            break;

        // scroll bar has the focus -- recalc it's thumb caret size
        // no need to DeferWinEventNotify() - see CreateCaret below.
        DestroyCaret();

            //   |             |
            //   |  FALL THRU  |
            //   V             V

    case WM_SETFOCUS:
    {
        // REVIEW (phellyar) Do we want themed scroll bars to have
        //                   a caret?
        if ( !psb->GetTheme() )
        {
            SBCtlSetup(hwnd);
            RECT rcWindow;
            GetWindowRect( hwnd, &rcWindow );

            cx = (psb->_fVert ? rcWindow.right - rcWindow.left
                                : psb->_calc.cpxThumb) - 2 * SYSMET(CXEDGE);
            cy = (psb->_fVert ? psb->_calc.cpxThumb
                                : rcWindow.bottom - rcWindow.top) - 2 * SYSMET(CYEDGE);
#ifdef _VISUAL_DELTA_
            cx -= (CARET_BORDERWIDTH * 2);
            cy -= (CARET_BORDERWIDTH * 2);
#endif _VISUAL_DELTA_

            CreateCaret((HWND)hwnd, (HBITMAP)1, cx, cy);
            zzzSetSBCaretPos(hwnd);
            ShowCaret((HWND)hwnd);
        }
        break;
    }

    case WM_KILLFOCUS:
        DestroyCaret();
        break;

    case WM_ERASEBKGND:

        /*
         * Do nothing, but don't let DefWndProc() do it either.
         * It will be erased when its painted.
         */
        return (LONG)TRUE;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        if ((hdc = (HDC)wParam) == NULL) {
            hdc = BeginPaint((HWND)hwnd, (LPPAINTSTRUCT)&ps);
        }
        if (!fSize) {
            SBCtlSetup(hwnd);
            xxxDrawSB2((HWND)hwnd, &psb->_calc, hdc, psb->_fVert, psb->_wDisableFlags);
        } else {
            fSizeReal = TestWF((HWND)hwnd, WFSIZEBOX);
            if (!fSizeReal)
                SetWF((HWND)hwnd, WFSIZEBOX);

            _DrawSizeBoxFromFrame((HWND)hwnd, hdc, 0, 0);

            if (!fSizeReal)
                ClrWF((HWND)hwnd, WFSIZEBOX);
        }

        if (wParam == 0L)
            EndPaint((HWND)hwnd, (LPPAINTSTRUCT)&ps);
        break;

    case WM_GETDLGCODE:
        return DLGC_WANTARROWS;

    case WM_CONTEXTMENU:
    {
        HWND hwndParent = GetParent(hwnd);
        if (hwndParent)
        {
            ScrollBar_Menu(hwndParent, hwnd, lParam, psb->_fVert);
        }
        break;

    }
    case WM_NCHITTEST:
        if (LOBYTE(dwStyle) & SBS_SIZEGRIP) {
#ifdef USE_MIRRORING
            /*
             * If the scroll bar is RTL mirrored, then
             * mirror the hittest of the grip location.
             */
            if (TestWF((HWND)hwnd, WEFLAYOUTRTL))
                return HTBOTTOMLEFT;
            else
#endif
                return HTBOTTOMRIGHT;
        } else {
            goto CallDWP;
        }
        break;

    case WM_MOUSELEAVE:
        //xxxHotTrackSBCtl(hwnd, 0, FALSE);
        psb->SetHotComponent(HTNOWHERE, psb->_fVert);
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_MOUSEMOVE:
    {
        INT ht;

        if (psb->GetHotComponent(psb->_fVert) == 0) 
        {
            TRACKMOUSEEVENT tme;

            tme.cbSize      = sizeof(TRACKMOUSEEVENT);
            tme.dwFlags     = TME_LEAVE;
            tme.hwndTrack   = hwnd;
            tme.dwHoverTime = 0;

            TrackMouseEvent(&tme);
        }

        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        ht = HitTestScrollBar((HWND)hwnd, psb->_fVert, pt);
        if (psb->GetHotComponent(psb->_fVert) != ht) 
        {
            //xxxHotTrackSBCtl(hwnd, ht, TRUE);
            psb->SetHotComponent(ht, psb->_fVert);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        break;

    }
    case WM_LBUTTONDBLCLK:
        cmd = SC_ZOOM;
        if (fSize)
            goto postmsg;

        /*
         *** FALL THRU **
         */

    case WM_LBUTTONDOWN:
            //
            // Note that SBS_SIZEGRIP guys normally won't ever see button
            // downs.  This is because they return HTBOTTOMRIGHT to
            // WindowHitTest handling.  This will walk up the parent chain
            // to the first sizeable ancestor, bailing out at caption windows
            // of course.  That dude, if he exists, will handle the sizing
            // instead.
            //
        if (!fSize) {
            if (TestWF((HWND)hwnd, WFTABSTOP)) {
                SetFocus((HWND)hwnd);
            }

            HideCaret((HWND)hwnd);
            SBCtlSetup(hwnd);

            /*
             * SBCtlSetup enters SEM_SB, and _SBTrackInit leaves it.
             */
            _SBTrackInit((HWND)hwnd, lParam, 0, (GetKeyState(VK_SHIFT) < 0) ? SCROLL_DIRECT : SCROLL_NORMAL);
            break;
        } else {
            cmd = SC_SIZE;
postmsg:
            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);
            ClientToScreen((HWND)hwnd, &pt);
            lParam = MAKELONG(pt.x, pt.y);

            /*
             * convert HT value into a move value.  This is bad,
             * but this is purely temporary.
             */
#ifdef USE_MIRRORING
            if (TestWF(GetParent(hwnd),WEFLAYOUTRTL))
            {
                uSide = HTBOTTOMLEFT;
            } 
            else 
#endif
            {
                uSide = HTBOTTOMRIGHT;
            }
            ThreadLock(((HWND)hwnd)->hwndParent, &tlpwndParent);
            SendMessage(GetParent(hwnd), WM_SYSCOMMAND,
                    (cmd | (uSide - HTSIZEFIRST + 1)), lParam);
            ThreadUnlock(&tlpwndParent);
        }
        break;

    case WM_KEYUP:
        switch (wParam) {
        case VK_HOME:
        case VK_END:
        case VK_PRIOR:
        case VK_NEXT:
        case VK_LEFT:
        case VK_UP:
        case VK_RIGHT:
        case VK_DOWN:

            /*
             * Send end scroll uMsg when user up clicks on keyboard
             * scrolling.
             *
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            xxxDoScroll( (HWND)hwnd, GetParent(hwnd),
                         SB_ENDSCROLL, 0, psb->_fVert
            );
            break;

        default:
            break;
        }
        break;

    case WM_KEYDOWN:
        switch (wParam) {
        case VK_HOME:
            wParam = SB_TOP;
            goto KeyScroll;

        case VK_END:
            wParam = SB_BOTTOM;
            goto KeyScroll;

        case VK_PRIOR:
            wParam = SB_PAGEUP;
            goto KeyScroll;

        case VK_NEXT:
            wParam = SB_PAGEDOWN;
            goto KeyScroll;

        case VK_LEFT:
        case VK_UP:
            wParam = SB_LINEUP;
            goto KeyScroll;

        case VK_RIGHT:
        case VK_DOWN:
            wParam = SB_LINEDOWN;
KeyScroll:

            /*
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            xxxDoScroll((HWND)hwnd, GetParent(hwnd), (int)wParam, 0, psb->_fVert
            );
            break;

        default:
            break;
        }
        break;

    case WM_ENABLE:
        return SendMessage((HWND)hwnd, SBM_ENABLE_ARROWS,
               (wParam ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH), 0);

    case SBM_ENABLE_ARROWS:

        /*
         * This is used to enable/disable the arrows in a SB ctrl
         */
        return (LONG)xxxEnableSBCtlArrows((HWND)hwnd, (UINT)wParam);

    case SBM_GETPOS:
        return (LONG)psb->_calc.data.pos;

    case SBM_GETRANGE:
        *((LPINT)wParam) = psb->_calc.data.posMin;
        *((LPINT)lParam) = psb->_calc.data.posMax;
        return MAKELRESULT(LOWORD(psb->_calc.data.posMin), LOWORD(psb->_calc.data.posMax));

    case SBM_GETSCROLLINFO:
        return (LONG)_SBGetParms((HWND)hwnd, SB_CTL, (PSBDATA)&psb->_calc, (LPSCROLLINFO) lParam);

    case SBM_SETRANGEREDRAW:
        fRedraw = TRUE;

    case SBM_SETRANGE:
        // Save the old values of Min and Max for return value
        si.cbSize = sizeof(si);
//        si.nMin = LOWORD(lParam);
//        si.nMax = HIWORD(lParam);
        si.nMin = (int)wParam;
        si.nMax = (int)lParam;
        si.fMask = SIF_RANGE | SIF_RETURNOLDPOS;
        goto SetInfo;

    case SBM_SETPOS:
        fRedraw = (BOOL) lParam;
        si.cbSize = sizeof(si);
        si.fMask = SIF_POS | SIF_RETURNOLDPOS;
        si.nPos  = (int)wParam;
        goto SetInfo;

    case SBM_SETSCROLLINFO:
    {
        lpsi = (LPSCROLLINFO) lParam;
        fRedraw = (BOOL) wParam;
SetInfo:
        fScroll = TRUE;
        lres = SBSetParms((PSBDATA)&psb->_calc, lpsi, &fScroll, &lres);

        if (SBSetParms((PSBDATA)&psb->_calc, lpsi, &fScroll, &lres))
        {
            NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, hwnd, OBJID_CLIENT, INDEX_SCROLLBAR_SELF);
        }

        if (!fRedraw)
            return lres;

        /*
         * We must set the new position of the caret irrespective of
         * whether the window is visible or not;
         * Still, this will work only if the app has done a xxxSetScrollPos
         * with fRedraw = TRUE;
         * Fix for Bug #5188 --SANKAR-- 10-15-89
         * No need to DeferWinEventNotify since hwnd is locked.
         */
        HideCaret((HWND)hwnd);
        SBCtlSetup(hwnd);
        zzzSetSBCaretPos(hwnd);

            /*
             ** The following ShowCaret() must be done after the DrawThumb2(),
             ** otherwise this caret will be erased by DrawThumb2() resulting
             ** in this bug:
             ** Fix for Bug #9263 --SANKAR-- 02-09-90
             *
             */

            /*
             *********** ShowCaret((HWND)hwnd); ******
             */

        if (_FChildVisible((HWND)hwnd) && fRedraw)
        {
            UINT    wDisable;
            HBRUSH  hbrUse;

            if (!fScroll)
                fScroll = !(lpsi->fMask & SIF_DISABLENOSCROLL);

            wDisable = (fScroll) ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH;
            xxxEnableScrollBar((HWND) hwnd, SB_CTL, wDisable);

            hdc = GetWindowDC((HWND)hwnd);
            if (hdc)
            {
                BOOL fOwnerBrush = FALSE;

                hbrUse = ScrollBar_GetColorObjects(hwnd, hdc, &fOwnerBrush);
                hbrSave = SelectBrush(hdc, hbrUse);

                // Before we used to only hideshowthumb() if the mesage was
                // not SBM_SETPOS.  I am not sure why but this case was ever
                // needed for win 3.x but on NT it resulted in trashing the border
                // of the scrollbar when the app called SetScrollPos() during
                // scrollbar tracking.  - mikehar 8/26
                DrawThumb2((HWND)hwnd, &psb->_calc, hdc, hbrUse, psb->_fVert, psb->_wDisableFlags, fOwnerBrush);
                SelectBrush(hdc, hbrSave);
                ReleaseDC(hwnd, hdc);
            }
        }

            /*
             * This ShowCaret() has been moved to this place from above
             * Fix for Bug #9263 --SANKAR-- 02-09-90
             */
        ShowCaret((HWND)hwnd);
        return lres;
    }

    case WM_GETOBJECT:

        if(lParam == OBJID_QUERYCLASSNAMEIDX)
        {
             return MSAA_CLASSNAMEIDX_SCROLLBAR;
        }

        break;

    case WM_THEMECHANGED:

        psb->ChangeSBTheme();
        InvalidateRect(hwnd, NULL, TRUE);

        break;

    default:

CallDWP:
        return DefWindowProc((HWND)hwnd, uMsg, wParam, lParam);

    }

    return 0L;
}

//-------------------------------------------------------------------------//
//  Globals
static HBRUSH g_hbrGray = NULL;

//-------------------------------------------------------------------------//
HBRUSH _UxGrayBrush(VOID)
{
    if( NULL == g_hbrGray )
    {
        CONST static WORD patGray[8] = {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa};
        HBITMAP hbmGray;
        /*
         * Create a gray brush to be used with GrayString
         */
        if( (hbmGray = CreateBitmap(8, 8, 1, 1, (LPBYTE)patGray)) != NULL )
        {
            g_hbrGray  = CreatePatternBrush(hbmGray);
            DeleteObject( hbmGray );
        }
    }
    return g_hbrGray;
}

//-------------------------------------------------------------------------//
void _UxFreeGDIResources()
{
    DeleteObject( g_hbrGray );
}

//-------------------------------------------------------------------------//
void _RedrawFrame( HWND hwnd )
{
    CheckLock(hwnd);

    /*
     * We always want to call xxxSetWindowPos, even if invisible or iconic,
     * because we need to make sure the WM_NCCALCSIZE message gets sent.
     */
    SetWindowPos( hwnd, NULL, 0, 0, 0, 0, SWP_NOZORDER |
                  SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE | SWP_DRAWFRAME);
}

//-------------------------------------------------------------------------//
//  from winmgr.c
BOOL _FChildVisible( HWND hwnd )
{
    while (GetWindowStyle( hwnd ) & WS_CHILD )
    {
        if( NULL == (hwnd = GetParent(hwnd)) )
        if (!TestWF(hwnd, WFVISIBLE))
            return FALSE;
    }

    return TRUE;
}


//-------------------------------------------------------------------------//
//
// SizeBoxHwnd
//
// Returns the HWND that will be sized if the user drags in the given window's
// sizebox -- If NULL, then the sizebox is not needed
//
// Criteria for choosing what window will be sized:
// find first sizeable parent; if that parent is not maximized and the child's
// bottom, right corner is within a scroll bar height and width of the parent's
//
HWND SizeBoxHwnd(HWND hwnd)
{
    BOOL bMirroredSizeBox = (BOOL)TestWF(hwnd, WEFLAYOUTRTL);
    RECT rc;
    int  xbrChild;
    int  ybrChild;

    GetWindowRect(hwnd, &rc);
    
    xbrChild = bMirroredSizeBox ? rc.left : rc.right;
    ybrChild = rc.bottom;

    while (hwnd != HWND_DESKTOP)
    {
        if (TestWF(hwnd, WFSIZEBOX)) 
        {
            //
            // First sizeable parent found
            //
            int xbrParent;
            int ybrParent;

            if (TestWF(hwnd, WFMAXIMIZED))
            {
                return NULL;
            }

            GetWindowRect(hwnd, &rc);

            xbrParent = bMirroredSizeBox ? rc.left : rc.right;
            ybrParent = rc.bottom;

            //
            // the sizebox dude is within an EDGE of the client's bottom
            // right corner (left corner for mirrored windows), let this succeed.
            // That way people who draw their own sunken clients will be happy.
            //
            if (bMirroredSizeBox) 
            {
                if ((xbrChild - SYSMETRTL(CXFRAME) > xbrParent) || (ybrChild + SYSMETRTL(CYFRAME) < ybrParent)) 
                {
                    //
                    // Child's bottom, left corner of SIZEBOX isn't close enough
                    // to bottom left of parent's client.
                    //
                    return NULL;
                }
            } 
            else
            {
                if ((xbrChild + SYSMETRTL(CXFRAME) < xbrParent) || (ybrChild + SYSMETRTL(CYFRAME) < ybrParent)) 
                {
                    //
                    // Child's bottom, right corner of SIZEBOX isn't close enough
                    // to bottom right of parent's client.
                    //
                    return NULL;
                }
            }

            return hwnd;
        }

        if (!TestWF(hwnd, WFCHILD) || TestWF(hwnd, WFCPRESENT))
        {
            break;
        }

        hwnd = GetParent(hwnd); 
    }

    return NULL;
}


//-------------------------------------------------------------------------//
//
// _DrawPushButton
//
// From ntuser\rtl\draw.c
// Draws a push style button in the given state.  Adjusts passed in rectangle
// if desired.
//
// Algorithm:
// Depending on the state we either draw
//      - raised edge   (undepressed)
//      - sunken edge with extra shadow (depressed)
// If it is an option push button (a push button that is
// really a check button or a radio button like buttons
// in tool bars), and it is checked, then we draw it
// depressed with a different fill in the middle.
//
VOID _DrawPushButton(HWND hwnd, HDC hdc, LPRECT lprc, UINT state, UINT flags, BOOL fVert)
{
    RECT   rc;
    HBRUSH hbrMiddle;
    DWORD  rgbBack = 0;
    DWORD  rgbFore = 0;
    BOOL   fDither;
    HTHEME hTheme = CUxScrollBar::GetSBTheme(hwnd);

    if ( !hTheme )
    {
        rc = *lprc;

        DrawEdge(hdc,
                 &rc,
                 (state & (DFCS_PUSHED | DFCS_CHECKED)) ? EDGE_SUNKEN : EDGE_RAISED,
                 (UINT)(BF_ADJUST | BF_RECT | (flags & (BF_SOFT | BF_FLAT | BF_MONO))));

        //
        // BOGUS
        // On monochrome, need to do something to make pushed buttons look
        // better.
        //

        //
        // Fill in middle.  If checked, use dither brush (gray brush) with
        // black becoming normal color.
        //
        fDither = FALSE;

        if (state & DFCS_CHECKED) 
        {
            if ((GetDeviceCaps(hdc, BITSPIXEL) /*gpsi->BitCount*/ < 8) || (SYSRGBRTL(3DHILIGHT) == RGB(255,255,255))) 
            {
                hbrMiddle = _UxGrayBrush();
                rgbBack = SetBkColor(hdc, SYSRGBRTL(3DHILIGHT));
                rgbFore = SetTextColor(hdc, SYSRGBRTL(3DFACE));
                fDither = TRUE;
            } 
            else 
            {
                hbrMiddle = SYSHBR(3DHILIGHT);
            }

        } 
        else 
        {
            hbrMiddle = SYSHBR(3DFACE);
        }

        FillRect(hdc, &rc, hbrMiddle);

        if (fDither) 
        {
            SetBkColor(hdc, rgbBack);
            SetTextColor(hdc, rgbFore);
        }

        if (flags & BF_ADJUST)
        {
            *lprc = rc;
        }
    }
    else
    {
        INT  iStateId;
        INT  iPartId;
        SIZE sizeGrip;
        RECT rcContent;
        PSBTRACK pSBTrack = CUxScrollBar::GetSBTrack(hwnd);

        if ((CUxScrollBarCtl::GetDisableFlags(hwnd) & ESB_DISABLE_BOTH) == ESB_DISABLE_BOTH)
        {
            iStateId = SCRBS_DISABLED;
        }
        else if (pSBTrack && ((BOOL)pSBTrack->fTrackVert == fVert) && (pSBTrack->cmdSB == SB_THUMBPOSITION))
        {
            iStateId = SCRBS_PRESSED;
        }
        else if (CUxScrollBar::GetSBHotComponent(hwnd, fVert) == HTSCROLLTHUMB)
        {
            iStateId = SCRBS_HOT;
        }
        else
        {
            iStateId = SCRBS_NORMAL;
        }

        iPartId = fVert ? SBP_THUMBBTNVERT : SBP_THUMBBTNHORZ;

        //
        // Draw the thumb
        //
        DrawThemeBackground(hTheme, hdc, iPartId, iStateId, lprc, 0);
        
        //
        // Lastly draw the little gripper image, if there is enough room 
        //
        if ( SUCCEEDED(GetThemeBackgroundContentRect(hTheme, hdc, iPartId, iStateId, lprc, &rcContent)) )
        {
            iPartId = fVert ? SBP_GRIPPERVERT : SBP_GRIPPERHORZ;

            if ( SUCCEEDED(GetThemePartSize(hTheme, hdc, iPartId, iStateId, &rcContent, TS_TRUE, &sizeGrip)) )
            {
                if ( (sizeGrip.cx < RECTWIDTH(&rcContent)) && (sizeGrip.cy < RECTHEIGHT(&rcContent)) )
                {
                    DrawThemeBackground(hTheme, hdc, iPartId, iStateId, &rcContent, 0);
                }
            }
        }                   
    }
}


//  user.h
#define CheckMsgFilter(wMsg, wMsgFilterMin, wMsgFilterMax)                 \
    (   ((wMsgFilterMin) == 0 && (wMsgFilterMax) == 0xFFFFFFFF)            \
     || (  ((wMsgFilterMin) > (wMsgFilterMax))                             \
         ? (((wMsg) <  (wMsgFilterMax)) || ((wMsg) >  (wMsgFilterMin)))    \
         : (((wMsg) >= (wMsgFilterMin)) && ((wMsg) <= (wMsgFilterMax)))))

#define SYS_ALTERNATE           0x2000
#define SYS_PREVKEYSTATE        0x4000
         
//  mnaccel.h         
/***************************************************************************\
* _SysToChar
*
* EXIT: If the message was not made with the ALT key down, convert
*       the message from a WM_SYSKEY* to a WM_KEY* message.
*
* IMPLEMENTATION:
*     The 0x2000 bit in the hi word of lParam is set if the key was
*     made with the ALT key down.
*
* History:
*   11/30/90 JimA       Ported.
\***************************************************************************/

UINT _SysToChar(
    UINT message,
    LPARAM lParam)
{
    if (CheckMsgFilter(message, WM_SYSKEYDOWN, WM_SYSDEADCHAR) &&
            !(HIWORD(lParam) & SYS_ALTERNATE))
        return (message - (WM_SYSKEYDOWN - WM_KEYDOWN));

    return message;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\static.h ===
#if !defined(USRCTL32__Static_h__INCLUDED)
#define USRCTL32__Static_h__INCLUDED

//---------------------------------------------------------------------------//
//
//  Static Controls
//
//---------------------------------------------------------------------------//


// Statics
#define SFRIGHTJUST             0x0D04
#define SFEDITCONTROL           0x0D20
#define SFWIDELINESPACING       0x0C20

#define IDSYS_STANIMATE     0x0000FFFDL

//
// Instance data pointer access functions
//
#define Static_GetPtr(hwnd)    \
            (PSTAT)GetWindowPtr(hwnd, 0)

#define Static_SetPtr(hwnd, p) \
            (PSTAT)SetWindowPtr(hwnd, 0, p)


extern LRESULT Static_WndProc(
    HWND   hwnd, 
    UINT   uMsg, 
    WPARAM wParam,
    LPARAM lParam 
);

typedef struct tagSTAT 
{
    HWND    hwnd;
    union   tagDUMMY 
    {
        HANDLE hFont;
        BOOL   fDeleteIt;
    };
    HANDLE  hImage;
    UINT    cicur;
    UINT    iicur;
    BOOL    fPaintKbdCuesOnly;
    BOOL    fAlphaImage;
    HTHEME  hTheme;
    PWW     pww;            // RO pointer into the pwnd to ExStyle, Style, State, State2
} STAT, *PSTAT;


typedef struct tagCURSORRESOURCE 
{
    WORD xHotspot;
    WORD yHotspot;
    BITMAPINFOHEADER bih;
} CURSORRESOURCE, *PCURSORRESOURCE;


#endif // USRCTL32__Static_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\thunk.c ===
#include "ctlspriv.h"
#include <limits.h>

/*
 * Creates a buffer for a unicode string, and then copies the ANSI text
 * into it (converting it to unicode in the process)
 *
 * The returned pointer should be freed with LocalFree after use.
 */
LPWSTR ProduceWFromA( UINT uiCodePage, LPCSTR psz ) {
    LPWSTR pszW;
    int cch;

    if (psz == NULL || psz == LPSTR_TEXTCALLBACKA)
        return (LPWSTR)psz;

    // The old code would call lstrlen and lstrcpy which would fault internal to the
    // api, this should do about the same...
    if (IsBadReadPtr(psz,1))
        return NULL;    // For now lets try not setting a string...

    cch = MultiByteToWideChar(uiCodePage, 0, psz, -1, NULL, 0);

    if (cch == 0)
        cch = 1;

    pszW = LocalAlloc( LMEM_FIXED, cch * sizeof(WCHAR) );

    if (pszW != NULL ) {
         if (MultiByteToWideChar( uiCodePage, MB_PRECOMPOSED, psz, -1, pszW,
                cch ) == FALSE) {
            LocalFree(pszW);
            pszW = NULL;
        }
    }

    return pszW;

}


/*
 * Creates a buffer for a unicode string, and then copies the ANSI text
 * into it (converting it to unicode in the process)
 *
 * The returned pointer should be freed with LocalFree after use.
 */
LPSTR ProduceAFromW( UINT uiCodePage, LPCWSTR psz ) {
    LPSTR pszA;
    int cch;

    if (psz == NULL || psz == LPSTR_TEXTCALLBACKW)
        return (LPSTR)psz;

    cch = WideCharToMultiByte(uiCodePage, 0, psz, -1, NULL, 0, NULL, NULL);

    if (cch == 0)
        cch = 1;

    pszA = LocalAlloc( LMEM_FIXED, cch * sizeof(char) );

    if (pszA != NULL ) {
         if (WideCharToMultiByte(uiCodePage, 0, psz, -1, pszA, cch, NULL, NULL) ==
                                                                       FALSE) {
            LocalFree(pszA);
            pszA = NULL;
        }
    }

    return pszA;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\status.c ===
/*
**    STATUS.C
**
**    Status bar code
**
*/

#include "ctlspriv.h"

#define MAX_TOOLTIP_STRING 80
#define SB_HITTEST_NOITEM  -2

typedef struct {
    ULONG_PTR dwString;
    UINT uType;
    int right;
    HICON hIcon;
    SIZE  sizeIcon;
    LPTSTR pszToolTip;
    BOOL fNeedToTip;
} STRINGINFO, *PSTRINGINFO;

typedef struct {
    CCONTROLINFO ci;
    HWND hwndToolTips;
    HFONT hStatFont;
    BOOL bDefFont;

    int nFontHeight;
    int nMinHeight;
    int nBorderX, nBorderY, nBorderPart;
    int nLastX;                 // for invalidating unclipped right side
    int dxGripper;                // 0 if no gripper
    int dyGripper;
    UINT uiCodePage;            // code page

    STRINGINFO sSimple;

    int nParts;
    COLORREF _clrBk;  
    
    HTHEME hTheme;

    PSTRINGINFO sInfo;
} STATUSINFO, *PSTATUSINFO;


#define SBT_NORMAL        0xf000
#define SBT_NULL        0x0000    /* Some code depends on this being 0 */
#define SBT_ALLTYPES    0xf000    /* this does NOT include rtlred */
#define SBT_NOSIMPLE    0x00ff    /* Flags to indicate normal status bar */


#define MAXPARTS 256
// Bug#94368 raymondc v6: This limit isn't big enough on large res screens
#define MAX_STATUS_TEXT_LEN 128

#define CharNextEx(cp, sz, f) ((sz)+1)

BOOL SBSetText(PSTATUSINFO pStatusInfo, WPARAM wParam, LPCTSTR lpsz);
void SBSetBorders(PSTATUSINFO pStatusInfo, LPINT lpInt);
void SBSetFont(PSTATUSINFO pStatusInfo, HFONT hFont, BOOL bInvalidate);
void WINAPI DrawStatusTextEx(PSTATUSINFO pStatusInfo, HDC hDC, LPRECT lprc, LPCTSTR pszText, STRINGINFO * psi,  UINT uFlags, BOOL fClipText);
void RecalcTooltipRects(PSTATUSINFO pStatusinfo);
PSTRINGINFO GetStringInfo(PSTATUSINFO pStatusInfo, int nIndex);
int  IndexFromPt(PSTATUSINFO pStatusInfo, POINT pt);
void StatusUpdateToolTips(PSTATUSINFO psi);

void GetNewMetrics(PSTATUSINFO pStatusInfo, HDC hDC, HFONT hNewFont)
{
    HFONT hOldFont;
    /* HACK! Pass in -1 to just delete the old font
     */
    if (hNewFont != (HFONT)-1)
    {
        HRESULT hr = E_FAIL;
        TEXTMETRIC tm;

        if (pStatusInfo->hTheme)
        {
            hr = GetThemeTextMetrics(pStatusInfo->hTheme, hDC, 0, 0, &tm);

        }
        if (FAILED(hr))
        {
            hOldFont = 0;
            if (hNewFont)
            hOldFont = SelectObject(hDC, hNewFont);

            GetTextMetrics(hDC, &tm);

            if (hOldFont)
            SelectObject(hDC, hOldFont);
        }

        pStatusInfo->nFontHeight = tm.tmHeight + tm.tmInternalLeading;

        // For far east font which has no internal leading
        if ( !tm.tmInternalLeading )
             pStatusInfo->nFontHeight += g_cyBorder * 2;

    }
}

void NewFont(PSTATUSINFO pStatusInfo, HFONT hNewFont, BOOL fResize)
{
    HFONT hOldFont;
    BOOL bDelFont;
    HDC hDC;

    hOldFont = pStatusInfo->hStatFont;
    bDelFont = pStatusInfo->bDefFont;

    hDC = GetDC(pStatusInfo->ci.hwnd);

    if (hNewFont) {
        pStatusInfo->hStatFont = hNewFont;
        pStatusInfo->bDefFont = FALSE;
        pStatusInfo->uiCodePage = GetCodePageForFont(hNewFont);
    } else {
        if (bDelFont) {
            /* I will reuse the default font, so don't delete it later
             */
            hNewFont = pStatusInfo->hStatFont;
            bDelFont = FALSE;
        } else {
#ifndef DBCS_FONT
            hNewFont = CCCreateStatusFont();
            if (!hNewFont)
#endif // DBCS_FONT
                hNewFont = g_hfontSystem;


            pStatusInfo->hStatFont = hNewFont;
            pStatusInfo->bDefFont = BOOLFROMPTR(hNewFont);
        }
    }

#ifndef DBCS_FONT
    /* We delete the old font after creating the new one in case they are
     * the same; this should help GDI a little
     */
    if (bDelFont)
        DeleteObject(hOldFont);
#endif

    GetNewMetrics(pStatusInfo, hDC, hNewFont);

    ReleaseDC(pStatusInfo->ci.hwnd, hDC);

    // My font changed, so maybe I should resize to match
    if (fResize)
        SendMessage(pStatusInfo->ci.hwnd, WM_SIZE, 0, 0L);
}

/* We should send messages instead of calling things directly so we can
 * be subclassed more easily.
 */
LRESULT InitStatusWnd(HWND hWnd, LPCREATESTRUCT lpCreate)
{
    int nBorders[3];
    PSTATUSINFO pStatusInfo = (PSTATUSINFO)LocalAlloc(LPTR, sizeof(STATUSINFO));
    if (!pStatusInfo)
        return -1;        // fail the window create

    // Start out with one part
    pStatusInfo->sInfo = (PSTRINGINFO)LocalAlloc(LPTR, sizeof(STRINGINFO));
    if (!pStatusInfo->sInfo)
    {
        LocalFree(pStatusInfo);
        return -1;        // fail the window create
    }

    SetWindowPtr(hWnd, 0, pStatusInfo);
    CIInitialize(&pStatusInfo->ci, hWnd, lpCreate);
    

    pStatusInfo->sSimple.uType = SBT_NOSIMPLE | SBT_NULL;
    pStatusInfo->sSimple.right = -1;
    pStatusInfo->uiCodePage = CP_ACP;

    pStatusInfo->nParts = 1;
    pStatusInfo->sInfo[0].uType = SBT_NULL;
    pStatusInfo->sInfo[0].right = -1;

    pStatusInfo->_clrBk = CLR_DEFAULT;

        
    pStatusInfo->hTheme = OpenThemeData(pStatusInfo->ci.hwnd, L"Status");

    // Save the window text in our struct, and let USER store the NULL string
    SBSetText(pStatusInfo, 0, lpCreate->lpszName);
    lpCreate->lpszName = c_szNULL;

    // Don't resize because MFC doesn't like getting funky
    // messages before the window is fully created.  USER will send
    // us a WM_SIZE message after the WM_CREATE returns, so we'll
    // get it sooner or later.
    NewFont(pStatusInfo, 0, FALSE);

    nBorders[0] = -1;     // use default border widths
    nBorders[1] = -1;
    nBorders[2] = -1;

    SBSetBorders(pStatusInfo, nBorders);

#define GRIPSIZE (g_cxVScroll + g_cxBorder)     // make the default look good

    if ((lpCreate->style & SBARS_SIZEGRIP) ||
        ((GetWindowStyle(lpCreate->hwndParent) & WS_THICKFRAME) &&
         !(lpCreate->style & (CCS_NOPARENTALIGN | CCS_TOP | CCS_NOMOVEY))))
    if (pStatusInfo->hTheme)
    {
        RECT rcContent = {0, 0, GRIPSIZE, GRIPSIZE};
        GetThemeBackgroundExtent(pStatusInfo->hTheme, NULL, SP_GRIPPER, 0, &rcContent, &rcContent);

        pStatusInfo->dxGripper = RECTWIDTH(rcContent);
        pStatusInfo->dyGripper = RECTHEIGHT(rcContent);
    }
    else
    {
        pStatusInfo->dxGripper = GRIPSIZE;
    }

    return 0;     // success
}

// lprc is left unchanged, but used as scratch
void WINAPI DrawStatusText(HDC hDC, LPRECT lprc, LPCTSTR pszText, UINT uFlags)
{
    DrawStatusTextEx(NULL, hDC, lprc, pszText, NULL, uFlags, FALSE);
}    

void WINAPI DrawStatusTextA(HDC hDC, LPRECT lprc, LPCSTR pszText, UINT uFlags)
{
     INT     cch;
     LPWSTR     lpw;

     cch = lstrlenA(pszText);
     lpw = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, ((cch + 1) * sizeof(TCHAR)));

     if (!lpw) 
     {
        return;
     }

     MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszText, cch, lpw, cch);
     DrawStatusTextW(hDC, lprc, lpw, uFlags);

     LocalFree((LPVOID)lpw);
}

BOOL Status_GetRect(PSTATUSINFO pStatusInfo, int nthPart, LPRECT lprc)
{
    PSTRINGINFO pStringInfo = pStatusInfo->sInfo;

    if (lprc == NULL)
        return FALSE;

    if (pStatusInfo->sSimple.uType & SBT_NOSIMPLE)
    {
        RECT rc;
        int nRightMargin, i;

        /* Get the client rect and inset the top and bottom.    Then set
         * up the right side for entry into the loop
         */
        GetClientRect(pStatusInfo->ci.hwnd, &rc);

        if (pStatusInfo->dxGripper && !IsZoomed(pStatusInfo->ci.hwndParent))
        {
            rc.right = rc.right - pStatusInfo->dxGripper + pStatusInfo->nBorderX;
        }

        rc.top += pStatusInfo->nBorderY;

        nRightMargin = rc.right - pStatusInfo->nBorderX;
        rc.right = pStatusInfo->nBorderX - pStatusInfo->nBorderPart;

        for (i = 0; i < pStatusInfo->nParts; ++i, ++pStringInfo)
        {
            // WARNING!  This pixel computation is also in PaintStatusWnd,
            // so make sure the two algorithms are in sync.

            if (pStringInfo->right == 0)
                continue;

            rc.left = rc.right + pStatusInfo->nBorderPart;

            rc.right = pStringInfo->right;

            // size the right-most one to the end with room for border
            if (rc.right < 0 || rc.right > nRightMargin)
                rc.right = nRightMargin;

            // if the part is real small, don't show it
            // Bug keep the rc.left valid in case this item happens to
            // be the nthPart.
            if ((rc.right - rc.left) < pStatusInfo->nBorderPart)
                rc.left = rc.right;

            if (i == nthPart)
            {
                if (nthPart == pStatusInfo->nParts - 1)
                {
                    rc.right -= pStatusInfo->dxGripper;
                }

                *lprc = rc;
                return TRUE;
            }
        }
    }

    return FALSE;

}

void PaintStatusWnd(PSTATUSINFO pStatusInfo, HDC hdcIn, PSTRINGINFO pStringInfo, int nParts, int nBorderX)
{
    PAINTSTRUCT ps;
    RECT rc, rcGripper, rcClient;
    int nRightMargin, i;
    HFONT hOldFont = NULL;
    UINT uType;
    BOOL bDrawGrip;

    // paint the whole client area
    GetClientRect(pStatusInfo->ci.hwnd, &rcClient);
    rc = rcClient;

    if (hdcIn)
    {
        ps.rcPaint = rc;
        ps.hdc = hdcIn;
    }
    else
        BeginPaint(pStatusInfo->ci.hwnd, &ps);


    rc.top += pStatusInfo->nBorderY;

    bDrawGrip = pStatusInfo->dxGripper && !IsZoomed(pStatusInfo->ci.hwndParent);

    if (bDrawGrip)
        rcGripper = rc;

    nRightMargin = rc.right - nBorderX;
    rc.right = nBorderX - pStatusInfo->nBorderPart;

    if (pStatusInfo->hStatFont)
        hOldFont = SelectObject(ps.hdc, pStatusInfo->hStatFont);

    for (i=0; i<nParts; ++i, ++pStringInfo)
    {
        BOOL fClipRight = FALSE;
        // WARNING!  This pixel computation is also in Status_GetRect,
        // so make sure the two algorithms are in sync.
        if (pStringInfo->right == 0)
            continue;

        rc.left = rc.right + pStatusInfo->nBorderPart;
        rc.right = pStringInfo->right;

        // size the right-most one to the end with room for border
        if (rc.right < 0 || rc.right > nRightMargin)
            rc.right = nRightMargin;

        if(g_fMEEnabled && (rc.right > (nRightMargin-pStatusInfo->dxGripper)))
        {
            //
            // for MidEast we DONT overpaint the rhs with the grip, this will
            // lose the begining of the text.
            //
            rc.right = nRightMargin-pStatusInfo->dxGripper;
        }

        if (pStatusInfo->dxGripper && !IsZoomed(pStatusInfo->ci.hwndParent)
            && rc.right > rcClient.right - pStatusInfo->dxGripper + 1)
        {
            fClipRight = TRUE;
        }
        
        DebugMsg(TF_STATUS, TEXT("SBPaint: part=%d, x/y=%d/%d"), i, rc.left, rc.right);

        // if the part is real small, don't show it
        if (((rc.right - rc.left) < pStatusInfo->nBorderPart) || !RectVisible(ps.hdc, &rc))
            continue;

        uType = pStringInfo->uType;

        if ((uType&SBT_ALLTYPES) == SBT_NORMAL)
        {
            DrawStatusTextEx(pStatusInfo, ps.hdc, &rc, (LPTSTR)OFFSETOF(pStringInfo->dwString), pStringInfo, uType, fClipRight);
        }
        else
        {
            DrawStatusTextEx(pStatusInfo, ps.hdc, &rc, c_szNULL, pStringInfo, uType, fClipRight);

            if (uType & SBT_OWNERDRAW)
            {
                DRAWITEMSTRUCT di;

                di.CtlID = GetWindowID(pStatusInfo->ci.hwnd);
                di.itemID = i;
                di.hwndItem = pStatusInfo->ci.hwnd;
                di.hDC = ps.hdc;
                di.rcItem = rc;
                InflateRect(&di.rcItem, -g_cxBorder, -g_cyBorder);
                di.itemData = pStringInfo->dwString;

                SaveDC(ps.hdc);
                IntersectClipRect(ps.hdc, di.rcItem.left, di.rcItem.top,
                                    di.rcItem.right, di.rcItem.bottom);
                SendMessage(pStatusInfo->ci.hwndParent, WM_DRAWITEM, di.CtlID,
                            (LPARAM)(LPTSTR)&di);
                RestoreDC(ps.hdc, -1);
            }
        }
    }

    if (bDrawGrip)
    {
        RECT rcTemp;
        COLORREF crBkColorOld;
        COLORREF crBkColor;
        
        pStatusInfo->dxGripper = min(pStatusInfo->dxGripper, pStatusInfo->nFontHeight);

        if (pStatusInfo->hTheme)
        {
            rcGripper.left = rcGripper.right - pStatusInfo->dxGripper;
            rcGripper.top = rcGripper.bottom - pStatusInfo->dyGripper;

            DrawThemeBackground(pStatusInfo->hTheme, 
                                ps.hdc, 
                                SP_GRIPPER, 
                                1, 
                                &rcGripper, 0);
        }
        else
        {
            // draw the grip
            rcGripper.right -= g_cxBorder;                    // inside the borders
            rcGripper.bottom -= g_cyBorder;

            rcGripper.left = rcGripper.right - pStatusInfo->dxGripper;        // make it square
            rcGripper.top += g_cyBorder;
            // rcGripper.top    = rcGripper.bottom - pStatusInfo->dxGripper;

            crBkColor = g_clrBtnFace;
            if ((pStatusInfo->_clrBk != CLR_DEFAULT))
                crBkColor = pStatusInfo->_clrBk;
        
            crBkColorOld = SetBkColor(ps.hdc, crBkColor);
            DrawFrameControl(ps.hdc, &rcGripper, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);

            // clear out the border edges to make this appear on the same level

            // NOTE: these values line up right only for the default scroll bar
            // width. for others this is close enough...

            // right border
            rcTemp.top = rcGripper.bottom - pStatusInfo->dxGripper + g_cyBorder + g_cyEdge;
            rcTemp.left = rcGripper.right;
            rcTemp.bottom = rcGripper.bottom;
            rcTemp.right = rcGripper.right + g_cxBorder;
            FillRectClr(ps.hdc, &rcTemp, crBkColor);
        
            // bottom border
            rcTemp.top = rcGripper.bottom;
            rcTemp.left = rcGripper.left + g_cyBorder + g_cxEdge;
            rcTemp.bottom = rcGripper.bottom +    g_cyBorder;
            rcTemp.right = rcGripper.right + g_cxBorder;
            FillRectClr(ps.hdc, &rcTemp, crBkColor);
        
            SetBkColor(ps.hdc, crBkColorOld);
        }
    }
    
    if (hOldFont)
        SelectObject(ps.hdc, hOldFont);

    if (hdcIn == NULL)
        EndPaint(pStatusInfo->ci.hwnd, &ps);
}


BOOL SetStatusText(PSTATUSINFO pStatusInfo, PSTRINGINFO pStringInfo, UINT uPart, LPCTSTR lpStr)
{
    PTSTR pString;
    UINT wLen;
    int nPart;
    RECT rc;

    nPart = LOBYTE(uPart);

    /* Note it is up to the app the dispose of the previous itemData for
     * SBT_OWNERDRAW
     */
    if ((pStringInfo->uType&SBT_ALLTYPES) == SBT_NORMAL)
        LocalFree((HLOCAL)OFFSETOF(pStringInfo->dwString));

    /* Set to the NULL string in case anything goes wrong
     *
     * But be careful to preserve simple-ness if this is the simple
     * pane being updated.
     */
    if (nPart == 0xFF)
    {
        pStringInfo->uType = (uPart & 0xff00) | (pStringInfo->uType & 0x00ff);
        nPart = 0;          // There is only one simple part, so we are part 0
    }
    else
    {
        pStringInfo->uType = uPart & 0xff00;
    }
    pStringInfo->uType &= ~SBT_ALLTYPES;
    pStringInfo->uType |= SBT_NULL;

    /* Invalidate the rect of this pane.
     *
     * Note that we don't check whether the pane is actually visible
     * in the current status bar mode.  The result is some gratuitous
     * invalidates and updates.  Oh well.
     */
    GetClientRect(pStatusInfo->ci.hwnd, &rc);
    if (nPart)
        rc.left = pStringInfo[-1].right;
    if (pStringInfo->right > 0)
        rc.right = pStringInfo->right;
    InvalidateRect(pStatusInfo->ci.hwnd, &rc, TRUE);

    switch (uPart&SBT_ALLTYPES)
    {
        case 0:
            /* If lpStr==NULL, we have the NULL string
             */
            if (HIWORD64(lpStr))
            {
                wLen = lstrlen(lpStr);
                if (wLen)
                {
                    pString = (PTSTR)LocalAlloc(LPTR, (wLen+1)*sizeof(TCHAR));
                    pStringInfo->dwString = (ULONG_PTR)(LPTSTR)pString;
                    if (pString)
                    {
                        pStringInfo->uType |= SBT_NORMAL;

                        /* Copy the string
                         */
                        lstrcpy(pString, lpStr);

                        /* Replace unprintable characters (like CR/LF) with spaces
                         */
                        for ( ; *pString;
                              pString=(PTSTR)OFFSETOF(CharNextEx((WORD)pStatusInfo->uiCodePage, pString, 0)))
                            if ((unsigned)(*pString)<(unsigned)TEXT(' ') && *pString!= TEXT('\t'))
                                *pString = TEXT(' ');
                    }
                    else
                    {
                        /* We return FALSE to indicate there was an error setting
                         * the string
                         */
                        return(FALSE);
                    }
                }
            }
            else if (LOWORD(lpStr))
            {
                /* We don't allow this anymore; the app needs to set the ownerdraw
                 * bit for ownerdraw.
                 */
                return(FALSE);
            }
            break;

        case SBT_OWNERDRAW:
            pStringInfo->uType |= SBT_OWNERDRAW;
            pStringInfo->dwString = (ULONG_PTR)lpStr;
            break;

        default:
            return(FALSE);
    }

    UpdateWindow(pStatusInfo->ci.hwnd);
    return(TRUE);
}

BOOL SetStatusParts(PSTATUSINFO pStatusInfo, int nParts, LPINT lpInt)
{
    int i;
    int prev;
    PSTRINGINFO pStringInfo, pStringInfoTemp;
    BOOL bRedraw = FALSE;

    if (nParts != pStatusInfo->nParts)
    {
        TOOLINFO ti = {0};
        int n;

        if (pStatusInfo->hwndToolTips)
        {
            ti.cbSize = sizeof(ti);
            ti.hwnd = pStatusInfo->ci.hwnd;
            ti.lpszText = LPSTR_TEXTCALLBACK;
    
            for(n = 0; n < pStatusInfo->nParts; n++)
            {
                ti.uId = n;
                SendMessage(pStatusInfo->hwndToolTips, TTM_DELTOOL, 0, (LPARAM)&ti);
            }
        }

        bRedraw = TRUE;

        /* Note that if nParts > pStatusInfo->nParts, this loop
         * does nothing
         */
        for (i=pStatusInfo->nParts-nParts,
            pStringInfo=&pStatusInfo->sInfo[nParts]; i>0;
            --i, ++pStringInfo)
        {
            if ((pStringInfo->uType&SBT_ALLTYPES) == SBT_NORMAL)
                LocalFree((HLOCAL)OFFSETOF(pStringInfo->dwString));
            pStringInfo->uType = SBT_NULL;
        }

        /* Realloc to the new size and store the new pointer
         */
        pStringInfoTemp = (PSTRINGINFO)CCLocalReAlloc(pStatusInfo->sInfo,
                                             nParts * sizeof(STRINGINFO));
        if (!pStringInfoTemp)
            return(FALSE);
        pStatusInfo->sInfo = pStringInfoTemp;

        /* Note that if nParts < pStatusInfo->nParts, this loop
         * does nothing
         */
        for (i=nParts-pStatusInfo->nParts,
             pStringInfo=&pStatusInfo->sInfo[pStatusInfo->nParts]; i>0;
             --i, ++pStringInfo)
        {
            pStringInfo->uType = SBT_NULL;
            pStringInfo->right = 0;
        }
        pStatusInfo->nParts = nParts;

        StatusUpdateToolTips(pStatusInfo);
    }

    //
    //  Under stress, apps such as Explorer might pass coordinates that
    //  result in status bar panes with negative width, so make sure
    //  each edge is at least as far to the right as the previous.
    //
    prev = 0;
    for (i=0, pStringInfo=pStatusInfo->sInfo; i<nParts;
         ++i, ++pStringInfo, ++lpInt)
    {
        int right = *lpInt;
        // The last component is allowed to have *lpInt = -1.
        // Otherwise, make sure the widths are nondecreasing.
        if (!(right == -1 && i == nParts - 1) && right < prev)
            right = prev;
        DebugMsg(TF_STATUS, TEXT("SBSetParts: part=%d, rlimit=%d (%d)"), i, right, *lpInt);
        if (pStringInfo->right != right)
        {
            bRedraw = TRUE;
            pStringInfo->right = right;
        }
        prev = right;
    }

    /* Only redraw if necesary (if the number of parts has changed or
     * a border has changed)
     */
    if (bRedraw)
        InvalidateRect(pStatusInfo->ci.hwnd, NULL, TRUE);

    RecalcTooltipRects(pStatusInfo);

    return TRUE;
}

void SBSetFont(PSTATUSINFO pStatusInfo, HFONT hFont, BOOL bInvalidate)
{
    NewFont(pStatusInfo, hFont, TRUE);
    if (bInvalidate)
    {
        RedrawWindow(pStatusInfo->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
    }
}

BOOL SBSetText(PSTATUSINFO pStatusInfo, WPARAM wParam, LPCTSTR lpsz)
{
    BOOL bRet;
    UINT idChild;

    DebugMsg(TF_STATUS, TEXT("SBSetText(%04x, [%s])"), wParam, lpsz);

    /* This is the "simple" status bar pane
     */
    if (LOBYTE(wParam) == 0xff)
    {
        UINT uSimple;

        // Note that we do not allow OWNERDRAW for a "simple" status bar
        if (wParam & SBT_OWNERDRAW)
            return FALSE;

        //
        //  IE4 BUG-FOR-BUG COMPATIBILITY:  In IE4, changing the SIMPLE
        //  status bar text while you were in complex mode caused the simple
        //  text to be painted briefly.  It would get cleaned up the next time
        //  the window got invalidated.
        //
        //  Corel Gallery actually RELIES ON THIS BUG!
        //
        //  Since the bad text got cleaned up on every invalidate, they
        //  "worked around" their bug by doing SB_SETTEXT in their idle loop,
        //  so the "correct" text gets repainted no matter what.
        //
        //  So if we have an old status bar, emulate the bug by temporarily
        //  setting the status bar into SIMPLE mode for the duration of the
        //  SetStatusText call.

        uSimple = pStatusInfo->sSimple.uType;
        if (pStatusInfo->ci.iVersion < 5)
            pStatusInfo->sSimple.uType = (uSimple & 0xFF00);

        bRet = SetStatusText(pStatusInfo, &pStatusInfo->sSimple,
                             (UINT) wParam, lpsz);

        if (pStatusInfo->ci.iVersion < 5)
            pStatusInfo->sSimple.uType |= LOBYTE(uSimple);

        idChild = 0;
    }
    else
    {

        if ((UINT)pStatusInfo->nParts <= (UINT)LOBYTE(wParam))
            bRet = FALSE;
        else
            bRet = SetStatusText(pStatusInfo, &pStatusInfo->sInfo[LOBYTE(wParam)],
                                 (UINT) wParam, lpsz);

        idChild = LOBYTE(wParam);
    }

    if (bRet)
        NotifyWinEvent(EVENT_OBJECT_NAMECHANGE, pStatusInfo->ci.hwnd,
            OBJID_CLIENT, idChild+1);

    return bRet;
}

//
//  iPart - which part we are querying
//  lpOutBuf - output buffer, NULL if no output desired
//  cchOutBuf - size of output buffer in characters
//  flags - zero or more of the following flags
//
//      SBGT_ANSI       - Output buffer is ANSI
//      SBGT_UNICODE    - Output buffer is unicode
//      SBGT_TCHAR      - Output buffer is TCHAR
//      SBGT_OWNERDRAWOK- Return refdata for owner-draw
//
//  If item is a string, and output buffer is provided, then returns
//  output string length (not including null) in low word, flags in
//  high word.
//
//  If item is a string, and no output buffer is provided, then returns
//  source string length (not including null) in low word, flags in
//  high word.
//
//  If item is owner-draw and SBGT_OWNERDRAWOK is set, then return the
//  refdata for the owner-draw item.
//
//  If item is owner-draw and SBGT_OWNERDRAWOK is clear, then treats
//  string as if it were empty.
//

#define     SBGT_ANSI           0
#define     SBGT_UNICODE        1
#define     SBGT_OWNERDRAWOK    2

#define     SBGT_TCHAR          SBGT_UNICODE

// Value for cchOutBuf to indicate largest possible output buffer size
// We cannot use -1 because StrCpyNW thinks -1 means a negative-size buffer.
// Since the maximum value we return is 0xFFFF (LOWORD), and the return value
// doesn't include the trailing null, the largest incoming buffer is one
// greater.
#define     SBGT_INFINITE       0x00010000

LRESULT SBGetText(PSTATUSINFO pStatusInfo, WPARAM iPart, LPVOID lpOutBuf, int cchOutBuf, UINT flags)
{
    UINT uType;
    PTSTR pString;
    ULONG_PTR dwString;
    UINT wLen;

    if (!pStatusInfo || (UINT)pStatusInfo->nParts<=iPart)
        return(0);

    if (pStatusInfo->sSimple.uType & SBT_NOSIMPLE)
    {
        uType = pStatusInfo->sInfo[iPart].uType;
        dwString = pStatusInfo->sInfo[iPart].dwString;
    } else {
        uType = pStatusInfo->sSimple.uType;
        dwString = pStatusInfo->sSimple.dwString;
    }

    // Catch the boundary condition early so we only have to check lpOutBuf
    if (cchOutBuf == 0)
        lpOutBuf = NULL;

    if ((uType&SBT_ALLTYPES) == SBT_NORMAL)
    {
        pString = (PTSTR)dwString;
        if (flags & SBGT_UNICODE)
        {
            if (lpOutBuf)
            {
                StrCpyNW(lpOutBuf, pString, cchOutBuf);
                wLen = lstrlenW(lpOutBuf);
            }
            else
                wLen = lstrlen(pString);
        }
        else
        {
            // We have to use ProduceAFromW because WideCharToMultiByte
            // will simply fail if the output buffer isn't big enough,
            // but we want to copy as many as will fit.
            LPSTR pStringA = ProduceAFromW(pStatusInfo->ci.uiCodePage, pString);
            if (pStringA)
            {
                if (lpOutBuf)
                {
                    lstrcpynA(lpOutBuf, pStringA, cchOutBuf);
                    wLen = lstrlenA(lpOutBuf);
                }
                else
                    wLen = lstrlenA(pStringA);  // Return required ANSI buf size
                FreeProducedString(pStringA);
            }
            else
            {
                if (lpOutBuf)
                    *(LPSTR)lpOutBuf = '\0';
                wLen = 0;               // Eek, horrible memory problem
            }
        }
        /* Set this back to 0 to return to the app
         */
        uType &= ~SBT_ALLTYPES;
    }
    else
    {
        if (lpOutBuf)
        {
            if (flags & SBGT_UNICODE)
                *(LPWSTR)lpOutBuf = L'\0';
            else
                *(LPSTR)lpOutBuf = '\0';
        }
        wLen = 0;

        // Only SB_GETTEXT[AW] returns the raw owner-draw refdata
        if ((uType&SBT_ALLTYPES)==SBT_OWNERDRAW && (flags & SBGT_OWNERDRAWOK))
            return(dwString);
    }

    return(MAKELONG(wLen, uType));
}

void SBSetBorders(PSTATUSINFO pStatusInfo, LPINT lpInt)
{
    // pStatusInfo->nBorderX = lpInt[0] < 0 ? 0 : lpInt[0];
    pStatusInfo->nBorderX = 0;

    // pStatusInfo->nBorderY = lpInt[1] < 0 ? 2 * g_cyBorder : lpInt[1];
    pStatusInfo->nBorderY = g_cyEdge;

    // pStatusInfo->nBorderPart = lpInt[2] < 0 ? 2 * g_cxBorder : lpInt[2];
    pStatusInfo->nBorderPart = g_cxEdge;
}

void StatusUpdateToolTips(PSTATUSINFO psi)
{
    if (psi->hwndToolTips)
    {
        TOOLINFO ti = {0};
        int n;

        ti.cbSize = sizeof(ti);
        ti.hwnd = psi->ci.hwnd;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        for(n = 0; n < psi->nParts; n++)
        {
            ti.uId = n;
            SendMessage(psi->hwndToolTips, TTM_ADDTOOL, 0, (LPARAM)&ti);
        }

    }
}
void StatusForceCreateTooltips(PSTATUSINFO psi)
{
    if (psi->ci.style & SBT_TOOLTIPS && !psi->hwndToolTips) 
    {
        TOOLINFO ti = {0};
        psi->hwndToolTips = CreateWindowEx(WS_EX_TRANSPARENT, c_szSToolTipsClass, NULL, WS_POPUP | TTS_ALWAYSTIP, 
                                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                    psi->ci.hwnd, NULL, HINST_THISDLL, NULL);


        ti.cbSize = sizeof(ti);
        ti.hwnd = psi->ci.hwnd;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        ti.uId = SB_SIMPLEID;
        SendMessage(psi->hwndToolTips, TTM_ADDTOOL, 0, (LPARAM)&ti);
        StatusUpdateToolTips(psi);
        RecalcTooltipRects(psi);
    }
}

LRESULT CALLBACK StatusWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PSTATUSINFO pStatusInfo = GetWindowPtr(hWnd, 0);
    NMCLICK nm;
    int nNotification;

    if (!pStatusInfo && uMsg != WM_CREATE) 
        goto DoDefault;
    
    switch (uMsg)
    {
        case WM_CREATE:
                return InitStatusWnd(hWnd, (LPCREATESTRUCT)lParam);
                
        case WM_SYSCOLORCHANGE:
            if (pStatusInfo->hwndToolTips)
                SendMessage(pStatusInfo->hwndToolTips, uMsg, wParam, lParam);
            break;

        case WM_MOUSEMOVE:  
        case WM_LBUTTONDOWN:
            StatusForceCreateTooltips(pStatusInfo);
            RelayToToolTips(pStatusInfo->hwndToolTips, hWnd, uMsg, wParam, lParam);
            break;
        case WM_STYLECHANGED:
        {
            if (wParam == GWL_EXSTYLE)
            {
                //
                // If the RTL_MIRROR extended style bit had changed, let's
                // repaint the control window
                //
                if ((pStatusInfo->ci.dwExStyle&RTL_MIRRORED_WINDOW) !=  
                    (((LPSTYLESTRUCT)lParam)->styleNew&RTL_MIRRORED_WINDOW))
                    InvalidateRect(pStatusInfo->ci.hwnd, NULL, TRUE);

                //
                // Save the new ex-style bits
                //
                pStatusInfo->ci.dwExStyle = ((LPSTYLESTRUCT)lParam)->styleNew;
            }
        }
        return 0;

        case WM_SETTINGCHANGE:
            InitGlobalColors();
            InitGlobalMetrics(wParam);

            if (pStatusInfo->hwndToolTips)
                SendMessage(pStatusInfo->hwndToolTips, uMsg, wParam, lParam);
                
            if (pStatusInfo->dxGripper)
                pStatusInfo->dxGripper = GRIPSIZE;

            if (wParam == SPI_SETNONCLIENTMETRICS)
            {
                if (pStatusInfo->bDefFont)
                {
                    if (pStatusInfo->hStatFont)
                    {
                        DeleteObject(pStatusInfo->hStatFont);
                        pStatusInfo->hStatFont = NULL;
                        pStatusInfo->bDefFont = FALSE;
                        SBSetFont(pStatusInfo, 0, TRUE);
                    }
                }
            }
            break;

        case WM_DESTROY:
            if (pStatusInfo)
            {
                int i;
                PSTRINGINFO pStringInfo;

                // FALSE = Don't resize while being destroyed...
                NewFont(pStatusInfo, (HFONT)-1, FALSE);
                for (i=pStatusInfo->nParts-1, pStringInfo=pStatusInfo->sInfo;
                     i>=0; --i, ++pStringInfo)
                {
                    if ((pStringInfo->uType&SBT_ALLTYPES) == SBT_NORMAL)
                        LocalFree((HLOCAL)OFFSETOF(pStringInfo->dwString));
                    Str_Set(&pStringInfo->pszToolTip, NULL);
                }

                if ((pStatusInfo->sSimple.uType&SBT_ALLTYPES) == SBT_NORMAL)
                    LocalFree((HLOCAL)OFFSETOF(pStatusInfo->sSimple.dwString));

                if (IsWindow(pStatusInfo->hwndToolTips))
                    DestroyWindow(pStatusInfo->hwndToolTips);

                Str_Set(&pStatusInfo->sSimple.pszToolTip, NULL);

                if (pStatusInfo->sInfo)
                    LocalFree(pStatusInfo->sInfo);
                if (pStatusInfo->hTheme)
                    CloseThemeData(pStatusInfo->hTheme);
                LocalFree((HLOCAL)pStatusInfo);
                SetWindowInt(hWnd, 0, 0);

            }
            break;

        case WM_NCHITTEST:
            if (pStatusInfo->dxGripper && !IsZoomed(pStatusInfo->ci.hwndParent))
            {
                RECT rc;

                // already know height is valid.    if the width is in the grip,
                // show the sizing cursor
                GetWindowRect(pStatusInfo->ci.hwnd, &rc);
                
                //
                // If this is a RTL mirrored status window, then measure
                // from the near edge (screen coordinates) since Screen
                // Coordinates are not RTL mirrored.
                // [samera]
                //
                if (pStatusInfo->ci.dwExStyle&RTL_MIRRORED_WINDOW) {
                    if (GET_X_LPARAM(lParam) < (rc.left + pStatusInfo->dxGripper))
                        return HTBOTTOMLEFT;
                } else if (GET_X_LPARAM(lParam) > (rc.right - pStatusInfo->dxGripper)) {
                    return HTBOTTOMRIGHT;
                }
            }
            goto DoDefault;

        case WM_SETTEXT:
        {
            wParam = 0;
            uMsg = SB_SETTEXT;
        }
            /* Fall through */
        case SB_SETTEXT:
            return SBSetText(pStatusInfo, wParam, (LPCTSTR)lParam);

        case SB_SETTEXTA:
        {
            BOOL bRet, bAlloced = FALSE;
            LPTSTR lpsz;

            if (!(wParam & SBT_OWNERDRAW)) 
            {
                lpsz = ProduceWFromA(pStatusInfo->uiCodePage, (LPSTR)lParam);
                bAlloced = TRUE;
            } 
            else 
            {
                lpsz = (LPTSTR)lParam;
            }

            if (!pStatusInfo)
                bRet = FALSE;
            else
            {
                bRet = SBSetText(pStatusInfo, wParam, (LPCTSTR)lpsz);
            }

            if (bAlloced)
            {
                FreeProducedString(lpsz);
            }
            return bRet;
        }

        // The WM_GETTEXT and WM_GETTEXTLENGTH messages must return a
        // character count, no flags.  (Otherwise USER gets mad at us.)
        // So we throw away the flags by returning only the LOWORD().
        case WM_GETTEXT:
            return LOWORD(SBGetText(pStatusInfo, 0, (LPVOID)lParam, (int)wParam, SBGT_TCHAR));
        case WM_GETTEXTLENGTH:
            return LOWORD(SBGetText(pStatusInfo, 0, NULL, 0, SBGT_TCHAR));

        case SB_GETTEXT:
            /* We assume the buffer is large enough to hold the string, just
             * as listboxes do; the app should call SB_GETTEXTLEN first
             */
            return SBGetText(pStatusInfo, wParam, (LPVOID)lParam, SBGT_INFINITE, SBGT_TCHAR | SBGT_OWNERDRAWOK);

        case SB_GETTEXTLENGTH:
            return SBGetText(pStatusInfo, wParam, NULL, 0, SBGT_TCHAR);

        case SB_GETTEXTA:
            /* We assume the buffer is large enough to hold the string, just
             * as listboxes do; the app should call SB_GETTEXTLEN first
             */
            return SBGetText(pStatusInfo, wParam, (LPVOID)lParam, SBGT_INFINITE, SBGT_ANSI | SBGT_OWNERDRAWOK);

        case SB_GETTEXTLENGTHA:
            return SBGetText(pStatusInfo, wParam, NULL, 0, SBGT_ANSI);

        case SB_SETBKCOLOR:
        {
            COLORREF clr = pStatusInfo->_clrBk;
            pStatusInfo->_clrBk = (COLORREF)lParam;
            InvalidateRect(hWnd, NULL, TRUE);
            return clr;
        }

        case SB_SETPARTS:
            if (!wParam || wParam>MAXPARTS)
                return FALSE;

            return SetStatusParts(pStatusInfo, (int) wParam, (LPINT)lParam);

        case SB_GETPARTS:
            if (lParam)
            {
                PSTRINGINFO pStringInfo;
                LPINT lpInt;

                /* Fill in the lesser of the number of entries asked for or
                 * the number of entries there are
                 */
                if (wParam > (WPARAM)pStatusInfo->nParts)
                    wParam = pStatusInfo->nParts;

                for (pStringInfo=pStatusInfo->sInfo, lpInt=(LPINT)lParam;
                    wParam>0; --wParam, ++pStringInfo, ++lpInt)
                    *lpInt = pStringInfo->right;
            }

            /* Always return the number of actual entries
             */
            return(pStatusInfo->nParts);

        case SB_GETBORDERS:
            // Can't validate any more than this....
            if ((LPINT)lParam != NULL)
            {
                ((LPINT)lParam)[0] = pStatusInfo->nBorderX;
                ((LPINT)lParam)[1] = pStatusInfo->nBorderY;
                ((LPINT)lParam)[2] = pStatusInfo->nBorderPart;
                return TRUE;
            }
            else
                return FALSE;
            
        case SB_ISSIMPLE:
            return !(pStatusInfo->sSimple.uType & SBT_NOSIMPLE);

        case SB_GETRECT:
            return Status_GetRect(pStatusInfo, (int)wParam, (LPRECT)lParam);

        case SB_SETMINHEIGHT:     // this is a substitute for WM_MEASUREITEM
            pStatusInfo->nMinHeight = (int) wParam;
            RecalcTooltipRects(pStatusInfo);
            break;

        case SB_SIMPLE:
        {
            BOOL bInvalidate = FALSE;

            if (wParam)
            {
                if (pStatusInfo->sSimple.uType & SBT_NOSIMPLE)
                {
                    pStatusInfo->sSimple.uType &= ~SBT_NOSIMPLE;
                    bInvalidate = TRUE;
                }
            }
            else
            {
                if ((pStatusInfo->sSimple.uType & SBT_NOSIMPLE) == 0)
                {
                    pStatusInfo->sSimple.uType |= SBT_NOSIMPLE;
                    bInvalidate = TRUE;
                }
            }

            if (bInvalidate) {
                DebugMsg(TF_STATUS, TEXT("SB_SIMPLE: %d"), wParam);
                RecalcTooltipRects(pStatusInfo);
                SendNotifyEx(pStatusInfo->ci.hwndParent, pStatusInfo->ci.hwnd, SBN_SIMPLEMODECHANGE, NULL, FALSE);
                InvalidateRect(pStatusInfo->ci.hwnd, NULL, TRUE);
            }
            break;
        }

        case SB_SETICON:
        case SB_GETICON:
        {
            PSTRINGINFO pStringInfo = NULL;

            // -1 implies we are setting the icon for sSimple
            if ((UINT_PTR)-1 == wParam)
                pStringInfo = &pStatusInfo->sSimple;
            else if(wParam < (UINT)pStatusInfo->nParts)
                pStringInfo = &pStatusInfo->sInfo[wParam];
                
            if (uMsg == SB_GETICON)
                return (LRESULT)(pStringInfo ? pStringInfo->hIcon : NULL);
                
            if (pStringInfo && (pStringInfo->hIcon != (HICON)lParam))
            {
                BITMAP bm = {0};
                RECT rc;

                if (lParam)
                {
                    ICONINFO ii;

                    // Save the dimensions of the icon
                    GetIconInfo((HICON)lParam, &ii);
                    GetObject(ii.hbmColor, sizeof(BITMAP), &bm);
                    DeleteObject(ii.hbmColor);
                    DeleteObject(ii.hbmMask);
                }

                pStringInfo->sizeIcon.cx = bm.bmWidth;
                pStringInfo->sizeIcon.cy = bm.bmHeight;
                pStringInfo->hIcon = (HICON)lParam;
                
                Status_GetRect(pStatusInfo, (int)wParam, &rc);
                InvalidateRect(pStatusInfo->ci.hwnd, &rc, TRUE);
                UpdateWindow(pStatusInfo->ci.hwnd);
            }
            return TRUE;
        }

        // HIWORD(wParam) is the cbChar
        // LOWORD(wParam) is the nPart 
        case SB_GETTIPTEXT:
        {
            PSTRINGINFO pStringInfo = GetStringInfo(pStatusInfo, LOWORD(wParam));

            if (pStringInfo && pStringInfo->pszToolTip)
                lstrcpyn((LPTSTR)lParam, pStringInfo->pszToolTip,  HIWORD(wParam));
                
            break;
        }
        
        case SB_SETTIPTEXT:
        {
            PSTRINGINFO pStringInfo = GetStringInfo(pStatusInfo, (int) wParam);

            if (pStringInfo)
                Str_Set(&pStringInfo->pszToolTip, (LPCTSTR)lParam);

            break;    
        }    
        case SB_GETTIPTEXTA:
        {
            PSTRINGINFO pStringInfo = GetStringInfo(pStatusInfo, LOWORD(wParam));

            if (pStringInfo)
                WideCharToMultiByte(CP_ACP, 0, pStringInfo->pszToolTip, -1, (LPSTR)lParam,
                                        HIWORD(wParam), NULL, NULL);
            break;
        }
        
        case SB_SETTIPTEXTA:
        {
            PSTRINGINFO pStringInfo = GetStringInfo(pStatusInfo, (int) wParam);
            LPTSTR lpsz;

            lpsz = ProduceWFromA(pStatusInfo->uiCodePage, (LPSTR)lParam);
                
            if (pStringInfo)
                Str_Set(&pStringInfo->pszToolTip, (LPCTSTR)lpsz);

            LocalFree(lpsz);
            break;    
        }    

#define lpNmhdr ((LPNMHDR)(lParam))
#define lpnmTT ((LPTOOLTIPTEXT) lParam)
#define IsTextPtr(lpszText)  (((lpszText) != LPSTR_TEXTCALLBACK) && (HIWORD64(lpszText)))
        case WM_NOTIFY:
        {
            PSTRINGINFO pStringInfo = NULL;
            if (lpNmhdr->code == TTN_NEEDTEXT) 
            {
                pStringInfo = GetStringInfo(pStatusInfo, (int) lpNmhdr->idFrom);
                if (!pStringInfo || !pStringInfo->fNeedToTip)
                    break;
            }
            //
            // We are just going to pass this on to the
            // real parent.  Note that -1 is used as
            // the hwndFrom.  This prevents SendNotifyEx
            // from updating the NMHDR structure.
            //
            SendNotifyEx(pStatusInfo->ci.hwndParent, (HWND) -1,
                   lpNmhdr->code, lpNmhdr, pStatusInfo->ci.bUnicode);

            if ((lpNmhdr->code == TTN_NEEDTEXT) && lpnmTT->lpszText 
                && IsTextPtr(lpnmTT->lpszText) && !lpnmTT->lpszText[0])
            {    
                if (pStringInfo)
                    lpnmTT->lpszText = pStringInfo->pszToolTip;
            }
            break;
        }    

        case WM_NOTIFYFORMAT:
            return CIHandleNotifyFormat(&pStatusInfo->ci, lParam);
            
        case WM_SETFONT:
            if (!pStatusInfo)
                return FALSE;

            SBSetFont(pStatusInfo, (HFONT)wParam, (BOOL)lParam);
            return TRUE;
            
        case WM_LBUTTONUP:
            nNotification = NM_CLICK;
            StatusForceCreateTooltips(pStatusInfo);
            RelayToToolTips(pStatusInfo->hwndToolTips, hWnd, uMsg, wParam, lParam);
            goto SendNotify;
        
        case WM_LBUTTONDBLCLK:
            nNotification = NM_DBLCLK;
            goto SendNotify;
        
        case WM_RBUTTONDBLCLK:
            nNotification = NM_RDBLCLK;
            goto SendNotify;
        
        case WM_RBUTTONUP:
            nNotification = NM_RCLICK;
SendNotify:
            LPARAM_TO_POINT(lParam, nm.pt);
            nm.dwItemSpec = IndexFromPt(pStatusInfo, nm.pt);
            if (!SendNotifyEx(pStatusInfo->ci.hwndParent, pStatusInfo->ci.hwnd, nNotification, (LPNMHDR)&nm,FALSE))
                goto DoDefault;
            return 0;

        case WM_GETFONT:
            if (!pStatusInfo)
                return 0;

            return (LRESULT)pStatusInfo->hStatFont;

        case WM_SIZE:
        {
            int nHeight;
            RECT rc;
            LPTSTR lpStr;
            PSTRINGINFO pStringInfo;
            int i, nTabs;

            if (!pStatusInfo)
                return 0;

            GetWindowRect(pStatusInfo->ci.hwnd, &rc);
            rc.right -= rc.left;    // -> dx
            rc.bottom -= rc.top;    // -> dy

            // If there is no parent, then this is a top level window
            if (pStatusInfo->ci.hwndParent)
            {
                ScreenToClient(pStatusInfo->ci.hwndParent, (LPPOINT)&rc);

                //
                // Places the status bar properly
                //
                if (pStatusInfo->ci.dwExStyle&RTL_MIRRORED_WINDOW)
                    rc.left -= rc.right;  
            }

            // need room for text, 3d border, and extra edge
            nHeight = 
                max(pStatusInfo->nFontHeight, g_cySmIcon) + 2 * g_cyBorder ;

            if (nHeight < pStatusInfo->nMinHeight)
                nHeight = pStatusInfo->nMinHeight;
             nHeight += pStatusInfo->nBorderY;


             // we don't have a divider thing -> force CCS_NODIVIDER
            NewSize(pStatusInfo->ci.hwnd, nHeight, GetWindowStyle(pStatusInfo->ci.hwnd) | CCS_NODIVIDER,
                rc.left, rc.top, rc.right, rc.bottom);

            // If the pane is right aligned then we need to invalidate all the pane
            // to force paint the entire pane. because the system will invalidate none if 
            // the status bar get shrieked or only the new added part if the status bar 
            // get grow and this does not work with the right justified text.
            pStringInfo = pStatusInfo->sInfo;
            for (i = 0; i < pStatusInfo->nParts; ++i, ++pStringInfo)
            {
                if ((pStringInfo->uType&SBT_ALLTYPES) == SBT_NORMAL &&
                    (lpStr = (LPTSTR)(pStringInfo->dwString)) != NULL)
                {
                    for ( nTabs = 0; (lpStr = StrChr(lpStr, TEXT('\t'))) != NULL; lpStr++) 
                    {
                        nTabs++;
                    }
                    if ( nTabs >= 2)
                    {
                        Status_GetRect(pStatusInfo, i, &rc);
                        InvalidateRect(pStatusInfo->ci.hwnd, &rc, FALSE);
                    }
                }
            }

            // need to invalidate the right end of the status bar
            // to maintain the finished edge look.
            GetClientRect(pStatusInfo->ci.hwnd, &rc);

            if (rc.right > pStatusInfo->nLastX)
                rc.left = pStatusInfo->nLastX;
            else
                rc.left = rc.right;
            rc.left -= (g_cxBorder + pStatusInfo->nBorderX);
            if (pStatusInfo->dxGripper)
                rc.left -= pStatusInfo->dxGripper;
            else
                rc.left -= pStatusInfo->nBorderPart;
            
            if (pStatusInfo->hTheme)
            {
                MARGINS m = {0};
                GetThemeMargins(pStatusInfo->hTheme, NULL, SP_PANE, 0, TMT_SIZINGMARGINS, &rc, &m);
                rc.left -= m.cxRightWidth;
            }
            
            InvalidateRect(pStatusInfo->ci.hwnd, &rc, TRUE);
            RecalcTooltipRects(pStatusInfo);
            pStatusInfo->nLastX = rc.right;
            break;
        }

        case WM_PRINTCLIENT:
        case WM_PAINT:
            if (!pStatusInfo)
                break;

            if (pStatusInfo->sSimple.uType & SBT_NOSIMPLE)
                PaintStatusWnd(pStatusInfo, (HDC)wParam, pStatusInfo->sInfo, pStatusInfo->nParts, pStatusInfo->nBorderX);
            else
                PaintStatusWnd(pStatusInfo, (HDC)wParam, &pStatusInfo->sSimple, 1, 0);

            return 0;       

        case WM_ERASEBKGND:
            if (pStatusInfo) 
            {  
                RECT rc;
                GetClientRect(hWnd, &rc);            
                if (pStatusInfo->hTheme)
                {
                    DrawThemeBackground(pStatusInfo->hTheme, (HDC)wParam, 0, 0, &rc, 0);
                    return 1;
                }
                else if (pStatusInfo->_clrBk != CLR_DEFAULT) 
                {
                    FillRectClr((HDC)wParam, &rc, pStatusInfo->_clrBk);        
                    return 1;
                }
            }
            goto DoDefault;

        case WM_GETOBJECT:
            if( lParam == OBJID_QUERYCLASSNAMEIDX )
                return MSAA_CLASSNAMEIDX_STATUS;
            goto DoDefault;

        case WM_THEMECHANGED:
            if (pStatusInfo->hTheme)
                CloseThemeData(pStatusInfo->hTheme);

            pStatusInfo->hTheme = OpenThemeData(pStatusInfo->ci.hwnd, L"Status");
            InvalidateRect(pStatusInfo->ci.hwnd, NULL, TRUE);
            return 0;

        default:
        {
            LRESULT lres;
            if (CCWndProc(&pStatusInfo->ci, uMsg, wParam, lParam, &lres))
                return lres;
        }
            break;
    }

DoDefault:
    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

BOOL InitStatusClass(HINSTANCE hInstance)
{
    WNDCLASS rClass;

    rClass.lpfnWndProc        = StatusWndProc;
    rClass.style            = CS_DBLCLKS | CS_GLOBALCLASS |    CS_VREDRAW;
    rClass.cbClsExtra         = 0;
    rClass.cbWndExtra         = sizeof(PSTATUSINFO);
    rClass.hInstance        = hInstance;
    rClass.hIcon            = NULL;
    rClass.hCursor            = LoadCursor(NULL, IDC_ARROW);
    rClass.hbrBackground    = (HBRUSH)(COLOR_BTNFACE+1);
    rClass.lpszMenuName     = NULL;
    rClass.lpszClassName    = c_szStatusClass;

    if (!RegisterClass(&rClass) && !GetClassInfo(hInstance, c_szStatusClass, &rClass))
        return FALSE;

    return TRUE;
}


HWND WINAPI CreateStatusWindow(LONG style, LPCTSTR pszText, HWND hwndParent, UINT uID)
{
    // remove border styles to fix capone and other apps

    return CreateWindowEx(0, c_szStatusClass, pszText, style & ~(WS_BORDER | CCS_NODIVIDER),
        -100, -100, 10, 10, hwndParent, IntToPtr_(HMENU, uID), HINST_THISDLL, NULL);
}

HWND WINAPI CreateStatusWindowA(LONG style, LPCSTR pszText, HWND hwndParent,
        UINT uID)
{
    // remove border styles to fix capone and other apps

    return CreateWindowExA(0, STATUSCLASSNAMEA, pszText, style & ~(WS_BORDER | CCS_NODIVIDER),
        -100, -100, 10, 10, hwndParent, IntToPtr_(HMENU, uID), HINST_THISDLL, NULL);
}
void WINAPI DrawStatusTextEx(PSTATUSINFO pStatusInfo, HDC hDC, LPRECT lprc, LPCTSTR pszText, STRINGINFO * psi,  UINT uFlags, BOOL fClipText)
{
    int len, nWidth = 0, nHeight = 0;
    HBRUSH hFaceBrush=NULL;
    COLORREF crTextColor, crBkColor;
    UINT uOpts = 0;
    BOOL bNull;
    int nOldMode;
    int i = 0, left = 0;
    LPTSTR lpTab, lpNext;
    TCHAR szBuf[MAX_STATUS_TEXT_LEN];
    int oldAlign;
    BOOL fDrawnIcon = FALSE;
    RECT rc = * lprc;
    RECT rcItem = *lprc;

    //
    // IMPORTANT NOTE:
    // pStatusInfo can be NULL, please check before reference.
    //

    if (uFlags & SBT_RTLREADING)
    {
        oldAlign = GetTextAlign(hDC);
        SetTextAlign(hDC, oldAlign | TA_RTLREADING);
    }

    if (pszText)
        lstrcpyn(szBuf, pszText, ARRAYSIZE(szBuf));
    else
        szBuf[0] = TEXT('\0');

    if (pStatusInfo && pStatusInfo->hTheme)
    {
        if (!(uFlags & SBT_NOBORDERS))
            DrawThemeBackground(pStatusInfo->hTheme, hDC, fClipText?SP_GRIPPERPANE:SP_PANE, 0, &rc, 0);
        InflateRect(&rc, -g_cxBorder, -g_cyBorder);

        crTextColor = SetTextColor(hDC, g_clrBtnText);
        crBkColor = SetBkColor(hDC, g_clrBtnFace);
        nOldMode = SetBkMode(hDC, TRANSPARENT);
    }
    else
    {
        //
        // Create the three brushes we need.    If the button face is a solid
        // color, then we will just draw in opaque, instead of using a
        // brush to avoid the flash
        //
        if (GetNearestColor(hDC, g_clrBtnFace) == g_clrBtnFace ||
            !(hFaceBrush = CreateSolidBrush(g_clrBtnFace)))
        {
            uOpts = ETO_CLIPPED | ETO_OPAQUE;
            nOldMode = SetBkMode(hDC, OPAQUE);
        }
        else
        {
            uOpts = ETO_CLIPPED;
            nOldMode = SetBkMode(hDC, TRANSPARENT);
        }
        crTextColor = SetTextColor(hDC, g_clrBtnText);
        if (pStatusInfo && (pStatusInfo->_clrBk != CLR_DEFAULT))
            crBkColor = SetBkColor(hDC, pStatusInfo->_clrBk);
        else
            crBkColor = SetBkColor(hDC, g_clrBtnFace);

        // Draw the hilites

        if (!(uFlags & SBT_NOBORDERS))
            // BF_ADJUST does the InflateRect stuff
            DrawEdge(hDC, &rc, (uFlags & SBT_POPOUT) ? BDR_RAISEDINNER : BDR_SUNKENOUTER, BF_RECT | BF_ADJUST);
        else
            InflateRect(&rc, -g_cxBorder, -g_cyBorder);
        
        if (hFaceBrush)
        {
            HBRUSH hOldBrush = SelectObject(hDC, hFaceBrush);
            if (hOldBrush)
            {
                PatBlt(hDC, rc.left, rc.top,
                       rc.right-rc.left, rc.bottom-rc.top, PATCOPY);
                SelectObject(hDC, hOldBrush);
            }
        }
    }

    for (i=0, lpNext=szBuf, bNull=FALSE; i<3; ++i)
    {
        HRESULT hr = E_FAIL;
        int cxIcon = 0;
        int leftIcon;
        UINT uiCodePage = pStatusInfo? pStatusInfo->uiCodePage: CP_ACP;
        /* Optimize for NULL left or center strings
         */
        if (!(uFlags & SBT_NOTABPARSING)) 
        {
            if (*lpNext==TEXT('\t') && i<=1)
            {
                ++lpNext;
                continue;
            }
        }

        /* Determine the end of the current string
         */
        for (lpTab=lpNext; ; lpTab=CharNextEx((WORD)uiCodePage, lpTab, 0))
        {
            if (!*lpTab) {
                bNull = TRUE;
                break;
            } else if (!(uFlags & SBT_NOTABPARSING)) 
            {
                if (*lpTab == TEXT('\t'))
                    break;
            }
        }
        *lpTab = TEXT('\0');
        len = lstrlen(lpNext);

        if (pStatusInfo && pStatusInfo->hTheme)
        {
            RECT rc = {0};
            hr = GetThemeTextExtent(pStatusInfo->hTheme, hDC, 0, 0, lpNext, -1, DT_CALCRECT | DT_SINGLELINE,  &rc, &rc);
            nWidth = RECTWIDTH(rc);
            nHeight = RECTHEIGHT(rc);
        }

        if (FAILED(hr))
            MGetTextExtent(hDC, lpNext, len, &nWidth, &nHeight);

        if (psi) 
        {
            if (psi->hIcon && !fDrawnIcon) 
            {
                cxIcon = psi->sizeIcon.cx + g_cxEdge * 2;
                fDrawnIcon = TRUE;
            }
        }

        /* i=0 means left, 1 means center, and 2 means right justified text
         */
        switch (i) {
            case 0:
                leftIcon = rcItem.left + g_cxEdge;
                break;

            case 1:
                leftIcon = (rcItem.left + rcItem.right - (nWidth + cxIcon)) / 2;
                break;

            default:
                leftIcon = rcItem.right - g_cxEdge - (nWidth + cxIcon);
                break;
        }    
        
        left = leftIcon + cxIcon;

        if (psi)
        {
            if (cxIcon)
            {
                int nTop = rc.top + ((rc.bottom - rc.top)  - (psi->sizeIcon.cy )) / 2 ;

                if (leftIcon > rcItem.left) 
                {
                    if (psi->hIcon)
                    {
                        DrawIconEx(hDC, leftIcon, nTop, psi->hIcon,
                                   psi->sizeIcon.cx, psi->sizeIcon.cy, 
                                   0, NULL, DI_NORMAL);
                    }
                }
                rc.left = leftIcon + cxIcon;
            }

            if (!*lpNext && cxIcon)
                psi->fNeedToTip = TRUE;
            else 
                psi->fNeedToTip  = (BOOL)(nWidth >= (rc.right - rc.left));
        }

        if (pStatusInfo && pStatusInfo->hTheme)
        {
            RECT rcText = rc;
            rcText.left = left;
            rcText.top = (rc.bottom - nHeight + rc.top) / 2;
            if (fClipText)
            {
                rcText.right -= pStatusInfo->dxGripper;
            }

            hr = DrawThemeText(pStatusInfo->hTheme, hDC, 0, 0, lpNext, -1, DT_SINGLELINE | DT_NOPREFIX, 0, &rcText);
        }

        if (FAILED(hr))
            ExtTextOut(hDC, left, (rc.bottom - nHeight + rc.top) / 2, uOpts, &rc, lpNext, len, NULL);

        /* Now that we have drawn text once, take off the OPAQUE flag
         */
        uOpts = ETO_CLIPPED;

        if (bNull)
            break;

        *lpTab = TEXT('\t');
        lpNext = lpTab + 1;
    }

    if (uFlags & SBT_RTLREADING)
        SetTextAlign(hDC, oldAlign);

    SetTextColor(hDC, crTextColor);
    SetBkColor(hDC, crBkColor);
    SetBkMode(hDC, nOldMode);

    if (hFaceBrush)
        DeleteObject(hFaceBrush);

}

void RecalcTooltipRects(PSTATUSINFO pStatusInfo)
{
    if(pStatusInfo->hwndToolTips) 
    {
        UINT i;
        TOOLINFO ti;
        STRINGINFO * psi;

        ti.cbSize = sizeof(ti);
        ti.hwnd = pStatusInfo->ci.hwnd;
        ti.lpszText = LPSTR_TEXTCALLBACK;

        if (pStatusInfo->sSimple.uType & SBT_NOSIMPLE)
        {
            for ( i = 0, psi = pStatusInfo->sInfo; i < (UINT)pStatusInfo->nParts; i++, psi++) 
            {
                ti.uId = i;
                Status_GetRect(pStatusInfo, i, &ti.rect);
                SendMessage(pStatusInfo->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM)((LPTOOLINFO)&ti));
            }
            SetRect(&ti.rect, 0,0,0,0);
            ti.uId = SB_SIMPLEID;
            SendMessage(pStatusInfo->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM)((LPTOOLINFO)&ti));
        }
        else
        {

            GetClientRect(pStatusInfo->ci.hwnd, &ti.rect);
            InflateRect(&ti.rect, -g_cxBorder, -g_cyBorder);
            ti.uId = SB_SIMPLEID;
            SendMessage(pStatusInfo->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM)((LPTOOLINFO)&ti));
            SetRect(&ti.rect, 0,0,0,0);
            for ( i = 0, psi = pStatusInfo->sInfo; i < (UINT)pStatusInfo->nParts; i++, psi++) 
            {
                ti.uId = i;
                SendMessage(pStatusInfo->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM)((LPTOOLINFO)&ti));
            }
        }
    }    
   return;
}

PSTRINGINFO GetStringInfo(PSTATUSINFO pStatusInfo, int nIndex)
{
    PSTRINGINFO pRet = NULL;

    if (nIndex == SB_SIMPLEID)
        pRet = &pStatusInfo->sSimple;
    else if (nIndex < pStatusInfo->nParts)
        pRet = &pStatusInfo->sInfo[nIndex];

    return pRet;
}

int  IndexFromPt(PSTATUSINFO pStatusInfo, POINT pt)
{
    RECT rc;
    int nPart = 0;

    //
    //  More IE4 bug-for-bug compatibility.  IE4 tested for simple mode
    //  incorrectly.
    //
    if (pStatusInfo->ci.iVersion < 5)
    {
        // This is not a typo!  Well, actually, it *is* a typo, but it's
        // a typo we have to preserve for compatibility.  I don't know if
        // anybody relied on the typo, but I'm playing it safe.
        //
        // The bug was that in IE4, a click on a simple status bar usually
        // came back as SB_HITTEST_NOITEM instead of SB_SIMPLEID.
        //
        // I re-parenthesized the test so typo.pl won't trigger.  The original
        // IE4 code lacked the parentheses.

        if ((!pStatusInfo->sSimple.uType) & SBT_NOSIMPLE)
            return SB_SIMPLEID;
    }
    else
    {
        if (!(pStatusInfo->sSimple.uType & SBT_NOSIMPLE))
            return SB_SIMPLEID;
    }

    for(nPart = 0; nPart < pStatusInfo->nParts; nPart++)
    {
        Status_GetRect(pStatusInfo, nPart, &rc);
        if (PtInRect(&rc, pt))
            return nPart;
    }
    return SB_HITTEST_NOITEM;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\thunk.h ===
/*************************************************************************\
*
* thunk.h
*
* These are helper functions to make thunking easier.
*
* 18-Aug-1994 JonPa     Created it.
*
\ *************************************************************************/

/*
 * Creates a buffer for a unicode string, and then copies the ANSI text
 * into it (converting it to unicode in the process)
 *
 * The returned pointer should be freed with FreeProducedString after use.
 */
LPWSTR ProduceWFromA( UINT uiCodePage, LPCSTR pszAnsi );

/*
 * Creates a buffer for a ANSI string, and then copies the UNICODE text
 * into it (converting it to ANSI in the process)
 *
 * The returned pointer should be freed with FreeProducedString after use.
 */
LPSTR ProduceAFromW( UINT uiCodePage, LPCWSTR pszW );


/*
 * FreeProducedString
 *
 * Takes a pointer returned from Produce?From?() and frees it.  No
 * validity checking is needed before calling this function.  (ie, any
 * value returned by Produce?From?() can be safely sent to this function)
 */
#define FreeProducedString( psz )   \
    if((psz) != NULL && ((LPSTR)psz) != LPSTR_TEXTCALLBACKA) {LocalFree(psz);} else


/*
 * Converts a UNICODE string to ANSI
 */
#define ConvertWToAN( uiCodePage, pszABuf, cchA, pszW, cchW )         \
    WideCharToMultiByte(uiCodePage, 0, pszW, cchW, pszABuf, cchA, NULL, NULL)

#define ConvertWToA( uiCodePage, pszABuf, pszW )     \
    ConvertWToAN( uiCodePage, pszABuf, INT_MAX, pszW, -1 )

/*
 * Converts an ANSI string to UNICODE
 */
#define ConvertAToWN( uiCodePage, pszWBuf, cchW, pszA, cchA )         \
    MultiByteToWideChar( uiCodePage, MB_PRECOMPOSED, pszA, cchA, pszWBuf, cchW )

#define ConvertAToW( uiCodePage, pszWBuf, pszAnsi )     \
    ConvertAToWN( uiCodePage, pszWBuf, INT_MAX, pszAnsi, -1 )


/*
 * IsFlagPtr
 *  Returns TRUE if the pointer == NULL or -1
 */
#define IsFlagPtr( p )  ((p) == NULL || (LPSTR)(p) == LPSTR_TEXTCALLBACKA)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\static.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "static.h"
#include "image.h"

#define SS_TEXTMIN1         0x0000000BL
#define SS_TEXTMAX1         0x0000000DL
#define SS_EDITCONTROL      0x00002000L

#define ISSSTEXTOROD(bType)                 \
            (((bType) <= SS_TEXTMAX0)       \
            || (((bType) >= SS_TEXTMIN1)    \
            && ((bType) <= SS_TEXTMAX1)))

//  Common macros for image handling.
#define IsValidImage(imageType, realType, max)  \
            ((imageType < max) && (rgbType[imageType] == realType))


//---------------------------------------------------------------------------//
//
//  Type table.  This is used for validation of the
//  image-types.  For the PPC release we won't support
//  the metafile format, but others are OK.
#define IMAGE_STMMAX    IMAGE_ENHMETAFILE+1
static BYTE rgbType[IMAGE_STMMAX] = 
{
    SS_BITMAP,       // IMAGE_BITMAP
    SS_ICON,         // IMAGE_CURSOR
    SS_ICON,         // IMAGE_ICON
    SS_ENHMETAFILE   // IMAGE_ENHMETAFILE
};


//---------------------------------------------------------------------------//
//
//  LOBYTE of SS_ style is index into this array
#define STK_OWNER       0x00
#define STK_IMAGE       0x01
#define STK_TEXT        0x02
#define STK_GRAPHIC     0x03
#define STK_TYPE        0x03

#define STK_ERASE       0x04
#define STK_USEFONT     0x08
#define STK_USETEXT     0x10

BYTE rgstk[] = 
{
    STK_TEXT | STK_ERASE | STK_USEFONT | STK_USETEXT,       // SS_LEFT
    STK_TEXT | STK_ERASE | STK_USEFONT | STK_USETEXT,       // SS_CENTER
    STK_TEXT | STK_ERASE | STK_USEFONT | STK_USETEXT,       // SS_RIGHT
    STK_IMAGE | STK_ERASE,                                  // SS_ICON
    STK_GRAPHIC,                                            // SS_BLACKRECT
    STK_GRAPHIC,                                            // SS_GRAYRECT
    STK_GRAPHIC,                                            // SS_WHITERECT
    STK_GRAPHIC,                                            // SS_BLACKFRAME
    STK_GRAPHIC,                                            // SS_GRAYFRAME
    STK_GRAPHIC,                                            // SS_WHITEFRAME
    STK_OWNER,                                              // SS_USERITEM
    STK_TEXT | STK_USEFONT | STK_USETEXT,                   // SS_SIMPLE
    STK_TEXT | STK_ERASE | STK_USEFONT | STK_USETEXT,       // SS_LEFTNOWORDWRAP
    STK_OWNER | STK_USEFONT | STK_USETEXT,                  // SS_OWNERDRAW
    STK_IMAGE | STK_ERASE,                                  // SS_BITMAP
    STK_IMAGE | STK_ERASE,                                  // SS_ENHMETAFILE
    STK_GRAPHIC,                                            // SS_ETCHEDHORZ
    STK_GRAPHIC,                                            // SS_ETCHEDVERT
    STK_GRAPHIC                                             // SS_ETCHEDFRAME
};

//---------------------------------------------------------------------------//
//
//  InitStaticClass() - Registers the control's window class 
//
BOOL InitStaticClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = Static_WndProc;
    wc.lpszClassName = WC_STATIC;
    wc.style         = CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PSTAT);
    wc.hInstance     = hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;

    if (!RegisterClass(&wc) && !GetClassInfo(hInstance, WC_STATIC, &wc))
        return FALSE;

    return TRUE;
}


//---------------------------------------------------------------------------//
void GetRectInParent(HWND hwnd, PRECT prc)
{
    HWND hwndParent = GetParent(hwnd);

    GetWindowRect(hwnd, prc);
    ScreenToClient(hwndParent, (PPOINT)prc);
    ScreenToClient(hwndParent, (PPOINT)&prc->right);
}


//---------------------------------------------------------------------------//
VOID GetIconSize(HICON hIcon, PSIZE pSize)
{
    ICONINFO iconInfo;
    BITMAP   bmp;

    pSize->cx = pSize->cy = 32;

    if (GetIconInfo(hIcon, &iconInfo))
    {
        if (GetObject(iconInfo.hbmColor, sizeof(bmp), &bmp)) 
        {
            pSize->cx = bmp.bmWidth;
            pSize->cy = bmp.bmHeight;
        }

        DeleteObject(iconInfo.hbmMask);
        DeleteObject(iconInfo.hbmColor);
    }
}


//---------------------------------------------------------------------------//
//
// SetStaticImage()
//
// Sets bitmap/icon of static guy, either in response to a STM_SETxxxx
// message, or at create time.
//
HANDLE Static_SetImage(PSTAT pstat, HANDLE hImage, BOOL fDeleteIt)
{
    UINT   bType;
    RECT   rc;
    RECT   rcWindow;
    RECT   rcClient;
    HANDLE hImageOld;
    DWORD  dwRate;
    UINT   cicur;
    BOOL   fAnimated = FALSE;
    HWND   hwnd = pstat->hwnd;
    LONG   dwStyle = GET_STYLE(pstat);

    bType =  dwStyle & SS_TYPEMASK;

    GetClientRect(hwnd, &rcClient);

    //
    // If this is an old-ani-icon, then delete its timer.
    //
    if ((bType == SS_ICON) && pstat->cicur > 1) 
    {
        //
        // Old cursor was an animated cursor, so kill
        // the timer that is used to animate it.
        //
        KillTimer(hwnd, IDSYS_STANIMATE);
    }

    //
    // Initialize the old-image return value.
    //
    hImageOld = pstat->hImage;

    rc.right = rc.bottom = 0;

    if (hImage != NULL) 
    {

        switch (bType) 
        {
        case SS_ENHMETAFILE: 
        {
            //
            // We do NOT resize the window.
            //
            rc.right  = rcClient.right  - rcClient.left;
            rc.bottom = rcClient.bottom - rcClient.top;

            break;
        }

        case SS_BITMAP: 
        {
            BITMAP bmp;

            pstat->fAlphaImage = FALSE;

            if (GetObject(hImage, sizeof(BITMAP), &bmp)) 
            {
                rc.right  = bmp.bmWidth;
                rc.bottom = bmp.bmHeight;

                if (bmp.bmBitsPixel == 32)
                {
                    HDC hdc = CreateCompatibleDC(NULL);
                    if (hdc)
                    {
                        RGBQUAD* prgb;
                        HBITMAP hbmpImage32 = CreateDIB(hdc, bmp.bmWidth, bmp.bmHeight, &prgb);
                        if (hbmpImage32)
                        {
                            HDC hdc32 = CreateCompatibleDC(hdc);
                            if (hdc32)
                            {
                                HBITMAP hbmpOld = (HBITMAP)SelectObject(hdc32, hbmpImage32);
                                HBITMAP hbmpTemp = (HBITMAP)SelectObject(hdc, hImage);
                                BitBlt(hdc32, 0, 0, bmp.bmWidth, bmp.bmHeight, hdc, 0, 0, SRCCOPY);

                                SelectObject(hdc, hbmpTemp);
                                SelectObject(hdc32, hbmpOld);
                                DeleteDC(hdc32);

                                if (DIBHasAlpha(bmp.bmWidth, bmp.bmHeight, prgb))
                                {
                                    PreProcessDIB(bmp.bmWidth, bmp.bmHeight, prgb);

                                    if (fDeleteIt)
                                        DeleteObject(hImage);

                                    pstat->fAlphaImage = TRUE;
                                    hImage = hbmpImage32;
                                    hbmpImage32 = NULL;
                                    fDeleteIt = TRUE;
                                }
                            }

                            if (hbmpImage32)
                                DeleteObject(hbmpImage32);
                        }

                        DeleteDC(hdc);
                    }
                }
            }

            break;
        }

        case SS_ICON: 
        {
            SIZE size;

            GetIconSize((HICON)hImage, &size);
            rc.right  = size.cx;
            rc.bottom = size.cy;

            pstat->cicur = 0;
            pstat->iicur = 0;

            //
            // Perhaps we can do something like shell\cpl\main\mouseptr.c
            // here, and make GetCursorFrameInfo obsolete.
            //
            if (GetCursorFrameInfo(hImage, NULL, 0, &dwRate, &cicur)) 
            {
                fAnimated = (cicur > 1);
                pstat->cicur = cicur;
            }
            break;
        }

        }
    }

    pstat->hImage = hImage;
    pstat->fDeleteIt = fDeleteIt;

    //
    // Resize static to fit.
    // Do NOT do this for SS_CENTERIMAGE or SS_REALSIZECONTROL
    //
    if (!(dwStyle & SS_CENTERIMAGE) && !(dwStyle & SS_REALSIZECONTROL))
    {
        //
        // Get current window rect in parent's client coordinates.
        //
        GetRectInParent(hwnd, &rcWindow);

        //
        // Get new window dimensions
        //
        rc.left = 0;
        rc.top = 0;

        if (rc.right && rc.bottom) 
        {
            AdjustWindowRectEx(&rc, dwStyle, FALSE, GET_EXSTYLE(pstat));
            rc.right  -= rc.left;
            rc.bottom -= rc.top;
        }

        SetWindowPos(hwnd, HWND_TOP,
                    0, 0, rc.right, rc.bottom,
                    SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
    }

    if (IsWindowVisible(hwnd)) 
    {
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }


    //
    // If this is an aimated-icon, then start the timer for
    // the animation sequence.
    //
    if(fAnimated) 
    {
        //
        // Perhaps we can do something like shell\cpl\main\mouseptr.c
        // here, and make GetCursorFrameInfo obsolete.
        //
        GetCursorFrameInfo(pstat->hImage, NULL, pstat->iicur, &dwRate, &cicur);
        dwRate = max(200, dwRate * 100 / 6);
        SetTimer(hwnd, IDSYS_STANIMATE, dwRate, NULL);
    }

    return hImageOld;
}


//---------------------------------------------------------------------------//
//
// Static_LoadImage()
//
// Loads the icon or bitmap from the app's resource file if a name was
// specified in the dialog template.  We assume that the name is the name
// of the resource to load.
//
VOID Static_LoadImage(PSTAT pstat, LPTSTR lpszName)
{
    HANDLE hImage = NULL;
    HWND hwnd = pstat->hwnd;
    ULONG ulStyle = GET_STYLE(pstat);
    HINSTANCE hInstance = (HINSTANCE) GetWindowInstance(hwnd);

    if (lpszName && *lpszName) 
    {
        //
        // Only try to load the icon/bitmap if the string is non null.
        //
        if (*(BYTE *)lpszName == 0xFF)
        {
            lpszName = (TCHAR*)MAKEINTRESOURCE(((LPWORD)lpszName)[1]);
        }
   
        //
        // Load the image.  If it can't be found in the app, try the
        // display driver.
        //
        if (lpszName)
        {
            switch ((ulStyle & SS_TYPEMASK)) 
            {
            case SS_BITMAP:

                hImage = LoadBitmap(hInstance, lpszName);

                //
                // If the above didn't load it, try loading it from the
                // display driver (hmod == NULL).
                //
                if (hImage == NULL)
                {
                    hImage = LoadBitmap(NULL, lpszName);
                }

                break;

            case SS_ICON:
                if ((ulStyle & SS_REALSIZEIMAGE)) 
                {
                    hImage = LoadImage(hInstance, lpszName, IMAGE_ICON, 0, 0, 0);
                } 
                else 
                {
                    hImage = LoadIcon(hInstance, lpszName);

                    //
                    // We will also try to load a cursor-format if the
                    // window is a 4.0 compatible.  Icons/Cursors are really
                    // the same.  We don't do this for 3.x apps for the
                    // usual compatibility reasons.
                    //
                    if ((hImage == NULL))
                    {
                        hImage = LoadCursor(hInstance, lpszName);
                    }

                    //
                    // If the above didn't load it, try loading it from the
                    // display driver (hmod == NULL).
                    //
                    if (hImage == NULL) 
                    {
                        hImage = LoadIcon(NULL, lpszName);
                    }
                }

                break;
            }

            //
            // Set the image if it was loaded.
            //
            if (hImage)
            {
                Static_SetImage(pstat, hImage, TRUE);
            }
        }
    }
}


//---------------------------------------------------------------------------//
//
// Static_DrawStateCB()
//
// Draws text statics, called by DrawState.
//
BOOL CALLBACK Static_DrawStateCB(HDC hdc, LPARAM lp, WPARAM wp, int cx, int cy)
{
    PSTAT pstat  = (PSTAT)lp;
    if (pstat)
    {
        UINT   style;
        RECT   rc;
        BYTE   bType;
        LONG   lTextLength;
        ULONG  ulStyle   = GET_STYLE(pstat);
        ULONG  ulExStyle = GET_EXSTYLE(pstat);
        HWND   hwnd = pstat->hwnd;


        bType = (BYTE)(ulStyle & SS_TYPEMASK);
        
        if ((lTextLength = GetWindowTextLength(hwnd))) 
        {
            PTCHAR lpszName = (TCHAR *) _alloca((lTextLength + 1) * sizeof(wchar_t));

            if (lpszName)
            {
                GetWindowText(pstat->hwnd, lpszName, lTextLength + 1);
                style = DT_NOCLIP | DT_EXPANDTABS;

                if (bType != LOBYTE(SS_LEFTNOWORDWRAP)) 
                {
                    style |= DT_WORDBREAK;
                    style |= (UINT)(bType - LOBYTE(SS_LEFT));

                    if (ulStyle &  SS_EDITCONTROL)
                    {
                        style |= DT_EDITCONTROL;
                    }
                }

                switch (ulStyle & SS_ELLIPSISMASK) 
                {
                case SS_WORDELLIPSIS:
                    style |= DT_WORD_ELLIPSIS | DT_SINGLELINE;
                    break;

                case SS_PATHELLIPSIS:
                    style |= DT_PATH_ELLIPSIS | DT_SINGLELINE;
                    break;

                case SS_ENDELLIPSIS:
                    style |= DT_END_ELLIPSIS | DT_SINGLELINE;
                    break;
                }

                if (ulStyle &  SS_NOPREFIX)
                {
                    style |= DT_NOPREFIX;
                }

                if (ulStyle & SS_CENTERIMAGE)
                {
                    style |= DT_VCENTER | DT_SINGLELINE;
                }

                rc.left     = 0;
                rc.top      = 0;
                rc.right    = cx;
                rc.bottom   = cy;

                if (TESTFLAG(GET_EXSTYLE(pstat), WS_EXP_UIACCELHIDDEN))
                {
                    style |= DT_HIDEPREFIX;
                } 
                else if (pstat->fPaintKbdCuesOnly) 
                {
                    style |= DT_PREFIXONLY;
                }

                if (!pstat->hTheme)
                {
                    DrawText(hdc, lpszName, -1, &rc, (DWORD)style);
                }
                else
                {
                    DrawThemeText(pstat->hTheme, 
                                  hdc, 
                                  0, 
                                  0, 
                                  lpszName, 
                                  lTextLength, 
                                  style, 
                                  0, 
                                  &rc);
                }
            }
        }

        return TRUE;
    }

    return FALSE;
}


//---------------------------------------------------------------------------//
void Static_Paint(PSTAT pstat, HDC hdc, BOOL fClip)
{
    HWND   hwndParent;
    RECT   rc;
    UINT   cmd;
    BYTE   bType;
    BOOL   fFont;
    HBRUSH hbrControl;
    UINT   oldAlign;
    DWORD  dwOldLayout=0;
    HANDLE hfontOld = NULL;
    HWND hwnd = pstat->hwnd;
    ULONG ulStyle = GET_STYLE(pstat);
    ULONG ulExStyle = GET_EXSTYLE(pstat);

    if (ulExStyle & WS_EX_RTLREADING)
    {
        oldAlign = GetTextAlign(hdc);
        SetTextAlign(hdc, oldAlign | TA_RTLREADING);
    }

    bType = (BYTE)(ulStyle & SS_TYPEMASK);
    GetClientRect(hwnd, &rc);

    if (fClip) 
    {
        IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
    }

    fFont = (rgstk[bType] & STK_USEFONT) && (pstat->hFont != NULL);

    if (fFont)
    {
        hfontOld = SelectObject(hdc, pstat->hFont);
    }

    //
    // Send WM_CTLCOLORSTATIC to all statics (even frames) for 1.03
    // compatibility.
    //
    SetBkMode(hdc, OPAQUE);
    hbrControl = (HBRUSH)SendMessage(GetParent(hwnd), WM_CTLCOLORSTATIC, (WPARAM)hdc, (LPARAM)hwnd);

    //
    // Do we erase the background?  We don't for SS_OWNERDRAW
    // and STK_GRAPHIC kind of things.
    //
    hwndParent = GetParent(hwnd);
    
    if ((rgstk[bType] & STK_ERASE) && 
         !pstat->fPaintKbdCuesOnly &&
         !pstat->hTheme) 
    {
        FillRect(hdc, &rc, hbrControl);
    }

    switch (LOBYTE(bType))
    {
    case SS_ICON:

        if (pstat->hImage)
        {

            int     cx;
            int     cy;

            if (ulExStyle & WS_EX_LAYOUTRTL) 
            {
                dwOldLayout = SetLayoutWidth(hdc, -1, 0);
            }

            //
            // Perform the correct rect-setup.
            //
            if (ulStyle & SS_CENTERIMAGE)
            {
                SIZE size;

                GetIconSize((HICON)pstat->hImage, &size);
                cx = size.cx;
                cy = size.cy;

                rc.left   = (rc.right  - cx) / 2;
                rc.right  = (rc.left   + cx);
                rc.top    = (rc.bottom - cy) / 2;
                rc.bottom = (rc.top    + cy);
            }
            else
            {
                cx = rc.right  - rc.left;
                cy = rc.bottom - rc.top;
            }

            DrawIconEx(hdc, rc.left, rc.top, (HICON)pstat->hImage, cx, cy,
                       pstat->iicur, pstat->hTheme ? NULL : hbrControl, DI_NORMAL);

            if (ulExStyle & WS_EX_LAYOUTRTL) 
            {
                SetLayoutWidth(hdc, -1, dwOldLayout);
            }
        }
        else 
        {
            // Empty!  Need to erase.
            FillRect(hdc, &rc, hbrControl);
        }
        break;

    case SS_BITMAP:

        if (pstat->hImage)
        {

            BITMAP  bmp;
            //
            // Get the bitmap information.  If this fails, then we
            // can assume somethings wrong with its format...don't
            // draw in this case.
            //
            if (GetObject(pstat->hImage, sizeof(BITMAP), &bmp))
            {
                HDC hdcT;

                if (ulStyle & SS_CENTERIMAGE) 
                {
                    rc.left   = (rc.right  - bmp.bmWidth)  >> 1;
                    rc.right  = (rc.left   + bmp.bmWidth);
                    rc.top    = (rc.bottom - bmp.bmHeight) >> 1;
                    rc.bottom = (rc.top    + bmp.bmHeight);
                } 

                //
                // Select in the bitmap and blt it to the client-surface.
                //
                hdcT = CreateCompatibleDC(hdc);
                if (hdcT)
                {
                    HBITMAP hbmpT = (HBITMAP)SelectObject(hdcT, pstat->hImage);

                    if (pstat->fAlphaImage)
                    {
                        BLENDFUNCTION bf = {0};
                        bf.BlendOp = AC_SRC_OVER;
                        bf.SourceConstantAlpha = 255;
                        bf.AlphaFormat = AC_SRC_ALPHA;
                        bf.BlendFlags = 0;
                        GdiAlphaBlend(hdc,  rc.left, rc.top, rc.right-rc.left,
                               rc.bottom-rc.top, hdcT, 0, 0, bmp.bmWidth, bmp.bmHeight, bf);
                    }
                    else
                    {
                        // I'm assuming people try to match the color to the dialog
                        GdiTransparentBlt(hdc, rc.left, rc.top, rc.right-rc.left,
                               rc.bottom-rc.top, hdcT, 0, 0, bmp.bmWidth,
                               bmp.bmHeight, GetSysColor(COLOR_BTNFACE));       
                    }

                    if (hbmpT)
                    {
                        SelectObject(hdcT, hbmpT);
                    }

                    DeleteDC(hdcT);
                }                
            }
        }
        break;

    case SS_ENHMETAFILE:

        if (pstat->hImage) 
        {
            RECT rcl;

            rcl.left   = rc.left;
            rcl.top    = rc.top;
            rcl.right  = rc.right;
            rcl.bottom = rc.bottom;

            PlayEnhMetaFile(hdc, (HENHMETAFILE)pstat->hImage, &rcl);
        }
        break;

    case SS_OWNERDRAW: 
        {
            DRAWITEMSTRUCT dis;

            dis.CtlType    = ODT_STATIC;
            dis.CtlID      = GetDlgCtrlID(hwnd);
            dis.itemAction = ODA_DRAWENTIRE;
            dis.itemState  = IsWindowVisible(hwnd) ? ODS_DISABLED : 0;
            dis.hwndItem   = hwnd;
            dis.hDC        = hdc;
            dis.itemData   = 0L;
            dis.rcItem     = rc;

            if (TESTFLAG(GET_EXSTYLE(pstat), WS_EXP_UIACCELHIDDEN))
            {
                dis.itemState |= ODS_NOACCEL;
            }

            //
            // Send a WM_DRAWITEM message to the parent.
            //
            SendMessage(hwndParent, WM_DRAWITEM, (WPARAM)dis.CtlID, (LPARAM)&dis);
        }
        break;

    case SS_LEFT:
    case SS_CENTER:
    case SS_RIGHT:
    case SS_LEFTNOWORDWRAP:

        if (GetWindowTextLength(hwnd)) 
        {
            UINT dstFlags;

            dstFlags = DST_COMPLEX;

            if (!IsWindowEnabled(hwnd)) 
            {
                dstFlags |= DSS_DISABLED;
            }

            DrawState(hdc, GetSysColorBrush(COLOR_WINDOWTEXT),
                (DRAWSTATEPROC)Static_DrawStateCB,(LPARAM)pstat, (WPARAM)TRUE,
                rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
                dstFlags);
        }
        break;

    case SS_SIMPLE: 
        {
            LPWSTR pszText = NULL;
            INT    cchText;

            //
            // The "Simple" bType assumes everything, including the following:
            // 1. The Text exists and fits on one line.
            // 2. The Static item is always enabled.
            // 3. The Static item is never changed to be a shorter string.
            // 4. The Parent never responds to the CTLCOLOR message
            //
            cchText = GetWindowTextLength(hwnd);
            if (cchText > 0) 
            {
                pszText = (LPWSTR)_alloca((cchText + 1) * sizeof(WCHAR));
                cchText = GetWindowText(hwnd, pszText, cchText + 1);
            }
            else
            {
                pszText = TEXT("");
                cchText = 0;
            }

            if (pszText)
            {
                if (ulStyle & SS_NOPREFIX && !pstat->hTheme) 
                {
                    ExtTextOut(hdc, rc.left, rc.top, ETO_OPAQUE | ETO_CLIPPED, &rc, pszText, cchText, 0L);
                } 
                else 
                {
                    //
                    // Use OPAQUE for speed.
                    //
                    DWORD dwFlags;
                    if (TESTFLAG(GET_EXSTYLE(pstat), WS_EXP_UIACCELHIDDEN))
                    {
                        dwFlags = DT_HIDEPREFIX;
                    } 
                    else if (pstat->fPaintKbdCuesOnly) 
                    {
                        dwFlags = DT_PREFIXONLY;
                    } 
                    else if (ulStyle & SS_NOPREFIX)
                    {
                        dwFlags = DT_NOPREFIX;
                    }
                    else
                    {
                        dwFlags = 0;
                    }

                    if (!pstat->hTheme)
                    {
                        TextOut(hdc, rc.left, rc.top, pszText, cchText);
                    }
                    else
                    {
                        DrawThemeText(pstat->hTheme, hdc, 0, 0, pszText, cchText, dwFlags, 0, &rc);
                    }
                }
            }
        }

        break;

    case SS_BLACKFRAME:
        cmd = (COLOR_3DDKSHADOW << 3);
        goto StatFrame;

    case SS_GRAYFRAME:
        cmd = (COLOR_3DSHADOW << 3);
        goto StatFrame;

    case SS_WHITEFRAME:
        cmd = (COLOR_3DHILIGHT << 3);
StatFrame:
        DrawFrame(hdc, &rc, 1, cmd);
        break;

    case SS_BLACKRECT:
        hbrControl = GetSysColorBrush(COLOR_3DDKSHADOW);
        goto StatRect;

    case SS_GRAYRECT:
        hbrControl = GetSysColorBrush(COLOR_3DSHADOW);
        goto StatRect;

    case SS_WHITERECT:
        hbrControl = GetSysColorBrush(COLOR_3DHILIGHT);
StatRect:
        FillRect(hdc, &rc, hbrControl);
        break;

    case SS_ETCHEDFRAME:
        DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RECT);
        break;
    }

    if (hfontOld) 
    {
        SelectObject(hdc, hfontOld);
    }

    if (ulExStyle & WS_EX_RTLREADING) 
    {
        SetTextAlign(hdc, oldAlign);
    }
}


//---------------------------------------------------------------------------//
void Static_Repaint(PSTAT pstat)
{
    HWND hwnd = pstat->hwnd;

    if (IsWindowVisible(hwnd)) 
    {
        HDC hdc;

        if (hdc = GetDC(hwnd)) 
        {
            Static_Paint(pstat, hdc, TRUE);
            ReleaseDC(hwnd, hdc);
        }
    }
}



//---------------------------------------------------------------------------//
//
// Static_NotifyParent()
// 
// Sends WM_COMMAND notification messages.
//
LRESULT Static_NotifyParent(HWND hwnd, HWND hwndParent, int  nCode)
{
    LRESULT lret;

    if (!hwndParent) 
    {
        hwndParent = GetParent(hwnd);
    }

    lret = SendMessage(hwndParent, WM_COMMAND,
                       MAKELONG(GetDlgCtrlID(hwnd), nCode), (LPARAM)hwnd);

    return lret;
}


//---------------------------------------------------------------------------//
//
// Static_AniIconStep
//
// Advances to the next step in an animaged icon.
//
VOID Static_AniIconStep(PSTAT pstat)
{
    DWORD dwRate;
    HWND hwnd = pstat->hwnd;

    dwRate = 0;

    //
    // Stop the timer for the next animation step.
    //
    KillTimer(hwnd, IDSYS_STANIMATE);

    if (++(pstat->iicur) >= pstat->cicur) 
    {
        pstat->iicur = 0;
    }

    //
    // Perhaps we can do something like shell\cpl\main\mouseptr.c
    // here, and make GetCursorFrameInfo obsolete.
    //
    GetCursorFrameInfo(pstat->hImage, NULL, pstat->iicur, &dwRate, &pstat->cicur);
    dwRate = max(200, dwRate * 100 / 6);

    InvalidateRect(hwnd, NULL, FALSE);
    UpdateWindow(hwnd);

    SetTimer(hwnd, IDSYS_STANIMATE, dwRate, NULL);
}


//---------------------------------------------------------------------------//
//
// Static_WndProc
//
// WndProc for Static controls
//
LRESULT APIENTRY Static_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PSTAT   pstat;
    LRESULT lReturn = FALSE;

    //
    // Get the instance data for this static control
    //
    pstat = Static_GetPtr(hwnd);
    if (!pstat && uMsg != WM_NCCREATE)
    {
        goto CallDWP;
    }

    switch (uMsg) 
    {
    case STM_GETICON:
        wParam = IMAGE_ICON;

    case STM_GETIMAGE:
        if (IsValidImage(wParam, (GET_STYLE(pstat) & SS_TYPEMASK), IMAGE_STMMAX)) 
        {
            return (LRESULT)pstat->hImage;
        }
        break;

    case STM_SETICON:
        lParam = (LPARAM)wParam;
        wParam = IMAGE_ICON;

    case STM_SETIMAGE:
        if (IsValidImage(wParam, (GET_STYLE(pstat) & SS_TYPEMASK), IMAGE_STMMAX)) 
        {
            return (LRESULT)Static_SetImage(pstat, (HANDLE)lParam, FALSE);
        }
        break;

    case WM_ERASEBKGND:

        //
        // The control will be erased in Static_Paint().
        //
        return TRUE;

    case WM_PRINTCLIENT:
        Static_Paint(pstat, (HDC)wParam, FALSE);
        break;

    case WM_PAINT:
    {
        HDC         hdc;
        PAINTSTRUCT ps;

        hdc = (HDC)wParam;
        if (hdc == NULL) 
        {
            hdc = BeginPaint(hwnd, &ps);
        }

        if (IsWindowVisible(hwnd)) 
        {
            Static_Paint(pstat, hdc, !wParam);
        }

        //
        // If hwnd was destroyed, BeginPaint was automatically undone.
        //
        if (!wParam) 
        {
            EndPaint(hwnd, &ps);
        }

        break;
    }

    case WM_CREATE:
    {
        BYTE bType = (BYTE)(GET_STYLE(pstat) & SS_TYPEMASK);
        pstat->hTheme = OpenThemeData(pstat->hwnd, L"Static");
        EnableThemeDialogTexture(GetParent(pstat->hwnd), ETDT_ENABLE);

        if ((rgstk[bType] & STK_TYPE) == STK_IMAGE) 
        {
            LPTSTR  lpszName;

            lpszName = (LPTSTR)(((LPCREATESTRUCT)lParam)->lpszName);

            //
            // Load the image
            //
            Static_LoadImage(pstat, lpszName);
        } 
        else if (bType == SS_ETCHEDHORZ || bType == SS_ETCHEDVERT) 
        {
            //
            // Resize static window to fit edge.  Horizontal dudes
            // make bottom one edge from top, vertical dudes make
            // right edge one edge from left.
            //
            RECT    rcClient;

            GetClientRect(hwnd, &rcClient);
            if (bType == SS_ETCHEDHORZ)
            {
                rcClient.bottom = GetSystemMetrics(SM_CYEDGE);
            }
            else
            {
                rcClient.right = GetSystemMetrics(SM_CXEDGE);
            }

            SetWindowPos(hwnd, HWND_TOP, 0, 0, rcClient.right,
                rcClient.bottom, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }

        break;
    }

    case WM_DESTROY:
    {
        BYTE bType = (BYTE)(GET_STYLE(pstat) & SS_TYPEMASK);

        if (((rgstk[bType] & STK_TYPE) == STK_IMAGE) &&
            (pstat->hImage != NULL)                  &&
            (pstat->fDeleteIt)) 
        {

            if (bType == SS_BITMAP) 
            {
                DeleteObject(pstat->hImage);
            } 
            else if (bType == SS_ICON) 
            {
                if (pstat->cicur > 1) 
                {
                    //  Kill the animated cursor timer
                    KillTimer(hwnd, IDSYS_STANIMATE);
                }
                DestroyIcon((HICON)(pstat->hImage));
            }
        }

        break;

    }
    case WM_NCCREATE:

        //
        // Allocate the static instance stucture
        //
        pstat = (PSTAT)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(STAT));
        if (pstat)
        {
            DWORD dwStyle;
            DWORD dwExStyle;
            BYTE  bType;
        
            //
            // Success... store the instance pointer.
            //
            TraceMsg(TF_STANDARD, "STATIC: Setting static instance pointer.");
            Static_SetPtr(hwnd, pstat);

            pstat->hwnd = hwnd;
            pstat->pww  = (PWW)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);

            dwStyle = GET_STYLE(pstat);
            dwExStyle = GET_EXSTYLE(pstat);
            bType = (BYTE)(dwStyle & SS_TYPEMASK);

            if ((dwExStyle & WS_EX_RIGHT) != 0) 
            {
                AlterWindowStyle(hwnd, SS_TYPEMASK, SS_RIGHT);
            }

            if (dwStyle & SS_SUNKEN ||
                ((bType == LOBYTE(SS_ETCHEDHORZ)) || (bType == LOBYTE(SS_ETCHEDVERT)))) 
            {
                dwExStyle |= WS_EX_STATICEDGE;
                SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyle);
            }

            
            goto CallDWP;
        }
        else
        {
            //
            // Failed... return FALSE.
            //
            // From a WM_NCCREATE msg, this will cause the
            // CreateWindow call to fail.
            //
            TraceMsg(TF_STANDARD, "STATIC: Unable to allocate static instance structure.");
            lReturn = FALSE;
        }

        break;

    case WM_NCDESTROY:
        if ( pstat->hTheme )
        {
            CloseThemeData(pstat->hTheme);
        }

        UserLocalFree(pstat);
        TraceMsg(TF_STANDARD, "STATIC: Clearing static instance pointer.");
        Static_SetPtr(hwnd, NULL);

        break;
    
    case WM_NCHITTEST:
        return (GET_STYLE(pstat) &  SS_NOTIFY) ? HTCLIENT : HTTRANSPARENT;

    case WM_LBUTTONDOWN:
    case WM_NCLBUTTONDOWN:
        if (GET_STYLE(pstat) & SS_NOTIFY) 
        {
            //
            // It is acceptable for an app to destroy a static label
            // in response to a STN_CLICKED notification.
            //
            Static_NotifyParent(hwnd, NULL, STN_CLICKED);
        }
        break;

    case WM_LBUTTONDBLCLK:
    case WM_NCLBUTTONDBLCLK:
        if (GET_STYLE(pstat) & SS_NOTIFY) 
        {
            //
            // It is acceptable for an app to destroy a static label in
            // response to a STN_DBLCLK notification.
            //
            Static_NotifyParent(hwnd, NULL, STN_DBLCLK);
        }
        break;

    case WM_SETTEXT:
    {
        BYTE bType = (BYTE)(GET_STYLE(pstat) & SS_TYPEMASK);

        //
        // No more hack to set icon/bitmap via WM_SETTEXT!
        //
        if (rgstk[bType] & STK_USETEXT) 
        {
            if (DefWindowProc(hwnd, WM_SETTEXT, wParam, lParam)) 
            {
                Static_Repaint(pstat);
                return TRUE;
            }
        }
        break;

    }
    case WM_ENABLE:
        Static_Repaint(pstat);
        if (GET_STYLE(pstat) & SS_NOTIFY) 
        {
            Static_NotifyParent(hwnd, NULL, (wParam ? STN_ENABLE : STN_DISABLE));
        }
        break;

    case WM_GETDLGCODE:
        return (LONG)DLGC_STATIC;

    case WM_SETFONT:
    {
        BYTE bType = (BYTE)(GET_STYLE(pstat) & SS_TYPEMASK);

        //
        // wParam - handle to the font
        // lParam - if true, redraw else don't
        //
        if (rgstk[bType] & STK_USEFONT) 
        {
            pstat->hFont = (HANDLE)wParam;

            if (lParam && IsWindowVisible(hwnd)) 
            {
                InvalidateRect(hwnd, NULL, TRUE);
                UpdateWindow(hwnd);
            }
        }
        break;

    }
    case WM_GETFONT:
    {
        BYTE bType = (BYTE)(GET_STYLE(pstat) & SS_TYPEMASK);

        if (rgstk[bType] & STK_USEFONT) 
        {
            return (LRESULT)pstat->hFont;
        }

        break;

    }
    case WM_TIMER:
        if (wParam == IDSYS_STANIMATE) 
        {
            Static_AniIconStep(pstat);
        }
        break;

    case WM_UPDATEUISTATE:
        {
            DefWindowProc(hwnd, uMsg, wParam, lParam);

            if (HIWORD(wParam) & UISF_HIDEACCEL) 
            {
                BYTE bType = (BYTE)(GET_STYLE(pstat) & SS_TYPEMASK);

                if (ISSSTEXTOROD(bType)) 
                {
                    pstat->fPaintKbdCuesOnly = TRUE;
                    Static_Repaint(pstat);
                    pstat->fPaintKbdCuesOnly = FALSE;
                }
            }
        }
        break;

    case WM_GETOBJECT:

        if(lParam == OBJID_QUERYCLASSNAMEIDX)
        {
            lReturn = MSAA_CLASSNAMEIDX_STATIC;
        }
        else
        {
            lReturn = FALSE;
        }

        break;

    case WM_THEMECHANGED:

        if ( pstat->hTheme )
        {
            CloseThemeData(pstat->hTheme);
        }

        pstat->hTheme = OpenThemeData(pstat->hwnd, L"Static");

        InvalidateRect(pstat->hwnd, NULL, TRUE);

        lReturn = TRUE;

        break;

    default:

CallDWP:
        lReturn = DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\tab.c ===
#include "ctlspriv.h"
#include "tab.h"

#define BMOVECURSORONCLICK  FALSE
#define BMOVECURSORONDRAG   TRUE

BOOL Tab_OnGetItemRect(PTC ptc, int iItem, LPRECT lprc);

BOOL Tab_Init(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = Tab_WndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = c_szTabControlClass;
    wc.hbrBackground   = (HBRUSH)(COLOR_3DFACE + 1);
    wc.style           = CS_GLOBALCLASS | CS_DBLCLKS | CS_HREDRAW |  CS_VREDRAW;
    wc.cbWndExtra      = sizeof(PTC);
    wc.cbClsExtra      = 0;

    if (!RegisterClass(&wc) && !GetClassInfo(hinst, c_szTabControlClass, &wc))
        return FALSE;

    return TRUE;
}

void Tab_VFlipRect(PTC ptc, LPRECT prc);
void FlipRect(LPRECT prc);
void VertInvalidateRect(HWND hwnd, LPRECT qrc, BOOL b, BOOL fVert);

// Shared generic theme-aware code (exists in trackbar.c)
void VertDrawEdge(HDC hdc, LPRECT qrc, UINT edgeType, UINT grfFlags,
                             BOOL fVert, HTHEME hTheme, int iPartId, int iStateId);
void VertPatBlt(HDC hdc1, int x1, int y1, int w, int h,
                           DWORD rop, BOOL fVert, HTHEME hTheme, int iPartId, int iStateId);

LRESULT TabDragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp)
{
    PTC ptc = (PTC)GetWindowInt(hwnd, 0);
    LRESULT lres;

    switch (code)
    {
    case DPX_ENTER:
    case DPX_LEAVE:
        ptc->iDragTab = -1;
        ptc->dwDragDelay = 0;
        lres = 1;
        break;

    case DPX_DRAGHIT:
        if (lp)
        {
            BOOL fResetDelay = TRUE;
            int iTab;
            POINT pt;
            pt.x = ((POINTL *)lp)->x;
            pt.y = ((POINTL *)lp)->y;


            MapWindowPoints(NULL, ptc->ci.hwnd, &pt, 1);
            iTab = Tab_OnHitTest(ptc, pt.x, pt.y, NULL);

            if ((iTab != ptc->iSel))
            {
                if (iTab >= 0)
                {
                    DWORD dwHitTime = GetTickCount();

                    if (ptc->dwDragDelay == 0 ||
                        dwHitTime - ptc->dwDragDelay >= TAB_DRAGDELAY)
                    {
                        if (ptc->dwDragDelay)
                        {
                            ChangeSel(ptc, iTab, TRUE, BMOVECURSORONDRAG);

                            // present no target if validation failed
                            // this will prevent accidental drops
                            if (ptc->iSel != iTab)
                                iTab = -1;
                        }
                        else
                        {
                            ptc->dwDragDelay = dwHitTime | 1; // make sure value is not zero
                            fResetDelay = FALSE;
                        }
                    }
                    else if (iTab == ptc->iDragTab)
                        fResetDelay = FALSE;
                }

                ptc->iDragTab = iTab;
            }

            if (fResetDelay)
                ptc->dwDragDelay = 0;

            lres = (LRESULT)iTab;
        }
        else
            lres = -1;
        break;

    case DPX_GETOBJECT:
        lres = (LRESULT)GetItemObject(&ptc->ci, TCN_GETOBJECT, &IID_IDropTarget, (LPNMOBJECTNOTIFY)lp);
        break;

    case DPX_SELECT:
        if (((int)wp) >= 0)
        {
            SendMessage(ptc->ci.hwnd, TCM_HIGHLIGHTITEM, wp,
                MAKELPARAM((lp != DROPEFFECT_NONE), 0));
        }
        lres = 0;
        break;

    default:
        lres = -1;
        break;
    }

    return lres;
}


void VertSmoothScrollWindow(HWND hwnd, int dx, int dy, LPCRECT lprcSrc, LPCRECT lprcClip, HRGN hrgn, LPRECT lprcUpdate, UINT fuScroll, BOOL fVert, UINT uScrollMin)
{
    RECT rcSrc;
    RECT rcClip;
    SMOOTHSCROLLINFO si;

    if (fVert) 
    {
        SWAP(dx, dy, int);
        
        if (lprcSrc) 
        {
            rcSrc = *lprcSrc;
            lprcSrc = &rcSrc;
            FlipRect(&rcSrc);
        }

        if (lprcClip) 
        {
            rcClip = *lprcClip;
            lprcClip = &rcClip;
            FlipRect(&rcClip);
        }
        
    }

    si.cbSize=sizeof(si);
    si.fMask= SSIF_MINSCROLL;
    si.hwnd= hwnd;
    si.dx=dx;
    si.dy=dy;
    si.lprcSrc=lprcSrc;
    si.lprcClip=lprcClip;
    si.hrgnUpdate=hrgn;
    si.lprcUpdate=lprcUpdate;
    si.fuScroll=fuScroll;
    si.uMaxScrollTime=SSI_DEFAULT;
    si.cxMinScroll=uScrollMin;
    si.cyMinScroll= uScrollMin;
    si.pfnScrollProc = NULL;
    SmoothScrollWindow(&si);
    
    if (fVert) 
    {
        
        if (lprcUpdate)
            FlipRect(lprcUpdate);
    }
}

void Tab_SmoothScrollWindow(PTC ptc, int dx, int dy, LPRECT lprcSrc, LPRECT lprcClip, 
                            HRGN hrgn, LPRECT lprcUpdate, UINT fuScroll, UINT uScrollMin) 
{
    RECT rcSrc;
    RECT rcClip;
    if (Tab_Bottom(ptc))
    {
        dy *= -1;
        if (lprcSrc) 
        {
            rcSrc = *lprcSrc;
            lprcSrc = &rcSrc;
            Tab_VFlipRect(ptc, lprcSrc);
        }
        
        if (lprcClip)
        {
            rcClip = *lprcClip;
            lprcClip = &rcClip;
            Tab_VFlipRect(ptc, lprcClip);
        }
        
    }
    
    VertSmoothScrollWindow(ptc->ci.hwnd, dx, dy, lprcSrc, lprcClip, hrgn, lprcUpdate, fuScroll, Tab_Vertical(ptc), uScrollMin);

    if (lprcUpdate)
    {
        Tab_VFlipRect(ptc, lprcClip);
    }

}


void Tab_InvalidateRect(PTC ptc, LPRECT prc, BOOL b) 
{
    RECT rc = *prc;
    Tab_VFlipRect(ptc, &rc);
    VertInvalidateRect((ptc)->ci.hwnd, &rc, b, Tab_Vertical(ptc));
}

// Tab_DrawEdge is theme-aware
void Tab_DrawEdge(HDC hdc, LPRECT prc, UINT uType, UINT uFlags, PTC ptc) 
{
    RECT rc = *prc;
    Tab_VFlipRect(ptc, &rc);
    if (Tab_Bottom(ptc)) 
    {
        
        
        UINT uNewFlags;

        if (uFlags & BF_DIAGONAL) 
        {
            uNewFlags = uFlags & ~(BF_RIGHT | BF_LEFT);
            if (uFlags & BF_LEFT)
                uNewFlags |= BF_RIGHT;
            if (uFlags & BF_RIGHT) 
                uNewFlags |= BF_LEFT;
        }
        else 
        {

            uNewFlags = uFlags & ~(BF_TOP | BF_BOTTOM);
            if (uFlags & BF_TOP)
                uNewFlags |= BF_BOTTOM;
            if (uFlags & BF_BOTTOM) 
                uNewFlags |= BF_TOP;
        }
        uFlags = uNewFlags;
    }

    VertDrawEdge(hdc, &rc, uType, uFlags, Tab_Vertical(ptc), ptc->hTheme, ptc->iPartId, ptc->iStateId);
}

// Tab_PatBlt is theme aware        
void Tab_PatBlt(HDC hdc, int x1, int y1, int w, int h, UINT rop, PTC ptc) 
{
    RECT rc;
    rc.top = y1;
    rc.left = x1;
    rc.right = x1+w;
    rc.bottom = y1+h;
    Tab_VFlipRect(ptc, &rc);

    VertPatBlt(hdc, rc.left, rc.top, RECTWIDTH(rc) , RECTHEIGHT(rc), rop, Tab_Vertical(ptc), ptc->hTheme, ptc->iPartId, ptc->iStateId);
}
        

void NormalizeRect(LPRECT prc)
{
    if (prc->right < prc->left) 
    {
        SWAP(prc->right, prc->left, int);
    }
    
    if (prc->bottom < prc->top) 
    {
        SWAP(prc->bottom, prc->top, int);
    }
}

void VFlipRect(LPRECT prcClient, LPRECT prc)
{
    int iTemp = prc->bottom;
    
    prc->bottom = prcClient->bottom - (prc->top - prcClient->top);
    prc->top = prcClient->bottom - (iTemp - prcClient->top);
}

// diagonal flip.
void Tab_DFlipRect(PTC ptc, LPRECT prc)
{
    if (Tab_Vertical(ptc)) 
    {
        FlipRect(prc);
    }
}

// vertical support is done much like the trackbar control.  we're going
// to flip the coordinate system.  this means that tabs will be added from top down.
void Tab_GetClientRect(PTC ptc, LPRECT prc)
{
    GetClientRect(ptc->ci.hwnd, prc);
    Tab_DFlipRect(ptc, prc);
}

// vertical flip
void Tab_VFlipRect(PTC ptc, LPRECT prc)
{
    if (Tab_Bottom(ptc)) 
    {
        RECT rcClient;
        Tab_GetClientRect(ptc, &rcClient);
        VFlipRect(&rcClient, prc);

    }
}

void Tab_VDFlipRect(PTC ptc, LPRECT prc)
{
    Tab_VFlipRect(ptc, prc);
    Tab_DFlipRect(ptc, prc);
}

// real coordinates to tab coordinates
void Tab_DVFlipRect(PTC ptc, LPRECT prc)
{
    Tab_DFlipRect(ptc, prc);
    Tab_VFlipRect(ptc, prc);
}


#define Tab_ImageList_GetIconSize(ptc, pcx, pcy) VertImageList_GetIconSize((ptc)->himl, pcx, pcy, Tab_Vertical(ptc))
void VertImageList_GetIconSize(HIMAGELIST himl, LPINT pcx, LPINT pcy, BOOL fVert)
{
    ImageList_GetIconSize(himl, pcx, pcy);
    if (fVert)
    {
                
        // if we're in vertical mode, the width is really the height.
        // we won't draw the bitmaps sideways.  we'll rely on people
        // authoring them that way.
        int iTemp = *pcy;
        *pcy = *pcx;
        *pcx = iTemp;
        
    }
}

void VertImageList_Draw(HIMAGELIST himl, int iIndex, HDC hdc, int x, int y, UINT uFlags, BOOL fVert)
{
    if (fVert) {
        int iTemp;

        iTemp = y;
        y = x;
        x = iTemp;

        // since we draw from the upper left, flipping the x/y axis means we still draw from the upper left.
        // all we need to do is swap x and y.  we don't need to offset
    }
        
    ImageList_Draw( himl,  iIndex,  hdc,  x,  y,  uFlags);
}
void Tab_ImageList_Draw(PTC ptc, int iImage, HDC hdc, int x, int y, UINT uFlags) 
{
    RECT rc;
    int cxImage, cyImage;
    
    Tab_ImageList_GetIconSize(ptc, &cxImage, &cyImage);

    if (Tab_Bottom(ptc)) {
        y += cyImage;
    }
    rc.top = rc.bottom = y;
    Tab_VFlipRect(ptc, &rc);
    y = rc.top;
    
    VertImageList_Draw((ptc)->himl, iImage, hdc, x, y, uFlags, Tab_Vertical(ptc));
}

// Tab_DrawText is theme aware (RENDERS)
void Tab_DrawText(HDC hdc, LPTSTR lpsz, int nCount, LPRECT lprc, UINT uFormat, PTC ptc)
{
    RECT rcTemp = *lprc;
    Tab_VDFlipRect(ptc, &rcTemp);
    if (Tab_Vertical(ptc))
        uFormat |= DT_BOTTOM;
   
    if (CCGetUIState(&(ptc->ci)) & UISF_HIDEACCEL)
    {
        uFormat |= DT_HIDEPREFIX;
    }

    // Use theme text renderer if possible
    if (ptc->hTheme)
    {
        DrawThemeText(ptc->hTheme, hdc, ptc->iPartId, ptc->iStateId, lpsz, nCount, uFormat, nCount, &rcTemp);
    }
    else
    {
        DrawText(hdc, lpsz, nCount, &rcTemp, uFormat);
    }
}

// Tab_DrawTextEx is theme aware (RENDERS)
void Tab_DrawTextEx(HDC hdc, LPTSTR lpsz, int nCount, LPRECT lprc, UINT uFormat, LPDRAWTEXTPARAMS lpParams, PTC ptc)
{
    RECT rcTemp = *lprc;
    Tab_VDFlipRect(ptc, &rcTemp);
    if (Tab_Vertical(ptc))
        uFormat |= DT_BOTTOM;
   
    if (CCGetUIState(&(ptc->ci)) & UISF_HIDEACCEL)
    {
        uFormat |= DT_HIDEPREFIX;
    }

    // Use theme text renderer if possible
    if (ptc->hTheme)
    {
        DrawThemeText(ptc->hTheme, hdc, ptc->iPartId, ptc->iStateId, lpsz, nCount, uFormat | DT_CENTER, nCount, &rcTemp);
    }
    else
    {
        DrawTextEx(hdc, lpsz, nCount, &rcTemp, uFormat, lpParams);
    }
}

// Tab_ExtTextOut is theme aware (RENDERS)
void Tab_ExtTextOut(HDC hdc, int x, int y, UINT uFlags, LPRECT prc, 
                                LPTSTR lpsz, UINT cch, CONST INT *pdw, PTC ptc)
{
    RECT rcTemp;

    rcTemp.left = rcTemp.right = x;
    if (Tab_Bottom(ptc) && !Tab_Vertical(ptc)) {

        // first we need to move the top point because if we're drawing on Tab_Bottom, then
        // text won't extend down from y.
        y += ptc->tmHeight;
    }
    rcTemp.top = rcTemp.bottom = y;
    Tab_VDFlipRect(ptc, &rcTemp);
    x = rcTemp.left;
    y = rcTemp.bottom;
    
    rcTemp = *prc;
    Tab_VDFlipRect(ptc, &rcTemp);

    // Use theme text renderer if possible
    if (ptc->hTheme)
    {
        if (lpsz)
        {
            UINT uDTFlags = 0;
            RECT rc = { x, y, rcTemp.right, rcTemp.bottom };

            if (!(uFlags & ETO_CLIPPED))
                uDTFlags |= DT_NOCLIP;
            if (uFlags & ETO_RTLREADING)
                uDTFlags |= DT_RTLREADING;

            // Vertical text not supported
            DrawThemeText(ptc->hTheme, hdc, ptc->iPartId, ptc->iStateId, lpsz, cch, uDTFlags, 0, &rc);
        }
    }
    else
    {
        ExtTextOut(hdc, x, y, uFlags, &rcTemp, lpsz, cch, pdw);
    }
}

void VertDrawFocusRect(HDC hdc, LPRECT lprc, BOOL fVert)
{
    
    RECT rc;
    
    rc = *lprc;
    if (fVert)
        FlipRect(&rc);
    
    DrawFocusRect(hdc, &rc);
}

// Tab_DrawFocusRect is theme aware
void Tab_DrawFocusRect(HDC hdc, LPRECT lprc, PTC ptc) 
{
    RECT rc = *lprc;

    Tab_VFlipRect(ptc, &rc);
    VertDrawFocusRect(hdc, &rc, Tab_Vertical(ptc));
}


void Tab_Scroll(PTC ptc, int dx, int iNewFirstIndex)
{
    int i;
    int iMax;
    RECT rc;
    LPTABITEM pitem = NULL;

    // don't stomp on edge unless first item is selected
    rc.left = g_cxEdge;
    rc.right = ptc->cxTabs;   // Dont scroll beyond tabs.
    rc.top = 0;
    rc.bottom = ptc->cyTabs + 2 * g_cyEdge;  // Only scroll in the tab area
    
    // See if we can scroll the window...
    // DebugMsg(DM_TRACE, TEXT("Tab_Scroll dx=%d, iNew=%d\n\r"), dx, iNewFirstIndex);
    Tab_SmoothScrollWindow(ptc, dx, 0, NULL, &rc,
            NULL, NULL, SW_INVALIDATE | SW_ERASE, SSI_DEFAULT);

    // We also need to update the item rectangles and also
    // update the internal variables...
    iMax = Tab_Count(ptc) - 1;
    for (i = iMax; i >= 0; i--)
    {
        pitem = Tab_FastGetItemPtr(ptc, i);
        OffsetRect(&pitem->rc, dx, 0);
    }

    // If the previously last visible item is not fully visible
    // now, we need to invalidate it also.
    //
    if (ptc->iLastVisible > iMax)
        ptc->iLastVisible = iMax;

    for (i = ptc->iLastVisible; i>= 0; i--)
    {
        pitem = Tab_GetItemPtr(ptc, i);
        if (pitem) {
            if (pitem->rc.right <= ptc->cxTabs)
                break;
            Tab_InvalidateItem(ptc, ptc->iLastVisible, TRUE);
        }
    }

    if ((i == ptc->iLastVisible) && pitem)
    {
        // The last previously visible item is still fully visible, so
        // we need to invalidate to the right of it as there may have been
        // room for a partial item before, that will now need to be drawn.
        rc.left = pitem->rc.right;
        Tab_InvalidateRect(ptc, &rc, TRUE);
    }

    ptc->iFirstVisible = iNewFirstIndex;

    if (ptc->hwndArrows)
        SendMessage(ptc->hwndArrows, UDM_SETPOS, 0, MAKELPARAM(iNewFirstIndex, 0));

    UpdateToolTipRects(ptc);
}


void Tab_OnHScroll(PTC ptc, HWND hwndCtl, UINT code, int pos)
{
    // Now process the Scroll messages
    if (code == SB_THUMBPOSITION)
    {
        //
        // For now lets simply try to set that item as the first one
        //
        {
            // If we got here we need to scroll
            LPTABITEM pitem = Tab_GetItemPtr(ptc, pos);
            int dx = 0;

            if (pitem)
                dx = -pitem->rc.left + g_cxEdge;

            if (dx || !pitem) {
                Tab_Scroll(ptc, dx, pos);
                UpdateWindow(ptc->ci.hwnd);
            }
        }
    }
}

void Tab_OnSetRedraw(PTC ptc, BOOL fRedraw)
{
    if (fRedraw) {
        ptc->flags |= TCF_REDRAW;
        RedrawAll(ptc, RDW_INVALIDATE);
    } else {
        ptc->flags &= ~TCF_REDRAW;
    }
}

// Tab_OnSetFont will always cache the font (even if themes are on, in which case this font will be
// ignored). This is because dialog managers will set the tabs font on creation. If themes are
// turned off and this font was never set, the default system font will be incorrectly used.
void Tab_OnSetFont(PTC ptc, HFONT hfont, BOOL fRedraw)
{
    ASSERT(ptc);

    if (!ptc->hfontLabel || hfont != ptc->hfontLabel)
    {
        if (ptc->flags & TCF_FONTCREATED) 
        {
            DeleteObject(ptc->hfontLabel);
            ptc->flags &= ~TCF_FONTCREATED;
            ptc->hfontLabel = NULL;
        }
    
        if (!hfont) 
        {
            // set back to system font
            ptc->hfontLabel = g_hfontSystem;
        } 
        else 
        {
            ptc->flags |= TCF_FONTSET;
            ptc->hfontLabel = hfont;
            ptc->ci.uiCodePage = GetCodePageForFont(hfont);
        }
        ptc->cxItem = ptc->cyTabs = RECOMPUTE;
    

        if (Tab_Vertical(ptc)) 
        {
            // make sure that the font is drawn vertically
            LOGFONT lf;
            GetObject(ptc->hfontLabel, sizeof(lf), &lf);
        
            if (Tab_Bottom(ptc)) 
            {
                lf.lfEscapement = 2700;
            } 
            else 
            {
                lf.lfEscapement = 900; // 90 degrees
            }

            lf.lfOutPrecision = OUT_TT_ONLY_PRECIS;
        
            ptc->hfontLabel = CreateFontIndirect(&lf);
            if (ptc->hfontLabel != NULL)
                ptc->flags |= TCF_FONTCREATED;
        }

        if (ptc->hfontLabel != NULL)
            RedrawAll(ptc, RDW_INVALIDATE | RDW_ERASE);
    }
}


BOOL Tab_OnCreate(PTC ptc)
{
    HDC hdc;
    DWORD exStyle = 0;

    ptc->hdpa = DPA_Create(4);
    if (!ptc->hdpa)
        return FALSE;

    // make sure we don't have invalid bits set
    if (!Tab_FixedWidth(ptc)) 
    {
        ptc->ci.style &= ~(TCS_FORCEICONLEFT | TCS_FORCELABELLEFT);
    }
    
    if (Tab_Vertical(ptc)) 
    {
        ptc->ci.style |= TCS_MULTILINE;
        //ptc->ci.style &= ~TCS_BUTTONS;
    }
    
    if (Tab_ScrollOpposite(ptc))
    {
        ptc->ci.style |= TCS_MULTILINE;
        ptc->ci.style &= ~TCS_BUTTONS;
    }

    if (Tab_FlatButtons(ptc)) 
    {
        ptc->dwStyleEx |= TCS_EX_FLATSEPARATORS;
    }

    // Initialize themes. No themes for owner drawn or button-style tab controls
    ptc->hTheme = (!Tab_OwnerDraw(ptc) && !Tab_DrawButtons(ptc)) ? OpenThemeData(ptc->ci.hwnd, L"Tab") : NULL;

    // Active hot state if themes are in use
    if (ptc->hTheme)
    {
        ptc->ci.style |= TCS_HOTTRACK;
    }

    // make us always clip siblings
    SetWindowLong(ptc->ci.hwnd, GWL_STYLE, WS_CLIPSIBLINGS | ptc->ci.style);

    ptc->flags = TCF_REDRAW;        // enable redraw
    ptc->cbExtra = sizeof(LPARAM);  // default extra size
    ptc->iSel = -1;
    ptc->iHot = -1;
    ptc->cxItem = ptc->cyTabs = RECOMPUTE;
    ptc->cxPad = g_cxEdge * 3;
    ptc->cyPad = (g_cyEdge * 3/2);
    ptc->iFirstVisible = 0;
    ptc->hwndArrows = NULL;
    ptc->iLastRow = -1;
    ptc->iNewSel = -1;
    ptc->iLastTopRow = -1;

    hdc = GetDC(NULL);
    ptc->iTabWidth = GetDeviceCaps(hdc, LOGPIXELSX);
    ReleaseDC(NULL, hdc);

    InitDitherBrush();

    if (ptc->ci.style & TCS_TOOLTIPS) 
    {
        TOOLINFO ti;
        // don't bother setting the rect because we'll do it below
        // in FlushToolTipsMgr;
        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_IDISHWND;
        ti.hwnd = ptc->ci.hwnd;
        ti.uId = (UINT_PTR)ptc->ci.hwnd;
        ti.lpszText = 0;

        ptc->hwndToolTips = CreateWindowEx(exStyle, c_szSToolTipsClass, TEXT(""),
                                              WS_POPUP,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              ptc->ci.hwnd, NULL, HINST_THISDLL,
                                              NULL);
        if (ptc->hwndToolTips)
            SendMessage(ptc->hwndToolTips, TTM_ADDTOOL, 0,
                        (LPARAM)(LPTOOLINFO)&ti);
        else
            ptc->ci.style &= ~(TCS_TOOLTIPS);
    }

    if (g_fDBCSInputEnabled)
        ptc->hPrevImc = ImmAssociateContext(ptc->ci.hwnd, 0L);

    // Setup theme state for methods called that render themes before first paint, setup state (TAB/BUTTON)
    if (ptc->hTheme)
    {
        ptc->iPartId = TABP_TABITEM;
        ptc->iStateId = TIS_NORMAL;
    }

    return TRUE;
}


void Tab_OnDestroy(PTC ptc)
{
    int i;

    // Close theme
    if (ptc->hTheme)
        CloseThemeData(ptc->hTheme);

    if (g_fDBCSInputEnabled)
        ImmAssociateContext(ptc->ci.hwnd, ptc->hPrevImc);

    if ((ptc->ci.style & TCS_TOOLTIPS) && IsWindow(ptc->hwndToolTips)) 
    {
        DestroyWindow(ptc->hwndToolTips);
    }

    for (i = 0; i < Tab_Count(ptc); i++)
        Tab_FreeItem(ptc, Tab_FastGetItemPtr(ptc, i));

    DPA_Destroy(ptc->hdpa);

    if (ptc->hDragProxy)
        DestroyDragProxy(ptc->hDragProxy);

    if (ptc->flags & TCF_FONTCREATED) {
        DeleteObject(ptc->hfontLabel);
    }
    
    if (ptc) {
        SetWindowInt(ptc->ci.hwnd, 0, 0);
        NearFree((HLOCAL)ptc);
    }

    TerminateDitherBrush();
}

// returns true if it actually moved

void PutzRowToBottom(PTC ptc, int iRowMoving)
{
    int i;
    LPTABITEM pitem;
    int dy;
    RECT rcTabs;
    

    Tab_GetClientRect(ptc, &rcTabs);
    
    if (Tab_ScrollOpposite(ptc)) {
        // in scroll mode, the iRow doesn't change.  only the rc's do.
        int yOldTop;
        int yNewTop;
        
        int iLastTopRow = ptc->iLastTopRow == -1 ? ptc->iLastRow : ptc->iLastTopRow;

        if (iRowMoving == iLastTopRow) {
            if (ptc->iLastTopRow == -1)
                ptc->iLastTopRow = iRowMoving;
            return; // already at the bottom;
        }

            
        
        // this is the height of the tab's empty area... which is the amount
        // of space a tab must move to get from the top to the bottom
        dy = rcTabs.bottom - rcTabs.top - (ptc->cyTabs * (ptc->iLastRow + 1)) - g_cyEdge;
        
        for (i = Tab_Count(ptc) - 1; i >= 0; i--) {
            pitem = Tab_FastGetItemPtr(ptc, i);
            DebugMsg(DM_TRACE, TEXT("Putzing %s %d %d %d %d"), pitem->pszText, pitem->rc.left, pitem->rc.top, pitem->rc.right, pitem->rc.bottom);
            
            // save this for scrolling below
            if (pitem->iRow == iRowMoving) {
                yNewTop = pitem->rc.bottom;
            } else if (pitem->iRow == iLastTopRow) {
                yOldTop = pitem->rc.bottom;
            }
            
            if (pitem->iRow > iRowMoving) {
                // this item should be on the bottom
                
                if (pitem->iRow <= iLastTopRow) {
                    // but it's not...
                    OffsetRect(&pitem->rc, 0, dy);
                    
                }
                
            } else {
                // this item should be on the top
                
                if (pitem->iRow > iLastTopRow) {
                    // but it's not... so move it
                    OffsetRect(&pitem->rc, 0, -dy);
                }
            }
            
            if ((pitem->iRow == iLastTopRow) && iLastTopRow > iRowMoving) {
                // in this case, we need to get the yOldTop AFTER it's moved.
                yOldTop = pitem->rc.bottom;
            }
            DebugMsg(DM_TRACE, TEXT("Putzing %s %d %d %d %d"), pitem->pszText, pitem->rc.left, pitem->rc.top, pitem->rc.right, pitem->rc.bottom);
            
        }
        
        if (ptc->iLastTopRow != -1) {
            // if it wasn't a full recalc, then we need to do some scrollwindow stuff.
            int dy;
            // first find the topmost parent
            
            dy = yOldTop - yNewTop;
            if (yNewTop > yOldTop) {
                rcTabs.top = yOldTop;
                rcTabs.bottom = yNewTop;
            } else {
                rcTabs.top = yNewTop;
                rcTabs.bottom = yOldTop;
            }
            
            Tab_SmoothScrollWindow(ptc, 0, dy, NULL, &rcTabs, NULL, NULL, SW_ERASE |SW_INVALIDATE, 1);
            InflateRect(&rcTabs, g_cxEdge, g_cyEdge);
            Tab_InvalidateRect(ptc, &rcTabs, FALSE);
        }

        ptc->iLastTopRow = iRowMoving;
        
    } else {
        
        if (iRowMoving == ptc->iLastRow)
            return; // already at the bottom;

        // no scrolling.  just set the iRow var appropriatesly

        for (i = Tab_Count(ptc) -1 ;i >= 0; i--) {
            pitem = Tab_FastGetItemPtr(ptc, i);
            if (pitem->iRow > iRowMoving) {
                
                // if the row is higher than the row that's being selected,
                // it drops one.
                pitem->iRow--;
                dy = -ptc->cyTabs;
                
            } else if (pitem->iRow == iRowMoving) {
                // save this
                rcTabs.top = pitem->rc.top;
                
                // if it's on the row that's moving down, we assign it to iLastRow and
                //calculate how far it needs to go.
                dy = ptc->cyTabs * (ptc->iLastRow - iRowMoving);
                pitem->iRow = ptc->iLastRow;

            } else
                continue;

            pitem->rc.top += dy;
            pitem->rc.bottom += dy;
        }
        
        rcTabs.bottom = ptc->cyTabs * (ptc->iLastRow + 1);
            
        Tab_SmoothScrollWindow(ptc, 0, rcTabs.bottom - rcTabs.top, NULL, &rcTabs, NULL, NULL, SW_ERASE |SW_INVALIDATE, 1);
        UpdateWindow(ptc->ci.hwnd);
        // invalidate the little bit below the
        rcTabs.bottom += 2*g_cyEdge;
        rcTabs.top = rcTabs.bottom - 3 * g_cyEdge;
        Tab_InvalidateRect(ptc, &rcTabs, TRUE);
    }
    UpdateToolTipRects(ptc);
}

__inline int Tab_InterButtonGap(PTC ptc)
{
    ASSERT(Tab_DrawButtons(ptc));

    if (Tab_FlatButtons(ptc)) {
        return (g_cxEdge * 5);
    } else {
        return (g_cxEdge * 3)/2;
    }
}

//
//  BADNESS is the amount of unused space in the row
//
#define BADNESS(ptc, i) (ptc->cxTabs - Tab_FastGetItemPtr(ptc, i)->rc.right)

// borrow one tab from the prevous row
BOOL BorrowOne(PTC ptc, int iCurLast, int iPrevLast, int iBorrow)
{
    LPTABITEM pitem, pitem2;
    int i;
    int dx;

    // is there room to move the prev item? (might now be if iPrev is huge)
    pitem = Tab_FastGetItemPtr(ptc, iPrevLast);
    pitem2 = Tab_FastGetItemPtr(ptc, iCurLast);

    // dx is the number of extra pixels that aren't part of the pitem->rc.
    // The non-button case of 2 * g_cxEdge is maniacally hard-coded
    // all over the place.  Change it at your own risk.
    if (Tab_DrawButtons(ptc))
        dx = Tab_InterButtonGap(ptc);
    else
        dx = 2 * g_cxEdge;              // inflate by g_cxEdge

    // if the size of the item is greaterthan the badness
    if (BADNESS(ptc, iCurLast) < (pitem->rc.right - pitem->rc.left + dx))
        return FALSE;

    // otherwise do it.
    // move this one down
    dx = pitem->rc.left - Tab_FastGetItemPtr(ptc, iPrevLast + 1)->rc.left;
    pitem->rc.left -= dx;
    pitem->rc.right -= dx;
    pitem->rc.top = pitem2->rc.top;
    pitem->rc.bottom = pitem2->rc.bottom;
    pitem->iRow = pitem2->iRow;

    // and move all the others over.
    dx = pitem->rc.right - pitem->rc.left;
    for(i = iPrevLast + 1 ; i <= iCurLast ; i++ ) {
        pitem = Tab_FastGetItemPtr(ptc, i);
        pitem->rc.left += dx;
        pitem->rc.right += dx;
    }

    if (iBorrow) {
        if (pitem->iRow > 1) {

            // borrow one from the next row up.
            // setup the new iCurLast as the one right before the one we moved
            // (the one we moved is now the current row's first
            // and hunt backwards until we find an iPrevLast
            iCurLast = iPrevLast - 1;
            while (iPrevLast-- &&
                   Tab_FastGetItemPtr(ptc, iPrevLast)->iRow == (pitem->iRow - 1))
            {
                if (iPrevLast <= 0)
                {
                    // sanity check
                    return FALSE;
                }
            }
            return BorrowOne(ptc, iCurLast, iPrevLast, iBorrow - 1 );
        } else
            return FALSE;

    }
    return TRUE;
}


// fill last row will fiddle around borrowing from the previous row(s)
// to keep from having huge huge bottom tabs
void FillLastRow(PTC ptc)
{
    int hspace;
    int cItems = Tab_Count(ptc);
    int iPrevLast;
    int iBorrow = 0;

    // if not even two items, nothing to fill from
    if (cItems < 2)
        return;

    // find last item on previous row
    for (iPrevLast = cItems - 2;
         Tab_FastGetItemPtr(ptc, iPrevLast)->iRow == ptc->iLastRow;
         iPrevLast--)
    {
        // sanity check
        if (iPrevLast <= 0)
        {
            ASSERT(FALSE);
            return;
        }
    }

    while (iPrevLast &&  (hspace = BADNESS(ptc, cItems-1)) &&
           (hspace > ((ptc->cxTabs/8) + BADNESS(ptc, iPrevLast))))
    {
        // if borrow fails, bail
        if (!BorrowOne(ptc, cItems - 1, iPrevLast, iBorrow++))
            return;
        iPrevLast--;
    }
}

void RightJustify(PTC ptc)
{
    int i;
    LPTABITEM pitem;
    int j;
    int k;
    int n;
    int cItems = Tab_Count(ptc);
    int hspace, dwidth, dremainder, moved;

    // don't justify if only one row
    if (ptc->iLastRow < 1)
        return;

    FillLastRow(ptc);

    for ( i = 0; i < cItems; i++ ) {
        int iRow;
        pitem = Tab_FastGetItemPtr(ptc, i) ;
        iRow = pitem->iRow;

        // find the last item in this row
        for( j = i ; j < cItems; j++) {
            if(Tab_FastGetItemPtr(ptc, j)->iRow != iRow)
                break;
        }

        // count the number of items
        for(n=0,k=i ; k < j ; k++ ) {
            pitem = Tab_FastGetItemPtr(ptc, k);
            if (!(pitem->dwState & TCIS_HIDDEN))
                n++;
        }

        // how much to fill
        hspace = ptc->cxTabs - Tab_FastGetItemPtr(ptc, j-1)->rc.right - g_cxEdge;
        dwidth = hspace/n;  // amount to increase each by.
        dremainder =  hspace % n; // the remnants
        moved = 0;  // how much we've moved already

        for( ; i < j ; i++ ) {
            int iHalf = dwidth/2;
            pitem = Tab_FastGetItemPtr(ptc, i);

            if (!(pitem->dwState & TCIS_HIDDEN)) {
                pitem->rc.left += moved;
                pitem->xLabel += iHalf;
                pitem->xImage += iHalf;
                moved += dwidth + (dremainder ? 1 : 0);
                if ( dremainder )  dremainder--;
                pitem->rc.right += moved;
            }
        }
        i--; //dec because the outter forloop incs again.
    }
}

BOOL Tab_OnDeleteAllItems(PTC ptc)
{
    int i;

    for (i = Tab_Count(ptc); i-- > 0; i) {
        if(ptc->hwndToolTips) {
            TOOLINFO ti;
            ti.cbSize = sizeof(ti);
            ti.hwnd = ptc->ci.hwnd;
            ti.uId = i;
            SendMessage(ptc->hwndToolTips, TTM_DELTOOL, 0,
                        (LPARAM)(LPTOOLINFO)&ti);
        }
        Tab_FreeItem(ptc, Tab_FastGetItemPtr(ptc, i));
    }

    DPA_DeleteAllPtrs(ptc->hdpa);

    ptc->cxItem = RECOMPUTE;    // force recomputing of all tabs
    ptc->iSel = -1;
    ptc->iFirstVisible = 0;

    RedrawAll(ptc, RDW_INVALIDATE | RDW_ERASE);
    return TRUE;
}

BOOL Tab_OnSetItemExtra(PTC ptc, int cbExtra)
{
    if (Tab_Count(ptc) >0 || cbExtra<0)
        return FALSE;

    ptc->cbExtra = cbExtra;

    return TRUE;
}

BOOL Tab_OnSetItem(PTC ptc, int iItem, const TC_ITEM* ptci)
{
    TABITEM* pitem;
    UINT mask;
    BOOL fChanged = FALSE;
    BOOL fFullRedraw = FALSE;

    mask = ptci->mask;
    if (!mask)
        return TRUE;

    pitem = Tab_GetItemPtr(ptc, iItem);
    if (!pitem)
        return FALSE;

    if (mask & TCIF_TEXT)
    {
        if (!Str_Set(&pitem->pszText, ptci->pszText))
            return FALSE;
        fFullRedraw = TRUE;
        fChanged = TRUE;
        pitem->etoRtlReading = (mask & TCIF_RTLREADING) ?ETO_RTLREADING :0;
    }

    if (mask & TCIF_IMAGE) 
    {

        if (pitem->iImage == -1 || 
            ptci->iImage == -1) 
        {
            // went from no image to image... or vice versa
            // means needs full redraw
            
            fFullRedraw = TRUE;
        }
        pitem->iImage = ptci->iImage;
        fChanged = TRUE;
    }

    if ((mask & TCIF_PARAM) && ptc->cbExtra)
    {
        hmemcpy(pitem->DUMMYUNION_MEMBER(abExtra), &ptci->lParam, ptc->cbExtra);
    }
    
    if (mask & TCIF_STATE) {
        DWORD dwOldState = pitem->dwState;
        
        pitem->dwState = 
            (ptci->dwState & ptci->dwStateMask) | 
                (pitem->dwState & ~ptci->dwStateMask);
        
        if (dwOldState != pitem->dwState)
            fChanged = TRUE;

        if ((dwOldState ^ pitem->dwState) & TCIS_HIDDEN)
            fFullRedraw = TRUE;
        
        if ((ptci->dwStateMask & TCIS_BUTTONPRESSED) &&
            !(ptci->dwState & TCIS_BUTTONPRESSED)) {
            // if they turned OFF being pushed and we were pushed because of
            // selection, nuke it now.
            if (ptc->iNewSel == iItem) {
                ptc->iNewSel = -1;
                fChanged = TRUE;
            }
            
            if (ptc->iSel == iItem) {
                ChangeSel(ptc, -1, TRUE, FALSE);
                fChanged = TRUE;
            }
        }
    }

    if (fChanged) {
        if (Tab_FixedWidth(ptc) || !fFullRedraw) {
            Tab_InvalidateItem(ptc, iItem, FALSE);
        } else {
            ptc->cxItem = ptc->cyTabs = RECOMPUTE;
            RedrawAll(ptc, RDW_INVALIDATE | RDW_NOCHILDREN | RDW_ERASE);
        }
    }
    return TRUE;
}

void Tab_OnMouseMove(PTC ptc, WPARAM fwKeys, int x, int y)
{
    POINT pt;
    int iHit;
    pt.x=x; pt.y=y;

    iHit = Tab_OnHitTest(ptc, x, y, NULL);
    
    if (Tab_HotTrack(ptc)) {
        if (iHit != ptc->iHot) {
            Tab_InvalidateItem(ptc, iHit, FALSE);
            Tab_InvalidateItem(ptc, ptc->iHot, FALSE);
            ptc->iHot = iHit;
        }
        
    }
    
    if (fwKeys & MK_LBUTTON && Tab_DrawButtons(ptc)) {

        UINT uFlags;

        if (ptc->iNewSel == -1)
            return;

        if (iHit == ptc->iNewSel) {
            uFlags = TCF_DRAWSUNKEN;

        } else {
            uFlags = 0;
        }

        if ((ptc->flags & TCF_DRAWSUNKEN) != uFlags) {

            // the bit isn't what it should be
            ptc->flags ^=  TCF_DRAWSUNKEN;

            // we need to invalidate on flat buttons because we go from one pixes to 2 pixel edge
            Tab_InvalidateItem(ptc, ptc->iNewSel, Tab_FlatButtons(ptc));
            
        }
    }
}

void Tab_OnButtonUp(PTC ptc, int x, int y, BOOL fNotify)
{
    BOOL fAllow = TRUE;


    if (fNotify) {
        // pass NULL for parent because W95 queryied each time and some
        // folks reparent
        fAllow = !SendNotifyEx(NULL, ptc->ci.hwnd, NM_CLICK, NULL, ptc->ci.bUnicode);
    }

    if (Tab_DrawSunken(ptc)) {
        
        // nothing selected (its empty)
        // only do this if something is selected...
        // otherwise we still do need to go below and release capture though
        if (ptc->iNewSel != -1) {

            
            if (Tab_OnHitTest(ptc, x, y, NULL) == ptc->iNewSel) {

                int iNewSel = ptc->iNewSel;
                // use iNewSel instead of ptc->iNewSel because the SendNotify could have nuked us

                if (fAllow)
                    ChangeSel(ptc, iNewSel, TRUE, BMOVECURSORONCLICK);

                Tab_InvalidateItem(ptc, iNewSel, FALSE);

            } else {
                Tab_InvalidateItem(ptc, ptc->iNewSel, FALSE);
                Tab_InvalidateItem(ptc, ptc->iNewSel, FALSE);
            }

            // the changsel forces an updatewindow,
            // but we might have a border to unpaint(because of the TCF_DRAWSUNKEN
            // so we do another invalidate with just redraw 
            ptc->flags &= ~TCF_DRAWSUNKEN;
            ptc->iNewSel = -1;
        }
    }

    // don't worry about checking DrawButtons because TCF_MOUSEDOWN
    // wouldn't be set otherwise.
    if (ptc->flags & TCF_MOUSEDOWN) {
        int iOldSel = ptc->iNewSel;
        ptc->flags &= ~TCF_MOUSEDOWN; // do this before release  to avoid reentry
        ptc->iNewSel = -1;
        Tab_InvalidateItem(ptc, iOldSel, FALSE);
        CCReleaseCapture(&ptc->ci);
    }

}

int Tab_OnHitTest(PTC ptc, int x, int y, UINT *lpuFlags)
{
    int i;
    int iLast = Tab_Count(ptc);
    RECT rc;
    POINT pt;
    UINT uTemp;


    rc.left = rc.right = x;
    rc.top = rc.bottom = y;
    Tab_DVFlipRect(ptc, &rc);
    pt.x = rc.left;
    pt.y = rc.top;

    if (!lpuFlags) lpuFlags = &uTemp;

    for (i = 0; i < iLast; i++) {
        LPTABITEM pitem = Tab_FastGetItemPtr(ptc, i);
        if (PtInRect(&pitem->rc, pt)) {
            
            // x now needs to be in pitem coordinates
            x -= pitem->rc.left;
           
            *lpuFlags = TCHT_ONITEM;
            if (!Tab_OwnerDraw(ptc)) {
                if ((x > pitem->xLabel) && x < pitem->xLabel + pitem->cxLabel) {
                    *lpuFlags = TCHT_ONITEMLABEL;
                } else if (HASIMAGE(ptc, pitem)) {
                    int cxImage, cyImage;
                    Tab_ImageList_GetIconSize(ptc, &cxImage, &cyImage);
                    if ((x > pitem->xImage) && (x < (pitem->xImage + cxImage)))
                        *lpuFlags = TCHT_ONITEMICON;
                }
            }
            return i;
        }
    }
    *lpuFlags = TCHT_NOWHERE;
    return -1;
}

void Tab_DeselectAll(PTC ptc, BOOL fExcludeFocus)
{
    int iMax = Tab_Count(ptc) - 1;
    int i;

    if (Tab_DrawButtons(ptc)) {
        for (i = iMax; i >= 0; i--)
        {
            LPTABITEM pitem;

            pitem = Tab_FastGetItemPtr(ptc, i);
            if (!fExcludeFocus || (pitem->dwState & TCIS_BUTTONPRESSED)) {
                TCITEM tci;
                tci.mask = TCIF_STATE;
                tci.dwStateMask = TCIS_BUTTONPRESSED;
                tci.dwState = 0;
                Tab_OnSetItem(ptc, i, &tci);
            }
        }
    }
}

void Tab_OnRButtonDown(PTC ptc, int x, int y, WPARAM keyFlags)
{
    int i;
    int iOldSel = -1;

    
    if (Tab_Vertical(ptc)) {
        
        if (y > ptc->cxTabs) 
            return;
        
    } else {

        if (x > ptc->cxTabs)
            return;     // outside the range of the visible tabs
    }

    i = Tab_OnHitTest(ptc, x,y, NULL); // we don't swap x,y here because OnHitTest will

    if (i != -1) {

        if (Tab_DrawButtons(ptc) && Tab_MultiSelect(ptc)) {
            TCITEM tci;
            tci.mask = TCIF_STATE;
            tci.dwStateMask = TCIS_BUTTONPRESSED;

            Tab_OnGetItem(ptc, i, &tci);

            // as with the listview, don't deselect anything on right button
            if (!(tci.dwState & TCIS_BUTTONPRESSED)) {
                if (!(GetAsyncKeyState(VK_CONTROL) < 0)) {
                    Tab_DeselectAll(ptc, FALSE);
                }

                // just toggle the pushed state.
                tci.dwState = TCIS_BUTTONPRESSED;
                Tab_OnSetItem(ptc, i, &tci);
            }
        }
    }
}

void Tab_OnLButtonDown(PTC ptc, int x, int y, WPARAM keyFlags)
{
    int i;
    int iOldSel = -1;

    
    if (Tab_Vertical(ptc)) {
        
        if (y > ptc->cxTabs) 
            return;
        
    } else {

        if (x > ptc->cxTabs)
            return;     // outside the range of the visible tabs
    }

    i = Tab_OnHitTest(ptc, x,y, NULL); // we don't swap x,y here because OnHitTest will

    if (i != -1) {
        
        if (Tab_MultiSelect(ptc) && (GetAsyncKeyState(VK_CONTROL) < 0) && Tab_DrawButtons(ptc) ) {
            // just toggle the pushed state.
            TCITEM tci;
            tci.mask = TCIF_STATE;
            tci.dwStateMask = TCIS_BUTTONPRESSED;
            
            Tab_OnGetItem(ptc, i, &tci);
            tci.dwState ^= TCIS_BUTTONPRESSED;
            Tab_OnSetItem(ptc, i, &tci);
            
        } else {
            
            iOldSel = ptc->iSel;

            if ((!Tab_FocusNever(ptc))
                && Tab_FocusOnButtonDown(ptc))
            {
                SetFocus(ptc->ci.hwnd);
            }

            if (Tab_DrawButtons(ptc)) {
                ptc->iNewSel = i;
                ptc->flags |= (TCF_DRAWSUNKEN|TCF_MOUSEDOWN);
                SetCapture(ptc->ci.hwnd);
                // we need to invalidate on flat buttons because we go from one pixes to 2 pixel edge
                Tab_InvalidateItem(ptc, i, Tab_FlatButtons(ptc));
            } else {
                iOldSel = ChangeSel(ptc, i, TRUE, BMOVECURSORONCLICK);
            }
        }
    }

    if ((!Tab_FocusNever(ptc)) &&
        (iOldSel == i))  // reselect current selection
        // this also catches i == -1 because iOldSel started as -1
    {
        SetFocus(ptc->ci.hwnd);
        UpdateWindow(ptc->ci.hwnd);
    }
}


TABITEM* Tab_CreateItem(PTC ptc, const TC_ITEM* ptci)
{
    TABITEM* pitem;

    if (pitem = Alloc(sizeof(TABITEM)-sizeof(LPARAM)+ptc->cbExtra))
    {
        if (ptci->mask & TCIF_IMAGE)
            pitem->iImage = ptci->iImage;
        else
            pitem->iImage = -1;

        pitem->xLabel = pitem->yLabel = RECOMPUTE;

        // If specified, copy extra block of memory.
        if (ptci->mask & TCIF_PARAM) 
        {
            if (ptc->cbExtra) 
            {
                hmemcpy(pitem->DUMMYUNION_MEMBER(abExtra), &ptci->lParam, ptc->cbExtra);
            }
        }

        if (ptci->mask & TCIF_TEXT)  
        {
            if (!Str_Set(&pitem->pszText, ptci->pszText))
            {
                Tab_FreeItem(ptc, pitem);
                return NULL;
            }
            pitem->etoRtlReading = (ptci->mask & TCIF_RTLREADING) ?ETO_RTLREADING :0;
        }
    }
    return pitem;
}


void Tab_UpdateArrows(PTC ptc, BOOL fSizeChanged)
{
    RECT rc;
    BOOL fArrow;

    Tab_GetClientRect(ptc, &rc);

    if (IsRectEmpty(&rc))
        return;     // Nothing to do yet!

    // See if all of the tabs will fit.
    ptc->cxTabs = rc.right;     // Assume can use whole area to paint

    if (Tab_MultiLine(ptc))
        fArrow = FALSE;
    else {
        Tab_CalcPaintMetrics(ptc, NULL);
        fArrow = (ptc->cxItem >= rc.right);
    }

    if (!fArrow)
    {
    NoArrows:
        // Don't need arrows
        if (ptc->hwndArrows)
        {
            ShowWindow(ptc->hwndArrows, SW_HIDE);
            // Bug#94368:: This is overkill should only invalidate portion
            // that may be impacted, like the last displayed item..
            InvalidateRect(ptc->ci.hwnd, NULL, TRUE);
        }
        if (ptc->iFirstVisible > 0) 
        {
            Tab_OnHScroll(ptc, NULL, SB_THUMBPOSITION, 0);
            // Bug#94368:: This is overkill should only invalidate portion
            // that may be impacted, like the last displayed item..
            InvalidateRect(ptc->ci.hwnd, NULL, TRUE);
        }
    }
    else
    {
        int cx;
        int cy;
        int iMaxBtnVal;
        int xSum;
        TABITEM * pitem;


        cy = ptc->cxyArrows;
        cx = cy * 2;

        ptc->cxTabs = rc.right - cx;   // Make buttons square

        //  See how many tabs we have to remove until the last tab becomes
        //  fully visible.
        xSum = 0;                       // Number of pixels in removed tabs
        for (iMaxBtnVal=0; (ptc->cxTabs + xSum) < ptc->cxItem; iMaxBtnVal++)
        {
            pitem = Tab_GetItemPtr(ptc, iMaxBtnVal);
            if (!pitem)
                break;
            xSum += pitem->rc.right - pitem->rc.left;
        }

        // If we removed *all* the tabs, then put the last one back.
        // This happens if the last tab is so huge it doesn't fit into
        // the requisite space no matter how many tabs you remove.
        if (iMaxBtnVal >= Tab_Count(ptc))
        {
            iMaxBtnVal = Tab_Count(ptc) - 1;
        }

        //  If we don't need to remove any tabs, then we guessed wrong about
        //  arrows.  This can happen if there is exactly one tab that doesn't
        //  fit in the requisite space.  No arrow since there is nothing to
        //  scroll to!
        //
        if (iMaxBtnVal <= 0)
        {
            ptc->cxTabs = rc.right;     // Can use whole area to paint
            goto NoArrows;
        }

        if (!ptc->hwndArrows) {
            
            InvalidateRect(ptc->ci.hwnd, NULL, TRUE);
            ptc->hwndArrows = CreateUpDownControl
                (Tab_Vertical(ptc) ? (HDS_VERT | WS_CHILD) : (UDS_HORZ | WS_CHILD), 0, 0, 0, 0,
                 ptc->ci.hwnd, 1, HINST_THISDLL, NULL, iMaxBtnVal, 0,
                 ptc->iFirstVisible);
        }

        // DebugMsg(DM_TRACE, TEXT("Tabs_UpdateArrows iMax=%d\n\r"), iMaxBtnVal);
        if (ptc->hwndArrows)
        {
            rc.left = rc.right - cx;
            rc.top = ptc->cyTabs - cy;
            rc.bottom = ptc->cyTabs;
            Tab_VDFlipRect(ptc, &rc);
            
            if (fSizeChanged || !IsWindowVisible(ptc->hwndArrows))
                SetWindowPos(ptc->hwndArrows, NULL,
                             rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
                             SWP_NOACTIVATE | SWP_NOZORDER | SWP_SHOWWINDOW);
            // Make sure the range is set
            SendMessage(ptc->hwndArrows, UDM_SETRANGE, 0,
                        MAKELPARAM(iMaxBtnVal, 0));

        }
    }
}

int Tab_OnInsertItem(PTC ptc, int iItem, const TC_ITEM* ptci)
{
    TABITEM* pitem;
    int i;

    pitem = Tab_CreateItem(ptc, ptci);
    if (!pitem)
        return -1;

    i = iItem;

    i = DPA_InsertPtr(ptc->hdpa, i, pitem);
    if (i == -1)
    {
        Tab_FreeItem(ptc, pitem);
        return -1;
    }

    if (ptc->iSel < 0)
        ptc->iSel = i;
    else if (ptc->iSel >= i)
        ptc->iSel++;

    if (ptc->iFirstVisible > i)
        ptc->iFirstVisible++;

    ptc->cxItem = RECOMPUTE;    // force recomputing of all tabs

    //Add tab to tooltips..  calculate the rect later
    if(ptc->hwndToolTips) {
        TOOLINFO ti;
        // don't bother setting the rect because we'll do it below
        // in FlushToolTipsMgr;
        ti.cbSize = sizeof(ti);
        ti.uFlags = ptci->mask & TCIF_RTLREADING ?TTF_RTLREADING :0;
        ti.hwnd = ptc->ci.hwnd;
        ti.uId = Tab_Count(ptc) - 1 ;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        SendMessage(ptc->hwndToolTips, TTM_ADDTOOL, 0,
                    (LPARAM)(LPTOOLINFO)&ti);
    }

    if (Tab_RedrawEnabled(ptc)) {
        RECT rcInval;
        LPTABITEM pitem;

        if (Tab_DrawButtons(ptc)) {

            if (Tab_FixedWidth(ptc)) {

                Tab_CalcPaintMetrics(ptc, NULL);
                if (i == Tab_Count(ptc) - 1) {
                    Tab_InvalidateItem(ptc, i, FALSE);
                } else {
                    pitem = Tab_GetItemPtr(ptc, i);
                    GetClientRect(ptc->ci.hwnd, &rcInval);

                    if (pitem) {
                        rcInval.top = pitem->rc.top;
                        if (ptc->iLastRow == 0) {
                            rcInval.left = pitem->rc.left;
                        }
                        Tab_UpdateArrows(ptc, FALSE);
                        RedrawWindow(ptc->ci.hwnd, &rcInval, NULL, RDW_INVALIDATE |RDW_NOCHILDREN);
                    }
                }

                NotifyWinEvent(EVENT_OBJECT_CREATE, ptc->ci.hwnd, OBJID_CLIENT, i+1);
                return i;
            }

        } else {

            // in tab mode Clear the selected item because it may move
            // and it sticks high a bit.
            if (ptc->iSel > i) {
                // update now because invalidate erases
                // and the redraw below doesn't.
                Tab_InvalidateItem(ptc, ptc->iSel, TRUE);
                UpdateWindow(ptc->ci.hwnd);
            }
        }

        RedrawAll(ptc, RDW_INVALIDATE | RDW_NOCHILDREN);

    }

    NotifyWinEvent(EVENT_OBJECT_CREATE, ptc->ci.hwnd, OBJID_CLIENT, i+1);
    return i;
}

// Add/remove/replace item

BOOL Tab_FreeItem(PTC ptc, TABITEM* pitem)
{
    if (pitem)
    {
        Str_Set(&pitem->pszText, NULL);
        Free(pitem);
    }
    return FALSE;
}

void Tab_OnRemoveImage(PTC ptc, int iItem)
{
    if (ptc->himl && iItem >= 0) {
        int i;
        LPTABITEM pitem;

        ImageList_Remove(ptc->himl, iItem);
        for( i = Tab_Count(ptc)-1 ; i >= 0; i-- ) {
            pitem = Tab_FastGetItemPtr(ptc, i);
            if (pitem->iImage > iItem)
                pitem->iImage--;
            else if (pitem->iImage == iItem) {
                pitem->iImage = -1; // if we now don't draw something, inval
                Tab_InvalidateItem(ptc, i, FALSE);
            }
        }
    }
}

BOOL Tab_OnDeleteItem(PTC ptc, int i)
{
    TABITEM* pitem;
    UINT uRedraw;
    RECT rcInval;
    rcInval.left = -1; // special flag...

    if (i >= Tab_Count(ptc))
        return FALSE;

    NotifyWinEvent(EVENT_OBJECT_DESTROY, ptc->ci.hwnd, OBJID_CLIENT, i+1);

    if (!Tab_DrawButtons(ptc) && (Tab_RedrawEnabled(ptc) || ptc->iSel >= i)) {
        // in tab mode, Clear the selected item because it may move
        // and it sticks high a bit.
        Tab_InvalidateItem(ptc, ptc->iSel, TRUE);
    }

    // if its fixed width, don't need to erase everything, just the last one
    if (Tab_FixedWidth(ptc)) {
        int j;

        uRedraw = RDW_INVALIDATE | RDW_NOCHILDREN;
        j = Tab_Count(ptc) -1;
        Tab_InvalidateItem(ptc, j, TRUE);

        // update optimization
        if (Tab_DrawButtons(ptc)) {

            if (i == Tab_Count(ptc) - 1) {
                rcInval.left = 0;
                uRedraw = 0;
            } else {
                pitem = Tab_GetItemPtr(ptc, i);
                GetClientRect(ptc->ci.hwnd, &rcInval);

                if (pitem) {
                    rcInval.top = pitem->rc.top;
                    if (ptc->iLastRow == 0) {
                        rcInval.left = pitem->rc.left;
                    }
                }
            }
        }

    } else {
        uRedraw = RDW_INVALIDATE | RDW_NOCHILDREN | RDW_ERASE;
    }
    pitem = DPA_DeletePtr(ptc->hdpa, i);
    if (!pitem)
        return FALSE;


    Tab_FreeItem(ptc, pitem);

    if (ptc->iSel == i)
        ptc->iSel = -1;       // deleted the focus item
    else if (ptc->iSel > i)
        ptc->iSel--;          // slide the foucs index down

    // maintain the first visible
    if (ptc->iFirstVisible > i)
        ptc->iFirstVisible--;

    ptc->cxItem = RECOMPUTE;    // force recomputing of all tabs
    ptc->iLastTopRow = -1;
    if(ptc->hwndToolTips) {
        TOOLINFO ti;
        ti.cbSize = sizeof(ti);
        ti.hwnd = ptc->ci.hwnd;
        ti.uId = Tab_Count(ptc) ;
        SendMessage(ptc->hwndToolTips, TTM_DELTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
    }

    if (Tab_RedrawEnabled(ptc)) {
        if (rcInval.left == -1) {
            RedrawAll(ptc, uRedraw);
        } else {

            Tab_UpdateArrows(ptc, FALSE);
            if (uRedraw)
                RedrawWindow(ptc->ci.hwnd, &rcInval, NULL, uRedraw);
        }
    }

    return TRUE;
}



BOOL Tab_OnGetItem(PTC ptc, int iItem, TC_ITEM* ptci)
{
    UINT mask = ptci->mask;
    const TABITEM* pitem = Tab_GetItemPtr(ptc, iItem);

    if (!pitem)
    {
        // NULL init the the tci struct incase there is no pitem.
        // This is incase the dude calling doesn't check the return
        // from this function. Bug # 7105
        if (mask & TCIF_PARAM)
            ptci->lParam = 0;
        else if (mask & TCIF_TEXT)
            ptci->pszText = 0;
        else if (mask & TCIF_IMAGE)
            ptci->iImage = 0;

        return FALSE;
    }

    if (mask & TCIF_TEXT) {
        if (pitem->pszText)
            lstrcpyn(ptci->pszText, pitem->pszText, ptci->cchTextMax);
        else
            ptci->pszText = 0;
    }
    
    if (mask & TCIF_STATE) {
        ptci->dwState = pitem->dwState & ptci->dwStateMask;
        
        // REViEW... maybe we should maintain the state in the statemask...
        if (ptci->dwStateMask & TCIS_BUTTONPRESSED) {
            if ((ptc->iSel == iItem) ||
                ((ptc->iNewSel == iItem) && Tab_DrawSunken(ptc))) {
                
                ptci->dwState |= TCIS_BUTTONPRESSED;
                
            }
        }
    }


    if ((mask & TCIF_PARAM) && ptc->cbExtra)
        hmemcpy(&ptci->lParam, pitem->DUMMYUNION_MEMBER(abExtra), ptc->cbExtra);

    if (mask & TCIF_IMAGE)
        ptci->iImage = pitem->iImage;

    // TC_ITEM does not have room for querying TCIF_RTLREADING !!
    // it only allows you to set it.
    // This is a hack to return info about tab item reading order
    if((mask & TCIF_RTLREADING) && !(mask & TCIF_TEXT)) 
    {
        if(pitem->etoRtlReading)
            ptci->cchTextMax = 1;
    }       

    return TRUE;
}

void Tab_InvalidateItem(PTC ptc, int iItem, BOOL bErase)
{
    if (iItem != -1) {
        LPTABITEM pitem = Tab_GetItemPtr(ptc, iItem);

        if (pitem) {
            RECT rc = pitem->rc;
            if (rc.right > ptc->cxTabs)
                rc.right = ptc->cxTabs;  // don't invalidate past our end
            InflateRect(&rc, g_cxEdge, g_cyEdge);
            if (Tab_FlatButtons(ptc)) {
                rc.right += 2 * g_cxEdge;
            }
            Tab_InvalidateRect(ptc, &rc, bErase);
        }
    }
}

BOOL RedrawAll(PTC ptc, UINT uFlags)
{
    if (ptc && Tab_RedrawEnabled(ptc)) {
        Tab_UpdateArrows(ptc, FALSE);
        RedrawWindow(ptc->ci.hwnd, NULL, NULL, uFlags);
        return TRUE;
    }
    return FALSE;
}

int ChangeSel(PTC ptc, int iNewSel, BOOL bSendNotify,
    BOOL bUpdateCursorPos)
{
    BOOL bErase;
    int iOldSel;
    HWND hwnd;
    SIZE screenDelta;
    RECT rcT;

    if (iNewSel == ptc->iSel)
        return ptc->iSel;

    if (bUpdateCursorPos && Tab_OnGetItemRect(ptc, iNewSel, &rcT))
    {
        screenDelta.cx = rcT.left;
        screenDelta.cy = rcT.top;
    }
    else
    {
        screenDelta.cx = screenDelta.cy = 0;
        bUpdateCursorPos = FALSE;
    }

    hwnd = ptc->ci.hwnd;
    // make sure in range
    if (iNewSel < 0) {
        iOldSel = ptc->iSel;
        ptc->iSel = -1;
    } else if (iNewSel < Tab_Count(ptc)) {

        LPTABITEM pitem = Tab_GetItemPtr(ptc, iNewSel);
        ASSERT(pitem);
        if (!pitem)
            return -1;

        //
        // dont allow a hidden item to get the focus
        //
        // Bug#94368 this is not 100% correct, focus will only
        // work right if hidden items are at the begining
        // or end (user will not be able to arrow past it)
        //
        // currenly this is not a bad restriction
        // only desk.cpl uses this flag, and it
        // always hides the last item.
        //
        // if we make this a general flag we will need to
        // fix this.
        //
        if (pitem->dwState & TCIS_HIDDEN)
            return -1;

        // make sure this is a change that's wanted
        if (bSendNotify)
        {
            // pass NULL for parent because W95 queryied each time and some
            // folks reparent
            if (SendNotifyEx(NULL, hwnd, TCN_SELCHANGING, NULL, ptc->ci.bUnicode))
                return ptc->iSel;
        }

        iOldSel = ptc->iSel;
        ptc->iSel = iNewSel;

        // See if we need to make sure the item is visible
        if (Tab_MultiLine(ptc)) {
            if( !Tab_DrawButtons(ptc) && ptc->iLastRow > 0 && iNewSel != -1) {
                // In multiLineTab Mode bring the row to the bottom.
                PutzRowToBottom(ptc, Tab_FastGetItemPtr(ptc, iNewSel)->iRow);
            }
        } else   {
            // In single line mode, slide things over to  show selection
            RECT rcClient;
            int xOffset = 0;
            int iNewFirstVisible = 0;

            GetClientRect(ptc->ci.hwnd, &rcClient);
            if (pitem->rc.left < g_cxEdge)
            {
                xOffset = -pitem->rc.left + g_cxEdge;        // Offset to get back to zero
                iNewFirstVisible = iNewSel;
            }
            else if ((iNewSel != ptc->iFirstVisible) &&
                    (pitem->rc.right > ptc->cxTabs))
            {
                // A little more tricky new to scroll each tab until we
                // fit on the end
                for (iNewFirstVisible = ptc->iFirstVisible;
                        iNewFirstVisible < iNewSel;)
                {
                    LPTABITEM pitemT = Tab_FastGetItemPtr(ptc, iNewFirstVisible);
                    xOffset -= (pitemT->rc.right - pitemT->rc.left);
                    iNewFirstVisible++;
                    if ((pitem->rc.right + xOffset) < ptc->cxTabs)
                        break;      // Found our new top index
                }
                // If we end up being the first item shown make sure our left
                // end is showing correctly
                if (iNewFirstVisible == iNewSel)
                    xOffset = -pitem->rc.left + g_cxEdge;
            }

            if (xOffset != 0)
            {
                Tab_Scroll(ptc, xOffset, iNewFirstVisible);
            }
        }
    } else
        return -1;

    Tab_DeselectAll(ptc, TRUE);
    
    // repaint opt: we don't need to erase for buttons because their paint covers all.
    bErase = (!Tab_DrawButtons(ptc) || Tab_FlatButtons(ptc));
    if (bErase)
        UpdateWindow(hwnd);
    Tab_InvalidateItem(ptc, iOldSel, bErase);
    Tab_InvalidateItem(ptc, iNewSel, bErase);
    // mfc4.2 relies upon this update window.  they do something that
    // forces the window invalid bit to be false on the TCN_SELCHANGE and
    // thereby making us lose this update window
    UpdateWindow(hwnd);

    if (bUpdateCursorPos && Tab_OnGetItemRect(ptc, iNewSel, &rcT))
    {
        POINT ptCursor;

        screenDelta.cx = rcT.left - screenDelta.cx;
        screenDelta.cy = rcT.top  - screenDelta.cy;

        GetCursorPos(&ptCursor);
        SetCursorPos(ptCursor.x + screenDelta.cx, ptCursor.y + screenDelta.cy);
    }

    // if they are buttons, we send the message on mouse up
    if (bSendNotify)
    {
        // pass NULL for parent because W95 queryied each time and some
        // folks reparent
        SendNotifyEx(NULL, hwnd, TCN_SELCHANGE, NULL, ptc->ci.bUnicode);
    }

    NotifyWinEvent(EVENT_OBJECT_SELECTION, hwnd, OBJID_CLIENT, ptc->iSel+1);
    // We might've been destroyed during the notify, but GetFocus
    // couldn't possibly return our hwnd in that case, so we're still safe.
    if (GetFocus() == hwnd)
        NotifyWinEvent(EVENT_OBJECT_FOCUS, hwnd, OBJID_CLIENT, ptc->iSel+1);

    return iOldSel;
}

// Tab_CalcTabHeight is theme aware
void Tab_CalcTabHeight(PTC ptc, HDC hdc)
{
    BOOL bReleaseDC = FALSE;

    if (ptc->cyTabs == RECOMPUTE) {
        TEXTMETRIC tm;
        int iYExtra;
        int cx = 0;
        int cy = 0;

        ZeroMemory(&tm, sizeof(TEXTMETRIC));

        if (!hdc)
        {
            bReleaseDC = TRUE;
            hdc = GetDC(NULL);
            SelectObject(hdc, ptc->hfontLabel);
        }

        // Get metircs on theme font
        if (ptc->hTheme)
        {
            GetThemeTextMetrics(ptc->hTheme, hdc, ptc->iPartId, ptc->iStateId, &tm);
        }
        else
        {
            GetTextMetrics(hdc, &tm);
        }

        if (!ptc->fMinTabSet) {
            ptc->cxMinTab = tm.tmAveCharWidth * 6 + ptc->cxPad * 2;
        }
        ptc->cxyArrows = tm.tmHeight + 2 * g_cyEdge;

        if (ptc->himl)
            Tab_ImageList_GetIconSize(ptc, &cx, &cy);

        if (ptc->iTabHeight) {
            ptc->cyTabs = ptc->iTabHeight;
            if (Tab_DrawButtons(ptc))
                iYExtra = 3 * g_cyEdge; // (for the top edge, button edge and room to drop down)
            else
                iYExtra = 2 * g_cyEdge - 1;

        } else {
            // the height is the max of image or label plus padding.
            // where padding is 2*cypad-edge but at lease an edges
            iYExtra = ptc->cyPad*2;
            if (iYExtra < 2*g_cyEdge)
                iYExtra = 2*g_cyEdge;

            if (!Tab_DrawButtons(ptc))
                iYExtra -= (1 + g_cyEdge);

            // add an edge to the font height because we want a bit of
            // space under the text
            ptc->cyTabs = max(tm.tmHeight + g_cyEdge, cy) + iYExtra;
        }

        ptc->tmHeight = tm.tmHeight;

        // add one so that if it's odd, we'll round up.
        ptc->cyText = (ptc->cyTabs - iYExtra - tm.tmHeight + 1) / 2;
        ptc->cyIcon = (ptc->cyTabs - iYExtra - cy) / 2;

        if (bReleaseDC)
        {
            ReleaseDC(NULL, hdc);
        }
    }
}

void UpdateToolTipRects(PTC ptc)
{
    if(ptc->hwndToolTips) {
        int i;
        TOOLINFO ti;
        int iMax;
        LPTABITEM pitem;

        ti.cbSize = sizeof(ti);
        ti.uFlags = 0;
        ti.hwnd = ptc->ci.hwnd;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        for ( i = 0, iMax = Tab_Count(ptc); i < iMax;  i++) {
            pitem = Tab_FastGetItemPtr(ptc, i);

            ti.uId = i;
            ti.rect = pitem->rc;
            Tab_VDFlipRect(ptc, &ti.rect);
            SendMessage(ptc->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM)((LPTOOLINFO)&ti));
        }
    }
}

// Tab_GetTextExtentPoint is theme aware
void Tab_GetTextExtentPoint(PTC ptc, HDC hdc, LPTSTR lpszText, int iCount, LPSIZE lpsize)
{
    TCHAR szBuffer[128];

    if (iCount < ARRAYSIZE(szBuffer) && !Tab_Vertical(ptc)) {
        StripAccelerators(lpszText, szBuffer, TRUE);
        lpszText = szBuffer;
        iCount = lstrlen(lpszText);
    }

    if (ptc->hTheme)
    {
        RECT rc = { 0 };
        GetThemeTextExtent(ptc->hTheme, hdc, ptc->iPartId, ptc->iStateId, lpszText, iCount, 0, &rc, &rc);

        lpsize->cx = RECTWIDTH(rc);
        lpsize->cy = RECTHEIGHT(rc);
    }
    else
    {
        GetTextExtentPoint(hdc, lpszText, iCount, lpsize);
    }
}

void Tab_InvertRows(PTC ptc)
{
    int i;
    int yTop = g_cyEdge;
    int yNew;
    int iNewRow;
    
    // we want the first item to be on the bottom.
    for (i = Tab_Count(ptc) - 1; i >= 0; i--) {
        LPTABITEM pitem = Tab_FastGetItemPtr(ptc, i);
        iNewRow = ptc->iLastRow - pitem->iRow;
        yNew = yTop + iNewRow * ptc->cyTabs;
        pitem->iRow = iNewRow;
        OffsetRect(&pitem->rc, 0, yNew - pitem->rc.top);
    }
}

// Tab_CalcPaintMetrics is theme aware
void Tab_CalcPaintMetrics(PTC ptc, HDC hdc)
{
    SIZE siz;
    LPTABITEM pitem;
    int i, x, y;
    int xStart;
    int iRow = 0;
    int cItems = Tab_Count(ptc);
    BOOL bReleaseDC = FALSE;

    if (ptc->cxItem == RECOMPUTE) {
        
        // if the font hasn't been created yet, let's do it now
        if (!ptc->hfontLabel)
            Tab_OnSetFont(ptc, NULL, FALSE);
        
        if (!hdc)
        {
            bReleaseDC = TRUE;
            hdc = GetDC(NULL);
            SelectObject(hdc, ptc->hfontLabel);
        }

        Tab_CalcTabHeight(ptc, hdc);

        if (Tab_DrawButtons(ptc)) {
            // start at the edge;
            xStart = 0;
            y = 0;
        } else {
            xStart = g_cxEdge;
            y = g_cyEdge;
        }
        x = xStart;

        for (i = 0; i < cItems; i++) {
            int cxImage = 0;
            int cy = 0;
            int cxBounds = 0;
            pitem = Tab_FastGetItemPtr(ptc, i);

            if (pitem->pszText) {
                Tab_GetTextExtentPoint(ptc, hdc, pitem->pszText, lstrlen(pitem->pszText), &siz);
            } else  {
                siz.cx = 0;
                siz.cy = 0;
            }

            pitem->cxLabel = siz.cx;

            // if there's an image, count that too
            if (HASIMAGE(ptc, pitem)) {
                Tab_ImageList_GetIconSize(ptc, &cxImage, &cy);

                cxImage += ptc->cxPad;
                siz.cx += cxImage;
            }

            // If a theme is in use, inflate rect to accomidate full theme background (including margins)
            if (ptc->hTheme)
            {
                RECT rc = { 0, 0, siz.cx, siz.cy }; // Current content size
                GetThemeBackgroundExtent(ptc->hTheme, hdc, ptc->iPartId, ptc->iStateId, &rc, &rc);
                siz.cx = rc.right - rc.left;
                siz.cy = rc.bottom - rc.top;
            }

            cxBounds = siz.cx;

            if (Tab_FixedWidth(ptc)) {
                siz.cx = ptc->iTabWidth;
            } else {

                siz.cx += ptc->cxPad * 2;
                // Make sure the tab has a least a minimum width
                if (siz.cx < ptc->cxMinTab)
                    siz.cx = ptc->cxMinTab;
            }

            // handle hidden items
            if (pitem->dwState & TCIS_HIDDEN) {
                siz.cx = 0;
                siz.cy = 0;
            }

            // should we wrap?
            if (Tab_MultiLine(ptc)) {
                // two cases to wrap around:
                // case 2: is our right edge past the end but we ourselves
                //   are shorter than the width?
                // case 1: are we already past the end? (this happens if
                //      the previous line had only one item and it was longer
                //      than the tab's width.
                int iTotalWidth = ptc->cxTabs - g_cxEdge;
                if (x > iTotalWidth ||
                    (x+siz.cx >= iTotalWidth &&
                     (siz.cx < iTotalWidth))) {
                    x = xStart;
                    y += ptc->cyTabs;
                    iRow++;

                    if (Tab_DrawButtons(ptc))
                        y += ((g_cyEdge * 3)/2);
                }
                pitem->iRow = iRow;
            }

            pitem->rc.left = x;
            pitem->rc.right = x + siz.cx;
            pitem->rc.top = y;
            pitem->rc.bottom = ptc->cyTabs + y;

            if (!Tab_FixedWidth(ptc) || Tab_ForceLabelLeft(ptc) ||
                Tab_ForceIconLeft(ptc)) {

                pitem->xImage = ptc->cxPad;

            } else {
                // in fixed width mode center it
                pitem->xImage = (siz.cx - cxBounds)/2;
            }

            if (pitem->xImage < g_cxEdge)
                pitem->xImage = g_cxEdge;

            if (Tab_ForceIconLeft(ptc)) {
                // Center the text in the space remaining after the icon
                // The math here gets kind of crazy so I'm going to draw
                // a picture.
                //
                //     xImage
                //     |
                //   ->|   |<- cxImage
                //   +-----------------------------------------------+
                //   |  @@@           text text text                 |
                //   |  @@@                                          |
                //   +-----------------------------------------------+
                //   |<----------------- siz.cx -------------------->|
                //         |<-magic->|<--cxLabel--->|
                //                   xLabel
                //
                //  Therefore,
                //
                //  remaining space = siz.cx - cxImage - xImage - cxLabel.
                //  magic = remaining space / 2
                //  xLabel = xImage + cxImage + magic.
                //
                int cxImageTotal = pitem->xImage + cxImage;
                int cxRemaining = siz.cx - cxImageTotal - pitem->cxLabel;
                int cxMagic = cxRemaining / 2;
                pitem->xLabel = cxImageTotal + cxMagic;
            } else {
                // Place the text immediately after the icon
                pitem->xLabel = pitem->xImage + cxImage;

            }
            

            pitem->yImage = ptc->cyPad + ptc->cyIcon - (g_cyEdge/2);
            pitem->yLabel = ptc->cyPad + ptc->cyText - (g_cyEdge/2);

            x = pitem->rc.right;

            if (Tab_DrawButtons(ptc))
                x += Tab_InterButtonGap(ptc);
        }

        ptc->cxItem = x;        // total width of all tabs

        // if we added a line in non-button mode, we need to do a full refresh
        if (ptc->iLastRow != -1 &&
            ptc->iLastRow != iRow &&
            !Tab_DrawButtons(ptc)) {
            InvalidateRect(ptc->ci.hwnd, NULL, TRUE);
        }
        ptc->iLastRow = (cItems > 0) ? iRow : -1;

        if (Tab_MultiLine(ptc)) {
            if (!Tab_RaggedRight(ptc) && !Tab_FixedWidth(ptc))
                RightJustify(ptc);
            
            if (Tab_ScrollOpposite(ptc)) {
                Tab_InvertRows(ptc);
                                // if we have no selection, then the last row is the last top row
                                if (ptc->iSel == -1) 
                                        ptc->iLastTopRow = ptc->iLastRow;
            }

            if (!Tab_DrawButtons(ptc) && ptc->iSel != -1) {
                ptc->iLastTopRow = -1;
                PutzRowToBottom(ptc, Tab_FastGetItemPtr(ptc, ptc->iSel)->iRow);
            }

        } else if ( cItems > 0) {
            // adjust x's to the first visible
            int dx;
            pitem = Tab_GetItemPtr(ptc, ptc->iFirstVisible);
            if (pitem) {
                dx = -pitem->rc.left + g_cxEdge;
                for ( i = cItems - 1; i >=0  ; i--) {
                    pitem = Tab_FastGetItemPtr(ptc, i);
                    OffsetRect(&pitem->rc, dx, 0);
                }
            }
        }

        if (bReleaseDC)
        {
            ReleaseDC(NULL, hdc);
        }

        UpdateToolTipRects(ptc);
    }
}

// Tab_DoCorners is theme aware
void Tab_DoCorners(HDC hdc, LPRECT prc, PTC ptc, BOOL fBottom)
{
    RECT rc;
    COLORREF iOldColor;

    // Ignore for themes
    if (!ptc->hTheme)
    {
        iOldColor = SetBkColor(hdc, g_clrBtnFace);

        if (fBottom) {
            // lower right;
            rc = *prc;
            rc.left = rc.right - 2;
            rc.top = rc.bottom - 3;
        
            Tab_ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL, ptc);
            rc.bottom--;
            Tab_DrawEdge(hdc, &rc, EDGE_RAISED, BF_SOFT | BF_DIAGONAL_ENDBOTTOMLEFT, ptc);

        
            // lower left

            rc = *prc;
            rc.right = rc.left + 2;
            rc.top = rc.bottom - 3;
            Tab_ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL, ptc);
            rc.bottom--;
            Tab_DrawEdge(hdc, &rc, EDGE_RAISED, BF_SOFT | BF_DIAGONAL_ENDTOPLEFT, ptc);
        
        } else {
            // upper right
            rc = *prc;
            rc.left = rc.right - 2;
            rc.bottom = rc.top + 3;
            Tab_ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL, ptc);
            rc.top++;
            Tab_DrawEdge(hdc, &rc, EDGE_RAISED, BF_SOFT | BF_DIAGONAL_ENDBOTTOMRIGHT, ptc);


            // upper left

            rc = *prc;
            rc.right = rc.left + 2;
            rc.bottom = rc.top + 3;
            Tab_ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL, ptc);
            rc.top++;
            Tab_DrawEdge(hdc, &rc, EDGE_RAISED, BF_SOFT | BF_DIAGONAL_ENDTOPRIGHT, ptc);
        }
    }
}

void RefreshArrows(PTC ptc, HDC hdc)
{
    RECT rcClip, rcArrows, rcIntersect;

    if (ptc->hwndArrows && IsWindowVisible(ptc->hwndArrows)) {

        GetClipBox(hdc, &rcClip);
        GetWindowRect(ptc->hwndArrows, &rcArrows);
        MapWindowRect(NULL, ptc->ci.hwnd, &rcArrows);
        if (IntersectRect(&rcIntersect, &rcClip, &rcArrows))
            RedrawWindow(ptc->hwndArrows, NULL, NULL, RDW_INVALIDATE);
    }
}

// Tab_DrawBody is theme aware
void Tab_DrawBody(HDC hdc, PTC ptc, LPTABITEM pitem, LPRECT lprc, int i,
                          BOOL fTransparent, int dx, int dy)
{
    BOOL fSelected = (i == ptc->iSel);

    if (i == ptc->iHot)
    {
        if ( !Tab_FlatButtons(ptc) ) 
        {
            SetTextColor(hdc, GetSysColor(COLOR_HOTLIGHT));
        }
    }

    if (Tab_OwnerDraw(ptc)) 
    {
        DRAWITEMSTRUCT dis;
        WORD wID = (WORD) GetWindowID(ptc->ci.hwnd);

        dis.CtlType = ODT_TAB;
        dis.CtlID = wID;
        dis.itemID = i;
        dis.itemAction = ODA_DRAWENTIRE;
        if (fSelected)
            dis.itemState = ODS_SELECTED;
        else
            dis.itemState = 0;
        dis.hwndItem = ptc->ci.hwnd;
        dis.hDC = hdc;
        dis.rcItem = *lprc;
        Tab_VDFlipRect(ptc, &dis.rcItem);
        dis.itemData =
            (ptc->cbExtra <= sizeof(LPARAM)) ?
                (DWORD)pitem->DUMMYUNION_MEMBER(lParam) : (ULONG_PTR)(LPBYTE)&pitem->DUMMYUNION_MEMBER(abExtra);

        SendMessage( ptc->ci.hwndParent , WM_DRAWITEM, wID,
                    (LPARAM)(DRAWITEMSTRUCT *)&dis);

    } 
    else 
    {
        // draw the text and image
        // draw even if pszText == NULL to blank it out
        int xLabel;
        int xIcon;
        BOOL fUseDrawText = FALSE;
        if (pitem->pszText)
        {

            // only use draw text if there's any underlining to do.
            // Draw text does not support vertical drawing, so only do this in horz mode
            if (!Tab_Vertical(ptc) &&
                StrChr(pitem->pszText, CH_PREFIX)) 
            {
                fUseDrawText = TRUE;
            }
        }

        // DrawTextEx will not clear the entire area, so we need to.
        // or if there's no text, we need to blank it out
        if ((fUseDrawText || !pitem->pszText) && !fTransparent)
            Tab_ExtTextOut(hdc, 0, 0,
                       ETO_OPAQUE, lprc, NULL, 0, NULL, ptc);

        xLabel = pitem->rc.left + pitem->xLabel + dx;
        xIcon = pitem->rc.left + pitem->xImage + dx;
        
        if (pitem->pszText)
        {
            int xVertOffset = 0;
            int yOffset = 0;

            int oldMode;
            COLORREF oldBkColor;
            COLORREF oldTextColor;
            TEXTMETRIC tm;

            GetTextMetrics(hdc, &tm);
            if (tm.tmInternalLeading == 0)
                yOffset = 1;

            if (Tab_Vertical(ptc) && !Tab_Bottom(ptc)) 
            {
                
                // add this offset because we need to draw from the bottom up
                xLabel += pitem->cxLabel;
                
                // if we're drawing vertically (on the left)
                // the icon needs to go below (flipped coordinate, on the right)
                if (HASIMAGE(ptc, pitem)) 
                {
                    int cxIcon = 0;
                    int cyIcon = 0;
                    int xLabelNew;
                    
                    Tab_ImageList_GetIconSize(ptc, &cxIcon, &cyIcon);
                    xLabelNew = xIcon + pitem->cxLabel;
                    xIcon = xLabel - cxIcon;
                    xLabel = xLabelNew;
                }                
            }

            if (pitem->dwState & TCIS_HIGHLIGHTED)
            {
                oldMode = SetBkMode (hdc, OPAQUE);
                oldBkColor = SetBkColor (hdc, g_clrHighlight);
                oldTextColor = SetTextColor (hdc, g_clrHighlightText);
            }
            if (fUseDrawText) 
            {
                DRAWTEXTPARAMS dtp;
                int topPrev;
                dtp.cbSize = sizeof(DRAWTEXTPARAMS);
                dtp.iLeftMargin = xLabel - lprc->left;
                dtp.iRightMargin = 0;

                // There is no dtp.iTopMargin so we have to adjust the
                // rectangle instead.  The opaqueing has already been done,
                // so isn't not a problem if we "miss" some pixels since
                // they've already been erased.
                topPrev = lprc->top;
                lprc->top = pitem->rc.top + pitem->yLabel + dy + yOffset;

                Tab_DrawTextEx(hdc, pitem->pszText, -1, lprc, DT_SINGLELINE | DT_TOP, &dtp, ptc);

                // Undo our changes to lprc before anybody (else) notices.
                lprc->top = topPrev;
            } 
            else 
            {
                UINT uETOFlags = (ETO_CLIPPED | pitem->etoRtlReading | (ptc->ci.dwExStyle & WS_EX_RTLREADING ? ETO_RTLREADING : 0 ));

                if (!fTransparent || (pitem->dwState & TCIS_HIGHLIGHTED))
                    uETOFlags |= ETO_OPAQUE;

                Tab_ExtTextOut(hdc, xLabel, pitem->rc.top + pitem->yLabel + dy + yOffset,
                    uETOFlags, lprc, pitem->pszText, lstrlen(pitem->pszText),
                    NULL, ptc);
            }

            if (pitem->dwState & TCIS_HIGHLIGHTED)
            {
                SetBkMode(hdc, oldMode);
                SetBkColor (hdc, oldBkColor);
                SetTextColor (hdc, oldTextColor);
            }
        }

        if (HASIMAGE(ptc, pitem)) 
        {
            UINT uFlags = fTransparent ? ILD_TRANSPARENT : ILD_NORMAL;

            if (pitem->dwState & TCIS_HIGHLIGHTED)
                uFlags |= ILD_BLEND50;

            Tab_ImageList_Draw(ptc, pitem->iImage, hdc, xIcon,
                pitem->rc.top + pitem->yImage + dy, uFlags);
        }

    }
    if (i == ptc->iHot)
    {
        if ( !Tab_FlatButtons(ptc) ) 
        {
            SetTextColor(hdc, g_clrBtnText);
        }
    }
}

// Tab_DrawItemFrame is theme aware
void Tab_DrawItemFrame(PTC ptc, HDC hdc, UINT edgeType, LPTABITEM pitem, int i)
{
    UINT uWhichEdges;
    BOOL fBottom = FALSE;

    if (Tab_DrawButtons(ptc)) 
	{

        if (Tab_FlatButtons(ptc)) 
		{
            if ((edgeType == EDGE_SUNKEN) ||
                (edgeType == BDR_RAISEDINNER)) 
			{
                uWhichEdges = BF_RECT;
            } 
			else
			{

                if ((ptc->ci.style & TCS_HOTTRACK) &&
                    (i == ptc->iHot)) 
				{
                    edgeType = BDR_RAISEDINNER;
                    uWhichEdges = BF_RECT;
                }
				else 
				{

                    HPEN hPen, hOldPen;
                    RECT rcEdge;

                    // Ignore for themes
                    if (!ptc->hTheme)
                    {
                        CopyRect (&rcEdge, &pitem->rc);
                        //InflateRect (&rcEdge, -g_cxEdge, -g_cyEdge);

                        hPen = CreatePen (PS_SOLID, 2 * g_cyEdge, GetSysColor(COLOR_3DFACE));
                        hOldPen = SelectObject (hdc, hPen);

                        //
                        // Remove any border in the x direction
                        //

                        MoveToEx (hdc, rcEdge.left, rcEdge.top, NULL);
                        LineTo (hdc, rcEdge.right, rcEdge.top);
                        MoveToEx (hdc, rcEdge.left, rcEdge.bottom, NULL);
                        LineTo (hdc, rcEdge.right, rcEdge.bottom);

                        SelectObject (hdc, hOldPen);
                        DeleteObject (hPen);

                        //
                        // Remove any border in the y direction
                        //

                        hPen = CreatePen (PS_SOLID, 2 * g_cxEdge, GetSysColor(COLOR_3DFACE));
                        hOldPen = SelectObject (hdc, hPen);

                        MoveToEx (hdc, rcEdge.left, rcEdge.top, NULL);
                        LineTo (hdc, rcEdge.left, rcEdge.bottom);
                        MoveToEx (hdc, rcEdge.right, rcEdge.top, NULL);
                        LineTo (hdc, rcEdge.right, rcEdge.bottom);

                        SelectObject (hdc, hOldPen);
                        DeleteObject (hPen);
                    }

                    goto DrawCorners;
                }
            }
        }
		else 
		{
            uWhichEdges = BF_RECT | BF_SOFT;
        }
    }
	else 
	{
        uWhichEdges = BF_LEFT | BF_TOP | BF_RIGHT | BF_SOFT;
        
        if (Tab_ScrollOpposite(ptc))
		{
            ASSERT(ptc->iLastTopRow != -1);
            if (Tab_IsItemOnBottom(ptc, pitem))
			{
                fBottom = TRUE;
                uWhichEdges = BF_LEFT | BF_BOTTOM | BF_RIGHT | BF_SOFT;
            }
        }
    }
    
    Tab_DrawEdge(hdc, &pitem->rc, edgeType, uWhichEdges, ptc);
    
DrawCorners:

    if (!Tab_DrawButtons(ptc))
	{
        Tab_DoCorners(hdc, &pitem->rc, ptc, fBottom);
    }
	else 
	{
        if (Tab_FlatButtons(ptc) && Tab_FlatSeparators(ptc))
		{
           RECT rcEdge;

           // Ignore in themes
           if (!ptc->hTheme)
           {
               CopyRect (&rcEdge, &pitem->rc);
               rcEdge.right += (3 * g_cxEdge);
               DrawEdge(hdc, &rcEdge, EDGE_ETCHED, BF_RIGHT);
           }
        }
    }
}

// Tab_Paint is theme aware (iPartId and iStateId are only set here)
void Tab_Paint(PTC ptc, HDC hdcIn)
{
    PAINTSTRUCT ps;
    HDC hdc;
    RECT rcClient, rcClipBox, rcTest, rcBody;
    int cItems, i;
    int fnNewMode = OPAQUE;
    LPTABITEM pitem;
    HWND hwnd = ptc->ci.hwnd;
    HBRUSH hbrOld = NULL;

    // Calling methods that render themes, setup state (TAB/BUTTON)
    if (ptc->hTheme)
    {
        ptc->iPartId = TABP_TABITEM;
        ptc->iStateId = TIS_NORMAL;
    }

    GetClientRect(hwnd, &rcClient);
    if (!rcClient.right)
        return;

    if (hdcIn)
    {
        hdc = hdcIn;
        ps.rcPaint = rcClient;
    }
    else
    {
        hdc = BeginPaint(hwnd, &ps);
    }

    // Fill background if themes are in use, WM_ERASEBKGND will be overridden to do nothing in this case
    if (ptc->hTheme)
    {
        if (CCSendPrint(&ptc->ci, hdc) == FALSE)
        {
            FillRect(hdc, &rcClient, g_hbrBtnFace);
        }
    }
    
    // select font first so metrics will have the right size
    if (!ptc->hfontLabel)
        Tab_OnSetFont(ptc, NULL, FALSE);
    SelectObject(hdc, ptc->hfontLabel);
    Tab_CalcPaintMetrics(ptc, hdc);

    // now put it in our native orientation if it was vertical
    Tab_DFlipRect(ptc, &rcClient);
    
    Tab_OnAdjustRect(ptc, FALSE, &rcClient);
    InflateRect(&rcClient, g_cxEdge * 2, g_cyEdge * 2);
    rcClient.top += g_cyEdge;

    // Draw pane (if applicable)
    if(!Tab_DrawButtons(ptc)) 
    {
        DebugMsg(DM_TRACE, TEXT("Drawing at %d %d %d %d"), rcClient.left, rcClient.top, rcClient.right, rcClient.bottom);

        // Calling a method that render themes, setup state (PANE)
        if (ptc->hTheme)
        {
            ptc->iPartId = TABP_PANE;
            ptc->iStateId = 0;
        }

        Tab_DrawEdge(hdc, &rcClient, EDGE_RAISED, BF_SOFT | BF_RECT, ptc);
    }

    // Draw tab items

    // Calling methods that render themes, setup state (TAB/BUTTON)
    if (ptc->hTheme)
    {
        ptc->iPartId = TABP_TABITEM;
        ptc->iStateId = TIS_NORMAL;
    }

    cItems = Tab_Count(ptc);
    if (cItems) 
    {

        RefreshArrows(ptc, hdc);
        SetBkColor(hdc, g_clrBtnFace);
        SetTextColor(hdc, g_clrBtnText);

        if (!Tab_MultiLine(ptc))
            IntersectClipRect(hdc, 0, 0,
                              ptc->cxTabs, rcClient.bottom);

        GetClipBox(hdc, &rcClipBox);
        Tab_DVFlipRect(ptc, &rcClipBox);

        // draw all but the selected item
        for (i = ptc->iFirstVisible; i < cItems; i++) 
        {

            // Calling methods that render themes, setup state (TAB/BUTTON, HOT state)
            if (ptc->hTheme)
            {
                ptc->iStateId = (i == ptc->iHot) ? TIS_HOT : TIS_NORMAL;
            }

            pitem = Tab_FastGetItemPtr(ptc, i);

            if (pitem->dwState & TCIS_HIDDEN)
                continue;

            if (!Tab_MultiLine(ptc)) 
            {
                // if not multiline, and we're off the screen... we're done
                if (pitem->rc.left > ptc->cxTabs)
                    break;
            }

            // should we bother drawing this?
            if (i != ptc->iSel || Tab_DrawButtons(ptc)) 
            {
                if (IntersectRect(&rcTest, &rcClipBox, &pitem->rc)) 
                {

                    int dx = 0, dy = 0;  // shift variables if button sunken;
                    UINT edgeType;

                    
                    rcBody = pitem->rc;

                    // Draw the edge around each item
                    if(Tab_DrawButtons(ptc) &&
                       ((ptc->iNewSel == i && Tab_DrawSunken(ptc)) ||
                        (ptc->iSel == i) ||
                        (pitem->dwState & TCIS_BUTTONPRESSED))) 
                    {

                        dx = g_cxEdge/2;
                        dy = g_cyEdge/2;
                        if (Tab_FlatButtons(ptc) &&
                            (ptc->iNewSel == i && Tab_DrawSunken(ptc)))
                        {
                            edgeType = BDR_RAISEDINNER;
                        } 
                        else
                        {
                            edgeType =  EDGE_SUNKEN;
                        }

                    } 
                    else
                    {
                        edgeType = EDGE_RAISED;
                    }

                    if (Tab_DrawButtons(ptc) && !Tab_OwnerDraw(ptc))
                    {

                        // if drawing buttons, show selected by dithering  background
                        // which means we need to draw transparent.
                        if (ptc->iSel == i) 
                        {

                            // Calling methods that render themes, setup state (BUTTON, SELECTED state)
                            if (ptc->hTheme)
                            {
                                ptc->iStateId = TIS_SELECTED;
                            }

                            fnNewMode = TRANSPARENT;
                            SetBkMode(hdc, TRANSPARENT);
                            hbrOld = SelectObject(hdc, g_hbrMonoDither);
                            SetTextColor(hdc, g_clrBtnHighlight);
                            Tab_PatBlt(hdc, pitem->rc.left, pitem->rc.top, pitem->rc.right - pitem->rc.left,
                                       pitem->rc.bottom - pitem->rc.top, PATCOPY, ptc);
                            SetTextColor(hdc, g_clrBtnText);

                            // Calling methods that render themes, setup state (TAB/BUTTON, HOT state)
                            if (ptc->hTheme)
                            {
                                ptc->iStateId = (i == ptc->iHot) ? TIS_HOT : TIS_NORMAL;
                            }
                        }
                    }

                    InflateRect(&rcBody, -g_cxEdge, -g_cyEdge);
                    if (!Tab_DrawButtons(ptc)) 
                    {
                        
                        // move the bottom (or top) by an edge to draw where the tab doesn't have an edge.
                        // by doing this, we fill the entire area and don't need to do as many inval with erase
                        if (Tab_IsItemOnBottom(ptc, pitem))
                        {
                            rcBody.top -= g_cyEdge;
                        }
                        else 
                        {
                            rcBody.bottom += g_cyEdge;
                        }
                    }

                    // Draw background and content (for all items expect selected tab-style item)
                    if (ptc->hTheme)
                    {
                        RECT rcc;
                        GetClientRect(ptc->ci.hwnd, &rcc);

                        // Determine what part is currently being rendered
                        ptc->iPartId = TABP_TABITEM;

                        if (pitem->rc.left == g_cxEdge)
                            ptc->iPartId = TABP_TABITEMLEFTEDGE;

                        // Ick: Aaron wants "slop" for determining the right tab edge.
                        if ((pitem->rc.right >= (rcc.right - 2 * g_cxEdge)) || ((i + 1) == cItems))
                            ptc->iPartId = (ptc->iPartId == TABP_TABITEMLEFTEDGE) ? TABP_TABITEMBOTHEDGE : TABP_TABITEMRIGHTEDGE;

                        if (pitem->rc.top == g_cyEdge)
                        {
                            switch (ptc->iPartId)
                            {
                            case TABP_TABITEM:
                                ptc->iPartId = TABP_TOPTABITEM;
                                break;

                            case TABP_TABITEMLEFTEDGE:
                                ptc->iPartId = TABP_TOPTABITEMLEFTEDGE;
                                break;

                            case TABP_TABITEMRIGHTEDGE:
                                ptc->iPartId = TABP_TOPTABITEMRIGHTEDGE;
                                break;

                            case TABP_TABITEMBOTHEDGE:
                                ptc->iPartId = TABP_TOPTABITEMBOTHEDGE;
                                break;
                            }
                        }

                        // Reverse order for themes
                        // Edges
                        Tab_DrawItemFrame(ptc, hdc, edgeType, pitem, i);

                        // Content
                        Tab_DrawBody(hdc, ptc, pitem, &rcBody, i, fnNewMode == TRANSPARENT, dx, dy);
                    }
                    else
                    {
                        // Content
                        Tab_DrawBody(hdc, ptc, pitem, &rcBody, i, fnNewMode == TRANSPARENT, dx, dy);

                        // Edges
                        Tab_DrawItemFrame(ptc, hdc, edgeType, pitem, i);
                    }

                    if (fnNewMode == TRANSPARENT)
                    {
                        fnNewMode = OPAQUE;
                        SelectObject(hdc, hbrOld);
                        SetBkMode(hdc, OPAQUE);
                    }
                }
            }
        }

        if (!Tab_MultiLine(ptc))
            ptc->iLastVisible = i - 1;
        else
            ptc->iLastVisible = cItems - 1;

        // Calling methods that render themes, setup state (TAB, SELECTED state)
        if (ptc->hTheme)
        {
            ptc->iStateId = TIS_SELECTED;
        }

        // draw the selected one last to make sure it is on top
        pitem = Tab_GetItemPtr(ptc, ptc->iSel);
        if (pitem && (pitem->rc.left <= ptc->cxTabs))
        {
            rcBody = pitem->rc;

            if (!Tab_DrawButtons(ptc)) 
            {
                UINT uWhichEdges;
                
                InflateRect(&rcBody, g_cxEdge, g_cyEdge);

                if (IntersectRect(&rcTest, &rcClipBox, &rcBody))
                {

                    // Content
                    if (ptc->hTheme)
                    {
                        RECT rcc;
                        RECT rcBack = rcBody;

                        GetClientRect(ptc->ci.hwnd, &rcc);

                        // Determine what part is currently being rendered
                        ptc->iPartId = TABP_TABITEM;

                        if (pitem->rc.left == g_cxEdge)
                            ptc->iPartId = TABP_TABITEMLEFTEDGE;

                        if ((pitem->rc.right >= (rcc.right - 2 * g_cxEdge)) || ((i + 1) == cItems))
                            ptc->iPartId = (ptc->iPartId == TABP_TABITEMLEFTEDGE) ? TABP_TABITEMBOTHEDGE : TABP_TABITEMRIGHTEDGE;

                        if (pitem->rc.top == g_cyEdge)
                        {
                            switch (ptc->iPartId)
                            {
                            case TABP_TABITEM:
                                ptc->iPartId = TABP_TOPTABITEM;
                                break;

                            case TABP_TABITEMLEFTEDGE:
                                ptc->iPartId = TABP_TOPTABITEMLEFTEDGE;
                                break;

                            case TABP_TABITEMRIGHTEDGE:
                                ptc->iPartId = TABP_TOPTABITEMRIGHTEDGE;
                                break;

                            case TABP_TABITEMBOTHEDGE:
                                ptc->iPartId = TABP_TOPTABITEMBOTHEDGE;
                                break;
                            }
                        }

                        Tab_DrawEdge(hdc, &rcBack, EDGE_RAISED, 
                                     BF_LEFT | BF_TOP | BF_RIGHT | BF_SOFT,
                                     ptc);

                        Tab_DrawBody(hdc, ptc, pitem, &rcBody, ptc->iSel, FALSE, 0,-g_cyEdge);
                    }
                    else
                    {
                        Tab_DrawBody(hdc, ptc, pitem, &rcBody, ptc->iSel, FALSE, 0,-g_cyEdge);

                        rcBody.bottom--;  //because of button softness
                        Tab_DrawEdge(hdc, &rcBody, EDGE_RAISED, 
                                     BF_LEFT | BF_TOP | BF_RIGHT | BF_SOFT,
                                     ptc);
                    }

                    // Edges
                    Tab_DoCorners(hdc, &rcBody, ptc, FALSE);

                    // draw that extra bit on the left or right side
                    // if we're on the edge
                    rcBody.bottom++;
                    rcBody.top = rcBody.bottom-1;
                    if (rcBody.right == rcClient.right)
                    {
                        uWhichEdges = BF_SOFT | BF_RIGHT;

                    }
                    else if (rcBody.left == rcClient.left) 
                    {
                        uWhichEdges = BF_SOFT | BF_LEFT;
                    }
                    else
                    {
                        uWhichEdges = 0;
                    }

                    if (!ptc->hTheme)
                    {
                        if (uWhichEdges)
                            Tab_DrawEdge(hdc, &rcBody, EDGE_RAISED, uWhichEdges, ptc);
                    }
                }
            }

        }

        if (GetFocus() == hwnd)
        {
            if (!pitem && (ptc->iNewSel != -1))
            {
                pitem = Tab_GetItemPtr(ptc, ptc->iNewSel);
            }

            if (pitem && !(CCGetUIState(&(ptc->ci))& UISF_HIDEFOCUS))
            {
                rcBody = pitem->rc;
                if (Tab_DrawButtons(ptc))
                    InflateRect(&rcBody, -g_cxEdge, -g_cyEdge);
                else
                    InflateRect(&rcBody, -(g_cxEdge/2), -(g_cyEdge/2));
                Tab_DrawFocusRect(hdc, &rcBody, ptc);
            }
        }
    }

    if (hdcIn == NULL)
        EndPaint(hwnd, &ps);
}

int Tab_FindTab(PTC ptc, int iStart, UINT vk)
{
    int iRow;
    int x;
    int i;
    LPTABITEM pitem = Tab_GetItemPtr(ptc, iStart);

    if (!pitem)
    {
        return(0);
    }

    iRow=  pitem->iRow  + ((vk == VK_UP) ? -1 : 1);
    x = (pitem->rc.right + pitem->rc.left) / 2;

    // find the and item on the iRow at horizontal x
    if (iRow > ptc->iLastRow || iRow < 0)
        return iStart;

    // this relies on the ordering of tabs from left to right , but
    // not necessarily top to bottom.
    for (i = Tab_Count(ptc) - 1 ; i >= 0; i--) {
        pitem = Tab_FastGetItemPtr(ptc, i);
        if (pitem->iRow == iRow) {
            if (pitem->rc.left < x)
                return i;
        }
    }

    // this should never happen.. we should have caught this case in the iRow check
    // right before the for loop.
    ASSERT(0);
    return iStart;
}

void Tab_SetCurFocus(PTC ptc, int iStart)
{

    if (Tab_DrawButtons(ptc)) {
        if ((iStart >= 0) && (iStart < Tab_Count(ptc)) && (ptc->iNewSel != iStart)) {
            if (ptc->iNewSel != -1)
                Tab_InvalidateItem(ptc, ptc->iNewSel, FALSE);
            Tab_InvalidateItem(ptc, iStart, FALSE);
            ptc->iNewSel = iStart;
            ptc->flags |= TCF_DRAWSUNKEN;
            
            if (!Tab_MultiLine(ptc)) {
                // scroll into view if necessary
                RECT rc;
                do {
                    Tab_OnGetItemRect(ptc, iStart, &rc);
                    if (rc.right > ptc->cxTabs) {
                        Tab_OnHScroll(ptc, NULL, SB_THUMBPOSITION, ptc->iFirstVisible + 1);
                    } else if (rc.left < 0) {
                        Tab_OnHScroll(ptc, NULL, SB_THUMBPOSITION, iStart);
                        break;
                    } else {
                        break;
                    }
                } while (1);
            }
            
            CCSendNotify(&ptc->ci, TCN_FOCUSCHANGE, NULL);
            NotifyWinEvent(EVENT_OBJECT_FOCUS, ptc->ci.hwnd, OBJID_CLIENT,
                iStart+1);
        }
    } else
    {
        int iOld = ptc->iSel;

        ChangeSel(ptc, iStart, TRUE, FALSE);

        if ((iOld != ptc->iSel) && (GetFocus() == ptc->ci.hwnd))
            NotifyWinEvent(EVENT_OBJECT_FOCUS, ptc->ci.hwnd, OBJID_CLIENT,
                ptc->iSel+1);
    }
}

void Tab_OnKeyDown(PTC ptc, UINT vk, BOOL fDown, int cRepeat, UINT flags)
{
    int iStart;
    TC_KEYDOWN nm;

    // Notify
    nm.wVKey = (WORD) vk;
    nm.flags = flags;
    // pass NULL for parent because W95 queryied each time and some
    // folks reparent
    SendNotifyEx(NULL, ptc->ci.hwnd, TCN_KEYDOWN, &nm.hdr, ptc->ci.bUnicode);

    if (Tab_DrawButtons(ptc)) {
        ptc->flags |= (TCF_DRAWSUNKEN|TCF_MOUSEDOWN);
        if (ptc->iNewSel != -1) {
            iStart = ptc->iNewSel;
        } else {
            iStart = ptc->iSel;
        }
    } else {
        iStart = ptc->iSel;
    }

    vk = RTLSwapLeftRightArrows(&ptc->ci, vk);

    if (Tab_Vertical(ptc)) {
        // remap arrow keys if we're in vertial mode
        switch(vk) {
        case VK_LEFT:
            vk = VK_DOWN;
            break;
            
        case VK_RIGHT:
            vk = VK_UP;
            break;
            
        case VK_DOWN:
            vk = VK_RIGHT;
            break;
            
        case VK_UP:
            vk = VK_LEFT;
            break;
        }
    }

    switch (vk) {

    case VK_LEFT:
        iStart--;
        break;

    case VK_RIGHT:
        iStart++;
        break;

    case VK_UP:
    case VK_DOWN:
        if (iStart != -1) {
            iStart = Tab_FindTab(ptc, iStart, vk);
            break;
        } // else fall through to set iStart = 0;

    case VK_HOME:
        iStart = 0;
        break;

    case VK_END:
        iStart = Tab_Count(ptc) - 1;
        break;

    case VK_SPACE:
        if (!Tab_DrawButtons(ptc))
            return;
        // else fall through...  in button mode space does selection

    case VK_RETURN:
        ChangeSel(ptc, iStart, TRUE, FALSE);
        ptc->iNewSel = -1;
        ptc->flags &= ~TCF_DRAWSUNKEN;
        //notify of navigation key usage
        CCNotifyNavigationKeyUsage(&(ptc->ci), UISF_HIDEFOCUS | UISF_HIDEACCEL);
        return;

    default:
        return;
    }

    if (iStart < 0)
        iStart = 0;

    Tab_SetCurFocus(ptc, iStart);
    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(ptc->ci), UISF_HIDEFOCUS | UISF_HIDEACCEL);
}

void Tab_Size(PTC ptc)
{
    ptc->cxItem = RECOMPUTE;
    Tab_UpdateArrows(ptc, TRUE);
}

BOOL Tab_OnGetItemRect(PTC ptc, int iItem, LPRECT lprc)
{
    LPTABITEM pitem = Tab_GetItemPtr(ptc, iItem);
    BOOL fRet = FALSE;

    if (lprc) 
    {
        Tab_CalcPaintMetrics(ptc, NULL);
        if (pitem) 
        {

            // Make sure all the item rects are up-to-date

            *lprc = pitem->rc;
            fRet = TRUE;
        }
        else 
        {
            lprc->top = 0;
            lprc->bottom = ptc->cyTabs;
            lprc->right = 0;
            lprc->left = 0;
        }

        Tab_VDFlipRect(ptc, lprc);
        
    }
    return fRet;
}

void Tab_StyleChanged(PTC ptc, UINT gwl,  LPSTYLESTRUCT pinfo)
{
#define STYLE_MASK   (TCS_BUTTONS | TCS_VERTICAL | TCS_MULTILINE | TCS_RAGGEDRIGHT | TCS_FIXEDWIDTH | TCS_FORCELABELLEFT | TCS_FORCEICONLEFT | TCS_BOTTOM | TCS_RIGHT | TCS_FLATBUTTONS | TCS_OWNERDRAWFIXED | TCS_HOTTRACK)
    if (ptc && (gwl == GWL_STYLE)) {

        DWORD dwChanged = (ptc->ci.style & STYLE_MASK) ^ (pinfo->styleNew & STYLE_MASK);
        // special case.  this is "Insider Trading" app (by papyrus, now kanisa).  they set the 3 on the low byte in ie3 comctl32 when it
        // had no meaning anyways. so we bail on that.
        if (ptc->ci.style == 0x50004000 && pinfo->styleNew == 0x54004003)
            return;
        if (dwChanged) {
            ptc->ci.style = (ptc->ci.style & ~STYLE_MASK)  | (pinfo->styleNew & STYLE_MASK);

            // make sure we don't have invalid bits set
            if (!Tab_FixedWidth(ptc)) {
                ptc->ci.style &= ~(TCS_FORCEICONLEFT | TCS_FORCELABELLEFT);
            }
            ptc->cxItem = RECOMPUTE;
            ptc->cyTabs = RECOMPUTE;
            
            //if the left/right orientation changed
            // we need to re-create the font (if we own it)
            // becaus the text orientation needs to flip by 180
            if ((dwChanged & TCS_VERTICAL) ||
                ((dwChanged & TCS_RIGHT) && Tab_Vertical(ptc))) {
                if (!(ptc->flags & TCF_FONTSET))
                    Tab_OnSetFont(ptc, NULL, FALSE);
            }
                
            if (Tab_RedrawEnabled(ptc))
                Tab_UpdateArrows(ptc, TRUE);
            RedrawAll(ptc, RDW_ERASE | RDW_INVALIDATE);
        }

#define FOCUS_MASK (TCS_FOCUSONBUTTONDOWN | TCS_FOCUSNEVER)
        if ( (ptc->ci.style &  FOCUS_MASK) ^ (pinfo->styleNew & FOCUS_MASK)) {
            ptc->ci.style = (ptc->ci.style & ~FOCUS_MASK)  | (pinfo->styleNew & FOCUS_MASK);
        }
    }
    if (gwl == GWL_EXSTYLE) 
    {
        ptc->ci.dwExStyle &= ~WS_EX_RTLREADING;
        ptc->ci.dwExStyle |= (pinfo->styleNew & WS_EX_RTLREADING);       
    }
}


DWORD Tab_ExtendedStyleChange(PTC ptc, DWORD dwNewStyle, DWORD dwExMask)
{
    DWORD dwOldStyle = ptc->dwStyleEx;

    if (ptc->hDragProxy)
    {
        DestroyDragProxy(ptc->hDragProxy);
        ptc->hDragProxy = NULL;
    }

    if (dwExMask) 
        dwNewStyle = (ptc->dwStyleEx & ~ dwExMask) | (dwNewStyle & dwExMask);
    
    ptc->dwStyleEx = dwNewStyle;

    // do any invalidation or whatever is needed here.
    if ((dwOldStyle ^ dwNewStyle) & TCS_EX_FLATSEPARATORS)
    {
        InvalidateRect (ptc->ci.hwnd, NULL, TRUE);
    }

    if (ptc->dwStyleEx & TCS_EX_REGISTERDROP)
        ptc->hDragProxy = CreateDragProxy(ptc->ci.hwnd, TabDragCallback, TRUE);

    return dwOldStyle;
}


//
// APPCOMPAT Assumes that the tab control is on top.  Returns bogus values for
// left, bottom or right.  For app compat reasons, we can't change this
// buggy behavior. (Apps might be relying on the wrong values and fixing them
// up, so if we fix the function, they end up trying to "fix" something that
// wasn't broken, thereby breaking it.)  But we might want to add
// TCM_ADJUSTRECT2 that can handle the left/right/bottom cases.
//
void Tab_OnAdjustRect(PTC ptc, BOOL fGrow, LPRECT prc)
{
    int idy;
    Tab_CalcPaintMetrics(ptc, NULL);

    if (Tab_DrawButtons(ptc)) {
        if (Tab_Count(ptc)) {
            RECT rc;
            Tab_OnGetItemRect(ptc, Tab_Count(ptc) - 1, &rc);
            idy = rc.bottom;
        } else {
            idy = 0;
        }
    } else {
        idy = (ptc->cyTabs * (ptc->iLastRow + 1));
    }
    
    if (fGrow) {
        // calc a larger rect from the smaller
        prc->top -= idy;
        InflateRect(prc, g_cxEdge * 2, g_cyEdge * 2);
    } else {
        prc->top += idy;
        // given the bounds, calc the "client" area
        InflateRect(prc, -g_cxEdge * 2, -g_cyEdge * 2);
    }

    if (Tab_ScrollOpposite(ptc)) {
        // the sizes are the same, it's just offset wrong vertically
        idy = ptc->cyTabs * (ptc->iLastRow - ptc->iLastTopRow);
        ASSERT(ptc->iLastTopRow != -1);

        if (!fGrow) {
            idy *= -1;
        }
        DebugMsg(DM_TRACE, TEXT("Tab_AdjustRect %d %d %d %d"), prc->left, prc->top, prc->right, prc->bottom);
        OffsetRect(prc, 0, idy);
        DebugMsg(DM_TRACE, TEXT("Tab_AdjustRect %d %d %d %d"), prc->left, prc->top, prc->right, prc->bottom);
    }
}

// Tab_WndProc is theme aware
LRESULT CALLBACK Tab_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PTC ptc = (PTC)GetWindowInt((hwnd), 0);

    if (ptc)
    {
        if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST) &&
            Tab_HotTrack(ptc) && !ptc->fTrackSet)
        {

            TRACKMOUSEEVENT tme;

            ptc->fTrackSet = TRUE;
            tme.cbSize = sizeof(tme);
            tme.hwndTrack = ptc->ci.hwnd;
            tme.dwFlags = TME_LEAVE;

            TrackMouseEvent(&tme);
        }
        else
        {
            // Check for theme changes
            if (uMsg == WM_THEMECHANGED)
            {
                if (ptc->hTheme)
                    CloseThemeData(ptc->hTheme);

                ptc->hTheme = (!Tab_OwnerDraw(ptc) && !Tab_DrawButtons(ptc)) ? OpenThemeData(ptc->ci.hwnd, L"Tab") : NULL;

                // Active hot state if themes are in use
                if (ptc->hTheme)
                    ptc->ci.style |= TCS_HOTTRACK;
                else
                    ptc->ci.style &= ~TCS_HOTTRACK;

                // Recompute metrics since font may have changed
                ptc->cxItem = RECOMPUTE;
                ptc->cyTabs = RECOMPUTE;

                InvalidateRect(ptc->ci.hwnd, NULL, TRUE);
            }
        }

    } else if (uMsg != WM_CREATE)
        goto DoDefault;
    
    switch (uMsg) {

    HANDLE_MSG(ptc, WM_HSCROLL, Tab_OnHScroll);
    
    case WM_MOUSELEAVE:
        Tab_InvalidateItem(ptc, ptc->iHot, FALSE);
        ptc->iHot = -1;
        ptc->fTrackSet = FALSE;
        break;

    case WM_CREATE:

        InitGlobalColors();
        ptc = (PTC)NearAlloc(sizeof(TC));
        if (!ptc)
            return -1;  // fail the window create

        SetWindowPtr(hwnd, 0, ptc);
        CIInitialize(&ptc->ci, hwnd, (LPCREATESTRUCT)lParam);

        if (!Tab_OnCreate(ptc))
            return -1;

        break;

    case WM_DESTROY:
        Tab_OnDestroy(ptc);
        break;

    case WM_SIZE:
        Tab_Size(ptc);
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        if (!(ptc->flags & TCF_FONTSET))
            Tab_OnSetFont(ptc, NULL, FALSE);
        RedrawAll(ptc, RDW_INVALIDATE | RDW_ERASE);
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        if ((wParam == SPI_SETNONCLIENTMETRICS) ||
            (!wParam && !lParam))
            RedrawAll(ptc, RDW_INVALIDATE | RDW_ERASE);
        break;

    case WM_ERASEBKGND:
        // Background fill will happen in Tab_Paint if themes are active
        if (ptc->hTheme)
            return 1;
        goto DoDefault;        

    case WM_PRINTCLIENT:
    case WM_PAINT:
        Tab_Paint(ptc, (HDC)wParam);
        break;

    case WM_STYLECHANGED:
        Tab_StyleChanged(ptc, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        break;

    case WM_MOUSEMOVE:
        RelayToToolTips(ptc->hwndToolTips, hwnd, uMsg, wParam, lParam);
        Tab_OnMouseMove(ptc, wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        break;

    case WM_LBUTTONDOWN:
        RelayToToolTips(ptc->hwndToolTips, hwnd, uMsg, wParam, lParam);
        Tab_OnLButtonDown(ptc, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), wParam);
        break;
        
    case WM_LBUTTONDBLCLK:
        if (Tab_DrawButtons(ptc)) {
            MSG msg;
            // on the double click, grab capture until we get the lbutton up and
            // eat it.
            SetCapture(ptc->ci.hwnd);
            while (GetCapture() == ptc->ci.hwnd && 
                   !PeekMessage(&msg, ptc->ci.hwnd, WM_LBUTTONUP, WM_LBUTTONUP, PM_REMOVE)) 
            {
            }
            CCReleaseCapture(&ptc->ci);
        }
        break;

    case WM_MBUTTONDOWN:
        SetFocus(hwnd);
        break;

    case WM_RBUTTONDOWN:
        Tab_OnRButtonDown(ptc, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), wParam);
        break;
        
    case WM_RBUTTONUP:
        // pass NULL for parent because W95 queryied each time and some
        // folks reparent
        if (!SendNotifyEx(NULL, ptc->ci.hwnd, NM_RCLICK, NULL, ptc->ci.bUnicode))
            goto DoDefault;
        break;

    case WM_CAPTURECHANGED:
        lParam = -1L; // fall through to LBUTTONUP

    case WM_LBUTTONUP:
        if (uMsg == WM_LBUTTONUP) {
            RelayToToolTips(ptc->hwndToolTips, hwnd, uMsg, wParam, lParam);
        }

        Tab_OnButtonUp(ptc, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (uMsg == WM_LBUTTONUP));
        break;

    case WM_SYSKEYDOWN:
        //notify of navigation key usage
        if (HIWORD(lParam) & KF_ALTDOWN)
            CCNotifyNavigationKeyUsage(&(ptc->ci), UISF_HIDEFOCUS | UISF_HIDEACCEL);
        goto DoDefault;

    case WM_KEYDOWN:
        HANDLE_WM_KEYDOWN(ptc, wParam, lParam, Tab_OnKeyDown);
        break;

    case WM_KILLFOCUS:

        if (ptc->iNewSel != -1) {
            int iOldSel = ptc->iNewSel;
            ptc->iNewSel = -1;
            Tab_InvalidateItem(ptc, iOldSel, FALSE);
            ptc->flags &= ~TCF_DRAWSUNKEN;
        }
        // fall through
    case WM_SETFOCUS:
        Tab_InvalidateItem(ptc, ptc->iSel, Tab_OwnerDraw(ptc));
        if ((uMsg == WM_SETFOCUS) && (ptc->iSel != -1))
            NotifyWinEvent(EVENT_OBJECT_FOCUS, hwnd, OBJID_CLIENT, ptc->iSel+1);
        break;

    case WM_GETDLGCODE:
        return DLGC_WANTARROWS | DLGC_WANTCHARS;

    HANDLE_MSG(ptc, WM_SETREDRAW, Tab_OnSetRedraw);
    HANDLE_MSG(ptc, WM_SETFONT, Tab_OnSetFont);

    case WM_GETFONT:
        return (LRESULT)ptc->hfontLabel;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&ptc->ci, lParam);

    case WM_NOTIFY: {
        LPNMHDR lpNmhdr = (LPNMHDR)(lParam);

        //
        // We are just going to pass this on to the
        // real parent.  Note that -1 is used as
        // the hwndFrom.  This prevents SendNotifyEx
        // from updating the NMHDR structure.
        //

        SendNotifyEx(GetParent(ptc->ci.hwnd), (HWND) -1,
                     lpNmhdr->code, lpNmhdr, ptc->ci.bUnicode);
        }
        break;

    case WM_UPDATEUISTATE:
        if (CCOnUIState(&(ptc->ci), WM_UPDATEUISTATE, wParam, lParam))
        {
            if (UISF_HIDEFOCUS == HIWORD(wParam))
            {
                // We erase only if we are removing the focus rect or the accel
                Tab_InvalidateItem(ptc, ptc->iSel,
                    (UIS_CLEAR == LOWORD(wParam)) ? TRUE : FALSE);
            }
            else
            {
                if ((UISF_HIDEFOCUS | UISF_HIDEACCEL) & HIWORD(wParam))
                {
                    int i;

                    for (i = ptc->iFirstVisible; i <= ptc->iLastVisible; ++i)
                    {
                        Tab_InvalidateItem(ptc, i,
                            (UIS_CLEAR == LOWORD(wParam)) ? TRUE : FALSE);
                    }
                }
            }
        }

        goto DoDefault;

    case TCM_SETITEMEXTRA:
        return (LRESULT)Tab_OnSetItemExtra(ptc, (int)wParam);

    case TCM_GETITEMCOUNT:
        return (LRESULT)Tab_Count(ptc);

    case TCM_SETITEMA:
    {
        LRESULT lResult;
        TC_ITEMW * pItemW;

        if (!lParam)
        {
            return FALSE;
        }

        pItemW = ThunkItemAtoW(ptc, (TC_ITEMA*)lParam);

        if (!pItemW) 
        {
            return FALSE;
        }

        lResult = (LRESULT)Tab_OnSetItem(ptc, (int)wParam, pItemW);

        FreeItemW(pItemW);

        return lResult;
    }

    case TCM_SETITEM:
        if (!lParam)
        {
            return FALSE;
        }

        return (LRESULT)Tab_OnSetItem(ptc, (int)wParam, (const TC_ITEM*)lParam);

    case TCM_GETITEMA:
    {
        LRESULT lResult;
        TC_ITEMW * pItemW;
        LPWSTR pszTextW = NULL;
        TC_ITEMA * pItemA = (TC_ITEMA*)lParam;

        if (!ptc || !pItemA)
        {
            return FALSE;
        }

        pItemW = GlobalAlloc (GPTR, sizeof(TC_ITEMW) + ptc->cbExtra);

        if (!pItemW) 
        {
            return FALSE;
        }

        if (pItemA->mask & TCIF_TEXT) 
        {
            pszTextW = GlobalAlloc (GPTR, pItemA->cchTextMax * sizeof (TCHAR));

            if (!pszTextW) 
            {
                GlobalFree (pItemW);
                return FALSE;
            }
            pItemW->pszText = pszTextW;
        }

        pItemW->mask       = pItemA->mask;
        pItemW->cchTextMax = pItemA->cchTextMax;
        pItemW->dwStateMask = pItemA->dwStateMask;

        lResult = (LRESULT)Tab_OnGetItem(ptc, (int)wParam, pItemW);

        if (!ThunkItemWtoA (ptc, pItemW, pItemA))
        {
            lResult = (LRESULT)FALSE;
        }

        if (pszTextW) 
        {
            GlobalFree (pszTextW);
        }
        GlobalFree (pItemW);

        return lResult;
    }

    case TCM_GETITEM:
        if (!ptc || !lParam)
        {
            return FALSE;
        }

        return (LRESULT)Tab_OnGetItem(ptc, (int)wParam, (TC_ITEM*)lParam);

    case TCM_INSERTITEMA:
    {
        LRESULT  lResult;
        TC_ITEMW * pItemW;

        if (!lParam) 
        {
            return FALSE;
        }

        pItemW = ThunkItemAtoW(ptc, (TC_ITEMA*)lParam);

        if (!pItemW)
        {
            return FALSE;
        }

        lResult =  (LRESULT)Tab_OnInsertItem(ptc, (int)wParam, pItemW);

        FreeItemW(pItemW);

        return lResult;
    }

    case TCM_INSERTITEM:
        if (!lParam) 
        {
            return FALSE;
        }
        return (LRESULT)Tab_OnInsertItem(ptc, (int)wParam, (const TC_ITEM*)lParam);

    case TCM_DELETEITEM:
        return (LRESULT)Tab_OnDeleteItem(ptc, (int)wParam);

    case TCM_DELETEALLITEMS:
        return (LRESULT)Tab_OnDeleteAllItems(ptc);

    case TCM_SETCURFOCUS:
        Tab_SetCurFocus(ptc, (int) wParam);
        break;

    case TCM_GETCURFOCUS:
        if (ptc->iNewSel != -1)
            return ptc->iNewSel;
        // else fall through

    case TCM_GETCURSEL:
        return ptc->iSel;

    case TCM_SETCURSEL:
        return (LRESULT)ChangeSel(ptc, (int)wParam, FALSE, FALSE);

    case TCM_GETTOOLTIPS:
        return (LRESULT)ptc->hwndToolTips;

    case TCM_SETTOOLTIPS:
        ptc->hwndToolTips = (HWND)wParam;
        break;

    case TCM_ADJUSTRECT:
        if (lParam) 
        {
            RECT* prc = (RECT *)lParam;
            Tab_DVFlipRect(ptc, prc);
            Tab_OnAdjustRect(ptc, BOOLFROMPTR( wParam), (LPRECT)lParam);
            Tab_VDFlipRect(ptc, prc);
        } 
        else
            return -1;
        break;
        
    case TCM_GETITEMRECT:
        return Tab_OnGetItemRect(ptc, (int)wParam, (LPRECT)lParam);

    case TCM_SETIMAGELIST: 
        {
        HIMAGELIST himlOld = ptc->himl;
        ptc->himl = (HIMAGELIST)lParam;
        ptc->cxItem = ptc->cyTabs = RECOMPUTE;
        RedrawAll(ptc, RDW_INVALIDATE | RDW_ERASE);
        return (LRESULT)himlOld;
    }

    case TCM_GETIMAGELIST:
        return (LRESULT)ptc->himl;

    case TCM_REMOVEIMAGE:
        Tab_OnRemoveImage(ptc, (int)wParam);
        break;

    case TCM_SETITEMSIZE:
        {
        int iOldWidth = ptc->iTabWidth;
        int iOldHeight = ptc->iTabHeight;
        int iNewWidth = LOWORD(lParam);
        int iNewHeight = HIWORD(lParam);

        if (ptc->himl) 
        {
            int cx, cy;
            Tab_ImageList_GetIconSize(ptc, &cx, &cy);
            if (iNewWidth < (cx + (2*g_cxEdge)))
                iNewWidth = cx + (2*g_cxEdge);

        }
        ptc->iTabWidth = iNewWidth;
        ptc->iTabHeight = iNewHeight;

        if (iNewWidth != iOldWidth ||
            iNewHeight != iOldHeight)
        {
            ptc->cxItem = RECOMPUTE;
            ptc->cyTabs = RECOMPUTE;
            RedrawAll(ptc, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
        }

        return (LRESULT)MAKELONG(iOldWidth, iOldHeight);
    }

    case TCM_SETPADDING:
        ptc->cxPad = GET_X_LPARAM(lParam);
        ptc->cyPad = GET_Y_LPARAM(lParam);
        break;

    case TCM_GETROWCOUNT:
        Tab_CalcPaintMetrics(ptc, NULL);
        return (LRESULT)ptc->iLastRow + 1;
        
    case TCM_SETMINTABWIDTH:
    {
        int iOld = ptc->cxMinTab;
        if ((int)lParam >= 0) 
        {
            ptc->cxMinTab = (int)lParam;
            ptc->fMinTabSet = TRUE;
        }
        else
        {
            ptc->fMinTabSet = FALSE;
        }
        ptc->cyTabs = RECOMPUTE;
        ptc->cxItem = RECOMPUTE;
        InvalidateRect(ptc->ci.hwnd, NULL, TRUE);
        return iOld;
    }
        
    case TCM_DESELECTALL:
        Tab_DeselectAll(ptc, BOOLFROMPTR( wParam));
        break;

    case TCM_SETEXTENDEDSTYLE:
        return Tab_ExtendedStyleChange(ptc, (DWORD) lParam, (DWORD) wParam);

    case TCM_GETEXTENDEDSTYLE:
        return ptc->dwStyleEx;

    case TCM_HITTEST: 
    {
        LPTC_HITTESTINFO lphitinfo  = (LPTC_HITTESTINFO)lParam;
        return Tab_OnHitTest(ptc, lphitinfo->pt.x, lphitinfo->pt.y, &lphitinfo->flags);
    }

    case TCM_HIGHLIGHTITEM:
    {
        LPTABITEM pitem = Tab_GetItemPtr(ptc, (int)wParam);

        if (pitem)
        {
            BOOL fHighlight = LOWORD(lParam) != 0;

            // Don't do anything if state hasn't changed.
            if (fHighlight == ((pitem->dwState & TCIS_HIGHLIGHTED) != 0))
                break;

            if (fHighlight)
                pitem->dwState |= TCIS_HIGHLIGHTED;
            else
                pitem->dwState &= ~TCIS_HIGHLIGHTED;

            Tab_InvalidateItem(ptc, (int)wParam, TRUE);
            return TRUE;
        }
        break;
    }

    case WM_NCHITTEST:
    {
        POINT pt;
            
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        ScreenToClient(ptc->ci.hwnd, &pt);
        if (Tab_OnHitTest(ptc, pt.x, pt.y, NULL) == -1)
            return(HTTRANSPARENT);
        else {
            goto DoDefault;
        }
    }

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_TAB;
        break;

    default:
    {
        LRESULT lres;
        if (CCWndProc(&ptc->ci, uMsg, wParam, lParam, &lres))
            return lres;
    }
    
DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0L;
}

//
// ANSI <=> UNICODE thunks
//

TC_ITEMW * ThunkItemAtoW (PTC ptc, TC_ITEMA * pItemA)
{
    TC_ITEMW *pItemW;
    UINT      cbTextW;
    INT       iResult;

    pItemW = (TC_ITEMW *) GlobalAlloc (GPTR, sizeof(TC_ITEMW) + ptc->cbExtra);

    if (!pItemW) {
        return NULL;
    }

    pItemW->mask        = pItemA->mask;
    pItemW->dwState = pItemA->dwState;
    pItemW->dwStateMask = pItemA->dwStateMask;

    if ((pItemA->mask & TCIF_TEXT) && pItemA->pszText) {
        cbTextW = lstrlenA(pItemA->pszText) + 1;

        pItemW->pszText = (LPWSTR)GlobalAlloc (GPTR, cbTextW * sizeof(TCHAR));

        if (!pItemW->pszText) {
            GlobalFree (pItemW);
            return NULL;
        }

        iResult = MultiByteToWideChar (CP_ACP, 0, pItemA->pszText, -1,
                                       pItemW->pszText, cbTextW);

        if (!iResult) {
            if (GetLastError()) {
                GlobalFree (pItemW->pszText);
                GlobalFree (pItemW);
                return NULL;
            }
        }
    }

    pItemW->cchTextMax = pItemA->cchTextMax;

    if (pItemA->mask & TCIF_IMAGE) {
        pItemW->iImage = pItemA->iImage;
    }

    if (pItemA->mask & TCIF_PARAM) {
        hmemcpy(&pItemW->lParam, &pItemA->lParam, ptc->cbExtra);
    }

    return (pItemW);
}

BOOL ThunkItemWtoA (PTC ptc, TC_ITEMW * pItemW, TC_ITEMA * pItemA)
{
    INT        iResult;


    if (!pItemA) {
        return FALSE;
    }

    pItemA->mask        = pItemW->mask;
    pItemA->dwState = pItemW->dwState;
    pItemA->dwStateMask = pItemW->dwStateMask;

    if ((pItemW->mask & TCIF_TEXT) && pItemW->pszText && pItemW->cchTextMax) {

        iResult = WideCharToMultiByte (CP_ACP, 0, pItemW->pszText, -1,
                                       pItemA->pszText, pItemW->cchTextMax, NULL, NULL);

        if (!iResult) {
            if (GetLastError()) {
                return FALSE;
            }
        }
    }

    pItemA->cchTextMax = pItemW->cchTextMax;

    if (pItemW->mask & TCIF_IMAGE) {
        pItemA->iImage = pItemW->iImage;
    }

    if (pItemW->mask & TCIF_PARAM) {
        hmemcpy(&pItemA->lParam, &pItemW->lParam, ptc->cbExtra);
    }

    return TRUE;
}

BOOL FreeItemW (TC_ITEMW *pItemW)
{

    if ((pItemW->mask & TCIF_TEXT) && pItemW->pszText) {
        GlobalFree (pItemW->pszText);
    }

    GlobalFree (pItemW);

    return TRUE;
}

BOOL FreeItemA (TC_ITEMA *pItemA)
{

    if ((pItemA->mask & TCIF_TEXT) && pItemA->pszText) {
        GlobalFree (pItemA->pszText);
    }

    GlobalFree (pItemA);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\tab.h ===
typedef struct 
{ // ti
    RECT rc;        // for hit testing and drawing
    int iImage;     // image index
    int xLabel;     // position of the text for drawing (relative to rc)
    int yLabel;     // (relative to rc)
    int cxLabel;    // width of the label.  this is needed if we're drawing in vertical mode
    
    int xImage;     // Position of the icon for drawing (relative to rc)
    int yImage;
    int iRow;           // what row is it in?
    LPTSTR pszText;
    
    DWORD dwState;
    
    UINT etoRtlReading;
    
    union 
    {
        LPARAM lParam;
        BYTE   abExtra[1];
    }DUMMYUNIONNAME;
} TABITEM, *LPTABITEM;

typedef struct 
{
    CCONTROLINFO ci;
    
    HWND hwndArrows;    // Hwnd Arrows.
    HDPA hdpa;          // item array structure
    UINT flags;         // TCF_ values (internal state bits)
    int  cbExtra;       // extra bytes allocated for each item
    DWORD dwStyleEx;    // set by TCM_SETEXTENDEDSTYLE
    HFONT hfontLabel;   // font to use for labels
    int iSel;           // index of currently-focused item
    int iNewSel;        // index of next potential selection

    int cxItem;         // width of all tabs
    int cxMinTab;       // width of minimum tab
    int cyTabs;         // height of a row of tabs
    int cxTabs;     // The right hand edge where tabs can be painted.

    int cxyArrows;      // width and height to draw arrows
    int iFirstVisible;  // the index of the first visible item.
                        // wont fit and we need to scroll.
    int iLastVisible;   // Which one was the last one we displayed?

    int cxPad;           // Padding space between edges and text/image
    int cyPad;           // should be a multiple of c?Edge

    int iTabWidth;      // size of each tab in fixed width mode
    int iTabHeight;     // settable size of each tab
    int iLastRow;       // number of the last row.
    int iLastTopRow;    // the number of the last row that's on top (SCROLLOPPOSITE mode)

    int cyText;         // where to put the text vertically
    int cyIcon;         // where to put the icon vertically

    HIMAGELIST himl;    // images,
    HWND hwndToolTips;
    HIMC hPrevImc;      // previous input context handle
    HDRAGPROXY hDragProxy;
    DWORD dwDragDelay;  // delay for auto page-change during drag
    int iDragTab;       // last tab dragged over

    int tmHeight;    // text metric height
    BOOL fMinTabSet:1;  // have they set the minimum tab width
    BOOL fTrackSet:1;
    
    int iHot; 

    HTHEME hTheme;      // Theme support
    int iPartId;        // Theme support
    int iStateId;       // Theme support

} TC, *PTC;

#ifndef TCS_MULTISELECT 
#define TCS_MULTISELECT  0x0004
#endif

#define HASIMAGE(ptc, pitem) (ptc->himl && pitem->iImage != -1)

// tab control flag values
#define TCF_FOCUSED     0x0001
#define TCF_MOUSEDOWN   0x0002
#define TCF_DRAWSUNKEN  0x0004
#define TCF_REDRAW      0x0010  /* Value from WM_SETREDRAW message */
#define TCF_BUTTONS     0x0020  /* draw using buttons instead of tabs */

#define TCF_FONTSET     0x0040  /* if this is set, they set the font */
#define TCF_FONTCREATED 0x0080  

#define ID_ARROWS       1

#define TAB_DRAGDELAY   500

// Some helper macros for checking some of the flags...
#define Tab_RedrawEnabled(ptc)          (ptc->flags & TCF_REDRAW)
#define Tab_Count(ptc)                  DPA_GetPtrCount((ptc)->hdpa)
#define Tab_GetItemPtr(ptc, i)          ((LPTABITEM)DPA_GetPtr((ptc)->hdpa, (i)))
#define Tab_FastGetItemPtr(ptc, i)      ((LPTABITEM)DPA_FastGetPtr((ptc)->hdpa, (i)))
#define Tab_IsItemOnBottom(ptc, pitem)  ((BOOL)pitem->iRow > ptc->iLastTopRow)
#define Tab_DrawSunken(ptc)             ((BOOL)(ptc)->flags & TCF_DRAWSUNKEN)

#define Tab_DrawButtons(ptc)            ((BOOL)(ptc->ci.style & TCS_BUTTONS))
#define Tab_MultiLine(ptc)              ((BOOL)(ptc->ci.style & TCS_MULTILINE))
#define Tab_RaggedRight(ptc)            ((BOOL)(ptc->ci.style & TCS_RAGGEDRIGHT))
#define Tab_FixedWidth(ptc)             ((BOOL)(ptc->ci.style & TCS_FIXEDWIDTH))
#define Tab_Vertical(ptc)               ((BOOL)(ptc->ci.style & TCS_VERTICAL))
#define Tab_Bottom(ptc)                 ((BOOL)(ptc->ci.style & TCS_BOTTOM))
#define Tab_ScrollOpposite(ptc)        ((BOOL)(ptc->ci.style & TCS_SCROLLOPPOSITE))
#define Tab_ForceLabelLeft(ptc)         ((BOOL)(ptc->ci.style & TCS_FORCELABELLEFT))
#define Tab_ForceIconLeft(ptc)          ((BOOL)(ptc->ci.style & TCS_FORCEICONLEFT))
#define Tab_FocusOnButtonDown(ptc)      ((BOOL)(ptc->ci.style & TCS_FOCUSONBUTTONDOWN))
#define Tab_OwnerDraw(ptc)              ((BOOL)(ptc->ci.style & TCS_OWNERDRAWFIXED))
#define Tab_FocusNever(ptc)             ((BOOL)(ptc->ci.style & TCS_FOCUSNEVER))
#define Tab_HotTrack(ptc)             ((BOOL)(ptc->ci.style & TCS_HOTTRACK))
#define Tab_MultiSelect(ptc)            ((BOOL)(ptc->ci.style & TCS_MULTISELECT))
#define Tab_FlatButtons(ptc)            ((BOOL)((ptc)->ci.style & TCS_FLATBUTTONS))

#define Tab_FlatSeparators(ptc)         ((BOOL)((ptc)->dwStyleEx & TCS_EX_FLATSEPARATORS))

#ifdef __cplusplus
extern "C"
{
#endif

LRESULT CALLBACK Tab_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
void Tab_InvalidateItem(PTC ptc, int iItem, BOOL bErase);
void Tab_CalcPaintMetrics(PTC ptc, HDC hdc);
void Tab_OnHScroll(PTC ptc, HWND hwndCtl, UINT code, int pos);
void Tab_OnAdjustRect(PTC ptc, BOOL fGrow, LPRECT prc);
BOOL Tab_FreeItem(PTC ptc, TABITEM* pitem);
void Tab_UpdateArrows(PTC ptc, BOOL fSizeChanged);
int ChangeSel(PTC ptc, int iNewSel,  BOOL bSendNotify, BOOL bUpdateCursorPos);
BOOL RedrawAll(PTC ptc, UINT uFlags);
BOOL Tab_Init(HINSTANCE hinst);
void UpdateToolTipRects(PTC ptc);
BOOL Tab_OnGetItem(PTC ptc, int iItem, TC_ITEM* ptci);
int Tab_OnHitTest(PTC ptc, int x, int y, UINT *lpuFlags);

#ifdef UNICODE
//
// ANSI <=> UNICODE thunks
//

TC_ITEMW * ThunkItemAtoW (PTC ptc, TC_ITEMA * pItemA);
BOOL ThunkItemWtoA (PTC ptc, TC_ITEMW * pItemW, TC_ITEMA * pItemA);
BOOL FreeItemW (TC_ITEMW *pItemW);
BOOL FreeItemA (TC_ITEMA *pItemA);
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\strings.c ===
//============================================================================
//
// DBCS aware string routines...
//
//
//============================================================================

//#if defined(UNIX) && !defined(UNICODE)
//#define UNICODE
//#endif


#include "ctlspriv.h"
#include <winnlsp.h>    // Get private NORM_ flag for StrEqIntl()

// for those of us who don't ssync to nt's build headers
#ifndef NORM_STOP_ON_NULL
#define NORM_STOP_ON_NULL   0x10000000
#endif

// WARNING: all of these APIs do not setup DS, so you can not access
// any data in the default data seg of this DLL.
//
// do not create any global variables... talk to chrisg if you don't
// understand thid
#define READNATIVEWORD(x) (*(UNALIGNED WORD *)x)


/*
 * StrEndN - Find the end of a string, but no more than n bytes
 * Assumes   lpStart points to start of null terminated string
 *           nBufSize is the maximum length
 * returns ptr to just after the last byte to be included
 */
LPSTR lstrfns_StrEndNA(LPCSTR lpStart, int nBufSize)
{
  LPCSTR lpEnd;

  for (lpEnd = lpStart + nBufSize; *lpStart && OFFSETOF(lpStart) < OFFSETOF(lpEnd);
	lpStart = AnsiNext(lpStart))
    continue;   /* just getting to the end of the string */
  if (OFFSETOF(lpStart) > OFFSETOF(lpEnd))
    {
      /* We can only get here if the last byte before lpEnd was a lead byte
       */
      lpStart -= 2;
    }
  return((LPSTR)lpStart);
}

LPWSTR lstrfns_StrEndNW(LPCWSTR lpStart, int nBufSize)
{
  LPCWSTR lpEnd;

  for (lpEnd = lpStart + nBufSize; *lpStart && (lpStart < lpEnd);
	lpStart++)
    continue;   /* just getting to the end of the string */

  return((LPWSTR)lpStart);
}

/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
  /* Most of the time this won't match, so test it first for speed.
   */
  if (LOBYTE(w1) == LOBYTE(wMatch))
    {
      if (IsDBCSLeadByte(LOBYTE(w1)))
	{
	  return(w1 != wMatch);
	}
      return FALSE;
    }
  return TRUE;
}

BOOL ChrCmpA(WORD w1, WORD wMatch)
{
  return ChrCmpA_inline(w1, wMatch);
}

__inline BOOL ChrCmpW_inline(WCHAR w1, WCHAR wMatch)
{
    return(!(w1 == wMatch));
}

BOOL ChrCmpW(WCHAR w1, WCHAR wMatch)
{
   return ChrCmpW_inline(w1, wMatch);
}



/*
 * ChrCmpI - Case insensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared;
 *           HIBYTE of wMatch is 0 if not a DBC
 * Return    FALSE if match, TRUE if not
 */
BOOL ChrCmpIA(WORD w1, WORD wMatch)
{
  char sz1[3], sz2[3];

  if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1)))
    {
      sz1[1] = HIBYTE(w1);
      sz1[2] = '\0';
    }
  else
      sz1[1] = '\0';

  *(WORD *)sz2 = wMatch;
  sz2[2] = '\0';
  return lstrcmpiA(sz1, sz2);
}

BOOL ChrCmpIW(WCHAR w1, WCHAR wMatch)
{
  WCHAR sz1[2], sz2[2];

  sz1[0] = w1;
  sz1[1] = TEXT('\0');
  sz2[0] = wMatch;
  sz2[1] = TEXT('\0');

  return lstrcmpiW(sz1, sz2);
}

LPWSTR StrCpyW(LPWSTR psz1, LPCWSTR psz2)
{
    LPWSTR psz = psz1;
    do {
        *psz1 = *psz2;
        psz1++;
    } while(*psz2++);
    return psz;
}


LPWSTR StrCpyNW(LPWSTR psz1, LPCWSTR psz2, int cchMax)
{
    LPWSTR psz = psz1;

    ASSERT(psz1);
    ASSERT(psz2);

    if (0 < cchMax)
    {
        // Leave room for the null terminator
        while (0 < --cchMax)
        {
            if ( !(*psz1++ = *psz2++) )
                break;
        }

        if (0 == cchMax)
            *psz1 = '\0';
    }

    return psz;
}

/*
 * StrChr - Find first occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR StrChrA(LPCSTR lpStart, WORD wMatch)
{
  for ( ; *lpStart; lpStart = AnsiNext(lpStart))
    {
      if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
      {
	  return((LPSTR)lpStart);
      }
   }
   return (NULL);
}

LPWSTR StrChrSlowW(const UNALIGNED WCHAR *lpStart, WCHAR wMatch)
{
    for ( ; *lpStart; lpStart++)
    {
      if (!ChrCmpW_inline(*lpStart, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }
    return NULL;
}

LPWSTR StrChrW(LPCWSTR lpStart, WCHAR wMatch)
{
    //
    //  Apparently, somebody is passing unaligned strings to StrChrW.
    //  Find out who and make them stop.
    //
    ASSERT(!((ULONG_PTR)lpStart & 1)); // Assert alignedness

    for ( ; *lpStart; lpStart++)
    {
      if (!ChrCmpW_inline(*lpStart, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }

  return (NULL);
}

/*
 * StrRChr - Find last occurrence of character in string
 * Assumes   lpStart points to start of string
 *           lpEnd   points to end of string (NOT included in search)
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR StrRChrA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
  LPCSTR lpFound = NULL;

  if (!lpEnd)
      lpEnd = lpStart + lstrlenA(lpStart);

  for ( ; OFFSETOF(lpStart) < OFFSETOF(lpEnd); lpStart = AnsiNext(lpStart))
    {
      if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
	  lpFound = lpStart;
    }
  return ((LPSTR)lpFound);
}

LPWSTR StrRChrW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch)
{
  LPCWSTR lpFound = NULL;

  if (!lpEnd)
      lpEnd = lpStart + lstrlenW(lpStart);

  for ( ; lpStart < lpEnd; lpStart++)
    {
      if (!ChrCmpW_inline(*lpStart, wMatch))
	  lpFound = lpStart;
    }
  return ((LPWSTR)lpFound);
}


/*
 * StrRChrI - Find last occurrence of character in string, case insensitive
 * Assumes   lpStart points to start of string
 *           lpEnd   points to end of string (NOT included in search)
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR StrRChrIA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
  LPCSTR lpFound = NULL;

  if (!lpEnd)
      lpEnd = lpStart + lstrlenA(lpStart);

  wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch));

  for ( ; OFFSETOF(lpStart) < OFFSETOF(lpEnd); lpStart = AnsiNext(lpStart))
    {
      if (!ChrCmpIA(READNATIVEWORD(lpStart), wMatch))
          lpFound = lpStart;
    }
  return ((LPSTR)lpFound);
}

LPWSTR StrRChrIW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch)
{
  LPCWSTR lpFound = NULL;

  if (!lpEnd)
      lpEnd = lpStart + lstrlenW(lpStart);

  for ( ; lpStart < lpEnd; lpStart++)
    {
      if (!ChrCmpIW(*lpStart, wMatch))
          lpFound = lpStart;
    }
  return ((LPWSTR)lpFound);
}


// StrCSpn: return index to first char of lpStr that is present in lpSet.
// Includes the NUL in the comparison; if no lpSet chars are found, returns
// the index to the NUL in lpStr.
// Just like CRT strcspn.
//
int StrCSpnA(LPCSTR lpStr, LPCSTR lpSet)
{
	// nature of the beast: O(lpStr*lpSet) work
	LPCSTR lp = lpStr;
	if (!lpStr || !lpSet)
		return 0;

	while (*lp)
	{
 		if (StrChrA(lpSet, READNATIVEWORD(lp)))
			return (int)(lp-lpStr);
		lp = AnsiNext(lp);
	}

	return (int)(lp-lpStr); // ==lstrlen(lpStr)
}

int StrCSpnW(LPCWSTR lpStr, LPCWSTR lpSet)
{
	// nature of the beast: O(lpStr*lpSet) work
	LPCWSTR lp = lpStr;
	if (!lpStr || !lpSet)
		return 0;

	while (*lp)
	{
		if (StrChrW(lpSet, *lp))
			return (int)(lp-lpStr);
		lp++;
	}

	return (int)(lp-lpStr); // ==lstrlen(lpStr)
}


// StrCSpnI: case-insensitive version of StrCSpn.
//
int StrCSpnIA(LPCSTR lpStr, LPCSTR lpSet)
{
    // nature of the beast: O(lpStr*lpSet) work
    LPCSTR lp = lpStr;
    if (!lpStr || !lpSet)
            return 0;

    while (*lp)
    {
            if (StrChrIA(lpSet, READNATIVEWORD(lp)))
                    return (int)(lp-lpStr);
            lp = AnsiNext(lp);
    }

    return (int)(lp-lpStr); // ==lstrlen(lpStr)
}

int StrCSpnIW(LPCWSTR lpStr, LPCWSTR lpSet)
{
    // nature of the beast: O(lpStr*lpSet) work
    LPCWSTR lp = lpStr;
    if (!lpStr || !lpSet)
            return 0;

    while (*lp)
    {
            if (StrChrIW(lpSet, *lp))
                    return (int)(lp-lpStr);
            lp++;
    }

    return (int)(lp-lpStr); // ==lstrlen(lpStr)
}


/*
 * StrCmpN      - Compare n bytes
 *
 * returns   See lstrcmp return values.
 */
int StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar)
{
    char sz1[4];
    char sz2[4];
    LPCSTR lpszEnd = lpStr1 + nChar;

    //DebugMsg(DM_TRACE, "StrCmpN: %s %s %d returns:", lpStr1, lpStr2, nChar);

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1 = AnsiNext(lpStr1), lpStr2 = AnsiNext(lpStr2)) {
        WORD wMatch;


        wMatch = (WORD) (*lpStr2 | (*(lpStr2+1)<<8));

        if (ChrCmpA_inline(READNATIVEWORD(lpStr1), wMatch))
        {
            int iRet;

            (*(WORD *)sz1) = READNATIVEWORD(lpStr1);
            (*(WORD *)sz2) = wMatch;
            *AnsiNext(sz1) = 0;
            *AnsiNext(sz2) = 0;
            iRet = lstrcmpA(sz1, sz2);
            //DebugMsg(DM_TRACE, ".................... %d", iRet);
            return iRet;
        }
    }

    //DebugMsg(DM_TRACE, ".................... 0");
    return 0;
}

int StrCmpNW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar)
{
    WCHAR sz1[2];
    WCHAR sz2[2];
    int i;
    LPCWSTR lpszEnd = lpStr1 + nChar;

    //DebugMsg(DM_TRACE, "StrCmpN: %s %s %d returns:", lpStr1, lpStr2, nChar);

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1++, lpStr2++)
    {
        i = ChrCmpW_inline(*lpStr1, *lpStr2);
        if (i)
        {
            int iRet;

            sz1[0] = *lpStr1;
            sz2[0] = *lpStr2;
            sz1[1] = TEXT('\0');
            sz2[1] = TEXT('\0');
            iRet = lstrcmpW(sz1, sz2);
            //DebugMsg(DM_TRACE, ".................... %d", iRet);
            return iRet;
        }
    }

    //DebugMsg(DM_TRACE, ".................... 0");
    return 0;
}

/*
 * StrCmpNI     - Compare n bytes, case insensitive
 *
 * returns   See lstrcmpi return values.
 */


int StrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar)
{
    int i;
    
    //  Win95 doesn't support NORM_STOP_ON_NULL
    i = CompareStringA(GetThreadLocale(), NORM_IGNORECASE | NORM_STOP_ON_NULL, 
                       lpStr1, nChar, lpStr2, nChar);

    if (!i)
    {
        i = CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL, 
                             lpStr1, nChar, lpStr2, nChar);
    }

    return i - CSTR_EQUAL;    
}

int StrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar)
{
    int i;

    //  Win95 doesn't support NORM_STOP_ON_NULL
    i = CompareStringW(GetThreadLocale(), NORM_IGNORECASE | NORM_STOP_ON_NULL, 
                       lpStr1, nChar, lpStr2, nChar);

    if (!i)
    {
        i = CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL, 
                             lpStr1, nChar, lpStr2, nChar);
    }

    return i - CSTR_EQUAL;    
}

/*
 * IntlStrEq
 *
 * returns TRUE if strings are equal, FALSE if not
 */
BOOL IntlStrEqWorkerA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar) 
{
    int retval;
    DWORD dwFlags = fCaseSens ? LOCALE_USE_CP_ACP : (NORM_IGNORECASE | LOCALE_USE_CP_ACP);

    //
    // On NT we can tell CompareString to stop at a '\0' if one is found before nChar chars
    //
    dwFlags |= NORM_STOP_ON_NULL;
    retval = CompareStringA( GetThreadLocale(),
                             dwFlags,
                             lpString1,
                             nChar,
                             lpString2,
                             nChar );
    if (retval == 0)
    {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringA( GetSystemDefaultLCID(),
                                 dwFlags,
                                 lpString1,
                                 nChar,
                                 lpString2,
                                 nChar );
    }

    if (retval == 0)
    {
        if (lpString1 && lpString2)
        {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
            if (fCaseSens)
                retval = StrCmpNA(lpString1, lpString2, nChar) + 2;
            else {
                retval = StrCmpNIA(lpString1, lpString2, nChar) + 2;
            }
        }
        else
        {
            retval = 2;
        }
    }

    return (retval == 2);

}


BOOL IntlStrEqWorkerW(BOOL fCaseSens, LPCWSTR lpString1, LPCWSTR lpString2, int nChar) 
{
    int retval;
    DWORD dwFlags = fCaseSens ? 0 : NORM_IGNORECASE;

    //
    // On NT we can tell CompareString to stop at a '\0' if one is found before nChar chars
    //
    dwFlags |= NORM_STOP_ON_NULL;

    retval = CompareStringW( GetThreadLocale(),
                             dwFlags,
                             lpString1,
                             nChar,
                             lpString2,
                             nChar );
    if (retval == 0)
    {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringW( GetSystemDefaultLCID(),
                                 dwFlags,
                                 lpString1,
                                 nChar,
                                 lpString2,
                                 nChar );
    }

    if (retval == 0)
    {
        if (lpString1 && lpString2)
        {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
            if (fCaseSens)
                retval = StrCmpNW(lpString1, lpString2, nChar) + 2;
            else {
                retval = StrCmpNIW(lpString1, lpString2, nChar) + 2;
            }
        }
        else
        {
            retval = 2;
        }
    }

    return (retval == 2);
}



/*
 * StrRStrI      - Search for last occurrence of a substring
 *
 * Assumes   lpSource points to the null terminated source string
 *           lpLast points to where to search from in the source string
 *           lpLast is not included in the search
 *           lpSrch points to string to search for
 * returns   last occurrence of string if successful; NULL otherwise
 */
LPSTR StrRStrIA(LPCSTR lpSource, LPCSTR lpLast, LPCSTR lpSrch)
{
    LPCSTR lpFound = NULL;
    LPSTR lpEnd;
    char cHold;

    if (!lpLast)
        lpLast = lpSource + lstrlenA(lpSource);

    if (lpSource >= lpLast || *lpSrch == 0)
        return NULL;

    lpEnd = lstrfns_StrEndNA(lpLast, (UINT)(lstrlenA(lpSrch)-1));
    cHold = *lpEnd;
    *lpEnd = 0;

    while ((lpSource = StrStrIA(lpSource, lpSrch))!=0 &&
          OFFSETOF(lpSource) < OFFSETOF(lpLast))
    {
        lpFound = lpSource;
        lpSource = AnsiNext(lpSource);
    }
    *lpEnd = cHold;
    return((LPSTR)lpFound);
}

LPWSTR StrRStrIW(LPCWSTR lpSource, LPCWSTR lpLast, LPCWSTR lpSrch)
{
    LPCWSTR lpFound = NULL;
    LPWSTR lpEnd;
    WCHAR cHold;

    if (!lpLast)
        lpLast = lpSource + lstrlenW(lpSource);

    if (lpSource >= lpLast || *lpSrch == 0)
        return NULL;

    lpEnd = lstrfns_StrEndNW(lpLast, (UINT)(lstrlenW(lpSrch)-1));
    cHold = *lpEnd;
    *lpEnd = 0;

    while ((lpSource = StrStrIW(lpSource, lpSrch))!=0 &&
          lpSource < lpLast)
    {
        lpFound = lpSource;
        lpSource++;
    }
    *lpEnd = cHold;
    return((LPWSTR)lpFound);
}



/*
 * StrStr      - Search for first occurrence of a substring
 *
 * Assumes   lpSource points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */
LPSTR StrStrA(LPCSTR lpFirst, LPCSTR lpSrch)
{
  UINT uLen;
  WORD wMatch;

  uLen = (UINT)lstrlenA(lpSrch);
  wMatch = READNATIVEWORD(lpSrch);

  for ( ; (lpFirst=StrChrA(lpFirst, wMatch))!=0 && !IntlStrEqNA(lpFirst, lpSrch, uLen);
        lpFirst=AnsiNext(lpFirst))
    continue; /* continue until we hit the end of the string or get a match */

  return((LPSTR)lpFirst);
}

LPWSTR StrStrW(LPCWSTR lpFirst, LPCWSTR lpSrch)
{
  UINT uLen;
  WCHAR wMatch;

  uLen = (UINT)lstrlenW(lpSrch);
  wMatch = *lpSrch;

  for ( ; (lpFirst=StrChrW(lpFirst, wMatch))!=0 && !IntlStrEqNW(lpFirst, lpSrch, uLen);
        lpFirst++)
    continue; /* continue until we hit the end of the string or get a match */

  return((LPWSTR)lpFirst);
}

/*
 * StrChrI - Find first occurrence of character in string, case insensitive
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR StrChrIA(LPCSTR lpStart, WORD wMatch)
{
  wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch));

  for ( ; *lpStart; lpStart = AnsiNext(lpStart))
    {
      if (!ChrCmpIA(READNATIVEWORD(lpStart), wMatch))
	  return((LPSTR)lpStart);
    }
  return (NULL);
}

LPWSTR StrChrIW(LPCWSTR lpStart, WCHAR wMatch)
{
  for ( ; *lpStart; lpStart++)
    {
      if (!ChrCmpIW(*lpStart, wMatch))
	  return((LPWSTR)lpStart);
    }
  return (NULL);
}


/*
 * StrStrI   - Search for first occurrence of a substring, case insensitive
 *
 * Assumes   lpFirst points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */
LPSTR StrStrIA(LPCSTR lpFirst, LPCSTR lpSrch)
{
  UINT uLen;
  WORD wMatch;

  uLen = (UINT)lstrlenA(lpSrch);
  wMatch = READNATIVEWORD(lpSrch);

  for ( ; (lpFirst = StrChrIA(lpFirst, wMatch)) != 0 && !IntlStrEqNIA(lpFirst, lpSrch, uLen);
        lpFirst=AnsiNext(lpFirst))
      continue; /* continue until we hit the end of the string or get a match */

  return((LPSTR)lpFirst);
}

LPWSTR StrStrIW(LPCWSTR lpFirst, LPCWSTR lpSrch)
{
  UINT uLen;
  WCHAR wMatch;

  uLen = (UINT)lstrlenW(lpSrch);
  wMatch = *lpSrch;

  for ( ; (lpFirst = StrChrIW(lpFirst, wMatch)) != 0 && !IntlStrEqNIW(lpFirst, lpSrch, uLen);
        lpFirst++)
      continue; /* continue until we hit the end of the string or get a match */

  return((LPWSTR)lpFirst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\tbcust.c ===
#include "ctlspriv.h"
#include "toolbar.h"
#include "help.h" // Help IDs

#define SEND_WM_COMMAND(hwnd, id, hwndCtl, codeNotify) \
    (void)SendMessage((hwnd), WM_COMMAND, MAKEWPARAM((UINT)(id),(UINT)(codeNotify)), (LPARAM)(HWND)(hwndCtl))

#define SPACESTRLEN 20

#define FLAG_NODEL  0x8000
#define FLAG_HIDDEN 0x4000
#define FLAG_SEP    0x2000
#define FLAG_ALLFLAGS   (FLAG_NODEL|FLAG_HIDDEN|FLAG_SEP)

typedef struct {        /* instance data for toolbar edit dialog */
    HWND hDlg;          /* dialog hwnd */
    PTBSTATE ptb;       // current toolbar state
    int iPos;           /* position to insert into */
} ADJUSTDLGDATA, *LPADJUSTDLGDATA;


int g_dyButtonHack = 0;     // to pass on before WM_INITDIALOG

LPTSTR TB_StrForButton(PTBSTATE ptb, LPTBBUTTONDATA pTBButton);

int GetPrevButton(PTBSTATE ptb, int iPos)
{
    /* This means to delete the preceding space
     */
    for (--iPos; ; --iPos)
    {
        if (iPos < 0)
            break;

        if (!(ptb->Buttons[iPos].fsState & TBSTATE_HIDDEN))
            break;;
    }

    return(iPos);
}

BOOL GetAdjustInfo(PTBSTATE ptb, int iItem, LPTBBUTTONDATA ptbButton, LPTSTR lpString, int cbString)
{
    TBNOTIFY tbn;
    tbn.pszText = lpString;
    tbn.cchText = cbString;
    tbn.iItem = iItem;

    if (lpString)
        *lpString = 0;

    if ((BOOL)CCSendNotify(&ptb->ci, TBN_GETBUTTONINFO, &tbn.hdr))
    {
        TBInputStruct(ptb, ptbButton, &tbn.tbButton);
        return TRUE;
    }
    return FALSE;
}

LRESULT SendItemNotify(PTBSTATE ptb, int iItem, int code)
{
    TBNOTIFY tbn = {0};
    tbn.iItem = iItem;

    switch (code)
    {
    case TBN_QUERYDELETE:
    case TBN_QUERYINSERT:
        // The following is to provide the parent app with information
        // about the button that information is being requested for...
        // Otherwise it's really awful trying to have control over
        // certain aspects of toolbar customization... [t-mkim]
        // IE4.0's toolbar wants this information.
        //      Should ONLY be done for TBN_QUERY* notifications BECAUSE
        //      this can be either a zero-based index _or_ Command ID depending
        //      on the particular notification code.
        if (iItem < ptb->iNumButtons)
            CopyMemory (&tbn.tbButton, &ptb->Buttons[iItem], sizeof (TBBUTTON));
        break;

    case TBN_DROPDOWN:
        TB_GetItemRect(ptb, PositionFromID(ptb, iItem), &tbn.rcButton);
        break;
    }

    // default return from SendNotify is false
    // this actually shouldnt return a bool, TBN_DROPDOWN needs to return 0, 1, or 2.
    return CCSendNotify(&ptb->ci, code, &tbn.hdr);
}

#define SendCmdNotify(ptb, code)   CCSendNotify(&ptb->ci, code, NULL)


// this is used to deal with the case where the ptb structure is re-alloced
// after a TBInsertButtons()

PTBSTATE FixPTB(HWND hwnd)
{
    PTBSTATE ptb = (PTBSTATE)GetWindowInt(hwnd, 0);

    if (ptb->hdlgCust)
    {
        LPADJUSTDLGDATA lpad = (LPADJUSTDLGDATA)GetWindowPtr(ptb->hdlgCust, DWLP_USER);
#ifdef DEBUG
        if (lpad->ptb != ptb)
            DebugMsg(DM_TRACE, TEXT("Fixing busted ptb pointer"));
#endif
        lpad->ptb = ptb;
    }
    return ptb;
}


void MoveButton(PTBSTATE ptb, int nSource)
{
    int nDest;
    RECT rc;
    HCURSOR hCursor;
    MSG32 msg32;

    /* You can't move separators like this
     */
    if (nSource < 0)
        return;

    // Make sure it is all right to "delete" the selected button
    if (!SendItemNotify(ptb, nSource, TBN_QUERYDELETE))
        return;

    hCursor = SetCursor(LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_MOVEBUTTON)));
    SetCapture(ptb->ci.hwnd);

    // Get the dimension of the window.
    GetClientRect(ptb->ci.hwnd, &rc);
    for ( ; ; )
    {
        while (!PeekMessage32(&msg32, NULL, 0, 0, PM_REMOVE, TRUE))
            ;

        if (GetCapture() != ptb->ci.hwnd)
            goto AbortMove;

        // See if the application wants to process the message...
        if (CallMsgFilter32(&msg32, MSGF_COMMCTRL_TOOLBARCUST, TRUE) != 0)
            continue;


        switch (msg32.message)
        {
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_CHAR:

            //notify of navigation key usage
            CCNotifyNavigationKeyUsage(&(ptb->ci), UISF_HIDEFOCUS);

            break;

        case WM_LBUTTONUP:
            RelayToToolTips(ptb->hwndToolTips, ptb->ci.hwnd, msg32.message, msg32.wParam, msg32.lParam);
            if ((GET_Y_LPARAM(msg32.lParam) > (short)(rc.bottom+ptb->iButWidth)) ||
                (GET_X_LPARAM(msg32.lParam) > (short)(rc.right+ptb->iButWidth)) ||
                (GET_Y_LPARAM(msg32.lParam) < -ptb->iButWidth) ||
                (GET_X_LPARAM(msg32.lParam) < -ptb->iButWidth))

            {
                /* If the button was dragged off the toolbar, delete it.
                 */
DeleteSrcButton:
                DeleteButton(ptb, nSource);
                SendCmdNotify(ptb, TBN_TOOLBARCHANGE);
                TBInvalidateItemRects(ptb);
            }
            else
            {
                TBBUTTONDATA tbbAdd;

                /* Add half a button to X so that it looks like it is centered
                 * over the target button, iff we have a horizontal layout.
                 * Add half a button to Y otherwise.
                 */
                if (rc.right!=ptb->iButWidth)
                    nDest = TBHitTest(ptb,
                                      GET_X_LPARAM(msg32.lParam) + ptb->iButWidth / 2,
                                      GET_Y_LPARAM(msg32.lParam));
                else
                    nDest = TBHitTest(ptb,
                                      GET_X_LPARAM(msg32.lParam),
                                      GET_Y_LPARAM(msg32.lParam) + ptb->iButHeight / 2);

                if (nDest < 0)
                    nDest = -1 - nDest;

                if (nDest>0 &&
                    (ptb->Buttons[nDest-1].fsState & TBSTATE_WRAP) &&
                    GET_X_LPARAM(msg32.lParam)>ptb->iButWidth &&
                    SendItemNotify(ptb, --nDest, TBN_QUERYINSERT))
                {
                    tbbAdd = ptb->Buttons[nSource];
                    DeleteButton(ptb, nSource);
                    if (nDest>nSource)
                        --nDest;

                    /* Insert before spaces, but after buttons. */
                    if (!(ptb->Buttons[nDest].fsStyle & TBSTYLE_SEP))
                        nDest++;

                    goto InsertSrcButton;
                }
                else if (nDest == nSource)
                {
                    /* This means to delete the preceding space, or to move a
                    button to the previous row.
                    */
                    nSource = GetPrevButton(ptb, nSource);
                    if (nSource < 0)
                        goto AbortMove;

                    // If the preceding item is a space with no ID, and
                    // the app says it's OK, then delete it.
                    if ((ptb->Buttons[nSource].fsStyle & TBSTYLE_SEP)
                        && !ptb->Buttons[nSource].idCommand
                        && SendItemNotify(ptb, nSource, TBN_QUERYDELETE))
                        goto DeleteSrcButton;
                }
                else if (nDest == nSource+1)
                {
                    // This means to add a preceding space
                    --nDest;
                    if (SendItemNotify(ptb, nDest, TBN_QUERYINSERT))
                    {
                        tbbAdd.DUMMYUNION_MEMBER(iBitmap) = 0;
                        tbbAdd.idCommand = 0;
                        tbbAdd.iString = -1;
                        tbbAdd.fsState = 0;
                        tbbAdd.fsStyle = TBSTYLE_SEP;
                        goto InsertSrcButton;
                    }
                }
                else if (SendItemNotify(ptb, nDest, TBN_QUERYINSERT))
                {
                    HWND hwndT;
                    TBBUTTON tbbAddExt;

                    /* This is a normal move operation
                     */
                    tbbAdd = ptb->Buttons[nSource];

                    ptb->Buttons[nSource].iString = -1;
                    DeleteButton(ptb, nSource);
                    if (nDest > nSource)
                        --nDest;
InsertSrcButton:
                    hwndT = ptb->ci.hwnd;

                    TBOutputStruct(ptb, &tbbAdd, &tbbAddExt);
                    TBInsertButtons(ptb, nDest, 1, &tbbAddExt, TRUE);

                    ptb = FixPTB(hwndT);

                    SendCmdNotify(ptb, TBN_TOOLBARCHANGE);
                    TBInvalidateItemRects(ptb);
                }
                else
                {
AbortMove:
                    ;
                }
            }
            goto AllDone;

        case WM_RBUTTONDOWN:
            goto AbortMove;

        default:
            TranslateMessage32(&msg32, TRUE);
            DispatchMessage32(&msg32, TRUE);
            break;
        }
    }
AllDone:

    SetCursor(hCursor);
    CCReleaseCapture(&ptb->ci);
}


#define GNI_HIGH    0x0001
#define GNI_LOW     0x0002

int GetNearestInsert(PTBSTATE ptb, int iPos, int iNumButtons, UINT uFlags)
{
    int i;
    BOOL bKeepTrying;

    // Find the nearest index where we can actually insert items
    for (i = iPos; ; ++i, --iPos)
    {
        bKeepTrying = FALSE;

        // Notice we favor going high if both flags are set
        if ((uFlags & GNI_HIGH) && i <= iNumButtons)
        {
            bKeepTrying = TRUE;

            if (SendItemNotify(ptb, i, TBN_QUERYINSERT))
                return i;
        }

        if ((uFlags & GNI_LOW) && iPos >= 0)
        {
            bKeepTrying = TRUE;

            if (SendItemNotify(ptb, iPos, TBN_QUERYINSERT))
                return iPos;
        }

        if (!bKeepTrying)
            return -1;   // There was no place to add buttons
    }
}


BOOL InitAdjustDlg(HWND hDlg, LPADJUSTDLGDATA lpad)
{
    HDC hDC;
    HFONT hFont;
    HWND hwndCurrent, hwndNew;
    LPTBBUTTONDATA ptbButton;
    int i, iPos, nItem, nWid, nMaxWid;
    TBBUTTONDATA tbAdjust;
    TCHAR szDesc[128];
    NMTBCUSTOMIZEDLG nm;
    TCHAR szSeparator[MAX_PATH];

    szSeparator[0] = 0;
    LocalizedLoadString(IDS_SPACE, szSeparator, ARRAYSIZE(szSeparator));

    lpad->hDlg = hDlg;
    lpad->ptb->hdlgCust = hDlg;

    /* Determine the item nearest the desired item that will allow
     * insertion.
     */
    iPos = GetNearestInsert(lpad->ptb, lpad->iPos, lpad->ptb->iNumButtons,
                            GNI_HIGH | GNI_LOW);
    if (iPos < 0)
    /* No item allowed insertion, so leave the dialog */
    {
        return(FALSE);
    }

    /* Reset the lists of used and available items.
     */
    hwndCurrent = GetDlgItem(hDlg, IDC_CURRENT);
    SendMessage(hwndCurrent, LB_RESETCONTENT, 0, 0L);

    hwndNew = GetDlgItem(hDlg, IDC_BUTTONLIST);
    SendMessage(hwndNew, LB_RESETCONTENT, 0, 0L);

    nm.hDlg = hDlg;
    if (CCSendNotify(&lpad->ptb->ci, TBN_INITCUSTOMIZE, &nm.hdr) == TBNRF_HIDEHELP)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_APPHELP), SW_HIDE);
    }

    for (i=0, ptbButton = lpad->ptb->Buttons; i < lpad->ptb->iNumButtons; ++i, ++ptbButton)
    {
        UINT uFlags;
        int iBitmap;
        LPTSTR pszStr = NULL;

        uFlags = 0;

        // Non-deletable and hidden items show up grayed.

        if (!SendItemNotify(lpad->ptb, i, TBN_QUERYDELETE))
        {
            uFlags |= FLAG_NODEL;
        }
        if (ptbButton->fsState & TBSTATE_HIDDEN)
        {
            uFlags |= FLAG_HIDDEN;
        }

        /* Separators have no bitmaps (even ones with IDs).  Only set
         * the separator flag if there is no ID (it is a "real"
         * separator rather than an owner item).
         */
        if (ptbButton->fsStyle&TBSTYLE_SEP)
        {
            if (!(ptbButton->idCommand))
            {
                uFlags |= FLAG_SEP;
            }
            iBitmap = -1;

            pszStr = szSeparator;
        }
        else
        {
            iBitmap = ptbButton->DUMMYUNION_MEMBER(iBitmap);
            // this specifies an imagelist.
            // pack this into the loword of the ibitmap.
            // this causes a restriction of max 16 imagelists, and 4096 images in any imagelist
            iBitmap = LOWORD(iBitmap) | (HIWORD(iBitmap) << 12);

            /* Add the item and the data
             * Note: A negative number in the LOWORD indicates no bitmap;
             * otherwise it is the bitmap index.
             */
            pszStr = TB_StrForButton(lpad->ptb, ptbButton);
        }

        if ((int)SendMessage(hwndCurrent, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)(pszStr ? pszStr : (LPTSTR)c_szNULL)) != i)
        {
            return(FALSE);
        }
        SendMessage(hwndCurrent, LB_SETITEMDATA, i, MAKELPARAM(iBitmap, uFlags));
    }

    /* Add a dummy "nodel" space at the end so things can be inserted at the end.
     */
    if ((int)SendMessage(hwndCurrent, LB_ADDSTRING, 0,(LPARAM)(LPTSTR)szSeparator) == i)
    {
        SendMessage(hwndCurrent, LB_SETITEMDATA, i, MAKELPARAM(-1, FLAG_NODEL|FLAG_SEP));
    }

    /* Now add a space at the beginning of the "new" list.
     */
        if (SendMessage(hwndNew, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)szSeparator) == LB_ERR)
            return(FALSE);
            
        SendMessage(hwndNew, LB_SETITEMDATA, 0, MAKELPARAM(-1, FLAG_SEP));

    /* We need this to determine the widest (in pixels) item string.
     */
    hDC = GetDC(hwndCurrent);
    hFont = (HFONT)(INT_PTR)SendMessage(hwndCurrent, WM_GETFONT, 0, 0L);
    if (hFont)
    {
        hFont = SelectObject(hDC, hFont);
    }
    nMaxWid = 0;

    for (i=0; ; ++i)
    {
        // Get the info about the i'th item from the app.
        if (!GetAdjustInfo(lpad->ptb, i, &tbAdjust, szDesc, ARRAYSIZE(szDesc)))
            break;
        
        if (!szDesc[0])
        {
            LPTSTR psz = TB_StrForButton(lpad->ptb, &tbAdjust);
            if (psz)
            {
                lstrcpyn(szDesc, psz, ARRAYSIZE(szDesc));
            }
        }

        /* Don't show separators that don't have commands
         */
        if (!(tbAdjust.fsStyle & TBSTYLE_SEP) || tbAdjust.idCommand)
        {
            
            /* Get the maximum width of a string.
             */
            MGetTextExtent(hDC, szDesc, lstrlen(szDesc), &nWid, NULL);

            if (nMaxWid < nWid)
            {
                nMaxWid = nWid;
            }

            nItem = PositionFromID(lpad->ptb, tbAdjust.idCommand);
            if (nItem < 0)
            /* If the item is not on the toolbar already */
            {
#ifdef UNIX
                if (!lstrcmp(szDesc, TEXT("Folders")) || !lstrcmp(szDesc, TEXT("Edit")))
                    continue;
#endif

                /* Don't show hidden buttons
                 */
                if (!(tbAdjust.fsState & TBSTATE_HIDDEN))
                {
                    nItem = (int)SendMessage(hwndNew, LB_ADDSTRING, 0,
                                             (LPARAM)(LPTSTR)szDesc);
                    if (nItem != LB_ERR)
                    {
                        
                        if (tbAdjust.fsStyle & TBSTYLE_SEP)
                            SendMessage(hwndNew, LB_SETITEMDATA, nItem,
                                        MAKELPARAM(-1, i));
                        else
                        {
                            int iBitmap = tbAdjust.DUMMYUNION_MEMBER(iBitmap);
                            iBitmap = LOWORD(iBitmap) | (HIWORD(iBitmap) << 12);
                            SendMessage(hwndNew, LB_SETITEMDATA, nItem,
                                        MAKELPARAM(iBitmap, i));
                        }
                    }
                }
            }
            else
            /* The item is on the toolbar already */
            {
                /* Preserve the flags and bitmap.
                 */
                DWORD dwTemp = (DWORD)SendMessage(hwndCurrent, LB_GETITEMDATA, nItem, 0L);

                if (szDesc[0])
                {
                    SendMessage(hwndCurrent, LB_DELETESTRING, nItem, 0L);

                    if ((int)SendMessage(hwndCurrent, LB_INSERTSTRING, nItem,
                                         (LPARAM)(LPTSTR)szDesc) != nItem)
                    {
                        ReleaseDC(hwndCurrent, hDC);
                        return(FALSE);
                    }
                }
                SendMessage(hwndCurrent, LB_SETITEMDATA, nItem,
                    MAKELPARAM(LOWORD(dwTemp), HIWORD(dwTemp)|i));
            }
        }
    }

    if (hFont)
    {
        SelectObject(hDC, hFont);
    }
    ReleaseDC(hwndCurrent, hDC);

    /* Add on some extra and set the extents for both lists.
     */
    nMaxWid += lpad->ptb->iButWidth + 2 + 1;
    SendMessage(hwndNew, LB_SETHORIZONTALEXTENT, nMaxWid, 0L);
    SendMessage(hwndCurrent, LB_SETHORIZONTALEXTENT, nMaxWid, 0L);

    /* Set the sels and return.
     */
    SendMessage(hwndNew, LB_SETCURSEL, 0, 0L);
    SendMessage(hwndCurrent, LB_SETCURSEL, iPos, 0L);
    SEND_WM_COMMAND(hDlg, IDC_CURRENT, hwndCurrent, LBN_SELCHANGE);

    return(TRUE);
}


#define IsSeparator(x) (HIWORD(x) & FLAG_SEP)

void PaintAdjustLine(PTBSTATE ptb, DRAWITEMSTRUCT *lpdis)
{
    HDC hdc = lpdis->hDC;
    HWND hwndList = lpdis->hwndItem;
    PTSTR pszText;
    RECT rc = lpdis->rcItem;
    int nBitmap, nLen, nItem = lpdis->itemID;
    COLORREF oldBkColor, oldTextColor;
    BOOL bSelected, bHasFocus;
    int wHeight;
    int x;


    if (lpdis->CtlID != IDC_BUTTONLIST && lpdis->CtlID != IDC_CURRENT)
        return;

    nBitmap = LOWORD(lpdis->itemData);
    // unpack the nBitmap.  we stored the imagelist spec in the hi char of loword
    if (nBitmap != 0xFFFF)
        nBitmap = (nBitmap & 0x0FFF) | ((nBitmap & 0xF000) << 4);

    nLen = (int)SendMessage(hwndList, LB_GETTEXTLEN, nItem, 0L);
    if (nLen < 0)
        return;

    pszText = (PTSTR)LocalAlloc(LPTR, (nLen+1)*sizeof(TCHAR));
    if (!pszText)
        return;

    // This needs to work for separators also or ActiveAccessibility
    // won't work.
    SendMessage(hwndList, LB_GETTEXT, nItem, (LPARAM)(LPTSTR)pszText);
    if (lpdis->itemAction != ODA_FOCUS)
    {
        COLORREF clr;
        TCHAR szSample[2];

        /* We don't care about focus if the item is not selected.
        */
        bSelected = lpdis->itemState & ODS_SELECTED;
        bHasFocus = bSelected && (GetFocus() == hwndList);

        if (HIWORD(lpdis->itemData) & (FLAG_NODEL | FLAG_HIDDEN))
            clr = g_clrGrayText;
        else if (bHasFocus)
            clr = g_clrHighlightText;
        else
            clr = g_clrWindowText;

        oldTextColor = SetTextColor(hdc, clr);
        oldBkColor = SetBkColor(hdc, bHasFocus ? g_clrHighlight : g_clrWindow);

        szSample[0] = TEXT('W');
        szSample[1] = TEXT('\0');

        MGetTextExtent(hdc, szSample, 1, NULL, &wHeight);

        x = rc.left + 2;
        x += (ptb->ci.style & TBSTYLE_FLAT) ? (ptb->iDxBitmap + g_cxEdge) : ptb->iButWidth;
        ExtTextOut(hdc, x,
                   (rc.top + rc.bottom-wHeight) / 2,
                   ETO_CLIPPED | ETO_OPAQUE, &rc, pszText, nLen, NULL);

        /* We really care about the bitmap value here; this is not just an
        * indicator for the separator.
        */
        if (nBitmap >= 0)
        {
            TBBUTTONDATA tbbAdd = {0};
            TBDRAWITEM tbdraw = {0};

            tbbAdd.DUMMYUNION_MEMBER(iBitmap) = nBitmap;
            tbbAdd.iString = -1;
            tbbAdd.fsStyle = TBSTYLE_BUTTON;
            tbbAdd.fsState = (BYTE)((HIWORD(lpdis->itemData) & FLAG_HIDDEN) ? 0 : TBSTATE_ENABLED);

            InitTBDrawItem(&tbdraw, ptb, &tbbAdd, tbbAdd.fsState, 0, 0, 0);

            if (ptb->ci.style & TBSTYLE_FLAT)
            {
                RECT rcFace = rc;
                rcFace.right = rcFace.left + ptb->iDxBitmap + g_cxEdge;
                DrawFace(hdc, &rcFace, rc.left + 1, rc.top + 1, 0, 0, 0, 0, &tbdraw, 0, 0);
            }
            else
                DrawButton(hdc, rc.left + 1, rc.top + 1, ptb, &tbbAdd, TRUE);
            ReleaseMonoDC(ptb);
        }

        SetBkColor(hdc, oldBkColor);
        SetTextColor(hdc, oldTextColor);

        /* Frame the item if it is selected but does not have the focus.
        */
        if (bSelected && !bHasFocus)
        {
            nLen = rc.left + (int)SendMessage(hwndList,
            LB_GETHORIZONTALEXTENT, 0, 0L);
            if (rc.right < nLen)
                rc.right = nLen;

            FrameRect(hdc, &rc, g_hbrHighlight);
        }
    }

    if ((lpdis->itemAction == ODA_FOCUS || (lpdis->itemState & ODS_FOCUS)) && 
        !(CCGetUIState(&(ptb->ci)) & UISF_HIDEFOCUS))
    {
        DrawFocusRect(hdc, &rc); 
    }

    LocalFree((HLOCAL)pszText);
}


void LBMoveButton(LPADJUSTDLGDATA lpad, UINT wIDSrc, int iPosSrc,
      UINT wIDDst, int iPosDst, int iSelOffset)
{
    HWND hwndSrc, hwndDst;
    DWORD dwDataSrc;
    PTSTR pStr;
    TBBUTTONDATA tbAdjust = {0};
    TBBUTTON tbbAddExt;
    int iTopDst;
    TCHAR szDesc[128];

    hwndSrc = GetDlgItem(lpad->hDlg, wIDSrc);
    hwndDst = GetDlgItem(lpad->hDlg, wIDDst);

    // Make sure we can delete the source and insert at the dest
    //
    dwDataSrc = (DWORD)SendMessage(hwndSrc, LB_GETITEMDATA, iPosSrc, 0L);
    if (iPosSrc < 0 || (HIWORD(dwDataSrc) & FLAG_NODEL))
        return;
    if (wIDDst == IDC_CURRENT && 
        !SendItemNotify(lpad->ptb, iPosDst, TBN_QUERYINSERT))
        return;

    // Get the string for the source
    //
    pStr = (PTSTR)LocalAlloc(LPTR,
        ((int)(SendMessage(hwndSrc, LB_GETTEXTLEN, iPosSrc, 0L))+1)*sizeof(TCHAR));
    if (!pStr)
        return;
    SendMessage(hwndSrc, LB_GETTEXT, iPosSrc, (LPARAM)(LPTSTR)pStr);

    SendMessage(hwndSrc, WM_SETREDRAW, 0, 0L);
    SendMessage(hwndDst, WM_SETREDRAW, 0, 0L);
    iTopDst = (int)SendMessage(hwndDst, LB_GETTOPINDEX, 0, 0L);

    // If we are inserting into the available button list, we need to determine
    // the insertion point
    //
    if (wIDDst == IDC_BUTTONLIST)
    {
        // Insert this back in the available list if this is not a space or a
        // hidden button.
        //
        if (HIWORD(dwDataSrc)&(FLAG_SEP|FLAG_HIDDEN))
        {
            iPosDst = 0;
            goto DelTheSrc;
        }
        else
        {
            UINT uCmdSrc = HIWORD(dwDataSrc) & ~(FLAG_ALLFLAGS);

            // This just does a linear search for where to put the
            // item.  Slow, but this only happens when the user clicks
            // the "Remove" button.
            //
            iPosDst = 1;
            
            for ( ; ; ++iPosDst)
            {
                // Notice that this will break out when iPosDst is
                // past the number of items, since -1 will be returned
                //
                if ((UINT)HIWORD(SendMessage(hwndDst, LB_GETITEMDATA,
                    iPosDst, 0L)) >= uCmdSrc)
                break;
            }
        }
    }
    else if (iPosDst < 0)
        goto CleanUp;

    // Attempt to insert the new string
    //
    if ((int)SendMessage(hwndDst, LB_INSERTSTRING, iPosDst, (LPARAM)(LPTSTR)pStr)
      == iPosDst)
    {
        // Attempt to sync up the actual toolbar.
        //
        if (wIDDst == IDC_CURRENT)
        {
            HWND hwndT;

            if (IsSeparator(dwDataSrc))
            {
                // Make up a dummy lpInfo if this is a space
                //
                tbAdjust.DUMMYUNION_MEMBER(iBitmap) = 0;
                tbAdjust.idCommand = 0;
                tbAdjust.fsState = 0;
                tbAdjust.fsStyle = TBSTYLE_SEP;
            }
            else
            {
                // Call back to client to get the source button info
                //
                int iCmdSrc = HIWORD(dwDataSrc) & ~FLAG_ALLFLAGS;
                if (!GetAdjustInfo(lpad->ptb, iCmdSrc, &tbAdjust, szDesc, ARRAYSIZE(szDesc)))
                    goto DelTheDst;
            }

            hwndT = lpad->ptb->ci.hwnd;

            TBOutputStruct(lpad->ptb, &tbAdjust, &tbbAddExt);
            if (!TBInsertButtons(lpad->ptb, iPosDst, 1, &tbbAddExt, TRUE))
            {
DelTheDst:
                SendMessage(hwndDst, LB_DELETESTRING, iPosDst, 0L);
                goto CleanUp;
            }
            else
            {
                lpad->ptb = FixPTB(hwndT);
            }

            if (wIDSrc == IDC_CURRENT && iPosSrc >= iPosDst)
                ++iPosSrc;
        }

        SendMessage(hwndDst, LB_SETITEMDATA, iPosDst, dwDataSrc);

DelTheSrc:
        // Don't delete the "Separator" in the new list
        //
        if ((wIDSrc != IDC_BUTTONLIST) || (iPosSrc != 0))
        {
            SendMessage(hwndSrc, LB_DELETESTRING, iPosSrc, 0L);
            if (wIDSrc == wIDDst)
            {
                if (iPosSrc < iPosDst)
                    --iPosDst;
                if (iPosSrc < iTopDst)
                    --iTopDst;
            }
        }

        // Delete the corresponding button
        //
        if (wIDSrc == IDC_CURRENT)
            DeleteButton(lpad->ptb, iPosSrc);

        // Only set the src index if the two windows are different
        //
        if (wIDSrc != wIDDst)
        {
            if (iPosSrc >= SendMessage(hwndSrc, LB_GETCOUNT, 0, 0L))
            {
                // HACKHACK: workaround for funkdified listbox scrolling behavior.
                // Select the first item (to force scroll back to top of list),
                // then select the item we really want selected.
                SendMessage(hwndSrc, LB_SETCURSEL, 0, 0L);
            }

            if (SendMessage(hwndSrc, LB_SETCURSEL, iPosSrc, 0L) == LB_ERR)
                SendMessage(hwndSrc, LB_SETCURSEL, iPosSrc-1, 0L);
            SEND_WM_COMMAND(lpad->hDlg, wIDSrc, hwndSrc, LBN_SELCHANGE);
        }

        // Send the final SELCHANGE message after everything else is done
        //
        SendMessage(hwndDst, LB_SETCURSEL, iPosDst+iSelOffset, 0L);
        SEND_WM_COMMAND(lpad->hDlg, wIDDst, hwndDst, LBN_SELCHANGE);
    }

CleanUp:

    LocalFree((HLOCAL)pStr);

    if (wIDSrc == wIDDst)
    {
        SendMessage(hwndDst, LB_SETTOPINDEX, iTopDst, 0L);
        //make sure that the selected item is still  visible
        SendMessage(hwndDst, LB_SETCURSEL, (int)SendMessage(hwndDst, LB_GETCURSEL, 0, 0L), 0);
    }
    SendMessage(hwndSrc, WM_SETREDRAW, 1, 0L);
    SendMessage(hwndDst, WM_SETREDRAW, 1, 0L);

    InvalidateRect(hwndDst, NULL, TRUE);

    SendCmdNotify(lpad->ptb, TBN_TOOLBARCHANGE);
}


void SafeEnableWindow(HWND hDlg, UINT wID, HWND hwndDef, BOOL bEnable)
{
    HWND hwndEnable;

    hwndEnable = GetDlgItem(hDlg, wID);

    if (!bEnable && GetFocus()==hwndEnable)
        SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hwndDef, 1L);
    EnableWindow(hwndEnable, bEnable);
}

int InsertIndex(LPADJUSTDLGDATA lpad, POINT pt, BOOL bDragging)
{
    HWND hwndCurrent = GetDlgItem(lpad->hDlg, IDC_CURRENT);
    int nItem = LBItemFromPt(hwndCurrent, pt, bDragging);
    if (nItem >= 0)
    {
        if (!SendItemNotify(lpad->ptb, nItem, TBN_QUERYINSERT))
            nItem = -1;
    }

    DrawInsert(lpad->hDlg, hwndCurrent, bDragging ? nItem : -1);

    return(nItem);
}


BOOL IsInButtonList(HWND hDlg, POINT pt)
{
    ScreenToClient(hDlg, &pt);

    return(ChildWindowFromPoint(hDlg, pt) == GetDlgItem(hDlg, IDC_BUTTONLIST));
}


BOOL HandleDragMsg(LPADJUSTDLGDATA lpad, HWND hDlg, WPARAM wID, LPDRAGLISTINFO lpns)
{
    switch (wID)
    {
    case IDC_CURRENT:
        switch (lpns->uNotification)
        {
        case DL_BEGINDRAG:
            {
                int nItem = (int)SendMessage(lpns->hWnd, LB_GETCURSEL, 0, 0L);
                if (HIWORD(SendMessage(lpns->hWnd, LB_GETITEMDATA, nItem, 0L)) & FLAG_NODEL)
                    return SetDlgMsgResult(hDlg, WM_COMMAND, FALSE);
                return SetDlgMsgResult(hDlg, WM_COMMAND, TRUE);
            }
            
        case DL_DRAGGING:
            {
                int nDropIndex;

DraggingSomething:
                nDropIndex = InsertIndex(lpad, lpns->ptCursor, TRUE);
                if (nDropIndex>=0 || IsInButtonList(hDlg, lpns->ptCursor))
                {
                    SetCursor(LoadCursor(HINST_THISDLL,
                        MAKEINTRESOURCE(IDC_MOVEBUTTON)));
                    return SetDlgMsgResult(hDlg, WM_COMMAND, 0);
                }
                return SetDlgMsgResult(hDlg, WM_COMMAND, DL_STOPCURSOR);
            }
            
        case DL_DROPPED:
            {
                int nDropIndex, nSrcIndex;
                
                nDropIndex = InsertIndex(lpad, lpns->ptCursor, FALSE);
                nSrcIndex = (int)SendMessage(lpns->hWnd, LB_GETCURSEL, 0, 0L);
                
                if (nDropIndex >= 0)
                {
                    if ((UINT)(nDropIndex-nSrcIndex) > 1)
                        LBMoveButton(lpad, IDC_CURRENT, nSrcIndex,
                        IDC_CURRENT, nDropIndex, 0);
                }
                else if (IsInButtonList(hDlg, lpns->ptCursor))
                {
                    LBMoveButton(lpad, IDC_CURRENT, nSrcIndex, IDC_BUTTONLIST, 0, 0);
                }
                break;
            }
            
        case DL_CANCELDRAG:
CancelDrag:
            /* This erases the insert icon if it exists.
             */
            InsertIndex(lpad, lpns->ptCursor, FALSE);
            break;
            
        default:
            break;
        }
        break;
        
        case IDC_BUTTONLIST:
            switch (lpns->uNotification)
            {
            case DL_BEGINDRAG:
                return SetDlgMsgResult(hDlg, WM_COMMAND, TRUE);
                
            case DL_DRAGGING:
                goto DraggingSomething;
                
            case DL_DROPPED:
                {
                    int nDropIndex;
                    
                    nDropIndex = InsertIndex(lpad, lpns->ptCursor, FALSE);
                    if (nDropIndex >= 0)
                        LBMoveButton(lpad, IDC_BUTTONLIST,
                            (int)SendMessage(lpns->hWnd,LB_GETCURSEL,0,0L),
                            IDC_CURRENT, nDropIndex, 0);
                    break;
                }
                
            case DL_CANCELDRAG:
                goto CancelDrag;
                
            default:
                break;
            }
            break;
            
            default:
                break;
    }
    
    return(0);
}

// Context Help IDs
const static DWORD aAdjustHelpIDs[] = 
{  
    IDC_RESET,       IDH_COMCTL_RESET,
    IDC_APPHELP,     IDH_HELP,
    IDC_MOVEUP,      IDH_COMCTL_MOVEUP,
    IDC_MOVEDOWN,    IDH_COMCTL_MOVEDOWN,
    IDC_BUTTONLIST,  IDH_COMCTL_AVAIL_BUTTONS,
    IDOK,            IDH_COMCTL_ADD,
    IDC_REMOVE,      IDH_COMCTL_REMOVE,
    IDC_CURRENT,     IDH_COMCTL_BUTTON_LIST,
    IDCANCEL,        IDH_COMCTL_CLOSE,
    0, 0
};

BOOL_PTR CALLBACK AdjustDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPADJUSTDLGDATA lpad = (LPADJUSTDLGDATA)GetWindowPtr(hDlg, DWLP_USER);
    switch (uMsg)
    {
    case WM_INITDIALOG:
        
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);  /* LPADJUSTDLGDATA pointer */
        if (!InitAdjustDlg(hDlg, (LPADJUSTDLGDATA)lParam))
            EndDialog(hDlg, FALSE);
        
        ShowWindow(hDlg, SW_SHOW);
        UpdateWindow(hDlg);
        SetFocus(GetDlgItem(hDlg, IDC_CURRENT));
        
        MakeDragList(GetDlgItem(hDlg, IDC_CURRENT));
        MakeDragList(GetDlgItem(hDlg, IDC_BUTTONLIST));
        
        return FALSE;
        
    case WM_MEASUREITEM:
#define lpmis ((MEASUREITEMSTRUCT *)lParam)
        
        if (lpmis->CtlID == IDC_BUTTONLIST || lpmis->CtlID == IDC_CURRENT)
        {
            int nHeight;
            HWND hwndList = GetDlgItem(hDlg, lpmis->CtlID);
            HDC hDC = GetDC(hwndList);
            TCHAR szSample[2];
            
            szSample[0] = TEXT('W');
            szSample[1] = TEXT('\0');
            
            MGetTextExtent(hDC, szSample, 1, NULL, &nHeight);
            
            // note, we use this hack because we get WM_MEASUREITEMS
            // before our WM_INITDIALOG where we get the lpad setup
            
            if (nHeight < g_dyButtonHack + 2)
                nHeight = g_dyButtonHack + 2;
            
            lpmis->itemHeight = nHeight;
            ReleaseDC(hwndList, hDC);
        }
        break;
        
    case WM_DRAWITEM:
        PaintAdjustLine(lpad->ptb, (DRAWITEMSTRUCT *)lParam);
        break;
        
    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aAdjustHelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR)(LPVOID) aAdjustHelpIDs);
        break;
        
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_APPHELP:
            SendCmdNotify(lpad->ptb, TBN_CUSTHELP);
            break;
            
        case IDOK:
            {
                int iPos, nItem;
                
                nItem = (int)SendDlgItemMessage(hDlg, IDC_BUTTONLIST,
                    LB_GETCURSEL, 0, 0L);
                
                iPos = (int)SendDlgItemMessage(hDlg, IDC_CURRENT,
                    LB_GETCURSEL, 0, 0L);
                
                if (iPos == -1)
                    iPos = 0;
                
                LBMoveButton(lpad, IDC_BUTTONLIST, nItem, IDC_CURRENT, iPos, 1);
                break;
            }
            
        case IDC_BUTTONLIST:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case LBN_DBLCLK:
                SendMessage(hDlg, WM_COMMAND, IDOK, 0L);
                break;
                
            case LBN_SETFOCUS:
            case LBN_KILLFOCUS:
                {
                    RECT rc;
                    
                    if (SendMessage(GET_WM_COMMAND_HWND(wParam, lParam), LB_GETITEMRECT,
                        (int)SendMessage(GET_WM_COMMAND_HWND(wParam, lParam), LB_GETCURSEL,
                        0, 0L), (LPARAM)(LPRECT)&rc) != LB_ERR)
                        InvalidateRect(GET_WM_COMMAND_HWND(wParam, lParam), &rc, FALSE);
                }
                
            default:
                break;
            }
            break;
            
        case IDC_CURRENT:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case LBN_SELCHANGE:
                {
                    BOOL bDelOK;
                    HWND hwndList = GET_WM_COMMAND_HWND(wParam, lParam);
                    int iPos = (int)SendMessage(hwndList, LB_GETCURSEL, 0, 0L);
                    
                    SafeEnableWindow(hDlg, IDOK, hwndList, BOOLFROMPTR(SendItemNotify(lpad->ptb, iPos, TBN_QUERYINSERT)));
                    
                    bDelOK = !(HIWORD(SendMessage(hwndList, LB_GETITEMDATA, iPos, 0L)) & FLAG_NODEL);
                    
                    SafeEnableWindow(hDlg, IDC_REMOVE, hwndList, bDelOK);
                    
                    SafeEnableWindow(hDlg, IDC_MOVEUP, hwndList, bDelOK &&
                        GetNearestInsert(lpad->ptb, iPos - 1, 0, GNI_LOW) >= 0);
                    
                    SafeEnableWindow(hDlg, IDC_MOVEDOWN, hwndList, bDelOK &&
                        GetNearestInsert(lpad->ptb, iPos + 2,
                        lpad->ptb->iNumButtons, GNI_HIGH) >=0 );
                    break;
                }
                
            case LBN_DBLCLK:
                SendMessage(hDlg, WM_COMMAND, IDC_REMOVE, 0L);
                break;
                
            case LBN_SETFOCUS:
            case LBN_KILLFOCUS:
                {
                    RECT rc;

                    if (SendMessage(GET_WM_COMMAND_HWND(wParam, lParam), LB_GETITEMRECT,
                        (int)SendMessage(GET_WM_COMMAND_HWND(wParam, lParam), LB_GETCURSEL,
                        0, 0L), (LPARAM)(LPRECT)&rc) != LB_ERR)
                        InvalidateRect(GET_WM_COMMAND_HWND(wParam, lParam), &rc, FALSE);
                }
                
            default:
                break;
            }
            break;
            
        case IDC_REMOVE:
            {
                int iPos = (int)SendDlgItemMessage(hDlg, IDC_CURRENT, LB_GETCURSEL, 0, 0);
                
                LBMoveButton(lpad, IDC_CURRENT, iPos, IDC_BUTTONLIST, 0, 0);
                break;
            }
            
        case IDC_MOVEUP:
        case IDC_MOVEDOWN:
            {
                int iPosSrc, iPosDst;
                
                iPosSrc = (int)SendDlgItemMessage(hDlg, IDC_CURRENT, LB_GETCURSEL, 0, 0L);
                if (wParam == IDC_MOVEUP)
                    iPosDst = GetNearestInsert(lpad->ptb, iPosSrc - 1, 0, GNI_LOW);
                else
                    iPosDst = GetNearestInsert(lpad->ptb, iPosSrc + 2, lpad->ptb->iNumButtons, GNI_HIGH);
                
                LBMoveButton(lpad, IDC_CURRENT, iPosSrc, IDC_CURRENT,iPosDst,0);
                break;
            }
            
        case IDC_RESET:
            {
                // ptb will change across call below
                HWND hwndT = lpad->ptb->ci.hwnd;
                BOOL fClose = FALSE;
                NMTBCUSTOMIZEDLG nm;
                nm.hDlg = hDlg;
                if (CCSendNotify(&lpad->ptb->ci, TBN_RESET, &nm.hdr) == TBNRF_ENDCUSTOMIZE)
                    fClose = TRUE;
                
                // ptb probably changed across above call
                lpad->ptb = FixPTB(hwndT);
            
                /* Reset the dialog, but exit if something goes wrong. */
                lpad->iPos = 0;
                if (!fClose && InitAdjustDlg(hDlg, lpad))
                    break;
            }
            
            /* We have to fall through because we won't know where to insert
             * buttons after resetting.
             */
        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            break;
            
        default:
            return(FALSE);
        }
        break;
        
    default:
        if (uMsg == uDragListMsg)
            return HandleDragMsg(lpad, hDlg, wParam, (LPDRAGLISTINFO)lParam);
        
        return(FALSE);
    }
    
    return(TRUE);
}

// FEATURE: this should support saving to an IStream

/* This saves the state of the toolbar.  Spaces are saved as -1 (-2 if hidden)
 * and other buttons are just saved as the command ID.  When restoring, all
 * ID's are filled in, and the app is queried for all buttons so that the
 * bitmap and state information may be filled in.  Button ID's that are not
 * returned from the app are removed.
 */

BOOL SaveRestoreFromReg(PTBSTATE ptb, BOOL bWrite, HKEY hkr, LPCTSTR pszSubKey, LPCTSTR pszValueName)
{
    BOOL bRet = FALSE;
    TCHAR szDesc[128];
    
    if (bWrite)
    {
        UINT uSize = ptb->iNumButtons * sizeof(DWORD);
        NMTBSAVE nmtbs;
        BOOL fAlloced = FALSE;
        nmtbs.pData = NULL;
        nmtbs.cbData = uSize;
        nmtbs.pCurrent = NULL;
        nmtbs.iItem = -1; // signal pre saving
        nmtbs.cButtons = ptb->iNumButtons;
        CCSendNotify(&ptb->ci, TBN_SAVE, &nmtbs.hdr);
        if (!nmtbs.pData)
        {
            nmtbs.pData = (DWORD *)LocalAlloc(LPTR, nmtbs.cbData);
            fAlloced = TRUE;
        }

        // Bug#94345 -- Somebody could've changed ptb->iNumButtons
        // during the CCSendNotify

        if (!nmtbs.pCurrent)
            nmtbs.pCurrent = nmtbs.pData;
        
        if (nmtbs.pData)
        {
            HKEY hkeySave;
            if (RegCreateKey(hkr, pszSubKey, &hkeySave) == ERROR_SUCCESS)
            {
                int i;
                for (i = 0; i < ptb->iNumButtons; i++)
                {
                    if (ptb->Buttons[i].idCommand)
                        *nmtbs.pCurrent = ptb->Buttons[i].idCommand;
                    else
                    {
                        // If the separator has an ID, then it is an "owner" item.
                        if (ptb->Buttons[i].fsState & TBSTATE_HIDDEN)
                            *nmtbs.pCurrent = (DWORD)-2;   // hidden
                        else
                            *nmtbs.pCurrent = (DWORD)-1;   // normal seperator
                    }
                    nmtbs.pCurrent++;
                    nmtbs.iItem = i;
                    TBOutputStruct(ptb, &ptb->Buttons[i], &nmtbs.tbButton);
                    CCSendNotify(&ptb->ci, TBN_SAVE, &nmtbs.hdr);
                }
                if (RegSetValueEx(hkeySave, (LPTSTR)pszValueName, 0, REG_BINARY, (LPVOID)nmtbs.pData, nmtbs.cbData) == ERROR_SUCCESS)
                    bRet = TRUE;
                RegCloseKey(hkeySave);
            }
            
            if (fAlloced)
                LocalFree((HLOCAL)nmtbs.pData);
        }
    }
    else
    {
        HKEY hkey;
        
        if (RegOpenKey(hkr, pszSubKey, &hkey) == ERROR_SUCCESS)
        {
            DWORD cbSize = 0;
            
            if ((RegQueryValueEx(hkey, (LPTSTR)pszValueName, 0, NULL, NULL, &cbSize) == ERROR_SUCCESS) &&
                (cbSize > sizeof(DWORD)))
            {
                UINT uSize = (UINT)cbSize;
                DWORD *pData = (DWORD *)LocalAlloc(LPTR, uSize);
                if (pData)
                {
                    DWORD dwType;
                    DWORD cbSize = (DWORD)uSize;
                    
                    if ((RegQueryValueEx(hkey, (LPTSTR)pszValueName, 0, &dwType, (LPVOID)pData, &cbSize) == ERROR_SUCCESS) &&
                        (dwType == REG_BINARY) &&
                        (cbSize == (DWORD)uSize))
                    {
                        int iButtonIndex;

                        NMTBRESTORE nmtbs;
                        BOOL fAlloced = FALSE;
                        nmtbs.pData = pData;
                        nmtbs.pCurrent = pData;
                        nmtbs.iItem = -1; // signal pre saving
                        nmtbs.cButtons = (int)uSize / SIZEOF(DWORD);
                        nmtbs.cbBytesPerRecord = SIZEOF(DWORD);
                        nmtbs.cbData = uSize;
                        // since we don't know the cButtons if they've added on extra data to pData,
                        // we'll use whatever they fill for cButtons
                        if (!CCSendNotify(&ptb->ci, TBN_RESTORE, &nmtbs.hdr))
                        {
                            //
                            // Before reloading the buttons, delete the tooltips
                            // of the previous buttons (if they exist).
                            //
                            if (ptb && ptb->hwndToolTips)
                            {
                                TOOLINFO ti;

                                ti.cbSize = sizeof(ti);
                                ti.hwnd = ptb->ci.hwnd;

                                for (iButtonIndex = 0;
                                     iButtonIndex < ptb->iNumButtons; iButtonIndex++)
                                {
                                    if (!(ptb->Buttons[iButtonIndex].fsStyle & TBSTYLE_SEP))
                                    {
                                        ti.uId = ptb->Buttons[iButtonIndex].idCommand;
                                        SendMessage(ptb->hwndToolTips, TTM_DELTOOL,
                                            0, (LPARAM)(LPTOOLINFO)&ti);
                                    }
                                }
                            }

                            // grow (or maybe shrink) pbt to hold new buttons
                            if (TBReallocButtons(ptb, nmtbs.cButtons))
                            {
                                int i;
                                if (ptb->iNumButtons < nmtbs.cButtons)
                                    ZeroMemory(&ptb->Buttons[ptb->iNumButtons], (nmtbs.cButtons - ptb->iNumButtons) * sizeof(TBBUTTON));
                                ptb->iNumButtons = nmtbs.cButtons;

                                for (i = 0; i < ptb->iNumButtons; i++)
                                {
                                    nmtbs.iItem = i;

                                    if ((long)*nmtbs.pCurrent < 0)
                                    {
                                        ptb->Buttons[i].fsStyle = TBSTYLE_SEP;
                                        ptb->Buttons[i].DUMMYUNION_MEMBER(iBitmap) = g_dxButtonSep;
                                        ptb->Buttons[i].idCommand = 0;
                                        if (*nmtbs.pCurrent == (DWORD)-1)
                                            ptb->Buttons[i].fsState = 0;
                                        else
                                        {
                                            ASSERT(*nmtbs.pCurrent == (DWORD)-2);
                                            ptb->Buttons[i].fsState = TBSTATE_HIDDEN;
                                        }
                                    }
                                    else
                                    {
                                        ptb->Buttons[i].fsStyle = 0;
                                        ptb->Buttons[i].idCommand = *nmtbs.pCurrent;
                                        ptb->Buttons[i].DUMMYUNION_MEMBER(iBitmap) = -1;
                                    }
                                    
                                    nmtbs.pCurrent++;
                                    
                                    TBOutputStruct(ptb, &ptb->Buttons[i], &nmtbs.tbButton);
                                    CCSendNotify(&ptb->ci, TBN_RESTORE, &nmtbs.hdr);
                                    ASSERT(nmtbs.tbButton.iString == -1 || !HIWORD(nmtbs.tbButton.iString));
                                    // we don't thunk.  only allow string index in string pool here
                                    if (HIWORD(nmtbs.tbButton.iString))
                                        nmtbs.tbButton.iString = 0;
                                    TBInputStruct(ptb, &ptb->Buttons[i], &nmtbs.tbButton);
                                }

                                // Now query for all buttons, and fill in the rest of the info

                                // For backward compatibility, ignore return value of TBN_BEGINADJUST
                                // if client is older than version 5 (NT5 #185499).
                                if (!SendCmdNotify(ptb, TBN_BEGINADJUST) || (ptb->ci.iVersion < 5))
                                {
                                    for (i = 0; ; i++)
                                    {
                                        TBBUTTONDATA tbAdjust;

                                        tbAdjust.idCommand = 0;

                                        if (!GetAdjustInfo(ptb, i, &tbAdjust, szDesc, ARRAYSIZE(szDesc)))
                                            break;

                                        if (!(tbAdjust.fsStyle & TBSTYLE_SEP) || tbAdjust.idCommand)
                                        {
                                            int iPos = PositionFromID(ptb, tbAdjust.idCommand);
                                            if (iPos >= 0)
                                            {
                                                ptb->Buttons[iPos] = tbAdjust;
                                            }
                                        }

                                    }
                                    SendCmdNotify(ptb, TBN_ENDADJUST);
                                }

                                // cleanup all the buttons that were not recognized
                                // do this backwards to minimize data movement (and nmtbs.cButtons changes)
                                for (i = ptb->iNumButtons - 1; i >= 0; i--)
                                {
                                    // DeleteButton does no realloc, so ptb will not move
                                    if (ptb->Buttons[i].DUMMYUNION_MEMBER(iBitmap) < 0)
                                        DeleteButton(ptb, (UINT)i);
                                    else
                                    {
                                        // the rest, add to tooltips 
                                        if(ptb->hwndToolTips &&
                                          (!(ptb->Buttons[i].fsStyle & TBSTYLE_SEP || !ptb->Buttons[i].idCommand)))
                                        {
                                            TOOLINFO ti;
                                            // don't bother setting the rect because we'll do it below
                                            // in TBInvalidateItemRects;
                                            ti.cbSize = sizeof(ti);
                                            ti.uFlags = 0;
                                            ti.hwnd = ptb->ci.hwnd;
                                            ti.uId = ptb->Buttons[i].idCommand;
                                            ti.lpszText = LPSTR_TEXTCALLBACK;

                                            SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
                                        }
                                    }

                                }
                                bRet = (ptb->iNumButtons != 0); // success

                                // Bug#94368: break autosize to a function and call it
                                SendMessage(ptb->ci.hwnd, TB_AUTOSIZE, 0, 0);
                                InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
                                TBInvalidateItemRects(ptb);
                            }
                        }
                    }
                    LocalFree((HLOCAL)pData);
                }
            }
            RegCloseKey(hkey);
        }
    }
    
    return bRet;
}

void CustomizeTB(PTBSTATE ptb, int iPos)
{
    ADJUSTDLGDATA ad;
    HWND hwndT = ptb->ci.hwnd;  // ptb will change across call below
    HRSRC hrsrc;
    LANGID wLang;
    LPVOID pTemplate;

    if (ptb->hdlgCust)      // We are already customizing this toolbar
        return;
    
    ad.ptb = ptb;
    ad.iPos = iPos;
    
    // REVIEW: really should be per thread data, but not likely to cause a problem
    
    // see note in WM_MEASUREITEM code
    g_dyButtonHack = (ptb->ci.style & TBSTYLE_FLAT) ? ptb->iDyBitmap : ptb->iButHeight;
    
    SendCmdNotify(ptb, TBN_BEGINADJUST);

    //
    //  Do locale-specific futzing.
    //
    wLang = LANGIDFROMLCID(CCGetProperThreadLocale(NULL));
    hrsrc = FindResourceExRetry(HINST_THISDLL, RT_DIALOG, MAKEINTRESOURCE(ADJUSTDLG), wLang);
    if (hrsrc &&
        (pTemplate = (LPVOID)LoadResource(HINST_THISDLL, hrsrc)))
    {
        DialogBoxIndirectParam(HINST_THISDLL, pTemplate,
                   ptb->ci.hwndParent, AdjustDlgProc, (LPARAM)(LPADJUSTDLGDATA)&ad);
    }

    // ptb probably changed across above call
    ptb = (PTBSTATE)GetWindowInt(hwndT, 0);
    ptb->hdlgCust = NULL;
    
    SendCmdNotify(ptb, TBN_ENDADJUST);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\subclass.c ===
#include "ctlspriv.h"

///////////////////////////////////////////////////////////////////////////////
// SUBCLASS.C -- subclassing helper functions
//
//      SetWindowSubclass
//      GetWindowSubclass
//      RemoveWindowSubclass
//      DefSubclassProc
//
//  This module defines helper functions that make subclassing windows safe(er)
// and easy(er).  The code maintains a single property on the subclassed window
// and dispatches various "subclass callbacks" to its clients a required.  The
// client is provided reference data and a simple "default processing" API.
//
// Semantics:
//  A "subclass callback" is identified by a unique pairing of a callback
// function pointer and an unsigned ID value.  Each callback can also store a
// single DWORD of reference data, which is passed to the callback function
// when it is called to filter messages.  No reference counting is performed
// for the callback, it may repeatedly call the SetWindowSubclass API to alter
// the value of its reference data element as desired.
//
// Warning: You cannot use these to subclass a window across threads since
//          the critical sections have been removed. 05-May-97
//
// History:
//  26-April-96  francish        Created.
//  05-May  -97  davidds         Stopped serializing the world.
///////////////////////////////////////////////////////////////////////////////
//
// NOTE: Although a linked list would have made the code slightly simpler, this
// module uses a packed callback array to avoid unneccessary fragmentation.  fh
//
struct _SUBCLASS_HEADER;

typedef struct
{
    SUBCLASSPROC    pfnSubclass;        // subclass procedure
    WPARAM          uIdSubclass;        // unique subclass identifier
    DWORD_PTR        dwRefData;          // optional ref data

} SUBCLASS_CALL;

typedef struct _SUBCLASS_FRAME
{
    UINT uCallIndex;                    // index of next callback to call
    UINT uDeepestCall;                  // deepest uCallIndex on stack
    struct _SUBCLASS_FRAME *pFramePrev; // previous subclass frame pointer
    struct _SUBCLASS_HEADER *pHeader;   // header associated with this frame

} SUBCLASS_FRAME;

typedef struct _SUBCLASS_HEADER
{
    UINT uRefs;                         // subclass count
    UINT uAlloc;                        // allocated subclass call nodes
    UINT uCleanup;                      // index of call node to clean up
    DWORD dwThreadId;                   // thread id of window we are hooking
    SUBCLASS_FRAME *pFrameCur;          // current subclass frame pointer
    SUBCLASS_CALL CallArray[1];         // base of packed call node array

} SUBCLASS_HEADER;

#define CALLBACK_ALLOC_GRAIN (3)        // 1 defproc, 1 subclass, 1 spare


#ifdef DEBUG
BOOL IsValidPSUBCLASS_CALL(SUBCLASS_CALL * pcall)
{
    return (IS_VALID_WRITE_PTR(pcall, SUBCLASS_CALL) &&
            (NULL == pcall->pfnSubclass || IS_VALID_CODE_PTR(pcall->pfnSubclass, SUBCLASSPROC)));
}   

// The LITE version does not validate the pHeader.
// Use this if you expect the pHeader to be bad.
BOOL IsValidPSUBCLASS_FRAME_LITE(SUBCLASS_FRAME * pframe)
{
    return (IS_VALID_WRITE_PTR(pframe, SUBCLASS_FRAME) && 
            (NULL == pframe->pFramePrev || IS_VALID_WRITE_PTR(pframe->pFramePrev, SUBCLASS_FRAME)));
}    
 
// The regular version does all the LITE validation plus validates
// the pHeader.  Most people will use this version.
BOOL IsValidPSUBCLASS_FRAME(SUBCLASS_FRAME * pframe)
{
    return (IS_VALID_STRUCT_PTR(pframe, SUBCLASS_FRAME_LITE) &&
            IS_VALID_WRITE_PTR(pframe->pHeader, SUBCLASS_HEADER));
}

//
//  The LITE version validates the SUBCLASS_FRAME the LITE way rather
//  than the regular way.
//
BOOL IsValidPSUBCLASS_HEADER_LITE(SUBCLASS_HEADER * phdr)
{
    BOOL bRet = (IS_VALID_WRITE_PTR(phdr, SUBCLASS_HEADER) &&
                 (NULL == phdr->pFrameCur || IS_VALID_STRUCT_PTR(phdr->pFrameCur, SUBCLASS_FRAME_LITE)) &&
                 IS_VALID_WRITE_BUFFER(phdr->CallArray, SUBCLASS_CALL, phdr->uAlloc));

    if (bRet)
    {
        UINT i;
        SUBCLASS_CALL * pcall = phdr->CallArray;

        for (i = 0; i < phdr->uRefs; i++, pcall++)
        {
            if (!IS_VALID_STRUCT_PTR(pcall, SUBCLASS_CALL))
                return FALSE;
        }
    }
    return bRet;
}    

// The regular version does regular validation of the SUBCLASS_FRAME.
BOOL IsValidPSUBCLASS_HEADER(SUBCLASS_HEADER * phdr)
{
    return (IS_VALID_STRUCT_PTR(phdr, SUBCLASS_HEADER_LITE) &&
            (NULL == phdr->pFrameCur || IS_VALID_STRUCT_PTR(phdr->pFrameCur, SUBCLASS_FRAME)));
}

#endif

///////////////////////////////////////////////////////////////////////////////
// DEBUG CODE TO CHECK IF WINDOW IS ON SAME THREAD AS CALLER
// Since we don't do any serialization, we need this to make sure of this.
///////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG
BOOL IsWindowOnCurrentThread(HWND hWnd)
{
    DWORD foo;

    if (!IsWindow(hWnd))
        // bail if the window is dead so we dont bogusly rip
        return(TRUE);
    
    if (GetCurrentThreadId() != GetWindowThreadProcessId(hWnd, &foo))
    {
        DebugMsg(TF_ALWAYS, TEXT("wn: WindowSubclass - Called from wrong thread %08X"), hWnd);
        return(FALSE);
    }
    else
        return(TRUE);
              
}
#endif

///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK MasterSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam);
LRESULT CallNextSubclassProc(SUBCLASS_HEADER *pHeader, HWND hWnd, UINT uMsg,
    WPARAM wParam, LPARAM lParam);

//-----------------------------------------------------------------------------
// RETAIL_ZOMBIE_MESSAGE_WNDPROC
//
// this macro controls the generation of diagnostic code for an error condition
// in the subclass code (see the SubclassDeath function below).
//
// commenting out this macro will zombie windows using DefWindowProc instead.
//
//-----------------------------------------------------------------------------
//#define RETAIL_ZOMBIE_MESSAGE_WNDPROC

#if defined(RETAIL_ZOMBIE_MESSAGE_WNDPROC) || defined(DEBUG)
#ifndef DEBUG
#pragma message("\r\nWARNING: disable retail ZombieWndProc before final release\r\n")
#endif
LRESULT ZombieWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#else
#define ZombieWndProc DefWindowProc
#endif

//-----------------------------------------------------------------------------
// SubclassDeath
//
// this function is called if we ever enter one of our subclassing procedures
// without our reference data (and hence without the previous wndproc).
//
// hitting this represents a catastrophic failure in the subclass code.
//
// the function resets the wndproc of the window to a 'zombie' window
// procedure to avoid faulting.  the RETAIL_ZOMBIE_MESSAGE_WNDPROC macro above
// controls the generation of diagnostic code for this wndproc.
//
//-----------------------------------------------------------------------------
LRESULT SubclassDeath(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //
    // WE SHOULD NEVER EVER GET HERE
    // if we do please find francish to debug it immediately
    //
    DebugMsg(TF_ALWAYS, TEXT("fatal: SubclassDeath in window %08X"), hWnd);

#ifdef DEBUG    
    //
    // if we are in a debugger, stop now regardless of break flags
    //
    __try { DebugBreak(); } __except(EXCEPTION_EXECUTE_HANDLER) {;} __endexcept
#endif
    
    //
    // we call the outside world so prepare to deadlock if we have the critsec
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTNONCRITICAL
#endif

    //
    // in theory we could save the original wndproc in a separate property
    // but that just wastes memory for something that should never happen
    //
    // convert this window to a zombie in hopes that it will get debugged
    //
    InvalidateRect(hWnd, NULL, TRUE);
    SubclassWindow(hWnd, ZombieWndProc);
    return ZombieWndProc(hWnd, uMsg, wParam, lParam);
}

//-----------------------------------------------------------------------------
// GetWindowProc
//
// this inline function returns the current wndproc for the specified window.
//
//-----------------------------------------------------------------------------
__inline WNDPROC GetWindowProc(HWND hWnd)
{
    return (WNDPROC)GetWindowLongPtr(hWnd, GWLP_WNDPROC);
}

//-----------------------------------------------------------------------------
// g_aCC32Subclass
//
// This is the global ATOM we use to store our SUBCLASS_HEADER property on
// random windows that come our way.
//
//  HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK
//
//  Win95's property code is BROKEN.  If you SetProp using a text string, USER
// adds and removes atoms for the property symmetrically, including when the
// window is destroyed with properties lying around (good).  Unfortunately, if
// you SetProp using a global atom, USER doesn't do things quite right in the
// window cleanup case.  It uses the atom without adding references in SetProp
// calls and without deleting them in RemoveProp calls (good so far).  However,
// when a window with one of these properties lying around is cleaned up, USER
// will delete the atom on you.  This tends to break apps that do the
// following:
//
//  - MyAtom = GlobalAddAtom("foo");            // at app startup
//  - SetProp(SomeWindow, MyAtom, MyData);
//  - <window gets destroyed, USER deletes atom>
//  - <time passes>
//  - SetProp(SomeOtherWindow, MyAtom, MyData); // fails or uses random atom
//  - GlobalDeleteAtom(MyAtom);                 // fails or deletes random atom
//
//  One might be tempted to ask why this file uses atom properties if they are
// so broken.  Put simply, it is the only way to defend yourself against other
// apps that use atom properties (like the one described above).  Imagine that
// we call SetProp(OurWindow, "bar", OurData) in some other app at about the
// <time passes> point in the sequence above.  USER has just nuked some poor
// app's atom, and we wander into SetProp, which calls GlobalAddAtom, which
// just happens to give us the free slot created by USER's window cleanup code.
// Now we have a real problem because the very same atom is sitting in some
// global variable in the other app, just waiting to be deleted when that app
// exits (Peachtree Accounting tends to be very good at this...)  Of course the
// ultimate outcome of this is that we will call GetProp in some critical
// routine and our data will have vanished (it's actually still in the window's
// property table but GetProp("bar") calls GlobalFindAtom("bar") to get the
// atom to scan the property table for; and that call will fail so the property
// will be missed and we'll get back NULL).
//
//  Basically, we create an atom and aggressively increment its reference count
// so that it can withstand a few GlobalDeleteAtom calls every now and then.
// Since we are using an atom property, we need to worry about USER's cleanup
// code nuking us too.  Thus we just keep incrementing the reference count
// until it pegs.
//
// IEUNIX 
// We doesn't have the above problems, but MainWin SetProp implementation
// doesn't create GlobalAtom when it gets 2nd argument as a string.
// And it doesn't have to - that's non-documented NT/Win95 implementation.
// So, if UNIX, we will use the ATOM in all the cases, marking #ifdef MAINWIN.
//
//  HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK
//
//-----------------------------------------------------------------------------
extern ATOM g_aCC32Subclass;

//-----------------------------------------------------------------------------
// FastGetSubclassHeader
//
// this inline function returns the subclass header for the specified window.
// if the window has no subclass header the return value is NULL.
//
//-----------------------------------------------------------------------------
__inline SUBCLASS_HEADER *FastGetSubclassHeader(HWND hWnd)
{
    return  (g_aCC32Subclass ?
            ((SUBCLASS_HEADER *)GetProp(hWnd, MAKEINTATOM(g_aCC32Subclass))) :
            NULL);
}

//-----------------------------------------------------------------------------
// GetSubclassHeader
//
// this function returns the subclass header for the specified window.  it
// fails if the caller is on the wrong process, but will allow the caller to
// get the header from a thread other than the specified window's thread.
//
//-----------------------------------------------------------------------------
SUBCLASS_HEADER *GetSubclassHeader(HWND hWnd)
{
    DWORD dwProcessId;

    //
    // only return the header if we are in the right process
    //
    if (!GetWindowThreadProcessId(hWnd, &dwProcessId))
        dwProcessId = 0;

    if (dwProcessId != GetCurrentProcessId())
    {
        if (dwProcessId)
            DebugMsg(TF_ALWAYS, TEXT("error: XxxWindowSubclass - wrong process for window %08X"), hWnd);

        ASSERT(FALSE);
        return NULL;
    }

    if (g_aCC32Subclass == 0) 
    {
        //
        // HACK: we are intentionally incrementing the refcount on this atom
        // WE DO NOT WANT IT TO GO BACK DOWN so we will not delete it in process
        // detach (see comments for g_aCC32Subclass in subclass.c for more info)
        //
        ATOM a;
        if ((a = GlobalAddAtom(c_szCC32Subclass)) != 0)
            g_aCC32Subclass = a;    // in case the old atom got nuked
    }


    //
    // return the header
    //
    return FastGetSubclassHeader(hWnd);
}

//-----------------------------------------------------------------------------
// SetSubclassHeader
//
// this function sets the subclass header for the specified window.
//
//-----------------------------------------------------------------------------
BOOL SetSubclassHeader(HWND hWnd, SUBCLASS_HEADER *pHeader,
    SUBCLASS_FRAME *pFrameFixup)
{
    BOOL fResult = TRUE;    // assume success

    ASSERT(NULL == pHeader || IS_VALID_STRUCT_PTR(pHeader, SUBCLASS_HEADER_LITE));
    ASSERT(NULL == pFrameFixup || IS_VALID_STRUCT_PTR(pFrameFixup, SUBCLASS_FRAME_LITE));

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;         // we are partying on the header and frame list
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));
#endif

    //
    // update the frame list if required
    //
    while (pFrameFixup)
    {
        pFrameFixup->pHeader = pHeader;
        pFrameFixup = pFrameFixup->pFramePrev;
    }

    //
    // do we have a window to update?
    //
    if (hWnd)
    {
        //
        // update/remove the property as required
        //
        if (!pHeader)
        {
            //
            // HACK: we remove with an ATOM so the refcount won't drop
            //          (see comments for g_aCC32Subclass above)
            //
            RemoveProp(hWnd, MAKEINTATOM(g_aCC32Subclass));
        }
        else
        {
            LPCTSTR lpPropAtomOrStr;
#ifndef MAINWIN
            //
            // HACK: we add using a STRING so the refcount will go up
            //          (see comments for g_aCC32Subclass above)
            //
            lpPropAtomOrStr = c_szCC32Subclass;
#else
            if (! g_aCC32Subclass) 
                g_aCC32Subclass = GlobalAddAtom(c_szCC32Subclass);
        
            if (! g_aCC32Subclass) {
                DebugMsg(TF_ALWAYS, TEXT("wn: SetWindowSubclass - couldn't subclass window %08X\
                         GlobalAddAtom failed for %s"), hWnd, c_szCC32Subclass);
                return FALSE;
            }
            lpPropAtomOrStr = g_aCC32Subclass;
#endif
            if (!SetProp(hWnd, lpPropAtomOrStr, (HANDLE)pHeader))
            {
                DebugMsg(TF_ALWAYS, TEXT("wn: SetWindowSubclass - couldn't subclass window %08X"), hWnd);
                fResult = FALSE;
            }
        }
    }

    return fResult;
}

//-----------------------------------------------------------------------------
// FreeSubclassHeader
//
// this function frees the subclass header for the specified window.
//
//-----------------------------------------------------------------------------
void FreeSubclassHeader(HWND hWnd, SUBCLASS_HEADER *pHeader)
{
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;                 // we will be removing the subclass header
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

    //
    // sanity
    //
    if (!pHeader)
    {
        ASSERT(FALSE);
        return;
    }

    //
    // clean up the header
    //
    SetSubclassHeader(hWnd, NULL, pHeader->pFrameCur);
    LocalFree((HANDLE)pHeader);
}

//-----------------------------------------------------------------------------
// ReAllocSubclassHeader
//
// this function allocates/reallocates a subclass header for the specified
// window.
//
//-----------------------------------------------------------------------------
SUBCLASS_HEADER *ReAllocSubclassHeader(HWND hWnd, SUBCLASS_HEADER *pHeader,
    UINT uCallbacks)
{
    UINT uAlloc;

    ASSERT(NULL == pHeader || IS_VALID_STRUCT_PTR(pHeader, SUBCLASS_HEADER));

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;     // we will be replacing the subclass header
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

    //
    // granularize the allocation
    //
    uAlloc = CALLBACK_ALLOC_GRAIN *
        ((uCallbacks + CALLBACK_ALLOC_GRAIN - 1) / CALLBACK_ALLOC_GRAIN);

    //
    // do we need to change the allocation?
    //
    if (!pHeader || (uAlloc != pHeader->uAlloc))
    {
        //
        // compute bytes required
        //
        uCallbacks = uAlloc * sizeof(SUBCLASS_CALL) + sizeof(SUBCLASS_HEADER);

        //
        // and try to alloc
        //
        pHeader = CCLocalReAlloc(pHeader, uCallbacks);

        //
        // did it work?
        //
        if (pHeader)
        {
            //
            // yup, update info
            //
            pHeader->uAlloc = uAlloc;

            if (!SetSubclassHeader(hWnd, pHeader, pHeader->pFrameCur))
            {
                FreeSubclassHeader(hWnd, pHeader);
                pHeader = NULL;
            }

        }
    }

    return pHeader;
}

//-----------------------------------------------------------------------------
// CallOriginalWndProc
//
// this procedure is the default SUBCLASSPROC which is always installed when we
// subclass a window.  the original window procedure is installed as the
// reference data for this callback.  it simply calls the original wndproc and
// returns its result.
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK CallOriginalWndProc(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    //
    // dwRefData should be the original window procedure
    //
    ASSERT(dwRefData);

    //
    // and call it
    //
    return CallWindowProc((WNDPROC)dwRefData, hWnd, uMsg, wParam, lParam);
}

//-----------------------------------------------------------------------------
// AttachSubclassHeader
//
// this procedure makes sure that a given window is subclassed by us.  it
// maintains a reference count on the data structures associated with our
// subclass.  if the window is not yet subclassed by us then this procedure
// installs our subclass procedure and associated data structures.
//
//-----------------------------------------------------------------------------
SUBCLASS_HEADER *AttachSubclassHeader(HWND hWnd)
{
    SUBCLASS_HEADER *pHeader;
    DWORD dwThreadId;

    //
    // we party on the subclass call chain here
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

    //
    // we only call SetWindowLong for the first caller, which would cause this
    // operation to work out of context sometimes and fail others...
    // artifically prevent people from subclassing from the wrong thread
    //  
    if ((dwThreadId = GetWindowThreadProcessId(hWnd, NULL)) !=
        GetCurrentThreadId())
    {
        AssertMsg(FALSE, TEXT("error: SetWindowSubclass - wrong thread for window %08X"), hWnd);
        return NULL;
    }

    //
    // if haven't already subclassed the window then do it now
    //
    if ((pHeader = GetSubclassHeader(hWnd)) == NULL)
    {
        WNDPROC pfnOldWndProc;
        SUBCLASS_CALL *pCall;

        //
        // attach our header data to the window
        // we need space for two callbacks; the subclass and the original proc
        //
        if ((pHeader = ReAllocSubclassHeader(hWnd, NULL, 2)) == NULL)
            return NULL;

        pHeader->dwThreadId = dwThreadId;

        //
        // actually subclass the window
        //
        if ((pfnOldWndProc = SubclassWindow(hWnd, MasterSubclassProc)) == NULL)
        {
            // clean up and get out
            FreeSubclassHeader(hWnd, pHeader);
            return NULL;
        }

        //
        // set up the first node in the array to call the original wndproc
        //
        ASSERT(pHeader->uAlloc);

        pCall = pHeader->CallArray;
        pCall->pfnSubclass = CallOriginalWndProc;
        pCall->uIdSubclass = 0;
        pCall->dwRefData   = (DWORD_PTR)pfnOldWndProc;

        //
        // init our subclass refcount...
        //
        pHeader->uRefs = 1;
    }

    return pHeader;
}

//-----------------------------------------------------------------------------
// DetachSubclassHeader
//
// this procedure attempts to detach the subclass header from the specified
// window
//
//-----------------------------------------------------------------------------
void DetachSubclassHeader(HWND hWnd, SUBCLASS_HEADER *pHeader, BOOL fForce)
{
    WNDPROC pfnOldWndProc;
#ifdef DEBUG
    SUBCLASS_CALL *pCall;
    UINT uCur;
#endif

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;         // we party on the subclass call chain here
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    ASSERT(pHeader);        // fear

    //
    // if we are not being forced to remove and the window is still valid then
    // sniff around a little and decide if it's a good idea to detach now
    //
    if (!fForce && hWnd)
    {
        ASSERT(pHeader == FastGetSubclassHeader(hWnd)); // paranoia

        //
        // do we still have active clients?
        //
        if (pHeader->uRefs > 1)
            return;

        ASSERT(pHeader->uRefs); // should always have the "call original" node

        //
        // are people on our stack?
        //
        if (pHeader->pFrameCur)
            return;

        //
        // if we are out of context then we should try again later
        //
        if (pHeader->dwThreadId != GetCurrentThreadId())
        {
            SendNotifyMessage(hWnd, WM_NULL, 0, 0L);
            return;
        }

        //
        // we keep the original window procedure as refdata for our
        // CallOriginalWndProc subclass callback
        //
        pfnOldWndProc = (WNDPROC)pHeader->CallArray[0].dwRefData;
        ASSERT(pfnOldWndProc);

        //
        // if somebody else is subclassed after us then we can't detach now
        //
        if (GetWindowProc(hWnd) != MasterSubclassProc)
            return;

        //
        // go ahead and try to detach
        //
        if (!SubclassWindow(hWnd, pfnOldWndProc))
        {
            ASSERT(FALSE);      // just plain shouldn't happen
            return;
        }
    }

    //
    // warn about anybody who hasn't unhooked yet
    //
#ifdef DEBUG
    uCur = pHeader->uRefs;
    pCall = pHeader->CallArray + uCur;
    while (--uCur)          // don't complain about our 'call original' node
    {
        pCall--;
        if (pCall->pfnSubclass)
        {
            //
            // always warn about these they could be leaks
            //
            DebugMsg(TF_ALWAYS, TEXT("warning: orphan subclass: fn %08X, id %08X, dw %08X"),
                pCall->pfnSubclass, pCall->uIdSubclass, pCall->dwRefData);
        }
    }
#endif

    //
    // free the header now
    //
    FreeSubclassHeader(hWnd, pHeader);
}

//-----------------------------------------------------------------------------
// PurgeSingleCallNode
//
// this procedure purges a single dead node in the call array
//
//-----------------------------------------------------------------------------
void PurgeSingleCallNode(HWND hWnd, SUBCLASS_HEADER *pHeader)
{
    UINT uRemain;

    ASSERT(IS_VALID_STRUCT_PTR(pHeader, SUBCLASS_HEADER));

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;         // we will try to re-arrange the call array
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    
    if (!pHeader->uCleanup) // a little sanity
    {
        ASSERT(FALSE);      // nothing to do!
        return;
    }

    //
    // and a little paranoia
    //
    ASSERT(!pHeader->pFrameCur ||
        (pHeader->uCleanup < pHeader->pFrameCur->uDeepestCall));

    //
    // are there any call nodes above the one we're about to remove?
    //
    if ((uRemain = (pHeader->uRefs - pHeader->uCleanup)) > 0)
    {
        //
        // yup, need to fix up the array the hard way
        //
        SUBCLASS_CALL *pCall;
        SUBCLASS_FRAME *pFrame;
        UINT uCur, uMax;

        //
        // move the remaining nodes down into the empty space
        //
        pCall = pHeader->CallArray + pHeader->uCleanup;
        MoveMemory(pCall, pCall + 1, uRemain * sizeof(SUBCLASS_CALL));

        ASSERT(IS_VALID_STRUCT_PTR(pCall, SUBCLASS_CALL));

        //
        // update the call indices of any active frames
        //
        uCur = pHeader->uCleanup;
        pFrame = pHeader->pFrameCur;
        while (pFrame)
        {
            if (pFrame->uCallIndex >= uCur)
            {
                pFrame->uCallIndex--;

                if (pFrame->uDeepestCall >= uCur)
                    pFrame->uDeepestCall--;
            }

            pFrame = pFrame->pFramePrev;
        }

        //
        // now search for any other dead call nodes in the reamining area
        //
        uMax = pHeader->uRefs - 1;  // we haven't decremented uRefs yet
        while (uCur < uMax)
        {
            if (!pCall->pfnSubclass)
                break;

            pCall++;
            uCur++;
        }
        pHeader->uCleanup = (uCur < uMax)? uCur : 0;
    }
    else
    {
        //
        // nope, this case is easy
        //
        pHeader->uCleanup = 0;
    }

    //
    // finally, decrement the client count
    //
    pHeader->uRefs--;
}

//-----------------------------------------------------------------------------
// CompactSubclassHeader
//
// this procedure attempts to compact the subclass call array, freeing the
// subclass header if the array is empty
//
//-----------------------------------------------------------------------------
void CompactSubclassHeader(HWND hWnd, SUBCLASS_HEADER *pHeader)
{
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;         // we will try to re-arrange the call array
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pHeader, SUBCLASS_HEADER));

    //
    // we must handle the "window destroyed unexpectedly during callback" case
    //
    if (hWnd)
    {
        //
        // clean out as many dead callbacks as possible
        //
        while (pHeader->uCleanup && (!pHeader->pFrameCur ||
            (pHeader->uCleanup < pHeader->pFrameCur->uDeepestCall)))
        {
            PurgeSingleCallNode(hWnd, pHeader);
        }

        //
        // do we still have clients?
        //
        if (pHeader->uRefs > 1)
        {
            //
            // yes, shrink our allocation, leaving room for at least one client
            //
            ReAllocSubclassHeader(hWnd, pHeader, pHeader->uRefs + 1);
            return;
        }
    }

    //
    // try to detach and free
    //
    DetachSubclassHeader(hWnd, pHeader, FALSE);
}

//-----------------------------------------------------------------------------
// FindCallRecord
//
// this procedure searches for a call record with the specified subclass proc
// and id, and returns its address.  if no such call record is found then NULL
// is returned.
//
//-----------------------------------------------------------------------------
SUBCLASS_CALL *FindCallRecord(SUBCLASS_HEADER *pHeader,
    SUBCLASSPROC pfnSubclass, WPARAM uIdSubclass)
{
    SUBCLASS_CALL *pCall;
    UINT uCallIndex;

    ASSERT(IS_VALID_STRUCT_PTR(pHeader, SUBCLASS_HEADER));

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;         // we'll be scanning the call array
#endif

    //
    // scan the call array.  note that we assume there is always at least
    // one member in the table (our CallOriginalWndProc record)
    //
    pCall = pHeader->CallArray + (uCallIndex = pHeader->uRefs);
    do
    {
        uCallIndex--;
        pCall--;
        if ((pCall->pfnSubclass == pfnSubclass) &&
            (pCall->uIdSubclass == uIdSubclass))
        {
            return pCall;
        }
    }
    while (uCallIndex != (UINT)-1);

    return NULL;
}

//-----------------------------------------------------------------------------
// GetWindowSubclass
//
// this procedure retrieves the reference data for the specified window
// subclass callback
//
//-----------------------------------------------------------------------------
BOOL GetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
    DWORD_PTR *pdwRefData)
{
    SUBCLASS_HEADER *pHeader;
    SUBCLASS_CALL *pCall;
    BOOL fResult = FALSE;
    DWORD_PTR dwRefData = 0;

    //
    // sanity
    //
    if (!IsWindow(hWnd))
    {
        AssertMsg(FALSE, TEXT("error: GetWindowSubclass - %08X not a window"), hWnd);
        goto ReturnResult;
    }

    //
    // more sanity
    //
    if (!pfnSubclass
#ifdef DEBUG
        || IsBadCodePtr((PROC)pfnSubclass)
#endif
        )
    {
        AssertMsg(FALSE, TEXT("error: GetWindowSubclass - invalid callback %08X"), pfnSubclass);
        goto ReturnResult;
    }

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    
    //
    // if we've subclassed it and they are a client then get the refdata
    //
    if (((pHeader = GetSubclassHeader(hWnd)) != NULL) &&
        ((pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass)) != NULL))
    {
        //
        // fetch the refdata and note success
        //
        dwRefData = pCall->dwRefData;
        fResult = TRUE;
    }

#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

    //
    // we always fill in/zero pdwRefData regradless of result
    //
ReturnResult:
    if (pdwRefData)
        *pdwRefData = dwRefData;

    return fResult;
}

//-----------------------------------------------------------------------------
// SetWindowSubclass
//
// this procedure installs/updates a window subclass callback.  subclass
// callbacks are identified by their callback address and id pair.  if the
// specified callback/id pair is not yet installed then the procedure installs
// the pair.  if the callback/id pair is already installed then this procedure
// changes the refernce data for the pair.
//
//-----------------------------------------------------------------------------
BOOL SetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
    DWORD_PTR dwRefData)
{
    SUBCLASS_HEADER *pHeader;
    SUBCLASS_CALL *pCall;
    BOOL bResult;

    //
    // some sanity
    //
    if (!IsWindow(hWnd))
    {
        AssertMsg(FALSE, TEXT("error: SetWindowSubclass - %08X not a window"), hWnd);
        return FALSE;
    }

    //
    // more sanity
    //
    if (!pfnSubclass
#ifdef DEBUG
        || IsBadCodePtr((PROC)pfnSubclass)
#endif
        )
    {
        AssertMsg(FALSE, TEXT("error: SetWindowSubclass - invalid callback %08X"), pfnSubclass);
        return FALSE;
    }

    bResult = FALSE;    // assume failure


    //
    // we party on the subclass call chain here

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    //
    // actually subclass the window
    //
    if ((pHeader = AttachSubclassHeader(hWnd)) == NULL)
        goto bail;

    //
    // find a call node for this caller
    //
    if ((pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass)) == NULL)
    {
        //
        // not found, alloc a new one
        //
        SUBCLASS_HEADER *pHeaderT =
            ReAllocSubclassHeader(hWnd, pHeader, pHeader->uRefs + 1);

        if (!pHeaderT)
        {
            //
            // re-query in case it is already gone
            //
            if ((pHeader = FastGetSubclassHeader(hWnd)) != NULL)
                CompactSubclassHeader(hWnd, pHeader);

            goto bail;
        }

        pHeader = pHeaderT;
        pCall = pHeader->CallArray + pHeader->uRefs;
        pHeader->uRefs++;
    }

    //
    // fill in the subclass call data
    //
    pCall->pfnSubclass = pfnSubclass;
    pCall->uIdSubclass = uIdSubclass;
    pCall->dwRefData   = dwRefData;

    bResult = TRUE;

bail:
    //
    // release the critical section and return the result
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    return bResult;
}

//-----------------------------------------------------------------------------
// RemoveWindowSubclass
//
// this procedure removes a subclass callback from a window.  subclass
// callbacks are identified by their callback address and id pair.
//
//-----------------------------------------------------------------------------
BOOL RemoveWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass,
    UINT_PTR uIdSubclass)
{
    SUBCLASS_HEADER *pHeader;
    SUBCLASS_CALL *pCall;
    BOOL bResult;
    UINT uCall;

    //
    // some sanity
    //
    if (!IsWindow(hWnd))
    {
        AssertMsg(FALSE, TEXT("error: RemoveWindowSubclass - %08X not a window"), hWnd);
        return FALSE;
    }

    //
    // more sanity
    //
    if (!pfnSubclass
#ifdef DEBUG
        || IsBadCodePtr((PROC)pfnSubclass)
#endif
        )
    {
        AssertMsg(FALSE, TEXT("error: RemoveWindowSubclass - invalid callback %08X"), pfnSubclass);
        return FALSE;
    }

    bResult = FALSE;    // assume failure

    //
    // we party on the subclass call chain here

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

    //
    // obtain our subclass data
    //
    if ((pHeader = GetSubclassHeader(hWnd)) == NULL)
        goto bail;

    //
    // find the callback to remove
    //
    if ((pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass)) == NULL)
        goto bail;

    //
    // disable this node and remember that we have something to clean up
    //
    pCall->pfnSubclass = NULL;

    uCall = (UINT) (pCall - pHeader->CallArray);

    if (!pHeader->uCleanup || (uCall < pHeader->uCleanup))
        pHeader->uCleanup = uCall;

    //
    // now try to clean up any unused nodes
    //
    CompactSubclassHeader(hWnd, pHeader);
#ifdef DEBUG
    // the call above can realloc or free the subclass header for this window
    pHeader = NULL;
#endif

    bResult = TRUE;     // it worked

bail:
    //
    // release the critical section and return the result
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    return bResult;
}

//-----------------------------------------------------------------------------
// DefSubclassProc
//
// this procedure calls the next handler in the window's subclass chain.  the
// last handler in the subclass chain is installed by us, and calls the
// original window procedure for the window.
//
//-----------------------------------------------------------------------------
LRESULT DefSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SUBCLASS_HEADER *pHeader;
    LRESULT lResult = 0L;

    //
    // make sure the window is still valid
    //
    if (!IsWindow(hWnd))
    {
        AssertMsg(FALSE, TEXT("warning: DefSubclassProc - %08X not a window"), hWnd);
        goto BailNonCritical;
    }

    //
    // take the critical section while we figure out who to call next
    //

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
        
    //
    // complain if we are being called improperly
    //
    if ((pHeader = FastGetSubclassHeader(hWnd)) == NULL)
    {
        AssertMsg(FALSE, TEXT("error: DefSubclassProc - window %08X not subclassed"), hWnd);
        goto BailCritical;
    }
    else if (GetCurrentThreadId() != pHeader->dwThreadId)
    {
        AssertMsg(FALSE, TEXT("error: DefSubclassProc - wrong thread for window %08X"), hWnd);
        goto BailCritical;
    }
    else if (!pHeader->pFrameCur)
    {
        AssertMsg(FALSE, TEXT("error: DefSubclassProc - window %08X not in callback"), hWnd);
        goto BailCritical;
    }

    //
    // call the next proc in the subclass chain
    //
    // WARNING: this call temporarily releases the critical section
    // WARNING: pHeader is invalid when this call returns
    //
    lResult = CallNextSubclassProc(pHeader, hWnd, uMsg, wParam, lParam);
#ifdef DEBUG
    pHeader = NULL;
#endif

    //
    // return the result
    //
BailCritical:
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

BailNonCritical:
    return lResult;
}

//-----------------------------------------------------------------------------
// UpdateDeepestCall
//
// this procedure updates the deepest call index for the specified frame
//
//-----------------------------------------------------------------------------
void UpdateDeepestCall(SUBCLASS_FRAME *pFrame)
{
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;     // we are partying on the frame list
#endif

    if (pFrame->pFramePrev &&
        (pFrame->pFramePrev->uDeepestCall < pFrame->uCallIndex))
    {
        pFrame->uDeepestCall = pFrame->pFramePrev->uDeepestCall;
    }
    else
        pFrame->uDeepestCall = pFrame->uCallIndex;
}

//-----------------------------------------------------------------------------
// EnterSubclassFrame
//
// this procedure sets up a new subclass frame for the specified header, saving
// away the previous one
//
//-----------------------------------------------------------------------------
__inline void EnterSubclassFrame(SUBCLASS_HEADER *pHeader,
    SUBCLASS_FRAME *pFrame)
{
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;     // we are partying on the header and frame list
#endif

    //
    // fill in the frame and link it into the header
    //
    pFrame->uCallIndex   = pHeader->uRefs;
    pFrame->pFramePrev   = pHeader->pFrameCur;
    pFrame->pHeader      = pHeader;
    pHeader->pFrameCur   = pFrame;

    //
    // initialize the deepest call index for this frame
    //
    UpdateDeepestCall(pFrame);
}

//-----------------------------------------------------------------------------
// LeaveSubclassFrame
//
// this procedure cleans up the current subclass frame for the specified
// header, restoring the previous one
//
//-----------------------------------------------------------------------------
__inline SUBCLASS_HEADER *LeaveSubclassFrame(SUBCLASS_FRAME *pFrame)
{
    SUBCLASS_HEADER *pHeader;

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;     // we are partying on the header
#endif

    //
    // unlink the frame from its header (if it still exists)
    //
    if ((pHeader = pFrame->pHeader) != NULL)
        pHeader->pFrameCur = pFrame->pFramePrev;

    return pHeader;
}

//-----------------------------------------------------------------------------
// SubclassFrameException
//
// this procedure cleans up when an exception is thrown from a subclass frame
//
//-----------------------------------------------------------------------------
void SubclassFrameException(SUBCLASS_FRAME *pFrame)
{
    //
    // clean up the current subclass frame
    //

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#endif
    DebugMsg(TF_ALWAYS, TEXT("warning: cleaning up subclass frame after exception"));
    LeaveSubclassFrame(pFrame);
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#endif
}

//-----------------------------------------------------------------------------
// MasterSubclassProc
//
// this is the window procedure we install to dispatch subclass callbacks.
// it maintains a linked list of 'frames' through the stack which allow
// DefSubclassProc to call the right subclass procedure in multiple-message
// scenarios.
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK MasterSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam)
{
    SUBCLASS_FRAME Frame;
    SUBCLASS_HEADER *pHeader;
    LRESULT lResult = 0;

    //
    // prevent people from partying on the callback chain while we look at it
    //

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    //
    // we're in big trouble if we got here and we don't have our data
    //
    if ((pHeader = FastGetSubclassHeader(hWnd)) == NULL)
    {
#ifdef FREETHREADEDSUBCLASSGOOP
        LEAVECRITICAL;
#else
        ASSERT(IsWindowOnCurrentThread(hWnd));        
#endif
        return SubclassDeath(hWnd, uMsg, wParam, lParam);
    }

    //
    // set up a new subclass frame and save away the previous one
    //
    EnterSubclassFrame(pHeader, &Frame);

    __try   // protect our state information from exceptions
    {
        //
        // go ahead and call the subclass chain on this frame
        //
        // WARNING: this call temporarily releases the critical section
        // WARNING: pHeader is invalid when this call returns
        //
        lResult =
            CallNextSubclassProc(pHeader, hWnd, uMsg, wParam, lParam);
#ifdef DEBUG
        pHeader = NULL;
#endif
    }
    __except ((SubclassFrameException(&Frame), EXCEPTION_CONTINUE_SEARCH))
    {
        ASSERT(FALSE);
    }
    __endexcept

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

    //
    // restore the previous subclass frame
    //
    pHeader = LeaveSubclassFrame(&Frame);

    //
    // if the header is gone we have already cleaned up in a nested frame
    //
    if (!pHeader)
        goto BailOut;

    //
    // was the window nuked (somehow) without us seeing the WM_NCDESTROY?
    //
    if (!IsWindow(hWnd))
    {
        //
        // EVIL! somebody subclassed after us and didn't pass on WM_NCDESTROY
        //
        AssertMsg(FALSE, TEXT("unknown subclass proc swallowed a WM_NCDESTROY"));

        // go ahead and clean up now
        hWnd = NULL;
        uMsg = WM_NCDESTROY;
    }

    //
    // if we are returning from a WM_NCDESTROY then we need to clean up
    //
    if (uMsg == WM_NCDESTROY)
    {
        DetachSubclassHeader(hWnd, pHeader, TRUE);
        goto BailOut;
    }

    //
    // is there any pending cleanup, or are all our clients gone?
    //
    if (pHeader->uCleanup || (!pHeader->pFrameCur && (pHeader->uRefs <= 1)))
    {
        CompactSubclassHeader(hWnd, pHeader);
#ifdef DEBUG
        pHeader = NULL;
#endif
    }

    //
    // all done
    //
BailOut:
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#endif
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTNONCRITICAL;
#endif
    return lResult;
}

//-----------------------------------------------------------------------------
// EnterSubclassCallback
//
// this procedure finds the next callback in the subclass chain and updates
// pFrame to indicate that we are calling it
//
//-----------------------------------------------------------------------------
UINT EnterSubclassCallback(SUBCLASS_HEADER *pHeader, SUBCLASS_FRAME *pFrame,
    SUBCLASS_CALL *pCallChosen)
{
    SUBCLASS_CALL *pCall;
    UINT uDepth;

    //
    // we will be scanning the subclass chain and updating frame data
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;
#endif

    //
    // scan the subclass chain for the next callable subclass callback
    //
    pCall = pHeader->CallArray + pFrame->uCallIndex;
    uDepth = 0;
    do
    {
        uDepth++;
        pCall--;

    } while (!pCall->pfnSubclass);

    //
    // copy the callback information for the caller
    //
    pCallChosen->pfnSubclass = pCall->pfnSubclass;
    pCallChosen->uIdSubclass = pCall->uIdSubclass;
    pCallChosen->dwRefData   = pCall->dwRefData;

    //
    // adjust the frame's call index by the depth we entered
    //
    pFrame->uCallIndex -= uDepth;

    //
    // keep the deepest call index up to date
    //
    UpdateDeepestCall(pFrame);

    return uDepth;
}

//-----------------------------------------------------------------------------
// LeaveSubclassCallback
//
// this procedure finds the next callback in the cal
//
//-----------------------------------------------------------------------------
__inline void LeaveSubclassCallback(SUBCLASS_FRAME *pFrame, UINT uDepth)
{
    //
    // we will be updating subclass frame data
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;
#endif

    //
    // adjust the frame's call index by the depth we entered and return
    //
    pFrame->uCallIndex += uDepth;

    //
    // keep the deepest call index up to date
    //
    UpdateDeepestCall(pFrame);
}

//-----------------------------------------------------------------------------
// SubclassCallbackException
//
// this procedure cleans up when a subclass callback throws an exception
//
//-----------------------------------------------------------------------------
void SubclassCallbackException(SUBCLASS_FRAME *pFrame, UINT uDepth)
{
    //
    // clean up the current subclass callback
    //

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#endif
    DebugMsg(TF_ALWAYS, TEXT("warning: cleaning up subclass callback after exception"));
    LeaveSubclassCallback(pFrame, uDepth);
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#endif
}

//-----------------------------------------------------------------------------
// CallNextSubclassProc
//
// this procedure calls the next subclass callback in the subclass chain
//
// WARNING: this call temporarily releases the critical section
// WARNING: pHeader is invalid when this call returns
//
//-----------------------------------------------------------------------------
LRESULT CallNextSubclassProc(SUBCLASS_HEADER *pHeader, HWND hWnd, UINT uMsg,
    WPARAM wParam, LPARAM lParam)
{
    SUBCLASS_CALL Call;
    SUBCLASS_FRAME *pFrame;
    LRESULT lResult;
    UINT uDepth;

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;     // sanity
#endif
    ASSERT(pHeader);    // paranoia

    //
    // get the current subclass frame
    //
    pFrame = pHeader->pFrameCur;
    ASSERT(pFrame);

    //
    // get the next subclass call we need to make
    //
    uDepth = EnterSubclassCallback(pHeader, pFrame, &Call);

    //
    // leave the critical section so we don't deadlock in our callback
    //
    // WARNING: pHeader is invalid when this call returns
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#endif
#ifdef DEBUG
    pHeader = NULL;
#endif

    //
    // we call the outside world so prepare to deadlock if we have the critsec
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTNONCRITICAL;
#endif

    __try   // protect our state information from exceptions
    {
        //
        // call the chosen subclass proc
        //
        ASSERT(Call.pfnSubclass);

        lResult = Call.pfnSubclass(hWnd, uMsg, wParam, lParam,
            Call.uIdSubclass, Call.dwRefData);
    }
    __except ((SubclassCallbackException(pFrame, uDepth),
        EXCEPTION_CONTINUE_SEARCH))
    {
        ASSERT(FALSE);
    }
    __endexcept

    //
    // we left the critical section before calling out so re-enter it
    //

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#endif
    
    //
    // finally, clean up and return
    //
    LeaveSubclassCallback(pFrame, uDepth);
    return lResult;
}

///////////////////////////////////////////////////////////////////////////////

#if defined(RETAIL_ZOMBIE_MESSAGE_WNDPROC) || defined(DEBUG)
#ifdef DEBUG
static const TCHAR c_szZombieMessage[] =                                     \
    TEXT("This window has encountered an internal error which is preventing ")    \
    TEXT("it from operating normally.\r\n\nPlease report this problem to ")       \
    TEXT("FrancisH immediately.");
#else
static const TCHAR c_szZombieMessage[] =                                     \
    TEXT("This window has encountered an internal error which is preventing ")    \
    TEXT("it from operating normally.\r\n\nPlease report this as a bug in the ")  \
    TEXT("COMCTL32 library.");
#endif

LRESULT ZombieWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_ERASEBKGND:
        {
            HDC hDC = (HDC)wParam;
            HBRUSH hBrush = CreateSolidBrush(RGB(255,255,0));

            if (hBrush)
            {
                RECT rcErase;

                switch (GetClipBox(hDC, &rcErase))
                {
                default:
                    FillRect(hDC, &rcErase, hBrush);
                    break;
                case NULLREGION:
                case ERROR:
                    break;
                }

                DeleteBrush(hBrush);
            }
        }
        return 1;

    case WM_PAINT:
        {
            RECT rcClient;
            PAINTSTRUCT ps;
            HDC hDC = BeginPaint(hWnd, &ps);

            if (hDC && GetClientRect(hWnd, &rcClient))
            {
                COLORREF clrBkSave = SetBkColor(hDC, RGB(255,255,0));
                COLORREF clrFgSave = SetTextColor(hDC, RGB(255,0,0));

                DrawText(hDC, c_szZombieMessage, -1, &rcClient,
                    DT_LEFT | DT_TOP | DT_NOPREFIX | DT_WORDBREAK |
                    DT_WORD_ELLIPSIS);

                SetTextColor(hDC, clrFgSave);
                SetBkColor(hDC, clrBkSave);
            }

            EndPaint(hWnd, &ps);
        }
        return 0;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}
#endif

///////////////////////////////////////////////////////////////////////////////
//
//  See comments in InitForWinlogon() for an explanation of why this is
//  necessary.
//

// FixupEnumChildWindowProc
//      hwnd = child window
//      lParam = new ATOM for subclass data
//
// If this window has an old subclass record, move it to the new atom

BOOL CALLBACK FixupEnumChildWindowProc(HWND hwnd, LPARAM lParam)
{
    HANDLE hSubclass = RemoveProp(hwnd, MAKEINTATOM(g_aCC32Subclass));
    if (hSubclass)
    {
        SetProp(hwnd, (LPCTSTR)lParam, hSubclass);
    }
    return TRUE;
}

// FixupEnumWindowProc
//      hwnd = top-level window
//      lParam = new ATOM for subclass data
//
// If this window belongs to our process, fix it up and fix up
// all its children, too.

BOOL CALLBACK FixupEnumWindowProc(HWND hwnd, LPARAM lParam)
{
    DWORD dwPid;
    if (GetWindowThreadProcessId(hwnd, &dwPid) &&
        dwPid == GetCurrentProcessId())
    {
        FixupEnumChildWindowProc(hwnd, lParam); // fix up the window itself
        EnumChildWindows(hwnd, FixupEnumChildWindowProc, lParam); // and all its kids
    }
    return TRUE;
}

//
//  FixupEnumDesktopProc
//      lpszDesktop = desktop name
//      lParam = new ATOM for subclass data
//

BOOL CALLBACK FixupEnumDesktopProc(LPTSTR lpszDesktop, LPARAM lParam)
{
    HDESK hdesk = OpenDesktop(lpszDesktop, 0, FALSE,
                              DESKTOP_ENUMERATE | DESKTOP_READOBJECTS |
                              DESKTOP_WRITEOBJECTS);
    if (hdesk)
    {
        HDESK hdeskPrev = GetThreadDesktop(GetCurrentThreadId());
        if (hdeskPrev)
        {
            if (SetThreadDesktop(hdesk))
            {
                EnumWindows(FixupEnumWindowProc, lParam);
                SetThreadDesktop(hdeskPrev);
            }
        }
        CloseDesktop(hdesk);
    }
    return TRUE;
}

STDAPI_(void) FixupSubclassRecordsAfterLogoff()
{
    ATOM a;

    if (!g_aCC32Subclass)
        return;             // No active subclasses; nothing to do

    a = GlobalAddAtom(c_szCC32Subclass);
    if (a == g_aCC32Subclass)
        return;             // We lucked out -- no actual change

    EnumDesktops(GetProcessWindowStation(), FixupEnumDesktopProc, a);
    g_aCC32Subclass = a;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\toolbar.h ===
// common stuff for the toolbar control

#ifndef _TOOLBAR_H
#define _TOOLBAR_H

#define TBHIGHLIGHT_BACK
#define TBHIGHLIGHT_GLYPH

#include <uxtheme.h>

typedef struct 
{        /* info for recreating the bitmaps */
    int nButtons;
    HINSTANCE hInst;
    UINT_PTR wID;
} TBBMINFO, *PTBBMINFO;

typedef struct _TBBUTTONDATA 
{
    union
    {
        // Someone wanted to conserve space.  This is a union to make 
        // the code easier to read.
        int iBitmap;
        int cxySep;         // Used by separators
    }DUMMYUNIONNAME;
    int idCommand;
    BYTE fsState;
    BYTE fsStyle;
    WORD cx;
    DWORD_PTR dwData;
    INT_PTR iString;
    POINT pt;               // top left corner of this button
} TBBUTTONDATA, * LPTBBUTTONDATA;

#define HIML_NORMAL 0
#define HIML_HOT    1   // Image list for the hot-tracked image
#define HIML_DISABLED 2 // Image list for the hot-tracked image
#define HIML_MAX        2

typedef struct 
{
    HIMAGELIST himl[3];
} TBIMAGELISTS, *LPTBIMAGELISTS;

typedef struct 
{            /* instance data for toolbar window */
    CCONTROLINFO ci;
    DWORD dwStyleEx;
    HDC hdcMono;
    HBITMAP hbmMono;
    LPTBBUTTONDATA Buttons;     // Array of actual buttons
    LPTBBUTTONDATA pCaptureButton;
    POINT   ptCapture;
    HWND hwndToolTips;
    LPTSTR      pszTip;         // store current tooltip string.
    HWND hdlgCust;
    HFONT hfontIcon;
    int nBitmaps;
#ifdef GLYPHCACHE
    int nSelectedBM;            // currently selected pBitmaps index
#endif
    PTBBMINFO pBitmaps;
#ifdef FACECACHE
    HBITMAP hbmCache;
#endif
    PTSTR *pStrings;
    int nStrings;
    int nTextRows;              // # Rows of text per button
    UINT uStructSize;
    int iDxBitmap;
    int iDyBitmap;
    int iButWidth;
    int iButHeight;
    int iButMinWidth;           // The min and max width of the button. If the app does not
    int iButMaxWidth;           // have an opinion on what the min and max should be, these will be 0
    int iYPos;
    int iNumButtons;
    int dyIconFont;
    int dxDDArrowChar;
    int xFirstButton;
    int cxPad;
    int cyPad;
    int iListGap;               // space between icon and text on list-style buttons
    int iDropDownGap;           // padding after text on list-style drop-down buttons
    SIZE szCached;
    
#ifndef UNICODE
    BYTE bLeadByte;             // Save DBCS Lead Byte
#endif

    HDRAGPROXY hDragProxy;
    
    UINT uDrawText;
    UINT uDrawTextMask;

    COLORSCHEME clrsc;

    TBIMAGELISTS* pimgs;
    int cPimgs;
    
    int iHot;                   // Index of the currently Hot Tracked Button
    int iPressedDD;             // Index of the currently pressed dropdown button
    int iInsert;                // Index of the insertion mark, or -1 if none
    COLORREF    clrim;          // current insert mark color
    RECT rcInvalid;             // Saved invalid rectangle

    BITBOOL fHimlValid : 1;
    BITBOOL fHimlNative : 1;
    BITBOOL fFontCreated: 1;
    BITBOOL fNoStringPool :1;
    BITBOOL fTTNeedsFlush :1;

    BITBOOL fMouseTrack: 1;     // Are we currently tracking Mouse over this toolbar ?
    BITBOOL fActive: 1;
    BITBOOL fAnchorHighlight: 1;// TRUE: anchor the highlight to current position 
                                //       when mouse goes out of toolbar
    BITBOOL fRightDrag: 1;      // TRUE if current drag is right drag
    BITBOOL fDragOutNotify: 1;  // FALSE from start of drag until mouse leaves button
                                //       at which point it is TRUE until next drag
    BITBOOL fInsertAfter: 1;    // insert after (TRUE) or before (FALSE) button at iInsert?

    BITBOOL fRedrawOff : 1;     // did we get a WM_SETREDRAW = FALSE
    BITBOOL fInvalidate : 1;    // did we get any paint messages whilst we were fRedrawOff
    BITBOOL fRecalc : 1;        // did we try to call TBRecalc while we were fRedrawOff?
    
    BITBOOL fRequeryCapture :1; // app hack see comment on lbutton up
    BITBOOL fShowPrefix: 1;     // Show the underline of an item. Set with WM_KEYBOARDCUES

    BITBOOL fItemRectsValid:1;  // Are the cached button item rects valid?
    BITBOOL fAntiAlias: 1;    // Turn off AntiAliasing durning the create of a drag image.
    BITBOOL fForcedDoubleBuffer: 1; // Even though not explicitly set by external, we want to enable it. 
                                    // Double buffer has some bagage: It also means "FlickerFree/Efficient drawing"

    
    RECT rc;                    // cache rc of toolbar. (used only for TBSTYLE_EX_MULTICOL and TBSTYLE_EX_HIDECLIPPEDBUTTONS)
    SIZE sizeBound;             // largest bounding size in vertical multicolumn mode.

    HTHEME hTheme;

    int iTracking;              // Used for tooltips via keyboard (current item in focus for info display, >= 0 is tracking active)
    LPARAM lLastMMove;          // Filter out mouse move messages that didn't result in an actual move (for track tooltip canceling)
    
    int cxBarPad;
    int cyBarPad;
    int cxButtonSpacing;
    int cyButtonSpacing;
} TBSTATE, *PTBSTATE;

typedef struct {
/*REVIEW: index, command, flag words, resource ids should be UINT */
    int iBitmap;    /* index into bitmap of this button's picture */
    int idCommand;  /* WM_COMMAND menu ID that this button sends */
    BYTE fsState;   /* button's state */
    BYTE fsStyle;   /* button's style */
    int idsHelp;    /* string ID for button's status bar help */
} OLDTBBUTTON,* LPOLDTBBUTTON;


typedef struct _TBDRAWITEM
{
    TBSTATE * ptb;
    LPTBBUTTONDATA pbutton;

    UINT state;
    BOOL fHotTrack;

    // himl and image index
    int iIndex;
    int iImage;

    DWORD dwCustom;
    NMTBCUSTOMDRAW tbcd;
} TBDRAWITEM, * PTBDRAWITEM;


// toolbar keyboard tooltip tracking
#define TBKTT_NOTRACK           -1

#define TB_IsKbdTipTracking(ptb)  (ptb->iTracking != TBKTT_NOTRACK)

#define IDT_TRACKINGTIP         0

#ifdef __cplusplus
extern "C" {
#endif

HIMAGELIST TBGetImageList(PTBSTATE ptb, int iMode, int iIndex);
HIMAGELIST TBSetImageList(PTBSTATE ptb, int iMode, int iIndex, HIMAGELIST himl);
#define GET_HIML_INDEX GET_Y_LPARAM
#define GET_IMAGE_INDEX GET_X_LPARAM

HBITMAP SelectBM(HDC hDC, PTBSTATE pTBState, int nButton);
void DrawButton(HDC hdc, int x, int y, PTBSTATE pTBState, LPTBBUTTONDATA ptButton, BOOL fActive);
void DrawFace(HDC hdc, PRECT prc, int x, int y, int offx, int offy, int dxText, 
              int dyText, TBDRAWITEM * ptbdraw, int iListGap, PRECT prcText);
int  TBHitTest(PTBSTATE pTBState, int xPos, int yPos);
int  PositionFromID(PTBSTATE pTBState, LONG_PTR id);
void BuildButtonTemplates(void);
void TBInputStruct(PTBSTATE ptb, LPTBBUTTONDATA pButtonInt, LPTBBUTTON pButtonExt);
void TBOutputStruct(PTBSTATE ptb, LPTBBUTTONDATA pButtonInt, LPTBBUTTON pButtonExt);

BOOL SaveRestoreFromReg(PTBSTATE ptb, BOOL bWrite, HKEY hkr, LPCTSTR pszSubKey, LPCTSTR pszValueName);

void CustomizeTB(PTBSTATE pTBState, int iPos);
void MoveButton(PTBSTATE pTBState, int nSource);
BOOL DeleteButton(PTBSTATE ptb, UINT uIndex);
BOOL TBReallocButtons(PTBSTATE ptb, UINT uButtons);
BOOL TBInsertButtons(PTBSTATE ptb, UINT uWhere, UINT uButtons, LPTBBUTTON lpButtons, BOOL fNative);

LRESULT SendItemNotify(PTBSTATE ptb, int iItem, int code);
void TBInvalidateItemRects(PTBSTATE ptb);
void ReleaseMonoDC(PTBSTATE ptb);
void InitTBDrawItem(TBDRAWITEM * ptbdraw, PTBSTATE ptb, LPTBBUTTONDATA pbutton, 
                    UINT state, BOOL fHotTrack, int dxText, int dyText);
BOOL TBGetInfoTip(PTBSTATE ptb, LPTOOLTIPTEXT lpttt, LPTBBUTTONDATA pTBButton);
extern const int g_dxButtonSep;

BOOL TB_GetItemRect(PTBSTATE ptb, UINT uButton, LPRECT lpRect);

#ifdef __cplusplus
}
#endif

#endif // _TOOLBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\trackbar.c ===
#include "ctlspriv.h"
#include "limits.h"
#include "image.h"          // for CreateColorBitmap

#if defined(MAINWIN)
#include <mainwin.h>
#endif

//#define TB_DEBUG
//#define FEATURE_DEBUG     // Ctrl+Shift force-enables rare features for debugging

typedef struct {

    // standard header information for each control
    CCONTROLINFO ci;

    HDC     hdc;            // current DC
    HBITMAP hbmBuffer;      // double buffer

    LONG    lLogMin;        // Logical minimum
    LONG    lLogMax;        // Logical maximum
    LONG    lLogPos;        // Logical position

    LONG    lSelStart;      // Logical selection start
    LONG    lSelEnd;        // Logical selection end

    int     iThumbWidth;    // Width of the thumb
    int     iThumbHeight;   // Height of the thumb

    int     iSizePhys;      // Size of where thumb lives
    RECT    rc;             // track bar rect.

    RECT    rcThumb;          // Rectangle we current thumb
    DWORD   dwDragPos;      // Logical position of mouse while dragging.
    int     dwDragOffset;   // how many pixels off the center did they click

    int     nTics;          // number of ticks.
    PDWORD  pTics;          // the tick marks.

    int     ticFreq;        // the frequency of ticks

    LONG     lPageSize;      // how much to thumb up and down.
    LONG     lLineSize;      // how muhc to scroll up and down on line up/down

    HWND     hwndToolTips;

    // these should probably be word or bytes
    UINT     wDirtyFlags;
    UINT     uTipSide;   // which side should the tip be on?
    UINT     Flags;          // Flags for our window
    UINT     Cmd;            // The command we're repeating.

    HTHEME   hTheme;
    BOOL     bThumbHot;
    HIMC    hPrevImc;       // previous input context handle
    HWND        hwndBuddyLeft;
    HWND        hwndBuddyRight;

} TRACKBAR, *PTRACKBAR;

// Trackbar flags

#define TBF_NOTHUMB     0x0001  // No thumb because not wide enough.
#define TBF_SELECTION   0x0002  // a selection has been established (draw the range)

#define MIN_THUMB_HEIGHT (2 * g_cxEdge)

/*
        useful constants.
*/

#define REPEATTIME      500     // mouse auto repeat 1/2 of a second
#define TIMER_ID        1

/*
        Function Prototypes
*/

void   DoTrack(PTRACKBAR, int, DWORD);
WORD   WTrackType(PTRACKBAR, LONG);
void   TBTrackInit(PTRACKBAR, LPARAM);
void   TBTrackEnd(PTRACKBAR);
void   TBTrack(PTRACKBAR, LPARAM);
void   DrawThumb(PTRACKBAR, LPRECT, BOOL);

HBRUSH SelectColorObjects(PTRACKBAR, BOOL);
void   SetTBCaretPos(PTRACKBAR);

#define TICKHEIGHT 3
#define BORDERSIZE 2

#define ISVERT(tb) (tb->ci.style & TBS_VERT)

#define TBC_TICS        0x1
#define TBC_THUMB       0x2
#define TBC_ALL         0xF


// this is called internally when the trackbar has
// changed and we need to update the double buffer bitmap
// we only set a flag.  we do the actual draw
// during WM_PAINT.  This prevents wasted efforts drawing.
#define TBChanged(ptb, wFlags) ((ptb)->wDirtyFlags |= (wFlags))

//
// Function Prototypes
//
LPARAM CALLBACK TrackBarWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
void FlushChanges(PTRACKBAR tb);

//--------------------------------------------------------------------------;
//
//  LONG MulDiv32(a,b,c)    = (a * b + c/2) / c
//
//--------------------------------------------------------------------------;

#ifdef WIN32

#define MulDiv32 MulDiv     // use KERNEL32 version (it rounds)

#else // WIN32

#define ASM66 _asm _emit 0x66 _asm
#define DB    _asm _emit

#define EAX_TO_DXAX \
    DB      0x66    \
    DB      0x0F    \
    DB      0xA4    \
    DB      0xC2    \
    DB      0x10

#pragma warning(disable:4035 4704)

static LONG MulDiv32(LONG a,LONG b,LONG c)
{
    ASM66   mov     ax,word ptr c   //  mov  eax, c
    ASM66   sar     ax,1            //  sar  eax,1
    ASM66   cwd                     //  cdq
    ASM66   mov     bx,ax           //  mov  ebx,eax
    ASM66   mov     cx,dx           //  mov  ecx,edx
    ASM66   mov     ax,word ptr a   //  mov  eax, a
    ASM66   imul    word ptr b      //  imul b
    ASM66   add     ax,bx           //  add  eax,ebx
    ASM66   adc     dx,cx           //  adc  edx,ecx
    ASM66   idiv    word ptr c      //  idiv c
    EAX_TO_DXAX

} // MulDiv32()

#pragma warning(default:4035 4704)

#endif // WIN32

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

//
//  convert a logical scroll-bar position to a physical pixel position
//
int TBLogToPhys(PTRACKBAR tb, DWORD dwPos)
{
    int x;
    x = tb->rc.left;
    if (tb->lLogMax == tb->lLogMin)
        return x;

    return (int)MulDiv32(dwPos - tb->lLogMin, tb->iSizePhys - 1,
                          tb->lLogMax - tb->lLogMin) + x;
}

LONG TBPhysToLog(PTRACKBAR ptb, int iPos)
{
    int min, max, x;
    min = ptb->rc.left;
    max = ptb->rc.right;
    x = ptb->rc.left;

    if (ptb->iSizePhys <= 1)
        return ptb->lLogMin;

    if (iPos <= min)
        return ptb->lLogMin;

    if (iPos >= max)
        return ptb->lLogMax;

    return MulDiv32(iPos - x, ptb->lLogMax - ptb->lLogMin,
                    ptb->iSizePhys - 1) + ptb->lLogMin;
}



#pragma code_seg(CODESEG_INIT)
/*
 * Initialize the trackbar code
 */

BOOL InitTrackBar(HINSTANCE hInstance)
{
    WNDCLASS wc;

    // See if we must register a window class
    wc.lpfnWndProc = TrackBarWndProc;
    wc.lpszClassName = s_szSTrackBarClass;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon = NULL;
    wc.lpszMenuName = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.hInstance = hInstance;
    wc.style = CS_GLOBALCLASS;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(PTRACKBAR);

    if (!RegisterClass(&wc) && !GetClassInfo(hInstance, s_szSTrackBarClass, &wc))
        return FALSE;
    return TRUE;
}
#pragma code_seg()



/* 
 * To add vertical capabilities, I'm using a virtual coordinate
 * system.  the ptb->rcThumb and ptb->rc are in the virtual space (which
 * is just a horizontal trackbar).  Draw routines use PatRect and
 * TBBitBlt which switch to the real coordinate system as needed.
 *
 * The one gotcha is that the Thumb Bitmap has the pressed bitmap
 * to the real right, and the masks to the real right again for both
 * the vertical and horizontal Thumbs.  So those cases are hardcoded.
 * Do a search for ISVERT to find these dependancies.
 *                              -Chee
 */

/*
  FlipRect Function is moved to cutils.c as  other controls  were also using it.
  -Arul

*/

void TBFlipPoint(PTRACKBAR ptb, LPPOINT lppt)
{
    if (ISVERT(ptb)) {
        FlipPoint(lppt);
    }
}


/* added trackbar variable to do auto verticalization */
void PatRect(HDC hdc,int x,int y,int dx,int dy, PTRACKBAR ptb)
{
    RECT    rc;

    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    if (ISVERT(ptb))
        FlipRect(&rc);
    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

#define TBInvalidateRect(hwnd, prc, bErase, ptb) VertInvalidateRect(hwnd, prc, bErase, ISVERT(ptb))
void VertInvalidateRect(HWND hwnd, LPRECT qrc, BOOL b, BOOL fVert)
{
    RECT rc;
    rc = *qrc;
    if (fVert) FlipRect(&rc);
    InvalidateRect(hwnd, &rc, b);
}

#define TBDrawEdge(hdc, prc, uType, grfFlags, ptb, hTheme, iPartId, iStateId) VertDrawEdge(hdc, prc, uType, grfFlags, ISVERT(ptb), hTheme, iPartId, iStateId)

// VertDrawEdge is theme aware (RENDERS)
void VertDrawEdge(HDC hdc, LPRECT qrc, UINT edgeType, UINT grfFlags,
                               BOOL fVert, HTHEME hTheme, int iPartId, int iStateId)
{
    RECT temprc;
    UINT uFlags = grfFlags;

    temprc = *qrc;
    if (fVert) {
        FlipRect(&temprc);

        if (!(uFlags & BF_DIAGONAL)) {
            if (grfFlags & BF_TOP) uFlags |= BF_LEFT;
            else uFlags &= ~BF_LEFT;

            if (grfFlags & BF_LEFT) uFlags |= BF_TOP;
            else uFlags &= ~BF_TOP;

            if (grfFlags & BF_BOTTOM) uFlags |= BF_RIGHT;
            else uFlags &= ~BF_RIGHT;

            if (grfFlags & BF_RIGHT) uFlags |= BF_BOTTOM;
            else uFlags &= ~BF_BOTTOM;
        } else {
            if ((grfFlags & (BF_BOTTOM | BF_RIGHT)) == (BF_BOTTOM | BF_RIGHT)) {
                uFlags = BF_TOP | BF_LEFT;

                if (edgeType == EDGE_RAISED) {
                    edgeType = EDGE_SUNKEN;
                } else {
                    edgeType = EDGE_RAISED;
                }


                uFlags |= grfFlags & (~BF_RECT);
                uFlags ^= BF_SOFT;
            }
        }
    }

    if (hTheme)
    {
        DrawThemeBackground(hTheme, hdc, iPartId, iStateId, &temprc, 0);
    }
    else
    {
        DrawEdge(hdc, &temprc, edgeType, uFlags);
    }
}

void TBBitBlt(HDC hdc1, int x1, int y1, int w, int h,
                          HDC hdc2, int x2, int y2, DWORD rop, PTRACKBAR ptb)
{
    if (ISVERT(ptb))
        BitBlt(hdc1, y1, x1, h, w, hdc2, x2, y2, rop);
    else
        BitBlt(hdc1, x1, y1, w, h, hdc2, x2, y2, rop);
}

#define TBPatBlt(hdc1, x1, y1, w, h, rop, ptb) VertPatBlt(hdc1, x1, y1, w, h, rop, ISVERT(ptb), NULL, 0, 0)

// VertPatBlt is theme aware (RENDERS)
void VertPatBlt(HDC hdc1, int x1, int y1, int w, int h,
                          DWORD rop, BOOL fVert, HTHEME hTheme, int iPartId, int iStateId)
{
    if (hTheme)
    {
        RECT rc;
        if (fVert)
            SetRect(&rc, y1, x1, h, w);
        else
            SetRect(&rc, x1, y1, w, h);

        DrawThemeBackground(hTheme, hdc1, iPartId, iStateId, &rc, 0);
    }
    else
    {
        if (fVert)
            PatBlt(hdc1, y1, x1, h, w, rop);
        else
            PatBlt(hdc1, x1, y1, w, h, rop);
    }
}

// DrawTic is theme aware (RENDERS)
void DrawTic(PTRACKBAR ptb, int x, int y, int dir)
{
    if (dir == -1) y -= TICKHEIGHT;

    if (ptb->hTheme)
    {
        COLORREF cr = 0;
        GetThemeColor(ptb->hTheme, ISVERT(ptb) ? TKP_TICSVERT : TKP_TICS, TSS_NORMAL, TMT_COLOR, &cr);
        SetBkColor(ptb->hdc, cr);
    }
    else
    {
        SetBkColor(ptb->hdc, g_clrBtnText);
    }

    PatRect(ptb->hdc,x,y,1,TICKHEIGHT, ptb);
}

// dir = direction multiplier (drawing up or down)
// yTic = where (vertically) to draw the line of tics
void DrawTicsOneLine(PTRACKBAR ptb, int dir, int yTic)
{
    PDWORD pTics;
    int    iPos;
    int    i;

    DrawTic(ptb, ptb->rc.left, yTic, dir);             // first
    DrawTic(ptb, ptb->rc.left, yTic+ (dir * 1), dir);
    DrawTic(ptb, ptb->rc.right-1, yTic, dir);            // last
    DrawTic(ptb, ptb->rc.right-1, yTic+ (dir * 1), dir);

    // those inbetween
    pTics = ptb->pTics;
    if (ptb->ticFreq && pTics) {
        for (i = 0; i < ptb->nTics; ++i) {
            if (((i+1) % ptb->ticFreq) == 0) {
                iPos = TBLogToPhys(ptb,pTics[i]);
                DrawTic(ptb, iPos, yTic, dir);
            }
        }
    }

    // draw the selection range (triangles)

    if ((ptb->Flags & TBF_SELECTION) &&
        (ptb->lSelStart <= ptb->lSelEnd) && (ptb->lSelEnd >= ptb->lLogMin)) {

        SetBkColor(ptb->hdc, g_clrBtnText);

        iPos = TBLogToPhys(ptb,ptb->lSelStart);

        for (i = 0; i < TICKHEIGHT; i++)
            PatRect(ptb->hdc,iPos-i,yTic+(dir==1 ? i : -TICKHEIGHT),
                    1,TICKHEIGHT-i, ptb);

        iPos = TBLogToPhys(ptb,ptb->lSelEnd);

        for (i = 0; i < TICKHEIGHT; i++)
            PatRect(ptb->hdc,iPos+i,yTic+(dir==1 ? i : -TICKHEIGHT),
                    1,TICKHEIGHT-i, ptb);
    }

}

/* DrawTics() */
/* There is always a tick at the beginning and end of the bar, but you can */
/* add some more of your own with a TBM_SETTIC message.  This draws them.  */
/* They are kept in an array whose handle is a window word.  The first     */
/* element is the number of extra ticks, and then the positions.           */

void DrawTics(PTRACKBAR ptb)
{
    // do they even want this?
    if (ptb->ci.style & TBS_NOTICKS) return;

    if ((ptb->ci.style & TBS_BOTH) || !(ptb->ci.style & TBS_TOP)) {
        DrawTicsOneLine(ptb, 1, ptb->rc.bottom + 1);
    }

    if ((ptb->ci.style & (TBS_BOTH | TBS_TOP))) {
        DrawTicsOneLine(ptb, -1, ptb->rc.top - 1);
    }
}

void GetChannelRect(PTRACKBAR ptb, LPRECT lprc)
{
        int iwidth, iheight;

        if (!lprc)
            return;

        lprc->left = ptb->rc.left - ptb->iThumbWidth / 2;
        iwidth = ptb->iSizePhys + ptb->iThumbWidth - 1;
        lprc->right = lprc->left + iwidth;

        if (ptb->ci.style & TBS_ENABLESELRANGE) {
                iheight =  ptb->iThumbHeight / 4 * 3; // this is Scrollheight
        } else {
                iheight = 4;
        }

        lprc->top = (ptb->rc.top + ptb->rc.bottom - iheight) /2;
        if (!(ptb->ci.style & TBS_BOTH))
            if (ptb->ci.style & TBS_TOP) lprc->top++;
            else lprc->top--;

        lprc->bottom = lprc->top + iheight;

}

/* This draws the track bar itself */

// DrawChannel is theme aware (RENDERS)
void DrawChannel(PTRACKBAR ptb, LPRECT lprc)
{
    TBDrawEdge(ptb->hdc, lprc, EDGE_SUNKEN, BF_RECT,ptb, ptb->hTheme, ISVERT(ptb) ? TKP_TRACKVERT : TKP_TRACK, TRS_NORMAL);

    if (!ptb->hTheme)
    {
        SetBkColor(ptb->hdc, g_clrBtnHighlight);
        // Fill the center
        PatRect(ptb->hdc, lprc->left+2, lprc->top+2, (lprc->right-lprc->left)-4,
                (lprc->bottom-lprc->top)-4, ptb);


        // now highlight the selection range
        if ((ptb->Flags & TBF_SELECTION) &&
            (ptb->lSelStart <= ptb->lSelEnd) && (ptb->lSelEnd > ptb->lLogMin)) {
                int iStart, iEnd;

                iStart = TBLogToPhys(ptb,ptb->lSelStart);
                iEnd   = TBLogToPhys(ptb,ptb->lSelEnd);

                if (iStart + 2 <= iEnd) {
                        SetBkColor(ptb->hdc, g_clrHighlight);
                        PatRect(ptb->hdc, iStart+1, lprc->top+3,
                                iEnd-iStart-1, (lprc->bottom-lprc->top)-6, ptb);
                }
        }
    }
}

// DrawThumb is theme aware (RENDERS)
void DrawThumb(PTRACKBAR ptb, LPRECT lprc, BOOL fSelected)
{

    // iDpt direction from middle to point of thumb
    // a negative value inverts things.
    // this allows one code path..
    int iDpt = 0;
    int i = 0;  // size of point triangle
    int iYpt = 0;       // vertical location of tip;
    int iXmiddle = 0;
    int icount;  // just a loop counter
    UINT uEdgeFlags = 0;
    RECT rcThumb = *lprc;

    if (ptb->Flags & TBF_NOTHUMB ||
        ptb->ci.style & TBS_NOTHUMB)            // If no thumb, just leave.
        return;

    ASSERT(ptb->iThumbHeight >= MIN_THUMB_HEIGHT);
    ASSERT(ptb->iThumbWidth > 1);

    if (!ptb->hTheme)
    {
        // draw the rectangle part
        if (!(ptb->ci.style & TBS_BOTH))  {
            int iMiddle;
            // do -3  because wThumb is odd (triangles ya know)
            // and because draw rects draw inside the rects passed.
            // actually should be (width-1)/2-1, but this is the same...

            i = (ptb->iThumbWidth - 3) / 2;
            iMiddle = ptb->iThumbHeight / 2 + rcThumb.top;

            //draw the rectangle part
            if (ptb->ci.style & TBS_TOP) {
                iMiddle++; //correction because drawing routines
                iDpt = -1;
                rcThumb.top += (i+1);
                uEdgeFlags = BF_SOFT | BF_LEFT | BF_RIGHT | BF_BOTTOM;
            } else {
                iDpt = 1;
                rcThumb.bottom -= (i+1);
                // draw on the inside, not on the bottom and rt edge
                uEdgeFlags = BF_SOFT | BF_LEFT | BF_RIGHT | BF_TOP;
            }

            iYpt = iMiddle + (iDpt * (ptb->iThumbHeight / 2));
            iXmiddle = rcThumb.left + i;
        }  else {
            uEdgeFlags = BF_SOFT | BF_RECT;
        }

        // fill in the center
        if (fSelected || !IsWindowEnabled(ptb->ci.hwnd)) {
            HBRUSH hbrTemp;
            // draw the dithered insides;
            hbrTemp = SelectObject(ptb->hdc, g_hbrMonoDither);
            if (hbrTemp) {
                SetTextColor(ptb->hdc, g_clrBtnHighlight);
                SetBkColor(ptb->hdc, g_clrBtnFace);
                TBPatBlt(ptb->hdc, rcThumb.left +2 , rcThumb.top,
                         rcThumb.right-rcThumb.left -4, rcThumb.bottom-rcThumb.top,
                         PATCOPY,ptb);

                if (!(ptb->ci.style & TBS_BOTH)) {

                    for (icount = 1;  icount <= i;  icount++) {
                        TBPatBlt(ptb->hdc, iXmiddle-icount+1,
                             iYpt - (iDpt*icount),
                             icount*2, 1, PATCOPY, ptb);
                    }
                }
                SelectObject(ptb->hdc, hbrTemp);
            }

        } else {


            SetBkColor(ptb->hdc, g_clrBtnFace);
            PatRect(ptb->hdc, rcThumb.left+2, rcThumb.top,
                    rcThumb.right-rcThumb.left-4, rcThumb.bottom-rcThumb.top, ptb);

            if (!(ptb->ci.style & TBS_BOTH)) {
                for (icount = 1; icount <= i; icount++) {
                    PatRect(ptb->hdc, iXmiddle-icount+1,
                            iYpt - (iDpt*icount),
                            icount*2, 1, ptb);
                }
            }

        }
    }

    if (ptb->hTheme)
    {
        int iPartId;

        // States in overriding order
        int iStateId = TUS_NORMAL;

        if (ISVERT(ptb))
        {
            if (ptb->ci.style & TBS_BOTH)
            {
                iPartId = TKP_THUMBVERT;
            }
            else if (ptb->ci.style & TBS_LEFT)
            {
                iPartId = TKP_THUMBLEFT;
            }
            else
            {
                iPartId = TKP_THUMBRIGHT;
            }
        }
        else
        {
            if (ptb->ci.style & TBS_BOTH)
            {
                iPartId = TKP_THUMB;
            }
            else if (ptb->ci.style & TBS_TOP)
            {
                iPartId = TKP_THUMBTOP;
            }
            else
            {
                iPartId = TKP_THUMBBOTTOM;
            }
        }
#ifdef DEBUG
        if (!IsThemePartDefined(ptb->hTheme, iPartId, 0))
            DebugMsg(DM_WARNING, TEXT("WARNING: Trackbar_Drawthumb: Theme Part not defined: %d\n"), iPartId);
#endif

        if (ptb->ci.hwnd == GetFocus() && !(CCGetUIState(&(ptb->ci)) & UISF_HIDEFOCUS))
            iStateId = TUS_FOCUSED;

        if (ptb->bThumbHot)
            iStateId = TUS_HOT;

        if (fSelected)
            iStateId = TUS_PRESSED;

        if (ptb->ci.style & WS_DISABLED)
            iStateId = TUS_DISABLED;

        // Thumb and ThumbVert parts share the same enum values
        TBDrawEdge(ptb->hdc, &rcThumb, EDGE_RAISED, uEdgeFlags, ptb, ptb->hTheme, iPartId, iStateId); 
    }
    else
    {
        TBDrawEdge(ptb->hdc, &rcThumb, EDGE_RAISED, uEdgeFlags, ptb, NULL, 0, 0);
    }

    if (!ptb->hTheme)
    {
        //now draw the point
        if (!(ptb->ci.style & TBS_BOTH)) {
            UINT uEdgeFlags2;

            // uEdgeFlags is now used to switch between top and bottom.
            // we'll or it in with the diagonal and left/right flags below
            if (ptb->ci.style & TBS_TOP) {
                rcThumb.bottom = rcThumb.top + 1;
                rcThumb.top = rcThumb.bottom - (i + 2);
                uEdgeFlags = BF_TOP | BF_RIGHT | BF_DIAGONAL | BF_SOFT;
                uEdgeFlags2 = BF_BOTTOM | BF_RIGHT | BF_DIAGONAL;
            } else {
                rcThumb.top = rcThumb.bottom - 1;
                rcThumb.bottom = rcThumb.top + (i + 2);

                uEdgeFlags = BF_TOP | BF_LEFT | BF_DIAGONAL | BF_SOFT;
                uEdgeFlags2 = BF_BOTTOM | BF_LEFT | BF_DIAGONAL;
            }

            rcThumb.right = rcThumb.left + (i + 2);
            // do the left side first
            TBDrawEdge(ptb->hdc, &rcThumb, EDGE_RAISED, uEdgeFlags , ptb, NULL, 0, 0);
            // then do th right side
            OffsetRect(&rcThumb, i + 1, 0);
            TBDrawEdge(ptb->hdc, &rcThumb, EDGE_RAISED, uEdgeFlags2 , ptb, NULL, 0, 0);
        }
    }
}
void TBInvalidateAll(PTRACKBAR ptb)
{
    if (ptb) {
        TBChanged(ptb, TBC_ALL);
        InvalidateRect(ptb->ci.hwnd, NULL, FALSE);
    }
}

void MoveThumb(PTRACKBAR ptb, LONG lPos)
{
    long    lOld = ptb->lLogPos;

    TBInvalidateRect(ptb->ci.hwnd, &ptb->rcThumb, FALSE,ptb);

    ptb->lLogPos  = BOUND(lPos,ptb->lLogMin,ptb->lLogMax);
    ptb->rcThumb.left   = TBLogToPhys(ptb, ptb->lLogPos) - ptb->iThumbWidth / 2;
    ptb->rcThumb.right  = ptb->rcThumb.left + ptb->iThumbWidth;

    TBInvalidateRect(ptb->ci.hwnd, &ptb->rcThumb, FALSE,ptb);
    TBChanged(ptb, TBC_THUMB);
    UpdateWindow(ptb->ci.hwnd);

    if (lOld != ptb->lLogPos)
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ptb->ci.hwnd, OBJID_CLIENT, 0);
}


void DrawFocus(PTRACKBAR ptb, HBRUSH hbrBackground)
{
    RECT rc;
    if (ptb->ci.hwnd == GetFocus() && 
        !(CCGetUIState(&(ptb->ci)) & UISF_HIDEFOCUS))
    {
        SetBkColor(ptb->hdc, g_clrBtnHighlight);
        GetClientRect(ptb->ci.hwnd, &rc);

        // Successive calls to DrawFocusRect will invert it thereby erasing it.
        // To avoid this, whenever we process WM_PAINT, we erase the focus rect ourselves
        // before we draw it below.
        if (hbrBackground)
            FrameRect(ptb->hdc, &rc, hbrBackground);

        DrawFocusRect(ptb->hdc, &rc);
    }
}

void DoAutoTics(PTRACKBAR ptb)
{
    LONG *pl;
    LONG l;

    if (!(ptb->ci.style & TBS_AUTOTICKS))
        return;

    if (ptb->pTics)
        LocalFree((HLOCAL)ptb->pTics);

    ptb->nTics = (int)(ptb->lLogMax - ptb->lLogMin - 1);

    if (ptb->nTics > 0)
        ptb->pTics = (DWORD *)LocalAlloc(LPTR, sizeof(DWORD) * ptb->nTics);
    else
        ptb->pTics = NULL;

    if (!ptb->pTics) {
        ptb->nTics = 0;
        return;
    }

    for (pl = (LONG *)ptb->pTics, l = ptb->lLogMin + 1; l < ptb->lLogMax; l++)
        *pl++ = l;
}


void ValidateThumbHeight(PTRACKBAR ptb)
{
    if (ptb->iThumbHeight < MIN_THUMB_HEIGHT)
        ptb->iThumbHeight = MIN_THUMB_HEIGHT;

    ptb->iThumbWidth = ptb->iThumbHeight / 2;
    ptb->iThumbWidth |= 0x01;  // make sure it's odd at at least 3

    if (ptb->ci.style & TBS_ENABLESELRANGE) {
        if (ptb->ci.style & TBS_FIXEDLENGTH) {
            // half of 9/10
            ptb->iThumbWidth = (ptb->iThumbHeight * 9) / 20;
            ptb->iThumbWidth |= 0x01;
        } else {
            ptb->iThumbHeight += (ptb->iThumbWidth * 2) / 9;
        }
    }
}

void TBPositionBuddies(PTRACKBAR ptb)
{
    POINT pt;
    HWND hwndParent;
    RECT rcBuddy;
    RECT rcClient;
    RECT rcChannel;

    int yMid;

    GetChannelRect(ptb, &rcChannel);
    yMid = (rcChannel.top + rcChannel.bottom) / 2;

    GetClientRect(ptb->ci.hwnd, &rcClient);
    if (ISVERT(ptb))
        FlipRect(&rcClient);


    if (ptb->hwndBuddyLeft) {
        GetClientRect(ptb->hwndBuddyLeft, &rcBuddy);
        if (ISVERT(ptb))
            FlipRect(&rcBuddy);

        pt.y = yMid - ((RECTHEIGHT(rcBuddy))/2);
        pt.x = rcClient.left - RECTWIDTH(rcBuddy) - g_cxEdge;

        // x and y are now in trackbar's coordinates.
        // convert them to the parent of the buddy's coordinates
        hwndParent = GetParent(ptb->hwndBuddyLeft);
        TBFlipPoint(ptb, &pt);
        MapWindowPoints(ptb->ci.hwnd, hwndParent, &pt, 1);
        SetWindowPos(ptb->hwndBuddyLeft, NULL, pt.x, pt.y, 0, 0, SWP_NOSIZE |SWP_NOZORDER | SWP_NOACTIVATE);
    }

    if (ptb->hwndBuddyRight) {
        GetClientRect(ptb->hwndBuddyRight, &rcBuddy);
        if (ISVERT(ptb))
            FlipRect(&rcBuddy);

        pt.y = yMid - ((RECTHEIGHT(rcBuddy))/2);
        pt.x = rcClient.right + g_cxEdge;

        // x and y are now in trackbar's coordinates.
        // convert them to the parent of the buddy's coordinates
        hwndParent = GetParent(ptb->hwndBuddyRight);
        TBFlipPoint(ptb, &pt);
        MapWindowPoints(ptb->ci.hwnd, hwndParent, &pt, 1);
        SetWindowPos(ptb->hwndBuddyRight, NULL, pt.x, pt.y, 0, 0, SWP_NOSIZE |SWP_NOZORDER | SWP_NOACTIVATE);
    }

}

void TBNukeBuffer(PTRACKBAR ptb)
{
    if (ptb->hbmBuffer) {
        DeleteObject(ptb->hbmBuffer);
        ptb->hbmBuffer = NULL;
        TBChanged(ptb, TBC_ALL);            // Must do a full repaint
    }
}

void TBResize(PTRACKBAR ptb)
{
    GetClientRect(ptb->ci.hwnd, &ptb->rc);

    if (ISVERT(ptb))
        FlipRect(&ptb->rc);


    if (!(ptb->ci.style & TBS_FIXEDLENGTH)) {
        ptb->iThumbHeight = (g_cyHScroll * 4) / 3;

        ValidateThumbHeight(ptb);
        if ((ptb->iThumbHeight > MIN_THUMB_HEIGHT) && (ptb->rc.bottom < (int)ptb->iThumbHeight)) {
            ptb->iThumbHeight = ptb->rc.bottom - 3*g_cyEdge; // top, bottom, and tic
            if (ptb->ci.style & TBS_ENABLESELRANGE)
                ptb->iThumbHeight = (ptb->iThumbHeight * 3 / 4);
            ValidateThumbHeight(ptb);
        }
    } else {
        ValidateThumbHeight(ptb);
    }


    if (ptb->ci.style & (TBS_BOTH | TBS_TOP) && !(ptb->ci.style & TBS_NOTICKS))
        ptb->rc.top += TICKHEIGHT + BORDERSIZE + 3;
    ptb->rc.top   += BORDERSIZE;
    ptb->rc.bottom  = ptb->rc.top + ptb->iThumbHeight;
    ptb->rc.left   += (ptb->iThumbWidth + BORDERSIZE);
    ptb->rc.right  -= (ptb->iThumbWidth + BORDERSIZE);

    ptb->rcThumb.top = ptb->rc.top;
    ptb->rcThumb.bottom = ptb->rc.bottom;

    // Figure out how much room we have to move the thumb in
    ptb->iSizePhys = ptb->rc.right - ptb->rc.left;

    // Elevator isn't there if there's no room.
    if (ptb->iSizePhys == 0) {
        // Lost our thumb.
        ptb->Flags |= TBF_NOTHUMB;
        ptb->iSizePhys = 1;
    } else {
        // Ah. We have a thumb.
        ptb->Flags &= ~TBF_NOTHUMB;
    }

    TBNukeBuffer(ptb);

    MoveThumb(ptb, ptb->lLogPos);
    TBInvalidateAll(ptb);

    TBPositionBuddies(ptb);
}

LRESULT TrackOnCreate(HWND hwnd, LPCREATESTRUCT lpCreate)
{
    PTRACKBAR       ptb;

#ifdef MAINWIN
    DWORD exStyle = WS_EX_MW_UNMANAGED_WINDOW;
#else
    DWORD exStyle = 0;
#endif

    InitDitherBrush();
    InitGlobalColors();

    // Get us our window structure.
    ptb = (PTRACKBAR)LocalAlloc(LPTR, sizeof(TRACKBAR));
    if (!ptb)
        return -1;

    SetWindowPtr(hwnd, 0, ptb);
    CIInitialize(&ptb->ci, hwnd, lpCreate);

    ptb->Cmd = (UINT)-1;
    ptb->lLogMax = 100;
    ptb->ticFreq = 1;
    // ptb->hbmBuffer = 0;
    ptb->lPageSize = -1;
    ptb->lLineSize = 1;
    // initial size;
    ptb->iThumbHeight = (g_cyHScroll * 4) / 3;
    if (g_fDBCSInputEnabled)
        ptb->hPrevImc = ImmAssociateContext(hwnd, 0L);

    if (ISVERT(ptb)) 
    {
        if (ptb->ci.style & TBS_TOP) 
        {
            ptb->uTipSide = TBTS_RIGHT;
        } 
        else 
        {
            ptb->uTipSide = TBTS_LEFT;
        }
    } 
    else 
    {
        if (ptb->ci.style & TBS_TOP) 
        {
            ptb->uTipSide = TBTS_BOTTOM;
        } 
        else 
        {
            ptb->uTipSide = TBTS_TOP;
        }
    }

    if (ptb->ci.style & TBS_TOOLTIPS) 
    {
        ptb->hwndToolTips = CreateWindowEx(exStyle, 
                                              c_szSToolTipsClass, TEXT(""),
                                              WS_POPUP,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              ptb->ci.hwnd, NULL, HINST_THISDLL,
                                              NULL);
        if (ptb->hwndToolTips)
        {
            TOOLINFO ti;
            // don't bother setting the rect because we'll do it below
            // in FlushToolTipsMgr;
            ti.cbSize = sizeof(ti);
            ti.uFlags = TTF_TRACK | TTF_IDISHWND | TTF_CENTERTIP;
            ti.hwnd = ptb->ci.hwnd;
            ti.uId = (UINT_PTR)ptb->ci.hwnd;
            ti.lpszText = LPSTR_TEXTCALLBACK;
            ti.rect.left = ti.rect.top = ti.rect.bottom = ti.rect.right = 0; // update this on size
            SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0,
                        (LPARAM)(LPTOOLINFO)&ti);
        } 
        else
            ptb->ci.style &= ~(TBS_TOOLTIPS);
    }

    // Initialize themes. No themese for owner drawn tab controls
    ptb->hTheme = OpenThemeData(ptb->ci.hwnd, L"TrackBar");
    ptb->bThumbHot = FALSE;

    TBResize(ptb);

    return 0;
}

void TrackOnNotify(PTRACKBAR ptb, LPNMHDR lpnm)
{
    if (lpnm->hwndFrom == ptb->hwndToolTips) 
    {
        switch (lpnm->code) 
        {
        case TTN_NEEDTEXT:
#define lpttt ((LPTOOLTIPTEXT)lpnm)
            wsprintf(lpttt->szText, TEXT("%d"), ptb->lLogPos);

        default:
            SendNotifyEx(ptb->ci.hwndParent, (HWND)-1,
                         lpnm->code, lpnm, ptb->ci.bUnicode);
            break;
        }
    }
}

HWND TBSetBuddy(PTRACKBAR ptb, BOOL fLeft, HWND hwndBuddy)
{
    HWND hwndOldBuddy;

    if (fLeft) 
    {
        hwndOldBuddy = ptb->hwndBuddyLeft;
        ptb->hwndBuddyLeft = hwndBuddy;
    } 
    else 
    {
        hwndOldBuddy = ptb->hwndBuddyRight;
        ptb->hwndBuddyRight = hwndBuddy;
    }

    TBResize(ptb);

    return hwndOldBuddy;
}

// Theme helper
void TBRedrawThumb(PTRACKBAR ptb)
{
    // Update display
    TBInvalidateRect(ptb->ci.hwnd, &ptb->rcThumb, FALSE, ptb);
    TBChanged(ptb, TBC_THUMB); 
    UpdateWindow(ptb->ci.hwnd);
}

// TrackBarWndProc is theme aware
LPARAM CALLBACK TrackBarWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
        PTRACKBAR       ptb;
        PAINTSTRUCT     ps;
        HLOCAL          h;

        ptb = GetWindowPtr(hwnd, 0);
        if (!ptb) {
            if (uMsg == WM_CREATE)
                return TrackOnCreate(hwnd, (LPCREATESTRUCT)lParam);

            goto DoDefault;
        }

        // Track hot state for themes
        if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST))
        {
            TRACKMOUSEEVENT tme;

            tme.cbSize = sizeof(tme);
            tme.hwndTrack = hwnd;
            tme.dwFlags = TME_LEAVE;

            TrackMouseEvent(&tme);
        }

        switch (uMsg) {

        case WM_MOUSELEAVE:
            if (ptb->hTheme)
            {
                // Make sure thumb hot is turned off
                if (ptb->bThumbHot)
                {
                    ptb->bThumbHot = FALSE;
                    TBRedrawThumb(ptb);
                }
            }
            break;

        // If color depth changes, the old buffer is no longer any good
        case WM_DISPLAYCHANGE:
            TBNukeBuffer(ptb);
            break;

        case WM_WININICHANGE:

            InitGlobalMetrics(wParam);
            // fall through to WM_SIZE

        case WM_SIZE:
            TBResize(ptb);
            break;

        case WM_SYSCOLORCHANGE:
            InitGlobalColors();
            TBInvalidateAll(ptb);
            break;

        case WM_NOTIFYFORMAT:
            return CIHandleNotifyFormat(&ptb->ci,lParam);

        case WM_NOTIFY:
            TrackOnNotify(ptb, (LPNMHDR)lParam);
            break;

        case WM_DESTROY:
            TerminateDitherBrush();
            if (ptb) 
            {
                if (g_fDBCSInputEnabled)
                    ImmAssociateContext(hwnd, ptb->hPrevImc);

                if ((ptb->ci.style & TBS_TOOLTIPS) && IsWindow(ptb->hwndToolTips)) 
                {
                    DestroyWindow (ptb->hwndToolTips);
                }

                TBNukeBuffer(ptb);

                if (ptb->pTics)
                    LocalFree((HLOCAL)ptb->pTics);

                // Close theme
                if (ptb->hTheme)
                    CloseThemeData(ptb->hTheme);

                LocalFree((HLOCAL)ptb);
                SetWindowPtr(hwnd, 0, 0);

            }
            break;

        case WM_KILLFOCUS:
            // Reset wheel scroll amount
            gcWheelDelta = 0;
            // fall-through

        case WM_SETFOCUS:
            ASSERT(gcWheelDelta == 0);
            if (ptb)
                TBInvalidateAll(ptb);
            break;

        case WM_ENABLE:
            if (wParam) {
                ptb->ci.style &= ~WS_DISABLED;
            } else {
                ptb->ci.style |= WS_DISABLED;
            }
            // Redraw all if themes are enabled since more is configurable
            TBChanged(ptb, (ptb->hTheme) ? TBC_ALL : TBC_THUMB);
            InvalidateRect(hwnd, NULL, FALSE);
            break;

        case WM_PRINTCLIENT:
        case WM_PAINT: {
            RECT rc;
            HBITMAP hbmOld;
            HDC hdc;

            hdc = wParam ?  (HDC)wParam : BeginPaint(hwnd, &ps);

            //DebugMsg(DM_TRACE, "NumTics = %d", SendMessage(ptb->ci.hwnd, TBM_GETNUMTICS, 0, 0));

            //ptb->hdc = GetDC(NULL);
            ptb->hdc = CreateCompatibleDC(hdc);
            if (!ptb->hbmBuffer) {
                GetClientRect(hwnd, &rc);
                ptb->hbmBuffer = CreateColorBitmap(rc.right, rc.bottom);
            }

            hbmOld = SelectObject(ptb->hdc, ptb->hbmBuffer);
            FlushChanges(ptb);

            //only copy the area that's changable.. ie the clip box
            switch(GetClipBox(hdc, &rc)) {
                case NULLREGION:
                case ERROR:
                    GetClientRect(ptb->ci.hwnd, &rc);
            }
            BitBlt(hdc, rc.left, rc.top,
                     rc.right - rc.left, rc.bottom - rc.top,
                     ptb->hdc, rc.left, rc.top, SRCCOPY);

#ifdef TB_DEBUG
            {
                HDC hdcScreen;
                RECT rcClient;
                hdcScreen = GetDC(NULL);
                GetClientRect(ptb->ci.hwnd, &rcClient);
                BitBlt(hdcScreen, 0, 0, rcClient.right, rcClient.bottom, ptb->hdc, 0,0, SRCCOPY);
                ReleaseDC(NULL, hdcScreen);
            }
#endif

            SelectObject(ptb->hdc, hbmOld);
            DeleteDC(ptb->hdc);
            //ReleaseDC(NULL, ptb->hdc);
            if (wParam == 0)
                EndPaint(hwnd, &ps);

            ptb->hdc = NULL;
            break;
        }

        case WM_GETDLGCODE:
            return DLGC_WANTARROWS;

        case WM_LBUTTONDOWN:
            /* Give ourselves focus */
            if (!(ptb->ci.style & WS_DISABLED)) {
                SetFocus(hwnd); // REVIEW: we may not want to do this
                TBTrackInit(ptb, lParam);
            }
            break;

        case WM_LBUTTONUP:
            // We're through doing whatever we were doing with the
            // button down.
            if (!(ptb->ci.style & WS_DISABLED)) {
                TBTrackEnd(ptb);
                if (GetCapture() == hwnd)
                    CCReleaseCapture(&ptb->ci);
            }
            break;

        case WM_TIMER:
            // The only way we get a timer message is if we're
            // autotracking.
            lParam = GetMessagePosClient(ptb->ci.hwnd, NULL);
            // fall through to WM_MOUSEMOVE

        case WM_MOUSEMOVE:

            // We only care that the mouse is moving if we're
            // tracking the bloody thing.
            if (!(ptb->ci.style & WS_DISABLED))
            {
                if ((ptb->Cmd != (UINT)-1))
                    TBTrack(ptb, lParam);
                else
                {
                    // No user actions, track hot state if theme
                    if (ptb->hTheme)
                    {
                        // Check if mouse is currently over thumb
                        if (WTrackType(ptb, (LONG)lParam) == TB_THUMBTRACK)
                        {
                            if (!ptb->bThumbHot)
                            {
                                // Hot bit not set, set now and invalidate
                                ptb->bThumbHot = TRUE;

                                // Update display
                                TBRedrawThumb(ptb);
                            }
                        }
                        else
                        {
                            // Mouse not over thumb
                            if (ptb->bThumbHot)
                            {
                                ptb->bThumbHot = FALSE;

                                // Update display
                                TBRedrawThumb(ptb);
                            }
                        }
                    }
                }
            }
            break;

        case WM_CAPTURECHANGED:
            // someone is stealing the capture from us
            TBTrackEnd(ptb);
            break;

        case WM_KEYUP:
            if (!(ptb->ci.style & WS_DISABLED)) {
                // If key was any of the keyboard accelerators, send end
                // track message when user up clicks on keyboard
                switch (wParam) {
                case VK_HOME:
                case VK_END:
                case VK_PRIOR:
                case VK_NEXT:
                case VK_LEFT:
                case VK_UP:
                case VK_RIGHT:
                case VK_DOWN:
                    DoTrack(ptb, TB_ENDTRACK, 0);
                    break;
                default:
                    break;
                }
            }
            break;

        case WM_KEYDOWN:
            if (!(ptb->ci.style & WS_DISABLED)) {

                // Swap the left and right arrow key if the control is mirrored.
                wParam = RTLSwapLeftRightArrows(&ptb->ci, wParam);

                // If TBS_DOWNISLEFT, then swap left/right or up/down
                // depending on whether we are vertical or horizontal.
                // Some horizontal trackbars (e.g.) prefer that
                // UpArrow=TB_PAGEDOWN.
                if (ptb->ci.style & TBS_DOWNISLEFT) {
                    if (ISVERT(ptb)) {
                        wParam = CCSwapKeys(wParam, VK_LEFT, VK_RIGHT);
                    } else {
                        wParam = CCSwapKeys(wParam, VK_UP, VK_DOWN);
                        wParam = CCSwapKeys(wParam, VK_PRIOR, VK_NEXT);
                    }
                }

                switch (wParam) {
                case VK_HOME:
                    wParam = TB_TOP;
                    goto KeyTrack;

                case VK_END:
                    wParam = TB_BOTTOM;
                    goto KeyTrack;

                case VK_PRIOR:
                    wParam = TB_PAGEUP;
                    goto KeyTrack;

                case VK_NEXT:
                    wParam = TB_PAGEDOWN;
                    goto KeyTrack;

                case VK_LEFT:
                case VK_UP:
                    wParam = TB_LINEUP;
                    goto KeyTrack;

                case VK_RIGHT:
                case VK_DOWN:
                    wParam = TB_LINEDOWN;
                KeyTrack:
                    DoTrack(ptb, (int) wParam, 0);

                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(ptb->ci), UISF_HIDEFOCUS);

                    break;

                default:
                    break;
                }
            }
            break;

        case WM_MBUTTONDOWN:
            SetFocus(hwnd);
            break;

        case WM_STYLECHANGED:
            if (wParam == GWL_STYLE) {
                ptb->ci.style = ((LPSTYLESTRUCT)lParam)->styleNew;
                TBResize(ptb);
            }
            break;

        case WM_UPDATEUISTATE:
        {
            DWORD dwUIStateMask = MAKEWPARAM(0xFFFF, UISF_HIDEFOCUS);

            if (CCOnUIState(&(ptb->ci), WM_UPDATEUISTATE, wParam & dwUIStateMask, lParam))
                InvalidateRect(hwnd, NULL, TRUE);

            goto DoDefault;
        }
        case TBM_GETPOS:
            return ptb->lLogPos;

        case TBM_GETSELSTART:
            return ptb->lSelStart;

        case TBM_GETSELEND:
            return ptb->lSelEnd;

        case TBM_GETRANGEMIN:
            return ptb->lLogMin;

        case TBM_GETRANGEMAX:
            return ptb->lLogMax;

        case TBM_GETPTICS:
            return (LRESULT)ptb->pTics;

        case TBM_CLEARSEL:
            ptb->Flags &= ~TBF_SELECTION;
            ptb->lSelStart = -1;
            ptb->lSelEnd   = -1;
            goto RedrawTB;

        case TBM_CLEARTICS:
            if (ptb->pTics)
                LocalFree((HLOCAL)ptb->pTics);

            ptb->pTics = NULL;
            ptb->nTics = 0;
            goto RedrawTB;

        case TBM_GETTIC:

            if (ptb->pTics == NULL || (int)wParam >= ptb->nTics)
                return -1L;

            return ptb->pTics[wParam];

        case TBM_GETTICPOS:

            if (ptb->pTics == NULL || (int)wParam >= ptb->nTics)
                return -1L;

            return TBLogToPhys(ptb,ptb->pTics[wParam]);

        case TBM_GETNUMTICS:
            if (ptb->ci.style & TBS_NOTICKS)
                return 0;

            if (ptb->ticFreq) {
                // first and last +
                return 2 + (ptb->nTics / ptb->ticFreq);
            }

            // if there's no ticFreq, then we fall down here.
            // 2 for the first and last tics that we always draw
            // when NOTICS isn't set.
            return 2;


        case TBM_SETTIC:
            /* not a valid position */
            if (((LONG)lParam) < ptb->lLogMin || ((LONG)lParam) > ptb->lLogMax)
                break;

            h = CCLocalReAlloc(ptb->pTics,
                                 sizeof(DWORD) * (ptb->nTics + 1));
            if (!h)
                return (LONG)FALSE;
            
            ptb->pTics = (PDWORD)h;
            ptb->pTics[ptb->nTics++] = (DWORD)lParam;

            TBInvalidateAll(ptb);
            return (LONG)TRUE;

        case TBM_SETTICFREQ:
            ptb->ticFreq = (int) wParam;
            DoAutoTics(ptb);
            goto RedrawTB;

        case TBM_SETPOS:
            /* Only redraw if it will physically move */
            if (wParam && TBLogToPhys(ptb, (DWORD) lParam) !=
                TBLogToPhys(ptb, ptb->lLogPos))
                MoveThumb(ptb, (DWORD) lParam);
            else
                ptb->lLogPos = BOUND((LONG)lParam,ptb->lLogMin,ptb->lLogMax);
            break;

        case TBM_SETSEL:

            if (!(ptb->ci.style & TBS_ENABLESELRANGE)) break;
            ptb->Flags |= TBF_SELECTION;

            if (((LONG)(SHORT)LOWORD(lParam)) < ptb->lLogMin)
                ptb->lSelStart = ptb->lLogMin;
            else
                ptb->lSelStart = (LONG)(SHORT)LOWORD(lParam);

            if (((LONG)(SHORT)HIWORD(lParam)) > ptb->lLogMax)
                ptb->lSelEnd = ptb->lLogMax;
            else
                ptb->lSelEnd   = (LONG)(SHORT)HIWORD(lParam);

            if (ptb->lSelEnd < ptb->lSelStart)
                ptb->lSelEnd = ptb->lSelStart;
            goto RedrawTB;

        case TBM_SETSELSTART:

            if (!(ptb->ci.style & TBS_ENABLESELRANGE)) break;
            ptb->Flags |= TBF_SELECTION;
            if (lParam < ptb->lLogMin)
                ptb->lSelStart = ptb->lLogMin;
            else
                ptb->lSelStart = (LONG) lParam;
            if (ptb->lSelEnd < ptb->lSelStart || ptb->lSelEnd == -1)
                ptb->lSelEnd = ptb->lSelStart;
            goto RedrawTB;

        case TBM_SETSELEND:

            if (!(ptb->ci.style & TBS_ENABLESELRANGE)) break;
            ptb->Flags |= TBF_SELECTION;
            if (lParam > ptb->lLogMax)
                ptb->lSelEnd = ptb->lLogMax;
            else
                ptb->lSelEnd = (LONG) lParam;
            if (ptb->lSelStart > ptb->lSelEnd || ptb->lSelStart == -1)
                ptb->lSelStart = ptb->lSelEnd;
            goto RedrawTB;

        case TBM_SETRANGE:

            ptb->lLogMin = (LONG)(SHORT)LOWORD(lParam);
            ptb->lLogMax = (LONG)(SHORT)HIWORD(lParam);
            if (ptb->lSelStart < ptb->lLogMin)
                ptb->lSelStart = ptb->lLogMin;
            if (ptb->lSelEnd > ptb->lLogMax)
                ptb->lSelEnd = ptb->lLogMax;
            DoAutoTics(ptb);
            goto RedrawTB;

        case TBM_SETRANGEMIN:
            ptb->lLogMin = (LONG)lParam;
            if (ptb->lSelStart < ptb->lLogMin)
                ptb->lSelStart = ptb->lLogMin;
            DoAutoTics(ptb);
            goto RedrawTB;

        case TBM_SETRANGEMAX:
            ptb->lLogMax = (LONG)lParam;
            if (ptb->lSelEnd > ptb->lLogMax)
                ptb->lSelEnd = ptb->lLogMax;
            DoAutoTics(ptb);

RedrawTB:
            ptb->lLogPos = BOUND(ptb->lLogPos, ptb->lLogMin,ptb->lLogMax);
            TBChanged(ptb, TBC_ALL);
            /* Only redraw if flag says so */
            if (wParam) {
                InvalidateRect(hwnd, NULL, FALSE);
                MoveThumb(ptb, ptb->lLogPos);
            }
            break;

        case TBM_SETTHUMBLENGTH:
            if (ptb->ci.style & TBS_FIXEDLENGTH) {
                ptb->iThumbHeight = (UINT)wParam;
                TBResize(ptb);
            }
            break;

        case TBM_GETTHUMBLENGTH:
            return ptb->iThumbHeight;

        case TBM_SETPAGESIZE: {
            LONG lOldPage = ptb->lPageSize == -1 ? (ptb->lLogMax - ptb->lLogMin)/5 : ptb->lPageSize;
            ptb->lPageSize = (LONG)lParam;
            return lOldPage;
        }

        case TBM_GETPAGESIZE:
            return ptb->lPageSize == -1 ? (ptb->lLogMax - ptb->lLogMin)/5 : ptb->lPageSize;

        case TBM_SETLINESIZE:  {
            LONG lOldLine = ptb->lLineSize;
            ptb->lLineSize = (LONG)lParam;
            return lOldLine;
        }

        case TBM_GETLINESIZE:
            return ptb->lLineSize;

        case TBM_GETTHUMBRECT:
            if (lParam) {
                *((LPRECT)lParam) = ptb->rcThumb;
                if (ISVERT(ptb)) FlipRect((LPRECT)lParam);
            }
            break;

        case TBM_GETTOOLTIPS:
            return (LRESULT)ptb->hwndToolTips;

        case TBM_SETTOOLTIPS:
            ptb->hwndToolTips = (HWND)wParam;
            break;

        case TBM_SETTIPSIDE:
        {
            UINT uOldSide = ptb->uTipSide;
            
            ptb->uTipSide = (UINT) wParam;
            return uOldSide;
        }

        case TBM_GETCHANNELRECT:
            GetChannelRect(ptb, (LPRECT)lParam);
            break;

        case TBM_SETBUDDY:
            return (LRESULT)TBSetBuddy(ptb, (BOOL)wParam, (HWND)lParam);

        case TBM_GETBUDDY:
            return (LRESULT)(wParam ? ptb->hwndBuddyLeft : ptb->hwndBuddyRight);

        case WM_GETOBJECT:
            if( lParam == OBJID_QUERYCLASSNAMEIDX )
                return MSAA_CLASSNAMEIDX_TRACKBAR;
            goto DoDefault;

        case WM_THEMECHANGED:
            if (ptb->hTheme)
                CloseThemeData(ptb->hTheme);

            ptb->hTheme = OpenThemeData(ptb->ci.hwnd, L"TrackBar");

            TBInvalidateAll(ptb);
            break;

        default:
            if (uMsg == g_msgMSWheel) 
            {
                int   cDetants;
                long  lPos;
                ULONG ulPos;
                int   iWheelDelta = (int)(short)HIWORD(wParam);

                // Update count of scroll amount
                gcWheelDelta -= iWheelDelta;
                cDetants = gcWheelDelta / WHEEL_DELTA;
                if (cDetants != 0) 
                {
                    gcWheelDelta %= WHEEL_DELTA;
                }

                if (wParam & (MK_SHIFT | MK_CONTROL))
                    goto DoDefault;

                if (SHRT_MIN <= ptb->lLogPos && ptb->lLogPos <= SHRT_MAX) 
                {
                    // Update position based on the logical unit length of the trackbar
                    // The larger the spread, the more logical units traversed
                    int cMult = (ptb->lLogMax - ptb->lLogMin) / 50;
                    if (cMult == 0)
                        cMult = 1;

                    lPos = ptb->lLogPos + (cDetants * cMult);
                    lPos = BOUND(lPos, ptb->lLogMin, ptb->lLogMax);
                    ulPos = BOUND(lPos, SHRT_MIN, SHRT_MAX);
                    if ((long) ulPos != ptb->lLogPos) 
                    {
                        MoveThumb(ptb, (long) ulPos);
                        DoTrack(ptb, TB_THUMBPOSITION, ulPos);
                    }
                }

                return TRUE;
            }
            else
            {
                LRESULT lres;
                if (CCWndProc(&ptb->ci, uMsg, wParam, lParam, &lres))
                    return lres;
            }

DoDefault:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0L;
}

/* DoTrack() */

void DoTrack(PTRACKBAR ptb, int cmd, DWORD dwPos)
{
    LONG dpos;
    switch(cmd) {
        case TB_LINEDOWN:
            dpos = ptb->lLineSize;
            goto DMoveThumb;

        case TB_LINEUP:
            dpos = -ptb->lLineSize;
            goto DMoveThumb;

        case TB_PAGEUP:
        case TB_PAGEDOWN:
            if (ptb->lPageSize == -1) {
                dpos = (ptb->lLogMax - ptb->lLogMin) / 5;
                if (!dpos)
                    dpos = 1;
            } else {
                dpos = ptb->lPageSize;
            }

            if (cmd == TB_PAGEUP)
                dpos *= -1;

DMoveThumb: // move delta
            MoveThumb(ptb, ptb->lLogPos + dpos);
            break;

        case TB_BOTTOM:
            dpos = ptb->lLogMax; // the BOUND will take care of this;
            goto ABSMoveThumb;

        case TB_TOP:
            dpos = ptb->lLogMin; // the BOUND will take care of this;

ABSMoveThumb: // move absolute
            MoveThumb(ptb, dpos);
            break;

        default:  // do nothing
            break;

    }

    // note: we only send back a WORD worth of the position.
    if (ISVERT(ptb)) {
        FORWARD_WM_VSCROLL(ptb->ci.hwndParent, ptb->ci.hwnd, cmd, LOWORD(dwPos), SendMessage);
    } else
        FORWARD_WM_HSCROLL(ptb->ci.hwndParent, ptb->ci.hwnd, cmd, LOWORD(dwPos), SendMessage);
}

/* WTrackType() */

WORD WTrackType(PTRACKBAR ptb, LONG lParam)
{
    POINT pt;

    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    if (ptb->Flags & TBF_NOTHUMB ||
        ptb->ci.style & TBS_NOTHUMB)            // If no thumb, just leave.
        return 0;

    if (ISVERT(ptb)) {
        // put point in virtual coordinates
        int temp;
        temp = pt.x;
        pt.x = pt.y;
        pt.y = temp;
    }

    if (PtInRect(&ptb->rcThumb, pt))
        return TB_THUMBTRACK;

    if (!PtInRect(&ptb->rc, pt))
        return 0;

    if (pt.x >= ptb->rcThumb.left)
        return TB_PAGEDOWN;
    else
        return TB_PAGEUP;
}

/* TBTrackInit() */

void TBTrackInit(PTRACKBAR ptb, LPARAM lParam)
{
        WORD wCmd;

        if (ptb->Flags & TBF_NOTHUMB ||
            ptb->ci.style & TBS_NOTHUMB)         // No thumb:  just leave.
            return;

        wCmd = WTrackType(ptb, (LONG) lParam);
        if (!wCmd)
            return;

        SetCapture(ptb->ci.hwnd);

        ptb->Cmd = wCmd;
        ptb->dwDragPos = (DWORD)-1;

        // Set up for auto-track (if needed).
        if (wCmd != TB_THUMBTRACK) {
                // Set our timer up
                SetTimer(ptb->ci.hwnd, TIMER_ID, REPEATTIME, NULL);
        } else {
            int xPos;
            // thumb tracking...

            // store the offset between the cursor's position and the center of the thumb
            xPos = TBLogToPhys(ptb, ptb->lLogPos);
            ptb->dwDragOffset = (ISVERT(ptb) ? HIWORD(lParam) : LOWORD(lParam)) - xPos;

            if (ptb->hwndToolTips) {
                TOOLINFO ti;
                // don't bother setting the rect because we'll do it below
                // in FlushToolTipsMgr;
                ti.cbSize = sizeof(ti);
                ti.uFlags = TTF_TRACK | TTF_CENTERTIP;
                ti.hwnd = ptb->ci.hwnd;
                ti.uId = (UINT_PTR)ptb->ci.hwnd;
                SendMessage(ptb->hwndToolTips, TTM_TRACKACTIVATE, (WPARAM)TRUE, (LPARAM)&ti);
            }
        }

        TBTrack(ptb, lParam);
}

/* EndTrack() */

void TBTrackEnd(PTRACKBAR ptb)
{
        // Decide how we're ending this thing.
        if (ptb->Cmd == TB_THUMBTRACK) {

            if (ptb->hwndToolTips)
                SendMessage(ptb->hwndToolTips, TTM_TRACKACTIVATE, (WPARAM)FALSE, 0);

            DoTrack(ptb, TB_THUMBPOSITION, ptb->dwDragPos);

        }

        KillTimer(ptb->ci.hwnd, TIMER_ID);

        // Always send TB_ENDTRACK message if there's some sort of command tracking.
        if (ptb->Cmd != (UINT)-1) {
            DoTrack(ptb, TB_ENDTRACK, 0);

            // Nothing going on.
            ptb->Cmd = (UINT)-1;
        }

        MoveThumb(ptb, ptb->lLogPos);
}

#define TBTS_RIGHTLEFT   1   // low bit means it's on the right or left

void TBTrack(PTRACKBAR ptb, LPARAM lParam)
{
    DWORD dwPos;
    WORD pos;


    // See if we're tracking the thumb
    if (ptb->Cmd == TB_THUMBTRACK) {


        pos = (ISVERT(ptb)) ? HIWORD(lParam) : LOWORD(lParam);
        pos -= (WORD) ptb->dwDragOffset;
        dwPos = TBPhysToLog(ptb, (int)(SHORT)pos);

        // Tentative position changed -- notify the guy.
        if (dwPos != ptb->dwDragPos) {
            ptb->dwDragPos = dwPos;
            MoveThumb(ptb, dwPos);
            DoTrack(ptb, TB_THUMBTRACK, dwPos);
        }

        if (ptb->hwndToolTips) {
            RECT rc;
            POINT pt;
            int iPixel;
            UINT uTipSide = ptb->uTipSide;

            // find the center of the window
            GetClientRect(ptb->ci.hwnd, &rc);
            pt.x = rc.right / 2;
            pt.y = rc.bottom / 2;

            //find the position of the thumb
            iPixel = TBLogToPhys(ptb, dwPos);
            if (ISVERT(ptb)) {
                pt.y = iPixel;
                uTipSide |= TBTS_RIGHTLEFT;
            } else {
                pt.x = iPixel;
                uTipSide &= ~TBTS_RIGHTLEFT;
            }
            
            // move it out to the requested side
            switch (uTipSide) {

            case TBTS_TOP:
                pt.y = -1;
                break;

            case TBTS_LEFT:
                pt.x = -1;
                break;

            case TBTS_BOTTOM:
                pt.y = rc.bottom + 1;
                break;

            case TBTS_RIGHT:
                pt.x = rc.right + 1;
                break;
            }

            // map it to screen coordinates
            MapWindowPoints(ptb->ci.hwnd, HWND_DESKTOP, &pt, 1);

            SendMessage(ptb->hwndToolTips, TTM_TRACKPOSITION, 0, MAKELONG(pt.x, pt.y));
        }

    }
    else {
        if (ptb->Cmd != WTrackType(ptb, (LONG) lParam))
            return;

        DoTrack(ptb, ptb->Cmd, 0);
    }
}


// FlushChanges is theme aware (RENDERS)
void FlushChanges(PTRACKBAR ptb)
{
    HBRUSH hbr;
    NMCUSTOMDRAW nmcd;

    hbr = FORWARD_WM_CTLCOLORSTATIC(ptb->ci.hwndParent, ptb->hdc, ptb->ci.hwnd, SendMessage);

    if (hbr) 
    {
        RECT rc;
        BOOL fClear = FALSE;

        if ( ptb->wDirtyFlags == TBC_ALL ) 
        {
            GetClientRect(ptb->ci.hwnd, &rc);
            fClear = TRUE;
        } 
        else if (ptb->wDirtyFlags & TBC_THUMB) 
        {
            rc = ptb->rc;
            rc.left = 0;
            rc.right += ptb->iThumbWidth;
            if (ISVERT(ptb))
                FlipRect(&rc);
            fClear = TRUE;
        }

        // Background fill
        if (fClear)
        {
            FillRect(ptb->hdc, &rc, hbr);
        }
    }

    nmcd.hdc = ptb->hdc;
    if (ptb->ci.hwnd == GetFocus())
        nmcd.uItemState = CDIS_FOCUS;
    else
        nmcd.uItemState = 0;

    nmcd.lItemlParam = 0;
    ptb->ci.dwCustom = CICustomDrawNotify(&ptb->ci, CDDS_PREPAINT, &nmcd);

    // for skip default, no other flags make sense..  only allow that one
    if (!(ptb->ci.dwCustom == CDRF_SKIPDEFAULT)) 
    {
        DWORD dwRet = 0;
        // do the actual drawing

        if (nmcd.uItemState & CDIS_FOCUS)
        {
            DrawFocus(ptb, hbr);
        }

        nmcd.uItemState = 0;
        if (ptb->wDirtyFlags & TBC_TICS) 
        {

            nmcd.dwItemSpec = TBCD_TICS;
            dwRet = CICustomDrawNotify(&ptb->ci, CDDS_ITEMPREPAINT, &nmcd);

            if (!(dwRet == CDRF_SKIPDEFAULT)) 
            {
                DrawTics(ptb);

                if (dwRet & CDRF_NOTIFYPOSTPAINT) 
                {
                    nmcd.dwItemSpec = TBCD_TICS;
                    CICustomDrawNotify(&ptb->ci, CDDS_ITEMPOSTPAINT, &nmcd);
                }
            }
        }

        if (ptb->wDirtyFlags & TBC_THUMB) 
        {


            // the channel
            GetChannelRect(ptb, &nmcd.rc);
            if (ISVERT(ptb))
                FlipRect(&nmcd.rc);
            nmcd.dwItemSpec = TBCD_CHANNEL;
            dwRet = CICustomDrawNotify(&ptb->ci, CDDS_ITEMPREPAINT, &nmcd);

            if (!(dwRet == CDRF_SKIPDEFAULT)) 
            {

                // flip it back from the last notify
                if (ISVERT(ptb))
                    FlipRect(&nmcd.rc);

                // the actual drawing
                DrawChannel(ptb, &nmcd.rc);

                if (dwRet & CDRF_NOTIFYPOSTPAINT) 
                {

                    if (ISVERT(ptb))
                        FlipRect(&nmcd.rc);
                    nmcd.dwItemSpec = TBCD_CHANNEL;
                    CICustomDrawNotify(&ptb->ci, CDDS_ITEMPOSTPAINT, &nmcd);
                }
            }


            // the thumb
            nmcd.rc = ptb->rcThumb;
            if (ptb->Cmd == TB_THUMBTRACK) 
            {
                nmcd.uItemState = CDIS_SELECTED;
            }

            if (ISVERT(ptb))
                FlipRect(&nmcd.rc);
            nmcd.dwItemSpec = TBCD_THUMB;
            dwRet = CICustomDrawNotify(&ptb->ci, CDDS_ITEMPREPAINT, &nmcd);

            if (!(dwRet == CDRF_SKIPDEFAULT))
            {

                if (ISVERT(ptb))
                    FlipRect(&nmcd.rc);

                // the actual drawing
                DrawThumb(ptb, &nmcd.rc, nmcd.uItemState & CDIS_SELECTED);

                if (dwRet & CDRF_NOTIFYPOSTPAINT) 
                {
                    if (ISVERT(ptb))
                        FlipRect(&nmcd.rc);
                    nmcd.dwItemSpec = TBCD_THUMB;
                    CICustomDrawNotify(&ptb->ci, CDDS_ITEMPOSTPAINT, &nmcd);
                }
            }

        }
        ptb->wDirtyFlags = 0;

        // notify parent afterwards if they want us to
        if (ptb->ci.dwCustom & CDRF_NOTIFYPOSTPAINT)
        {
            CICustomDrawNotify(&ptb->ci, CDDS_POSTPAINT, &nmcd);
        }
    }

#ifdef TB_DEBUG
    DebugMsg(DM_TRACE, TEXT("DrawDone"));
    {
        HDC hdcScreen;
        RECT rcClient;
        hdcScreen = GetDC(NULL);
        GetClientRect(ptb->ci.hwnd, &rcClient);
        BitBlt(hdcScreen, 200, 0, 200 + rcClient.right, rcClient.bottom, ptb->hdc, 0,0, SRCCOPY);
        ReleaseDC(NULL, hdcScreen);
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\treeview.h ===
#include "listview.h"   // for some helper routines and border metrics
#define __IOleControl_INTERFACE_DEFINED__       // There is a conflich with the IOleControl's def of CONTROLINFO
#include "shlobj.h"

//
//  Definitions missing from commctrl.h
//
typedef const TVITEMEX *LPCTVITEMEX;

//
//  Private definitions
//
#define MAGIC_MININDENT 5
#define MAGIC_INDENT    3
#define MAGIC_HORZLINE  5

// flags for TV_DrawItem
#define TVDI_NOIMAGE    0x0001  // don't draw image
#define TVDI_NOTREE     0x0002  // don't draw indent, lines, +/-
#define TVDI_TRANSTEXT  0x0004  // draw text transparently in black
#define TVDI_ERASE      0x0008  // erase while drawing
#define TVDI_GRAYTEXT   0x0010  // text is gray (disabled item)
#define TVDI_GRAYCTL    0x0020  // text and background is gray (disabled control)
#define TVDI_FORCEIMAGE 0x0040  // Always draw image
#define TVDI_NOBK       0x0080

// Internal flags for TV_SelectItem
#define TVC_INTERNAL   0x1000

typedef struct _TREE 
{
    CCONTROLINFO ci;

    // Flags
    BITBOOL        fHorz:1;        // horizontal scrollbar present
    BITBOOL        fVert:1;        // vertical scrollbar present
    BITBOOL        fFocus:1;       // currently has focus
    BITBOOL        fNameEditPending:1;  // Is a name edit pending?
    BITBOOL        fRedraw:1;      // should redraw?
    BITBOOL        fScrollWait:1;  // are we waiting for a dblclk to not scroll?
    BITBOOL        fCreatedFont:1; // we created our font
    BITBOOL        fNoDismissEdit:1; // don't dismiss in-place edit control
    BITBOOL        fIndentSet:1;    // is the parent managing the indent size?
    BITBOOL        fTrackSet:1;    // have we set a track event?
    BITBOOL        fPlaceTooltip:1; // should we do the placement of tooltip over the text?
    BITBOOL        fCyItemSet:1;    // the the parent set our item height?
    BITBOOL        fInsertAfter:1; // insert mark should be after htiInsert instead of before
    BITBOOL        fRestoreOldDrop:1; // hOldDrop needs to be restored to hDropTarget

    // Handles
    HTREEITEM   hRoot;          // tree root item
    HTREEITEM   hCaret;         // item with focus caret
    HTREEITEM   hDropTarget;    // item which is the drop target
    HTREEITEM   hOldDrop;       // item which used to be the drop target
    HTREEITEM   htiEdit;        // The item that is being edited.
    HTREEITEM   hHot;           // the currently hottracked item
    HTREEITEM   hToolTip;       // the current item set in tooltips
    HTREEITEM   htiInsert;      // item that is relative to the insert mark
    HTREEITEM   htiSearch;      // item active in most recent incremental search
    HTREEITEM   htiDrag;        // item that's being dragged.
    HDPA        hdpaWatch;      // array of PTVWATCHEDITEMs - items being watched
    HIMAGELIST  hImageList;     // image list
    HIMAGELIST  himlState;      // state image list

    HCURSOR hCurHot; // the cursor when we're over a hot item

    int         iPuntChar;      // number of wm_char's to punt
    int         cxState;
    int         cyState;

    HBRUSH      hbrBk;          // background brush
    HFONT       hFont;          // tree font
    HFONT       hFontHot;       // underlined for hot tracking
    HFONT       hFontBold;      // bold tree font
    HFONT       hFontBoldHot;       // underlined for hot tracking
    HBITMAP     hStartBmp;      // initial DC mono bitmap
    HBITMAP     hBmp;           // indent bitmaps in hdcBits
    HDC         hdcBits;        // HDC for drawing indent bitmaps
    HTREEITEM   hItemPainting;  // the guy we are currently painting
    HANDLE      hheap;          // heap for allocs for win32

    HBRUSH      hbrLine;
    HBRUSH      hbrText;

    POINT       ptCapture;      // Point where the mouse was capture

    COLORREF    clrText;
    COLORREF    clrBk; 
    COLORREF    clrim;          // insert mark color.
    COLORREF    clrLine;        // line color

    COLORREF    clrBkNonTheme;      // Saved when not themed
    COLORREF    clrLineNonTheme;    // Saved when not themed

    // Dimensions
    SHORT       cxImage;        // image width
    SHORT       cyImage;        // image height
    SHORT       cxNativeImage;  // image width (no scaling)
    SHORT       cyNativeImage;  // image height (no scaling)
    SHORT       cyText;         // text height
    SHORT       cyItem;         // item height
    SHORT       cxBorder;   // horizontal item border
    SHORT       cyBorder;   // vert item border
    SHORT       cxIndent;       // indent width
    SHORT       cxWnd;          // window width
    SHORT       cyWnd;          // window height

    // Scroll Positioners
    WORD        cxMax;          // width of longest item
    WORD        cFullVisible;   // number of items that CAN fully fit in window
    SHORT       xPos;           // horizontal scrolled position
    UINT        cShowing;       // number of showing (non-collapsed) items
    UINT        cItems;         // total number of items
    HTREEITEM   hTop;           // first visible item (i.e., at top of client rect)
    UINT        uMaxScrollTime; // the maximum smooth scroll timing

    // stuff for edit in place
    HWND        hwndEdit;       // Edit window for name editing.
    WNDPROC     pfnEditWndProc; // edit field subclass proc

    //tooltip stuff
    HWND        hwndToolTips;
    LPTSTR      pszTip;         // store current tooltip/infotip string.
#ifdef UNICODE
    LPSTR       pszTipA;        // store current ANSI tooltip/infotip string.
#endif

    //incremental search stuff
    ISEARCHINFO is;

    HTHEME hTheme;

    DWORD       dwLastAccId;
    DWORD       dwExStyle;

#ifdef DEBUG
    BOOL        fInTextCallback;
#endif
} TREE, *PTREE;

#define TV_StateIndex(pitem) ((int)(((DWORD)((pitem)->state) >> 12) & 0xF))

#define KIDS_COMPUTE            0    // use hKids to determine if a node has children
#define KIDS_FORCE_YES          1    // force a node to have kids (ignore hKids)
#define KIDS_FORCE_NO           2    // force a node to not have kids (ignore hKids)
#define KIDS_CALLBACK           3    // callback to see if a node has kids
#define KIDS_INVALID            4    // all values this and above are bogus

#define MAXLABELTEXT            MAX_PATH

//
//  Note that there are multiple senses of "visible" going on.
//
//  TREE.hTop tracks visibility in the sense of "will it be painted?"
//
//  TREEITEM.iShownIndex tracks visibility in the sense of "not collapsed".
//  You can be off the screen but as long as your parent is expanded
//  you get an iShownIndex.
//
//

typedef struct _TREEITEM 
{
    HTREEITEM hParent;          // allows us to walk back out of the tree
    HTREEITEM hNext;            // next sibling
    HTREEITEM hKids;            // first child
    LPTSTR    lpstr;            // item text, can be LPSTR_TEXTCALLBACK
    LPARAM lParam;              // item data
    DWORD     dwAccId;

    WORD      state;            // TVIS_ state flags
    WORD      iImage;           // normal state image at iImage
    WORD      iSelectedImage;   // selected state image
    WORD      iWidth;           // cached: width of text area (for hit test, drawing)
    WORD      iShownIndex;      // cached: -1 if not visible, otherwise nth visible item
                                // invisible = parent is invisible or collapsed
    BYTE      iLevel;           // cached: level of item (indent)
    BYTE      fKids;            // KIDS_ values
    WORD      iIntegral;        // integral height

// for parameter validation, put at end of struct
// ******************************
    WORD      wSignature;       
// ******************************
} TREEITEM;

//
//  The signature is intentionally not ASCII characters, so it's
//  harder to run into by mistake.  I choose a value greater than
//  0x8000 so it can't be the high word of a pointer.
//
#define TV_SIG      0xABCD

#define TV_MarkAsDead(hti)      ((hti)->wSignature = 0)

#define ITEM_VISIBLE(hti) ((hti)->iShownIndex != (WORD)-1)

// get the parent, avoiding the hidden root node
#define VISIBLE_PARENT(hItem) (!(hItem)->iLevel ? NULL : (hItem)->hParent)

// REVIEW: make this a function if the optimizer doesn't do well with this
#define FULL_WIDTH(pTree, hItem)  (ITEM_OFFSET(pTree,hItem) + hItem->iWidth)
int ITEM_OFFSET(PTREE pTree, HTREEITEM hItem);

#define VTI_NULLOK      1
BOOL ValidateTreeItem(HTREEITEM hItem, UINT flags);

#ifdef DEBUG
#define DBG_ValidateTreeItem(hItem, flags) ValidateTreeItem(hItem, flags)
#else
#define DBG_ValidateTreeItem(hItem, flags)
#endif

//
//  TVWATCHEDITEM
//
//  Structure that tracks items being watched.
//
//  See TV_StartWatch for more information, and TV_DoExpandRecurse
//  for an example.
//
//  The hti field is a bit odd.
//
//  if fStale == FALSE, then hti is the item being watched.
//  if fStale == TRUE , then hti is the item *after* the item being watched.
//
//  We keep this strange semantic for fStale==TRUE so that TV_NextWatchItem
//  can successfully step to the item after a deleted item.  (Normally,
//  trying to do anything with a deleted item will fault.)
//

typedef struct TVWATCHEDITEM 
{
    HTREEITEM   hti;                    // current item
    BOOL        fStale;                 // has the original item been deleted?
} TVWATCHEDITEM, *PTVWATCHEDITEM;

BOOL TV_StartWatch(PTREE pTree, PTVWATCHEDITEM pwi, HTREEITEM htiStart);
BOOL TV_EndWatch(PTREE pTree, PTVWATCHEDITEM pwi);
#define TV_GetWatchItem(pTree, pwi) ((pwi)->hti)
#define TV_RestartWatch(pTree, pwi, htiStart) \
                        ((pwi)->hti = (htiStart), (pwi)->fStale = FALSE)
#define TV_IsWatchStale(pTree, pwi) ((pwi)->fStale)
#define TV_IsWatchValid(pTree, pwi) (!(pwi)->fStale)
#define TV_GetAccId(hItem)  ((hItem)? (hItem)->dwAccId : CHILDID_SELF)
//
//  TV_NextWatchItem - Enumerate the item after the watched item.
//                     This works even if the watched item was deleted.
//
#define TV_NextWatchItem(pTree, pwi) \
    ((pwi)->fStale || ((pwi)->hti = (pwi)->hti->hNext)), \
     (pwi)->fStale = FALSE

// in TVSCROLL.C
BOOL       TV_ScrollBarsAfterAdd       (PTREE, HTREEITEM);
BOOL       TV_ScrollBarsAfterRemove    (PTREE, HTREEITEM);
BOOL       TV_ScrollBarsAfterExpand    (PTREE, HTREEITEM);
BOOL       TV_ScrollBarsAfterCollapse  (PTREE, HTREEITEM);
void       TV_ScrollBarsAfterResize    (PTREE, HTREEITEM, int, UINT);
BOOL       TV_ScrollBarsAfterSetWidth  (PTREE, HTREEITEM);
BOOL       TV_HorzScroll               (PTREE, UINT, UINT);
BOOL       TV_VertScroll               (PTREE, UINT, UINT);
BOOL       TV_SetLeft                  (PTREE, int);
#define TV_SetTopItem(pTree, i) TV_SmoothSetTopItem(pTree, i, 0)
BOOL       TV_SmoothSetTopItem               (PTREE, UINT, UINT);
BOOL       TV_CalcScrollBars           (PTREE);
BOOL       TV_ScrollIntoView           (PTREE, HTREEITEM);
BOOL       TV_ScrollVertIntoView       (PTREE, HTREEITEM);
HTREEITEM  TV_GetShownIndexItem        (HTREEITEM, UINT);
UINT       TV_ScrollBelow              (PTREE, HTREEITEM, BOOL, BOOL);
BOOL       TV_SortChildren(PTREE, HTREEITEM, BOOL);
BOOL       TV_SortChildrenCB(PTREE, LPTV_SORTCB, BOOL);
void       TV_ComputeItemWidth(PTREE pTree, HTREEITEM hItem, HDC hdc);

// in TVPAINT.C
void        TV_GetBackgroundBrush       (PTREE pTree, HDC hdc);
void        TV_UpdateTreeWindow         (PTREE, BOOL);
void        TV_ChangeColors             (PTREE);
void        TV_CreateIndentBmps         (PTREE);
void        TV_Paint                    (PTREE, HDC);
HIMAGELIST  TV_CreateDragImage          (PTREE pTree, HTREEITEM hItem);
BOOL        TV_ShouldItemDrawBlue       (PTREE pTree, TVITEMEX *ti, UINT flags);
LRESULT     TV_GenerateDragImage        (PTREE ptree, SHDRAGIMAGE* pshdi);

BOOL TV_GetInsertMarkRect(PTREE pTree, LPRECT prc);

// in TVMEM.C

#define TVDI_NORMAL             0x0000  // TV_DeleteItem flags
#define TVDI_NONOTIFY           0x0001
#define TVDI_CHILDRENONLY       0x0002
#define TVDI_NOSELCHANGE        0x0004

BOOL       TV_DeleteItem(PTREE, HTREEITEM, UINT);
HTREEITEM  TV_InsertItem(PTREE pTree, LPTV_INSERTSTRUCT lpis);
void       TV_DestroyTree(PTREE);
LRESULT    TV_OnCreate(HWND, LPCREATESTRUCT);


#ifdef UNICODE
HTREEITEM  TV_InsertItemA(PTREE pTree, LPTV_INSERTSTRUCTA lpis);
#endif


// in TREEVIEW.C
BOOL      TV_GetItemRect(PTREE, HTREEITEM, LPRECT, BOOL);
BOOL      TV_Expand(PTREE pTree, WPARAM wCode, TREEITEM * hItem, BOOL fNotify);
HTREEITEM TV_GetNextItem(PTREE, HTREEITEM, WPARAM);
void      TV_GetItem(PTREE pTree, HTREEITEM hItem, UINT mask, LPTVITEMEX lpItem);
void      TV_PopBubble(PTREE pTree);

// Flags for TV_SelectItem
#define TVSIFI_NOTIFY            0x0001
#define TVSIFI_UPDATENOW         0x0002
#define TVSIFI_NOSINGLEEXPAND    0x0004

BOOL      TV_SelectItem(PTREE, WPARAM, HTREEITEM, UINT, UINT);
BOOL      TV_SendChange(PTREE, HTREEITEM, int, UINT, UINT, UINT, int, int);
HTREEITEM TV_GetNextVisItem(HTREEITEM);
HTREEITEM TV_GetPrevItem(HTREEITEM);
HTREEITEM TV_GetPrevVisItem(HTREEITEM);
void      TV_CalcShownItems(PTREE, HTREEITEM hItem);
void      TV_OnSetFont(PTREE, HFONT, BOOL);
BOOL      TV_SizeWnd(PTREE, UINT, UINT);
void      TV_InvalidateItem(PTREE, HTREEITEM, UINT uFlags);
VOID TV_CreateBoldFont(PTREE pTree);
BOOL TV_SetInsertMark(PTREE pTree, HTREEITEM hItem, BOOL fAfter);

LRESULT CALLBACK _export TV_EditWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK _export TV_WndProc(HWND, UINT, WPARAM, LPARAM);
BOOL                 TV_Init(HINSTANCE hinst);
void                 TV_Terminate(BOOL fSystemExit);

LRESULT    TV_Timer                    (PTREE pTree, UINT uTimerId);
HWND       TV_OnEditLabel              (PTREE pTree, HTREEITEM hItem);
void       TV_SetEditSize              (PTREE pTree);
BOOL       TV_DismissEdit              (PTREE pTree, BOOL fCancel);
void       TV_CancelPendingEdit        (PTREE pTree);
int        TV_UpdateShownIndexes       (PTREE pTree, HTREEITEM hWalk);


void TV_UnsubclassToolTips(PTREE pTree);
LRESULT WINAPI TV_SubClassWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
void TV_SubclassToolTips(PTREE pTree);
BOOL TV_UpdateToolTip(PTREE pTree);
BOOL TV_SetToolTipTarget(PTREE pTree, HTREEITEM hItem);
void TV_OnSetBkColor(PTREE pTree, COLORREF clr);
void TV_InitCheckBoxes(PTREE pTree);
void TV_InitThemeMetrics(PTREE pTree, HTHEME hTheme);

#define TVMP_CALCSCROLLBARS (TV_FIRST + 0x1000)

// Fake customdraw.  See comment block in tvscroll.c

typedef struct TVFAKEDRAW 
{
    NMTVCUSTOMDRAW nmcd;
    PTREE pTree;
    HFONT hfontPrev;
    DWORD dwCustomPrev;
    DWORD dwCustomItem;
} TVFAKEDRAW, *PTVFAKEDRAW;

void TreeView_BeginFakeCustomDraw(PTREE pTree, PTVFAKEDRAW ptvfd);
DWORD TreeView_BeginFakeItemDraw(PTVFAKEDRAW plvfd, HTREEITEM hitem);
void TreeView_EndFakeItemDraw(PTVFAKEDRAW ptvfd);
void TreeView_EndFakeCustomDraw(PTVFAKEDRAW ptvfd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\toolbar.cpp ===
/*
** Toolbar.c
**
** This is it, the incredibly famous toolbar control.  Most of
** the customization stuff is in another file.
*/

#include "ctlspriv.h"
#include "toolbar.h"
extern "C" 
{
    #include "image.h"
}
#include <limits.h>
#define __IOleControl_INTERFACE_DEFINED__       // There is a conflich with the IOleControl's def of CONTROLINFO
#include "shlobj.h"

#define TBP_ONRELEASECAPTURE (WM_USER + 0x500)

#define TBIMAGELIST
// these values are defined by the UI gods...
#define DEFAULTBITMAPX 16
#define DEFAULTBITMAPY 15

#define LIST_GAP        (g_cxEdge * 2)
#define DROPDOWN_GAP    (g_cxEdge * 2)
#define CX_TOP_FUDGE    (g_cxEdge * 2)

#define SMALL_DXYBITMAP     16      // new dx dy for sdt images
#define LARGE_DXYBITMAP     24

#define DEFAULTBUTTONX      24
#define DEFAULTBUTTONY      22
// the insert mark is 6 pixels high/wide depending on horizontal or vertical mode...
#define INSERTMARKSIZE      6

const int g_dxButtonSep = 8;
const int s_xFirstButton = 0;   // was 8 in 3.1
#define USE_MIXED_BUTTONS(ptb) (((ptb)->dwStyleEx & TBSTYLE_EX_MIXEDBUTTONS) && ((ptb)->ci.style & TBSTYLE_LIST))
#define BTN_NO_SHOW_TEXT(ptb, ptbb) (!(ptb)->nTextRows || (USE_MIXED_BUTTONS(ptb) && !((ptbb)->fsStyle & BTNS_SHOWTEXT)))
#define BTN_IS_AUTOSIZE(ptb, ptbb) (((ptbb)->fsStyle & BTNS_AUTOSIZE) || (USE_MIXED_BUTTONS(ptb) && !((ptbb)->fsStyle & BTNS_SEP)))
#define DRAW_MONO_BTN(ptb, state)   (!(state & TBSTATE_ENABLED) || ((ptb->ci.style & WS_DISABLED)))
#ifdef DPITEST
#define ToolBar_IsDPIScaled(ptb) TRUE
#else
#define ToolBar_IsDPIScaled(ptb) (CCDPIScale(ptb->ci))
#endif

// Globals - since all of these globals are used durring a paint we have to
// take a criticial section around all toolbar paints.  can we do better?
//

const UINT wStateMasks[] = 
{
    TBSTATE_ENABLED,
    TBSTATE_CHECKED,
    TBSTATE_PRESSED,
    TBSTATE_HIDDEN,
    TBSTATE_INDETERMINATE,
    TBSTATE_MARKED
};

#define TBISSTRINGPTR(iString)  (((iString) != -1) && (!IS_INTRESOURCE(iString)))

#define TBDraw_State(ptbdraw)   ((ptbdraw)->tbcd.nmcd.uItemState)

LRESULT CALLBACK ToolbarWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
void TBOnButtonStructSize(PTBSTATE ptb, UINT uStructSize);
BOOL SetBitmapSize(PTBSTATE ptb, int width, int height);
int  AddBitmap(PTBSTATE ptb, int nButtons, HINSTANCE hBMInst, UINT_PTR wBMID);
void TBBuildImageList(PTBSTATE ptb);
BOOL GetInsertMarkRect(PTBSTATE ptb, LPRECT lpRect, BOOL fHorizMode);
extern "C" LPTSTR TB_StrForButton(PTBSTATE ptb, LPTBBUTTONDATA pTBButton);
UINT TBGetDrawTextFlags(PTBSTATE ptb, UINT uiStyle, LPTBBUTTONDATA);
BOOL TBGetMaxSize( PTBSTATE ptb, LPSIZE lpsize );
void TBGetItem(PTBSTATE ptb,LPTBBUTTONDATA ptButton, LPNMTBDISPINFO ptbdi);

#define GT_INSIDE       0x0001
#define GT_MASKONLY     0x0002
BOOL GrowToolbar(PTBSTATE ptb, int newButWidth, int newButHeight, UINT flags);


//Pager Control Functions
LRESULT TB_OnScroll(PTBSTATE ptb, LPNMHDR pnm);
LRESULT TB_OnPagerControlNotify(PTBSTATE ptb,LPNMHDR pnm);
void TBAutoSize(PTBSTATE ptb);
LRESULT TB_OnCalcSize(PTBSTATE ptb, LPNMHDR pnm);

#define TBInvalidateImageList(ptb)  ((ptb)->fHimlValid = FALSE)
#define TBHasStrings(ptb)  ((ptb)->nStrings || (ptb)->fNoStringPool)

#ifdef DEBUG
#if 0
void _InvalidateRect(HWND hwnd, LPRECT prc, BOOL fInval)
{
    if (!(GetAsyncKeyState(VK_SHIFT) < 0) )
        InvalidateRect(hwnd, prc, fInval);
}
void _RedrawWindow(HWND hwnd, LPRECT prc, HANDLE hrgn, UINT uFlags)
{
    if (!(GetAsyncKeyState(VK_SHIFT) < 0) )
        RedrawWindow(hwnd, prc, hrgn, uFlags);
}

void _SetWindowPos(HWND hwnd, HWND hwnd2, int x, int y, int cx, int cy, UINT uFlags)
{
    if (GetAsyncKeyState(VK_SHIFT) < 0)
        uFlags &= ~( SWP_FRAMECHANGED);
    SetWindowPos(hwnd, hwnd2, x, y, cx, cy, uFlags);
}

#define InvalidateRect(hwnd, prc, fInval) _InvalidateRect(hwnd, prc, fInval)
#define RedrawWindow(hwnd, prc, hrgn, uFlags) _RedrawWindow(hwnd, prc, hrgn, uFlags)
#define SetWindowPos(hwnd, hwnd2, x, y, cx, cy, uFlags) _SetWindowPos(hwnd, hwnd2, x, y, cx, cy, uFlags)
#endif
#endif


__inline BOOL TB_IsDropDown(LPTBBUTTONDATA ptbb)
{
    BOOL fRet = (ptbb->fsStyle & (BTNS_DROPDOWN | BTNS_WHOLEDROPDOWN));

    return fRet;
}

__inline BOOL TB_HasDDArrow(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    BOOL fRet = (((ptb->dwStyleEx & TBSTYLE_EX_DRAWDDARROWS) &&
                        (ptbb->fsStyle & BTNS_DROPDOWN)) ||
                  (ptbb->fsStyle & BTNS_WHOLEDROPDOWN));

    return fRet;
}

__inline BOOL TB_HasSplitDDArrow(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    // If the button is both BTNS_DROPDOWN and BTNS_WHOLEDROPDOWN,
    // BTNS_WHOLEDROPDOWN wins.

    BOOL fRet = ((ptb->dwStyleEx & TBSTYLE_EX_DRAWDDARROWS) &&
                (ptbb->fsStyle & BTNS_DROPDOWN) &&
                !(ptbb->fsStyle & BTNS_WHOLEDROPDOWN));

    return fRet;
}

__inline BOOL TB_HasUnsplitDDArrow(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    BOOL fRet = (ptbb->fsStyle & BTNS_WHOLEDROPDOWN);

    return fRet;
}

__inline BOOL TB_HasTopDDArrow(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    BOOL fRet = (!(ptb->ci.style & TBSTYLE_LIST) &&
                TB_HasUnsplitDDArrow(ptb, ptbb) &&
                (ptb->nTextRows > 0) && TB_StrForButton(ptb, ptbb));

    return fRet;
}

// check if toolbar is double buffered
__inline BOOL TB_IsDoubleBuffer(PTBSTATE ptb)
{
#ifdef FULL_DEBUG
    static fOn = TRUE;
    if (GetKeyState(VK_SCROLL) < 0)
    {
        fOn = !fOn;
    }

    return (BOOL)fOn && (ptb->dwStyleEx & TBSTYLE_EX_DOUBLEBUFFER) && !(ptb->ci.dwExStyle & WS_EX_TRANSPARENT);


#endif
    return (BOOL)((ptb->dwStyleEx & TBSTYLE_EX_DOUBLEBUFFER) || ptb->fForcedDoubleBuffer) && !(ptb->ci.dwExStyle & WS_EX_TRANSPARENT);
}


// Cancel tracking tooltips which are activated by item focus via keyboard
void TB_CancelTipTrack(PTBSTATE ptb)
{
    // Make sure in tracking mode
    if (ptb->hwndToolTips)
    {
        // Cancel any pending timer
        KillTimer(ptb->ci.hwnd, IDT_TRACKINGTIP);

        if (TB_IsKbdTipTracking(ptb) && 
            ptb->iTracking < ptb->iNumButtons)
        {
            TOOLINFO ti = {0};
     
            ti.cbSize = sizeof(TOOLINFO);
            ti.hwnd = ptb->ci.hwnd;
            ti.uId = ptb->Buttons[ptb->iTracking].idCommand;

            SendMessage(ptb->hwndToolTips, TTM_GETTOOLINFO, 0, (LPARAM)&ti);

            SendMessage(ptb->hwndToolTips, TTM_TRACKACTIVATE, FALSE, (LPARAM)&ti);

            // Switch tooltip window back to non-tracking (manual) mode
            ti.uFlags &= ~TTF_TRACK;
            SendMessage(ptb->hwndToolTips, TTM_SETTOOLINFO, 0, (LPARAM)&ti);

            // Nothing being tracked
            ptb->iTracking = TBKTT_NOTRACK;
        }
    }
}

BOOL TBIsHotTrack(PTBSTATE ptb, LPTBBUTTONDATA ptButton, UINT state)
{
    BOOL fHotTrack = FALSE;

    if (&ptb->Buttons[ptb->iHot]==ptButton)
        fHotTrack = TRUE;

    // The following is in place to prevent hot tracking during the following conds:
    //  - drag & drop toolbar customization
    //  - when the mouse capture is on a particular button-press.
    // This does _not_ drop out of the loop because we don't want to break update
    // behavior; thus we'll have a little flickering on refresh as we pass over
    // these buttons.
    if (!(state & TBSTATE_PRESSED) && (GetKeyState (VK_LBUTTON) < 0) &&
        GetCapture() == ptb->ci.hwnd)
    {
        fHotTrack = FALSE;
    }

    if (!fHotTrack && (ptb->iPressedDD == ptButton - ptb->Buttons))
        fHotTrack = TRUE;

    return fHotTrack;
}


UINT StateFromCDIS(UINT uItemState)
{
    UINT state = 0;

    if (uItemState & CDIS_CHECKED)
        state |= TBSTATE_CHECKED;

    if (uItemState & CDIS_SELECTED)
        state |= TBSTATE_PRESSED;

    if (!(uItemState & CDIS_DISABLED))
        state |= TBSTATE_ENABLED;

    if (uItemState & CDIS_MARKED)
        state |= TBSTATE_MARKED;

    if (uItemState & CDIS_INDETERMINATE)
        state |= TBSTATE_INDETERMINATE;

    return state;
}


UINT CDISFromState(UINT state)
{
    UINT uItemState = 0;

    // Here are the TBSTATE - to - CDIS mappings:
    //
    //  TBSTATE_CHECKED         = CDIS_CHECKED
    //  TBSTATE_PRESSED         = CDIS_SELECTED
    // !TBSTATE_ENABLED         = CDIS_DISABLED
    //  TBSTATE_MARKED          = CDIS_MARKED
    //  TBSTATE_INDETERMINATE   = CDIS_INDETERMINATE
    //
    //  Hot tracked item        = CDIS_HOT
    //

    if (state & TBSTATE_CHECKED)
        uItemState |= CDIS_CHECKED;

    if (state & TBSTATE_PRESSED)
        uItemState |= CDIS_SELECTED;

    if (!(state & TBSTATE_ENABLED))
        uItemState |= CDIS_DISABLED;

    if (state & TBSTATE_MARKED)
        uItemState |= CDIS_MARKED;

    if (state & TBSTATE_INDETERMINATE)
        uItemState |= CDIS_INDETERMINATE;

    return uItemState;
}

void FlushToolTipsMgrNow(PTBSTATE ptb);

void TB_ForceCreateTooltips(PTBSTATE ptb)
{
    if (ptb->ci.style & TBSTYLE_TOOLTIPS && !ptb->hwndToolTips)
    {
        TOOLINFO ti;
        // don't bother setting the rect because we'll do it below
        // in TBInvalidateItemRects;
        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_IDISHWND|TTF_ABSOLUTE;
        if (ptb->dwStyleEx & TBSTYLE_EX_TOOLTIPSEXCLUDETOOLBAR)
            ti.uFlags |= TTF_EXCLUDETOOLAREA;
        ti.hwnd = ptb->ci.hwnd;
        ti.uId = (UINT_PTR)ptb->ci.hwnd;
        ti.lpszText = 0;

        ptb->hwndToolTips = CreateWindowEx(WS_EX_TRANSPARENT, c_szSToolTipsClass, NULL,
                                         WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                         ptb->ci.hwnd, NULL, HINST_THISDLL, NULL);
        if (ptb->hwndToolTips) 
        {
            int i;
            NMTOOLTIPSCREATED nm;

            CCSetInfoTipWidth(ptb->ci.hwnd, ptb->hwndToolTips);

            SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0,
                        (LPARAM)(LPTOOLINFO)&ti);

            nm.hwndToolTips = ptb->hwndToolTips;
            CCSendNotify(&ptb->ci, NM_TOOLTIPSCREATED, &nm.hdr);

            // don't bother setting the rect because we'll do it below
            // in TBInvalidateItemRects;
            ti.uFlags = 0;
            ti.lpszText = LPSTR_TEXTCALLBACK;

            for (i = 0; i < ptb->iNumButtons; i++) 
            {
                if (!(ptb->Buttons[i].fsStyle & BTNS_SEP)) 
                {
                    ti.uId = ptb->Buttons[i].idCommand;
                    SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0,
                                (LPARAM)(LPTOOLINFO)&ti);
                }
            }

            FlushToolTipsMgrNow(ptb);
        }
    }
}

void TBRelayToToolTips(PTBSTATE ptb, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    TB_ForceCreateTooltips(ptb);
    if (ptb->hwndToolTips) {
        RelayToToolTips(ptb->hwndToolTips, ptb->ci.hwnd, wMsg, wParam, lParam);
    }
}


LRESULT ToolbarDragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp)
{
    PTBSTATE ptb = (PTBSTATE)GetWindowInt(hwnd, 0);
    LRESULT lres;

    switch (code)
    {
    case DPX_DRAGHIT:
        if (lp)
        {
            POINT pt;
            int item;
            pt.x = ((POINTL *)lp)->x;
            pt.y = ((POINTL *)lp)->y;
            MapWindowPoints(NULL, ptb->ci.hwnd, &pt, 1);
            item = TBHitTest(ptb, pt.x, pt.y);

            if (0 <= item && item < ptb->iNumButtons)
                lres = (LRESULT)ptb->Buttons[item].idCommand;
            else
                lres = (LRESULT)-1;
        }
        else
            lres = -1;
        break;

    case DPX_GETOBJECT:
        lres = (LRESULT)GetItemObject(&ptb->ci, TBN_GETOBJECT, &IID_IDropTarget, (LPNMOBJECTNOTIFY)lp);
        break;

    case DPX_SELECT:
        if ((int)wp >= 0)
        {
            NMTBHOTITEM nmhi;
            nmhi.idNew = (int) wp;
            if (!CCSendNotify(&ptb->ci, TBN_DRAGOVER, &nmhi.hdr))
            {
                SendMessage(ptb->ci.hwnd, TB_MARKBUTTON, wp,
                    MAKELPARAM((lp != DROPEFFECT_NONE), 0));
            }
        }
        lres = 0;
        break;

    default:
        lres = -1;
        break;
    }

    return lres;
}

int TBMixedButtonHeight(PTBSTATE ptb, int iIndex)
{
    int iHeight;
    LPTBBUTTONDATA ptbb = &(ptb->Buttons[iIndex]);

    if (ptbb->fsStyle & BTNS_SHOWTEXT)                      // text and icon
        iHeight = max(ptb->iDyBitmap, ptb->dyIconFont);
    else                                                    // icon, no text
        iHeight = ptb->iDyBitmap;

    return iHeight;
}

int TBMixedButtonsHeight(PTBSTATE ptb)
{
    int i;
    int iHeightMax = 0;
    int iHeight;
    ASSERT(ptb->ci.style & TBSTYLE_LIST);
    ASSERT(USE_MIXED_BUTTONS(ptb));
    for (i = 0; i < ptb->iNumButtons; i++) {
        iHeight = TBMixedButtonHeight(ptb, i);
        iHeightMax = max(iHeightMax, iHeight);
    }
    return iHeightMax;
}

int HeightWithString(PTBSTATE ptb, int h)
{
    if (USE_MIXED_BUTTONS(ptb))
    {
        int hMixed = TBMixedButtonsHeight(ptb);
        return (max(h, hMixed));
    }
    else if (ptb->ci.style & TBSTYLE_LIST)
        return (max(h, ptb->dyIconFont));
    else if (ptb->dyIconFont)
        return (h + ptb->dyIconFont + 1);
    else
        return (h);
}

int TBGetSepHeight(PTBSTATE ptb, LPTBBUTTONDATA pbtn)
{
    ASSERT(pbtn->fsStyle & BTNS_SEP);

    // THEMESBUMMER: Can't change the size of a separator because apps expect a certain size
    // If we want people to use V6 we can't change that behaviour
    if (ptb->ci.style & (CCS_VERT | TBSTYLE_FLAT) )
        return pbtn->cxySep;
    else
        return pbtn->cxySep * 2 / 3;
}

UINT TBWidthOfString(PTBSTATE ptb, LPTBBUTTONDATA ptbb, HDC hdc)
{
    UINT uiWidth = 0;

    LPTSTR pstr = TB_StrForButton(ptb, ptbb);
    if (pstr)
    {
        HDC hdcCreated = NULL;
        HFONT hOldFont;
        UINT uiStyle;
        RECT rcText = {0,0,1000,10};

        if (!hdc)
        {
            hdcCreated = GetDC(ptb->ci.hwnd);
            hdc = hdcCreated;
        }
        hOldFont = (HFONT)SelectObject(hdc, ptb->hfontIcon);

        uiStyle = DT_CALCRECT | TBGetDrawTextFlags(ptb, 0, ptbb);
        HRESULT hr = E_FAIL;
        if (ptb->hTheme)
            hr = GetThemeTextExtent(ptb->hTheme, hdc, 0, 0, pstr, -1, uiStyle, &rcText, &rcText);

        if (FAILED(hr))
            DrawText(hdc, pstr, -1, &rcText, uiStyle);

        uiWidth += rcText.right;

        SelectObject(hdc, hOldFont);
        if (hdcCreated)
            ReleaseDC(ptb->ci.hwnd, hdcCreated);
    }

    return uiWidth;
}

// TBDDArrowAdjustment(ptb, ptbb): the amount by which we change the width of
// this button to accomodate the drop-down arrow.  not necessarily the same as
// ptb->dxDDArrowChar.
int TBDDArrowAdjustment(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    int iAdjust = 0;

    if (TB_HasDDArrow(ptb, ptbb))
    {
        // If a whole dd, non-autosize button, then we'll just use the standard
        // button width which ought to have room for this button (i.e., return 0).

        if (!TB_HasTopDDArrow(ptb, ptbb) || BTN_IS_AUTOSIZE(ptb, ptbb))
        {
            iAdjust += (WORD)ptb->dxDDArrowChar;

            if (TB_HasUnsplitDDArrow(ptb, ptbb))
            {
                // subtract off a bit since there won't be a border
                // around dd arrow part of this button
                iAdjust -= 2 * g_cxEdge;

                if (ptbb->iBitmap != I_IMAGENONE)
                {
                    // nudge over a bit more to overlap bitmap border padding
                    iAdjust -= g_cxEdge;
                }
            }

            if (TB_HasTopDDArrow(ptb, ptbb))
            {
                // If string width >= icon width + iAdjust, then no need
                // to add extra space for the arrow.

                if ((int)TBWidthOfString(ptb, ptbb, NULL) >= ptb->iDxBitmap + iAdjust)
                    iAdjust = 0;
            }
        }
    }

    return max(iAdjust, 0);
}

void TBGetPartAndState(PTBSTATE ptb, LPTBBUTTONDATA ptButton, int* piPart, int* piState)
{
    int state = ptButton->fsState;

    BOOL fHotTrack = TBIsHotTrack(ptb, ptButton, state);

    *piPart = TP_BUTTON;       // Whole dropdown
    if (TB_HasDDArrow(ptb, ptButton))
    {
        *piPart = TP_DROPDOWNBUTTON;
        if (!TB_HasUnsplitDDArrow(ptb, ptButton))   // unless it's split
        {
            *piPart = TP_SPLITBUTTON;
        }
    }

    *piState = TS_NORMAL;
    if (state & TBSTATE_PRESSED)
        *piState = TS_PRESSED;
    else if (DRAW_MONO_BTN(ptb, state))
        *piState = TS_DISABLED;
    else if (fHotTrack && (state & TBSTATE_CHECKED))
        *piState = TS_HOTCHECKED;
    else if (fHotTrack)
        *piState = TS_HOT;
    else if (state & TBSTATE_CHECKED)
        *piState = TS_CHECKED;
}

int TBWidthOfButton(PTBSTATE ptb, LPTBBUTTONDATA pButton, HDC hdc)
{
    RECT rc;
    UINT uiStringWidth;
    if (BTN_IS_AUTOSIZE(ptb, pButton)) 
    {
        // if they've set this button for autosize, calculate it and cache
        // it in cx
        if (BTN_NO_SHOW_TEXT(ptb, pButton)) 
        {
            pButton->cx = 0;
            goto CalcIconWidth;
        }

        if (pButton->cx == 0) 
        {
            uiStringWidth = TBWidthOfString(ptb, pButton, hdc);
            pButton->cx = (WORD) ptb->cxPad + uiStringWidth;

            if (uiStringWidth) 
            {
                // Since we have a string for this button, we need to add
                // some padding around it.
                if ((ptb->ci.style & TBSTYLE_LIST) && TB_HasSplitDDArrow(ptb, pButton))
                    pButton->cx += (WORD) ptb->iDropDownGap;
                else
                    pButton->cx += 2 * g_cxEdge;
            }

CalcIconWidth:
            if (pButton->iBitmap != I_IMAGENONE) 
            {

                if (ptb->ci.style & TBSTYLE_LIST) 
                {
                    pButton->cx += ptb->iDxBitmap + ptb->iListGap;
                    if (BTN_NO_SHOW_TEXT(ptb, pButton))
                        pButton->cx += g_cxEdge * 2;
                }
                else 
                {
                    // Use wider of string width (pButton->cx so far) and bitmap width.
                    pButton->cx = max(pButton->cx, ptb->iDxBitmap + ptb->cxPad);
                }
            }

            pButton->cx += (USHORT)TBDDArrowAdjustment(ptb, pButton);

            if (ptb->hTheme)
            {
                RECT rc = {0, 0, pButton->cx, ptb->iButHeight};
                int iPartId;
                int iStateId;
                TBGetPartAndState(ptb, pButton, &iPartId, &iStateId);
                GetThemeBackgroundExtent(ptb->hTheme, hdc, iPartId, iStateId, &rc, &rc);
                pButton->cx = (USHORT)RECTWIDTH(rc);
            }
        }
    }

    if (pButton->cx) 
    {
        return (int)pButton->cx;
    } 
    else if (pButton->fsStyle & BTNS_SEP) 
    {
        if (ptb->ci.style & CCS_VERT) 
        {
            GetWindowRect(ptb->ci.hwnd, &rc);
            return RECTWIDTH(rc);
        } 
        else 
        {
            // Compat: Corel (Font navigator) expects the separators to be
            // 8 pixels wide.  So do not return pButton->cxySep here, since
            // that can be calculated differently depending on the flat style.
            //
            // No.  owner draw items are added by specifying separator, and
            // the iBitmap width which is then copied down to cxySep.
            // the preserving of size for corel needs to be done at that point.
            return pButton->cxySep;
        }
    } 
    else if (!(TBSTYLE_EX_VERTICAL & ptb->dwStyleEx) && !(TBSTYLE_EX_FIXEDDROPDOWN & ptb->dwStyleEx)) 
    {
        return ptb->iButWidth + TBDDArrowAdjustment(ptb, pButton);
    } 
    else 
    {
        return ptb->iButWidth;
    }
}

UINT TBGetDrawTextFlags(PTBSTATE ptb, UINT uiStyle, TBBUTTONDATA* ptbb)
{
    if (ptb->nTextRows > 1)
        uiStyle |= DT_WORDBREAK | DT_EDITCONTROL;
    else
        uiStyle |= DT_SINGLELINE;


    if (ptb->ci.style & TBSTYLE_LIST)
    {
        uiStyle |= DT_LEFT | DT_VCENTER | DT_SINGLELINE;

        if (ptbb->iBitmap == I_IMAGENONE)
        {
            uiStyle |= DT_CENTER;
        }
    }
    else
    {
        uiStyle |= DT_CENTER;
    }

    uiStyle &= ~(ptb->uDrawTextMask);
    uiStyle |= ptb->uDrawText;
    if (ptbb->fsStyle & BTNS_NOPREFIX)
        uiStyle |= DT_NOPREFIX;

    if (CCGetUIState(&(ptb->ci)) & UISF_HIDEACCEL)
    {
        uiStyle |= DT_HIDEPREFIX;
    }
    return uiStyle;
}

BOOL TBRecalc(PTBSTATE ptb)
{
    TEXTMETRIC tm = {0};
    int i;
    HDC hdc;
    int cxMax = 0, cxMask, cy;
    HFONT hOldFont=NULL;

    if (ptb->fRedrawOff) {
        // redraw is off; defer recalc until redraw is turned back on
        ptb->fRecalc = TRUE;
        return TRUE;    // The recalc "succeeded" - actual work will happen later
    }

    ptb->dyIconFont = 0;
    if (!TBHasStrings(ptb) || !ptb->nTextRows ) {

        cxMax = ptb->iDxBitmap;
        cxMask = cxMax;

    } else {

        SIZE size = {0};
        LPCTSTR pstr;
        RECT rcText = {0,0,0,0};
        int cxExtra = ptb->cxPad;

        ptb->iButWidth = 0;

        hdc = GetDC(ptb->ci.hwnd);
        if (!hdc)
            return(FALSE);

        if (ptb->hfontIcon)
            hOldFont = (HFONT)SelectObject(hdc, ptb->hfontIcon);

        if (ptb->hTheme)
        {
            GetThemeTextMetrics(ptb->hTheme, hdc, 0, 0, &tm);
        }
        else
        {
            GetTextMetrics(hdc, &tm);
        }

        if (ptb->nTextRows)
        {
            ptb->dyIconFont = (tm.tmHeight * ptb->nTextRows) +
                              (tm.tmExternalLeading * (ptb->nTextRows - 1)); // add an edge ?
        }

        if (ptb->ci.style & TBSTYLE_LIST)
            cxExtra += ptb->iDxBitmap + ptb->iListGap;

        // default to the image size...
        cxMax = ptb->iDxBitmap;

        // walk strings to find max width
        for (i = 0; i < ptb->iNumButtons; i++)
        {
            if (ptb->Buttons[i].fsState & TBSTATE_HIDDEN)
                continue;

            if (BTN_IS_AUTOSIZE(ptb, &ptb->Buttons[i]))
                ptb->Buttons[i].cx = 0;

            pstr = TB_StrForButton(ptb, &ptb->Buttons[i]);
            if (pstr) 
            {
                // wordbreak is not allowed in the calcrect w/ singleline
                UINT uiStyle = DT_CALCRECT | DT_SINGLELINE | (TBGetDrawTextFlags(ptb, 0, &ptb->Buttons[i]) & ~DT_WORDBREAK);
                RECT rcTemp = {0,0,0,0};
                rcTemp.bottom = ptb->dyIconFont;

                HRESULT hr = E_FAIL;
                if (ptb->hTheme)
                    hr = GetThemeTextExtent(ptb->hTheme, hdc, 0, 0, pstr, -1, uiStyle, &rcTemp, &rcTemp);
                if (FAILED(hr))
                    DrawText(hdc, pstr, -1, &rcTemp, uiStyle);
                size.cx = RECTWIDTH(rcTemp);
                size.cy = RECTHEIGHT(rcTemp);
            }
            else
            {
                size.cx = 0;
            }

            if (TB_HasTopDDArrow(ptb, &ptb->Buttons[i])) {
                int iBmpWithArrow = CX_TOP_FUDGE + ptb->iDxBitmap + ptb->dxDDArrowChar;
                size.cx = max(size.cx, iBmpWithArrow);
            }
            else if ((ptb->dwStyleEx & TBSTYLE_EX_VERTICAL) && 
                TB_HasDDArrow(ptb, &ptb->Buttons[i])) {

                // for vertical toolbars, buttons with drop-down arrows
                // are drawn with the same width as normal buttons, so
                // we need to figure them into our max width calculation.

                size.cx += ptb->dxDDArrowChar;
            }

            if (cxMax < size.cx)
                cxMax = size.cx;
        }

        // if cxMax is less than the iButMinWidth - dxBitmap (if LIST) then
        // cxMax = iButMinWidth
        if (ptb->iButMinWidth && (ptb->iButMinWidth > (cxMax + cxExtra)))
            cxMax = ptb->iButMinWidth - cxExtra;

        cxMask = cxMax;

        // Is the cxMax +  dxBitmap (if LIST) more than the max width ?
        if (ptb->iButMaxWidth && (ptb->iButMaxWidth < (cxMax + cxExtra)))
        {
            int cyMax = 0;
            int cxTemp = 0;

            cxMax = ptb->iButMaxWidth - cxExtra;

            // But leave cxMask at its old value since AUTOSIZE buttons
            // are exempt from button truncation.  This exemption is a bug,
            // but IE4 shipped that way so we're stuck with it.  (You can
            // tell it's a bug because we go ahead and flip TBSTATE_ELLIPSIS
            // even on AUTOSIZE buttons, only to "forget" about the ellipsis
            // in TBWidthOfString().)

            // walk strings to set the TBSTATE_ELLIPSES
            for (i = 0; i < ptb->iNumButtons; i++)
            {
                BOOL fEllipsed = FALSE;
                UINT uiStyle;

                if (ptb->Buttons[i].fsState & TBSTATE_HIDDEN)
                    continue;

                if (BTN_NO_SHOW_TEXT(ptb, &ptb->Buttons[i]))
                    pstr = NULL;
                else
                {
                    pstr = TB_StrForButton(ptb, &ptb->Buttons[i]);
                    uiStyle = DT_CALCRECT | TBGetDrawTextFlags(ptb, 0, &ptb->Buttons[i]);
                }

                if (pstr) 
                {
                    int cxMaxText;
                    if ((ptb->dwStyleEx & TBSTYLE_EX_VERTICAL) && 
                        TB_HasDDArrow(ptb, &ptb->Buttons[i]))
                    {
                        // if a drop-down button on a vertical toolbar,
                        // need to make space for drop-down arrow
                        cxMaxText = cxMax - ptb->dxDDArrowChar;
                    } 
                    else 
                    {
                        cxMaxText = cxMax;
                    }
                    // DrawText doesn't like it when cxMaxText <= 0
                    cxMaxText = max(cxMaxText, 1);

                    rcText.bottom = ptb->dyIconFont;
                    rcText.right = cxMaxText;

                    HRESULT hr = E_FAIL;
                    if (ptb->hTheme)
                        hr = GetThemeTextExtent(ptb->hTheme, hdc, 0, 0, pstr, -1, uiStyle, &rcText, &rcText);

                    if (FAILED(hr))
                        DrawText(hdc, pstr, -1, &rcText, uiStyle);
                    if (ptb->nTextRows > 1)
                    {
                        // width is width of text plus width we might
                        // have lopped off for drop-down arrow
                        int cx = rcText.right + (cxMax - cxMaxText);
                        if (cx > cxTemp)
                        {
                            // this is our new multiline text hack max
                            cxTemp = cx;
                        }
                        fEllipsed = (BOOL)(rcText.bottom > ptb->dyIconFont);
                    }
                    else
                        fEllipsed = (BOOL)(rcText.right > cxMaxText);

                    if (cyMax < rcText.bottom)
                        cyMax = rcText.bottom;
                }

                if (fEllipsed)
                    ptb->Buttons[i].fsState |= TBSTATE_ELLIPSES;
                else
                    ptb->Buttons[i].fsState &= ~TBSTATE_ELLIPSES;
            }

            if (cxTemp && (ptb->nTextRows > 1 ))
                cxMax = cxTemp;

            // Set the text height to the tallest text, with the top end being the number
            // of rows specified by MAXTEXTROWS
            if (ptb->dyIconFont > cyMax)
                ptb->dyIconFont = cyMax;
        }
        else
        {
            for (i = 0; i < ptb->iNumButtons; i++)
                ptb->Buttons[i].fsState &= ~TBSTATE_ELLIPSES;

            if ((ptb->nTextRows) && ptb->iNumButtons && (ptb->dyIconFont > size.cy))
                ptb->dyIconFont = size.cy;
        }

        if (ptb->iButMinWidth && (ptb->iButMinWidth > (cxMax + cxExtra)))
            cxMax = ptb->iButMinWidth - cxExtra;

        if (hOldFont)
            SelectObject(hdc, hOldFont);
        ReleaseDC(ptb->ci.hwnd, hdc);
    }

    //
    //  Need to call GrowToolbar twice, once to grow the mask, and again
    //  to grow the buttons.  (Yes, this is sick.)
    //
    cy = HeightWithString(ptb, ptb->iDyBitmap);

    if (!GrowToolbar(ptb, max(cxMax, cxMask), cy, GT_INSIDE | GT_MASKONLY))
        return(FALSE);

    return(GrowToolbar(ptb, cxMax, cy, GT_INSIDE));
}

BOOL TBChangeFont(PTBSTATE ptb, WPARAM wParam, HFONT hFont)
{
    LOGFONT lf;
    BOOL fWasFontCreated = ptb->fFontCreated;

    if ((wParam != 0) && (wParam != SPI_SETICONTITLELOGFONT) && (wParam != SPI_SETNONCLIENTMETRICS))
        return(FALSE);

    if (!SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0))
        return(FALSE);

    if (!hFont) {
        if (!(hFont = CreateFontIndirect(&lf)))
            return(FALSE);
        ptb->fFontCreated = TRUE;
    } else {
        ptb->fFontCreated = FALSE;
    }

    if (ptb->hfontIcon && fWasFontCreated)
        DeleteObject(ptb->hfontIcon);

    ptb->hfontIcon = hFont;

    return(TBRecalc(ptb));
}

void TBSetFont(PTBSTATE ptb, HFONT hFont, BOOL fInval)
{
    TBChangeFont(ptb, 0, hFont);
    if (fInval)
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

}

EXTERN_C HWND WINAPI CreateToolbarEx(HWND hwnd, DWORD ws, UINT wID, int nBitmaps,
            HINSTANCE hBMInst, UINT_PTR wBMID, LPCTBBUTTON lpButtons,
            int iNumButtons, int dxButton, int dyButton,
            int dxBitmap, int dyBitmap, UINT uStructSize)
{

    HWND hwndToolbar = CreateWindow(c_szToolbarClass, NULL, WS_CHILD | ws,
          0, 0, 100, 30, hwnd, IntToPtr_(HMENU, wID), HINST_THISDLL, NULL);
    if (hwndToolbar)
    {
        PTBSTATE ptb = (PTBSTATE)GetWindowInt(hwndToolbar, 0);
        TBOnButtonStructSize(ptb, uStructSize);

        if ((dxBitmap && dyBitmap && !SetBitmapSize(ptb, dxBitmap, dyBitmap)) ||
            (dxButton && dyButton && !SetBitmapSize(ptb,dxButton, dyButton)))
        {
            //!!!! do we actually need to deal with this?
            DestroyWindow(hwndToolbar);
            hwndToolbar = NULL;
            goto Error;
        }

        AddBitmap(ptb, nBitmaps, hBMInst, wBMID);
        TBInsertButtons(ptb, (UINT)-1, iNumButtons, (LPTBBUTTON)lpButtons, TRUE);

        // ptb may be bogus now after above button insert
    }
Error:
    return hwndToolbar;
}

/* This is no longer declared in COMMCTRL.H.  It only exists for compatibility
** with existing apps; new apps must use CreateToolbarEx.
*/
HWND WINAPI CreateToolbar(HWND hwnd, DWORD ws, UINT wID, int nBitmaps, HINSTANCE hBMInst, UINT_PTR wBMID, LPCTBBUTTON lpButtons, int iNumButtons)
{
    // old-style toolbar, so no divider.
    return CreateToolbarEx(hwnd, ws | CCS_NODIVIDER, wID, nBitmaps, hBMInst, wBMID,
                lpButtons, iNumButtons, 0, 0, 0, 0, sizeof(OLDTBBUTTON));
}

#pragma code_seg(CODESEG_INIT)

BOOL InitToolbarClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = ToolbarWndProc;

    wc.lpszClassName = c_szToolbarClass;
    wc.style     = CS_DBLCLKS | CS_GLOBALCLASS;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PTBSTATE);
    wc.hInstance     = hInstance;   // use DLL instance if in DLL
    wc.hIcon     = NULL;
    wc.hCursor   = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
    wc.lpszMenuName  = NULL;

    if (!RegisterClass(&wc) && !GetClassInfo(hInstance, c_szToolbarClass, &wc))
        return FALSE;

    return TRUE;
}
#pragma code_seg()

void PatB(HDC hdc,int x,int y,int dx,int dy, DWORD rgb)
{
    RECT    rc;

    SetBkColor(hdc,rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

// Parameter fHighlight determines whether to draw text highlighted, for
// new TBSTATE_MARKED
//
void DrawString(HDC hdc, int x, int y, int dx, int dy, PTSTR pszString,
                            BOOL fHighlight, TBDRAWITEM * ptbdraw)
{
    int oldMode;
    COLORREF oldBkColor;
    COLORREF oldTextColor;
    RECT rcText;
    UINT uiStyle = 0;
    PTBSTATE ptb;
    LPTBBUTTONDATA ptbb;

    ASSERT(ptbdraw);

    ptb = ptbdraw->ptb;
    ptbb = ptbdraw->pbutton;

    if (!(ptb->ci.style & TBSTYLE_LIST) && ((ptb->iDyBitmap + ptb->cyPad + g_cyEdge) >= ptb->iButHeight))
        // there's no room to show the text -- bail out
        return;

    if (BTN_NO_SHOW_TEXT(ptb, ptbb))
        // don't show text for this button -- bail out
        return;

    if (fHighlight)
    {
        oldMode = SetBkMode (hdc, ptbdraw->tbcd.nHLStringBkMode);
        oldBkColor = SetBkColor (hdc, ptbdraw->tbcd.clrMark);
        oldTextColor = SetTextColor (hdc, ptbdraw->tbcd.clrTextHighlight);
    }
    else
        oldMode = SetBkMode(hdc, ptbdraw->tbcd.nStringBkMode);

    uiStyle = TBGetDrawTextFlags(ptb, DT_END_ELLIPSIS, ptbb);

    SetRect( &rcText, x, y, x + dx, y + dy);

    // The text rect (x,y,dx,dy) that was passed in covers a larger area than the text.  dy is the height of the
    // entire button.  If we're using the DT_SINGLELINE flag, that's fine, the text will be centered in that
    // height if necessary (e.g. if DT_VCENTER is set).  Otherwise, the text could run over the max number of lines
    // (nTextRows), and off the button.  So, if DT_SINGLELINE isn't set, we adjust the height of the text rect to
    // be exactly the height of the text.
    if ((uiStyle & DT_SINGLELINE) == 0)
    {
        rcText.bottom = y + ptb->dyIconFont;
    }

    HRESULT hr = E_FAIL;

    if (ptb->hTheme)
    {
        int iPartId;
        int iStateId;
        // Get the state back from what custom draw may have set
        TBGetPartAndState(ptb, ptbb, &iPartId, &iStateId);

        hr = DrawThemeText(ptb->hTheme, hdc, 0, iStateId, pszString, -1, uiStyle, 0, &rcText);
    }

    if (FAILED(hr))
        DrawText(hdc, (LPTSTR)pszString, -1, &rcText, uiStyle);

    SetBkMode(hdc, oldMode);
    if (fHighlight)
    {
        SetBkColor (hdc, oldBkColor);
        SetTextColor (hdc, oldTextColor);
    }
}

LPTSTR TB_StrForButton(PTBSTATE ptb, LPTBBUTTONDATA pTBButton)
{
    if (TBISSTRINGPTR(pTBButton->iString))
        return (LPTSTR)pTBButton->iString;
    else {
        if (pTBButton->iString != -1 &&
            pTBButton->iString < ptb->nStrings)
            return ptb->pStrings[pTBButton->iString];
        return NULL;
    }
}

HIMAGELIST TBGetImageList(PTBSTATE ptb, int iMode, int iIndex)
{
    HIMAGELIST himl = NULL;

    ASSERT(iMode <= HIML_MAX);
    if (iIndex >= 0 && iIndex < ptb->cPimgs) {
        himl = ptb->pimgs[iIndex].himl[iMode];
    }

    return himl;
}

//
//  v5 toolbars support multiple imagelists.  To use images from an alternate
//  imagelist, set the imagelist handle via TB_SETIMAGELIST(iIndex, himlAlt)
//  and set your button's iImage to MAKELONG(iImage, iIndex).
//
//  APP COMPAT:  GroupWise 5.5 passes garbage as the iIndex (even though it
//  was documented as "must be zero"), so we enable this functionality
//  only for v5 toolbars.  IE4 ignored the iIndex, which is why they got
//  away with it up until now.
//
#define MAX_TBIMAGELISTS 20             // arbitrary limit

HIMAGELIST TBSetImageList(PTBSTATE ptb, int iMode, int iIndex, HIMAGELIST himl)
{
    HIMAGELIST himlOld = NULL;

    // Watch out for app compat or for totally bogus parameters
    if (iIndex < 0 || iIndex >= MAX_TBIMAGELISTS)
        iIndex = 0;

    ASSERT(iMode <= HIML_MAX);
    if (iIndex >= ptb->cPimgs) {
        // asking for more than we have, realloc.

        void *p = CCLocalReAlloc(ptb->pimgs, (iIndex+1) * SIZEOF(TBIMAGELISTS));
        if (p) {
            ptb->pimgs = (TBIMAGELISTS*)p;
            ZeroMemory(&ptb->pimgs[ptb->cPimgs], (iIndex + 1 - ptb->cPimgs) * sizeof(TBIMAGELISTS));
            ptb->cPimgs = iIndex + 1;  // iIndex is 0 based, but cPimgs is 1 based (it's a count, not an index)
        }
    }

    if (iIndex < ptb->cPimgs) {
        himlOld = ptb->pimgs[iIndex].himl[iMode];
        ptb->pimgs[iIndex].himl[iMode] = himl;
    }

    return himlOld;
}

// create a mono bitmap mask:
//   1's where color == COLOR_BTNFACE || COLOR_3DHILIGHT
//   0's everywhere else

void CreateMask(PRECT prc, int xoffset, int yoffset, int dx, int dy, BOOL fDrawGlyph, TBDRAWITEM * ptbdraw)
{
    LPTSTR psz;
    IMAGELISTDRAWPARAMS imldp;
    HIMAGELIST himl;
    PTBSTATE ptb = ptbdraw->ptb;
    LPTBBUTTONDATA pTBButton = ptbdraw->pbutton;

    // create mask based on color bitmap
    // convert this to 1's

    int xIcon, yIcon, xText, yText;
    if (ptb->ci.style & TBSTYLE_LIST)
    {
        if (BTN_NO_SHOW_TEXT(ptb, pTBButton))
        {
            xIcon = (RECTWIDTH(*prc) - ptb->iDxBitmap) / 2;
        }
        else
        {
            xIcon = ptb->cxPad / 2;
        }

        yIcon = (RECTHEIGHT(*prc) - ptb->iDyBitmap)/2;

        if (!(pTBButton->iBitmap == I_IMAGENONE &&
             (pTBButton->fsStyle & BTNS_AUTOSIZE)))
        {
            xText = xIcon + ptb->iDxBitmap + ptb->iListGap;
            dx -= xIcon + ptb->iDxBitmap + ptb->iListGap;
        }
        else
        {
            xText = 0;
        }

        yText = 0;
        dy = RECTHEIGHT(*prc);
    }
    else
    {
        if (TB_HasTopDDArrow(ptb, pTBButton))
        {
            xIcon = (RECTWIDTH(*prc) + CX_TOP_FUDGE - (ptb->iDxBitmap + ptb->dxDDArrowChar)) / 2;
        }
        else
        {
            xIcon = (RECTWIDTH(*prc) - ptb->iDxBitmap) / 2;
        }

        // No text to display?
        if (dx == 0)
        {
            yIcon = (RECTHEIGHT(*prc) - ptb->iDyBitmap) / 2;
        }
        else
        {
            yIcon = (RECTHEIGHT(*prc) - ptb->iDyBitmap - ptb->dyIconFont) / 2;
        }

        yText = yIcon + ptb->iDyBitmap + 1;
        xText = (RECTWIDTH(*prc) - dx) / 2;
    }

    TEXTMETRIC tm;
    GetTextMetrics(ptb->hdcMono, &tm);
    // initalize whole area with 1's
    // we adjust by tmMaxCharWidth because DrawText can draw outside the rectangle
    // by up to one character.
    PatBlt(ptb->hdcMono, 0, 0, xText+dx+tm.tmMaxCharWidth, yText+dy, WHITENESS);

    himl = TBGetImageList(ptb, HIML_NORMAL, ptbdraw->iIndex);
    if (fDrawGlyph && himl)
    {
        imldp.cbSize = sizeof(imldp);
        imldp.himl   = himl;
        imldp.i      = ptbdraw->iImage;
        imldp.hdcDst = ptb->hdcMono;
        imldp.x      = xIcon;
        imldp.y      = yIcon;
        imldp.cx     = 0;
        imldp.cy     = 0;
        imldp.xBitmap= 0;
        imldp.yBitmap= 0;
        imldp.rgbBk  = g_clrBtnFace;
        imldp.rgbFg  = CLR_DEFAULT;
        imldp.fStyle = ILD_ROP | ILD_MASK;
        imldp.dwRop  = SRCCOPY;
        imldp.fState = 0;

        if (ToolBar_IsDPIScaled(ptb))
        {
            imldp.fStyle |= ILD_DPISCALE;
        }


        ImageList_DrawIndirect(&imldp);

        imldp.fStyle = ILD_ROP | ILD_IMAGE;
        imldp.rgbBk  = g_clrBtnHighlight;
        imldp.dwRop  = SRCPAINT;
        ImageList_DrawIndirect(&imldp);
    }

    psz = TB_StrForButton(ptb, pTBButton);
    if (psz)
    {
        // The FALSE in 4th param is so we don't get a box in the mask.
        DrawString(ptb->hdcMono, xText, yText, dx, dy, psz,
                   FALSE, ptbdraw);
    }
}

void DrawBlankButton(HDC hdc, int x, int y, int dx, int dy, TBDRAWITEM * ptbdraw)
{
    RECT r1;
    UINT state;

    // face color
    // The Office toolbar sends us bitmaps that are smaller than they claim they are
    // So we need to do the PatB or the window background shows through around the
    // edges of the button bitmap  -jjk
    ASSERT(ptbdraw);

    state = ptbdraw->state;

    if (!(state & TBSTATE_CHECKED))
        PatB(hdc, x, y, dx, dy, ptbdraw->tbcd.clrBtnFace);

    if  ( !(ptbdraw->dwCustom & TBCDRF_NOEDGES))
    {
        r1.left = x;
        r1.top = y;
        r1.right = x + dx;
        r1.bottom = y + dy;

        if (ptbdraw->fHotTrack)
            DrawEdge(hdc, &r1, EDGE_SUNKEN, BF_RECT | BF_SOFT);
        else
            DrawEdge(hdc, &r1, (state & (TBSTATE_CHECKED | TBSTATE_PRESSED)) ? EDGE_SUNKEN : EDGE_RAISED, BF_RECT | BF_SOFT);
    }
}

// these are raster ops
#define PSDPxax     0x00B8074A

HWND g_hwndDebug = NULL;

void DrawFace(HDC hdc, PRECT prc, int x, int y, int offx, int offy, int dxText,
              int dyText, TBDRAWITEM * ptbdraw, int iListGap, PRECT prcText)
{
    IMAGELISTDRAWPARAMS imldp;
    BOOL fHotTrack = FALSE;
    UINT state;
    PTBSTATE ptb = ptbdraw->ptb;
    LPTBBUTTONDATA ptButton = ptbdraw->pbutton;
    BOOL fImage = TRUE;        // !fImage means no image (as opposed to a blank image)
    LPTSTR psz = TB_StrForButton(ptb, ptButton);
    int xPressedOffset = 0;
    int yPressedOffset = 0;
    DWORD frame = 0;
    DWORD fState = 0;
    BOOL bCheckForDisabledDesat = FALSE;

    // AutosizeTextNoImage
    if ((ptbdraw->iImage == I_IMAGENONE) || 
        ((ptbdraw->iImage == I_IMAGENONE) && 
         (ptb->ci.style & TBSTYLE_LIST) && 
         (ptButton->fsStyle & BTNS_AUTOSIZE)))
    {
        fImage = FALSE;
    } 

    state = ptbdraw->state;

    if (state & TBSTATE_ENABLED)
    {
        fHotTrack = ptbdraw->fHotTrack;

        if (ptb->ci.style & TBSTYLE_FLAT && !ptb->hTheme)
        {
            UINT bdr = 0;

            if (state & (TBSTATE_PRESSED | TBSTATE_CHECKED))
                bdr = BDR_SUNKENOUTER;
            else if (fHotTrack)
                bdr = BDR_RAISEDINNER;

            if (bdr)
            {
                RECT rc;
                TB_GetItemRect(ptb, (UINT)(ptButton - ptb->Buttons), &rc);

                if (TB_HasSplitDDArrow(ptb, ptButton))
                    rc.right -= ptb->dxDDArrowChar;

                if (!(ptbdraw->dwCustom & TBCDRF_NOEDGES) && ptb)
                    CCDrawEdge(hdc, &rc, bdr, BF_RECT, &(ptb->clrsc));
            }
        }
    }

    imldp.himl = NULL;

    if (fHotTrack || (state & TBSTATE_CHECKED)) 
    {
        imldp.himl   = TBGetImageList(ptb, HIML_HOT, ptbdraw->iIndex);
        if (imldp.himl == NULL)
            imldp.himl = TBGetImageList(ptb, HIML_NORMAL, ptbdraw->iIndex);
    } 
    else if (DRAW_MONO_BTN(ptb, state))
    {
        imldp.himl = TBGetImageList(ptb, HIML_DISABLED, ptbdraw->iIndex);

        if (imldp.himl == NULL)
        {
            // If there isn't a specific 'disabled' imagelist, we'll use the
            // regular one, in which case we want to desat any 32bit alpha image.
            bCheckForDisabledDesat = TRUE;
        }
    } 

    if (imldp.himl == NULL)
    {
        imldp.himl = TBGetImageList(ptb, HIML_NORMAL, ptbdraw->iIndex);

        if (bCheckForDisabledDesat)
        {
            // If we have an alpha channel, then we'll desaturate.
            if (ImageList_GetItemFlags(imldp.himl, GET_IMAGE_INDEX(ptbdraw->iIndex)) == ILIF_ALPHA)
            {
                fState = ILS_SATURATE;
                frame = -100;
            }
        }
    }

    int xIcon = 0, yIcon = 0, xText, yText;
    if (ptb->ci.style & TBSTYLE_LIST)
    {
        if (BTN_NO_SHOW_TEXT(ptb, ptButton))
        {
            xIcon = (RECTWIDTH(*prc) - ptb->iDxBitmap) / 2;
        }
        else if (fImage)
        {
            xIcon = ptb->cxPad / 2;
        }

        yIcon = (RECTHEIGHT(*prc) - ptb->iDyBitmap)/2;

        xText = prc->left;
        yText = prc->top;

        if (fImage)
        {
            xText += ptb->iDxBitmap + iListGap + xIcon;
            dxText -= (ptb->iDxBitmap + iListGap);
        }
        dyText = RECTHEIGHT(*prc);
    }
    else
    {
        if (TB_HasTopDDArrow(ptb, ptButton))
        {
            xIcon = (RECTWIDTH(*prc) + CX_TOP_FUDGE - (ptb->iDxBitmap + ptb->dxDDArrowChar)) / 2;
        }
        else
        {
            xIcon = (RECTWIDTH(*prc) - ptb->iDxBitmap) / 2;
        }

        // No text to display?
        if (psz && ((ptb->iDyBitmap + ptb->cyPad + g_cyEdge) < ptb->iButHeight))
        {
            yIcon = (RECTHEIGHT(*prc) - ptb->iDyBitmap - ptb->dyIconFont) / 2;
        }
        else
        {
            yIcon = (RECTHEIGHT(*prc) - ptb->iDyBitmap) / 2;
        }

        yText = prc->top + yIcon + ptb->iDyBitmap + 1;
        xText = prc->left + (RECTWIDTH(*prc) - dxText) / 2;
    }

    if ((state & (TBSTATE_PRESSED | TBSTATE_CHECKED)) &&
        !(ptbdraw->dwCustom & TBCDRF_NOOFFSET))
    {
        xPressedOffset++;
        if (ptb->ci.style & TBSTYLE_LIST)
            yPressedOffset++;
    }


    if (imldp.himl && (ptbdraw->iImage != -1) && fImage)
    {
        COLORREF rgbBk = ptbdraw->tbcd.clrBtnFace;
        if (ptb->ci.style & TBSTYLE_TRANSPARENT) 
            rgbBk = CLR_NONE;
        
        if (ptb->dwStyleEx & TBSTYLE_EX_INVERTIBLEIMAGELIST)
            rgbBk = CLR_DEFAULT;

        imldp.cbSize = sizeof(imldp);
        imldp.i      = ptbdraw->iImage;
        imldp.hdcDst = hdc;
        imldp.x      = prc->left + xIcon + xPressedOffset;
        imldp.y      = prc->top + yIcon + yPressedOffset;
        imldp.cx     = 0;
        imldp.cy     = 0;
        imldp.xBitmap= 0;
        imldp.yBitmap= 0;
        imldp.rgbBk  = rgbBk;
        imldp.rgbFg  = CLR_DEFAULT;
        imldp.fStyle = ILD_NORMAL;
        imldp.fState = fState;
        imldp.Frame  = frame;

        if (state & (TBSTATE_CHECKED | TBSTATE_INDETERMINATE) || ptb->hTheme)
            imldp.fStyle = ILD_TRANSPARENT;

        if (ptbdraw->dwCustom & TBCDRF_BLENDICON)
            imldp.fStyle = ILD_TRANSPARENT | ILD_BLEND50;

        if (ToolBar_IsDPIScaled(ptb))
        {
            imldp.fStyle |= ILD_DPISCALE;
        }

        ImageList_DrawIndirect(&imldp);
    }

    if (psz && !DRAW_MONO_BTN(ptb, state))
    {
        BOOL bHighlight = (state & TBSTATE_MARKED) && (ptb->ci.style & TBSTYLE_LIST) &&
                          !(ptbdraw->dwCustom & TBCDRF_NOMARK);

        xText += xPressedOffset;
        yText += yPressedOffset;

        prcText->left = xText;
        prcText->top  = yText;
        prcText->right = xText + dxText;
        prcText->bottom = yText + dyText;
        DrawString(hdc, xText, yText, dxText, dyText, psz, bHighlight, ptbdraw);
    }
}

void InitTBDrawItem(TBDRAWITEM * ptbdraw, PTBSTATE ptb, LPTBBUTTONDATA pbutton,
                    UINT state, BOOL fHotTrack, int dxText, int dyText)
{
    NMTBCUSTOMDRAW * ptbcd;
    NMCUSTOMDRAW * pnmcd;

    ASSERT(ptbdraw);

    ptbdraw->ptb = ptb;
    ptbdraw->pbutton = pbutton;
    ptbdraw->fHotTrack = fHotTrack;
    ptbdraw->iIndex = GET_HIML_INDEX(pbutton->iBitmap);
    ptbdraw->iImage = GET_IMAGE_INDEX(pbutton->iBitmap);
    ptbdraw->state = state;

    ptbcd = &ptbdraw->tbcd;

    ptbcd->hbrMonoDither = g_hbrMonoDither;
    ptbcd->hbrLines = (HBRUSH)GetStockObject(BLACK_BRUSH);
    ptbcd->hpenLines = (HPEN)GetStockObject(BLACK_PEN);
    ptbcd->clrMark = g_clrHighlight;
    ptbcd->clrBtnHighlight = g_clrBtnHighlight;
    ptbcd->clrTextHighlight = g_clrHighlightText;
    ptbcd->clrBtnFace = g_clrBtnFace;
    ptbcd->nStringBkMode = TRANSPARENT;
    ptbcd->nHLStringBkMode = OPAQUE;
    ptbcd->clrText = g_clrBtnText;
    SetRect(&ptbcd->rcText, 0, 0, dxText, dyText);
    ptbcd->iListGap = ptb->iListGap;

    pnmcd = &ptbcd->nmcd;

    pnmcd->uItemState = CDISFromState(state);

    if (fHotTrack)
        pnmcd->uItemState |= CDIS_HOT;
}

void DrawButton(HDC hdc, int x, int y, PTBSTATE ptb, LPTBBUTTONDATA ptButton, BOOL fActive)
{
    int yOffset;
    HBRUSH hbrOld;
    UINT state;
    int dxFace, dyFace;
    int dxText, dyText;
    int xCenterOffset;
    int dx = TBWidthOfButton(ptb, ptButton, hdc);
    HFONT oldhFont;
    int dy = ptb->iButHeight;
    TBDRAWITEM tbdraw = { 0 };
    NMTBCUSTOMDRAW * ptbcd = &tbdraw.tbcd;
    NMCUSTOMDRAW * pnmcd = &ptbcd->nmcd;
    COLORREF clrSave;
    BOOL fHotTrack;
    HFONT hFontNoAntiAlias = NULL;

    state = (UINT)ptButton->fsState;
    // make local copy of state and do proper overriding
    if (state & TBSTATE_INDETERMINATE) 
    {
        if (state & TBSTATE_PRESSED)
            state &= ~TBSTATE_INDETERMINATE;
        else if (state & TBSTATE_ENABLED)
            state = TBSTATE_INDETERMINATE;
        else
            state &= ~TBSTATE_INDETERMINATE;
    }

    if (!fActive) 
    {
        state &= ~TBSTATE_ENABLED;
    }

    fHotTrack = TBIsHotTrack(ptb, ptButton, state);

    pnmcd->hdc = hdc;
    pnmcd->dwItemSpec = ptButton->idCommand;
    pnmcd->uItemState = 0;
    pnmcd->lItemlParam = (LPARAM)ptButton->dwData;
    SetRect(&pnmcd->rc, x, y, x + dx, y + dy);

    dxText = dx - ptb->cxPad;

    if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
    {
        dyText = dy;
    }
    else
    {
        dyText = dy - (2 * g_cyEdge);
    }

    InitTBDrawItem(&tbdraw, ptb, ptButton, state, fHotTrack, dxText, dyText);

    tbdraw.dwCustom = CICustomDrawNotify(&ptb->ci, CDDS_ITEMPREPAINT, &ptbcd->nmcd);

    // We gotta update our concept of hotness
    tbdraw.fHotTrack = fHotTrack = pnmcd->uItemState & CDIS_HOT;

    if (!(tbdraw.dwCustom & CDRF_SKIPDEFAULT ))
    {
        int iPartId;
        int iStateId;
        // Get the state back from what custom draw may have set
        state = tbdraw.state = StateFromCDIS(pnmcd->uItemState);
        TBGetPartAndState(ptb, ptButton, &iPartId, &iStateId);

        RECT rcContent = pnmcd->rc;
        if (ptb->hTheme)
        {
            GetThemeBackgroundContentRect(ptb->hTheme, hdc, iPartId, iStateId, &pnmcd->rc, &rcContent);
            dxFace = RECTWIDTH(rcContent);
            dyFace = RECTHEIGHT(rcContent);
            dxText = ptbcd->rcText.right - ptbcd->rcText.left;
            dyText = ptbcd->rcText.bottom - ptbcd->rcText.top;
            dxText -= RECTWIDTH(pnmcd->rc) - dxFace;   // Text width has been calculated. Need to adjust based on content rect
        }
        else
        {
            dxFace = dx - (2 * g_cxEdge);
            dyFace = dy - (2 * g_cyEdge);
            dxText = ptbcd->rcText.right - ptbcd->rcText.left;
            dyText = ptbcd->rcText.bottom - ptbcd->rcText.top;
        }

        if (TB_HasDDArrow(ptb, ptButton) && !TB_HasTopDDArrow(ptb, ptButton)) 
        {
            int iAdjust = TBDDArrowAdjustment(ptb, ptButton);
            if (!(ptb->dwStyleEx & TBSTYLE_EX_FIXEDDROPDOWN))
            {
                dxFace -= iAdjust;
            }
            dxText -= iAdjust;

            rcContent.right -= iAdjust;
        }

        // Should we display the font using the GDI AntiAliasing?
        if (!ptb->fAntiAlias && !(tbdraw.dwCustom & CDRF_NEWFONT))
        {
            // No. Must be doing drag and drop. We don't want to AntiAlias because the
            // Purple color key will show through and it looks ugly.
            LOGFONT lfFont;

            if (GetObject(ptb->hfontIcon, sizeof(lfFont), &lfFont))
            {
                lfFont.lfQuality = NONANTIALIASED_QUALITY;
                hFontNoAntiAlias = CreateFontIndirect(&lfFont);
            }
        }

        if (!(tbdraw.dwCustom & CDRF_NEWFONT))
        {
            if (hFontNoAntiAlias)
                oldhFont = (HFONT)SelectObject(hdc, hFontNoAntiAlias);
            else
                oldhFont = (HFONT)SelectObject(hdc, ptb->hfontIcon);
        }

        clrSave = SetTextColor(hdc, ptbcd->clrText);

        if (ptb->hTheme)
        {
            if (!(tbdraw.dwCustom & TBCDRF_NOBACKGROUND))
            {
                if (TB_HasDDArrow(ptb, ptButton))
                {
                    RECT rcNoArrow = pnmcd->rc;
                    if (!TB_HasUnsplitDDArrow(ptb, ptButton))   // unless it's split
                    {
                        rcNoArrow.right -= ptb->dxDDArrowChar;
                    }

                    DrawThemeBackground(ptb->hTheme, hdc, iPartId, iStateId, &rcNoArrow, 0);
                }
                else
                {

                    DrawThemeBackground(ptb->hTheme, hdc, iPartId, iStateId, &pnmcd->rc, 0);
                }
            }

            x = rcContent.left;
            y = rcContent.top;
        }
        else
        {
            if (!(tbdraw.dwCustom & TBCDRF_NOBACKGROUND))
            {
                if (!(ptb->ci.style & TBSTYLE_FLAT))
                    DrawBlankButton(hdc, x, y, dx, dy, &tbdraw);
            }

            // move coordinates inside border and away from upper left highlight.
            // the extents change accordingly.
            x += g_cxEdge;
            y += g_cyEdge;

        }

        yOffset = (RECTHEIGHT(pnmcd->rc) - RECTHEIGHT(rcContent)) / 2;

        if (yOffset < 0)
            yOffset = 0;

        if ((ptb->ci.style & TBSTYLE_LIST) && !BTN_NO_SHOW_TEXT(ptb, ptButton)) 
        {
            xCenterOffset = ptb->cxPad / 2;
        } 
        else if (TB_HasTopDDArrow(ptb, ptButton)) 
        {
            //
            // Layout of "top dropdown" buttons looks like this:
            //
            //       icon            
            // fudge   |  dropdown arrow
            //    |    |    |
            //    v    v    v
            // +-+-+-------+--+-+
            // | | |       |  | |
            // | | |       |  | |
            // +-+-+-------+--+-+
            // |     <text>     |
            // +----------------+
            //
            // |<--- dxFace --->|
            //
            // xCenterOffset is the offset at which to start drawing the icon.
            //
            xCenterOffset = (dxFace + CX_TOP_FUDGE - (ptb->iDxBitmap + ptb->dxDDArrowChar)) / 2;
        } 
        else 
        {
            xCenterOffset = (dxFace - ptb->iDxBitmap) / 2;
        }

        if (state & (TBSTATE_PRESSED | TBSTATE_CHECKED) &&
            !(tbdraw.dwCustom & TBCDRF_NOOFFSET))
        {
            // pressed state moves down and to the right
            xCenterOffset++;
            yOffset++;
        }

        if (!ptb->hTheme)
        {

            // draw the dithered background
            if  (!fHotTrack &&
                 (((state & (TBSTATE_CHECKED | TBSTATE_INDETERMINATE)) ||
                  ((state & TBSTATE_MARKED) &&
                   !(ptb->ci.style & TBSTYLE_FLAT) &&
                   !(tbdraw.dwCustom & TBCDRF_NOMARK)))))
            {

                //Custom Draw can set hbrMonoDither to be NULL. Validate it before using it
                hbrOld = ptbcd->hbrMonoDither ? (HBRUSH)SelectObject(hdc, ptbcd->hbrMonoDither) : NULL;
                if (hbrOld)
                {
                    COLORREF clrText, clrBack;
                    clrText = SetTextColor(hdc, ptbcd->clrBtnHighlight); // 0 -> 0
                    clrBack = SetBkColor(hdc, ptbcd->clrBtnFace);        // 1 -> 1

                    // only draw the dither brush where the mask is 1's
                    if (!(tbdraw.dwCustom & TBCDRF_NOBACKGROUND))
                    {
                        PatBlt(hdc, x, y, dxFace, dyFace, PATCOPY);
                    }

                    SelectObject(hdc, hbrOld);
                    SetTextColor(hdc, clrText);
                    SetBkColor(hdc, clrBack);
                }
            }
        }

        // Paint the background of the hot-tracked item if the
        // custom draw said so
        if ((tbdraw.dwCustom & TBCDRF_HILITEHOTTRACK) && fHotTrack && !(tbdraw.dwCustom & TBCDRF_NOBACKGROUND))
        {
            PatB(hdc, pnmcd->rc.left, pnmcd->rc.top,
                 pnmcd->rc.right - pnmcd->rc.left, pnmcd->rc.bottom - pnmcd->rc.top,
                 ptbcd->clrHighlightHotTrack);
        }

        tbdraw.iImage = ptButton->iBitmap;
        if((ptButton->iBitmap == I_IMAGECALLBACK) && ptb->fHimlNative)
        {
            NMTBDISPINFO  tbgdi = {0};
            tbgdi.dwMask  = TBNF_IMAGE;
            TBGetItem(ptb,ptButton,&tbgdi);
            tbdraw.iImage = tbgdi.iImage;
        }

        tbdraw.iIndex = GET_HIML_INDEX(tbdraw.iImage);
        tbdraw.iImage = GET_IMAGE_INDEX(tbdraw.iImage);

        // Now put on the face.
        if (!DRAW_MONO_BTN(ptb, state) ||
            TBGetImageList(ptb, HIML_DISABLED, tbdraw.iIndex) ||
            (ImageList_GetItemFlags(TBGetImageList(ptb, HIML_NORMAL, tbdraw.iIndex), tbdraw.iImage) == ILIF_ALPHA))
        {
            // regular version
            int yStart = y;

            if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
                yStart -= g_cyEdge;

            DrawFace(hdc, &rcContent, x, yStart, xCenterOffset, yOffset, dxText, dyText, &tbdraw, ptbcd->iListGap, &ptbcd->rcText);
        }

        if (DRAW_MONO_BTN(ptb, state))
        {
            HBITMAP hbmOld;

            //initialize the monochrome dc
            if (!ptb->hdcMono) 
            {
                ptb->hdcMono = CreateCompatibleDC(hdc);
                if (!ptb->hdcMono)
                    return;
                SetTextColor(ptb->hdcMono, 0L);
                SelectObject(ptb->hdcMono, ptb->hfontIcon);
            }

            hbmOld = (HBITMAP)SelectObject(ptb->hdcMono, ptb->hbmMono);

            //
            // If we a mirrored DC, mirror the Memory DC so that
            // text written on the bitmap won't get flipped.
            //
            if ((IS_DC_RTL_MIRRORED(hdc)) &&
                (!(IS_DC_RTL_MIRRORED(ptb->hdcMono))))
            {
                SET_DC_RTL_MIRRORED(ptb->hdcMono);
            }

            BOOL fDrawMono = TRUE;

            // If we have a disabled image, or an alpha image, then we don't draw mono
            if (TBGetImageList(ptb, HIML_DISABLED, tbdraw.iIndex) != NULL ||
               (ImageList_GetItemFlags(TBGetImageList(ptb, HIML_NORMAL, tbdraw.iIndex), tbdraw.iImage) == ILIF_ALPHA))
            {
                fDrawMono = FALSE;
            }

            // disabled version (or indeterminate)
            CreateMask(&rcContent, xCenterOffset, yOffset, dxFace, dyFace, fDrawMono, &tbdraw);

            SetTextColor(hdc, 0L);       // 0's in mono -> 0 (for ROP)
            SetBkColor(hdc, 0x00FFFFFF); // 1's in mono -> 1

            // draw glyph's etched-effect
            if (!(state & TBSTATE_INDETERMINATE) &&
                !(tbdraw.dwCustom & TBCDRF_NOETCHEDEFFECT)) 
            {

                hbrOld = (HBRUSH)SelectObject(hdc, g_hbrBtnHighlight);
                if (hbrOld) 
                {
                    // draw hilight color where we have 0's in the mask
                    BitBlt(hdc, rcContent.left + 1, rcContent.top + 1, dxFace, dyFace, ptb->hdcMono, 0, 0, PSDPxax);
                    SelectObject(hdc, hbrOld);
                }
            }

            // gray out glyph
            hbrOld = (HBRUSH)SelectObject(hdc, g_hbrBtnShadow);
            if (hbrOld) 
            {
                // draw the shadow color where we have 0's in the mask
                BitBlt(hdc, rcContent.left, rcContent.top, dxFace, dyFace, ptb->hdcMono, 0, 0, PSDPxax);
                SelectObject(hdc, hbrOld);
            }

            if (state & TBSTATE_CHECKED) 
            {
                BitBlt(ptb->hdcMono, 1, 1, dxFace - 1, dyFace - 1, ptb->hdcMono, 0, 0, SRCAND);
            }
            SelectObject(ptb->hdcMono, hbmOld);
        }

        if (TB_HasDDArrow(ptb, ptButton))
        {
            WORD wDSAFlags = DCHF_TRANSPARENT | DCHF_FLIPPED;
            BOOL fPressedDD = ((ptb->Buttons + ptb->iPressedDD) == ptButton);

            RECT rc;
            if (TB_HasTopDDArrow(ptb, ptButton)) 
            {
                // position the dd arrow up next to the bitmap
                rc.left = x + xCenterOffset + ptb->iDxBitmap;
                rc.right = rc.left + ptb->dxDDArrowChar;
                rc.top = y + yOffset;
                rc.bottom = rc.top + ptb->iDyBitmap;
            }
            else 
            {
                // position the dd arrow to the right of the text & bitmap
                TB_GetItemRect(ptb, (UINT)(ptButton - ptb->Buttons), &rc);
                rc.left = rc.right - ptb->dxDDArrowChar;
            }

            if (TB_HasUnsplitDDArrow(ptb, ptButton)) 
            {
                // if a non-split dd arrow, don't draw a border.
                wDSAFlags |= DCHF_NOBORDER;
            }

            if (DRAW_MONO_BTN(ptb, state)) 
            {
                // DFCS_INACTIVE means "draw the arrow part grayed"
                wDSAFlags |= DCHF_INACTIVE;
            }
            // if TB_HasTopDDArrow, we've already offset rect, so don't draw DCHF_PUSHED
            else if ((fPressedDD || (state & (TBSTATE_CHECKED | TBSTATE_PRESSED))) &&
                   !TB_HasTopDDArrow(ptb, ptButton)) {
                // DCHF_PUSHED means "offset the arrow and draw indented border"
                wDSAFlags |= DCHF_PUSHED;
            } 
            else if (fHotTrack || !(ptb->ci.style & TBSTYLE_FLAT)) {
                // DCHF_HOT means "draw raised border"
                // non-flat dropdown arrows are either pushed or hot
                wDSAFlags |= DCHF_HOT;
            }

            if (ptb->hTheme && !TB_HasUnsplitDDArrow(ptb, ptButton))
            {
                int iState = TS_NORMAL;
                wDSAFlags |= DCHF_NOBORDER;

                if (wDSAFlags & DCHF_PUSHED)
                    iState = TS_PRESSED;
                else if (wDSAFlags & DCHF_INACTIVE)
                    iState = TS_DISABLED;
                else if (wDSAFlags & DCHF_HOT)
                    iState = TS_HOT;

                DrawThemeBackground(ptb->hTheme, hdc, TP_SPLITBUTTONDROPDOWN, iState, &rc, 0);
            }
            else
            {
                COLORREF crText;
                if (ptb->hTheme)
                {
                    GetThemeColor(ptb->hTheme, 0, 0, TMT_TEXTCOLOR, &crText);
                }
                DrawScrollArrow(hdc, &rc, wDSAFlags, ptb->hTheme ? crText : CLR_INVALID);
            }
        }

        if (!(tbdraw.dwCustom & CDRF_NEWFONT))
        {
            SelectObject(hdc, oldhFont);
        }

        SetTextColor(hdc, clrSave);

        if (hFontNoAntiAlias)
        {
            DeleteObject(hFontNoAntiAlias);
        }
    }

    if (tbdraw.dwCustom & CDRF_NOTIFYPOSTPAINT)
    {
        if (ptb->hTheme)
        {
            int iPartId;
            int iStateId;
            // Get the state back from what custom draw may have set
            TBGetPartAndState(ptb, ptButton, &iPartId, &iStateId);
            RECT rcTemp;
            GetThemeBackgroundContentRect(ptb->hTheme, hdc, iPartId, iStateId, &pnmcd->rc, &rcTemp);
            pnmcd->rc = rcTemp;
        }

        CICustomDrawNotify(&ptb->ci, CDDS_ITEMPOSTPAINT, &ptbcd->nmcd);
    }
}

// make sure that g_hbmMono is big enough to do masks for this
// size of button.  if not, fail.
BOOL CheckMonoMask(PTBSTATE ptb, int width, int height)
{
    BITMAP bm;
    HBITMAP hbmTemp;

    if (ptb->hbmMono) {
        GetObject(ptb->hbmMono, sizeof(BITMAP), &bm);
        if (width <= bm.bmWidth && height <= bm.bmHeight) {
            return TRUE;
        }
    }


    // Add a bit of fudge to keep this from being reallocated too often.
    hbmTemp = CreateMonoBitmap(width+8, height+8);
    if (!hbmTemp)
        return FALSE;

    if (ptb->hbmMono)
        DeleteObject(ptb->hbmMono);
    ptb->hbmMono = hbmTemp;
    return TRUE;
}

/*
** GrowToolbar
**
** Attempt to grow the button size.
**
** The calling function can either specify a new internal measurement
** (GT_INSIDE) or a new external measurement.
**
** GT_MASKONLY updates the mono mask and nothing else.
*/
BOOL GrowToolbar(PTBSTATE ptb, int newButWidth, int newButHeight, UINT flags)
{
    BOOL fGetNewSize = (!newButWidth) || (!newButHeight);

    if (!newButWidth)
        newButWidth = DEFAULTBUTTONX;
    if (!newButHeight)
        newButHeight = DEFAULTBUTTONY;

    // if growing based on inside measurement, get full size
    if (flags & GT_INSIDE)
    {
        if (ptb->ci.style & TBSTYLE_LIST)
            newButWidth += ptb->iDxBitmap + ptb->iListGap;

        newButHeight += ptb->cyPad;
        newButWidth += ptb->cxPad;

        // if toolbar already has strings, don't shrink width it because it
        // might clip room for the string
        if ((newButWidth < ptb->iButWidth) && ptb->nStrings &&
            ptb->nTextRows > 0)
            newButWidth = ptb->iButWidth;
    }
    else {
        if (newButHeight == -1)
            newButHeight = ptb->iButHeight;
        if (newButWidth == -1)
            newButWidth = ptb->iButWidth;

        
        int dyInner = ptb->iDyBitmap;

        HFONT hfontIcon = NULL;
        BOOL fDeleteFont = FALSE;
        if (ptb->hTheme)
        {
            LOGFONT lf;
            if (SUCCEEDED(GetThemeFont(ptb->hTheme, NULL, 0, 0, TMT_FONT, &lf)))
            {
                hfontIcon = CreateFontIndirect(&lf);
                fDeleteFont = TRUE;
            }
        }
        else
        {
            hfontIcon = ptb->hfontIcon;
        }

        if (hfontIcon)
        {
            HDC hdc = GetDC(ptb->ci.hwnd);
            if (hdc)
            {
                HFONT hfontOld = (HFONT)SelectObject(hdc, hfontIcon);

                TEXTMETRIC tm;
                GetTextMetrics(hdc, &tm);
                dyInner = max(dyInner, tm.tmHeight);

                SelectObject(hdc, hfontOld);

                ReleaseDC(ptb->ci.hwnd, hdc);
            }

            if (fDeleteFont)
            {
                DeleteObject(hfontIcon);
            }
        }

        if (newButHeight < dyInner + ptb->cyPad)
            newButHeight = dyInner + ptb->cyPad;
        if (newButWidth < ptb->iDxBitmap + ptb->cxPad)
            newButWidth = ptb->iDxBitmap + ptb->cxPad;
    }

    // if the size of the toolbar is actually growing, see if shadow
    // bitmaps can be made sufficiently large.
    if (!ptb->hbmMono || (newButWidth > ptb->iButWidth) || (newButHeight > ptb->iButHeight)) {
        if (!CheckMonoMask(ptb, newButWidth, newButHeight))
            return(FALSE);
    }

    if (flags & GT_MASKONLY)
        return(TRUE);

    if (!(flags & GT_INSIDE) && ((ptb->iButWidth != newButWidth) || (ptb->iButHeight != newButHeight)))
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

    if (ptb->hTheme && (fGetNewSize || (ptb->iButWidth != newButWidth || ptb->iButHeight != newButHeight)))
    {
        int cx = newButWidth;
        int cy = newButHeight;

        RECT rc = {0, 0, newButWidth, newButHeight};

        int iPartId = TP_BUTTON;
        int iStateId = TS_NORMAL;

        // start with -1 so we can get sensible defaults in the case of no buttons
        for (int iButton = -1; iButton < ptb->iNumButtons; iButton++)
        {
            RECT rcOut;

            if (iButton != -1)
                TBGetPartAndState(ptb, &ptb->Buttons[iButton], &iPartId, &iStateId);

            GetThemeBackgroundExtent(ptb->hTheme, NULL, iPartId, iStateId, &rc, &rcOut);
            cx = max(cx, RECTWIDTH(rcOut));
            cy = max(cy, RECTHEIGHT(rcOut));
        }

        ptb->iButWidth = cx;
        ptb->iButHeight = cy;
    }
    else
    {
        ptb->iButWidth = newButWidth;
        ptb->iButHeight = newButHeight;
    }

    // bar height has 2 pixels above, 2 below
    ptb->iYPos = ptb->cyBarPad;

    TBInvalidateItemRects(ptb);

    return TRUE;
}

BOOL SetBitmapSize(PTBSTATE ptb, int width, int height)
{
    int realh;

    if (!width)
        width = 1;
    if (!height)
        height = 1;

    if (width == -1)
        width = ptb->iDxBitmap;

    if (height == -1)
        height = ptb->iDyBitmap;

    realh = height;

    if ((ptb->iDxBitmap == width) && (ptb->iDyBitmap == height))
        return TRUE;

    if (TBHasStrings(ptb))
        realh = HeightWithString(ptb, height);

    if (GrowToolbar(ptb, width, realh, GT_INSIDE)) {
        ptb->iDxBitmap = width;
        ptb->iDyBitmap = height;

        // the size changed, we need to rebuild the imagelist
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
        TBInvalidateImageList(ptb);
        return TRUE;
    }
    return FALSE;
}

void TB_OnSysColorChange(PTBSTATE ptb)
{

    int i;
    InitGlobalColors();
    //  Reset all of the bitmaps

    for (i = 0; i < ptb->cPimgs; i++) {
        HIMAGELIST himl = TBGetImageList(ptb, HIML_NORMAL, i);
        if (himl)
            ImageList_SetBkColor(himl, (ptb->ci.style & TBSTYLE_TRANSPARENT) ? CLR_NONE : g_clrBtnFace);
        himl = TBGetImageList(ptb, HIML_HOT, i);
        if (himl)
            ImageList_SetBkColor(himl, (ptb->ci.style & TBSTYLE_TRANSPARENT) ? CLR_NONE : g_clrBtnFace);
    }
}

#define CACHE 0x01
#define BUILD 0x02


void ReleaseMonoDC(PTBSTATE ptb)
{
    if (ptb->hdcMono) {
        SelectObject(ptb->hdcMono, g_hfontSystem);
        DeleteDC(ptb->hdcMono);
        ptb->hdcMono = NULL;
    }
}

void TB_DrawBackground(PTBSTATE ptb, HDC hdc, NMTBCUSTOMDRAW *ptbcd, RECT* prcClip)
{
    if (ptb->ci.style & TBSTYLE_CUSTOMERASE) 
    {
        ptb->ci.dwCustom = CICustomDrawNotify(&ptb->ci, CDDS_PREERASE, &ptbcd->nmcd);
    } 
    else 
    {
        ptb->ci.dwCustom = CDRF_DODEFAULT;
    }

    if (!(ptb->ci.dwCustom & CDRF_SKIPDEFAULT))
    {
        BOOL fPaintBackground = TRUE;
        if (ptb->ci.style & TBSTYLE_TRANSPARENT)
        {
            // Explicitly check here. Double buffer passed in means "Efficent flicker free painting".
            // Only callers that know about this flag know to handle WM_PRINTCLIENT correctly, 
            // so they get the efficient rendering.
            if (ptb->dwStyleEx & TBSTYLE_EX_DOUBLEBUFFER)
            {
                // V6 Behaviour Change: Toolbar doesn't use Erase background for transparency any more.
                // Erase is much less efficent than WM_PRINT.
            
                if (!ptb->hTheme || CCShouldAskForBits(&ptb->ci, ptb->hTheme, TP_BUTTON, 1)) // Cheat: We assume transparency for all if the button is
                {
                    if (CCSendPrintRect(&ptb->ci, hdc, prcClip))
                        fPaintBackground = FALSE;
                }
            }
            else
            {
                if (CCForwardEraseBackground(ptb->ci.hwnd, hdc))
                    fPaintBackground = FALSE;
            }
        }

        if (fPaintBackground)
        {
            if (ptb->hTheme)
            {
                RECT rc;
                GetWindowRect(ptb->ci.hwnd, &rc);
                OffsetRect(&rc, -rc.left, -rc.top);

                DebugPaintRect(hdc, &rc);
                DrawThemeBackground(ptb->hTheme, hdc, 0, 0, &rc, NULL /*prcClip*/);
            }
            else
            {
                DefWindowProc(ptb->ci.hwnd, WM_ERASEBKGND, (WPARAM) hdc, 0);
            }
        }
    }

    if (ptb->ci.dwCustom & CDRF_NOTIFYPOSTERASE)
        CICustomDrawNotify(&ptb->ci, CDDS_POSTERASE, &ptbcd->nmcd);
}

void TB_OnEraseBkgnd(PTBSTATE ptb, HDC hdc)
{
    if (!TB_IsDoubleBuffer(ptb))
    {
        NMTBCUSTOMDRAW  tbcd = { 0 };
        tbcd.nmcd.hdc = hdc;

        TB_DrawBackground(ptb, hdc, &tbcd, NULL);
    }  
}

BOOL TBIsRectClipped(PTBSTATE ptb, LPRECT prc)
{
    RECT rc;
    RECT rcTB;

    if (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN)
        CopyRect(&rcTB, &ptb->rc);
    else
        GetClientRect(ptb->ci.hwnd, &rcTB);

    if (IntersectRect(&rc, &rcTB, prc)) {
        if (EqualRect(prc, &rc))
            return FALSE;
    }

    return TRUE;
}

BOOL TBShouldDrawButton(PTBSTATE ptb, LPRECT prcBtn, HDC hdc)
{
    // don't bother drawing buttons that aren't in the dc clipping region
    if (RectVisible(hdc, prcBtn)) {
        if (ptb->dwStyleEx & TBSTYLE_EX_HIDECLIPPEDBUTTONS)
            return !TBIsRectClipped(ptb, prcBtn);
        else
            return TRUE;
    }

    return FALSE;
}

// goin horizontal . . .
void DrawToolbarH(PTBSTATE ptb, HDC hdc, LPRECT prc)
{
    int iButton, xButton, yButton, cxBar;
    LPTBBUTTONDATA pAllButtons = ptb->Buttons;
    cxBar = prc->right - prc->left;

    yButton   = ptb->iYPos;
    prc->top    = ptb->iYPos;
    prc->bottom = ptb->iYPos + ptb->iButHeight;   // Bug#16338 (scotth): what if first btn is a separator?


    for (iButton = 0, xButton = ptb->xFirstButton;
            iButton < ptb->iNumButtons; iButton++)
    {
        LPTBBUTTONDATA pButton = &pAllButtons[iButton];
        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            int cxButton = TBWidthOfButton(ptb, pButton, hdc);

            // Is there anything to draw?
            if (!(pButton->fsStyle & BTNS_SEP) || (ptb->ci.style & TBSTYLE_FLAT))
            {
                // Yes
                prc->left = xButton;
                prc->right = xButton + cxButton;

                if (TBShouldDrawButton(ptb, prc, hdc))
                {
                    // Draw separator?
                    if (pButton->fsStyle & BTNS_SEP)
                    {
                        // Yes; must be a flat separator.  Is this toolbar vertical?
                        if (ptb->ci.style & CCS_VERT)
                        {
                            // Yes; draw a horizontal separator.  Center w/in the
                            // button rect
                            if (ptb->hTheme)
                                DrawThemeBackground(ptb->hTheme, hdc, TP_SEPARATORVERT, 0, prc, 0);
                            else
                            {
                                int iSave = prc->top;
                                prc->top += (TBGetSepHeight(ptb, pButton) - 1) / 2;
                                InflateRect(prc, -g_cxEdge, 0);
                                CCDrawEdge(hdc, prc, EDGE_ETCHED, BF_TOP, &(ptb->clrsc));
                                InflateRect(prc, g_cxEdge, 0);
                                prc->top = iSave;
                            }
                        }
                        else
                        {
                            // No; draw a vertical separator
                            if (ptb->hTheme)
                                DrawThemeBackground(ptb->hTheme, hdc, TP_SEPARATOR, 0, prc, 0);
                            else
                            {
                                prc->left += (cxButton - 1) / 2;
                                InflateRect(prc, 0, -g_cyEdge);
                                CCDrawEdge(hdc, prc, EDGE_ETCHED, BF_LEFT, &(ptb->clrsc));
                                InflateRect(prc, 0, g_cyEdge);
                            }
                        }
                    }
                    else
                    {
                        // No
                        DrawButton(hdc, xButton, yButton, ptb, pButton, ptb->fActive);
                    }
                }
            }

            xButton += (cxButton + ptb->cxButtonSpacing);

            if (pButton->fsState & TBSTATE_WRAP)
            {
                int dy;

                if (pButton->fsStyle & BTNS_SEP)
                {
                    if (ptb->ci.style & CCS_VERT)
                        dy = TBGetSepHeight(ptb, pButton);
                    else
                    {
                        if (ptb->ci.style & TBSTYLE_FLAT)
                        {
                            // Draw a separator across the entire toolbar to separate rows.
                            // For horizontal toolbars only.
                            RECT rcMid;
                            rcMid.top = prc->top + ptb->iButHeight + ((TBGetSepHeight(ptb, pButton) - 1) / 2);
                            rcMid.bottom = rcMid.top + g_cxEdge;
                            rcMid.left = g_cxEdge;
                            rcMid.right = cxBar - g_cxEdge;

                            CCDrawEdge(hdc, &rcMid, EDGE_ETCHED, BF_TOP, &(ptb->clrsc));
                        }

                        dy = ptb->iButHeight + TBGetSepHeight(ptb, pButton);
                    }
                }
                else
                    dy = ptb->iButHeight;

                xButton = ptb->xFirstButton;
                yButton   += dy + ptb->cyButtonSpacing;
                prc->top    += dy + ptb->cyButtonSpacing;
                prc->bottom += dy + ptb->cyButtonSpacing;
            }
        }
    }
}

// goin vertical . . .
void DrawToolbarV(PTBSTATE ptb, HDC hdc, LPRECT prc)
{
    int iButton, xButton, yButton, cyBar;
    LPTBBUTTONDATA pAllButtons = ptb->Buttons;
    NMTBCUSTOMDRAW  tbcd = { 0 };
    LPTBBUTTONDATA pButton = pAllButtons;

    cyBar = prc->bottom - prc->top;

    xButton = ptb->xFirstButton;
    prc->left = xButton;
    prc->right = prc->left + ptb->iButWidth;

    for (iButton = 0, yButton = 0;
            iButton < ptb->iNumButtons; iButton++, pButton++)
    {
        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            // Is there anything to draw?
            if (!(pButton->fsStyle & BTNS_SEP) || (ptb->ci.style & TBSTYLE_FLAT))
            {
                int cyButton;
                
                if (pButton->fsStyle & BTNS_SEP)
                    cyButton = TBGetSepHeight(ptb, pButton);
                else
                    cyButton = ptb->iButHeight;

                prc->top = yButton;
                prc->bottom = yButton + cyButton;

                if (TBShouldDrawButton(ptb, prc, hdc))
                {
                    // Draw separator?
                    if (pButton->fsStyle & BTNS_SEP)
                    {
                        DWORD dwCustRet;
                        NMTBCUSTOMDRAW  tbcd = { 0 };

                        tbcd.nmcd.hdc = hdc;
                        tbcd.nmcd.dwItemSpec = -1;
                        CopyRect(&tbcd.nmcd.rc, prc);

                        dwCustRet = CICustomDrawNotify(&ptb->ci, CDDS_ITEMPREPAINT, &tbcd.nmcd);

                        if ( !(CDRF_SKIPDEFAULT &  dwCustRet) )
                        {
                            if (ptb->hTheme)
                                DrawThemeBackground(ptb->hTheme, hdc, TP_SEPARATORVERT, 0, prc, 0);
                            else
                            {
                                // Yes; must be a flat separator.
                                InflateRect(prc, -g_cxEdge, 0);
                                CCDrawEdge(hdc, prc, EDGE_ETCHED, BF_TOP, &(ptb->clrsc));
                                InflateRect(prc, g_cxEdge, 0);
                            }
                        }
                    }
                    else
                    {
                        // No
                        DrawButton(hdc, xButton, yButton, ptb, pButton, ptb->fActive);
                    }
                }
                
                yButton += cyButton;
            }

            if (pButton->fsState & TBSTATE_WRAP)
            {
                int dx;
            
                if (ptb->ci.style & TBSTYLE_FLAT)
                {
                    // Draw a separator vertival across the entire toolbar to separate cols.
                    // For vertical toolbars only.

                    RECT rcMid;

                    rcMid.top = ptb->rc.top + g_cxEdge;
                    rcMid.bottom = ptb->rc.bottom - g_cxEdge;
                    rcMid.left = xButton + ptb->iButWidth;
                    rcMid.right = rcMid.left + g_cxEdge;
                    CCDrawEdge(hdc, &rcMid, EDGE_ETCHED, BF_LEFT, &(ptb->clrsc));
                }

                dx = ptb->iButWidth + g_cxEdge;

                yButton  = 0;
                xButton += dx;
                prc->left += dx;
                prc->right += dx;
            }
        }
    }
}

COLORREF TB_GetInsertMarkColor(PTBSTATE ptb)
{
    if (ptb->clrim == CLR_DEFAULT)
        return g_clrBtnText;
    else
        return ptb->clrim;
}

void TBPaint(PTBSTATE ptb, HDC hdcIn)
{
    RECT rc;
    HDC hdc;
    PAINTSTRUCT ps;
    NMTBCUSTOMDRAW  tbcd = { 0 };
    CCDBUFFER db = {0};

    GetClientRect(ptb->ci.hwnd, &rc);

    if (hdcIn)
    {
        hdc = hdcIn;
        GetClipBox(hdc, &ps.rcPaint);
    }
    else
        hdc = BeginPaint(ptb->ci.hwnd, &ps);

    if (!rc.right)
        goto Error1;

    // Create memory surface and map rendering context if double buffering
    if (TB_IsDoubleBuffer(ptb))
    {
        hdc = CCBeginDoubleBuffer(hdc, &ps.rcPaint, &db);
    }

    if (!hdc)
        return;


    tbcd.nmcd.hdc = hdc;
    tbcd.nmcd.rc = rc;

    // Draw background in this pass if double buffering, otherwise, it was handled in WM_ERASEBKGND
    if (TB_IsDoubleBuffer(ptb))
    {
        TB_DrawBackground(ptb, hdc, &tbcd, &ps.rcPaint);
    }
 
    //Draw foreground
    ptb->ci.dwCustom = CICustomDrawNotify(&ptb->ci, CDDS_PREPAINT, &tbcd.nmcd);

    if (!(ptb->ci.dwCustom & CDRF_SKIPDEFAULT))
    {
        if (!ptb->fHimlValid)
            TBBuildImageList(ptb);

        if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
            DrawToolbarV(ptb, hdc, &rc);
        else
            DrawToolbarH(ptb, hdc, &rc);

        if (ptb->iInsert!=-1)
        {
            BOOL fHorizMode = !(ptb->ci.style & CCS_VERT);
            RECT rc;
            if (GetInsertMarkRect(ptb, &rc, fHorizMode))
            {
                CCDrawInsertMark(hdc, &rc, fHorizMode, TB_GetInsertMarkColor(ptb));
            }
        }

        ReleaseMonoDC(ptb);
    }

    if (ptb->ci.dwCustom & CDRF_NOTIFYPOSTPAINT)
    {
        tbcd.nmcd.hdc = hdc;
        tbcd.nmcd.uItemState = 0;
        tbcd.nmcd.lItemlParam = 0;
        CICustomDrawNotify(&ptb->ci, CDDS_POSTPAINT, &tbcd.nmcd);
    }

    CCEndDoubleBuffer(&db);

Error1:
    if (hdcIn == NULL)
        EndPaint(ptb->ci.hwnd, &ps);

}

void TB_GetItemDropDownRect(PTBSTATE ptb, UINT uButton, LPRECT lpRect)
{
    TB_GetItemRect(ptb,uButton,lpRect);
    lpRect->left = lpRect->right - ptb->dxDDArrowChar;
}

int TBHeightOfButton(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    int dy;

	if ((ptbb->fsStyle & BTNS_SEP)  && 
		(ptbb->fsState & TBSTATE_WRAP || ptb->dwStyleEx & TBSTYLE_EX_VERTICAL))
	{
		if (!(ptb->ci.style & CCS_VERT) && !(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)) 
		{
			dy = TBGetSepHeight(ptb, ptbb) + ptb->iButHeight;
		} 
		else 
		{
			dy = TBGetSepHeight(ptb, ptbb);
		}
	}
	else
	{
		dy = ptb->iButHeight;
	}

    return dy;
}

void TB_CalcItemRects(PTBSTATE ptb)
{
    int iButton, xPos, yPos;

    ASSERT(!ptb->fItemRectsValid);

    xPos = ptb->xFirstButton;
    yPos = ptb->iYPos;

    for (iButton = 0; iButton < ptb->iNumButtons; iButton++)
    {
        int xPosButton;
        LPTBBUTTONDATA pButton = &ptb->Buttons[iButton];

        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            if ((pButton->fsState & TBSTATE_WRAP) && (pButton->fsStyle & BTNS_SEP))
                xPosButton = ptb->xFirstButton;
            else
                xPosButton = xPos;

            pButton->pt.x = xPosButton;
            pButton->pt.y = yPos;

            if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
            {
                if (pButton->fsState & TBSTATE_WRAP)
                {
                    xPos += (ptb->iButWidth + g_cxEdge);    // to not overwrite the edge.
                    yPos = 0;
                }
                else if (pButton->fsStyle & BTNS_SEP)
                    yPos += (TBGetSepHeight(ptb, pButton));
                else
                    yPos += ptb->iButHeight + ptb->cyButtonSpacing;
            }
            else // standard horizontal toolbar.
            {
                xPos += TBWidthOfButton(ptb, pButton, NULL) + ptb->cxButtonSpacing;

                if (pButton->fsState & TBSTATE_WRAP)
                {
                    yPos += ptb->iButHeight + ptb->cyButtonSpacing;

                    if (pButton->fsStyle & BTNS_SEP)
                    {
                        if (ptb->ci.style & CCS_VERT) {
                            yPos -= ptb->iButHeight + ptb->cyButtonSpacing;
                        }
                        yPos += (TBGetSepHeight(ptb, pButton));
                    }

                    xPos = ptb->xFirstButton;
                }
            }
        }
    }
}

BOOL TB_GetItemRect(PTBSTATE ptb, UINT uButton, LPRECT lpRect)
{
    int dy = ptb->iButHeight;

    if (uButton >= (UINT)ptb->iNumButtons
        || (ptb->Buttons[uButton].fsState & TBSTATE_HIDDEN))
    {
        return FALSE;
    }

    if (!ptb->fItemRectsValid) {
        TB_CalcItemRects(ptb);
        ptb->fItemRectsValid = TRUE;
    }

    lpRect->left   = ptb->Buttons[uButton].pt.x;
    lpRect->right  = lpRect->left + TBWidthOfButton(ptb, &ptb->Buttons[uButton], NULL);
    lpRect->top    = ptb->Buttons[uButton].pt.y;
    lpRect->bottom = lpRect->top + TBHeightOfButton(ptb, &ptb->Buttons[uButton]);

    return TRUE;
}

void InvalidateButton(PTBSTATE ptb, LPTBBUTTONDATA pButtonToPaint, BOOL fErase)
{
    RECT rc;

    if (TB_GetItemRect(ptb, (UINT) (pButtonToPaint - ptb->Buttons), &rc))
    {
        InvalidateRect(ptb->ci.hwnd, &rc, fErase);
    }
}

/*----------------------------------------------------------
Purpose: Toggles the button as a dropdown

Returns: TRUE if handled
*/
BOOL TBToggleDropDown(PTBSTATE ptb, int iPos, BOOL fEatMsg)
{
    BOOL bRet = FALSE;
    LPTBBUTTONDATA ptbButton = &ptb->Buttons[iPos];

    ASSERT(TB_IsDropDown(ptbButton));

    if (ptbButton->fsState & TBSTATE_ENABLED)
    {
        UINT nVal;
        HWND hwnd = ptb->ci.hwnd;

        ptb->iPressedDD = iPos;

        if (TB_HasUnsplitDDArrow(ptb, ptbButton))
            ptbButton->fsState |= TBSTATE_PRESSED;

        InvalidateButton(ptb, ptbButton, TRUE);
        UpdateWindow(hwnd);

        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, iPos+1);

        nVal = (UINT) SendItemNotify(ptb, ptbButton->idCommand, TBN_DROPDOWN);
        if (TBDDRET_DEFAULT == nVal || TBDDRET_TREATPRESSED == nVal)
        {
            if (fEatMsg)
            {
                MSG msg;

                PeekMessage(&msg, hwnd, WM_LBUTTONDOWN, WM_LBUTTONDOWN, PM_REMOVE);

                if (!IsWindow(hwnd))
                    return FALSE;
            }

            ptb->iPressedDD = -1;

            if (TB_HasUnsplitDDArrow(ptb, ptbButton))
                ptbButton->fsState &= ~TBSTATE_PRESSED;

            InvalidateButton(ptb, ptbButton, TRUE);
            UpdateWindow(hwnd);

            NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, iPos+1);
        }

        bRet = (TBDDRET_DEFAULT == nVal);
    }
    return bRet;
}


void TBInvalidateButton(PTBSTATE ptb, int i, BOOL fErase)
{
    if (i != -1) {
        InvalidateButton(ptb, &ptb->Buttons[i], fErase);
   }
}


void TBSetHotItem(PTBSTATE ptb, int iPos, DWORD dwReason)
{
    HWND hwnd;

    // Either one of these values can be -1, but refrain
    // from processing if both are negative b/c it is wasteful
    // and very common

    if ((ptb->iHot != iPos || (dwReason & HICF_RESELECT)) &&
        (0 <= ptb->iHot || 0 <= iPos) &&
        iPos < ptb->iNumButtons)
    {
        NMTBHOTITEM nmhot = {0};
        int iHot = ptb->iHot;

        // Has the mouse moved away from the toolbar but
        // do we still anchor the highlight?
        if (0 > iPos && ptb->fAnchorHighlight && (dwReason & HICF_MOUSE))
            return ;        // Yes; deny the hot item change

        // Send a notification about the hot item change
        if (0 > ptb->iHot)
        {
            if (iPos >= 0)
                nmhot.idNew = ptb->Buttons[iPos].idCommand;
            nmhot.dwFlags = HICF_ENTERING;
        }
        else if (0 > iPos)
        {
            if (ptb->iHot >= 0 && ptb->iHot < ptb->iNumButtons)
                nmhot.idOld = ptb->Buttons[ptb->iHot].idCommand;
            nmhot.dwFlags = HICF_LEAVING;
        }
        else
        {
            if (ptb->iHot < ptb->iNumButtons)
                nmhot.idOld = ptb->Buttons[ptb->iHot].idCommand;
            nmhot.idNew = ptb->Buttons[iPos].idCommand;
        }
        nmhot.dwFlags |= dwReason;

        // must save this for revalidation
        hwnd = ptb->ci.hwnd;

        if (CCSendNotify(&ptb->ci, TBN_HOTITEMCHANGE, &nmhot.hdr))
            return;         // deny the hot item change

        // Revalidate the window
        if (!IsWindow(hwnd)) return;

        TBInvalidateButton(ptb, ptb->iHot, TRUE);
        if ((iPos < 0) || !(ptb->Buttons[iPos].fsState & TBSTATE_ENABLED))
            iPos = -1;

        ptb->iHot = iPos;

        // Hot state change, cancel tracking tooltips
        if (ptb->iHot == -1)
            TB_CancelTipTrack(ptb);

        // Item focus changed, start tracking tooltip timeout for keyboard nav popups
        if ((ptb->iHot != -1) && !(nmhot.dwFlags & HICF_MOUSE))
        {
            if (ptb->hwndToolTips)
            {
                TB_CancelTipTrack(ptb);
                ptb->iTracking = ptb->iHot;

                // Delay will be replaced with an SPI
                SetTimer(ptb->ci.hwnd, IDT_TRACKINGTIP, GetDoubleClickTime() * 2, NULL);
            }
        }

        if (GetFocus() == ptb->ci.hwnd && 
            iHot != ptb->iHot)
        {
            NotifyWinEvent(EVENT_OBJECT_FOCUS, ptb->ci.hwnd, OBJID_CLIENT, iPos + 1);
        }

        TBInvalidateButton(ptb, ptb->iHot, TRUE);

        if ((iPos >= 0 && iPos < ptb->iNumButtons) &&
            (TB_IsDropDown(&ptb->Buttons[iPos])) &&
            (dwReason & HICF_TOGGLEDROPDOWN))
        {
            TBToggleDropDown(ptb, iPos, FALSE);
        }
    }
}

BOOL GetInsertMarkRect(PTBSTATE ptb, LPRECT prc, BOOL fHorizMode)
{
    BOOL fRet = TB_GetItemRect(ptb, ptb->iInsert, prc);
    if (fRet)
    {
        // if we are in horizontal mode, we need a vertical insertion marker
        if ( fHorizMode )
        {
            if (ptb->fInsertAfter)
                prc->left = prc->right;
            else
                prc->right = prc->left;

            prc->left -= INSERTMARKSIZE/2;
            prc->right += INSERTMARKSIZE/2 + 1;
        }
        else
        {
            if (ptb->fInsertAfter)
                prc->top = prc->bottom;
            else
                prc->bottom = prc->top;

            prc->top -= INSERTMARKSIZE/2;
            prc->bottom += INSERTMARKSIZE/2 + 1;
        }
    }
    return fRet;
}

void TBInvalidateMark(PTBSTATE ptb)
{
    RECT rc;

    if (GetInsertMarkRect(ptb, &rc, !(ptb->ci.style & CCS_VERT)))
    {
        InvalidateRect(ptb->ci.hwnd, &rc, TRUE);
    }
}

void TBSetInsertMark(PTBSTATE ptb, LPTBINSERTMARK ptbim)
{
    if (ptbim->iButton != ptb->iInsert ||
        BOOLIFY(ptb->fInsertAfter) != BOOLIFY(ptbim->dwFlags & TBIMHT_AFTER))
    {
        if (ptb->iInsert != -1)
            TBInvalidateMark(ptb);

        ptb->iInsert = ptbim->iButton;
        ptb->fInsertAfter = BOOLIFY(ptbim->dwFlags & TBIMHT_AFTER);

        if (ptb->iInsert != -1)
            TBInvalidateMark(ptb);
    }
}

void TBCycleHotItem(PTBSTATE ptb, int iStart, int iDirection, UINT nReason)
{
    int i;
    int iPrev;
    NMTBWRAPHOTITEM nmwh;

    nmwh.iDir = iDirection;
    nmwh.nReason = nReason;


    //When cycling around the menu, without this check, the second to last menu
    //item would be selected.
    if (iStart == -1 && iDirection == -1)
        iStart = 0;

    for (i = 0; i < ptb->iNumButtons; i++)
    {
        iPrev = iStart;
        iStart += iDirection + ptb->iNumButtons;
        iStart %= ptb->iNumButtons;

        if ( ( iPrev + iDirection >= ptb->iNumButtons) || (iPrev + iDirection < 0) )
        {
            nmwh.iStart = iStart;
            if (CCSendNotify(&ptb->ci, TBN_WRAPHOTITEM, &nmwh.hdr))
                return;
        }

        if (ptb->Buttons[iStart].fsState & TBSTATE_ENABLED &&
            !(ptb->Buttons[iStart].fsState & TBSTATE_HIDDEN) &&
            !(ptb->Buttons[iStart].fsStyle & BTNS_SEP))
        {
            // if the old hot item was dropped down, undrop it.
            if (ptb->iHot != -1 && ptb->iHot == ptb->iPressedDD)
                TBToggleDropDown(ptb, ptb->iHot, FALSE);

            TBSetHotItem(ptb, iStart, nReason);
            break;
        }
    }
}


// Do hit testing by sliding the origin of the supplied point
//
// returns:
//  >= 0    index of non separator item hit
//  < 0     index of separator or nearest non separator item (area
//          just below and to the left)
//
// +--------------------------------------
// |      -1    -1    -1    -1
// |      btn   sep   btn
// |    +-----+     +-----+
// |    |     |     |     |
// | -1 |  0  | -1  |  2  | -3
// |    |     |     |     |
// |    +-----+     +-----+
// |
// | -1   -1    -1    -2    -3
//

int TBHitTest(PTBSTATE ptb, int xPos, int yPos)
{
    int prev = 0;
    int last = 0;
    int i;
    RECT rc;

    if (ptb->iNumButtons == 0)
        return(-1);

    for (i=0; i<ptb->iNumButtons; i++)
    {
        if (TB_GetItemRect(ptb, i, &rc))
        {
            // ignore this button if hidden because of HideClippedButtons style
            if (!(ptb->dwStyleEx & TBSTYLE_EX_HIDECLIPPEDBUTTONS) || !(TBIsRectClipped(ptb, &rc)))
            {
                // From PtInRect docs:
                //   A point is within a rectangle if it lies on the left or top
                //   side or is within all four sides. A point on the right or
                //   bottom side is considered outside the rectangle.

                if (yPos >= rc.top && yPos < rc.bottom)
                {
                    if (xPos >= rc.left && xPos < rc.right)
                    {
                        if (ptb->Buttons[i].fsStyle & BTNS_SEP)
                            return - i - 1;
                        else
                            return i;
                    }
                    else
                    {
                        prev = i + 1;
                    }
                }
                else
                {
                    last = i;
                }
            }
        }
    }

    if (prev)
        return -1 - prev;
    else if (yPos > rc.bottom)
        // this means that we are off the bottom of the toolbar
        return(- i - 1);

    return -1 - last;
}

// Same as above except:
//  - returns TRUE if the cursor is on the button edge.
//  - returns FALSE is the cursor is b/t buttons or on the button itself

BOOL TBInsertMarkHitTest(PTBSTATE ptb, int xPos, int yPos, LPTBINSERTMARK ptbim)
{
    TBINSERTMARK prev = {-1, TBIMHT_AFTER|TBIMHT_BACKGROUND}; // best guess if we hit a row
    TBINSERTMARK last = {-1, TBIMHT_AFTER|TBIMHT_BACKGROUND}; // best guess if we don't
    int i;

    // restrict hit testing depending upon whether we are vertical or horizontal
    BOOL fHorizMode = !(ptb->ci.style & CCS_VERT);

    for (i=0; i<ptb->iNumButtons; i++)
    {
        RECT rc;

        if (TB_GetItemRect(ptb, i, &rc))
        {
            if (yPos >= rc.top && yPos < rc.bottom)
            {
                if (xPos >= rc.left && xPos < rc.right)
                {
                    ptbim->iButton = i;

                    if ( fHorizMode )
                    {
                        if (xPos < rc.left + g_cxEdge*4)
                        {
                            ptbim->dwFlags = 0;
                            return TRUE;
                        }
                        else if (xPos > rc.right - g_cxEdge*4)
                        {
                            ptbim->dwFlags = TBIMHT_AFTER;
                            return TRUE;
                        }
                    }
                    else
                    {
                        // vertical....
                        if (yPos < rc.top + g_cyEdge*4)
                        {
                            ptbim->dwFlags = 0;
                            return TRUE;
                        }
                        else if (yPos > rc.bottom - g_cyEdge*4)
                        {
                            ptbim->dwFlags = TBIMHT_AFTER;
                            return TRUE;
                        }
                    }

                    // else we are just on a button...
                    ptbim->dwFlags = 0;
                    return FALSE;
                }
                else
                {
                    if (xPos < rc.left)
                    {
                        // since buttons are laid out left to right
                        // and rows are laid out top to bottom,
                        // if we ever hit this case, we can't hit anything else
                        ptbim->iButton = i;
                        ptbim->dwFlags = TBIMHT_BACKGROUND;
                        return FALSE;
                    }
                    else // (xPos > rc.right)
                    {
                        // remember the last one we've seen on this row
                        prev.iButton = i;
                    }
                }
            }
            else
            {
                if (yPos < rc.top)
                {
                    if (prev.iButton != -1)
                    {
                        *ptbim = prev;
                    }
                    else
                    {
                        ptbim->iButton = i;
                        ptbim->dwFlags = TBIMHT_BACKGROUND;
                    }
                }
                else
                {
                    // remember the last one we've seen
                    last.iButton = i;
                }
            }
        }
    }

    if (prev.iButton != -1)
        *ptbim = prev;
    else
        *ptbim = last;

    return FALSE;
}

int CountRows(PTBSTATE ptb)
{
    LPTBBUTTONDATA pButton, pBtnLast;
    int rows = 1;

    pBtnLast = &(ptb->Buttons[ptb->iNumButtons]);
    for (pButton = ptb->Buttons; pButton<pBtnLast; pButton++) {
        if (pButton->fsState & TBSTATE_WRAP) {
            rows++;
            if (pButton->fsStyle & BTNS_SEP)
                rows++;
        }
    }

    return rows;
}

#define CountCols(ptb)  CountRows(ptb)

void WrapToolbarCol(PTBSTATE ptb, int dy, LPRECT lpRect, int *pCols)
{
    LPTBBUTTONDATA pButton, pBtnLast, pBtnPrev;
    LPTBBUTTONDATA pbtnLastVisible = NULL;
    LPTBBUTTONDATA pbtnPrev = NULL;
    int xPos, yPos;
    int dyButton;
    int yPosWrap = 0;
    int cCols = 1;

    DEBUG_CODE( int cItemsPerCol = 0; )

    ASSERT(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL);
    TraceMsg(TF_TOOLBAR, "Toolbar: calculating WrapToolbar");

    // dy must be at least the button height, otherwise the final
    // rect is mis-calculated and will be too big.
    if (dy < ptb->iButHeight)
        dy = ptb->iButHeight;

    dyButton = ptb->iButHeight;
    xPos = ptb->xFirstButton;
    yPos = ptb->iYPos;
    pBtnLast = &(ptb->Buttons[ptb->iNumButtons]);
    ptb->szCached.cx = -1;
    ptb->szCached.cy = -1;

    if (pCols)
        (*pCols) = 1;

    pBtnPrev = ptb->Buttons;

    for (pButton = ptb->Buttons; pButton < pBtnLast; pButton++)
    {
        DEBUG_CODE( cItemsPerCol++; )

        // we nuke the wrap state at the start of the loop.
        // so we don't know if/when we are adding on a wrap bit that wasn't there
        // before.  we overstep the button, then back up when we've gone too far,
        pButton->fsState &= ~TBSTATE_WRAP;
        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            if (pButton->fsStyle & BTNS_SEP)
                yPos += (TBGetSepHeight(ptb, pButton));
            else
                yPos += dyButton;
            // Is this button out of bounds?
            if (yPos > dy)
            {
                // Yes; wrap it.
                if ((pButton->fsStyle & BTNS_SEP) &&
                    yPos - TBGetSepHeight(ptb, pButton) > yPosWrap)
                {
                    yPosWrap = yPos - TBGetSepHeight(ptb, pButton); // wrap at first in next col.
                }
                else if (yPos - dyButton > yPosWrap)
                    yPosWrap = yPos - dyButton; // wrap at first in next col.

                if (xPos + ptb->iButWidth <= ptb->sizeBound.cx)
                    xPos += ptb->iButWidth;
                yPos = dyButton;
                cCols++;
                pBtnPrev->fsState |= TBSTATE_WRAP;

                DEBUG_CODE( cItemsPerCol = 0; )
            }
           // button in bounds gets handled above.
            pBtnPrev = pButton; // save previous for wrap point
        }
    }
    yPos = yPosWrap ? yPosWrap : yPos;
    if (pCols)
        *pCols = cCols;
    ptb->rc.left = 0;
    ptb->rc.right = xPos + ptb->iButWidth;
    ptb->rc.top = 0;
    ptb->rc.bottom = yPos;

    if (lpRect)
        CopyRect(lpRect, &ptb->rc);

    InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
}

/**** WrapToolbar: * The buttons in the toolbar is layed out from left to right,
 * top to bottom. If adding another button to the current row,
 * while computing the layout, would cause that button to extend
 * beyond the right edge or the client area, then locate a break-
 * point (marked with the TBSTATE_WRAP flag). A break-point is:
 *
 * a) The right-most separator on the current row.
 *
 * b) The right-most button if there is no separator on the current row.
 *
 * A new row is also started at the end of any button group (sequence
 * of buttons that are delimited by separators) that are taller than
 * or equal to two rows.
 */

void WrapToolbar(PTBSTATE ptb, int dx, LPRECT lpRect, int *pRows)
{
    BOOL fInvalidate = FALSE;
    LPTBBUTTONDATA pButton, pBtnT, pBtnLast;
    LPTBBUTTONDATA pbtnLastVisible = NULL;
    LPTBBUTTONDATA pbtnPrev = NULL;
    BOOL fLastVisibleWrapped = FALSE;
    int xPos, yPos, xMax;
    int dyButton;
    BOOL bWrapAtNextSeparator = FALSE;

    ASSERT(!(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL));
    TraceMsg(TF_TOOLBAR, "Toolbar: calculating WrapToolbar");

    if (ptb->iNumButtons == 0) {
        // no buttons, so we're not going to go through the loop below; initialize 
        // dyButton to 0 so that we fill in lpRect with 0 height.  this fixes ideal 
        // size calculation for empty toolbars (NT5 #180430)
        dyButton = 0;
    } else {
        if (dx < ptb->iButWidth) {
            // dx must be at least the button width, otherwise the final
            // rect is mis-calculated and will be too big.
            dx = ptb->iButWidth;
        }
        dyButton = ptb->iButHeight;
    }

    xMax = 0;
    xPos = ptb->xFirstButton;
    yPos = ptb->iYPos;
    pBtnLast = &(ptb->Buttons[ptb->iNumButtons]);
    ptb->szCached.cx = -1;
    ptb->szCached.cy = -1;

    if (pRows)
        (*pRows)=1;

    for (pButton = ptb->Buttons; pButton < pBtnLast; pButton++)
    {
        // we nuke the wrap state at the start of the loop.
        // so we don't know if/when we are adding on a wrap bit that wasn't there
        // before.  we overstep the button, then back up when we've gone too far,
        // so we can't simply keep the at the start of the loop
        // we need to keep it over to the next iteration
        BOOL fNextLastVisibleWrapped = (pButton->fsState & TBSTATE_WRAP);
        LPTBBUTTONDATA pbtnSav = pButton;

        pButton->fsState &= ~TBSTATE_WRAP;

        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            LPTBBUTTONDATA pbtnNextLastVisible = pButton;

            xPos += TBWidthOfButton(ptb, pButton, NULL) + ptb->cxButtonSpacing;

            // Is this a normal button and is the button out of bounds?
            if (!(pButton->fsStyle & BTNS_SEP) && (xPos > dx)) {

                // Yes; wrap it.  Go back to the first non-hidden separator
                // as a break-point candidate.
                for (pBtnT=pButton;
                     pBtnT>ptb->Buttons && !(pBtnT->fsState & TBSTATE_WRAP);
                     pBtnT--)
                {
                    if ((pBtnT->fsStyle & BTNS_SEP) &&
                        !(pBtnT->fsState & TBSTATE_HIDDEN))
                    {
                        yPos += (TBGetSepHeight(ptb, pBtnT)) + dyButton + ptb->cyButtonSpacing;
                        bWrapAtNextSeparator = FALSE;
                        if (pRows)
                            (*pRows)++;

                        goto SetWrapHere;
                    }
                }

                pBtnT = pButton;

                // Are we at the first button?
                if (pButton != ptb->Buttons) {
                    // No; back up to first non-hidden button
                    do {
                        pBtnT--;
                    } while ((pBtnT>ptb->Buttons) &&
                             (pBtnT->fsState & TBSTATE_HIDDEN));

                    // Is it already wrapped?
                    if (pBtnT->fsState & TBSTATE_WRAP)
                    {
                        // Yes; wrap the button we were looking at originally
                        pBtnT = pButton;
                    }
                }

                // Wrap at the next separator because we've now wrapped in the middle
                // of a group of buttons.
                bWrapAtNextSeparator = TRUE;
                yPos += dyButton + ptb->cyButtonSpacing;

SetWrapHere:
                pBtnT->fsState |= TBSTATE_WRAP;

                // find out if this wrap bit is new...
                // it isn't if this button was the last visible button
                // and that last visible button started off wrapped
                if (pBtnT != pbtnLastVisible || !fLastVisibleWrapped)
                    fInvalidate = TRUE;

                xPos = ptb->xFirstButton;
                pButton = pBtnT;

                // Count another row.
                if (pRows)
                    (*pRows)++;
            }
            else
            {
                // No; this is a separator (in or out of bounds) or a button that is in-bounds.

                if (pButton->fsStyle & BTNS_SEP)
                {
                    if (ptb->ci.style & CCS_VERT)
                    {
                        if (pbtnPrev && !(pbtnPrev->fsState & TBSTATE_WRAP))
                        {
                            pbtnPrev->fsState |= TBSTATE_WRAP;
                            yPos += dyButton + ptb->cyButtonSpacing;
                        }
                        xPos = ptb->xFirstButton;
                        yPos += TBGetSepHeight(ptb, pButton);
                        pButton->fsState |= TBSTATE_WRAP;
                        if (pRows)
                            (*pRows)++;
                    }
                    else if (bWrapAtNextSeparator)
                    {
                        bWrapAtNextSeparator = FALSE;
                        pButton->fsState |= TBSTATE_WRAP;
                        xPos = ptb->xFirstButton;
                        yPos += dyButton + (TBGetSepHeight(ptb, pButton)) + ptb->cyButtonSpacing;
                        if (pRows)
                            (*pRows)+=2;
                    }
                }

                // This button is visible and it's one we cached at the top of the loop
                // set it for the next loop
                if (pButton == pbtnNextLastVisible) {
                    ASSERT(!(pButton->fsState & TBSTATE_HIDDEN));
                    if (!(pButton->fsState & TBSTATE_HIDDEN)) {

                        // we don't know that we're not going to re-wrap an item that was initially wrapped
                        // until this point
                        if (pbtnLastVisible && fLastVisibleWrapped && !(pbtnLastVisible->fsState & TBSTATE_WRAP))
                            fInvalidate = TRUE;

                        pbtnLastVisible = pButton;
                        fLastVisibleWrapped = fNextLastVisibleWrapped;
                    }
                }
            }
            if (!(pButton->fsStyle&BTNS_SEP))
                xMax = max(xPos, xMax);

            pbtnPrev = pbtnSav;
        }
    }

    if (lpRect)
    {
        lpRect->left = 0;
        lpRect->right = xMax;
        lpRect->top = 0;
        lpRect->bottom = yPos + ptb->iYPos + dyButton;
    }

    if (fInvalidate)
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
}


// only called from TB_SETROWS so no worry's about TBSTYLE_EX_MULTICOLUMN
BOOL BoxIt(PTBSTATE ptb, int height, BOOL fLarger, LPRECT lpRect)
{
    int dx, bwidth;
    int rows, prevRows, prevWidth;
    RECT rcCur;

    if (height<1)
        height = 1;

    rows = CountRows(ptb);
    if (height==rows || ptb->iNumButtons==0)
    {
        GetClientRect(ptb->ci.hwnd, lpRect);
        return FALSE;
    }

    bwidth = ptb->iButWidth + ptb->cxButtonSpacing;
    prevRows = ptb->iNumButtons+1;
    prevWidth = bwidth;
    for (rows=height+1, dx = bwidth; rows>height;dx+=bwidth/4)
    {
        WrapToolbar(ptb, dx, &rcCur, &rows);
        if (rows<prevRows && rows>height)
        {
            prevWidth = dx;
            prevRows = rows;
        }
    }

    if (rows<height && fLarger)
    {
        WrapToolbar(ptb, prevWidth, &rcCur, NULL);
    }

    if (lpRect)
        *lpRect = rcCur;

    return TRUE;
}


int PositionFromID(PTBSTATE ptb, LONG_PTR id)
{
    int i;

    // Handle case where this is sent at the wrong time..
    if (ptb == NULL || id == -1)
        return -1;

    // note, we don't skip separators, so you better not have conflicting
    // cmd ids and separator ids.
    for (i = 0; i < ptb->iNumButtons; i++)
        if (ptb->Buttons[i].idCommand == id)
            return i;       // position found

    return -1;      // ID not found!
}

// check a radio button by button index.
// the button matching idCommand was just pressed down.  this forces
// up all other buttons in the group.
// this does not work with buttons that are forced up with

void MakeGroupConsistant(PTBSTATE ptb, int idCommand)
{
    int i, iFirst, iLast, iButton;
    int cButtons = ptb->iNumButtons;
    LPTBBUTTONDATA pAllButtons = ptb->Buttons;

    iButton = PositionFromID(ptb, idCommand);

    if (iButton < 0)
        return;

    // assertion

//    if (!(pAllButtons[iButton].fsStyle & BTNS_CHECK))
//  return;

    // did the pressed button just go down?
    if (!(pAllButtons[iButton].fsState & TBSTATE_CHECKED))
        return;         // no, can't do anything

    // find the limits of this radio group

    // there was a bug here since win95 days -- ; there was no ; at the end of for loop
    // and if was part of it -- some apps may rely on that (reljai 6/16/98)
    for (iFirst = iButton; (iFirst > 0) && (pAllButtons[iFirst].fsStyle & BTNS_GROUP); iFirst--);
    
    if (!(pAllButtons[iFirst].fsStyle & BTNS_GROUP))
        iFirst++;

    cButtons--;
    for (iLast = iButton; (iLast < cButtons) && (pAllButtons[iLast].fsStyle & BTNS_GROUP); iLast++);

    if (!(pAllButtons[iLast].fsStyle & BTNS_GROUP))
        iLast--;

    // search for the currently down button and pop it up
    for (i = iFirst; i <= iLast; i++) {
        if (i != iButton) {
            // is this button down?
            if (pAllButtons[i].fsState & TBSTATE_CHECKED) {
                pAllButtons[i].fsState &= ~TBSTATE_CHECKED;     // pop it up
                TBInvalidateButton(ptb, i, TRUE);
                break;          // only one button is down right?
            }
        }
    }
}

void DestroyStrings(PTBSTATE ptb)
{
    PTSTR *p;
    PTSTR end = 0, start = 0;
    int i;

    p = ptb->pStrings;
    for (i = 0; i < ptb->nStrings; i++) {
        if (!((*p < end) && (*p > start))) {
            start = (*p);
            end = start + (LocalSize((HANDLE)*p) / sizeof(TCHAR));
            LocalFree((HANDLE)*p);
        }
    p++;
    }

    LocalFree((HANDLE)ptb->pStrings);
}

// gets the iString from pStrings and copies it to pszText.
// returns the lstrlen.
// pszText can be null to just fetch the length.
int TBGetString(PTBSTATE ptb, int iString, int cchText, LPTSTR pszText)
{
    int iRet = -1;
    if (iString < ptb->nStrings) 
    {
        iRet = lstrlen(ptb->pStrings[iString]);
        if (pszText)
        {
            lstrcpyn(pszText, ptb->pStrings[iString], cchText);
        }
    }

    return iRet;
}

// gets the iString from pStrings and copies it to pszText.
// returns the lstrlen.
// pszText can be null to just fetch the length.
int TBGetStringA(PTBSTATE ptb, int iString, int cchText, LPSTR pszText)
{
    int iRet = -1;
    if (iString < ptb->nStrings) 
    {

        iRet = lstrlenW(ptb->pStrings[iString]);
        if (pszText) 
        {
            WideCharToMultiByte (CP_ACP, 0, ptb->pStrings[iString],
                                 -1, pszText, cchText, NULL, NULL);
        }
    }

    return iRet;
}

#define MAXSTRINGSIZE 1024
int TBAddStrings(PTBSTATE ptb, WPARAM wParam, LPARAM lParam)
{
    int i = 0,j = 0, cxMax = 0;
    LPTSTR lpsz;
    PTSTR  pString, pStringAlloc, psz;
    int numstr;
    PTSTR *pFoo;
    PTSTR *pOffset;
    TCHAR cSeparator;
    int len;

    // read the string as a resource
    if (wParam != 0) {
        pString = (PTSTR)LocalAlloc(LPTR, (MAXSTRINGSIZE * sizeof (TCHAR)));
        if (!pString)
            return -1;
        i = LoadString((HINSTANCE)wParam, LOWORD(lParam), (LPTSTR)pString, MAXSTRINGSIZE);
        if (!i) {
            LocalFree(pString);
            return -1;
        }
        // realloc string buffer to actual needed size
        psz = (PTSTR)LocalReAlloc(pString, (i+1) * sizeof (TCHAR), LMEM_MOVEABLE);
        if (psz)
            pString = psz;

        // convert separators to '\0' and count number of strings
        cSeparator = *pString;

        for (numstr = 0, psz = pString + 1, i--; i; i--, psz++) 
        {
            if (*psz == cSeparator) 
            {
                if (i != 1)     // We don't want to count the second terminator as another string
                    numstr++;

                *psz = 0;   // terminate with 0
            }
            // shift string to the left to overwrite separator identifier
            *(psz - 1) = *psz;
        }
    }
    // read explicit string.  copy it into local memory, too.
    else {

        // Common mistake is to forget to check the return value of
        // LoadLibrary and accidentally pass wParam=NULL.
        if (IS_INTRESOURCE(lParam))
            return -1;

        // find total length and number of strings
        for (i = 0, numstr = 0, lpsz = (LPTSTR)lParam;;) {
            i++;
            if (*lpsz == 0) {
                numstr++;
                if (*(lpsz + 1) == 0)
                    break;
            }
            lpsz++;
        }

        pString = (PTSTR)LocalAlloc(LPTR, (i * sizeof (TCHAR)));
        if (!pString)
            return -1;
        hmemcpy(pString, (void *)lParam, i * sizeof(TCHAR));
    }

    pStringAlloc = pString;         // in case something bad happens

    // make room for increased string pointer table
    pFoo = (PTSTR *)CCLocalReAlloc(ptb->pStrings,
            (ptb->nStrings + numstr) * sizeof(PTSTR));
    if (!pFoo) {
        goto Failure;
    }

    ptb->pStrings = pFoo;
    // pointer to next open slot in string index table.
    pOffset = ptb->pStrings + ptb->nStrings;

    for (i = 0; i < numstr; i++, pOffset++)
    {
        *pOffset = pString;
        len = lstrlen(pString);
        pString += len + 1;
    }
    // is the world big enough to handle the larger buttons?
    i = ptb->nStrings;
    ptb->nStrings += numstr;
    if (!TBRecalc(ptb))
    {
        ptb->nStrings -= numstr;

        // back out changes.
        pFoo = (PTSTR *)CCLocalReAlloc(ptb->pStrings,
                    ptb->nStrings * sizeof(PTSTR));
        if (pFoo || (ptb->nStrings == 0))
            ptb->pStrings = pFoo;
         // don't get mad if pFoo == NULL; it means the shrink failed, no big deal

Failure:
        LocalFree(pStringAlloc);
        return -1;
    }

    return i;               // index of first added string
}

void MapToStandardBitmaps(HINSTANCE *phinst, UINT_PTR *pidBM, int *pnButtons)
{
    if (*phinst == HINST_COMMCTRL) {
        *phinst = g_hinst;

        // low 2 bits are coded M(mono == ~color) L(large == ~small)
        //  0 0   -> color small
        //  0 1   -> color large
        //  ...
        //  1 1   -> mono  large

        switch (*pidBM)
        {
        case IDB_STD_SMALL_COLOR:
        case IDB_STD_LARGE_COLOR:
        case IDB_STD_SMALL_MONO:
        case IDB_STD_LARGE_MONO:
            *pidBM = IDB_STDTB_SMALL_COLOR + (*pidBM & 1);
            *pnButtons = STD_PRINT + 1;
            break;

        case IDB_HIST_SMALL_COLOR:
        case IDB_HIST_LARGE_COLOR:
        //case IDB_HIST_SMALL_MONO:
        //case IDB_HIST_LARGE_MONO:
            *pidBM = IDB_HISTTB_SMALL_COLOR + (*pidBM & 1);
            *pnButtons = HIST_LAST + 1;
            break;

        case IDB_VIEW_SMALL_COLOR:
        case IDB_VIEW_LARGE_COLOR:
        case IDB_VIEW_SMALL_MONO:
        case IDB_VIEW_LARGE_MONO:
            *pidBM = IDB_VIEWTB_SMALL_COLOR + (*pidBM & 1);
            *pnButtons = VIEW_NEWFOLDER + 1;
            break;
        }
    }
}

//
//  the PBITMAP points to the BITMAP structure that was GetObject'd from
//  the hbm, except that pbm->bmWidth and pbm->bmHeight have been adjusted
//  to represent the *desired* height and width, not the actual height
//  and width.
//
HBITMAP _CopyBitmap(PTBSTATE ptb, HBITMAP hbm, PBITMAP pbm)
{
    HBITMAP hbmCopy = NULL;
    HDC hdcWin;
    HDC hdcSrc, hdcDest;

    // Old code called CreateColorBitmap, which is bad on multimon systems
    // because it will create a bitmap that ImageList_AddMasked can't handle,
    // resulting in disabled toolbar buttons looking bad.

    // so we have to create the bitmap copy in the same format as the source

    hdcWin = GetDC(ptb->ci.hwnd);
    hdcSrc = CreateCompatibleDC(hdcWin);
    hdcDest = CreateCompatibleDC(hdcWin);
    if (hdcWin && hdcSrc && hdcDest) {
        SelectObject(hdcSrc, hbm);

        if (pbm->bmBits) {
            // Source was a DIB section.  Create a DIB section in the same
            // color format with the same palette.
            //
            // Man, creating a DIB section is so annoying.

            struct {                    // Our private version of BITMAPINFO
                BITMAPINFOHEADER bmiHeader;
                RGBQUAD bmiColors[256];
            } bmi;
            UINT cBitsPixel;
            LPVOID pvDummy;

            ZeroMemory(&bmi.bmiHeader, sizeof(bmi.bmiHeader));

            bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
            bmi.bmiHeader.biWidth = pbm->bmWidth;
            bmi.bmiHeader.biHeight = pbm->bmHeight;
            bmi.bmiHeader.biPlanes = 1;

            // DIB color depths must be exactly 1, 4, 8 or 24.
            cBitsPixel = pbm->bmPlanes * pbm->bmBitsPixel;
            if (cBitsPixel <= 1)
                bmi.bmiHeader.biBitCount = 1;
            else if (cBitsPixel <= 4)
                bmi.bmiHeader.biBitCount = 4;
            else if (cBitsPixel <= 8)
                bmi.bmiHeader.biBitCount = 8;
            else
                goto CreateDDB; // ImageList_AddMasked doesn't like DIBs deeper than 8bpp

            // And get the color table too
            ASSERT(bmi.bmiHeader.biBitCount <= 8);
            bmi.bmiHeader.biClrUsed = GetDIBColorTable(hdcSrc, 0, 1 << bmi.bmiHeader.biBitCount, bmi.bmiColors);

            ASSERT(bmi.bmiHeader.biCompression == BI_RGB);
            ASSERT(bmi.bmiHeader.biSizeImage == 0);

            hbmCopy = CreateDIBSection(hdcWin, (LPBITMAPINFO)&bmi, DIB_RGB_COLORS, &pvDummy, NULL, 0);

        } else {
            // Source was a DDB.  Create a duplicate DDB.
        CreateDDB:
            // Since the caller may have dorked the bmWidth,
            // we have to recompute the bmWidthBytes, because GDI
            // gets mad if it's not exactly right, even in the bmBits == NULL
            // case.

            pbm->bmBits = NULL;
            pbm->bmWidthBytes = ((pbm->bmBitsPixel * pbm->bmWidth + 15) >> 4) << 1;
            hbmCopy = CreateBitmapIndirect(pbm);
        }

        SelectObject(hdcDest, hbmCopy);

        // fill the background
        PatB(hdcDest, 0, 0, pbm->bmWidth, pbm->bmHeight, g_clrBtnFace);

        BitBlt(hdcDest, 0, 0, pbm->bmWidth, pbm->bmHeight,
               hdcSrc, 0, 0, SRCCOPY);

    }

    if (hdcWin)
        ReleaseDC(ptb->ci.hwnd, hdcWin);

    if (hdcSrc)
        DeleteDC(hdcSrc);
    if (hdcDest)
        DeleteDC(hdcDest);
    return hbmCopy;
}

BOOL TBAddBitmapToImageList(PTBSTATE ptb, PTBBMINFO pTemp)
{
    HBITMAP hbm = NULL, hbmTemp = NULL;
    HIMAGELIST himl = TBGetImageList(ptb, HIML_NORMAL, 0);
    BOOL bSkipFixup = FALSE;
    if (!himl)
    {
        himl = ImageList_Create(ptb->iDxBitmap, ptb->iDyBitmap, ILC_MASK | ILC_COLOR32, 4, 4);
        if (!himl)
            return(FALSE);

        TBSetImageList(ptb, HIML_NORMAL, 0, himl);
        ImageList_SetBkColor(himl, (ptb->ci.style & TBSTYLE_TRANSPARENT) ? CLR_NONE : g_clrBtnFace);
    }

    if (pTemp->hInst)
    {
        // can't use LoadImage(..., LR_MAP3DCOLORS) - more than 3 colors
        hbm = hbmTemp = CreateMappedBitmap(pTemp->hInst, pTemp->wID, CMB_DIBSECTION, NULL, 0);

        // fixup is converting 32bit DIBs to DDB, which breaks icons in <32bit color.
        // pfortier: need to figure out the proper fixup mechanism for >8bit bitmaps.
        // for now, assume that bitmap resources from comctl32 don't need this.
        if (pTemp->hInst == g_hinst)
            bSkipFixup = TRUE;
    }
    else if (pTemp->wID)
    {
        hbm = (HBITMAP)pTemp->wID;
    }

    if (hbm && !bSkipFixup)
    {

        //
        // Fix up bitmaps that aren't iDxBitmap x iDyBitmap
        //
        BITMAP bm;

        GetObject( hbm, sizeof(bm), &bm);

        if (bm.bmWidth < ptb->iDxBitmap) {
            bm.bmWidth = ptb->iDxBitmap;
        }

        if (bm.bmHeight < ptb->iDyBitmap) {
            bm.bmHeight = ptb->iDyBitmap;
        }

        // The error cases we are catching are:
        // If the pTemp->nButtons is 0 then we assume there is one button
        // If width of the bitmap is less than what it is supposed to be, we fix it.
        if (!pTemp->nButtons)
            bm.bmWidth = ptb->iDxBitmap;
        else if (pTemp->nButtons > (bm.bmWidth / ptb->iDxBitmap))
            bm.bmWidth = ptb->iDxBitmap * pTemp->nButtons;

        // Must preserve color depth to keep ImageList_AddMasked happy
        // And if we started with a DIB section, then create a DIB section.
        // (Curiously, CopyImage does not preserve DIB-ness.)
        hbm = (HBITMAP)_CopyBitmap(ptb, hbm, &bm);
    }

    // AddMasked parties on the bitmap, so we want to use a local copy
    if (hbm) {
        ImageList_AddMasked(himl, hbm, g_clrBtnFace);

        DeleteObject(hbm);
    }

    if (hbmTemp) {
        DeleteObject(hbmTemp);
    }

    return(TRUE);

}

void TBBuildImageList(PTBSTATE ptb)
{
    int i;
    PTBBMINFO pTemp;
    HIMAGELIST himl;

    ptb->fHimlValid = TRUE;

    // is the parent dealing natively with imagelists?  if so,
    // don't do this back compat building
    if (ptb->fHimlNative)
        return;

    himl = TBSetImageList(ptb, HIML_NORMAL, 0, NULL);
    ImageList_Destroy(himl);

    for (i = 0, pTemp = ptb->pBitmaps; i < ptb->nBitmaps; i++, pTemp++)
    {
        TBAddBitmapToImageList(ptb, pTemp);
    }

}

/* Adds a new bitmap to the list of BMs available for this toolbar.
 * Returns the index of the first button in the bitmap or -1 if there
 * was an error.
 */
int AddBitmap(PTBSTATE ptb, int nButtons, HINSTANCE hBMInst, UINT_PTR idBM)
{
    PTBBMINFO pTemp;
    int nBM, nIndex;

    // map things to the standard toolbar images
    if (hBMInst == HINST_COMMCTRL)        // -1
    {
        // set the proper dimensions...
        if (idBM & 1)
            SetBitmapSize(ptb, LARGE_DXYBITMAP, LARGE_DXYBITMAP);
        else
            SetBitmapSize(ptb, SMALL_DXYBITMAP, SMALL_DXYBITMAP);

        MapToStandardBitmaps(&hBMInst, &idBM, &nButtons);
    }

    if (ptb->pBitmaps)
    {
      /* Check if the bitmap has already been added
       */
        for (nBM=ptb->nBitmaps, pTemp=ptb->pBitmaps, nIndex=0;
            nBM>0; --nBM, ++pTemp)
        {
            if (pTemp->hInst==hBMInst && pTemp->wID==idBM)
            {
                /* We already have this bitmap, but have we "registered" all
                 * the buttons in it?
                 */
                if (pTemp->nButtons >= nButtons)
                    return(nIndex);
                if (nBM == 1)
                {
                /* If this is the last bitmap, we can easily increase the
                 * number of buttons without messing anything up.
                 */
                    pTemp->nButtons = nButtons;
                    return(nIndex);
                }
            }

            nIndex += pTemp->nButtons;
        }

    }

    pTemp = (PTBBMINFO)CCLocalReAlloc(ptb->pBitmaps,
            (ptb->nBitmaps + 1)*sizeof(TBBMINFO));
    if (!pTemp)
        return(-1);
    ptb->pBitmaps = pTemp;

    pTemp = ptb->pBitmaps + ptb->nBitmaps;

    pTemp->hInst = hBMInst;
    pTemp->wID = idBM;
    pTemp->nButtons = nButtons;

    if (!TBAddBitmapToImageList(ptb, pTemp))
        return(-1);

    ++ptb->nBitmaps;

    for (nButtons=0, --pTemp; pTemp>=ptb->pBitmaps; --pTemp)
        nButtons += pTemp->nButtons;


    return(nButtons);
}

/* Adds a bitmap to the list of  BMs available for this
 * toolbar. Returns the index of the first button in the bitmap or -1 if there
 * was an error.
 */

int TBLoadImages(PTBSTATE ptb, UINT_PTR id, HINSTANCE hinst)
{
    int iTemp = 0;
    TBBMINFO bmi;
    HIMAGELIST himl;

    MapToStandardBitmaps(&hinst, &id, &iTemp);

    bmi.hInst = hinst;
    bmi.wID = id;
    bmi.nButtons = iTemp;

    himl = TBGetImageList(ptb, HIML_NORMAL, 0);
    if (himl)
        iTemp = ImageList_GetImageCount(himl);
    else
        iTemp = 0;

    if (!TBAddBitmapToImageList(ptb, &bmi))
        return(-1);

    ptb->fHimlNative = TRUE;
    return iTemp;
}

BOOL ReplaceBitmap(PTBSTATE ptb, LPTBREPLACEBITMAP lprb)
{
    int nBM;
    PTBBMINFO pTemp;

    int iTemp;

    MapToStandardBitmaps(&lprb->hInstOld, &lprb->nIDOld, &iTemp);
    MapToStandardBitmaps(&lprb->hInstNew, &lprb->nIDNew, &lprb->nButtons);

    for (nBM=ptb->nBitmaps, pTemp=ptb->pBitmaps;
         nBM>0; --nBM, ++pTemp)
    {
        if (pTemp->hInst==lprb->hInstOld && pTemp->wID==lprb->nIDOld)
        {
            // number of buttons must match
            pTemp->hInst = lprb->hInstNew;
            pTemp->wID = lprb->nIDNew;
            pTemp->nButtons = lprb->nButtons;
            TBInvalidateImageList(ptb);
            return TRUE;
        }
    }

    return FALSE;
}


void TBInvalidateItemRects(PTBSTATE ptb)
{
    // Invalidate item rect cache
    ptb->fItemRectsValid = FALSE;

    // Invalidate the tooltips
    ptb->fTTNeedsFlush = TRUE;

    // Invalidate the ideal size cache
    ptb->szCached.cx = -1;
    ptb->szCached.cy = -1;
}

void FlushToolTipsMgrNow(PTBSTATE ptb) {

    // change all the rects for the tool tips mgr.  this is
    // cheap, and we don't do it often, so go ahead
    // and do them all.
    if(ptb->hwndToolTips) {
        UINT i;
        TOOLINFO ti;
        LPTBBUTTONDATA pButton;

        ti.cbSize = SIZEOF(ti);
        ti.hwnd = ptb->ci.hwnd;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        for ( i = 0, pButton = ptb->Buttons;
             i < (UINT)ptb->iNumButtons;
             i++, pButton++) {

            if (!(pButton->fsStyle & BTNS_SEP)) {
                ti.uId = pButton->idCommand;

                if (!TB_GetItemRect(ptb, i, &ti.rect) ||
                   ((ptb->dwStyleEx & TBSTYLE_EX_HIDECLIPPEDBUTTONS) && TBIsRectClipped(ptb, &ti.rect))) {

                    ti.rect.left = ti.rect.right = ti.rect.top = ti.rect.bottom = 0;
                }

                SendMessage(ptb->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM)((LPTOOLINFO)&ti));
            }
        }

        ptb->fTTNeedsFlush = FALSE;
    }
}

BOOL TBReallocButtons(PTBSTATE ptb, UINT uButtons)
{
    LPTBBUTTONDATA ptbbNew;
    LPTBBUTTONDATA pOldCaptureButton;

    if (!ptb || !ptb->uStructSize)
        return FALSE;

    // When we realloc the Button array, make sure all interior pointers
    //  move with it.  (This should probably be an index.)
    pOldCaptureButton = ptb->pCaptureButton;

    // realloc the button table
    ptbbNew = (LPTBBUTTONDATA)CCLocalReAlloc(ptb->Buttons,
                                             uButtons * sizeof(TBBUTTONDATA));

    if (!ptbbNew) return FALSE;

    if (pOldCaptureButton)
        ptb->pCaptureButton = (LPTBBUTTONDATA)(
                        (LPBYTE)ptbbNew +
                          ((LPBYTE)pOldCaptureButton - (LPBYTE)ptb->Buttons));
    ptb->Buttons = ptbbNew;

    return TRUE;
}

BOOL TBInsertButtons(PTBSTATE ptb, UINT uWhere, UINT uButtons, LPTBBUTTON lpButtons, BOOL fNative)
{
    LPTBBUTTONDATA pOut;
    LPTBBUTTONDATA ptbbIn;
    UINT    uAdded;
    UINT    uStart;
    BOOL fRecalc;
    int idHot = -1;

    if (!TBReallocButtons(ptb, ptb->iNumButtons + uButtons))
        return FALSE;

    TB_CancelTipTrack(ptb);

    // if where points beyond the end, set it at the end
    if (uWhere > (UINT)ptb->iNumButtons)
        uWhere = ptb->iNumButtons;

    // Need to save these since the values gues toasted.
    uAdded = uButtons;
    uStart = uWhere;

    // Correct the hot item when we add something something. Since the hot item is index based, the index
    // has probrably changed
    if (ptb->iHot >= 0 && ptb->iHot < ptb->iNumButtons)
        idHot = ptb->Buttons[ptb->iHot].idCommand;

    // move buttons above uWhere up uButton spaces
    // the uWhere gets inverted and counts to zero..
    //
    // REVIEW: couldn't this be done with MoveMemory?
    //  MoveMemory(&ptb->Buttons[uWhere], &ptb->Buttons[uWhere+uButtons], sizeof(ptb->Buttons[0])*(ptb->iNumButtons - uWhere));
    //
    for (ptbbIn = &ptb->Buttons[ptb->iNumButtons-1], pOut = ptbbIn+uButtons,
         uWhere=(UINT)ptb->iNumButtons-uWhere; uWhere>0;
     --ptbbIn, --pOut, --uWhere)
        *pOut = *ptbbIn;

    // only need to recalc if there are strings & room enough to actually show them
    fRecalc = (TBHasStrings(ptb) && ((ptb->ci.style & TBSTYLE_LIST) || ((ptb->iDyBitmap + ptb->cyPad + g_cyEdge) < ptb->iButHeight)));

    // now do the copy.
    for (lpButtons=(LPTBBUTTON)((LPBYTE)lpButtons+ptb->uStructSize*(uButtons-1)),
        ptb->iNumButtons+=(int)uButtons;  // init
        uButtons>0; //test
        --pOut, lpButtons=(LPTBBUTTON)((LPBYTE)lpButtons-ptb->uStructSize), --uButtons)
    {
        TBInputStruct(ptb, pOut, lpButtons);

        // If this button is a seperator, then should not use the string
        // buffer passed in, because it could be bogus data.
        if (pOut->fsStyle & BTNS_SEP)
            pOut->iString = -1;

        if (TBISSTRINGPTR(pOut->iString)) 
        {
            LPTSTR psz = (LPTSTR)pOut->iString;
            if (!fNative) 
            {
                psz = ProduceWFromA(ptb->ci.uiCodePage, (LPSTR)psz);
            }
            pOut->iString = 0;
            Str_Set((LPTSTR*)&pOut->iString, psz);

            if (!fNative)
                FreeProducedString(psz);
            if (!ptb->fNoStringPool)
                fRecalc = TRUE;

            ptb->fNoStringPool = TRUE;
        }

        if(ptb->hwndToolTips && !(lpButtons->fsStyle & BTNS_SEP)) 
        {
            TOOLINFO ti;
            // don't bother setting the rect because we'll do it below
            // in TBInvalidateItemRects;
            ti.cbSize = sizeof(ti);
            ti.uFlags = 0;
            if (ptb->dwStyleEx & TBSTYLE_EX_TOOLTIPSEXCLUDETOOLBAR)
                ti.uFlags |= TTF_EXCLUDETOOLAREA;
            ti.hwnd = ptb->ci.hwnd;
            ti.uId = lpButtons->idCommand;
            ti.lpszText = LPSTR_TEXTCALLBACK;
            SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0,
                (LPARAM)(LPTOOLINFO)&ti);
        }

        if (pOut->fsStyle & BTNS_SEP && pOut->cxySep <= 0)
        {

            // Compat: Corel (Font navigator) expects the separators to be
            // 8 pixels wide.
            // as do many old apps.
            //
            // so if it's not flat or not vertical, put it to defautl to win95 size
            pOut->cxySep = g_dxButtonSep;
        }
    }

    // Re-compute layout if toolbar is wrappable.
    if ((ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN) || 
        (ptb->ci.style & TBSTYLE_WRAPABLE))
    {
        // NOTE: we used to do send ourself a message instead of call directly...
        //SendMessage(ptb->ci.hwnd, TB_AUTOSIZE, 0, 0);
        TBAutoSize(ptb);
    }

    TBInvalidateItemRects(ptb);

    // adding and removing buttons during toolbar customization shouldn't
    // result in recalcing the sizes of buttons.
    if (fRecalc && !ptb->hdlgCust)
        TBRecalc(ptb);

    //
    // Reorder notification so apps can go requery what's on the toolbar if
    // more than 1 button was added; otherwise, just say create.
    //
    if (uAdded == 1)
        NotifyWinEvent(EVENT_OBJECT_CREATE, ptb->ci.hwnd, OBJID_CLIENT,
            uWhere+1);
    else
        NotifyWinEvent(EVENT_OBJECT_REORDER, ptb->ci.hwnd, OBJID_CLIENT, 0);

    // was there a hot item before the delete?
    if (idHot != -1)
    {
        // Yes; Then update it to the current index
        ptb->iHot = PositionFromID(ptb, idHot);
    }

    TBInvalidateItemRects(ptb);

    // We need to completely redraw the toolbar at this point.
    // this MUST be done last!
    // tbrecalc and others will nuke out invalid area and we won't paint if this isn't last
    InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
    return(TRUE);
}


/* Notice that the state structure is not realloc'ed smaller at this
 * point.  This is a time optimization, and the fact that the structure
 * will not move is used in other places.
 */
BOOL DeleteButton(PTBSTATE ptb, UINT uIndex)
{
    TBNOTIFY tbn = { 0 };
    LPTBBUTTONDATA pIn, pOut;
    BOOL fRecalc;
    int idHot = -1;



    if (uIndex >= (UINT)ptb->iNumButtons)
        return FALSE;

    if (&ptb->Buttons[uIndex] == ptb->pCaptureButton) {
        if (ptb->uStructSize == 0x14)
            ptb->fRequeryCapture = TRUE;
        if (!CCReleaseCapture(&ptb->ci)) 
            return FALSE;
        ptb->pCaptureButton = NULL;
    }
    TB_CancelTipTrack(ptb);

    // Correct the hot item when we remove something. Since the hot item is index based, the index
    // has probrably changed
    if (ptb->iHot >= 0 && ptb->iHot < ptb->iNumButtons)
        idHot = ptb->Buttons[ptb->iHot].idCommand;

    // Notify Active Accessibility of the delete
    NotifyWinEvent(EVENT_OBJECT_DESTROY, ptb->ci.hwnd, OBJID_CLIENT, uIndex+1);

    // Notify client of the delete
    tbn.iItem = ptb->Buttons[uIndex].idCommand;
    TBOutputStruct(ptb, &ptb->Buttons[uIndex], &tbn.tbButton);
    CCSendNotify(&ptb->ci, TBN_DELETINGBUTTON, &tbn.hdr);

    if (TBISSTRINGPTR(ptb->Buttons[uIndex].iString))
        Str_Set((LPTSTR*)&ptb->Buttons[uIndex].iString, NULL);

    if (ptb->hwndToolTips) {
        TOOLINFO ti;

        ti.cbSize = sizeof(ti);
        ti.hwnd = ptb->ci.hwnd;
        ti.uId = ptb->Buttons[uIndex].idCommand;
        SendMessage(ptb->hwndToolTips, TTM_DELTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
    }

    --ptb->iNumButtons;

    pOut = ptb->Buttons + uIndex;

    fRecalc = (pOut->fsState & TBSTATE_WRAP);

    for (pIn = pOut + 1; uIndex<(UINT)ptb->iNumButtons; ++uIndex, ++pIn, ++pOut)
    {
        fRecalc |= (pIn->fsState & TBSTATE_WRAP);
        *pOut = *pIn;
    }

    // We need to completely recalc or redraw the toolbar at this point.
    if (((ptb->ci.style & TBSTYLE_WRAPABLE)
            || (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN)) && fRecalc)
    {
        RECT rc;
        HWND hwnd = ptb->ci.hwnd;

        if (!(ptb->ci.style & CCS_NORESIZE) && !(ptb->ci.style & CCS_NOPARENTALIGN))
            hwnd = GetParent(hwnd);

        GetWindowRect(hwnd, &rc);

        if (ptb->ci.style & TBSTYLE_WRAPABLE)
            WrapToolbar(ptb, rc.right - rc.left, &rc, NULL);
        else
            WrapToolbarCol(ptb, ptb->sizeBound.cy, &rc, NULL);
    }

    // was there a hot item before the delete?
    if (idHot != -1)
    {
        // Yes; Then update it to the current index
        ptb->iHot = PositionFromID(ptb, idHot);
    }


    InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

    TBInvalidateItemRects(ptb);

    return TRUE;
}

// move button at location iOld to location iNew, sliding everything
// after iNew UP.
BOOL TBMoveButton(PTBSTATE ptb, UINT iOld, UINT iNew)
{
    TBBUTTONDATA tbd, *ptbdOld, *ptbdNew;

    if (iOld >= (UINT)ptb->iNumButtons)
        return FALSE;

    if (iNew > (UINT)ptb->iNumButtons-1)
        iNew = (UINT)ptb->iNumButtons-1;

    if (iOld == iNew)
        return FALSE;

    TBInvalidateItemRects(ptb);

    ptbdOld = &(ptb->Buttons[iOld]);
    ptbdNew = &(ptb->Buttons[iNew]);

    tbd = *ptbdOld;

#if 0
    if (iOld < iNew)
        MoveMemory(ptbdOld+1, ptbdOld, (iNew - iOld) * SIZEOF(tbd));
    else
        MoveMemory(ptbdNew, ptbdNew+1, (iOld - iNew) * SIZEOF(tbd));
#else
    {
        TBBUTTONDATA *ptbdSrc;
        TBBUTTONDATA *ptbdDst;
        int iCount, iInc;

        if (iOld < iNew)
        {
            // move [iOld+1..iNew] to [iOld..iNew-1]
            iCount = iNew - iOld;
            iInc = 1;
            ptbdSrc = ptbdOld + 1;
            ptbdDst = ptbdOld;

            if (ptb->pCaptureButton > ptbdOld && ptb->pCaptureButton <= ptbdNew)
                ptb->pCaptureButton--;
        }
        else
        {
            ASSERT(iNew < iOld);

            // move [iNew..iOld-1] to [iNew+1..iOld]
            iCount = iOld - iNew;
            iInc = -1;
            ptbdSrc = ptbdNew + iCount - 1;
            ptbdDst = ptbdNew + iCount;

            if (ptb->pCaptureButton >= ptbdNew && ptb->pCaptureButton < ptbdOld)
                ptb->pCaptureButton++;
        }

        do {
            *ptbdDst = *ptbdSrc;
            ptbdDst += iInc;
            ptbdSrc += iInc;
            iCount--;
        } while (iCount);
    }
#endif

    *ptbdNew = tbd;

    if (ptb->pCaptureButton == ptbdOld)
        ptb->pCaptureButton = ptbdNew;

    TBAutoSize(ptb);
    InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

    return TRUE;
}


// deal with old TBBUTON structs for compatibility
void TBInputStruct(PTBSTATE ptb, LPTBBUTTONDATA pButtonInt, LPTBBUTTON pButtonExt)
{
    pButtonInt->iBitmap = pButtonExt->iBitmap;
    pButtonInt->idCommand = pButtonExt->idCommand;
    pButtonInt->fsState = pButtonExt->fsState;
    pButtonInt->fsStyle = pButtonExt->fsStyle;
    pButtonInt->cx = 0;

    if (ptb->uStructSize >= sizeof(TBBUTTON))
    {
        pButtonInt->dwData = pButtonExt->dwData;
        pButtonInt->iString = pButtonExt->iString;
    }
    else
    {
        /* It is assumed the only other possibility is the OLDBUTTON struct */
        /* We don't care about dwData */
        pButtonInt->dwData = 0;
        pButtonInt->iString = -1;
    }
}


void TBOutputStruct(PTBSTATE ptb, LPTBBUTTONDATA pButtonInt, LPTBBUTTON pButtonExt)
{
    ZeroMemory(pButtonExt, ptb->uStructSize);
    pButtonExt->iBitmap = pButtonInt->iBitmap;
    pButtonExt->idCommand = pButtonInt->idCommand;
    pButtonExt->fsState = pButtonInt->fsState;
    pButtonExt->fsStyle = pButtonInt->fsStyle;

    // We're returning cx in the bReserved field
    COMPILETIME_ASSERT(FIELD_OFFSET(TBBUTTONDATA, cx) == FIELD_OFFSET(TBBUTTON, bReserved));
    COMPILETIME_ASSERT(sizeof(pButtonInt->cx) <= sizeof(pButtonExt->bReserved));
    ((LPTBBUTTONDATA)pButtonExt)->cx = pButtonInt->cx;

    if (ptb->uStructSize >= sizeof(TBBUTTON))
    {
        pButtonExt->dwData = pButtonInt->dwData;
        pButtonExt->iString = pButtonInt->iString;
    }
}

void TBOnButtonStructSize(PTBSTATE ptb, UINT uStructSize)
{
    /* You are not allowed to change this after adding buttons.
    */
    if (ptb && !ptb->iNumButtons)
    {
        ptb->uStructSize = uStructSize;
    }
}

void TBAutoSize(PTBSTATE ptb)
{
    HWND hwndParent;
    RECT rc;
    int nTBThickness = 0;

    if (ptb->fRedrawOff) {
        // redraw is off; defer autosize until redraw is turned back on
        ptb->fRecalc = TRUE;
        return;
    }

    if (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN)
    {
        ASSERT(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL);
        nTBThickness = ptb->iButWidth * CountCols(ptb) + g_cyEdge * 2;
    }
    else
        nTBThickness = (ptb->iButHeight + ptb->cyButtonSpacing) * CountRows(ptb) + g_cxEdge * 2 - ptb->cyButtonSpacing;

    hwndParent = GetParent(ptb->ci.hwnd);
    if (!hwndParent)
        return;

    if ((ptb->ci.style & TBSTYLE_WRAPABLE)
                    || (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN))
    {
        RECT rcNew;

        if ((ptb->ci.style & CCS_NORESIZE) || (ptb->ci.style & CCS_NOPARENTALIGN))
            GetWindowRect(ptb->ci.hwnd, &rc);
        else
            GetWindowRect(hwndParent, &rc);

        if (ptb->ci.style & TBSTYLE_WRAPABLE)
            WrapToolbar(ptb, rc.right - rc.left, &rcNew, NULL);
        else
            WrapToolbarCol(ptb, ptb->sizeBound.cy, &rcNew, NULL);

        // Some sample app found a bug in our autosize code which this line
        // fixes. Unfortunately Carbon Copy 32 (IE4 bug 31943) relies on the
        // broken behavior and fixing this clips the buttons.
        //
        //nTBThickness = rcNew.bottom - rcNew.top + g_cxEdge;
    }

    if ((ptb->ci.style & TBSTYLE_WRAPABLE) ||
        (ptb->dwStyleEx & (TBSTYLE_EX_MULTICOLUMN | TBSTYLE_EX_HIDECLIPPEDBUTTONS)))
    {
        TBInvalidateItemRects(ptb);
    }

    GetWindowRect(ptb->ci.hwnd, &rc);
    MapWindowPoints(HWND_DESKTOP, hwndParent, (LPPOINT)&rc, 2);
    NewSize(ptb->ci.hwnd, nTBThickness, ptb->ci.style,
            rc.left, rc.top, rc.right, rc.bottom);
}

void TBSetStyle(PTBSTATE ptb, DWORD dwStyle)
{
    BOOL fSizeChanged = FALSE;

    if ((BOOL)(ptb->ci.style & TBSTYLE_WRAPABLE) != (BOOL)(dwStyle & TBSTYLE_WRAPABLE))
    {
        int i;
        fSizeChanged = TRUE;

        for (i=0; i<ptb->iNumButtons; i++)
            ptb->Buttons[i].fsState &= ~TBSTATE_WRAP;
    }

    ptb->ci.style = dwStyle;

    if (fSizeChanged)
        TBRecalc(ptb);

    TBAutoSize(ptb);

    TraceMsg(TF_TOOLBAR, "toolbar window style changed %x", ptb->ci.style);
}

void TBSetStyleEx(PTBSTATE ptb, DWORD dwStyleEx, DWORD dwStyleMaskEx)
{
    BOOL fSizeChanged = FALSE;

    if (dwStyleMaskEx)
        dwStyleEx = (ptb->dwStyleEx & ~dwStyleMaskEx) | (dwStyleEx & dwStyleMaskEx);

    // Second, we can validate a few of the bits:
    // Multicolumn should never be set w/o the vertical style...
    ASSERT((ptb->dwStyleEx & TBSTYLE_EX_VERTICAL) || !(ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN));
    // also can't be set with hide clipped buttons style (for now)
    ASSERT(!(ptb->dwStyleEx & TBSTYLE_EX_HIDECLIPPEDBUTTONS) || !(ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN));
    // ...but just in case someone gets it wrong, we'll set the vertical
    // style and rip off the hide clipped buttons style
    if (dwStyleEx & TBSTYLE_EX_MULTICOLUMN)
    {
        dwStyleEx |= TBSTYLE_EX_VERTICAL;
        dwStyleEx &= ~TBSTYLE_EX_HIDECLIPPEDBUTTONS;
    }

    // Then, some things need to be tweaked when they change
    if ((ptb->dwStyleEx ^ dwStyleEx) & TBSTYLE_EX_MULTICOLUMN)
    {
        int i;
        // Clear all the wrap states if we're changing multicolumn styles
        for (i = 0; i < ptb->iNumButtons; i++)
            ptb->Buttons[i].fsState &= ~TBSTATE_WRAP;

        fSizeChanged = TRUE;
    }
    if ((ptb->dwStyleEx ^ dwStyleEx) & TBSTYLE_EX_MIXEDBUTTONS)
    {
        int i;
        for (i = 0; i < ptb->iNumButtons; i++)
            (ptb->Buttons[i]).cx = 0;

        fSizeChanged = TRUE;
        
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
    }
    if ((ptb->dwStyleEx ^ dwStyleEx) & TBSTYLE_EX_HIDECLIPPEDBUTTONS)
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

    ptb->dwStyleEx = dwStyleEx;

    if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
        TBSetStyle(ptb, CCS_VERT);      // vertical sep and insert mark orientation

    if (fSizeChanged)
    {
        TBRecalc(ptb);
        TBAutoSize(ptb);
    }

    TraceMsg(TF_TOOLBAR, "toolbar window extended style changed %x", ptb->dwStyleEx);
}


LRESULT TB_OnSetImage(PTBSTATE ptb, LPTBBUTTONDATA ptbButton, int iImage)
{
    if (!ptb->fHimlNative) 
    {
        if (ptb->fHimlValid) 
        {
            if (!TBGetImageList(ptb, HIML_NORMAL, 0) ||
                iImage >= ImageList_GetImageCount(TBGetImageList(ptb, HIML_NORMAL, 0)))
            {
                return FALSE;
            }
        } 
        else 
        {

            PTBBMINFO pTemp;
            int nBitmap;
            UINT nTot;

            // we're not natively himl and we've got some invalid
            // image state, so we need to count the bitmaps ourselvesa
            pTemp = ptb->pBitmaps;
            nTot = 0;

            for (nBitmap=0; nBitmap < ptb->nBitmaps; nBitmap++)
            {
                nTot += pTemp->nButtons;
                pTemp++;
            }

            if (iImage >= (int)nTot)
                return FALSE;
        }
    }

    ptbButton->iBitmap = iImage;

    InvalidateButton(ptb, ptbButton, IsUsingCleartype());
    UpdateWindow(ptb->ci.hwnd);
    return TRUE;
}

void TB_OnDestroy(PTBSTATE ptb)
{
    HWND hwnd = ptb->ci.hwnd;
    int i;

    for (i = 0; i < ptb->iNumButtons; i++) {
        if (TBISSTRINGPTR(ptb->Buttons[i].iString))
            Str_Set((LPTSTR*)&ptb->Buttons[i].iString, NULL);
    }

    //
    // If the toolbar created tooltips, then destroy them.
    //
    if ((ptb->ci.style & TBSTYLE_TOOLTIPS) && IsWindow(ptb->hwndToolTips)) {
        DestroyWindow (ptb->hwndToolTips);
        ptb->hwndToolTips = NULL;
    }

    if (ptb->hDragProxy)
        DestroyDragProxy(ptb->hDragProxy);

    if (ptb->hbmMono)
        DeleteObject(ptb->hbmMono);

    ReleaseMonoDC(ptb);

    if (ptb->nStrings > 0)
        DestroyStrings(ptb);

    if (ptb->hfontIcon && ptb->fFontCreated)
        DeleteObject(ptb->hfontIcon);

    // only do this destroy if pBitmaps exists..
    // this is our signal that it was from an old style toolba
    // and we created it ourselves.
    if (ptb->pBitmaps)
        ImageList_Destroy(TBGetImageList(ptb, HIML_NORMAL, 0));

    if (ptb->pBitmaps)
        LocalFree(ptb->pBitmaps);

    // couldn't have created tb if pimgs creation failed
    CCLocalReAlloc(ptb->pimgs, 0);

    Str_Set(&ptb->pszTip, NULL);

    if (ptb->hTheme)
        CloseThemeData(ptb->hTheme);

    if (ptb->Buttons) LocalFree(ptb->Buttons);
    LocalFree((HLOCAL)ptb);
    SetWindowInt(hwnd, 0, 0);

    TerminateDitherBrush();

}

void TB_OnSetState(PTBSTATE ptb, LPTBBUTTONDATA ptbButton, BYTE bState, int iPos)
{
    BYTE fsState;
    fsState = bState ^ ptbButton->fsState;
    ptbButton->fsState = bState;

    if (fsState)
    {
        if (ptb->fRedrawOff)
        {
            ptb->fInvalidate = ptb->fRecalc = TRUE;
        }
        else
        {
            if (fsState & TBSTATE_HIDDEN)
            {
                InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
                TBRecalc(ptb);
            }
            else
                InvalidateButton(ptb, ptbButton, TRUE);

            NotifyWinEvent(EVENT_OBJECT_STATECHANGE, ptb->ci.hwnd, OBJID_CLIENT,
                             iPos+1);
        }
    }
}

void TB_OnSetCmdID(PTBSTATE ptb, LPTBBUTTONDATA ptbButton, UINT idCommand)
{
    UINT uiOldID;

    uiOldID = ptbButton->idCommand;
    ptbButton->idCommand = idCommand;

    //
    // If the app was using tooltips, then
    // we need to update the command id there also.
    //

    if(ptb->hwndToolTips) {
        TOOLINFO ti;

        //
        // Query the old information
        //

        ti.cbSize = sizeof(ti);
        ti.hwnd = ptb->ci.hwnd;
        ti.uId = uiOldID;
        SendMessage(ptb->hwndToolTips, TTM_GETTOOLINFO, 0,
                    (LPARAM)(LPTOOLINFO)&ti);

        //
        // Delete the old tool since we can't just
        // change the command id.
        //

        SendMessage(ptb->hwndToolTips, TTM_DELTOOL, 0,
                    (LPARAM)(LPTOOLINFO)&ti);

        //
        // Add the new tool with the new command id.
        //

        ti.uId = idCommand;
        SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0,
                    (LPARAM)(LPTOOLINFO)&ti);
    }
}



LRESULT TB_OnSetButtonInfo(PTBSTATE ptb, int idBtn, LPTBBUTTONINFO ptbbi)
{
    int iPos;
    BOOL fInvalidateAll = FALSE;

    if (ptbbi->cbSize != SIZEOF(TBBUTTONINFO))
        return 0;

    if (ptbbi->dwMask & TBIF_BYINDEX)
        iPos = idBtn;
    else
        iPos = PositionFromID(ptb, idBtn);

    if (iPos != -1)
    {
        LPTBBUTTONDATA ptbButton;
        BOOL fInvalidate = FALSE;

        ptbButton = ptb->Buttons + iPos;

        if (ptbbi->dwMask & TBIF_STYLE) {
            if ((ptbButton->fsStyle ^ ptbbi->fsStyle) & (BTNS_DROPDOWN | BTNS_WHOLEDROPDOWN))
            {
                // Width may have changed!
                fInvalidateAll = TRUE;
            }
            if ((ptbButton->fsStyle ^ ptbbi->fsStyle) & BTNS_AUTOSIZE)
                ptbButton->cx = 0;

            ptbButton->fsStyle = ptbbi->fsStyle;
            fInvalidate = TRUE;
        }

        if (ptbbi->dwMask & TBIF_STATE) {
            TB_OnSetState(ptb, ptbButton, ptbbi->fsState, iPos);
        }

        if (ptbbi->dwMask & TBIF_IMAGE) {
            TB_OnSetImage(ptb, ptbButton, ptbbi->iImage);
        }

        if (ptbbi->dwMask & TBIF_SIZE) {
            ptbButton->cx = ptbbi->cx;
            fInvalidate = TRUE;
            fInvalidateAll = TRUE;
        }

        if (ptbbi->dwMask & TBIF_TEXT) {

            // changing the text on an autosize button means recalc
            if (BTN_IS_AUTOSIZE(ptb, ptbButton)) {
                fInvalidateAll = TRUE;
                ptbButton->cx = (WORD)0;
            }

            ptb->fNoStringPool = TRUE;
            if (!TBISSTRINGPTR(ptbButton->iString)) {
                ptbButton->iString = 0;
            }

            Str_Set((LPTSTR*)&ptbButton->iString, ptbbi->pszText);
            fInvalidate = TRUE;

        }

        if (ptbbi->dwMask & TBIF_LPARAM) {
            ptbButton->dwData = ptbbi->lParam;
        }

        if (ptbbi->dwMask & TBIF_COMMAND) {
            TB_OnSetCmdID(ptb, ptbButton, ptbbi->idCommand);
        }

        if (fInvalidateAll || fInvalidate) {
            TBInvalidateItemRects(ptb);
            if (fInvalidateAll)
                InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
            else
                InvalidateButton(ptb, ptbButton, TRUE);
        }

        return TRUE;
    }

    return FALSE;
}

LRESULT TB_OnGetButtonInfo(PTBSTATE ptb, int idBtn, LPTBBUTTONINFO ptbbi)
{
    int iPos;

    if (ptbbi->cbSize != SIZEOF(TBBUTTONINFO))
        return -1;

    if (ptbbi->dwMask & TBIF_BYINDEX)
        iPos = idBtn;
    else
        iPos = PositionFromID(ptb, idBtn);
    if (iPos >= 0 && iPos < ptb->iNumButtons)
    {
        LPTBBUTTONDATA ptbButton;
        ptbButton = ptb->Buttons + iPos;

        if (ptbbi->dwMask & TBIF_STYLE) {
            ptbbi->fsStyle = ptbButton->fsStyle;
        }

        if (ptbbi->dwMask & TBIF_STATE) {
            ptbbi->fsState = ptbButton->fsState;
        }

        if (ptbbi->dwMask & TBIF_IMAGE) {
            ptbbi->iImage = ptbButton->iBitmap;
        }

        if (ptbbi->dwMask & TBIF_SIZE) {
            ptbbi->cx = (WORD) ptbButton->cx;
        }

        if (ptbbi->dwMask & TBIF_TEXT) {
            LPTSTR psz = TB_StrForButton(ptb, ptbButton);
            if (psz) {
                lstrcpyn(ptbbi->pszText, psz, ptbbi->cchText);
            }
        }

        if (ptbbi->dwMask & TBIF_LPARAM) {
            ptbbi->lParam = ptbButton->dwData;
        }

        if (ptbbi->dwMask & TBIF_COMMAND) {
            ptbbi->idCommand = ptbButton->idCommand;
        }
    } else
        iPos = -1;

    return iPos;
}

UINT GetAccelerator(LPTSTR psz)
{
    UINT ch = (UINT)-1;
    LPTSTR pszAccel = psz;
    // then prefixes are allowed.... see if it has one
    do 
    {
        pszAccel = StrChr(pszAccel, CH_PREFIX);
        if (pszAccel) 
        {
            pszAccel = FastCharNext(pszAccel);

            // handle having &&
            if (*pszAccel != CH_PREFIX)
                ch = *pszAccel;
            else
                pszAccel = FastCharNext(pszAccel);
        }
    } 
    while (pszAccel && (ch == (UINT)-1));

    return ch;
}


UINT TBButtonAccelerator(PTBSTATE ptb, LPTBBUTTONDATA ptbn)
{
    UINT ch = (UINT)-1;
    LPTSTR psz = TB_StrForButton(ptb, ptbn);

    if (psz && *psz) 
    {
        if (!(ptb->uDrawTextMask & ptb->uDrawText & DT_NOPREFIX)) 
        {
            ch = GetAccelerator(psz);
        }

        if (ch == (UINT)-1) 
        {
            // no prefix found.  use the first char
            ch = (UINT)*psz;
        }
    }
    return (UINT)ch;
}


/*----------------------------------------------------------
Purpose: Returns the number of buttons that have the passed
            in char as their accelerator

*/
int TBHasAccelerator(PTBSTATE ptb, UINT ch)
{
    int i;
    int c = 0;
    for (i = 0; i < ptb->iNumButtons; i++)
    {
        if (!ChrCmpI((WORD)TBButtonAccelerator(ptb, &ptb->Buttons[i]), (WORD)ch))
            c++;
    }

    if (c == 0)
    {
        NMCHAR nm = {0};
        nm.ch = ch;
        nm.dwItemPrev = 0;
        nm.dwItemNext = -1;

        // The duplicate accelerator is used to expand or execute a menu item,
        // if we determine that there are no items, we still want to ask the 
        // owner if there are any...

        if (CCSendNotify(&ptb->ci, TBN_MAPACCELERATOR, &nm.hdr) &&
            nm.dwItemNext != -1)
        {
            c++;
        }
    }

    return c;
}

/*----------------------------------------------------------
Purpose: Returns TRUE if the character maps to more than one
         button.

*/
BOOL TBHasDupChar(PTBSTATE ptb, UINT ch)
{
    BOOL bRet = FALSE;
    NMTBDUPACCELERATOR nmda;

    int c = 0;

    nmda.ch = ch;

    if (CCSendNotify(&ptb->ci, TBN_DUPACCELERATOR, &nmda.hdr))
    {
        bRet = nmda.fDup;
    }
    else
    {
        if (TBHasAccelerator(ptb, ch) > 1)
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Returns the index of the item whose accelerator matches
         the given character.  Starts at the current hot item.

Returns: -1 if nothing found

*/
int TBItemFromAccelerator(PTBSTATE ptb, UINT ch, BOOL * pbDup)
{
    int iRet = -1;
    int i;
    int iStart = ptb->iHot;

    NMTBWRAPACCELERATOR nmwa;
    NMCHAR nm = {0};
    nm.ch = ch;
    nm.dwItemPrev = iStart;
    nm.dwItemNext = -1;

    // Ask the client if they want to handle this keyboard press
    if (CCSendNotify(&ptb->ci, TBN_MAPACCELERATOR, &nm.hdr) &&
        (int)nm.dwItemNext > iStart && (int)nm.dwItemNext < ptb->iNumButtons)
    {
        // They handled it, so we're just going to return the position
        // that they said.
        iRet =  nm.dwItemNext;
    }
    else for (i = 0; i < ptb->iNumButtons; i++)
    {

        if ( iStart + 1 >= ptb->iNumButtons )
        {
            nmwa.ch = ch;
            if (CCSendNotify(&ptb->ci, TBN_WRAPACCELERATOR, &nmwa.hdr))
                return nmwa.iButton;
        }

        iStart += 1 + ptb->iNumButtons;
        iStart %= ptb->iNumButtons;

        if ((ptb->Buttons[iStart].fsState & TBSTATE_ENABLED) &&
            !ChrCmpI((WORD)TBButtonAccelerator(ptb, &ptb->Buttons[iStart]), (WORD)ch))
        {
            iRet = iStart;
            break;
        }

    }

    *pbDup = TBHasDupChar(ptb, ch);

    return iRet;
}


BOOL TBOnChar(PTBSTATE ptb, UINT ch)
{
    NMCHAR nm = {0};
    BOOL bDupChar;
    int iPos = TBItemFromAccelerator(ptb, ch, &bDupChar);
    BOOL fHandled = FALSE;

    // Send the notification.  Parent may want to change the next button.
    nm.ch = ch;
    nm.dwItemPrev = (0 <= ptb->iHot) ? ptb->Buttons[ptb->iHot].idCommand : -1;
    nm.dwItemNext = (0 <= iPos) ? ptb->Buttons[iPos].idCommand : -1;
    if (CCSendNotify(&ptb->ci, NM_CHAR, (LPNMHDR)&nm))
        return TRUE;

    iPos = PositionFromID(ptb, nm.dwItemNext);

    if (-1 != iPos)
    {
        DWORD dwFlags = HICF_ACCELERATOR;

        if (ptb->iHot == iPos)
            dwFlags |= HICF_RESELECT;

        if (bDupChar)
            dwFlags |= HICF_DUPACCEL;

        TBSetHotItem(ptb, iPos, dwFlags);

        if (bDupChar)
            iPos = -1;

        fHandled = TRUE;
    } else {

        // handle this here instead of VK_KEYDOWN
        // because a typical thing to do is to pop down a menu
        // which will beep when it gets the WM_CHAR resulting from
        // the VK_KEYDOWN
        switch (ch) {
        case ' ':
        case 13:
            if (ptb->iHot != -1)
            {
                LPTBBUTTONDATA ptbButton = &ptb->Buttons[ptb->iHot];
                if (TB_IsDropDown(ptbButton) &&
                    !TB_HasSplitDDArrow(ptb, ptbButton))
                {
                    iPos = ptb->iHot;
                    fHandled = TRUE;
                }
                break;
            }
        }
    }

    if (-1 != iPos) {
        LPTBBUTTONDATA ptbButton = &ptb->Buttons[iPos];
        if (TB_IsDropDown(ptbButton))
            TBToggleDropDown(ptb, iPos, FALSE);
    }

    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(ptb->ci), UISF_HIDEFOCUS | UISF_HIDEACCEL);

    return fHandled;
}


BOOL TBOnMapAccelerator(PTBSTATE ptb, UINT ch, UINT * pidCmd)
{
    int iPos;
    BOOL bDupChar;

    ASSERT(IS_VALID_WRITE_PTR(pidCmd, UINT));

    iPos = TBItemFromAccelerator(ptb, ch, &bDupChar);
    if (-1 != iPos)
    {
        *pidCmd = ptb->Buttons[iPos].idCommand;
        return TRUE;
    }
    return FALSE;
}

void TBSendUpClick(PTBSTATE ptb, int iPos, LPARAM lParam)
{
    NMCLICK nm = { 0 };

    if ((iPos >= 0) && (iPos < ptb->iNumButtons))
    {
        nm.dwItemSpec = ptb->Buttons[iPos].idCommand;
        nm.dwItemData = ptb->Buttons[iPos].dwData;
    }
    else
    {
        nm.dwItemSpec = (UINT_PTR) -1;
    }

    LPARAM_TO_POINT(lParam, nm.pt);

    CCSendNotify(&ptb->ci, NM_CLICK, (LPNMHDR )&nm);
}

BOOL TBOnKey(PTBSTATE ptb, int nVirtKey, UINT uFlags)
{
    NMKEY nm;

    TB_CancelTipTrack(ptb);

    // Send the notification
    nm.nVKey = nVirtKey;
    nm.uFlags = uFlags;
    if (CCSendNotify(&ptb->ci, NM_KEYDOWN, &nm.hdr))
        return TRUE;

    // Swap the left and right arrow key if the control is mirrored.
    nVirtKey = RTLSwapLeftRightArrows(&ptb->ci, nVirtKey);

    if (ptb->iHot != -1 && TB_IsDropDown(&ptb->Buttons[ptb->iHot])) {
        // if we're on a dropdown button and you hit the up/down arrow (left/rigth in vert mode)
        // then drop the button down.
        // escape undrops it if it's dropped
        switch (nVirtKey) {
        case VK_RIGHT:
        case VK_LEFT:
            if (!(ptb->ci.style & CCS_VERT))
                break;
            goto DropDown;

        case VK_DOWN:
        case VK_UP:
            if ((ptb->ci.style & CCS_VERT) || (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL))
                break;
            goto DropDown;


        case VK_ESCAPE:
            if (ptb->iHot != ptb->iPressedDD)
                break;
DropDown:
            TBToggleDropDown(ptb, ptb->iHot, FALSE);
            
            //notify of navigation key usage
            CCNotifyNavigationKeyUsage(&(ptb->ci), UISF_HIDEFOCUS | UISF_HIDEACCEL);

            return TRUE;
        }
    }


    switch (nVirtKey) {
    case VK_RIGHT:
    case VK_DOWN:
        TBCycleHotItem(ptb, ptb->iHot, 1, HICF_ARROWKEYS);
        break;

    case VK_LEFT:
    case VK_UP:
        TBCycleHotItem(ptb, ptb->iHot, -1, HICF_ARROWKEYS);
        break;

    case VK_SPACE:
    case VK_RETURN:
        if (ptb->iHot != -1)
        {
            FORWARD_WM_COMMAND(ptb->ci.hwndParent, ptb->Buttons[ptb->iHot].idCommand, ptb->ci.hwnd, BN_CLICKED, SendMessage);
        }
        break;

    default:
        return FALSE;
    }

    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(ptb->ci), UISF_HIDEFOCUS | UISF_HIDEACCEL);

    return TRUE;
}

LRESULT TB_OnSetButtonInfoA(PTBSTATE ptb, int idBtn, LPTBBUTTONINFOA ptbbiA)
{
    TBBUTTONINFO tbbi = *(LPTBBUTTONINFO)ptbbiA;
    WCHAR szText[256];

    if ((ptbbiA->dwMask & TBIF_TEXT) && ptbbiA->pszText)
    {
        tbbi.pszText = szText;
        tbbi.cchText = ARRAYSIZE(szText);

        MultiByteToWideChar(CP_ACP, 0, (LPCSTR) ptbbiA->pszText, -1,
                            szText, ARRAYSIZE(szText));
    }

    return TB_OnSetButtonInfo(ptb, idBtn, (LPTBBUTTONINFO)&tbbi);
}

LRESULT TB_OnGetButtonInfoA(PTBSTATE ptb, int idBtn, LPTBBUTTONINFOA ptbbiA)
{
    LPTBBUTTONDATA ptbButton;
    int iPos;
    DWORD dwMask = ptbbiA->dwMask;

    ptbbiA->dwMask &= ~TBIF_TEXT;

    iPos = (int) TB_OnGetButtonInfo(ptb, idBtn, (LPTBBUTTONINFO)ptbbiA);

    if (iPos != -1)
    {
        ptbButton = ptb->Buttons + iPos;

        ptbbiA->dwMask = dwMask;
        if (ptbbiA->dwMask & TBIF_TEXT)
        {
            if (TBISSTRINGPTR(ptbButton->iString))
            {
                WideCharToMultiByte (CP_ACP, 0, (LPCTSTR)ptbButton->iString,
                                     -1, ptbbiA->pszText , ptbbiA->cchText, NULL, NULL);
            } 
            else 
            {
                ptbbiA->pszText[0] = 0;
            }
        }
    }

    return iPos;
}


void TBOnMouseMove(PTBSTATE ptb, HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    // Only cancel tip track if cursor really did move
    if (ptb->lLastMMove != lParam)
        TB_CancelTipTrack(ptb);

    ptb->lLastMMove = lParam;

    if (ptb->fActive)
    {
        BOOL fSameButton;
        BOOL fDragOut = FALSE;
        int iPos;

        // do drag notifies/drawing first
        if (ptb->pCaptureButton != NULL)
        {
            if (hwnd != GetCapture())
            {
                //DebugMsg(DM_TRACE, TEXT("capture isn't us"));
                SendItemNotify(ptb, ptb->pCaptureButton->idCommand, TBN_ENDDRAG);

                // Revalidate after calling out
                if (!IsWindow(hwnd)) return;

                // if the button is still pressed, unpress it.
                if (EVAL(ptb->pCaptureButton) &&
                    (ptb->pCaptureButton->fsState & TBSTATE_PRESSED))
                    SendMessage(hwnd, TB_PRESSBUTTON, ptb->pCaptureButton->idCommand, 0L);
                ptb->pCaptureButton = NULL;
                ptb->fRightDrag = FALSE; // just in case we were right dragging
            }
            else
            {
                //DebugMsg(DM_TRACE, TEXT("capture IS us, and state is enabled"));
                iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
                fSameButton = (iPos >= 0 && ptb->pCaptureButton == ptb->Buttons + iPos);

                // notify on first drag out
                if (!fSameButton && !ptb->fDragOutNotify)
                {
                    ptb->fDragOutNotify = TRUE;
                    fDragOut = (BOOL)SendItemNotify(ptb, ptb->pCaptureButton->idCommand, TBN_DRAGOUT);

                    // Revalidate after calling out
                    if (!IsWindow(hwnd)) return;

                }

                // Check for ptb->pCaptureButton in case it was somehow nuked
                // in TBN_DRAGOUT.
                // This happens in the case when dragging an item out of start menu. When the
                // notify TBN_DRAGOUT is received, they go into a modal drag drop loop. Before
                // This loop finishes, the file is moved, causing a shell change notify to nuke
                // the button, which invalidates pCatpure button. So I'm getting rid of the
                // eval (lamadio) 4.14.98

                if (ptb->pCaptureButton &&
                    (ptb->pCaptureButton->fsState & TBSTATE_ENABLED) &&
                    (fSameButton == !(ptb->pCaptureButton->fsState & TBSTATE_PRESSED)) &&
                    !ptb->fRightDrag)
                {
                    //DebugMsg(DM_TRACE, TEXT("capture IS us, and Button is different"));

                    ptb->pCaptureButton->fsState ^= TBSTATE_PRESSED;

                    InvalidateButton(ptb, ptb->pCaptureButton, TRUE);

                    NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd,
                        OBJID_CLIENT, (LONG)(ptb->pCaptureButton - ptb->Buttons) + 1);  // Cast is ok because this is just an index
                }
            }
        }

        if (!fDragOut)
        {
            TBRelayToToolTips(ptb, wMsg, wParam, lParam);

            // Yes; set the hot item
            iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            if ((ptb->ci.style & TBSTYLE_FLAT) || (ptb->hTheme))
                TBSetHotItem(ptb, iPos, HICF_MOUSE);

            // Track mouse events now?
            if (!ptb->fMouseTrack && !ptb->fAnchorHighlight)
            {
                // Yes
                TRACKMOUSEEVENT tme;

                tme.cbSize = sizeof(TRACKMOUSEEVENT);
                tme.dwFlags = TME_LEAVE;
                tme.hwndTrack = hwnd;
                ptb->fMouseTrack = TRUE;
                TrackMouseEvent(&tme);
            }
        }
    }

}


void TBHandleLButtonDown(PTBSTATE ptb, LPARAM lParam, int iPos)
{
    LPTBBUTTONDATA ptbButton;
    HWND hwnd = ptb->ci.hwnd;
    if (iPos >= 0 && iPos < ptb->iNumButtons)
    {
        POINT pt;
        RECT rcDropDown;

        LPARAM_TO_POINT(lParam, pt);

        // should this check for the size of the button struct?
        ptbButton = ptb->Buttons + iPos;

        if (TB_IsDropDown(ptbButton))
            TB_GetItemDropDownRect(ptb, iPos, &rcDropDown);

        if (TB_IsDropDown(ptbButton) &&
            (!TB_HasSplitDDArrow(ptb, ptbButton) || PtInRect(&rcDropDown, pt))) {

            // Was the dropdown handled?
            if (!TBToggleDropDown(ptb, iPos, TRUE))
            {
                // No; consider it a drag-out
                ptb->pCaptureButton = ptbButton;
                SetCapture(hwnd);

                ptb->fDragOutNotify = FALSE;
                SendItemNotify(ptb, ptb->pCaptureButton->idCommand, TBN_BEGINDRAG);
                GetMessagePosClient(ptb->ci.hwnd, &ptb->ptCapture);
            }

        } else {
            ptb->pCaptureButton = ptbButton;
            SetCapture(hwnd);

            if (ptbButton->fsState & TBSTATE_ENABLED)
            {
                ptbButton->fsState |= TBSTATE_PRESSED;
                InvalidateButton(ptb, ptbButton, TRUE);
                UpdateWindow(hwnd);         // immediate feedback

                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd,
                    OBJID_CLIENT, iPos+1);
            }

            ptb->fDragOutNotify = FALSE;

            // pCaptureButton may have changed
            if (ptb->pCaptureButton)
                SendItemNotify(ptb, ptb->pCaptureButton->idCommand, TBN_BEGINDRAG);
            GetMessagePosClient(ptb->ci.hwnd, &ptb->ptCapture);
        }
    }
}


void TBOnLButtonDown(PTBSTATE ptb, HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    int iPos;
    NMCLICK nm = {0};

    ptb->fRequeryCapture = FALSE;
    TBRelayToToolTips(ptb, wMsg, wParam, lParam);

    iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
    if ((ptb->ci.style & CCS_ADJUSTABLE) &&
        (((wParam & MK_SHIFT) && !(ptb->ci.style & TBSTYLE_ALTDRAG)) ||
         ((GetKeyState(VK_MENU) & ~1) && (ptb->ci.style & TBSTYLE_ALTDRAG))))
    {
        MoveButton(ptb, iPos);
    }
    else {
        TBHandleLButtonDown(ptb, lParam, iPos);
    }

    if ((iPos >= 0) && (iPos < ptb->iNumButtons))
    {
        nm.dwItemSpec = ptb->Buttons[iPos].idCommand;
        nm.dwItemData = ptb->Buttons[iPos].dwData;
    }
    else
        nm.dwItemSpec = (UINT_PTR) -1;

    LPARAM_TO_POINT(lParam, nm.pt);

    CCSendNotify(&ptb->ci, NM_LDOWN, (LPNMHDR )&nm);
}

void TBOnLButtonUp(PTBSTATE ptb, HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    int iPos = -1;

    TBRelayToToolTips(ptb, wMsg, wParam, lParam);
    if (lParam != (LPARAM)-1)
        iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

    if (ptb->fRequeryCapture && iPos >= 0) {
        // hack for broderbund (and potentially mand mfc apps.
        // on button down, they delete the pressed button and insert another one right underneat that
        // has pretty much the same characteristics.
        // on win95, we allowed pCaptureButton to temporarily point to garbage.
        // now we validate against it.
        // we detect this case on delete now and if the creation size (uStructSize == old 0x14 size)
        // we reget the capture button here
        ptb->pCaptureButton = &ptb->Buttons[iPos];
    }

    if (ptb->pCaptureButton != NULL) {

        int idCommand = ptb->pCaptureButton->idCommand;

        if (!CCReleaseCapture(&ptb->ci)) return;

        SendItemNotify(ptb, idCommand, TBN_ENDDRAG);
        if (!IsWindow(hwnd)) return;

        if (ptb->pCaptureButton && (ptb->pCaptureButton->fsState & TBSTATE_ENABLED) && iPos >=0
            && (ptb->pCaptureButton == ptb->Buttons+iPos)) {

            ptb->pCaptureButton->fsState &= ~TBSTATE_PRESSED;

            if (ptb->pCaptureButton->fsStyle & BTNS_CHECK) {
                if (ptb->pCaptureButton->fsStyle & BTNS_GROUP) {

                    // group buttons already checked can't be force
                    // up by the user.

                    if (ptb->pCaptureButton->fsState & TBSTATE_CHECKED) {
                        ptb->pCaptureButton = NULL;
                        return; // bail!
                    }

                    ptb->pCaptureButton->fsState |= TBSTATE_CHECKED;
                    MakeGroupConsistant(ptb, idCommand);
                } else {
                    ptb->pCaptureButton->fsState ^= TBSTATE_CHECKED; // toggle
                }
            }
            InvalidateButton(ptb, ptb->pCaptureButton, TRUE);
            ptb->pCaptureButton = NULL;

            NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd,  OBJID_CLIENT,
                iPos+1);

            FORWARD_WM_COMMAND(ptb->ci.hwndParent, idCommand, hwnd, BN_CLICKED, SendMessage);


            // do not dereference ptb... it might have been destroyed on the WM_COMMAND.
            // if the window has been destroyed, bail out.
            if (!IsWindow(hwnd))
                return;

            TBSendUpClick(ptb, iPos, lParam);
        }
        else {
            ptb->pCaptureButton = NULL;
        }
    }
    else
    {
        TBSendUpClick(ptb, iPos, lParam);
    }
}

BOOL CALLBACK GetUpdateRectEnumProc(HWND hwnd, LPARAM lParam)
{
    PTBSTATE ptb = (PTBSTATE)lParam;

    if (IsWindowVisible(hwnd))
    {
        RECT rcInvalid;

        if (GetUpdateRect(hwnd, &rcInvalid, FALSE))
        {
            RECT rcNew;

            MapWindowPoints(hwnd, ptb->ci.hwnd, (LPPOINT)&rcInvalid, 2);
            UnionRect(&rcNew, &rcInvalid, &ptb->rcInvalid);
            ptb->rcInvalid = rcNew;
        }
    }

    return TRUE;
}

void TB_OnSize(PTBSTATE ptb, int nWidth, int nHeight)
{
    BOOL fResizeH, fResizeV;
    fResizeH = (nWidth != RECTWIDTH(ptb->rc));
    fResizeV = (nHeight != RECTHEIGHT(ptb->rc));

    if (ptb->dwStyleEx & TBSTYLE_EX_DOUBLEBUFFER)
    {
        RECT rcClient, rcNonclient;
        GetWindowRect(ptb->ci.hwnd, &rcNonclient);
        GetClientRect(ptb->ci.hwnd, &rcClient);

        if (!(IsRectEmpty(&rcNonclient) || IsRectEmpty(&rcClient)) &&
            (RECTWIDTH(rcNonclient) != RECTWIDTH(rcClient) ||
             RECTHEIGHT(rcNonclient) != RECTHEIGHT(rcClient)) )
        {
            // Turn off double buffering if the client and non-client aren't the same. This is 
            // a hack for MFC apps who expect the toolbar to paint it's non-client area in the
            // WM_ERASEBKGND handler, which we can't if we are double buffered

            ptb->dwStyleEx &= ~TBSTYLE_EX_DOUBLEBUFFER;
        }
    }

    if (ptb->dwStyleEx & TBSTYLE_EX_HIDECLIPPEDBUTTONS)
    {
        // figure out which buttons intersect the resized region
        // and invalidate the rects for those buttons
        //
        // +---------------+------+
        // |               |     <--- rcResizeH
        // |               |      |
        // +---------------+------+
        // |   ^           |      |
        // +---|-----------+------+
        //     rcResizeV
        
        int i;
        RECT rcResizeH, rcResizeV;
        SetRect(&rcResizeH, min(ptb->rc.right, nWidth),
                            ptb->rc.top,
                            max(ptb->rc.right, nWidth),
                            min(ptb->rc.bottom, nHeight));

        SetRect(&rcResizeV, ptb->rc.left,
                            min(ptb->rc.bottom, nHeight),
                            min(ptb->rc.right, nWidth),
                            max(ptb->rc.bottom, nHeight));

        for (i = 0; i < ptb->iNumButtons; i++)
        {
            RECT rcTemp, rcBtn;
            TB_GetItemRect(ptb, i, &rcBtn);
            if (IntersectRect(&rcTemp, &rcBtn, &rcResizeH) ||
                IntersectRect(&rcTemp, &rcBtn, &rcResizeV))
            {
                InvalidateRect(ptb->ci.hwnd, &rcBtn, TRUE);
            }
        }
    }

    if (ptb->hTheme)
    {
        MARGINS margin = {0};
        RECT rc;
        GetThemeMargins(ptb->hTheme, NULL, 0, 0, TMT_SIZINGMARGINS, NULL, &margin);

        if (fResizeH)
        {
            SetRect(&rc, min(ptb->rc.right, nWidth) - margin.cxRightWidth, 0, nWidth, nHeight);
            InvalidateRect(ptb->ci.hwnd, &rc, TRUE);
        }

        if (fResizeV)
        {
            SetRect(&rc, 0, min(ptb->rc.bottom, nHeight) - margin.cyBottomHeight, nWidth, nHeight);
            InvalidateRect(ptb->ci.hwnd, &rc, TRUE); 
        }
    }

    SetRect(&ptb->rc, 0, 0, nWidth, nHeight);
}

BOOL TB_TranslateAccelerator(HWND hwnd, LPMSG lpmsg)
{
    if (!lpmsg)
        return FALSE;

    if (GetFocus() != hwnd)
        return FALSE;

    switch (lpmsg->message) {

    case WM_KEYUP:
    case WM_KEYDOWN:

        switch (lpmsg->wParam) {

        case VK_RIGHT:
        case VK_LEFT:
        case VK_UP:
        case VK_DOWN:
        case VK_ESCAPE:
        case VK_SPACE:
        case VK_RETURN:
            TranslateMessage(lpmsg);
            DispatchMessage(lpmsg);
            return TRUE;
        }
        break;

    case WM_CHAR:
        switch (lpmsg->wParam) {

        case VK_ESCAPE:
        case VK_SPACE:
        case VK_RETURN:
            TranslateMessage(lpmsg);
            DispatchMessage(lpmsg);
            return TRUE;
        }
        break;

    }

    return FALSE;
}

void TBInitMetrics(PTBSTATE ptb)
{
    // init our g_clr's
    InitGlobalColors();

    // get the size of a drop down arrow
    ptb->dxDDArrowChar = GetSystemMetrics(SM_CYMENUCHECK);
}

LRESULT TBGenerateDragImage(PTBSTATE ptb, SHDRAGIMAGE* pshdi)
{
    HBITMAP hbmpOld = NULL;
    NMTBCUSTOMDRAW  tbcd = { 0 };
    HDC  hdcDragImage;
    // Do we have a hot item?
    if (ptb->iHot == -1)
        return 0;       // No? Return...

    hdcDragImage = CreateCompatibleDC(NULL);

    if (!hdcDragImage)
        return 0;

    //
    // Mirror the the DC, if the toolbar is mirrored.
    //
    if (ptb->ci.dwExStyle & RTL_MIRRORED_WINDOW)
    {
        SET_DC_RTL_MIRRORED(hdcDragImage);
    }

    tbcd.nmcd.hdc = hdcDragImage;
    ptb->ci.dwCustom = CICustomDrawNotify(&ptb->ci, CDDS_PREPAINT, &tbcd.nmcd);
    pshdi->sizeDragImage.cx = TBWidthOfButton(ptb, &ptb->Buttons[ptb->iHot], hdcDragImage);
    pshdi->sizeDragImage.cy = ptb->iButHeight;
    pshdi->hbmpDragImage = CreateBitmap( pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy,
        GetDeviceCaps(hdcDragImage, PLANES), GetDeviceCaps(hdcDragImage, BITSPIXEL),
        NULL);

    if (pshdi->hbmpDragImage)
    {
        DWORD dwStyle;
        RECT  rc = {0, 0, pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy};
        hbmpOld = (HBITMAP)SelectObject(hdcDragImage, pshdi->hbmpDragImage);

        pshdi->crColorKey = RGB(0xFF, 0x00, 0x55);

        FillRectClr(hdcDragImage, &rc, pshdi->crColorKey);

        // We want the button to be drawn transparent. This is a hack, because I
        // don't want to rewrite the draw code. Fake a transparent draw.
        dwStyle = ptb->ci.style;
        ptb->ci.style |= TBSTYLE_TRANSPARENT;
        ptb->fAntiAlias = FALSE;

        DrawButton(hdcDragImage, 0, 0, ptb, &ptb->Buttons[ptb->iHot], TRUE);

        ptb->fAntiAlias = TRUE;
        ptb->ci.style = dwStyle;

        TB_GetItemRect(ptb, ptb->iHot, &rc);
        if (PtInRect(&rc, ptb->ptCapture))
        {
           if (ptb->ci.dwExStyle & RTL_MIRRORED_WINDOW)
               pshdi->ptOffset.x = rc.right - ptb->ptCapture.x;
           else
               pshdi->ptOffset.x = ptb->ptCapture.x - rc.left;
           pshdi->ptOffset.y = ptb->ptCapture.y - rc.top;
        }

        SelectObject(hdcDragImage, hbmpOld);
        DeleteDC(hdcDragImage);

        // We're passing back the created HBMP.
        return 1;
    }

    return 0;
}

void TB_OnTimer(PTBSTATE ptb, UINT id)
{
    KillTimer(ptb->ci.hwnd, id);

    if (id == IDT_TRACKINGTIP)
    {
        // Display keyboard nav tracking tooltip popups

        if (TB_IsKbdTipTracking(ptb))  // Item requires tracking popup
        {
            TOOLINFO ti = {0};

            ti.cbSize = sizeof(TOOLINFO);
            ti.hwnd = ptb->ci.hwnd;
            ti.uId = ptb->Buttons[ptb->iTracking].idCommand;

            // Cancel previous
            SendMessage(ptb->hwndToolTips, TTM_TRACKACTIVATE, FALSE, (LPARAM)&ti);

            // Switch ListView's tooltip window to "tracking" (manual) mode
            SendMessage(ptb->hwndToolTips, TTM_GETTOOLINFO, 0, (LPARAM)&ti);
            ti.uFlags |= TTF_TRACK;
            SendMessage(ptb->hwndToolTips, TTM_SETTOOLINFO, 0, (LPARAM)&ti);

            // Activate and establish size
            SendMessage(ptb->hwndToolTips, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti);
        }
    }
}

BOOL TB_GetIdealSize(PTBSTATE ptb, LPSIZE psize, BOOL fCalcHeight)
{
    if (psize)
    {
        NMPGCALCSIZE nm;
        nm.dwFlag = fCalcHeight ? PGF_CALCHEIGHT : PGF_CALCWIDTH;
        nm.iWidth = psize->cx;
        nm.iHeight = psize->cy;
        TB_OnCalcSize(ptb, (LPNMHDR)&nm);

        // Since both values may have changed, reset the out-param.
        psize->cy = nm.iHeight;
        psize->cx = nm.iWidth;

        return TRUE;
    }
    return FALSE;
}

LRESULT CALLBACK ToolbarWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPTBBUTTONDATA ptbButton;
    int iPos;
    LRESULT dw;
    PTBSTATE ptb = (PTBSTATE)GetWindowPtr0(hwnd);   // GetWindowPtr(hwnd, 0)

    if (uMsg == WM_NCCREATE)
    {
        LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;

        InitDitherBrush();

        // create the state data for this toolbar

        ptb = (PTBSTATE)LocalAlloc(LPTR, sizeof(TBSTATE));
        if (!ptb)
            return 0;   // WM_NCCREATE failure is 0

        // note, zero init memory from above
        CIInitialize(&ptb->ci, hwnd, lpcs);
        ptb->xFirstButton = s_xFirstButton;
        ptb->iHot = -1;
        ptb->iPressedDD = -1;
        ptb->iInsert = -1;
        ptb->clrim = CLR_DEFAULT;
        ptb->fAntiAlias = TRUE; // Anti Alias fonts by default.
        // initialize system metric-dependent stuff
        TBInitMetrics(ptb);

        // horizontal/vertical space taken up by button chisel, sides,
        // and a 1 pixel margin.  used in GrowToolbar.
        ptb->cxPad = 7;
        ptb->cyPad = 6;
        ptb->fShowPrefix = TRUE;

        ptb->iListGap = LIST_GAP;
        ptb->iDropDownGap = DROPDOWN_GAP;

        ptb->clrsc.clrBtnHighlight = ptb->clrsc.clrBtnShadow = CLR_DEFAULT;

        ptb->hTheme = OpenThemeData(ptb->ci.hwnd, L"Toolbar");

        ptb->iTracking = TBKTT_NOTRACK;

        ASSERT(ptb->uStructSize == 0);
        ASSERT(ptb->hfontIcon == NULL);  // initialize to null.
        ASSERT(ptb->iButMinWidth == 0);
        ASSERT(ptb->iButMaxWidth == 0);
        ptb->nTextRows = 1;
        ptb->fActive = TRUE;

        // IE 3 passes in TBSTYLE_FLAT, but they really
        // wanted TBSTYLE_TRANSPARENT also.
        //
        if (ptb->ci.style & TBSTYLE_FLAT) 
        {
            ptb->ci.style |= TBSTYLE_TRANSPARENT;
        }

        // Turn it on to reduce flicker.
        if (ptb->ci.style & TBSTYLE_TRANSPARENT)
        {
            ptb->fForcedDoubleBuffer = TRUE;
        }

        // Now Initialize the hfont we will use.
        TBChangeFont(ptb, 0, NULL);

        // grow the button size to the appropriate girth
        if (!SetBitmapSize(ptb, DEFAULTBITMAPX, DEFAULTBITMAPX))
        {
            goto Failure;
        }

        SetWindowPtr(hwnd, 0, ptb);

        if (!(ptb->ci.style & (CCS_TOP | CCS_NOMOVEY | CCS_BOTTOM)))
        {
            ptb->ci.style |= CCS_TOP;
            SetWindowLong(hwnd, GWL_STYLE, ptb->ci.style);
        }

        return TRUE;

Failure:
        if (ptb) {
            ASSERT(!ptb->Buttons);  // App hasn't had a change to AddButtons yet
            LocalFree(ptb);
        }
        return FALSE;
    }

    if (!ptb)
        goto DoDefault;

    switch (uMsg) 
    {

    case WM_CREATE:
        if (ptb->ci.style & TBSTYLE_REGISTERDROP)
        {
            ptb->hDragProxy = CreateDragProxy(ptb->ci.hwnd, ToolbarDragCallback, TRUE);
        }
        goto DoDefault;

    case WM_DESTROY:
        TB_OnDestroy(ptb);
        break;

    case WM_KEYDOWN:
        if (TBOnKey(ptb, (int) wParam, HIWORD(lParam)))
            break;
        goto DoDefault;

    case WM_UPDATEUISTATE:
    {
        if (CCOnUIState(&(ptb->ci), WM_UPDATEUISTATE, wParam, lParam))
        {
            BOOL fSmooth = IsUsingCleartype();
            // We erase background only if we are removing underscores or focus rect,
            // or if Font smooting is enabled
            InvalidateRect(hwnd, NULL, 
                 fSmooth || ((UIS_SET == LOWORD(wParam)) ? TRUE : FALSE));
        }

        goto DoDefault;
    }
    
    case WM_GETDLGCODE:
        return (LRESULT) (DLGC_WANTARROWS | DLGC_WANTCHARS);

    case WM_SYSCHAR:
    case WM_CHAR:
        if (!TBOnChar(ptb, (UINT) wParam))
        {
            // didn't handle it & client is >= v5
            // forward to default handler
            goto DoDefault;
        }
        break;

    case WM_SETFOCUS:
        if (ptb->iHot == -1) {
            // set hot the first enabled button
            TBCycleHotItem(ptb, -1, 1, HICF_OTHER);
        }
        break;

    case WM_KILLFOCUS:
        TBSetHotItem(ptb, -1, HICF_OTHER);
        break;

    case WM_SETFONT:
        TBSetFont(ptb, (HFONT)wParam, (BOOL)lParam);
        return TRUE;

    case WM_NCCALCSIZE:
        // let defwindowproc handle the standard borders etc...
        dw = DefWindowProc(hwnd, uMsg, wParam, lParam ) ;

        // add the extra edge at the top of the toolbar to seperate from the menu bar
        if (!(ptb->ci.style & CCS_NODIVIDER))
        {
            ((NCCALCSIZE_PARAMS *)lParam)->rgrc[0].top += g_cyEdge;
        }

        return dw;

    case WM_NCHITTEST:
        if (ptb->dwStyleEx & TBSTYLE_EX_TRANSPARENTDEADAREA)
        {
            POINT pt;

            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);
            ScreenToClient(hwnd, &pt);
            if (TBHitTest(ptb, pt.x, pt.y) < 0)
            {
                if (ptb->lLastMMove != lParam)
                    TB_CancelTipTrack(ptb);

                ptb->lLastMMove = lParam;

                return HTTRANSPARENT;
            }
        }
        return HTCLIENT;

    case WM_NCACTIVATE:

        // only make sense to do this stuff if we're top level
        if ((BOOLIFY(ptb->fActive) != (BOOL)wParam && !GetParent(hwnd))) {
            int iButton;

            ptb->fActive = (BOOL) wParam;

            for (iButton = 0; iButton < ptb->iNumButtons; iButton++) {
                ptbButton = &ptb->Buttons[iButton];
                InvalidateButton(ptb, ptbButton, FALSE);
            }
        }
        // fall through...

    case WM_NCPAINT:
        // old-style toolbars are forced to be without dividers above
        if (!(ptb->ci.style & CCS_NODIVIDER))
        {
            RECT rc;
            HDC hdc = GetWindowDC(hwnd);
            GetWindowRect(hwnd, &rc);
            MapWindowRect(NULL, hwnd, &rc); // screen -> client

                rc.bottom = -rc.top;                // bottom of NC area
                rc.top = rc.bottom - g_cyEdge;

            CCDrawEdge(hdc, &rc, BDR_SUNKENOUTER, BF_TOP | BF_BOTTOM, &(ptb->clrsc));
            ReleaseDC(hwnd, hdc);
        }
        goto DoDefault;

    case WM_ENABLE:
        if (wParam) {
            ptb->ci.style &= ~WS_DISABLED;
        } else {
            ptb->ci.style |= WS_DISABLED;
        }
        InvalidateRect(hwnd, NULL, ptb->ci.style & TBSTYLE_TRANSPARENT);
        goto DoDefault;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        if (ptb->fTTNeedsFlush)
            FlushToolTipsMgrNow(ptb);

        if (ptb->fRedrawOff)
        {
            if (!wParam)
            {
                HDC hdcPaint;
                PAINTSTRUCT ps;

                hdcPaint = BeginPaint(hwnd, &ps);
                EndPaint(hwnd, &ps);
            }

            // we got a paint region, so invalidate
            // when we get redraw back on...
            ptb->fInvalidate = TRUE;
        }
        else
        {
            TBPaint(ptb, (HDC)wParam);
        }
        break;

    case WM_SETREDRAW:
        {
            BOOL fRedrawOld = !ptb->fRedrawOff;

            if ( wParam && ptb->fRedrawOff )
            {
                if ( ptb->fInvalidate )
                {
                    // If font smoothing is enabled, then we need to erase the background too.
                    BOOL fSmooth = IsUsingCleartype();

                    // invalidate before turning back on ...
                    RedrawWindow( hwnd, NULL, NULL, (fSmooth? RDW_ERASE: 0)  | RDW_INVALIDATE );
                    ptb->fInvalidate = FALSE;
                }
                ptb->fRedrawOff = FALSE;

                if ( ptb->fRecalc )
                {
                    // recalc & autosize after turning back on
                    TBRecalc(ptb);
                    TBAutoSize(ptb);
                    ptb->fRecalc = FALSE;
                }
            }
            else
            {
                ptb->fRedrawOff = !wParam;
            }

            return fRedrawOld;
        }
        break;

    case WM_ERASEBKGND:
        TB_OnEraseBkgnd(ptb, (HDC) wParam);
        return(TRUE);

    case WM_SYSCOLORCHANGE:
        TB_OnSysColorChange(ptb);
        if (ptb->hwndToolTips)
            SendMessage(ptb->hwndToolTips, uMsg, wParam, lParam);
        break;

    case WM_TIMER:
        TB_OnTimer(ptb, (UINT)wParam);
        break;

    case TB_GETROWS:
        return CountRows(ptb);
        break;

    case TB_GETPADDING:
        lParam = MAKELONG(-1, -1);
        // fall through
    case TB_SETPADDING:
    {
        LRESULT lres = MAKELONG(ptb->cxPad, ptb->cyPad);
        int xPad = GET_X_LPARAM(lParam);
        int yPad = GET_Y_LPARAM(lParam);
        if (xPad != -1)
            ptb->cxPad = xPad;
        if (yPad != -1)
            ptb->cyPad = yPad;
        return lres;
    }

    case TB_GETMETRICS:
        {
            LPTBMETRICS ptbm = (LPTBMETRICS)lParam;
            if (ptbm && (ptbm->cbSize == sizeof(TBMETRICS)))
            {
                if (ptbm->dwMask & TBMF_PAD)
                {
                    ptbm->cxPad = ptb->cxPad;
                    ptbm->cyPad = ptb->cyPad;
                }
                if (ptbm->dwMask & TBMF_BARPAD)
                {
                    ptbm->cxBarPad = ptb->cxBarPad;
                    ptbm->cyBarPad = ptb->cyBarPad;
                }
                if (ptbm->dwMask & TBMF_BUTTONSPACING)
                {
                    ptbm->cxButtonSpacing = ptb->cxButtonSpacing;
                    ptbm->cyButtonSpacing = ptb->cyButtonSpacing;
                }
            }
        }
        break;

    case TB_SETMETRICS:
        {
            LPTBMETRICS ptbm = (LPTBMETRICS)lParam;
            if (ptbm && (ptbm->cbSize == sizeof(TBMETRICS)))
            {
                if (ptbm->dwMask & TBMF_PAD)
                {
                    ptb->cxPad = ptbm->cxPad;
                    ptb->cyPad = ptbm->cyPad;
                }
                if (ptbm->dwMask & TBMF_BARPAD)
                {
                    ptb->cxBarPad = ptbm->cxBarPad;
                    ptb->cyBarPad = ptbm->cyBarPad;
                }
                if (ptbm->dwMask & TBMF_BUTTONSPACING)
                {
                    ptb->cxButtonSpacing = ptbm->cxButtonSpacing;
                    ptb->cyButtonSpacing = ptbm->cyButtonSpacing;
                }
            }
        }
        break;

    case TB_SETROWS:
        {
            RECT rc;

            if (BoxIt(ptb, LOWORD(wParam), HIWORD(wParam), &rc))
            {
                TBInvalidateItemRects(ptb);
                SetWindowPos(hwnd, NULL, 0, 0, rc.right, rc.bottom,
                             SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE);
                InvalidateRect(hwnd, NULL, TRUE);
            }
            if (lParam)
                *((RECT *)lParam) = rc;
        }
        break;

    case WM_MOVE:
        // JJK TODO: This needs to be double buffered to get rid of the flicker
        if (ptb->ci.style & TBSTYLE_TRANSPARENT)
            InvalidateRect(hwnd, NULL, TRUE);
        goto DoDefault;

    case WM_SIZE:
        TB_OnSize(ptb, LOWORD(lParam), HIWORD(lParam));
        // fall through
    case TB_AUTOSIZE:
        TBAutoSize(ptb);
        break;

    case WM_WINDOWPOSCHANGING:
        if ((ptb->ci.style & TBSTYLE_TRANSPARENT) || (ptb->hTheme))
        {
            LPWINDOWPOS pwp = (LPWINDOWPOS)lParam;
            if (pwp)
            {
                pwp->flags |= SWP_NOCOPYBITS;
            }
        }
        break;

    case WM_COMMAND:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_VKEYTOITEM:
    case WM_CHARTOITEM:
        SendMessage(ptb->ci.hwndParent, uMsg, wParam, lParam);
        break;

    case WM_RBUTTONDBLCLK:
        if (!CCSendNotify(&ptb->ci, NM_RDBLCLK, NULL))
            goto DoDefault;
        break;

    case WM_RBUTTONUP:
        {
            NMCLICK nm = {0};
            int iIndex;

            if (ptb->pCaptureButton != NULL)
            {
                if (!CCReleaseCapture(&ptb->ci)) break;
                ptb->pCaptureButton = NULL;
                ptb->fRightDrag = FALSE;
            }

            iIndex = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            if ((iIndex >= 0) && (iIndex < ptb->iNumButtons)) {
                nm.dwItemSpec = ptb->Buttons[iIndex].idCommand;
                nm.dwItemData = ptb->Buttons[iIndex].dwData;
            } else
                nm.dwItemSpec = (UINT_PTR) -1;

            LPARAM_TO_POINT(lParam, nm.pt);

            if (!CCSendNotify(&ptb->ci, NM_RCLICK, (LPNMHDR )&nm))
                goto DoDefault;
        }
        break;

    case WM_LBUTTONDBLCLK:
        iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        if (iPos < 0 && (ptb->ci.style & CCS_ADJUSTABLE))
        {
            iPos = -1 - iPos;
            CustomizeTB(ptb, iPos);
        } else {
            TBHandleLButtonDown(ptb, lParam, iPos);
        }
        break;

    case WM_LBUTTONDOWN:
        TBOnLButtonDown(ptb, hwnd, uMsg, wParam, lParam);
        break;

    case WM_CAPTURECHANGED:
        // do this only for newer apps because some apps
        // do things like delete a button when you
        // mouse down and add it back in immediately.
        // also do it on a post because we call ReleaseCapture
        // internally and only want to catch this on external release
        PostMessage(hwnd, TBP_ONRELEASECAPTURE, 0, 0);
        break;

    case TBP_ONRELEASECAPTURE:
        if (ptb->pCaptureButton) {
            // abort current capture
            // simulate a lost capture mouse move.  this will restore state
            TBOnMouseMove(ptb, hwnd, WM_MOUSEMOVE, 0, (LPARAM)-1);
            ptb->pCaptureButton = NULL;
        }
        break;


    case WM_RBUTTONDOWN:

        if (ptb->pCaptureButton) {
            // abort current capture
            if (hwnd == GetCapture()) {
                // we were left clicking.   abort that now
                if (!CCReleaseCapture(&ptb->ci)) break;
                // simulate a lost capture mouse move.  this will restore state
                TBOnMouseMove(ptb, hwnd, WM_MOUSEMOVE, 0, (LPARAM)-1);
            }
        }

        iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

        // we need to check VK_RBUTTON because some apps subclass us to pick off rbuttondown to do their menu
        // (instead of up, or the notify, or wm_contextmenu)
        // then after it's done and the button is up, they then send us a button down
        if ((iPos >= 0) && (iPos < ptb->iNumButtons) && (GetAsyncKeyState(VK_RBUTTON) < 0))
        {
            ptb->pCaptureButton = ptb->Buttons + iPos;
            ptb->fRightDrag = TRUE;
            SetCapture(hwnd);
            GetMessagePosClient(ptb->ci.hwnd, &ptb->ptCapture);

            SendItemNotify(ptb, ptb->pCaptureButton->idCommand, TBN_BEGINDRAG);
            if (!IsWindow(hwnd)) break;
            ptb->fDragOutNotify = FALSE;
        }
        break;

    case WM_MOUSELEAVE:
        {
            TRACKMOUSEEVENT tme;

            // Cancel the mouse event tracking
            tme.cbSize = sizeof(TRACKMOUSEEVENT);
            tme.dwFlags = TME_CANCEL | TME_LEAVE;
            tme.hwndTrack = hwnd;
            TrackMouseEvent(&tme);
            ptb->fMouseTrack = FALSE;

            TBSetHotItem(ptb, -1, HICF_MOUSE);
        }
        break;

    case WM_MOUSEMOVE:
        TBOnMouseMove(ptb, hwnd, uMsg, wParam, lParam);
        break;

    case WM_LBUTTONUP:
        TBOnLButtonUp(ptb, hwnd, uMsg, wParam, lParam);
        break;

    case WM_SETTINGCHANGE:
        InitGlobalMetrics(wParam);
        if (ptb->fFontCreated)
            TBChangeFont(ptb, wParam, NULL);
        if (ptb->hwndToolTips)
            SendMessage(ptb->hwndToolTips, uMsg, wParam, lParam);

        // recalc & redraw
        TBInitMetrics(ptb);
        TBRecalc(ptb);
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&ptb->ci, lParam);
        break;


    case WM_NOTIFY:
#define lpNmhdr ((LPNMHDR)(lParam))
        //The following statement traps all pager control notification messages.
        if((lpNmhdr->code <= PGN_FIRST)  && (lpNmhdr->code >= PGN_LAST)) {
            return TB_OnPagerControlNotify(ptb, lpNmhdr);
        }
    {
        LRESULT lres = 0;
        if (lpNmhdr->code == TTN_NEEDTEXT)
        {
            int i = TB_IsKbdTipTracking(ptb) ? ptb->iTracking : PositionFromID(ptb, lpNmhdr->idFrom);

            BOOL fEllipsied = FALSE;
            LRESULT lres;
            LPTOOLTIPTEXT lpnmTT = ((LPTOOLTIPTEXT) lParam);

            if (i != -1) {
                // if infotip not supported, try for TTN_NEEDTEXT in client.
                if (!TBGetInfoTip(ptb, lpnmTT, &ptb->Buttons[i]))
                    lres = SendNotifyEx(ptb->ci.hwndParent, (HWND) -1,
                                        lpNmhdr->code, lpNmhdr, ptb->ci.bUnicode);

#define IsTextPtr(lpszText)  (((lpszText) != LPSTR_TEXTCALLBACK) && (!IS_INTRESOURCE(lpszText)))

                fEllipsied = (BOOL)(ptb->Buttons[i].fsState & TBSTATE_ELLIPSES);

                // if we don't get a string from TTN_NEEDTEXT try to use the title text.
                if ((lpNmhdr->code == TTN_NEEDTEXT) &&
                    (BTN_NO_SHOW_TEXT(ptb, &ptb->Buttons[i]) || fEllipsied) &&
                    lpnmTT->lpszText && IsTextPtr(lpnmTT->lpszText) &&
                    !lpnmTT->lpszText[0])
                {
                    LPCTSTR psz = TB_StrForButton(ptb, &ptb->Buttons[i]);
                    if (psz)
                        lpnmTT->lpszText = (LPTSTR)psz;
                }
            }
        }
        else if (lpNmhdr->code == TTN_SHOW)
        {
            if (TB_IsKbdTipTracking(ptb))  // Size tip when keyboard tracking
            {
                RECT rcTT;
                RECT rcItem;
                POINT ptTT;
                POINT ptItem;

                MONITORINFO mi = {0};
                mi.cbSize = sizeof(MONITORINFO);

                // Establish item screen position and size
                SendMessage(ptb->ci.hwnd, TB_GETITEMRECT, ptb->iTracking, (LPARAM)&rcItem);
                ptItem.x = rcItem.left;
                ptItem.y = rcItem.top;
                ClientToScreen(ptb->ci.hwnd, &ptItem);

                // Get tip rect
                GetWindowRect(ptb->hwndToolTips, &rcTT);

                // Init tooltip position
                ptTT.x = ptItem.x + RECTWIDTH(rcItem) - g_cxIconMargin;
                ptTT.y = ptItem.y + RECTHEIGHT(rcItem);

                // Get screen info where tooltip is being displayed
                GetMonitorInfo(MonitorFromPoint(ptTT, MONITOR_DEFAULTTONEAREST), &mi);

                // Update tooltip position if it runs off the screen
                if ((ptTT.x + RECTWIDTH(rcTT)) > mi.rcMonitor.right)
                    ptTT.x = (ptItem.x + g_cxIconMargin) - RECTWIDTH(rcTT);

                if ((ptTT.y + RECTHEIGHT(rcTT)) > mi.rcMonitor.bottom)
                    ptTT.y = ptItem.y - RECTHEIGHT(rcTT);

                SetWindowPos(ptb->hwndToolTips, NULL, ptTT.x, ptTT.y, 0, 0, SWP_NOSIZE|SWP_NOACTIVATE);

                return TRUE;
            }
        }
        else
        {
            //
            // We are just going to pass this on to the
            // real parent.  Note that -1 is used as
            // the hwndFrom.  This prevents SendNotifyEx
            // from updating the NMHDR structure.
            //
            lres = SendNotifyEx(ptb->ci.hwndParent, (HWND) -1,
                                lpNmhdr->code, lpNmhdr, ptb->ci.bUnicode);
        }
        return(lres);
    }

    case WM_STYLECHANGING:
        if (wParam == GWL_STYLE)
        {
            LPSTYLESTRUCT lpStyle = (LPSTYLESTRUCT) lParam;

            // is MFC dorking with just our visibility bit?
            if ((lpStyle->styleOld ^ lpStyle->styleNew) == WS_VISIBLE)
            {
                if (lpStyle->styleNew & WS_VISIBLE)
                {
                    BOOL fSmooth = IsUsingCleartype();
                    // MFC trying to make us visible,
                    // convert it to WM_SETREDRAW instead.
                    DefWindowProc(hwnd, WM_SETREDRAW, TRUE, 0);

                    // Reinvalidate everything we lost when we
                    // did the WM_SETREDRAW stuff.
                    RedrawWindow(hwnd, &ptb->rcInvalid, NULL, (fSmooth? RDW_ERASE: 0)  | RDW_INVALIDATE | RDW_ALLCHILDREN);
                    ZeroMemory(&ptb->rcInvalid, SIZEOF(ptb->rcInvalid));
                }
                else
                {
                    // Save the invalid rectangle in ptb->rcInvalid since
                    // WM_SETREDRAW will blow it away.
                    ZeroMemory(&ptb->rcInvalid, SIZEOF(ptb->rcInvalid));
                    GetUpdateRect(ptb->ci.hwnd, &ptb->rcInvalid, FALSE);
                    EnumChildWindows(ptb->ci.hwnd, GetUpdateRectEnumProc, (LPARAM)ptb);

                    // MFC trying to make us invisible,
                    // convert it to WM_SETREDRAW instead.
                    DefWindowProc(hwnd, WM_SETREDRAW, FALSE, 0);
                }
            }
        }
        break;

    case WM_STYLECHANGED:
        if (wParam == GWL_STYLE)
        {
            TBSetStyle(ptb, ((LPSTYLESTRUCT)lParam)->styleNew);
        }
        else if (wParam == GWL_EXSTYLE)
        {
            //
            // If the RTL_MIRROR extended style bit had changed, let's
            // repaint the control window
            //
            if ((ptb->ci.dwExStyle&RTL_MIRRORED_WINDOW) !=
                (((LPSTYLESTRUCT)lParam)->styleNew&RTL_MIRRORED_WINDOW))
                TBAutoSize(ptb);

            //
            // Save the new ex-style bits
            //
            ptb->ci.dwExStyle = ((LPSTYLESTRUCT)lParam)->styleNew;

        }
        return 0;

    case TB_GETIDEALSIZE:
        return TB_GetIdealSize(ptb, (LPSIZE)lParam, (BOOL)wParam);

    case TB_SETSTYLE:
        TBSetStyle(ptb, (DWORD) lParam);
        break;

    case TB_GETSTYLE:
        return (ptb->ci.style);

    case TB_GETBUTTONSIZE:
        return (MAKELONG(ptb->iButWidth,ptb->iButHeight));

    case TB_SETBUTTONWIDTH:
        if (ptb->iButMinWidth  != LOWORD(lParam) ||
            ptb->iButMaxWidth != HIWORD(lParam)) {

            ptb->iButMinWidth  = LOWORD(lParam);
            ptb->iButMaxWidth = HIWORD(lParam);
            ptb->iButWidth = 0;
            TBRecalc(ptb);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        return TRUE;

    case TB_TRANSLATEACCELERATOR:
        return TB_TranslateAccelerator(hwnd, (LPMSG)lParam);

    case TB_SETSTATE:
        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return FALSE;
        ptbButton = ptb->Buttons + iPos;

        TB_OnSetState(ptb, ptbButton, (BYTE)(LOWORD(lParam)), iPos);
        TBInvalidateItemRects(ptb);
        return TRUE;

    // set the cmd ID of a button based on its position
    case TB_SETCMDID:
        if (wParam >= (UINT)ptb->iNumButtons)
            return FALSE;

        TB_OnSetCmdID(ptb, &ptb->Buttons[wParam], (UINT)lParam);
        return TRUE;

    case TB_GETSTATE:
        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return -1L;
        return ptb->Buttons[iPos].fsState;

    case TB_MAPACCELERATORA:
    {
        char szAcl[2];
        WCHAR wszAcl[2];
        szAcl[0] = (BYTE)wParam;
        szAcl[1] = '\0';
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szAcl, ARRAYSIZE(szAcl),
                                               wszAcl, ARRAYSIZE(wszAcl));
        // no need to check return we just take junk if MbtoWc has failed
        wParam = (WPARAM)wszAcl[0];
    }
    // fall through...
    case TB_MAPACCELERATOR:
        return TBOnMapAccelerator(ptb, (UINT)wParam, (UINT *)lParam);

    case TB_ENABLEBUTTON:
    case TB_CHECKBUTTON:
    case TB_PRESSBUTTON:
    case TB_HIDEBUTTON:
    case TB_INDETERMINATE:
    case TB_MARKBUTTON:
    {
        BYTE fsState;

        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return FALSE;
        ptbButton = &ptb->Buttons[iPos];
        fsState = ptbButton->fsState;

        if (LOWORD(lParam))
            ptbButton->fsState |= wStateMasks[uMsg - TB_ENABLEBUTTON];
        else
            ptbButton->fsState &= ~wStateMasks[uMsg - TB_ENABLEBUTTON];

        // did this actually change the state?
        if (fsState != ptbButton->fsState) {
            // is this button a member of a group?
            if ((uMsg == TB_CHECKBUTTON) && (ptbButton->fsStyle & BTNS_GROUP))
                MakeGroupConsistant(ptb, (int)wParam);

            if (uMsg == TB_HIDEBUTTON) {
                InvalidateRect(hwnd, NULL, TRUE);
                TBInvalidateItemRects(ptb);
            } else
                InvalidateButton(ptb, ptbButton, TRUE);

            NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, iPos+1);
        }
        return(TRUE);
    }

    case TB_ISBUTTONENABLED:
    case TB_ISBUTTONCHECKED:
    case TB_ISBUTTONPRESSED:
    case TB_ISBUTTONHIDDEN:
    case TB_ISBUTTONINDETERMINATE:
    case TB_ISBUTTONHIGHLIGHTED:
        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return(-1L);
        return (LRESULT)ptb->Buttons[iPos].fsState & wStateMasks[uMsg - TB_ISBUTTONENABLED];

    case TB_ADDBITMAP:
    case TB_ADDBITMAP32:    // only for compatibility with mail
        {
            LPTBADDBITMAP pab = (LPTBADDBITMAP)lParam;
            return AddBitmap(ptb, (int) wParam, pab->hInst, pab->nID);
        }

    case TB_REPLACEBITMAP:
        return ReplaceBitmap(ptb, (LPTBREPLACEBITMAP)lParam);

    case TB_ADDSTRINGA:
        {
        LPWSTR lpStrings;
        UINT   uiCount;
        LPSTR  lpAnsiString = (LPSTR) lParam;
        int    iResult;
        BOOL   bAllocatedMem = FALSE;

        if (!wParam && !IS_INTRESOURCE(lpAnsiString)) 
        {
            //
            // We have to figure out how many characters
            // are in this string.
            //
            
            uiCount = 0;

            while (TRUE) 
            {
               uiCount++;
               if ((*lpAnsiString == 0) && (*(lpAnsiString+1) == 0)) 
               {
                  uiCount++;  // needed for double null
                  break;
               }

               lpAnsiString++;
            }

            lpStrings = (PTSTR)LocalAlloc(LPTR, uiCount * sizeof(TCHAR));

            if (!lpStrings)
                return -1;

            bAllocatedMem = TRUE;

            MultiByteToWideChar(CP_ACP, 0, (LPCSTR) lParam, uiCount,
                                lpStrings, uiCount);

        } 
        else 
        {
            lpStrings = (LPWSTR)lParam;
        }

        iResult = TBAddStrings(ptb, wParam, (LPARAM)lpStrings);

        if (bAllocatedMem)
            LocalFree(lpStrings);

        return iResult;
        }

    case TB_ADDSTRING:
        return TBAddStrings(ptb, wParam, lParam);

    case TB_GETSTRING:
        return TBGetString(ptb, HIWORD(wParam), LOWORD(wParam), (LPTSTR)lParam);

    case TB_GETSTRINGA:
        return TBGetStringA(ptb, HIWORD(wParam), LOWORD(wParam), (LPSTR)lParam);

    case TB_ADDBUTTONSA:
        return TBInsertButtons(ptb, (UINT)-1, (UINT) wParam, (LPTBBUTTON)lParam, FALSE);

    case TB_INSERTBUTTONA:
        return TBInsertButtons(ptb, (UINT) wParam, 1, (LPTBBUTTON)lParam, FALSE);

    case TB_ADDBUTTONS:
        return TBInsertButtons(ptb, (UINT)-1, (UINT) wParam, (LPTBBUTTON)lParam, TRUE);

    case TB_INSERTBUTTON:
        return TBInsertButtons(ptb, (UINT) wParam, 1, (LPTBBUTTON)lParam, TRUE);

    case TB_DELETEBUTTON:
        return DeleteButton(ptb, (UINT) wParam);

    case TB_GETBUTTON:
        if (wParam >= (UINT)ptb->iNumButtons)
            return(FALSE);

        TBOutputStruct(ptb, ptb->Buttons + wParam, (LPTBBUTTON)lParam);
        return TRUE;

    case TB_SETANCHORHIGHLIGHT:
        BLOCK
        {
            BOOL bAnchor = BOOLIFY(ptb->fAnchorHighlight);
            ptb->fAnchorHighlight = BOOLFROMPTR(wParam);
            return bAnchor;
        }
        break;

    case TB_GETANCHORHIGHLIGHT:
        return BOOLIFY(ptb->fAnchorHighlight);

    case TB_HASACCELERATOR:
        ASSERT(IS_VALID_WRITE_PTR(lParam, int*));
        *((int*)lParam) = TBHasAccelerator(ptb, (UINT)wParam);
        break;

    case TB_SETHOTITEM:
        lParam = HICF_OTHER;
        // Fall through
    case TB_SETHOTITEM2:
        BLOCK
        {
            int iPos = ptb->iHot;

            TBSetHotItem(ptb, (int)wParam, (DWORD)lParam);
            return iPos;
        }
        break;

    case TB_GETHOTITEM:
        return ptb->iHot;

    case TB_SETINSERTMARK:
        TBSetInsertMark(ptb, (LPTBINSERTMARK)lParam);
        break;

    case TB_GETINSERTMARK:
    {
        LPTBINSERTMARK ptbim = (LPTBINSERTMARK)lParam;

        ptbim->iButton = ptb->iInsert;
        ptbim->dwFlags = ptb->fInsertAfter ? TBIMHT_AFTER : 0;
        return TRUE;
    }

    case TB_SETINSERTMARKCOLOR:
    {
        LRESULT lres = (LRESULT)TB_GetInsertMarkColor(ptb);
        ptb->clrim = (COLORREF) lParam;
        return lres;
    }

    case TB_GETINSERTMARKCOLOR:
        return TB_GetInsertMarkColor(ptb);

    case TB_INSERTMARKHITTEST:
    return (LRESULT)TBInsertMarkHitTest(ptb, ((LPPOINT)wParam)->x, ((LPPOINT)wParam)->y, (LPTBINSERTMARK)lParam);

    case TB_MOVEBUTTON:
        return (LRESULT)TBMoveButton(ptb, (UINT)wParam, (UINT)lParam);

    case TB_GETMAXSIZE:
        return (LRESULT)TBGetMaxSize(ptb, (LPSIZE) lParam );

    case TB_BUTTONCOUNT:
        return ptb->iNumButtons;

    case TB_COMMANDTOINDEX:
        return PositionFromID(ptb, wParam);

    case TB_SAVERESTOREA:
        {
        LPWSTR lpSubKeyW, lpValueNameW;
        TBSAVEPARAMSA * lpSaveA = (TBSAVEPARAMSA *) lParam;
        BOOL bResult;

        lpSubKeyW = ProduceWFromA (CP_ACP, lpSaveA->pszSubKey);
        lpValueNameW = ProduceWFromA (CP_ACP, lpSaveA->pszValueName);

        bResult = SaveRestoreFromReg(ptb, (BOOL) wParam, lpSaveA->hkr, lpSubKeyW, lpValueNameW);

        FreeProducedString(lpSubKeyW);
        FreeProducedString(lpValueNameW);

        return bResult;
        }

    case TB_SAVERESTORE:
        {
            TBSAVEPARAMS* psr = (TBSAVEPARAMS *)lParam;
            return SaveRestoreFromReg(ptb, (BOOL) wParam, psr->hkr, psr->pszSubKey, psr->pszValueName);
        }

    case TB_CUSTOMIZE:
        CustomizeTB(ptb, ptb->iNumButtons);
        break;

    case TB_GETRECT:
        // PositionFromID() accepts NULL ptbs!
        wParam = PositionFromID(ptb, wParam);
        // fall through
    case TB_GETITEMRECT:
        if (!lParam)
            break;
        return TB_GetItemRect(ptb, (UINT) wParam, (LPRECT)lParam);

    case TB_BUTTONSTRUCTSIZE:
        TBOnButtonStructSize(ptb, (UINT) wParam);
        break;

    case TB_SETBUTTONSIZE:
        return GrowToolbar(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), 0);

    case TB_SETBITMAPSIZE:
        return SetBitmapSize(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

    case TB_SETIMAGELIST:
    {
        HIMAGELIST himl = (HIMAGELIST)lParam;
        HIMAGELIST himlOld = TBSetImageList(ptb, HIML_NORMAL, (int) wParam, himl);
        DWORD dwFlags = ImageList_GetFlags(himl);

        ptb->fHimlNative = TRUE;

        if (!ptb->uStructSize) 
        {
            // let people get away without calling TB_BUTTONSTRUCTSIZE... no other control requires this
            ptb->uStructSize = sizeof(TBBUTTON);
        }

        // The bitmap size is based on the primary image list
        if (wParam == 0)
        {
            int cx = 0, cy = 0;
            if (himl) 
            {
                // Update the bitmap size based on this image list
                CCGetIconSize(&ptb->ci, himl, &cx, &cy);
            }
            SetBitmapSize(ptb, cx, cy);
        }

        return (LRESULT)himlOld;
    }

    case TB_GETIMAGELIST:
        return (LRESULT)TBGetImageList(ptb, HIML_NORMAL, (int) wParam);

    case TB_GETIMAGELISTCOUNT:
        return ptb->cPimgs;

    case TB_SETHOTIMAGELIST:
        return (LRESULT)TBSetImageList(ptb, HIML_HOT, (int) wParam, (HIMAGELIST)lParam);

    case TB_GETHOTIMAGELIST:
        return (LRESULT)TBGetImageList(ptb, HIML_HOT, (int) wParam);

    case TB_GETDISABLEDIMAGELIST:
        return (LRESULT)TBGetImageList(ptb, HIML_DISABLED, (int) wParam);

    case TB_SETDISABLEDIMAGELIST:
        return (LRESULT)TBSetImageList(ptb, HIML_DISABLED, (int) wParam, (HIMAGELIST)lParam);

    case TB_GETOBJECT:
        if (IsEqualIID(*(IID *)wParam, IID_IDropTarget))
        {
            // if we have not already registered create an unregistered target now
            if (ptb->hDragProxy == NULL)
                ptb->hDragProxy = CreateDragProxy(ptb->ci.hwnd, ToolbarDragCallback, FALSE);

            if (ptb->hDragProxy)
                return (LRESULT)GetDragProxyTarget(ptb->hDragProxy, (IDropTarget **)lParam);
        }
        return E_FAIL;

    case WM_GETFONT:
        return (LRESULT)(ptb? ptb->hfontIcon : 0);

    case TB_LOADIMAGES:
        return TBLoadImages(ptb, (UINT_PTR) wParam, (HINSTANCE)lParam);

    case TB_GETTOOLTIPS:
        TB_ForceCreateTooltips(ptb);
        return (LRESULT)ptb->hwndToolTips;

    case TB_SETTOOLTIPS:
        ptb->hwndToolTips = (HWND)wParam;
        break;

    case TB_SETPARENT:
        {
            HWND hwndOld = ptb->ci.hwndParent;

        ptb->ci.hwndParent = (HWND)wParam;
        return (LRESULT)hwndOld;
        }

    case TB_GETBUTTONINFOA:
        return TB_OnGetButtonInfoA(ptb, (int)wParam, (LPTBBUTTONINFOA)lParam);

    case TB_SETBUTTONINFOA:
        return TB_OnSetButtonInfoA(ptb, (int)wParam, (LPTBBUTTONINFOA)lParam);

    case TB_GETBUTTONINFO:
        return TB_OnGetButtonInfo(ptb, (int)wParam, (LPTBBUTTONINFO)lParam);

    case TB_SETBUTTONINFO:
        return TB_OnSetButtonInfo(ptb, (int)wParam, (LPTBBUTTONINFO)lParam);

    case TB_CHANGEBITMAP:
        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return(FALSE);

        //
        // Check to see if the new bitmap ID is
        // valid.
        //
        ptbButton = &ptb->Buttons[iPos];
        return TB_OnSetImage(ptb, ptbButton, LOWORD(lParam));

    case TB_GETBITMAP:
        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return(FALSE);
        ptbButton = &ptb->Buttons[iPos];
        return ptbButton->iBitmap;

    case TB_GETBUTTONTEXTA:
        iPos = PositionFromID(ptb, wParam);
        if (iPos >= 0) 
        {
            LPTSTR psz;

            ptbButton = &ptb->Buttons[iPos];
            psz = TB_StrForButton(ptb, ptbButton);
            if (psz)
            {
                // Passing a 0 for the length of the buffer when the
                // buffer is NULL returns the number bytes required
                // to convert the string.
                int cbBuff = WideCharToMultiByte (CP_ACP, 0, psz,
                    -1, NULL, 0, NULL, NULL);

                // We used to pass an obscenly large number for the buffer length,
                // but on checked builds, this causes badness. So no we double-dip
                // into WideCharToMultiByte to calculate the real size required.
                if (lParam)
                {
                    WideCharToMultiByte (CP_ACP, 0, psz,
                        -1, (LPSTR)lParam, cbBuff, NULL, NULL);
                }

                // WideChar include a trailing NULL but we don't want to.
                return cbBuff - 1;
            }
        }
        return -1;

    case TB_GETBUTTONTEXT:
        iPos = PositionFromID(ptb, wParam);
        if (iPos >= 0) 
        {
            LPCTSTR psz;

            ptbButton = &ptb->Buttons[iPos];
            psz = TB_StrForButton(ptb, ptbButton);
            if (psz) 
            {
                if (lParam) 
                {
                    lstrcpy((LPTSTR)lParam, psz);
                }
                return lstrlen(psz);
            }
        }
        return -1;

    case TB_GETBITMAPFLAGS:
        {
            DWORD fFlags = 0;
            HDC hdc = GetDC(NULL);

            if (GetDeviceCaps(hdc, LOGPIXELSY) >= 120)
                fFlags |= TBBF_LARGE;

            ReleaseDC(NULL, hdc);

            return fFlags;
        }

    case TB_SETINDENT:
        ptb->xFirstButton = (int) wParam;
        InvalidateRect (hwnd, NULL, TRUE);
        TBInvalidateItemRects(ptb);
        return 1;

    case TB_SETMAXTEXTROWS:

        if (ptb->nTextRows != (int)wParam) {
            ptb->nTextRows = (int) wParam;
            TBRecalc(ptb);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        return 1;

    case TB_SETLISTGAP:
        ptb->iListGap = (int) wParam;
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case TB_SETDROPDOWNGAP:
        ptb->iDropDownGap = (int) wParam;
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case TB_GETTEXTROWS:
        return ptb->nTextRows;

    case TB_HITTEST:
        return TBHitTest(ptb, ((LPPOINT)lParam)->x, ((LPPOINT)lParam)->y);

    case TB_SETDRAWTEXTFLAGS:
    {
        UINT uOld = ptb->uDrawText;
        ptb->uDrawText = (UINT) (lParam & wParam);
        ptb->uDrawTextMask = (UINT) wParam;
        return uOld;
    }

    case TB_GETEXTENDEDSTYLE:
        return (ptb->dwStyleEx);

    case TB_SETEXTENDEDSTYLE:
    {
        DWORD dwRet = ptb->dwStyleEx;
        TBSetStyleEx(ptb, (DWORD) lParam, (DWORD) wParam);
        return dwRet;
    }
    case TB_SETBOUNDINGSIZE:
    {
        LPSIZE lpSize = (LPSIZE)lParam;
        ptb->sizeBound = *lpSize;
        break;
    }
    case TB_GETCOLORSCHEME:
    {
        LPCOLORSCHEME lpclrsc = (LPCOLORSCHEME) lParam;
        if (lpclrsc) {
            if (lpclrsc->dwSize == sizeof(COLORSCHEME))
                *lpclrsc = ptb->clrsc;
        }
        return (LRESULT) lpclrsc;
    }

    case TB_SETCOLORSCHEME:
    {
        if (lParam) {
            if (((LPCOLORSCHEME) lParam)->dwSize == sizeof(COLORSCHEME)) {
                ptb->clrsc.clrBtnHighlight = ((LPCOLORSCHEME) lParam)->clrBtnHighlight;
                ptb->clrsc.clrBtnShadow = ((LPCOLORSCHEME) lParam)->clrBtnShadow;
                InvalidateRect(hwnd, NULL, FALSE);
                if (ptb->ci.style & WS_BORDER)
                    CCInvalidateFrame(hwnd);
            }
        }
    }
    break;

    case TB_SETWINDOWTHEME:
        if (lParam)
        {
            SetWindowTheme(hwnd, (LPWSTR)lParam, NULL);
            TB_ForceCreateTooltips(ptb);
            if (ptb->hwndToolTips)
            {
                SendMessage(ptb->hwndToolTips, TTM_SETWINDOWTHEME, wParam, lParam);
            }
        }
        break;

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_TOOLBAR;
        goto DoDefault;

    case WM_NULL:
            // Trap failed RegsiterWindowMessages;
        break;

    case WM_THEMECHANGED:
        if (ptb->hTheme)
            CloseThemeData(ptb->hTheme);

        ptb->hTheme = OpenThemeData(ptb->ci.hwnd, L"Toolbar");
        TBAutoSize(ptb);
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

        CCSendNotify(&ptb->ci, NM_THEMECHANGED, NULL);
        break;

    default:
    {
        LRESULT lres;
        if (g_uDragImages == uMsg)
            return TBGenerateDragImage(ptb, (SHDRAGIMAGE*)lParam);

        if (CCWndProc(&ptb->ci, uMsg, wParam, lParam, &lres))
            return lres;
    }
DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0L;
}


int TB_CalcWidth(PTBSTATE ptb, int iHeight)
{
    RECT rc;
    int iWidth = 0;
    int iMaxBtnWidth = 0;  // ptb->iButWidth isn't always width of widest button
    LPTBBUTTONDATA pButton, pBtnLast;
    pBtnLast = &(ptb->Buttons[ptb->iNumButtons]);

    for(pButton = ptb->Buttons; pButton < pBtnLast; pButton++)
    {
        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            int iBtnWidth = TBWidthOfButton(ptb, pButton, NULL);
            iWidth += iBtnWidth + ptb->cxButtonSpacing;
            iMaxBtnWidth = max(iMaxBtnWidth, iBtnWidth);
        }

    }

    if (ptb->ci.style & TBSTYLE_WRAPABLE) {
        //Make sure the height is a multiple of button height
        iHeight += ptb->cyButtonSpacing;
        iHeight -= (iHeight % (ptb->iButHeight + ptb->cyButtonSpacing));
        iHeight -= ptb->cyButtonSpacing;
        if (iHeight < ptb->iButHeight)
            iHeight = ptb->iButHeight;

        WrapToolbar(ptb, iWidth, &rc, NULL);

        // if wrapping at full width gives us a height that's too big,
        // then there's nothing we can do because widening it still keeps us at 1 row
        if (iHeight > RECTHEIGHT(rc)) {
            int iPrevWidth;
            BOOL fDivide = TRUE; //first start by dividing for speed, then narrow it down by subtraction

            TraceMsg(TF_TOOLBAR, "Toolbar: performing expensive width calculation!");

            while (iMaxBtnWidth < iWidth) {
                iPrevWidth = iWidth;
                if (fDivide)
                    iWidth = (iWidth * 2) / 3;
                else
                    iWidth -= ptb->iButWidth;

                if (iWidth == iPrevWidth)
                    break;

                WrapToolbar(ptb, iWidth, &rc, NULL);

                if (iHeight < RECTHEIGHT(rc)) {
                    iWidth = iPrevWidth;
                    if (fDivide) {
                        // we've overstepped on dividing.  go to the previous width
                        // that was ok, and now try subtracting one button at a time
                        fDivide = FALSE;
                    } else
                        break;
                }
            };

            WrapToolbar(ptb, iWidth, &rc, NULL);
            iWidth = max(RECTWIDTH(rc), iMaxBtnWidth);
        }


        // WrapToolbar above has the side effect of actually modifying
        // the layout.  we need to restore it after doing all this calculations
        TBAutoSize(ptb);
    }

    return iWidth;
}


LRESULT TB_OnScroll(PTBSTATE ptb, LPNMHDR pnm)
{
    POINT pt, ptTemp;
    LPNMPGSCROLL pscroll = (LPNMPGSCROLL)pnm;
    int iDir = pscroll->iDir;
    RECT rcTemp, rc = pscroll->rcParent;
    int parentsize = 0;
    int scroll = pscroll->iScroll;
    int iButton = 0;
    int iButtonSize  = ptb->iButHeight;
    int y = 0;
    int iCurrentButton = 0;
   //This variable holds the number of buttons in a row
    int iButInRow = 0;

    pt.x = pscroll->iXpos;
    pt.y = pscroll->iYpos;
    ptTemp = pt;

    //We need to add the offset of the toolbar to the scroll position to get the
    //correct scroll positon in terms of toolbar window
    pt.x += ptb->xFirstButton;
    pt.y += ptb->iYPos;
    ptTemp = pt;


    if ((iDir == PGF_SCROLLUP) || (iDir == PGF_SCROLLDOWN))
    {
        //Vertical Mode
        if (ptb->iButWidth == 0 )
        {
            iButInRow = 1;
        }
        else
        {
            iButInRow = RECTWIDTH(rc) / ptb->iButWidth;
        }

    }
    else
    {
        //Horizontal Mode
        iButInRow =  1;
    }
    // if the parent height/width is less than button height/width then set the  number of
    // buttons in a row to be 1
    if (0 == iButInRow)
    {
        iButInRow = 1;
    }

    iCurrentButton = TBHitTest(ptb, pt.x + 1, pt.y + 1);

    //if the button is negative then we have hit a seperator.
    //Convert the index of the seperator into button index
    if (iCurrentButton < 0)
         iCurrentButton = -iCurrentButton - 1;

    switch ( iDir )
    {
    case PGF_SCROLLUP:
    case PGF_SCROLLLEFT:
        if(iDir == PGF_SCROLLLEFT)
        {
            FlipRect(&rc);
            FlipPoint(&pt);
            FlipPoint(&ptTemp);
            iButtonSize = ptb->iButWidth;
        }

        //Check if any button is partially visible at the left/top. if so then set the bottom
        // of that button to be our current offset and then scroll. This avoids skipping over
        // certain buttons when partial buttons are displayed at the left or top
        y = pt.y;
        TB_GetItemRect(ptb, iCurrentButton, &rcTemp);
        if(iDir == PGF_SCROLLLEFT)
        {
            FlipRect(&rcTemp);
        }

        if (rcTemp.top  <  y-1)
        {
            iCurrentButton += iButInRow;
        }

        //Now do the actual calculation

        parentsize = RECTHEIGHT(rc);

        //if  the control key is down and we have more than parentsize size of child window
        // then scroll by that amount
        if (pscroll->fwKeys & PGK_CONTROL)

        {
            if ((y - parentsize) > 0 )
            {
                scroll = parentsize;
            }
            else
            {
                scroll = y;
                return 0L;
            }

        } else  if ((y - iButtonSize) > 0 ){
        // we dont have control key down so scroll by one buttonsize
            scroll = iButtonSize;

        } else {
            scroll = pt.y;
            return 0L;
        }
        ptTemp.y -= scroll;

        if(iDir == PGF_SCROLLLEFT)
        {
            FlipPoint(&ptTemp);
        }

        iButton = TBHitTest(ptb, ptTemp.x, ptTemp.y);

        //if the button is negative then we have hit a seperator.
        //Convert the index of the seperator into button index
        if (iButton < 0)
            iButton = -iButton -1 ;

       // if  the hit test gives us the same button as our prevbutton then set the button
       // to one button to the left  of the prev button

       if ((iButton == iCurrentButton) && (iButton >= iButInRow))
       {
           iButton -= iButInRow;
           if ((ptb->Buttons[iButton].fsStyle & BTNS_SEP)  && (iButton >= iButInRow))
           {
               iButton -= iButInRow;
           }
       }
       //When scrolling left if we end up in the middle of some button then we align it to the
       //right of that button this is to avoid scrolling more than the pager window width but if the
       // button happens to be the left button of  our current button then we end up in not scrolling
       //if thats the case then move one more button to the left.


       if (iButton == iCurrentButton-iButInRow)
       {
           iButton -= iButInRow;
       }

       TB_GetItemRect(ptb, iButton, &rcTemp);
       if(iDir == PGF_SCROLLLEFT)
       {
           FlipRect(&rcTemp);
       }
       scroll = pt.y - rcTemp.bottom;
       //Set the scroll value
       pscroll->iScroll = scroll;
       break;

    case PGF_SCROLLDOWN:
    case PGF_SCROLLRIGHT:
        {
            RECT rcChild;
            int childsize;

            GetWindowRect(ptb->ci.hwnd, &rcChild);
            if( iDir == PGF_SCROLLRIGHT)
            {
                FlipRect(&rcChild);
                FlipRect(&rc);
                FlipPoint(&pt);
                FlipPoint(&ptTemp);
                iButtonSize = ptb->iButWidth;
            }

            childsize = RECTHEIGHT(rcChild);
            parentsize = RECTHEIGHT(rc);

            //if  the control key is down and we have more than parentsize size of child window
            // then scroll by that amount

            if (pscroll->fwKeys & PGK_CONTROL)
            {
                if ((childsize - pt.y - parentsize) > parentsize)
                {
                    scroll = parentsize;
                }
                else
                {
                    scroll = childsize - pt.y - parentsize;
                    return 0L;
                }

            } else if (childsize - pt.y - parentsize > iButtonSize) {
            // we dont have control key down so scroll by one buttonsize
                scroll = iButtonSize;

            } else {
                pscroll->iScroll = childsize - pt.y - parentsize;
                return 0L;
            }
            ptTemp.y += scroll;

            if(iDir == PGF_SCROLLRIGHT)
            {
                FlipPoint(&ptTemp);
            }

            iButton = TBHitTest(ptb, ptTemp.x, ptTemp.y);

            //if the button is negative then we have hit a seperator.
            //Convert the index of the seperator into button index
                if (iButton < 0)
                iButton = -iButton - 1 ;

            if ((iButton == iCurrentButton) && ((iButton + iButInRow) < ptb->iNumButtons))
            {
                iButton += iButInRow;
                if ((ptb->Buttons[iButton].fsStyle & BTNS_SEP)  && ((iButton + iButInRow) < ptb->iNumButtons))
                {
                    iButton += iButInRow;
                }
            }

            TB_GetItemRect(ptb, iButton, &rcTemp);
            if(iDir == PGF_SCROLLRIGHT)
            {
                FlipRect(&rcTemp);
            }
            scroll = rcTemp.top  - pt.y ;

            //Set the scroll value
            pscroll->iScroll = scroll;
            break;
        }
    }
    return 0L;
}

int TB_CalcHeight(PTBSTATE ptb)
{
    int iHeight = 0;
    int i;

    ASSERT(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL);
    ASSERT(!(ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN));

    for (i = 0; i < ptb->iNumButtons; i++)
    {
        if (!(ptb->Buttons[i].fsState & TBSTATE_HIDDEN))
        {
            if (ptb->Buttons[i].fsStyle & BTNS_SEP)
                iHeight += (TBGetSepHeight(ptb, &ptb->Buttons[i])) + ptb->cyButtonSpacing;
            else
                iHeight += ptb->iButHeight + ptb->cyButtonSpacing;
        }
    }

    if (ptb->iNumButtons > 0)
        iHeight -= ptb->cyButtonSpacing;

    return iHeight;
}

LRESULT TB_OnCalcSize(PTBSTATE ptb, LPNMHDR pnm)
{
    LPNMPGCALCSIZE pcalcsize = (LPNMPGCALCSIZE)pnm;
    RECT rc;
    BOOL fUpdate = FALSE;

    switch(pcalcsize->dwFlag)
    {
    case PGF_CALCHEIGHT:

        if (ptb->szCached.cx == pcalcsize->iWidth)
            pcalcsize->iHeight = ptb->szCached.cy;
        else
        {
            if (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN)
            {
                WrapToolbarCol(ptb, ptb->sizeBound.cy,  &rc, NULL);
                pcalcsize->iWidth = RECTWIDTH(rc);
                pcalcsize->iHeight = RECTHEIGHT(rc);
            }
            else if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
            {
                pcalcsize->iHeight = TB_CalcHeight(ptb);
            }
            else
            {
                // Bug#94368: this WrapToolbar call can modify toolbar layout ...
                // seems busted.  should perhaps call TBAutoSize after to restore.
                WrapToolbar(ptb, pcalcsize->iWidth,  &rc, NULL);
                pcalcsize->iHeight = RECTHEIGHT(rc);
            }

            fUpdate = TRUE;
        }
        break;

    case PGF_CALCWIDTH:
        if (ptb->szCached.cy == pcalcsize->iHeight) 
        {
            pcalcsize->iWidth = ptb->szCached.cx;
        } 
        else 
        {
            pcalcsize->iWidth = TB_CalcWidth(ptb, pcalcsize->iHeight);

            fUpdate = TRUE;
        }
        break;
    }

    ptb->szCached.cx = pcalcsize->iWidth;
    ptb->szCached.cy = pcalcsize->iHeight;
    return 0L;
}

LRESULT TB_OnPagerControlNotify(PTBSTATE ptb, LPNMHDR pnm)
{
    switch(pnm->code) {
    case PGN_SCROLL:
        return TB_OnScroll(ptb, pnm);
        break;
    case PGN_CALCSIZE:
        return TB_OnCalcSize(ptb, pnm);
        break;
    }
    return 0L;
}


BOOL TBGetMaxSize(PTBSTATE ptb, LPSIZE lpsize)
{
    if (lpsize)
    {
        if (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN)
        {
            ASSERT(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL);
            lpsize->cx = RECTWIDTH(ptb->rc);
            lpsize->cy = RECTHEIGHT(ptb->rc);
        }
        else
        {
            lpsize->cx = ptb->iButWidth;
            lpsize->cy = ptb->iButHeight;
            TB_GetIdealSize(ptb, lpsize, (ptb->ci.style & CCS_VERT));
        }
        return TRUE;
    }
    return FALSE;
}


void TBGetItem(PTBSTATE ptb, LPTBBUTTONDATA ptButton, LPNMTBDISPINFO ptbdi)
{

    ptbdi->idCommand = ptButton->idCommand;
    ptbdi->iImage  =  -1;
    ptbdi->lParam  = ptButton->dwData;


    CCSendNotify(&ptb->ci, TBN_GETDISPINFO, &(ptbdi->hdr));

    if(ptbdi->dwMask & TBNF_DI_SETITEM) {
        if(ptbdi->dwMask & TBNF_IMAGE)
            ptButton->iBitmap = ptbdi->iImage;
    }

}

BOOL TBGetInfoTip(PTBSTATE ptb, LPTOOLTIPTEXT lpttt, LPTBBUTTONDATA pTBButton)
{
    NMTBGETINFOTIP git;
    TCHAR   szBuf[INFOTIPSIZE];

    szBuf[0] = 0;
    git.pszText = szBuf;
    git.cchTextMax = ARRAYSIZE(szBuf);
    git.iItem = pTBButton->idCommand;
    git.lParam = pTBButton->dwData;

    CCSendNotify(&ptb->ci, TBN_GETINFOTIP, &git.hdr);

    if (git.pszText && git.pszText[0]) {
        // if they didn't fill anything in, go to the default stuff
        // without modifying the notify structure

        Str_Set(&ptb->pszTip, git.pszText);
        lpttt->lpszText = ptb->pszTip;
        return lpttt->lpszText && lpttt->lpszText[0];
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\tooltips.cpp ===
#include <ctlspriv.h>
#include <markup.h>

/* current serious issues in markup conversion:
    = theme codepath not supported 
    = notify in callback needs some help    */

#define TF_TT 0x10

//#define TTDEBUG

#define ACTIVE          0x10
#define BUTTONISDOWN    0x20
#define BUBBLEUP        0x40
#define VIRTUALBUBBLEUP 0x80  // this is for dead areas so we won't
                                //wait after moving through dead areas
#define NEEDTEXT        0x100 // Set when processing a TTN_NEEDTEXT, to avoid recursion
                                // if the app sends us other messages during the callback
#define TRACKMODE       0x01

#define NOFONT     (HFONT) 1 // Used to clean up the font

#define MAXTIPSIZE       128
#define INITIALTIPSIZE    80
#define XTEXTOFFSET        2
#define YTEXTOFFSET        1
#define XBALLOONOFFSET    10
#define YBALLOONOFFSET     8
#define BALLOON_X_CORNER  13
#define BALLOON_Y_CORNER  13
#define STEMOFFSET        16
#define STEMHEIGHT        20
#define STEMWIDTH         14
#define MINBALLOONWIDTH   30 // min width for stem to show up

#define TTT_INITIAL        1
#define TTT_RESHOW         2
#define TTT_POP            3
#define TTT_AUTOPOP        4
#define TTT_FADESHOW       5
#define TTT_FADEHIDE       6

#define TIMEBETWEENANIMATE  2000        // 2 Seconds between animates

#define MAX_TIP_CHARACTERS 100
#define TITLEICON_DIST    (g_cySmIcon / 2)     // Distance from Icon to Title
#define TITLE_INFO_DIST   (g_cySmIcon / 3)    // Distance from the Title to the Tip Text

#define TT_FADEHIDEDECREMENT    30
#define TT_MAXFADESHOW          255     // Opaque as max....
#define TT_FADESHOWINCREMENT    40
#define TTTT_FADESHOW           30
#define TTTT_FADEHIDE           30

typedef struct
{
    UINT cbSize;
    UINT uFlags;
    HWND hwnd;
    UINT uId;
    RECT rect;
    HINSTANCE hinst;
    LPSTR lpszText;
} WIN95TTTOOLINFO;

class CToolTipsMgr : public IMarkupCallback
{
protected:
    ~CToolTipsMgr();    // don't let anyone but our ::Release() call delete

public:
    CToolTipsMgr();

    //  IUnknown
    STDMETHODIMP         QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IMarkupCallback
    STDMETHODIMP GetState(UINT uState);
    STDMETHODIMP Notify(int nCode, int iLink);
    STDMETHODIMP InvalidateRect(RECT* prc);
    STDMETHODIMP OnCustomDraw(DWORD dwDrawStage, HDC hdc, const RECT *prc, DWORD dwItemSpec, UINT uItemState, LRESULT *pdwResult) { return E_NOTIMPL;};

    CCONTROLINFO _ci;
    LONG _cRef;
    int iNumTools;
    int iDelayTime;
    int iReshowTime;
    int iAutoPopTime;
    PTOOLINFO tools;
    TOOLINFO *pCurTool;
    BOOL fMyFont;
    HFONT hFont;
    HFONT hFontUnderline;
    DWORD dwFlags;

    // Timer info;
    UINT_PTR idTimer;
    POINT pt;

    UINT_PTR idtAutoPop;

    // Tip title buffer
    LPTSTR lpTipTitle;
    UINT   cchTipTitle; 
    UINT   uTitleBitmap;
    int    iTitleHeight;
    HIMAGELIST himlTitleBitmaps;

    POINT ptTrack; // the saved track point from TTM_TRACKPOSITION

    BOOL fBkColorSet :1;
    BOOL fTextColorSet :1;
    BOOL fUnderStem : 1;        // true if stem is under the balloon
    BOOL fInWindowFromPoint:1;  // handling a TTM_WINDOWFROMPOINT message
    BOOL fEverShown:1;          // Have we ever been shown before?
    COLORREF clrTipBk;          // This is joeb's idea...he wants it
    COLORREF clrTipText;        // to be able to _blend_ more, so...
    
    int  iMaxTipWidth;          // the maximum tip width
    RECT rcMargin;              // margin offset b/t border and text
    int  iStemHeight;           // balloon mode stem/wedge height
    DWORD dwLastDisplayTime;    // The tick count taken at the last display. Used for animate puroposes.

    HTHEME hTheme;
    int iFadeState;
    RECT rcClose;
    int iStateId;

    // Markup additions
    IControlMarkup* pMarkup;                  // A markup we keep around for compatibility (old versions of TOOLINFO)
};


#define TTToolHwnd(pTool)  ((pTool->uFlags & TTF_IDISHWND) ? (HWND)pTool->uId : pTool->hwnd)
#define IsTextPtr(lpszText)  (((lpszText) != LPSTR_TEXTCALLBACK) && (!IS_INTRESOURCE(lpszText)))

inline IControlMarkup* GetToolMarkup(TOOLINFO *pTool)
{
    return (IControlMarkup*)pTool->lpReserved;
}

IControlMarkup* CheckToolMarkup(TOOLINFO *pTool)
{
    return (pTool && (pTool->cbSize == TTTOOLINFOW_V3_SIZE) && pTool->lpReserved)
        ? GetToolMarkup(pTool) : NULL;
}

IControlMarkup* GetCurToolBestMarkup(CToolTipsMgr *pTtm)
{
    return CheckToolMarkup(pTtm->pCurTool) ? GetToolMarkup(pTtm->pCurTool) : pTtm->pMarkup;
}

LRESULT WINAPI ToolTipsWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
void TTSetDelayTime(CToolTipsMgr *pTtm, WPARAM wParam, LPARAM lParam);
int TTGetDelayTime(CToolTipsMgr *pTtm, WPARAM wParam);

BOOL ThunkToolInfoAtoW(LPTOOLINFOA lpTiA, LPTOOLINFOW lpTiW, BOOL bThunkText, UINT uiCodePage);
BOOL ThunkToolInfoWtoA(LPTOOLINFOW lpTiW, LPTOOLINFOA lpTiA, UINT uiCodePage);
BOOL ThunkToolTipTextAtoW(LPTOOLTIPTEXTA lpTttA, LPTOOLTIPTEXTW lpTttW, UINT uiCodePage);

BOOL InitToolTipsClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    // See if we must register a window class
    wc.lpfnWndProc = ToolTipsWndProc;
    wc.lpszClassName = c_szSToolTipsClass;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon = NULL;
    wc.lpszMenuName = NULL;
    wc.hbrBackground = (HBRUSH)(NULL);
    wc.hInstance = hInstance;
    wc.style = CS_DBLCLKS | CS_GLOBALCLASS | CS_DROPSHADOW;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(CToolTipsMgr *);

    if (!RegisterClass(&wc) && !GetClassInfo(hInstance, c_szSToolTipsClass, &wc))
    {
        return FALSE;
    }
    return TRUE;
}

// make this a member of CToolTipsMgr when that becomes a C++ class

CToolTipsMgr::CToolTipsMgr() : _cRef(1) 
{
}

CToolTipsMgr::~CToolTipsMgr()
{
}

STDMETHODIMP CToolTipsMgr::QueryInterface(REFIID riid, void** ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CToolTipsMgr, IMarkupCallback),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CToolTipsMgr::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CToolTipsMgr::Release()
{
    if (InterlockedDecrement(&_cRef))
    {
        return _cRef;
    }

    delete this;
    return 0;
}

STDMETHODIMP CToolTipsMgr::GetState(UINT uState)
{
    HRESULT hr = E_FAIL;    

    switch (uState)
    {
    case MARKUPSTATE_FOCUSED: 
        hr = (GetFocus() == _ci.hwnd) ? S_OK : S_FALSE;
        break;

    case MARKUPSTATE_ALLOWMARKUP:
        if (pCurTool && (pCurTool->uFlags & TTF_PARSELINKS))
        {
            hr = S_OK;
        }
        break;
    }
    return hr;
}

STDMETHODIMP CToolTipsMgr::Notify(int nCode, int iLink)
{
    HRESULT hr = S_OK;

    if (nCode == MARKUPMESSAGE_WANTFOCUS)
    {
        // Markup complaining it wants focus due to a mouse click
        SetFocus(_ci.hwnd);
    }

    if (nCode == MARKUPMESSAGE_KEYEXECUTE || nCode == MARKUPMESSAGE_CLICKEXECUTE)
    {
        // Markup didn't SHELLEXEC a Url and is telling us about it.

        // Get manager
        CToolTipsMgr *pTtm = this; 

        // Send a notify back to the parent window
        NMLINK nm;
        ZeroMemory(&nm, sizeof(nm));
        nm.hdr.hwndFrom = _ci.hwnd;
        nm.hdr.idFrom   = (UINT_PTR)GetWindowLong(_ci.hwnd, GWL_ID);
        nm.hdr.code     = TTN_LINKCLICK;

        // Fill LITEM with szID, szUrl, and iLink
        DWORD dwCchID = ARRAYSIZE(nm.item.szID);
        DWORD dwCchURL = ARRAYSIZE(nm.item.szUrl);
        nm.item.iLink   = iLink;
        GetCurToolBestMarkup(pTtm)->GetLinkText(iLink, MARKUPLINKTEXT_ID, nm.item.szID, &dwCchID);
        GetCurToolBestMarkup(pTtm)->GetLinkText(iLink, MARKUPLINKTEXT_URL, nm.item.szUrl, &dwCchURL);

        if (pTtm->pCurTool)
        {
            hr = (HRESULT) SendMessage(pTtm->pCurTool->hwnd, WM_NOTIFY, nm.hdr.idFrom, (LPARAM)&nm);        
        }
    }       
    return hr;
}

STDMETHODIMP CToolTipsMgr::InvalidateRect(RECT* prc)
{
    return S_OK;
}

/* _  G E T  H C U R S O R  P D Y 3 */
/*-------------------------------------------------------------------------
 %%Function: _GetHcursorPdy3
 %%Contact: migueldc

 With the new mouse drivers that allow you to customize the mouse
 pointer size, GetSystemMetrics returns useless values regarding
 that pointer size.

 Assumptions:
 1. The pointer's width is equal to its height. We compute
 its height and infer its width.
 2. The pointer's leftmost pixel is located in the 0th column
 of the bitmap describing it.
 3. The pointer's topmost pixel is located in the 0th row
 of the bitmap describing it.

 This function looks at the mouse pointer bitmap,
 to find out the height of the mouse pointer (not returned),
 the vertical distance between the cursor's hot spot and
 the cursor's lowest visible pixel (pdyBottom),
 the horizontal distance between the hot spot and the pointer's
 left edge (pdxLeft) annd the horizontal distance between the
 hot spot and the pointer's right edge (pdxRight).
 -------------------------------------------------------------------------*/
typedef WORD CURMASK;
#define _BitSizeOf(x) (sizeof(x)*8)

void _GetHcursorPdy3(int *pdxRight, int *pdyBottom)
{
    int i;
    int iXOR = 0;
    int dy, dx;
    CURMASK CurMask[16*8];
    ICONINFO iconinfo;
    BITMAP bm;

    *pdyBottom = 0;
    *pdxRight  = 0;

    HCURSOR hCursor = GetCursor();
    if (hCursor)
    {
        *pdyBottom = 16; //best guess
        *pdxRight = 16;  //best guess
        if (!GetIconInfo(hCursor, &iconinfo))
            return;
        if (!GetObject(iconinfo.hbmMask, sizeof(bm), (LPSTR)&bm))
            return;
        if (!GetBitmapBits(iconinfo.hbmMask, sizeof(CurMask), CurMask))
            return;
        i = (int)(bm.bmWidth * bm.bmHeight / _BitSizeOf(CURMASK));
    
        if (!iconinfo.hbmColor) 
        {
            // if no color bitmap, then the hbmMask is a double height bitmap
            // with the cursor and the mask stacked.
            iXOR = i - 1;
            i /= 2;    
        } 
    
        if (i >= sizeof(CurMask)) i = sizeof(CurMask) -1;
        if (iXOR >= sizeof(CurMask)) iXOR = 0;
    
        for (i--; i >= 0; i--)
        {
            if (CurMask[i] != 0xFFFF || (iXOR && (CurMask[iXOR--] != 0)))
                break;
        }
    
        if (iconinfo.hbmColor) 
            DeleteObject(iconinfo.hbmColor);

        if (iconinfo.hbmMask) 
            DeleteObject(iconinfo.hbmMask);

        // Compute the pointer height
        dy = (i + 1) * _BitSizeOf(CURMASK) / (int)bm.bmWidth;
        dx = (i + 1) * _BitSizeOf(CURMASK) / (int)bm.bmHeight;

        // Compute the distance between the pointer's lowest, left, rightmost
        //  pixel and the HotSpotspot
        *pdyBottom = dy - (int)iconinfo.yHotspot;
        *pdxRight  = dx - (int)iconinfo.xHotspot;
    }
}

BOOL FadeEnabled()
{
    BOOL fFadeTurnedOn = FALSE;
    BOOL fAnimate = TRUE;
    SystemParametersInfo(SPI_GETTOOLTIPANIMATION, 0, &fAnimate, 0);
    SystemParametersInfo(SPI_GETTOOLTIPFADE, 0, &fFadeTurnedOn, 0);

    return fFadeTurnedOn && fAnimate;
}


// this returns the values in work area coordinates because
// that's what set window placement uses
void _GetCursorLowerLeft(int *piLeft, int *piTop, int *piWidth, int *piHeight)
{
    DWORD dwPos;
    
    dwPos = GetMessagePos();
    _GetHcursorPdy3(piWidth, piHeight);
    *piLeft = GET_X_LPARAM(dwPos);
    *piTop  = GET_Y_LPARAM(dwPos) + *piHeight;
}

void ToolTips_NewFont(CToolTipsMgr *pTtm, HFONT hFont)
{
    if (pTtm->fMyFont && pTtm->hFont)
    {
        DeleteObject(pTtm->hFont);
        pTtm->fMyFont = FALSE;
    }

    if (!hFont)
    {
        hFont = CCCreateStatusFont();
        pTtm->fMyFont = TRUE;
        
        if (!hFont) 
        {
            hFont = g_hfontSystem;
            pTtm->fMyFont = FALSE;
        }
    }

    pTtm->hFont = hFont;

    if (pTtm->hFontUnderline)
    {
        DeleteObject(pTtm->hFontUnderline);
        pTtm->hFontUnderline = NULL;
    }

    if (hFont != NOFONT)
    {
        pTtm->hFontUnderline = CCCreateUnderlineFont(hFont);
    }

    pTtm->_ci.uiCodePage = GetCodePageForFont(hFont);
}

BOOL ChildOfActiveWindow(HWND hwndChild)
{
    HWND hwnd = hwndChild;
    HWND hwndActive = GetForegroundWindow();

    while (hwnd)
    {
        if (hwnd == hwndActive)
            return TRUE;
        else
            hwnd = GetParent(hwnd);
    }
    return FALSE;
}

void PopBubble2(CToolTipsMgr *pTtm, BOOL fForce)
{
    BOOL fFadeTurnedOn = FadeEnabled();

    // Can't be pressed if we're down...
    pTtm->iStateId = TTCS_NORMAL;

    // we're at least waiting to show;
    DebugMsg(TF_TT, TEXT("PopBubble (killing timer)"));
    if (pTtm->idTimer) 
    {
        KillTimer(pTtm->_ci.hwnd, pTtm->idTimer);
        pTtm->idTimer = 0;
    }

    if (pTtm->idtAutoPop) 
    {
        KillTimer(pTtm->_ci.hwnd, pTtm->idtAutoPop);
        pTtm->idtAutoPop = 0;
    }


    if (IsWindowVisible(pTtm->_ci.hwnd) && pTtm->pCurTool) 
    {
        NMHDR nmhdr;
        nmhdr.hwndFrom = pTtm->_ci.hwnd;
        nmhdr.idFrom = pTtm->pCurTool->uId;
        nmhdr.code = TTN_POP;

        SendNotifyEx(pTtm->pCurTool->hwnd, (HWND)-1,
                     TTN_POP, &nmhdr,
                     (pTtm->pCurTool->uFlags & TTF_UNICODE) ? 1 : 0);
    }

    KillTimer(pTtm->_ci.hwnd, TTT_POP);
    KillTimer(pTtm->_ci.hwnd, TTT_FADEHIDE);
    KillTimer(pTtm->_ci.hwnd, TTT_FADESHOW);
    if (pTtm->iFadeState > 0 && !fForce && fFadeTurnedOn)
    {
        SetTimer(pTtm->_ci.hwnd, TTT_FADEHIDE, TTTT_FADEHIDE, NULL);
    }
    else
    {
        ShowWindow(pTtm->_ci.hwnd, SW_HIDE);
    }

    pTtm->dwFlags &= ~(BUBBLEUP|VIRTUALBUBBLEUP);
    pTtm->pCurTool = NULL;
}

void NEAR PASCAL PopBubble(CToolTipsMgr *pTtm)
{
    PopBubble2(pTtm, FALSE);
}

CToolTipsMgr *ToolTipsMgrCreate(HWND hwnd, CREATESTRUCT* lpCreateStruct)
{
    CToolTipsMgr *pTtm = new CToolTipsMgr;
    if (pTtm) 
    {
        CIInitialize(&pTtm->_ci, hwnd, lpCreateStruct);

        // LPTR zeros the rest of the struct for us
        TTSetDelayTime(pTtm, TTDT_AUTOMATIC, (LPARAM)-1);
        pTtm->dwFlags = ACTIVE;
        pTtm->iMaxTipWidth = -1;
        pTtm->_ci.fDPIAware = TRUE;
        
        // These are the defaults (straight from cutils.c), 
        // but you can always change them...
        pTtm->clrTipBk = g_clrInfoBk;
        pTtm->clrTipText = g_clrInfoText;
    }
    return pTtm;
}

void TTSetTimer(CToolTipsMgr *pTtm, int id)
{
    int iDelayTime = 0;

    if (pTtm->idTimer) 
    {
        KillTimer(pTtm->_ci.hwnd, pTtm->idTimer);
    }

    switch (id) 
    {
    case TTT_POP:
    case TTT_RESHOW:
        iDelayTime = pTtm->iReshowTime;
        if (iDelayTime < 0)
            iDelayTime = GetDoubleClickTime() / 5;
        break;

    case TTT_INITIAL:
        iDelayTime = pTtm->iDelayTime;
        if (iDelayTime < 0)
            iDelayTime = GetDoubleClickTime();
        break;

    case TTT_AUTOPOP:
        iDelayTime = pTtm->iAutoPopTime;
        if (iDelayTime < 0)
            iDelayTime = GetDoubleClickTime() * 10;
        pTtm->idtAutoPop = SetTimer(pTtm->_ci.hwnd, id, iDelayTime, NULL);
        return;
    }

    
    DebugMsg(TF_TT, TEXT("TTSetTimer %d for %d ms"), id, iDelayTime);
    
    if (SetTimer(pTtm->_ci.hwnd, id, iDelayTime, NULL) &&
        (id != TTT_POP)) 
    {
        pTtm->idTimer = id;
        GetCursorPos(&pTtm->pt);
    }
}

//
//  Double-hack to solve blinky-tooltips problems.
//
//  fInWindowFromPoint makes us temporarily transparent.
//
//  Clear the WS_DISABLED flag to trick USER into hit-testing against us.
//  USER by default skips disabled windows.  Restore the flag afterwards.
//  VB in particular likes to run around disabling all top-level windows
//  owned by his process.
//
//  We must use SetWindowBits() instead of EnableWindow() because
//  EnableWindow() will mess with the capture and focus.
//
HWND TTWindowFromPoint(CToolTipsMgr *pTtm, LPPOINT ppt)
{
    HWND hwnd;
    DWORD dwStyle;
    dwStyle = SetWindowBits(pTtm->_ci.hwnd, GWL_STYLE, WS_DISABLED, 0);
    pTtm->fInWindowFromPoint = TRUE;
    hwnd = (HWND)SendMessage(pTtm->_ci.hwnd, TTM_WINDOWFROMPOINT, 0, (LPARAM)ppt);
    pTtm->fInWindowFromPoint = FALSE;
    SetWindowBits(pTtm->_ci.hwnd, GWL_STYLE, WS_DISABLED, dwStyle);
    return hwnd;
}

BOOL ToolHasMoved(CToolTipsMgr *pTtm)
{
    // this is in case Raymond pulls something sneaky like moving
    // the tool out from underneath the cursor.

    RECT rc;
    TOOLINFO *pTool = pTtm->pCurTool;

    if (!pTool)
        return TRUE;

    HWND hwnd = TTToolHwnd(pTool);

    // if the window is no longer visible, or is no long a child
    // of the active (without the always tip flag)
    // also check window at point to ensure that the window isn't covered
    if (IsWindowVisible(hwnd) &&
        ((pTtm->_ci.style & TTS_ALWAYSTIP) || ChildOfActiveWindow(hwnd)) &&
        (hwnd == TTWindowFromPoint(pTtm, &pTtm->pt))) 
    {
        GetWindowRect(hwnd, &rc);
        if (PtInRect(&rc, pTtm->pt))
            return FALSE;
    }

    return TRUE;
}

BOOL MouseHasMoved(CToolTipsMgr *pTtm)
{
    POINT pt;
    GetCursorPos(&pt);
    return ((pt.x != pTtm->pt.x) || (pt.y != pTtm->pt.y));
}

TOOLINFO *FindTool(CToolTipsMgr *pTtm, TOOLINFO *pToolInfo)
{
    if (!(pTtm && pToolInfo))
    {
        DebugMsg(TF_ALWAYS, TEXT("FindTool passed invalid argumnet. Exiting..."));
        return NULL;
    }

    
    if (pToolInfo->cbSize > sizeof(TOOLINFO))
        return NULL;
    
    TOOLINFO *pTool = NULL;
    // you can pass in an index or a toolinfo descriptor
    if (IS_INTRESOURCE(pToolInfo)) 
    {
        int i = PtrToUlong(pToolInfo);
        if (i < pTtm->iNumTools) 
        {
            pTool = &pTtm->tools[i];
            return pTool;
       } 
    }
    else
    {
        for (int i = 0; i < pTtm->iNumTools; i++) 
        {
            pTool = &pTtm->tools[i];
            if ((pTool->hwnd == pToolInfo->hwnd) &&
                (pTool->uId == pToolInfo->uId))
            {
                return pTool;
            }
        }
    }
    return NULL;
}


LRESULT WINAPI TTSubclassProc(HWND hwnd, UINT message, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData);

void TTUnsubclassHwnd(HWND hwnd, HWND hwndTT, BOOL fForce)
{
    ULONG_PTR dwRefs;
    
    if (IsWindow(hwnd) &&
        GetWindowSubclass(hwnd, TTSubclassProc, (UINT_PTR)hwndTT, (PULONG_PTR) &dwRefs))
    {
        if (!fForce && (dwRefs > 1))
            SetWindowSubclass(hwnd, TTSubclassProc, (UINT_PTR)hwndTT, dwRefs - 1);
        else
            RemoveWindowSubclass(hwnd, TTSubclassProc, (UINT_PTR)hwndTT);
    }
}

LRESULT WINAPI TTSubclassProc(HWND hwnd, UINT message, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData)
{
    if (((message >= WM_MOUSEFIRST) && (message <= WM_MOUSELAST)) ||
        (message == WM_NCMOUSEMOVE))
    {
        RelayToToolTips((HWND)uIdSubclass, hwnd, message, wParam, lParam);
    }
    else if (message == WM_NCDESTROY)
    {
        TTUnsubclassHwnd(hwnd, (HWND)uIdSubclass, TRUE);
    }

    return DefSubclassProc(hwnd, message, wParam, lParam);
}

void TTSubclassHwnd(TOOLINFO *pTool, HWND hwndTT)
{
    HWND hwnd = TTToolHwnd(pTool);
    if (IsWindow(hwnd))
    {
        ULONG_PTR dwRefs;

        GetWindowSubclass(hwnd, TTSubclassProc, (UINT_PTR)hwndTT, &dwRefs);
        SetWindowSubclass(hwnd, TTSubclassProc, (UINT_PTR)hwndTT, dwRefs + 1);
    }
}
    
    
void TTSetTipText(TOOLINFO *pTool, LPTSTR lpszText)
{
    // if it wasn't alloc'ed before, set it to NULL now so we'll alloc it
    // otherwise, don't touch it and it will be realloced
    if (!IsTextPtr(pTool->lpszText)) 
    {
        pTool->lpszText = NULL;
    }
    
    if (IsTextPtr(lpszText)) 
    {
        DebugMsg(TF_TT, TEXT("TTSetTipText %s"), lpszText);
        Str_Set(&pTool->lpszText, lpszText);
    } 
    else 
    {
        // if it was alloc'ed before free it now.
        Str_Set(&pTool->lpszText, NULL);
        pTool->lpszText = lpszText;
    }
}

void CopyTool(TOOLINFO *pTo, TOOLINFO *pFrom)
{
    ASSERT(pFrom->cbSize <= sizeof(TOOLINFO));
    memcpy(pTo, pFrom, pFrom->cbSize); 
    pTo->lpszText = NULL;       // make sure these are zero
    pTo->lpReserved = NULL;
}


LRESULT AddTool(CToolTipsMgr *pTtm, TOOLINFO *pToolInfo)
{
    if (pToolInfo->cbSize > sizeof(TOOLINFO)) 
    {
        ASSERT(0);
        return 0;   // app bug, bad struct size
    }

    // on failure to alloc do nothing.
    TOOLINFO *ptoolsNew = (TOOLINFO *)CCLocalReAlloc(pTtm->tools, sizeof(TOOLINFO) * (pTtm->iNumTools + 1));
    if (!ptoolsNew)
        return 0;
    
    if (pTtm->tools) 
    {
        // realloc could have moved stuff around.  repoint pCurTool
        if (pTtm->pCurTool) 
        {
            pTtm->pCurTool = ((PTOOLINFO)ptoolsNew) + (pTtm->pCurTool - pTtm->tools);
        }
    }
    
    pTtm->tools = ptoolsNew;

    TOOLINFO *pTool = &pTtm->tools[pTtm->iNumTools];
    pTtm->iNumTools++;
    CopyTool(pTool, pToolInfo); 

    // If the tooltip will be displayed within a RTL mirrored window, then
    // simulate mirroring the tooltip. [samera]

    if (IS_WINDOW_RTL_MIRRORED(pToolInfo->hwnd) &&
        (!(pTtm->_ci.dwExStyle & RTL_MIRRORED_WINDOW)))
    {
        // toggle (mirror) the flags
        pTool->uFlags ^= (TTF_RTLREADING | TTF_RIGHT);
    }

    TTSetTipText(pTool, pToolInfo->lpszText);
    if (pTool->uFlags & TTF_SUBCLASS) 
    {
        TTSubclassHwnd(pTool, pTtm->_ci.hwnd);
    }

    LRESULT lResult;

    if (!pToolInfo->hwnd || !IsWindow(pToolInfo->hwnd)) 
    {
        lResult = NFR_UNICODE;
    } 
    else if (pTool->uFlags & TTF_UNICODE) 
    {
        lResult = NFR_UNICODE;
    } 
    else 
    {
        lResult = SendMessage(pTool->hwnd, WM_NOTIFYFORMAT, (WPARAM)pTtm->_ci.hwnd, NF_QUERY);
    }

    if (lResult == NFR_UNICODE) 
    {
        pTool->uFlags |= TTF_UNICODE;
    }

    // Create a markup
    if (pTool->cbSize == TTTOOLINFOW_V3_SIZE) 
    {  
        // lpReserved is void** because we don't want to make markup public
        Markup_Create(pTtm, NULL, NULL, IID_PPV_ARG(IControlMarkup, ((IControlMarkup **)&pTool->lpReserved)));
    }

    return 1;
}

void TTBeforeFreeTool(CToolTipsMgr *pTtm, TOOLINFO *pTool)
{
    if (pTool->uFlags & TTF_SUBCLASS) 
        TTUnsubclassHwnd(TTToolHwnd(pTool), pTtm->_ci.hwnd, FALSE);

    // clean up
    TTSetTipText(pTool, NULL);

    // Destroy the markup
    if (pTool->lpReserved)
    {
        GetToolMarkup(pTool)->Release();
        pTool->lpReserved = NULL;
    }
}

void DeleteTool(CToolTipsMgr *pTtm, TOOLINFO *pToolInfo)
{
    // bail for right now;
    if (pToolInfo->cbSize > sizeof(TOOLINFO)) 
    {
        ASSERT(0);
        return;
    }

    TOOLINFO *pTool = FindTool(pTtm, pToolInfo);
    if (pTool) 
    {
        if (pTtm->pCurTool == pTool)
            PopBubble2(pTtm, TRUE);

        TTBeforeFreeTool(pTtm, pTool);

        // replace it with the last one.. no need to waste cycles in realloc
        pTtm->iNumTools--;
        *pTool = pTtm->tools[pTtm->iNumTools]; // struct copy

        //cleanup if we moved the current tool
        if (pTtm->pCurTool == &pTtm->tools[pTtm->iNumTools])
        {
            pTtm->pCurTool = pTool;
        }
    }
}

// this strips out & markers so that people can use menu text strings
void StripAccels(CToolTipsMgr *pTtm, LPTSTR lpTipText)
{
    if (!(pTtm->_ci.style & TTS_NOPREFIX)) 
    {
        StripAccelerators(lpTipText, lpTipText, FALSE);
    }
}

//
//  The way we detect if a window is a toolbar or not is by asking it
//  for its MSAA class ID.  We cannot use GetClassWord(GCL_ATOM) because
//  Microsoft LiquidMotion **superclasses** the toolbar, so the classname
//  won't match.
//
#define IsToolbarWindow(hwnd) \
    (SendMessage(hwnd, WM_GETOBJECT, 0, OBJID_QUERYCLASSNAMEIDX) == MSAA_CLASSNAMEIDX_TOOLBAR)

LPTSTR GetToolText(CToolTipsMgr *pTtm, TOOLINFO *pTool)
{
    int id;
    HINSTANCE hinst;
    DWORD dwStrLen;
    TOOLTIPTEXT ttt;
    
    if (!pTool)
    {
        return NULL;
    }

    TraceMsg(TF_TT, "        **Enter GetToolText: ptr=%d, wFlags=%d, wid=%d, hwnd=%d",
             pTool, pTool->uFlags, pTool->uId, pTool->hwnd);

    LPTSTR lpTipText = (LPTSTR) LocalAlloc(LPTR, INITIALTIPSIZE * sizeof(TCHAR));
    if (lpTipText)
    {
        UINT cchTipText = INITIALTIPSIZE;

        if (pTool->lpszText == LPSTR_TEXTCALLBACK) 
        {
            if (pTtm->dwFlags & NEEDTEXT) // Avoid recursion
            {
                goto Cleanup;
            }

            ttt.hdr.idFrom = pTool->uId;
            ttt.hdr.code = TTN_NEEDTEXT;
            ttt.hdr.hwndFrom = pTtm->_ci.hwnd;

            ttt.szText[0] = 0;
            ttt.lpszText = ttt.szText;
            ttt.uFlags = pTool->uFlags;
            ttt.lParam = pTool->lParam;
            ttt.hinst = NULL;

            pTtm->dwFlags |= NEEDTEXT;
            SendNotifyEx(pTool->hwnd, (HWND) -1,
                         0, (NMHDR *)&ttt,
                         (pTool->uFlags & TTF_UNICODE) ? 1 : 0);
            pTtm->dwFlags &= ~NEEDTEXT;

            if (ttt.uFlags & TTF_DI_SETITEM) 
            {
                if (IS_INTRESOURCE(ttt.lpszText)) 
                {
                    pTool->lpszText = ttt.lpszText;
                    pTool->hinst = ttt.hinst;
                } 
                else if (ttt.lpszText != LPSTR_TEXTCALLBACK) 
                {
                    TTSetTipText(pTool, ttt.lpszText);
                }
            }
        
            if (IsFlagPtr(ttt.lpszText))
                goto Cleanup;

            //
            // we allow the RtlReading flag ONLY to be changed here.
            //
            if (ttt.uFlags & TTF_RTLREADING)
                pTool->uFlags |= TTF_RTLREADING;
            else
                pTool->uFlags &= ~TTF_RTLREADING;

            if (IS_INTRESOURCE(ttt.lpszText)) 
            {
                id = PtrToUlong(ttt.lpszText);
                hinst = ttt.hinst;
                ttt.lpszText = ttt.szText;
                goto LoadFromResource;
            }
        
            if (*ttt.lpszText == 0)
                goto Cleanup;

            dwStrLen = lstrlen(ttt.lpszText) + 1;
            if (cchTipText < dwStrLen)
            {
                LPTSTR psz = (LPTSTR) LocalReAlloc (lpTipText,
                                                    dwStrLen * sizeof(TCHAR),
                                                    LMEM_MOVEABLE);
                if (psz)
                {
                    lpTipText = psz;
                    cchTipText = dwStrLen;
                }
            }

            if (lpTipText)
            {
                lstrcpyn(lpTipText, ttt.lpszText, cchTipText);
                StripAccels(pTtm, lpTipText);
            }

            //
            //  if ttt.lpszText != ttt.szText and the ttt.uFlags has TTF_MEMALLOCED, then
            //  the ANSI thunk allocated the buffer for us, so free it.
            //

            if ((ttt.lpszText != ttt.szText) && (ttt.uFlags & TTF_MEMALLOCED)) 
            {
                LocalFree(ttt.lpszText);
            }

        } 
        else if (pTool->lpszText && IS_INTRESOURCE(pTool->lpszText)) 
        {
            id = PtrToLong(pTool->lpszText);
            hinst = pTool->hinst;

    LoadFromResource:

            if (lpTipText) 
            {
                if (!LoadString(hinst, id, lpTipText, cchTipText))
                    goto Cleanup;

                StripAccels(pTtm, lpTipText);
            }
        } 
        else
        {
            // supplied at creation time.
            TraceMsg(TF_TT, "GetToolText returns %s", pTool->lpszText);

            if (pTool->lpszText && *pTool->lpszText) 
            {
                dwStrLen = lstrlen(pTool->lpszText) + 1;
                if (cchTipText < dwStrLen)
                {
                    LPTSTR psz = (LPTSTR) LocalReAlloc (lpTipText,
                                                        dwStrLen * sizeof(TCHAR),
                                                        LMEM_MOVEABLE);
                    if (psz)
                    {
                        lpTipText = psz;
                        cchTipText = dwStrLen;
                    }
                }

                if (lpTipText) 
                {
                    lstrcpyn(lpTipText, pTool->lpszText, cchTipText);
                    StripAccels(pTtm, lpTipText);
                }
            }
        }

        TraceMsg(TF_TT, "        **GetToolText returns %s", lpTipText ? lpTipText : TEXT("NULL"));
    }

    // Note that we don't parse the text into the markup. We'll do that only when we need it.
    return lpTipText;

Cleanup:        // Ick, Goto...
    if (lpTipText)
        LocalFree(lpTipText);
    return NULL;
}

LPTSTR GetCurToolText(CToolTipsMgr *pTtm)
{
    LPTSTR psz = NULL;
    if (pTtm->pCurTool)
        psz = GetToolText(pTtm, pTtm->pCurTool);

    // this could have changed during the WM_NOTIFY back
    if (!pTtm->pCurTool)
        psz = NULL;
    
    return psz;
}

BOOL MarkupCurToolText(CToolTipsMgr *pTtm)
{
    BOOL bResult = FALSE;
    LPTSTR lpsz = GetCurToolText(pTtm);

    if (lpsz)
    {
        // Now that we have the tiptext, parse it into the tool's markup
        GetCurToolBestMarkup(pTtm)->SetText(lpsz);
        // Also, set the font properly
        GetCurToolBestMarkup(pTtm)->SetFonts(pTtm->hFont, pTtm->hFontUnderline);
        if (*lpsz)
        {
            bResult = TRUE;
        }

        LocalFree(lpsz);
    }

    return bResult;
}

void GetToolRect(TOOLINFO *pTool, RECT *lprc)
{
    if (pTool->uFlags & TTF_IDISHWND) 
    {
        GetWindowRect((HWND)pTool->uId, lprc);
    } 
    else 
    {
        *lprc = pTool->rect;
        MapWindowPoints(pTool->hwnd, HWND_DESKTOP, (POINT *)lprc, 2);
    }
}

BOOL PointInTool(TOOLINFO *pTool, HWND hwnd, int x, int y)
{
    // We never care if the point is in a track tool or we're using
    // a hit-test.
    if (pTool->uFlags & (TTF_TRACK | TTF_USEHITTEST))
        return FALSE;
    
    if (pTool->uFlags & TTF_IDISHWND) 
    {
        if (hwnd == (HWND)pTool->uId) 
        {
            return TRUE;
        }
    } 
    else if (hwnd == pTool->hwnd) 
    {
        POINT pt;
        pt.x = x;
        pt.y = y;
        if (PtInRect(&pTool->rect, pt)) 
        {
            return TRUE;
        }
    }
    return FALSE;
}

#define HittestInTool(pTool, hwnd, ht) \
    ((pTool->uFlags & TTF_USEHITTEST) && pTool->hwnd == hwnd && ht == pTool->rect.left)

PTOOLINFO GetToolAtPoint(CToolTipsMgr *pTtm, HWND hwnd, int x, int y, 
        int ht, BOOL fCheckText)
{
    TOOLINFO *pToolReturn = NULL;
    TOOLINFO *pTool;

    // short cut..  if we're in the same too, and the bubble is up (not just virtual)
    // return it.  this prevents us from having to poll all the time and
    // prevents us from switching to another tool when this one is good
    if ((pTtm->dwFlags & BUBBLEUP) && pTtm->pCurTool != NULL &&
        (HittestInTool(pTtm->pCurTool, hwnd, ht) ||
         PointInTool(pTtm->pCurTool, hwnd, x, y)))
    {
        return pTtm->pCurTool;
    }

    if (pTtm->iNumTools) 
    {
        for (pTool = &pTtm->tools[pTtm->iNumTools-1]; pTool >= pTtm->tools; pTool--) 
        {
            if (HittestInTool(pTool, hwnd, ht) || PointInTool(pTool, hwnd, x, y)) 
            {
                // if this tool has text, return it.
                // otherwise, save it away as a dead area tool,
                // and keep looking
                if (fCheckText) 
                {
                    LPTSTR psz = GetToolText(pTtm, pTool);
                    if (psz) 
                    {
                        LocalFree(psz);
                        return pTool;
                    }
                    else if (pTtm->dwFlags & (BUBBLEUP|VIRTUALBUBBLEUP)) 
                    {
                        // only return this (only allow a virutal tool
                        // if there was previously a tool up.
                        // IE, we can't start things off with a virutal tool
                        pToolReturn = pTool;
                    }
                }
                else
                {
                    return pTool;
                }
            }
        }
    }

    return pToolReturn;
}

void ShowVirtualBubble(CToolTipsMgr *pTtm)
{
    TOOLINFO *pTool = pTtm->pCurTool;

    DebugMsg(TF_TT, TEXT("Entering ShowVirtualBubble so popping bubble"));
    PopBubble2(pTtm, TRUE);

    // Set this back in so that while we're in this tool's area,
    // we won't keep querying for info
    pTtm->pCurTool = pTool;
    pTtm->dwFlags |= VIRTUALBUBBLEUP;
}

#define TRACK_TOP    0
#define TRACK_LEFT   1
#define TRACK_BOTTOM 2
#define TRACK_RIGHT  3 


void TTGetTipPosition(CToolTipsMgr *pTtm, LPRECT lprc, int cxText, int cyText, int *pxStem, int *pyStem)
{
    RECT rcWorkArea;
    // ADJUSTRECT!  Keep TTAdjustRect and TTM_GETBUBBLESIZE in sync.
    int cxMargin = pTtm->rcMargin.left + pTtm->rcMargin.right;
    int cyMargin = pTtm->rcMargin.top + pTtm->rcMargin.bottom;
    int iBubbleWidth =  2*XTEXTOFFSET * g_cxBorder + cxText + cxMargin;
    int iBubbleHeight = 2*YTEXTOFFSET * g_cyBorder + cyText + cyMargin;
    UINT uSide = (UINT)-1;
    RECT rcTool;
    MONITORINFO mi;
    HMONITOR    hMonitor;
    POINT pt;
    BOOL bBalloon = pTtm->_ci.style & TTS_BALLOON;
    int  xStem, yStem;
    int iCursorHeight=0;
    int iCursorWidth=0;
        
    if (bBalloon  || pTtm->cchTipTitle)
    {
        // ADJUSTRECT!  Keep TTAdjustRect and TTM_GETBUBBLESIZE in sync.
        iBubbleWidth += 2*XBALLOONOFFSET;
        iBubbleHeight += 2*YBALLOONOFFSET;

        if (bBalloon)
        {
            if (iBubbleWidth < MINBALLOONWIDTH)
                pTtm->iStemHeight = 0;
            else
            {
                pTtm->iStemHeight = STEMHEIGHT;
                if (pTtm->iStemHeight > iBubbleHeight/3)
                    pTtm->iStemHeight = iBubbleHeight/3; // don't let the stem be longer than the bubble -- looks ugly
            }
        }
    }
    
    GetToolRect(pTtm->pCurTool, &rcTool);
    
    if (pTtm->pCurTool->uFlags & TTF_TRACK) 
    {
        lprc->left = pTtm->ptTrack.x;
        lprc->top = pTtm->ptTrack.y;
        if (bBalloon)
        {
            // adjust the desired left hand side
            xStem = pTtm->ptTrack.x;
            yStem = pTtm->ptTrack.y;
        }

        if (pTtm->pCurTool->uFlags & TTF_CENTERTIP) 
        {
            // center the bubble around the ptTrack
            lprc->left -= (iBubbleWidth / 2);
            if (!bBalloon)
                lprc->top -=  (iBubbleHeight / 2);
        }
        
        if (pTtm->pCurTool->uFlags & TTF_ABSOLUTE)
        {
            // with goto bellow we'll skip adjusting
            // bubble height -- so do it here
            if (bBalloon)
                iBubbleHeight += pTtm->iStemHeight;
            goto CompleteRect;
        }

        // in balloon style the positioning depends on the position
        // of the stem and we don't try to position the tooltip
        // next to the tool rect
        if (!bBalloon)
        {
            // now align it so that the tip sits beside the rect.
            if (pTtm->ptTrack.y > rcTool.bottom) 
            {
                uSide = TRACK_BOTTOM;
                if (lprc->top < rcTool.bottom)
                    lprc->top = rcTool.bottom;    
            }
            else if (pTtm->ptTrack.x < rcTool.left) 
            {
                uSide = TRACK_LEFT;
                if (lprc->left + iBubbleWidth > rcTool.left)
                    lprc->left = rcTool.left - iBubbleWidth;
            } 
            else if (pTtm->ptTrack.y < rcTool.top) 
            {    
                uSide = TRACK_TOP;
                if (lprc->top + iBubbleHeight > rcTool.top) 
                    lprc->top = rcTool.top - iBubbleHeight;    
            } 
            else 
            {    
                uSide = TRACK_RIGHT;
                if (lprc->left < rcTool.right)
                    lprc->left = rcTool.right;
            }
        }        
    } 
    else if (pTtm->pCurTool->uFlags & TTF_CENTERTIP) 
    {
        lprc->left = (rcTool.right + rcTool.left - iBubbleWidth)/2;
        lprc->top = rcTool.bottom;
        if (bBalloon)
        {
            xStem = (rcTool.left + rcTool.right)/2;
            yStem = rcTool.bottom;
        }
    } 
    else 
    {
        // now set it
        _GetCursorLowerLeft((LPINT)&lprc->left, (LPINT)&lprc->top, &iCursorWidth, &iCursorHeight);
        if (pTtm->pCurTool->uFlags & TTF_EXCLUDETOOLAREA)
        {
            lprc->top = rcTool.top-iBubbleHeight;
        }

        if (g_fLeftAligned)
        {
            lprc->left -= iBubbleWidth;
        }

        if (bBalloon)
        {
            HMONITOR  hMon1, hMon2;
            POINT     pt;
            BOOL      bOnSameMonitor = FALSE;
            int iTop = lprc->top - (iCursorHeight + iBubbleHeight + pTtm->iStemHeight);

            xStem = lprc->left;
            yStem = lprc->top;

            pt.x = xStem;
            pt.y = lprc->top;
            hMon1 = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);
            pt.y = iTop;
            hMon2 = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);

            if (hMon1 == hMon2)
            {
                // the hmons are the same but maybe iTop is off any monitor and we just defaulted 
                // to the nearest one -- check if it's really on the monitor
                mi.cbSize = sizeof(mi);
                GetMonitorInfo(hMon1, &mi);

                if (PtInRect(&mi.rcMonitor, pt))
                {
                    // we'd like to show balloon above the cursor so that wedge/stem points
                    // to tip of the cursor not its bottom left corner
                    yStem -= iCursorHeight;
                    lprc->top = iTop;
                    bOnSameMonitor = TRUE;
                }   
            }

            if (!bOnSameMonitor)
            {
                xStem += iCursorWidth/2;
                iCursorHeight = iCursorWidth = 0;
            }
        }
    }

    //
    //  At this point, (lprc->left, lprc->top) is the position
    //  at which we would prefer that the tooltip appear.
    //
    if (bBalloon)
    {
        // adjust the left point now that all calculations are done
        // but only if we're not in the center tip mode
        // note we use height as width so we can have 45 degree angle that looks nice
        if (!(pTtm->pCurTool->uFlags & TTF_CENTERTIP) && iBubbleWidth > STEMOFFSET + pTtm->iStemHeight)
            lprc->left -= STEMOFFSET;
        // adjust the height to include stem
        iBubbleHeight += pTtm->iStemHeight;
    }

    pt.x = lprc->left;
    pt.y = lprc->top;
    hMonitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &mi);
    
    if (GetWindowLong(pTtm->_ci.hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
    {
        CopyRect(&rcWorkArea, &mi.rcMonitor);
    }
    else
    {
        CopyRect(&rcWorkArea, &mi.rcWork);
    }

    //
    //  At this point, rcWorkArea is the rectangle within which
    //  the tooltip should finally appear.
    //
    //  Now fiddle with the coordinates to try to find a sane location
    //  for the tip.
    //

    // move it up if it's at the bottom of the screen
    if ((lprc->top + iBubbleHeight) >= (rcWorkArea.bottom)) 
    {
        if (uSide == TRACK_BOTTOM) 
            lprc->top = rcTool.top - iBubbleHeight;     // flip to top
        else 
        {
            //
            //  We can't "stick to bottom" because that would cause
            //  our tooltip to lie under the mouse cursor, causing it
            //  to pop immediately!  So go just above the mouse cursor.
            //
            // cannot do that in the track mode -- tooltip randomly on the 
            // screen, not even near the button
            //
            // Bug#94368 raymondc v6: This messes up Lotus SmartCenter.
            // Need to be smarter about when it is safe to flip up.
            // Perhaps by checking if the upflip would put the tip too
            // far away from the mouse.
            if (pTtm->pCurTool->uFlags & TTF_TRACK)
                lprc->top = pTtm->ptTrack.y - iBubbleHeight;
            else
            {
                int y = GET_Y_LPARAM(GetMessagePos());
                lprc->top = y - iBubbleHeight;
                if (bBalloon)
                    yStem = y;
            }
        }
    }
    
    // If above the top of the screen...
    if (lprc->top < rcWorkArea.top) 
    {
        if (uSide == TRACK_TOP) 
            lprc->top = rcTool.bottom;      // flip to bottom
        else
            lprc->top = rcWorkArea.top;     // stick to top
    }

    // move it over if it extends past the right.
    if ((lprc->left + iBubbleWidth) >= (rcWorkArea.right)) 
    {
        // flipping is not the right thing to do with balloon style
        // because the wedge/stem can stick out of the window and 
        // would therefore be clipped so
        if (bBalloon)
        {
            // move it to the left so that stem appears on the right side of the balloon
            // again we use height as width so we can have 45 degree angle
            if (iBubbleWidth >= MINBALLOONWIDTH)
                lprc->left = xStem + min(STEMOFFSET, (iBubbleWidth-pTtm->iStemHeight)/2) - iBubbleWidth;
            // are we still out?
            if (lprc->left + iBubbleWidth >= rcWorkArea.right)
                lprc->left = rcWorkArea.right - iBubbleWidth - 1;
        }
        else if (uSide == TRACK_RIGHT) 
            lprc->left = rcTool.left - iBubbleWidth;    // flip to left
        else 
            // not in right tracking mode, just scoot it over
            lprc->left = rcWorkArea.right - iBubbleWidth - 1; // stick to right
    }

    // if too far left...
    if (lprc->left < rcWorkArea.left) 
    {
        if (uSide == TRACK_LEFT)
        {
            // flipping is not the right thing to do with balloon style
            // because the wedge/stem can stick out of the window and 
            // would therefore be clipped so
            if (bBalloon)
                lprc->left = rcWorkArea.left; //pTtm->ptTrack.x;
            else
                lprc->left = rcTool.right;          // flip to right
        }
        else 
            lprc->left = rcWorkArea.left;       // stick to left
    }
    
CompleteRect:
    lprc->right = lprc->left + iBubbleWidth;
    lprc->bottom = lprc->top + iBubbleHeight;

    if (bBalloon && pxStem && pyStem)
    {
        *pxStem = xStem;
        *pyStem = yStem;
    }
}

void LoadAndAddToImagelist(HIMAGELIST himl, int id)
{
    HICON hicon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(id), IMAGE_ICON, g_cxSmIcon, g_cySmIcon, LR_DEFAULTCOLOR | LR_SHARED);
    if (hicon)
    {
        ImageList_AddIcon(himl, hicon);
        DestroyIcon(hicon);
    }
}

BOOL TTCreateTitleBitmaps(CToolTipsMgr *pTtm)
{
    if (pTtm->himlTitleBitmaps)
        return TRUE;

    pTtm->himlTitleBitmaps = ImageList_Create(g_cxSmIcon, g_cySmIcon, ILC_COLOR32 | ILC_MASK, 3, 1);
    if (pTtm->himlTitleBitmaps)
    {
        LoadAndAddToImagelist(pTtm->himlTitleBitmaps, IDI_TITLE_INFO);
        LoadAndAddToImagelist(pTtm->himlTitleBitmaps, IDI_TITLE_WARNING);
        LoadAndAddToImagelist(pTtm->himlTitleBitmaps, IDI_TITLE_ERROR);
        return TRUE;
    }

    return FALSE;
}

// Called when caclulating the size of a "titled tool tip" or actually drawing
// based on the boolean value bCalcRect.

// TTRenderTitledTip is theme aware
BOOL TTRenderTitledTip(CToolTipsMgr *pTtm, HDC hdc, BOOL bCalcRect, RECT* prc, UINT uDrawFlags)
{
    RECT rc;
    int lWidth=0, lHeight=0;
    HFONT hfont;
    COLORREF crOldTextColor;
    int iOldBKMode;

    // If we don't have a title, we don't need to be here.
    if (pTtm->cchTipTitle == 0)
        return FALSE;

    CopyRect(&rc, prc);
    if (pTtm->uTitleBitmap != TTI_NONE)
    {
        int cx, cy;
        CCGetIconSize(&pTtm->_ci, pTtm->himlTitleBitmaps, &cx, &cy);

        lWidth    = cx + TITLEICON_DIST;
        lHeight  += cy;
        if (!bCalcRect && pTtm->himlTitleBitmaps)
        {
            ImageList_Draw(pTtm->himlTitleBitmaps, pTtm->uTitleBitmap - 1, hdc, rc.left, rc.top, ILD_TRANSPARENT | ILD_DPISCALE);
        }
        rc.left  += lWidth;
    }

    if (!bCalcRect)
    {
        crOldTextColor = SetTextColor(hdc, pTtm->clrTipText);
        iOldBKMode = SetBkMode(hdc, TRANSPARENT);
    }
    
    if (pTtm->lpTipTitle && pTtm->lpTipTitle[0] != 0)
    {
        LOGFONT lf;
        HFONT   hfTitle;
        UINT    uFlags = uDrawFlags | DT_SINGLELINE; // title should be on one line only

        hfont = (HFONT) GetCurrentObject(hdc, OBJ_FONT);
        GetObject(hfont, sizeof(lf), &lf);
        CCAdjustForBold(&lf);
        hfTitle = CreateFontIndirect(&lf);
        if (hfTitle)
        {
            // hfont should already be set to this
            hfont = (HFONT) SelectObject(hdc, hfTitle);
        }

        // drawtext does not calculate the height if these are specified
        if (!bCalcRect)
            uFlags |= DT_VCENTER;

        // we need to calc title height -- either we did it before or we'll do it now
        ASSERT(pTtm->iTitleHeight != 0 || uFlags & DT_CALCRECT);

        // adjust the rect so we can stick the title to the bottom of it
        rc.bottom = rc.top + max(pTtm->iTitleHeight, g_cySmIcon);
        // problems in DrawText if margins make rc.right < rc.left
        // even though we are asking for calculation of the rect nothing happens, so ...
        if (bCalcRect)
            rc.right = rc.left + (GetSystemMetrics(SM_CXICON) * 10);   // 320 by default

        SIZE szClose = {GetSystemMetrics(SM_CXMENUSIZE), GetSystemMetrics(SM_CYMENUSIZE)}; 

        if (pTtm->_ci.style & TTS_CLOSE)
        {
            if (pTtm->hTheme)
            {
                GetThemePartSize(pTtm->hTheme, hdc, TTP_CLOSE, TTCS_NORMAL, NULL, 
                    TS_TRUE, &szClose);
            }

            // We only want to do this if we are painting, 
            // because we don't want the text to overlap the close
            if (!bCalcRect)
                rc.right -= szClose.cx;
        }

        DrawText(hdc, pTtm->lpTipTitle, lstrlen(pTtm->lpTipTitle), &rc, uFlags);

        if (pTtm->iTitleHeight == 0)
            pTtm->iTitleHeight = RECTHEIGHT(rc);    // Use rc instead of lfHeight, because it can be Negative.

        lHeight  = max(lHeight, pTtm->iTitleHeight) + TITLE_INFO_DIST;
        lWidth  += RECTWIDTH(rc);

        if (pTtm->_ci.style & TTS_CLOSE)
        {
            if (bCalcRect)
            {
                lHeight = max(lHeight, szClose.cy);
                lWidth += szClose.cx;
            }
            else
            {
                SetRect(&pTtm->rcClose, rc.right + XBALLOONOFFSET - 5, rc.top - YBALLOONOFFSET + 5, 
                 rc.right + szClose.cx + XBALLOONOFFSET - 5, rc.top + szClose.cy - YBALLOONOFFSET + 5);
                if (pTtm->hTheme)
                    DrawThemeBackground(pTtm->hTheme, hdc, TTP_CLOSE, pTtm->iStateId, &pTtm->rcClose, 0);
                else
                    DrawFrameControl(hdc, &pTtm->rcClose, DFC_CAPTION, DFCS_FLAT | DFCS_CAPTIONCLOSE | (pTtm->iStateId == TTCS_PRESSED?DFCS_PUSHED:0));
            }
        }
        
        // Bypass title font cleanup if using themes
        if (hfTitle)
        {
            SelectObject(hdc, hfont);
            DeleteObject(hfTitle);
        }
    }

    // adjust the rect for the info text
    CopyRect(&rc, prc);
    rc.top += lHeight;

    // we want multi line text -- tooltip will give us single line if we did not set MAXWIDTH
    uDrawFlags &= ~DT_SINGLELINE;

    GetCurToolBestMarkup(pTtm)->SetRenderFlags(uDrawFlags);

    GetCurToolBestMarkup(pTtm)->CalcIdealSize(hdc, MARKUPSIZE_CALCHEIGHT, &rc);

    if (!bCalcRect)
        GetCurToolBestMarkup(pTtm)->DrawText(hdc, &rc);

    lHeight += RECTHEIGHT(rc);
    lWidth   = max(lWidth, RECTWIDTH(rc));

    if (bCalcRect)
    {
        prc->right = prc->left + lWidth;
        prc->bottom = prc->top + lHeight;
    }
    else
    {
        SetTextColor(hdc, crOldTextColor);
        SetBkMode(hdc, iOldBKMode);
    }

    return TRUE;
}

// TTGetTipSize is theme aware
void TTGetTipSize(CToolTipsMgr *pTtm, TOOLINFO *pTool, LPINT pcxText, LPINT pcyText)
{
    // get the size it will be
    *pcxText = 0;
    *pcyText = 0;

    HDC hdcTemp = GetDC(pTtm->_ci.hwnd);

    if (hdcTemp == NULL)
    {
        return;
    }

    HDC hdc  = CreateCompatibleDC(hdcTemp);
    
    ReleaseDC(pTtm->_ci.hwnd, hdcTemp);

    if (hdc == NULL)
    {
        return;
    }

    HFONT hOldFont;

    if (pTtm->hFont) 
        hOldFont = (HFONT) SelectObject(hdc, pTtm->hFont);

    /* If need to fire off the pre-DrawText notify then do so, otherwise use the
       original implementation that just called MGetTextExtent */


    {
        NMTTCUSTOMDRAW nm;
        DWORD dwCustom;
        UINT  uDefDrawFlags = 0;

        nm.nmcd.hdr.hwndFrom = pTtm->_ci.hwnd;
        nm.nmcd.hdr.idFrom = pTool->uId;
        nm.nmcd.hdr.code = NM_CUSTOMDRAW;
        nm.nmcd.hdc = hdc;
        // TTGetTipSize must use CDDS_PREPAINT so the client can tell
        // whether we are measuring or painting
        nm.nmcd.dwDrawStage = CDDS_PREPAINT;
        nm.nmcd.rc.left = nm.nmcd.rc.top = 0;

        if (pTtm->_ci.style & TTS_NOPREFIX)
            uDefDrawFlags = DT_NOPREFIX;

        if (pTtm->iMaxTipWidth == -1) 
        {
            uDefDrawFlags |= DT_CALCRECT|DT_SINGLELINE |DT_LEFT;
            GetCurToolBestMarkup(pTtm)->SetRenderFlags(uDefDrawFlags);

            SetRect(&nm.nmcd.rc, 0, 0, 0, 0);               
            GetCurToolBestMarkup(pTtm)->CalcIdealSize(hdc, MARKUPSIZE_CALCHEIGHT, &nm.nmcd.rc);
            *pcxText = nm.nmcd.rc.right;
            *pcyText = nm.nmcd.rc.bottom;
        }
        else 
        {    
            uDefDrawFlags |= DT_CALCRECT | DT_LEFT | DT_WORDBREAK | DT_EXPANDTABS | DT_EXTERNALLEADING;
            nm.nmcd.rc.right = pTtm->iMaxTipWidth;
            nm.nmcd.rc.bottom = 0;

            GetCurToolBestMarkup(pTtm)->SetRenderFlags(uDefDrawFlags);

            GetCurToolBestMarkup(pTtm)->CalcIdealSize(hdc, MARKUPSIZE_CALCHEIGHT, &nm.nmcd.rc);
            *pcxText = nm.nmcd.rc.right;
            *pcyText = nm.nmcd.rc.bottom;
        }

        if ((pTtm->pCurTool->uFlags & TTF_RTLREADING) || (pTtm->_ci.dwExStyle & WS_EX_RTLREADING))
            uDefDrawFlags |= DT_RTLREADING;

        //
        // Make it right aligned, if requested.
        //
        if (pTool->uFlags & TTF_RIGHT)
            uDefDrawFlags |= DT_RIGHT;

        nm.uDrawFlags = uDefDrawFlags;

        dwCustom = (DWORD)SendNotifyEx(pTool->hwnd, (HWND) -1,
                     0, (NMHDR*) &nm,
                     (pTool->uFlags & TTF_UNICODE) ? 1 : 0);

        if (TTRenderTitledTip(pTtm, hdc, TRUE, &nm.nmcd.rc, uDefDrawFlags))
        {
            *pcxText = nm.nmcd.rc.right - nm.nmcd.rc.left;
            *pcyText = nm.nmcd.rc.bottom - nm.nmcd.rc.top;
        }
        else if ((dwCustom & CDRF_NEWFONT) || nm.uDrawFlags != uDefDrawFlags)
        {               
            GetCurToolBestMarkup(pTtm)->SetRenderFlags(nm.uDrawFlags);
            GetCurToolBestMarkup(pTtm)->CalcIdealSize(hdc, MARKUPSIZE_CALCHEIGHT, &nm.nmcd.rc);

            *pcxText = nm.nmcd.rc.right - nm.nmcd.rc.left;
            *pcyText = nm.nmcd.rc.bottom - nm.nmcd.rc.top;
        }
        // did the owner specify the size?
        else if (nm.nmcd.rc.right - nm.nmcd.rc.left != *pcxText || 
                 nm.nmcd.rc.bottom - nm.nmcd.rc.top != *pcyText)
        {
            *pcxText = nm.nmcd.rc.right - nm.nmcd.rc.left;
            *pcyText = nm.nmcd.rc.bottom - nm.nmcd.rc.top;
        }

        // notify parent afterwards if they want us to
        if (!(dwCustom & CDRF_SKIPDEFAULT) &&
            dwCustom & CDRF_NOTIFYPOSTPAINT) 
        {
            nm.nmcd.dwDrawStage = CDDS_POSTPAINT;
            SendNotifyEx(pTool->hwnd, (HWND) -1,
                         0, (NMHDR*) &nm,
                         (pTool->uFlags & TTF_UNICODE) ? 1 : 0);
        }
    }

    if (pTtm->hFont) 
        SelectObject(hdc, hOldFont);

    DeleteDC(hdc);

    // after the calc rect, add a little space on the right
    *pcxText += g_cxEdge;
    *pcyText += g_cyEdge;
}

//
//  Given an inner rectangle, return the coordinates of the outer,
//  or vice versa.
//
//  "outer rectangle" = window rectangle.
//  "inner rectangle" = the area where we draw the text.
//
//  This allows people like listview and treeview to position
//  the tooltip so the inner rectangle exactly coincides with
//  their existing text.
//
//  All the places we do rectangle adjusting are marked with
//  the comment
//
//      // ADJUSTRECT!  Keep TTAdjustRect in sync.
//
LRESULT TTAdjustRect(CToolTipsMgr *pTtm, BOOL fLarger, LPRECT prc)
{
    RECT rc;

    if (!prc)
        return 0;

    //
    //  Do all the work on our private little rectangle on the
    //  assumption that everything is getting bigger.  At the end,
    //  we'll flip all the numbers around if in fact we're getting
    //  smaller.
    //
    rc.top = rc.left = rc.bottom = rc.right = 0;

    // TTRender adjustments -
    rc.left   -= XTEXTOFFSET*g_cxBorder + pTtm->rcMargin.left;
    rc.right  += XTEXTOFFSET*g_cxBorder + pTtm->rcMargin.right;
    rc.top    -= YTEXTOFFSET*g_cyBorder + pTtm->rcMargin.top;
    rc.bottom += YTEXTOFFSET*g_cyBorder + pTtm->rcMargin.bottom;

    // Compensate for the hack in TTRender that futzes all the rectangles
    // by one pixel.  Look for "Account for off-by-one."
    rc.bottom--;
    rc.right--;

    if (pTtm->_ci.style & TTS_BALLOON || pTtm->cchTipTitle)
    {
        InflateRect(&rc, XBALLOONOFFSET, YBALLOONOFFSET);
    }

    //
    //  Ask Windows how much adjusting he will do to us.
    //
    //  Since we don't track WM_STYLECHANGED/GWL_EXSTYLE, we have to ask USER
    //  for our style information, since the app may have changed it.
    //
    AdjustWindowRectEx(&rc,
                       pTtm->_ci.style,
                       BOOLFROMPTR(GetMenu(pTtm->_ci.hwnd)),
                       GetWindowLong(pTtm->_ci.hwnd, GWL_EXSTYLE));

    //
    //  Now adjust our caller's rectangle.
    //
    if (fLarger)
    {
        prc->left   += rc.left;
        prc->right  += rc.right;
        prc->top    += rc.top;
        prc->bottom += rc.bottom;
    }
    else
    {
        prc->left   -= rc.left;
        prc->right  -= rc.right;
        prc->top    -= rc.top;
        prc->bottom -= rc.bottom;
    }

    return TRUE;
}

#define CSTEMPOINTS 3
// bMirrored does not mean a mirrored tooltip.
// It means simulating the behavior or a mirrored tooltip for a tooltip created with a mirrored parent.
HRGN CreateBalloonRgn(int xStem, int yStem, int iWidth, int iHeight, int iStemHeight, BOOL bUnderStem, BOOL bMirrored)
{
    int  y = 0, yHeight = iHeight;
    HRGN rgn;

    if (bUnderStem)
        yHeight -= iStemHeight;
    else
        y = iStemHeight;
        
    rgn = CreateRoundRectRgn(0, y, iWidth, yHeight, BALLOON_X_CORNER, BALLOON_Y_CORNER);
    if (rgn)
    {
        // create wedge/stem rgn
        if (iWidth >= MINBALLOONWIDTH)
        {
            HRGN rgnStem;
            POINT aptStemRgn[CSTEMPOINTS];
            POINT *ppt = aptStemRgn;
            POINT pt;
            BOOL  bCentered;
            int   iStemWidth = iStemHeight+1; // for a 45 degree angle

            // we center the stem if we have TTF_CENTERTIP or the width
            // of the balloon is not big enough to offset the stem by 
            // STEMOFFSET
            // can't quite center the tip on TTF_CENTERTIP because it may be
            // moved left or right it did not fit on the screen: just check
            // if xStem is in the middle
            bCentered = (xStem == iWidth/2) || (iWidth < 2*STEMOFFSET + iStemWidth);

            if (bCentered)
                pt.x = (iWidth - iStemWidth)/2;
            else if (xStem > iWidth/2)
            {
                if (bMirrored)
                {
                    pt.x = STEMOFFSET + iStemWidth;
                }
                else
                {
                    pt.x = iWidth - STEMOFFSET - iStemWidth;
                }    
            }    
            else
            {
                if (bMirrored)
                {
                    pt.x = iWidth - STEMOFFSET;
                }
                else
                {
                    pt.x = STEMOFFSET;
                }    
            }    

            if (bMirrored && (ABS(pt.x - (iWidth - xStem)) <= 2))
            {
                pt.x = iWidth - xStem; // avoid rough edges, have a straight line
                
            }
            else if (!bMirrored && (ABS(pt.x - xStem) <= 2))
            {
                pt.x = xStem; // avoid rough edges, have a straight line
            }    
            if (bUnderStem)
                pt.y = iHeight - iStemHeight - 2;
            else
                pt.y = iStemHeight + 2;
            *ppt++ = pt;
            if (bMirrored)
            {
                pt.x -= iStemWidth;            
            }
            else
            {
                pt.x += iStemWidth;
            }    
            if (bMirrored && (ABS(pt.x - (iWidth - xStem)) <= 2))
            {
                pt.x = iWidth - xStem; // avoid rough edges, have a straight line
                
            }
            else if (!bMirrored && (ABS(pt.x - xStem) <= 2))
            {
                pt.x = xStem; // avoid rough edges, have a straight line
            }    
            *ppt++ = pt;
            if (bMirrored)
            {
                pt.x = iWidth - xStem;
            }
            else
            {
                pt.x = xStem;                
            }
            pt.y = yStem;
            *ppt = pt;

            rgnStem = CreatePolygonRgn(aptStemRgn, CSTEMPOINTS, ALTERNATE);
            if (rgnStem)
            {
                CombineRgn(rgn, rgn, rgnStem, RGN_OR);
                DeleteObject(rgnStem);
            }
        }
    }
    return rgn;
}

/*----------------------------------------------------------
Purpose: Shows the tooltip.  On NT4/Win95, this is a standard
         show window.  On NT5/Memphis, this slides the tooltip
         bubble from an invisible point.

Returns: --
Cond:    --
*/

#define CMS_TOOLTIP 135

void SlideAnimate(HWND hwnd, LPCRECT prc)
{
    DWORD dwPos, dwFlags;

    dwPos = GetMessagePos();
    if (GET_Y_LPARAM(dwPos) > prc->top + (prc->bottom - prc->top) / 2)
    {
        dwFlags = AW_VER_NEGATIVE;
    } 
    else
    {
        dwFlags = AW_VER_POSITIVE;
    }

    AnimateWindow(hwnd, CMS_TOOLTIP, dwFlags | AW_SLIDE);
}

STDAPI_(void) CoolTooltipBubble(IN HWND hwnd, IN LPCRECT prc, BOOL fAllowFade, BOOL fAllowAnimate)
{
    BOOL fSetWindowPos = FALSE;
    BOOL fAnimate = TRUE;

    ASSERT(prc);

    SystemParametersInfo(SPI_GETTOOLTIPANIMATION, 0, &fAnimate, 0);

    if (fAnimate)
    {
        fAnimate = FALSE;
        SystemParametersInfo(SPI_GETTOOLTIPFADE, 0, &fAnimate, 0);
        if (fAnimate && fAllowFade)
        {
            AnimateWindow(hwnd, CMS_TOOLTIP, AW_BLEND);
        }
        else if (fAllowAnimate)
        {
            SlideAnimate(hwnd, prc);
        }
        else
        {
            fSetWindowPos = TRUE;
        }
    }
    else
    {
        fSetWindowPos = TRUE;
    }


    if (fSetWindowPos)
    {
        SetWindowPos(hwnd, NULL, 0, 0, 0, 0, 
                     SWP_NOACTIVATE|SWP_SHOWWINDOW|SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER);
    }
}

void DoShowBubble(CToolTipsMgr *pTtm)
{
    if (!g_fEnableBalloonTips && (pTtm->_ci.style & TTS_BALLOON))
        return;

    HFONT hFontPrev;
    RECT rc;
    int cxText, cyText;
    int xStem = 0, yStem = 0;
    NMTTSHOWINFO si;
    BOOL fAllowFade = !(pTtm->_ci.style & TTS_NOFADE);
    BOOL fAllowAnimate = !(pTtm->_ci.style & TTS_NOANIMATE);
    DWORD dwCurrentTime = (pTtm->dwLastDisplayTime == 0)? TIMEBETWEENANIMATE : GetTickCount();
    DWORD dwDelta = dwCurrentTime - pTtm->dwLastDisplayTime;
    BOOL fFadeTurnedOn = FadeEnabled();


    DebugMsg(TF_TT, TEXT("Entering DoShowBubble"));
    
    BOOL bResult = MarkupCurToolText(pTtm);

    if (pTtm->dwFlags & TRACKMODE) 
    {
        if (bResult == FALSE) 
        {
            PopBubble2(pTtm, TRUE);
            pTtm->dwFlags &= ~TRACKMODE;
            return;
        }
    } 
    else 
    {
        TTSetTimer(pTtm, TTT_POP);
        if (bResult == FALSE) 
        {

            ShowVirtualBubble(pTtm);
            return;
        }
        TTSetTimer(pTtm, TTT_AUTOPOP);
    }
    

    do 
    {
        UINT uFlags = SWP_NOACTIVATE | SWP_NOZORDER;

        // get the size it will be
        TTGetTipSize(pTtm, pTtm->pCurTool, &cxText, &cyText);
        TTGetTipPosition(pTtm, &rc, cxText, cyText, &xStem, &yStem);

        SetWindowPos(pTtm->_ci.hwnd, NULL, rc.left, rc.top,
                     rc.right-rc.left, rc.bottom-rc.top, uFlags);

        if (pTtm->pCurTool == NULL)
            return;

        si.hdr.hwndFrom = pTtm->_ci.hwnd;
        si.hdr.idFrom = pTtm->pCurTool->uId;
        si.hdr.code = TTN_SHOW;
        si.dwStyle = pTtm->_ci.style;

        hFontPrev = pTtm->hFont;
        if (!SendNotifyEx(pTtm->pCurTool->hwnd, (HWND)-1,
                          TTN_SHOW, &si.hdr,
                          (pTtm->pCurTool->uFlags & TTF_UNICODE) ? 1 : 0)) 
        {
            uFlags = SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOOWNERZORDER;

            SetWindowPos(pTtm->_ci.hwnd, HWND_TOP, rc.left, rc.top,
                         0, 0, uFlags);
        }
    
    } 
    while (hFontPrev != pTtm->hFont);

    // If we're under the minimum time between animates, then we don't animate
    if (dwDelta < TIMEBETWEENANIMATE)
        fAllowFade = fAllowAnimate = FALSE;


    // create the balloon region if necessary
    // Note: Don't use si.dwStyle here, since other parts of comctl32
    // look at pTtm->_ci.style to decide what to do
    if (pTtm->_ci.style & TTS_BALLOON)
    {
        HRGN rgn;
        BOOL bMirrored = FALSE;
        if (pTtm->pCurTool)
        {
            bMirrored = pTtm->_ci.dwExStyle & WS_EX_LAYOUTRTL;
        }
        pTtm->fUnderStem = yStem >= rc.bottom-1;
        rgn = CreateBalloonRgn(xStem - rc.left, yStem-rc.top, rc.right-rc.left, rc.bottom-rc.top, 
                               pTtm->iStemHeight, pTtm->fUnderStem, bMirrored);

        if (rgn && !SetWindowRgn(pTtm->_ci.hwnd, rgn, FALSE))
            DeleteObject(rgn);
    }

    pTtm->dwLastDisplayTime = GetTickCount();

    // Don't Show and hide at the same time. This can cause fading tips to interfere with each other
    KillTimer(pTtm->_ci.hwnd, TTT_FADEHIDE);
    if (fFadeTurnedOn && fAllowFade)
    {
        // If we can fade, then setup the attributes to start from zero.
        SetLayeredWindowAttributes(pTtm->_ci.hwnd, 0, (BYTE)pTtm->iFadeState, LWA_ALPHA);
        RedrawWindow(pTtm->_ci.hwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_UPDATENOW);

        // Position it.
        SetWindowPos(pTtm->_ci.hwnd,HWND_TOP,0,0,0,0,SWP_NOACTIVATE|SWP_SHOWWINDOW|SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER);

        // Start the fade in.
        SetTimer(pTtm->_ci.hwnd, TTT_FADESHOW, TTTT_FADESHOW, NULL);
    }
    else
    {
        RedrawWindow(pTtm->_ci.hwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_UPDATENOW);

        // Position it.
        SetWindowPos(pTtm->_ci.hwnd,HWND_TOP,0,0,0,0,SWP_NOACTIVATE|SWP_SHOWWINDOW|SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER);

        pTtm->iFadeState = TT_MAXFADESHOW;

        SetLayeredWindowAttributes(pTtm->_ci.hwnd, 0, (BYTE)pTtm->iFadeState, LWA_ALPHA);

    }

    pTtm->dwFlags |= BUBBLEUP;
    RedrawWindow(pTtm->_ci.hwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_UPDATENOW);
}

void ShowBubbleForTool(CToolTipsMgr *pTtm, TOOLINFO *pTool)
{
    DebugMsg(TF_TT, TEXT("ShowBubbleForTool"));
    // if there's a bubble up for a different tool, pop it.
    if ((pTool != pTtm->pCurTool) && (pTtm->dwFlags & BUBBLEUP)) 
    {
        PopBubble2(pTtm, TRUE);
    }

    // if the bubble was for a different tool, or no bubble, show it
    if ((pTool != pTtm->pCurTool) || !(pTtm->dwFlags & (VIRTUALBUBBLEUP|BUBBLEUP))) 
    {
        pTtm->pCurTool = pTool;
        DoShowBubble(pTtm);
    }
    else
    {
        DebugMsg(TF_TT, TEXT("ShowBubbleForTool not showinb bubble"));
    }
}

void HandleRelayedMessage(CToolTipsMgr *pTtm, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    int ht = HTERROR;

    if (pTtm->dwFlags & TRACKMODE) 
    {
        // punt all messages if we're in track mode
        return;
    }
    
    if (pTtm->dwFlags & BUTTONISDOWN) 
    {
        // verify that the button is down
        // this can happen if the tool didn't set capture so it didn't get the up message
        if (GetKeyState(VK_LBUTTON) >= 0 &&
            GetKeyState(VK_RBUTTON) >= 0 &&
            GetKeyState(VK_MBUTTON) >= 0)
            pTtm->dwFlags &= ~BUTTONISDOWN;
    }
    
    switch (message) 
    {
    case WM_NCLBUTTONUP:
    case WM_NCRBUTTONUP:
    case WM_NCMBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONUP:
    case WM_LBUTTONUP:
        pTtm->dwFlags &= ~BUTTONISDOWN;
        break;

    case WM_NCLBUTTONDOWN:
    case WM_NCRBUTTONDOWN:
    case WM_NCMBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_LBUTTONDOWN:
        pTtm->dwFlags |= BUTTONISDOWN;
        ShowVirtualBubble(pTtm);
        break;

    case WM_NCMOUSEMOVE:
    {
        // convert to client coords
        POINT pt;
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        ScreenToClient(hwnd, &pt);
        lParam = MAKELONG(pt.x, pt.y);
        ht = (int) wParam;

        // Fall thru...
    }
    case WM_MOUSEMOVE: {

        TOOLINFO *pTool;
        // to prevent us from popping up when some
        // other app is active
        if (((!(pTtm->_ci.style & TTS_ALWAYSTIP)) && !(ChildOfActiveWindow(hwnd))) ||
           !(pTtm->dwFlags & ACTIVE) ||
           (pTtm->dwFlags & BUTTONISDOWN))
        {
            break;
        }

        pTool = GetToolAtPoint(pTtm, hwnd, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), ht, FALSE);
        if (pTool) 
        {
            int id = 0;
            // show only if another is showing
            if (pTtm->dwFlags & (VIRTUALBUBBLEUP | BUBBLEUP)) 
            {
                // call show if bubble is up to make sure we're showing
                // for the right tool
                if (pTool != pTtm->pCurTool) 
                {
                    DebugMsg(TF_TT, TEXT("showing virtual bubble"));
                    PopBubble2(pTtm, TRUE);
                    pTtm->pCurTool = pTool;
                    ShowVirtualBubble(pTtm);
                    id = TTT_RESHOW;
                }
                else if (pTtm->idTimer == TTT_RESHOW) 
                {
                    // if the timer is currently waiting to reshow,
                    // don't reset the timer on mouse moves
                    id = 0;
                }
            }
            else if (pTtm->idTimer != TTT_INITIAL || pTtm->pCurTool != pTool)
            {
                pTtm->pCurTool = pTool;
                id = TTT_INITIAL;
            }

            DebugMsg(TF_TT, TEXT("MouseMove over pTool id = %d"), id);
            if (id)
                TTSetTimer(pTtm, id);
        }
        else 
        {
            DebugMsg(TF_TT, TEXT("MouseMove over non-tool"));
            PopBubble(pTtm);
        }
        break;
        }
    }
}

void TTUpdateTipText(CToolTipsMgr *pTtm, TOOLINFO *lpti)
{
    TOOLINFO *lpTool = FindTool(pTtm, lpti);
    if (lpTool) 
    {
        lpTool->hinst = lpti->hinst;
        TTSetTipText(lpTool, lpti->lpszText);
        if (pTtm->dwFlags & TRACKMODE) 
        {
            // if track mode is in effect and active, then
            // redisplay the bubble.
            if (pTtm->pCurTool)
                DoShowBubble(pTtm);
        } 
        else if (lpTool == pTtm->pCurTool) 
        {
            // set the current position to our saved position.
            // ToolHasMoved will return false for us if those this point
            // is no longer within pCurTool's area
            GetCursorPos(&pTtm->pt);
            if (!ToolHasMoved(pTtm)) 
            {
                if (pTtm->dwFlags & (VIRTUALBUBBLEUP | BUBBLEUP)) 
                    DoShowBubble(pTtm);
            }
            else
            {
                DebugMsg(TF_TT, TEXT("TTUpdateTipText popping bubble"));
                PopBubble2(pTtm, TRUE);
            }
        }
    }
}

void TTSetFont(CToolTipsMgr *pTtm, HFONT hFont, BOOL fInval)
{
    ToolTips_NewFont(pTtm, hFont);
    if (hFont != NOFONT)
    {
        GetCurToolBestMarkup(pTtm)->SetFonts(pTtm->hFont, pTtm->hFontUnderline);
    }
    
    if (fInval)
    {
        // is a balloon up and is it in the track mode?
        if ((pTtm->dwFlags & ACTIVE) && pTtm->pCurTool && (pTtm->pCurTool->uFlags & TTF_TRACK))
        {
            TOOLINFO *pCurTool = pTtm->pCurTool;
            
            PopBubble2(pTtm, TRUE); // sets pTtm->pCurTool to NULL
            ShowBubbleForTool(pTtm, pCurTool);
        }
        else
            InvalidateRect(pTtm->_ci.hwnd, NULL, FALSE);
    }
}

void TTSetDelayTime(CToolTipsMgr *pTtm, WPARAM wParam, LPARAM lParam)
{
    int iDelayTime = GET_X_LPARAM(lParam);

    switch (wParam) 
    {
    case TTDT_INITIAL:
        pTtm->iDelayTime = iDelayTime;
        break;

    case TTDT_AUTOPOP:
        pTtm->iAutoPopTime = iDelayTime;
        break;

    case TTDT_RESHOW:
        pTtm->iReshowTime = iDelayTime;
        break;

    case TTDT_AUTOMATIC:
        if (iDelayTime > 0)
        {
            pTtm->iDelayTime = iDelayTime;
            pTtm->iReshowTime = pTtm->iDelayTime / 5;
            pTtm->iAutoPopTime = pTtm->iDelayTime * 10;
        }
        else
        {
            pTtm->iDelayTime = -1;
            pTtm->iReshowTime = -1;
            pTtm->iAutoPopTime = -1;
        }
        break;
    }
}

int TTGetDelayTime(CToolTipsMgr *pTtm, WPARAM wParam)
{
    switch (wParam) 
    {
    case TTDT_AUTOMATIC:
    case TTDT_INITIAL:
        return (pTtm->iDelayTime < 0 ? GetDoubleClickTime() : pTtm->iDelayTime);

    case TTDT_AUTOPOP:
        return (pTtm->iAutoPopTime < 0 ? GetDoubleClickTime()*10 : pTtm->iAutoPopTime);

    case TTDT_RESHOW:
        return (pTtm->iReshowTime < 0 ? GetDoubleClickTime()/5 : pTtm->iReshowTime);

    default:
        return -1;
    }
}

BOOL CopyToolInfoA(TOOLINFO *pToolSrc, PTOOLINFOA lpTool, UINT uiCodePage)
{
    if (pToolSrc && lpTool) 
    {
        if (lpTool->cbSize >= sizeof(TOOLINFOA) - sizeof(LPARAM)) 
        {
            lpTool->uFlags = pToolSrc->uFlags;
            lpTool->hwnd = pToolSrc->hwnd;
            lpTool->uId = pToolSrc->uId;
            lpTool->rect = pToolSrc->rect;
            lpTool->hinst = pToolSrc->hinst;
            if ((pToolSrc->lpszText != LPSTR_TEXTCALLBACK) &&
                !IS_INTRESOURCE(pToolSrc->lpszText)) 
            {
                if (lpTool->lpszText) 
                {
                    WideCharToMultiByte(uiCodePage, 0,
                                                 pToolSrc->lpszText,
                                                 -1,
                                                 lpTool->lpszText,
                                                 80, NULL, NULL);
                }
            } 
            else 
                lpTool->lpszText = (LPSTR)pToolSrc->lpszText;
        }

        if (lpTool->cbSize > FIELD_OFFSET(TOOLINFOA, lParam))
            lpTool->lParam = pToolSrc->lParam;
        
        if (lpTool->cbSize > sizeof(TOOLINFOA))
            return FALSE;
            
        return TRUE;
    } 
    else
        return FALSE;
}

BOOL CopyToolInfo(TOOLINFO *pToolSrc, PTOOLINFO lpTool)
{
    if (pToolSrc && lpTool && lpTool->cbSize <= sizeof(TOOLINFO)) 
    {
        if (lpTool->cbSize >= sizeof(TOOLINFO) - sizeof(LPARAM)) 
        {
            lpTool->uFlags = pToolSrc->uFlags;
            lpTool->hwnd = pToolSrc->hwnd;
            lpTool->uId = pToolSrc->uId;
            lpTool->rect = pToolSrc->rect;
            lpTool->hinst = pToolSrc->hinst;
            if ((pToolSrc->lpszText != LPSTR_TEXTCALLBACK) && !IS_INTRESOURCE(pToolSrc->lpszText)) 
            {
                if (lpTool->lpszText) 
                    lstrcpy(lpTool->lpszText, pToolSrc->lpszText);
            }
            else 
                lpTool->lpszText = pToolSrc->lpszText;
        }
        if (lpTool->cbSize > FIELD_OFFSET(TOOLINFO, lParam))
             lpTool->lParam = pToolSrc->lParam;
        
        if (lpTool->cbSize > sizeof(TOOLINFO))
            return FALSE;
    
        return TRUE;
    }
    else
        return FALSE;
}

PTOOLINFO TTToolAtMessagePos(CToolTipsMgr *pTtm)
{
    TOOLINFO *pTool;
    HWND hwndPt;
    POINT pt;
    DWORD dwPos = GetMessagePos();
    //int ht;

    pt.x = GET_X_LPARAM(dwPos);
    pt.y = GET_Y_LPARAM(dwPos);
    hwndPt = TTWindowFromPoint(pTtm, &pt);
    //ht = SendMessage(hwndPt, WM_NCHITTEST, 0, MAKELONG(pt.x, pt.y));
    ScreenToClient(hwndPt, &pt);
    pTool = GetToolAtPoint(pTtm, hwndPt, pt.x, pt.y, HTERROR, FALSE);

    return pTool;
}

void TTCheckCursorPos(CToolTipsMgr *pTtm)
{
    TOOLINFO *pTool = TTToolAtMessagePos(pTtm);
    if ((pTtm->pCurTool != pTool) || 
        ToolHasMoved(pTtm)) 
    {
        PopBubble(pTtm);
        DebugMsg(TF_TT, TEXT("TTCheckCursorPos popping bubble"));
    }
}

void TTHandleTimer(CToolTipsMgr *pTtm, UINT_PTR id)
{
    TOOLINFO *pTool;

    switch (id)
    {
    case TTT_FADESHOW:
        pTtm->iFadeState += TT_FADESHOWINCREMENT;
        if (pTtm->iFadeState > TT_MAXFADESHOW)
        {
            pTtm->iFadeState = TT_MAXFADESHOW;
            KillTimer(pTtm->_ci.hwnd, TTT_FADESHOW);
        }

        SetLayeredWindowAttributes(pTtm->_ci.hwnd, 0, (BYTE)pTtm->iFadeState, LWA_ALPHA);
        break;

    case TTT_FADEHIDE:
        pTtm->iFadeState -= TT_FADEHIDEDECREMENT;
        if (pTtm->iFadeState <= 0)
        {
            KillTimer(pTtm->_ci.hwnd, TTT_FADEHIDE);
            pTtm->iFadeState = 0;
            ShowWindow(pTtm->_ci.hwnd, SW_HIDE);
        }
        SetLayeredWindowAttributes(pTtm->_ci.hwnd, 0, (BYTE)pTtm->iFadeState, LWA_ALPHA);
        break;
    }
    
    // punt all timers in track mode
    if (pTtm->dwFlags & TRACKMODE)
        return;

    switch (id) 
    {

    case TTT_AUTOPOP:
        TTCheckCursorPos(pTtm); 
        if (pTtm->pCurTool) 
        {
            DebugMsg(TF_TT, TEXT("ToolTips: Auto popping"));
            ShowVirtualBubble(pTtm);
        }
        break;

    case TTT_POP:

        // this could be started up again by a slight mouse touch
        if (pTtm->dwFlags & VIRTUALBUBBLEUP) 
        {
            KillTimer(pTtm->_ci.hwnd, TTT_POP);
        }

        TTCheckCursorPos(pTtm); 
        break;
        
    case TTT_INITIAL:
        if (ToolHasMoved(pTtm)) 
        {
            // this means the timer went off
            // without us getting a mouse move
            // which means they left our tools.
            PopBubble(pTtm);
            break;
        }

        // else fall through

    case TTT_RESHOW:
        pTool = TTToolAtMessagePos(pTtm);
        if (!pTool) 
        {
            if (pTtm->pCurTool) 
                PopBubble(pTtm);
        } 
        else if (pTtm->dwFlags & ACTIVE) 
        {
            if (id == TTT_RESHOW) 
            {
                // this will force a re-show
                pTtm->dwFlags &= ~(BUBBLEUP|VIRTUALBUBBLEUP);
            }
            ShowBubbleForTool(pTtm, pTool);
        }
        break;  
    }
}    

// TTRender is theme aware (RENDERS)
BOOL TTRender(CToolTipsMgr *pTtm, HDC hdc)
{
    BOOL bRet = FALSE;
    RECT rc;

    if (pTtm->pCurTool && MarkupCurToolText(pTtm))
    {
        UINT uFlags;
        NMTTCUSTOMDRAW nm;
        UINT uDefDrawFlags = 0;
        LPRECT prcMargin = &pTtm->rcMargin;

        HBRUSH hbr;
        DWORD  dwCustomDraw = CDRF_DODEFAULT;

        uFlags = 0;

        if ((pTtm->pCurTool->uFlags & TTF_RTLREADING) || (pTtm->_ci.dwExStyle & WS_EX_RTLREADING))
            uFlags |= ETO_RTLREADING;

        SelectObject(hdc, pTtm->hFont);
        GetClientRect(pTtm->_ci.hwnd, &rc);
        SetTextColor(hdc, pTtm->clrTipText);

        /* If we support pre-Draw text then call the client allowing them to modify
         /  the item, and then render.  Otherwise just use ExTextOut */
        nm.nmcd.hdr.hwndFrom = pTtm->_ci.hwnd;
        nm.nmcd.hdr.idFrom = pTtm->pCurTool->uId;
        nm.nmcd.hdr.code = NM_CUSTOMDRAW;
        nm.nmcd.hdc = hdc;
        nm.nmcd.dwDrawStage = CDDS_PREPAINT;

        // ADJUSTRECT!  Keep TTAdjustRect and TTGetTipPosition in sync.
        nm.nmcd.rc.left   = rc.left   + XTEXTOFFSET*g_cxBorder + prcMargin->left;
        nm.nmcd.rc.right  = rc.right  - XTEXTOFFSET*g_cxBorder - prcMargin->right;
        nm.nmcd.rc.top    = rc.top    + YTEXTOFFSET*g_cyBorder + prcMargin->top;
        nm.nmcd.rc.bottom = rc.bottom - YTEXTOFFSET*g_cyBorder - prcMargin->bottom;

        if (pTtm->_ci.style & TTS_BALLOON)
        {
            InflateRect(&(nm.nmcd.rc), -XBALLOONOFFSET, -YBALLOONOFFSET);
            if (!pTtm->fUnderStem)
                OffsetRect(&(nm.nmcd.rc), 0, pTtm->iStemHeight);
        }

        if (pTtm->iMaxTipWidth == -1) 
            uDefDrawFlags = DT_SINGLELINE |DT_LEFT;
        else 
            uDefDrawFlags = DT_LEFT | DT_WORDBREAK | DT_EXPANDTABS | DT_EXTERNALLEADING;

        if (pTtm->_ci.style & TTS_NOPREFIX)
            uDefDrawFlags |= DT_NOPREFIX;

        if ((pTtm->pCurTool->uFlags & TTF_RTLREADING) || (pTtm->_ci.dwExStyle & WS_EX_RTLREADING))
            uDefDrawFlags |= DT_RTLREADING;
        //
        // Make it right aligned, if requested. [samera]
        //
        if (pTtm->pCurTool->uFlags & TTF_RIGHT)
            uDefDrawFlags |= DT_RIGHT;
 
        nm.uDrawFlags = uDefDrawFlags;

        dwCustomDraw = (DWORD)SendNotifyEx(pTtm->pCurTool->hwnd, (HWND) -1,
                     0, (NMHDR*) &nm,
                     (pTtm->pCurTool->uFlags & TTF_UNICODE) ? 1 : 0);
        // did the owner do custom draw? yes, we're done
        if (dwCustomDraw == CDRF_SKIPDEFAULT)
            return TRUE;

        // if this fails, it may be the a dither...
        // in which case, we can't set the bk color
        hbr = CreateSolidBrush(pTtm->clrTipBk);
        FillRect(hdc, &rc, hbr);
        DeleteObject(hbr);

        SetBkMode(hdc, TRANSPARENT);
        uFlags |= ETO_CLIPPED;

        // Account for off-by-one.  Something wierd about DrawText
        // clips the bottom-most pixelrow, so increase one more
        // into the margin space.

        // ADJUSTRECT!  Keep TTAdjustRect in sync.
        nm.nmcd.rc.bottom++;
        nm.nmcd.rc.right++;
        // if in balloon style the text is already indented so no need for inflate..
        if (pTtm->cchTipTitle > 0 && !(pTtm->_ci.style & TTS_BALLOON))
            InflateRect(&nm.nmcd.rc, -XBALLOONOFFSET, -YBALLOONOFFSET);

        if (!TTRenderTitledTip(pTtm, hdc, FALSE, &nm.nmcd.rc, uDefDrawFlags))
        {
            GetCurToolBestMarkup(pTtm)->SetRenderFlags(nm.uDrawFlags);

            GetCurToolBestMarkup(pTtm)->DrawText(hdc, &nm.nmcd.rc);
        }

        if (pTtm->_ci.style & TTS_BALLOON)
        {
            HRGN rgn = CreateRectRgn(1,1,2,2);

            if (rgn)
            {
                int iRet = GetWindowRgn(pTtm->_ci.hwnd, rgn);
                if (iRet != ERROR)
                {
                    COLORREF crBrdr = pTtm->clrTipText;
                    HBRUSH hbr = CreateSolidBrush(crBrdr);
                    FrameRgn(hdc, rgn, hbr, 1, 1);
                    DeleteObject(hbr);
                }
                DeleteObject(rgn);
            }
        }

        // notify parent afterwards if they want us to
        if (!(dwCustomDraw & CDRF_SKIPDEFAULT) &&
            dwCustomDraw & CDRF_NOTIFYPOSTPAINT) 
        {
            // Convert PREPAINT to POSTPAINT and ITEMPREPAINT to ITEMPOSTPAINT
            COMPILETIME_ASSERT(CDDS_POSTPAINT - CDDS_PREPAINT ==
                               CDDS_ITEMPOSTPAINT - CDDS_ITEMPREPAINT);
            nm.nmcd.dwDrawStage += CDDS_POSTPAINT - CDDS_PREPAINT;
            SendNotifyEx(pTtm->pCurTool->hwnd, (HWND) -1,
                         0, (NMHDR*) &nm,
                         (pTtm->pCurTool->uFlags & TTF_UNICODE) ? 1 : 0);
        }

        bRet = TRUE;
    }

    return bRet;
}

void TTOnPaint(CToolTipsMgr *pTtm)
{
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(pTtm->_ci.hwnd, &ps);

    if (!TTRender(pTtm, hdc)) 
    {
        DebugMsg(TF_TT, TEXT("TTOnPaint render failed popping bubble"));
        PopBubble(pTtm);
    }

    EndPaint(pTtm->_ci.hwnd, &ps);
    pTtm->fEverShown = TRUE;                // See TTOnFirstShow
}

// ToolTipsWndProc is theme aware
LRESULT WINAPI ToolTipsWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TOOLINFO *pTool;
    TOOLINFO *pToolSrc;
    CToolTipsMgr *pTtm = (CToolTipsMgr *) GetWindowPtr(hwnd, 0);
    POINT pt;
    
    if (!pTtm && uMsg != WM_CREATE)
        goto DoDefault;

    switch (uMsg)
    {
    case TTM_ACTIVATE:
        if (wParam) 
        {
            pTtm->dwFlags |= ACTIVE;
        }
        else
        {
            PopBubble(pTtm);
            pTtm->dwFlags &= ~(ACTIVE | TRACKMODE);
        }
        break;

    case TTM_SETDELAYTIME:
        TTSetDelayTime(pTtm, wParam, lParam);
        break;

    case TTM_GETDELAYTIME:
        return (LRESULT)(UINT)TTGetDelayTime(pTtm, wParam);
        
    case TTM_ADDTOOLA:
        {
        TOOLINFOW ti;

        if (!lParam)
            return FALSE;

        if (!ThunkToolInfoAtoW((LPTOOLINFOA)lParam, &ti, TRUE, pTtm->_ci.uiCodePage))
            return FALSE;

        LRESULT res = AddTool(pTtm, &ti);

        if ((ti.uFlags & TTF_MEMALLOCED) && (ti.lpszText != LPSTR_TEXTCALLBACK)) 
            LocalFree(ti.lpszText);

        return res;
        }

    case TTM_ADDTOOL:
        if (!lParam)
            return FALSE;

        return AddTool(pTtm, (LPTOOLINFO)lParam);

    case TTM_DELTOOLA:
        {
        TOOLINFOW ti;

        if (!lParam) 
            return FALSE;

        if (!ThunkToolInfoAtoW((LPTOOLINFOA)lParam, &ti, FALSE, pTtm->_ci.uiCodePage)) 
            break;

        DeleteTool(pTtm, &ti);
        break;
        }
        
    case TTM_DELTOOL:
        if (!lParam)
            return FALSE;

        DeleteTool(pTtm, (LPTOOLINFO)lParam);
        break;

    case TTM_NEWTOOLRECTA:
        {
        TOOLINFOW ti;

        if (!lParam) 
            return FALSE;

        if (!ThunkToolInfoAtoW((LPTOOLINFOA)lParam, &ti, FALSE, pTtm->_ci.uiCodePage)) 
            break;

        pTool = FindTool(pTtm, &ti);
        if (pTool) 
            pTool->rect = ((LPTOOLINFOA)lParam)->rect;

        break;
        }
        
    case TTM_NEWTOOLRECT:
        if (!lParam)
            return FALSE;

        pTool = FindTool(pTtm, (LPTOOLINFO)lParam);
        if (pTool)
            pTool->rect = ((LPTOOLINFO)lParam)->rect;

        break;

    case TTM_GETTOOLCOUNT:
        return pTtm->iNumTools;

    case TTM_GETTOOLINFOA:
        {
        TOOLINFOW ti;

        if (!lParam)
            return FALSE;

        if (!ThunkToolInfoAtoW((LPTOOLINFOA)lParam, &ti, FALSE, pTtm->_ci.uiCodePage))
            return FALSE;

        pToolSrc = FindTool(pTtm, &ti);

        return (LRESULT)(UINT)CopyToolInfoA(pToolSrc, (LPTOOLINFOA)lParam, pTtm->_ci.uiCodePage);
        }

    case TTM_GETCURRENTTOOLA:
        if (lParam) 
            return (LRESULT)(UINT)CopyToolInfoA(pTtm->pCurTool, (LPTOOLINFOA)lParam, pTtm->_ci.uiCodePage);
        else
            return BOOLFROMPTR(pTtm->pCurTool);

    case TTM_ENUMTOOLSA:
        if (wParam < (UINT)pTtm->iNumTools) 
        {
            pToolSrc = &pTtm->tools[wParam];
            return (LRESULT)(UINT)CopyToolInfoA(pToolSrc, (LPTOOLINFOA)lParam, pTtm->_ci.uiCodePage);
        }
        return FALSE;

    case TTM_GETTOOLINFO:
        if (!lParam)
            return FALSE;
        pToolSrc = FindTool(pTtm, (LPTOOLINFO)lParam);
        return (LRESULT)(UINT)CopyToolInfo(pToolSrc, (LPTOOLINFO)lParam);

    case TTM_GETCURRENTTOOL:
        if (lParam)
            return (LRESULT)(UINT)CopyToolInfo(pTtm->pCurTool, (LPTOOLINFO)lParam);
        else 
            return BOOLFROMPTR(pTtm->pCurTool);

    case TTM_ENUMTOOLS:
        if (wParam < (UINT)pTtm->iNumTools) 
        {
            pToolSrc = &pTtm->tools[wParam];
            return (LRESULT)(UINT)CopyToolInfo(pToolSrc, (LPTOOLINFO)lParam);
        }
        return FALSE;

    case TTM_SETTOOLINFOA:
        {
        TOOLINFOW ti;

        if (!lParam)
            return FALSE;

        if (!ThunkToolInfoAtoW((LPTOOLINFOA)lParam, &ti, TRUE, pTtm->_ci.uiCodePage))
            return FALSE;

        pTool = FindTool(pTtm, &ti);
        if (pTool) 
        {
            TTSetTipText(pTool, NULL);
            CopyTool(pTool, &ti);
            TTSetTipText(pTool, ti.lpszText);

            if (pTool == pTtm->pCurTool) 
            {
                DoShowBubble(pTtm);
            }
        }

        if ((ti.uFlags & TTF_MEMALLOCED) && (ti.lpszText != LPSTR_TEXTCALLBACK)) 
            LocalFree(ti.lpszText);

        break;
        }

    case TTM_SETTOOLINFO:
        if (!lParam)
            return FALSE;
        pTool = FindTool(pTtm, (LPTOOLINFO)lParam);
        if (pTool) 
        {
            TTSetTipText(pTool, NULL);
            CopyTool(pTool, (LPTOOLINFO)lParam); 
            TTSetTipText(pTool, ((LPTOOLINFO)lParam)->lpszText);
            
            if (pTool == pTtm->pCurTool) 
            {
                DoShowBubble(pTtm);
            }
        }
        break;

    case TTM_HITTESTA:
#define lphitinfoA ((LPHITTESTINFOA)lParam)
        if (!lParam)
            return FALSE;
        pTool = GetToolAtPoint(pTtm, lphitinfoA->hwnd, lphitinfoA->pt.x, lphitinfoA->pt.y, HTERROR, TRUE);
        if (pTool) 
        {
            ThunkToolInfoWtoA(pTool, (LPTOOLINFOA)(&(lphitinfoA->ti)), pTtm->_ci.uiCodePage);
            return TRUE;
        }
        return FALSE;

    case TTM_HITTEST:
#define lphitinfo ((LPHITTESTINFO)lParam)
        if (!lParam)
            return FALSE;
        pTool = GetToolAtPoint(pTtm, lphitinfo->hwnd, lphitinfo->pt.x, lphitinfo->pt.y, HTERROR, TRUE);
        if (pTool) 
        {
            // for back compat...  if thesize isn't set right, we only give
            // them the win95 amount.
            if (lphitinfo->ti.cbSize != sizeof(TTTOOLINFO)) 
            {
                *((WIN95TTTOOLINFO*)&lphitinfo->ti) = *(WIN95TTTOOLINFO*)pTool;
            } 
            else
            {
                lphitinfo->ti = *pTool;
            }
            return TRUE;
        }
        return FALSE;

    case TTM_GETTEXTA: 
        {
            LPWSTR lpszTemp;
            TOOLINFOW ti;

            if (!lParam || !((LPTOOLINFOA)lParam)->lpszText)
                return FALSE;

            if (!ThunkToolInfoAtoW((LPTOOLINFOA)lParam, &ti, FALSE, pTtm->_ci.uiCodePage))
                break;
                       
            ((LPTOOLINFOA)lParam)->lpszText[0] = 0;
            pTool = FindTool(pTtm, &ti);
            lpszTemp = GetToolText(pTtm, pTool);
            if (lpszTemp) 
            {
                WideCharToMultiByte(pTtm->_ci.uiCodePage,
                                     0,
                                     lpszTemp,
                                     -1,
                                     (((LPTOOLINFOA)lParam)->lpszText),
                                     80, NULL, NULL);

                LocalFree(lpszTemp);
            }
        }
        break;

    case TTM_GETTEXT: 
        {
            if (!lParam || !pTtm || !((LPTOOLINFO)lParam)->lpszText)
                return FALSE;

            ((LPTOOLINFO)lParam)->lpszText[0] = 0;
            pTool = FindTool(pTtm, (LPTOOLINFO)lParam);

            LPTSTR lpszTemp = GetToolText(pTtm, pTool);
            if (lpszTemp) 
            {
                lstrcpy((((LPTOOLINFO)lParam)->lpszText), lpszTemp);
                LocalFree(lpszTemp);
            }
        }
        break;


    case WM_GETTEXTLENGTH:
    case WM_GETTEXT:
    {
        TCHAR *pszDest = uMsg == WM_GETTEXT ? (TCHAR *)lParam : NULL;
        LRESULT lres = 0;

        // Pre-terminate the string just in case
        if (pszDest && wParam)
            pszDest[0] = 0;

        if (pTtm) 
        {
            LPTSTR lpszStr = GetCurToolText(pTtm);
            if (lpszStr)
            {
                if (pszDest && wParam) 
                {
                    StrCpyN(pszDest, lpszStr, (int) wParam);
                    lres = lstrlen(pszDest);
                } 
                else 
                {
                    lres = lstrlen(lpszStr);
                }

                LocalFree(lpszStr);
            }
        } 
        return lres;
    }

    case TTM_RELAYEVENT:
        {
            MSG* pmsg = ((MSG*)lParam);
            if (!pmsg)
                return FALSE;
            HandleRelayedMessage(pTtm, pmsg->hwnd, pmsg->message, pmsg->wParam, pmsg->lParam);
        }
        break;

    // this is here for people to subclass and fake out what we
    // think the window from point is.  this facilitates "transparent" windows
    case TTM_WINDOWFROMPOINT: 
    {
        HWND hwndPt = WindowFromPoint(*((POINT *)lParam));
        DebugMsg(TF_TT, TEXT("TTM_WINDOWFROMPOINT %x"), hwndPt);
        return (LRESULT)hwndPt;
    }

    case TTM_UPDATETIPTEXTA:
    {
        TOOLINFOW ti;

        if (lParam) 
        {
            if (!ThunkToolInfoAtoW((LPTOOLINFOA)lParam, &ti, TRUE, pTtm->_ci.uiCodePage)) 
            {
                break;
            }
            TTUpdateTipText(pTtm, &ti);

            if ((ti.uFlags & TTF_MEMALLOCED) && (ti.lpszText != LPSTR_TEXTCALLBACK)) 
            {
                LocalFree(ti.lpszText);
            }
        }
        break;
    }

    case TTM_UPDATETIPTEXT:
        if (lParam)
            TTUpdateTipText(pTtm, (LPTOOLINFO)lParam);
        break;

    /* Pop the current tooltip if there is one displayed, ensuring that the virtual
    /  bubble is also discarded. */

    case TTM_POP:
    {
        if (pTtm->dwFlags & BUBBLEUP)
            PopBubble(pTtm);

        pTtm->dwFlags &= ~VIRTUALBUBBLEUP;

        break;
    }

    case TTM_POPUP:
        {
            TOOLINFO *pTool;
            pTool = TTToolAtMessagePos(pTtm);
            if (pTool && pTtm->dwFlags & ACTIVE) 
            {
                // this will force a re-show
                pTtm->dwFlags &= ~(BUBBLEUP|VIRTUALBUBBLEUP);
                ShowBubbleForTool(pTtm, pTool);
                return TRUE;
            }
        }
        break;
    

    case TTM_TRACKPOSITION:
        if ((GET_X_LPARAM(lParam) != pTtm->ptTrack.x) || 
            (GET_Y_LPARAM(lParam) != pTtm->ptTrack.y)) 
        {
            pTtm->ptTrack.x = GET_X_LPARAM(lParam); 
            pTtm->ptTrack.y = GET_Y_LPARAM(lParam);
        
            // if track mode is in effect, update the position
            if ((pTtm->dwFlags & TRACKMODE) && 
                pTtm->pCurTool) 
            {
                DoShowBubble(pTtm);
            }
        }
        break;
        
    case TTM_UPDATE:
        if (!lParam ||
            lParam == (LPARAM)pTtm->pCurTool) 
        {
            DoShowBubble(pTtm);
        }
        break;

    case TTM_TRACKACTIVATE:
        if (pTtm->dwFlags & ACTIVE) 
        {
            if (wParam && lParam)
                wParam = TRACKMODE;
            else 
                wParam = 0;
            
            if ((wParam ^ pTtm->dwFlags) & TRACKMODE) 
            {
                // if the trackmode changes by this..
                PopBubble2(pTtm, FALSE);

                pTtm->dwFlags ^= TRACKMODE;
                if (wParam) 
                {
                    // turning on track mode
                    pTool = FindTool(pTtm, (LPTOOLINFO)lParam);
                    if (pTool) 
                    {
                        // only if the tool is found
                        ShowBubbleForTool(pTtm, pTool);
                    }
                }
            }
        }
        return TRUE;
        
    case TTM_SETTIPBKCOLOR:
        if (pTtm->clrTipBk != (COLORREF)wParam) 
        {
            pTtm->clrTipBk = (COLORREF)wParam;
            InvalidateRgn(pTtm->_ci.hwnd,NULL,TRUE);
        }
        pTtm->fBkColorSet = TRUE;
        break;
        
    case TTM_GETTIPBKCOLOR:
        return (LRESULT)(UINT)pTtm->clrTipBk;
        
    case TTM_SETTIPTEXTCOLOR:
        if (pTtm->clrTipText != (COLORREF)wParam) 
        {
            InvalidateRgn(pTtm->_ci.hwnd,NULL,TRUE);
            pTtm->clrTipText = (COLORREF)wParam;
        }
        pTtm->fTextColorSet = TRUE;
        break;
        
    case TTM_GETTIPTEXTCOLOR:
        return (LRESULT)(UINT)pTtm->clrTipText;
        
    case TTM_SETMAXTIPWIDTH:
    {
        int iOld = pTtm->iMaxTipWidth;
        pTtm->iMaxTipWidth = (int)lParam;
        return iOld;
    }
        
    case TTM_GETMAXTIPWIDTH:
        return pTtm->iMaxTipWidth;
        
    case TTM_SETMARGIN:
        if (lParam)
            pTtm->rcMargin = *(LPRECT)lParam;
        break;

    case TTM_GETMARGIN:
        if (lParam)
            *(LPRECT)lParam = pTtm->rcMargin;
        break;

    case TTM_GETBUBBLESIZE:
        if (lParam)
        {
            pTool = FindTool(pTtm, (LPTOOLINFO)lParam);
            if (pTool)
            {                
                // We actually have to insert this text into our markup to get the proper tipsize
                // We don't reset it later because DoShowBubble and TTRender do when they draw.
                if (CheckToolMarkup(pTool)) 
                {
                    LPTSTR psz = GetToolText(pTtm, pTool);
                    if (psz)
                    {
                        GetToolMarkup(pTool)->SetText(psz);
                        LocalFree(psz);
                    }
                }

                int cxText, cyText, cxMargin, cyMargin, iBubbleWidth, iBubbleHeight;

                TTGetTipSize(pTtm, pTool, &cxText, &cyText);

                cxMargin = pTtm->rcMargin.left + pTtm->rcMargin.right;
                cyMargin = pTtm->rcMargin.top + pTtm->rcMargin.bottom;
                iBubbleWidth =  2*XTEXTOFFSET * g_cxBorder + cxText + cxMargin;
                iBubbleHeight = 2*YTEXTOFFSET * g_cyBorder + cyText + cyMargin;

                if (pTtm->_ci.style & TTS_BALLOON)
                {
                    iBubbleWidth += 2*XBALLOONOFFSET;
                    iBubbleHeight += 2*YBALLOONOFFSET;
                }   
                return MAKELONG(iBubbleWidth, iBubbleHeight);
            }
        }
        break;

    case TTM_ADJUSTRECT:
        return TTAdjustRect(pTtm, BOOLFROMPTR(wParam), (LPRECT)lParam);

    case TTM_SETTITLEA:
        {
            TCHAR szTitle[MAX_TIP_CHARACTERS];
            pTtm->uTitleBitmap = (UINT)wParam;
            Str_Set(&pTtm->lpTipTitle, NULL);
            pTtm->iTitleHeight = 0;

            TTCreateTitleBitmaps(pTtm);

            if (lParam)
            {
                pTtm->cchTipTitle = lstrlenA((LPCSTR)lParam);
                if (pTtm->cchTipTitle < ARRAYSIZE(szTitle))
                {
                    ConvertAToWN(pTtm->_ci.uiCodePage, szTitle, ARRAYSIZE(szTitle),
                        (LPCSTR)lParam, -1);
                    Str_Set(&pTtm->lpTipTitle, szTitle);
                    if (pTtm->pCurTool) 
                    {
                        INT cxText, cyText;

                        // recalculate the tip size
                        TTGetTipSize(pTtm, pTtm->pCurTool, &cxText, &cyText);
                    }
                    return TRUE;
                }
            }
            pTtm->cchTipTitle = 0;
            return FALSE;
        }
        break;
    case TTM_SETTITLE:
        {
            pTtm->uTitleBitmap = (UINT)wParam;
            Str_Set(&pTtm->lpTipTitle, NULL);
            pTtm->iTitleHeight = 0;

            TTCreateTitleBitmaps(pTtm);

            if (lParam)
            {
                pTtm->cchTipTitle = lstrlen((LPCTSTR)lParam);
                if (pTtm->cchTipTitle < MAX_TIP_CHARACTERS)
                {
                    Str_Set(&pTtm->lpTipTitle, (LPCTSTR)lParam);
                    if (pTtm->pCurTool) 
                    {
                        INT cxText, cyText;

                        // recalculate the tip size
                        TTGetTipSize(pTtm, pTtm->pCurTool, &cxText, &cyText);
                    }
                    return TRUE;                    
                }
            }
            pTtm->cchTipTitle = 0;
            return FALSE;
        }
        break;

    case TTM_GETTITLE:
        {
            if (wParam != 0 || lParam == 0 || pTtm->lpTipTitle == NULL)
                return FALSE;

            TTGETTITLE* pgt = (TTGETTITLE*)lParam;
            if (pgt->dwSize != sizeof(TTGETTITLE) || 
                pgt->cch == 0 || 
                pgt->pszTitle == NULL)
            {
                return FALSE;
            }

            StrCpyN(pgt->pszTitle, pTtm->lpTipTitle, pgt->cch);
            pgt->uTitleBitmap = pTtm->uTitleBitmap;

            return TRUE;
        }
        break;

    case TTM_SETWINDOWTHEME:
        if (lParam)
        {
            SetWindowTheme(hwnd, (LPWSTR)lParam, NULL);
        }
        break;

        /* uMsgs that REALLY came for me. */

    case WM_CREATE:
        {
            DWORD dwBits, dwValue;

            pTtm = ToolTipsMgrCreate(hwnd, (LPCREATESTRUCT)lParam);
            if (!pTtm)
                return -1;

            // Create a markup for compatibility with old TOOLINFO
            if (SUCCEEDED(Markup_Create(pTtm, NULL, NULL, IID_PPV_ARG(IControlMarkup, &pTtm->pMarkup))))
            {
                SetWindowPtr(hwnd, 0, pTtm);
                SetWindowBits(hwnd, GWL_EXSTYLE, WS_EX_LAYERED | WS_EX_TOOLWINDOW, WS_EX_LAYERED | WS_EX_TOOLWINDOW);

                dwBits = WS_CHILD | WS_POPUP | WS_BORDER | WS_DLGFRAME;
                dwValue = WS_POPUP | WS_BORDER;
                // we don't want border for balloon style
                if (pTtm->_ci.style & TTS_BALLOON)
                    dwValue &= ~WS_BORDER;
                SetWindowBits(hwnd, GWL_STYLE, dwBits, dwValue);

                // Initialize themes
                pTtm->hTheme = OpenThemeData(pTtm->_ci.hwnd, L"Tooltip");
            
                TTSetFont(pTtm, 0, FALSE);
                break;
            }
            else 
            {
                LocalFree(pTtm);
                return -1;
            }
        }
        break;

    case WM_TIMER:  
        TTHandleTimer(pTtm, wParam);
        break;

        
    case WM_NCHITTEST:
        // we should not return HTTRANSPARENT here because then we don't receive the mouse events
        // and we cannot forward them down to our parent. but because of the backcompat we keep doing
        // it unless we are using comctl32 v5 or greater
        //
        // If we are inside TTWindowFromPoint, then respect transparency
        // even on v5 clients.
        //
        // Otherwise, your tooltips flicker because the tip appears,
        // then WM_NCHITTEST says "not over the tool any more" (because
        // it's over the tooltip), so the bubble pops, and then the tip
        // reappears, etc.
        if (pTtm && (pTtm->_ci.iVersion < 5 || pTtm->fInWindowFromPoint) &&
            pTtm->pCurTool && (pTtm->pCurTool->uFlags & TTF_TRANSPARENT))
        {
            return HTTRANSPARENT;
        } 
        goto DoDefault;
        
    case WM_MOUSEMOVE:
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);       

        // the cursor moved onto the tips window.
        if (!(pTtm->dwFlags & TRACKMODE) && pTtm->pCurTool && !(pTtm->pCurTool->uFlags & TTF_TRANSPARENT))
            PopBubble(pTtm);

        if ((pTtm->_ci.style & TTS_CLOSE))
        {
            if (PtInRect(&pTtm->rcClose, pt))
            {
                pTtm->iStateId = TTCS_HOT;
                InvalidateRect(pTtm->_ci.hwnd, &pTtm->rcClose, FALSE);
            }
            else if (pTtm->iStateId == TTCS_HOT)
            {
                pTtm->iStateId = TTCS_NORMAL;
                InvalidateRect(pTtm->_ci.hwnd, &pTtm->rcClose, FALSE);
            }
        }
        // fall through

    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
        {
            BOOL fForward = TRUE;
            // handle link clicking
            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);

            // Never forward if in the close button
            if (PtInRect(&pTtm->rcClose, pt))
                fForward = FALSE;

            if (uMsg == WM_LBUTTONDOWN)
            {
                if ((pTtm->_ci.style & TTS_CLOSE) && 
                    pTtm->iStateId == TTCS_HOT)
                {
                    pTtm->iStateId = TTCS_PRESSED;
                    InvalidateRect(pTtm->_ci.hwnd, &pTtm->rcClose, FALSE);
                }
                else
                {
                    // Don't forward if clicking on a link
                    if (S_OK == GetCurToolBestMarkup(pTtm)->OnButtonDown(pt))
                        fForward = FALSE;
                }
            }

            // Handle other actions
            if (fForward && pTtm->pCurTool && (pTtm->pCurTool->uFlags & TTF_TRANSPARENT))
            {            
                MapWindowPoints(pTtm->_ci.hwnd, pTtm->pCurTool->hwnd, &pt, 1);
                SendMessage(pTtm->pCurTool->hwnd, uMsg, wParam, MAKELPARAM(pt.x, pt.y));            
            }
        }
        break;

    case WM_LBUTTONUP:
        // handle link clicking
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);        
        if (pTtm->iStateId == TTCS_PRESSED)
        {
            pTtm->iStateId = TTCS_NORMAL;
            InvalidateRect(pTtm->_ci.hwnd, &pTtm->rcClose, FALSE);
            
        }

        if ((pTtm->_ci.style & TTS_CLOSE) &&
            PtInRect(&pTtm->rcClose, pt))
        {
            PopBubble(pTtm);
        }
        else
        {
            GetCurToolBestMarkup(pTtm)->OnButtonUp(pt);
        }
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        if (pTtm) 
        {
            if (!pTtm->fBkColorSet)
                pTtm->clrTipBk = g_clrInfoBk;
            if (!pTtm->fTextColorSet)
                pTtm->clrTipText = g_clrInfoText;
        }
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        if (pTtm->fMyFont)
            TTSetFont(pTtm, 0, FALSE);
        break;

    case WM_PAINT: 
        TTOnPaint(pTtm);
        break;

    case WM_SETFONT:
        TTSetFont(pTtm, (HFONT)wParam, (BOOL)lParam);
        return(TRUE);

    case WM_GETFONT:
        if (pTtm) 
           return((LRESULT)pTtm->hFont);
        break;

    case WM_NOTIFYFORMAT:
        if (lParam == NF_QUERY) 
        {
            return NFR_UNICODE;
        }
        else if (lParam == NF_REQUERY) 
        {
            for (int i = 0 ; i < pTtm->iNumTools; i++) 
            {
                pTool = &pTtm->tools[i];

                if (SendMessage(pTool->hwnd, WM_NOTIFYFORMAT, (WPARAM)hwnd, NF_QUERY) == NFR_UNICODE) 
                {
                    pTool->uFlags |= TTF_UNICODE;
                } 
                else 
                {
                    pTool->uFlags &= ~TTF_UNICODE;
                }
            }

            return CIHandleNotifyFormat(&pTtm->_ci, lParam);
        }
        return 0;

    case WM_ERASEBKGND:
        break;
        
    case WM_STYLECHANGED:
        if ((wParam == GWL_STYLE) && pTtm) 
        {
            DWORD dwNewStyle = ((LPSTYLESTRUCT)lParam)->styleNew;
            if (pTtm->_ci.style & TTS_BALLOON &&    // If the old style was a balloon,
                !(dwNewStyle & TTS_BALLOON))        // And the new style is not a balloon,
            {
                // Then we need to unset the region.
                SetWindowRgn(pTtm->_ci.hwnd, NULL, FALSE);
            }

            pTtm->_ci.style = ((LPSTYLESTRUCT)lParam)->styleNew;
        }
        break;

    case WM_DESTROY: 
        {
            if (pTtm->tools) 
            {
                // free the tools
                for (int i = 0; i < pTtm->iNumTools; i++) 
                {
                    TTBeforeFreeTool(pTtm, &pTtm->tools[i]);
                }
                LocalFree((HANDLE)pTtm->tools);
                pTtm->tools = NULL;
            }
        
            TTSetFont(pTtm, NOFONT, FALSE); // delete font if we made one.

            Str_Set(&pTtm->lpTipTitle, NULL);

            if (pTtm->himlTitleBitmaps)
                ImageList_Destroy(pTtm->himlTitleBitmaps);
        
            // Close theme
            if (pTtm->hTheme)
                CloseThemeData(pTtm->hTheme);

            // Release our compatibility markup
            if (pTtm->pMarkup)
            {
                pTtm->pMarkup->Release();
                pTtm->pMarkup = NULL;
            }

            pTtm->Release();
            SetWindowPtr(hwnd, 0, 0);
        }
        break;

    case WM_PRINTCLIENT:
        TTRender(pTtm, (HDC)wParam);
        break;

    case WM_GETOBJECT:
        if (lParam == OBJID_QUERYCLASSNAMEIDX)
            return MSAA_CLASSNAMEIDX_TOOLTIPS;
        goto DoDefault;

    case WM_THEMECHANGED:
        if (pTtm->hTheme)
            CloseThemeData(pTtm->hTheme);

        pTtm->hTheme = OpenThemeData(pTtm->_ci.hwnd, L"Tooltip");

        InvalidateRect(pTtm->_ci.hwnd, NULL, TRUE);
        break;

    default:
    {
        LRESULT lres;
        if (CCWndProc(&pTtm->_ci, uMsg, wParam, lParam, &lres))
            return lres;
    }
DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

//
//  Purpose:    Thunks a TOOLINFOA structure to a TOOLINFOW
//              structure.
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//

BOOL ThunkToolInfoAtoW(LPTOOLINFOA lpTiA, LPTOOLINFOW lpTiW, BOOL bThunkText, UINT uiCodePage)
{
    lpTiW->uFlags      = lpTiA->uFlags;
    lpTiW->hwnd        = lpTiA->hwnd;
    lpTiW->uId         = lpTiA->uId;

    lpTiW->rect.left   = lpTiA->rect.left;
    lpTiW->rect.top    = lpTiA->rect.top;
    lpTiW->rect.right  = lpTiA->rect.right;
    lpTiW->rect.bottom = lpTiA->rect.bottom;

    lpTiW->hinst       = lpTiA->hinst;

    //
    //  Set the size properly and optionally copy the new fields if the
    //  structure is large enough.
    //
    if (lpTiA->cbSize <= TTTOOLINFOA_V1_SIZE) 
    {
        lpTiW->cbSize  = TTTOOLINFOW_V1_SIZE;
    }
    else 
    {
        lpTiW->cbSize  = sizeof(TOOLINFOW);
        lpTiW->lParam  = lpTiA->lParam;
    }

    if (bThunkText) 
    {
        // Thunk the string to the new structure.
        // Special case LPSTR_TEXTCALLBACK.

        if (lpTiA->lpszText == LPSTR_TEXTCALLBACKA) 
        {
            lpTiW->lpszText = LPSTR_TEXTCALLBACKW;
        } 
        else if (!IS_INTRESOURCE(lpTiA->lpszText)) 
        {
            int iResult;
            DWORD dwBufSize = lstrlenA(lpTiA->lpszText) + 1;
            lpTiW->lpszText = (LPWSTR) LocalAlloc (LPTR, dwBufSize * sizeof(WCHAR));

            if (!lpTiW->lpszText) 
            {
                return FALSE;
            }

            iResult = MultiByteToWideChar(uiCodePage, 0, lpTiA->lpszText, -1,
                                           lpTiW->lpszText, dwBufSize);

            // If iResult is 0, and GetLastError returns an error code,
            // then MultiByteToWideCharfailed.

            if (!iResult) 
            {
                if (GetLastError()) 
                {
                    return FALSE;
                }
            }

            lpTiW->uFlags |= TTF_MEMALLOCED;

        }
        else 
        {
            lpTiW->lpszText = (LPWSTR)lpTiA->lpszText;
        }
    }
    return TRUE;
}

//
//  Purpose:    Thunks a TOOLINFOW structure to a TOOLINFOA
//              structure.
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//

BOOL ThunkToolInfoWtoA(LPTOOLINFOW lpTiW, LPTOOLINFOA lpTiA, UINT uiCodePage)
{
    int iResult = 1;

    lpTiA->uFlags      = lpTiW->uFlags;
    lpTiA->hwnd        = lpTiW->hwnd;
    lpTiA->uId         = lpTiW->uId;

    lpTiA->rect.left   = lpTiW->rect.left;
    lpTiA->rect.top    = lpTiW->rect.top;
    lpTiA->rect.right  = lpTiW->rect.right;
    lpTiA->rect.bottom = lpTiW->rect.bottom;

    lpTiA->hinst       = lpTiW->hinst;

    //
    //  Set the size properly and optionally copy the new fields if the
    //  structure is large enough.
    //
    if (lpTiW->cbSize <= TTTOOLINFOW_V1_SIZE) 
    {
        lpTiA->cbSize  = TTTOOLINFOA_V1_SIZE;
    }
    else
    {
        lpTiA->cbSize  = sizeof(TOOLINFOA);
        lpTiA->lParam  = lpTiA->lParam;
    }

    //
    // Thunk the string to the new structure.
    // Special case LPSTR_TEXTCALLBACK.
    //

    if (lpTiW->lpszText == LPSTR_TEXTCALLBACKW) 
    {
        lpTiA->lpszText = LPSTR_TEXTCALLBACKA;
    }
    else if (!IS_INTRESOURCE(lpTiW->lpszText)) 
    {
        // It is assumed that lpTiA->lpszText is already setup to
        // a valid buffer, and that buffer is 80 characters.
        // 80 characters is defined in the TOOLTIPTEXT structure.

        iResult = WideCharToMultiByte(uiCodePage, 0, lpTiW->lpszText, -1,
                                       lpTiA->lpszText, 80, NULL, NULL);
    }
    else 
    {
        lpTiA->lpszText = (LPSTR)lpTiW->lpszText;
    }

    //
    // If iResult is 0, and GetLastError returns an error code,
    // then WideCharToMultiByte failed.
    //

    if (!iResult) 
    {
        if (GetLastError()) 
        {
            return FALSE;
        }
    }

    return TRUE;
}


//*************************************************************
//
//  ThunkToolTipTextAtoW()
//
//  Purpose:    Thunks a TOOLTIPTEXTA structure to a TOOLTIPTEXTW
//              structure.
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//*************************************************************

BOOL ThunkToolTipTextAtoW (LPTOOLTIPTEXTA lpTttA, LPTOOLTIPTEXTW lpTttW, UINT uiCodePage)
{
    int iResult;


    if (!lpTttA || !lpTttW)
        return FALSE;

    //
    // Thunk the NMHDR structure.
    //
    lpTttW->hdr.hwndFrom = lpTttA->hdr.hwndFrom;
    lpTttW->hdr.idFrom   = lpTttA->hdr.idFrom;
    lpTttW->hdr.code     = TTN_NEEDTEXTW;

    lpTttW->hinst  = lpTttA->hinst;
    lpTttW->uFlags = lpTttA->uFlags;
    lpTttW->lParam = lpTttA->lParam;

    //
    // Thunk the string to the new structure.
    // Special case LPSTR_TEXTCALLBACK.
    //

    if (lpTttA->lpszText == LPSTR_TEXTCALLBACKA) 
    {
        lpTttW->lpszText = LPSTR_TEXTCALLBACKW;
    }
    else if (!IS_INTRESOURCE(lpTttA->lpszText)) 
    {
        //  Transfer the lpszText into the lpTttW...
        //
        //  First see if it fits into the buffer, and optimistically assume
        //  it will.
        //
        lpTttW->lpszText = lpTttW->szText;
        iResult = MultiByteToWideChar(uiCodePage, 0, lpTttA->lpszText, -1,
                                       lpTttW->szText, ARRAYSIZE(lpTttW->szText));
        if (!iResult) 
        {
            //
            //  Didn't fit into the small buffer; must alloc our own.
            //
            lpTttW->lpszText = ProduceWFromA(uiCodePage, lpTttA->lpszText);
            lpTttW->uFlags |= TTF_MEMALLOCED;
        }

    }
    else
    {
        lpTttW->lpszText = (LPWSTR)lpTttA->lpszText;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\unixstuff.cpp ===
#include "ctlspriv.h"
#include "unixstuff.h"

EXTERN_C void UnixPaintArrow(HDC hDC, BOOL bHoriz, BOOL bDown, int nXCenter, int nYCenter,
          int nWidth, int nHeight)
{
    HPEN hOldPen;
    HBRUSH hOldBrush;
    POINT pFigure[4];
    LOGBRUSH  hBrLog  = { BS_SOLID, GetSysColor( COLOR_BTNTEXT ), 0   };

    HBRUSH hBrush = CreateBrushIndirect( &hBrLog  );
    HPEN   hPen   = CreatePen( PS_SOLID, 1, GetSysColor( COLOR_BTNTEXT ) );

    if( hPen && hBrush )
    {
        hOldPen           = (HPEN)   SelectObject(hDC, hPen);
        hOldBrush         = (HBRUSH) SelectObject(hDC, hBrush);
    }
    else
    {
        hOldPen   = (HPEN)   SelectObject(hDC, GetStockObject( BLACK_PEN ) );
        hOldBrush = (HBRUSH) SelectObject(hDC, GetStockObject( BLACK_BRUSH ) );
    }

    if(bHoriz) {
       if (bDown) {
                pFigure[0].x = nXCenter - nWidth /2;
                pFigure[0].y = nYCenter - nHeight/2;
                pFigure[1].x = nXCenter - nWidth /2;
                pFigure[1].y = nYCenter + nHeight/2;
                pFigure[2].x = nXCenter + nWidth /2;
                pFigure[2].y = nYCenter;
        } else {
                pFigure[0].x = nXCenter - nWidth /2;
                pFigure[0].y = nYCenter;
                pFigure[1].x = nXCenter + nWidth /2;
                pFigure[1].y = nYCenter + nHeight/2;
                pFigure[2].x = nXCenter + nWidth /2;
                pFigure[2].y = nYCenter - nHeight/2;
        }
    }
    else {
       if (bDown) {
                pFigure[0].x = nXCenter - nWidth /2;
                pFigure[0].y = nYCenter - nHeight/2;
                pFigure[1].x = nXCenter + nWidth /2;
                pFigure[1].y = nYCenter - nHeight/2;
                pFigure[2].x = nXCenter;
                pFigure[2].y = nYCenter + nHeight/2;
        } else {
                pFigure[0].x = nXCenter;
                pFigure[0].y = nYCenter - nHeight/2;
                pFigure[1].x = nXCenter - nWidth /2;
                pFigure[1].y = nYCenter + nHeight/2;
                pFigure[2].x = nXCenter + nWidth /2;
                pFigure[2].y = nYCenter + nHeight/2;
        }

    }

    Polygon(hDC, pFigure, 3);

    SelectObject(hDC, hOldPen);
    SelectObject(hDC, hOldBrush);

    if( hPen   ) DeleteObject(hPen  );
    if( hBrush ) DeleteObject(hBrush);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\tvpaint.c ===
#include "ctlspriv.h"
#include "treeview.h"
#include "image.h"

extern void  TruncateString(char *sz, int cch);

void TV_GetBackgroundBrush(PTREE pTree, HDC hdc)
{
    if (pTree->clrBk == (COLORREF)-1) 
    {
        if (pTree->ci.style & WS_DISABLED)
            pTree->hbrBk = FORWARD_WM_CTLCOLORSTATIC(pTree->ci.hwndParent, hdc, pTree->ci.hwnd, SendMessage);
        else
            pTree->hbrBk = FORWARD_WM_CTLCOLOREDIT(pTree->ci.hwndParent, hdc, pTree->ci.hwnd, SendMessage);
    }
}

// ----------------------------------------------------------------------------
//
//  Draws a horizontal or vertical dotted line from the given (x,y) location
//  for the given length (c).
//
// ----------------------------------------------------------------------------

void TV_DrawDottedLine(HDC hdc, int x, int y, int c, BOOL fVert)
{
    while (c > 0)
    {
        PatBlt(hdc, x, y, 1, 1, PATCOPY);

        if (fVert)
            y += 2;
        else
            x += 2;
        c -= 2;
    }
}


// ----------------------------------------------------------------------------
//
//  Draws a plus or minus sign centered around the given (x,y) location and
//  extending out from that location the given distance (c).
//
// ----------------------------------------------------------------------------

// TV_DrawPlusMinus is theme aware
void TV_DrawPlusMinus(PTREE pTree, HDC hdc, int x, int y, int c, HBRUSH hbrSign, HBRUSH hbrBox, HBRUSH hbrBk, BOOL fPlus)
{
    HRESULT hr = E_FAIL;
    int n;
    int p = (c * 7) / 10;

    n = p * 2 + 1;

    if (pTree->hTheme)
    {
        RECT rc = { x - c, y - c, x + c + 1, y + c + 1 };
        hr = DrawThemeBackground(pTree->hTheme, hdc, TVP_GLYPH, fPlus ? GLPS_CLOSED : GLPS_OPENED, &rc, 0);
    }

    if (FAILED(hr))
    {
        SelectObject(hdc, hbrBk);
        PatBlt(hdc, x - c, y - c, 2*c, 2*c, PATCOPY);

        SelectObject(hdc, hbrSign);
    
        if (p >= 5)
        {
            PatBlt(hdc, x - p, y - 1, n, 3, PATCOPY);
            if (fPlus)
                PatBlt(hdc, x - 1, y - p, 3, n, PATCOPY);
        
            p--;
            n -= 2;
        }
    
        PatBlt(hdc, x - p, y, n, 1, PATCOPY);
        if (fPlus)
            PatBlt(hdc, x, y - p, 1, n, PATCOPY);
    
        n = c * 2 + 1;
    
        SelectObject(hdc, hbrBox);
    
        PatBlt(hdc, x - c, y - c, n, 1, PATCOPY);
        PatBlt(hdc, x - c, y - c, 1, n, PATCOPY);
        PatBlt(hdc, x - c, y + c, n, 1, PATCOPY);
        PatBlt(hdc, x + c, y - c, 1, n, PATCOPY);
    }
}


// ----------------------------------------------------------------------------
//
//  Create the bitmaps for the indent area of the tree as follows
//  if  fHasLines &&  fHasButtons --> 7 bitmaps
//  if  fHasLines && !fHasButtons --> 3 bitmaps
//  if !fHasLines &&  fHasButtons --> 2 bitmaps
//
//  sets hStartBmp, hBmp, hdcBits
//
//  If "has lines" then there are three basic bitmaps.
//
//      |       |       |
//      |       +---    +---
//      |       |
//
//  (The plan vertical line does not get buttons.)
//
//  Otherwise, there are no lines, so the basic bitmaps are blank.
//
//  If "has buttons", then the basic bitmaps are augmented with buttons.
//
//       [+]      [-]
//
//  And if you have "lines at root", you get
//
//      __
//
//
//  And if you have "lines at root" with "has buttons", then you also get
//
//      --[+]   --[-]
//
//  So, there are twelve image types.  Here they are, with the code names
//  written underneath.
//
//      |       |       |       |       |       |       |
//      |       +---    +---   [+]--   [+]--   [-]--   [-]--
//      |       |               |               |
//
//     "|"     "|-"    "L"     "|-+"   "L+"    "|--"   "L-"
//
//      ---    [+]--   [-]--   [+]     [-]
//
//     ".-"    ".-+"   ".--"   "+"     "-"
//
//      And the master table of which styles get which images.
//
//
//  LINES   BTNS    ROOT    |   |-  L   |-+ L+  |-- L-  .-  .-+ .-- +   -
//
//           x                                                      0   1
//    x                     0   1   2                   3
//    x                     0   1   2                   3
//    x      x              0   1   2   3   4   5   6
//    x              x      0   1   2                   3
//    x      x       x      0   1   2   3   4   5   6   7   8   9
//
// ----------------------------------------------------------------------------

void TV_DrawV(PTREE pTree, HDC hdc, int x, int y)         // "|"
{
    int xMid;
    HBRUSH hbrOld = SelectObject(hdc, pTree->hbrLine);

    if (pTree->hImageList)
        xMid = (pTree->cxImage - MAGIC_INDENT) / 2;
    else
        xMid = pTree->cxIndent / 2;

    TV_DrawDottedLine(hdc, x + xMid, y, pTree->cyItem, TRUE);
    SelectObject(hdc, hbrOld);
}

void TV_DrawT(PTREE pTree, HDC hdc, int x, int y)         // "|-"
{
    int xMid, yMid;
    HBRUSH hbrOld = SelectObject(hdc, pTree->hbrLine);
    if (pTree->hImageList)
        xMid = (pTree->cxImage - MAGIC_INDENT) / 2;
    else
        xMid = pTree->cxIndent / 2;

    yMid = ((pTree->cyItem / 2) + 1) & ~1;

    TV_DrawDottedLine(hdc, x + xMid, y, pTree->cyItem, TRUE);
    TV_DrawDottedLine(hdc, x + xMid, y + yMid, pTree->cxIndent - xMid, FALSE);
    SelectObject(hdc, hbrOld);
}

void TV_DrawL(PTREE pTree, HDC hdc, int x, int y, BOOL bRoot)         // "L"
{
    int xMid, yMid;
    HBRUSH hbrOld = SelectObject(hdc, pTree->hbrLine);
    if (pTree->hImageList)
        xMid = (pTree->cxImage - MAGIC_INDENT) / 2;
    else
        xMid = pTree->cxIndent / 2;

    yMid = ((pTree->cyItem / 2) + 1) & ~1;

    if (!bRoot)
    {
        TV_DrawDottedLine(hdc, x + xMid, y, yMid, TRUE);
    } else
    {
        TV_DrawDottedLine(hdc, x + xMid, y + yMid, yMid, TRUE);
    }
    TV_DrawDottedLine(hdc, x + xMid, y + yMid, pTree->cxIndent - xMid, FALSE);
    SelectObject(hdc, hbrOld);
}

void TV_DrawPML(PTREE pTree, HDC hdc, int x, int y, BOOL fPlus, BOOL fL, BOOL bRoot)
{
    int xMid, yMid, c;
    HBRUSH hbrOld = SelectObject(hdc, pTree->hbrLine);
    if (pTree->hImageList)
        xMid = (pTree->cxImage - MAGIC_INDENT) / 2;
    else
        xMid = pTree->cxIndent / 2;

    yMid = ((pTree->cyItem / 2) + 1) & ~1;
    c = (min(xMid, yMid)) / 2;
    if (fL)
    {
        if (!bRoot)
        {
            TV_DrawDottedLine(hdc, x + xMid, y, yMid - c, TRUE);
        } else
        {
            TV_DrawDottedLine(hdc, x + xMid, y + yMid + c, yMid - c, TRUE);
        }

        TV_DrawDottedLine(hdc, x + xMid + c, y + yMid, pTree->cxIndent - xMid - c, FALSE);
    }
    else
    {
        TV_DrawDottedLine(hdc, x + xMid, y, yMid - c, TRUE);
        TV_DrawDottedLine(hdc, x + xMid + c, y + yMid, pTree->cxIndent - xMid - c, FALSE);
        TV_DrawDottedLine(hdc, x + xMid, y + yMid + c, yMid - c, TRUE);
    }
    TV_DrawPlusMinus(pTree, hdc, x + xMid, y + yMid, c, pTree->hbrText, pTree->hbrLine, pTree->hbrBk, fPlus);
    SelectObject(hdc, hbrOld);
}

void TV_DrawTP(PTREE pTree, HDC hdc, int x, int y)        // "|-+"
{
    TV_DrawPML(pTree, hdc, x, y, TRUE, FALSE, FALSE);
}

void TV_DrawLP(PTREE pTree, HDC hdc, int x, int y, BOOL bRoot)        // "L+"
{
    TV_DrawPML(pTree, hdc, x, y, TRUE, TRUE, bRoot);
}
void TV_DrawTM(PTREE pTree, HDC hdc, int x, int y)        // "|--"
{
    TV_DrawPML(pTree, hdc, x, y, FALSE, FALSE, FALSE);
}
void TV_DrawLM(PTREE pTree, HDC hdc, int x, int y, BOOL bRoot)        // "L-"
{
    TV_DrawPML(pTree, hdc, x, y, FALSE, TRUE, bRoot);
}

void TV_DrawH(PTREE pTree, HDC hdc, int x, int y)         // ".-"
{
    int xMid, yMid;
    HBRUSH hbrOld = SelectObject(hdc, pTree->hbrLine);
    if (pTree->hImageList)
        xMid = (pTree->cxImage - MAGIC_INDENT) / 2;
    else
        xMid = pTree->cxIndent / 2;

    yMid = ((pTree->cyItem / 2) + 1) & ~1;
    TV_DrawDottedLine(hdc, x + xMid, y + yMid, pTree->cxIndent - xMid, FALSE);
    SelectObject(hdc, hbrOld);
}

void TV_DrawHP(PTREE pTree, HDC hdc, int x, int y)        // ".-+"
{
    int xMid, yMid, c;
    HBRUSH hbrOld = SelectObject(hdc, pTree->hbrLine);
    if (pTree->hImageList)
        xMid = (pTree->cxImage - MAGIC_INDENT) / 2;
    else
        xMid = pTree->cxIndent / 2;

    yMid = ((pTree->cyItem / 2) + 1) & ~1;
    c = (min(xMid, yMid)) / 2;
    TV_DrawDottedLine(hdc, x + c, y + yMid, pTree->cxIndent - xMid - c, FALSE);
    TV_DrawPlusMinus(pTree, hdc, x + xMid, y + yMid, c, pTree->hbrText, pTree->hbrLine, pTree->hbrBk, TRUE);
    SelectObject(hdc, hbrOld);
}

void TV_DrawHM(PTREE pTree, HDC hdc, int x, int y)        // ".--"
{
    int xMid, yMid, c;
    HBRUSH hbrOld = SelectObject(hdc, pTree->hbrLine);
    if (pTree->hImageList)
        xMid = (pTree->cxImage - MAGIC_INDENT) / 2;
    else
        xMid = pTree->cxIndent / 2;

    yMid = ((pTree->cyItem / 2) + 1) & ~1;
    c = (min(xMid, yMid)) / 2;

    TV_DrawDottedLine(hdc, x + c, y + yMid, pTree->cxIndent - xMid - c, FALSE);
    TV_DrawPlusMinus(pTree, hdc, x + xMid, y + yMid, c, pTree->hbrText, pTree->hbrLine, pTree->hbrBk, FALSE);
    SelectObject(hdc, hbrOld);
}

void TV_DrawP(PTREE pTree, HDC hdc, int x, int y)         // "+"
{
    int xMid, yMid, c;
    if (pTree->hImageList)
        xMid = (pTree->cxImage - MAGIC_INDENT) / 2;
    else
        xMid = pTree->cxIndent / 2;

    yMid = ((pTree->cyItem / 2) + 1) & ~1;
    c = (min(xMid, yMid)) / 2;

    TV_DrawPlusMinus(pTree, hdc, x + xMid, y + yMid, c, pTree->hbrText, pTree->hbrLine, pTree->hbrBk, TRUE);
}

void TV_DrawM(PTREE pTree, HDC hdc, int x, int y)         // "-"
{
    int xMid, yMid, c;
    if (pTree->hImageList)
        xMid = (pTree->cxImage - MAGIC_INDENT) / 2;
    else
        xMid = pTree->cxIndent / 2;

    yMid = ((pTree->cyItem / 2) + 1) & ~1;
    c = (min(xMid, yMid)) / 2;

    TV_DrawPlusMinus(pTree, hdc, x + xMid, y + yMid, c, pTree->hbrText, pTree->hbrLine, pTree->hbrBk, FALSE);
}

void TV_DrawState2(PTREE pTree, int iState, HDC hdc, int x, int y, BOOL bRoot)
{
    switch (iState)
    {
    case 0:
        if (pTree->ci.style & TVS_HASLINES)
        {
            TV_DrawV(pTree, hdc, x, y);
        }
        else
        {
            TV_DrawP(pTree, hdc, x, y);
        }
        break;
    case 1:
        if (pTree->ci.style & TVS_HASLINES)
        {
            TV_DrawT(pTree, hdc, x, y);
        }
        else
        {
            TV_DrawM(pTree, hdc, x, y);
        }

        break;
    case 2:
            TV_DrawL(pTree, hdc, x, y, bRoot);
        break;
    case 3:
        if (!(pTree->ci.style & TVS_HASBUTTONS))
        {
            TV_DrawH(pTree, hdc, x, y);
        }
        else
        {
            TV_DrawTP(pTree, hdc, x, y);

        }
        break;
    case 4:
        TV_DrawLP(pTree, hdc, x, y, bRoot);
        break;
    case 5:
        TV_DrawTM(pTree, hdc, x, y);
        break;
    case 6:
        TV_DrawLM(pTree, hdc, x, y, bRoot);
        break;
    case 7:
        TV_DrawH(pTree, hdc, x, y);
        break;
    case 8:
        TV_DrawHP(pTree, hdc, x, y);
        break;
    case 9:
        TV_DrawHM(pTree, hdc, x, y);
        break;
    }
}

void TV_DrawState(PTREE pTree, int iState, HDC hdc, int x, int y)
{
    TV_DrawState2(pTree, iState, hdc, x, y, FALSE);
}

// TV_CreateIndentBmps is theme aware
void TV_CreateIndentBmps(PTREE pTree)
{
    if (pTree->fRedraw)
        InvalidateRect(pTree->ci.hwnd, NULL, TRUE);

    return;
}


// ----------------------------------------------------------------------------
//
//  fills in a TVITEM structure based by coying data from the item or
//  by calling the callback to get it.
//
//  in:
//	hItem	item to get TVITEM struct for
//	mask	which bits of the TVITEM struct you want (TVIF_ flags)
//  out:
//	lpItem	TVITEM filled in
//
// ----------------------------------------------------------------------------

void TV_GetItem(PTREE pTree, HTREEITEM hItem, UINT mask, LPTVITEMEX lpItem)
{
    TV_DISPINFO nm;
    
    if (!hItem || !lpItem)
        return;
    
    DBG_ValidateTreeItem(hItem, FALSE);

    nm.item.mask = 0;
    
    // We need to check the mask to see if lpItem->pszText is valid
    // And even then, it might not be, so be paranoid
    if ((mask & TVIF_TEXT) && lpItem->pszText && lpItem->cchTextMax)
    {
        if (hItem->lpstr == LPSTR_TEXTCALLBACK)
        {
            nm.item.mask |= TVIF_TEXT;
            // caller had to fill in pszText and cchTextMax with valid data
            nm.item.pszText = lpItem->pszText;
            nm.item.cchTextMax = lpItem->cchTextMax;
            nm.item.pszText[0] = 0;
#ifdef DEBUG
            pTree->fInTextCallback = TRUE;
#endif
        }
        else
        {
            ASSERT(hItem->lpstr);
            // we could do this but this is dangerous (when responding
            // to TVM_GETITEM we would be giving the app a pointer to our data)
            // lpItem->pszText = hItem->lpstr;
            lstrcpyn(lpItem->pszText, hItem->lpstr, lpItem->cchTextMax);
        }

    }
    
    if (mask & TVIF_IMAGE)
    {
        if (hItem->iImage == (WORD)I_IMAGECALLBACK)
            nm.item.mask |= TVIF_IMAGE;
        else
            lpItem->iImage = hItem->iImage;
    }
    
    if (mask & TVIF_SELECTEDIMAGE)
    {
        if (hItem->iSelectedImage == (WORD)I_IMAGECALLBACK)
            nm.item.mask |= TVIF_SELECTEDIMAGE;
        else
            lpItem->iSelectedImage = hItem->iSelectedImage;
    }
    
    if (mask & TVIF_INTEGRAL)
    {
        lpItem->iIntegral = hItem->iIntegral;
    }
    
    if (mask & TVIF_CHILDREN)
    {
        switch (hItem->fKids) 
        {
        case KIDS_COMPUTE:
            lpItem->cChildren = hItem->hKids ? 1 : 0;// the actual count doesn't matter
            break;
            
        case KIDS_FORCE_YES:
            lpItem->cChildren = 1;// the actual count doesn't matter
            break;
            
        case KIDS_FORCE_NO:
            lpItem->cChildren = 0;
            break;
            
        case KIDS_CALLBACK:
            nm.item.mask |= TVIF_CHILDREN;
            break;
        }
    }

    // copy out constant parameters (and prepare for callback)
    // IE4 and IE5.0 did this unconditionally
    lpItem->state = nm.item.state = hItem->state;

    //
    //  NOTICE!  We do not set TVIF_STATE nm.item.mask and we do not
    //  check for TVIF_STATE in the "any items need to be filled in
    //  by callback?" test a few lines below.  This is necessary for
    //  backwards compat.  IE5 and earlier did not call the app back
    //  if the only thing you asked for was TVIF_STATE.  You can't
    //  change this behavior unless you guard it with a version check, or
    //  apps will break.  (They'll get callbacks when they didn't used to.)
    //  Besides, nobody knows that they can customize the state, so it's
    //  not like we're missing out on anything.
    //

    lpItem->lParam = nm.item.lParam = hItem->lParam;
    
    // any items need to be filled in by callback?
    if (nm.item.mask & (TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN))
    {
        nm.item.hItem = hItem;
        
        CCSendNotify(&pTree->ci, TVN_GETDISPINFO, &nm.hdr);
#ifdef DEBUG
        pTree->fInTextCallback = FALSE;
#endif

        // copy out things that may have been filled in on the callback
        if (nm.item.mask & TVIF_CHILDREN)
            lpItem->cChildren = nm.item.cChildren;
        if (nm.item.mask & TVIF_IMAGE)
            lpItem->iImage = nm.item.iImage;
        if (nm.item.mask & TVIF_SELECTEDIMAGE)
            lpItem->iSelectedImage = nm.item.iSelectedImage;
        // callback may have redirected pszText to point into its own buffer
        if (nm.item.mask & TVIF_TEXT)
            lpItem->pszText = CCReturnDispInfoText(nm.item.pszText, lpItem->pszText, lpItem->cchTextMax);
        if (nm.item.mask & TVIF_STATE)
        {
            lpItem->state = (nm.item.state & nm.item.stateMask) | (lpItem->state & ~nm.item.stateMask);
            if ((lpItem->state & TVIS_BOLD) && !pTree->hFontBold)
                TV_CreateBoldFont(pTree);
        }
        
        
        if (nm.item.mask & TVIF_DI_SETITEM)
        {
            if (nm.item.mask & TVIF_TEXT)
                if (nm.item.pszText)
                {
                    Str_Set(&hItem->lpstr, nm.item.pszText);
                }
                if (nm.item.mask & TVIF_STATE)
                {
                    // if the bold bit changed, then the width changed
                    if ((hItem->state ^ lpItem->state) & TVIS_BOLD)
                        hItem->iWidth = 0;
                    hItem->state = (WORD) lpItem->state;
                }
                if (nm.item.mask & TVIF_IMAGE)
                    hItem->iImage = (WORD) lpItem->iImage;
                if (nm.item.mask & TVIF_SELECTEDIMAGE)
                    hItem->iSelectedImage = (WORD) lpItem->iSelectedImage;
                if (nm.item.mask & TVIF_CHILDREN)
                {
                    switch(nm.item.cChildren)
                    {
                    case I_CHILDRENCALLBACK:
                        hItem->fKids = KIDS_CALLBACK;
                        break;

                    case I_CHILDRENAUTO:
                        hItem->fKids = KIDS_COMPUTE;
                        break;

                    case 0:
                        hItem->fKids = KIDS_FORCE_NO;
                        break;
                        
                    default:
                        hItem->fKids = KIDS_FORCE_YES;
                        break;
                    }
                    
                }
        }
    }
}


// ----------------------------------------------------------------------------
//
//  Draws the given item starting at the given (x,y) and extending down and to
//  the right.
//
// ----------------------------------------------------------------------------

BOOL TV_ShouldItemDrawBlue(PTREE pTree, TVITEMEX *ti, UINT flags) 
{
    return  ( (ti->state & TVIS_DROPHILITED) ||
        (!pTree->hDropTarget && 
        !(flags & TVDI_GRAYCTL) &&
        (ti->state & TVIS_SELECTED) &&
        pTree->fFocus));
}

#define TV_ShouldItemDrawDisabled(pTree, pti, flags) (flags & TVDI_GRAYCTL)

//
//  Caution:  Depending on the user's color scheme, a Gray item may
//  end up looking Blue if Gray would otherwise be invisible.  So make
//  sure that there are other cues that the user can use to tell whether
//  the item is "Really Blue" or "Gray masquerading as Blue".
//
//  For example, you might get both is if the treeview is
//  participating in drag/drop while it is not the active window,
//  because the selected item gets "Gray masquerading as Blue" and
//  the drop target gets "Really Blue".  But we special-case that
//  and turn off the selection while we are worrying about drag/drop,
//  so there is no confusion after all.
//
BOOL TV_ShouldItemDrawGray(PTREE pTree, TVITEMEX *pti, UINT flags) 
{
    return  ((flags & TVDI_GRAYCTL) ||
        (!pTree->hDropTarget && 
        ((pti->state & TVIS_SELECTED) &&
        (!pTree->fFocus && (pTree->ci.style & TVS_SHOWSELALWAYS)) )));
}

//
//  Draw a descender line for the item.  It is the caller's job to
//  draw the appropriate glyph at level 0.
//
void
TV_DrawDescender(PTREE pTree, HDC hdc, int x, int y, HTREEITEM hItem)
{
    int i;
    for (i = 1; i < hItem->iIntegral; i++)
    {
        BitBlt(hdc, x, y + i * pTree->cyItem, pTree->cxIndent, pTree->cyItem, pTree->hdcBits, 0, 0, SRCCOPY);
    }
}

//
//  Erase any previous descender line for the item.
//
void
TV_EraseDescender(PTREE pTree, HDC hdc, int x, int y, HTREEITEM hItem)
{
    RECT rc;
    rc.left = x;
    rc.right = x + pTree->cxIndent;
    rc.top = y + pTree->cyItem;
    rc.bottom = y + hItem->iIntegral * pTree->cyItem;
    FillRect(hdc, &rc, pTree->hbrBk);
}

//
//  Draw (or erase) descenders for siblings and children.
//
void TV_DrawKinDescender(PTREE pTree, HDC hdc, int x, int y, HTREEITEM hItem, UINT state)
{
    if (hItem->hNext)   // Connect to next sibling
        TV_DrawDescender(pTree, hdc, x, y, hItem);
    else
        TV_EraseDescender(pTree, hdc, x, y, hItem);

    // If any bonus images, then need to connect the image to the kids.
    if (pTree->himlState || pTree->hImageList) {
        if (state & (TVIS_EXPANDED | TVIS_EXPANDPARTIAL)) // Connect to expanded kids
            TV_DrawDescender(pTree, hdc, x + pTree->cxIndent, y, hItem);
        else
            TV_EraseDescender(pTree, hdc, x + pTree->cxIndent, y, hItem);
    }
}

// TV_DrawItem is theme aware
void TV_DrawItem(PTREE pTree, HTREEITEM hItem, HDC hdc, int x, int y, UINT flags)
{
    UINT cxIndent = pTree->cxIndent;
    COLORREF rgbOldBack = 0, rgbOldText;
    COLORREF clrBk = CLR_DEFAULT;
    RECT rc;
    int iBack, iText;
    HTREEITEM hItemSave = hItem;
    LPTSTR lpstr;
    int cch;
    UINT etoFlags = ETO_OPAQUE | ETO_CLIPPED;
    TVITEMEX ti;
    TCHAR szTemp[MAX_PATH];
    int iState = 0;
    HFONT hFont;                        //$BOLD
    DWORD dwRet;
    NMTVCUSTOMDRAW nmcd;
    BOOL fItemFocused = ((pTree->fFocus) && (hItem == pTree->hCaret));
    DWORD clrTextTemp, clrTextBkTemp;
    BOOL fSelectedIcon = FALSE;
    int iOldBkMode = GetBkMode(hdc);

    rc.top = y;
    rc.bottom = rc.top + (pTree->cyItem * hItem->iIntegral);
    rc.left = 0;
    rc.right = pTree->cxWnd;

    if (flags & TVDI_ERASE) 
    {
        // Opaque the whole item
        FillRect(hdc, &rc, pTree->hbrBk);
    }
    
    
    // make sure the callbacks don't invalidate this item
    pTree->hItemPainting = hItem;	
    
    ti.pszText = szTemp;
    ti.cchTextMax  = ARRAYSIZE(szTemp);
    ti.stateMask = TVIS_OVERLAYMASK | TVIS_CUT | TVIS_BOLD; //$BOLD
    TV_GetItem(pTree, hItem, TVIF_IMAGE | TVIF_STATE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM, &ti);
    
    pTree->hItemPainting = NULL;
    
    
    ////////////////
    // set up the HDC

    if (TV_ShouldItemDrawBlue(pTree,&ti,flags)) 
    {
        // selected 
        iBack = COLOR_HIGHLIGHT;
        iText = COLOR_HIGHLIGHTTEXT;

    } 
    else if (TV_ShouldItemDrawDisabled(pTree, &pti, flags))
    {
        iBack = COLOR_3DFACE;
        iText = COLOR_GRAYTEXT;

        SetBkMode(hdc, TRANSPARENT);
        etoFlags &= ~ ETO_OPAQUE;

    } 
    else if  (TV_ShouldItemDrawGray(pTree, &ti, flags))
    {
        // On some color schemes, the BTNFACE color equals the WINDOW color,
        // and our gray comes out invisible.  In such case, change from gray
        // to blue so you can see it at all.
        if (GetSysColor(COLOR_WINDOW) != GetSysColor(COLOR_BTNFACE))
        {
            iBack = COLOR_BTNFACE;
            iText = COLOR_BTNTEXT;
        }
        else
        {
            iBack = COLOR_HIGHLIGHT;
            iText = COLOR_HIGHLIGHTTEXT;
        }
    } 
    else 
    {
        // not selected
        iBack = COLOR_WINDOW;
        iText = COLOR_WINDOWTEXT;

        if (hItem == pTree->hHot)
        {
            iText = COLOR_HOTLIGHT;
        }
    }

    if (iBack == COLOR_WINDOW && (pTree->clrBk != (COLORREF)-1))
        nmcd.clrTextBk = clrTextBkTemp = pTree->clrBk;
    else
        nmcd.clrTextBk = clrTextBkTemp = GetSysColor(iBack);

    if (iText == COLOR_WINDOWTEXT && (pTree->clrText != (COLORREF)-1))
        nmcd.clrText = clrTextTemp = pTree->clrText;
    else
        nmcd.clrText = clrTextTemp = GetSysColor(iText);

    // if forcing black and transparent, do so.  dc's BkMode should
    // already be set to TRANSPARENT by caller
    if (flags & TVDI_TRANSTEXT)
    {
        nmcd.clrText = clrTextTemp = 0x000000;
        etoFlags = 0;			// don't opaque nothin'
    }

    rgbOldBack = SetBkColor(hdc, nmcd.clrTextBk);
    rgbOldText = SetTextColor(hdc, nmcd.clrText);
    
    
    if (pTree->ci.style & TVS_RTLREADING)
        etoFlags |= ETO_RTLREADING;
    
    // Figure out which font to use.    
    if (ti.state & TVIS_BOLD) 
    {         
        hFont = pTree->hFontBold;
        if (hItem == pTree->hHot) 
        {
            hFont = CCGetHotFont(pTree->hFontBold, &pTree->hFontBoldHot);
        }
    } 
    else 
    {                            
        hFont = pTree->hFont;
        if (hItem == pTree->hHot) 
        {
            hFont = CCGetHotFont(pTree->hFont, &pTree->hFontHot);
        }
    }                                   
    hFont = SelectObject(hdc, hFont);   
    // End HDC setup
    ////////////////
    
    
    // notify on custom draw then do it!
    nmcd.nmcd.hdc = hdc;
    nmcd.nmcd.dwItemSpec = (DWORD_PTR)hItem;
    nmcd.nmcd.uItemState = 0;
    nmcd.nmcd.rc = rc;
    if (flags & TVDI_NOTREE)
        nmcd.iLevel = 0;
    else 
        nmcd.iLevel = hItem->iLevel;
    
    if (ti.state & TVIS_SELECTED)
    {
        
        fSelectedIcon = TRUE;
        
        if (pTree->fFocus || (pTree->ci.style & TVS_SHOWSELALWAYS))
            nmcd.nmcd.uItemState |= CDIS_SELECTED;
    }
    if (fItemFocused)
        nmcd.nmcd.uItemState |= CDIS_FOCUS;

    if (hItem == pTree->hHot)
        nmcd.nmcd.uItemState |= CDIS_HOT;

    nmcd.nmcd.lItemlParam = ti.lParam;
    
    dwRet = CICustomDrawNotify(&pTree->ci, CDDS_ITEMPREPAINT, &nmcd.nmcd);
    if (dwRet & CDRF_SKIPDEFAULT) 
        return;
    
    fItemFocused = (nmcd.nmcd.uItemState & CDIS_FOCUS);
    if (nmcd.nmcd.uItemState & CDIS_SELECTED)
        ti.state |= TVIS_SELECTED;
    else
    {
        ti.state &= ~TVIS_SELECTED;
    }
    
    if (nmcd.clrTextBk != clrTextBkTemp)
        SetBkColor(hdc, nmcd.clrTextBk);
    
    if (nmcd.clrText != clrTextTemp)
        SetTextColor(hdc, nmcd.clrText);
    
    if (pTree->ci.style & TVS_FULLROWSELECT && 
         !(flags & TVDI_TRANSTEXT)) 
    {
        FillRectClr(hdc, &nmcd.nmcd.rc, GetBkColor(hdc));
        etoFlags |= ETO_OPAQUE;
        clrBk = CLR_NONE;
    }
    
    if (!(flags & TVDI_NOTREE)) 
    {
        if ((pTree->ci.style & (TVS_HASLINES | TVS_HASBUTTONS)) &&
            (pTree->ci.style & TVS_LINESATROOT))
            // Make room for the "plus" at the front of the tree
            x += cxIndent;
    }
    
    
    // deal with margin, etc.
    x += (pTree->cxBorder + (nmcd.iLevel * cxIndent));
    y += pTree->cyBorder;
    
    // draw image
    if ((!(flags & TVDI_NOTREE) && !(dwRet & TVCDRF_NOIMAGES)) || (flags & TVDI_FORCEIMAGE))
    {
        int dx, dy;     // to clip the images within the borders.
        COLORREF clrImage = CLR_HILIGHT;
        COLORREF clrBkImage = clrBk;

        if (flags & TVDI_NOBK)
        {
            clrBkImage = CLR_NONE;
        }


        if (pTree->himlState)
        {
            iState = TV_StateIndex(&ti);
            // go figure.  in the treeview, 0 for the state image index
            // means draw nothing... the 0th item is unused.
            // the listview is 0 based and uses the 0th item.  
            if (iState)
            {
                dx = min(pTree->cxState, pTree->cxMax - pTree->cxBorder - x);
                dy = min(pTree->cyState, pTree->cyItem - (2 * pTree->cyBorder));
                ImageList_DrawEx(pTree->himlState, iState, hdc, x, 
                    y + max(pTree->cyItem - pTree->cyState, 0), dx, dy, clrBk, CLR_DEFAULT, ILD_NORMAL | (CCDPIScale(pTree->ci)?ILD_SCALE:0));
                x += pTree->cxState;            
            }
        }
        
        if (pTree->hImageList) 
        {
            UINT fStyle = 0;
            int i = (fSelectedIcon) ? ti.iSelectedImage : ti.iImage;

            if (ti.state & TVIS_CUT)
            {
                fStyle |= ILD_BLEND50;
                clrImage = ImageList_GetBkColor(pTree->hImageList);
            }
            
            dx = min(pTree->cxImage - MAGIC_INDENT, pTree->cxMax - pTree->cxBorder - x);
            dy = min(pTree->cyImage, pTree->cyItem - (2 * pTree->cyBorder));

            // Draw image stretched (rather than centered) when ImageList allows for scaling
            ImageList_DrawEx(pTree->hImageList, i, hdc,
                x + (dx - pTree->cxNativeImage) / 2, y + (max(pTree->cyItem - pTree->cyImage, 0) / 2) + (dy - pTree->cyNativeImage) / 2, 
                pTree->cxNativeImage, pTree->cyNativeImage,
                clrBkImage, clrImage,
                fStyle | (ti.state & TVIS_OVERLAYMASK) | (CCDPIScale(pTree->ci)?ILD_SCALE:0));
        }
    }
    
    if (pTree->hImageList) 
    {
        // even if not drawing image, draw text in right place
        x += pTree->cxImage;
    }
    
    // draw text
    lpstr = ti.pszText;
    cch = lstrlen(lpstr);
    
    if (!hItem->iWidth || (hItem->lpstr == LPSTR_TEXTCALLBACK))
    {
        TV_ComputeItemWidth(pTree, hItem, hdc); //$BOLD
    }
    
    rc.left = x;
    rc.top = y + pTree->cyBorder;
    rc.right = min((x + hItem->iWidth),
                   (pTree->cxMax - pTree->cxBorder));
    rc.bottom-= pTree->cyBorder;
    
    // Draw the text, unless it's the one we are editing
    if (pTree->htiEdit != hItem || !IsWindow(pTree->hwndEdit) || !IsWindowVisible(pTree->hwndEdit))
    {
        ExtTextOut(hdc, x + g_cxLabelMargin, y + ((pTree->cyItem - pTree->cyText) / 2) + g_cyBorder,
            etoFlags, &rc, lpstr, cch, NULL);

        // Draw the focus rect, if appropriate.
        if (pTree->fFocus && (fItemFocused) && 
            !(pTree->ci.style & TVS_FULLROWSELECT) &&
            !(flags & (TVDI_TRANSTEXT | TVDI_GRAYCTL))&& 
            !(CCGetUIState(&(pTree->ci)) & UISF_HIDEFOCUS))
        {
            DrawFocusRect(hdc, &rc);
        }
    }
    
    SetBkColor(hdc, rgbOldBack);
    SetTextColor(hdc, rgbOldText);
    
    // Restore the original font.       //$BOLD
    SelectObject(hdc, hFont);           //$BOLD
    
    // Notice that we should have opaque'd the rest of the line above if no tree
    if (!(flags & TVDI_NOTREE))
    {
        int dx, dy;
        
        if (pTree->hImageList)
            x -= pTree->cxImage;
        
        if (iState)
            x -= pTree->cxState;
        
        if (pTree->ci.style & TVS_HASLINES)
        {
            int i;

            x -= cxIndent;
            if (nmcd.iLevel-- || (pTree->ci.style & TVS_LINESATROOT))
            {
                // Special case the first root
                if (nmcd.iLevel == -1 && hItem == hItem->hParent->hKids)
                {
                    if (hItem->hNext) 
                    {
                        i = 2;              // "L"
                        if (ti.cChildren && (pTree->ci.style & TVS_HASBUTTONS))
                        {
                            i += 2;         // "L+"
                            if ((ti.state & (TVIS_EXPANDED | TVIS_EXPANDPARTIAL)) == TVIS_EXPANDED)
                                i += 2;     // "L-"
                        }
                        
                        dx = min((int)cxIndent, pTree->cxMax - pTree->cxBorder - x);
                        dy = pTree->cyItem - (2 * pTree->cyBorder);

                        // Pass TRUE to draw the root ("L" upside down)
                        TV_DrawState2(pTree, i, hdc, x, y, TRUE);
                        i = -1;
                    }
                    else 
                    {
                        // first root no siblings
                        // if there's no other item, draw just the button if button mode,
                        if (pTree->ci.style & TVS_HASBUTTONS)
                        {
                            if (ti.cChildren)
                            {
                                // hasbuttons, has lines, lines at root
                                i = ((ti.state & (TVIS_EXPANDED | TVIS_EXPANDPARTIAL)) == TVIS_EXPANDED) ? 
                                    9 : 8;  // ".--" : ".-+"
                            } 
                            else
                            {
                                i = 7;      // ".-"
                            }
                        }
                        else
                        {
                            i = 3;          // ".-"
                        }
                    }
                }
                else
                {
                    i = (hItem->hNext) ? 1 : 2; // "|-" (rep) : "L"
                    if (ti.cChildren && (pTree->ci.style & TVS_HASBUTTONS))
                    {
                        i += 2;                 // "|-+" (rep) : "L+"
                        if ((ti.state & (TVIS_EXPANDED | TVIS_EXPANDPARTIAL)) == TVIS_EXPANDED)
                            i += 2;             // "|--" (rep) : "L-"
                    }
                }
                if (hItem->iIntegral > 1)
                    TV_DrawKinDescender(pTree, hdc, x, y, hItem, ti.state);

                if (i != -1)
                {
                    dx = min((int)cxIndent, pTree->cxMax - pTree->cxBorder - x);
                    dy = pTree->cyItem - (2 * pTree->cyBorder);
                    if ((dx > 0) && (dy > 0))
                        TV_DrawState(pTree, i, hdc, x, y);
                }
                
                while ((--nmcd.iLevel >= 0) || ((pTree->ci.style & TVS_LINESATROOT) && nmcd.iLevel >= -1))
                {
                    hItem = hItem->hParent;
                    x -= cxIndent;
                    if (hItem->hNext)
                    {
                        dx = min((int)cxIndent, (pTree->cxMax - pTree->cxBorder - x));
                        dy = min(pTree->cyItem, pTree->cyWnd - pTree->cyBorder - y);
                        if ((dx > 0) && (dy > 0))
                            TV_DrawState(pTree, 0, hdc, x, y);
                        TV_DrawDescender(pTree, hdc, x, y, hItemSave);
                    }
                }
            }
        }
        else
        {               // no lines
            if ((pTree->ci.style & TVS_HASBUTTONS) && (nmcd.iLevel || pTree->ci.style & TVS_LINESATROOT)
                && ti.cChildren)
            {
                int i = ((ti.state & (TVIS_EXPANDED | TVIS_EXPANDPARTIAL)) == TVIS_EXPANDED) ? 1 : 0;
                
                x -= cxIndent;
                dx = min((int)cxIndent, pTree->cxMax - pTree->cxBorder - x);
                dy = min(pTree->cyItem, pTree->cyWnd - pTree->cyBorder - y);
                if ((dx > 0) && (dy > 0))
                    TV_DrawState(pTree, i, hdc, x, y);
            }
        }
    }
    
    
    if (dwRet & CDRF_NOTIFYPOSTPAINT)
    {
        nmcd.nmcd.dwItemSpec = (DWORD_PTR)hItemSave;
        CICustomDrawNotify(&pTree->ci, CDDS_ITEMPOSTPAINT, &nmcd.nmcd);
    }


    SetBkMode(hdc, iOldBkMode);
}

#define INSERTMARKSIZE      6

BOOL TV_GetInsertMarkRect(PTREE pTree, LPRECT prc)
{
    ASSERT(pTree);

    if(pTree->htiInsert && TV_GetItemRect(pTree, pTree->htiInsert, prc, TRUE))
    {
        if (pTree->fInsertAfter)
            prc->top = prc->bottom;
        else
            prc->bottom = prc->top;
        
        prc->top -= INSERTMARKSIZE/2;
        prc->bottom += INSERTMARKSIZE/2 + 1;
        prc->right = pTree->cxWnd - INSERTMARKSIZE;      // should always go all the way to right with pad.
        prc->left -= pTree->cxImage;
        
        return TRUE;
    }
    return FALSE;
}

__inline COLORREF TV_GetInsertMarkColor(PTREE pTree)
{
    if (pTree->clrim == CLR_DEFAULT)
        return g_clrWindowText;
    else
        return pTree->clrim;
}

void TV_DrawTree(PTREE pTree, HDC hdc, BOOL fErase, LPRECT lprc)
{
    int x;
    int iStart, iCnt;
    UINT uFlags;
    RECT rc;
    NMCUSTOMDRAW nmcd;
    
    if (!pTree->fRedraw)
        return;

    if (pTree->ci.style & TVS_CHECKBOXES)
        if (!pTree->himlState)
            TV_InitCheckBoxes(pTree);
    
    x = -pTree->xPos;
    
    TV_GetBackgroundBrush(pTree, hdc);
    
    rc = *lprc;
    
    iStart = lprc->top / pTree->cyItem;

    if (pTree->cItems && pTree->hTop) 
    {
        ASSERT(ITEM_VISIBLE(pTree->hTop));

        iCnt = pTree->cShowing - pTree->hTop->iShownIndex;
    }
    else 
    {
        iCnt = 0;                   // Nothing to draw
    }

    nmcd.hdc = hdc;
    /// not implemented yet
    //if (ptb->ci.hwnd == GetFocus()) 
    //nmcd.uItemState = CDIS_FOCUS;
    //else 
    nmcd.uItemState = 0;
    nmcd.lItemlParam = 0;
    nmcd.rc = rc;
    pTree->ci.dwCustom = CICustomDrawNotify(&pTree->ci, CDDS_PREPAINT, &nmcd);
    if (!(pTree->ci.dwCustom & CDRF_SKIPDEFAULT)) 
    {
        
        if (iStart <= iCnt)
        {
            HTREEITEM   hItem;
            HFONT       hOldFont;
            RECT        rcT;
            int y = 0;
            
            for (hItem = pTree->hTop; hItem; ) 
            {
                if (iStart > hItem->iIntegral)
                {
                    iStart -= hItem->iIntegral;
                    y += hItem->iIntegral * pTree->cyItem;
                    hItem = TV_GetNextVisItem(hItem);
                } else
                    break;
            }
            
            hOldFont = pTree->hFont ? SelectObject(hdc, pTree->hFont) : NULL;
            
            // TVDI_* for all items
            uFlags = (pTree->ci.style & WS_DISABLED) ? TVDI_GRAYCTL : 0;
            if (fErase)
                uFlags |= TVDI_ERASE;

            // loop from the first visible item until either all visible items are
            // drawn or there are no more items to draw
            for ( ; hItem && y < lprc->bottom; hItem = TV_GetNextVisItem(hItem))
            {
                TV_DrawItem(pTree, hItem, hdc, x, y, uFlags);
                y += pTree->cyItem * hItem->iIntegral;
            }
            
            //
            // handle drawing the InsertMark next to this item.
            //
            if(TV_GetInsertMarkRect(pTree, &rcT))
                CCDrawInsertMark(hdc, &rcT, FALSE, TV_GetInsertMarkColor(pTree));

            
            if (hOldFont)
                SelectObject(hdc, hOldFont);
            
            rc.top = y;
        }
        
        if (fErase)
            // Opaque out everything we have not drawn explicitly
            FillRect(hdc, &rc, pTree->hbrBk);
        
        // notify parent afterwards if they want us to
        if (pTree->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) {
            CICustomDrawNotify(&pTree->ci, CDDS_POSTPAINT, &nmcd);
        }
    }

}


// ----------------------------------------------------------------------------
//
//  Set up for paint, call DrawTree, and clean up after paint.
//
// ----------------------------------------------------------------------------

void TV_Paint(PTREE pTree, HDC hdc)
{
    PAINTSTRUCT ps;
    
    if (hdc)
    {
        // hdc != 0 indicates a subclassed paint -- use the hdc passed in
        SetRect(&ps.rcPaint, 0, 0, pTree->cxWnd, pTree->cyWnd);
        TV_DrawTree(pTree, hdc, TRUE, &ps.rcPaint);
    }
    else
    {
        BeginPaint(pTree->ci.hwnd, &ps);
        TV_DrawTree(pTree, ps.hdc, ps.fErase, &ps.rcPaint);
        EndPaint(pTree->ci.hwnd, &ps);
    }
}

// ----------------------------------------------------------------------------
// Create an imagelist to be used for dragging.
//
// 1) create mask and image bitmap matching the select bounds size
// 2) draw the text to both bitmaps (in black for now)
// 3) create an imagelist with these bitmaps
// 4) make a dithered copy of the image onto the new imagelist
// ----------------------------------------------------------------------------

HIMAGELIST TV_CreateDragImage(PTREE pTree, HTREEITEM hItem)
{
    HDC hdcMem = NULL;
    HBITMAP hbmImage = NULL;
    HBITMAP hbmMask = NULL;
    HBITMAP hbmOld;
    HIMAGELIST himl = NULL;
    BOOL bMirroredWnd = (pTree->ci.dwExStyle&RTL_MIRRORED_WINDOW);
    int dx, dy;
    int iSrc;

    TVITEMEX ti;

    if (!pTree->hImageList)
        return NULL;

    if (hItem == NULL)
        hItem = pTree->htiDrag;

    if (hItem == NULL)
        return NULL;

    
    dx = hItem->iWidth + pTree->cxImage;
    dy = pTree->cyItem;
    
    if (!(hdcMem = CreateCompatibleDC(NULL)))
        goto CDI_Exit;
    if (!(hbmImage = CreateColorBitmap(dx, dy)))
        goto CDI_Exit;
    if (!(hbmMask = CreateMonoBitmap(dx, dy)))
        goto CDI_Exit;
    
    //
    // Mirror the memory DC so that the transition from
    // mirrored(memDC)->non-mirrored(imagelist DCs)->mirrored(screenDC)
    // is consistent. [samera]
    //
    if (bMirroredWnd) {
        SET_DC_RTL_MIRRORED(hdcMem);
    }

    // prepare for drawing the item
    if (pTree->hFont)
        SelectObject(hdcMem, pTree->hFont);
    SetBkMode(hdcMem, TRANSPARENT);
    
    /*
    ** draw the text to both bitmaps
    */
    hbmOld = SelectObject(hdcMem, hbmImage);
    // fill image with black for transparency
    PatBlt(hdcMem, 0, 0, dx, dy, BLACKNESS);
    TV_DrawItem(pTree, hItem, hdcMem, 0, 0,
        TVDI_NOIMAGE | TVDI_NOTREE | TVDI_TRANSTEXT);

    //
    // If the header is RTL mirrored, then
    // mirror the Memory DC, so that when copying back
    // we don't get any image-flipping. [samera]
    //
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmImage);

    SelectObject(hdcMem, hbmMask);
    // fill mask with white for transparency
    PatBlt(hdcMem, 0, 0, dx, dy, WHITENESS);
    TV_DrawItem(pTree, hItem, hdcMem, 0, 0,
        TVDI_NOIMAGE | TVDI_NOTREE | TVDI_TRANSTEXT);
    
    //
    // If the header is RTL mirrored, then
    // mirror the Memory DC, so that when copying back
    // we don't get any image-flipping. [samera]
    //
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmMask);

    // unselect objects that we used
    SelectObject(hdcMem, hbmOld);
    SelectObject(hdcMem, g_hfontSystem);
    
    /*
    ** make an image list that for now only has the text
    */
    if (!(himl = ImageList_Create(dx, dy, ILC_MASK, 1, 0)))
        goto CDI_Exit;
    ImageList_SetBkColor(himl, CLR_NONE);
    ImageList_Add(himl, hbmImage, hbmMask);
    
    /*
    ** make a dithered copy of the image part onto our bitmaps
    ** (need both bitmap and mask to be dithered)
    */
    TV_GetItem(pTree, hItem, TVIF_IMAGE, &ti);
    iSrc = ti.iImage;
    
    ImageList_CopyDitherImage(himl, 0, 0, (pTree->cyItem - pTree->cyImage) / 2,
        pTree->hImageList, iSrc, ((pTree->ci.dwExStyle & dwExStyleRTLMirrorWnd) ? ILD_MIRROR : 0L) | (hItem->state & TVIS_OVERLAYMASK));

CDI_Exit:
    if (hdcMem)
        DeleteObject(hdcMem);
    if (hbmImage)
        DeleteObject(hbmImage);
    if (hbmMask)
        DeleteObject(hbmMask);
    
    return himl;
}

#define COLORKEY RGB(0xF4, 0x0, 0x0)

LRESULT TV_GenerateDragImage(PTREE pTree, SHDRAGIMAGE* pshdi)
{
    LRESULT lRet = 0;
    HBITMAP hbmpOld = NULL;
    HTREEITEM hItem = pTree->htiDrag;
    RECT rc;
    HDC  hdcDragImage;

    if (hItem == NULL)
        return FALSE;

    hdcDragImage = CreateCompatibleDC(NULL);

    if (!hdcDragImage)
        return 0;

    // After this rc contains the bounds of all the items in Client Coordinates.
    //
    // Mirror the the DC, if the listview is mirrored.
    //
    if (pTree->ci.dwExStyle & RTL_MIRRORED_WINDOW)
    {
        SET_DC_RTL_MIRRORED(hdcDragImage);
    }

    TV_GetItemRect(pTree, hItem, &rc, TRUE);

    // Subtract off the image...
    rc.left -= pTree->cxImage;

    pshdi->sizeDragImage.cx = RECTWIDTH(rc);
    pshdi->sizeDragImage.cy = RECTHEIGHT(rc);
    pshdi->hbmpDragImage = CreateBitmap( pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy,
        GetDeviceCaps(hdcDragImage, PLANES), GetDeviceCaps(hdcDragImage, BITSPIXEL),
        NULL);

    if (pshdi->hbmpDragImage)
    {
        COLORREF clrBkSave;
        RECT  rcImage = {0, 0, pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy};

        hbmpOld = SelectObject(hdcDragImage, pshdi->hbmpDragImage);

        pshdi->crColorKey = COLORKEY;
        FillRectClr(hdcDragImage, &rcImage, pshdi->crColorKey);

        // Calculate the offset... The cursor should be in the bitmap rect.

        if (pTree->ci.dwExStyle & RTL_MIRRORED_WINDOW)
            pshdi->ptOffset.x = rc.right - pTree->ptCapture.x;
        else
            pshdi->ptOffset.x = pTree->ptCapture.x - rc.left;

        pshdi->ptOffset.y = pTree->ptCapture.y - rc.top;

        clrBkSave = pTree->clrBk;

        pTree->clrBk = COLORKEY;

        TV_DrawItem(pTree, hItem, hdcDragImage, 0, 0,
            TVDI_NOTREE | TVDI_TRANSTEXT | TVDI_FORCEIMAGE | TVDI_NOBK);

        pTree->clrBk = clrBkSave;

        SelectObject(hdcDragImage, hbmpOld);
        DeleteDC(hdcDragImage);

        // We're passing back the created HBMP.
        return 1;
    }


    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\tvmem.c ===
#include "ctlspriv.h"
#include "treeview.h"
#if defined(MAINWIN)
#include <mainwin.h>
#endif

void TV_ScrollItems(PTREE pTree, int nItems, int iTopShownIndex, BOOL fDown);


// in:
//      hItem   item to delete
//      flags   controls how/what to delete
//              TVDI_NORMAL             delete this node and all children
//              TVDI_NONOTIFY           don't send notify messages
//              TVDI_CHILDRENONLY       just delete the kids (not the item)

void TV_DeleteItemRecurse(PTREE pTree, TREEITEM * hItem, UINT flags)
{
    TREEITEM *hKid;
    TREEITEM *hNext;
    TREEITEM *hParent;
    int i;

    DBG_ValidateTreeItem(hItem, 0);

    //
    // We do this from DeleteItemRecurse(), kind of like how USER sends
    // Destroy notifications from its FreeWindow() code, so that we get
    // deletes for parent and children both.
    //
    NotifyWinEvent(EVENT_OBJECT_DESTROY, pTree->ci.hwnd, OBJID_CLIENT,
        TV_GetAccId(hItem));

    //
    //  While the item is still valid, clean up if it's the insertion point.
    //  The item needs to be valid because we're going to call other
    //  functions that validate their parameters...
    //
    if (hItem == pTree->htiInsert)
    {
        TV_SetInsertMark(pTree, NULL, FALSE);
        ASSERT(pTree->htiInsert == NULL);
    }

    // remove all kids (and their kids)
    for (hKid = hItem->hKids; hKid; hKid = hNext) {
        hNext = hKid->hNext;

        // recurse on each child
        TV_DeleteItemRecurse(pTree, hKid, flags & ~TVDI_CHILDRENONLY);
    }

    if ((flags & TVDI_CHILDRENONLY) || !hItem->hParent)
        return;

    if (!(flags & TVDI_NONOTIFY))
    {
        NM_TREEVIEW nm;
        // Let the app clean up after itself
        nm.itemOld.hItem = hItem;
        nm.itemOld.lParam = hItem->lParam;
        nm.itemNew.mask = 0;
        nm.itemOld.mask = (TVIF_HANDLE | TVIF_PARAM);
        CCSendNotify(&pTree->ci, TVN_DELETEITEM, &nm.hdr);
    }

    //
    // If anybody has a watch on our item, let him know that it's gone.
    //
    i = DPA_GetPtrCount(pTree->hdpaWatch);
    while (--i >= 0)
    {
        PTVWATCHEDITEM pwi = DPA_FastGetPtr(pTree->hdpaWatch, i);
        ASSERT(pwi);
        if (pwi->hti == hItem) {
            pwi->hti = hItem->hNext;
            pwi->fStale = TRUE;
        }
    }

    hParent = hItem->hParent;
    ASSERT(hParent);

    // unlink ourselves from the parent child chain

    if (hParent->hKids == hItem) {
        hParent->hKids = hItem->hNext;
        hKid = NULL; 
    } else {
        // not the first child, find our previous item (linear search!)
        hKid = TV_GetNextItem(pTree, hItem, TVGN_PREVIOUS);
        ASSERT(hKid);
        hKid->hNext = hItem->hNext;
    }

    pTree->cItems--;

    TV_ScrollBarsAfterRemove(pTree, hItem);

    // reset tooltip after unlink from the parent child chain
    if (pTree->hToolTip == hItem)
        TV_SetToolTipTarget(pTree, NULL);

    Str_Set(&hItem->lpstr, NULL);

    TV_MarkAsDead(hItem);

    // be careful from here down.  hItem is unlinked but
    // still has some valid fields

    // Check to see if the user has deleted one of the
    // special items that is stored in the main tree structure.
    if (hItem == pTree->htiEdit)
        pTree->htiEdit = NULL;

    if (hItem == pTree->hDropTarget)
        pTree->hDropTarget = NULL;

    if (hItem == pTree->hOldDrop)
        pTree->hOldDrop = NULL;

    if (hItem == pTree->hHot )
        pTree->hHot = NULL;

    if (hItem == pTree->htiSearch )
        pTree->htiSearch = NULL;

    // if the caret escaped the collapsed area and landed on us, push it away
    if (pTree->hCaret == hItem) {
        HTREEITEM hTemp;
        if (hItem->hNext)
            hTemp = hItem->hNext;
        else {
            hTemp = VISIBLE_PARENT(hItem);
            if (!hTemp) 
                hTemp = hKid;  // set above when we unlinked from the previous item
        }
        // Reset the caret to NULL as to not try to reference our
        // invalidated item.
        pTree->hCaret = NULL;
        TV_SelectItem(pTree, TVGN_CARET, hTemp, (flags & TVDI_NOSELCHANGE) ? 0 : TVSIFI_NOTIFY, 0);
        ASSERT(pTree->hCaret != hItem);
    }

    ASSERT(pTree->hItemPainting != hItem);

    ControlFree(pTree->hheap, hItem);
}


// ----------------------------------------------------------------------------
//
//  Removes the given item and all children from the tree.
//  Special case: if the given item is the hidden root, all children are
//  removed, but the hidden root is NOT removed.
//
//  sets cItems
//
// ----------------------------------------------------------------------------

BOOL TV_DeleteItem(PTREE pTree, TREEITEM * hItem, UINT flags)
{
    if (hItem == TVI_ROOT || !hItem)
        hItem = pTree->hRoot;

    // BUGUBG: send TVN_DELETEALLITEMS and TVDI_NONOTIFY if they respond
    // if (hItem == pTree->hRoot)
    //     etc.

    if (!ValidateTreeItem(hItem, 0))
        return FALSE;

    // Collapse first to speed things up (not as much scroll bar recalcs) and
    // to set the top index correctly after the remove.
    if (hItem != pTree->hRoot)
        TV_Expand(pTree, TVE_COLLAPSE, hItem, FALSE);
    else
    {
        // TV_Expand punts on the root item, so manually iterate through it's kids
        TREEITEM *hKid = hItem->hKids;
        while (hKid)
        {
            TV_Expand(pTree, TVE_COLLAPSE, hKid, FALSE);
            if (!ValidateTreeItem(hKid, 0)) break;      // callback during collapse could delete
            hKid = hKid->hNext;
        }
    }

    // Invalidate everything below this item; must be done AFTER setting the
    // selection
    if (hItem->hParent == pTree->hRoot || hItem == pTree->hRoot || ITEM_VISIBLE(hItem->hParent)) {
        if (pTree->fRedraw) {
            InvalidateRect(pTree->ci.hwnd, NULL, TRUE);
        }
    } else {
        TV_ScrollBelow(pTree, hItem->hParent, FALSE, FALSE);
    }

    // We can pass in the root to clear all items
    if (hItem == pTree->hRoot)
        flags |= TVDI_CHILDRENONLY;

    TV_DeleteItemRecurse(pTree, hItem, flags);

    ASSERT(pTree->hRoot); // didn't go too far, did we?

    // maybe everything's gone...
    // check out our cleanup job
    if (!pTree->hRoot->hKids) {
        // the tree itself
        ASSERT(pTree->cItems == 0);
        pTree->cItems = 0; // just removed it all, didn't we?

        pTree->hTop = NULL;

        AssertMsg(pTree->hCaret == NULL, TEXT("hCaret not NULL, but empty tree"));
        pTree->hCaret = NULL;

        pTree->fNameEditPending = FALSE;
        pTree->cxMax = 0;
        pTree->xPos = 0;

        // the invisible root
        ASSERT(pTree->hRoot->hNext == NULL);            
        pTree->hRoot->hNext = NULL;
        ASSERT(pTree->hRoot->hParent == NULL);          
        pTree->hRoot->hParent = NULL;
        ASSERT(pTree->hRoot->hKids == NULL);            
        pTree->hRoot->hKids = NULL;
        ASSERT(pTree->hRoot->state & TVIS_EXPANDED);
        pTree->hRoot->state |= (TVIS_EXPANDED | TVIS_EXPANDEDONCE);
        ASSERT(pTree->hRoot->iLevel == (BYTE)-1);
        pTree->hRoot->iLevel = (BYTE) -1;
        ASSERT(pTree->hRoot->iShownIndex == (WORD)-1);
        pTree->hRoot->iShownIndex = (WORD) -1;
    }

    return TRUE;
}


// ----------------------------------------------------------------------------
//
//  Creates the hidden root node for the tree -- all items will trace up to
//  this root, and the first child of the root is the first item in the tree.
//
//  sets hRoot
//
// ----------------------------------------------------------------------------

BOOL TV_CreateRoot(PTREE pTree)
{
    TREEITEM * hRoot = ControlAlloc(pTree->hheap, sizeof(TREEITEM));
    if (!hRoot)
        return FALSE;

    // hRoot->hNext        = NULL;
    // hRoot->hKids        = NULL;
    // hRoot->hParent      = NULL;
    hRoot->iLevel = (BYTE) -1;
    hRoot->state = (TVIS_EXPANDED | TVIS_EXPANDEDONCE);
    hRoot->iShownIndex = (WORD)-1;
    hRoot->wSignature      = TV_SIG;
    hRoot->dwAccId = pTree->dwLastAccId++;

    pTree->hRoot = hRoot;

    // OLEACC asks for the text of the root item (d'oh!)
    Str_Set(&hRoot->lpstr, c_szNULL);
    return TRUE;
}

#ifdef DEBUG

void DumpItem(TREEITEM *hItem)
{
    LPTSTR p;

    if (hItem->lpstr == LPSTR_TEXTCALLBACK)
        p = TEXT("(callback)");
    else if (hItem->lpstr == NULL)
        p = TEXT("(null)");
    else
        p = hItem->lpstr;

    TraceMsg(TF_TREEVIEW, "%s", p);
    TraceMsg(TF_TREEVIEW, "\tstate:%4.4x show index:%3d level:%2d kids:%ld lparam:%4.4x",
            hItem->state, hItem->iShownIndex,
            hItem->iLevel, hItem->fKids, hItem->lParam);

}

#else
#define DumpItem(hItem)
#endif


// ----------------------------------------------------------------------------
//
//  Adds the item described by the given arguments to the tree.
//
//  sets hTop, cItems
//
// ----------------------------------------------------------------------------

#ifdef UNICODE
TREEITEM * TV_InsertItemA(PTREE pTree, LPTV_INSERTSTRUCTA lpis) {
    LPSTR pszA = NULL;
    TREEITEM *ptvi;

    //HACK Alert!  This code assumes that TV_INSERTSTRUCTA is exactly the same
    // as TV_INSERTSTRUCTW except for the text pointer in the TVITEM
    COMPILETIME_ASSERT(sizeof(TV_INSERTSTRUCTA) == sizeof(TV_INSERTSTRUCTW));

    if (!IsFlagPtr(lpis) && (lpis->DUMMYUNION_MEMBER(item).mask & TVIF_TEXT) && !IsFlagPtr(lpis->DUMMYUNION_MEMBER(item).pszText)) {

        pszA = lpis->DUMMYUNION_MEMBER(item).pszText;
        lpis->DUMMYUNION_MEMBER(item).pszText = (LPSTR)ProduceWFromA(pTree->ci.uiCodePage, lpis->DUMMYUNION_MEMBER(item).pszText);

        if (lpis->DUMMYUNION_MEMBER(item).pszText == NULL) {
            lpis->DUMMYUNION_MEMBER(item).pszText = pszA;
            return NULL;
        }
    }

    ptvi = TV_InsertItem( pTree, (LPTV_INSERTSTRUCTW)lpis );

    if (pszA) {
        FreeProducedString(lpis->DUMMYUNION_MEMBER(item).pszText);
        lpis->DUMMYUNION_MEMBER(item).pszText = pszA;
    }

    return ptvi;
}
#endif

TREEITEM * TV_InsertItem(PTREE pTree, LPTV_INSERTSTRUCT lpis)
{
    TREEITEM *hNewItem, *hItem;
    TREEITEM *hParent;
    TREEITEM *hInsertAfter;
    UINT mask;

    if (!lpis)
        return NULL; //Bug#94345: Validate LPTV_INSERTSTRUCT

    // initialize _after_ the check for NULL!
    hParent      = lpis->hParent;
    hInsertAfter = lpis->hInsertAfter;
    mask         = lpis->DUMMYUNION_MEMBER(item).mask;
           
    // don't allow undefined bits
    AssertMsg((lpis->DUMMYUNION_MEMBER(item).mask & ~TVIF_ALL) == 0, TEXT("Invalid TVIF mask specified"));
    if (mask & ~TVIF_ALL) {
        // if they used bogus bits,
        // restrict to win95 bits only
        // I'd like to fail completely, but for win95 compat, we can't
        //
        // this fixes  QuaterDesk's CleanSweep which has bogus garbage on the stack for a mask
        mask = (TVIF_WIN95 & mask);
    }

    TV_DismissEdit(pTree, FALSE);

    //
    //  Zillions of apps pass garbage for hInsertAfter, so don't fail if
    //  it's invalid.  Fortunately, we never dereference hInsertAfter, so
    //  garbage is okay.

    if (!ValidateTreeItem(hParent, VTI_NULLOK))     // NULL means TVI_ROOT
        return NULL;

    DBG_ValidateTreeItem(hInsertAfter, 0);

    hNewItem = ControlAlloc(pTree->hheap, sizeof(TREEITEM));
    if (!hNewItem)
    {
        TraceMsg(TF_ERROR, "TreeView: Out of memory");
        return NULL;
    }

    hNewItem->wSignature = TV_SIG;

    if (mask & TVIF_TEXT)
    {
        //
        // We will setup the text string next, before we link our self in
        // as to handle the case where we run out of memory and need to
        // destroy ourself without having to unlink.
        //
        if (!lpis->DUMMYUNION_MEMBER(item).pszText)
        {
            hNewItem->lpstr = LPSTR_TEXTCALLBACK;
        }
        else
        {
            if (!Str_Set(&hNewItem->lpstr, lpis->DUMMYUNION_MEMBER(item).pszText))
            {
                // Memory allocation failure...
                TraceMsg(TF_ERROR, "TreeView: Out of memory");
                TV_MarkAsDead(hNewItem);
                ControlFree(pTree->hheap, hNewItem);
                return NULL;
            }
        }
    } 
    else
    {
        Str_Set(&hNewItem->lpstr, c_szNULL);
    }

    AssertMsg(hNewItem->lpstr != NULL, TEXT("Item added with NULL text"));

    if ((hParent == NULL) || (hParent == TVI_ROOT))
    {
        hParent = pTree->hRoot;
        if (!pTree->hTop)
            pTree->hTop = hNewItem;
    }
    else if (!pTree->hRoot->hKids)
    {
        TV_MarkAsDead(hNewItem);
        ControlFree(pTree->hheap, hNewItem);
        return NULL;
    }

    // We will do the sort later, so we can handle TEXTCALLBACK things
    if ((hInsertAfter == TVI_FIRST || hInsertAfter == TVI_SORT) || !hParent->hKids)
    {
        hNewItem->hNext = hParent->hKids;
        hParent->hKids = hNewItem;
    }
    else
    {
        // Bug#94348: we should cache the last insert after pointer to try to
        // catch the case of consecutive adds to the end of a node

        if (hInsertAfter == TVI_LAST)
            for (hItem = hParent->hKids; hItem->hNext; hItem = hItem->hNext)
                ;
        else
        {
            for (hItem = hParent->hKids; hItem->hNext; hItem = hItem->hNext)
                if (hItem == hInsertAfter)
                    break;
        }

        hNewItem->hNext = hItem->hNext;
        hItem->hNext = hNewItem;
    }

    // hNewItem->hKids     = NULL;
    hNewItem->hParent   = hParent;
    hNewItem->iLevel    = hParent->iLevel + 1;
    // hNewItem->iWidth = 0;
    // hNewItem->state = 0;
    if ((mask & TVIF_INTEGRAL) &&
        LOWORD(lpis->DUMMYUNION_MEMBER(itemex).iIntegral) > 0)
    {
        hNewItem->iIntegral = LOWORD(lpis->DUMMYUNION_MEMBER(itemex).iIntegral);
    } 
    else 
    {
        hNewItem->iIntegral = 1;
    }
    
    if (pTree->hTop == hNewItem)
        hNewItem->iShownIndex = 0; // calc me please!
    else
        hNewItem->iShownIndex = (WORD)-1; // calc me please!

    if (mask & TVIF_IMAGE)
        hNewItem->iImage = (WORD) lpis->DUMMYUNION_MEMBER(item).iImage;

    if (mask & TVIF_SELECTEDIMAGE)
        hNewItem->iSelectedImage = (WORD) lpis->DUMMYUNION_MEMBER(item).iSelectedImage;

    if (mask & TVIF_PARAM)
        hNewItem->lParam = lpis->DUMMYUNION_MEMBER(item).lParam;

    if (mask & TVIF_STATE)
        hNewItem->state = lpis->DUMMYUNION_MEMBER(item).state & lpis->DUMMYUNION_MEMBER(item).stateMask;
    
    // if we're in check box mode, inforce that it has a check box
    if (pTree->ci.style & TVS_CHECKBOXES)
    {
        if ((hNewItem->state & TVIS_STATEIMAGEMASK) == 0) 
        {
            hNewItem->state |= INDEXTOSTATEIMAGEMASK(1);
        }
    }

    if ((hNewItem->state & TVIS_BOLD) && !pTree->hFontBold) //$BOLD
        TV_CreateBoldFont(pTree);                           //$BOLD

    // TraceMsg(TF_TRACE, "Tree: Inserting i = %d state = %d", TV_StateIndex(&lpis->item), lpis->item.state);

    if (mask & TVIF_CHILDREN) 
    {
        switch (lpis->DUMMYUNION_MEMBER(item).cChildren) 
        {
        case I_CHILDRENCALLBACK:
            hNewItem->fKids = KIDS_CALLBACK;
            break;

        case I_CHILDRENAUTO:
            hNewItem->fKids = KIDS_COMPUTE;
            break;

        case 0:
            hNewItem->fKids = KIDS_FORCE_NO;
            break;

        default:
            hNewItem->fKids = KIDS_FORCE_YES;
            break;
        }
    }

    hNewItem->dwAccId = pTree->dwLastAccId++;

    // accept state bits on create?
    // mask & TVIF_STATE

    pTree->cItems++;

    // I don't want to do any callbacks until the item is completed
    // so sorting waits until the end
    // special case an only child for speed
    // (hKids && hKids->hNext means more than one child)
    if ((hInsertAfter == TVI_SORT) && hParent->hKids && hParent->hKids->hNext)
    {
        TVITEMEX sThisItem, sNextItem;
        TCHAR szThis[64], szNext[64];

        sThisItem.pszText = szThis;
        sThisItem.cchTextMax  = ARRAYSIZE(szThis);
        TV_GetItem(pTree, hNewItem, TVIF_TEXT, &sThisItem);

        // We know that the first kid of hParent is hNewItem
        for (hItem = hNewItem->hNext; hItem; hItem = hItem->hNext)
        {

            sNextItem.pszText = szNext;
            sNextItem.cchTextMax  = ARRAYSIZE(szNext);

            TV_GetItem(pTree, hItem, TVIF_TEXT, &sNextItem);

            if (lstrcmpi(sThisItem.pszText, sNextItem.pszText) < 0)
                break;

            hInsertAfter = hItem;
        }

        // Check if this is still the first item
        if (hInsertAfter != TVI_SORT)
        {
            // Move this item from the beginning to where it
            // should be
            hParent->hKids = hNewItem->hNext;
            hNewItem->hNext = hInsertAfter->hNext;
            hInsertAfter->hNext = hNewItem;
        }
    }

    
    if ((hNewItem->hNext == pTree->hTop) && !pTree->fVert) 
    {
        
        // there's no scrollbars and we got added before the top 
        // item.  we're now the top.
        hNewItem->iShownIndex = 0;
        pTree->hTop = hNewItem;
    }

    if (pTree->fRedraw)
    {
        BOOL fVert = pTree->fVert;
        RECT rc;
        RECT rc2;

        if (TV_ScrollBarsAfterAdd(pTree, hNewItem))
        {
            // scroll everything down one
            if (ITEM_VISIBLE(hNewItem))
            {
                int iTop = hNewItem->iShownIndex - pTree->hTop->iShownIndex;

                // if there wasn't a scrollbar and we're the 0th item,
                // TV_ScrollBarsAfterAdd already scrolled us
                if (iTop > 0 || !fVert)
                    TV_ScrollItems(pTree, hNewItem->iIntegral, iTop + hNewItem->iIntegral - 1, TRUE);
            }
        }

        // connect the lines, add the buttons, etc. on the item above
        // TV_GetPrevVisItem only works after TV_Scroll* stuff is done
            
        if (TV_GetItemRect(pTree, hNewItem, &rc, FALSE))
        {

            // find the previous sibling or the parent if no prev sib.
            if (hParent->hKids == hNewItem)
            {
                hItem = hParent;
            } 
            else
            {
                hItem = hParent->hKids;
                while ( hItem->hNext != hNewItem )
                {
                    ASSERT(hItem->hNext);
                    hItem = hItem->hNext;
                }
            }

            // invalidate from there to the new one
            if (TV_GetItemRect(pTree, hItem, &rc2, FALSE)) 
            {
                rc.top = rc2.top;
            }
            RedrawWindow(pTree->ci.hwnd, &rc, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
    }

    // DumpItem(hNewItem);

    NotifyWinEvent(EVENT_OBJECT_CREATE, pTree->ci.hwnd, OBJID_CLIENT, TV_GetAccId(hNewItem));

    if (pTree->hToolTip)
    {
        TV_PopBubble(pTree);
    }

    return hNewItem;
}

void TV_DeleteHotFonts(PTREE pTree)
{
    if (pTree->hFontHot)
        DeleteObject(pTree->hFontHot);
    
    if (pTree->hFontBoldHot)
        DeleteObject(pTree->hFontBoldHot);
    
    pTree->hFontHot = pTree->hFontBoldHot = NULL;
}

// ----------------------------------------------------------------------------
//
//  Frees all allocated memory and objects associated with the tree.
//
// ----------------------------------------------------------------------------

void TV_DestroyTree(PTREE pTree)
{
    HWND hwnd = pTree->ci.hwnd;

    ASSERT(pTree->hRoot);

    pTree->fRedraw = FALSE;
    
    TV_OnSetBkColor(pTree, (COLORREF)-1);

    if (pTree->hbrLine)
    {
        DeleteObject(pTree->hbrLine);
    }

    if (pTree->hbrText)
    {
        DeleteObject(pTree->hbrText);
    }

    if (pTree->hCurHot)
    {
        DestroyCursor(pTree->hCurHot);
    }

    if (IsWindow(pTree->hwndToolTips)) 
    {
        DestroyWindow(pTree->hwndToolTips);
    }

    pTree->hwndToolTips = NULL;

    if (IsWindow(pTree->hwndEdit)) 
    {
        DestroyWindow(pTree->hwndEdit);
    }

    pTree->hwndEdit = NULL;

    TV_DeleteItem(pTree, pTree->hRoot, TVDI_CHILDRENONLY | TVDI_NOSELCHANGE);

    if (pTree->hRoot)
    {
        Str_Set(&pTree->hRoot->lpstr, NULL);

        // No point in marking dead since the entire control is going away
        ControlFree(pTree->hheap, pTree->hRoot);
    }

    if (pTree->hdcBits)
    {
        if (pTree->hBmp)
        {
            SelectObject(pTree->hdcBits, pTree->hStartBmp);
            DeleteObject(pTree->hBmp);
        }

        DeleteDC(pTree->hdcBits);
    }

    if (pTree->fCreatedFont && pTree->hFont)
    {
        DeleteObject(pTree->hFont);
    }

    if (pTree->hFontBold)
    {
        DeleteObject(pTree->hFontBold);
    }

    Str_Set(&pTree->pszTip, NULL);
    
    if (pTree->pszTipA)
    {
        LocalFree(pTree->pszTipA);
    }

    TV_DeleteHotFonts(pTree);

    if (pTree->hdpaWatch)
    {
        DPA_Destroy(pTree->hdpaWatch);
    }

    IncrementSearchFree(&pTree->is);

    if (pTree->hTheme)
    {
        CloseThemeData(pTree->hTheme);
    }

    NearFree(pTree);

    // Don't try to use this var when window is destroyed...
    SetWindowInt(hwnd, 0, 0);
}

void TV_CreateToolTips(PTREE pTree);

void TV_InitThemeMetrics(PTREE pTree, HTHEME hTheme)
{
    COLORREF cr;

    HRESULT hr = GetThemeColor(hTheme, 0, 0, TMT_COLOR, &cr);
    if (SUCCEEDED(hr))
        SendMessage(pTree->ci.hwnd, TVM_SETBKCOLOR, 0, cr);

    // Line color
    hr = GetThemeColor(hTheme, TVP_BRANCH, 0, TMT_COLOR, &cr);
    if (SUCCEEDED(hr))
        SendMessage(pTree->ci.hwnd, TVM_SETLINECOLOR, 0, cr);
}


// ----------------------------------------------------------------------------
//
//  Allocates space for the tree and initializes the tree's data
//
// ----------------------------------------------------------------------------

LRESULT TV_OnCreate(HWND hwnd, LPCREATESTRUCT lpCreate)
{
    HTHEME hTheme;
    HRESULT hr = E_FAIL;
    PTREE pTree = NearAlloc(sizeof(TREE));

    if (!pTree)
        return -1;      // fail the create window

    pTree->hheap = GetProcessHeap();

    if (!TV_CreateRoot(pTree)) 
    {
        NearFree((HLOCAL)pTree);
        return -1;      // fail the create window
    }

    pTree->hdpaWatch = DPA_Create(8);
    if (!pTree->hdpaWatch) 
    {
        // No point in marking dead since the entire control is going away
        ControlFree(pTree->hheap, pTree->hRoot);
        NearFree((HLOCAL)pTree);
        return -1;      // fail the create window
    }

    SetWindowPtr(hwnd, 0, pTree);

    CIInitialize(&pTree->ci, hwnd, lpCreate);

    if (lpCreate->dwExStyle & WS_EX_RTLREADING)
        pTree->ci.style |= TVS_RTLREADING;
    
    pTree->fRedraw    = TRUE;
    pTree->clrim = CLR_DEFAULT;
    pTree->clrText = (COLORREF)-1;
    pTree->clrBkNonTheme = pTree->clrBk = (COLORREF)-1;
    pTree->clrLineNonTheme = pTree->clrLine = CLR_DEFAULT;
    pTree->hbrLine = g_hbrGrayText;
    pTree->cxBorder = 3;

    hTheme = OpenThemeData(pTree->ci.hwnd, L"TreeView");


    if (hTheme)
    {
        TV_InitThemeMetrics(pTree, hTheme);
    }

    pTree->hTheme = hTheme;

    pTree->hbrText = g_hbrWindowText;

    // pTree->fHorz        = FALSE;
    // pTree->fVert        = FALSE;
    // pTree->fFocus       = FALSE;
    // pTree->fNameEditPending = FALSE;
    // pTree->cxMax        = 0;
    // pTree->cxWnd        = 0;
    // pTree->cyWnd        = 0;
    // pTree->hTop         = NULL;
    // pTree->hCaret       = NULL;
    // pTree->hDropTarget  = NULL;
    // pTree->hOldDrop     = NULL;
    // pTree->cItems       = 0;
    // pTree->cShowing     = 0;
    pTree->cFullVisible = 1;
    // pTree->hdcBits      = NULL;
    // pTree->hBmp         = NULL;
    // pTree->hbrBk        = NULL;
    // pTree->xPos         = 0;
    // pTree->cxIndent     = 0; // init this for real in TV_OnSetFont()
    // pTree->dwCDDepth    = 0;
    pTree->uMaxScrollTime  = SSI_DEFAULT;
    pTree->dwLastAccId     = 1;     // Start at 1 because 0 means self
    // pTree->dwExStyle     = 0;
    // pTree->fInTextCallback = FALSE;
    
    TV_OnSetFont(pTree, NULL, TRUE);
    
    // You cannot combine TVS_HASLINES and TVS_FULLROWSELECT
    // because it doesn't work
    if (pTree->ci.style & TVS_HASLINES) {
        if (pTree->ci.style & TVS_FULLROWSELECT) {
            DebugMsg(DM_ERROR, TEXT("Cannot combine TVS_HASLINES and TVS_FULLROWSELECT"));
        }
        pTree->ci.style &= ~TVS_FULLROWSELECT;
    }

    if (!(pTree->ci.style & TVS_NOTOOLTIPS)) {
        TV_CreateToolTips(pTree);
    }

    SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
    SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);

    return 0;   // success
}


void TV_CreateToolTips(PTREE pTree)
{
    DWORD exStyle = 0;

    if(pTree->ci.style & TVS_RTLREADING) 
    {
        exStyle |= WS_EX_RTLREADING;
    }

    pTree->hwndToolTips = CreateWindowEx(WS_EX_TRANSPARENT | exStyle, c_szSToolTipsClass, NULL,
                                       WS_POPUP | TTS_NOPREFIX,
                                       CW_USEDEFAULT, CW_USEDEFAULT,
                                       CW_USEDEFAULT, CW_USEDEFAULT,
                                       pTree->ci.hwnd, NULL, HINST_THISDLL,
                                       NULL);
    if (pTree->hwndToolTips) 
    {
        TOOLINFO ti;

        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_IDISHWND | TTF_TRANSPARENT;
        ti.hwnd = pTree->ci.hwnd;
        ti.uId = (UINT_PTR)pTree->ci.hwnd; 
        ti.lpszText = LPSTR_TEXTCALLBACK;
        ti.lParam = 0;
        SendMessage(pTree->hwndToolTips, TTM_ADDTOOL, 0,
                    (LPARAM)(LPTOOLINFO)&ti);
        SendMessage(pTree->hwndToolTips, WM_SETFONT, (WPARAM)pTree->hFont, (LPARAM)TRUE);
        SendMessage(pTree->hwndToolTips, TTM_SETDELAYTIME, TTDT_INITIAL, (LPARAM)500);
    } 
    else
        pTree->ci.style |= (TVS_NOTOOLTIPS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\unixstuff.h ===
#ifndef _COMCTL32_UNIXSTUFF_H_
#define _COMCTL32_UNIXSTUFF_H_

#define ARROW_WIDTH  4
#define ARROW_HEIGHT 4

#define CHECK_FREE( ptr ) { if(ptr) { free(ptr); ptr = NULL; } }

STDAPI_(void) UnixPaintArrow(HDC hDC, BOOL bHoriz, BOOL bDown, int nXCenter, int nYCenter, int nWidth, int nHeight);

/* We need this for the unaligned template classes to work after
 * fixing the mmsystem.h header.
 */
#if defined(MWBIG_ENDIAN)
#ifdef mmioFOURCC
#undef mmioFOURCC
#endif
#define mmioFOURCC(ch0, ch1, ch2, ch3) MAKEFOURCC(ch3, ch2, ch1, ch0)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\treeview.c ===
#include "ctlspriv.h"
#include "treeview.h"
#include "listview.h"

// penwin.h is messed up; define local stuff for now
#define HN_BEGINDIALOG                  40              // Lens/EditText/garbage detection dialog is about
                                    // to come up on this hedit/bedit
#define HN_ENDDIALOG                       41           // Lens/EditText/garbage detection dialog has
                                    // just been destroyed

//---------------------------------------------------------
#define IDT_SCROLLWAIT 43

//-----------------------
// ToolTip stuff...
//
#define REPEATTIME      SendMessage(pTree->hwndToolTips,TTM_GETDELAYTIME,(WPARAM)TTDT_RESHOW, 0)
#define CHECKFOCUSTIME  (REPEATTIME)
#define IDT_TOOLTIPWAIT   2
#define IDT_FOCUSCHANGE   3
// in tooltips.c
BOOL ChildOfActiveWindow(HWND hwnd);
void TV_HandleStateIconClick(PTREE pTree, HTREEITEM hItem);

HWND TV_EditLabel(PTREE pTree, HTREEITEM hItem, LPTSTR pszInitial);
void TV_CancelEditTimer(PTREE pTree);
BOOL TV_SetItem(PTREE pTree, LPCTVITEMEX ptvi);
void TV_DeleteHotFonts(PTREE pTree);
BOOL TV_IsShowing(HTREEITEM hItem);

LRESULT TV_OnScroll(PTREE ptv, LPNMHDR pnm);

#define TVBD_FROMWHEEL      0x0001
#define TVBD_WHEELFORWARD   0x0002
#define TVBD_WHEELBACK      0x0004

BOOL ValidateTreeItem(TREEITEM * hItem, UINT flags)
{
    BOOL fValid = TRUE;

    /*
     *  Check the values to make sure the new Win64-compatible values
     *  are consistent with the old Win32 values.
     */
    CO