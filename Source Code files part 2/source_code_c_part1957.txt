eateInstance( CComObjectDbg<Base>** pp, const char* lpszFileName, int nLine, int nSubType = ATL_CLIENT_BLOCK );
};

template <class Base>
HRESULT WINAPI CComObjectDbg<Base>::CreateInstance(CComObjectDbg<Base>** pp, const char* lpszFileName, int nLine, int nSubType )
{
    ATLASSERT(pp != NULL);
    HRESULT hRes = E_OUTOFMEMORY;
    CComObjectDbg<Base>* p = NULL;
    ATLTRY( p = new( lpszFileName, nLine, nSubType) CComObjectDbg<Base>() );; 
    if (p != NULL)
    {
        p->SetVoid(NULL);
        p->InternalFinalConstructAddRef();
        hRes = p->FinalConstruct();
        p->InternalFinalConstructRelease();
        if (hRes != S_OK)
        {
            delete p;
            p = NULL;
        }
    }
    *pp = p;
    return hRes;
}

#define CCOMOBJECT              CComObjectDbg
#define CREATEINSTANCE( class, p )  class::CreateInstance( p, __FILE__, __LINE__, ATL_CLIENT_BLOCK )

#endif //__ATLCOM_H__

#define DEBUG_NEW new( THIS_FILE, __LINE__ )
#define new DEBUG_NEW

#endif // !USE_MFC

#define DECLARE_ALLOCATION_HOOK extern int _cdecl _dbg_AllocHook(int,void*,size_t,int,long,const unsigned char*,int)
#define REGISTER_ALLOCATION_HOOK _CrtSetAllocHook( &_dbg_AllocHook )

#else  // !DBG || !defined(FIND_LEAKS)

#if !defined(USE_MFC)

#define DECLARE_THIS_FILE
#define BEGIN_LEAK_CHECKING
#define END_LEAK_CHECKING
#define DUMP_LEAKS_ON_EXIT

#endif // !defined(USE_MFC)

// Is ATL being used.
#if defined(__ATLCOM_H__)
#define CCOMOBJECT                  CComObject
#define CREATEINSTANCE( class, p )  class::CreateInstance( p )
#endif

#define DECLARE_ALLOCATION_HOOK
#define REGISTER_ALLOCATION_HOOK

#endif // !DBG || !defined(FIND_LEAKS)

//////////////////////////////////////////////////////////////////////////////
#define BEGIN_ALLOCATION_HOOK \
int _cdecl _dbg_AllocHook(    \
        int AllocationType,   \
        void* pUserData,      \
        size_t cbAllocated,   \
        int BlockType,        \
        long nRequest,        \
        const unsigned char *pszFile,  \
        int nLine )           \
{                             \
    if( _CRT_BLOCK == BlockType )   \
    {                               \
        return( TRUE );       \
    }                         \
    switch( AllocationType )  \
    {                         \
    case _HOOK_ALLOC:         \
        {                     

//////////////////////////////////////////////////////////////////////////////
#define END_ALLOCATION_HOOK   \
        break;                \
        }                     \
    }                         \
    return( TRUE );           \
}
  

#endif //FINDLEAK_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\irtldbg.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       irtldbg.h

   Abstract:
       Some simple debugging macros that look and behave a lot like their
       namesakes in MFC.  These macros should work in both C and C++ and do
       something useful with almost any Win32 compiler.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __IRTLDBG_H__
#define __IRTLDBG_H__

#ifndef __IRTLMISC_H__
# include <irtlmisc.h>
#endif

/* Ensure that MessageBoxes can popup */
# define IRTLDBG_RUNNING_AS_SERVICE 1

#include <tchar.h>


// Compile-time (not run-time) assertion. Code will not compile if
// expr is false. Note: there is no non-debug version of this; we
// want this for all builds. The compiler optimizes the code away.
template <bool> struct static_checker;
template <> struct static_checker<true> {};  // specialize only for `true'
#define STATIC_ASSERT(expr) static_checker< (expr) >()


# ifndef _AFX
  /* Assure compatiblity with MFC */

# ifdef _DEBUG
#  define IRTLDEBUG
# endif

# ifdef IRTLDEBUG
#  if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
    /* Use the new debugging tools in Visual C++ 4.x */
#   include <crtdbg.h>
    /* _ASSERTE will give a more meaningful message, but the string takes
     * space.  Use _ASSERT if this is an issue. */
#   define IRTLASSERT(f) _ASSERTE(f)
#  else
#   include <assert.h>
#   define IRTLASSERT(f) assert(f)
#  endif

#  define IRTLVERIFY(f)               IRTLASSERT(f)
#  ifndef DEBUG_ONLY
#   define DEBUG_ONLY(f)              (f)
#  endif
#  define IRTLTRACE                   IrtlTrace
#  define IRTLTRACE0(psz)             IrtlTrace(_T("%s"), _T(psz))
#  define IRTLTRACE1(psz, p1)         IrtlTrace(_T(psz), p1)
#  define IRTLTRACE2(psz, p1, p2)     IrtlTrace(_T(psz), p1, p2)
#  define IRTLTRACE3(psz, p1, p2, p3) IrtlTrace(_T(psz), p1, p2, p3)
#  define IRTLTRACE4(psz, p1, p2, p3, p4) \
                                      IrtlTrace(_T(psz), p1, p2, p3, p4)
#  define IRTLTRACE5(psz, p1, p2, p3, p4, p5) \
                                      IrtlTrace(_T(psz), p1, p2, p3, p4, p5)
#  define ASSERT_VALID(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->AssertValid();} while (0)
#  define DUMP(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->Dump();} while (0)

# else /* !IRTLDEBUG */

  /* These macros should all compile away to nothing */
#  define IRTLASSERT(f)           ((void)0)
#  define IRTLVERIFY(f)           ((void)(f))
#  ifndef DEBUG_ONLY
#   define DEBUG_ONLY(f)          ((void)0)
#  endif
#  define IRTLTRACE               1 ? (void)0 : IrtlTrace
#  define IRTLTRACE0(psz)         1 ? (void)0 : IrtlTrace
#  define IRTLTRACE1(psz, p1)     1 ? (void)0 : IrtlTrace
#  define IRTLTRACE2(psz, p1, p2) 1 ? (void)0 : IrtlTrace
#  define IRTLTRACE3(psz, p1, p2, p3)         1 ? (void)0 : IrtlTrace
#  define IRTLTRACE4(psz, p1, p2, p3, p4)     1 ? (void)0 : IrtlTrace
#  define IRTLTRACE5(psz, p1, p2, p3, p4, p5) 1 ? (void)0 : IrtlTrace
#  define ASSERT_VALID(pObj)      ((void)0)
#  define DUMP(pObj)              ((void)0)

# endif /* !IRTLDEBUG */


# define ASSERT_POINTER(p, type) \
    IRTLASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

# define ASSERT_NULL_OR_POINTER(p, type) \
    IRTLASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_STRING(s) \
    IRTLASSERT(((s) != NULL)  &&  IsValidString((s), -1))

#define ASSERT_NULL_OR_STRING(s) \
    IRTLASSERT(((s) == NULL)  ||  IsValidString((s), -1))


/* Declarations for non-Windows apps */

# ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
# endif /* _WINDEF_ */

# ifndef TRUE
#  define FALSE  0
#  define TRUE   1
# endif


# ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

}

# else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength);

# endif /* !__cplusplus */

#else
# define IRTLASSERT(f) _ASSERTE(f)

#endif /* !_AFX */


/* Writes trace messages to debug stream */
extern
#ifdef __cplusplus
"C"
#endif /* !__cplusplus */
IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR pszFormat,
    ...);


#ifdef IRTLDEBUG
# define IRTL_DEBUG_INIT()            IrtlDebugInit()
# define IRTL_DEBUG_TERM()            IrtlDebugTerm()
#else /* !IRTLDEBUG */
# define IRTL_DEBUG_INIT()            ((void)0)
# define IRTL_DEBUG_TERM()            ((void)0)
#endif /* !IRTLDEBUG */


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* should be called from main(), WinMain(), or DllMain() */
IRTL_DLLEXP void
IrtlDebugInit();

IRTL_DLLEXP void
IrtlDebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __IRTLDBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\hashfn.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       hashfn.h

   Abstract:
       Declares and defines a collection of overloaded hash functions.
       It is strongly suggested that you use these functions with LKRhash.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __HASHFN_H__
#define __HASHFN_H__


#ifndef __HASHFN_NO_NAMESPACE__
namespace HashFn {
#endif // !__HASHFN_NO_NAMESPACE__

// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKRhash applies this internally
// to all hash signatures for exactly this reason.

inline DWORD
HashScramble(DWORD dwHash)
{
    // Here are 10 primes slightly greater than 10^9
    //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.

    // default value for "scrambling constant"
    const DWORD RANDOM_CONSTANT = 314159269UL;
    // large prime number, also used for scrambling
    const DWORD RANDOM_PRIME =   1000000007UL;

    return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
}


// Faster scrambling function suggested by Eric Jacobsen

inline DWORD
HashRandomizeBits(DWORD dw)
{
	return (((dw * 1103515245 + 12345) >> 16)
            | ((dw * 69069 + 1) & 0xffff0000));
}


// Small prime number used as a multiplier in the supplied hash functions
const DWORD HASH_MULTIPLIER = 101;

#undef HASH_SHIFT_MULTIPLY

#ifdef HASH_SHIFT_MULTIPLY
# define HASH_MULTIPLY(dw)   (((dw) << 7) - (dw))
#else
# define HASH_MULTIPLY(dw)   ((dw) * HASH_MULTIPLIER)
#endif

// Fast, simple hash function that tends to give a good distribution.
// Apply HashScramble to the result if you're using this for something
// other than LKRhash.

inline DWORD
HashString(
    const char* psz,
    DWORD       dwHash = 0)
{
    // force compiler to use unsigned arithmetic
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *upsz;

    return dwHash;
}


// Unicode version of above

inline DWORD
HashString(
    const wchar_t* pwsz,
    DWORD          dwHash = 0)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pwsz;

    return dwHash;
}


// Quick-'n'-dirty case-insensitive string hash function.
// Make sure that you follow up with _stricmp or _mbsicmp.  You should
// also cache the length of strings and check those first.  Caching
// an uppercase version of a string can help too.
// Again, apply HashScramble to the result if using with something other
// than LKRhash.
// Note: this is not really adequate for MBCS strings.

inline DWORD
HashStringNoCase(
    const char* psz,
    DWORD       dwHash = 0)
{
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)
                     +  (*upsz & 0xDF);  // strip off lowercase bit

    return dwHash;
}


// Unicode version of above

inline DWORD
HashStringNoCase(
    const wchar_t* pwsz,
    DWORD          dwHash = 0)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  (*pwsz & 0xFFDF);

    return dwHash;
}


// HashBlob returns the hash of a blob of arbitrary binary data.
// 
// Warning: HashBlob is generally not the right way to hash a class object.
// Consider:
//     class CFoo {
//     public:
//         char   m_ch;
//         double m_d;
//         char*  m_psz;
//     };
// 
//     inline DWORD Hash(const CFoo& rFoo)
//     { return HashBlob(&rFoo, sizeof(CFoo)); }
//
// This is the wrong way to hash a CFoo for two reasons: (a) there will be
// a 7-byte gap between m_ch and m_d imposed by the alignment restrictions
// of doubles, which will be filled with random data (usually non-zero for
// stack variables), and (b) it hashes the address (rather than the
// contents) of the string m_psz.  Similarly,
// 
//     bool operator==(const CFoo& rFoo1, const CFoo& rFoo2)
//     { return memcmp(&rFoo1, &rFoo2, sizeof(CFoo)) == 0; }
//
// does the wrong thing.  Much better to do this:
//
//     DWORD Hash(const CFoo& rFoo)
//     {
//         return HashString(rFoo.m_psz,
//                           HASH_MULTIPLIER * Hash(rFoo.m_ch)
//                               +  Hash(rFoo.m_d));
//     }
//
// Again, apply HashScramble if using with something other than LKRhash.

inline DWORD
HashBlob(
    const void* pv,
    size_t      cb,
    DWORD       dwHash = 0)
{
    const BYTE* pb = static_cast<const BYTE*>(const_cast<void*>(pv));

    while (cb-- > 0)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pb++;

    return dwHash;
}



//
// Overloaded hash functions for all the major builtin types.
// Again, apply HashScramble to result if using with something other than
// LKRhash.
//

inline DWORD Hash(const char* psz)
{ return HashString(psz); }

inline DWORD Hash(const unsigned char* pusz)
{ return HashString(reinterpret_cast<const char*>(pusz)); }

inline DWORD Hash(const signed char* pssz)
{ return HashString(reinterpret_cast<const char*>(pssz)); }

inline DWORD Hash(const wchar_t* pwsz)
{ return HashString(pwsz); }

inline DWORD
Hash(
    const GUID* pguid,
    DWORD       dwHash = 0)
{
    
    return * reinterpret_cast<DWORD*>(const_cast<GUID*>(pguid)) + dwHash;
}

// Identity hash functions: scalar values map to themselves
inline DWORD Hash(char c)
{ return c; }

inline DWORD Hash(unsigned char uc)
{ return uc; }

inline DWORD Hash(signed char sc)
{ return sc; }

inline DWORD Hash(short sh)
{ return sh; }

inline DWORD Hash(unsigned short ush)
{ return ush; }

inline DWORD Hash(int i)
{ return i; }

inline DWORD Hash(unsigned int u)
{ return u; }

inline DWORD Hash(long l)
{ return l; }

inline DWORD Hash(unsigned long ul)
{ return ul; }

inline DWORD Hash(float f)
{
    // be careful of rounding errors when computing keys
    union {
        float f;
        DWORD dw;
    } u;
    u.f = f;
    return u.dw;
}

inline DWORD Hash(double dbl)
{
    // be careful of rounding errors when computing keys
    union {
        double dbl;
        DWORD  dw[2];
    } u;
    u.dbl = dbl;
    return u.dw[0] * HASH_MULTIPLIER  +  u.dw[1];
}

#ifndef __HASHFN_NO_NAMESPACE__
}
#endif // !__HASHFN_NO_NAMESPACE__

#endif // __HASHFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\irtlmisc.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       irtlmisc.h

   Abstract:
       Declares miscellaneous functions and classes in IisRtl.DLL

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#ifndef __IRTLMISC_H__
#define __IRTLMISC_H__

#include <windows.h>

//--------------------------------------------------------------------
// These declarations are needed to export the template classes from
// IisRtl.DLL and import them into other modules.

#ifndef IRTL_DLLEXP
# ifdef DLL_IMPLEMENTATION
#  define IRTL_DLLEXP __declspec(dllexport)
#  ifdef IMPLEMENTATION_EXPORT
#   define IRTL_EXPIMP
#  else
#   undef  IRTL_EXPIMP
#  endif 
# else // !DLL_IMPLEMENTATION
#  define IRTL_DLLEXP __declspec(dllimport)
#  define IRTL_EXPIMP extern
# endif // !DLL_IMPLEMENTATION 
#endif // !IRTL_DLLEXP



//--------------------------------------------------------------------
// Miscellaneous functions

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// how many CPUs on this machine?
inline int NumProcessors()
{
    static int s_nCPUs = 0;
    
    if (s_nCPUs == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nCPUs = si.dwNumberOfProcessors;
    }
    return s_nCPUs;
}


// Type of processor, 386, 486, etc
inline int ProcessorType()
{
    static int s_nProcessorType = 0;
    
    if (s_nProcessorType == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nProcessorType = si.dwProcessorType;
    }
    return s_nProcessorType;
}


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __IRTLMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\locks.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       locks.h

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __LOCKS_H__
#define __LOCKS_H__

//--------------------------------------------------------------------
// File: locks.h
//
// A collection of different implementations of read/write locks that all
// share the same interface.  This allows different locks to be plugged
// into C++ templates as parameters.
//
// The implementations are:
//      CSmallSpinLock      lightweight critical section
//      CSpinLock           variant of CSmallSpinLock
//      CFakeLock           do-nothing class; useful as a template parameter
//      CCritSec            Win32 CRITICAL_SECTION
//   Multi-Reader/Single-Writer locks:
//      CReaderWriterLock   MRSW lock from Neel Jain
//      CReaderWriterLock2  smaller implementation of CReaderWriterLock
//      CReaderWriterLock3  CReaderWriterLock2 with recursive WriteLock
//
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> can used as
// exception-safe wrappers.
//
// TODO:
// * Add per-class lock-contention statistics
// * Add a timeout feature to Try{Read,Write}Lock
// * Add some way of tracking all the owners of a multi-reader lock
//--------------------------------------------------------------------



#ifndef __IRTLDBG_H__
# include <irtldbg.h>
#endif


enum LOCK_LOCKTYPE {
    LOCK_SMALLSPINLOCK = 1,
    LOCK_SPINLOCK,
    LOCK_FAKELOCK,
    LOCK_CRITSEC,
    LOCK_READERWRITERLOCK,
    LOCK_READERWRITERLOCK2,
    LOCK_READERWRITERLOCK3,
};


// Forward declarations
class IRTL_DLLEXP CSmallSpinLock;
class IRTL_DLLEXP CSpinLock;
class IRTL_DLLEXP CFakeLock;
class IRTL_DLLEXP CCritSec;
class IRTL_DLLEXP CReaderWriterLock;
class IRTL_DLLEXP CReaderWriterLock2;
class IRTL_DLLEXP CReaderWriterLock3;



#if defined(_MSC_VER)  &&  (_MSC_VER >= 1200)
// __forceinline keyword new to VC6
# define LOCK_FORCEINLINE __forceinline
#else
# define LOCK_FORCEINLINE inline
#endif

#ifdef _M_IX86
// The compiler will warn that the assembly language versions of the
// Lock_Atomic* functions don't return a value. Actually, they do: in EAX.
# pragma warning(disable: 4035)
#endif

// Workarounds for certain useful interlocked operations that are not
// available on Windows 95. Note: the CMPXCHG and XADD instructions were
// introduced in the 80486. If you still need to run on a 386 (unlikely in
// 2000), you'll need to use something else.

LOCK_FORCEINLINE
LONG
Lock_AtomicIncrement(
    IN OUT PLONG plAddend)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddend
             mov        eax,    1
        lock xadd       [ecx],  eax
             inc        eax                 // correct result
    }
#else
    return InterlockedIncrement(plAddend);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicDecrement(
    IN OUT PLONG plAddend)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddend
             mov        eax,    -1
        lock xadd       [ecx],  eax
             dec        eax                 // correct result
    }
#else
    return InterlockedDecrement(plAddend);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        edx,    lNew
             mov        eax,    [ecx]
    LAEloop:
        lock cmpxchg    [ecx],  edx
             jnz        LAEloop
    }
#else
    return InterlockedExchange(plAddr, lNew);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicCompareExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew,
    IN LONG      lCurrent)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        edx,    lNew
             mov        eax,    lCurrent
        lock cmpxchg    [ecx],  edx
    }
#else
    return InterlockedCompareExchange(plAddr, lNew, lCurrent);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicExchangeAdd(
    IN OUT LPLONG plAddr,
    IN LONG       lValue)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        eax,    lValue
        lock xadd       [ecx],  eax
    }
#else
    return InterlockedExchangeAdd(plAddr, lValue);
#endif
}



#ifdef _M_IX86
# pragma warning(default: 4035)
// Makes tight loops a little more cache friendly and reduces power
// consumption. Needed on Willamette processors.
# define Lock_Yield()    _asm { rep nop }
#else
# define Lock_Yield()    ((void) 0)
#endif



//--------------------------------------------------------------------
// Spin count values.
enum LOCK_SPINS {
    LOCK_MAXIMUM_SPINS =      10000,    // maximum allowable spin count
    LOCK_DEFAULT_SPINS =       4000,    // default spin count
    LOCK_MINIMUM_SPINS =        100,    // minimum allowable spin count
    LOCK_USE_DEFAULT_SPINS = 0xFFFF,    // use class default spin count
    LOCK_DONT_SPIN =              0,    // don't spin at all
};


// Boilerplate code for the per-class default spincount and spinfactor

#define LOCK_DEFAULT_SPIN_IMPLEMENTATION()                                  \
protected:                                                                  \
    /* per-class variables */                                               \
    static   WORD   sm_wDefaultSpinCount;   /* global default spin count */   \
    static   double sm_dblDfltSpinAdjFctr;  /* global spin adjustment factor*/\
                                                                            \
public:                                                                     \
    /* Set the default spin count for all locks */                          \
    static void SetDefaultSpinCount(WORD wSpins)                            \
    {                                                                       \
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)                               \
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)                    \
                   || (LOCK_MINIMUM_SPINS <= wSpins                         \
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));                  \
                                                                            \
        if ((LOCK_MINIMUM_SPINS <= wSpins  &&  wSpins <= LOCK_MAXIMUM_SPINS)\
                || (wSpins == LOCK_DONT_SPIN))                              \
            sm_wDefaultSpinCount = wSpins;                                  \
        else if (wSpins == LOCK_USE_DEFAULT_SPINS)                          \
            sm_wDefaultSpinCount = LOCK_DEFAULT_SPINS;                      \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static WORD GetDefaultSpinCount()                                       \
    {                                                                       \
        return sm_wDefaultSpinCount;                                        \
    }                                                                       \
                                                                            \
    /* Set the adjustment factor for the spincount, used in each iteration */\
    /* of countdown-and-sleep by the backoff algorithm. */                  \
    static void SetDefaultSpinAdjustmentFactor(double dblAdjFactor)         \
    {                                                                       \
        IRTLASSERT(0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0);          \
        if (0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0)                  \
            sm_dblDfltSpinAdjFctr = dblAdjFactor;                           \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static double GetDefaultSpinAdjustmentFactor()                          \
    {                                                                       \
        return sm_dblDfltSpinAdjFctr;                                       \
    }                                                                       \



//--------------------------------------------------------------------
// Various Lock Traits

// Is the lock a simple mutex or a multi-reader/single-writer lock?
enum LOCK_RW_MUTEX {
    LOCK_MUTEX = 1,         // mutexes allow only one thread to hold the lock
    LOCK_MRSW,              // multi-reader, single-writer
};


// Can the lock be recursively acquired?
enum LOCK_RECURSION {
    LOCK_RECURSIVE = 1,     // Write and Read locks can be recursively acquired
    LOCK_READ_RECURSIVE,    // Read locks can be reacquired, but not Write
    LOCK_NON_RECURSIVE,     // Will deadlock if attempt to acquire recursively
};


// Does the lock Sleep in a loop or block on a kernel synch object handle?
// May (or may not) spin first before sleeping/blocking.
enum LOCK_WAIT_TYPE {
    LOCK_WAIT_SLEEP = 1,    // Calls Sleep() in a loop
    LOCK_WAIT_HANDLE,       // Blocks on a kernel mutex, semaphore, or event
};


// When the lock is taken, how are the waiters dequeued?
enum LOCK_QUEUE_TYPE {
    LOCK_QUEUE_FIFO = 1,    // First in, first out.  Fair.
    LOCK_QUEUE_LIFO,        // Unfair but CPU cache friendly
    LOCK_QUEUE_KERNEL,      // Determined by vagaries of scheduler
};


// Can the lock's spincount be set on a per-lock basis, or is it only
// possible to modify the default spincount for all the locks in this class?
enum LOCK_PERLOCK_SPIN {
    LOCK_NO_SPIN = 1,       // The locks do not spin at all
    LOCK_CLASS_SPIN,        // Can set class-wide spincount, not individual
    LOCK_INDIVIDUAL_SPIN,   // Can set a spincount on an individual lock
};


//--------------------------------------------------------------------
// CLockBase: bundle the above attributes

template < LOCK_LOCKTYPE     locktype,
           LOCK_RW_MUTEX     mutextype,
           LOCK_RECURSION    recursiontype,
           LOCK_WAIT_TYPE    waittype,
           LOCK_QUEUE_TYPE   queuetype,
           LOCK_PERLOCK_SPIN spintype
         >
class CLockBase
{
public:
    static LOCK_LOCKTYPE     LockType()     {return locktype;}
    static LOCK_RW_MUTEX     MutexType()    {return mutextype;}
    static LOCK_RECURSION    Recursion()    {return recursiontype;}
    static LOCK_WAIT_TYPE    WaitType()     {return waittype;}
    static LOCK_QUEUE_TYPE   QueueType()    {return queuetype;}
    static LOCK_PERLOCK_SPIN PerLockSpin()  {return spintype;}
};



// Lock instrumentation causes all sorts of interesting statistics about
// lock contention, etc., to be gathered, but makes locks considerably fatter
// and somewhat slower.  Turned off by default.

// #define LOCK_INSTRUMENTATION 1

#ifdef LOCK_INSTRUMENTATION

// We generally don't want to instrument CSmallSpinLock in addition
// to CSpinLock1, as it makes a CSpinLock1 huge.

// #define LOCK_SMALL_SPIN_INSTRUMENTATION 1

//--------------------------------------------------------------------
// CLockStatistics: statistics for an individual lock

class IRTL_DLLEXP CLockStatistics
{
public:
    enum {
        L_NAMELEN = 8,
    };
    
    double   m_nContentions;     // #times this lock was already locked
    double   m_nSleeps;          // Total #Sleep()s needed
    double   m_nContentionSpins; // Total iterations this lock spun
    double   m_nAverageSpins;    // Average spins each contention needed
    double   m_nReadLocks;       // Number of times lock acquired for reading
    double   m_nWriteLocks;      // Number of times lock acquired for writing
    TCHAR    m_tszName[L_NAMELEN];// Name of this lock

    CLockStatistics()
        : m_nContentions(0),
          m_nSleeps(0),
          m_nContentionSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {
        m_tszName[0] = _TEXT('\0');
    }
};



//--------------------------------------------------------------------
// CGlobalLockStatistics: statistics for all the known locks

class IRTL_DLLEXP CGlobalLockStatistics
{
public:
    LONG     m_cTotalLocks;     // Total number of locks created
    LONG     m_cContendedLocks; // Total number of contended locks
    LONG     m_nSleeps;         // Total #Sleep()s needed by all locks
    LONGLONG m_cTotalSpins;     // Total iterations all locks spun
    double   m_nAverageSpins;   // Average spins needed for each contended lock
    LONG     m_nReadLocks;      // Total ReadLocks
    LONG     m_nWriteLocks;     // Total WriteLocks

    CGlobalLockStatistics()
        : m_cTotalLocks(0),
          m_cContendedLocks(0),
          m_nSleeps(0),
          m_cTotalSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {}
};

# define LOCK_INSTRUMENTATION_DECL() \
private:                                                                    \
    volatile LONG   m_nContentionSpins; /* #iterations this lock spun */    \
    volatile WORD   m_nContentions;     /* #times lock was already locked */\
    volatile WORD   m_nSleeps;          /* #Sleep()s needed */              \
    volatile WORD   m_nReadLocks;       /* #ReadLocks */                    \
    volatile WORD   m_nWriteLocks;      /* #WriteLocks */                   \
    TCHAR           m_tszName[CLockStatistics::L_NAMELEN]; /* Name of lock */\
                                                                            \
    static   LONG   sm_cTotalLocks;     /* Total number of locks created */ \
    static   LONG   sm_cContendedLocks; /* Total number of contended locks */\
    static   LONG   sm_nSleeps;         /* Total #Sleep()s by all locks */  \
    static LONGLONG sm_cTotalSpins;     /* Total iterations all locks spun */\
    static   LONG   sm_nReadLocks;      /* Total ReadLocks */               \
    static   LONG   sm_nWriteLocks;     /* Total WriteLocks */              \
                                                                            \
public:                                                                     \
    const TCHAR* Name() const       {return m_tszName;}                     \
                                                                            \
    CLockStatistics                 Statistics() const;                     \
    static CGlobalLockStatistics    GlobalStatistics();                     \
    static void                     ResetGlobalStatistics();                \
private:                                                                    \


// Add this to constructors

# define LOCK_INSTRUMENTATION_INIT(ptszName)        \
    m_nContentionSpins = 0;                         \
    m_nContentions = 0;                             \
    m_nSleeps = 0;                                  \
    m_nReadLocks = 0;                               \
    m_nWriteLocks = 0;                              \
    ++sm_cTotalLocks;                               \
    if (ptszName == NULL)                           \
        m_tszName[0] = _TEXT('\0');                 \
    else                                            \
        _tcsncpy(m_tszName, ptszName, sizeof(m_tszName)/sizeof(TCHAR))

// Note: we are not using Interlocked operations for the shared
// statistical counters.  We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.

# define LOCK_READLOCK_INSTRUMENTATION()    \
      { ++m_nReadLocks;                     \
        ++sm_nReadLocks; }

# define LOCK_WRITELOCK_INSTRUMENTATION()   \
      { ++m_nWriteLocks;                    \
        ++sm_nWriteLocks; }

#else // !LOCK_INSTRUMENTATION

# define LOCK_INSTRUMENTATION_DECL()
# define LOCK_READLOCK_INSTRUMENTATION()    ((void) 0)
# define LOCK_WRITELOCK_INSTRUMENTATION()   ((void) 0)

#endif // !LOCK_INSTRUMENTATION



//--------------------------------------------------------------------
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> provide exception-safe
// acquisition and release of the other locks defined below

template <class _Lock>
class IRTL_DLLEXP CAutoReadLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoReadLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }
    ~CAutoReadLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.ReadLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_Lock.ReadUnlock();
            m_fLocked = false;
        }
    }
};



template <class _Lock>
class IRTL_DLLEXP CAutoWriteLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoWriteLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }

    ~CAutoWriteLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.WriteLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_fLocked = false;
            m_Lock.WriteUnlock();
        }
    }
};




//--------------------------------------------------------------------
// A spinlock is a sort of lightweight critical section.  Its main
// advantage over a true Win32 CRITICAL_SECTION is that it occupies 4 bytes
// instead of 24 (+ another 32 bytes for the RTL_CRITICAL_SECTION_DEBUG data),
// which is important when we have many thousands of locks
// and we're trying to be L1 cache-conscious.  A CRITICAL_SECTION also
// contains a HANDLE to a semaphore, although this is not initialized until
// the first time that the CRITICAL_SECTION blocks.
//
// On a multiprocessor machine, a spinlock tries to acquire the lock.  If
// it fails, it sits in a tight loop, testing the lock and decrementing a
// counter.  If the counter reaches zero, it does a Sleep(0), yielding the
// processor to another thread.  When control returns to the thread, the
// lock is probably free.  If not, the loop starts again and it is
// terminated only when the lock is acquired.  The theory is that it is
// less costly to spin in a busy loop for a short time rather than
// immediately yielding the processor, forcing an expensive context switch
// that requires the old thread's state (registers, etc) be saved, the new
// thread's state be reloaded, and the L1 and L2 caches be left full of
// stale data.
//
// You can tune the spin count (global only: per-lock spin counts are 
// disabled) and the backoff algorithm (the factor by which the spin
// count is multiplied after each Sleep).
//
// On a 1P machine, the loop is pointless---this thread has control,
// hence no other thread can possibly release the lock while this thread
// is looping---so the processor is yielded immediately.
//
// The kernel uses spinlocks internally and spinlocks were also added to
// CRITICAL_SECTIONs in NT 4.0 sp3.  In the CRITICAL_SECTION implementation,
// however, the counter counts down only once and waits on a semaphore
// thereafter (i.e., the same blocking behavior that it exhibits without
// the spinlock).
//
// A disadvantage of a user-level spinlock such as this is that if the
// thread that owns the spinlock blocks for any reason (or is preempted by
// the scheduler), all the other threads will continue to spin on the
// spinlock, wasting CPU, until the owning thread completes its wait and
// releases the lock.  (The kernel spinlocks, however, are smart enough to
// switch to another runnable thread instead of wasting time spinning.)
// The backoff algorithm decreases the spin count on each iteration in an
// attempt to minimize this effect.  The best policy---and this is true for
// all locks---is to hold the lock for as short as time as possible.
//
// Note: unlike a CRITICAL_SECTION, a CSmallSpinLock cannot be recursively
// acquired; i.e., if you acquire a spinlock and then attempt to acquire it
// again *on the same thread* (perhaps from a different function), the
// thread will hang forever.  Use CSpinLock instead, which is safe though a
// little slower than a CSmallSpinLock.  If you own all the code
// that is bracketed by Lock() and Unlock() (e.g., no callbacks or passing
// back of locked data structures to callers) and know for certain that it
// will not attempt to reacquire the lock, you can use CSmallSpinLock.
//
// See also http://muralik/work/performance/spinlocks.htm and John Vert's
// MSDN article, "Writing Scalable Applications for Windows NT".
//
// The original implementation is due to PALarson.

class IRTL_DLLEXP CSmallSpinLock :
    public CLockBase<LOCK_SMALLSPINLOCK, LOCK_MUTEX,
                       LOCK_NON_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lTid;              // The lock state variable

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_DECL();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        return (LONG) (dwTid);
    }

private:
    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

    LOCK_FORCEINLINE bool _TryLock()
    {
        if (m_lTid == 0)
        {
            LONG l = _CurrentThreadId();

            return (Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lTid), l,0)
                    == 0);
        }
        else
            return false;
    }

public:

#ifndef LOCK_SMALL_SPIN_INSTRUMENTATION

    CSmallSpinLock()
        : m_lTid(0)
    {}

#else // LOCK_SMALL_SPIN_INSTRUMENTATION

    CSmallSpinLock(
        const TCHAR* ptszName)
        : m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }

#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CSmallSpinLock()
    {
        IRTLASSERT(m_lTid == 0);
    }
#endif // IRTLDEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    inline void WriteLock()
    {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        LOCK_WRITELOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        // Optimize for the common case by helping the processor's branch
        // prediction algorithm.
        if (_TryLock())
            return;

        _LockSpin();
    }

    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    inline void ReadLock()
    {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        LOCK_READLOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        if (_TryLock())
            return;

        _LockSpin();
    }

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        bool fAcquired = _TryLock();

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        bool fAcquired = _TryLock();

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    // Assumes caller owned the lock.
    inline void WriteUnlock()
    {
        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 0);
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    // Assumes caller owned the lock.
    inline void ReadUnlock()
    {
        WriteUnlock();
    }

    // Is the lock already locked for writing by this thread?
    bool IsWriteLocked() const
    {
        return (m_lTid == _CurrentThreadId());
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return IsWriteLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return (m_lTid == 0);
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return IsWriteUnlocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }

    // Set the spin count for this lock.
    // Returns true if successfully set the per-lock spincount, false otherwise
    bool SetSpinCount(WORD wSpins)
    {
        UNREFERENCED_PARAMETER(wSpins);
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)
                   || (LOCK_MINIMUM_SPINS <= wSpins
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));

        return false;
    }

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()  {return _TEXT("CSmallSpinLock");}
}; // CSmallSpinLock




//--------------------------------------------------------------------
// CSpinLock is a spinlock that doesn't deadlock if recursively acquired.
// This version occupies only 4 bytes.  Uses 28 bits for the thread id.

class IRTL_DLLEXP CSpinLock :
    public CLockBase<LOCK_SPINLOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    // a union for convenience
    volatile LONG m_lTid;

    enum {
        THREAD_SHIFT = 0,
        THREAD_BITS  = 28,
        OWNER_SHIFT  = THREAD_BITS,
        OWNER_BITS   = 4,
        THREAD_MASK  = ((1 << THREAD_BITS) - 1) << THREAD_SHIFT,
        OWNER_INCR   = 1 << THREAD_BITS,
        OWNER_MASK   = ((1 << OWNER_BITS) - 1) << OWNER_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    // Get the current thread ID.  Assumes that it can fit into 28 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit into
    // 28 bits would mean that more than 268,435,456 threads were currently
    // active.  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        // Thread ID 0 is used by the System Idle Process (Process ID 0).
        // We use a thread-id of zero to indicate that the lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        IRTLASSERT(dwTid != 0
                   && ((dwTid <= THREAD_MASK) || (dwTid > ~THREAD_MASK)));
        return (LONG) (dwTid & THREAD_MASK);
    }

    // Attempt to acquire the lock without blocking
    LOCK_FORCEINLINE bool _TryLock()
    {
        if (m_lTid == 0)
        {
            LONG l = _CurrentThreadId() | OWNER_INCR;

            return (Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lTid), l,0)
                    == 0);
        }
        else
            return false;
    }


    // Acquire the lock, recursively if need be
    void _Lock()
    {
        // Do we own the lock already?  Just bump the count.
        if ((m_lTid & THREAD_MASK) == _CurrentThreadId())
        {
            // owner count isn't maxed out?
            IRTLASSERT((m_lTid & OWNER_MASK) != OWNER_MASK);

            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid),
                                m_lTid + OWNER_INCR);
        }

        // Some other thread owns the lock.  We'll have to spin :-(.
        else
            _LockSpin();

        IRTLASSERT((m_lTid & OWNER_MASK) > 0
                   &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());
    }


    // Release the lock
    LOCK_FORCEINLINE void _Unlock()
    {
        IRTLASSERT((m_lTid & OWNER_MASK) > 0
                   &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());

        LONG l = m_lTid - OWNER_INCR; 

        // Last owner?  Release completely, if so
        if ((l & OWNER_MASK) == 0)
            l = 0;

        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), l);
    }


    // Return true if the lock is owned by this thread
    bool _IsLocked() const
    {
        bool fLocked = ((m_lTid & THREAD_MASK) == _CurrentThreadId());

        IRTLASSERT(!fLocked || ((m_lTid & OWNER_MASK) > 0
                               && (m_lTid & THREAD_MASK)==_CurrentThreadId()));

        return fLocked;
    }


    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

public:

#ifndef LOCK_INSTRUMENTATION

    CSpinLock()
        : m_lTid(0)
    {}

#else // LOCK_INSTRUMENTATION

    CSpinLock(
        const TCHAR* ptszName)
        : m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }

#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CSpinLock()
    {
        IRTLASSERT(m_lTid == 0);
    }
#endif // IRTLDEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock
        
        _Lock();
    }
    

    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock
        
        _Lock();
    }

    // See the description under CReaderWriterLock3::ReadOrWriteLock
    inline bool ReadOrWriteLock()
    {
        ReadLock();
        return true;
    } 

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    inline void WriteUnlock()
    {
        _Unlock();
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    inline void ReadUnlock()
    {
        _Unlock();
    }

    // Unlock the lock after a call to ReadOrWriteLock().
    inline void ReadOrWriteUnlock(bool)
    {
        ReadUnlock();
    } 

    // Is the lock already locked for writing?
    bool IsWriteLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return !IsWriteLocked();
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return !IsReadLocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }
    
    // Set the spin count for this lock.
    bool SetSpinCount(WORD)             {return false;}

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CSpinLock");}
}; // CSpinLock




//--------------------------------------------------------------------
// A dummy class, primarily useful as a template parameter

class IRTL_DLLEXP CFakeLock :
    public CLockBase<LOCK_FAKELOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_FIFO,
                       LOCK_NO_SPIN
                      >
{
private:
    LOCK_INSTRUMENTATION_DECL();

public:
    CFakeLock()                     {} 
#ifdef LOCK_INSTRUMENTATION
    CFakeLock(const char*)          {}
#endif // LOCK_INSTRUMENTATION
    ~CFakeLock()                    {} 
    void WriteLock()                {} 
    void ReadLock()                 {} 
    bool ReadOrWriteLock()          {return true;} 
    bool TryWriteLock()             {return true;} 
    bool TryReadLock()              {return true;} 
    void WriteUnlock()              {}
    void ReadUnlock()               {}
    void ReadOrWriteUnlock(bool)    {}
    bool IsWriteLocked() const      {return true;} 
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}
    bool IsReadUnlocked() const     {return true;}
    void ConvertSharedToExclusive() {}
    void ConvertExclusiveToShared() {}
    bool SetSpinCount(WORD)         {return false;}
    WORD GetSpinCount() const       {return LOCK_DONT_SPIN;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()  {return _TEXT("CFakeLock");}
}; // CFakeLock




//--------------------------------------------------------------------
// A Win32 CRITICAL_SECTION

class IRTL_DLLEXP CCritSec :
    public CLockBase<LOCK_CRITSEC, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_INDIVIDUAL_SPIN
                      >
{
private:
    CRITICAL_SECTION m_cs;

    LOCK_INSTRUMENTATION_DECL();

public:
    CCritSec()
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#ifdef LOCK_INSTRUMENTATION
    CCritSec(const char*)
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#endif // LOCK_INSTRUMENTATION
    ~CCritSec()         { DeleteCriticalSection(&m_cs); }

    void WriteLock()    { EnterCriticalSection(&m_cs); }
    void ReadLock()     { WriteLock(); }
    bool ReadOrWriteLock() { ReadLock(); return true; } 
    bool TryWriteLock();
    bool TryReadLock()  { return TryWriteLock(); }
    void WriteUnlock()  { LeaveCriticalSection(&m_cs); }
    void ReadUnlock()   { WriteUnlock(); }
    void ReadOrWriteUnlock(bool) { ReadUnlock(); } 

    bool IsWriteLocked() const      {return true;}  // TODO: fix this
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}  // TODO: fix this
    bool IsReadUnlocked() const     {return true;}  // TODO: fix this

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }
    
    // Wrapper for ::SetCriticalSectionSpinCount which was introduced
    // in NT 4.0 sp3 and hence is not available on all platforms
    static DWORD SetSpinCount(LPCRITICAL_SECTION pcs,
                              DWORD dwSpinCount=LOCK_DEFAULT_SPINS);

    bool SetSpinCount(WORD wSpins)
    {SetSpinCount(&m_cs, wSpins); return true;}
    
    WORD GetSpinCount() const       { return sm_wDefaultSpinCount; }    // TODO

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()  {return _TEXT("CCritSec");}
}; // CCritSec




//--------------------------------------------------------------------
// CReaderWriterlock is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. Use CReaderWriterLock3.

class IRTL_DLLEXP CReaderWriterLock :
    public CLockBase<LOCK_READERWRITERLOCK, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile  LONG  m_nState;   // > 0 => that many readers
    volatile  LONG  m_cWaiting; // number of would-be writers

    LOCK_INSTRUMENTATION_DECL();

private:
    enum {
        SL_FREE = 0,
        SL_EXCLUSIVE = -1,
    };

    void _LockSpin(bool fWrite);
    void _WriteLockSpin() { _LockSpin(true); }
    void _ReadLockSpin()  { _LockSpin(false); }

    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent == Lock_AtomicCompareExchange(
                                 const_cast<LONG*>(&m_nState), lNew, lCurrent);
    }

    LOCK_FORCEINLINE bool _TryWriteLock()
    {
        return (m_nState == SL_FREE  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE));
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        LONG nCurrState = m_nState;
                
        // Give writers priority
        return (nCurrState != SL_EXCLUSIVE  &&  m_cWaiting == 0
                &&  _CmpExch(nCurrState + 1, nCurrState));
    }

public:
    CReaderWriterLock()
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
    }

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock(
        const TCHAR* ptszName)
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock()
    {
        IRTLASSERT(m_nState == SL_FREE  &&  m_cWaiting == 0);
    }
#endif // IRTLDEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Add ourselves to the queue of waiting writers
        Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));
        
        if (_TryWriteLock())
            return;

        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    inline bool TryWriteLock()
    {
        // Add ourselves to the queue of waiting writers
        Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));

        if (_TryWriteLock())
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
        return false;    
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        Lock_AtomicExchange(const_cast<LONG*>(&m_nState), SL_FREE);
        Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
    }

    inline void ReadUnlock()
    {
        Lock_AtomicDecrement(const_cast<LONG*>(&m_nState));
    }

    bool IsWriteLocked() const      {return m_nState == SL_EXCLUSIVE;}
    bool IsReadLocked() const       {return m_nState > SL_FREE;}
    bool IsWriteUnlocked() const    {return m_nState != SL_EXCLUSIVE;}
    bool IsReadUnlocked() const     {return m_nState <= SL_FREE;}

    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());
        Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));

        // single reader?
        if (m_nState == SL_FREE + 1  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE + 1))
            return;

        // release the reader lock and spin
        Lock_AtomicDecrement(const_cast<LONG*>(&m_nState));
        _WriteLockSpin();

        IRTLASSERT(IsWriteLocked());
    }

    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());
        Lock_AtomicExchange(const_cast<LONG*>(&m_nState), SL_FREE + 1);
        Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD)             {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock");}
}; // CReaderWriterLock



//--------------------------------------------------------------------
// CReaderWriterlock2 is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. The difference between this and CReaderWriterLock is
// that all the state is packed into a single LONG, instead of two LONGs.

class IRTL_DLLEXP CReaderWriterLock2 :
    public CLockBase<LOCK_READERWRITERLOCK2, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;

    // LoWord is state. ==0 => free; >0 => readers; ==0xFFFF => 1 writer.
    // HiWord is count of writers, W.
    //      If LoWord==0xFFFF => W-1 waiters, 1 writer;
    //      otherwise W waiters.
    enum {
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    void _LockSpin(bool fWrite);
    void _WriteLockSpin();
    void _ReadLockSpin()  { _LockSpin(false); }

    
    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent ==Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lRW),
                                                     lNew, lCurrent);
    }

    LOCK_FORCEINLINE bool _TryWriteLock(
        LONG nIncr)
    {
        LONG l = m_lRW;
        // Grab exclusive access to the lock if it's free.  Works even
        // if there are other writers queued up.
        return ((l & SL_STATE_MASK) == SL_FREE
                &&  _CmpExch((l + nIncr) | SL_EXCLUSIVE, l));
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        LONG l = m_lRW;
                
        // Give writers priority
        return ((l & SL_WRITERS_MASK) == 0
                &&  _CmpExch(l + SL_READER_INCR, l));
    }

public:
    CReaderWriterLock2()
        : m_lRW(SL_FREE)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock2(
        const TCHAR* ptszName)
        : m_lRW(SL_FREE)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock2()
    {
        IRTLASSERT(m_lRW == SL_FREE);
    }
#endif // IRTLDEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryWriteLock(SL_WRITER_INCR))
            return;
        
        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    inline bool TryWriteLock()
    {
        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        IRTLASSERT(IsWriteLocked());
        for (LONG l = m_lRW;
                    // decrement waiter count, clear loword to SL_FREE
             !_CmpExch((l - SL_WRITER_INCR) & ~SL_STATE_MASK, l);
             l = m_lRW)
        {
            IRTLASSERT(IsWriteLocked());
            Lock_Yield();
        }
    }

    inline void ReadUnlock()
    {
        IRTLASSERT(IsReadLocked());
        for (LONG l = m_lRW;  !_CmpExch(l - SL_READER_INCR, l);  l = m_lRW)
        {
            IRTLASSERT(IsReadLocked());
            Lock_Yield();
        }
    }

    bool IsWriteLocked() const
    {return (m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE;}

    bool IsReadLocked() const
    {return (m_lRW & SL_READER_MASK) >= SL_READER_INCR ;}

    bool IsWriteUnlocked() const
    {return !IsWriteLocked();}

    bool IsReadUnlocked() const
    {return !IsReadLocked();}

    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());

        // single reader?
        if (m_lRW != SL_ONE_READER  ||  !_CmpExch(SL_ONE_WRITER,SL_ONE_READER))
        {
            // no, multiple readers
            ReadUnlock();
            _WriteLockSpin();
        }

        IRTLASSERT(IsWriteLocked());
    }

    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());
        for (LONG l = m_lRW;
             !_CmpExch(((l-SL_WRITER_INCR) & SL_WAITING_MASK) | SL_READER_INCR,
                         l);
            l = m_lRW)
        {
            IRTLASSERT(IsWriteLocked());
            Lock_Yield();
        }

        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD)             {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock2");}
}; // CReaderWriterLock2



//--------------------------------------------------------------------
// CReaderWriterLock3 is a multi-reader, single-writer spinlock due
// to NJain, which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. Much like CReaderWriterLock2, except that the WriteLock
// can be acquired recursively.

class IRTL_DLLEXP CReaderWriterLock3 :
    public CLockBase<LOCK_READERWRITERLOCK3, LOCK_MRSW,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;    // Reader-Writer state
    volatile LONG m_lTid;   // Owning Thread ID + recursion count

    // m_lRW:
    //  LoWord is state. =0 => free; >0 => readers; ==0xFFFF => 1 writer
    //  HiWord is count of writers. If LoWord==0xFFFF => N-1 waiters, 1 writer;
    //      otherwise N waiters.
    // m_lTid:
    //  If readers, then 0; if a write lock, then thread id + recursion count

    enum {
        // m_lRW
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,

        // m_lTid
        SL_THREAD_SHIFT = 0,
        SL_THREAD_BITS  = 28,
        SL_OWNER_SHIFT  = SL_THREAD_BITS,
        SL_OWNER_BITS   = 4,
        SL_THREAD_MASK  = ((1 << SL_THREAD_BITS) - 1) << SL_THREAD_SHIFT,
        SL_OWNER_INCR   = 1 << SL_THREAD_BITS,
        SL_OWNER_MASK   = ((1 << SL_OWNER_BITS) - 1) << SL_OWNER_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    enum SPIN_TYPE {
        SPIN_WRITE = 1,
        SPIN_READ,
        SPIN_READ_RECURSIVE,
    };

    void _LockSpin(SPIN_TYPE st);
    void _WriteLockSpin();
    void _ReadLockSpin(SPIN_TYPE st)  { _LockSpin(st); }

    
    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent==Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lRW),
                                                    lNew, lCurrent);
    }

    // Get the current thread ID.  Assumes that it can fit into 28 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit into
    // 28 bits would mean that more than 268,435,456 threads were currently
    // active.  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    inline static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        // Thread ID 0 is used by the System Idle Process (Process ID 0).
        // We use a thread-id of zero to indicate lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        IRTLASSERT(dwTid != 0
                  && ((dwTid <= SL_THREAD_MASK) || (dwTid > ~SL_THREAD_MASK)));
        return (LONG) (dwTid & SL_THREAD_MASK);
    }

    LOCK_FORCEINLINE bool _TryWriteLock(
        LONG nIncr)
    {
        // The common case: the writelock has no owner
        if (m_lTid == 0)
        {
            // IRTLASSERT((m_lRW & SL_STATE_MASK) != SL_EXCLUSIVE);
            LONG l = m_lRW;
            // Grab exclusive access to the lock if it's free.  Works even
            // if there are other writers queued up.
            if ((l & SL_STATE_MASK) == SL_FREE
                &&  _CmpExch((l + nIncr) | SL_EXCLUSIVE, l))
            {
                l = Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 
                                        _CurrentThreadId() | SL_OWNER_INCR);
                IRTLASSERT(l == 0);
                return true;
            }
        }

        return _TryWriteLock2();
    }

    // split into a separate function to make _TryWriteLock more inlineable
    bool _TryWriteLock2()
    {
        if ((m_lTid & SL_THREAD_MASK) == _CurrentThreadId())
        {
            IRTLASSERT((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE);
            IRTLASSERT((m_lTid & SL_OWNER_MASK) != SL_OWNER_MASK);

            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid),
                                m_lTid + SL_OWNER_INCR);
            return true;
        }

        return false;
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        // Give writers priority
        LONG l = m_lRW;
        bool fLocked = (((l & SL_WRITERS_MASK) == 0)
                        &&  _CmpExch(l + SL_READER_INCR, l));
        IRTLASSERT(!fLocked  ||  m_lTid == 0);
        return fLocked;
    }

    LOCK_FORCEINLINE bool _TryReadLockRecursive()
    {
        // Do *not* give writers priority. If the inner call attempts
        // to reacquire the read lock while another thread is waiting on
        // the write lock, we would deadlock if we waited for the queue
        // of writers to empty: the writer(s) can't acquire the lock
        // exclusively, as this thread holds a readlock. The inner call
        // typically releases the lock very quickly, so there is no
        // danger of writer starvation.
        LONG l = m_lRW;
        bool fLocked = (((l & SL_STATE_MASK) != SL_EXCLUSIVE)
                        &&  _CmpExch(l + SL_READER_INCR, l));
        IRTLASSERT(!fLocked  ||  m_lTid == 0);
        return fLocked;
    }

public:
    CReaderWriterLock3()
        : m_lRW(SL_FREE),
          m_lTid(0)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock3(
        const TCHAR* ptszName)
        : m_lRW(SL_FREE),
          m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock3()
    {
        IRTLASSERT(m_lRW == SL_FREE  &&  m_lTid == 0);
    }
#endif // IRTLDEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryWriteLock(SL_WRITER_INCR))
            return;
        
        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryReadLock())
            return;
        
        _ReadLockSpin(SPIN_READ);
    } 

    // If already locked, recursively acquires another lock of the same
    // kind (read or write). Otherwise, just acquires a read lock.
    // Needed for cases like this.
    //      pTable->WriteLock();
    //      if (!pTable->FindKey(&SomeKey))
    //          InsertRecord(&Whatever);
    //      pTable->WriteUnlock();
    // where FindKey looks like
    //  Table::FindKey(pKey) {
    //      ReadOrWriteLock();
    //      // find pKey if present in table
    //      ReadOrWriteUnlock();
    //  }
    // and InsertRecord looks like
    //  Table::InsertRecord(pRecord) {
    //      WriteLock();
    //      // insert pRecord into table
    //      WriteUnlock();
    //  }
    // If FindKey called ReadLock while the thread already had done a
    // WriteLock, the thread would deadlock.
    
    inline bool ReadOrWriteLock()
    {
        if (IsWriteLocked())
        {
            WriteLock();
            return false;   // => not read locked
        }
        else
        {
            LOCK_READLOCK_INSTRUMENTATION();

            if (!_TryReadLockRecursive())
                _ReadLockSpin(SPIN_READ_RECURSIVE);
            
            return true;   // => is read locked
        }
    } 

    inline bool TryWriteLock()
    {
        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        IRTLASSERT(IsWriteLocked());
        LONG lNew = m_lTid - SL_OWNER_INCR; 

        // Last owner?  Release completely, if so
        if ((lNew & SL_OWNER_MASK) == 0)
            lNew = 0;

        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), lNew);

        if (lNew == 0)
        {
            LONG l;
            do 
            {
                Lock_Yield();
                l = m_lRW;
                // decrement waiter count, clear loword to SL_FREE
            }
            while (!_CmpExch((l - SL_WRITER_INCR) & ~SL_STATE_MASK, l));
        }
    }

    inline void ReadUnlock()
    {
        IRTLASSERT(IsReadLocked());
        for (LONG l = m_lRW;  !_CmpExch(l - SL_READER_INCR, l);  l = m_lRW)
        {
            IRTLASSERT(IsReadLocked());
            Lock_Yield();
        }
    }

    inline void ReadOrWriteUnlock(bool fIsReadLocked)
    {
        if (fIsReadLocked)
            ReadUnlock();
        else
            WriteUnlock();
    } 

    // Does current thread hold a write lock?
    bool IsWriteLocked() const
    {
        // bool fLocked = ((m_lTid & SL_THREAD_MASK) == _CurrentThreadId());
        bool fLocked = ((m_lTid ^ GetCurrentThreadId()) & SL_THREAD_MASK) == 0;
        IRTLASSERT(!fLocked  || (((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE)
                                 &&  ((m_lTid & SL_OWNER_MASK) > 0)));
        return fLocked;
    }

    bool IsReadLocked() const
    {return (m_lRW & SL_READER_MASK) >= SL_READER_INCR ;}

    bool IsWriteUnlocked() const
    {return !IsWriteLocked();}

    bool IsReadUnlocked() const
    {return !IsReadLocked();}

    // Note: if there's more than one reader, then there's a window where
    // another thread can acquire and release a writelock before this routine
    // returns.
    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());

        // single reader?
        if (m_lRW == SL_ONE_READER  &&  _CmpExch(SL_ONE_WRITER, SL_ONE_READER))
        {
            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 
                                _CurrentThreadId() | SL_OWNER_INCR);
        }
        else
        {
            // no, multiple readers
            ReadUnlock();
            _WriteLockSpin();
        }

        IRTLASSERT(IsWriteLocked());
    }

    // There is no such window when converting from a writelock to a readlock
    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());

        // assume writelock is not held recursively
        IRTLASSERT((m_lTid & SL_OWNER_MASK) == SL_OWNER_INCR);
        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 0);

        for (LONG l = m_lRW;
             !_CmpExch(((l-SL_WRITER_INCR) & SL_WAITING_MASK) | SL_READER_INCR,
                        l);
             l = m_lRW)
        {
            Lock_Yield();
        }

        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD)             {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock3");}
}; // CReaderWriterLock3


#endif // __LOCKS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

xeventids.h: ..\events\$(_OBJ_DIR)\xeventids.h
	copy ..\events\$(_OBJ_DIR)\xeventids.h $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\lkrhash.h ===
/*++

   Copyright    (c) 1998-2001    Microsoft Corporation

   Module  Name :
       LKRhash.h

   Abstract:
       Declares LKRhash: a fast, scalable, cache- and MP-friendly hash table

   Author:
       Paul (Per-Ake) Larson, palarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       10/01/1998 - Change name from LKhash to LKRhash

--*/


#define LKR_STL_ITERATORS 1
// #define LKR_DEPRECATED_ITERATORS
#define LKR_APPLY_IF
#undef  LKR_COUNTDOWN

#ifndef LKR_TABLE_LOCK
# define LKR_TABLE_LOCK  CReaderWriterLock3 
#endif // !LKR_TABLE_LOCK

#ifndef LKR_BUCKET_LOCK
# ifdef LKR_DEPRECATED_ITERATORS
#  define LKR_BUCKET_LOCK CReaderWriterLock3 
# else // !LKR_DEPRECATED_ITERATORS
#  define LKR_BUCKET_LOCK CSmallSpinLock
# endif // !LKR_DEPRECATED_ITERATORS
#endif // !LKR_BUCKET_LOCK


#ifndef __LKRHASH_H__
#define __LKRHASH_H__

//=====================================================================
//  The class CLKRLinearHashTable defined in this file provides dynamic hash
//  tables, i.e. tables that grow and shrink dynamically with
//  the number of records in the table.
//  The basic method used is linear hashing, as explained in:
//
//    P.-A. Larson, Dynamic Hash Tables, Comm. of the ACM, 31, 4 (1988)
//
//  This version has the following characteristics:
//  - It is thread-safe and uses spin locks for synchronization.
//  - It was designed to support very high rates of concurrent
//    operations (inserts/deletes/lookups).  It achieves this by
//    (a) partitioning a CLKRHashTable into a collection of
//        CLKRLinearHashTables to reduce contention on the global table lock.
//    (b) minimizing the hold time on a table lock, preferring to lock
//        down a bucket chain instead.
//  - The design is L1 cache-conscious.  See CNodeClump.
//  - It is designed for sets varying in size from a dozen
//    elements to several million.
//
//  Main classes:
//    CLKRLinearHashTable: thread-safe linear hash table
//    CLKRHashTable:       collection of CLKRLinearHashTables
//    CTypedHashTable:     typesafe wrapper for CLKRHashTable
//
//
//  Paul Larson, palarson@microsoft.com, July 1997
//   Original implementation with input from Murali R. Krishnan,
//   muralik@microsoft.com.
//
//  George V. Reilly, georgere@microsoft.com, Dec 1997-Jan 1998
//   Massive cleanup and rewrite.  Added templates.
//=====================================================================


// 1) Linear Hashing
// ------------------
//
// Linear hash tables grow and shrink dynamically with the number of
// records in the table.  The growth or shrinkage is smooth: logically,
// one bucket at a time but physically in larger increments
// (64 buckets).  An insertion (deletion) may cause an expansion
// (contraction) of the table.  This causes relocation of a small number
// of records (at most one bucket worth).  All operations (insert,
// delete, lookup) take constant expected time, regardless of the
// current size or the growth of the table.
//
// 2) LKR extensions to Linear hash table
// --------------------------------------
//
// Larson-Krishnan-Reilly extensions to Linear hash tables for multiprocessor
// scalability and improved cache performance.
//
// Traditional implementations of linear hash tables use one global lock
// to prevent interference between concurrent operations
// (insert/delete/lookup) on the table.  The single lock easily becomes
// the bottleneck in SMP scenarios when multiple threads are used.
//
// Traditionally, a (hash) bucket is implemented as a chain of
// single-item nodes.  Every operation results in chasing down a chain
// looking for an item. However, pointer chasing is very slow on modern
// systems because almost every jump results in a cache miss. L2 (or L3)
// cache misses are very expensive in missed CPU cycles and the cost is
// increasing (going to 100s of cycles in the future).
//
// LKR extensions offer
//    1) Partitioning (by hashing) of records among multiple subtables.
//       Each subtable has locks but there is no global lock.  Each
//       subtable receives a much lower rate of operations, resulting in
//       fewer conflicts.
//
//    2) Improved cache locality by grouping keys and their hash values
//       into contigous chunks that fit exactly into one (or a few)
//       cache lines.
//
// Specifically the implementation that exists here achieves this using
// the following techniques.
//
// Class CLKRHashTable is the top-level data structure that dynamically
// creates m_cSubTables linear hash tables. The CLKRLinearHashTables act as
// the subtables to which items and accesses are fanned out. A good
// hash function multiplexes requests uniformly to various subtables,
// thus minimizing traffic to any single subtable. The implemenation
// uses a home-grown version of bounded spinlocks, that is, a thread
// does not spin on a lock indefinitely, instead yielding after a
// predetermined number of loops.
//
// Each CLKRLinearHashTable consists of a CDirEntry pointing to segments
// each holding m_dwSegSize CBuckets. Each CBucket in turn consists of a
// chain of CNodeClumps.  Each CNodeClump contains a group of
// NODES_PER_CLUMP hash values (aka hash keys or signatures) and
// pointers to the associated data items.  Keeping the signatures
// together increases the cache locality in scans for lookup.
//
// Traditionally, people store a link-list element right inside the
// object that is hashed and use this link-list for the chaining of data
// blocks.  However, keeping just the pointers to the data object and
// not chaining through them limits the need for bringing in the data
// object to the cache.  We need to access the data object only if the
// hash values match. This limits the cache-thrashing behaviour
// exhibited by conventional implementations.  It has the additional
// benefit that the objects themselves do not need to be modified
// in order to be collected in the hash table (i.e., it's non-invasive).


//--------------------------------------------------------------------
// TODO
// * Provide support for multiple, identical keys. Needed for EqualRange,
//   hash_multiset, and hash_multimap.
// * Provide implementations of the STL collection classes: hash_map,
//   hash_set, hash_multimap, and hash_multiset.
// * Make exception-safe.
// * Use auto_ptrs.
// * Add some kind of auto object for readlocking or writelocking a table,
//   so that the table automatically gets unlocked by auto-obj's destructor.
// * Provide a C API wrapper
// * Port to kernel mode (will require different locks, at the very least)
// * Port to managed code (Chris Tracy has started on this)
// * Typedef hash signatures (currently DWORDs)
// * Make available as a static library as well as a DLL
//--------------------------------------------------------------------



#ifndef __IRTLDBG_H__
# include <irtldbg.h>
#endif

#ifndef __LSTENTRY_H__
# include <lstentry.h>
#endif

#ifndef __HASHFN_H__
# include <hashfn.h>
#endif

#include <limits.h>


#ifdef LKR_STL_ITERATORS

// needed for std::forward_iterator_tag, etc
# include <iterator>

// The iterators have very verbose tracing. Don't want it on all the time
// in debug builds.
# if defined(IRTLDEBUG)  &&  (LKR_STL_ITERATORS >= 2)
#  define LKR_ITER_TRACE  IrtlTrace
# else // !defined(IRTLDEBUG)  ||  LKR_STL_ITERATORS < 2
#  define LKR_ITER_TRACE  1 ? (void)0 : IrtlTrace
# endif // !defined(IRTLDEBUG)  ||  LKR_STL_ITERATORS < 2

#endif // LKR_STL_ITERATORS


// Used to initialize and destroy custom allocators
extern "C" bool LKRHashTableInit();
extern "C" void LKRHashTableUninit();


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__


enum LK_TABLESIZE {
    LK_SMALL_TABLESIZE=  1,     // < 200 elements
    LK_MEDIUM_TABLESIZE= 2,     // 200...10,000 elements
    LK_LARGE_TABLESIZE=  3,     // 10,000+ elements
};


// Default values for the hashtable constructors
enum {
#ifndef _WIN64
    LK_DFLT_MAXLOAD=     6, // Default upperbound on average chain length.
#else // _WIN64
    LK_DFLT_MAXLOAD=     4, // 64-byte nodes => NODES_PER_CLUMP = 4
#endif // _WIN64
    LK_DFLT_INITSIZE=LK_MEDIUM_TABLESIZE, // Default initial size of hash table
    LK_DFLT_NUM_SUBTBLS= 0, // Use a heuristic to choose #subtables
};


// obsolete build fix hack
// enum {
//     DFLT_LK_MAXLOAD=     LK_DFLT_MAXLOAD,
//     DFLT_LK_INITSIZE=    LK_DFLT_INITSIZE,
//     DFLT_LK_NUM_SUBTBLS= LK_DFLT_NUM_SUBTBLS,
// };


//--------------------------------------------------------------------
// forward declarations

class IRTL_DLLEXP CLKRLinearHashTable;

class IRTL_DLLEXP CLKRHashTable;

template <class _Der, class _Rcd, class _Ky, class _HT
#ifdef LKR_DEPRECATED_ITERATORS
          , class _Iter
#endif // LKR_DEPRECATED_ITERATORS
          >
class CTypedHashTable;


//--------------------------------------------------------------------
// Possible return codes from public member functions of
// CLKRLinearHashTable, CLKRHashTable, and CTypedHashTable

enum LK_RETCODE {
    // severe errors < 0
    LK_UNUSABLE = -99,  // Table corrupted: all bets are off
    LK_ALLOC_FAIL,      // ran out of memory
    LK_BAD_ITERATOR,    // invalid iterator; e.g., points to another table
    LK_BAD_RECORD,      // invalid record; e.g., NULL for InsertRecord
    LK_BAD_PARAMETERS,  // invalid parameters; e.g., NULL fnptrs to ctor
    LK_NOT_INITIALIZED, // LKRHashTableInit was not called

    LK_SUCCESS = 0,     // everything's okay
    LK_KEY_EXISTS,      // key already present for InsertRecord(no-overwrite)
    LK_NO_SUCH_KEY,     // key not found
    LK_NO_MORE_ELEMENTS,// iterator exhausted
};

#define LK_SUCCEEDED(lkrc)  ((lkrc) >= LK_SUCCESS)


#ifdef LKR_APPLY_IF

//--------------------------------------------------------------------
// Return codes from PFnRecordPred.

enum LK_PREDICATE {
    LKP_ABORT = 1,           // Stop walking the table immediately
    LKP_NO_ACTION = 2,       // No action, just keep walking
    LKP_PERFORM = 3,         // Perform action and continue walking
    LKP_PERFORM_STOP = 4,    // Perform action, then stop
    LKP_DELETE = 5,          // Delete record and keep walking
    LKP_DELETE_STOP = 6,     // Delete record, then stop
};


//--------------------------------------------------------------------
// Return codes from PFnRecordAction.

enum LK_ACTION {
    LKA_ABORT = 1,          // Stop walking the table immediately
    LKA_FAILED = 2,         // Action failed; continue walking the table
    LKA_SUCCEEDED = 3,      // Action succeeded; continue walking the table
};

#endif // LKR_APPLY_IF

#if defined(LKR_DEPRECATED_ITERATORS) || defined(LKR_APPLY_IF)
//--------------------------------------------------------------------
// Parameter to Apply and ApplyIf.

enum LK_LOCKTYPE {
    LKL_READLOCK = 1,       // Lock the table for reading (for constness)
    LKL_WRITELOCK = 2,      // Lock the table for writing
};

#endif // LKR_DEPRECATED_ITERATORS || LKR_APPLY_IF



//--------------------------------------------------------------------
// Global table lock code.  This is only used to measure how much of a
// slowdown having a global lock on the CLKRHashTable causes.  It is
// *never* used in production code.


// #define LKRHASH_GLOBAL_LOCK CCritSec

#ifdef LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()         \
    typedef LKRHASH_GLOBAL_LOCK GlobalLock;  \
    mutable GlobalLock m_lkGlobal;

# define LKRHASH_GLOBAL_READ_LOCK()     m_lkGlobal.ReadLock()
# define LKRHASH_GLOBAL_WRITE_LOCK()    m_lkGlobal.WriteLock()
# define LKRHASH_GLOBAL_READ_UNLOCK()   m_lkGlobal.ReadUnlock()
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  m_lkGlobal.WriteUnlock()

#else // !LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()

// These ones will be optimized away by the compiler
# define LKRHASH_GLOBAL_READ_LOCK()     ((void)0)
# define LKRHASH_GLOBAL_WRITE_LOCK()    ((void)0)
# define LKRHASH_GLOBAL_READ_UNLOCK()   ((void)0)
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  ((void)0)

#endif // !LKRHASH_GLOBAL_LOCK



//--------------------------------------------------------------------
// Statistical information returned by GetStatistics
//--------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION

class IRTL_DLLEXP CAveragedLockStats : public CLockStatistics
{
public:
    int m_nItems;

    CAveragedLockStats()
        : m_nItems(1)
    {}
};

#endif // LOCK_INSTRUMENTATION



class IRTL_DLLEXP CLKRHashTableStats
{
public:
    int      RecordCount;           // number of records in the table
    int      TableSize;             // table size in number of slots
    int      DirectorySize;         // number of entries in directory
    int      LongestChain;          // longest hash chain in the table
    int      EmptySlots;            // number of unused hash slots
    double   SplitFactor;           // fraction of buckets split
    double   AvgSearchLength;       // average length of a successful search
    double   ExpSearchLength;       // theoretically expected length
    double   AvgUSearchLength;      // average length of an unsuccessful search
    double   ExpUSearchLength;      // theoretically expected length
    int      NodeClumpSize;         // number of slots in a node clump
    int      CBucketSize;           // sizeof(CBucket)

#ifdef LOCK_INSTRUMENTATION
    CAveragedLockStats      m_alsTable;  // stats for table lock
    CAveragedLockStats      m_alsBucketsAvg; // avg of stats for bucket locks
    CGlobalLockStatistics   m_gls;      // global statistics for all locks
#endif // LOCK_INSTRUMENTATION

    enum {
        MAX_BUCKETS = 40,
    };

    // histogram of bucket lengths
    LONG    m_aBucketLenHistogram[MAX_BUCKETS];

    CLKRHashTableStats()
        : RecordCount(0),
          TableSize(0),
          DirectorySize(0),
          LongestChain(0),
          EmptySlots(0),
          SplitFactor(0.0),
          AvgSearchLength(0.0),
          ExpSearchLength(0.0),
          AvgUSearchLength(0.0),
          ExpUSearchLength(0.0),
          NodeClumpSize(1),
          CBucketSize(0)
    {
        for (int i = MAX_BUCKETS;  --i >= 0;  )
            m_aBucketLenHistogram[i] = 0;
    }

    static const LONG*
    BucketSizes()
    {
        static const LONG  s_aBucketSizes[MAX_BUCKETS] = {
                   1,    2,    3,    4,    5,    6,    7,      8,        9,
            10,   11,   12,   13,   14,   15,   16,   17,     18,       19,
            20,   21,   22,   23,   24,   25,   30,   40,     50,       60,
            70,   80,   90,  100,  200,  500, 1000,10000, 100000, LONG_MAX,
        };

        return s_aBucketSizes;
    }

    static LONG
    BucketSize(
        LONG nBucketIndex)
    {
        IRTLASSERT(0 <= nBucketIndex  &&  nBucketIndex < MAX_BUCKETS);
        return BucketSizes()[nBucketIndex];
    }

    static LONG
    BucketIndex(
        LONG nBucketLength)
    {
        const LONG* palBucketSizes = BucketSizes();
        LONG i = 0;
        while (palBucketSizes[i] < nBucketLength)
            ++i;
        if (i == MAX_BUCKETS  ||  palBucketSizes[i] > nBucketLength)
            --i;
        IRTLASSERT(0 <= i  &&  i < MAX_BUCKETS);
        return i;
    }
};



// Use types defined in recent versions of the Platform SDK in basetsd.h.
#ifndef _W64
typedef DWORD DWORD_PTR;   // integral type big enough to hold a pointer
#endif

//--------------------------------------------------------------------
// CLKRLinearHashTable deals with void* records.  These typedefs
// provide prototypes for functions that manipulate instances of
// those records.  CTypedHashTable and CStringTestHashTable (below) show a
// way to encapsulate these in typesafe wrappers.
//--------------------------------------------------------------------

// Given a record, return its key.  Assumes that the key is embedded in
// the record, or at least somehow derivable from the record.  For
// completely unrelated keys & values, a wrapper class should use
// something like STL's pair<key,value> template to aggregate them
// into a record.
typedef const DWORD_PTR (WINAPI *PFnExtractKey)  (const void* pvRecord);

// Given a key, return its hash signature.  The hashing functions in
// hashfn.h (or something that builds upon them) are suggested.
typedef DWORD       (WINAPI *PFnCalcKeyHash) (const DWORD_PTR pnKey);

// Compare two keys for equality; e.g., _stricmp, memcmp, operator==
typedef bool        (WINAPI *PFnEqualKeys)   (const DWORD_PTR pnKey1,
                                              const DWORD_PTR pnKey2);

// Increment the reference count of a record before returning it from
// FindKey.  It's necessary to do it in FindKey itself while the bucket
// is still locked, rather than one of the wrappers, to avoid race
// conditions.  Similarly, the reference count is incremented in
// InsertRecord and decremented in DeleteKey.  Finally, if an old record
// is overwritten in InsertRecord, its reference count is decremented.
//
// It's up to you to decrement the reference count when you're finished
// with it after retrieving it via FindKey and to determine the
// semantics of what this means.  The hashtable itself has no notion of
// reference counts; this is merely to help with the lifetime management
// of the record objects.
typedef void        (WINAPI *PFnAddRefRecord)(const void* pvRecord, int nIncr);

#ifdef LKR_APPLY_IF
// ApplyIf() and DeleteIf(): Does the record match the predicate?
typedef LK_PREDICATE (WINAPI *PFnRecordPred) (const void* pvRecord,
                                              void* pvState);

// Apply() et al: Perform action on record.
typedef LK_ACTION   (WINAPI *PFnRecordAction)(const void* pvRecord,
                                              void* pvState);
#endif // LKR_APPLY_IF


#ifndef __LKRHASH_NO_NAMESPACE__
}
#endif // !__LKRHASH_NO_NAMESPACE__



//--------------------------------------------------------------------
// Custom memory allocators
//--------------------------------------------------------------------


#ifndef LKR_NO_ALLOCATORS
// # define LKRHASH_ACACHE 1
// # define LKRHASH_MANODEL 1
// # define LKRHASH_MADEL 1
// # define LKRHASH_ROCKALL_FAST 1

// # define LKRHASH_MEM_DEFAULT_ALIGN 32
#endif // !LKR_NO_ALLOCATORS

#ifndef LKRHASH_MEM_DEFAULT_ALIGN
# define LKRHASH_MEM_DEFAULT_ALIGN 8
#endif // !LKRHASH_MEM_DEFAULT_ALIGN

#if defined(LKRHASH_ACACHE)

# include <acache.hxx>
  typedef ALLOC_CACHE_HANDLER  CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N)                            \
    const ALLOC_CACHE_CONFIGURATION acc = { 1, N, sizeof(C) };  \
    C::sm_palloc = new ALLOC_CACHE_HANDLER("LKRhash:" #C, &acc);

#elif defined(LKRHASH_ROCKALL_FAST)

# include <FastHeap.hpp>

class FastHeap : public FAST_HEAP
{
public:
    FastHeap(
        SIZE_T cb)
        : m_cb(cb)
    {}

    LPVOID Alloc()
    { return New(m_cb, NULL, false); }

    BOOL   Free(LPVOID pvMem)
    { return Delete(pvMem); }

    SIZE_T m_cb;
};

  typedef FastHeap  CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N)                            \
    C::sm_palloc = new FastHeap(sizeof(C));

#else // no custom allocator

# undef LKRHASH_ALLOCATOR_NEW

#endif // no custom allocator



#ifdef LKRHASH_ALLOCATOR_NEW

// placed inline in the declaration of class C
# define LKRHASH_ALLOCATOR_DEFINITIONS(C)                       \
    protected:                                                  \
        static CLKRhashAllocator* sm_palloc;                    \
        friend bool  LKRHashTableInit();                        \
        friend void  LKRHashTableUninit();                      \
        friend class CLKRLinearHashTable;                       \
    public:                                                     \
        static void*  operator new(size_t s)                    \
        {                                                       \
            UNREFERENCED_PARAMETER(s);                          \
            IRTLASSERT(s == sizeof(C));                         \
            IRTLASSERT(sm_palloc != NULL);                      \
            return sm_palloc->Alloc();                          \
        }                                                       \
        static void   operator delete(void* pv)                 \
        {                                                       \
            IRTLASSERT(pv != NULL);                             \
            IRTLASSERT(sm_palloc != NULL);                      \
            sm_palloc->Free(pv);                                \
        }                                                       \
        static bool init(void)                                  \
        {                                                       \
            IRTLASSERT(sm_palloc == NULL);                      \
            LKRHASH_ALLOCATOR_NEW(C, 1);                        \
            return (sm_palloc != NULL);                         \
        }                                                       \
        static void uninit(void)                                \
        {                                                       \
            if (sm_palloc != NULL)                              \
            {                                                   \
                delete sm_palloc;                               \
                sm_palloc = NULL;                               \
            }                                                   \
        }


// used in LKRHashTableInit()
# define LKRHASH_ALLOCATOR_INIT(C, N, f)                        \
    {                                                           \
        if (f)                                                  \
        {                                                       \
            f = C::init();                                      \
        }                                                       \
    }


// used in LKRHashTableUninit()
# define LKRHASH_ALLOCATOR_UNINIT(C)                            \
    {                                                           \
        C::uninit();                                            \
    }


#else // !LKRHASH_ALLOCATOR_NEW

# define LKRHASH_ALLOCATOR_DEFINITIONS(C)
# define LKRHASH_ALLOCATOR_INIT(C, N, f)
# define LKRHASH_ALLOCATOR_UNINIT(C)

#endif // !LKRHASH_ALLOCATOR_NEW



#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__

// Class for nodes on a bucket chain.  Instead of a node containing
// one (signature, record-pointer, next-tuple-pointer) tuple, it
// contains _N_ such tuples.  (N-1 next-tuple-pointers are omitted.)
// This improves locality of reference greatly; i.e., it's L1
// cache-friendly.  It also reduces memory fragmentation and memory
// allocator overhead.  It does complicate the chain traversal code
// slightly, admittedly.
//
// This theory is beautiful.  In practice, however, CNodeClumps
// are *not* perfectly aligned on 32-byte boundaries by the memory
// allocators.  Experimental results indicate that we get a 2-3%
// speed improvement by using 32-byte-aligned blocks, but this must
// be considered against the average of 16 bytes wasted per block.

class CNodeClump
{
public:
    // Record slots per chunk - set so a chunk matches (one or
    // two) cache lines.  3 ==> 32 bytes, 7 ==> 64 bytes
    // Note: the default max load factor is 6.0, which implies that
    // there will seldom be more than one node clump in a chain.
    enum {
        BUCKET_BYTE_SIZE = 64,
        BUCKET_OVERHEAD  = sizeof(LKR_BUCKET_LOCK) + sizeof(CNodeClump*),
        NODE_SIZE        = sizeof(const void*) + sizeof(DWORD),
        NODES_PER_CLUMP  = (BUCKET_BYTE_SIZE - BUCKET_OVERHEAD) / NODE_SIZE
    };

    enum {
        // See if countdown loops are faster than countup loops for
        // traversing a CNodeClump. In practice, countup loops are faster.
#ifndef LKR_COUNTDOWN
        NODE_BEGIN = 0,
        NODE_END   = NODES_PER_CLUMP,
        NODE_STEP  = +1,
        // for (int x = 0;  x < NODES_PER_CLUMP;  ++x) ...
#else // LKR_COUNTDOWN
        NODE_BEGIN = NODES_PER_CLUMP-1,
        NODE_END   = -1,
        NODE_STEP  = -1,
        // for (int x = NODES_PER_CLUMP;  --x >= 0;  ) ...
#endif // LKR_COUNTDOWN
    };

    enum {
        // No number in 0..2^31-1 maps to this number after it has been
        // scrambled by HashFn::HashRandomizeBits
        HASH_INVALID_SIGNATURE = 31678523,
    };

    DWORD  m_dwKeySigs[NODES_PER_CLUMP]; // hash values computed from keys
    CNodeClump* m_pncNext;               // next node clump on the chain
    const void* m_pvNode[NODES_PER_CLUMP];// pointers to records

    CNodeClump()
    {
        Clear();
    }

    void
    Clear()
    { 
        m_pncNext = NULL;  // no dangling pointers
        for (int i = NODES_PER_CLUMP;  --i >= 0; )
        {
            m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
            m_pvNode[i] = NULL;
        }
    }

    bool
    InvalidSignature(
        int i) const
    {
        IRTLASSERT(0 <= i  &&  i < NODES_PER_CLUMP);
        return (m_dwKeySigs[i] == HASH_INVALID_SIGNATURE);
    }

    bool
    IsEmptyNode(
        int i) const
    {
        IRTLASSERT(0 <= i  &&  i < NODES_PER_CLUMP);
        return (m_pvNode[i] == NULL);
    }

    bool
    IsEmptyAndInvalid(
        int i) const
    {
        return IsEmptyNode(i) && InvalidSignature(i);
    }

    bool
    IsEmptySlot(
        int i) const
    {
        return InvalidSignature(i);
    }

    bool
    IsLastClump() const
    {
        return (m_pncNext == NULL);
    }

#ifdef IRTLDEBUG
    // Don't want overhead of calls to dtor in retail build
    ~CNodeClump()
    {
        IRTLASSERT(IsLastClump());  // no dangling pointers
        for (int i = NODES_PER_CLUMP;  --i >= 0;  )
            IRTLASSERT(InvalidSignature(i)  &&  IsEmptyNode(i));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CNodeClump);
}; // class CNodeClump



// Class for bucket chains of the hash table.  Note that the first
// nodeclump is actually included in the bucket and not dynamically
// allocated, which increases space requirements slightly but does
// improve performance.
class CBucket
{
private:
    typedef LKR_BUCKET_LOCK BucketLock;
    mutable BucketLock m_Lock;       // lock protecting this bucket

#ifdef LOCK_INSTRUMENTATION
    static LONG sm_cBuckets;

    static const TCHAR*
    _LockName()
    {
        LONG l = ++sm_cBuckets;
        // possible race condition but we don't care, as this is never
        // used in production code
        static TCHAR s_tszName[CLockStatistics::L_NAMELEN];
        wsprintf(s_tszName, _TEXT("B%06x"), 0xFFFFFF & l);
        return s_tszName;
    }
#endif // LOCK_INSTRUMENTATION

public:
    CNodeClump    m_ncFirst;    // first CNodeClump of this bucket

#if defined(LOCK_INSTRUMENTATION) || defined(IRTLDEBUG)
    CBucket()
#ifdef LOCK_INSTRUMENTATION
        : m_Lock(_LockName())
#endif // LOCK_INSTRUMENTATION
    {
#ifdef IRTLDEBUG
        LOCK_LOCKTYPE lt = BucketLock::LockType();
        if (lt == LOCK_SPINLOCK  ||  lt == LOCK_FAKELOCK)
            IRTLASSERT(sizeof(*this) <= 64);
#endif IRTLDEBUG
    }
#endif // LOCK_INSTRUMENTATION || IRTLDEBUG

    void  WriteLock()           { m_Lock.WriteLock(); }
    void  ReadLock() const      { m_Lock.ReadLock(); }
    void  WriteUnlock() const   { m_Lock.WriteUnlock();   }
    void  ReadUnlock() const    { m_Lock.ReadUnlock();   }
    bool  IsWriteLocked() const { return m_Lock.IsWriteLocked(); }
    bool  IsReadLocked() const  { return m_Lock.IsReadLocked(); }
    bool  IsWriteUnlocked() const { return m_Lock.IsWriteUnlocked(); }
    bool  IsReadUnlocked() const  { return m_Lock.IsReadUnlocked(); }
    void  SetSpinCount(WORD wSpins) { m_Lock.SetSpinCount(wSpins); }
    WORD  GetSpinCount() const  { return m_Lock.GetSpinCount(); }
#ifdef LOCK_INSTRUMENTATION
    CLockStatistics LockStats() const {return m_Lock.Statistics();}
#endif // LOCK_INSTRUMENTATION
}; // class CBucket



// The hash table space is divided into fixed-size segments (arrays of
// CBuckets) and physically grows/shrinks one segment at a time.
//
// We provide small, medium, and large segments to better tune the
// overall memory requirements of the hash table according to the
// expected usage of an instance.

class CSegment
{
public:
    CBucket m_bktSlots[1];

    // See note at m_bktSlots2 in CSmallSegment below
    CBucket& Slot(DWORD i)
    { return m_bktSlots[i]; }
}; // class CSegment


// Small-sized segments contain 2^3 = 8 buckets => ~0.5Kb
class CSmallSegment : public CSegment
{
public:
    // Maximum table size equals MAX_DIRSIZE * SEGSIZE buckets.
    enum {
        SEGBITS  =            3,// number of bits extracted from a hash
                                // address for offset within a segment
        SEGSIZE  = (1<<SEGBITS),// segment size
        SEGMASK  = (SEGSIZE-1), // mask used for extracting offset bit
        INITSIZE = 1 * SEGSIZE, // #segments to allocate initially
    };

    // Hack: assumes immediately after CSegment::m_bktSlots, with no
    // padding. The STATIC_ASSERT in _AllocateSegment should cause a
    // compile-time error if this assumption is false.
    CBucket m_bktSlots2[SEGSIZE-1];

public:
    DWORD Bits() const      { return SEGBITS; }
    DWORD Size() const      { return SEGSIZE; }
    DWORD Mask() const      { return SEGMASK; }
    DWORD InitSize() const  { return INITSIZE;}

#ifdef IRTLDEBUG
    CSmallSegment()
    {
        IRTLASSERT(&Slot(1) == m_bktSlots2);
        IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
        IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CSmallSegment);
}; // class CSmallSegment


// Medium-sized segments contain 2^6 = 64 buckets => ~4Kb
class CMediumSegment : public CSegment
{
public:
    enum {
        SEGBITS  =            6,
        SEGSIZE  = (1<<SEGBITS),
        SEGMASK  = (SEGSIZE-1),
        INITSIZE = 2 * SEGSIZE,
    };

    CBucket m_bktSlots2[SEGSIZE-1];

public:
    DWORD Bits() const      { return SEGBITS; }
    DWORD Size() const      { return SEGSIZE; }
    DWORD Mask() const      { return SEGMASK; }
    DWORD InitSize() const  { return INITSIZE;}

#ifdef IRTLDEBUG
    CMediumSegment()
    {
        IRTLASSERT(&Slot(1) == m_bktSlots2);
        IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
        IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CMediumSegment);
}; // class CMediumSegment


// Large-sized segments contain 2^9 = 512 buckets => ~32Kb
class CLargeSegment : public CSegment
{
public:
    enum {
        SEGBITS  =            9,
        SEGSIZE  = (1<<SEGBITS),
        SEGMASK  = (SEGSIZE-1),
        INITSIZE = 4 * SEGSIZE,
    };

    CBucket m_bktSlots2[SEGSIZE-1];

public:
    DWORD Bits() const      { return SEGBITS; }
    DWORD Size() const      { return SEGSIZE; }
    DWORD Mask() const      { return SEGMASK; }
    DWORD InitSize() const  { return INITSIZE;}

#ifdef IRTLDEBUG
    CLargeSegment()
    {
        IRTLASSERT(&Slot(1) == m_bktSlots2);
        IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
        IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CLargeSegment);
}; // class CLargeSegment



// A directory keeps track of the segments comprising the hash table.
// The directory is just a variable-sized array of pointers to
// segments (CDirEntrys).
class CDirEntry
{
public:
    // MIN_DIRSIZE and MAX_DIRSIZE can be changed independently
    // of anything else.  Should be powers of two.
    enum {
        MIN_DIRSIZE =  (1<<3),   // minimum directory size
        MAX_DIRSIZE = (1<<20),   // maximum directory size
    };

    CSegment* m_pseg;

    CDirEntry()
        : m_pseg(NULL)
    {}

    ~CDirEntry()
    { delete m_pseg; }
}; // class CDirEntry



#ifdef LKR_STL_ITERATORS

class IRTL_DLLEXP CLKRLinearHashTable_Iterator;
class IRTL_DLLEXP CLKRHashTable_Iterator;


class IRTL_DLLEXP CLKRLinearHashTable_Iterator
{
    friend class CLKRLinearHashTable;
    friend class CLKRHashTable;
    friend class CLKRHashTable_Iterator;

protected:
    CLKRLinearHashTable* m_plht;        // which linear hash table?
    CNodeClump*          m_pnc;         // a CNodeClump in bucket
    DWORD                m_dwBucketAddr;// bucket index
    short                m_iNode;       // offset within m_pnc
    
    enum {
        NODES_PER_CLUMP = CNodeClump::NODES_PER_CLUMP,
        NODE_BEGIN      = CNodeClump::NODE_BEGIN,
        NODE_END        = CNodeClump::NODE_END,
        NODE_STEP       = CNodeClump::NODE_STEP,
    };

    CLKRLinearHashTable_Iterator(
        CLKRLinearHashTable* plht,
        CNodeClump*          pnc,
        DWORD                dwBucketAddr,
        short                iNode)
        : m_plht(plht),
          m_pnc(pnc),
          m_dwBucketAddr(dwBucketAddr),
          m_iNode(iNode)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::prot ctor, this=%p, plht=%p, ")
                       _TEXT("pnc=%p, ba=%d, in=%d\n"),
                       this, plht, pnc, dwBucketAddr, iNode);
    }
    
    inline void _AddRef(
        int nIncr) const;
    
    bool _Increment(
        bool fDecrementOldValue=true);
    
public:
    CLKRLinearHashTable_Iterator()
        : m_plht(NULL),
          m_pnc(NULL),
          m_dwBucketAddr(0),
          m_iNode(0)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::default ctor, this=%p\n"), this);
    }
    
    CLKRLinearHashTable_Iterator(
        const CLKRLinearHashTable_Iterator& rhs)
        : m_plht(rhs.m_plht),
          m_pnc(rhs.m_pnc),
          m_dwBucketAddr(rhs.m_dwBucketAddr),
          m_iNode(rhs.m_iNode)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::copy ctor, this=%p, rhs=%p\n"),
                       this, &rhs);
        _AddRef(+1);
    }

    CLKRLinearHashTable_Iterator& operator=(
        const CLKRLinearHashTable_Iterator& rhs)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator=, this=%p, rhs=%p\n"),
                       this, &rhs);
        rhs._AddRef(+1);
        this->_AddRef(-1);

        m_plht =         rhs.m_plht;
        m_pnc =          rhs.m_pnc;
        m_dwBucketAddr = rhs.m_dwBucketAddr;
        m_iNode =        rhs.m_iNode;

        return *this;
    }

    ~CLKRLinearHashTable_Iterator()
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::dtor, this=%p, plht=%p\n"),
                       this, m_plht);
        _AddRef(-1);
    }

    bool Increment()
    {
        return IsValid()  ? _Increment()  :  false;

    }

    bool IsValid() const
    {
        bool fValid = (m_plht != NULL  &&  m_pnc != NULL
                       &&  0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP);
        if (fValid)
            fValid = (m_pnc->m_pvNode[m_iNode] != NULL);
        IRTLASSERT(fValid);
        return fValid;
    }

    const void* Record() const
    {
        IRTLASSERT(IsValid());
        return m_pnc->m_pvNode[m_iNode];
    }

    inline const DWORD_PTR Key() const;

    bool operator==(
        const CLKRLinearHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator==, this=%p, rhs=%p\n"),
                       this, &rhs);
        // m_pnc and m_iNode uniquely identify an iterator
        bool fEQ = ((m_pnc == rhs.m_pnc)    // most unique field
                    &&  (m_iNode == rhs.m_iNode));
        IRTLASSERT(!fEQ || ((m_plht == rhs.m_plht)
                            &&  (m_dwBucketAddr == rhs.m_dwBucketAddr)));
        return fEQ;
    }

    bool operator!=(
        const CLKRLinearHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator!=, this=%p, rhs=%p\n"),
                       this, &rhs);
        bool fNE = ((m_pnc != rhs.m_pnc)
                    ||  (m_iNode != rhs.m_iNode));
        //// IRTLASSERT(fNE == !this->operator==(rhs));
        return fNE;
    }
}; // class CLKRLinearHashTable_Iterator



class IRTL_DLLEXP CLKRHashTable_Iterator
{
    friend class CLKRHashTable;
        
protected:
    // order important to minimize size
    CLKRHashTable*                  m_pht;      // which hash table?
    CLKRLinearHashTable_Iterator    m_subiter;  // iterator into subtable
    short                           m_ist;      // index of subtable

    CLKRHashTable_Iterator(
        CLKRHashTable* pht,
        short          ist)
        : m_pht(pht),
          m_subiter(CLKRLinearHashTable_Iterator()), // zero
          m_ist(ist)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::prot ctor, this=%p, pht=%p, ist=%d\n"),
                       this, pht, ist);
    }

    bool _Increment(
        bool fDecrementOldValue=true);

public:
    CLKRHashTable_Iterator()
        : m_pht(NULL),
          m_subiter(CLKRLinearHashTable_Iterator()), // zero
          m_ist(0)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::default ctor, this=%p\n"), this);
    }

#ifdef IRTLDEBUG
    // Compiler does a perfectly adequate job of synthesizing these
    // methods.
    CLKRHashTable_Iterator(
        const CLKRHashTable_Iterator& rhs)
        : m_pht(rhs.m_pht),
          m_subiter(rhs.m_subiter),
          m_ist(rhs.m_ist)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::copy ctor, this=%p, rhs=%p\n"),
                       this, &rhs);
    }

    CLKRHashTable_Iterator& operator=(
        const CLKRHashTable_Iterator& rhs)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator=, this=%p, rhs=%p\n"),
                       this, &rhs);

        m_ist     = rhs.m_ist;
        m_subiter = rhs.m_subiter;
        m_pht     = rhs.m_pht;

        return *this;
    }

    ~CLKRHashTable_Iterator()
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::dtor, this=%p, pht=%p\n"), this, m_pht);
    }
#endif

    bool Increment()
    {
        return IsValid()  ? _Increment()  :  false;

    }

    bool IsValid() const
    {
                           
        bool fValid = (m_pht != NULL  &&  m_ist >= 0);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_plht != NULL);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_pnc != NULL);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (0 <= m_subiter.m_iNode);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_iNode < CNodeClump::NODES_PER_CLUMP);
        IRTLASSERT(fValid);

        if (fValid)
            fValid = (m_subiter.m_pnc->m_pvNode[m_subiter.m_iNode] != NULL);
        IRTLASSERT(fValid);
        return fValid;
    }

    const void* Record() const
    {
        IRTLASSERT(IsValid());
        return m_subiter.Record();
    }

    const DWORD_PTR Key() const
    {
        IRTLASSERT(IsValid());
        return m_subiter.Key();
    }

    bool operator==(
        const CLKRHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator==, this=%p, rhs=%p\n"),
                       this, &rhs);
        // m_pnc and m_iNode uniquely identify an iterator
        bool fEQ = ((m_subiter.m_pnc
                            == rhs.m_subiter.m_pnc)     // most unique field
                    &&  (m_subiter.m_iNode == rhs.m_subiter.m_iNode));
        IRTLASSERT(!fEQ
                   || ((m_ist == rhs.m_ist)
                       &&  (m_pht == rhs.m_pht)
                       &&  (m_subiter.m_plht == rhs.m_subiter.m_plht)
                       &&  (m_subiter.m_dwBucketAddr
                                == rhs.m_subiter.m_dwBucketAddr)));
        return fEQ;
    }

    bool operator!=(
        const CLKRHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator!=, this=%p, rhs=%p\n"),
                       this, &rhs);
        bool fNE = ((m_subiter.m_pnc != rhs.m_subiter.m_pnc)
                    ||  (m_subiter.m_iNode != rhs.m_subiter.m_iNode));
        //// IRTLASSERT(fNE == !this->operator==(rhs));
        return fNE;
    }
}; // class CLKRHashTable_Iterator

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// CLKRLinearHashTable
//
// A thread-safe linear hash table.
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRLinearHashTable
{
public:
    typedef LKR_TABLE_LOCK  TableLock;
    typedef LKR_BUCKET_LOCK BucketLock;

#ifdef LKR_DEPRECATED_ITERATORS
    class CIterator;
    friend class CLKRLinearHashTable::CIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_STL_ITERATORS
    friend class CLKRLinearHashTable_Iterator;
    typedef CLKRLinearHashTable_Iterator Iterator;
#endif // LKR_STL_ITERATORS

private:
    friend class CNodeClump;
    friend class CLKRHashTable;

#ifdef LKRHASH_ALLOCATOR_NEW
    friend bool LKRHashTableInit();
    friend void LKRHashTableUninit();
#endif // LKRHASH_ALLOCATOR_NEW

#ifdef LKRHASH_INSTRUMENTATION
    // TODO
#endif // LKRHASH_INSTRUMENTATION


public:

    // aliases for convenience
    enum {
        NODES_PER_CLUMP        = CNodeClump::NODES_PER_CLUMP,
        MIN_DIRSIZE            = CDirEntry::MIN_DIRSIZE,
        MAX_DIRSIZE            = CDirEntry::MAX_DIRSIZE,
        NAME_SIZE              = 16,
        NODE_BEGIN             = CNodeClump::NODE_BEGIN,
        NODE_END               = CNodeClump::NODE_END,
        NODE_STEP              = CNodeClump::NODE_STEP,
        HASH_INVALID_SIGNATURE = CNodeClump::HASH_INVALID_SIGNATURE,
    };


private:

    //
    // Miscellaneous helper functions
    //

    // Convert a hash signature to a bucket address
    inline DWORD _BucketAddress(DWORD dwSignature) const
    {
        DWORD dwBktAddr = _H0(dwSignature);
        // Has this bucket been split already?
        if (dwBktAddr < m_iExpansionIdx)
            dwBktAddr = _H1(dwSignature);
        IRTLASSERT(dwBktAddr < m_cActiveBuckets);
        IRTLASSERT(dwBktAddr < (m_cDirSegs << m_dwSegBits));
        return dwBktAddr;
    }

    // See the Linear Hashing paper
    static DWORD _H0(DWORD dwSignature, DWORD dwBktAddrMask)
    { return dwSignature & dwBktAddrMask; }

    DWORD        _H0(DWORD dwSignature) const
    { return _H0(dwSignature, m_dwBktAddrMask0); }

    // See the Linear Hashing paper.  Preserves one bit more than _H0.
    static DWORD _H1(DWORD dwSignature, DWORD dwBktAddrMask)
    { return dwSignature & ((dwBktAddrMask << 1) | 1); }

    DWORD        _H1(DWORD dwSignature) const
    { return _H0(dwSignature, m_dwBktAddrMask1); }

    // In which segment within the directory does the bucketaddress lie?
    // (Return type must be lvalue so that it can be assigned to.)
    CSegment*&   _Segment(DWORD dwBucketAddr) const
    {
        const DWORD iSeg = dwBucketAddr >> m_dwSegBits;
        IRTLASSERT(m_paDirSegs != NULL  &&  iSeg < m_cDirSegs);
        return m_paDirSegs[iSeg].m_pseg;
    }

    // Offset within the segment of the bucketaddress
    DWORD        _SegIndex(DWORD dwBucketAddr) const
    { return (dwBucketAddr & m_dwSegMask); }

    // Convert a bucketaddress to a CBucket*
    inline CBucket* _Bucket(DWORD dwBucketAddr) const
    {
        IRTLASSERT(dwBucketAddr < m_cActiveBuckets);
        CSegment* const pseg = _Segment(dwBucketAddr);
        IRTLASSERT(pseg != NULL);
        return &(pseg->Slot(_SegIndex(dwBucketAddr)));
    }

    // Extract the key from a record
    const DWORD_PTR  _ExtractKey(const void* pvRecord) const
    {
        IRTLASSERT(pvRecord != NULL);
        IRTLASSERT(m_pfnExtractKey != NULL);
        return (*m_pfnExtractKey)(pvRecord);
    }

    // Hash the key
    DWORD        _CalcKeyHash(const DWORD_PTR pnKey) const
    {
        // Note pnKey==0 is acceptable, as the real key type could be an int
        IRTLASSERT(m_pfnCalcKeyHash != NULL);
        DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);
        // We forcibly scramble the result to help ensure a better distribution
#ifndef __HASHFN_NO_NAMESPACE__
        dwHash = HashFn::HashRandomizeBits(dwHash);
#else // !__HASHFN_NO_NAMESPACE__
        dwHash = ::HashRandomizeBits(dwHash);
#endif // !__HASHFN_NO_NAMESPACE__
        IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);
        return dwHash;
    }

    // Compare two keys for equality
    bool       _EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2) const
    {
        IRTLASSERT(m_pfnEqualKeys != NULL);
        return (*m_pfnEqualKeys)(pnKey1, pnKey2);
    }

    // AddRef or Release a record.
    void         _AddRefRecord(const void* pvRecord, int nIncr) const
    {
        IRTLASSERT(pvRecord != NULL  &&  (nIncr == -1  ||  nIncr == +1));
        IRTLASSERT(m_pfnAddRefRecord != NULL);
        (*m_pfnAddRefRecord)(pvRecord, nIncr);
    }

    // Find a bucket, given its signature.
    CBucket*     _FindBucket(DWORD dwSignature, bool fLockForWrite) const;

    // Used by _FindKey so that the thread won't deadlock if the user has
    // already explicitly called table->WriteLock().
    bool _ReadOrWriteLock() const
    { return m_Lock.ReadOrWriteLock(); }

    void _ReadOrWriteUnlock(bool fReadLocked) const
    { m_Lock.ReadOrWriteUnlock(fReadLocked); }

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    static CDirEntry* const
    _AllocateSegmentDirectory(
        size_t n);

    bool
    _FreeSegmentDirectory();

    static CNodeClump* const
    _AllocateNodeClump();

    static bool
    _FreeNodeClump(
        CNodeClump* pnc);

    CSegment* const
    _AllocateSegment() const;

    bool
    _FreeSegment(
        CSegment* pseg) const;

#ifdef LOCK_INSTRUMENTATION
    static LONG sm_cTables;

    static const TCHAR*
    _LockName()
    {
        LONG l = ++sm_cTables;
        // possible race condition but we don't care, as this is never
        // used in production code
        static TCHAR s_tszName[CLockStatistics::L_NAMELEN];
        wsprintf(s_tszName, _TEXT("LH%05x"), 0xFFFFF & l);
        return s_tszName;
    }

    // Statistics for the table lock
    CLockStatistics _LockStats() const
    { return m_Lock.Statistics(); }
#endif // LOCK_INSTRUMENTATION

private:

    // Fields are ordered so as to minimize number of cache lines touched

    DWORD         m_dwSignature;    // debugging: id & corruption check
    CHAR          m_szName[NAME_SIZE];  // an identifier for debugging
    mutable LK_RETCODE m_lkrcState; // Internal state of table
    mutable TableLock m_Lock;       // Lock on entire linear hash table

    // type-specific function pointers
    PFnExtractKey   m_pfnExtractKey;    // Extract key from record
    PFnCalcKeyHash  m_pfnCalcKeyHash;   // Calculate hash signature of key
    PFnEqualKeys    m_pfnEqualKeys;     // Compare two keys
    PFnAddRefRecord m_pfnAddRefRecord;  // AddRef a record

    LK_TABLESIZE  m_lkts;           // "size" of table: small, medium, or large
    DWORD         m_dwSegBits;      // C{Small,Medium,Large}Segment::SEGBITS
    DWORD         m_dwSegSize;      // C{Small,Medium,Large}Segment::SEGSIZE
    DWORD         m_dwSegMask;      // C{Small,Medium,Large}Segment::SEGMASK
    double        m_MaxLoad;        // max load factor (average chain length)

    DWORD         m_dwBktAddrMask0; // mask used for address calculation
    DWORD         m_dwBktAddrMask1; // used in _H1 calculation
    DWORD         m_iExpansionIdx;  // address of next bucket to be expanded
    CDirEntry*    m_paDirSegs;      // directory of table segments
    DWORD         m_nLevel;         // number of table doublings performed
    DWORD         m_cDirSegs;       // segment directory size: varies between
                                    // MIN_DIRSIZE and MAX_DIRSIZE
    DWORD         m_cRecords;       // number of records in the table
    DWORD         m_cActiveBuckets; // number of buckets in use (table size)

    WORD          m_wBucketLockSpins;// default spin count for bucket locks

    const BYTE    m_nTableLockType; // for debugging: LOCK_SPINLOCK, etc
    const BYTE    m_nBucketLockType;// for debugging: LOCK_SPINLOCK, etc
    const CLKRHashTable* const m_phtParent;// Owning table. NULL => standalone

    const bool    m_fMultiKeys;     // Allow multiple identical keys?

#ifndef LKR_NO_GLOBAL_LIST
    static CLockedDoubleList sm_llGlobalList;// All active CLKRLinearHashTables
    CListEntry    m_leGlobalList;
#endif // !LKR_NO_GLOBAL_LIST

    void        _InsertThisIntoGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        // Only add standalone CLKRLinearHashTables to global list.
        // CLKRHashTables have their own global list.
        if (m_phtParent == NULL)
            sm_llGlobalList.InsertHead(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    void        _RemoveThisFromGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        if (m_phtParent == NULL)
            sm_llGlobalList.RemoveEntry(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    // Non-trivial implementation functions
    LK_RETCODE   _InsertRecord(const void* pvRecord, DWORD dwSignature,
                               bool fOverwrite
#ifdef LKR_STL_ITERATORS
                             , Iterator* piterResult=NULL
#endif // LKR_STL_ITERATORS
                               );
    LK_RETCODE   _DeleteKey(const DWORD_PTR pnKey, DWORD dwSignature);
    LK_RETCODE   _DeleteRecord(const void* pvRecord, DWORD dwSignature);
    bool         _DeleteNode(CBucket* pbkt, CNodeClump*& rpnc,
                             CNodeClump*& rpncPrev, int& riNode);
    LK_RETCODE   _FindKey(const DWORD_PTR pnKey, DWORD dwSignature,
                          const void** ppvRecord
#ifdef LKR_STL_ITERATORS
                        , Iterator* piterResult=NULL
#endif // LKR_STL_ITERATORS
                          ) const;
    LK_RETCODE   _FindRecord(const void* pvRecord, DWORD dwSignature) const;

    // returns count of errors in compacted state => 0 is good
    int          _IsNodeCompact(CBucket* const pbkt) const;


#ifdef LKR_APPLY_IF
    // Predicate functions
    static LK_PREDICATE WINAPI
    _PredTrue(const void* /*pvRecord*/, void* /*pvState*/)
    { return LKP_PERFORM; }

    DWORD        _Apply(PFnRecordAction pfnAction, void* pvState,
                        LK_LOCKTYPE lkl, LK_PREDICATE& rlkp);
    DWORD        _ApplyIf(PFnRecordPred   pfnPredicate,
                          PFnRecordAction pfnAction, void* pvState,
                          LK_LOCKTYPE lkl, LK_PREDICATE& rlkp);
    DWORD        _DeleteIf(PFnRecordPred pfnPredicate, void* pvState,
                           LK_PREDICATE& rlkp);
#endif // LKR_APPLY_IF

    void         _Clear(bool fShrinkDirectory);
    LK_RETCODE   _SetSegVars(LK_TABLESIZE lkts, DWORD cInitialBuckets);
    LK_RETCODE   _Expand();
    LK_RETCODE   _Contract();
    LK_RETCODE   _SplitRecordSet(CNodeClump* pncOldTarget,
                                 CNodeClump* pncNewTarget,
                                 DWORD       iExpansionIdx,
                                 DWORD       dwBktAddrMask,
                                 DWORD       dwNewBkt,
                                 CNodeClump* pncFreeList);
    LK_RETCODE   _MergeRecordSets(CBucket*    pbktNewTarget,
                                  CNodeClump* pncOldList,
                                  CNodeClump* pncFreeList);

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // TODO: implement these properly; they could be useful.

    CLKRLinearHashTable(const CLKRLinearHashTable&);
    CLKRLinearHashTable& operator=(const CLKRLinearHashTable&);

private:
    // This ctor is used by CLKRHashTable
    CLKRLinearHashTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double          maxload,        // Upperbound on average chain length
        DWORD           initsize,       // Initial size of hash table.
        CLKRHashTable*  phtParent,      // Owning table.
        bool            fMultiKeys      // Allow multiple identical keys?
        );

    LK_RETCODE
    _Initialize(
        PFnExtractKey   pfnExtractKey,
        PFnCalcKeyHash  pfnCalcKeyHash,
        PFnEqualKeys    pfnEqualKeys,
        PFnAddRefRecord pfnAddRefRecord,
        LPCSTR          pszName,
        double          maxload,
        DWORD           initsize);

public:
    CLKRLinearHashTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double   maxload=LK_DFLT_MAXLOAD,// Upperbound on average chain length
        DWORD    initsize=LK_DFLT_INITSIZE, // Initial size of hash table.
        DWORD    num_subtbls=LK_DFLT_NUM_SUBTBLS, // for signature compatiblity
                                                  // with CLKRHashTable
        bool            fMultiKeys=false  // Allow multiple identical keys?
        );

    ~CLKRLinearHashTable();

    static const TCHAR* ClassName()
    {return _TEXT("CLKRLinearHashTable");}

    int                NumSubTables() const  {return 1;}

    bool               MultiKeys() const
    {
        return false;
        // return m_fMultiKeys;     // TODO: implement
    }

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);

    // Insert a new record into hash table.
    // Returns LK_SUCCESS if all OK, LK_KEY_EXISTS if same key already
    // exists (unless fOverwrite), LK_ALLOC_FAIL if out of space,
    // or LK_BAD_RECORD for a bad record.
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false)
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;
        
        return _InsertRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)),
                             fOverwrite);
    }

    // Delete record with the given key.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteKey(const DWORD_PTR pnKey)
    {
        if (!IsUsable())
            return m_lkrcState;
        
        return _DeleteKey(pnKey, _CalcKeyHash(pnKey));
    }

    // Delete a record from the table, if present.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteRecord(const void* pvRecord)
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;
        
        return _DeleteRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }

    // Find record with given key.
    // Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
    //           LK_BAD_RECORD, if ppvRecord is invalid
    //           LK_NO_SUCH_KEY, if no record with given key value was found
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is AddRef'd.  You must decrement the reference
    // count when you are finished with the record (if you're implementing
    // refcounting semantics).
    LK_RETCODE     FindKey(const DWORD_PTR pnKey,
                           const void** ppvRecord) const
    {
        if (!IsUsable())
            return m_lkrcState;
        
        if (ppvRecord == NULL)
            return LK_BAD_RECORD;
        
        return _FindKey(pnKey, _CalcKeyHash(pnKey), ppvRecord);
    }

    // Sees if the record is contained in the table
    // Returns:  LK_SUCCESS, if record found
    //           LK_BAD_RECORD, if pvRecord is invalid
    //           LK_NO_SUCH_KEY, if record is not in the table
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is *not* AddRef'd.
    LK_RETCODE     FindRecord(const void* pvRecord) const
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;
        
        return _FindRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }


#ifdef LKR_APPLY_IF
    // Walk the hash table, applying pfnAction to all records.
    // Locks the whole table for the duration with either a (possibly
    // shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          Apply(PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Walk the hash table, applying pfnAction to any records that match
    // pfnPredicate.  Locks the whole table for the duration with either
    // a (possibly shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          ApplyIf(PFnRecordPred   pfnPredicate,
                           PFnRecordAction pfnAction,
                           void*           pvState=NULL,
                           LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Delete any records that match pfnPredicate.
    // Locks the table for the duration with a writelock.
    // Returns the number of deletions.
    //
    // Do *not* walk the hash table by hand with an iterator and call
    // DeleteKey.  The iterator will end up pointing to garbage.
    DWORD          DeleteIf(PFnRecordPred pfnPredicate,
                            void*         pvState=NULL);
#endif // LKR_APPLY_IF


    // Check table for consistency.  Returns 0 if okay, or the number of
    // errors otherwise.
    int            CheckTable() const;

    // Remove all data from the table
    void           Clear()
    {
        WriteLock();
        _Clear(true);
        WriteUnlock();
    }

    // Number of elements in the table
    DWORD          Size() const
    { return m_cRecords; }

    // Maximum possible number of elements in the table
    DWORD          MaxSize() const
    { return static_cast<DWORD>(m_MaxLoad * MAX_DIRSIZE * m_dwSegSize); }

    // Get hash table statistics
    CLKRHashTableStats GetStatistics() const;

    // Is the hash table usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }
    
    // Is the hash table consistent and correct?
    bool           IsValid() const
    {
        STATIC_ASSERT(((MIN_DIRSIZE & (MIN_DIRSIZE-1)) == 0)  // == (1 << N)
                      &&  ((1 << 3) <= MIN_DIRSIZE)
                      &&  (MIN_DIRSIZE < MAX_DIRSIZE)
                      &&  ((MAX_DIRSIZE & (MAX_DIRSIZE-1)) == 0)
                      &&  (MAX_DIRSIZE <= (1 << 30)));

        bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
                  &&  m_paDirSegs != NULL
                  &&  MIN_DIRSIZE <= m_cDirSegs  &&  m_cDirSegs <= MAX_DIRSIZE
                  &&  (m_cDirSegs & (m_cDirSegs-1)) == 0
                  &&  m_pfnExtractKey != NULL
                  &&  m_pfnCalcKeyHash != NULL
                  &&  m_pfnEqualKeys != NULL
                  &&  m_pfnAddRefRecord != NULL
                  &&  m_cActiveBuckets > 0
                  &&  ValidSignature()
                  );
        if (!f)
            m_lkrcState = LK_UNUSABLE;
        return f;
    }

    // Set the spin count on the table lock
    void        SetTableLockSpinCount(WORD wSpins)
    { m_Lock.SetSpinCount(wSpins); }

    // Get the spin count on the table lock
    WORD        GetTableLockSpinCount() const
    { return m_Lock.GetSpinCount(); }

    // Set/Get the spin count on the bucket locks
    void        SetBucketLockSpinCount(WORD wSpins);
    WORD        GetBucketLockSpinCount() const;

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('L' << 16) | ('H' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('L' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}


    //
    // Lock manipulators
    //

    // Lock the table (exclusively) for writing
    void        WriteLock()
    { m_Lock.WriteLock(); }

    // Lock the table (possibly shared) for reading
    void        ReadLock() const
    { m_Lock.ReadLock(); }

    // Unlock the table for writing
    void        WriteUnlock() const
    { m_Lock.WriteUnlock(); }

    // Unlock the table for reading
    void        ReadUnlock() const
    { m_Lock.ReadUnlock(); }

    // Is the table already locked for writing?
    bool        IsWriteLocked() const
    { return m_Lock.IsWriteLocked(); }

    // Is the table already locked for reading?
    bool        IsReadLocked() const
    { return m_Lock.IsReadLocked(); }

    // Is the table unlocked for writing?
    bool        IsWriteUnlocked() const
    { return m_Lock.IsWriteUnlocked(); }

    // Is the table unlocked for reading?
    bool        IsReadUnlocked() const
    { return m_Lock.IsReadUnlocked(); }

    // Convert the read lock to a write lock
    void  ConvertSharedToExclusive() const
    { m_Lock.ConvertSharedToExclusive(); }

    // Convert the write lock to a read lock
    void  ConvertExclusiveToShared() const
    { m_Lock.ConvertExclusiveToShared(); }

    // LKRHASH_ALLOCATOR_DEFINITIONS(CLKRLinearHashTable);


#ifdef LKR_DEPRECATED_ITERATORS

public:

    // Iterators can be used to walk the table.  To ensure a consistent
    // view of the data, the iterator locks the whole table.  This can
    // have a negative effect upon performance, because no other thread
    // can do anything with the table.  Use with care.
    //
    // You should not use an iterator to walk the table, calling DeleteKey,
    // as the iterator will end up pointing to garbage.
    //
    // Use Apply, ApplyIf, or DeleteIf instead of iterators to safely
    // walk the tree. Or use the STL-style iterators.
    //
    // Note that iterators acquire a reference to the record pointed to
    // and release that reference as soon as the iterator is incremented.
    // In other words, this code is safe:
    //     lkrc = ht.IncrementIterator(&iter);
    //     // assume lkrc == LK_SUCCESS for the sake of this example
    //     CMyHashTable::Record* pRec = iter.Record();
    //     Foo(pRec);  // uses pRec but doesn't hang on to it
    //     lkrc = ht.IncrementIterator(&iter);
    //
    // But this code is not safe because pRec is used out of the scope of
    // the iterator that provided it:
    //     lkrc = ht.IncrementIterator(&iter);
    //     CMyHashTable::Record* pRec = iter.Record();
    //     // Broken code: Should have called ht.AddRefRecord(pRec, +1) here
    //     lkrc = ht.IncrementIterator(&iter);
    //     Foo(pRec);   // Unsafe: because no longer have a valid reference
    //
    // If the record has no reference-counting semantics, then you can
    // ignore the above remarks about scope.


    class CIterator
    {
    protected:
        friend class CLKRLinearHashTable;

        CLKRLinearHashTable* m_plht;        // which linear hash table?
        DWORD               m_dwBucketAddr; // bucket index
        CNodeClump*         m_pnc;          // a CNodeClump in bucket
        int                 m_iNode;        // offset within m_pnc
        LK_LOCKTYPE         m_lkl;          // readlock or writelock?

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // Must provide (bad) implementation because we export instantiations.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : m_plht(NULL),
              m_dwBucketAddr(0),
              m_pnc(NULL),
              m_iNode(-1),
              m_lkl(lkl)
        {}

        // Return the record associated with this iterator
        const void* Record() const
        {
            IRTLASSERT(IsValid());

            return ((m_pnc != NULL
                        &&  m_iNode >= 0
                        &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    ?  m_pnc->m_pvNode[m_iNode]
                    :  NULL);
        }

        // Return the key associated with this iterator
        const DWORD_PTR Key() const
        {
            IRTLASSERT(m_plht != NULL);
            const void* pRec = Record();
            return ((pRec != NULL  &&  m_plht != NULL)
                    ?  m_plht->_ExtractKey(pRec)
                    :  NULL);
        }

        bool IsValid() const
        {
            return ((m_plht != NULL)
                    &&  (m_pnc != NULL)
                    &&  (0 <= m_iNode
                         &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    &&  (!m_pnc->IsEmptyNode(m_iNode)));
        }

        // Delete the record that the iterator points to.  Does an implicit
        // IncrementIterator after deletion.
        LK_RETCODE     DeleteRecord();

        // Change the record that the iterator points to.  The new record
        // must have the same key as the old one.
        LK_RETCODE     ChangeRecord(const void* pNewRec);
    }; // class CIterator


    // Const iterators for readonly access.  You must use these with
    // const CLKRLinearHashTables.
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    }; // class CConstIterator


private:
    // The public APIs lock the table.  The private ones, which are used
    // directly by CLKRHashTable, don't.
    LK_RETCODE     _InitializeIterator(CIterator* piter);
    LK_RETCODE     _CloseIterator(CIterator* piter);

public:
    // Initialize the iterator to point to the first item in the hash table
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        if (piter == NULL  ||  piter->m_plht != NULL)
            return LK_BAD_ITERATOR;

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteLock();
        else
            ReadLock();

        return _InitializeIterator(piter);
    }

    // The const iterator version
    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        ReadLock();
        return const_cast<CLKRLinearHashTable*>(this)
                    ->_InitializeIterator(static_cast<CIterator*>(piter));
    }

    // Move the iterator on to the next item in the table.
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     IncrementIterator(CIterator* piter);

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRLinearHashTable*>(this)
                    ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    // Close the iterator.
    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        if (piter == NULL  ||  piter->m_plht != this)
            return LK_BAD_ITERATOR;
        _CloseIterator(piter);

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteUnlock();
        else
            ReadUnlock();

        return LK_SUCCESS;
    };

    // Close the CConstIterator
    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        const_cast<CLKRLinearHashTable*>(this)
             ->_CloseIterator(static_cast<CIterator*>(piter));

        ReadUnlock();
        return LK_SUCCESS;
    };

#endif // LKR_DEPRECATED_ITERATORS


#ifdef LKR_STL_ITERATORS

private:
    bool _Erase(Iterator& riter, DWORD dwSignature);
    bool _Find(DWORD_PTR pnKey, DWORD dwSignature, Iterator& riterResult);

    bool _IsValidIterator(const Iterator& riter) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH:_IsValidIterator(%p)\n"), &riter);
        bool fValid = ((riter.m_plht == this)
                       &&  (riter.m_dwBucketAddr < m_cActiveBuckets)
                       &&  riter.IsValid());
        IRTLASSERT(fValid);
        return fValid;
    }

public:
    // Return iterator pointing to first item in table
    Iterator
    Begin();

    // Return a one-past-the-end iterator. Always empty.
    Iterator
    End()
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::End\n"));
        return Iterator();
    }

    // Insert a record
    // Returns `true' if successful; iterResult points to that record
    // Returns `false' otherwise; iterResult == End()
    bool
    Insert(
        /* in */  const void* pvRecord,
        /* out */ Iterator&   riterResult,
        /* in */  bool        fOverwrite=false);

    // Erase the record pointed to by the iterator; adjust the iterator
    // to point to the next record. Returns `true' if successful.
    bool
    Erase(
        /* in,out */ Iterator& riter);

    // Erase the records in the range [riterFirst, riterLast).
    // Returns `true' if successful.
    bool
    Erase(
        /*in*/ Iterator& riterFirst,
        /*in*/ Iterator& riterLast);
    
    // Find the (first) record that has its key == pnKey.
    // If successful, returns `true' and iterator points to (first) record.
    // If fails, returns `false' and iterator == End()
    bool
    Find(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterResult);

    // Find the range of records that have their keys == pnKey.
    // If successful, returns `true', iterFirst points to first record,
    //     and iterLast points to one-beyond-the last such record.
    // If fails, returns `false' and both iterators == End().
    // Primarily useful when m_fMultiKey == true
    bool
    EqualRange(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterFirst,     // inclusive
        /* out */ Iterator& riterLast);     // exclusive

#endif // LKR_STL_ITERATORS

}; // class CLKRLinearHashTable



#ifdef LKR_STL_ITERATORS

// These functions have to be defined after CLKRLinearHashTable

inline void
CLKRLinearHashTable_Iterator::_AddRef(
    int nIncr) const
{
    // TODO: should iterator call _AddRefRecord at all
    if (m_plht != NULL  &&  m_iNode != NODE_BEGIN - NODE_STEP)
    {
        IRTLASSERT((0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP)
                   &&  (unsigned) m_iNode < NODES_PER_CLUMP
                   &&  m_pnc != NULL
                   &&  (nIncr == -1 ||  nIncr == +1));
        const void* pvRecord = m_pnc->m_pvNode[m_iNode];
        IRTLASSERT(pvRecord != NULL);
        LKR_ITER_TRACE(_TEXT("  LKLH::AddRef, this=%p, Rec=%p\n"),
                       this, pvRecord);
        m_plht->_AddRefRecord(pvRecord, nIncr);
    }
} // CLKRLinearHashTable_Iterator::_AddRef


inline const DWORD_PTR
CLKRLinearHashTable_Iterator::Key() const
{
    IRTLASSERT(IsValid());
    return m_plht->_ExtractKey(m_pnc->m_pvNode[m_iNode]);
} // CLKRLinearHashTable_Iterator::Key

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// CLKRHashTable
//
// To improve concurrency, a hash table is divided into a number of
// (independent) subtables. Each subtable is a linear hash table. The
// number of subtables is defined when the table is created and remains
// fixed thereafter. Records are assigned to subtables based on their
// hashed key.
//
// For small or low-contention hashtables, you can bypass this
// thin wrapper and use CLKRLinearHashTable directly.  The methods are
// documented in the declarations for CLKRHashTable (above).
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRHashTable
{
private:
    typedef CLKRLinearHashTable SubTable;

public:
    typedef SubTable::TableLock  TableLock;
    typedef SubTable::BucketLock BucketLock;

#ifdef LKR_DEPRECATED_ITERATORS
    class CIterator;
    friend class CLKRHashTable::CIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_STL_ITERATORS
    friend class CLKRHashTable_Iterator;
    typedef CLKRHashTable_Iterator Iterator;
#endif // LKR_STL_ITERATORS

    friend class CLKRLinearHashTable;

    // aliases for convenience
    enum {
        NAME_SIZE = SubTable::NAME_SIZE,
        HASH_INVALID_SIGNATURE = SubTable::HASH_INVALID_SIGNATURE,
        NODES_PER_CLUMP = SubTable::NODES_PER_CLUMP,
    };

    enum {
        MAX_SUBTABLES = 64,
    };

private:
    // Hash table parameters
    DWORD          m_dwSignature;   // debugging: id & corruption check
    CHAR           m_szName[NAME_SIZE]; // an identifier for debugging
    DWORD          m_cSubTables;    // number of subtables
    SubTable**     m_palhtDir;      // array of subtables

    // type-specific function pointers
    PFnExtractKey  m_pfnExtractKey;
    PFnCalcKeyHash m_pfnCalcKeyHash;
    mutable LK_RETCODE m_lkrcState;     // Internal state of table
    int            m_nSubTableMask;

#ifndef LKR_NO_GLOBAL_LIST
    static CLockedDoubleList sm_llGlobalList; // All active CLKRHashTables
    CListEntry     m_leGlobalList;
#endif // !LKR_NO_GLOBAL_LIST

    void
    _InsertThisIntoGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        sm_llGlobalList.InsertHead(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    void
    _RemoveThisFromGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        sm_llGlobalList.RemoveEntry(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    LKRHASH_GLOBAL_LOCK_DECLARATIONS();

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // TODO: implement these properly; they could be useful.
    CLKRHashTable(const CLKRHashTable&);
    CLKRHashTable& operator=(const CLKRHashTable&);


    // Extract the key from the record
    const DWORD_PTR  _ExtractKey(const void* pvRecord) const
    {
        IRTLASSERT(pvRecord != NULL);
        IRTLASSERT(m_pfnExtractKey != NULL);
        return (*m_pfnExtractKey)(pvRecord);
    }

    // Hash the key
    DWORD        _CalcKeyHash(const DWORD_PTR pnKey) const
    {
        // Note pnKey==0 is acceptable, as the real key type could be an int
        IRTLASSERT(m_pfnCalcKeyHash != NULL);
        DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);
        // We forcibly scramble the result to help ensure a better distribution
#ifndef __HASHFN_NO_NAMESPACE__
        dwHash = HashFn::HashRandomizeBits(dwHash);
#else // !__HASHFN_NO_NAMESPACE__
        dwHash = ::HashRandomizeBits(dwHash);
#endif // !__HASHFN_NO_NAMESPACE__
        IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);
        return dwHash;
    }

    // Use the key's hash signature to multiplex into a subtable
    SubTable*    _SubTable(DWORD dwSignature) const;

    // Find the index of pst within the subtable array
    int          _SubTableIndex(SubTable* pst) const;

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    static SubTable** const
    _AllocateSubTableArray(
        size_t n);

    static bool
    _FreeSubTableArray(
        SubTable** palht);

    static SubTable* const
    _AllocateSubTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double          maxload,        // Upperbound on average chain length
        DWORD           initsize,       // Initial size of hash table.
        CLKRHashTable*  phtParent,      // Owning table.
        bool            fMultiKeys      // Allow multiple identical keys?
    );

    static bool
    _FreeSubTable(
        SubTable* plht);


public:
    CLKRHashTable(
        LPCSTR   pszName,               // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double    maxload=LK_DFLT_MAXLOAD,      // bound on avg chain length
        DWORD     initsize=LK_DFLT_INITSIZE,    // Initial size of hash table.
        DWORD     num_subtbls=LK_DFLT_NUM_SUBTBLS, // #subordinate hash tables.
        bool            fMultiKeys=false  // Allow multiple identical keys?
        );

    ~CLKRHashTable();

    static const TCHAR* ClassName()
    {return _TEXT("CLKRHashTable");}

    int                NumSubTables() const  {return m_cSubTables;}

    bool               MultiKeys() const;
    
    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);


    // Thin wrappers for the corresponding methods in CLKRLinearHashTable
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false);
    LK_RETCODE     DeleteKey(const DWORD_PTR pnKey);
    LK_RETCODE     DeleteRecord(const void* pvRecord);
    LK_RETCODE     FindKey(const DWORD_PTR pnKey,
                           const void** ppvRecord) const;
    LK_RETCODE     FindRecord(const void* pvRecord) const;

#ifdef LKR_APPLY_IF
    DWORD          Apply(PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          ApplyIf(PFnRecordPred   pfnPredicate,
                           PFnRecordAction pfnAction,
                           void*           pvState=NULL,
                           LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          DeleteIf(PFnRecordPred pfnPredicate,
                            void*         pvState=NULL);
#endif // LKR_APPLY_IF

    void           Clear();
    int            CheckTable() const;
    DWORD          Size() const;
    DWORD          MaxSize() const;
    CLKRHashTableStats GetStatistics() const;
    bool           IsValid() const;

    void           SetTableLockSpinCount(WORD wSpins);
    WORD           GetTableLockSpinCount() const;
    void           SetBucketLockSpinCount(WORD wSpins);
    WORD           GetBucketLockSpinCount() const;

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('H' << 16) | ('T' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('H' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}

    // Is the hash table usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }
    
    void        WriteLock();
    void        ReadLock() const;
    void        WriteUnlock() const;
    void        ReadUnlock() const;
    bool        IsWriteLocked() const;
    bool        IsReadLocked() const;
    bool        IsWriteUnlocked() const;
    bool        IsReadUnlocked() const;
    void        ConvertSharedToExclusive() const;
    void        ConvertExclusiveToShared() const;


    // LKRHASH_ALLOCATOR_DEFINITIONS(CLKRHashTable);

#ifdef LKR_DEPRECATED_ITERATORS

public:

    typedef SubTable::CIterator CLHTIterator;

    class CIterator : public CLHTIterator
    {
    protected:
        friend class CLKRHashTable;

        CLKRHashTable*  m_pht;  // which hash table?
        int             m_ist;  // which subtable

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // Must provide (bad) implementation because we export instantiations.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : CLHTIterator(lkl),
              m_pht(NULL),
              m_ist(-1)
        {}

        const void* Record() const
        {
            IRTLASSERT(IsValid());

            // This is a hack to work around a compiler bug.  Calling
            // CLHTIterator::Record calls this function recursively until
            // the stack overflows.
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Record();
        }

        const DWORD_PTR Key() const
        {
            IRTLASSERT(IsValid());
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Key();
        }

        bool IsValid() const
        {
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return (m_pht != NULL  &&  m_ist >= 0  &&  pBase->IsValid());
        }
    };

    // Const iterators for readonly access
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter);
    LK_RETCODE     IncrementIterator(CIterator* piter);
    LK_RETCODE     CloseIterator(CIterator* piter);

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    };

#endif // LKR_DEPRECATED_ITERATORS



#ifdef LKR_STL_ITERATORS

private:
    bool _IsValidIterator(const Iterator& riter) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT:_IsValidIterator(%p)\n"), &riter);
        bool fValid = (riter.m_pht == this);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (0 <= riter.m_ist
                              &&  riter.m_ist < (int) m_cSubTables);
        IRTLASSERT(fValid);
        IRTLASSERT(_SubTableIndex(riter.m_subiter.m_plht) == riter.m_ist);
        fValid = fValid  &&  riter.IsValid();
        IRTLASSERT(fValid);
        return fValid;
    }


public:
    Iterator
    Begin();

    Iterator
    End()
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::End\n"));
        return Iterator();
    }

    bool
    Insert(
        /* in */  const void* pvRecord,
        /* out */ Iterator&   riterResult,
        /* in */  bool        fOverwrite=false);

    bool
    Erase(
        /* in,out */ Iterator& riter);

    bool
    Erase(
        /*in*/ Iterator& riterFirst,
        /*in*/ Iterator& riterLast);
    
    bool
    Find(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterResult);

    bool
    EqualRange(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterFirst,     // inclusive
        /* out */ Iterator& riterLast);     // exclusive

#endif // LKR_STL_ITERATORS

}; // class CLKRHashTable



//--------------------------------------------------------------------
// A typesafe wrapper for CLKRHashTable (or CLKRLinearHashTable).
//
// * _Derived must derive from CTypedHashTable and provide certain member
//   functions.  It's needed for various downcasting operations.  See
//   CStringTestHashTable and CNumberTestHashTable below.
// * _Record is the type of the record.  C{Linear}HashTable will store
//   pointers to _Record.
// * _Key is the type of the key.  _Key is used directly; i.e., it is
//   not assumed to be a pointer type.  C{Linear}HashTable assumes that
//   the key is stored in the associated record.  See the comments
//   at the declaration of PFnExtractKey for more details.
//
// (optional parameters):
// * _BaseHashTable is the base hash table: CLKRHashTable or
///   CLKRLinearHashTable
// * _BaseIterator is the iterator type, _BaseHashTable::CIterator
//
// CTypedHashTable could derive directly from CLKRLinearHashTable, if you
// don't need the extra overhead of CLKRHashTable (which is quite low).
//
// You may need to add the following line to your code to disable
// warning messages about truncating extremly long identifiers.
//   #pragma warning (disable : 4786)
//--------------------------------------------------------------------


template < class _Derived, class _Record, class _Key,
           class _BaseHashTable=CLKRHashTable
#ifdef LKR_DEPRECATED_ITERATORS
         , class _BaseIterator=_BaseHashTable::CIterator
#endif // LKR_DEPRECATED_ITERATORS
         >
class CTypedHashTable : public _BaseHashTable
{
public:
    // convenient aliases
    typedef _Derived        Derived;
    typedef _Record         Record;
    typedef _Key            Key;
    typedef _BaseHashTable  BaseHashTable;

    typedef CTypedHashTable<_Derived, _Record, _Key, _BaseHashTable
#ifdef LKR_DEPRECATED_ITERATORS
                            , _BaseIterator
#endif // LKR_DEPRECATED_ITERATORS
                            > HashTable;
#ifdef LKR_DEPRECATED_ITERATORS
    typedef _BaseIterator   BaseIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_APPLY_IF
    // ApplyIf() and DeleteIf(): Does the record match the predicate?
    // Note: takes a Record*, not a const Record*.  You can modify the
    // record in Pred() or Action(), if you like, but if you do, you
    // should use LKL_WRITELOCK to lock the table.
    typedef LK_PREDICATE (WINAPI *PFnRecordPred) (Record* pRec, void* pvState);

    // Apply() et al: Perform action on record.
    typedef LK_ACTION   (WINAPI *PFnRecordAction)(Record* pRec, void* pvState);
#endif // LKR_APPLY_IF

private:

    // Wrappers for the typesafe methods exposed by the derived class

    static const DWORD_PTR WINAPI
    _ExtractKey(const void* pvRecord)
    {
        const _Record* pRec = static_cast<const _Record*>(pvRecord);
        const _Key   key = static_cast<const _Key>(_Derived::ExtractKey(pRec));
        // I would prefer to use reinterpret_cast here and in _CalcKeyHash
        // and _CompareKeys, but the stupid Win64 compiler thinks it knows
        // better than I do.
        return (const DWORD_PTR) key;
    }

    static DWORD WINAPI
    _CalcKeyHash(const DWORD_PTR pnKey)
    {
        const _Key key = (const _Key) (DWORD_PTR) pnKey;
        return _Derived::CalcKeyHash(key);
    }

    static bool WINAPI
    _EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2)
    {
        const _Key key1 = (const _Key) (DWORD_PTR) pnKey1;
        const _Key key2 = (const _Key) (DWORD_PTR) pnKey2;
        return _Derived::EqualKeys(key1, key2);
    }

    static void WINAPI
    _AddRefRecord(const void* pvRecord, int nIncr)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        _Derived::AddRefRecord(pRec, nIncr);
    }


#ifdef LKR_APPLY_IF
    // Typesafe wrappers for Apply, ApplyIf, and DeleteIf.

    class CState
    {
    public:
        PFnRecordPred   m_pfnPred;
        PFnRecordAction m_pfnAction;
        void*           m_pvState;

        CState(
            PFnRecordPred   pfnPred,
            PFnRecordAction pfnAction,
            void*           pvState)
            : m_pfnPred(pfnPred), m_pfnAction(pfnAction), m_pvState(pvState)
        {}
    };

    static LK_PREDICATE WINAPI
    _Pred(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnPred)(pRec, pState->m_pvState);
    }

    static LK_ACTION WINAPI
    _Action(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnAction)(pRec, pState->m_pvState);
    }
#endif // LKR_APPLY_IF

public:
    CTypedHashTable(
        LPCSTR pszName,                       // An identifier for debugging
        double maxload=LK_DFLT_MAXLOAD,       // Upperbound on avg chain len
        DWORD  initsize=LK_DFLT_INITSIZE,     // Initial size of table: S/M/L
        DWORD  num_subtbls=LK_DFLT_NUM_SUBTBLS,// #subordinate hash tables.
        bool   fMultiKeys=false               // Allow multiple identical keys?
        )
        : _BaseHashTable(pszName, _ExtractKey, _CalcKeyHash, _EqualKeys,
                            _AddRefRecord, maxload, initsize, num_subtbls,
                            fMultiKeys)
    {
        // Ensure that _Key is no bigger than a pointer. Because we
        // support both numeric and pointer keys, the various casts
        // in the member functions unfortunately silently truncate if
        // _Key is an unacceptable numeric type, such as __int64 on x86.
        STATIC_ASSERT(sizeof(_Key) <= sizeof(DWORD_PTR));
    }

    LK_RETCODE   InsertRecord(const _Record* pRec, bool fOverwrite=false)
    { return _BaseHashTable::InsertRecord(pRec, fOverwrite); }

    LK_RETCODE   DeleteKey(const _Key key)
    {
        DWORD_PTR pnKey = (DWORD_PTR) key;
        return _BaseHashTable::DeleteKey(pnKey);
    }

    LK_RETCODE   DeleteRecord(const _Record* pRec)
    { return _BaseHashTable::DeleteRecord(pRec);}

    // Note: returns a _Record**, not a const Record**.  Note that you
    // can use a const type for the template parameter to ensure constness.
    LK_RETCODE   FindKey(const _Key key, _Record** ppRec) const
    {
        if (ppRec == NULL)
            return LK_BAD_RECORD;
        *ppRec = NULL;
        const void* pvRec = NULL;
        DWORD_PTR pnKey = (DWORD_PTR) key;
        LK_RETCODE lkrc = _BaseHashTable::FindKey(pnKey, &pvRec);
        *ppRec = static_cast<_Record*>(const_cast<void*>(pvRec));
        return lkrc;
    }

    LK_RETCODE   FindRecord(const _Record* pRec) const
    { return _BaseHashTable::FindRecord(pRec);}


    // Other C{Linear}HashTable methods can be exposed without change


#ifdef LKR_APPLY_IF

public:

    // Typesafe wrappers for Apply et al

    DWORD        Apply(PFnRecordAction pfnAction,
                       void*           pvState=NULL,
                       LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnAction != NULL);
        if (pfnAction == NULL)
            return 0;

        CState   state(NULL, pfnAction, pvState);
        return   _BaseHashTable::Apply(_Action, &state, lkl);
    }

    DWORD        ApplyIf(PFnRecordPred   pfnPredicate,
                         PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);
        if (pfnPredicate == NULL  ||  pfnAction == NULL)
            return 0;

        CState   state(pfnPredicate, pfnAction, pvState);
        return   _BaseHashTable::ApplyIf(_Pred, _Action, &state, lkl);
    }

    DWORD        DeleteIf(PFnRecordPred pfnPredicate, void* pvState=NULL)
    {
        IRTLASSERT(pfnPredicate != NULL);
        if (pfnPredicate == NULL)
            return 0;

        CState   state(pfnPredicate, NULL, pvState);
        return   _BaseHashTable::DeleteIf(_Pred, &state);
    }
#endif // LKR_APPLY_IF



#ifdef LKR_DEPRECATED_ITERATORS
    // Typesafe wrappers for iterators


    class CIterator : public _BaseIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : _BaseIterator(lkl)
        {}

        _Record*  Record() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Record*>(const_cast<void*>(
                        pBase->Record()));
        }

        _Key      Key() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Key>(reinterpret_cast<void*>(pBase->Key()));
        }
    };

    // readonly iterator
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}

        const _Record*  Record() const
        {
            return CIterator::Record();
        }

        const _Key      Key() const
        {
            return CIterator::Key();
        }
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        return _BaseHashTable::InitializeIterator(piter);
    }

    LK_RETCODE     IncrementIterator(CIterator* piter)
    {
        return _BaseHashTable::IncrementIterator(piter);
    }

    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        return _BaseHashTable::CloseIterator(piter);
    }

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    }

#endif // LKR_DEPRECATED_ITERATORS



#ifdef LKR_STL_ITERATORS

    // TODO: const_iterator

public:

    class iterator
    {
        friend class CTypedHashTable<_Derived, _Record, _Key,
                                     _BaseHashTable
 #ifdef LKR_DEPRECATED_ITERATORS
                                     , _BaseIterator
 #endif // LKR_DEPRECATED_ITERATORS
        >;

    protected:
        typename _BaseHashTable::Iterator            m_iter;

        iterator(
            const typename _BaseHashTable::Iterator& rhs)
            : m_iter(rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::prot ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

    public:
        typedef std::forward_iterator_tag   iterator_category;
        typedef _Record                     value_type;
        typedef ptrdiff_t                   difference_type;
        typedef size_t                      size_type;
        typedef value_type&                 reference;
        typedef value_type*                 pointer;

        iterator()
            : m_iter()
        {
            LKR_ITER_TRACE(_TEXT("Typed::default ctor, this=%p\n"), this);
        }

        iterator(
            const iterator& rhs)
            : m_iter(rhs.m_iter)
        {
            LKR_ITER_TRACE(_TEXT("Typed::copy ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

        iterator& operator=(
            const iterator& rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator=, this=%p, rhs=%p\n"),
                           this, &rhs);
            m_iter = rhs.m_iter;
            return *this;
        }

        ~iterator()
        {
            LKR_ITER_TRACE(_TEXT("Typed::dtor, this=%p\n"), this);
        }

        pointer   operator->() const
        {
            return (reinterpret_cast<_Record*>(
                        const_cast<void*>(m_iter.Record())));
        }

        reference operator*() const
        {
            return * (operator->());
        }

        // pre-increment
        iterator& operator++()
        {
            LKR_ITER_TRACE(_TEXT("Typed::pre-increment, this=%p\n"), this);
            m_iter.Increment();
            return *this;
        }

        // post-increment
        iterator  operator++(int)
        {
            LKR_ITER_TRACE(_TEXT("Typed::post-increment, this=%p\n"), this);
            iterator iterPrev = *this;
            m_iter.Increment();
            return iterPrev;
        }

        bool operator==(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator==, this=%p, rhs=%p\n"),
                           this, &rhs);
            return m_iter == rhs.m_iter;
        }

        bool operator!=(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator!=, this=%p, rhs=%p\n"),
                           this, &rhs);
            return m_iter != rhs.m_iter;
        }

        _Record*  Record() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Record, this=%p\n"), this);
            return reinterpret_cast<_Record*>(
                        const_cast<void*>(m_iter.Record()));
        }

        _Key      Key() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Key, this=%p\n"), this);
            return reinterpret_cast<_Key>(
                        reinterpret_cast<void*>(m_iter.Key()));
        }
    }; // class iterator

    // Return iterator pointing to first item in table
    iterator begin()
    {
        LKR_ITER_TRACE(_TEXT("Typed::begin()\n"));
        return iterator(_BaseHashTable::Begin());
    }

    // Return a one-past-the-end iterator. Always empty.
    iterator end()
    {
        LKR_ITER_TRACE(_TEXT("Typed::end()\n"));
        return iterator(_BaseHashTable::End());
    }

    template <class _InputIterator>
    CTypedHashTable(
        LPCSTR pszName,                       // An identifier for debugging
        _InputIterator f,                     // first element in range
        _InputIterator l,                     // one-beyond-last element
        double maxload=LK_DFLT_MAXLOAD,       // Upperbound on avg chain len
        DWORD  initsize=LK_DFLT_INITSIZE,     // Initial size of table: S/M/L
        DWORD  num_subtbls=LK_DFLT_NUM_SUBTBLS,// #subordinate hash tables.
        bool   fMultiKeys=false               // Allow multiple identical keys?
        )
        : _BaseHashTable(pszName, _ExtractKey, _CalcKeyHash, _EqualKeys,
                         _AddRefRecord, maxload, initsize, num_subtbls,
                         fMultiKeys)
    {
        insert(f, l);
    }

    template <class _InputIterator>
    void insert(_InputIterator f, _InputIterator l)
    {
        for ( ;  f != l;  ++f)
            InsertRecord(&(*f));
    }

    bool
    Insert(
        const _Record* pRecord,
        iterator& riterResult,
        bool fOverwrite=false)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Insert\n"));
        return _BaseHashTable::Insert(pRecord, riterResult.m_iter, fOverwrite);
    }

    bool
    Erase(
        iterator& riter)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase\n"));
        return _BaseHashTable::Erase(riter.m_iter);
    }

    bool
    Erase(
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase2\n"));
        return _BaseHashTable::Erase(riterFirst.m_iter, riterLast.m_iter);
    }
    
    bool
    Find(
        const _Key key,
        iterator& riterResult)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Find\n"));
        const void* pvKey = reinterpret_cast<const void*>(key);
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::Find(pnKey, riterResult.m_iter);
    }

    bool
    EqualRange(
        const _Key key,
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::EqualRange\n"));
        const void* pvKey = reinterpret_cast<const void*>(key);
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::EqualRange(pnKey, riterFirst.m_iter,
                                          riterLast.m_iter);
    }

    // The iterator functions for an STL hash_(|multi)_(set|map)
    //
    // Value type of a Pair-Associative Container is
    //     pair<const key_type, mapped_type>
    //
    // pair<iterator,bool> insert(const value_type& x);
    //
    // void erase(iterator pos);
    // void erase(iterator f, iterator l);
    //
    // iterator find(const key_type& k) [const];
    // const_iterator find(const key_type& k) const;
    //
    // pair<iterator,iterator> equal_range(const key_type& k) [const];
    // pair<const_iterator,const_iterator> equal_range(const key_type& k) const


#endif // LKR_STL_ITERATORS
};



#ifndef __LKRHASH_NO_NAMESPACE__
}
#endif // !__LKRHASH_NO_NAMESPACE__


#endif // __LKRHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\rc4sha1.h ===
/*++

    Copyright (c) 2000 - 2001 Microsoft Corporation

    Module Name:

        rc4sha1.h

    Author:

        Tony Chen (tonychen) 4-Dec-2000

--*/

#ifndef __RC4SHA1_H
#define __RC4SHA1_H

#include "sha.h"
#include "rc4.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// define the rc4 sha crypto system to be th one used
//
#define XCRYPT_STATE_BUFFER RC4_SHA_HMAC_STATE_BUFFER
#define PXCRYPT_STATE_BUFFER PRC4_SHA_HMAC_STATE_BUFFER
#define XCRYPT_HEADER RC4_SHA_HEADER
#define PXCRYPT_HEADER PRC4_SHA_HEADER

#define XCRYPT_KEY_SIZE XRC4SHA_KEY_SIZE
#define XCRYPT_MAC_SIZE XRC4SHA_MAC_SIZE
#define XCRYPT_STATE_SIZE XRC4SHA_STATE_SIZE
#define XCRYPT_HEADER_SIZE XRC4SHA_HEADER_SIZE

#define XcryptHashPassword Xrc4shaHashPassword
#define XcryptInitialize Xrc4shaInitialize
#define XcryptEncrypt Xrc4shaEncrypt
#define XcryptDecrypt Xrc4shaDecrypt
#define XcryptComputeMAC Xrc4shaComputeMAC

//
// Define the real RC4 SHA1 structures and functions
//
#define RC4_CONFOUNDER_LEN  8

typedef struct _RC4_SHA_HEADER {
    BYTE Checksum[A_SHA_DIGEST_LEN];
    BYTE Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA_HEADER, *PRC4_SHA_HEADER;

typedef struct _RC4_SHA_HMAC_STATE_BUFFER {
    BYTE Key[A_SHA_DIGEST_LEN];
} RC4_SHA_HMAC_STATE_BUFFER, *PRC4_SHA_HMAC_STATE_BUFFER;

#define XRC4SHA_KEY_SIZE A_SHA_DIGEST_LEN
#define XRC4SHA_MAC_SIZE A_SHA_DIGEST_LEN
#define XRC4SHA_STATE_SIZE sizeof(RC4_SHA_HMAC_STATE_BUFFER)
#define XRC4SHA_HEADER_SIZE sizeof(RC4_SHA_HEADER)

// Generate a Key of size XRC4SHA_KEY_SIZE from the password
void Xrc4shaHashPassword(
    IN PCHAR szPassword,
    OUT PBYTE pbKey);

// Initialize the state buffer for encrypt, decrypt, and MAC computation
// psbBuffer must be of size XRC4SHA_STATE_SIZE
void Xrc4shaInitialize(
    PBYTE pbKey,
    DWORD cbKey,
    OUT PRC4_SHA_HMAC_STATE_BUFFER psbBuffer);

// Encrypt input to output using key in state buffer
// The output should be XRC4SHA_HEADER_SIZE bytes larger the input
void Xrc4shaEncrypt(
    IN PRC4_SHA_HMAC_STATE_BUFFER psbBuffer,
    IN PBYTE pbInput,
    IN DWORD cbInput,
    OUT PBYTE pbOutput,
    OUT PDWORD pcbOutput);
    
// Decrypt the input to output using key in state buffer
// The output should be XRC4SHA_HEADER_SIZE bytes smaller the input
BOOL Xrc4shaDecrypt(
    IN PRC4_SHA_HMAC_STATE_BUFFER psbBuffer,
    IN PBYTE pbInput,
    IN DWORD cbInput,
    OUT PBYTE pbOutput,
    OUT PDWORD pcbOutput);

// Compute HMAC of input. Output will be XRC4SHA_MAC_SIZE bytes
void Xrc4shaComputeMAC(
    IN PRC4_SHA_HMAC_STATE_BUFFER psbBuffer,
    IN PBYTE pbInput,
    IN DWORD cbInput,
    OUT PBYTE pbMAC);

#ifdef __cplusplus
}
#endif

#endif // __RC4SHA1_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\lstentry.h ===
/*++

   Copyright    (c)    1999-2000    Microsoft Corporation

   Module  Name :
       lstentry.h

   Abstract:
       Declares CListEntry and other intrusive singly- and doubly-linked lists

   Author:
       George V. Reilly      (GeorgeRe)     02-Mar-1999

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __LSTENTRY_H__
#define __LSTENTRY_H__

#ifndef __LOCKS_H__
# include <locks.h>
#endif // !__LOCKS_H__

// TODO:
// * Add STL-style iterators: begin(), end(), operator++(), etc
// * Templatize the lists, so that you can avoid the CONTAINING_RECORD goo

//--------------------------------------------------------------------
// CSingleListEntry: a node in a singly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CSingleListEntry
{
public:
    CSingleListEntry* Next;  // forward link
};



//--------------------------------------------------------------------
// A non-threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CSingleList
{
protected:
    CSingleListEntry m_sleHead; // external head node

public:
    CSingleList()
    {
        m_sleHead.Next = NULL;
    }

    ~CSingleList()
    {
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_sleHead.Next == NULL;
    }

    CSingleListEntry* const
    Pop()
    {
        CSingleListEntry* psle = m_sleHead.Next;

        if (psle != NULL)
            m_sleHead.Next = psle->Next;

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        psle->Next     = m_sleHead.Next;
        m_sleHead.Next = psle;
    }
};


//--------------------------------------------------------------------
// A threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedSingleList
{
protected:
    CSpinLock   m_lock;
    CSingleList m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedSingleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION

    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    CSingleListEntry* const
    Pop()
    {
        Lock();
        CSingleListEntry* const psle = m_list.Pop();
        Unlock();

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        Lock();
        m_list.Push(psle);
        Unlock();
    }
};



//--------------------------------------------------------------------
// CListEntry: a node in a circular doubly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CListEntry
{
public:
    CListEntry* Flink;  // forward link
    CListEntry* Blink;  // backward link
};


//--------------------------------------------------------------------
// A non-threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CDoubleList
{
protected:
    CListEntry  m_leHead; // external head node

public:
    CDoubleList()
    {
        m_leHead.Flink = m_leHead.Blink = &m_leHead;
    }

    ~CDoubleList()
    {
        IRTLASSERT(m_leHead.Flink != NULL  &&  m_leHead.Blink != NULL);
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_leHead.Flink == &m_leHead;
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        ple->Blink        = &m_leHead;
        ple->Flink        = m_leHead.Flink;
        ple->Flink->Blink = ple;
        m_leHead.Flink    = ple;
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        ple->Flink        = &m_leHead;
        ple->Blink        = m_leHead.Blink;
        ple->Blink->Flink = ple;
        m_leHead.Blink    = ple;
    }

    const CListEntry* const
    HeadNode() const
    {
        return &m_leHead;
    }

    CListEntry* const
    First() const
    {
        return m_leHead.Flink;
    }

    CListEntry* const
    RemoveHead()
    {
        CListEntry* ple = First();
        RemoveEntry(ple);
        return ple;
    }

    CListEntry* const
    Last() const
    {
        return m_leHead.Blink;
    }

    CListEntry* const
    RemoveTail()
    {
        CListEntry* ple = Last();
        RemoveEntry(ple);
        return ple;
    }

    static void
    RemoveEntry(
        CListEntry* const ple)
    {
        CListEntry* const pleOldBlink = ple->Blink;
        IRTLASSERT(pleOldBlink != NULL);
        CListEntry* const pleOldFlink = ple->Flink;
        IRTLASSERT(pleOldFlink != NULL);

        pleOldBlink->Flink = pleOldFlink;
        pleOldFlink->Blink = pleOldBlink;
    }
};


//--------------------------------------------------------------------
// A threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedDoubleList
{
protected:
    CSpinLock   m_lock;
    CDoubleList m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedDoubleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION
    
    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertHead(ple);
        Unlock();
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertTail(ple);
        Unlock();
    }

    // not threadsafe
    const CListEntry* const
    HeadNode() const
    {
        return m_list.HeadNode();
    }

    // not threadsafe
    CListEntry* const
    First()
    {
        return m_list.First();
    }

    CListEntry* const
    RemoveHead()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveHead();
        Unlock();
        return ple;
    }

    // not threadsafe
    CListEntry* const
    Last()
    {
        return m_list.Last();
    }

    CListEntry* const
    RemoveTail()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveTail();
        Unlock();
        return ple;
    }

    void
    RemoveEntry(
        CListEntry* const ple)
    {
        Lock();
        m_list.RemoveEntry(ple);
        Unlock();
    }
};


#ifndef CONTAINING_RECORD
//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) \
            ((type *)((PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))

#endif // !CONTAINING_RECORD


#endif // __LSTENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\winsockp.h ===
#ifndef _WINSOCKP_H
#define _WINSOCKP_H


#ifdef XNET_FEATURE_VXBOX

#define VXSOCK_PREFIX(api) VXSock_##api

#define WSAStartup                  VXSOCK_PREFIX(WSAStartup)
#define WSACleanup                  VXSOCK_PREFIX(WSACleanup)
#define socket                      VXSOCK_PREFIX(socket)
#define closesocket                 VXSOCK_PREFIX(closesocket)
#define shutdown                    VXSOCK_PREFIX(shutdown)
#define ioctlsocket                 VXSOCK_PREFIX(ioctlsocket)
#define setsockopt                  VXSOCK_PREFIX(setsockopt)
#define getsockopt                  VXSOCK_PREFIX(getsockopt)
#define getsockname                 VXSOCK_PREFIX(getsockname)
#define getpeername                 VXSOCK_PREFIX(getpeername)
#define bind                        VXSOCK_PREFIX(bind)
#define connect                     VXSOCK_PREFIX(connect)
#define listen                      VXSOCK_PREFIX(listen)
#define accept                      VXSOCK_PREFIX(accept)
#define select                      VXSOCK_PREFIX(select)
#define WSAGetOverlappedResult      VXSOCK_PREFIX(WSAGetOverlappedResult)
#define WSACancelOverlappedIO       VXSOCK_PREFIX(WSACancelOverlappedIO)
#define recv                        VXSOCK_PREFIX(recv)
#define WSARecv                     VXSOCK_PREFIX(WSARecv)
#define recvfrom                    VXSOCK_PREFIX(recvfrom)
#define WSARecvFrom                 VXSOCK_PREFIX(WSARecvFrom)
#define send                        VXSOCK_PREFIX(send)
#define WSASend                     VXSOCK_PREFIX(WSASend)
#define sendto                      VXSOCK_PREFIX(sendto)
#define WSASendTo                   VXSOCK_PREFIX(WSASendTo)
#define inet_addr                   VXSOCK_PREFIX(inet_addr)
#define htonl                       VXSOCK_PREFIX(htonl)
#define htons                       VXSOCK_PREFIX(htons)
#define ntohl                       VXSOCK_PREFIX(ntohl)
#define ntohs                       VXSOCK_PREFIX(ntohs)
#define WSAGetLastError             VXSOCK_PREFIX(WSAGetLastError)
#define WSASetLastError             VXSOCK_PREFIX(WSASetLastError)
#define WSACreateEvent              VXSOCK_PREFIX(WSACreateEvent)
#define WSACloseEvent               VXSOCK_PREFIX(WSACloseEvent)
#define WSASetEvent                 VXSOCK_PREFIX(WSASetEvent)
#define WSAResetEvent               VXSOCK_PREFIX(WSAResetEvent)
#define WSAWaitForMultipleEvents    VXSOCK_PREFIX(WSAWaitForMultipleEvents)
#define __WSAFDIsSet                VXSOCK_PREFIX(__WSAFDIsSet)

#endif
#ifdef __cplusplus
extern "C" {
#endif


// ---------------------------------------------------------------------------------------
// Virtual Xbox configuration
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_VXBOX

struct XNetVXboxConfig
{
    DWORD   _dwTitleID;                 // Self-explanatory
    DWORD   _dwTitleVersion;            // Self-explanatory
    DWORD   _dwLanguage;                // XC_LANGUAGE_XXX value to use (english == 1)
    IN_ADDR _inaNicToBind;              // IP addr of NIC to use, or INADDR_ANY
    WORD    _wPortVXbox;                // UDP port to use, or zero for auto-assigned port
    IN_ADDR _inaProxy;                  // IP addr of the LSP proxy
    WORD    _wPortProxy;                // TCP port to contact the proxy (0 = default)
    char    _achRootPath[128];          // Complete drive + path to use as root directory for VXbox Hal
    WORD    _fOverrideKey;              // Should the following value be used?
    BYTE    _abKeyShaLan[16];           // Override value to use for interop with pre-6/03 XDKs
    UINT    _cbKeyExXbToTsMin;          // Minimum size of key exchange initiator
    WORD    _wXbToTsTimeoutInSecs;      // Secs of no inbound data/pulse before disconnecting
    WORD    _wXbToTsPulseTimeoutInSecs; // Secs of no outbound data/pulse before sending SECMSG_TYPE_XBTOSG_PULSE
};

#ifdef __cplusplus
extern "C" {
#endif

BOOL WSAAPI XNetConfigureVXbox(const XNetVXboxConfig *pConfig);

DWORD WSAAPI XGetLanguage();

#ifdef __cplusplus
}
#endif

#endif

#ifdef __cplusplus
}
#endif


#define TCP_RESET                       0x5001      // Special socket option to reset TCP socket and peer

#define XNET_QOS_LOOKUP_SERVICE         0x80000000  // Special flag to XNetQosLookup used by XNetQosServiceLookup

// ---------------------------------------------------------------------------------------
// XNet Configuration
// ---------------------------------------------------------------------------------------

#define XNET_STARTUP_MANUAL_CONFIG      0x80        // XNetStartup won't configure to defaults

#include <pshpack1.h>

typedef struct {
    BYTE                abSeed[20];                 // Last random seed
    IN_ADDR             inaLegacy;                  // Legacy IP address (0 for DHCP)
    IN_ADDR             inaMaskLegacy;              // Legacy subnet mask
    IN_ADDR             inaGatewayLegacy;           // Legacy default gateway
    IN_ADDR             inaDnsPrimaryLegacy;        // Legacy primary DNS server
    IN_ADDR             inaDnsSecondaryLegacy;      // Legacy secondary DNS server
    BYTE                abHash[20];                 // HMAC hash from dwSigBeg through dwSigEnd
    DWORD               dwSigBeg;                   // XNET_CONFIG_PARAMS_SIGBEG
    WORD                wFlags;                     // XNCP_FLAGS_*
    BYTE                abEnet[6];                  // Spoofed ethernet address
    IN_ADDR             ina;                        // Static IP address
    IN_ADDR             inaMask;                    // Static IP subnet mask
    IN_ADDR             inaGateway;                 // Static IP address of default gateway
    IN_ADDR             ainaDnsServers[2];          // Static IP addresses of DNS servers
    char                achDhcpHostName[40];        // Host name to send to DHCP servers
    char                achPppoeUserName[64];       // User name for PPPoE configuration
    char                achPppoePassword[64];       // Password for PPPoE configuration
    char                achPppoeServer[40];         // Server name for PPPoE configuration
    char                achPppoeService[40];        // Service name for PPPoE configuration
    LARGE_INTEGER       liTimeOfLease;              // System time of last DHCP lease (0 if no lease)
    DWORD               dwSecsInLease;              // Secs from lease acquire to expiration
    IN_ADDR             inaLease;                   // IP address of DHCP lease
    IN_ADDR             inaMaskLease;               // IP subnet mask of DHCP lease
    IN_ADDR             inaServerLease;             // IP address of DHCP server granting the lease
    IN_ADDR             ainaGatewaysLease[4];       // IP addresses of gateways configured by the DHCP lease
    IN_ADDR             ainaDnsServersLease[4];     // IP addresses of DNS servers configured by the DHCP lease
    BYTE                abEnetUPnP[6];              // Ethernet address of last gateway checked for UPnP support
    WORD                wPortUPnP;                  // Port mapping assigned by last gateway supporting UPnP
    BYTE                abEnetPppoeServer[6];       // Ethernet address of last PPPoE server session
    WORD                wPppoeSessionId;            // Session Id of last PPPoE server session
    BYTE                abReserved[76];             // Reserved (makes structure 492 bytes)
    DWORD               dwSigEnd;                   // XNET_CONFIG_PARAMS_SIGEND
} XNetConfigParams;

typedef int __farf__XNetConfigParams[sizeof(XNetConfigParams) == 492];

#define XNET_CONFIG_PARAMS_SIGBEG           'XBV2'  // Must never change once any title has shipped
#define XNET_CONFIG_PARAMS_SIGEND           'XBCP'  // Must never change

#define XNET_CONFIG_NORMAL                  0x0000  // Configure normally
#define XNET_CONFIG_TROUBLESHOOT            0x0001  // Configure for troubleshooter in DASH
#define XNET_CONFIG_TROUBLESHOOT_PING       0x0002  // Answer ICMP echo requests (ping)
#define XNET_CONFIG_TROUBLESHOOT_PPPOE      0x0004  // Look for PPPoE concentrators only

#define XNCP_FLAGS_ETHERNET_SPOOF           0x0001  // Use abEnet as spoofed ethernet address
#define XNCP_FLAGS_IP_PPPOE                 0x0002  // Use PPPoE configuration of IP/mask/gateways
#define XNCP_FLAGS_IP_STATIC                0x0004  // Use manual configuration of IP/mask/gateways
#define XNCP_FLAGS_DNS_STATIC               0x0008  // Use manual configuration of DNS servers
#define XNCP_FLAGS_DHCP_HOST_NAME           0x0010  // Send host name to DHCP server

typedef struct {
    char            achServer[40];                  // Name of PPPoE server
    UINT            cpchService;                    // Number of services offereed
    char *          apchService[8];                 // Pointers to serivces offered by PPPoE server
    char            achBuffer[8 * 40];              // Buffer for service strings
} XNetConfigPppoe;

typedef struct {
    DWORD               dwFlags;                    // See XNET_STATUS_* below
    IN_ADDR             ina;                        // IP address
    IN_ADDR             inaMask;                    // IP subnet mask
    IN_ADDR             ainaGateways[4];            // IP addresses of gateways
    IN_ADDR             ainaDnsServers[4];          // IP addresses of DNS servers
    UINT                cConfigPppoe;               // Number of PPPoE servers discovered
    XNetConfigPppoe *   pConfigPppoe;               // Vector of PPPoE servers discovered
    BOOL                fConfigUPnP;                // TRUE if UPnP negotiation should be performed
    WORD                wPortUPnP;                  // UPnP port mapping added last time
} XNetConfigStatus;

#define XNET_STATUS_COMPLETE                            0x00000001  // XNet configuration is complete
#define XNET_STATUS_IP_PPPOE                            0x00000002  // XNet configuration attempted using PPPoE
#define XNET_STATUS_IP_STATIC                           0x00000004  // XNet configuration attempted statically
#define XNET_STATUS_DNS_STATIC                          0x00000008  // XNet configuration used static DNS

#define XNET_STATUS_ETHERNET_UNPLUGGED                  0x00000010  // Ethernet cable is not plugged in
#define XNET_STATUS_ETHERNET_SPOOFED                    0x00000020  // Ethernet address is being spoofed (not factory)
#define XNET_STATUS_ETHERNET_INVALID                    0x00000040  // Ethernet abEnet is an invalid address
#define XNET_STATUS_DNS_SERVERS_INVALID                 0x00000080  // Static ainaDnsServers has an invalid address

#define XNET_STATUS_STATIC_INA_INVALID                  0x00000100  // Static ina is an invalid address
#define XNET_STATUS_STATIC_INA_MASK_INVALID             0x00000200  // Static inaMask is invalid subnet mask
#define XNET_STATUS_STATIC_INA_GATEWAY_INVALID          0x00000400  // Static inaGateway is an invalid address
#define XNET_STATUS_STATIC_INA_IN_USE                   0x00000800  // Static ina is in use by another host
#define XNET_STATUS_STATIC_INA_GATEWAY_NO_RESPONSE      0x00001000  // Static inaGateway failed to respond to ARP request

#define XNET_STATUS_DHCP_HOST_NAME_INVALID              0x00000100  // DHCP host name field is invalid
#define XNET_STATUS_DHCP_SAVED_LEASE_EXPIRED            0x00000200  // DHCP saved lease is expired and not being used
#define XNET_STATUS_DHCP_SAVED_LEASE_INVALID            0x00000400  // DHCP saved lease is invalid and not being used
#define XNET_STATUS_DHCP_SAVED_LEASE_UNCONFIRMED        0x00000800  // DHCP server failed to respond; using saved lease
#define XNET_STATUS_DHCP_PACKET_DHCPDISCOVER_SENT       0x00001000  // DHCP packet type DHCPDISCOVER was sent
#define XNET_STATUS_DHCP_PACKET_DHCPOFFER_RECEIVED      0x00002000  // DHCP packet type DHCPOFFER was received
#define XNET_STATUS_DHCP_PACKET_DHCPREQUEST_SENT        0x00004000  // DHCP packet type DHCPREQUEST was sent
#define XNET_STATUS_DHCP_PACKET_DHCPACK_RECEIVED        0x00008000  // DHCP packet type DHCPACK was received
#define XNET_STATUS_DHCP_PACKET_DHCPINFORM_SENT         0x00010000  // DHCP packet type DHCPINFORM was sent
#define XNET_STATUS_DHCP_PACKET_DHCPNAK_RECEIVED        0x00020000  // DHCP packet type DHCPNAK was received
#define XNET_STATUS_DHCP_PACKET_DHCPDECLINE_SENT        0x00040000  // DHCP packet type DHCPDECLINE was sent
#define XNET_STATUS_DHCP_PACKET_INVALID                 0x00080000  // DHCP packet was invalid
#define XNET_STATUS_DHCP_PACKET_MESSAGE_TYPE_INVALID    0x00100000  // DHCP packet had invalid message type
#define XNET_STATUS_DHCP_PACKET_SERVERID_INVALID        0x00200000  // DHCP packet had invalid server id option
#define XNET_STATUS_DHCP_PACKET_INA_YOURS_INVALID       0x00400000  // DHCP packet had invalid ipaY
#define XNET_STATUS_DHCP_PACKET_LEASE_TIME_INVALID      0x00800000  // DHCP packet had invalid lease time option
#define XNET_STATUS_DHCP_PACKET_SUBNET_MASK_INVALID     0x01000000  // DHCP packet had invalid subnet mask option
#define XNET_STATUS_DHCP_PACKET_DHCPACK_UNEXPECTED      0x02000000  // DHCP packet type DHCPACK received unexpectedly
#define XNET_STATUS_DHCP_PACKET_DHCPOFFER_UNEXPECTED    0x04000000  // DHCP packet type DHCPOFFER received unexpectedly
#define XNET_STATUS_DHCP_PACKET_DHCPNAK_UNEXPECTED      0x08000000  // DHCP packet type DHCPNAK received unecpectedly
#define XNET_STATUS_DHCP_PACKET_RENEW_MISMATCH          0x10000000  // DHCP renewal tried to change ipa or ipaMask
#define XNET_STATUS_DHCP_INA_IN_USE                     0x20000000  // DHCP server failed to respond; saved IP in use
#define XNET_STATUS_DHCP_UNABLE_TO_OBTAIN_LEASE         0x40000000  // DHCP client was unable to negotiate a lease

#define XNET_STATUS_PPPOE_USER_NAME_INVALID             0x00000100  // PPPoE user name field is invalid
#define XNET_STATUS_PPPOE_PASSWORD_INVALID              0x00000200  // PPPoE password field is invalid
#define XNET_STATUS_PPPOE_SERVER_INVALID                0x00000400  // PPPoE server field is invalid
#define XNET_STATUS_PPPOE_SERVICE_INVALID               0x00000800  // PPPoE service field is invalid
#define XNET_STATUS_PPPOE_PHASE_MASK                    0x00003000  // PPPoE current phase mask
#define XNET_STATUS_PPPOE_PHASE_INFO_MASK               0x0FFFC000  // PPPoE information about current phase
#define XNET_STATUS_PPPOE_PHASE_DISCOVER                0x00000000  // PPPoE is discovering concentrator
#define XNET_STATUS_PPPOE_PHASE_LCP                     0x00001000  // PPPoE is negotiating link configuration 
#define XNET_STATUS_PPPOE_PHASE_AUTH                    0x00002000  // PPPoE is authenticating
#define XNET_STATUS_PPPOE_PHASE_IPCP                    0x00003000  // PPPoE is negotiating protocol configuration
#define XNET_STATUS_PPPOE_PADI_SENT                     0x00004000  // PPPoE discover type PADI was sent
#define XNET_STATUS_PPPOE_PADO_RECEIVED                 0x00008000  // PPPoE discover type PADO was received
#define XNET_STATUS_PPPOE_PADR_SENT                     0x00010000  // PPPoE discover type PADR was sent
#define XNET_STATUS_PPPOE_PADS_RECEIVED                 0x00020000  // PPPoE discover type PADS was received
#define XNET_STATUS_PPPOE_PADX_PACKET_MALFORMED         0x00040000  // PPPoE discover packet was malformed
#define XNET_STATUS_PPPOE_PADX_PACKET_LACKS_HOST_UNIQ   0x00080000  // PPPoE discover packet lacked HOST_UNIQ tag
#define XNET_STATUS_PPPOE_PADX_PACKET_LACKS_AC_NAME     0x00100000  // PPPoE discover packet lacked AC_NAME tag
#define XNET_STATUS_PPPOE_PADX_PACKET_MISMATCH_AC_NAME  0x00200000  // PPPoE discover packet AC_NAME tag didn't match
#define XNET_STATUS_PPPOE_PADX_PACKET_MISMATCH_SERVICE  0x00400000  // PPPoE discover packet SERVICE tag didn't match
#define XNET_STATUS_PPPOE_PADX_PACKET_INVALID_SESSIONID 0x00800000  // PPPoE discover packet had invalid wSessionId
#define XNET_STATUS_PPPOE_LCP_REQ_SENT                  0x00004000  // PPPoE LCP/IPCP req was sent
#define XNET_STATUS_PPPOE_LCP_ACK_SENT                  0x00008000  // PPPoE LCP/IPCP ack was sent
#define XNET_STATUS_PPPOE_LCP_NAK_SENT                  0x00010000  // PPPoE LCP/IPCP nak was sent
#define XNET_STATUS_PPPOE_LCP_REJ_SENT                  0x00020000  // PPPoE LCP/IPCP rej was sent
#define XNET_STATUS_PPPOE_LCP_REQ_RECV                  0x00040000  // PPPoE LCP/IPCP req was received
#define XNET_STATUS_PPPOE_LCP_ACK_RECV                  0x00080000  // PPPoE LCP/IPCP ack was received
#define XNET_STATUS_PPPOE_LCP_NAK_RECV                  0x00100000  // PPPoE LCP/IPCP nak was received
#define XNET_STATUS_PPPOE_LCP_REJ_RECV                  0x00200000  // PPPoE LCP/IPCP rej was received
#define XNET_STATUS_PPPOE_LCP_PACKET_MALFORMED          0x00400000  // PPPoE LCP/IPCP packet was malformed
#define XNET_STATUS_PPPOE_LCP_INA_NOT_OFFERED           0x00800000  // PPPoE server refused to offer an IP address
#define XNET_STATUS_PPPOE_LCP_INA_DNS_NOT_OFFERED       0x01000000  // PPPoE server refused to offer any DNS servers
#define XNET_STATUS_PPPOE_AUTH_PAP                      0x00004000  // PPPoE PAP authentication attempted
#define XNET_STATUS_PPPOE_AUTH_CHAP                     0x00008000  // PPPoE CHAP authentication attempted
#define XNET_STATUS_PPPOE_AUTH_FAILED                   0x00010000  // PPPoE authentication failed (bad credentials)
#define XNET_STATUS_PPPOE_AUTH_PACKET_MALFORMED         0x00020000  // PPPOE PAP/CHAP packet was malformed
#define XNET_STATUS_PPPOE_PADT_RECEIVED                 0x10000000  // PPPoE discover packet type PADT was received
#define XNET_STATUS_PPPOE_LCPT_RECEIVED                 0x20000000  // PPPoE LCP/IPCP termreq/coderej/protrej was received
#define XNET_STATUS_PPPOE_TIMEOUT                       0x40000000  // PPPoE configuration failed due to timeout

#define XNET_STATUS_TROUBLE                             0x80000000  // Requested configuration failed

#include <poppack.h>

#ifdef __cplusplus
extern "C" {
#endif

INT     WSAAPI XnInit(void ** ppXn, char * pchXbox, const XNetStartupParams * pxnsp, BOOL fWsa, WORD wVersionRequired, LPWSADATA lpWSAData);
INT     WSAAPI XnTerm(void ** ppXn, BOOL fWsa);

INT     WSAAPI XNetConfig(const XNetConfigParams * pxncp, DWORD dwFlags);
INT     WSAAPI XNetGetConfigStatus(XNetConfigStatus * pxncs);

HANDLE  WSAAPI XNetOpenConfigVolume();
BOOL    WSAAPI XNetLoadConfigSector(HANDLE hVolume, UINT iSector, BYTE * pbData, UINT cbData);
BOOL    WSAAPI XNetSaveConfigSector(HANDLE hVolume, UINT iSector, const BYTE * pbData, UINT cbData);
BOOL    WSAAPI XNetCloseConfigVolume(HANDLE hVolume);

BOOL    WSAAPI XNetLoadConfigParams(XNetConfigParams * pxncp);
BOOL    WSAAPI XNetSaveConfigParams(const XNetConfigParams * pxncp);
BOOL    WSAAPI XNetUpdateConfigParams(BOOL fForce, BOOL fShutdown);

BOOL    WSAAPI XNetConfigUPnP(WORD wPortUPnP);

typedef struct {
    UINT    cbCap;          // [IN]  size of this structure (header and buffer)
    BYTE *  pbCapHead;      // [OUT] pointer to first captured frame
    BYTE *  pbCapTail;      // [OUT] pointer just past last captured frame
    UINT    cbCapFree;      // [OUT] size of free space after tail and before head
                            // A circular buffer of XNetCapFrame structures
} XNetCapBuffer;

typedef struct {
    UINT    cbSize;         // Size of the frame in bytes (including this header)
    DWORD   dwTick;         // Millisecond time of capture (for delta comparison)
                            // A byte array of frame data
} XNetCapFrame;

INT     WSAAPI XNetCapture(XNetCapBuffer * pXnCapBuffer);

typedef void (WSAAPI * PFNXNETRECVRAW)(const BYTE * pb, UINT cb);

INT     WSAAPI XNetTransmit(const BYTE * pb, UINT cb, PFNXNETRECVRAW pfnRecv);

#ifdef __cplusplus
}
#endif

// ---------------------------------------------------------------------------------------
// Hal Api List
// ---------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#ifdef NT_INCLUDED
    NTSTATUS HalNtOpenFile(char * pszXbox, PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);
    NTSTATUS HalNtCreateFile(char * pszXbox, PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions);
    NTSTATUS HalNtReadFile(char * pszXbox, HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset);
    NTSTATUS HalNtWriteFile(char * pszXbox, HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset);
    NTSTATUS HalNtClose(char * pszXbox, HANDLE Handle);

    #define HALNTAPILIST() \
        HALAPI(NTSTATUS, NtOpenFile, (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions), (HALXBOX FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, OpenOptions)) \
        HALAPI(NTSTATUS, NtCreateFile, (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions), (HALXBOX FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions)) \
        HALAPI(NTSTATUS, NtReadFile, (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset), (HALXBOX FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, ByteOffset)) \
        HALAPI(NTSTATUS, NtWriteFile, (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset), (HALXBOX FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, ByteOffset)) \
        HALAPI(NTSTATUS, NtClose, (HANDLE Handle), (HALXBOX Handle))
#else
    #define HALNTAPILIST()
    typedef LONG NTSTATUS;
#endif

HANDLE   HalCreateFile(char * pszXbox, LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
NTSTATUS HalExQueryNonVolatileSetting(char * pszXbox, ULONG ValueIndex, ULONG * Type, VOID * Value, ULONG ValueLength, ULONG * ResultLength);
NTSTATUS HalExSaveNonVolatileSetting(char * pszXbox, ULONG ValueIndex, ULONG Type, const VOID * Value, ULONG ValueLength);
NTSTATUS ExQueryNonVolatileSetting(ULONG ValueIndex, ULONG * Type, VOID * Value, ULONG ValueLength, ULONG * ResultLength);
NTSTATUS ExSaveNonVolatileSetting(ULONG ValueIndex, ULONG Type, const VOID * Value, ULONG ValueLength);

#define HALAPILIST() \
    HALAPI(HANDLE,   CreateFile, (LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile), (HALXBOX lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile)) \
    HALAPI(NTSTATUS, ExQueryNonVolatileSetting, (ULONG ValueIndex, ULONG * Type, VOID * Value, ULONG ValueLength, ULONG * ResultLength), (HALXBOX ValueIndex, Type, Value, ValueLength, ResultLength)) \
    HALAPI(NTSTATUS, ExSaveNonVolatileSetting, (ULONG ValueIndex, ULONG Type, const VOID * Value, ULONG ValueLength), (HALXBOX ValueIndex, Type, Value, ValueLength)) \
    HALNTAPILIST()

#ifdef _XBOX
    #define HALXBOX
#elif defined(XNET_FEATURE_VXBOX)
    #define HALXBOX NULL,
#else
    #define HALXBOX _achXbox,
#endif

#ifdef __cplusplus
}
#endif

// ---------------------------------------------------------------------------------------
// XNet Api List
// ---------------------------------------------------------------------------------------

#define XNETAPILIST() \
    XNETAPI_(INT,       XnInit, (void ** ppXn, char * pchXbox, const XNetStartupParams * pxnsp, BOOL fWsa, WORD wVersionRequired, LPWSADATA lpWSAData), (ppXn, pchXbox, pxnsp, fWsa, wVersionRequired, lpWSAData)) \
    XNETAPI_(INT,       XnTerm, (void ** ppXn, BOOL fWsa), (ppXn, fWsa)) \
    XNETAPI_(INT,       XNetStartup, (const XNetStartupParams * pxnsp), (pxnsp)) \
    XNETAPI_(INT,       XNetCleanup, (), ()) \
    XNETAPI_(HANDLE,    XNetOpenConfigVolume, (), ()) \
    XNETAPI_(BOOL,      XNetLoadConfigSector, (HANDLE hVolume, UINT iSector, BYTE * pbData, UINT cbData), (hVolume, iSector, pbData, cbData)) \
    XNETAPI_(BOOL,      XNetSaveConfigSector, (HANDLE hVolume, UINT iSector, const BYTE * pbData, UINT cbData), (hVolume, iSector, pbData, cbData)) \
    XNETAPI_(BOOL,      XNetCloseConfigVolume, (HANDLE hVolume), (hVolume)) \
    XNETAPI_(BOOL,      XNetLoadConfigParams, (XNetConfigParams * pxncp), (pxncp)) \
    XNETAPI_(BOOL,      XNetSaveConfigParams, (const XNetConfigParams * pxncp), (pxncp)) \
    XNETAPI_(BOOL,      XNetUpdateConfigParams, (BOOL fForce, BOOL fShutdown), (fForce, fShutdown)) \
    XNETAPI_(BOOL,      XNetConfigUPnP, (WORD wPortUPnP), (wPortUPnP)) \
    XNETAPI (INT,       XNetConfig, (const XNetConfigParams * pxncp, DWORD dwFlags), (pxncp, dwFlags)) \
    XNETAPI (INT,       XNetGetConfigStatus, (XNetConfigStatus * pxncs), (pxncs)) \
    XNETAPI (INT,       XNetRandom, (BYTE * pb, UINT cb), (pb, cb)) \
    XNETAPI (INT,       XNetCreateKey, (XNKID * pxnkid, XNKEY * pxnkey), (pxnkid, pxnkey)) \
    XNETAPI (INT,       XNetRegisterKey, (const XNKID * pxnkid, const XNKEY * pxnkey), (pxnkid, pxnkey)) \
    XNETAPI (INT,       XNetUnregisterKey, (const XNKID * pxnkid), (pxnkid)) \
    XNETAPI (INT,       XNetXnAddrToInAddr, (const XNADDR * pxna, const XNKID * pxnkid, IN_ADDR * pina), (pxna, pxnkid, pina)) \
    XNETAPI (INT,       XNetServerToInAddr, (const IN_ADDR ina, DWORD dwServiceId, IN_ADDR * pina), (ina, dwServiceId, pina)) \
    XNETAPI (INT,       XNetTsAddrToInAddr, (const TSADDR * ptsa, DWORD dwServiceId, const XNKID * pxnkid, IN_ADDR * pina), (ptsa, dwServiceId, pxnkid, pina)) \
    XNETAPI (INT,       XNetInAddrToXnAddr, (const IN_ADDR ina, XNADDR * pxna, XNKID * pxnkid), (ina, pxna, pxnkid)) \
    XNETAPI (INT,       XNetInAddrToServer, (const IN_ADDR ina, IN_ADDR *pina), (ina, pina)) \
    XNETAPI (INT,       XNetInAddrToString, (const IN_ADDR ina, char * pchBuf, INT cchBuf), (ina, pchBuf, cchBuf)) \
    XNETAPI (INT,       XNetUnregisterInAddr, (const IN_ADDR ina), (ina)) \
    XNETAPI (INT,       XNetXnAddrToMachineId, (const XNADDR *pxnaddr, ULONGLONG *pqwMachineId), (pxnaddr, pqwMachineId)) \
    XNETAPI (INT,       XNetConnect, (const IN_ADDR ina), (ina)) \
    XNETAPI (DWORD,     XNetGetConnectStatus, (const IN_ADDR ina), (ina)) \
    XNETAPI (INT,       XNetDnsLookup, (const char * pszHost, WSAEVENT hEvent, XNDNS ** ppxndns), (pszHost, hEvent, ppxndns)) \
    XNETAPI (INT,       XNetDnsRelease, (XNDNS * pxndns), (pxndns)) \
    XNETAPI (INT,       XNetQosListen, (const XNKID * pxnkid, const BYTE * pb, UINT cb, DWORD dwBitsPerSec, DWORD dwFlags), (pxnkid, pb, cb, dwBitsPerSec, dwFlags)) \
    XNETAPI (INT,       XNetQosLookup, (UINT cxna, const XNADDR * apxna[], const XNKID * apxnkid[], const XNKEY * apxnkey[], UINT cina, const IN_ADDR aina[], const DWORD adwServiceId[], UINT cProbes, DWORD dwBitsPerSec, DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos), (cxna, apxna, apxnkid, apxnkey, cina, aina, adwServiceId, cProbes, dwBitsPerSec, dwFlags, hEvent, ppxnqos)) \
    XNETAPI (INT,       XNetQosServiceLookup, (DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos), (dwFlags, hEvent, ppxnqos)) \
    XNETAPI (INT,       XNetQosRelease, (XNQOS * pxnqos), (pxnqos)) \
    XNETAPI (DWORD,     XNetGetTitleXnAddr, (XNADDR * pxna), (pxna)) \
    XNETAPI (DWORD,     XNetGetDebugXnAddr, (XNADDR * pxna), (pxna)) \
    XNETAPI_(DWORD,     XNetGetEthernetLinkStatus, (), ()) \
    XNETAPI (INT,       XNetCapture, (XNetCapBuffer * pXnCapBuffer), (pXnCapBuffer)) \
    XNETAPI (DWORD,     XNetGetBroadcastVersionStatus, (BOOL fReset), (fReset)) \
    XNETAPI (INT,       XNetTransmit, (const BYTE * pb, UINT cb, PFNXNETRECVRAW pfnRecv), (pb, cb, pfnRecv)) \

#define SOCKAPILIST() \
    XNETAPI_(INT,       WSAStartup, (WORD wVersionRequired, LPWSADATA lpWSAData), (wVersionRequired, lpWSAData)) \
    XNETAPI_(INT,       WSACleanup, (), ()) \
    XNETAPI (SOCKET,    socket, (IN int af, IN int type, IN int protocol), (af, type, protocol)) \
    XNETAPI (int,       closesocket, (IN SOCKET s), (s)) \
    XNETAPI (int,       shutdown, (IN SOCKET s, IN int how), (s, how)) \
    XNETAPI (int,       ioctlsocket, (SOCKET s, long cmd, u_long* argp), (s, cmd, argp)) \
    XNETAPI (int,       setsockopt, (SOCKET s, int level, int optname, const char* optval, int optlen), (s, level, optname, optval, optlen)) \
    XNETAPI (int,       getsockopt, (SOCKET s, int level, int optname, char * optval, int * optlen), (s, level, optname, optval, optlen)) \
    XNETAPI (int,       getsockname, (SOCKET s, struct sockaddr * name, int * namelen), (s, name, namelen)) \
    XNETAPI (int,       getpeername, (SOCKET s, struct sockaddr * name, int * namelen), (s, name, namelen)) \
    XNETAPI (int,       bind, (SOCKET s, const struct sockaddr * name, int namelen), (s, name, namelen)) \
    XNETAPI (int,       connect, (SOCKET s, const struct sockaddr * name, int namelen), (s, name, namelen)) \
    XNETAPI (int,       listen, (SOCKET s, int backlog), (s, backlog)) \
    XNETAPI (SOCKET,    accept, (SOCKET s, struct sockaddr * addr, int * addrlen), (s, addr, addrlen)) \
    XNETAPI (int,       select, (int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, const struct timeval* timeout), (nfds, readfds, writefds, exceptfds, timeout)) \
    XNETAPI (BOOL,      WSAGetOverlappedResult, (SOCKET s, LPWSAOVERLAPPED overlapped, LPDWORD byteCount, BOOL fWait, LPDWORD flags), (s, overlapped, byteCount, fWait, flags)) \
    XNETAPI (INT,       WSACancelOverlappedIO, (SOCKET s), (s)) \
    XNETAPI (int,       recv, (SOCKET s, char* buf, int len, int flags), (s, buf, len, flags)) \
    XNETAPI (int,       WSARecv, (SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesRecv, LPDWORD flags, LPWSAOVERLAPPED overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc), (s, bufs, bufcnt, bytesRecv, flags, overlapped, completionproc)) \
    XNETAPI (int,       recvfrom, (SOCKET s, char FAR * buf, int len, int flags, struct sockaddr * from, int * fromlen), (s, buf, len, flags, from, fromlen)) \
    XNETAPI (int,       WSARecvFrom, (SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesRecv, LPDWORD flags, struct sockaddr * fromaddr, LPINT fromlen, LPWSAOVERLAPPED overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc), (s, bufs, bufcnt, bytesRecv, flags, fromaddr, fromlen, overlapped, completionproc)) \
    XNETAPI (int,       send, (SOCKET s, const char* buf, int len, int flags), (s, buf, len, flags)) \
    XNETAPI (int,       WSASend, (SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesSent, DWORD flags, LPWSAOVERLAPPED overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc), (s, bufs, bufcnt, bytesSent, flags, overlapped, completionproc)) \
    XNETAPI (int,       sendto, (SOCKET s, const char* buf, int len, int flags, const struct sockaddr* to, int tolen), (s, buf, len, flags, to, tolen)) \
    XNETAPI (int,       WSASendTo, (SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesSent, DWORD flags, const struct sockaddr* toaddr, int tolen, LPWSAOVERLAPPED overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc), (s, bufs, bufcnt, bytesSent, flags, toaddr, tolen, overlapped, completionproc)) \
    XNETAPI_(ULONG,     inet_addr, (const char * pch), (pch)) \
    XNETAPI_(u_long,    htonl, (u_long hostlong), (hostlong)) \
    XNETAPI_(u_short,   htons, (u_short hostshort), (hostshort)) \
    XNETAPI_(u_long,    ntohl, (u_long netlong), (netlong)) \
    XNETAPI_(u_short,   ntohs, (u_short netshort), (netshort)) \
    XNETAPI_(int,       WSAGetLastError, (), ()) \
    XNETAPI_(void,      WSASetLastError, (int error), (error)) \
    XNETAPI_(WSAEVENT,  WSACreateEvent, (), ()) \
    XNETAPI_(BOOL,      WSACloseEvent, (WSAEVENT hEvent), (hEvent)) \
    XNETAPI_(BOOL,      WSASetEvent, (WSAEVENT hEvent), (hEvent)) \
    XNETAPI_(BOOL,      WSAResetEvent, (WSAEVENT hEvent), (hEvent)) \
    XNETAPI_(DWORD,     WSAWaitForMultipleEvents, (DWORD cEvents, const WSAEVENT * lphEvents, BOOL fWaitAll, DWORD dwTimeout, BOOL fAlertable), (cEvents, lphEvents, fWaitAll, dwTimeout, fAlertable)) \
    XNETAPI_(int,       __WSAFDIsSet, (SOCKET fd, fd_set * set), (fd, set)) \

// If the compiler chokes on the following macro expansion, it means that one or more
// of the prototypes defined in this file is out of sync with the prototype in XNETAPILIST
// or SOCKAPILIST.

#ifdef __cplusplus
extern "C" {
#endif

#undef  XNETAPI
#define XNETAPI(ret, fname, arglist, paramlist) ret WSAAPI fname arglist;
#undef  XNETAPI_
#define XNETAPI_(ret, fname, arglist, paramlist) ret WSAAPI fname arglist;

XNETAPILIST()
SOCKAPILIST()

#ifdef __cplusplus
}
#endif

// ---------------------------------------------------------------------------------------
// CXNet
// ---------------------------------------------------------------------------------------

#ifdef __cplusplus

class CXNet
{
    friend class CXn;

public:

    // Constructor -----------------------------------------------------------------------

    #if defined(_XBOX) || defined(XNET_FEATURE_VXBOX)
        __forceinline CXNet(char * pszXbox = NULL) {}
        #define GetAchXbox() NULL
        #define _WSAAPI_ WSAAPI
    #else
        __forceinline CXNet(char * pszXbox = NULL) { _pXn = NULL; SetAchXbox(pszXbox); }
        __forceinline char *    GetAchXbox() { return(_achXbox); }
        __forceinline void      SetAchXbox(char * pszXbox) { _achXbox[sizeof(_achXbox) - 1] = 0; strncpy(_achXbox, pszXbox ? pszXbox : "xb1@Lan", sizeof(_achXbox) - 1); }
        __forceinline CXn *     GetXn() { return(_pXn); }
        __forceinline CXn **    GetXnRef() { return(&_pXn); }
        __forceinline void      SetXn(CXn * pXn) { _pXn = pXn; }
        #define _WSAAPI_ CXNet::
    #endif

    // API -------------------------------------------------------------------------------

    #undef  XNETAPI
    #undef  XNETAPI_
    #undef  HALAPI

    #ifdef _XBOX
        #define XNETAPI(ret, fname, arglist, paramlist) __forceinline ret fname arglist { return(::fname paramlist); }
        #define XNETAPI_(ret, fname, arglist, paramlist) __forceinline ret fname arglist { return(::fname paramlist); }
        #define HALAPI(ret, fname, arglist, paramlist) __forceinline ret fname arglist { return(::fname paramlist); }
    #elif defined(XNET_FEATURE_VXBOX)
        #define XNETAPI(ret, fname, arglist, paramlist) __forceinline ret fname arglist { return(::fname paramlist); }
        #define XNETAPI_(ret, fname, arglist, paramlist) __forceinline ret fname arglist { return(::fname paramlist); }
        #define HALAPI(ret, fname, arglist, paramlist)  __forceinline ret fname arglist { return(Hal##fname paramlist); }
    #else
        #define XNETAPI(ret, fname, arglist, paramlist) ret fname arglist;
        #define XNETAPI_(ret, fname, arglist, paramlist) ret fname arglist;
        #define HALAPI(ret, fname, arglist, paramlist)  __forceinline ret fname arglist { return(Hal##fname paramlist); }
    #endif

    XNETAPILIST()
    SOCKAPILIST()
    HALAPILIST()

    // Data ------------------------------------------------------------------------------

private:

    #if !defined(_XBOX) && !defined(XNET_FEATURE_VXBOX)
        CXn *   _pXn;                       // Pointer to CXn instance of this stack
        char    _achXbox[64];               // Name of this virtual xbox
    #endif
};

#endif

// ---------------------------------------------------------------------------------------
// Simulated Network Address Translator
// ---------------------------------------------------------------------------------------

#if defined(__cplusplus) && !defined(_XBOX)

#define NAT_ASSIGN_MINIMAL          0x00
#define NAT_ASSIGN_AGGRESSIVE       0x01

#define NAT_FILTER_NONE             0x00
#define NAT_FILTER_ADDRESS          0x01
#define NAT_FILTER_PORT             0x02
#define NAT_FILTER_ADDRESS_PORT     0x03

struct NATCREATE
{
    XNetStartupParams * _pxnsp;             // Pointer to startup params (or NULL)
    XNetConfigParams    _xncpInner;         // Inner network configuration
    XNetConfigParams    _xncpOuter;         // Outer network configuration
    char                _achXboxInner[64];  // Inner virtual xbox name
    char                _achXboxOuter[64];  // Outer virtual xbox name
    IN_ADDR             _inaBase;           // Base IP address to give to DHCP clients
    IN_ADDR             _inaLast;           // Last IP address to give to DHCP clients
    DWORD               _dwLeaseTime;       // Default DHCP lease time in seconds
    UINT                _iAssign;           // One of NAT_ASSIGN_* constants
    UINT                _iFilter;           // One of NAT_FILTER_* constants
    UINT                _iTimeout;          // Inactivity timeout in seconds
    UINT                _iNatPortBase;      // Base NAT port to assign
    UINT                _cNatPort;          // Number of NAT ports to assign
};

#ifdef __cplusplus
extern "C" {
#endif

void *  WSAAPI XNetNatCreate(NATCREATE * pNatCreate);
void    WSAAPI XNetNatDelete(void * pvNat);

#ifdef __cplusplus
}
#endif

#endif


#endif  /* _WINSOCKP_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\winsockx.h ===
/* Winsock2.h -- definitions to be used with the WinSock 2 DLL and
 *               WinSock 2 applications.
 *
 * This header file corresponds to version 2.2.x of the WinSock API
 * specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 */

#ifndef _WINSOCK2API_
#define _WINSOCK2API_
#define _WINSOCKAPI_   /* Prevent inclusion of winsock.h in windows.h */


/*
 * Ensure structures are packed consistently.
 */

#ifndef _WIN64
#include <pshpack4.h>
#endif

/*
 * Default: include function prototypes, don't include function typedefs.
 */

#ifndef INCL_WINSOCK_API_PROTOTYPES
#define INCL_WINSOCK_API_PROTOTYPES 1
#endif

#ifndef INCL_WINSOCK_API_TYPEDEFS
#define INCL_WINSOCK_API_TYPEDEFS 0
#endif

/*
 * Pull in WINDOWS.H if necessary
 */
#ifndef _INC_WINDOWS
#include <windows.h>
#endif /* _INC_WINDOWS */

/*
 * Define the current Winsock version. To build an earlier Winsock version
 * application redefine this value prior to including Winsock2.h.
 */

#if !defined(MAKEWORD)
#define MAKEWORD(low,high) \
        ((WORD)(((BYTE)(low)) | ((WORD)((BYTE)(high))) << 8))
#endif

#ifndef WINSOCK_VERSION
#define WINSOCK_VERSION MAKEWORD(2,2)
#endif

/*
 * On XBox, the winsock is in a static library rather than a DLL
 */
#define WINSOCK_API_LINKAGE

/*
 * Establish DLL function linkage if supported by the current build
 * environment and not previously defined.
 */

#ifndef WINSOCK_API_LINKAGE
#ifdef DECLSPEC_IMPORT
#define WINSOCK_API_LINKAGE DECLSPEC_IMPORT
#else
#define WINSOCK_API_LINKAGE
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Basic system type definitions, taken from the BSD file sys/types.h.
 */
typedef unsigned char   u_char;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;


/*
 * The new type to be used in all
 * instances which refer to sockets.
 */
typedef UINT_PTR        SOCKET;

/*
 * Select uses arrays of SOCKETs.  These macros manipulate such
 * arrays.  FD_SETSIZE may be defined by the user before including
 * this file, but the default here should be >= 64.
 *
 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
 * INCLUDED IN WINSOCK2.H EXACTLY AS SHOWN HERE.
 */
#ifndef FD_SETSIZE
#define FD_SETSIZE      64
#endif /* FD_SETSIZE */

typedef struct fd_set {
        u_int fd_count;               /* how many are SET? */
        SOCKET  fd_array[FD_SETSIZE];   /* an array of SOCKETs */
} fd_set;

extern int PASCAL FAR __WSAFDIsSet(SOCKET, fd_set FAR *);

#define FD_CLR(fd, set) do { \
    u_int __i; \
    for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count ; __i++) { \
        if (((fd_set FAR *)(set))->fd_array[__i] == fd) { \
            while (__i < ((fd_set FAR *)(set))->fd_count-1) { \
                ((fd_set FAR *)(set))->fd_array[__i] = \
                    ((fd_set FAR *)(set))->fd_array[__i+1]; \
                __i++; \
            } \
            ((fd_set FAR *)(set))->fd_count--; \
            break; \
        } \
    } \
} while(0)

#define FD_SET(fd, set) do { \
    u_int __i; \
    for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count; __i++) { \
        if (((fd_set FAR *)(set))->fd_array[__i] == (fd)) { \
            break; \
        } \
    } \
    if (__i == ((fd_set FAR *)(set))->fd_count) { \
        if (((fd_set FAR *)(set))->fd_count < FD_SETSIZE) { \
            ((fd_set FAR *)(set))->fd_array[__i] = (fd); \
            ((fd_set FAR *)(set))->fd_count++; \
        } \
    } \
} while(0)

#define FD_ZERO(set) (((fd_set FAR *)(set))->fd_count=0)

#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set FAR *)(set))

/*
 * Structure used in select() call, taken from the BSD file sys/time.h.
 */
struct timeval {
        long    tv_sec;         /* seconds */
        long    tv_usec;        /* and microseconds */
};

/*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 */
#define timerisset(tvp)         ((tvp)->tv_sec || (tvp)->tv_usec)
#define timercmp(tvp, uvp, cmp) \
        ((tvp)->tv_sec cmp (uvp)->tv_sec || \
         (tvp)->tv_sec == (uvp)->tv_sec && (tvp)->tv_usec cmp (uvp)->tv_usec)
#define timerclear(tvp)         (tvp)->tv_sec = (tvp)->tv_usec = 0

/*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 */
#define IOCPARM_MASK    0x7f            /* parameters must be < 128 bytes */
#define IOC_VOID        0x20000000      /* no parameters */
#define IOC_OUT         0x40000000      /* copy out parameters */
#define IOC_IN          0x80000000      /* copy in parameters */
#define IOC_INOUT       (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */
#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))

#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define FIONREAD    _IOR('f', 127, u_long) /* get # bytes to read */
#define FIONBIO     _IOW('f', 126, u_long) /* set/clear non-blocking i/o */




/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 */

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* internet group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

/*
 * Port/socket numbers: network standard functions
 */
#define IPPORT_ECHO             7
#define IPPORT_DISCARD          9
#define IPPORT_SYSTAT           11
#define IPPORT_DAYTIME          13
#define IPPORT_NETSTAT          15
#define IPPORT_FTP              21
#define IPPORT_TELNET           23
#define IPPORT_SMTP             25
#define IPPORT_TIMESERVER       37
#define IPPORT_NAMESERVER       42
#define IPPORT_WHOIS            43
#define IPPORT_MTP              57

/*
 * Port/socket numbers: host specific functions
 */
#define IPPORT_TFTP             69
#define IPPORT_RJE              77
#define IPPORT_FINGER           79
#define IPPORT_TTYLINK          87
#define IPPORT_SUPDUP           95

/*
 * UNIX TCP sockets
 */
#define IPPORT_EXECSERVER       512
#define IPPORT_LOGINSERVER      513
#define IPPORT_CMDSERVER        514
#define IPPORT_EFSSERVER        520

/*
 * UNIX UDP sockets
 */
#define IPPORT_BIFFUDP          512
#define IPPORT_WHOSERVER        513
#define IPPORT_ROUTESERVER      520
                                        /* 520+1 also used */

/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
#define IPPORT_RESERVED         1024


/*
 * Internet address (old style... should be updated)
 */
struct in_addr {
        union {
                struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { u_short s_w1,s_w2; } S_un_w;
                u_long S_addr;
        } S_un;
#define s_addr  S_un.S_addr
                                /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
                                /* host on imp */
#define s_net   S_un.S_un_b.s_b1
                                /* network */
#define s_imp   S_un.S_un_w.s_w2
                                /* imp */
#define s_impno S_un.S_un_b.s_b4
                                /* imp # */
#define s_lh    S_un.S_un_b.s_b3
                                /* logical host */
};

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 */
#define IN_CLASSA(i)            (((long)(i) & 0x80000000) == 0)
#define IN_CLASSA_NET           0xff000000
#define IN_CLASSA_NSHIFT        24
#define IN_CLASSA_HOST          0x00ffffff
#define IN_CLASSA_MAX           128

#define IN_CLASSB(i)            (((long)(i) & 0xc0000000) == 0x80000000)
#define IN_CLASSB_NET           0xffff0000
#define IN_CLASSB_NSHIFT        16
#define IN_CLASSB_HOST          0x0000ffff
#define IN_CLASSB_MAX           65536

#define IN_CLASSC(i)            (((long)(i) & 0xe0000000) == 0xc0000000)
#define IN_CLASSC_NET           0xffffff00
#define IN_CLASSC_NSHIFT        8
#define IN_CLASSC_HOST          0x000000ff

#define IN_CLASSD(i)            (((long)(i) & 0xf0000000) == 0xe0000000)
#define IN_CLASSD_NET           0xf0000000       /* These ones aren't really */
#define IN_CLASSD_NSHIFT        28               /* net and host fields, but */
#define IN_CLASSD_HOST          0x0fffffff       /* routing needn't know.    */
#define IN_MULTICAST(i)         IN_CLASSD(i)

#define INADDR_ANY              (u_long)0x00000000
#define INADDR_LOOPBACK         0x7f000001
#define INADDR_BROADCAST        (u_long)0xffffffff
#define INADDR_NONE             0xffffffff

#define ADDR_ANY                INADDR_ANY

/*
 * Socket address, internet style.
 */
struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};

#define WSADESCRIPTION_LEN      256
#define WSASYS_STATUS_LEN       128

typedef struct WSAData {
        WORD                    wVersion;
        WORD                    wHighVersion;
#ifdef _WIN64
        unsigned short          iMaxSockets;
        unsigned short          iMaxUdpDg;
        char FAR *              lpVendorInfo;
        char                    szDescription[WSADESCRIPTION_LEN+1];
        char                    szSystemStatus[WSASYS_STATUS_LEN+1];
#else
        char                    szDescription[WSADESCRIPTION_LEN+1];
        char                    szSystemStatus[WSASYS_STATUS_LEN+1];
        unsigned short          iMaxSockets;
        unsigned short          iMaxUdpDg;
        char FAR *              lpVendorInfo;
#endif
} WSADATA, FAR * LPWSADATA;

/*
 * Definitions related to sockets: types, address families, options,
 * taken from the BSD file sys/socket.h.
 */

/*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 */
#define INVALID_SOCKET  (SOCKET)(~0)
#define SOCKET_ERROR            (-1)

/*
 * The  following  may  be used in place of the address family, socket type, or
 * protocol  in  a  call  to WSASocket to indicate that the corresponding value
 * should  be taken from the supplied WSAPROTOCOL_INFO structure instead of the
 * parameter itself.
 */
#define FROM_PROTOCOL_INFO (-1)

/*
 * Types
 */
#define SOCK_STREAM     1               /* stream socket */
#define SOCK_DGRAM      2               /* datagram socket */

/*
 * Option flags per-socket.
 */
#define SO_ACCEPTCONN   0x0002          /* socket has had listen() */
#define SO_REUSEADDR    0x0004          /* allow local address reuse */
#define SO_BROADCAST    0x0020          /* permit sending of broadcast msgs */
#define SO_LINGER       0x0080          /* linger on close if data present */

#define SO_DONTLINGER   (int)(~SO_LINGER)
#define SO_EXCLUSIVEADDRUSE ((int)(~SO_REUSEADDR)) /* disallow local address reuse */

/*
 * Additional options.
 */
#define SO_SNDBUF       0x1001          /* send buffer size */
#define SO_RCVBUF       0x1002          /* receive buffer size */
#define SO_SNDTIMEO     0x1005          /* send timeout */
#define SO_RCVTIMEO     0x1006          /* receive timeout */
#define SO_TYPE         0x1008          /* get socket type */


/*
 * TCP options.
 */
#define TCP_NODELAY     0x0001

/*
 * Address families.
 */
#define AF_UNSPEC       0               /* unspecified */
/*
 * Although  AF_UNSPEC  is  defined for backwards compatibility, using
 * AF_UNSPEC for the "af" parameter when creating a socket is STRONGLY
 * DISCOURAGED.    The  interpretation  of  the  "protocol"  parameter
 * depends  on the actual address family chosen.  As environments grow
 * to  include  more  and  more  address families that use overlapping
 * protocol  values  there  is  more  and  more  chance of choosing an
 * undesired address family when AF_UNSPEC is used.
 */
#define AF_INET         2               /* internetwork: UDP, TCP, etc. */

#define AF_MAX          29

/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
        u_short sa_family;              /* address family */
        char    sa_data[14];            /* up to 14 bytes of direct address */
};


/*
 * Protocol families, same as address families for now.
 */
#define PF_UNSPEC       AF_UNSPEC
#define PF_INET         AF_INET

#define PF_MAX          AF_MAX

/*
 * Structure used for manipulating linger option.
 */
struct  linger {
        u_short l_onoff;                /* option on/off */
        u_short l_linger;               /* linger time */
};

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
#define SOL_SOCKET      0xffff          /* options for socket level */

/*
 * Maximum queue length specifiable by listen.
 */
#define SOMAXCONN       0x7fffffff


#define MSG_PARTIAL     0x8000          /* partial send or recv for message xport */




/*
 * WinSock error codes are also defined in winerror.h
 * Hence the IFDEF.
 */
#ifndef WSABASEERR

/*
 * All Windows Sockets error constants are biased by WSABASEERR from
 * the "normal"
 */
#define WSABASEERR              10000

/*
 * Windows Sockets definitions of regular Microsoft C error constants
 */
#define WSAEINTR                (WSABASEERR+4)
#define WSAEBADF                (WSABASEERR+9)
#define WSAEACCES               (WSABASEERR+13)
#define WSAEFAULT               (WSABASEERR+14)
#define WSAEINVAL               (WSABASEERR+22)
#define WSAEMFILE               (WSABASEERR+24)

/*
 * Windows Sockets definitions of regular Berkeley error constants
 */
#define WSAEWOULDBLOCK          (WSABASEERR+35)
#define WSAEINPROGRESS          (WSABASEERR+36)
#define WSAEALREADY             (WSABASEERR+37)
#define WSAENOTSOCK             (WSABASEERR+38)
#define WSAEDESTADDRREQ         (WSABASEERR+39)
#define WSAEMSGSIZE             (WSABASEERR+40)
#define WSAEPROTOTYPE           (WSABASEERR+41)
#define WSAENOPROTOOPT          (WSABASEERR+42)
#define WSAEPROTONOSUPPORT      (WSABASEERR+43)
#define WSAESOCKTNOSUPPORT      (WSABASEERR+44)
#define WSAEOPNOTSUPP           (WSABASEERR+45)
#define WSAEPFNOSUPPORT         (WSABASEERR+46)
#define WSAEAFNOSUPPORT         (WSABASEERR+47)
#define WSAEADDRINUSE           (WSABASEERR+48)
#define WSAEADDRNOTAVAIL        (WSABASEERR+49)
#define WSAENETDOWN             (WSABASEERR+50)
#define WSAENETUNREACH          (WSABASEERR+51)
#define WSAENETRESET            (WSABASEERR+52)
#define WSAECONNABORTED         (WSABASEERR+53)
#define WSAECONNRESET           (WSABASEERR+54)
#define WSAENOBUFS              (WSABASEERR+55)
#define WSAEISCONN              (WSABASEERR+56)
#define WSAENOTCONN             (WSABASEERR+57)
#define WSAESHUTDOWN            (WSABASEERR+58)
#define WSAETOOMANYREFS         (WSABASEERR+59)
#define WSAETIMEDOUT            (WSABASEERR+60)
#define WSAECONNREFUSED         (WSABASEERR+61)
#define WSAELOOP                (WSABASEERR+62)
#define WSAENAMETOOLONG         (WSABASEERR+63)
#define WSAEHOSTDOWN            (WSABASEERR+64)
#define WSAEHOSTUNREACH         (WSABASEERR+65)
#define WSAENOTEMPTY            (WSABASEERR+66)
#define WSAEPROCLIM             (WSABASEERR+67)
#define WSAEUSERS               (WSABASEERR+68)
#define WSAEDQUOT               (WSABASEERR+69)
#define WSAESTALE               (WSABASEERR+70)
#define WSAEREMOTE              (WSABASEERR+71)

/*
 * Extended Windows Sockets error constant definitions
 */
#define WSASYSNOTREADY          (WSABASEERR+91)
#define WSAVERNOTSUPPORTED      (WSABASEERR+92)
#define WSANOTINITIALISED       (WSABASEERR+93)
#define WSAEDISCON              (WSABASEERR+101)
#define WSAENOMORE              (WSABASEERR+102)
#define WSAECANCELLED           (WSABASEERR+103)
#define WSAEINVALIDPROCTABLE    (WSABASEERR+104)
#define WSAEINVALIDPROVIDER     (WSABASEERR+105)
#define WSAEPROVIDERFAILEDINIT  (WSABASEERR+106)
#define WSASYSCALLFAILURE       (WSABASEERR+107)
#define WSASERVICE_NOT_FOUND    (WSABASEERR+108)
#define WSATYPE_NOT_FOUND       (WSABASEERR+109)
#define WSA_E_NO_MORE           (WSABASEERR+110)
#define WSA_E_CANCELLED         (WSABASEERR+111)
#define WSAEREFUSED             (WSABASEERR+112)

/*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (when using the resolver). Note that these errors are
 * retrieved via WSAGetLastError() and must therefore follow
 * the rules for avoiding clashes with error numbers from
 * specific implementations or language run-time systems.
 * For this reason the codes are based at WSABASEERR+1001.
 * Note also that [WSA]NO_ADDRESS is defined only for
 * compatibility purposes.
 */

/* Authoritative Answer: Host not found */
#define WSAHOST_NOT_FOUND       (WSABASEERR+1001)

/* Non-Authoritative: Host not found, or SERVERFAIL */
#define WSATRY_AGAIN            (WSABASEERR+1002)

/* Non-recoverable errors, FORMERR, REFUSED, NOTIMP */
#define WSANO_RECOVERY          (WSABASEERR+1003)

/* Valid name, no data record of requested type */
#define WSANO_DATA              (WSABASEERR+1004)


/*
 * WinSock error codes are also defined in winerror.h
 * Hence the IFDEF.
 */
#endif /* ifdef WSABASEERR */

/*
 * Compatibility macros.
 */

#define h_errno         WSAGetLastError()
#define HOST_NOT_FOUND          WSAHOST_NOT_FOUND
#define TRY_AGAIN               WSATRY_AGAIN
#define NO_RECOVERY             WSANO_RECOVERY
#define NO_DATA                 WSANO_DATA
/* no address, look for MX record */
#define WSANO_ADDRESS           WSANO_DATA
#define NO_ADDRESS              WSANO_ADDRESS



/*
 * Windows Sockets errors redefined as regular Berkeley error constants.
 * These are commented out in Windows NT to avoid conflicts with errno.h.
 * Use the WSA constants instead.
 */
#if 0
#define EWOULDBLOCK             WSAEWOULDBLOCK
#define EINPROGRESS             WSAEINPROGRESS
#define EALREADY                WSAEALREADY
#define ENOTSOCK                WSAENOTSOCK
#define EDESTADDRREQ            WSAEDESTADDRREQ
#define EMSGSIZE                WSAEMSGSIZE
#define EPROTOTYPE              WSAEPROTOTYPE
#define ENOPROTOOPT             WSAENOPROTOOPT
#define EPROTONOSUPPORT         WSAEPROTONOSUPPORT
#define ESOCKTNOSUPPORT         WSAESOCKTNOSUPPORT
#define EOPNOTSUPP              WSAEOPNOTSUPP
#define EPFNOSUPPORT            WSAEPFNOSUPPORT
#define EAFNOSUPPORT            WSAEAFNOSUPPORT
#define EADDRINUSE              WSAEADDRINUSE
#define EADDRNOTAVAIL           WSAEADDRNOTAVAIL
#define ENETDOWN                WSAENETDOWN
#define ENETUNREACH             WSAENETUNREACH
#define ENETRESET               WSAENETRESET
#define ECONNABORTED            WSAECONNABORTED
#define ECONNRESET              WSAECONNRESET
#define ENOBUFS                 WSAENOBUFS
#define EISCONN                 WSAEISCONN
#define ENOTCONN                WSAENOTCONN
#define ESHUTDOWN               WSAESHUTDOWN
#define ETOOMANYREFS            WSAETOOMANYREFS
#define ETIMEDOUT               WSAETIMEDOUT
#define ECONNREFUSED            WSAECONNREFUSED
#define ELOOP                   WSAELOOP
#define ENAMETOOLONG            WSAENAMETOOLONG
#define EHOSTDOWN               WSAEHOSTDOWN
#define EHOSTUNREACH            WSAEHOSTUNREACH
#define ENOTEMPTY               WSAENOTEMPTY
#define EPROCLIM                WSAEPROCLIM
#define EUSERS                  WSAEUSERS
#define EDQUOT                  WSAEDQUOT
#define ESTALE                  WSAESTALE
#define EREMOTE                 WSAEREMOTE
#endif

/*
 * WinSock 2 extension -- new error codes and type definition
 */

#ifdef _WIN32

#define WSAAPI                  FAR PASCAL
#define WSAEVENT                HANDLE
#define LPWSAEVENT              LPHANDLE
#define WSAOVERLAPPED           OVERLAPPED
typedef struct _OVERLAPPED *    LPWSAOVERLAPPED;

#define WSA_IO_PENDING          (ERROR_IO_PENDING)
#define WSA_IO_INCOMPLETE       (ERROR_IO_INCOMPLETE)
#define WSA_INVALID_HANDLE      (ERROR_INVALID_HANDLE)
#define WSA_INVALID_PARAMETER   (ERROR_INVALID_PARAMETER)
#define WSA_NOT_ENOUGH_MEMORY   (ERROR_NOT_ENOUGH_MEMORY)
#define WSA_OPERATION_ABORTED   (ERROR_OPERATION_ABORTED)

#define WSA_INVALID_EVENT       ((WSAEVENT)NULL)
#define WSA_MAXIMUM_WAIT_EVENTS (MAXIMUM_WAIT_OBJECTS)
#define WSA_WAIT_FAILED         (WAIT_FAILED)
#define WSA_WAIT_EVENT_0        (WAIT_OBJECT_0)
#define WSA_WAIT_IO_COMPLETION  (WAIT_IO_COMPLETION)
#define WSA_WAIT_TIMEOUT        (WAIT_TIMEOUT)
#define WSA_INFINITE            (INFINITE)

#else /* WIN16 */

#define WSAAPI                  FAR PASCAL
typedef DWORD                   WSAEVENT, FAR * LPWSAEVENT;

typedef struct _WSAOVERLAPPED {
    DWORD    Internal;
    DWORD    InternalHigh;
    DWORD    Offset;
    DWORD    OffsetHigh;
    WSAEVENT hEvent;
} WSAOVERLAPPED, FAR * LPWSAOVERLAPPED;

#define WSA_IO_PENDING          (WSAEWOULDBLOCK)
#define WSA_IO_INCOMPLETE       (WSAEWOULDBLOCK)
#define WSA_INVALID_HANDLE      (WSAENOTSOCK)
#define WSA_INVALID_PARAMETER   (WSAEINVAL)
#define WSA_NOT_ENOUGH_MEMORY   (WSAENOBUFS)
#define WSA_OPERATION_ABORTED   (WSAEINTR)

#define WSA_INVALID_EVENT       ((WSAEVENT)NULL)
#define WSA_MAXIMUM_WAIT_EVENTS (MAXIMUM_WAIT_OBJECTS)
#define WSA_WAIT_FAILED         ((DWORD)-1L)
#define WSA_WAIT_EVENT_0        ((DWORD)0)
#define WSA_WAIT_TIMEOUT        ((DWORD)0x102L)
#define WSA_INFINITE            ((DWORD)-1L)

#endif  /* WIN32 */

/*
 * WinSock 2 extension -- WSABUF and QOS struct, include qos.h
 * to pull in FLOWSPEC and related definitions
 */

typedef struct _WSABUF {
    u_long      len;     /* the length of the buffer */
    char FAR *  buf;     /* the pointer to the buffer */
} WSABUF, FAR * LPWSABUF;

/*
 * WinSock 2 extension -- manifest constants for shutdown()
 */
#define SD_RECEIVE      0x00
#define SD_SEND         0x01
#define SD_BOTH         0x02




/*
 * Microsoft Windows Extended data types required for the functions to
 * convert   back  and  forth  between  binary  and  string  forms  of
 * addresses.
 */
typedef struct sockaddr SOCKADDR;
typedef struct sockaddr *PSOCKADDR;
typedef struct sockaddr FAR *LPSOCKADDR;


/* Socket function prototypes */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
SOCKET
WSAAPI
accept(
    IN SOCKET s,
    OUT struct sockaddr FAR * addr,
    IN OUT int FAR * addrlen
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
SOCKET
(WSAAPI * LPFN_ACCEPT)(
    IN SOCKET s,
    OUT struct sockaddr FAR * addr,
    IN OUT int FAR * addrlen
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
bind(
    IN SOCKET s,
    IN const struct sockaddr FAR * name,
    IN int namelen
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_BIND)(
    IN SOCKET s,
    IN const struct sockaddr FAR * name,
    IN int namelen
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
closesocket(
    IN SOCKET s
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_CLOSESOCKET)(
    IN SOCKET s
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
connect(
    IN SOCKET s,
    IN const struct sockaddr FAR * name,
    IN int namelen
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_CONNECT)(
    IN SOCKET s,
    IN const struct sockaddr FAR * name,
    IN int namelen
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
ioctlsocket(
    IN SOCKET s,
    IN long cmd,
    IN OUT u_long FAR * argp
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_IOCTLSOCKET)(
    IN SOCKET s,
    IN long cmd,
    IN OUT u_long FAR * argp
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
getpeername(
    IN SOCKET s,
    OUT struct sockaddr FAR * name,
    IN OUT int FAR * namelen
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_GETPEERNAME)(
    IN SOCKET s,
    IN struct sockaddr FAR * name,
    IN OUT int FAR * namelen
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
getsockname(
    IN SOCKET s,
    OUT struct sockaddr FAR * name,
    IN OUT int FAR * namelen
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_GETSOCKNAME)(
    IN SOCKET s,
    OUT struct sockaddr FAR * name,
    IN OUT int FAR * namelen
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
getsockopt(
    IN SOCKET s,
    IN int level,
    IN int optname,
    OUT char FAR * optval,
    IN OUT int FAR * optlen
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_GETSOCKOPT)(
    IN SOCKET s,
    IN int level,
    IN int optname,
    OUT char FAR * optval,
    IN OUT int FAR * optlen
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
u_long
WSAAPI
htonl(
    IN u_long hostlong
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
u_long
(WSAAPI * LPFN_HTONL)(
    IN u_long hostlong
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
u_short
WSAAPI
htons(
    IN u_short hostshort
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
u_short
(WSAAPI * LPFN_HTONS)(
    IN u_short hostshort
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
unsigned long
WSAAPI
inet_addr(
    IN const char FAR * cp
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
unsigned long
(WSAAPI * LPFN_INET_ADDR)(
    IN const char FAR * cp
    );
#endif // INCL_WINSOCK_API_TYPEDEFS


#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
listen(
    IN SOCKET s,
    IN int backlog
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_LISTEN)(
    IN SOCKET s,
    IN int backlog
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
u_long
WSAAPI
ntohl(
    IN u_long netlong
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
u_long
(WSAAPI * LPFN_NTOHL)(
    IN u_long netlong
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
u_short
WSAAPI
ntohs(
    IN u_short netshort
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
u_short
(WSAAPI * LPFN_NTOHS)(
    IN u_short netshort
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
recv(
    IN SOCKET s,
    OUT char FAR * buf,
    IN int len,
    IN int flags
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_RECV)(
    IN SOCKET s,
    OUT char FAR * buf,
    IN int len,
    IN int flags
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
recvfrom(
    IN SOCKET s,
    OUT char FAR * buf,
    IN int len,
    IN int flags,
    OUT struct sockaddr FAR * from,
    IN OUT int FAR * fromlen
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_RECVFROM)(
    IN SOCKET s,
    OUT char FAR * buf,
    IN int len,
    IN int flags,
    OUT struct sockaddr FAR * from,
    IN OUT int FAR * fromlen
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
select(
    IN int nfds,
    IN OUT fd_set FAR * readfds,
    IN OUT fd_set FAR * writefds,
    IN OUT fd_set FAR *exceptfds,
    IN const struct timeval FAR * timeout
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_SELECT)(
    IN int nfds,
    IN OUT fd_set FAR * readfds,
    IN OUT fd_set FAR * writefds,
    IN OUT fd_set FAR *exceptfds,
    IN const struct timeval FAR * timeout
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
send(
    IN SOCKET s,
    IN const char FAR * buf,
    IN int len,
    IN int flags
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_SEND)(
    IN SOCKET s,
    IN const char FAR * buf,
    IN int len,
    IN int flags
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
sendto(
    IN SOCKET s,
    IN const char FAR * buf,
    IN int len,
    IN int flags,
    IN const struct sockaddr FAR * to,
    IN int tolen
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_SENDTO)(
    IN SOCKET s,
    IN const char FAR * buf,
    IN int len,
    IN int flags,
    IN const struct sockaddr FAR * to,
    IN int tolen
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
setsockopt(
    IN SOCKET s,
    IN int level,
    IN int optname,
    IN const char FAR * optval,
    IN int optlen
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_SETSOCKOPT)(
    IN SOCKET s,
    IN int level,
    IN int optname,
    IN const char FAR * optval,
    IN int optlen
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
shutdown(
    IN SOCKET s,
    IN int how
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_SHUTDOWN)(
    IN SOCKET s,
    IN int how
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
SOCKET
WSAAPI
socket(
    IN int af,
    IN int type,
    IN int protocol
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
SOCKET
(WSAAPI * LPFN_SOCKET)(
    IN int af,
    IN int type,
    IN int protocol
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

/* Database function prototypes */



/* Microsoft Windows Extension function prototypes */

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSAStartup(
    IN WORD wVersionRequested,
    OUT LPWSADATA lpWSAData
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSASTARTUP)(
    IN WORD wVersionRequested,
    OUT LPWSADATA lpWSAData
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSACleanup(
    void
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSACLEANUP)(
    void
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
void
WSAAPI
WSASetLastError(
    IN int iError
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
void
(WSAAPI * LPFN_WSASETLASTERROR)(
    IN int iError
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSAGetLastError(
    void
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSAGETLASTERROR)(
    void
    );
#endif // INCL_WINSOCK_API_TYPEDEFS


/*
 * WinSock 2 extensions -- data types for the condition function in
 * WSAAccept() and overlapped I/O completion routine.
 */

typedef
void
(CALLBACK * LPWSAOVERLAPPED_COMPLETION_ROUTINE)(
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN DWORD dwFlags
    );

/* WinSock 2 API new function prototypes */


#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
BOOL
WSAAPI
WSACloseEvent(
    IN WSAEVENT hEvent
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
BOOL
(WSAAPI * LPFN_WSACLOSEEVENT)(
    IN WSAEVENT hEvent
    );
#endif // INCL_WINSOCK_API_TYPEDEFS


#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
WSAEVENT
WSAAPI
WSACreateEvent(
    void
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
WSAEVENT
(WSAAPI * LPFN_WSACREATEEVENT)(
    void
    );
#endif // INCL_WINSOCK_API_TYPEDEFS


#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
BOOL
WSAAPI
WSAGetOverlappedResult(
    IN SOCKET s,
    IN LPWSAOVERLAPPED lpOverlapped,
    OUT LPDWORD lpcbTransfer,
    IN BOOL fWait,
    OUT LPDWORD lpdwFlags
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
BOOL
(WSAAPI * LPFN_WSAGETOVERLAPPEDRESULT)(
    IN SOCKET s,
    IN LPWSAOVERLAPPED lpOverlapped,
    OUT LPDWORD lpcbTransfer,
    IN BOOL fWait,
    OUT LPDWORD lpdwFlags
    );
#endif // INCL_WINSOCK_API_TYPEDEFS


#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSARecv(
    IN SOCKET s,
    IN OUT LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    OUT LPDWORD lpNumberOfBytesRecvd,
    IN OUT LPDWORD lpFlags,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSARECV)(
    IN SOCKET s,
    IN OUT LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    OUT LPDWORD lpNumberOfBytesRecvd,
    IN OUT LPDWORD lpFlags,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif // INCL_WINSOCK_API_TYPEDEFS


#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSARecvFrom(
    IN SOCKET s,
    IN OUT LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    OUT LPDWORD lpNumberOfBytesRecvd,
    IN OUT LPDWORD lpFlags,
    OUT struct sockaddr FAR * lpFrom,
    IN OUT LPINT lpFromlen,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSARECVFROM)(
    IN SOCKET s,
    IN OUT LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    OUT LPDWORD lpNumberOfBytesRecvd,
    IN OUT LPDWORD lpFlags,
    OUT struct sockaddr FAR * lpFrom,
    IN OUT LPINT lpFromlen,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
BOOL
WSAAPI
WSAResetEvent(
    IN WSAEVENT hEvent
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
BOOL
(WSAAPI * LPFN_WSARESETEVENT)(
    IN WSAEVENT hEvent
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSASend(
    IN SOCKET s,
    IN LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    OUT LPDWORD lpNumberOfBytesSent,
    IN DWORD dwFlags,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSASEND)(
    IN SOCKET s,
    IN LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    OUT LPDWORD lpNumberOfBytesSent,
    IN DWORD dwFlags,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif // INCL_WINSOCK_API_TYPEDEFS


#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
int
WSAAPI
WSASendTo(
    IN SOCKET s,
    IN LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    OUT LPDWORD lpNumberOfBytesSent,
    IN DWORD dwFlags,
    IN const struct sockaddr FAR * lpTo,
    IN int iTolen,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_WSASENDTO)(
    IN SOCKET s,
    IN LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    OUT LPDWORD lpNumberOfBytesSent,
    IN DWORD dwFlags,
    IN const struct sockaddr FAR * lpTo,
    IN int iTolen,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif // INCL_WINSOCK_API_TYPEDEFS

#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
BOOL
WSAAPI
WSASetEvent(
    IN WSAEVENT hEvent
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
BOOL
(WSAAPI * LPFN_WSASETEVENT)(
    IN WSAEVENT hEvent
    );
#endif // INCL_WINSOCK_API_TYPEDEFS


#if INCL_WINSOCK_API_PROTOTYPES
WINSOCK_API_LINKAGE
DWORD
WSAAPI
WSAWaitForMultipleEvents(
    IN DWORD cEvents,
    IN const WSAEVENT FAR * lphEvents,
    IN BOOL fWaitAll,
    IN DWORD dwTimeout,
    IN BOOL fAlertable
    );
#endif // INCL_WINSOCK_API_PROTOTYPES

#if INCL_WINSOCK_API_TYPEDEFS
typedef
DWORD
(WSAAPI * LPFN_WSAWAITFORMULTIPLEEVENTS)(
    IN DWORD cEvents,
    IN const WSAEVENT FAR * lphEvents,
    IN BOOL fWaitAll,
    IN DWORD dwTimeout,
    IN BOOL fAlertable
    );
#endif // INCL_WINSOCK_API_TYPEDEFS


/* Microsoft Windows Extended data types */
typedef struct sockaddr_in SOCKADDR_IN;
typedef struct sockaddr_in *PSOCKADDR_IN;
typedef struct sockaddr_in FAR *LPSOCKADDR_IN;

typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger FAR *LPLINGER;

typedef struct in_addr IN_ADDR;
typedef struct in_addr *PIN_ADDR;
typedef struct in_addr FAR *LPIN_ADDR;

typedef struct fd_set FD_SET;
typedef struct fd_set *PFD_SET;
typedef struct fd_set FAR *LPFD_SET;


typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval FAR *LPTIMEVAL;


// XBox Secure Network Library -----------------------------------------------------------

#include <pshpack1.h>

//
// XNetStartup is called to load the XBox Secure Network Library.  It takes an optional
// pointer to a parameter structure.  To initialize the library with the default set
// of parameters, simply pass NULL for this argument.  To initialize the library with
// a different set of parameters, place an XNetStartupParams on the stack, zero it out,
// set the cfgSizeOfStruct to sizeof(XNetStartupParams), set any of the parameters you
// want to configure (leaving the remaining ones zeroed), and pass a pointer to this
// structure to XNetStartup.
//
// By default the XBox Secure Network Library operates in secure mode, which means that
// communication to untrusted hosts (such as a PC) is disallowed.  However, the devkit
// version of the XBox Secure Network Library (xnet.lib and xnetd.lib) allow you to 
// bypass this security by specifying the XNET_STARTUP_BYPASS_SECURITY flag in the 
// cfgFlags parameter.  Here is an example of how to do this:
// 
//      XNetStartupParams xnsp;
//      memset(&xnsp, 0, sizeof(xnsp));
//      xnsp.cfgSizeOfStruct = sizeof(XNetStartupParams);
//      xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;
//      INT err = XNetStartup(&xnsp);
//
// Attempting to bypass security when linking with xnets.lib or xnetsd.lib does not
// return an error, it is simply ignored.  Attempts to send or receive packets from
// untrusted hosts will fail.
//

typedef struct {

    BYTE        cfgSizeOfStruct;

        // Must be set to sizeof(XNetStartupParams).  There is no default.

    BYTE        cfgFlags;

        // One or more of the following flags OR'd together:

        #define XNET_STARTUP_BYPASS_SECURITY            0x01
            // This devkit-only flag tells the XNet stack to allow insecure
            // communication to untrusted hosts (such as a PC).  This flag
            // is silently ignored by the secure versions of the library.

        #define XNET_STARTUP_BYPASS_DHCP                0x02
            // This devkit-only flag tells the XNet stack to skip searching for
            // for a DHCP server and use auto-ip only to acquire an IP address.
            // This will save several seconds when starting up if you know
            // that there is no DHCP server configured.  This flag is silently
            // ignored by the secure versions of the library.
            //
            // If you use XNET_STARTUP_BYPASS_DHCP, you will usually
            // want to specify XNET_STARTUP_ALLOW_AUTOIP as well. Otherwise
            // DHCP will be bypassed, but auto-ip won't be run, and as
            // result no IP address will be chosen.

        #define XNET_STARTUP_ALLOW_AUTOIP                0x04
            // This flag tells the XNet stack to use auto-ip to obtain an
            // IP address if DHCP fails or is bypassed.

        // The default is 0 (no flags specified).

    BYTE        cfgPrivatePoolSizeInPages;

        // Specifies the size of the pre-allocated private memory pool used by
        // XNet for the following situations:
        //
        //      - Responding to ARP/DHCP/ICMP messages
        //      - Responding to certain TCP control messages
        //      - Allocating incoming TCP connection request sockets
        //      - Buffering outgoing data until it is transmitted (UDP) or
        //        until it is acknowledged (TCP)
        //      - Buffering incoming data on a socket that does not have a
        //        sufficiently large overlapped read pending
        //
        // The reason for using a private pool instead of the normal system
        // pool is because we want to have completely deterministic memory 
        // behavior.  That is, all memory allocation occurs only when an API
        // is called.  No system memory allocation happens asynchronously in
        // response to an incoming packet.
        //
        // Note that this parameter is in units of pages (4096 bytes per page). 
        //
        // The default is 12 pages (48K).

    BYTE        cfgEnetReceiveQueueLength;
        
        // The length of the Ethernet receive queue in number of packets.  Each 
        // packet takes 2KB of physically contiguous memory.
        //
        // The default is 8 packets (16K).

    BYTE        cfgIpFragMaxSimultaneous;

        // The maximum number of IP datagrams that can be in the process of reassembly
        // at the same time.
        //
        // The default is 4 packets.

    BYTE        cfgIpFragMaxPacketDiv256;

        // The maximum size of an IP datagram (including header) that can be reassembled.
        // Be careful when setting this parameter to a large value as it opens up 
        // a potential denial-of-service attack by consuming large amounts of memory
        // in the fixed-size private pool.
        //
        // Note that this parameter is in units of 256-bytes each.
        //
        // The default is 8 units (2048 bytes).

    BYTE        cfgSockMaxSockets;

        // The maximum number of sockets that can be opened at once, including those 
        // sockets created as a result of incoming connection requests.  Remember
        // that a TCP socket may not be closed immediately after closesocket is
        // called depending on the linger options in place (by default a TCP socket
        // will linger).
        //
        // The default is 64 sockets.
        
    BYTE        cfgSockDefaultRecvBufsizeInK;

        // The default receive buffer size for a socket, in units of K (1024 bytes).
        //
        // The default is 16 units (16K).

    BYTE        cfgSockDefaultSendBufsizeInK;

        // The default send buffer size for a socket, in units of K (1024 bytes).
        //
        // The default is 16 units (16K).

    BYTE        cfgKeyRegMax;

        // The maximum number of XNKID / XNKEY pairs that can be registered at the 
        // same time by calling XNetRegisterKey.
        //
        // The default is 4 key pair registrations.

    BYTE        cfgSecRegMax;

        // The maximum number of security associations that can be registered at the
        // same time.  Security associations are created for each unique XNADDR / XNKID
        // pair passed to XNetXnAddrToInAddr.  Security associations are also implicitly
        // created for each secure host that establishes an incoming connection
        // with this host on a given registered XNKID.  Note that there will only be
        // one security association between a pair of hosts on a given XNKID no matter
        // how many sockets are actively communicating on that secure connection.
        //
        // The default is 32 security associations.

     BYTE       cfgQosDataLimitDiv4;

        // The maximum amount of Qos data, in units of DWORD (4 bytes), that can be supplied
        // to a call to XNetQosListen or returned in the result set of a call to XNetQosLookup.
        //
        // The default is 64 (256 bytes).

} XNetStartupParams;

typedef struct {
    IN_ADDR     ina;                            // IP address (zero if not static/DHCP)
    IN_ADDR     inaOnline;                      // Online IP address (zero if not online)
    WORD        wPortOnline;                    // Online port
    BYTE        abEnet[6];                      // Ethernet MAC address
    BYTE        abOnline[20];                   // Online identification
} XNADDR;

typedef struct {
    BYTE        ab[8];                          // xbox to xbox key identifier
} XNKID;

typedef XNADDR TSADDR;


#define XNET_XNKID_MASK                 0xF0    // Mask of flag bits in first byte of XNKID
#define XNET_XNKID_SYSTEM_LINK          0x00    // Peer to peer system link session
#define XNET_XNKID_ONLINE_PEER          0x80    // Peer to peer online session
#define XNET_XNKID_ONLINE_SERVER        0xC0    // Client to server online session
#define XNET_XNKID_ONLINE_TITLESERVER   0xE0    // Client to title server online session

#define XNetXnKidIsSystemLink(pxnkid)           (((pxnkid)->ab[0] & 0xE0) == XNET_XNKID_SYSTEM_LINK)
#define XNetXnKidIsOnlinePeer(pxnkid)           (((pxnkid)->ab[0] & 0xE0) == XNET_XNKID_ONLINE_PEER)
#define XNetXnKidIsOnlineServer(pxnkid)         (((pxnkid)->ab[0] & 0xE0) == XNET_XNKID_ONLINE_SERVER)
#define XNetXnKidIsOnlineTitleServer(pxnkid)    (((pxnkid)->ab[0] & 0xE0) == XNET_XNKID_ONLINE_TITLESERVER)

// For XNKID values created by Matchmaking, this specifies the database server the session is located on
#define XNET_XNKID_DBINDEX_MASK         0x0F
#define XNetXnKidGetDatabaseIndex(pxnkid)       ((pxnkid)->ab[0] & XNET_XNKID_DBINDEX_MASK)


typedef struct {
    BYTE        ab[16];                         // xbox to xbox key exchange key
} XNKEY;

typedef struct {
    INT         iStatus;                        // WSAEINPROGRESS if pending; 0 if success; error if failed
    UINT        cina;                           // Count of IP addresses for the given host
    IN_ADDR     aina[8];                        // Vector of IP addresses for the given host
} XNDNS;

typedef struct {
    BYTE        bFlags;                         // See XNET_XNQOSINFO_* below
    BYTE        bReserved;                      // Reserved
    WORD        cProbesXmit;                    // Count of Qos probes transmitted
    WORD        cProbesRecv;                    // Count of Qos probes successfully received
    WORD        cbData;                         // Size of Qos data supplied by target (may be zero)
    BYTE *      pbData;                         // Qos data supplied by target (may be NULL)
    WORD        wRttMinInMsecs;                 // Minimum round-trip time in milliseconds
    WORD        wRttMedInMsecs;                 // Median round-trip time in milliseconds
    DWORD       dwUpBitsPerSec;                 // Upstream bandwidth in bits per second
    DWORD       dwDnBitsPerSec;                 // Downstream bandwidth in bits per second
} XNQOSINFO;

#define XNET_XNQOSINFO_COMPLETE         0x01    // Qos has finished processing this entry
#define XNET_XNQOSINFO_TARGET_CONTACTED 0x02    // Target host was successfully contacted
#define XNET_XNQOSINFO_TARGET_DISABLED  0x04    // Target host has disabled its Qos listener
#define XNET_XNQOSINFO_DATA_RECEIVED    0x08    // Target host supplied Qos data
#define XNET_XNQOSINFO_PARTIAL_COMPLETE 0x10    // Qos has unfinsihed estimates for this entry

typedef struct {
    UINT        cxnqos;                         // Count of items in axnqosinfo[] array
    UINT        cxnqosPending;                  // Count of items still pending
    XNQOSINFO   axnqosinfo[1];                  // Vector of Qos results
} XNQOS;


#include <poppack.h>

INT   WSAAPI XNetStartup(const XNetStartupParams * pxnsp);
INT   WSAAPI XNetCleanup();

INT   WSAAPI XNetRandom(BYTE * pb, UINT cb);

INT   WSAAPI XNetCreateKey(XNKID * pxnkid, XNKEY * pxnkey);
INT   WSAAPI XNetRegisterKey(const XNKID * pxnkid, const XNKEY * pxnkey);
INT   WSAAPI XNetUnregisterKey(const XNKID * pxnkid);

INT   WSAAPI XNetXnAddrToInAddr(const XNADDR * pxna, const XNKID * pxnkid, IN_ADDR * pina);
INT   WSAAPI XNetServerToInAddr(const IN_ADDR ina, DWORD dwServiceId, IN_ADDR * pina);
INT   WSAAPI XNetTsAddrToInAddr(const TSADDR * ptsa, DWORD dwServiceId, const XNKID * pxnkid, IN_ADDR * pina);
INT   WSAAPI XNetInAddrToXnAddr(const IN_ADDR ina, XNADDR * pxna, XNKID * pxnkid);
INT   WSAAPI XNetInAddrToServer(const IN_ADDR ina, IN_ADDR *pina);
INT   WSAAPI XNetInAddrToString(const IN_ADDR ina, char * pchBuf, INT cchBuf);
INT   WSAAPI XNetUnregisterInAddr(const IN_ADDR ina);
INT   WSAAPI XNetXnAddrToMachineId(const XNADDR *pxnaddr, ULONGLONG *pqwMachineId);

INT   WSAAPI XNetConnect(const IN_ADDR ina);
DWORD WSAAPI XNetGetConnectStatus(const IN_ADDR ina);

#define XNET_CONNECT_STATUS_IDLE            0x0000  // Connection not started; use XNetConnect or send packet
#define XNET_CONNECT_STATUS_PENDING         0x0001  // Connecting in progress; not complete yet
#define XNET_CONNECT_STATUS_CONNECTED       0x0002  // Connection is established
#define XNET_CONNECT_STATUS_LOST            0x0003  // Connection was lost

INT   WSAAPI XNetDnsLookup(const char * pszHost, WSAEVENT hEvent, XNDNS ** ppxndns);
INT   WSAAPI XNetDnsRelease(XNDNS * pxndns);

INT   WSAAPI XNetQosListen(const XNKID * pxnkid, const BYTE * pb, UINT cb, DWORD dwBitsPerSec, DWORD dwFlags);
INT   WSAAPI XNetQosLookup(UINT cxna, const XNADDR * apxna[], const XNKID * apxnkid[], const XNKEY * apxnkey[], UINT cina, const IN_ADDR aina[], const DWORD adwServiceId[], UINT cProbes, DWORD dwBitsPerSec, DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos);
INT   WSAAPI XNetQosServiceLookup(DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos);
INT   WSAAPI XNetQosRelease(XNQOS * pxnqos);

#define XNET_QOS_LISTEN_ENABLE              0x01    // Responds to queries on the given XNKID
#define XNET_QOS_LISTEN_DISABLE             0x02    // Rejects queries on the given XNKID
#define XNET_QOS_LISTEN_SET_DATA            0x04    // Sets the block of data to send back to queriers
#define XNET_QOS_LISTEN_SET_BITSPERSEC      0x08    // Sets max bandwidth that query reponses may consume
#define XNET_QOS_LISTEN_RELEASE             0x10    // Stops listening on given XNKID and releases memory
#define XNET_QOS_LOOKUP_RESERVED            0x00    // No flags defined yet for XNetQosLookup
#define XNET_QOS_SERVICE_LOOKUP_RESERVED    0x00    // No flags defined yet for XNetQosServiceLookup

DWORD WSAAPI XNetGetTitleXnAddr(XNADDR * pxna);
DWORD WSAAPI XNetGetDebugXnAddr(XNADDR * pxna);

#define XNET_GET_XNADDR_PENDING             0x0000  // Address acquisition is not yet complete
#define XNET_GET_XNADDR_NONE                0x0001  // XNet is uninitialized or no debugger found
#define XNET_GET_XNADDR_ETHERNET            0x0002  // Host has ethernet address (no IP address)
#define XNET_GET_XNADDR_STATIC              0x0004  // Host has staticically assigned IP address
#define XNET_GET_XNADDR_DHCP                0x0008  // Host has DHCP assigned IP address
#define XNET_GET_XNADDR_PPPOE               0x0010  // Host has PPPoE assigned IP address
#define XNET_GET_XNADDR_GATEWAY             0x0020  // Host has one or more gateways configured
#define XNET_GET_XNADDR_DNS                 0x0040  // Host has one or more DNS servers configured
#define XNET_GET_XNADDR_ONLINE              0x0080  // Host is currently connected to online service
#define XNET_GET_XNADDR_TROUBLESHOOT        0x8000  // Network configuration requires troubleshooting

DWORD WSAAPI XNetGetEthernetLinkStatus();

#define XNET_ETHERNET_LINK_ACTIVE           0x01    // Ethernet cable is connected and active
#define XNET_ETHERNET_LINK_100MBPS          0x02    // Ethernet link is set to 100 Mbps
#define XNET_ETHERNET_LINK_10MBPS           0x04    // Ethernet link is set to 10 Mbps
#define XNET_ETHERNET_LINK_FULL_DUPLEX      0x08    // Ethernet link is in full duplex mode
#define XNET_ETHERNET_LINK_HALF_DUPLEX      0x10    // Ethernet link is in half duplex mode

DWORD WSAAPI XNetGetBroadcastVersionStatus(BOOL fReset);

#define XNET_BROADCAST_VERSION_OLDER        0x0001  // Got broadcast packet(s) from incompatible older version of title
#define XNET_BROADCAST_VERSION_NEWER        0x0002  // Got broadcast packet(s) from incompatible newer version of title

//
// Since our socket handles are not file handles, apps can NOT call CancelIO API to cancel
// outstanding overlapped I/O requests. Apps must call WSACancelOverlappedIO function instead.
//

INT WSAAPI WSACancelOverlappedIO(SOCKET s);

//
// The following protocol can be passed to the socket() API to create a datagram socket that
// transports encrypted data and unencrypted voice in the same packet.
//

#define IPPROTO_VDP                         254



#ifdef __cplusplus
}
#endif

#ifndef _WIN64
#include <poppack.h>
#endif

#endif  /* _WINSOCK2API_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\wmspoolrelease.h ===
#pragma once
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       poolRelease.h
//
//  Contents: 
//
//--------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
// This virtual base class is used for all pool-allocated objects. When
// an object is ready to be deleted, it returns itself to the pool that
// allocated it. This base class remembers the pool that allocated it
// and returns itself to the pool.
/////////////////////////////////////////////////////////////////////////////

#ifndef _PoolRelease_h_
#define _PoolRelease_h_

class CPoolReleaseItem;

#define FORCE_ALL_POOLRELEASEITEMS_TO_USE_POOL_ALLOC        0

__forceinline void WmsDbgBreak()
{
    _asm int 3;
}

#if DBG
#define POOL_RELEASE_ITEM_ASSERT( exp )   if( !( exp ) ) { WmsDbgBreak(); }
#else
#define POOL_RELEASE_ITEM_ASSERT( exp )
#endif

/////////////////////////////////////////////////////////////////////////////
//
// This is a pool that allocates an object.
//
// This is not a template because we want to pass it into the base class,
// and we don't know the type of the subclass. As a result, we cannot make a
// fully-qualified argument for the parameter to the base class method.
// This is not a big issue; we simply type the parameter as CPoolReleaseItem*,
// so this is not a template.
/////////////////////////////////////////////////////////////////////////////
class CGenericFinalReleaseCallback
{
public:
    virtual HRESULT ReadyForGenericFinalRelease( CPoolReleaseItem *pCell ) = 0;
};




/////////////////////////////////////////////////////////////////////////////
//
// This is an object that is allocated from a pool. It returns itself
// to the pool when it is deleted.
/////////////////////////////////////////////////////////////////////////////
class CPoolReleaseItem
{
public:
    CPoolReleaseItem();
    virtual ~CPoolReleaseItem( ) { }

    void SetGenericFinalReleaseCallback( CGenericFinalReleaseCallback *pPool );
    void ReturnThisToPool();

protected:
    CGenericFinalReleaseCallback  *m_pOwnerPool;
};





/////////////////////////////////////////////////////////////////////////////
__forceinline 
CPoolReleaseItem::CPoolReleaseItem()
{
    m_pOwnerPool = NULL;
}



/////////////////////////////////////////////////////////////////////////////
__forceinline
void CPoolReleaseItem::SetGenericFinalReleaseCallback( 
                                        CGenericFinalReleaseCallback *pPool 
                                        )
{  
    POOL_RELEASE_ITEM_ASSERT( NULL == m_pOwnerPool );    
    m_pOwnerPool = pPool;

} // End of SetGenericFinalReleaseCallback.




/////////////////////////////////////////////////////////////////////////////
//
// This is called when an object is released; usually this means when
// an object's refcount reaches 0.
/////////////////////////////////////////////////////////////////////////////
__forceinline
void CPoolReleaseItem::ReturnThisToPool()
{
    if ( NULL != m_pOwnerPool )
    {
        m_pOwnerPool->ReadyForGenericFinalRelease( this );
    }

    else
    {
#if DBG && FORCE_ALL_POOLRELEASEITEMS_TO_USE_POOL_ALLOC
        // all pool release items should come from a pool.
        POOL_RELEASE_ITEM_ASSERT( !"we need to release to a pool" );
#endif
        delete this;
    }
} // End of ReturnThisToPool.



#endif // _PoolRelease_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\wmspoolallocate.h ===
#pragma once
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       wmsPoolAllocate.h
//
//  Contents: 
//
//--------------------------------------------------------------------------

#ifndef _WMSPoolAllocate_h_
#define _WMSPoolAllocate_h_

#include "wmsstd.h"
#include "tcelpool.h"
#include "mpcellpool.h"
#include "wmsPoolRelease.h"



/////////////////////////////////////////////////////////////////////////////
template<class T> 
class TWMSPoolAllocator : public CGenericFinalReleaseCallback
{
public:

    TWMSPoolAllocator( );
    virtual ~TWMSPoolAllocator( );

    HRESULT Initialize( DWORD nCellsPerPage = 10 );
    T *Alloc();

    // CGenericFinalReleaseCallback
    virtual HRESULT ReadyForGenericFinalRelease( CPoolReleaseItem *pItem );
    
private:
    CRITICAL_SECTION    m_CriticalSection;
    CTCellPool<T>       m_CellPool;
};




/////////////////////////////////////////////////////////////////////////////
//
// [TWMSPoolAllocator]
//
/////////////////////////////////////////////////////////////////////////////
template<class T> 
TWMSPoolAllocator<T>::TWMSPoolAllocator()
{
    InitializeCriticalSection( &m_CriticalSection );
} // End of TWMSPoolAllocator.




/////////////////////////////////////////////////////////////////////////////
//
// [~TWMSPoolAllocator]
//
/////////////////////////////////////////////////////////////////////////////
template<class T> 
TWMSPoolAllocator<T>::~TWMSPoolAllocator()
{
    DeleteCriticalSection( &m_CriticalSection );
} // End of ~TWMSPoolAllocator.


/////////////////////////////////////////////////////////////////////////////
//
// [Initialize]
//
/////////////////////////////////////////////////////////////////////////////
template<class T> 
HRESULT 
TWMSPoolAllocator<T>::Initialize( DWORD nCellsPerPage )
{
    return( m_CellPool.Initialize( nCellsPerPage ) );
} // End of Initialize.


/////////////////////////////////////////////////////////////////////////////
//
// [ReadyForGenericFinalRelease]
//
/////////////////////////////////////////////////////////////////////////////
template<class T> HRESULT
TWMSPoolAllocator<T>::ReadyForGenericFinalRelease( CPoolReleaseItem *pItem )
{
    T *pTypedItem;

    if ( NULL == pItem )
    {
        return( E_INVALIDARG );
    }
    pTypedItem = ( T * ) pItem;

    EnterCriticalSection( &m_CriticalSection );
    m_CellPool.ReleaseElement( pTypedItem );
    LeaveCriticalSection( &m_CriticalSection );

    return( S_OK );
} // End of ReadyForGenericFinalRelease.




////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
template<class T> T *
TWMSPoolAllocator<T>::Alloc()
{
    T *pItem;
   
    EnterCriticalSection( &m_CriticalSection );
    pItem = ( T * ) m_CellPool.AcquireElement();
    LeaveCriticalSection( &m_CriticalSection );

    if ( NULL == pItem )
    {
        return( NULL );
    }

    // Register a callback object with the buffer object. When the buffer
    // is deleted, our callback is called and it will return the buffer 
    // to the pool.
    pItem->SetGenericFinalReleaseCallback( this );

    return( ( T * ) pItem );
} // End of AllocContentDescription.

// No-op -- you can use call stack tracing to figure this out.
#define DEBUG_ALLOC( pool )




/////////////////////////////////////////////////////////////////////////////
//
// [TWMSGlobalPoolAllocator] uses CTMPCellPool.
//
/////////////////////////////////////////////////////////////////////////////
template<class Type> 
class TWMSGlobalPoolAllocator : public CGenericFinalReleaseCallback
{
public:

    TWMSGlobalPoolAllocator( );
    TWMSGlobalPoolAllocator( DWORD nCellsPerPage );

    virtual ~TWMSGlobalPoolAllocator( );

    HRESULT Initialize( DWORD nCellsPerPage = 16,
                        DWORD nInitialPages = 1, 
                        BOOL fFreeUnusedPages = FALSE
                      );

    Type *Alloc();

    // CGenericFinalReleaseCallback
    HRESULT ReadyForGenericFinalRelease( CPoolReleaseItem *pItem );
    
private:
    CMPCellPool  m_MpPool;
};




/////////////////////////////////////////////////////////////////////////////
//
// [TWMSGlobalPoolAllocator]
//
/////////////////////////////////////////////////////////////////////////////
template<class Type> 
TWMSGlobalPoolAllocator<Type>::TWMSGlobalPoolAllocator()
{
} // End of TWMSGlobalPoolAllocator.




/////////////////////////////////////////////////////////////////////////////
//
// [TWMSGlobalPoolAllocator]
//
/////////////////////////////////////////////////////////////////////////////
template<class Type> 
TWMSGlobalPoolAllocator<Type>::TWMSGlobalPoolAllocator( DWORD nCellsPerPage )
{
    if( nCellsPerPage == 0 )
    {
        Initialize();
    }
    else
    {
        Initialize( nCellsPerPage );
    }
} // End of TWMSGlobalPoolAllocator.



/////////////////////////////////////////////////////////////////////////////
//
// [~TWMSGlobalPoolAllocator]
//
/////////////////////////////////////////////////////////////////////////////
template<class Type> 
TWMSGlobalPoolAllocator<Type>::~TWMSGlobalPoolAllocator()
{
} // End of ~TWMSGlobalPoolAllocator.


/////////////////////////////////////////////////////////////////////////////
//
// [Initialize]
//
/////////////////////////////////////////////////////////////////////////////
template<class Type> 
HRESULT 
TWMSGlobalPoolAllocator<Type>::Initialize( DWORD nCellsPerPage,
                                           DWORD nInitialPages, 
                                           BOOL fFreeUnusedPages )
{
    HRESULT hr = m_MpPool.Initialize( sizeof(Type), nCellsPerPage, nInitialPages, fFreeUnusedPages );

    return( hr );
} // End of Initialize.



/////////////////////////////////////////////////////////////////////////////
//
// [ReadyForGenericFinalRelease]
//
// Ugly type name '_whoop_whoop_Type' is to allow objects with members
// called 'T' without confusing the compiler.
/////////////////////////////////////////////////////////////////////////////
template<class _whoop_whoop_Type> 
__forceinline
HRESULT
TWMSGlobalPoolAllocator<_whoop_whoop_Type>::ReadyForGenericFinalRelease( CPoolReleaseItem *pCell )
{
    _whoop_whoop_Type *pItem = ( _whoop_whoop_Type * ) pCell;
    
    if ( NULL == pItem )
    {
        return( E_INVALIDARG );
    }

    pItem->~_whoop_whoop_Type();

    HRESULT hr = m_MpPool.ReleaseCell( (void *) pItem );

    return( hr );
} // End of ReadyForGenericFinalRelease.


////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
template<class Type> 
__forceinline
Type *
TWMSGlobalPoolAllocator<Type>::Alloc()
{    
    void *pCell;
    Type *pItem;
    
    m_MpPool.AcquireCell( &pCell );
    if( NULL != pCell )
    {
#ifdef DEBUG_NEW
#undef new
        pItem = new( pCell ) Type;
#define new DEBUG_NEW
#else    
        pItem = new( pCell ) Type;
#endif

        // Register a callback object with the buffer object. When the buffer
        // is deleted, our callback is called and it will return the buffer 
        // to the pool.

        pItem->SetGenericFinalReleaseCallback( this );

        return( ( Type * ) pItem );
    }
    else
    {
        return( NULL );
    }

} // End of Alloc.


// No-op -- you can use call stack tracing to figure this out.
#define DEBUG_ALLOC( pool )
#define DEBUG_ALLOC_NAME( pool, poolName )

#endif // _WMSPoolAllocate_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\wmsstd.h ===
//
// Microsoft Windows Media Technologies.
// Copyright (c) Microsoft Corporation. All rights reserved.
//

#ifndef __WMSSTD_H__
#define __WMSSTD_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <string.h>
#include <tchar.h>
#include <winnls.h>

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// GENERIC MACROS //////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#define MAX(a, b) (max((a), (b)))
#define MIN(a, b) (min((a), (b)))

#define MAKEULONGLONG(a, b) ((ULONGLONG)(((DWORD)(a)) | ((ULONGLONG)((DWORD)(b))) << 32))
#define MAKEUINT64(a, b)    MAKEULONGLONG((a),(b))
#define MAKEQWORD(a, b)     MAKEULONGLONG((a),(b))
#define LODWORD(l)          ((DWORD)(l))
#define HIDWORD(l)          ((DWORD)(((ULONGLONG)(l) >> 32) & 0xFFFFFFFF))

#if !defined(COUNTOF)                   // macro to obtain the storage size of an array.
#define COUNTOF( x )        ( sizeof(x) / sizeof( (x)[0] ) )
#endif

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// WINSOCK MACROS //////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#define NTOHULL(ull)        MAKEULONGLONG(ntohl(LODWORD((ull))), ntohl(HIDWORD((ull))))
#define HTONULL(ull)        MAKEULONGLONG(htonl(LODWORD((ull))), htonl(HIDWORD((ull))))


/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// TYPES ///////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#ifndef QWORD
typedef ULONGLONG           QWORD;
typedef QWORD               *LPQWORD;
#endif // !QWORD

#ifndef _WIN64

typedef ULONG               ULONG_PTR;
typedef LONG                LONG_PTR;

#endif // _WIN64


/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// COMMENT MACROS //////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#define PUBLIC      
#define PROTECTED
#define PRIVATE 
#define STATIC
#define VIRTUAL


/////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////// DEBUG/RETAIL MACROS ////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#if DBG

#define Debug(s)            s   // Statement/declaration included only if DBG
#define Retail(s)               // Statement/declaration included only if !DBG
#define DebugOrRetail(d, r) d   // d if DBG; r if !DBG

#else // !DBG

#define Debug(s)                // Statement/declaration included only if DBG
#define Retail(s)           s   // Statement/declaration included only if !DBG
#define DebugOrRetail(d, r) r   // d if DBG; r if !DBG

#endif // !DBG


/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// STRING MACROS ///////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#if UNICODE
#define Unicode(s)          (s)
#define Ansi(s)
#define UnicodeOrAnsi(u, a) (u)
#define AnsiOrUnicode(a, u) (u)
#else
#define Unicode(s)
#define Ansi(s)             (s)
#define UnicodeOrAnsi(u, a) (a)
#define AnsiOrUnicode(a, u) (a)
#endif


#define WcharToAchar(a, w, l)       \
            WideCharToMultiByte(    \
                CP_ACP,             \
                0,                  \
                (w),                \
                -1,                 \
                (a),                \
                (l),                \
                NULL,               \
                NULL                \
                )

#define AcharToWchar(w, a, l)       \
            MultiByteToWideChar(    \
                CP_ACP,             \
                0,                  \
                (a),                \
                -1,                 \
                (w),                \
                (l)                 \
                )

#define WcharToTchar(t, w, l) UnicodeOrAnsi(wcscpy((t), (w)), WcharToAchar((t), (w), (l)))
#define WcharToTcharEx(t, w, l, p) UnicodeOrAnsi((p) = (w), (WcharToAchar((t), (w), (l)), (p) = (t)))
#define TcharToWchar(w, t, l) UnicodeOrAnsi(wcscpy((w), (t)), AcharToWchar((w), (t), (l)))
#define TcharToWcharEx(w, t, l, p) UnicodeOrAnsi((p) = (t), (AcharToWchar((w), (t), (l)), (p) = (w)))

#define AcharToTchar(t, a, l) AnsiOrUnicode(strcpy((t), (a)), AcharToWchar((t), (a), (l)))
#define AcharToTcharEx(t, a, l, p) AnsiOrUnicode((p) = (a), (AcharToWchar((t), (a), (l)), (p) = (t)))
#define TcharToAchar(a, t, l) AnsiOrUnicode(strcpy((a), (t)), WcharToAchar((a), (t), (l)))
#define TcharToAcharEx(a, t, l, p) AnsiOrUnicode((p) = (t), (WcharToAchar((a), (t), (l)), (p) = (a)))


/////////////////////////////////////////////////////////////////////////////////////////
//////////////////////// REFCOUNT AND SAFE_* MACROS /////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#ifdef INC_REF
#undef INC_REF
#endif
#ifdef DEC_REF
#undef DEC_REF
#endif

#ifdef SINGLE_THREADED
    #define INC_REF(u) (++u)
    #define DEC_REF(u) (--u)
#else // !SINGLE_THREADED
    #define INC_REF(u) InterlockedIncrement((LONG*)&u)
    #define DEC_REF(u) InterlockedDecrement((LONG*)&u)
#endif // SINGLE_THREADED

#ifndef _REF_ASSERT
    #ifdef NO_DEBUG_SYNCHRO
        #define _REF_ASSERT(x) 
    #else // !NO_DEBUG_SYNCHRO
        #ifdef USE_MFC
            #define _REF_ASSERT(x) ASSERT(x)
        #else // !USE_MFC
            #include <assert.h>
            #define _REF_ASSERT(x) assert(x)
        #endif // USE_MFC
    #endif // NO_DEBUG_SYNCHRO
#endif

#ifdef WIN32
#define YIELD(hwnd,reps) (void)0
#else
#define YIELD(hwnd,reps) \
        {MSG msg;int n=(int)(reps);while( n-- && PeekMessage( &msg, hwnd, 0, 0, PM_REMOVE ) ){TranslateMessage( &msg );DispatchMessage( &msg );}}
#endif

#define SAFE_ADDREF(p)              if( NULL != p ) { ( p )->AddRef(); }
#define SAFE_DELETE(p)              if( NULL != p ) { delete p; p = NULL; }
#define SAFE_ARRAY_DELETE(p)        if( NULL != p ) { delete [] p; p = NULL; }
#define SAFE_RELEASE(p)             if( NULL != p ) { ( p )->Release(); p = NULL; }
#define SAFE_SHUTRELEASE(p)         if( NULL != p ) { ( p )->Shutdown(); ( p )->Release(); p = NULL; }
#define SAFE_COTASKMEMFREE(p)       if( NULL != p ) { CoTaskMemFree( p ); p = NULL; }
#define SAFE_SYSFREESTRING(p)       if( NULL != p ) { SysFreeString( p ); p = NULL; }
#define SAFE_ARRAYDELETE(p)         if( NULL != p ) { delete [] p; p = NULL; }
#define SAFE_CLOSEHANDLE( h )       if( NULL != h ) { CloseHandle( h ); h = NULL; }
#define SAFE_CLOSEFILEHANDLE( h )   if( INVALID_HANDLE_VALUE != h ) { CloseHandle( h ); h = INVALID_HANDLE_VALUE; }
#define SAFE_GLOBALFREE(p)          if( NULL != p ) { GlobalFree( p ); p = NULL; }

//
// Ref-count safe assignment of 'src' to 'dst'
//
#define SAFE_REPLACEREF( dst, src )   \
    { \
        if( NULL != ( src ) ) \
        { \
            ( src )->AddRef( ); \
        } \
        if( NULL != ( dst ) ) \
        { \
            ( dst )->Release( ); \
        } \
        dst = src; \
    }

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////// OUTPARAMETER VALIDATION AND INITIALIZATION //////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#ifdef __tagVARIANT
inline HRESULT ValidateOutPtr( VARIANT* pDest, VARIANT& /*bogus*/ )
{
    if( reinterpret_cast< VARIANT* >( NULL ) == pDest )
    {
        return( E_POINTER );
    }
    ::VariantClear( pDest );
    return( S_OK );
}
#endif

template< class Tptr, class T > HRESULT ValidateOutPtr( Tptr& pVal, T&/* bogus*/ )
{
    if( reinterpret_cast< Tptr >( NULL ) == pVal )
    {
        return( E_POINTER );
    }
    *pVal = static_cast< T >( 0 );
    return( S_OK );
}

// Validate a pointer argument and initialize it if valid.
#define VALIDOUT_PTR( pVal ) \
{ \
    HRESULT hr = ValidateOutPtr( pVal, *pVal ); \
    if( FAILED( hr ) ) \
    { \
        return( hr ); \
    } \
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////// UTILITY MACROS//////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif

#endif // __WMSSTD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\wmscritsec.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Mar 12 01:14:55 2001
 */
/* Compiler settings for .\wmscritsec.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmscritsec_h__
#define __wmscritsec_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMSCriticalSection_FWD_DEFINED__
#define __IWMSCriticalSection_FWD_DEFINED__
typedef interface IWMSCriticalSection IWMSCriticalSection;
#endif 	/* __IWMSCriticalSection_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmscritsec_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft NetShow
//  Copyright (C) Microsoft Corporation 1998.
//
//  Automatically generated by Midl from ioCompletion.idl
//
// DO NOT EDIT THIS FILE.
//
//--------------------------------------------------------------------------
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
EXTERN_GUID( IID_IWMSCriticalSection, 0x4d7133a6, 0x397b, 0x4105, 0x9d, 0xd8, 0xeb, 0xe9, 0x75, 0x70, 0x58, 0xed );


extern RPC_IF_HANDLE __MIDL_itf_wmscritsec_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmscritsec_0000_v0_0_s_ifspec;

#ifndef __IWMSCriticalSection_INTERFACE_DEFINED__
#define __IWMSCriticalSection_INTERFACE_DEFINED__

/* interface IWMSCriticalSection */
/* [version][uuid][object] */ 


EXTERN_C const IID IID_IWMSCriticalSection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4d7133a6-397b-4105-9dd8-ebe9757058ed")
    IWMSCriticalSection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Enter( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Leave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsLockHeld( 
            /* [out] */ BOOL __RPC_FAR *pfHeld,
            /* [out] */ DWORD __RPC_FAR *pdwHoldingThreadId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSCriticalSectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMSCriticalSection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMSCriticalSection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMSCriticalSection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enter )( 
            IWMSCriticalSection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Leave )( 
            IWMSCriticalSection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsLockHeld )( 
            IWMSCriticalSection __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfHeld,
            /* [out] */ DWORD __RPC_FAR *pdwHoldingThreadId);
        
        END_INTERFACE
    } IWMSCriticalSectionVtbl;

    interface IWMSCriticalSection
    {
        CONST_VTBL struct IWMSCriticalSectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSCriticalSection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSCriticalSection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSCriticalSection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSCriticalSection_Enter(This)	\
    (This)->lpVtbl -> Enter(This)

#define IWMSCriticalSection_Leave(This)	\
    (This)->lpVtbl -> Leave(This)

#define IWMSCriticalSection_IsLockHeld(This,pfHeld,pdwHoldingThreadId)	\
    (This)->lpVtbl -> IsLockHeld(This,pfHeld,pdwHoldingThreadId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMSCriticalSection_Enter_Proxy( 
    IWMSCriticalSection __RPC_FAR * This);


void __RPC_STUB IWMSCriticalSection_Enter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSCriticalSection_Leave_Proxy( 
    IWMSCriticalSection __RPC_FAR * This);


void __RPC_STUB IWMSCriticalSection_Leave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSCriticalSection_IsLockHeld_Proxy( 
    IWMSCriticalSection __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfHeld,
    /* [out] */ DWORD __RPC_FAR *pdwHoldingThreadId);


void __RPC_STUB IWMSCriticalSection_IsLockHeld_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSCriticalSection_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\wsockntp.h ===
#ifndef _WSOCKPNT_H
#define _WSOCKPNT_H

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {

    BYTE        cfgSizeOfStruct;

        // Must be set to sizeof(XNetStartupParams).  There is no default.

    BYTE        cfgFlags;

        // One or more of the following flags OR'd together:

        #define XNET_STARTUP_BYPASS_SECURITY            0x01
            // This devkit-only flag tells the XNet stack to allow insecure
            // communication to untrusted hosts (such as a PC).  This flag
            // is silently ignored by the secure versions of the library.

        #define XNET_STARTUP_BYPASS_DHCP                0x02
            // This devkit-only flag tells the XNet stack to skip searching for
            // for a DHCP server and use auto-ip only to acquire an IP address.
            // This will save several seconds when starting up if you know
            // that there is no DHCP server configured.  This flag is silently
            // ignored by the secure versions of the library.
            //
            // If you use XNET_STARTUP_BYPASS_DHCP, you will usually
            // want to specify XNET_STARTUP_ALLOW_AUTOIP as well. Otherwise
            // DHCP will be bypassed, but auto-ip won't be run, and as
            // result no IP address will be chosen.

        #define XNET_STARTUP_ALLOW_AUTOIP                0x04
            // This flag tells the XNet stack to use auto-ip to obtain an
            // IP address if DHCP fails or is bypassed.

        // The default is 0 (no flags specified).

    BYTE        cfgPrivatePoolSizeInPages;

        // Specifies the size of the pre-allocated private memory pool used by
        // XNet for the following situations:
        //
        //      - Responding to ARP/DHCP/ICMP messages
        //      - Responding to certain TCP control messages
        //      - Allocating incoming TCP connection request sockets
        //      - Buffering outgoing data until it is transmitted (UDP) or
        //        until it is acknowledged (TCP)
        //      - Buffering incoming data on a socket that does not have a
        //        sufficiently large overlapped read pending
        //
        // The reason for using a private pool instead of the normal system
        // pool is because we want to have completely deterministic memory 
        // behavior.  That is, all memory allocation occurs only when an API
        // is called.  No system memory allocation happens asynchronously in
        // response to an incoming packet.
        //
        // Note that this parameter is in units of pages (4096 bytes per page). 
        //
        // The default is 12 pages (48K).

    BYTE        cfgEnetReceiveQueueLength;
        
        // The length of the Ethernet receive queue in number of packets.  Each 
        // packet takes 2KB of physically contiguous memory.
        //
        // The default is 8 packets (16K).

    BYTE        cfgIpFragMaxSimultaneous;

        // The maximum number of IP datagrams that can be in the process of reassembly
        // at the same time.
        //
        // The default is 4 packets.

    BYTE        cfgIpFragMaxPacketDiv256;

        // The maximum size of an IP datagram (including header) that can be reassembled.
        // Be careful when setting this parameter to a large value as it opens up 
        // a potential denial-of-service attack by consuming large amounts of memory
        // in the fixed-size private pool.
        //
        // Note that this parameter is in units of 256-bytes each.
        //
        // The default is 8 units (2048 bytes).

    BYTE        cfgSockMaxSockets;

        // The maximum number of sockets that can be opened at once, including those 
        // sockets created as a result of incoming connection requests.  Remember
        // that a TCP socket may not be closed immediately after closesocket is
        // called depending on the linger options in place (by default a TCP socket
        // will linger).
        //
        // The default is 64 sockets.
        
    BYTE        cfgSockDefaultRecvBufsizeInK;

        // The default receive buffer size for a socket, in units of K (1024 bytes).
        //
        // The default is 16 units (16K).

    BYTE        cfgSockDefaultSendBufsizeInK;

        // The default send buffer size for a socket, in units of K (1024 bytes).
        //
        // The default is 16 units (16K).

    BYTE        cfgKeyRegMax;

        // The maximum number of XNKID / XNKEY pairs that can be registered at the 
        // same time by calling XNetRegisterKey.
        //
        // The default is 4 key pair registrations.

    BYTE        cfgSecRegMax;

        // The maximum number of security associations that can be registered at the
        // same time.  Security associations are created for each unique XNADDR / XNKID
        // pair passed to XNetXnAddrToInAddr.  Security associations are also implicitly
        // created for each secure host that establishes an incoming connection
        // with this host on a given registered XNKID.  Note that there will only be
        // one security association between a pair of hosts on a given XNKID no matter
        // how many sockets are actively communicating on that secure connection.
        //
        // The default is 32 security associations.

     BYTE       cfgQosDataLimitDiv4;

        // The maximum amount of Qos data, in units of DWORD (4 bytes), that can be supplied
        // to a call to XNetQosListen or returned in the result set of a call to XNetQosLookup.
        //
        // The default is 64 (256 bytes).

} XNetStartupParams;

typedef struct {
    IN_ADDR     ina;                            // IP address (zero if not static/DHCP)
    IN_ADDR     inaOnline;                      // Online IP address (zero if not online)
    WORD        wPortOnline;                    // Online port
    BYTE        abEnet[6];                      // Ethernet MAC address
    BYTE        abOnline[20];                   // Online identification
} XNADDR;

typedef struct {
    BYTE        ab[8];                          // xbox to xbox key identifier
} XNKID;

typedef XNADDR TSADDR;


#define XNET_XNKID_MASK                 0xF0    // Mask of flag bits in first byte of XNKID
#define XNET_XNKID_SYSTEM_LINK          0x00    // Peer to peer system link session
#define XNET_XNKID_ONLINE_PEER          0x80    // Peer to peer online session
#define XNET_XNKID_ONLINE_SERVER        0xC0    // Client to server online session
#define XNET_XNKID_ONLINE_TITLESERVER   0xE0    // Client to title server online session

#define XNetXnKidIsSystemLink(pxnkid)           (((pxnkid)->ab[0] & 0xE0) == XNET_XNKID_SYSTEM_LINK)
#define XNetXnKidIsOnlinePeer(pxnkid)           (((pxnkid)->ab[0] & 0xE0) == XNET_XNKID_ONLINE_PEER)
#define XNetXnKidIsOnlineServer(pxnkid)         (((pxnkid)->ab[0] & 0xE0) == XNET_XNKID_ONLINE_SERVER)
#define XNetXnKidIsOnlineTitleServer(pxnkid)    (((pxnkid)->ab[0] & 0xE0) == XNET_XNKID_ONLINE_TITLESERVER)

// For XNKID values created by Matchmaking, this specifies the database server the session is located on
#define XNET_XNKID_DBINDEX_MASK         0x0F
#define XNetXnKidGetDatabaseIndex(pxnkid)       ((pxnkid)->ab[0] & XNET_XNKID_DBINDEX_MASK)


typedef struct {
    BYTE        ab[16];                         // xbox to xbox key exchange key
} XNKEY;

typedef struct {
    INT         iStatus;                        // WSAEINPROGRESS if pending; 0 if success; error if failed
    UINT        cina;                           // Count of IP addresses for the given host
    IN_ADDR     aina[8];                        // Vector of IP addresses for the given host
} XNDNS;

typedef struct {
    BYTE        bFlags;                         // See XNET_XNQOSINFO_* below
    BYTE        bReserved;                      // Reserved
    WORD        cProbesXmit;                    // Count of Qos probes transmitted
    WORD        cProbesRecv;                    // Count of Qos probes successfully received
    WORD        cbData;                         // Size of Qos data supplied by target (may be zero)
    BYTE *      pbData;                         // Qos data supplied by target (may be NULL)
    WORD        wRttMinInMsecs;                 // Minimum round-trip time in milliseconds
    WORD        wRttMedInMsecs;                 // Median round-trip time in milliseconds
    DWORD       dwUpBitsPerSec;                 // Upstream bandwidth in bits per second
    DWORD       dwDnBitsPerSec;                 // Downstream bandwidth in bits per second
} XNQOSINFO;

#define XNET_XNQOSINFO_COMPLETE         0x01    // Qos has finished processing this entry
#define XNET_XNQOSINFO_TARGET_CONTACTED 0x02    // Target host was successfully contacted
#define XNET_XNQOSINFO_TARGET_DISABLED  0x04    // Target host has disabled its Qos listener
#define XNET_XNQOSINFO_DATA_RECEIVED    0x08    // Target host supplied Qos data
#define XNET_XNQOSINFO_PARTIAL_COMPLETE 0x10    // Qos has unfinsihed estimates for this entry

typedef struct {
    UINT        cxnqos;                         // Count of items in axnqosinfo[] array
    UINT        cxnqosPending;                  // Count of items still pending
    XNQOSINFO   axnqosinfo[1];                  // Vector of Qos results
} XNQOS;



#ifdef __cplusplus
}
#endif

#endif  /* _WSOCKPNT_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\xalloc.h ===
//
//  XAlloc.h
//
//  Function prototypes for XBox-specific heap, based on RockAll heap by Michael Parkes.
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#pragma once
#ifndef __XALLOC_H
#define __XALLOC_H

#ifndef COMPILING_ROCKALL_LIBRARY
#define COMPILING_ROCKALL_LIBRARY
#endif

#include "xexception.h"

#if defined(_DEBUG)
#if defined(USE_PAGE_HEAP)
#include <PageHeap.hpp>
extern PAGE_HEAP g_XHeap;
#else
#include <DebugHeap.hpp>
extern DEBUG_HEAP g_XHeap;
#endif
#else
#include <BlendedHeap.hpp>
extern BLENDED_HEAP g_XHeap;
#endif



#define XAlloc(nSize) g_XHeap.New(nSize, NULL, false)
#define XAllocZ(nSize) g_XHeap.New(nSize, NULL, true)

#define XReAlloc(pv, nNewSize) g_XHeap.Resize(pv, nNewSize, 1, NULL, false, false)
#define XReAllocZ(pv, nNewSize) g_XHeap.Resize(pv, nNewSize, 1, NULL, false, true)

#define XFree(pv) g_XHeap.Delete(pv)

#if defined(_DEBUG)
    #define XDumpLeaks() g_XHeap.HeapLeaks()
#else
    #define XDumpLeaks()
#endif
/*
#define XAlloc(nSize) malloc(nSize)
#define XAllocZ(nSize) calloc(nSize)

#define XReAlloc(pv, nNewSize) realloc(pv, nNewSize)
#define XReAllocZ(pv, nNewSize) realloc(pv, nNewSize)

#define XFree(pv) free(pv)

#define XDumpLeaks()
*/

//
//  Overloaded global new and delete operators that use
//  our heap.
//

#if defined(IMPL_X_NEWDELETE)
void* __cdecl operator new(size_t nSize) { return XAlloc(nSize); }
void  __cdecl operator delete(void * pv) { XFree(pv); };
#else
extern void* __cdecl operator new(size_t);
extern void __cdecl operator delete(void*);
#endif

//
//  Smart pointer class.
//

template <class T>
class XPtr
{
public:

    //
    //  Default constructor allocates a single T.
    //

    XPtr(void)
    {
        m_p = NULL;
    }

    XPtr(int nSize)
    {
        if(nSize != 0)
        {
            // 48768 - Check for overflow
            if(nSize > (0xFFFFFFFF/sizeof(T)))
                THROW_WITH_HR(E_OUTOFMEMORY, "Allocation too large");

            m_p = (T*)XAlloc(sizeof(T) * nSize);
            THROW_IF_NULL_PTR(m_p, E_OUTOFMEMORY, "");
        }
        else
            m_p = NULL;
    }

    //
    //  Destructor
    //

    ~XPtr()
    {
        if(m_p != NULL)
            XFree(m_p);
    }

    //
    //  Allocate n elements
    //

    void Alloc(int nSize)
    {
        // 48832 - Check for overflow
        if(nSize > (0xFFFFFFFF/sizeof(T)))
            THROW_WITH_HR(E_OUTOFMEMORY, "Allocation too large");

        m_p = (T*)XAlloc(sizeof(T) * nSize);
        THROW_IF_NULL_PTR(m_p, E_OUTOFMEMORY, "");
    }

    //
    //  operators
    //

    operator T*()
    {
        return m_p;
    }

    T operator->()
    {
        return m_p;
    }

    T& operator[](int nIndex)
    {
        return m_p[nIndex];
    }

protected:

    T*   m_p;
};

#endif // __XALLOC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\xauthdata.h ===
#ifndef _XAUTHDATA_H_
#define _XAUTHDATA_H_

#pragma once

#include "xadrpc.h"
#include "winsock2.h"

typedef struct _XAD_XBOX
{
WORD                wTicketVersion; // This is the ticket version,
                                        // which is different from the client version
WORD                wClientVersion; // This is the client XOnline SDK version
DWORD               dwTitleID;      // The is the game title ID
ULONGLONG           qwXboxID;        // Passport PUID for machine account
ULONGLONG           qwUserID[4];     // Passport PUID for the 4 users, will be zero if no user present
DWORD               dwUserAuthData[4]; // A DWORD of AuthData for each user, The KDC and the services will need to agree on
                                           // what each bit of the DWORD means (e.g. the second bit represents a gold membership).
} XAD_XBOX, *PXAD_XBOX;

void XadQueryContextInfo(IN_ADDR addr, unsigned int port, XAUTHDATA *ad);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\xerrors.h ===
#pragma once

#ifndef __XERRORS_H
#define __XERRORS_H


#define XAUTH_S_BASE                        MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x1000)
#define XAUTH_S_KEEP_ALIVE                  MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x1000)

#define XAUTH_E_BASE                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1000)
#define XAUTH_E_FILENAME_NOT_CONFIGURED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1000)
#define XAUTH_E_NO_FILENAME_IN_REQUEST      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1001)

#endif // __XERRORS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\xauth.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    xauth.h

Abstract:

    Definitions and data structures used in xbox authentication.

Author:

    Darren Anderson (darrenan) 30-October-2000

Revision History:

--*/

#ifndef __XAUTH_H
#define __XAUTH_H

#include <time.h>
#include "rc4sha1.h"

#ifdef __cplusplus
extern "C" {
#endif

//#define X_KEY_LEN                XCRYPT_MAC_SIZE  // It's 20
#define X_KEY_LEN                32
#define X_MAX_USER_NAME_LEN      64          // TODO, length still undecided
#define X_MAX_AUTHED_USERS       4           // at most four users can be authenticated at once.
#define X_MAX_TICKET_SIZE        128         // TODO, don't know how long this is yet.
#define X_MAX_REQUESTED_SERVICES 8           // TODO, don't know how long this is yet.
#define X_MAX_SERVICE_NAME_LEN   4           // TODO, don't know how long this is yet
#define X_TICKET_LIFETIME        3600        // TODO, should be configurable
#define X_MAX_AUTHENTICATOR_AGE  600         // timestamp in the authenticator can be at most 10 minutes old.
#define X_CPUID_LEN              12          // byte size of cpuid returned by asm call.
#define X_HDDID_LEN              20          // TODO, don't know how long this is yet.
#define X_SERIAL_NUM_LEN         12          // number of characters in a serial number, after whitespace
                                             // and hyphens are removed.

//
// The current version number of the protocol
//

#define XONLINE_PROTOCOL_VERSION_MAJOR 1
#define XONLINE_PROTOCOL_VERSION_MINOR 0

//
//  Codes that can be returned in the body of the XBOX_AUTH_ERROR response
//

#define XBOX_AUTH_ERROR_BAD_CREDS               1
#define XBOX_AUTH_ERROR_NO_USERS                2
#define XBOX_AUTH_ERROR_NO_SERVICES             3
#define XBOX_AUTH_ERROR_MISSING_USER            4
#define XBOX_AUTH_ERROR_MISSING_CREDS           5
#define XBOX_AUTH_ERROR_MISSING_XBOX_ID         6
#define XBOX_AUTH_ERROR_UNKNOWN_USER            7
#define XBOX_AUTH_ERROR_UNKNOWN_SERVICE         8
#define XBOX_AUTH_ERROR_BAD_XBOX_ID             9
#define XBOX_AUTH_ERROR_UNREGISTERED_XBOX_ID    10
#define XBOX_AUTH_ERROR_BAD_PROTOCOL_VERSION    11
#define XBOX_AUTH_ERROR_OBSOLETE_VERSION        12
#define XBOX_AUTH_ERROR_NO_VERSION              13

//
//  Strings used in HTTP authentication
//

#define X_AUTH_SCHEME   "xbox"
#define X_TICKET_TOKEN  "ticket"
#define X_AUTH_TOKEN    "auth"
#define X_VERSION_TOKEN "v"
#define X_SAUTH_TOKEN   "sauth"

enum X_AUTH_TOKENS
{
    X_AUTH_TICKET=0,
    X_AUTH_AUTHENTICATOR,
    X_AUTH_VERSION,
    X_AUTH_LAST
};

//
//  Information returned to the xbox about each requested service.
//

typedef struct _XSERVICEINFO
{
    BYTE        sessionKey[X_KEY_LEN];
    DWORD       dwServiceIP;
    WORD        wServicePort;
    WORD        wReserved;
}
XSERVICEINFO, *PXSERVICEINFO;

//
//  XBox ticket structure.
//

typedef struct _XBOXTICKET
{
    time_t      tTicketTime;
    time_t      tExpirationTime;
    DWORD       dwNumServices;
    ULONGLONG   qwUserIds[X_MAX_AUTHED_USERS];
}
XBOXTICKET, *PXBOXTICKET;

//
//  Application ticket.
//

typedef struct _XAPPTICKET
{
    WORD        wVersionLow;    // not encrypted
    WORD        wVersionHigh;   // not encrypted
    time_t      tTicketTime;
    time_t      tExpirationTime;
    BYTE        sessionKey[X_KEY_LEN];
    DWORD       dwXBoxIP;  
    ULONGLONG   qwXBoxID;
    ULONGLONG   qwUserIds[X_MAX_AUTHED_USERS];
}
XAPPTICKET, *PXAPPTICKET;

//
//  XBox authenticator
//

typedef struct _XAUTHENTICATOR
{
    ULONGLONG   qwXboxID;
    BYTE        pURLMAC[XCRYPT_MAC_SIZE];
    time_t      tAuthTime;
}
XAUTHENTICATOR, *PXAUTHENTICATOR;

#ifdef __cplusplus
}   // extern "C"
#endif

#endif // __XAUTH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\xetestkeys.h ===
// Xenon Temporary Test keys 

#ifndef _XETESTKEYSH_
#define _XETESTKEYSH_

//-----------------------------------------------------------------------------
// Xenon-Master-Signing-Key
// Used to sign and verify console certificates. When we have the final keys, 
// only the public key will be available to the console while the private key 
// will live in ncypher devices at the factories. I'm making the test key 
// available here for test purposes only
//-----------------------------------------------------------------------------

extern const BYTE g_XenonMasterSigningProdBsafePub2048[284];
extern const BYTE g_XenonMasterSigningBsafePub2048[284];
extern const BYTE g_XenonMasterSigningBsafePrv2048[1340];

//-----------------------------------------------------------------------------
// Xenon-Console-key
// This is the new xenon console key. It's generated at the factory. The 
// public key will be made available to the world in the form of the console
// certificate
//-----------------------------------------------------------------------------

extern const BYTE g_XenonConsoleRsaBsafePub1024[156];
extern const BYTE g_XenonConsoleRsaBsafePrv1024[700];

//-----------------------------------------------------------------------------
// Xenon-XMACS-key
// Used to  authenticate with XMACS . The public key will be hardcoded in the 
// console. The private key will live in a nCypher device in the Live 
// datacenter. 
//-----------------------------------------------------------------------------

extern const BYTE g_XenonXmacsBsafePub2048[284];
extern const BYTE g_XenonXmacsBsafePrv2048[1340];

#endif // #ifndef _XETESTKEYSH_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\xboxverp.h ===
/****************************************************************************
 *                                                                          *
 *      XboxVerP.H      -- Version information for internal builds          *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION, VER_PRODUCTVERSION_STR and             *
 *      VER_PRODUCTBETA_STR values.                                         *
 *                                                                          *
 ****************************************************************************/

#if !defined(SKIP_XBOXVERP_PRAGMA)
#pragma once
#endif

#include <bldver.h>

#define VER_PRODUCTBETA_STR         ""
#define VER_PRODUCTVERSION_W        MAKEWORD(PRODUCT_MINOR,PRODUCT_MAJOR)
#define VER_PRODUCTVERSION_DW       MAKELONG(BUILD_MAJOR,MAKEWORD(PRODUCT_MINOR,PRODUCT_MAJOR))
#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft(R) is a registered trademark of Microsoft Corporation. Xbox(TM) is a trademark of Microsoft Corporation."

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if DBG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is prerelease */
#if BETA
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#if OFFICIAL_BUILD
#define VER_PRIVATE                 0
#else
#define VER_PRIVATE                 VS_FF_PRIVATEBUILD
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG|VER_PRIVATE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\XEvent.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once
#ifndef __XEvent_HPP
#define __XEvent_HPP

class XEvent
{
public:

    XEvent(BOOL bManualReset = TRUE, BOOL bInitialState = FALSE)
    {
        m_hEvent = CreateEvent(NULL, bManualReset, bInitialState, NULL);
    }

    ~XEvent()
    {
        if(m_hEvent != NULL)
            CloseHandle(m_hEvent);
    }

    BOOL Pulse()    {return PulseEvent(m_hEvent);}
    BOOL Set()      {return SetEvent(m_hEvent);}
    BOOL Reset()    {return ResetEvent(m_hEvent);}

    operator HANDLE() {return m_hEvent;}

private:

    HANDLE m_hEvent;
};

#endif // __XEvent_HPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\XElapsed.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once

#include <windows.h>

// Nonchanging frequency of the high resolution system counter.	

class XTimeElapsed
{
public:
    // moved this from a global static to a member which is populated from a static within the constructor.
    // this was done because the global static had file scope, and the compiler was picking different instances
    // of the global when different members of this class were called.  (causing a crash)
    ULONGLONG m_xPerfFreq;

    // Constructor. Gets the current time for reference.                
    XTimeElapsed()
    {
        static ULONGLONG _xPerfFreq = 0;
        if (_xPerfFreq == 0)
        {
            QueryPerformanceFrequency((LARGE_INTEGER *) &_xPerfFreq); 
        }
        m_xPerfFreq = _xPerfFreq;
        QueryPerformanceCounter((LARGE_INTEGER *) &_started);
    }

    void ReStart()
    {
        QueryPerformanceCounter((LARGE_INTEGER *) &_started);    
    }
    
    // Returns the time elapsed since the object was constructed.
    ULONGLONG TimeElapsed()
    {
        ULONGLONG now;
        QueryPerformanceCounter((LARGE_INTEGER *) &now);

        return now - _started;
    }
    
    ULONG SecondsElapsed()
    {
        ULONGLONG now;
        QueryPerformanceCounter((LARGE_INTEGER *) &now);                

        return (ULONG)((now - _started) / m_xPerfFreq);                
    }
    
    ULONG MillisecondsElapsed()
    {
        ULONGLONG now;
        QueryPerformanceCounter((LARGE_INTEGER *) &now);                

        return (ULONG)(((now - _started) * 1000) / m_xPerfFreq); 
    }

    ULONGLONG OneHundredNanoElapsed()
    {
        ULONGLONG now;
        QueryPerformanceCounter((LARGE_INTEGER *) &now);                

        return (((now - _started) * 10000000) / m_xPerfFreq); 
    }

private:
    ULONGLONG _started;
    // Time when object was instantiated.
        
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\XGuard.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef __XGUARD_H
#define __XGUARD_H

template <class Lock>
class XGuard
{
public:
	XGuard(Lock& lock)
		:mLock(lock)
	{
		mLock.Lock();
	}

	~XGuard()
	{
		mLock.Unlock();
	}
private:
	Lock& mLock;
};

#endif //!__XGUARD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\xeventids.h ===
// AUTO GENERATED FILE 
// MODIFY THE CORRESPONDING .xml AND .xsl FILES 
/////////////////////////////////////////////////////////////////////////////// 
 


// XEVENT_ACCELERATION_STARTUP_MGMT_INIT_FAILED, 20500, Error
#define XEVENT_ACCELERATION_STARTUP_MGMT_INIT_FAILED 0xC0005014

// XEVENT_ACCELERATION_STARTUP_MGMT_REGISTER_FAILED, 20501, Error
#define XEVENT_ACCELERATION_STARTUP_MGMT_REGISTER_FAILED 0xC0005015

// XEVENT_ACCELERATION_STARTUP_CONFIG_FAILED, 20502, Error
#define XEVENT_ACCELERATION_STARTUP_CONFIG_FAILED 0xC0005016

// XEVENT_ACCELERATION_STARTUP_PERF_COUNTERS_FAILED, 20503, Error
#define XEVENT_ACCELERATION_STARTUP_PERF_COUNTERS_FAILED 0xC0005017

// XEVENT_ACCELERATION_STARTUP_BUFFER_POOL_FAILED, 20504, Error
#define XEVENT_ACCELERATION_STARTUP_BUFFER_POOL_FAILED 0xC0005018

// XEVENT_ACCELERATION_STARTUP_SWITCHBOARD_FAILED, 20505, Error
#define XEVENT_ACCELERATION_STARTUP_SWITCHBOARD_FAILED 0xC0005019

// XEVENT_ACCELERATION_STARTUP_MRU_LIST_FAILED, 20506, Error
#define XEVENT_ACCELERATION_STARTUP_MRU_LIST_FAILED 0xC000501A

// XEVENT_ACCELERATION_STARTUP_CHANGELIST_FAILED, 20507, Error
#define XEVENT_ACCELERATION_STARTUP_CHANGELIST_FAILED 0xC000501B

// XEVENT_ACCELERATION_STARTUP_LOOKUP_TABLE_FAILED, 20508, Error
#define XEVENT_ACCELERATION_STARTUP_LOOKUP_TABLE_FAILED 0xC000501C

// XEVENT_ACCELERATION_STARTUP_LISTENER_FAILED, 20509, Error
#define XEVENT_ACCELERATION_STARTUP_LISTENER_FAILED 0xC000501D

// XEVENT_ACCELERATION_STARTUP_ALLOCATOR_FAILED, 20517, Error
#define XEVENT_ACCELERATION_STARTUP_ALLOCATOR_FAILED 0xC0005025

// XEVENT_ACCELERATION_CONFIG_LISTENER_FAILED, 20510, Error
#define XEVENT_ACCELERATION_CONFIG_LISTENER_FAILED 0xC000501E

// XEVENT_ACCELERATION_CONFIG_SETTING_FAILED, 20511, Error
#define XEVENT_ACCELERATION_CONFIG_SETTING_FAILED 0xC000501F

// XEVENT_ACCELERATION_CONFIG_OUT_OF_MEMORY, 20512, Error
#define XEVENT_ACCELERATION_CONFIG_OUT_OF_MEMORY 0xC0005020

// XEVENT_ACCELERATION_CONFIG_POST_COMPLETION_FAILED, 20513, Error
#define XEVENT_ACCELERATION_CONFIG_POST_COMPLETION_FAILED 0xC0005021

// XEVENT_ACCELERATION_CONFIG_WAIT_COMPLETION_FAILED, 20514, Error
#define XEVENT_ACCELERATION_CONFIG_WAIT_COMPLETION_FAILED 0xC0005022

// XEVENT_ACCELERATION_CONFIG_HEALTHINTEROP_CREATE, 20515, Error
#define XEVENT_ACCELERATION_CONFIG_HEALTHINTEROP_CREATE 0xC0005023

// XEVENT_ACCELERATION_CONFIG_HEALTHINTEROP_INIT, 20516, Error
#define XEVENT_ACCELERATION_CONFIG_HEALTHINTEROP_INIT 0xC0005024

// XEVENT_ACCELERATION_SOCKET_INIT_COMPLETION_PORT_FAILED, 20520, Error
#define XEVENT_ACCELERATION_SOCKET_INIT_COMPLETION_PORT_FAILED 0xC0005028

// XEVENT_ACCELERATION_SOCKET_INIT_CREATE_INSTANCE_FAILED, 20521, Error
#define XEVENT_ACCELERATION_SOCKET_INIT_CREATE_INSTANCE_FAILED 0xC0005029

// XEVENT_ACCELERATION_SOCKET_INIT_FAILED, 20522, Error
#define XEVENT_ACCELERATION_SOCKET_INIT_FAILED 0xC000502A

// XEVENT_ACCELERATION_SOCKET_INIT_LISTEN_FAILED, 20523, Error
#define XEVENT_ACCELERATION_SOCKET_INIT_LISTEN_FAILED 0xC000502B

// XEVENT_ACCELERATION_SOCKET_ACCEPT_FAILED, 20524, Error
#define XEVENT_ACCELERATION_SOCKET_ACCEPT_FAILED 0xC000502C

// XEVENT_ACCELERATION_SOCKET_SIZE_MISMATCH, 20525, Error
#define XEVENT_ACCELERATION_SOCKET_SIZE_MISMATCH 0xC000502D

// XEVENT_ACCELERATION_SOCKET_PROCESS_REQUEST_FAILED, 20526, Error
#define XEVENT_ACCELERATION_SOCKET_PROCESS_REQUEST_FAILED 0xC000502E

// XEVENT_ACCELERATION_PROXY_BUCKET_MAP_FAILED, 20530, Error
#define XEVENT_ACCELERATION_PROXY_BUCKET_MAP_FAILED 0xC0005032

// XEVENT_ACCELERATION_PROXY_BUCKET_CHANGE_FAILED, 20531, Error
#define XEVENT_ACCELERATION_PROXY_BUCKET_CHANGE_FAILED 0xC0005033

// XEVENT_ACCELERATION_PROXY_SERVER_CHANGE_FAILED, 20532, Error
#define XEVENT_ACCELERATION_PROXY_SERVER_CHANGE_FAILED 0xC0005034

// XEVENT_ACCELERATION_PROXY_CONNECT_FAILED, 20533, Error
#define XEVENT_ACCELERATION_PROXY_CONNECT_FAILED 0xC0005035

// XEVENT_ACCELERATION_PROXY_SEND_FAILED, 20534, Error
#define XEVENT_ACCELERATION_PROXY_SEND_FAILED 0xC0005036

// XEVENT_ACCELERATION_PROXY_RECEIVE_FAILED, 20535, Error
#define XEVENT_ACCELERATION_PROXY_RECEIVE_FAILED 0xC0005037

// XEVENT_ACCELERATION_PROXY_CALLBACK_EXCEPTION, 20536, Error
#define XEVENT_ACCELERATION_PROXY_CALLBACK_EXCEPTION 0xC0005038

// XEVENT_ACCELERATION_PROXY_REMOVE_FAILED, 20537, Error
#define XEVENT_ACCELERATION_PROXY_REMOVE_FAILED 0xC0005039

// XEVENT_ACCELERATION_PROXY_REQUEST_FAILED, 20538, Error
#define XEVENT_ACCELERATION_PROXY_REQUEST_FAILED 0xC000503A

// XEVENT_ACCELERATION_PROXY_NOT_INITIALIZED, 20539, Error
#define XEVENT_ACCELERATION_PROXY_NOT_INITIALIZED 0xC000503B

// XEVENT_ACCELERATION_PROXY_NOTIFICATION_FAILED, 20540, Error
#define XEVENT_ACCELERATION_PROXY_NOTIFICATION_FAILED 0xC000503C

// XEVENT_ACCELERATION_UNSUPPORTED_MESSAGE, 20575, Error
#define XEVENT_ACCELERATION_UNSUPPORTED_MESSAGE 0xC000505F

// XEVENT_ACCELERATION_SERVER_TOO_BUSY, 20576, Error
#define XEVENT_ACCELERATION_SERVER_TOO_BUSY 0xC0005060

// XEVENT_ACCELERATION_SERVER_BUFFERPOOL_OUTOFMEMORY, 20577, Error
#define XEVENT_ACCELERATION_SERVER_BUFFERPOOL_OUTOFMEMORY 0xC0005061

// XEVENT_ACCELERATION_WARN_0, 20600, Warning
#define XEVENT_ACCELERATION_WARN_0 0x80005078

// XEVENT_ACCELERATION_STARTED, 20700, Info
#define XEVENT_ACCELERATION_STARTED 0x400050DC

// XEVENT_ACCELERATION_SHUTDOWN_STARTED, 20701, Info
#define XEVENT_ACCELERATION_SHUTDOWN_STARTED 0x400050DD

// XEVENT_ACCELERATION_SHUTDOWN_COMPLETE, 20702, Info
#define XEVENT_ACCELERATION_SHUTDOWN_COMPLETE 0x400050DE

// XEVENT_ACCELERATION_CONFIG_SETTING_CHANGED, 20703, Info
#define XEVENT_ACCELERATION_CONFIG_SETTING_CHANGED 0x400050DF

// XEVENT_ACCELERATION_INFO_SERVER_RESUME, 20704, Info
#define XEVENT_ACCELERATION_INFO_SERVER_RESUME 0x400050E0

// XEVENT_AAGW_CONFIG_INVALID_ALLOWLISTENTRY, 15000, Error
#define XEVENT_AAGW_CONFIG_INVALID_ALLOWLISTENTRY 0xC0003A98

// XEVENT_AAM_UODB_DATABASE_ERROR, 63825, Error
#define XEVENT_AAM_UODB_DATABASE_ERROR 0xC000F951

// XEVENT_AAM_HANDLEREQUEST_ERROR, 63826, Error
#define XEVENT_AAM_HANDLEREQUEST_ERROR 0xC000F952

// XEVENT_AAM_CONFIG_INFO, 63827, Info
#define XEVENT_AAM_CONFIG_INFO 0x4000F953

// XEVENT_AAM_CONFIG_WARNING, 63828, Warning
#define XEVENT_AAM_CONFIG_WARNING 0x8000F954

// XEVENT_AAM_CONFIG_ERROR, 63829, Error
#define XEVENT_AAM_CONFIG_ERROR 0xC000F955

// XEVENT_AAM_POLICY_RELOADED, 63830, Info
#define XEVENT_AAM_POLICY_RELOADED 0x4000F956

// XEVENT_AAM_CONFIG_RPS_ERROR, 63831, Error
#define XEVENT_AAM_CONFIG_RPS_ERROR 0xC000F957

// XEVENT_AAM_INFO_TRACKING_START, 63832, Warning
#define XEVENT_AAM_INFO_TRACKING_START 0x8000F958

// XEVENT_AAM_INFO_TRACKING_STOP, 63833, Info
#define XEVENT_AAM_INFO_TRACKING_STOP 0x4000F959

// XEVENT_AAM_INFO_THROTTLING_START, 63834, Warning
#define XEVENT_AAM_INFO_THROTTLING_START 0x8000F95A

// XEVENT_AAM_INFO_THROTTLING_STOP, 63835, Info
#define XEVENT_AAM_INFO_THROTTLING_STOP 0x4000F95B

// XEVENT_AAM_INFO_BLOCKING_START, 63836, Warning
#define XEVENT_AAM_INFO_BLOCKING_START 0x8000F95C

// XEVENT_AAM_INFO_BLOCKING_STOP, 63837, Info
#define XEVENT_AAM_INFO_BLOCKING_STOP 0x4000F95D

// XEVENT_AAM_ANTIDOS_LIMIT_EXCEEDED, 63838, Error
#define XEVENT_AAM_ANTIDOS_LIMIT_EXCEEDED 0xC000F95E

// XEVENT_AAGW_HACK_URL, 63850, Error
#define XEVENT_AAGW_HACK_URL 0xC000F96A

// XEVENT_AAGW_HACK_UNKNOWN_SERVICE, 63851, Error
#define XEVENT_AAGW_HACK_UNKNOWN_SERVICE 0xC000F96B

// XEVENT_AAGW_HACK_UNKNOWN_HTTP_METHOD, 63852, Error
#define XEVENT_AAGW_HACK_UNKNOWN_HTTP_METHOD 0xC000F96C

// XEVENT_AAGW_HACK_URL_TOO_LONG, 63853, Error
#define XEVENT_AAGW_HACK_URL_TOO_LONG 0xC000F96D

// XEVENT_AAGW_HACK_QUERY_TOO_LONG, 63854, Error
#define XEVENT_AAGW_HACK_QUERY_TOO_LONG 0xC000F96E

// XEVENT_AAGW_HACK_CONTENT_TOO_LONG, 63855, Error
#define XEVENT_AAGW_HACK_CONTENT_TOO_LONG 0xC000F96F

// XEVENT_AAGW_EXCEPTION_WITH_NO_RESPONSE, 63856, Error
#define XEVENT_AAGW_EXCEPTION_WITH_NO_RESPONSE 0xC000F970

// XEVENT_AAGW_CONFIG_INVALID_SETTING, 63857, Error
#define XEVENT_AAGW_CONFIG_INVALID_SETTING 0xC000F971

// XEVENT_AAGW_CONFIG_SERVICE_TABLE, 63858, Error
#define XEVENT_AAGW_CONFIG_SERVICE_TABLE 0xC000F972

// XEVENT_AAGW_CONFIG_INFO, 63859, Info
#define XEVENT_AAGW_CONFIG_INFO 0x4000F973

// XEVENT_AAGW_INTERNAL_ERROR, 63860, Error
#define XEVENT_AAGW_INTERNAL_ERROR 0xC000F974

// XEVENT_XEVENTS_FAIL_INIT, 50000, Error
#define XEVENT_XEVENTS_FAIL_INIT 0xC000C350

// XEVENT_XEVENTS_FAIL_INIT_1, 50001, Error
#define XEVENT_XEVENTS_FAIL_INIT_1 0xC000C351

// XEVENT_XEVENTS_FAIL_INIT_2, 50002, Error
#define XEVENT_XEVENTS_FAIL_INIT_2 0xC000C352

// XEVENT_XEVENTS_FAIL_INIT_3, 50003, Error
#define XEVENT_XEVENTS_FAIL_INIT_3 0xC000C353

// XEVENT_XEVENTS_FAIL_INIT_4, 50004, Error
#define XEVENT_XEVENTS_FAIL_INIT_4 0xC000C354

// XEVENT_XEVENTS_NULL_BUFFER, 50005, Error
#define XEVENT_XEVENTS_NULL_BUFFER 0xC000C355

// XEVENT_XEVENTS_NULL_BUFFER_1, 50006, Error
#define XEVENT_XEVENTS_NULL_BUFFER_1 0xC000C356

// XEVENT_ALERTS_CODE_7, 50007, Error
#define XEVENT_ALERTS_CODE_7 0xC000C357

// XEVENT_ALERTS_CODE_8, 50008, Error
#define XEVENT_ALERTS_CODE_8 0xC000C358

// XEVENT_XEVENTS_BAD_PACKET, 50009, Error
#define XEVENT_XEVENTS_BAD_PACKET 0xC000C359

// XEVENT_XEVENTS_BAD_PACKET_1, 50010, Error
#define XEVENT_XEVENTS_BAD_PACKET_1 0xC000C35A

// XEVENT_XEVENTS_FAIL_INIT_5, 50011, Error
#define XEVENT_XEVENTS_FAIL_INIT_5 0xC000C35B

// XEVENT_XEVENTS_FAIL_INIT_6, 50012, Error
#define XEVENT_XEVENTS_FAIL_INIT_6 0xC000C35C

// XEVENT_XEVENTS_FAIL_INIT_7, 50013, Error
#define XEVENT_XEVENTS_FAIL_INIT_7 0xC000C35D

// XEVENT_XEVENTS_FAIL_INIT_8, 50014, Error
#define XEVENT_XEVENTS_FAIL_INIT_8 0xC000C35E

// XEVENT_XEVENTS_FAIL_INIT_9, 50015, Error
#define XEVENT_XEVENTS_FAIL_INIT_9 0xC000C35F

// XEVENT_XEVENTS_FAIL_INIT_10, 50016, Error
#define XEVENT_XEVENTS_FAIL_INIT_10 0xC000C360

// XEVENT_XEVENTS_FAIL_INIT_11, 50017, Error
#define XEVENT_XEVENTS_FAIL_INIT_11 0xC000C361

// XEVENT_XEVENTS_FAIL_INIT_12, 50018, Error
#define XEVENT_XEVENTS_FAIL_INIT_12 0xC000C362

// XEVENT_XEVENTS_RECEIVE_FAIL, 50050, Error
#define XEVENT_XEVENTS_RECEIVE_FAIL 0xC000C382

// XEVENT_XEVENTS_RECEIVE_FAIL_1, 50051, Error
#define XEVENT_XEVENTS_RECEIVE_FAIL_1 0xC000C383

// XEVENT_ALERTS_COMM_2, 50052, Error
#define XEVENT_ALERTS_COMM_2 0xC000C384

// XEVENT_ALERTS_COMM_3, 50053, Error
#define XEVENT_ALERTS_COMM_3 0xC000C385

// XEVENT_ALERTS_COMM_4, 50054, Error
#define XEVENT_ALERTS_COMM_4 0xC000C386

// XEVENT_ALERTS_COMM_5, 50055, Error
#define XEVENT_ALERTS_COMM_5 0xC000C387

// XEVENT_ALERTS_COMM_6, 50056, Error
#define XEVENT_ALERTS_COMM_6 0xC000C388

// XEVENT_ALERTS_COMM_7, 50057, Error
#define XEVENT_ALERTS_COMM_7 0xC000C389

// XEVENT_ALERTS_COMM_8, 50058, Error
#define XEVENT_ALERTS_COMM_8 0xC000C38A

// XEVENT_ALERTS_COMM_9, 50059, Error
#define XEVENT_ALERTS_COMM_9 0xC000C38B

// XEVENT_ALERTS_CONFIG_0, 50100, Error
#define XEVENT_ALERTS_CONFIG_0 0xC000C3B4

// XEVENT_ALERTS_CONFIG_1, 50101, Error
#define XEVENT_ALERTS_CONFIG_1 0xC000C3B5

// XEVENT_ALERTS_CONFIG_2, 50102, Error
#define XEVENT_ALERTS_CONFIG_2 0xC000C3B6

// XEVENT_ALERTS_CONFIG_3, 50103, Error
#define XEVENT_ALERTS_CONFIG_3 0xC000C3B7

// XEVENT_ALERTS_CONFIG_4, 50104, Error
#define XEVENT_ALERTS_CONFIG_4 0xC000C3B8

// XEVENT_ALERTS_CONFIG_5, 50105, Error
#define XEVENT_ALERTS_CONFIG_5 0xC000C3B9

// XEVENT_ALERTS_CONFIG_6, 50106, Error
#define XEVENT_ALERTS_CONFIG_6 0xC000C3BA

// XEVENT_ALERTS_CONFIG_7, 50107, Error
#define XEVENT_ALERTS_CONFIG_7 0xC000C3BB

// XEVENT_ALERTS_INFO_0, 50125, Info
#define XEVENT_ALERTS_INFO_0 0x4000C3CD

// XEVENT_ALERTS_INFO_1, 50126, Info
#define XEVENT_ALERTS_INFO_1 0x4000C3CE

// XEVENT_ALERTS_INFO_2, 50127, Info
#define XEVENT_ALERTS_INFO_2 0x4000C3CF

// XEVENT_ALERTS_INFO_3, 50128, Info
#define XEVENT_ALERTS_INFO_3 0x4000C3D0

// XEVENT_ARBITRATION_INTERNAL_FATAL_ERROR, 50150, Error
#define XEVENT_ARBITRATION_INTERNAL_FATAL_ERROR 0xC000C3E6

// XEVENT_ARBITRATION_INTERNAL_FATAL_ERROR_1, 50151, Error
#define XEVENT_ARBITRATION_INTERNAL_FATAL_ERROR_1 0xC000C3E7

// XEVENT_ARBITRATION_CODE_2, 50152, Error
#define XEVENT_ARBITRATION_CODE_2 0xC000C3E8

// XEVENT_ARBITRATION_CODE_3, 50153, Error
#define XEVENT_ARBITRATION_CODE_3 0xC000C3E9

// XEVENT_ARBITRATION_INTERNAL_FATAL_ERROR_2, 50154, Error
#define XEVENT_ARBITRATION_INTERNAL_FATAL_ERROR_2 0xC000C3EA

// XEVENT_ARBITRATION_CODE_5, 50155, Error
#define XEVENT_ARBITRATION_CODE_5 0xC000C3EB

// XEVENT_ARBITRATION_CODE_6, 50156, Error
#define XEVENT_ARBITRATION_CODE_6 0xC000C3EC

// XEVENT_ARBITRATION_CODE_7, 50157, Error
#define XEVENT_ARBITRATION_CODE_7 0xC000C3ED

// XEVENT_ARBITRATION_INTERFACE_BUCKET_THREAD, 50158, Error
#define XEVENT_ARBITRATION_INTERFACE_BUCKET_THREAD 0xC000C3EE

// XEVENT_ARBITRATION_INTERFACE_BUCKET_UNABLE_TO_QUEUE_EVENT, 50159, Error
#define XEVENT_ARBITRATION_INTERFACE_BUCKET_UNABLE_TO_QUEUE_EVENT 0xC000C3EF

// XEVENT_ARBITRATION_COMM_0, 50175, Error
#define XEVENT_ARBITRATION_COMM_0 0xC000C3FF

// XEVENT_ARBITRATION_COMM_1, 50176, Error
#define XEVENT_ARBITRATION_COMM_1 0xC000C400

// XEVENT_ARBITRATION_COMM_2, 50177, Error
#define XEVENT_ARBITRATION_COMM_2 0xC000C401

// XEVENT_ARBITRATION_COMM_3, 50178, Error
#define XEVENT_ARBITRATION_COMM_3 0xC000C402

// XEVENT_ARBITRATION_COMM_4, 50179, Error
#define XEVENT_ARBITRATION_COMM_4 0xC000C403

// XEVENT_ARBITRATION_COMM_5, 50180, Error
#define XEVENT_ARBITRATION_COMM_5 0xC000C404

// XEVENT_ARBITRATION_COMM_6, 50181, Error
#define XEVENT_ARBITRATION_COMM_6 0xC000C405

// XEVENT_ARBITRATION_COMM_7, 50182, Error
#define XEVENT_ARBITRATION_COMM_7 0xC000C406

// XEVENT_ARBITRATION_COMM_8, 50183, Error
#define XEVENT_ARBITRATION_COMM_8 0xC000C407

// XEVENT_ARBITRATION_COMM_9, 50184, Error
#define XEVENT_ARBITRATION_COMM_9 0xC000C408

// XEVENT_ARBITRATION_COMM_10, 50185, Error
#define XEVENT_ARBITRATION_COMM_10 0xC000C409

// XEVENT_ARBITRATION_COMM_11, 50186, Error
#define XEVENT_ARBITRATION_COMM_11 0xC000C40A

// XEVENT_ARBITRATION_COMM_12, 50187, Error
#define XEVENT_ARBITRATION_COMM_12 0xC000C40B

// XEVENT_ARBITRATION_CONFIG_0, 50225, Error
#define XEVENT_ARBITRATION_CONFIG_0 0xC000C431

// XEVENT_ARBITRATION_CONFIGURATION_ERROR, 50226, Warning
#define XEVENT_ARBITRATION_CONFIGURATION_ERROR 0x8000C432

// XEVENT_ARBITRATION_CONFIGURATION_ERROR_1, 50227, Error
#define XEVENT_ARBITRATION_CONFIGURATION_ERROR_1 0xC000C433

// XEVENT_ARBITRATION_CONFIGURATION_ERROR_2, 50228, Error
#define XEVENT_ARBITRATION_CONFIGURATION_ERROR_2 0xC000C434

// XEVENT_ARBITRATION_CONFIGURATION_ERROR_3, 50229, Error
#define XEVENT_ARBITRATION_CONFIGURATION_ERROR_3 0xC000C435

// XEVENT_ARBITRATION_CONFIGURATION_ERROR_4, 50230, Error
#define XEVENT_ARBITRATION_CONFIGURATION_ERROR_4 0xC000C436

// XEVENT_ARBITRATION_CONFIGURATION_ERROR_5, 50231, Error
#define XEVENT_ARBITRATION_CONFIGURATION_ERROR_5 0xC000C437

// XEVENT_ARBITRATION_CONFIGURATION_ERROR_6, 50232, Warning
#define XEVENT_ARBITRATION_CONFIGURATION_ERROR_6 0x8000C438

// XEVENT_ARBITRATION_CONFIGURATION_ERROR_7, 50233, Error
#define XEVENT_ARBITRATION_CONFIGURATION_ERROR_7 0xC000C439

// XEVENT_ARBITRATION_CONFIG_9, 50234, Warning
#define XEVENT_ARBITRATION_CONFIG_9 0x8000C43A

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT, 50275, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT 0x8000C463

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_1, 50276, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_1 0x8000C464

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_2, 50277, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_2 0x8000C465

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_3, 50278, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_3 0x8000C466

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_4, 50279, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_4 0x8000C467

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_5, 50280, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_5 0x8000C468

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_6, 50281, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_6 0x8000C469

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_7, 50282, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_7 0x8000C46A

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_8, 50283, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_8 0x8000C46B

// XEVENT_ARBITRATION_HACKER_ALERT, 50284, Warning
#define XEVENT_ARBITRATION_HACKER_ALERT 0x8000C46C

// XEVENT_ARBITRATION_HACKER_ALERT_1, 50285, Warning
#define XEVENT_ARBITRATION_HACKER_ALERT_1 0x8000C46D

// XEVENT_ARBITRATION_HACKER_ALERT_2, 50286, Warning
#define XEVENT_ARBITRATION_HACKER_ALERT_2 0x8000C46E

// XEVENT_ARBITRATION_HACKER_ALERT_3, 50287, Warning
#define XEVENT_ARBITRATION_HACKER_ALERT_3 0x8000C46F

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_9, 50288, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_9 0x8000C470

// XEVENT_ARBITRATION_HACKER_ALERT_4, 50289, Warning
#define XEVENT_ARBITRATION_HACKER_ALERT_4 0x8000C471

// XEVENT_ARBITRATION_HACKER_ALERT_5, 50290, Warning
#define XEVENT_ARBITRATION_HACKER_ALERT_5 0x8000C472

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_10, 50291, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_10 0x8000C473

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_11, 50292, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_11 0x8000C474

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_12, 50293, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_12 0x8000C475

// XEVENT_ARBITRATION_HACKER_ALERT_6, 50294, Warning
#define XEVENT_ARBITRATION_HACKER_ALERT_6 0x8000C476

// XEVENT_ARBITRATION_HACKER_ALERT_7, 50295, Warning
#define XEVENT_ARBITRATION_HACKER_ALERT_7 0x8000C477

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_13, 50296, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_13 0x8000C478

// XEVENT_ARBITRATION_HACKER_ALERT_8, 50297, Warning
#define XEVENT_ARBITRATION_HACKER_ALERT_8 0x8000C479

// XEVENT_ARBITRATION_HACKER_ALERT_9, 50298, Warning
#define XEVENT_ARBITRATION_HACKER_ALERT_9 0x8000C47A

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_14, 50299, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_14 0x8000C47B

// XEVENT_ARBITRATION_HACKER_ALERT_10, 50300, Warning
#define XEVENT_ARBITRATION_HACKER_ALERT_10 0x8000C47C

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_15, 50301, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_15 0x8000C47D

// XEVENT_ARBITRATION_HACKER_ALERT_11, 50302, Warning
#define XEVENT_ARBITRATION_HACKER_ALERT_11 0x8000C47E

// XEVENT_ARBITRATION_HACKER_ALERT_12, 50303, Warning
#define XEVENT_ARBITRATION_HACKER_ALERT_12 0x8000C47F

// XEVENT_ARBITRATION_HACKER_ALERT_13, 50304, Warning
#define XEVENT_ARBITRATION_HACKER_ALERT_13 0x8000C480

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_16, 50305, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_16 0x8000C481

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_17, 50306, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_17 0x8000C482

// XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_18, 50307, Warning
#define XEVENT_ARBITRATION_BAD_REQUEST_FROM_CLIENT_18 0x8000C483

// XEVENT_ARBITRATION_HACKER_ALERT_14, 50308, Warning
#define XEVENT_ARBITRATION_HACKER_ALERT_14 0x8000C484

// XEVENT_ARBITRATION_HACK_34, 50309, Warning
#define XEVENT_ARBITRATION_HACK_34 0x8000C485

// XEVENT_ARBITRATION_HACK_35, 50310, Warning
#define XEVENT_ARBITRATION_HACK_35 0x8000C486

// XEVENT_ARBITRATION_HACK_36, 50311, Warning
#define XEVENT_ARBITRATION_HACK_36 0x8000C487

// XEVENT_ARBITRATION_HACK_37, 50312, Warning
#define XEVENT_ARBITRATION_HACK_37 0x8000C488

// XEVENT_ARBITRATION_HACK_38, 50313, Warning
#define XEVENT_ARBITRATION_HACK_38 0x8000C489

// XEVENT_ARBITRATION_HACK_39, 50314, Warning
#define XEVENT_ARBITRATION_HACK_39 0x8000C48A

// XEVENT_ARBITRATION_HACK_40, 50315, Warning
#define XEVENT_ARBITRATION_HACK_40 0x8000C48B

// XEVENT_ARBITRATION_HACK_41, 50316, Warning
#define XEVENT_ARBITRATION_HACK_41 0x8000C48C

// XEVENT_ARBITRATION_HACK_42, 50317, Warning
#define XEVENT_ARBITRATION_HACK_42 0x8000C48D

// XEVENT_ARBITRATION_HACK_43, 50318, Warning
#define XEVENT_ARBITRATION_HACK_43 0x8000C48E

// XEVENT_ARBITRATION_HACK_44, 50319, Warning
#define XEVENT_ARBITRATION_HACK_44 0x8000C48F

// XEVENT_ARBITRATION_HACK_45, 50320, Warning
#define XEVENT_ARBITRATION_HACK_45 0x8000C490

// XEVENT_ARBITRATION_INFO_1, 50376, Info
#define XEVENT_ARBITRATION_INFO_1 0x4000C4C8

// XEVENT_ARBITRATION_INFO_2, 50377, Info
#define XEVENT_ARBITRATION_INFO_2 0x4000C4C9

// XEVENT_ARBITRATION_INFO_3, 50378, Info
#define XEVENT_ARBITRATION_INFO_3 0x4000C4CA

// XEVENT_ARBITRATION_TITLEBUG_0, 50400, Error
#define XEVENT_ARBITRATION_TITLEBUG_0 0xC000C4E0

// XEVENT_ARBITRATION_TITLEBUG_1, 50401, Error
#define XEVENT_ARBITRATION_TITLEBUG_1 0xC000C4E1

// XEVENT_ASKDC_KDCMANAGED_WSREADER_ERROR_1, 10000, Error
#define XEVENT_ASKDC_KDCMANAGED_WSREADER_ERROR_1 0xC0002710

// XEVENT_ASKDC_BAD_PARAMETER, 53225, Error
#define XEVENT_ASKDC_BAD_PARAMETER 0xC000CFE9

// XEVENT_ASKDC_BAD_PARAMETER_1, 53226, Error
#define XEVENT_ASKDC_BAD_PARAMETER_1 0xC000CFEA

// XEVENT_ASKDC_NO_MEMORY, 53227, Error
#define XEVENT_ASKDC_NO_MEMORY 0xC000CFEB

// XEVENT_ASKDC_NO_MEMORY_1, 53228, Error
#define XEVENT_ASKDC_NO_MEMORY_1 0xC000CFEC

// XEVENT_KDC_BASE_BAD_KERBCRYPT, 53229, Error
#define XEVENT_KDC_BASE_BAD_KERBCRYPT 0xC000CFED

// XEVENT_ASKDC_NO_MEMORY_2, 53230, Error
#define XEVENT_ASKDC_NO_MEMORY_2 0xC000CFEE

// XEVENT_ASKDC_NO_MEMORY_3, 53231, Error
#define XEVENT_ASKDC_NO_MEMORY_3 0xC000CFEF

// XEVENT_ASKDC_NO_MEMORY_4, 53232, Error
#define XEVENT_ASKDC_NO_MEMORY_4 0xC000CFF0

// XEVENT_DEPRACATED_ASKDC_NO_MEMORY_5, 53233, Error
#define XEVENT_DEPRACATED_ASKDC_NO_MEMORY_5 0xC000CFF1

// XEVENT_DEPRACATED_ASKDC_NO_MEMORY_6, 53234, Error
#define XEVENT_DEPRACATED_ASKDC_NO_MEMORY_6 0xC000CFF2

// XEVENT_KDC_CODE_10, 53235, Error
#define XEVENT_KDC_CODE_10 0xC000CFF3

// XEVENT_ASKDC_WSREADER_ERROR, 53236, Error
#define XEVENT_ASKDC_WSREADER_ERROR 0xC000CFF4

// XEVENT_ASKDC_NO_MEMORY_7, 53237, Error
#define XEVENT_ASKDC_NO_MEMORY_7 0xC000CFF5

// XEVENT_ASKDC_WSREADER_ERROR_1, 53238, Error
#define XEVENT_ASKDC_WSREADER_ERROR_1 0xC000CFF6

// XEVENT_ASKDC_NO_MEMORY_8, 53239, Error
#define XEVENT_ASKDC_NO_MEMORY_8 0xC000CFF7

// XEVENT_ASKDC_WSREADER_ERROR_2, 53240, Error
#define XEVENT_ASKDC_WSREADER_ERROR_2 0xC000CFF8

// XEVENT_ASKDC_WSREADER_ERROR_3, 53241, Error
#define XEVENT_ASKDC_WSREADER_ERROR_3 0xC000CFF9

// XEVENT_ASKDC_WSREADER_ERROR_4, 53242, Error
#define XEVENT_ASKDC_WSREADER_ERROR_4 0xC000CFFA

// XEVENT_ASKDC_WSREADER_ERROR_5, 53243, Error
#define XEVENT_ASKDC_WSREADER_ERROR_5 0xC000CFFB

// XEVENT_ASKDC_WSREADER_ERROR_6, 53244, Error
#define XEVENT_ASKDC_WSREADER_ERROR_6 0xC000CFFC

// XEVENT_ASKDC_WSREADER_ERROR_7, 53245, Error
#define XEVENT_ASKDC_WSREADER_ERROR_7 0xC000CFFD

// XEVENT_ASKDC_NO_MEMORY_9, 53246, Error
#define XEVENT_ASKDC_NO_MEMORY_9 0xC000CFFE

// XEVENT_KDC_CODE_22, 53247, Error
#define XEVENT_KDC_CODE_22 0xC000CFFF

// XEVENT_ASKDC_WSREADER_ERROR_8, 53248, Error
#define XEVENT_ASKDC_WSREADER_ERROR_8 0xC000D000

// XEVENT_ASKDC_NO_MEMORY_10, 53249, Error
#define XEVENT_ASKDC_NO_MEMORY_10 0xC000D001

// XEVENT_ASKDC_WSREADER_ERROR_9, 53250, Error
#define XEVENT_ASKDC_WSREADER_ERROR_9 0xC000D002

// XEVENT_ASKDC_NO_MEMORY_11, 53251, Error
#define XEVENT_ASKDC_NO_MEMORY_11 0xC000D003

// XEVENT_ASKDC_WSREADER_ERROR_10, 53252, Error
#define XEVENT_ASKDC_WSREADER_ERROR_10 0xC000D004

// XEVENT_KDC_CODE_28, 53253, Error
#define XEVENT_KDC_CODE_28 0xC000D005

// XEVENT_ASKDC_WSREADER_ERROR_11, 53254, Error
#define XEVENT_ASKDC_WSREADER_ERROR_11 0xC000D006

// XEVENT_ASKDC_WSREADER_ERROR_12, 53255, Error
#define XEVENT_ASKDC_WSREADER_ERROR_12 0xC000D007

// XEVENT_ASKDC_WSREADER_ERROR_13, 53256, Error
#define XEVENT_ASKDC_WSREADER_ERROR_13 0xC000D008

// XEVENT_ASKDC_NO_MEMORY_12, 53257, Error
#define XEVENT_ASKDC_NO_MEMORY_12 0xC000D009

// XEVENT_ASKDC_NO_MEMORY_13, 53258, Error
#define XEVENT_ASKDC_NO_MEMORY_13 0xC000D00A

// XEVENT_DEPRACATED_ASKDC_NO_MEMORY_14, 53259, Error
#define XEVENT_DEPRACATED_ASKDC_NO_MEMORY_14 0xC000D00B

// XEVENT_ASKDC_NO_MEMORY_15, 53260, Error
#define XEVENT_ASKDC_NO_MEMORY_15 0xC000D00C

// XEVENT_ASKDC_NO_MEMORY_16, 53261, Error
#define XEVENT_ASKDC_NO_MEMORY_16 0xC000D00D

// XEVENT_ASKDC_WSREADER_ERROR_14, 53262, Error
#define XEVENT_ASKDC_WSREADER_ERROR_14 0xC000D00E

// XEVENT_KDC_CODE_38, 53263, Error
#define XEVENT_KDC_CODE_38 0xC000D00F

// XEVENT_ASKDC_WSREADER_ERROR_15, 53264, Error
#define XEVENT_ASKDC_WSREADER_ERROR_15 0xC000D010

// XEVENT_ASKDC_WSREADER_ERROR_16, 53265, Error
#define XEVENT_ASKDC_WSREADER_ERROR_16 0xC000D011

// XEVENT_ASKDC_WSREADER_ERROR_17, 53266, Error
#define XEVENT_ASKDC_WSREADER_ERROR_17 0xC000D012

// XEVENT_ASKDC_WSREADER_ERROR_18, 53267, Error
#define XEVENT_ASKDC_WSREADER_ERROR_18 0xC000D013

// XEVENT_KDC_CODE_43, 53268, Error
#define XEVENT_KDC_CODE_43 0xC000D014

// XEVENT_DEPRACATED_ASKDC_WSREADER_ERROR_19, 53269, Error
#define XEVENT_DEPRACATED_ASKDC_WSREADER_ERROR_19 0xC000D015

// XEVENT_DEPRACATED_ASKDC_BAD_PARAMETER_2, 53270, Error
#define XEVENT_DEPRACATED_ASKDC_BAD_PARAMETER_2 0xC000D016

// XEVENT_ASKDC_NO_MEMORY_17, 53271, Error
#define XEVENT_ASKDC_NO_MEMORY_17 0xC000D017

// XEVENT_DEPRACATED_ASKDC_BAD_PARAMETER_3, 53272, Error
#define XEVENT_DEPRACATED_ASKDC_BAD_PARAMETER_3 0xC000D018

// XEVENT_KDC_CODE_48, 53273, Error
#define XEVENT_KDC_CODE_48 0xC000D019

// XEVENT_KDC_CODE_49, 53274, Error
#define XEVENT_KDC_CODE_49 0xC000D01A

// XEVENT_DEPRACATED_KDC_CODE_50, 53275, Error
#define XEVENT_DEPRACATED_KDC_CODE_50 0xC000D01B

// XEVENT_DEPRACATED_KDC_CODE_51, 53276, Error
#define XEVENT_DEPRACATED_KDC_CODE_51 0xC000D01C

// XEVENT_KDC_CODE_52, 53277, Error
#define XEVENT_KDC_CODE_52 0xC000D01D

// XEVENT_KDC_CODE_53, 53278, Error
#define XEVENT_KDC_CODE_53 0xC000D01E

// XEVENT_KDC_CODE_54, 53279, Error
#define XEVENT_KDC_CODE_54 0xC000D01F

// XEVENT_ASKDC_WSREADER_ERROR_20, 53280, Error
#define XEVENT_ASKDC_WSREADER_ERROR_20 0xC000D020

// XEVENT_ASKDC_WSREADER_ERROR_21, 53281, Error
#define XEVENT_ASKDC_WSREADER_ERROR_21 0xC000D021

// XEVENT_ASKDC_WSREADER_ERROR_22, 53282, Error
#define XEVENT_ASKDC_WSREADER_ERROR_22 0xC000D022

// XEVENT_ASKDC_NO_MEMORY_18, 53283, Error
#define XEVENT_ASKDC_NO_MEMORY_18 0xC000D023

// XEVENT_ASKDC_NO_MEMORY_19, 53284, Error
#define XEVENT_ASKDC_NO_MEMORY_19 0xC000D024

// XEVENT_ASKDC_WSREADER_ERROR_23, 53285, Error
#define XEVENT_ASKDC_WSREADER_ERROR_23 0xC000D025

// XEVENT_ASKDC_WSREADER_ERROR_24, 53286, Error
#define XEVENT_ASKDC_WSREADER_ERROR_24 0xC000D026

// XEVENT_ASKDC_NO_MEMORY_20, 53287, Error
#define XEVENT_ASKDC_NO_MEMORY_20 0xC000D027

// XEVENT_ASKDC_WSREADER_ERROR_25, 53288, Error
#define XEVENT_ASKDC_WSREADER_ERROR_25 0xC000D028

// XEVENT_ASKDC_WSREADER_ERROR_26, 53289, Error
#define XEVENT_ASKDC_WSREADER_ERROR_26 0xC000D029

// XEVENT_ASKDC_WSREADER_ERROR_27, 53290, Error
#define XEVENT_ASKDC_WSREADER_ERROR_27 0xC000D02A

// XEVENT_ASKDC_WSREADER_ERROR_28, 53291, Error
#define XEVENT_ASKDC_WSREADER_ERROR_28 0xC000D02B

// XEVENT_ASKDC_WSREADER_ERROR_29, 53292, Error
#define XEVENT_ASKDC_WSREADER_ERROR_29 0xC000D02C

// XEVENT_ASKDC_NO_CRYPTOHELPER, 53293, Error
#define XEVENT_ASKDC_NO_CRYPTOHELPER 0xC000D02D

// XEVENT_ASKDC_WSREADER_ERROR_30, 53294, Error
#define XEVENT_ASKDC_WSREADER_ERROR_30 0xC000D02E

// XEVENT_ASKDC_NO_MEMORY_21, 53295, Error
#define XEVENT_ASKDC_NO_MEMORY_21 0xC000D02F

// XEVENT_ASKDC_WSREADER_ERROR_31, 53296, Error
#define XEVENT_ASKDC_WSREADER_ERROR_31 0xC000D030

// XEVENT_ASKDC_NO_MEMORY_22, 53297, Error
#define XEVENT_ASKDC_NO_MEMORY_22 0xC000D031

// XEVENT_ASKDC_NO_MEMORY_23, 53298, Error
#define XEVENT_ASKDC_NO_MEMORY_23 0xC000D032

// XEVENT_ASKDC_NO_MEMORY_24, 53299, Error
#define XEVENT_ASKDC_NO_MEMORY_24 0xC000D033

// XEVENT_ASKDC_NO_MEMORY_25, 53300, Error
#define XEVENT_ASKDC_NO_MEMORY_25 0xC000D034

// XEVENT_ASKDC_NO_MEMORY_26, 53301, Error
#define XEVENT_ASKDC_NO_MEMORY_26 0xC000D035

// XEVENT_ASKDC_NO_MEMORY_27, 53302, Error
#define XEVENT_ASKDC_NO_MEMORY_27 0xC000D036

// XEVENT_ASKDC_NO_MEMORY_28, 53303, Error
#define XEVENT_ASKDC_NO_MEMORY_28 0xC000D037

// XEVENT_ASKDC_NO_MEMORY_29, 53304, Error
#define XEVENT_ASKDC_NO_MEMORY_29 0xC000D038

// XEVENT_ASKDC_CODE_MEMORY_ALLOCATION_ERROR, 53664, Error
#define XEVENT_ASKDC_CODE_MEMORY_ALLOCATION_ERROR 0xC000D1A0

// XEVENT_ASKDC_CODE_FAILED_TO_GET_CIPHERTEXT_SIZE, 53665, Error
#define XEVENT_ASKDC_CODE_FAILED_TO_GET_CIPHERTEXT_SIZE 0xC000D1A1

// XEVENT_ASKDC_CODE_MEMORY_ALLOCATION_ERROR_2, 53666, Error
#define XEVENT_ASKDC_CODE_MEMORY_ALLOCATION_ERROR_2 0xC000D1A2

// XEVENT_ASKDC_CODE_FAILED_TO_ENCRYPT_REPLY, 53667, Error
#define XEVENT_ASKDC_CODE_FAILED_TO_ENCRYPT_REPLY 0xC000D1A3

// XEVENT_ASKDC_CODE_FAILED_TO_PACK_REPLY, 53668, Error
#define XEVENT_ASKDC_CODE_FAILED_TO_PACK_REPLY 0xC000D1A4

// XEVENT_ASKDC_FAILED_TO_GET_USER_ID_FOR_PASSPORT_ID, 53669, Error
#define XEVENT_ASKDC_FAILED_TO_GET_USER_ID_FOR_PASSPORT_ID 0xC000D1A5

// XEVENT_ASKDC_FAILED_TO_GET_GAMERTAG_BY_USER_ID, 53672, Error
#define XEVENT_ASKDC_FAILED_TO_GET_GAMERTAG_BY_USER_ID 0xC000D1A8

// XEVENT_ASKDC_FAILED_TO_LOAD_ECHO_DATA_KEY, 53675, Error
#define XEVENT_ASKDC_FAILED_TO_LOAD_ECHO_DATA_KEY 0xC000D1AB

// XEVENT_ASKDC_BAD_PARAMETER_4, 53676, Error
#define XEVENT_ASKDC_BAD_PARAMETER_4 0xC000D1AC

// XEVENT_ASKDC_DOS_CACHE_TOO_SMALL, 54250, Error
#define XEVENT_ASKDC_DOS_CACHE_TOO_SMALL 0xC000D3EA

// XEVENT_ASKDC_DOS_CACHE_TOO_SMALL_1, 54251, Error
#define XEVENT_ASKDC_DOS_CACHE_TOO_SMALL_1 0xC000D3EB

// XEVENT_ASKDC_REGISTER_FAILURE, 54252, Error
#define XEVENT_ASKDC_REGISTER_FAILURE 0xC000D3EC

// XEVENT_ASKDC_REGISTER_FAILURE_1, 54253, Error
#define XEVENT_ASKDC_REGISTER_FAILURE_1 0xC000D3ED

// XEVENT_ASKDC_REGISTER_FAILURE_2, 54254, Error
#define XEVENT_ASKDC_REGISTER_FAILURE_2 0xC000D3EE

// XEVENT_ASKDC_REGISTER_FAILURE_3, 54255, Error
#define XEVENT_ASKDC_REGISTER_FAILURE_3 0xC000D3EF

// XEVENT_KDC_CONFIG_6, 54256, Error
#define XEVENT_KDC_CONFIG_6 0xC000D3F0

// XEVENT_ASKDC_INIT_FAILURE, 54257, Error
#define XEVENT_ASKDC_INIT_FAILURE 0xC000D3F1

// XEVENT_ASKDC_INIT_FAILURE_1, 54258, Error
#define XEVENT_ASKDC_INIT_FAILURE_1 0xC000D3F2

// XEVENT_ASKDC_INIT_FAILURE_2, 54259, Error
#define XEVENT_ASKDC_INIT_FAILURE_2 0xC000D3F3

// XEVENT_ASKDC_INIT_FAILURE_3, 54260, Error
#define XEVENT_ASKDC_INIT_FAILURE_3 0xC000D3F4

// XEVENT_ASKDC_INIT_FAILURE_4, 54261, Error
#define XEVENT_ASKDC_INIT_FAILURE_4 0xC000D3F5

// XEVENT_DEPRACATED_ASKDC_INIT_FAILURE_5, 54262, Error
#define XEVENT_DEPRACATED_ASKDC_INIT_FAILURE_5 0xC000D3F6

// XEVENT_ASKDC_INIT_WARNING, 54263, Warning
#define XEVENT_ASKDC_INIT_WARNING 0x8000D3F7

// XEVENT_ASKDC_INIT_WARNING_1, 54264, Warning
#define XEVENT_ASKDC_INIT_WARNING_1 0x8000D3F8

// XEVENT_ASKDC_INIT_WARNING_2, 54265, Warning
#define XEVENT_ASKDC_INIT_WARNING_2 0x8000D3F9

// XEVENT_ASKDC_INIT_WARNING_3, 54266, Warning
#define XEVENT_ASKDC_INIT_WARNING_3 0x8000D3FA

// XEVENT_ASKDC_DECRYPTION_FAILED, 54267, Error
#define XEVENT_ASKDC_DECRYPTION_FAILED 0xC000D3FB

// XEVENT_KDC_CONFIG_18, 54268, Warning
#define XEVENT_KDC_CONFIG_18 0x8000D3FC

// XEVENT_ASKDC_INVALID_PASSPORT_KEY_VERSION, 54269, Error
#define XEVENT_ASKDC_INVALID_PASSPORT_KEY_VERSION 0xC000D3FD

// XEVENT_DEPRACATED_KDC_CONFIG_20, 54270, Error
#define XEVENT_DEPRACATED_KDC_CONFIG_20 0xC000D3FE

// XEVENT_ASKDC_SET_PASSPORT_KEY_VERSION, 54271, Error
#define XEVENT_ASKDC_SET_PASSPORT_KEY_VERSION 0xC000D3FF

// XEVENT_KDC_CONFIG_22, 54272, Error
#define XEVENT_KDC_CONFIG_22 0xC000D400

// XEVENT_ASKDC_TOO_MANY_USER_KEY_VERSIONS, 54273, Error
#define XEVENT_ASKDC_TOO_MANY_USER_KEY_VERSIONS 0xC000D401

// XEVENT_KDC_CONFIG_24, 54274, Error
#define XEVENT_KDC_CONFIG_24 0xC000D402

// XEVENT_ASKDC_FAILED_TO_INITIALIZE_PASSPORT, 54368, Error
#define XEVENT_ASKDC_FAILED_TO_INITIALIZE_PASSPORT 0xC000D460

// XEVENT_ASKDC_INIT_FAILURE_6, 54372, Error
#define XEVENT_ASKDC_INIT_FAILURE_6 0xC000D464

// XEVENT_ASKDC_CRYPTO_FAILURE, 54373, Error
#define XEVENT_ASKDC_CRYPTO_FAILURE 0xC000D465

// XEVENT_ASKDC_DOS_REPLAY, 54650, Warning
#define XEVENT_ASKDC_DOS_REPLAY 0x8000D57A

// XEVENT_KDC_HACK_1, 54651, Warning
#define XEVENT_KDC_HACK_1 0x8000D57B

// XEVENT_KDC_HACK_2, 54652, Warning
#define XEVENT_KDC_HACK_2 0x8000D57C

// XEVENT_ASKDC_PPA_PADATA_MISSING, 54653, Warning
#define XEVENT_ASKDC_PPA_PADATA_MISSING 0x8000D57D

// XEVENT_ASKDC_BAD_CLIENT_NAME, 54654, Warning
#define XEVENT_ASKDC_BAD_CLIENT_NAME 0x8000D57E

// XEVENT_KDC_HACK_5, 54655, Warning
#define XEVENT_KDC_HACK_5 0x8000D57F

// XEVENT_ASKDC_HACK_INVALID_PRE_AUTH_TYPE, 54702, Warning
#define XEVENT_ASKDC_HACK_INVALID_PRE_AUTH_TYPE 0x8000D5AE

// XEVENT_ASKDC_HACK_MALFORMED_PRE_AUTH, 54703, Warning
#define XEVENT_ASKDC_HACK_MALFORMED_PRE_AUTH 0x8000D5AF

// XEVENT_ASKDC_HACK_FAILED_TO_CRACK_PASSPORT_TICKET, 54704, Warning
#define XEVENT_ASKDC_HACK_FAILED_TO_CRACK_PASSPORT_TICKET 0x8000D5B0

// XEVENT_ASKDC_HACK_INVALID_REQUEST, 54705, Warning
#define XEVENT_ASKDC_HACK_INVALID_REQUEST 0x8000D5B1

// XEVENT_ASKDC_HACK_DOS_ATTACK, 54707, Warning
#define XEVENT_ASKDC_HACK_DOS_ATTACK 0x8000D5B3

// XEVENT_ASKDC_HACK_MALFORMED_PRE_AUTH_1, 54715, Warning
#define XEVENT_ASKDC_HACK_MALFORMED_PRE_AUTH_1 0x8000D5BB

// XEVENT_ASKDC_UNKNOWN_SERVER_PRINCIPAL, 54716, Error
#define XEVENT_ASKDC_UNKNOWN_SERVER_PRINCIPAL 0xC000D5BC

// XEVENT_ASKDC_REGISTER_SUCCESS, 54750, Info
#define XEVENT_ASKDC_REGISTER_SUCCESS 0x4000D5DE

// XEVENT_ASKDC_REGISTER_SUCCESS_1, 54751, Info
#define XEVENT_ASKDC_REGISTER_SUCCESS_1 0x4000D5DF

// XEVENT_ASKDC_INIT_SUCCESS, 54752, Info
#define XEVENT_ASKDC_INIT_SUCCESS 0x4000D5E0

// XEVENT_ASKDC_TERM_SUCCESS, 54753, Info
#define XEVENT_ASKDC_TERM_SUCCESS 0x4000D5E1

// XEVENT_ASKDC_RELOAD_SUCCESS, 54754, Info
#define XEVENT_ASKDC_RELOAD_SUCCESS 0x4000D5E2

// XEVENT_DEPRACATED_ASKDC_PPA_LOADING_INFO, 54755, Info
#define XEVENT_DEPRACATED_ASKDC_PPA_LOADING_INFO 0x4000D5E3

// XEVENT_DEPRACATED_ASKDC_PPA_LOADING_INFO_1, 54756, Info
#define XEVENT_DEPRACATED_ASKDC_PPA_LOADING_INFO_1 0x4000D5E4

// XEVENT_KDC_INFO_7, 54757, Info
#define XEVENT_KDC_INFO_7 0x4000D5E5

// XEVENT_XCBK_NOTIFY_KEY_NOT_FOUND_IN_MESSAGE, 15000, Error
#define XEVENT_XCBK_NOTIFY_KEY_NOT_FOUND_IN_MESSAGE 0xC0003A98

// XEVENT_XCBK_NOTIFY_SETTING_NOT_FOUND, 15001, Error
#define XEVENT_XCBK_NOTIFY_SETTING_NOT_FOUND 0xC0003A99

// XEVENT_XCBK_NOTIFY_UNAUTHORIZED_REQUEST, 15002, Error
#define XEVENT_XCBK_NOTIFY_UNAUTHORIZED_REQUEST 0xC0003A9A

// XEVENT_XCBK_NOTIFY_UNKNOWN_ERROR, 15003, Error
#define XEVENT_XCBK_NOTIFY_UNKNOWN_ERROR 0xC0003A9B

// XEVENT_PASSPORT_DELETE_CREDENTIAL_ERROR, 15004, Error
#define XEVENT_PASSPORT_DELETE_CREDENTIAL_ERROR 0xC0003A9C

// XEVENT_PASSPORT_ENUM_CREDENTIALS_BY_NAME_ERROR, 15005, Error
#define XEVENT_PASSPORT_ENUM_CREDENTIALS_BY_NAME_ERROR 0xC0003A9D

// XEVENT_PASSPORT_FORCE_CREDENTIAL_RENAME_ERROR, 15006, Error
#define XEVENT_PASSPORT_FORCE_CREDENTIAL_RENAME_ERROR 0xC0003A9E

// XEVENT_USER_PURCHASE_NOT_ELIGIBLE_FOR_FREE_GAMERTAG_CHANGE, 15007, Error
#define XEVENT_USER_PURCHASE_NOT_ELIGIBLE_FOR_FREE_GAMERTAG_CHANGE 0xC0003A9F

// XEVENT_XCBK_NOTIFY_BILLING_NOTIFICATION_ADD_FAILURE, 15015, Error
#define XEVENT_XCBK_NOTIFY_BILLING_NOTIFICATION_ADD_FAILURE 0xC0003AA7

// XEVENT_XCBK_NOTIFY_SUBSCRIPTION_NOTIFICATION_ADD_FAILURE, 15016, Error
#define XEVENT_XCBK_NOTIFY_SUBSCRIPTION_NOTIFICATION_ADD_FAILURE 0xC0003AA8

// XEVENT_XCBK_NOTIFY_SUBSCRIPTION_NOTIFICATION_ACCOUNT_MISMATCH, 15017, Error
#define XEVENT_XCBK_NOTIFY_SUBSCRIPTION_NOTIFICATION_ACCOUNT_MISMATCH 0xC0003AA9

// XEVENT_CTP_TRANSACTIONSERVICE_UNKNOWN_ERROR, 15008, Error
#define XEVENT_CTP_TRANSACTIONSERVICE_UNKNOWN_ERROR 0xC0003AA0

// XEVENT_CTP_TRANSACTIONSERVICE_COMMUNICATION_ERROR, 15009, Error
#define XEVENT_CTP_TRANSACTIONSERVICE_COMMUNICATION_ERROR 0xC0003AA1

// XEVENT_CTP_NON_USER_EXCEPTION, 15010, Error
#define XEVENT_CTP_NON_USER_EXCEPTION 0xC0003AA2

// XEVENT_CTP_TRANSACTIONSERVICE_VALIDATION_PATH, 15011, Error
#define XEVENT_CTP_TRANSACTIONSERVICE_VALIDATION_PATH 0xC0003AA3

// XEVENT_CTP_TRANSACTIONSERVICE_INVALID_SUBSCRIPTION_RESPONSE, 15012, Warning
#define XEVENT_CTP_TRANSACTIONSERVICE_INVALID_SUBSCRIPTION_RESPONSE 0x80003AA4

// XEVENT_CTP_TRANSACTIONSERVICE_INVALIDARGS, 15013, Error
#define XEVENT_CTP_TRANSACTIONSERVICE_INVALIDARGS 0xC0003AA5

// XEVENT_PREVIEW_PRODUCT_PURCHASE_MEDIA_TYPE_MISMATCH, 15014, Error
#define XEVENT_PREVIEW_PRODUCT_PURCHASE_MEDIA_TYPE_MISMATCH 0xC0003AA6

// XEVENT_CTP_PARTNER_CONFIGURATION_ERROR, 15018, Error
#define XEVENT_CTP_PARTNER_CONFIGURATION_ERROR 0xC0003AAA

// XEVENT_CATALOG_MEDIACLASS_SETTING_MALFORMATTED, 49991, Error
#define XEVENT_CATALOG_MEDIACLASS_SETTING_MALFORMATTED 0xC000C347

// XEVENT_OFFER_REDUCED_PRICECHECK_MALFORMATTED, 49992, Error
#define XEVENT_OFFER_REDUCED_PRICECHECK_MALFORMATTED 0xC000C348

// XEVENT_VIDEOCATALOG_SETTINGS_MALFORMATTED, 49993, Error
#define XEVENT_VIDEOCATALOG_SETTINGS_MALFORMATTED 0xC000C349

// XEVENT_STORECATALOG_DEFAULT_SETTINGS_MISSING, 49994, Error
#define XEVENT_STORECATALOG_DEFAULT_SETTINGS_MISSING 0xC000C34A

// XEVENT_STORECATALOG_DEFAULT_SETTINGS_MALFORMATTED_1, 49995, Error
#define XEVENT_STORECATALOG_DEFAULT_SETTINGS_MALFORMATTED_1 0xC000C34B

// XEVENT_STORECATALOG_DEFAULT_SETTINGS_MALFORMATTED_2, 49996, Error
#define XEVENT_STORECATALOG_DEFAULT_SETTINGS_MALFORMATTED_2 0xC000C34C

// XEVENT_STOREMEDIATYPECATALOG_OVERRIDE_SETTINGS_MALFORMATTED_1, 49997, Error
#define XEVENT_STOREMEDIATYPECATALOG_OVERRIDE_SETTINGS_MALFORMATTED_1 0xC000C34D

// XEVENT_STOREMEDIATYPECATALOG_OVERRIDE_SETTINGS_MALFORMATTED_2, 49998, Error
#define XEVENT_STOREMEDIATYPECATALOG_OVERRIDE_SETTINGS_MALFORMATTED_2 0xC000C34E

// XEVENT_STOREMEDIATYPECATALOG_OVERRIDE_SETTINGS_MALFORMATTED_3, 49999, Error
#define XEVENT_STOREMEDIATYPECATALOG_OVERRIDE_SETTINGS_MALFORMATTED_3 0xC000C34F

// XEVENT_CERT_GRABBER_GET_CERT_FAILURE, 40000, Error
#define XEVENT_CERT_GRABBER_GET_CERT_FAILURE 0xC0009C40

// XEVENT_CERT_GRABBER_PARSE_CERT_FAILURE, 40001, Error
#define XEVENT_CERT_GRABBER_PARSE_CERT_FAILURE 0xC0009C41

// XEVENT_CERT_GRABBER_UPDATE_CERT_FAILURE, 40002, Error
#define XEVENT_CERT_GRABBER_UPDATE_CERT_FAILURE 0xC0009C42

// XEVENT_PLUGIN_CERTGRABBER_CERTIFICATE_UPDATED, 40003, Info
#define XEVENT_PLUGIN_CERTGRABBER_CERTIFICATE_UPDATED 0x40009C43

// XEVENT_OFFER_ID_LOOKUP_FAILURE, 40004, Error
#define XEVENT_OFFER_ID_LOOKUP_FAILURE 0xC0009C44

// XEVENT_REINSTATE_DELAYED_CANCEL_FAILURE, 40005, Error
#define XEVENT_REINSTATE_DELAYED_CANCEL_FAILURE 0xC0009C45

// XEVENT_XCBK_UNEXPECTED_REQUEST, 50426, Error
#define XEVENT_XCBK_UNEXPECTED_REQUEST 0xC000C4FA

// XEVENT_XCBK_UNKNOWN_ERROR, 50429, Error
#define XEVENT_XCBK_UNKNOWN_ERROR 0xC000C4FD

// XEVENT_XCBK_UNKNOWN_ERROR_1, 50431, Error
#define XEVENT_XCBK_UNKNOWN_ERROR_1 0xC000C4FF

// XEVENT_XCBK_UNEXPECTED_REQUEST_1, 50434, Error
#define XEVENT_XCBK_UNEXPECTED_REQUEST_1 0xC000C502

// XEVENT_XCBK_UNKNOWN_ERROR_2, 50435, Error
#define XEVENT_XCBK_UNKNOWN_ERROR_2 0xC000C503

// XEVENT_XCBK_UNKNOWN_ERROR_3, 50436, Error
#define XEVENT_XCBK_UNKNOWN_ERROR_3 0xC000C504

// XEVENT_XCBK_UNKNOWN_ERROR_4, 50437, Error
#define XEVENT_XCBK_UNKNOWN_ERROR_4 0xC000C505

// XEVENT_MC_BAD_PARAMETER_3, 50438, Error
#define XEVENT_MC_BAD_PARAMETER_3 0xC000C506

// XEVENT_MC_APPLICATION_ERROR_8, 50440, Error
#define XEVENT_MC_APPLICATION_ERROR_8 0xC000C508

// XEVENT_MC_SPS_UNRECOGNIZED_ERROR_1, 50442, Error
#define XEVENT_MC_SPS_UNRECOGNIZED_ERROR_1 0xC000C50A

// XEVENT_FAIL_FAST_EXIT, 50455, Info
#define XEVENT_FAIL_FAST_EXIT 0x4000C517

// XEVENT_FAIL_FAST_ENTER, 50456, Error
#define XEVENT_FAIL_FAST_ENTER 0xC000C518

// XEVENT_DEPRECATED_BILLING_CODE_49, 50474, Error
#define XEVENT_DEPRECATED_BILLING_CODE_49 0xC000C52A

// XEVENT_DEPRECATED_BILLING_CODE_50, 50475, Error
#define XEVENT_DEPRECATED_BILLING_CODE_50 0xC000C52B

// XEVENT_DEPRECATED_BILLING_CODE_65, 50490, Error
#define XEVENT_DEPRECATED_BILLING_CODE_65 0xC000C53A

// XEVENT_UNKOWN_OFFER_TYPE, 50493, Error
#define XEVENT_UNKOWN_OFFER_TYPE 0xC000C53D

// XEVENT_UNKOWN_PAYMENT_TYPE, 50494, Error
#define XEVENT_UNKOWN_PAYMENT_TYPE 0xC000C53E

// XEVENT_GEOFENCE_COMPONENT_RETURNED_NULL, 50495, Warning
#define XEVENT_GEOFENCE_COMPONENT_RETURNED_NULL 0x8000C53F

// XEVENT_GEOFENCE_COMPONENT_RETURNED_EXCEPTION, 50496, Error
#define XEVENT_GEOFENCE_COMPONENT_RETURNED_EXCEPTION 0xC000C540

// XEVENT_DEPRECATED_GET_MACHINE_PART_NUMBER_FAILED, 50497, Error
#define XEVENT_DEPRECATED_GET_MACHINE_PART_NUMBER_FAILED 0xC000C541

// XEVENT_DEPRECATED_TRANSFER_MACHINE_LICENSES_FAILED, 50498, Error
#define XEVENT_DEPRECATED_TRANSFER_MACHINE_LICENSES_FAILED 0xC000C542

// XEVENT_DEPRECATED_TRANSFER_MACHINE_LICENSES_ASSET_CHECK_FAILED, 50499, Error
#define XEVENT_DEPRECATED_TRANSFER_MACHINE_LICENSES_ASSET_CHECK_FAILED 0xC000C543

// XEVENT_GET_PUID_FROM_MEMBERNAME_ERROR, 50500, Error
#define XEVENT_GET_PUID_FROM_MEMBERNAME_ERROR 0xC000C544

// XEVENT_XCBK_UNKNOWN_SERVICE_COMPONENT, 50526, Error
#define XEVENT_XCBK_UNKNOWN_SERVICE_COMPONENT 0xC000C55E

// XEVENT_MC_SPS_TIMEOUT, 50527, Error
#define XEVENT_MC_SPS_TIMEOUT 0xC000C55F

// XEVENT_MUSICNET_ADD_SUBSCRIPTION_OFFER_FAILED, 50534, Error
#define XEVENT_MUSICNET_ADD_SUBSCRIPTION_OFFER_FAILED 0xC000C566

// XEVENT_BDK_BLOCKING_SCS_APIS_BAD_MULTISETTING, 50535, Error
#define XEVENT_BDK_BLOCKING_SCS_APIS_BAD_MULTISETTING 0xC000C567

// XEVENT_CATALOG_MUSIC_MNETID_INVALID, 50536, Error
#define XEVENT_CATALOG_MUSIC_MNETID_INVALID 0xC000C568

// XEVENT_CATALOG_QUERY_ERROR, 50537, Error
#define XEVENT_CATALOG_QUERY_ERROR 0xC000C569

// XEVENT_XCBK_DATABASE_UNAVAILABLE, 50550, Error
#define XEVENT_XCBK_DATABASE_UNAVAILABLE 0xC000C576

// XEVENT_XCBK_DATABASE_UNAVAILABLE_1, 50551, Error
#define XEVENT_XCBK_DATABASE_UNAVAILABLE_1 0xC000C577

// XEVENT_MC_SPS_OFFER_MISCONFIGURATION_3, 50553, Error
#define XEVENT_MC_SPS_OFFER_MISCONFIGURATION_3 0xC000C579

// XEVENT_MC_SPS_OFFER_MISCONFIGURATION_4, 50554, Error
#define XEVENT_MC_SPS_OFFER_MISCONFIGURATION_4 0xC000C57A

// XEVENT_MC_SPS_OFFER_MISCONFIGURATION_5, 50555, Error
#define XEVENT_MC_SPS_OFFER_MISCONFIGURATION_5 0xC000C57B

// XEVENT_MC_BILLING_PROVIDER_INIT_ERROR, 50556, Error
#define XEVENT_MC_BILLING_PROVIDER_INIT_ERROR 0xC000C57C

// XEVENT_UODB_ACCESS_ERROR, 50567, Error
#define XEVENT_UODB_ACCESS_ERROR 0xC000C587

// XEVENT_MC_SPS_IS_OFF, 50568, Warning
#define XEVENT_MC_SPS_IS_OFF 0x8000C588

// XEVENT_MC_BILLING_PROVIDER_INIT_ERROR_1, 50582, Error
#define XEVENT_MC_BILLING_PROVIDER_INIT_ERROR_1 0xC000C596

// XEVENT_XCBK_SUBSCRIPTION_EXPIRATION_MESSAGE_FAILED, 50583, Error
#define XEVENT_XCBK_SUBSCRIPTION_EXPIRATION_MESSAGE_FAILED 0xC000C597

// XEVENT_DEPRECATED_BILLING_OFFERING_GEOAPI_INIT_FAILED, 50588, Error
#define XEVENT_DEPRECATED_BILLING_OFFERING_GEOAPI_INIT_FAILED 0xC000C59C

// XEVENT_XUACS_GRADUATE_USER_UPDATE_ERROR, 50679, Error
#define XEVENT_XUACS_GRADUATE_USER_UPDATE_ERROR 0xC000C5F7

// XEVENT_XUACS_GRADUATE_USER_QUEUE_ERROR, 50680, Error
#define XEVENT_XUACS_GRADUATE_USER_QUEUE_ERROR 0xC000C5F8

// XEVENT_XUACS_GRADUATE_USER_QUEUE_TIMER_ERROR, 50681, Error
#define XEVENT_XUACS_GRADUATE_USER_QUEUE_TIMER_ERROR 0xC000C5F9

// XEVENT_XUACS_GRADUATE_USER_DEQUEUE_ERROR, 50682, Error
#define XEVENT_XUACS_GRADUATE_USER_DEQUEUE_ERROR 0xC000C5FA

// XEVENT_GRADUATE_USER_QUEUE_GET_PENDING_ERROR, 50687, Error
#define XEVENT_GRADUATE_USER_QUEUE_GET_PENDING_ERROR 0xC000C5FF

// XEVENT_MC_CANNOT_COMPLETE_PURCHASE_COMMIT, 50705, Info
#define XEVENT_MC_CANNOT_COMPLETE_PURCHASE_COMMIT 0x4000C611

// XEVENT_MC_SPS_UNRECOGNIZED_ERROR, 50825, Error
#define XEVENT_MC_SPS_UNRECOGNIZED_ERROR 0xC000C689

// XEVENT_COMMON_CODE_1, 50826, Error
#define XEVENT_COMMON_CODE_1 0xC000C68A

// XEVENT_COMMON_CODE_2, 50827, Error
#define XEVENT_COMMON_CODE_2 0xC000C68B

// XEVENT_MC_SPS_INVALID_SUBSCRIPTION_ID, 50828, Error
#define XEVENT_MC_SPS_INVALID_SUBSCRIPTION_ID 0xC000C68C

// XEVENT_MC_SPS_INELIGIBLE_FOR_OFFER, 50829, Error
#define XEVENT_MC_SPS_INELIGIBLE_FOR_OFFER 0xC000C68D

// XEVENT_MC_SPS_INELIGIBLE_FOR_OFFER_1, 50830, Error
#define XEVENT_MC_SPS_INELIGIBLE_FOR_OFFER_1 0xC000C68E

// XEVENT_MC_SPS_INVALID_PUID, 50831, Error
#define XEVENT_MC_SPS_INVALID_PUID 0xC000C68F

// XEVENT_COMMON_CODE_7, 50832, Error
#define XEVENT_COMMON_CODE_7 0xC000C690

// XEVENT_COMMON_CODE_8, 50833, Error
#define XEVENT_COMMON_CODE_8 0xC000C691

// XEVENT_COMMON_CODE_9, 50834, Error
#define XEVENT_COMMON_CODE_9 0xC000C692

// XEVENT_COMMON_CODE_10, 50835, Error
#define XEVENT_COMMON_CODE_10 0xC000C693

// XEVENT_COMMON_CODE_11, 50836, Error
#define XEVENT_COMMON_CODE_11 0xC000C694

// XEVENT_MC_SPS_TOO_MANY_SERVICE_COMPONENTS, 50837, Error
#define XEVENT_MC_SPS_TOO_MANY_SERVICE_COMPONENTS 0xC000C695

// XEVENT_COMMON_CODE_13, 50838, Error
#define XEVENT_COMMON_CODE_13 0xC000C696

// XEVENT_COMMON_CODE_14, 50839, Error
#define XEVENT_COMMON_CODE_14 0xC000C697

// XEVENT_COMMON_CODE_15, 50840, Error
#define XEVENT_COMMON_CODE_15 0xC000C698

// XEVENT_MC_CANNOT_RECORD_TRANSACTION, 50841, Error
#define XEVENT_MC_CANNOT_RECORD_TRANSACTION 0xC000C699

// XEVENT_MC_CANNOT_RECORD_TRANSACTION_1, 50842, Error
#define XEVENT_MC_CANNOT_RECORD_TRANSACTION_1 0xC000C69A

// XEVENT_MC_CANNOT_RECORD_TRANSACTION_2, 50843, Error
#define XEVENT_MC_CANNOT_RECORD_TRANSACTION_2 0xC000C69B

// XEVENT_MC_CANNOT_RECORD_TRANSACTION_3, 50844, Error
#define XEVENT_MC_CANNOT_RECORD_TRANSACTION_3 0xC000C69C

// XEVENT_COMMON_CODE_123, 50948, Error
#define XEVENT_COMMON_CODE_123 0xC000C704

// XEVENT_COMMON_CODE_124, 50949, Error
#define XEVENT_COMMON_CODE_124 0xC000C705

// XEVENT_COMMON_CODE_125, 50950, Error
#define XEVENT_COMMON_CODE_125 0xC000C706

// XEVENT_COMMON_CODE_126, 50951, Error
#define XEVENT_COMMON_CODE_126 0xC000C707

// XEVENT_COMMON_CODE_127, 50952, Error
#define XEVENT_COMMON_CODE_127 0xC000C708

// XEVENT_COMMON_CODE_128, 50953, Error
#define XEVENT_COMMON_CODE_128 0xC000C709

// XEVENT_COMMON_CODE_129, 50954, Error
#define XEVENT_COMMON_CODE_129 0xC000C70A

// XEVENT_COMMON_CODE_130, 50955, Error
#define XEVENT_COMMON_CODE_130 0xC000C70B

// XEVENT_COMMON_CODE_131, 50956, Error
#define XEVENT_COMMON_CODE_131 0xC000C70C

// XEVENT_COMMON_CODE_132, 50957, Error
#define XEVENT_COMMON_CODE_132 0xC000C70D

// XEVENT_COMMON_CODE_134, 50959, Error
#define XEVENT_COMMON_CODE_134 0xC000C70F

// XEVENT_COMMON_CODE_135, 50960, Error
#define XEVENT_COMMON_CODE_135 0xC000C710

// XEVENT_COMMON_CODE_136, 50961, Error
#define XEVENT_COMMON_CODE_136 0xC000C711

// XEVENT_COMMON_CODE_137, 50962, Error
#define XEVENT_COMMON_CODE_137 0xC000C712

// XEVENT_COMMON_CODE_138, 50963, Error
#define XEVENT_COMMON_CODE_138 0xC000C713

// XEVENT_COMMON_CODE_139, 50964, Error
#define XEVENT_COMMON_CODE_139 0xC000C714

// XEVENT_COMMON_CODE_140, 50965, Error
#define XEVENT_COMMON_CODE_140 0xC000C715

// XEVENT_COMMON_CODE_141, 50966, Error
#define XEVENT_COMMON_CODE_141 0xC000C716

// XEVENT_COMMON_CODE_142, 50967, Error
#define XEVENT_COMMON_CODE_142 0xC000C717

// XEVENT_COMMON_CODE_143, 50968, Error
#define XEVENT_COMMON_CODE_143 0xC000C718

// XEVENT_COMMON_CODE_144, 50969, Error
#define XEVENT_COMMON_CODE_144 0xC000C719

// XEVENT_COMMON_CODE_145, 50970, Error
#define XEVENT_COMMON_CODE_145 0xC000C71A

// XEVENT_COMMON_CODE_201, 51026, Error
#define XEVENT_COMMON_CODE_201 0xC000C752

// XEVENT_COMMON_CODE_202, 51027, Error
#define XEVENT_COMMON_CODE_202 0xC000C753

// XEVENT_COMMON_CODE_203, 51028, Error
#define XEVENT_COMMON_CODE_203 0xC000C754

// XEVENT_COMMON_CODE_204, 51029, Error
#define XEVENT_COMMON_CODE_204 0xC000C755

// XEVENT_COMMON_COMM_0, 51225, Error
#define XEVENT_COMMON_COMM_0 0xC000C819

// XEVENT_COMMON_COMM_1, 51226, Error
#define XEVENT_COMMON_COMM_1 0xC000C81A

// XEVENT_COMMON_COMM_2, 51227, Error
#define XEVENT_COMMON_COMM_2 0xC000C81B

// XEVENT_MC_SPS_PROVISIONING_FAILURE, 51228, Error
#define XEVENT_MC_SPS_PROVISIONING_FAILURE 0xC000C81C

// XEVENT_COMMON_COMM_4, 51229, Error
#define XEVENT_COMMON_COMM_4 0xC000C81D

// XEVENT_COMMON_COMM_5, 51230, Error
#define XEVENT_COMMON_COMM_5 0xC000C81E

// XEVENT_COMMON_CONFIG_0, 51325, Warning
#define XEVENT_COMMON_CONFIG_0 0x8000C87D

// XEVENT_COMMON_CONFIG_1, 51326, Error
#define XEVENT_COMMON_CONFIG_1 0xC000C87E

// XEVENT_COMMON_CONFIG_2, 51327, Error
#define XEVENT_COMMON_CONFIG_2 0xC000C87F

// XEVENT_COMMON_CONFIG_3, 51328, Error
#define XEVENT_COMMON_CONFIG_3 0xC000C880

// XEVENT_COMMON_CONFIG_4, 51329, Error
#define XEVENT_COMMON_CONFIG_4 0xC000C881

// XEVENT_COMMON_CONFIG_5, 51330, Error
#define XEVENT_COMMON_CONFIG_5 0xC000C882

// XEVENT_COMMON_CONFIG_6, 51331, Error
#define XEVENT_COMMON_CONFIG_6 0xC000C883

// XEVENT_MC_BAD_CONFIG_DATA, 51332, Error
#define XEVENT_MC_BAD_CONFIG_DATA 0xC000C884

// XEVENT_COMMON_CONFIG_8, 51333, Error
#define XEVENT_COMMON_CONFIG_8 0xC000C885

// XEVENT_COMMON_CONFIG_9, 51334, Error
#define XEVENT_COMMON_CONFIG_9 0xC000C886

// XEVENT_COMMON_CONFIG_10, 51335, Error
#define XEVENT_COMMON_CONFIG_10 0xC000C887

// XEVENT_COMMON_CONFIG_11, 51336, Error
#define XEVENT_COMMON_CONFIG_11 0xC000C888

// XEVENT_MC_BAD_CONFIG_DATA_1, 51337, Error
#define XEVENT_MC_BAD_CONFIG_DATA_1 0xC000C889

// XEVENT_MC_BAD_CONFIG_DATA_2, 51338, Error
#define XEVENT_MC_BAD_CONFIG_DATA_2 0xC000C88A

// XEVENT_COMMON_CONFIG_14, 51339, Error
#define XEVENT_COMMON_CONFIG_14 0xC000C88B

// XEVENT_COMMON_CONFIG_15, 51340, Error
#define XEVENT_COMMON_CONFIG_15 0xC000C88C

// XEVENT_MC_BAD_CONFIG_DATA_3, 51341, Error
#define XEVENT_MC_BAD_CONFIG_DATA_3 0xC000C88D

// XEVENT_COMMON_CONFIG_17, 51342, Error
#define XEVENT_COMMON_CONFIG_17 0xC000C88E

// XEVENT_COMMON_CONFIG_18, 51343, Error
#define XEVENT_COMMON_CONFIG_18 0xC000C88F

// XEVENT_MC_SPS_INVALID_OFFER_ID, 51344, Error
#define XEVENT_MC_SPS_INVALID_OFFER_ID 0xC000C890

// XEVENT_MC_SPS_INVALID_OFFER_ID_1, 51345, Error
#define XEVENT_MC_SPS_INVALID_OFFER_ID_1 0xC000C891

// XEVENT_MC_SPS_QUEUE_ERROR, 51346, Error
#define XEVENT_MC_SPS_QUEUE_ERROR 0xC000C892

// XEVENT_MC_SPS_QUEUE_ERROR_1, 51347, Error
#define XEVENT_MC_SPS_QUEUE_ERROR_1 0xC000C893

// XEVENT_MC_SPS_QUEUE_ERROR_2, 51348, Error
#define XEVENT_MC_SPS_QUEUE_ERROR_2 0xC000C894

// XEVENT_COMMON_CONFIG_24, 51349, Error
#define XEVENT_COMMON_CONFIG_24 0xC000C895

// XEVENT_COMMON_CONFIG_25, 51350, Warning
#define XEVENT_COMMON_CONFIG_25 0x8000C896

// XEVENT_COMMON_CONFIG_26, 51351, Error
#define XEVENT_COMMON_CONFIG_26 0xC000C897

// XEVENT_COMMON_CONFIG_27, 51352, Error
#define XEVENT_COMMON_CONFIG_27 0xC000C898

// XEVENT_COMMON_CONFIG_28, 51353, Error
#define XEVENT_COMMON_CONFIG_28 0xC000C899

// XEVENT_COMMON_CONFIG_30, 51355, Error
#define XEVENT_COMMON_CONFIG_30 0xC000C89B

// XEVENT_COMMON_CONFIG_31, 51356, Error
#define XEVENT_COMMON_CONFIG_31 0xC000C89C

// XEVENT_QUEUE_FAILURE_AUTO_FIX, 51357, Error
#define XEVENT_QUEUE_FAILURE_AUTO_FIX 0xC000C89D

// XEVENT_COMMON_CONFIG_33, 51358, Error
#define XEVENT_COMMON_CONFIG_33 0xC000C89E

// XEVENT_COMMON_CONFIG_34, 51359, Error
#define XEVENT_COMMON_CONFIG_34 0xC000C89F

// XEVENT_COMMON_CONFIG_35, 51360, Error
#define XEVENT_COMMON_CONFIG_35 0xC000C8A0

// XEVENT_COMMON_CONFIG_36, 51361, Error
#define XEVENT_COMMON_CONFIG_36 0xC000C8A1

// XEVENT_COMMON_CONFIG_37, 51362, Error
#define XEVENT_COMMON_CONFIG_37 0xC000C8A2

// XEVENT_COMMON_CONFIG_38, 51363, Error
#define XEVENT_COMMON_CONFIG_38 0xC000C8A3

// XEVENT_COMMON_CONFIG_39, 51364, Error
#define XEVENT_COMMON_CONFIG_39 0xC000C8A4

// XEVENT_COMMON_CONFIG_40, 51365, Error
#define XEVENT_COMMON_CONFIG_40 0xC000C8A5

// XEVENT_COMMON_CONFIG_41, 51366, Error
#define XEVENT_COMMON_CONFIG_41 0xC000C8A6

// XEVENT_COMMON_CONFIG_42, 51367, Error
#define XEVENT_COMMON_CONFIG_42 0xC000C8A7

// XEVENT_COMMON_CONFIG_43, 51368, Error
#define XEVENT_COMMON_CONFIG_43 0xC000C8A8

// XEVENT_COMMON_CONFIG_44, 51369, Error
#define XEVENT_COMMON_CONFIG_44 0xC000C8A9

// XEVENT_COMMON_CONFIG_45, 51370, Error
#define XEVENT_COMMON_CONFIG_45 0xC000C8AA

// XEVENT_COMMON_CONFIG_46, 51371, Error
#define XEVENT_COMMON_CONFIG_46 0xC000C8AB

// XEVENT_COMMON_CONFIG_47, 51372, Error
#define XEVENT_COMMON_CONFIG_47 0xC000C8AC

// XEVENT_COMMON_CONFIG_48, 51373, Error
#define XEVENT_COMMON_CONFIG_48 0xC000C8AD

// XEVENT_COMMON_CONFIG_49, 51374, Warning
#define XEVENT_COMMON_CONFIG_49 0x8000C8AE

// XEVENT_COMMON_CONFIG_50, 51375, Warning
#define XEVENT_COMMON_CONFIG_50 0x8000C8AF

// XEVENT_MC_SPS_OFFER_MISCONFIGURATION, 51376, Error
#define XEVENT_MC_SPS_OFFER_MISCONFIGURATION 0xC000C8B0

// XEVENT_COMMON_CONFIG_52, 51377, Error
#define XEVENT_COMMON_CONFIG_52 0xC000C8B1

// XEVENT_COMMON_CONFIG_53, 51378, Error
#define XEVENT_COMMON_CONFIG_53 0xC000C8B2

// XEVENT_COMMON_CONFIG_54, 51379, Error
#define XEVENT_COMMON_CONFIG_54 0xC000C8B3

// XEVENT_COMMON_CONFIG_55, 51380, Error
#define XEVENT_COMMON_CONFIG_55 0xC000C8B4

// XEVENT_COMMON_CONFIG_56, 51381, Error
#define XEVENT_COMMON_CONFIG_56 0xC000C8B5

// XEVENT_COMMON_CONFIG_57, 51382, Error
#define XEVENT_COMMON_CONFIG_57 0xC000C8B6

// XEVENT_COMMON_CONFIG_58, 51383, Error
#define XEVENT_COMMON_CONFIG_58 0xC000C8B7

// XEVENT_COMMON_CONFIG_59, 51384, Error
#define XEVENT_COMMON_CONFIG_59 0xC000C8B8

// XEVENT_COMMON_CONFIG_60, 51385, Error
#define XEVENT_COMMON_CONFIG_60 0xC000C8B9

// XEVENT_COMMON_CONFIG_61, 51386, Error
#define XEVENT_COMMON_CONFIG_61 0xC000C8BA

// XEVENT_COMMON_CONFIG_62, 51387, Error
#define XEVENT_COMMON_CONFIG_62 0xC000C8BB

// XEVENT_COMMON_CONFIG_63, 51388, Error
#define XEVENT_COMMON_CONFIG_63 0xC000C8BC

// XEVENT_MC_SPS_OFFER_MISCONFIGURATION_1, 51389, Error
#define XEVENT_MC_SPS_OFFER_MISCONFIGURATION_1 0xC000C8BD

// XEVENT_COMMON_CONFIG_65, 51390, Error
#define XEVENT_COMMON_CONFIG_65 0xC000C8BE

// XEVENT_COMMON_CONFIG_66, 51391, Warning
#define XEVENT_COMMON_CONFIG_66 0x8000C8BF

// XEVENT_COMMON_CONFIG_67, 51392, Warning
#define XEVENT_COMMON_CONFIG_67 0x8000C8C0

// XEVENT_COMMON_CONFIG_68, 51393, Error
#define XEVENT_COMMON_CONFIG_68 0xC000C8C1

// XEVENT_COMMON_CONFIG_267, 51592, Error
#define XEVENT_COMMON_CONFIG_267 0xC000C988

// XEVENT_MC_SPS_OFFER_MISCONFIGURATION_2, 51594, Error
#define XEVENT_MC_SPS_OFFER_MISCONFIGURATION_2 0xC000C98A

// XEVENT_MC_AMBIGUOUS_OFFER_CONFIGURATION, 51673, Error
#define XEVENT_MC_AMBIGUOUS_OFFER_CONFIGURATION 0xC000C9D9

// XEVENT_COMMON_HACK_0, 52325, Warning
#define XEVENT_COMMON_HACK_0 0x8000CC65

// XEVENT_COMMON_HACK_1, 52326, Warning
#define XEVENT_COMMON_HACK_1 0x8000CC66

// XEVENT_COMMON_HACK_2, 52327, Warning
#define XEVENT_COMMON_HACK_2 0x8000CC67

// XEVENT_COMMON_HACK_3, 52328, Warning
#define XEVENT_COMMON_HACK_3 0x8000CC68

// XEVENT_COMMON_INFO_0, 52525, Info
#define XEVENT_COMMON_INFO_0 0x4000CD2D

// XEVENT_COMMON_INFO_1, 52526, Info
#define XEVENT_COMMON_INFO_1 0x4000CD2E

// XEVENT_COMMON_INFO_2, 52527, Info
#define XEVENT_COMMON_INFO_2 0x4000CD2F

// XEVENT_COMMON_INFO_3, 52528, Info
#define XEVENT_COMMON_INFO_3 0x4000CD30

// XEVENT_BILLING_SWITCH_USER_PASSPORT_QUEUE_DEQUEUE_ERROR, 62805, Error
#define XEVENT_BILLING_SWITCH_USER_PASSPORT_QUEUE_DEQUEUE_ERROR 0xC000F555

// XEVENT_BILLING_SWITCH_USER_PASSPORT_QUEUE_IMPERSONATION_ERROR, 62806, Error
#define XEVENT_BILLING_SWITCH_USER_PASSPORT_QUEUE_IMPERSONATION_ERROR 0xC000F556

// XEVENT_BILLING_SWITCH_USER_PASSPORT_QUEUE_TIMER_RESET_ERROR, 62807, Error
#define XEVENT_BILLING_SWITCH_USER_PASSPORT_QUEUE_TIMER_RESET_ERROR 0xC000F557

// XEVENT_BILLING_QUEUE_GET_PENDING_ERROR, 62819, Error
#define XEVENT_BILLING_QUEUE_GET_PENDING_ERROR 0xC000F563

// XEVENT_SWITCH_USER_PASSPORT_QUEUE_GET_PENDING_ERROR, 62821, Error
#define XEVENT_SWITCH_USER_PASSPORT_QUEUE_GET_PENDING_ERROR 0xC000F565

// XEVENT_COMMON_BILLING_CODE_0, 62825, Error
#define XEVENT_COMMON_BILLING_CODE_0 0xC000F569

// XEVENT_COMMON_BILLING_CODE_1, 62826, Error
#define XEVENT_COMMON_BILLING_CODE_1 0xC000F56A

// XEVENT_COMMON_BILLING_CODE_2, 62827, Error
#define XEVENT_COMMON_BILLING_CODE_2 0xC000F56B

// XEVENT_COMMON_BILLING_CODE_3, 62828, Error
#define XEVENT_COMMON_BILLING_CODE_3 0xC000F56C

// XEVENT_COMMON_BILLING_CODE_4, 62829, Error
#define XEVENT_COMMON_BILLING_CODE_4 0xC000F56D

// XEVENT_COMMON_BILLING_CODE_5, 62830, Error
#define XEVENT_COMMON_BILLING_CODE_5 0xC000F56E

// XEVENT_COMMON_BILLING_CODE_6, 62831, Error
#define XEVENT_COMMON_BILLING_CODE_6 0xC000F56F

// XEVENT_COMMON_BILLING_CODE_7, 62832, Error
#define XEVENT_COMMON_BILLING_CODE_7 0xC000F570

// XEVENT_COMMON_BILLING_CODE_8, 62833, Error
#define XEVENT_COMMON_BILLING_CODE_8 0xC000F571

// XEVENT_COMMON_BILLING_CODE_9, 62834, Error
#define XEVENT_COMMON_BILLING_CODE_9 0xC000F572

// XEVENT_COMMON_BILLING_CODE_10, 62835, Error
#define XEVENT_COMMON_BILLING_CODE_10 0xC000F573

// XEVENT_COMMON_BILLING_CODE_11, 62836, Error
#define XEVENT_COMMON_BILLING_CODE_11 0xC000F574

// XEVENT_COMMON_BILLING_CODE_12, 62837, Error
#define XEVENT_COMMON_BILLING_CODE_12 0xC000F575

// XEVENT_COMMON_BILLING_CODE_13, 62838, Error
#define XEVENT_COMMON_BILLING_CODE_13 0xC000F576

// XEVENT_COMMON_BILLING_CODE_14, 62839, Error
#define XEVENT_COMMON_BILLING_CODE_14 0xC000F577

// XEVENT_COMMON_BILLING_CODE_15, 62840, Error
#define XEVENT_COMMON_BILLING_CODE_15 0xC000F578

// XEVENT_COMMON_BILLING_CODE_16, 62841, Error
#define XEVENT_COMMON_BILLING_CODE_16 0xC000F579

// XEVENT_COMMON_BILLING_CODE_17, 62842, Error
#define XEVENT_COMMON_BILLING_CODE_17 0xC000F57A

// XEVENT_COMMON_BILLING_CODE_18, 62843, Error
#define XEVENT_COMMON_BILLING_CODE_18 0xC000F57B

// XEVENT_COMMON_BILLING_CODE_19, 62844, Error
#define XEVENT_COMMON_BILLING_CODE_19 0xC000F57C

// XEVENT_COMMON_BILLING_CODE_20, 62845, Error
#define XEVENT_COMMON_BILLING_CODE_20 0xC000F57D

// XEVENT_COMMON_BILLING_CODE_21, 62846, Error
#define XEVENT_COMMON_BILLING_CODE_21 0xC000F57E

// XEVENT_COMMON_BILLING_CODE_22, 62847, Error
#define XEVENT_COMMON_BILLING_CODE_22 0xC000F57F

// XEVENT_COMMON_BILLING_CODE_23, 62848, Error
#define XEVENT_COMMON_BILLING_CODE_23 0xC000F580

// XEVENT_COMMON_BILLING_CODE_24, 62849, Error
#define XEVENT_COMMON_BILLING_CODE_24 0xC000F581

// XEVENT_COMMON_BILLING_CODE_25, 62850, Error
#define XEVENT_COMMON_BILLING_CODE_25 0xC000F582

// XEVENT_COMMON_BILLING_CODE_26, 62851, Error
#define XEVENT_COMMON_BILLING_CODE_26 0xC000F583

// XEVENT_COMMON_BILLING_CODE_27, 62852, Error
#define XEVENT_COMMON_BILLING_CODE_27 0xC000F584

// XEVENT_COMMON_BILLING_CODE_28, 62853, Error
#define XEVENT_COMMON_BILLING_CODE_28 0xC000F585

// XEVENT_COMMON_BILLING_CODE_29, 62854, Error
#define XEVENT_COMMON_BILLING_CODE_29 0xC000F586

// XEVENT_COMMON_BILLING_CODE_30, 62855, Error
#define XEVENT_COMMON_BILLING_CODE_30 0xC000F587

// XEVENT_COMMON_BILLING_CODE_31, 62856, Error
#define XEVENT_COMMON_BILLING_CODE_31 0xC000F588

// XEVENT_COMMON_BILLING_CODE_32, 62857, Error
#define XEVENT_COMMON_BILLING_CODE_32 0xC000F589

// XEVENT_COMMON_BILLING_CODE_33, 62858, Error
#define XEVENT_COMMON_BILLING_CODE_33 0xC000F58A

// XEVENT_COMMON_BILLING_CODE_34, 62859, Error
#define XEVENT_COMMON_BILLING_CODE_34 0xC000F58B

// XEVENT_COMMON_BILLING_CODE_35, 62860, Error
#define XEVENT_COMMON_BILLING_CODE_35 0xC000F58C

// XEVENT_COMMON_BILLING_CODE_36, 62861, Error
#define XEVENT_COMMON_BILLING_CODE_36 0xC000F58D

// XEVENT_COMMON_BILLING_CODE_37, 62862, Error
#define XEVENT_COMMON_BILLING_CODE_37 0xC000F58E

// XEVENT_COMMON_BILLING_CODE_38, 62863, Error
#define XEVENT_COMMON_BILLING_CODE_38 0xC000F58F

// XEVENT_COMMON_BILLING_CODE_39, 62864, Error
#define XEVENT_COMMON_BILLING_CODE_39 0xC000F590

// XEVENT_COMMON_BILLING_CODE_40, 62865, Error
#define XEVENT_COMMON_BILLING_CODE_40 0xC000F591

// XEVENT_COMMON_BILLING_CODE_41, 62866, Error
#define XEVENT_COMMON_BILLING_CODE_41 0xC000F592

// XEVENT_COMMON_BILLING_CODE_42, 62867, Error
#define XEVENT_COMMON_BILLING_CODE_42 0xC000F593

// XEVENT_COMMON_BILLING_CODE_43, 62868, Error
#define XEVENT_COMMON_BILLING_CODE_43 0xC000F594

// XEVENT_COMMON_BILLING_CODE_44, 62869, Error
#define XEVENT_COMMON_BILLING_CODE_44 0xC000F595

// XEVENT_COMMON_BILLING_CODE_45, 62870, Error
#define XEVENT_COMMON_BILLING_CODE_45 0xC000F596

// XEVENT_COMMON_BILLING_CODE_46, 62871, Error
#define XEVENT_COMMON_BILLING_CODE_46 0xC000F597

// XEVENT_COMMON_BILLING_CODE_47, 62872, Error
#define XEVENT_COMMON_BILLING_CODE_47 0xC000F598

// XEVENT_COMMON_BILLING_CODE_48, 62873, Error
#define XEVENT_COMMON_BILLING_CODE_48 0xC000F599

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_49, 62874, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_49 0xC000F59A

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_50, 62875, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_50 0xC000F59B

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_51, 62876, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_51 0xC000F59C

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_52, 62877, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_52 0xC000F59D

// XEVENT_COMMON_BILLING_CODE_53, 62878, Error
#define XEVENT_COMMON_BILLING_CODE_53 0xC000F59E

// XEVENT_COMMON_BILLING_CODE_54, 62879, Error
#define XEVENT_COMMON_BILLING_CODE_54 0xC000F59F

// XEVENT_COMMON_BILLING_CODE_55, 62880, Error
#define XEVENT_COMMON_BILLING_CODE_55 0xC000F5A0

// XEVENT_COMMON_BILLING_CODE_56, 62881, Error
#define XEVENT_COMMON_BILLING_CODE_56 0xC000F5A1

// XEVENT_COMMON_BILLING_CODE_57, 62882, Error
#define XEVENT_COMMON_BILLING_CODE_57 0xC000F5A2

// XEVENT_COMMON_BILLING_CODE_58, 62883, Error
#define XEVENT_COMMON_BILLING_CODE_58 0xC000F5A3

// XEVENT_COMMON_BILLING_CODE_59, 62884, Error
#define XEVENT_COMMON_BILLING_CODE_59 0xC000F5A4

// XEVENT_COMMON_BILLING_CODE_60, 62885, Error
#define XEVENT_COMMON_BILLING_CODE_60 0xC000F5A5

// XEVENT_COMMON_BILLING_CODE_61, 62886, Error
#define XEVENT_COMMON_BILLING_CODE_61 0xC000F5A6

// XEVENT_COMMON_BILLING_CODE_62, 62887, Error
#define XEVENT_COMMON_BILLING_CODE_62 0xC000F5A7

// XEVENT_COMMON_BILLING_CODE_63, 62888, Error
#define XEVENT_COMMON_BILLING_CODE_63 0xC000F5A8

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_64, 62889, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_64 0xC000F5A9

// XEVENT_COMMON_BILLING_CODE_65, 62890, Error
#define XEVENT_COMMON_BILLING_CODE_65 0xC000F5AA

// XEVENT_COMMON_BILLING_CODE_66, 62891, Error
#define XEVENT_COMMON_BILLING_CODE_66 0xC000F5AB

// XEVENT_COMMON_BILLING_CODE_67, 62892, Error
#define XEVENT_COMMON_BILLING_CODE_67 0xC000F5AC

// XEVENT_COMMON_BILLING_CODE_68, 62893, Error
#define XEVENT_COMMON_BILLING_CODE_68 0xC000F5AD

// XEVENT_COMMON_BILLING_CODE_69, 62894, Error
#define XEVENT_COMMON_BILLING_CODE_69 0xC000F5AE

// XEVENT_COMMON_BILLING_CODE_70, 62895, Error
#define XEVENT_COMMON_BILLING_CODE_70 0xC000F5AF

// XEVENT_COMMON_BILLING_CODE_71, 62896, Error
#define XEVENT_COMMON_BILLING_CODE_71 0xC000F5B0

// XEVENT_COMMON_BILLING_CODE_72, 62897, Error
#define XEVENT_COMMON_BILLING_CODE_72 0xC000F5B1

// XEVENT_COMMON_BILLING_CODE_73, 62898, Error
#define XEVENT_COMMON_BILLING_CODE_73 0xC000F5B2

// XEVENT_COMMON_BILLING_CODE_74, 62899, Error
#define XEVENT_COMMON_BILLING_CODE_74 0xC000F5B3

// XEVENT_COMMON_BILLING_CODE_75, 62900, Error
#define XEVENT_COMMON_BILLING_CODE_75 0xC000F5B4

// XEVENT_COMMON_BILLING_CODE_76, 62901, Error
#define XEVENT_COMMON_BILLING_CODE_76 0xC000F5B5

// XEVENT_COMMON_BILLING_CODE_77, 62902, Error
#define XEVENT_COMMON_BILLING_CODE_77 0xC000F5B6

// XEVENT_COMMON_BILLING_CODE_78, 62903, Error
#define XEVENT_COMMON_BILLING_CODE_78 0xC000F5B7

// XEVENT_COMMON_BILLING_CODE_79, 62904, Error
#define XEVENT_COMMON_BILLING_CODE_79 0xC000F5B8

// XEVENT_COMMON_BILLING_CODE_80, 62905, Error
#define XEVENT_COMMON_BILLING_CODE_80 0xC000F5B9

// XEVENT_COMMON_BILLING_CODE_81, 62906, Error
#define XEVENT_COMMON_BILLING_CODE_81 0xC000F5BA

// XEVENT_COMMON_BILLING_CODE_82, 62907, Error
#define XEVENT_COMMON_BILLING_CODE_82 0xC000F5BB

// XEVENT_COMMON_BILLING_CODE_83, 62908, Error
#define XEVENT_COMMON_BILLING_CODE_83 0xC000F5BC

// XEVENT_COMMON_BILLING_CODE_84, 62909, Error
#define XEVENT_COMMON_BILLING_CODE_84 0xC000F5BD

// XEVENT_COMMON_BILLING_CODE_85, 62910, Error
#define XEVENT_COMMON_BILLING_CODE_85 0xC000F5BE

// XEVENT_COMMON_BILLING_CODE_86, 62911, Error
#define XEVENT_COMMON_BILLING_CODE_86 0xC000F5BF

// XEVENT_COMMON_BILLING_CODE_87, 62912, Error
#define XEVENT_COMMON_BILLING_CODE_87 0xC000F5C0

// XEVENT_COMMON_BILLING_CODE_88, 62913, Error
#define XEVENT_COMMON_BILLING_CODE_88 0xC000F5C1

// XEVENT_COMMON_BILLING_CODE_89, 62914, Error
#define XEVENT_COMMON_BILLING_CODE_89 0xC000F5C2

// XEVENT_COMMON_BILLING_CODE_90, 62915, Error
#define XEVENT_COMMON_BILLING_CODE_90 0xC000F5C3

// XEVENT_COMMON_BILLING_CODE_91, 62916, Error
#define XEVENT_COMMON_BILLING_CODE_91 0xC000F5C4

// XEVENT_COMMON_BILLING_CODE_92, 62917, Error
#define XEVENT_COMMON_BILLING_CODE_92 0xC000F5C5

// XEVENT_COMMON_BILLING_CODE_93, 62918, Error
#define XEVENT_COMMON_BILLING_CODE_93 0xC000F5C6

// XEVENT_COMMON_BILLING_CODE_94, 62919, Error
#define XEVENT_COMMON_BILLING_CODE_94 0xC000F5C7

// XEVENT_COMMON_BILLING_CODE_95, 62920, Error
#define XEVENT_COMMON_BILLING_CODE_95 0xC000F5C8

// XEVENT_COMMON_BILLING_CODE_96, 62921, Error
#define XEVENT_COMMON_BILLING_CODE_96 0xC000F5C9

// XEVENT_COMMON_BILLING_CODE_97, 62922, Error
#define XEVENT_COMMON_BILLING_CODE_97 0xC000F5CA

// XEVENT_COMMON_BILLING_CODE_98, 62923, Error
#define XEVENT_COMMON_BILLING_CODE_98 0xC000F5CB

// XEVENT_COMMON_BILLING_CODE_99, 62924, Error
#define XEVENT_COMMON_BILLING_CODE_99 0xC000F5CC

// XEVENT_COMMON_BILLING_CODE_100, 62925, Error
#define XEVENT_COMMON_BILLING_CODE_100 0xC000F5CD

// XEVENT_COMMON_BILLING_CODE_101, 62926, Error
#define XEVENT_COMMON_BILLING_CODE_101 0xC000F5CE

// XEVENT_COMMON_BILLING_CODE_102, 62927, Error
#define XEVENT_COMMON_BILLING_CODE_102 0xC000F5CF

// XEVENT_COMMON_BILLING_CODE_103, 62928, Error
#define XEVENT_COMMON_BILLING_CODE_103 0xC000F5D0

// XEVENT_COMMON_BILLING_CODE_104, 62929, Error
#define XEVENT_COMMON_BILLING_CODE_104 0xC000F5D1

// XEVENT_COMMON_BILLING_CODE_105, 62930, Error
#define XEVENT_COMMON_BILLING_CODE_105 0xC000F5D2

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_106, 62931, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_106 0xC000F5D3

// XEVENT_COMMON_BILLING_CODE_107, 62932, Error
#define XEVENT_COMMON_BILLING_CODE_107 0xC000F5D4

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_108, 62933, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_108 0xC000F5D5

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_109, 62934, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_109 0xC000F5D6

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_110, 62935, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_110 0xC000F5D7

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_111, 62936, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_111 0xC000F5D8

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_112, 62937, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_112 0xC000F5D9

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_113, 62938, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_113 0xC000F5DA

// XEVENT_COMMON_BILLING_CODE_114, 62939, Error
#define XEVENT_COMMON_BILLING_CODE_114 0xC000F5DB

// XEVENT_COMMON_BILLING_CODE_115, 62940, Error
#define XEVENT_COMMON_BILLING_CODE_115 0xC000F5DC

// XEVENT_COMMON_BILLING_CODE_116, 62941, Error
#define XEVENT_COMMON_BILLING_CODE_116 0xC000F5DD

// XEVENT_COMMON_BILLING_CODE_117, 62942, Error
#define XEVENT_COMMON_BILLING_CODE_117 0xC000F5DE

// XEVENT_COMMON_BILLING_CODE_118, 62943, Error
#define XEVENT_COMMON_BILLING_CODE_118 0xC000F5DF

// XEVENT_COMMON_BILLING_CODE_119, 62944, Error
#define XEVENT_COMMON_BILLING_CODE_119 0xC000F5E0

// XEVENT_COMMON_BILLING_CODE_120, 62945, Error
#define XEVENT_COMMON_BILLING_CODE_120 0xC000F5E1

// XEVENT_COMMON_BILLING_CODE_121, 62946, Error
#define XEVENT_COMMON_BILLING_CODE_121 0xC000F5E2

// XEVENT_COMMON_BILLING_CODE_122, 62947, Error
#define XEVENT_COMMON_BILLING_CODE_122 0xC000F5E3

// XEVENT_COMMON_BILLING_CODE_123, 62948, Error
#define XEVENT_COMMON_BILLING_CODE_123 0xC000F5E4

// XEVENT_COMMON_BILLING_CODE_124, 62949, Error
#define XEVENT_COMMON_BILLING_CODE_124 0xC000F5E5

// XEVENT_COMMON_BILLING_CODE_125, 62950, Error
#define XEVENT_COMMON_BILLING_CODE_125 0xC000F5E6

// XEVENT_COMMON_BILLING_CODE_126, 62951, Error
#define XEVENT_COMMON_BILLING_CODE_126 0xC000F5E7

// XEVENT_COMMON_BILLING_CODE_127, 62952, Error
#define XEVENT_COMMON_BILLING_CODE_127 0xC000F5E8

// XEVENT_COMMON_BILLING_CODE_128, 62953, Error
#define XEVENT_COMMON_BILLING_CODE_128 0xC000F5E9

// XEVENT_COMMON_BILLING_CODE_129, 62954, Error
#define XEVENT_COMMON_BILLING_CODE_129 0xC000F5EA

// XEVENT_COMMON_BILLING_CODE_130, 62955, Error
#define XEVENT_COMMON_BILLING_CODE_130 0xC000F5EB

// XEVENT_COMMON_BILLING_CODE_131, 62956, Error
#define XEVENT_COMMON_BILLING_CODE_131 0xC000F5EC

// XEVENT_COMMON_BILLING_CODE_132, 62957, Error
#define XEVENT_COMMON_BILLING_CODE_132 0xC000F5ED

// XEVENT_COMMON_BILLING_CODE_133, 62958, Error
#define XEVENT_COMMON_BILLING_CODE_133 0xC000F5EE

// XEVENT_COMMON_BILLING_CODE_134, 62959, Error
#define XEVENT_COMMON_BILLING_CODE_134 0xC000F5EF

// XEVENT_COMMON_BILLING_CODE_135, 62960, Error
#define XEVENT_COMMON_BILLING_CODE_135 0xC000F5F0

// XEVENT_COMMON_BILLING_CODE_136, 62961, Error
#define XEVENT_COMMON_BILLING_CODE_136 0xC000F5F1

// XEVENT_COMMON_BILLING_CODE_137, 62962, Error
#define XEVENT_COMMON_BILLING_CODE_137 0xC000F5F2

// XEVENT_COMMON_BILLING_CODE_138, 62963, Error
#define XEVENT_COMMON_BILLING_CODE_138 0xC000F5F3

// XEVENT_COMMON_BILLING_CODE_139, 62964, Error
#define XEVENT_COMMON_BILLING_CODE_139 0xC000F5F4

// XEVENT_COMMON_BILLING_CODE_140, 62965, Error
#define XEVENT_COMMON_BILLING_CODE_140 0xC000F5F5

// XEVENT_COMMON_BILLING_CODE_141, 62966, Error
#define XEVENT_COMMON_BILLING_CODE_141 0xC000F5F6

// XEVENT_COMMON_BILLING_CODE_142, 62967, Error
#define XEVENT_COMMON_BILLING_CODE_142 0xC000F5F7

// XEVENT_COMMON_BILLING_CODE_143, 62968, Error
#define XEVENT_COMMON_BILLING_CODE_143 0xC000F5F8

// XEVENT_COMMON_BILLING_CODE_144, 62969, Error
#define XEVENT_COMMON_BILLING_CODE_144 0xC000F5F9

// XEVENT_COMMON_BILLING_CODE_145, 62970, Error
#define XEVENT_COMMON_BILLING_CODE_145 0xC000F5FA

// XEVENT_COMMON_BILLING_CODE_146, 62971, Error
#define XEVENT_COMMON_BILLING_CODE_146 0xC000F5FB

// XEVENT_COMMON_BILLING_CODE_147, 62972, Error
#define XEVENT_COMMON_BILLING_CODE_147 0xC000F5FC

// XEVENT_COMMON_BILLING_CODE_148, 62973, Error
#define XEVENT_COMMON_BILLING_CODE_148 0xC000F5FD

// XEVENT_COMMON_BILLING_CODE_149, 62974, Error
#define XEVENT_COMMON_BILLING_CODE_149 0xC000F5FE

// XEVENT_COMMON_BILLING_CODE_150, 62975, Error
#define XEVENT_COMMON_BILLING_CODE_150 0xC000F5FF

// XEVENT_COMMON_BILLING_CODE_151, 62976, Error
#define XEVENT_COMMON_BILLING_CODE_151 0xC000F600

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_152, 62977, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_152 0xC000F601

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_153, 62978, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_153 0xC000F602

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_154, 62979, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_154 0xC000F603

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_155, 62980, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_155 0xC000F604

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_156, 62981, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_156 0xC000F605

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_157, 62982, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_157 0xC000F606

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_158, 62983, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_158 0xC000F607

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_159, 62984, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_159 0xC000F608

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_160, 62985, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_160 0xC000F609

// XEVENT_COMMON_BILLING_CODE_161, 62986, Error
#define XEVENT_COMMON_BILLING_CODE_161 0xC000F60A

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_162, 62987, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_162 0xC000F60B

// XEVENT_COMMON_BILLING_CODE_163, 62988, Error
#define XEVENT_COMMON_BILLING_CODE_163 0xC000F60C

// XEVENT_COMMON_BILLING_CODE_164, 62989, Error
#define XEVENT_COMMON_BILLING_CODE_164 0xC000F60D

// XEVENT_COMMON_BILLING_CODE_165, 62990, Error
#define XEVENT_COMMON_BILLING_CODE_165 0xC000F60E

// XEVENT_COMMON_BILLING_CODE_166, 62991, Error
#define XEVENT_COMMON_BILLING_CODE_166 0xC000F60F

// XEVENT_COMMON_BILLING_CODE_167, 62992, Error
#define XEVENT_COMMON_BILLING_CODE_167 0xC000F610

// XEVENT_COMMON_BILLING_CODE_168, 62993, Error
#define XEVENT_COMMON_BILLING_CODE_168 0xC000F611

// XEVENT_COMMON_BILLING_CODE_169, 62994, Error
#define XEVENT_COMMON_BILLING_CODE_169 0xC000F612

// XEVENT_COMMON_BILLING_CODE_170, 62995, Error
#define XEVENT_COMMON_BILLING_CODE_170 0xC000F613

// XEVENT_COMMON_BILLING_CODE_171, 62996, Error
#define XEVENT_COMMON_BILLING_CODE_171 0xC000F614

// XEVENT_COMMON_BILLING_CODE_172, 62997, Error
#define XEVENT_COMMON_BILLING_CODE_172 0xC000F615

// XEVENT_COMMON_BILLING_CODE_173, 62998, Error
#define XEVENT_COMMON_BILLING_CODE_173 0xC000F616

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_174, 62999, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_174 0xC000F617

// XEVENT_COMMON_BILLING_CODE_175, 63000, Error
#define XEVENT_COMMON_BILLING_CODE_175 0xC000F618

// XEVENT_COMMON_BILLING_CODE_176, 63001, Error
#define XEVENT_COMMON_BILLING_CODE_176 0xC000F619

// XEVENT_COMMON_BILLING_CODE_177, 63002, Error
#define XEVENT_COMMON_BILLING_CODE_177 0xC000F61A

// XEVENT_COMMON_BILLING_CODE_178, 63003, Error
#define XEVENT_COMMON_BILLING_CODE_178 0xC000F61B

// XEVENT_COMMON_BILLING_CODE_179, 63004, Error
#define XEVENT_COMMON_BILLING_CODE_179 0xC000F61C

// XEVENT_COMMON_BILLING_CODE_180, 63005, Error
#define XEVENT_COMMON_BILLING_CODE_180 0xC000F61D

// XEVENT_COMMON_BILLING_CODE_181, 63006, Error
#define XEVENT_COMMON_BILLING_CODE_181 0xC000F61E

// XEVENT_COMMON_BILLING_CODE_182, 63007, Error
#define XEVENT_COMMON_BILLING_CODE_182 0xC000F61F

// XEVENT_COMMON_BILLING_CODE_183, 63008, Error
#define XEVENT_COMMON_BILLING_CODE_183 0xC000F620

// XEVENT_COMMON_BILLING_CODE_184, 63009, Error
#define XEVENT_COMMON_BILLING_CODE_184 0xC000F621

// XEVENT_COMMON_BILLING_CODE_185, 63010, Error
#define XEVENT_COMMON_BILLING_CODE_185 0xC000F622

// XEVENT_COMMON_BILLING_CODE_186, 63011, Error
#define XEVENT_COMMON_BILLING_CODE_186 0xC000F623

// XEVENT_COMMON_BILLING_CODE_187, 63012, Error
#define XEVENT_COMMON_BILLING_CODE_187 0xC000F624

// XEVENT_COMMON_BILLING_CODE_188, 63013, Error
#define XEVENT_COMMON_BILLING_CODE_188 0xC000F625

// XEVENT_COMMON_BILLING_CODE_189, 63014, Error
#define XEVENT_COMMON_BILLING_CODE_189 0xC000F626

// XEVENT_DMP_EXTERNAL_EXCEPTION, 63015, Error
#define XEVENT_DMP_EXTERNAL_EXCEPTION 0xC000F627

// XEVENT_COMMON_BILLING_CODE_191, 63016, Error
#define XEVENT_COMMON_BILLING_CODE_191 0xC000F628

// XEVENT_COMMON_BILLING_CODE_192, 63017, Error
#define XEVENT_COMMON_BILLING_CODE_192 0xC000F629

// XEVENT_COMMON_BILLING_CODE_193, 63018, Error
#define XEVENT_COMMON_BILLING_CODE_193 0xC000F62A

// XEVENT_COMMON_BILLING_CODE_194, 63019, Error
#define XEVENT_COMMON_BILLING_CODE_194 0xC000F62B

// XEVENT_COMMON_BILLING_CODE_195, 63020, Error
#define XEVENT_COMMON_BILLING_CODE_195 0xC000F62C

// XEVENT_COMMON_BILLING_CODE_196, 63021, Error
#define XEVENT_COMMON_BILLING_CODE_196 0xC000F62D

// XEVENT_PASSPORT_CREATE_ERROR, 63022, Error
#define XEVENT_PASSPORT_CREATE_ERROR 0xC000F62E

// XEVENT_COMMON_BILLING_CODE_198, 63023, Error
#define XEVENT_COMMON_BILLING_CODE_198 0xC000F62F

// XEVENT_PASSPORT_CHANGE_PASSWORD_ERROR, 63024, Error
#define XEVENT_PASSPORT_CHANGE_PASSWORD_ERROR 0xC000F630

// XEVENT_PASSPORT_LOGIN_ERROR, 63025, Error
#define XEVENT_PASSPORT_LOGIN_ERROR 0xC000F631

// XEVENT_PASSPORT_CREATE_PROFILE_ERROR, 63026, Error
#define XEVENT_PASSPORT_CREATE_PROFILE_ERROR 0xC000F632

// XEVENT_PASSPORT_UPDATE_PROFILE_ERROR, 63027, Error
#define XEVENT_PASSPORT_UPDATE_PROFILE_ERROR 0xC000F633

// XEVENT_COMMON_BILLING_CODE_203, 63028, Error
#define XEVENT_COMMON_BILLING_CODE_203 0xC000F634

// XEVENT_COMMON_BILLING_CODE_204, 63029, Error
#define XEVENT_COMMON_BILLING_CODE_204 0xC000F635

// XEVENT_COMMON_BILLING_CODE_205, 63030, Error
#define XEVENT_COMMON_BILLING_CODE_205 0xC000F636

// XEVENT_COMMON_BILLING_CODE_206, 63031, Error
#define XEVENT_COMMON_BILLING_CODE_206 0xC000F637

// XEVENT_COMMON_BILLING_CODE_207, 63032, Error
#define XEVENT_COMMON_BILLING_CODE_207 0xC000F638

// XEVENT_COMMON_BILLING_CODE_208, 63033, Error
#define XEVENT_COMMON_BILLING_CODE_208 0xC000F639

// XEVENT_COMMON_BILLING_CODE_209, 63034, Error
#define XEVENT_COMMON_BILLING_CODE_209 0xC000F63A

// XEVENT_COMMON_BILLING_CODE_210, 63035, Error
#define XEVENT_COMMON_BILLING_CODE_210 0xC000F63B

// XEVENT_COMMON_BILLING_CODE_211, 63036, Error
#define XEVENT_COMMON_BILLING_CODE_211 0xC000F63C

// XEVENT_COMMON_BILLING_CODE_212, 63037, Error
#define XEVENT_COMMON_BILLING_CODE_212 0xC000F63D

// XEVENT_COMMON_BILLING_CODE_213, 63038, Error
#define XEVENT_COMMON_BILLING_CODE_213 0xC000F63E

// XEVENT_COMMON_BILLING_CODE_214, 63039, Error
#define XEVENT_COMMON_BILLING_CODE_214 0xC000F63F

// XEVENT_COMMON_BILLING_CODE_215, 63040, Error
#define XEVENT_COMMON_BILLING_CODE_215 0xC000F640

// XEVENT_COMMON_BILLING_CODE_216, 63041, Error
#define XEVENT_COMMON_BILLING_CODE_216 0xC000F641

// XEVENT_COMMON_BILLING_CODE_217, 63042, Error
#define XEVENT_COMMON_BILLING_CODE_217 0xC000F642

// XEVENT_COMMON_BILLING_CODE_218, 63043, Error
#define XEVENT_COMMON_BILLING_CODE_218 0xC000F643

// XEVENT_COMMON_BILLING_CODE_219, 63044, Error
#define XEVENT_COMMON_BILLING_CODE_219 0xC000F644

// XEVENT_COMMON_BILLING_CODE_220, 63045, Error
#define XEVENT_COMMON_BILLING_CODE_220 0xC000F645

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_221, 63046, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_221 0xC000F646

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_222, 63047, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_222 0xC000F647

// XEVENT_DEPRECATED_COMMON_BILLING_CODE_223, 63048, Error
#define XEVENT_DEPRECATED_COMMON_BILLING_CODE_223 0xC000F648

// XEVENT_COMMON_BILLING_SCS_API_BLOCKED, 63049, Error
#define XEVENT_COMMON_BILLING_SCS_API_BLOCKED 0xC000F649

// XEVENT_COMMON_BILLING_CODE_224, 63050, Error
#define XEVENT_COMMON_BILLING_CODE_224 0xC000F64A

// XEVENT_COMMON_PASSPORT_API_BLOCKED, 63051, Error
#define XEVENT_COMMON_PASSPORT_API_BLOCKED 0xC000F64B

// XEVENT_COMMON_BILLING_QUEUED_ACCOUNT_NOT_FOUND, 63052, Error
#define XEVENT_COMMON_BILLING_QUEUED_ACCOUNT_NOT_FOUND 0xC000F64C

// XEVENT_COMMON_BILLING_NOT_CONNECTED_TO_BILLING, 63053, Error
#define XEVENT_COMMON_BILLING_NOT_CONNECTED_TO_BILLING 0xC000F64D

// XEVENT_COMMON_FSE_NO_BOOKMARK_SETTING, 63054, Error
#define XEVENT_COMMON_FSE_NO_BOOKMARK_SETTING 0xC000F64E

// XEVENT_COMMON_FSE_INVALID_BOOKMARK_SETTING, 63055, Error
#define XEVENT_COMMON_FSE_INVALID_BOOKMARK_SETTING 0xC000F64F

// XEVENT_COMMON_BILLING_TEST_SETTING_WARNING, 63056, Warning
#define XEVENT_COMMON_BILLING_TEST_SETTING_WARNING 0x8000F650

// XEVENT_COMMON_BILLING_TITLEID_FORMAT, 63057, Warning
#define XEVENT_COMMON_BILLING_TITLEID_FORMAT 0x8000F651

// XEVENT_COMMON_BILLING_ADDITIONAL_ACCOUNT_DATA_REQUIRED, 63058, Error
#define XEVENT_COMMON_BILLING_ADDITIONAL_ACCOUNT_DATA_REQUIRED 0xC000F652

// XEVENT_COMMON_BILLING_MOVE_SUBSCRIPTION_FAILED, 63059, Error
#define XEVENT_COMMON_BILLING_MOVE_SUBSCRIPTION_FAILED 0xC000F653

// XEVENT_COMMON_BILLING_CHANGE_SUBSCRIPTION_STATE_FAILED, 63060, Error
#define XEVENT_COMMON_BILLING_CHANGE_SUBSCRIPTION_STATE_FAILED 0xC000F654

// XEVENT_COMMON_BILLING_CONTENT_TOKEN_OFFER_MISCONFIGURED, 63061, Error
#define XEVENT_COMMON_BILLING_CONTENT_TOKEN_OFFER_MISCONFIGURED 0xC000F655

// XEVENT_COMMON_FSE_CACHE_QUERY_ERROR, 63062, Error
#define XEVENT_COMMON_FSE_CACHE_QUERY_ERROR 0xC000F656

// XEVENT_COMMON_FSE_CACHE_INSERT_ERROR, 63063, Error
#define XEVENT_COMMON_FSE_CACHE_INSERT_ERROR 0xC000F657

// XEVENT_COMMON_FSE_CACHE_RESERVE_ERROR, 63064, Error
#define XEVENT_COMMON_FSE_CACHE_RESERVE_ERROR 0xC000F658

// XEVENT_COMMON_FSE_UNHANDLED_ERROR, 63065, Error
#define XEVENT_COMMON_FSE_UNHANDLED_ERROR 0xC000F659

// XEVENT_COMMON_BILLING_UPS_API_BLOCKED, 63066, Error
#define XEVENT_COMMON_BILLING_UPS_API_BLOCKED 0xC000F65A

// XEVENT_COMMON_FSE_CONFIGURATION_ERROR, 63067, Error
#define XEVENT_COMMON_FSE_CONFIGURATION_ERROR 0xC000F65B

// XEVENT_PASSPORT_INVALID_RESPONSE, 63068, Error
#define XEVENT_PASSPORT_INVALID_RESPONSE 0xC000F65C

// XEVENT_COMMON_UPS_ERROR, 63069, Error
#define XEVENT_COMMON_UPS_ERROR 0xC000F65D

// XEVENT_COMMON_UPS_GET_PROFILE_ERROR, 63070, Error
#define XEVENT_COMMON_UPS_GET_PROFILE_ERROR 0xC000F65E

// XEVENT_COMMON_UPS_UPDATE_PROFILE_ERROR, 63071, Error
#define XEVENT_COMMON_UPS_UPDATE_PROFILE_ERROR 0xC000F65F

// XEVENT_PASSPORT_GET_MEMBER_NAME_ERROR, 63072, Error
#define XEVENT_PASSPORT_GET_MEMBER_NAME_ERROR 0xC000F660

// XEVENT_PASSPORT_GET_MEMBER_NAME_AND_CID_ERROR, 63073, Error
#define XEVENT_PASSPORT_GET_MEMBER_NAME_AND_CID_ERROR 0xC000F661

// XEVENT_PASSPORT_GET_PUID_ERROR, 63074, Error
#define XEVENT_PASSPORT_GET_PUID_ERROR 0xC000F662

// XEVENT_PASSPORT_SET_NO_AGE_OUT_ERROR, 63075, Error
#define XEVENT_PASSPORT_SET_NO_AGE_OUT_ERROR 0xC000F663

// XEVENT_PASSPORT_GET_NO_AGE_OUT_ERROR, 63076, Error
#define XEVENT_PASSPORT_GET_NO_AGE_OUT_ERROR 0xC000F664

// XEVENT_PASSPORT_CREATE_PROFILE, 63077, Error
#define XEVENT_PASSPORT_CREATE_PROFILE 0xC000F665

// XEVENT_PASSPORT_UPDATE_PROFILE, 63078, Error
#define XEVENT_PASSPORT_UPDATE_PROFILE 0xC000F666

// XEVENT_CATALOG_WATCHER_EXTRACTOR_INVALID_MEDIAID_LCID, 20000, Error
#define XEVENT_CATALOG_WATCHER_EXTRACTOR_INVALID_MEDIAID_LCID 0xC0004E20

// XEVENT_CATALOG_WATCHER_WATCHER_TIME_OUT, 20001, Error
#define XEVENT_CATALOG_WATCHER_WATCHER_TIME_OUT 0xC0004E21

// XEVENT_CATALOG_WATCHER_PRODUCER_EXCEPTION, 20002, Error
#define XEVENT_CATALOG_WATCHER_PRODUCER_EXCEPTION 0xC0004E22

// XEVENT_CATALOG_WATCHER_WATCHER_EXCEPTION, 20003, Error
#define XEVENT_CATALOG_WATCHER_WATCHER_EXCEPTION 0xC0004E23

// XEVENT_CATALOG_WATCHER_PUBLISHER_EXCEPTION, 20004, Error
#define XEVENT_CATALOG_WATCHER_PUBLISHER_EXCEPTION 0xC0004E24

// XEVENT_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR, 20005, Error
#define XEVENT_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR 0xC0004E25

// XEVENT_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING, 20006, Warning
#define XEVENT_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING 0x80004E26

// XEVENT_CATALOG_WATCHER_ESPPUBLISHER_EXCEPTION, 20007, Warning
#define XEVENT_CATALOG_WATCHER_ESPPUBLISHER_EXCEPTION 0x80004E27

// XEVENT_CATALOG_WATCHER_MEDIA_EXTRACTOR_ERROR, 20008, Warning
#define XEVENT_CATALOG_WATCHER_MEDIA_EXTRACTOR_ERROR 0x80004E28

// XEVENT_CATALOG_WATCHER_MEDIA_PRODUCER_ERROR, 20009, Warning
#define XEVENT_CATALOG_WATCHER_MEDIA_PRODUCER_ERROR 0x80004E29

// XEVENT_CATALOG_WATCHER_MEDIA_DOCUMENT_TOO_LARGE, 20010, Error
#define XEVENT_CATALOG_WATCHER_MEDIA_DOCUMENT_TOO_LARGE 0xC0004E2A

// XEVENT_CATALOG_WATCHER_PROCESSOR_EXCEPTION, 20011, Error
#define XEVENT_CATALOG_WATCHER_PROCESSOR_EXCEPTION 0xC0004E2B

// XEVENT_CATALOG_WATCHER_VIDEO_PRODUCER_ERROR, 20012, Warning
#define XEVENT_CATALOG_WATCHER_VIDEO_PRODUCER_ERROR 0x80004E2C

// XEVENT_CATALOG_WATCHER_AZURESTORAGE_PUBLISHER_EXCEPTION, 20013, Warning
#define XEVENT_CATALOG_WATCHER_AZURESTORAGE_PUBLISHER_EXCEPTION 0x80004E2D

// XEVENT_CATALOG_WATCHER_SPEECH_PRODUCER_ERROR, 20014, Warning
#define XEVENT_CATALOG_WATCHER_SPEECH_PRODUCER_ERROR 0x80004E2E

// XEVENT_CLEANSER_ETX_WRITE_FAIL, 15000, Error
#define XEVENT_CLEANSER_ETX_WRITE_FAIL 0xC0003A98

// XEVENT_CLEANSER_ETX_ADD_FAIL, 15001, Error
#define XEVENT_CLEANSER_ETX_ADD_FAIL 0xC0003A99

// XEVENT_CLEANSER_BAD_PROTOCOL_FOR_DATA_REQ, 15002, Error
#define XEVENT_CLEANSER_BAD_PROTOCOL_FOR_DATA_REQ 0xC0003A9A

// XEVENT_CLEANSER_BAD_PROTOCOL_FOR_DISCONNECT_REQ, 15003, Error
#define XEVENT_CLEANSER_BAD_PROTOCOL_FOR_DISCONNECT_REQ 0xC0003A9B

// XEVENT_CLEANSER_MESSAGE_ENDOFSTREAM, 15004, Error
#define XEVENT_CLEANSER_MESSAGE_ENDOFSTREAM 0xC0003A9C

// XEVENT_CLEANSER_CODE_0, 50725, Error
#define XEVENT_CLEANSER_CODE_0 0xC000C625

// XEVENT_CLEANSER_CODE_1, 50726, Error
#define XEVENT_CLEANSER_CODE_1 0xC000C626

// XEVENT_CLEANSER_CODE_2, 50727, Error
#define XEVENT_CLEANSER_CODE_2 0xC000C627

// XEVENT_CLEANSER_CODE_3, 50728, Error
#define XEVENT_CLEANSER_CODE_3 0xC000C628

// XEVENT_CLEANSER_CODE_4, 50729, Error
#define XEVENT_CLEANSER_CODE_4 0xC000C629

// XEVENT_CLEANSER_CODE_5, 50730, Error
#define XEVENT_CLEANSER_CODE_5 0xC000C62A

// XEVENT_CLEANSER_COMM_0, 50750, Error
#define XEVENT_CLEANSER_COMM_0 0xC000C63E

// XEVENT_CLEANSER_COMM_1, 50751, Error
#define XEVENT_CLEANSER_COMM_1 0xC000C63F

// XEVENT_CLEANSER_COMM_2, 50752, Error
#define XEVENT_CLEANSER_COMM_2 0xC000C640

// XEVENT_CLEANSER_CONFIG_0, 50775, Error
#define XEVENT_CLEANSER_CONFIG_0 0xC000C657

// XEVENT_CLEANSER_CONFIG_1, 50776, Error
#define XEVENT_CLEANSER_CONFIG_1 0xC000C658

// XEVENT_CLEANSER_CONFIG_2, 50777, Error
#define XEVENT_CLEANSER_CONFIG_2 0xC000C659

// XEVENT_CLEANSER_CONFIG_3, 50778, Error
#define XEVENT_CLEANSER_CONFIG_3 0xC000C65A

// XEVENT_CLEANSER_INFO_0, 50800, Info
#define XEVENT_CLEANSER_INFO_0 0x4000C670

// XEVENT_CLEANSER_INFO_1, 50801, Info
#define XEVENT_CLEANSER_INFO_1 0x4000C671

// XEVENT_CLEANSER_INFO_2, 50802, Info
#define XEVENT_CLEANSER_INFO_2 0x4000C672

// XEVENT_CLEANSER_INFO_3, 50803, Info
#define XEVENT_CLEANSER_INFO_3 0x4000C673

// XEVENT_CLEANSER_INFO_4, 50804, Info
#define XEVENT_CLEANSER_INFO_4 0x4000C674

// XEVENT_SGINFO_CALL_SOURCE_INVALID, 40001, Error
#define XEVENT_SGINFO_CALL_SOURCE_INVALID 0xC0009C41

// XEVENT_SGINFO_VERIFY_PRIVILEGE, 40002, Error
#define XEVENT_SGINFO_VERIFY_PRIVILEGE 0xC0009C42

// XEVENT_XMGMT_FAILED_TO_REGISTER_ASSEMBLY, 40050, Warning
#define XEVENT_XMGMT_FAILED_TO_REGISTER_ASSEMBLY 0x80009C72

// XEVENT_HEALTH_REQUEST_FAILED, 40051, Error
#define XEVENT_HEALTH_REQUEST_FAILED 0xC0009C73

// XEVENT_HEALTH_INITIALIZE_INTEROP_FAILED, 40052, Error
#define XEVENT_HEALTH_INITIALIZE_INTEROP_FAILED 0xC0009C74

// XEVENT_HEALTH_REGISTERNATIVEHEALTHBLOCK_FAILED, 40053, Error
#define XEVENT_HEALTH_REGISTERNATIVEHEALTHBLOCK_FAILED 0xC0009C75

// XEVENT_HEALTH_LISTENER_CALLBACK_REQUEST_FAILED, 40054, Error
#define XEVENT_HEALTH_LISTENER_CALLBACK_REQUEST_FAILED 0xC0009C76

// XEVENT_HEALTH_LISTENER_CALLBACK_FAILED, 40055, Error
#define XEVENT_HEALTH_LISTENER_CALLBACK_FAILED 0xC0009C77

// XEVENT_MSNRR_EXTERNAL_EXCEPTION, 40056, Error
#define XEVENT_MSNRR_EXTERNAL_EXCEPTION 0xC0009C78

// XEVENT_SCS_NON_USER_EXCEPTION, 40057, Error
#define XEVENT_SCS_NON_USER_EXCEPTION 0xC0009C79

// XEVENT_FAST_FAIL_DUPLICATE_RESOURCE, 40058, Warning
#define XEVENT_FAST_FAIL_DUPLICATE_RESOURCE 0x80009C7A

// XEVENT_FAST_FAIL_ENABLED_DISABLED_TOGGLE, 40059, Info
#define XEVENT_FAST_FAIL_ENABLED_DISABLED_TOGGLE 0x40009C7B

// XEVENT_FAST_FAIL_BUCKET_COUNT_CHANGE, 40060, Info
#define XEVENT_FAST_FAIL_BUCKET_COUNT_CHANGE 0x40009C7C

// XEVENT_HEALTH_INITIALIZE_BLOCK_FAILED, 40061, Warning
#define XEVENT_HEALTH_INITIALIZE_BLOCK_FAILED 0x80009C7D

// XEVENT_SERVICE_KEY_LOAD_ERROR, 40062, Error
#define XEVENT_SERVICE_KEY_LOAD_ERROR 0xC0009C7E

// XEVENT_SERVICE_KEY_SAVE_ERROR, 40063, Error
#define XEVENT_SERVICE_KEY_SAVE_ERROR 0xC0009C7F

// XEVENT_SERVICE_KEY_NOT_FOUND, 40064, Error
#define XEVENT_SERVICE_KEY_NOT_FOUND 0xC0009C80

// XEVENT_GEOFENCE_TERRITORY_MAPPING_INVALID, 40065, Error
#define XEVENT_GEOFENCE_TERRITORY_MAPPING_INVALID 0xC0009C81

// XEVENT_GEOFENCE_TERRITORY_MAPPING_AMBIGUOUS, 40066, Error
#define XEVENT_GEOFENCE_TERRITORY_MAPPING_AMBIGUOUS 0xC0009C82

// XEVENT_GEOFENCE_TERRITORY_MAPPING_DUPLICATE, 40067, Info
#define XEVENT_GEOFENCE_TERRITORY_MAPPING_DUPLICATE 0x40009C83

// XEVENT_WIREDATA_DECRYPTION_ERROR, 40068, Warning
#define XEVENT_WIREDATA_DECRYPTION_ERROR 0x80009C84

// XEVENT_ACCELERATION_END_OF_STREAM, 40069, Warning
#define XEVENT_ACCELERATION_END_OF_STREAM 0x80009C85

// XEVENT_XBANC_END_OF_STREAM, 40070, Warning
#define XEVENT_XBANC_END_OF_STREAM 0x80009C86

// XEVENT_SERVICE_KEY_IMPORT_ERROR, 40071, Error
#define XEVENT_SERVICE_KEY_IMPORT_ERROR 0xC0009C87

// XEVENT_WIREDATA_DESERIALIZATION_ERROR, 40072, Warning
#define XEVENT_WIREDATA_DESERIALIZATION_ERROR 0x80009C88

// XEVENT_LSPLIB_DATABASE_ERROR, 40073, Error
#define XEVENT_LSPLIB_DATABASE_ERROR 0xC0009C89

// XEVENT_LOGTARGET_CREATE_ERROR, 40074, Error
#define XEVENT_LOGTARGET_CREATE_ERROR 0xC0009C8A

// XEVENT_SCS_QUEUE_FAILED_TO_UNCONSUME_TOKEN, 40075, Error
#define XEVENT_SCS_QUEUE_FAILED_TO_UNCONSUME_TOKEN 0xC0009C8B

// XEVENT_ACCOUNTS_HISTORY_GET_ERROR, 40076, Error
#define XEVENT_ACCOUNTS_HISTORY_GET_ERROR 0xC0009C8C

// XEVENT_ACCOUNTS_HISTORY_LOG_ERROR, 40077, Error
#define XEVENT_ACCOUNTS_HISTORY_LOG_ERROR 0xC0009C8D

// XEVENT_ACCOUNTS_GAMERTAG_HISTORY_LOG_ERROR, 40078, Error
#define XEVENT_ACCOUNTS_GAMERTAG_HISTORY_LOG_ERROR 0xC0009C8E

// XEVENT_ACCOUNTS_USER_GAMERTAG_THRESHOLD_EXCEEDED, 40079, Warning
#define XEVENT_ACCOUNTS_USER_GAMERTAG_THRESHOLD_EXCEEDED 0x80009C8F

// XEVENT_ACCOUNTS_MACHINE_GAMERTAG_THRESHOLD_EXCEEDED, 40080, Warning
#define XEVENT_ACCOUNTS_MACHINE_GAMERTAG_THRESHOLD_EXCEEDED 0x80009C90

// XEVENT_ACCOUNTS_PASSPORT_HISTORY_LOG_ERROR, 40081, Error
#define XEVENT_ACCOUNTS_PASSPORT_HISTORY_LOG_ERROR 0xC0009C91

// XEVENT_ACCOUNTS_USER_PASSPORT_THRESHOLD_EXCEEDED, 40082, Warning
#define XEVENT_ACCOUNTS_USER_PASSPORT_THRESHOLD_EXCEEDED 0x80009C92

// XEVENT_ACCOUNTS_MACHINE_PASSPORT_THRESHOLD_EXCEEDED, 40083, Warning
#define XEVENT_ACCOUNTS_MACHINE_PASSPORT_THRESHOLD_EXCEEDED 0x80009C93

// XEVENT_ACCOUNTS_RECOVERY_HISTORY_LOG_ERROR, 40084, Error
#define XEVENT_ACCOUNTS_RECOVERY_HISTORY_LOG_ERROR 0xC0009C94

// XEVENT_ACCOUNTS_USER_RECOVERY_THRESHOLD_EXCEEDED, 40085, Warning
#define XEVENT_ACCOUNTS_USER_RECOVERY_THRESHOLD_EXCEEDED 0x80009C95

// XEVENT_ACCOUNTS_MACHINE_RECOVERY_THRESHOLD_EXCEEDED, 40086, Warning
#define XEVENT_ACCOUNTS_MACHINE_RECOVERY_THRESHOLD_EXCEEDED 0x80009C96

// XEVENT_ACCOUNTS_HIJACKING_WARNING, 40087, Warning
#define XEVENT_ACCOUNTS_HIJACKING_WARNING 0x80009C97

// XEVENT_ACCOUNTS_HIJACKING_ERROR, 40088, Error
#define XEVENT_ACCOUNTS_HIJACKING_ERROR 0xC0009C98

// XEVENT_XCACHECONNECTION_NO_RECEIVETIMEOUT_SETTING, 40089, Error
#define XEVENT_XCACHECONNECTION_NO_RECEIVETIMEOUT_SETTING 0xC0009C99

// XEVENT_XCACHECONNECTION_NO_SENDTIMEOUT_SETTING, 40090, Error
#define XEVENT_XCACHECONNECTION_NO_SENDTIMEOUT_SETTING 0xC0009C9A

// XEVENT_AUTHDATA_NO_MORE_SERVICES_ERROR, 40091, Error
#define XEVENT_AUTHDATA_NO_MORE_SERVICES_ERROR 0xC0009C9B

// XEVENT_AAINFO_DATA_VERIFICATION_ERROR, 40092, Error
#define XEVENT_AAINFO_DATA_VERIFICATION_ERROR 0xC0009C9C

// XEVENT_AAINFO_DATA_VERIFICATION_WARNING, 40093, Warning
#define XEVENT_AAINFO_DATA_VERIFICATION_WARNING 0x80009C9D

// XEVENT_USER_FAMILY_DATA_MISSING, 40094, Error
#define XEVENT_USER_FAMILY_DATA_MISSING 0xC0009C9E

// XEVENT_COMMON_BILLING_CODE_CHANGE_STATE, 40095, Error
#define XEVENT_COMMON_BILLING_CODE_CHANGE_STATE 0xC0009C9F

// XEVENT_COMMON_BILLING_CODE_CHANGE_BILLING_STATE, 40096, Error
#define XEVENT_COMMON_BILLING_CODE_CHANGE_BILLING_STATE 0xC0009CA0

// XEVENT_ACCOUNTS_FAMILY_HISTORY_LOG_ERROR, 40097, Error
#define XEVENT_ACCOUNTS_FAMILY_HISTORY_LOG_ERROR 0xC0009CA1

// XEVENT_FINBUS_RECORD_TRANSACTION_INTENT_FAILURE, 40098, Error
#define XEVENT_FINBUS_RECORD_TRANSACTION_INTENT_FAILURE 0xC0009CA2

// XEVENT_FINBUS_RECORD_TRANSACTION_SUCESS_FAILURE, 40099, Error
#define XEVENT_FINBUS_RECORD_TRANSACTION_SUCESS_FAILURE 0xC0009CA3

// XEVENT_FINBUS_RECORD_TRANSACTION_RESULT_FAILURE, 40100, Error
#define XEVENT_FINBUS_RECORD_TRANSACTION_RESULT_FAILURE 0xC0009CA4

// XEVENT_FINBUS_RECORD_TRANSACTION_PREINTENT_FAILURE, 40101, Error
#define XEVENT_FINBUS_RECORD_TRANSACTION_PREINTENT_FAILURE 0xC0009CA5

// XEVENT_FINBUS_GET_RETRY_COUNT_FAILURE, 40102, Error
#define XEVENT_FINBUS_GET_RETRY_COUNT_FAILURE 0xC0009CA6

// XEVENT_FINBUS_GET_ITEM_FOR_RETRY_FAILURE, 40103, Error
#define XEVENT_FINBUS_GET_ITEM_FOR_RETRY_FAILURE 0xC0009CA7

// XEVENT_FINBUS_TOKEN_REDEMPTION_ITEM_RETRY_FAILURE, 40104, Error
#define XEVENT_FINBUS_TOKEN_REDEMPTION_ITEM_RETRY_FAILURE 0xC0009CA8

// XEVENT_FINBUS_PURCHASE_ORDER_ITEM_RETRY_FAILURE, 40105, Error
#define XEVENT_FINBUS_PURCHASE_ORDER_ITEM_RETRY_FAILURE 0xC0009CA9

// XEVENT_FINBUS_TRANSACTION_RESPONSE_IS_INVALID, 40106, Error
#define XEVENT_FINBUS_TRANSACTION_RESPONSE_IS_INVALID 0xC0009CAA

// XEVENT_FINBUS_MISSING_XNA_CREATOR_ID_ERROR, 40107, Error
#define XEVENT_FINBUS_MISSING_XNA_CREATOR_ID_ERROR 0xC0009CAB

// XEVENT_FINBUS_QUEUE_TIMER_RESET_ERROR, 40108, Error
#define XEVENT_FINBUS_QUEUE_TIMER_RESET_ERROR 0xC0009CAC

// XEVENT_FINBUS_QUEUE_IMPERSONATION_UNDO_ERROR, 40109, Error
#define XEVENT_FINBUS_QUEUE_IMPERSONATION_UNDO_ERROR 0xC0009CAD

// XEVENT_FINBUS_QUEUE_PUMP_ERROR, 40110, Error
#define XEVENT_FINBUS_QUEUE_PUMP_ERROR 0xC0009CAE

// XEVENT_FINBUS_QUEUE_GET_RETRYABLE_COUNT_ERROR, 40111, Error
#define XEVENT_FINBUS_QUEUE_GET_RETRYABLE_COUNT_ERROR 0xC0009CAF

// XEVENT_FINBUS_QUEUE_GET_ITEM_FOR_RETRY_ERROR, 40112, Error
#define XEVENT_FINBUS_QUEUE_GET_ITEM_FOR_RETRY_ERROR 0xC0009CB0

// XEVENT_FINBUS_QUEUE_RETRY_ITEM_ERROR, 40113, Error
#define XEVENT_FINBUS_QUEUE_RETRY_ITEM_ERROR 0xC0009CB1

// XEVENT_FINBUS_QUEUE_COMMUNICATION_ERROR, 40114, Error
#define XEVENT_FINBUS_QUEUE_COMMUNICATION_ERROR 0xC0009CB2

// XEVENT_MGMT_MISSING_REPORTING_COMPONENT_ID, 40115, Error
#define XEVENT_MGMT_MISSING_REPORTING_COMPONENT_ID 0xC0009CB3

// XEVENT_THREADPOOL_CONTEXT_EXCEPTION, 40116, Error
#define XEVENT_THREADPOOL_CONTEXT_EXCEPTION 0xC0009CB4

// XEVENT_THREADPOOL_THREAD_EXCEPTION, 40117, Error
#define XEVENT_THREADPOOL_THREAD_EXCEPTION 0xC0009CB5

// XEVENT_FINBUS_QUEUE_ITEM_FAILED, 40118, Warning
#define XEVENT_FINBUS_QUEUE_ITEM_FAILED 0x80009CB6

// XEVENT_ETX_EVENT_HEADER_VERSION_MISSING, 40119, Error
#define XEVENT_ETX_EVENT_HEADER_VERSION_MISSING 0xC0009CB7

// XEVENT_ACCOUNT_MOVE_SUBSCRIPTION_ERROR, 40120, Error
#define XEVENT_ACCOUNT_MOVE_SUBSCRIPTION_ERROR 0xC0009CB8

// XEVENT_SUBSCRIPTION_BAD_CREDITVALUE_ERROR, 40121, Error
#define XEVENT_SUBSCRIPTION_BAD_CREDITVALUE_ERROR 0xC0009CB9

// XEVENT_PASSPORT_GET_PROFILE_ERROR, 40122, Error
#define XEVENT_PASSPORT_GET_PROFILE_ERROR 0xC0009CBA

// XEVENT_TRACKED_API_CALL_DATABASE_ERROR, 40123, Error
#define XEVENT_TRACKED_API_CALL_DATABASE_ERROR 0xC0009CBB

// XEVENT_TRACKED_API_CALL_UCDB_DATABASE_ERROR, 40124, Error
#define XEVENT_TRACKED_API_CALL_UCDB_DATABASE_ERROR 0xC0009CBC

// XEVENT_COMMON_CODE_20, 50845, Error
#define XEVENT_COMMON_CODE_20 0xC000C69D

// XEVENT_CRYPTO_GENERAL_ERROR, 50846, Error
#define XEVENT_CRYPTO_GENERAL_ERROR 0xC000C69E

// XEVENT_COMMON_CODE_22, 50847, Error
#define XEVENT_COMMON_CODE_22 0xC000C69F

// XEVENT_COMMON_CODE_23, 50848, Error
#define XEVENT_COMMON_CODE_23 0xC000C6A0

// XEVENT_COMMON_CODE_24, 50849, Error
#define XEVENT_COMMON_CODE_24 0xC000C6A1

// XEVENT_MC_APPLICATION_ERROR, 50850, Error
#define XEVENT_MC_APPLICATION_ERROR 0xC000C6A2

// XEVENT_COMMON_CODE_26, 50851, Error
#define XEVENT_COMMON_CODE_26 0xC000C6A3

// XEVENT_COMMON_CODE_27, 50852, Error
#define XEVENT_COMMON_CODE_27 0xC000C6A4

// XEVENT_COMMON_CODE_28, 50853, Error
#define XEVENT_COMMON_CODE_28 0xC000C6A5

// XEVENT_COMMON_CODE_29, 50854, Error
#define XEVENT_COMMON_CODE_29 0xC000C6A6

// XEVENT_COMMON_CODE_30, 50855, Error
#define XEVENT_COMMON_CODE_30 0xC000C6A7

// XEVENT_COMMON_CODE_31, 50856, Error
#define XEVENT_COMMON_CODE_31 0xC000C6A8

// XEVENT_COMMON_CODE_32, 50857, Error
#define XEVENT_COMMON_CODE_32 0xC000C6A9

// XEVENT_COMMON_CODE_33, 50858, Error
#define XEVENT_COMMON_CODE_33 0xC000C6AA

// XEVENT_COMMON_CODE_34, 50859, Error
#define XEVENT_COMMON_CODE_34 0xC000C6AB

// XEVENT_COMMON_CODE_35, 50860, Error
#define XEVENT_COMMON_CODE_35 0xC000C6AC

// XEVENT_COMMON_CODE_36, 50861, Error
#define XEVENT_COMMON_CODE_36 0xC000C6AD

// XEVENT_COMMON_CODE_37, 50862, Error
#define XEVENT_COMMON_CODE_37 0xC000C6AE

// XEVENT_COMMON_CODE_38, 50863, Error
#define XEVENT_COMMON_CODE_38 0xC000C6AF

// XEVENT_MC_PLUGIN_ERROR, 50864, Error
#define XEVENT_MC_PLUGIN_ERROR 0xC000C6B0

// XEVENT_MC_PLUGIN_ERROR_1, 50865, Error
#define XEVENT_MC_PLUGIN_ERROR_1 0xC000C6B1

// XEVENT_COMMON_CODE_41, 50866, Error
#define XEVENT_COMMON_CODE_41 0xC000C6B2

// XEVENT_COMMON_CODE_42, 50867, Error
#define XEVENT_COMMON_CODE_42 0xC000C6B3

// XEVENT_COMMON_CODE_43, 50868, Error
#define XEVENT_COMMON_CODE_43 0xC000C6B4

// XEVENT_COMMON_CODE_46, 50871, Error
#define XEVENT_COMMON_CODE_46 0xC000C6B7

// XEVENT_COMMON_CODE_48, 50873, Error
#define XEVENT_COMMON_CODE_48 0xC000C6B9

// XEVENT_QUERY_BAD_PARAMETER, 50876, Error
#define XEVENT_QUERY_BAD_PARAMETER 0xC000C6BC

// XEVENT_QUERY_BAD_PARAMETER_1, 50877, Error
#define XEVENT_QUERY_BAD_PARAMETER_1 0xC000C6BD

// XEVENT_COMMON_CODE_53, 50878, Error
#define XEVENT_COMMON_CODE_53 0xC000C6BE

// XEVENT_COMMON_CODE_54, 50879, Error
#define XEVENT_COMMON_CODE_54 0xC000C6BF

// XEVENT_COMMON_CODE_55, 50880, Error
#define XEVENT_COMMON_CODE_55 0xC000C6C0

// XEVENT_COMMON_CODE_56, 50881, Error
#define XEVENT_COMMON_CODE_56 0xC000C6C1

// XEVENT_COMMON_CODE_57, 50882, Error
#define XEVENT_COMMON_CODE_57 0xC000C6C2

// XEVENT_COMMON_CODE_58, 50883, Error
#define XEVENT_COMMON_CODE_58 0xC000C6C3

// XEVENT_COMMON_CODE_59, 50884, Error
#define XEVENT_COMMON_CODE_59 0xC000C6C4

// XEVENT_MC_BAD_PARAMETER, 50885, Error
#define XEVENT_MC_BAD_PARAMETER 0xC000C6C5

// XEVENT_MC_BAD_PARAMETER_1, 50886, Error
#define XEVENT_MC_BAD_PARAMETER_1 0xC000C6C6

// XEVENT_MC_APPLICATION_ERROR_1, 50887, Error
#define XEVENT_MC_APPLICATION_ERROR_1 0xC000C6C7

// XEVENT_MC_APPLICATION_ERROR_2, 50888, Error
#define XEVENT_MC_APPLICATION_ERROR_2 0xC000C6C8

// XEVENT_MC_APPLICATION_ERROR_3, 50889, Error
#define XEVENT_MC_APPLICATION_ERROR_3 0xC000C6C9

// XEVENT_MC_BAD_PARAMETER_2, 50890, Error
#define XEVENT_MC_BAD_PARAMETER_2 0xC000C6CA

// XEVENT_COMMON_CODE_66, 50891, Error
#define XEVENT_COMMON_CODE_66 0xC000C6CB

// XEVENT_MC_BAD_CODE, 50892, Error
#define XEVENT_MC_BAD_CODE 0xC000C6CC

// XEVENT_MC_BAD_CODE_1, 50893, Error
#define XEVENT_MC_BAD_CODE_1 0xC000C6CD

// XEVENT_MC_BAD_CODE_2, 50894, Error
#define XEVENT_MC_BAD_CODE_2 0xC000C6CE

// XEVENT_MC_BAD_CODE_3, 50895, Error
#define XEVENT_MC_BAD_CODE_3 0xC000C6CF

// XEVENT_MC_BAD_CODE_4, 50896, Error
#define XEVENT_MC_BAD_CODE_4 0xC000C6D0

// XEVENT_MC_BAD_CODE_5, 50897, Error
#define XEVENT_MC_BAD_CODE_5 0xC000C6D1

// XEVENT_MC_BAD_CODE_6, 50898, Error
#define XEVENT_MC_BAD_CODE_6 0xC000C6D2

// XEVENT_COMMON_CODE_74, 50899, Error
#define XEVENT_COMMON_CODE_74 0xC000C6D3

// XEVENT_COMMON_CODE_75, 50900, Error
#define XEVENT_COMMON_CODE_75 0xC000C6D4

// XEVENT_COMMON_CODE_76, 50901, Error
#define XEVENT_COMMON_CODE_76 0xC000C6D5

// XEVENT_MC_BAD_CODE_7, 50902, Error
#define XEVENT_MC_BAD_CODE_7 0xC000C6D6

// XEVENT_MC_BAD_CODE_8, 50903, Error
#define XEVENT_MC_BAD_CODE_8 0xC000C6D7

// XEVENT_MC_BAD_CODE_9, 50904, Error
#define XEVENT_MC_BAD_CODE_9 0xC000C6D8

// XEVENT_MC_BAD_CODE_10, 50905, Error
#define XEVENT_MC_BAD_CODE_10 0xC000C6D9

// XEVENT_MC_BAD_CODE_11, 50906, Error
#define XEVENT_MC_BAD_CODE_11 0xC000C6DA

// XEVENT_MC_BAD_CODE_12, 50907, Error
#define XEVENT_MC_BAD_CODE_12 0xC000C6DB

// XEVENT_MC_BAD_CODE_13, 50908, Error
#define XEVENT_MC_BAD_CODE_13 0xC000C6DC

// XEVENT_MC_BAD_CODE_14, 50909, Error
#define XEVENT_MC_BAD_CODE_14 0xC000C6DD

// XEVENT_COMMON_CODE_85, 50910, Error
#define XEVENT_COMMON_CODE_85 0xC000C6DE

// XEVENT_COMMON_CODE_86, 50911, Error
#define XEVENT_COMMON_CODE_86 0xC000C6DF

// XEVENT_FORBIDDEN_NAMES_LOAD_FAILURE, 50912, Error
#define XEVENT_FORBIDDEN_NAMES_LOAD_FAILURE 0xC000C6E0

// XEVENT_MC_APPLICATION_ERROR_5, 50913, Error
#define XEVENT_MC_APPLICATION_ERROR_5 0xC000C6E1

// XEVENT_MC_APPLICATION_ERROR_6, 50914, Error
#define XEVENT_MC_APPLICATION_ERROR_6 0xC000C6E2

// XEVENT_MC_APPLICATION_ERROR_7, 50915, Error
#define XEVENT_MC_APPLICATION_ERROR_7 0xC000C6E3

// XEVENT_COMMON_CODE_91, 50916, Error
#define XEVENT_COMMON_CODE_91 0xC000C6E4

// XEVENT_COMMON_CODE_92, 50917, Error
#define XEVENT_COMMON_CODE_92 0xC000C6E5

// XEVENT_MGMT_GENERIC_ERROR, 50918, Error
#define XEVENT_MGMT_GENERIC_ERROR 0xC000C6E6

// XEVENT_MGMT_GENERIC_ERROR_1, 50919, Error
#define XEVENT_MGMT_GENERIC_ERROR_1 0xC000C6E7

// XEVENT_MGMT_GENERIC_ERROR_2, 50920, Error
#define XEVENT_MGMT_GENERIC_ERROR_2 0xC000C6E8

// XEVENT_MGMT_GENERIC_ERROR_3, 50921, Error
#define XEVENT_MGMT_GENERIC_ERROR_3 0xC000C6E9

// XEVENT_COMMON_CODE_97, 50922, Error
#define XEVENT_COMMON_CODE_97 0xC000C6EA

// XEVENT_MGMT_GENERIC_ERROR_4, 50923, Error
#define XEVENT_MGMT_GENERIC_ERROR_4 0xC000C6EB

// XEVENT_COMMON_CODE_99, 50924, Error
#define XEVENT_COMMON_CODE_99 0xC000C6EC

// XEVENT_COMMON_CODE_100, 50925, Error
#define XEVENT_COMMON_CODE_100 0xC000C6ED

// XEVENT_COMMON_CODE_101, 50926, Error
#define XEVENT_COMMON_CODE_101 0xC000C6EE

// XEVENT_COMMON_CODE_102, 50927, Error
#define XEVENT_COMMON_CODE_102 0xC000C6EF

// XEVENT_COMMON_CODE_103, 50928, Error
#define XEVENT_COMMON_CODE_103 0xC000C6F0

// XEVENT_COMMON_CODE_104, 50929, Error
#define XEVENT_COMMON_CODE_104 0xC000C6F1

// XEVENT_COMMON_CODE_105, 50930, Error
#define XEVENT_COMMON_CODE_105 0xC000C6F2

// XEVENT_COMMON_CODE_106, 50931, Error
#define XEVENT_COMMON_CODE_106 0xC000C6F3

// XEVENT_COMMON_CODE_107, 50932, Error
#define XEVENT_COMMON_CODE_107 0xC000C6F4

// XEVENT_COMMON_CODE_108, 50933, Error
#define XEVENT_COMMON_CODE_108 0xC000C6F5

// XEVENT_COMMON_CODE_109, 50934, Error
#define XEVENT_COMMON_CODE_109 0xC000C6F6

// XEVENT_HEALTH_GENERIC_ERROR_1, 50935, Error
#define XEVENT_HEALTH_GENERIC_ERROR_1 0xC000C6F7

// XEVENT_SQL_EXECUTE_READER, 50936, Error
#define XEVENT_SQL_EXECUTE_READER 0xC000C6F8

// XEVENT_SQL_EXECUTE_READER_BEHAVIOR, 50937, Error
#define XEVENT_SQL_EXECUTE_READER_BEHAVIOR 0xC000C6F9

// XEVENT_SQL_EXECUTE_NON_QUERY, 50938, Error
#define XEVENT_SQL_EXECUTE_NON_QUERY 0xC000C6FA

// XEVENT_SQL_EXECUTE_SCALAR, 50939, Error
#define XEVENT_SQL_EXECUTE_SCALAR 0xC000C6FB

// XEVENT_COUNTRY_LIST_MISSING, 50940, Error
#define XEVENT_COUNTRY_LIST_MISSING 0xC000C6FC

// XEVENT_COMMON_CODE_117, 50942, Error
#define XEVENT_COMMON_CODE_117 0xC000C6FE

// XEVENT_COMMON_CODE_118, 50943, Error
#define XEVENT_COMMON_CODE_118 0xC000C6FF

// XEVENT_DEPRECATED_COMMON_CODE_119, 50944, Error
#define XEVENT_DEPRECATED_COMMON_CODE_119 0xC000C700

// XEVENT_DEPRECATED_COMMON_CODE_120, 50945, Error
#define XEVENT_DEPRECATED_COMMON_CODE_120 0xC000C701

// XEVENT_COMMON_CODE_121, 50946, Error
#define XEVENT_COMMON_CODE_121 0xC000C702

// XEVENT_COMMON_CODE_122, 50947, Error
#define XEVENT_COMMON_CODE_122 0xC000C703

// XEVENT_CRYPTO_TOO_MANY_USER_KEYS, 50948, Warning
#define XEVENT_CRYPTO_TOO_MANY_USER_KEYS 0x8000C704

// XEVENT_CRYPTO_FAILED_GET_USER_KEYS, 50949, Error
#define XEVENT_CRYPTO_FAILED_GET_USER_KEYS 0xC000C705

// XEVENT_MUSICNET_EXTERNAL_EXCEPTION, 50958, Error
#define XEVENT_MUSICNET_EXTERNAL_EXCEPTION 0xC000C70E

// XEVENT_COMMON_CODE_146, 50971, Error
#define XEVENT_COMMON_CODE_146 0xC000C71B

// XEVENT_COMMON_CODE_147, 50972, Error
#define XEVENT_COMMON_CODE_147 0xC000C71C

// XEVENT_COMMON_CODE_148, 50973, Error
#define XEVENT_COMMON_CODE_148 0xC000C71D

// XEVENT_COMMON_CODE_149, 50974, Error
#define XEVENT_COMMON_CODE_149 0xC000C71E

// XEVENT_COMMON_CODE_150, 50975, Error
#define XEVENT_COMMON_CODE_150 0xC000C71F

// XEVENT_COMMON_CODE_151, 50976, Error
#define XEVENT_COMMON_CODE_151 0xC000C720

// XEVENT_COMMON_CODE_152, 50977, Error
#define XEVENT_COMMON_CODE_152 0xC000C721

// XEVENT_COMMON_CODE_153, 50978, Error
#define XEVENT_COMMON_CODE_153 0xC000C722

// XEVENT_COMMON_CODE_154, 50979, Error
#define XEVENT_COMMON_CODE_154 0xC000C723

// XEVENT_COMMON_CODE_155, 50980, Error
#define XEVENT_COMMON_CODE_155 0xC000C724

// XEVENT_COMMON_CODE_156, 50981, Error
#define XEVENT_COMMON_CODE_156 0xC000C725

// XEVENT_COMMON_CODE_157, 50982, Error
#define XEVENT_COMMON_CODE_157 0xC000C726

// XEVENT_COMMON_CODE_158, 50983, Error
#define XEVENT_COMMON_CODE_158 0xC000C727

// XEVENT_COMMON_CODE_159, 50984, Error
#define XEVENT_COMMON_CODE_159 0xC000C728

// XEVENT_COMMON_CODE_160, 50985, Error
#define XEVENT_COMMON_CODE_160 0xC000C729

// XEVENT_COMMON_CODE_161, 50986, Error
#define XEVENT_COMMON_CODE_161 0xC000C72A

// XEVENT_COMMON_CODE_162, 50987, Error
#define XEVENT_COMMON_CODE_162 0xC000C72B

// XEVENT_COMMON_CODE_163, 50988, Error
#define XEVENT_COMMON_CODE_163 0xC000C72C

// XEVENT_COMMON_CODE_164, 50989, Error
#define XEVENT_COMMON_CODE_164 0xC000C72D

// XEVENT_COMMON_CODE_165, 50990, Error
#define XEVENT_COMMON_CODE_165 0xC000C72E

// XEVENT_COMMON_CODE_166, 50991, Error
#define XEVENT_COMMON_CODE_166 0xC000C72F

// XEVENT_COMMON_CODE_167, 50992, Error
#define XEVENT_COMMON_CODE_167 0xC000C730

// XEVENT_COMMON_CODE_168, 50993, Error
#define XEVENT_COMMON_CODE_168 0xC000C731

// XEVENT_COMMON_CODE_169, 50994, Error
#define XEVENT_COMMON_CODE_169 0xC000C732

// XEVENT_COMMON_CODE_170, 50995, Error
#define XEVENT_COMMON_CODE_170 0xC000C733

// XEVENT_COMMON_CODE_171, 50996, Error
#define XEVENT_COMMON_CODE_171 0xC000C734

// XEVENT_COMMON_CODE_172, 50997, Error
#define XEVENT_COMMON_CODE_172 0xC000C735

// XEVENT_COMMON_CODE_173, 50998, Error
#define XEVENT_COMMON_CODE_173 0xC000C736

// XEVENT_COMMON_CODE_174, 50999, Error
#define XEVENT_COMMON_CODE_174 0xC000C737

// XEVENT_COMMON_CODE_175, 51000, Error
#define XEVENT_COMMON_CODE_175 0xC000C738

// XEVENT_COMMON_CODE_176, 51001, Error
#define XEVENT_COMMON_CODE_176 0xC000C739

// XEVENT_COMMON_CODE_177, 51002, Error
#define XEVENT_COMMON_CODE_177 0xC000C73A

// XEVENT_COMMON_CODE_178, 51003, Error
#define XEVENT_COMMON_CODE_178 0xC000C73B

// XEVENT_COMMON_CODE_179, 51004, Error
#define XEVENT_COMMON_CODE_179 0xC000C73C

// XEVENT_COMMON_CODE_180, 51005, Error
#define XEVENT_COMMON_CODE_180 0xC000C73D

// XEVENT_COMMON_CODE_181, 51006, Error
#define XEVENT_COMMON_CODE_181 0xC000C73E

// XEVENT_COMMON_CODE_182, 51007, Error
#define XEVENT_COMMON_CODE_182 0xC000C73F

// XEVENT_COMMON_CODE_183, 51008, Error
#define XEVENT_COMMON_CODE_183 0xC000C740

// XEVENT_COMMON_CODE_184, 51009, Error
#define XEVENT_COMMON_CODE_184 0xC000C741

// XEVENT_COMMON_CODE_185, 51010, Error
#define XEVENT_COMMON_CODE_185 0xC000C742

// XEVENT_WEBSTORE_EXECUTE_ERROR, 51011, Error
#define XEVENT_WEBSTORE_EXECUTE_ERROR 0xC000C743

// XEVENT_WEBSTORE_EXECUTE_TIMEOUT_ERROR, 51012, Error
#define XEVENT_WEBSTORE_EXECUTE_TIMEOUT_ERROR 0xC000C744

// XEVENT_WEBSTORE_EXECUTE_DEADLOCK_ERROR, 51013, Error
#define XEVENT_WEBSTORE_EXECUTE_DEADLOCK_ERROR 0xC000C745

// XEVENT_COMMON_CODE_189, 51014, Error
#define XEVENT_COMMON_CODE_189 0xC000C746

// XEVENT_COMMON_CODE_190, 51015, Error
#define XEVENT_COMMON_CODE_190 0xC000C747

// XEVENT_COMMON_CODE_191, 51016, Error
#define XEVENT_COMMON_CODE_191 0xC000C748

// XEVENT_COMMON_CODE_192, 51017, Error
#define XEVENT_COMMON_CODE_192 0xC000C749

// XEVENT_COMMON_CODE_193, 51018, Error
#define XEVENT_COMMON_CODE_193 0xC000C74A

// XEVENT_COMMON_CODE_194, 51019, Error
#define XEVENT_COMMON_CODE_194 0xC000C74B

// XEVENT_COMMON_CODE_195, 51020, Error
#define XEVENT_COMMON_CODE_195 0xC000C74C

// XEVENT_COMMON_CODE_196, 51021, Error
#define XEVENT_COMMON_CODE_196 0xC000C74D

// XEVENT_COMMON_CODE_197, 51022, Error
#define XEVENT_COMMON_CODE_197 0xC000C74E

// XEVENT_COMMON_CODE_198, 51023, Error
#define XEVENT_COMMON_CODE_198 0xC000C74F

// XEVENT_COMMON_CODE_199, 51024, Error
#define XEVENT_COMMON_CODE_199 0xC000C750

// XEVENT_COMMON_CODE_200, 51025, Error
#define XEVENT_COMMON_CODE_200 0xC000C751

// XEVENT_DEPRECATED_SYNCCAST_EXTERNAL_EXCEPTION, 51030, Error
#define XEVENT_DEPRECATED_SYNCCAST_EXTERNAL_EXCEPTION 0xC000C756

// XEVENT_COMMON_CODE_208, 51033, Error
#define XEVENT_COMMON_CODE_208 0xC000C759

// XEVENT_COMMON_CODE_209, 51034, Error
#define XEVENT_COMMON_CODE_209 0xC000C75A

// XEVENT_COMMON_CODE_210, 51035, Error
#define XEVENT_COMMON_CODE_210 0xC000C75B

// XEVENT_COMMON_CODE_211, 51036, Error
#define XEVENT_COMMON_CODE_211 0xC000C75C

// XEVENT_COMMON_CODE_212, 51037, Error
#define XEVENT_COMMON_CODE_212 0xC000C75D

// XEVENT_COMMON_CODE_213, 51038, Error
#define XEVENT_COMMON_CODE_213 0xC000C75E

// XEVENT_COMMON_CODE_214, 51039, Error
#define XEVENT_COMMON_CODE_214 0xC000C75F

// XEVENT_COMMON_CODE_215, 51040, Error
#define XEVENT_COMMON_CODE_215 0xC000C760

// XEVENT_COMMON_CODE_216, 51041, Error
#define XEVENT_COMMON_CODE_216 0xC000C761

// XEVENT_COMMON_CODE_217, 51042, Error
#define XEVENT_COMMON_CODE_217 0xC000C762

// XEVENT_COMMON_CODE_218, 51043, Error
#define XEVENT_COMMON_CODE_218 0xC000C763

// XEVENT_COMMON_CODE_219, 51044, Error
#define XEVENT_COMMON_CODE_219 0xC000C764

// XEVENT_COMMON_CODE_220, 51045, Error
#define XEVENT_COMMON_CODE_220 0xC000C765

// XEVENT_COMMON_CODE_221, 51046, Error
#define XEVENT_COMMON_CODE_221 0xC000C766

// XEVENT_COMMON_CODE_222, 51047, Error
#define XEVENT_COMMON_CODE_222 0xC000C767

// XEVENT_COMMON_CODE_223, 51048, Error
#define XEVENT_COMMON_CODE_223 0xC000C768

// XEVENT_COMMON_CODE_224, 51049, Error
#define XEVENT_COMMON_CODE_224 0xC000C769

// XEVENT_COMMON_CODE_225, 51050, Error
#define XEVENT_COMMON_CODE_225 0xC000C76A

// XEVENT_COMMON_CODE_226, 51051, Error
#define XEVENT_COMMON_CODE_226 0xC000C76B

// XEVENT_COMMON_CODE_227, 51052, Error
#define XEVENT_COMMON_CODE_227 0xC000C76C

// XEVENT_COMMON_CODE_228, 51053, Error
#define XEVENT_COMMON_CODE_228 0xC000C76D

// XEVENT_DEPRECATED_COMMON_CODE_229, 51054, Error
#define XEVENT_DEPRECATED_COMMON_CODE_229 0xC000C76E

// XEVENT_DEPRECATED_COMMON_CODE_230, 51055, Error
#define XEVENT_DEPRECATED_COMMON_CODE_230 0xC000C76F

// XEVENT_COMMON_CODE_231, 51056, Error
#define XEVENT_COMMON_CODE_231 0xC000C770

// XEVENT_COMMON_CODE_232, 51057, Error
#define XEVENT_COMMON_CODE_232 0xC000C771

// XEVENT_WMIS_EXTERNAL_EXCEPTION, 51058, Error
#define XEVENT_WMIS_EXTERNAL_EXCEPTION 0xC000C772

// XEVENT_COMMON_CODE_MATCH_STARTMIGRATE_FAILED, 51059, Error
#define XEVENT_COMMON_CODE_MATCH_STARTMIGRATE_FAILED 0xC000C773

// XEVENT_COMMON_CODE_MATCH_MIGRATESTATUS_FAILED_SPROC, 51060, Error
#define XEVENT_COMMON_CODE_MATCH_MIGRATESTATUS_FAILED_SPROC 0xC000C774

// XEVENT_COMMON_CODE_MATCH_UPDLTC_TV_FAILED, 51061, Error
#define XEVENT_COMMON_CODE_MATCH_UPDLTC_TV_FAILED 0xC000C775

// XEVENT_COMMON_CODE_MATCH_UPDLTC_NPDB_FAILED, 51062, Error
#define XEVENT_COMMON_CODE_MATCH_UPDLTC_NPDB_FAILED 0xC000C776

// XEVENT_COMMON_CODE_LSPLIB_SQLEXCEPTION, 51063, Error
#define XEVENT_COMMON_CODE_LSPLIB_SQLEXCEPTION 0xC000C777

// XEVENT_HEALTH_REPORT_RED, 51064, Error
#define XEVENT_HEALTH_REPORT_RED 0xC000C778

// XEVENT_HEALTH_ENGINE_FAILURE, 51065, Error
#define XEVENT_HEALTH_ENGINE_FAILURE 0xC000C779

// XEVENT_FEAPP_INITIALIZATION_METHOD_FAILED, 51066, Error
#define XEVENT_FEAPP_INITIALIZATION_METHOD_FAILED 0xC000C77A

// XEVENT_FEAPP_INITIALIZATION_METHOD_NOT_FOUND, 51067, Error
#define XEVENT_FEAPP_INITIALIZATION_METHOD_NOT_FOUND 0xC000C77B

// XEVENT_FAST_FAIL_MISSING_COUNTERS, 51068, Error
#define XEVENT_FAST_FAIL_MISSING_COUNTERS 0xC000C77C

// XEVENT_FAST_FAIL_MISSING_RESOURCE, 51069, Error
#define XEVENT_FAST_FAIL_MISSING_RESOURCE 0xC000C77D

// XEVENT_FEAPP_COMPRESSION_ERROR, 51070, Error
#define XEVENT_FEAPP_COMPRESSION_ERROR 0xC000C77E

// XEVENT_UNHANDLED_THREAD_EXCEPTION, 51071, Error
#define XEVENT_UNHANDLED_THREAD_EXCEPTION 0xC000C77F

// XEVENT_FEAPP_INIT_FAILURE, 51072, Error
#define XEVENT_FEAPP_INIT_FAILURE 0xC000C780

// XEVENT_FORBIDDEN_NAMES_EXCLUDED_TITLES_CONFIG_ERROR, 51073, Error
#define XEVENT_FORBIDDEN_NAMES_EXCLUDED_TITLES_CONFIG_ERROR 0xC000C781

// XEVENT_COMMON_COMM_6, 51231, Error
#define XEVENT_COMMON_COMM_6 0xC000C81F

// XEVENT_COMMON_COMM_7, 51232, Error
#define XEVENT_COMMON_COMM_7 0xC000C820

// XEVENT_COMMON_COMM_8, 51233, Error
#define XEVENT_COMMON_COMM_8 0xC000C821

// XEVENT_COMMON_COMM_9, 51234, Error
#define XEVENT_COMMON_COMM_9 0xC000C822

// XEVENT_COMMON_COMM_10, 51235, Error
#define XEVENT_COMMON_COMM_10 0xC000C823

// XEVENT_COMMON_COMM_11, 51236, Error
#define XEVENT_COMMON_COMM_11 0xC000C824

// XEVENT_COMMON_COMM_12, 51237, Error
#define XEVENT_COMMON_COMM_12 0xC000C825

// XEVENT_COMMON_COMM_13, 51238, Error
#define XEVENT_COMMON_COMM_13 0xC000C826

// XEVENT_XCACHE_CLIENT_BROKEN_PIPE, 51239, Error
#define XEVENT_XCACHE_CLIENT_BROKEN_PIPE 0xC000C827

// XEVENT_XCACHE_CLIENT_BROKEN_PIPE_1, 51240, Error
#define XEVENT_XCACHE_CLIENT_BROKEN_PIPE_1 0xC000C828

// XEVENT_XCACHE_CLIENT_BROKEN_PIPE_2, 51241, Error
#define XEVENT_XCACHE_CLIENT_BROKEN_PIPE_2 0xC000C829

// XEVENT_XCACHE_CLIENT_BROKEN_PIPE_3, 51242, Error
#define XEVENT_XCACHE_CLIENT_BROKEN_PIPE_3 0xC000C82A

// XEVENT_XCACHE_CLIENT_BROKEN_PIPE_4, 51243, Error
#define XEVENT_XCACHE_CLIENT_BROKEN_PIPE_4 0xC000C82B

// XEVENT_XCACHE_SERVER_BUSY, 51244, Error
#define XEVENT_XCACHE_SERVER_BUSY 0xC000C82C

// XEVENT_XCACHE_INVALID_MESSAGE, 51245, Error
#define XEVENT_XCACHE_INVALID_MESSAGE 0xC000C82D

// XEVENT_XCACHE_INVALID_MESSAGE_1, 51246, Error
#define XEVENT_XCACHE_INVALID_MESSAGE_1 0xC000C82E

// XEVENT_XCACHE_INVALID_MESSAGE_2, 51247, Error
#define XEVENT_XCACHE_INVALID_MESSAGE_2 0xC000C82F

// XEVENT_XCACHE_INVALID_MESSAGE_3, 51248, Error
#define XEVENT_XCACHE_INVALID_MESSAGE_3 0xC000C830

// XEVENT_XCACHE_INVALID_MESSAGE_4, 51249, Error
#define XEVENT_XCACHE_INVALID_MESSAGE_4 0xC000C831

// XEVENT_XCACHE_INVALID_MESSAGE_5, 51250, Error
#define XEVENT_XCACHE_INVALID_MESSAGE_5 0xC000C832

// XEVENT_XCACHE_INVALID_MESSAGE_6, 51251, Error
#define XEVENT_XCACHE_INVALID_MESSAGE_6 0xC000C833

// XEVENT_PIPE_FAILURE, 51252, Error
#define XEVENT_PIPE_FAILURE 0xC000C834

// XEVENT_PIPE_FAILURE_1, 51253, Error
#define XEVENT_PIPE_FAILURE_1 0xC000C835

// XEVENT_PIPE_FAILURE_2, 51254, Error
#define XEVENT_PIPE_FAILURE_2 0xC000C836

// XEVENT_AUTHDATA_SG_COMMUNICATION_ERROR, 51255, Error
#define XEVENT_AUTHDATA_SG_COMMUNICATION_ERROR 0xC000C837

// XEVENT_COMMON_COMM_31, 51256, Error
#define XEVENT_COMMON_COMM_31 0xC000C838

// XEVENT_AUTHDATA_SG_COMMUNICATION_ERROR_1, 51257, Error
#define XEVENT_AUTHDATA_SG_COMMUNICATION_ERROR_1 0xC000C839

// XEVENT_MC_XRL_REQUEST_ERROR, 51258, Error
#define XEVENT_MC_XRL_REQUEST_ERROR 0xC000C83A

// XEVENT_COMMON_COMM_34, 51259, Error
#define XEVENT_COMMON_COMM_34 0xC000C83B

// XEVENT_COMMON_COMM_35, 51260, Error
#define XEVENT_COMMON_COMM_35 0xC000C83C

// XEVENT_COMMON_COMM_36, 51261, Error
#define XEVENT_COMMON_COMM_36 0xC000C83D

// XEVENT_XCACHE_INVALID_MESSAGE_7, 51262, Error
#define XEVENT_XCACHE_INVALID_MESSAGE_7 0xC000C83E

// XEVENT_XCACHE_INVALID_RESPONSE_1, 51263, Error
#define XEVENT_XCACHE_INVALID_RESPONSE_1 0xC000C83F

// XEVENT_FORBIDDEN_NAMES_LOAD_SUCCESS, 51264, Info
#define XEVENT_FORBIDDEN_NAMES_LOAD_SUCCESS 0x4000C840

// XEVENT_FORBIDDEN_NAMES_UNVETTED_STRING, 51265, Error
#define XEVENT_FORBIDDEN_NAMES_UNVETTED_STRING 0xC000C841

// XEVENT_MUSICNET_ACCOUNT_CREATE_FAILED, 51354, Error
#define XEVENT_MUSICNET_ACCOUNT_CREATE_FAILED 0xC000C89A

// XEVENT_COMMON_CONFIG_69, 51394, Warning
#define XEVENT_COMMON_CONFIG_69 0x8000C8C2

// XEVENT_COMMON_CONFIG_70, 51395, Error
#define XEVENT_COMMON_CONFIG_70 0xC000C8C3

// XEVENT_COMMON_CONFIG_71, 51396, Warning
#define XEVENT_COMMON_CONFIG_71 0x8000C8C4

// XEVENT_COMMON_CONFIG_72, 51397, Warning
#define XEVENT_COMMON_CONFIG_72 0x8000C8C5

// XEVENT_COMMON_CONFIG_73, 51398, Warning
#define XEVENT_COMMON_CONFIG_73 0x8000C8C6

// XEVENT_COMMON_CONFIG_74, 51399, Warning
#define XEVENT_COMMON_CONFIG_74 0x8000C8C7

// XEVENT_COMMON_CONFIG_75, 51400, Warning
#define XEVENT_COMMON_CONFIG_75 0x8000C8C8

// XEVENT_COMMON_CONFIG_76, 51401, Warning
#define XEVENT_COMMON_CONFIG_76 0x8000C8C9

// XEVENT_COMMON_CONFIG_77, 51402, Warning
#define XEVENT_COMMON_CONFIG_77 0x8000C8CA

// XEVENT_COMMON_CONFIG_78, 51403, Error
#define XEVENT_COMMON_CONFIG_78 0xC000C8CB

// XEVENT_COMMON_CONFIG_79, 51404, Warning
#define XEVENT_COMMON_CONFIG_79 0x8000C8CC

// XEVENT_COMMON_CONFIG_80, 51405, Warning
#define XEVENT_COMMON_CONFIG_80 0x8000C8CD

// XEVENT_COMMON_CONFIG_81, 51406, Warning
#define XEVENT_COMMON_CONFIG_81 0x8000C8CE

// XEVENT_COMMON_CONFIG_82, 51407, Warning
#define XEVENT_COMMON_CONFIG_82 0x8000C8CF

// XEVENT_COMMON_CONFIG_83, 51408, Warning
#define XEVENT_COMMON_CONFIG_83 0x8000C8D0

// XEVENT_COMMON_CONFIG_84, 51409, Error
#define XEVENT_COMMON_CONFIG_84 0xC000C8D1

// XEVENT_COMMON_CONFIG_85, 51410, Error
#define XEVENT_COMMON_CONFIG_85 0xC000C8D2

// XEVENT_COMMON_CONFIG_86, 51411, Error
#define XEVENT_COMMON_CONFIG_86 0xC000C8D3

// XEVENT_COMMON_CONFIG_87, 51412, Error
#define XEVENT_COMMON_CONFIG_87 0xC000C8D4

// XEVENT_COMMON_CONFIG_88, 51413, Error
#define XEVENT_COMMON_CONFIG_88 0xC000C8D5

// XEVENT_COMMON_CONFIG_89, 51414, Error
#define XEVENT_COMMON_CONFIG_89 0xC000C8D6

// XEVENT_COMMON_CONFIG_90, 51415, Error
#define XEVENT_COMMON_CONFIG_90 0xC000C8D7

// XEVENT_COMMON_CONFIG_91, 51416, Error
#define XEVENT_COMMON_CONFIG_91 0xC000C8D8

// XEVENT_COMMON_CONFIG_92, 51417, Error
#define XEVENT_COMMON_CONFIG_92 0xC000C8D9

// XEVENT_COMMON_CONFIG_93, 51418, Error
#define XEVENT_COMMON_CONFIG_93 0xC000C8DA

// XEVENT_COMMON_CONFIG_94, 51419, Error
#define XEVENT_COMMON_CONFIG_94 0xC000C8DB

// XEVENT_COMMON_CONFIG_95, 51420, Error
#define XEVENT_COMMON_CONFIG_95 0xC000C8DC

// XEVENT_COMMON_CONFIG_96, 51421, Error
#define XEVENT_COMMON_CONFIG_96 0xC000C8DD

// XEVENT_COMMON_CONFIG_97, 51422, Error
#define XEVENT_COMMON_CONFIG_97 0xC000C8DE

// XEVENT_COMMON_CONFIG_98, 51423, Error
#define XEVENT_COMMON_CONFIG_98 0xC000C8DF

// XEVENT_COMMON_CONFIG_99, 51424, Error
#define XEVENT_COMMON_CONFIG_99 0xC000C8E0

// XEVENT_COMMON_CONFIG_100, 51425, Error
#define XEVENT_COMMON_CONFIG_100 0xC000C8E1

// XEVENT_COMMON_CONFIG_101, 51426, Error
#define XEVENT_COMMON_CONFIG_101 0xC000C8E2

// XEVENT_COMMON_CONFIG_102, 51427, Error
#define XEVENT_COMMON_CONFIG_102 0xC000C8E3

// XEVENT_COMMON_CONFIG_103, 51428, Error
#define XEVENT_COMMON_CONFIG_103 0xC000C8E4

// XEVENT_COMMON_CONFIG_104, 51429, Error
#define XEVENT_COMMON_CONFIG_104 0xC000C8E5

// XEVENT_COMMON_CONFIG_105, 51430, Error
#define XEVENT_COMMON_CONFIG_105 0xC000C8E6

// XEVENT_COMMON_CONFIG_106, 51431, Error
#define XEVENT_COMMON_CONFIG_106 0xC000C8E7

// XEVENT_COMMON_CONFIG_107, 51432, Error
#define XEVENT_COMMON_CONFIG_107 0xC000C8E8

// XEVENT_COMMON_CONFIG_108, 51433, Error
#define XEVENT_COMMON_CONFIG_108 0xC000C8E9

// XEVENT_COMMON_CONFIG_109, 51434, Warning
#define XEVENT_COMMON_CONFIG_109 0x8000C8EA

// XEVENT_COMMON_CONFIG_110, 51435, Error
#define XEVENT_COMMON_CONFIG_110 0xC000C8EB

// XEVENT_COMMON_CONFIG_111, 51436, Error
#define XEVENT_COMMON_CONFIG_111 0xC000C8EC

// XEVENT_COMMON_CONFIG_112, 51437, Error
#define XEVENT_COMMON_CONFIG_112 0xC000C8ED

// XEVENT_COMMON_CONFIG_113, 51438, Error
#define XEVENT_COMMON_CONFIG_113 0xC000C8EE

// XEVENT_COMMON_CONFIG_114, 51439, Error
#define XEVENT_COMMON_CONFIG_114 0xC000C8EF

// XEVENT_COMMON_CONFIG_115, 51440, Error
#define XEVENT_COMMON_CONFIG_115 0xC000C8F0

// XEVENT_COMMON_CONFIG_116, 51441, Error
#define XEVENT_COMMON_CONFIG_116 0xC000C8F1

// XEVENT_COMMON_CONFIG_117, 51442, Error
#define XEVENT_COMMON_CONFIG_117 0xC000C8F2

// XEVENT_COMMON_CONFIG_118, 51443, Error
#define XEVENT_COMMON_CONFIG_118 0xC000C8F3

// XEVENT_COMMON_CONFIG_119, 51444, Error
#define XEVENT_COMMON_CONFIG_119 0xC000C8F4

// XEVENT_COMMON_CONFIG_120, 51445, Error
#define XEVENT_COMMON_CONFIG_120 0xC000C8F5

// XEVENT_COMMON_CONFIG_121, 51446, Error
#define XEVENT_COMMON_CONFIG_121 0xC000C8F6

// XEVENT_COMMON_CONFIG_122, 51447, Error
#define XEVENT_COMMON_CONFIG_122 0xC000C8F7

// XEVENT_COMMON_CONFIG_123, 51448, Error
#define XEVENT_COMMON_CONFIG_123 0xC000C8F8

// XEVENT_COMMON_CONFIG_124, 51449, Error
#define XEVENT_COMMON_CONFIG_124 0xC000C8F9

// XEVENT_COMMON_CONFIG_125, 51450, Error
#define XEVENT_COMMON_CONFIG_125 0xC000C8FA

// XEVENT_COMMON_CONFIG_126, 51451, Error
#define XEVENT_COMMON_CONFIG_126 0xC000C8FB

// XEVENT_COMMON_CONFIG_127, 51452, Error
#define XEVENT_COMMON_CONFIG_127 0xC000C8FC

// XEVENT_COMMON_CONFIG_128, 51453, Error
#define XEVENT_COMMON_CONFIG_128 0xC000C8FD

// XEVENT_COMMON_CONFIG_129, 51454, Error
#define XEVENT_COMMON_CONFIG_129 0xC000C8FE

// XEVENT_COMMON_CONFIG_130, 51455, Error
#define XEVENT_COMMON_CONFIG_130 0xC000C8FF

// XEVENT_COMMON_CONFIG_131, 51456, Error
#define XEVENT_COMMON_CONFIG_131 0xC000C900

// XEVENT_COMMON_CONFIG_132, 51457, Error
#define XEVENT_COMMON_CONFIG_132 0xC000C901

// XEVENT_COMMON_CONFIG_133, 51458, Error
#define XEVENT_COMMON_CONFIG_133 0xC000C902

// XEVENT_COMMON_CONFIG_134, 51459, Warning
#define XEVENT_COMMON_CONFIG_134 0x8000C903

// XEVENT_COMMON_CONFIG_135, 51460, Error
#define XEVENT_COMMON_CONFIG_135 0xC000C904

// XEVENT_COMMON_CONFIG_136, 51461, Error
#define XEVENT_COMMON_CONFIG_136 0xC000C905

// XEVENT_COMMON_CONFIG_137, 51462, Error
#define XEVENT_COMMON_CONFIG_137 0xC000C906

// XEVENT_COMMON_CONFIG_138, 51463, Error
#define XEVENT_COMMON_CONFIG_138 0xC000C907

// XEVENT_COMMON_CONFIG_139, 51464, Error
#define XEVENT_COMMON_CONFIG_139 0xC000C908

// XEVENT_COMMON_CONFIG_140, 51465, Error
#define XEVENT_COMMON_CONFIG_140 0xC000C909

// XEVENT_COMMON_CONFIG_141, 51466, Error
#define XEVENT_COMMON_CONFIG_141 0xC000C90A

// XEVENT_COMMON_CONFIG_142, 51467, Error
#define XEVENT_COMMON_CONFIG_142 0xC000C90B

// XEVENT_COMMON_CONFIG_143, 51468, Error
#define XEVENT_COMMON_CONFIG_143 0xC000C90C

// XEVENT_COMMON_CONFIG_144, 51469, Error
#define XEVENT_COMMON_CONFIG_144 0xC000C90D

// XEVENT_COMMON_CONFIG_145, 51470, Error
#define XEVENT_COMMON_CONFIG_145 0xC000C90E

// XEVENT_COMMON_CONFIG_146, 51471, Warning
#define XEVENT_COMMON_CONFIG_146 0x8000C90F

// XEVENT_COMMON_CONFIG_147, 51472, Error
#define XEVENT_COMMON_CONFIG_147 0xC000C910

// XEVENT_COMMON_CONFIG_148, 51473, Error
#define XEVENT_COMMON_CONFIG_148 0xC000C911

// XEVENT_COMMON_CONFIG_149, 51474, Error
#define XEVENT_COMMON_CONFIG_149 0xC000C912

// XEVENT_COMMON_CONFIG_150, 51475, Error
#define XEVENT_COMMON_CONFIG_150 0xC000C913

// XEVENT_COMMON_CONFIG_151, 51476, Error
#define XEVENT_COMMON_CONFIG_151 0xC000C914

// XEVENT_COMMON_CONFIG_152, 51477, Error
#define XEVENT_COMMON_CONFIG_152 0xC000C915

// XEVENT_COMMON_CONFIG_153, 51478, Error
#define XEVENT_COMMON_CONFIG_153 0xC000C916

// XEVENT_COMMON_CONFIG_154, 51479, Error
#define XEVENT_COMMON_CONFIG_154 0xC000C917

// XEVENT_COMMON_CONFIG_155, 51480, Error
#define XEVENT_COMMON_CONFIG_155 0xC000C918

// XEVENT_COMMON_CONFIG_156, 51481, Error
#define XEVENT_COMMON_CONFIG_156 0xC000C919

// XEVENT_COMMON_CONFIG_157, 51482, Error
#define XEVENT_COMMON_CONFIG_157 0xC000C91A

// XEVENT_COMMON_CONFIG_158, 51483, Error
#define XEVENT_COMMON_CONFIG_158 0xC000C91B

// XEVENT_COMMON_CONFIG_159, 51484, Error
#define XEVENT_COMMON_CONFIG_159 0xC000C91C

// XEVENT_COMMON_CONFIG_160, 51485, Error
#define XEVENT_COMMON_CONFIG_160 0xC000C91D

// XEVENT_COMMON_CONFIG_161, 51486, Error
#define XEVENT_COMMON_CONFIG_161 0xC000C91E

// XEVENT_COMMON_CONFIG_162, 51487, Error
#define XEVENT_COMMON_CONFIG_162 0xC000C91F

// XEVENT_COMMON_CONFIG_163, 51488, Error
#define XEVENT_COMMON_CONFIG_163 0xC000C920

// XEVENT_COMMON_CONFIG_164, 51489, Error
#define XEVENT_COMMON_CONFIG_164 0xC000C921

// XEVENT_COMMON_CONFIG_165, 51490, Error
#define XEVENT_COMMON_CONFIG_165 0xC000C922

// XEVENT_COMMON_CONFIG_166, 51491, Error
#define XEVENT_COMMON_CONFIG_166 0xC000C923

// XEVENT_COMMON_CONFIG_167, 51492, Error
#define XEVENT_COMMON_CONFIG_167 0xC000C924

// XEVENT_COMMON_CONFIG_168, 51493, Error
#define XEVENT_COMMON_CONFIG_168 0xC000C925

// XEVENT_COMMON_CONFIG_169, 51494, Error
#define XEVENT_COMMON_CONFIG_169 0xC000C926

// XEVENT_COMMON_CONFIG_170, 51495, Warning
#define XEVENT_COMMON_CONFIG_170 0x8000C927

// XEVENT_COMMON_CONFIG_171, 51496, Error
#define XEVENT_COMMON_CONFIG_171 0xC000C928

// XEVENT_COMMON_CONFIG_172, 51497, Error
#define XEVENT_COMMON_CONFIG_172 0xC000C929

// XEVENT_COMMON_CONFIG_173, 51498, Error
#define XEVENT_COMMON_CONFIG_173 0xC000C92A

// XEVENT_COMMON_CONFIG_174, 51499, Warning
#define XEVENT_COMMON_CONFIG_174 0x8000C92B

// XEVENT_COMMON_CONFIG_175, 51500, Error
#define XEVENT_COMMON_CONFIG_175 0xC000C92C

// XEVENT_COMMON_CONFIG_176, 51501, Error
#define XEVENT_COMMON_CONFIG_176 0xC000C92D

// XEVENT_COMMON_CONFIG_177, 51502, Warning
#define XEVENT_COMMON_CONFIG_177 0x8000C92E

// XEVENT_COMMON_CONFIG_178, 51503, Error
#define XEVENT_COMMON_CONFIG_178 0xC000C92F

// XEVENT_COMMON_CONFIG_179, 51504, Error
#define XEVENT_COMMON_CONFIG_179 0xC000C930

// XEVENT_COMMON_CONFIG_180, 51505, Warning
#define XEVENT_COMMON_CONFIG_180 0x8000C931

// XEVENT_COMMON_CONFIG_181, 51506, Error
#define XEVENT_COMMON_CONFIG_181 0xC000C932

// XEVENT_COMMON_CONFIG_182, 51507, Error
#define XEVENT_COMMON_CONFIG_182 0xC000C933

// XEVENT_COMMON_CONFIG_183, 51508, Error
#define XEVENT_COMMON_CONFIG_183 0xC000C934

// XEVENT_COMMON_CONFIG_184, 51509, Error
#define XEVENT_COMMON_CONFIG_184 0xC000C935

// XEVENT_COMMON_CONFIG_185, 51510, Error
#define XEVENT_COMMON_CONFIG_185 0xC000C936

// XEVENT_COMMON_CONFIG_186, 51511, Error
#define XEVENT_COMMON_CONFIG_186 0xC000C937

// XEVENT_COMMON_CONFIG_187, 51512, Error
#define XEVENT_COMMON_CONFIG_187 0xC000C938

// XEVENT_COMMON_CONFIG_188, 51513, Error
#define XEVENT_COMMON_CONFIG_188 0xC000C939

// XEVENT_COMMON_CONFIG_189, 51514, Error
#define XEVENT_COMMON_CONFIG_189 0xC000C93A

// XEVENT_COMMON_CONFIG_190, 51515, Error
#define XEVENT_COMMON_CONFIG_190 0xC000C93B

// XEVENT_COMMON_CONFIG_191, 51516, Error
#define XEVENT_COMMON_CONFIG_191 0xC000C93C

// XEVENT_COMMON_CONFIG_192, 51517, Error
#define XEVENT_COMMON_CONFIG_192 0xC000C93D

// XEVENT_COMMON_CONFIG_193, 51518, Error
#define XEVENT_COMMON_CONFIG_193 0xC000C93E

// XEVENT_COMMON_CONFIG_194, 51519, Error
#define XEVENT_COMMON_CONFIG_194 0xC000C93F

// XEVENT_COMMON_CONFIG_195, 51520, Error
#define XEVENT_COMMON_CONFIG_195 0xC000C940

// XEVENT_COMMON_CONFIG_196, 51521, Error
#define XEVENT_COMMON_CONFIG_196 0xC000C941

// XEVENT_COMMON_CONFIG_197, 51522, Error
#define XEVENT_COMMON_CONFIG_197 0xC000C942

// XEVENT_COMMON_CONFIG_198, 51523, Error
#define XEVENT_COMMON_CONFIG_198 0xC000C943

// XEVENT_COMMON_CONFIG_199, 51524, Error
#define XEVENT_COMMON_CONFIG_199 0xC000C944

// XEVENT_COMMON_CONFIG_200, 51525, Error
#define XEVENT_COMMON_CONFIG_200 0xC000C945

// XEVENT_COMMON_CONFIG_201, 51526, Error
#define XEVENT_COMMON_CONFIG_201 0xC000C946

// XEVENT_COMMON_CONFIG_202, 51527, Error
#define XEVENT_COMMON_CONFIG_202 0xC000C947

// XEVENT_COMMON_CONFIG_203, 51528, Error
#define XEVENT_COMMON_CONFIG_203 0xC000C948

// XEVENT_COMMON_CONFIG_204, 51529, Error
#define XEVENT_COMMON_CONFIG_204 0xC000C949

// XEVENT_COMMON_CONFIG_205, 51530, Error
#define XEVENT_COMMON_CONFIG_205 0xC000C94A

// XEVENT_COMMON_CONFIG_206, 51531, Error
#define XEVENT_COMMON_CONFIG_206 0xC000C94B

// XEVENT_COMMON_CONFIG_207, 51532, Error
#define XEVENT_COMMON_CONFIG_207 0xC000C94C

// XEVENT_COMMON_CONFIG_208, 51533, Error
#define XEVENT_COMMON_CONFIG_208 0xC000C94D

// XEVENT_COMMON_CONFIG_209, 51534, Error
#define XEVENT_COMMON_CONFIG_209 0xC000C94E

// XEVENT_COMMON_CONFIG_210, 51535, Error
#define XEVENT_COMMON_CONFIG_210 0xC000C94F

// XEVENT_COMMON_CONFIG_211, 51536, Error
#define XEVENT_COMMON_CONFIG_211 0xC000C950

// XEVENT_COMMON_CONFIG_212, 51537, Error
#define XEVENT_COMMON_CONFIG_212 0xC000C951

// XEVENT_COMMON_CONFIG_213, 51538, Error
#define XEVENT_COMMON_CONFIG_213 0xC000C952

// XEVENT_COMMON_CONFIG_214, 51539, Error
#define XEVENT_COMMON_CONFIG_214 0xC000C953

// XEVENT_COMMON_CONFIG_215, 51540, Error
#define XEVENT_COMMON_CONFIG_215 0xC000C954

// XEVENT_COMMON_CONFIG_216, 51541, Error
#define XEVENT_COMMON_CONFIG_216 0xC000C955

// XEVENT_COMMON_CONFIG_217, 51542, Error
#define XEVENT_COMMON_CONFIG_217 0xC000C956

// XEVENT_COMMON_CONFIG_218, 51543, Error
#define XEVENT_COMMON_CONFIG_218 0xC000C957

// XEVENT_COMMON_CONFIG_219, 51544, Error
#define XEVENT_COMMON_CONFIG_219 0xC000C958

// XEVENT_COMMON_CONFIG_220, 51545, Error
#define XEVENT_COMMON_CONFIG_220 0xC000C959

// XEVENT_COMMON_CONFIG_221, 51546, Error
#define XEVENT_COMMON_CONFIG_221 0xC000C95A

// XEVENT_COMMON_CONFIG_222, 51547, Error
#define XEVENT_COMMON_CONFIG_222 0xC000C95B

// XEVENT_COMMON_CONFIG_223, 51548, Error
#define XEVENT_COMMON_CONFIG_223 0xC000C95C

// XEVENT_COMMON_CONFIG_224, 51549, Error
#define XEVENT_COMMON_CONFIG_224 0xC000C95D

// XEVENT_COMMON_CONFIG_225, 51550, Error
#define XEVENT_COMMON_CONFIG_225 0xC000C95E

// XEVENT_COMMON_CONFIG_226, 51551, Error
#define XEVENT_COMMON_CONFIG_226 0xC000C95F

// XEVENT_COMMON_CONFIG_227, 51552, Error
#define XEVENT_COMMON_CONFIG_227 0xC000C960

// XEVENT_COMMON_CONFIG_228, 51553, Error
#define XEVENT_COMMON_CONFIG_228 0xC000C961

// XEVENT_COMMON_CONFIG_229, 51554, Error
#define XEVENT_COMMON_CONFIG_229 0xC000C962

// XEVENT_COMMON_CONFIG_230, 51555, Error
#define XEVENT_COMMON_CONFIG_230 0xC000C963

// XEVENT_COMMON_CONFIG_231, 51556, Error
#define XEVENT_COMMON_CONFIG_231 0xC000C964

// XEVENT_COMMON_CONFIG_232, 51557, Error
#define XEVENT_COMMON_CONFIG_232 0xC000C965

// XEVENT_COMMON_CONFIG_233, 51558, Error
#define XEVENT_COMMON_CONFIG_233 0xC000C966

// XEVENT_COMMON_CONFIG_234, 51559, Error
#define XEVENT_COMMON_CONFIG_234 0xC000C967

// XEVENT_COMMON_CONFIG_235, 51560, Error
#define XEVENT_COMMON_CONFIG_235 0xC000C968

// XEVENT_COMMON_CONFIG_236, 51561, Error
#define XEVENT_COMMON_CONFIG_236 0xC000C969

// XEVENT_COMMON_CONFIG_237, 51562, Error
#define XEVENT_COMMON_CONFIG_237 0xC000C96A

// XEVENT_COMMON_CONFIG_238, 51563, Error
#define XEVENT_COMMON_CONFIG_238 0xC000C96B

// XEVENT_COMMON_CONFIG_239, 51564, Error
#define XEVENT_COMMON_CONFIG_239 0xC000C96C

// XEVENT_COMMON_CONFIG_240, 51565, Error
#define XEVENT_COMMON_CONFIG_240 0xC000C96D

// XEVENT_COMMON_CONFIG_241, 51566, Error
#define XEVENT_COMMON_CONFIG_241 0xC000C96E

// XEVENT_COMMON_CONFIG_242, 51567, Error
#define XEVENT_COMMON_CONFIG_242 0xC000C96F

// XEVENT_COMMON_CONFIG_243, 51568, Error
#define XEVENT_COMMON_CONFIG_243 0xC000C970

// XEVENT_COMMON_CONFIG_244, 51569, Error
#define XEVENT_COMMON_CONFIG_244 0xC000C971

// XEVENT_COMMON_CONFIG_245, 51570, Warning
#define XEVENT_COMMON_CONFIG_245 0x8000C972

// XEVENT_COMMON_CONFIG_246, 51571, Warning
#define XEVENT_COMMON_CONFIG_246 0x8000C973

// XEVENT_COMMON_CONFIG_247, 51572, Error
#define XEVENT_COMMON_CONFIG_247 0xC000C974

// XEVENT_COMMON_CONFIG_248, 51573, Error
#define XEVENT_COMMON_CONFIG_248 0xC000C975

// XEVENT_COMMON_CONFIG_249, 51574, Error
#define XEVENT_COMMON_CONFIG_249 0xC000C976

// XEVENT_COMMON_CONFIG_250, 51575, Error
#define XEVENT_COMMON_CONFIG_250 0xC000C977

// XEVENT_DEPRECATED_COMMON_CONFIG_251, 51576, Error
#define XEVENT_DEPRECATED_COMMON_CONFIG_251 0xC000C978

// XEVENT_COMMON_CONFIG_252, 51577, Error
#define XEVENT_COMMON_CONFIG_252 0xC000C979

// XEVENT_COMMON_CONFIG_253, 51578, Warning
#define XEVENT_COMMON_CONFIG_253 0x8000C97A

// XEVENT_COMMON_CONFIG_254, 51579, Error
#define XEVENT_COMMON_CONFIG_254 0xC000C97B

// XEVENT_COMMON_CONFIG_255, 51580, Error
#define XEVENT_COMMON_CONFIG_255 0xC000C97C

// XEVENT_COMMON_CONFIG_256, 51581, Error
#define XEVENT_COMMON_CONFIG_256 0xC000C97D

// XEVENT_COMMON_CONFIG_257, 51582, Error
#define XEVENT_COMMON_CONFIG_257 0xC000C97E

// XEVENT_COMMON_CONFIG_258, 51583, Error
#define XEVENT_COMMON_CONFIG_258 0xC000C97F

// XEVENT_COMMON_CONFIG_259, 51584, Warning
#define XEVENT_COMMON_CONFIG_259 0x8000C980

// XEVENT_COMMON_CONFIG_260, 51585, Warning
#define XEVENT_COMMON_CONFIG_260 0x8000C981

// XEVENT_COMMON_CONFIG_261, 51586, Error
#define XEVENT_COMMON_CONFIG_261 0xC000C982

// XEVENT_COMMON_CONFIG_262, 51587, Error
#define XEVENT_COMMON_CONFIG_262 0xC000C983

// XEVENT_COMMON_CONFIG_263, 51588, Error
#define XEVENT_COMMON_CONFIG_263 0xC000C984

// XEVENT_COMMON_CONFIG_264, 51589, Error
#define XEVENT_COMMON_CONFIG_264 0xC000C985

// XEVENT_COMMON_CONFIG_265, 51590, Error
#define XEVENT_COMMON_CONFIG_265 0xC000C986

// XEVENT_COMMON_CONFIG_266, 51591, Warning
#define XEVENT_COMMON_CONFIG_266 0x8000C987

// XEVENT_COMMON_CONFIG_PIPE_HANDLE_DISPOSED, 51593, Error
#define XEVENT_COMMON_CONFIG_PIPE_HANDLE_DISPOSED 0xC000C989

// XEVENT_COMMON_CONFIG_270, 51595, Error
#define XEVENT_COMMON_CONFIG_270 0xC000C98B

// XEVENT_COMMON_CONFIG_272, 51597, Error
#define XEVENT_COMMON_CONFIG_272 0xC000C98D

// XEVENT_COMMON_CONFIG_274, 51599, Error
#define XEVENT_COMMON_CONFIG_274 0xC000C98F

// XEVENT_MC_SGINFO_IS_OFF, 51600, Warning
#define XEVENT_MC_SGINFO_IS_OFF 0x8000C990

// XEVENT_COMMON_CONFIG_276, 51601, Error
#define XEVENT_COMMON_CONFIG_276 0xC000C991

// XEVENT_COMMON_CONFIG_277, 51602, Error
#define XEVENT_COMMON_CONFIG_277 0xC000C992

// XEVENT_COMMON_CONFIG_278, 51603, Error
#define XEVENT_COMMON_CONFIG_278 0xC000C993

// XEVENT_MC_BAD_CONFIG_DATA_4, 51604, Error
#define XEVENT_MC_BAD_CONFIG_DATA_4 0xC000C994

// XEVENT_MC_BAD_CONFIG_DATA_5, 51605, Error
#define XEVENT_MC_BAD_CONFIG_DATA_5 0xC000C995

// XEVENT_MC_BAD_CONFIG_DATA_6, 51606, Error
#define XEVENT_MC_BAD_CONFIG_DATA_6 0xC000C996

// XEVENT_MC_BAD_CONFIG_DATA_7, 51607, Error
#define XEVENT_MC_BAD_CONFIG_DATA_7 0xC000C997

// XEVENT_COMMON_CONFIG_283, 51608, Error
#define XEVENT_COMMON_CONFIG_283 0xC000C998

// XEVENT_COMMON_CONFIG_284, 51609, Error
#define XEVENT_COMMON_CONFIG_284 0xC000C999

// XEVENT_MC_BAD_CONFIG_DATA_8, 51610, Error
#define XEVENT_MC_BAD_CONFIG_DATA_8 0xC000C99A

// XEVENT_COMMON_CONFIG_286, 51611, Error
#define XEVENT_COMMON_CONFIG_286 0xC000C99B

// XEVENT_COMMON_CONFIG_287, 51612, Error
#define XEVENT_COMMON_CONFIG_287 0xC000C99C

// XEVENT_COMMON_CONFIG_288, 51613, Error
#define XEVENT_COMMON_CONFIG_288 0xC000C99D

// XEVENT_MGMT_CRITICAL_ERROR, 51614, Error
#define XEVENT_MGMT_CRITICAL_ERROR 0xC000C99E

// XEVENT_MGMT_INIT_FAILURE, 51615, Error
#define XEVENT_MGMT_INIT_FAILURE 0xC000C99F

// XEVENT_COMMON_CONFIG_291, 51616, Error
#define XEVENT_COMMON_CONFIG_291 0xC000C9A0

// XEVENT_COMMON_CONFIG_292, 51617, Error
#define XEVENT_COMMON_CONFIG_292 0xC000C9A1

// XEVENT_COMMON_CONFIG_293, 51618, Error
#define XEVENT_COMMON_CONFIG_293 0xC000C9A2

// XEVENT_MGMT_INIT_FAILURE_1, 51619, Error
#define XEVENT_MGMT_INIT_FAILURE_1 0xC000C9A3

// XEVENT_MGMT_INIT_FAILURE_2, 51620, Error
#define XEVENT_MGMT_INIT_FAILURE_2 0xC000C9A4

// XEVENT_MGMT_INIT_FAILURE_3, 51621, Error
#define XEVENT_MGMT_INIT_FAILURE_3 0xC000C9A5

// XEVENT_MGMT_INIT_WARNING, 51622, Warning
#define XEVENT_MGMT_INIT_WARNING 0x8000C9A6

// XEVENT_MGMT_INIT_FAILURE_4, 51623, Error
#define XEVENT_MGMT_INIT_FAILURE_4 0xC000C9A7

// XEVENT_MGMT_SRV_DISCONNECT, 51624, Error
#define XEVENT_MGMT_SRV_DISCONNECT 0xC000C9A8

// XEVENT_MGMT_SRV_DISCONNECT_1, 51625, Error
#define XEVENT_MGMT_SRV_DISCONNECT_1 0xC000C9A9

// XEVENT_MGMT_INIT_FAILURE_5, 51626, Error
#define XEVENT_MGMT_INIT_FAILURE_5 0xC000C9AA

// XEVENT_MGMT_INIT_FAILURE_6, 51627, Error
#define XEVENT_MGMT_INIT_FAILURE_6 0xC000C9AB

// XEVENT_MGMT_SUBCOMPONENT_WARNING, 51628, Error
#define XEVENT_MGMT_SUBCOMPONENT_WARNING 0xC000C9AC

// XEVENT_MGMT_SUBCOMPONENT_WARNING_1, 51629, Error
#define XEVENT_MGMT_SUBCOMPONENT_WARNING_1 0xC000C9AD

// XEVENT_MGMT_SUBCOMPONENT_WARNING_2, 51630, Error
#define XEVENT_MGMT_SUBCOMPONENT_WARNING_2 0xC000C9AE

// XEVENT_MGMT_SUBCOMPONENT_WARNING_3, 51631, Error
#define XEVENT_MGMT_SUBCOMPONENT_WARNING_3 0xC000C9AF

// XEVENT_COMMON_CONFIG_307, 51632, Error
#define XEVENT_COMMON_CONFIG_307 0xC000C9B0

// XEVENT_MGMT_SUBCOMPONENT_WARNING_4, 51633, Error
#define XEVENT_MGMT_SUBCOMPONENT_WARNING_4 0xC000C9B1

// XEVENT_MGMT_SUBCOMPONENT_WARNING_5, 51634, Error
#define XEVENT_MGMT_SUBCOMPONENT_WARNING_5 0xC000C9B2

// XEVENT_COMMON_CONFIG_310, 51635, Error
#define XEVENT_COMMON_CONFIG_310 0xC000C9B3

// XEVENT_COMMON_CONFIG_311, 51636, Error
#define XEVENT_COMMON_CONFIG_311 0xC000C9B4

// XEVENT_MGMT_SUBCOMPONENT_WARNING_6, 51637, Error
#define XEVENT_MGMT_SUBCOMPONENT_WARNING_6 0xC000C9B5

// XEVENT_MGMT_SUBCOMPONENT_WARNING_7, 51638, Error
#define XEVENT_MGMT_SUBCOMPONENT_WARNING_7 0xC000C9B6

// XEVENT_MGMT_SUBCOMPONENT_WARNING_8, 51639, Error
#define XEVENT_MGMT_SUBCOMPONENT_WARNING_8 0xC000C9B7

// XEVENT_MGMT_SUBCOMPONENT_WARNING_9, 51640, Error
#define XEVENT_MGMT_SUBCOMPONENT_WARNING_9 0xC000C9B8

// XEVENT_MGMT_SUBCOMPONENT_WARNING_10, 51641, Error
#define XEVENT_MGMT_SUBCOMPONENT_WARNING_10 0xC000C9B9

// XEVENT_MGMT_REMOTE_TARGET_WARNING, 51642, Warning
#define XEVENT_MGMT_REMOTE_TARGET_WARNING 0x8000C9BA

// XEVENT_COMMON_CONFIG_318, 51643, Error
#define XEVENT_COMMON_CONFIG_318 0xC000C9BB

// XEVENT_COMMON_CONFIG_319, 51644, Error
#define XEVENT_COMMON_CONFIG_319 0xC000C9BC

// XEVENT_COMMON_CONFIG_320, 51645, Error
#define XEVENT_COMMON_CONFIG_320 0xC000C9BD

// XEVENT_COMMON_CONFIG_321, 51646, Error
#define XEVENT_COMMON_CONFIG_321 0xC000C9BE

// XEVENT_COMMON_CONFIG_322, 51647, Error
#define XEVENT_COMMON_CONFIG_322 0xC000C9BF

// XEVENT_COMMON_CONFIG_323, 51648, Error
#define XEVENT_COMMON_CONFIG_323 0xC000C9C0

// XEVENT_COMMON_CONFIG_324, 51649, Error
#define XEVENT_COMMON_CONFIG_324 0xC000C9C1

// XEVENT_COMMON_CONFIG_325, 51650, Error
#define XEVENT_COMMON_CONFIG_325 0xC000C9C2

// XEVENT_COMMON_CONFIG_326, 51651, Error
#define XEVENT_COMMON_CONFIG_326 0xC000C9C3

// XEVENT_COMMON_CONFIG_327, 51652, Error
#define XEVENT_COMMON_CONFIG_327 0xC000C9C4

// XEVENT_COMMON_CONFIG_328, 51653, Error
#define XEVENT_COMMON_CONFIG_328 0xC000C9C5

// XEVENT_COMMON_CONFIG_329, 51654, Error
#define XEVENT_COMMON_CONFIG_329 0xC000C9C6

// XEVENT_COMMON_CONFIG_330, 51655, Error
#define XEVENT_COMMON_CONFIG_330 0xC000C9C7

// XEVENT_COMMON_CONFIG_331, 51656, Error
#define XEVENT_COMMON_CONFIG_331 0xC000C9C8

// XEVENT_COMMON_CONFIG_332, 51657, Error
#define XEVENT_COMMON_CONFIG_332 0xC000C9C9

// XEVENT_COMMON_CONFIG_333, 51658, Error
#define XEVENT_COMMON_CONFIG_333 0xC000C9CA

// XEVENT_COMMON_CONFIG_334, 51659, Error
#define XEVENT_COMMON_CONFIG_334 0xC000C9CB

// XEVENT_COMMON_CONFIG_335, 51660, Error
#define XEVENT_COMMON_CONFIG_335 0xC000C9CC

// XEVENT_COMMON_CONFIG_336, 51661, Error
#define XEVENT_COMMON_CONFIG_336 0xC000C9CD

// XEVENT_COMMON_CONFIG_337, 51662, Error
#define XEVENT_COMMON_CONFIG_337 0xC000C9CE

// XEVENT_COMMON_CONFIG_338, 51663, Error
#define XEVENT_COMMON_CONFIG_338 0xC000C9CF

// XEVENT_COMMON_CONFIG_339, 51664, Error
#define XEVENT_COMMON_CONFIG_339 0xC000C9D0

// XEVENT_MGMT_INIT_FAILURE_7, 51665, Error
#define XEVENT_MGMT_INIT_FAILURE_7 0xC000C9D1

// XEVENT_MGMT_INIT_FAILURE_8, 51666, Error
#define XEVENT_MGMT_INIT_FAILURE_8 0xC000C9D2

// XEVENT_MGMT_INIT_FAILURE_9, 51667, Error
#define XEVENT_MGMT_INIT_FAILURE_9 0xC000C9D3

// XEVENT_COMMON_CONFIG_INTEROP_REPORTMESSAGECOMPONENTID_FAILURE, 51668, Error
#define XEVENT_COMMON_CONFIG_INTEROP_REPORTMESSAGECOMPONENTID_FAILURE 0xC000C9D4

// XEVENT_COMMON_CONFIG_INTEROP_ADDREPORTMESSAGECOMPONENTIDMAPPING_FAILURE, 51669, Error
#define XEVENT_COMMON_CONFIG_INTEROP_ADDREPORTMESSAGECOMPONENTIDMAPPING_FAILURE 0xC000C9D5

// XEVENT_COMMON_CONFIG_INTEROP_REPORTMESSAGECLEANSERVIRTUALINTERFACE_FAILURE, 51670, Error
#define XEVENT_COMMON_CONFIG_INTEROP_REPORTMESSAGECLEANSERVIRTUALINTERFACE_FAILURE 0xC000C9D6

// XEVENT_COMMON_CONFIG_340, 51671, Error
#define XEVENT_COMMON_CONFIG_340 0xC000C9D7

// XEVENT_MGMT_READ_FAILURE, 51672, Error
#define XEVENT_MGMT_READ_FAILURE 0xC000C9D8

// XEVENT_COMMON_CONFIG_BAD_XLAST_FILE, 51674, Error
#define XEVENT_COMMON_CONFIG_BAD_XLAST_FILE 0xC000C9DA

// XEVENT_COMMON_CONFIG_MATCH_LTC_TIB_COUNTS_OUTOFSYNC, 51675, Error
#define XEVENT_COMMON_CONFIG_MATCH_LTC_TIB_COUNTS_OUTOFSYNC 0xC000C9DB

// XEVENT_COMMON_CONFIG_MATCH_LTC_TIB_SERVERS_OUTOFSYNC_1, 51676, Error
#define XEVENT_COMMON_CONFIG_MATCH_LTC_TIB_SERVERS_OUTOFSYNC_1 0xC000C9DC

// XEVENT_COMMON_CONFIG_MATCH_LTC_TIB_SERVERS_OUTOFSYNC_2, 51677, Error
#define XEVENT_COMMON_CONFIG_MATCH_LTC_TIB_SERVERS_OUTOFSYNC_2 0xC000C9DD

// XEVENT_COMMON_CONFIG_MATCH_LTC_TIB_OUTOFSYNC, 51678, Error
#define XEVENT_COMMON_CONFIG_MATCH_LTC_TIB_OUTOFSYNC 0xC000C9DE

// XEVENT_COMMON_CONFIG_MATCH_UNEXPECTED_MODE_IN_XLAST, 51679, Error
#define XEVENT_COMMON_CONFIG_MATCH_UNEXPECTED_MODE_IN_XLAST 0xC000C9DF

// XEVENT_COMMON_CONFIG_MATCH_MISSING_MODE_IN_XLAST, 51680, Error
#define XEVENT_COMMON_CONFIG_MATCH_MISSING_MODE_IN_XLAST 0xC000C9E0

// XEVENT_COMMON_CONFIG_MATCH_ENDMIGRATE_FAILED_NONEXT, 51681, Error
#define XEVENT_COMMON_CONFIG_MATCH_ENDMIGRATE_FAILED_NONEXT 0xC000C9E1

// XEVENT_COMMON_CONFIG_MATCH_ENDMIGRATE_FAILED_MISSING_BUCKET, 51682, Error
#define XEVENT_COMMON_CONFIG_MATCH_ENDMIGRATE_FAILED_MISSING_BUCKET 0xC000C9E2

// XEVENT_COMMON_CONFIG_MATCH_EXPMIGRATE_FAILED_NOTSTARTED, 51683, Error
#define XEVENT_COMMON_CONFIG_MATCH_EXPMIGRATE_FAILED_NOTSTARTED 0xC000C9E3

// XEVENT_COMMON_CONFIG_MATCH_ENDMIGRATE_FAILED_LTC_TIB_OUTOFSYNC, 51684, Error
#define XEVENT_COMMON_CONFIG_MATCH_ENDMIGRATE_FAILED_LTC_TIB_OUTOFSYNC 0xC000C9E4

// XEVENT_COMMON_CONFIG_MATCH_ADDRR_FAILED_MISSING_BUCKET, 51685, Error
#define XEVENT_COMMON_CONFIG_MATCH_ADDRR_FAILED_MISSING_BUCKET 0xC000C9E5

// XEVENT_COMMON_CONFIG_MATCH_ADDRR_FAILED_DUPE_SERVER, 51686, Error
#define XEVENT_COMMON_CONFIG_MATCH_ADDRR_FAILED_DUPE_SERVER 0xC000C9E6

// XEVENT_COMMON_CONFIG_MATCH_UPDLTC_INVALID_LTC, 51687, Error
#define XEVENT_COMMON_CONFIG_MATCH_UPDLTC_INVALID_LTC 0xC000C9E7

// XEVENT_COMMON_CONFIG_MATCH_DEFAULTBUCKETS_OVERWRITE, 51688, Error
#define XEVENT_COMMON_CONFIG_MATCH_DEFAULTBUCKETS_OVERWRITE 0xC000C9E8

// XEVENT_COMMON_CONFIG_MATCH_CONFIRMSERVER_BADSERVER, 51689, Error
#define XEVENT_COMMON_CONFIG_MATCH_CONFIRMSERVER_BADSERVER 0xC000C9E9

// XEVENT_COMMON_CONFIG_MATCH_PREPLTC_TID_MISMATCH, 51690, Error
#define XEVENT_COMMON_CONFIG_MATCH_PREPLTC_TID_MISMATCH 0xC000C9EA

// XEVENT_COMMON_CONFIG_MATCH_NO_PARTMAP, 51691, Error
#define XEVENT_COMMON_CONFIG_MATCH_NO_PARTMAP 0xC000C9EB

// XEVENT_COMMON_CONFIG_MATCH_PREPCONFIG_TID_MISMATCH, 51692, Error
#define XEVENT_COMMON_CONFIG_MATCH_PREPCONFIG_TID_MISMATCH 0xC000C9EC

// XEVENT_COMMON_CONFIG_GET_REFRESH_FUNCTIONS, 51693, Error
#define XEVENT_COMMON_CONFIG_GET_REFRESH_FUNCTIONS 0xC000C9ED

// XEVENT_COMMON_CONFIG_HEALTH_CHANGE, 51694, Error
#define XEVENT_COMMON_CONFIG_HEALTH_CHANGE 0xC000C9EE

// XEVENT_COMMON_SETTING_BATCH_CONSTRUCTION, 51695, Error
#define XEVENT_COMMON_SETTING_BATCH_CONSTRUCTION 0xC000C9EF

// XEVENT_COMMON_SETTING_BATCH_QUERY, 51696, Error
#define XEVENT_COMMON_SETTING_BATCH_QUERY 0xC000C9F0

// XEVENT_COMMON_SETTING_BATCH_SETTING_DELETED, 51697, Error
#define XEVENT_COMMON_SETTING_BATCH_SETTING_DELETED 0xC000C9F1

// XEVENT_COMMON_CONFIG_REGISTER_DYNAMIC_SETTING_FAILURE, 51698, Error
#define XEVENT_COMMON_CONFIG_REGISTER_DYNAMIC_SETTING_FAILURE 0xC000C9F2

// XEVENT_COMMON_BUCKETS_BATCH_CONSTRUCTION, 51699, Error
#define XEVENT_COMMON_BUCKETS_BATCH_CONSTRUCTION 0xC000C9F3

// XEVENT_COMMON_BUCKET_BATCH_QUERY, 51700, Error
#define XEVENT_COMMON_BUCKET_BATCH_QUERY 0xC000C9F4

// XEVENT_COMMON_BUCKET_BATCH_DELETED, 51701, Error
#define XEVENT_COMMON_BUCKET_BATCH_DELETED 0xC000C9F5

// XEVENT_COMMON_CONFIG_LIVE_REGISTRY_SETTINGS_CHANGE, 51702, Error
#define XEVENT_COMMON_CONFIG_LIVE_REGISTRY_SETTINGS_CHANGE 0xC000C9F6

// XEVENT_PERFORMANCE_COUNTERS_0, 51703, Error
#define XEVENT_PERFORMANCE_COUNTERS_0 0xC000C9F7

// XEVENT_COMMON_HACK_4, 52329, Warning
#define XEVENT_COMMON_HACK_4 0x8000CC69

// XEVENT_COMMON_HACK_5, 52330, Warning
#define XEVENT_COMMON_HACK_5 0x8000CC6A

// XEVENT_COMMON_HACK_6, 52331, Warning
#define XEVENT_COMMON_HACK_6 0x8000CC6B

// XEVENT_COMMON_HACK_7, 52332, Warning
#define XEVENT_COMMON_HACK_7 0x8000CC6C

// XEVENT_COMMON_HACK_8, 52333, Warning
#define XEVENT_COMMON_HACK_8 0x8000CC6D

// XEVENT_COMMON_HACK_9, 52334, Warning
#define XEVENT_COMMON_HACK_9 0x8000CC6E

// XEVENT_COMMON_HACK_10, 52335, Warning
#define XEVENT_COMMON_HACK_10 0x8000CC6F

// XEVENT_COMMON_HACK_11, 52336, Warning
#define XEVENT_COMMON_HACK_11 0x8000CC70

// XEVENT_COMMON_HACK_12, 52337, Warning
#define XEVENT_COMMON_HACK_12 0x8000CC71

// XEVENT_COMMON_HACK_13, 52338, Warning
#define XEVENT_COMMON_HACK_13 0x8000CC72

// XEVENT_COMMON_HACK_14, 52339, Warning
#define XEVENT_COMMON_HACK_14 0x8000CC73

// XEVENT_COMMON_HACK_15, 52340, Warning
#define XEVENT_COMMON_HACK_15 0x8000CC74

// XEVENT_COMMON_HACK_16, 52341, Warning
#define XEVENT_COMMON_HACK_16 0x8000CC75

// XEVENT_COMMON_HACK_17, 52342, Warning
#define XEVENT_COMMON_HACK_17 0x8000CC76

// XEVENT_COMMON_HACK_18, 52343, Warning
#define XEVENT_COMMON_HACK_18 0x8000CC77

// XEVENT_COMMON_HACK_19, 52344, Warning
#define XEVENT_COMMON_HACK_19 0x8000CC78

// XEVENT_COMMON_HACK_20, 52345, Warning
#define XEVENT_COMMON_HACK_20 0x8000CC79

// XEVENT_COMMON_HACK_21, 52346, Warning
#define XEVENT_COMMON_HACK_21 0x8000CC7A

// XEVENT_COMMON_HACK_22, 52347, Warning
#define XEVENT_COMMON_HACK_22 0x8000CC7B

// XEVENT_COMMON_HACK_23, 52348, Warning
#define XEVENT_COMMON_HACK_23 0x8000CC7C

// XEVENT_COMMON_HACK_24, 52349, Warning
#define XEVENT_COMMON_HACK_24 0x8000CC7D

// XEVENT_COMMON_HACK_25, 52350, Warning
#define XEVENT_COMMON_HACK_25 0x8000CC7E

// XEVENT_COMMON_HACK_26, 52351, Warning
#define XEVENT_COMMON_HACK_26 0x8000CC7F

// XEVENT_COMMON_HACK_27, 52352, Warning
#define XEVENT_COMMON_HACK_27 0x8000CC80

// XEVENT_COMMON_HACK_28, 52353, Warning
#define XEVENT_COMMON_HACK_28 0x8000CC81

// XEVENT_COMMON_HACK_33, 52358, Warning
#define XEVENT_COMMON_HACK_33 0x8000CC86

// XEVENT_COMMON_HACK_34, 52359, Warning
#define XEVENT_COMMON_HACK_34 0x8000CC87

// XEVENT_COMMON_HACK_40, 52365, Warning
#define XEVENT_COMMON_HACK_40 0x8000CC8D

// XEVENT_AUTHDATA_BAD_TEAM_TICKETS, 52366, Warning
#define XEVENT_AUTHDATA_BAD_TEAM_TICKETS 0x8000CC8E

// XEVENT_AUTHDATA_BAD_TEAM_TICKETS_1, 52367, Warning
#define XEVENT_AUTHDATA_BAD_TEAM_TICKETS_1 0x8000CC8F

// XEVENT_AUTHDATA_BAD_TEAM_TICKETS_2, 52368, Warning
#define XEVENT_AUTHDATA_BAD_TEAM_TICKETS_2 0x8000CC90

// XEVENT_AUTHDATA_BAD_TEAM_TICKETS_3, 52369, Warning
#define XEVENT_AUTHDATA_BAD_TEAM_TICKETS_3 0x8000CC91

// XEVENT_AUTHDATA_BAD_TEAM_TICKETS_4, 52370, Warning
#define XEVENT_AUTHDATA_BAD_TEAM_TICKETS_4 0x8000CC92

// XEVENT_AUTHDATA_BAD_TEAM_TICKETS_5, 52371, Warning
#define XEVENT_AUTHDATA_BAD_TEAM_TICKETS_5 0x8000CC93

// XEVENT_AUTHDATA_BAD_TEAM_TICKETS_6, 52372, Warning
#define XEVENT_AUTHDATA_BAD_TEAM_TICKETS_6 0x8000CC94

// XEVENT_AUTHDATA_BAD_TEAM_TICKETS_7, 52373, Warning
#define XEVENT_AUTHDATA_BAD_TEAM_TICKETS_7 0x8000CC95

// XEVENT_AUTHDATA_BAD_BUNDLED_AUTHDATA, 52374, Warning
#define XEVENT_AUTHDATA_BAD_BUNDLED_AUTHDATA 0x8000CC96

// XEVENT_AUTHDATA_VERIFICATION_ERROR, 52375, Warning
#define XEVENT_AUTHDATA_VERIFICATION_ERROR 0x8000CC97

// XEVENT_AUTHDATA_VERIFICATION_ERROR_1, 52376, Warning
#define XEVENT_AUTHDATA_VERIFICATION_ERROR_1 0x8000CC98

// XEVENT_AUTHDATA_VERIFICATION_ERROR_2, 52377, Warning
#define XEVENT_AUTHDATA_VERIFICATION_ERROR_2 0x8000CC99

// XEVENT_AUTHDATA_BAD_HTTP_AUTHDATA, 52378, Warning
#define XEVENT_AUTHDATA_BAD_HTTP_AUTHDATA 0x8000CC9A

// XEVENT_AUTHDATA_BAD_SG_AUTHDATA, 52379, Warning
#define XEVENT_AUTHDATA_BAD_SG_AUTHDATA 0x8000CC9B

// XEVENT_AUTHDATA_BAD_SG_AUTHDATA_1, 52380, Warning
#define XEVENT_AUTHDATA_BAD_SG_AUTHDATA_1 0x8000CC9C

// XEVENT_AUTHDATA_BAD_SG_AUTHDATA_2, 52381, Warning
#define XEVENT_AUTHDATA_BAD_SG_AUTHDATA_2 0x8000CC9D

// XEVENT_AUTHDATA_BAD_SG_AUTHDATA_3, 52382, Warning
#define XEVENT_AUTHDATA_BAD_SG_AUTHDATA_3 0x8000CC9E

// XEVENT_AUTHDATA_BAD_SG_AUTHDATA_4, 52383, Warning
#define XEVENT_AUTHDATA_BAD_SG_AUTHDATA_4 0x8000CC9F

// XEVENT_AUTHDATA_BAD_SG_AUTHDATA_5, 52384, Warning
#define XEVENT_AUTHDATA_BAD_SG_AUTHDATA_5 0x8000CCA0

// XEVENT_AUTHDATA_VERIFICATION_ERROR_3, 52385, Warning
#define XEVENT_AUTHDATA_VERIFICATION_ERROR_3 0x8000CCA1

// XEVENT_COMMON_HACK_61, 52386, Warning
#define XEVENT_COMMON_HACK_61 0x8000CCA2

// XEVENT_AUTHDATA_VERIFICATION_ERROR_4, 52387, Warning
#define XEVENT_AUTHDATA_VERIFICATION_ERROR_4 0x8000CCA3

// XEVENT_AUTHDATA_VERIFICATION_ERROR_5, 52388, Warning
#define XEVENT_AUTHDATA_VERIFICATION_ERROR_5 0x8000CCA4

// XEVENT_COMMON_HACK_64, 52389, Warning
#define XEVENT_COMMON_HACK_64 0x8000CCA5

// XEVENT_COMMON_HACK_65, 52390, Warning
#define XEVENT_COMMON_HACK_65 0x8000CCA6

// XEVENT_COMMON_HACK_66, 52391, Warning
#define XEVENT_COMMON_HACK_66 0x8000CCA7

// XEVENT_COMMON_HACK_67, 52392, Warning
#define XEVENT_COMMON_HACK_67 0x8000CCA8

// XEVENT_COMMON_HACK_68, 52393, Warning
#define XEVENT_COMMON_HACK_68 0x8000CCA9

// XEVENT_COMMON_HACK_69, 52394, Warning
#define XEVENT_COMMON_HACK_69 0x8000CCAA

// XEVENT_COMMON_HACK_70, 52395, Warning
#define XEVENT_COMMON_HACK_70 0x8000CCAB

// XEVENT_AUTHDATA_VERIFICATION_ERROR_6, 52396, Warning
#define XEVENT_AUTHDATA_VERIFICATION_ERROR_6 0x8000CCAC

// XEVENT_COMMON_HACK_72, 52397, Warning
#define XEVENT_COMMON_HACK_72 0x8000CCAD

// XEVENT_AUTHDATA_VERIFICATION_ERROR_7, 52398, Warning
#define XEVENT_AUTHDATA_VERIFICATION_ERROR_7 0x8000CCAE

// XEVENT_AUTHDATA_VERIFICATION_ERROR_8, 52399, Warning
#define XEVENT_AUTHDATA_VERIFICATION_ERROR_8 0x8000CCAF

// XEVENT_AUTHDATA_VERIFICATION_ERROR_9, 52400, Warning
#define XEVENT_AUTHDATA_VERIFICATION_ERROR_9 0x8000CCB0

// XEVENT_COMMON_HACK_76, 52401, Warning
#define XEVENT_COMMON_HACK_76 0x8000CCB1

// XEVENT_WIREDATA_END_OF_STREAM, 52402, Warning
#define XEVENT_WIREDATA_END_OF_STREAM 0x8000CCB2

// XEVENT_COMMON_HACK_78, 52403, Warning
#define XEVENT_COMMON_HACK_78 0x8000CCB3

// XEVENT_COMMON_HACK_79, 52404, Warning
#define XEVENT_COMMON_HACK_79 0x8000CCB4

// XEVENT_COMMON_HACK_80, 52405, Warning
#define XEVENT_COMMON_HACK_80 0x8000CCB5

// XEVENT_HACK_CONTENT_NOT_FOUND, 52406, Warning
#define XEVENT_HACK_CONTENT_NOT_FOUND 0x8000CCB6

// XEVENT_USER_AGENT_MISSING, 52412, Error
#define XEVENT_USER_AGENT_MISSING 0xC000CCBC

// XEVENT_USER_AGENT_INVALID, 52413, Error
#define XEVENT_USER_AGENT_INVALID 0xC000CCBD

// XEVENT_AAINFO_INVALID_REQUEST, 52414, Error
#define XEVENT_AAINFO_INVALID_REQUEST 0xC000CCBE

// XEVENT_COMMON_HACK_81, 52415, Error
#define XEVENT_COMMON_HACK_81 0xC000CCBF

// XEVENT_AUTHDATA_VERIFICATION_ERROR_10, 52416, Error
#define XEVENT_AUTHDATA_VERIFICATION_ERROR_10 0xC000CCC0

// XEVENT_COMMON_INFO_4, 52529, Info
#define XEVENT_COMMON_INFO_4 0x4000CD31

// XEVENT_COMMON_INFO_5, 52530, Info
#define XEVENT_COMMON_INFO_5 0x4000CD32

// XEVENT_COMMON_INFO_6, 52531, Info
#define XEVENT_COMMON_INFO_6 0x4000CD33

// XEVENT_COMMON_INFO_7, 52532, Info
#define XEVENT_COMMON_INFO_7 0x4000CD34

// XEVENT_COMMON_INFO_8, 52533, Info
#define XEVENT_COMMON_INFO_8 0x4000CD35

// XEVENT_COMMON_INFO_9, 52534, Info
#define XEVENT_COMMON_INFO_9 0x4000CD36

// XEVENT_COMMON_INFO_10, 52535, Info
#define XEVENT_COMMON_INFO_10 0x4000CD37

// XEVENT_COMMON_INFO_11, 52536, Info
#define XEVENT_COMMON_INFO_11 0x4000CD38

// XEVENT_COMMON_INFO_12, 52537, Info
#define XEVENT_COMMON_INFO_12 0x4000CD39

// XEVENT_COMMON_INFO_13, 52538, Info
#define XEVENT_COMMON_INFO_13 0x4000CD3A

// XEVENT_COMMON_INFO_14, 52539, Info
#define XEVENT_COMMON_INFO_14 0x4000CD3B

// XEVENT_COMMON_INFO_15, 52540, Info
#define XEVENT_COMMON_INFO_15 0x4000CD3C

// XEVENT_COMMON_INFO_16, 52541, Info
#define XEVENT_COMMON_INFO_16 0x4000CD3D

// XEVENT_COMMON_INFO_17, 52542, Info
#define XEVENT_COMMON_INFO_17 0x4000CD3E

// XEVENT_COMMON_INFO_18, 52543, Info
#define XEVENT_COMMON_INFO_18 0x4000CD3F

// XEVENT_COMMON_INFO_19, 52544, Info
#define XEVENT_COMMON_INFO_19 0x4000CD40

// XEVENT_COMMON_INFO_20, 52545, Info
#define XEVENT_COMMON_INFO_20 0x4000CD41

// XEVENT_COMMON_INFO_21, 52546, Info
#define XEVENT_COMMON_INFO_21 0x4000CD42

// XEVENT_COMMON_INFO_22, 52547, Info
#define XEVENT_COMMON_INFO_22 0x4000CD43

// XEVENT_COMMON_INFO_23, 52548, Info
#define XEVENT_COMMON_INFO_23 0x4000CD44

// XEVENT_COMMON_INFO_24, 52549, Info
#define XEVENT_COMMON_INFO_24 0x4000CD45

// XEVENT_COMMON_INFO_25, 52550, Info
#define XEVENT_COMMON_INFO_25 0x4000CD46

// XEVENT_COMMON_INFO_26, 52551, Info
#define XEVENT_COMMON_INFO_26 0x4000CD47

// XEVENT_COMMON_INFO_27, 52552, Info
#define XEVENT_COMMON_INFO_27 0x4000CD48

// XEVENT_COMMON_INFO_28, 52553, Info
#define XEVENT_COMMON_INFO_28 0x4000CD49

// XEVENT_COMMON_INFO_29, 52554, Info
#define XEVENT_COMMON_INFO_29 0x4000CD4A

// XEVENT_COMMON_INFO_30, 52555, Info
#define XEVENT_COMMON_INFO_30 0x4000CD4B

// XEVENT_COMMON_INFO_31, 52556, Info
#define XEVENT_COMMON_INFO_31 0x4000CD4C

// XEVENT_COMMON_INFO_32, 52557, Info
#define XEVENT_COMMON_INFO_32 0x4000CD4D

// XEVENT_COMMON_INFO_33, 52558, Info
#define XEVENT_COMMON_INFO_33 0x4000CD4E

// XEVENT_COMMON_INFO_34, 52559, Info
#define XEVENT_COMMON_INFO_34 0x4000CD4F

// XEVENT_COMMON_INFO_35, 52560, Info
#define XEVENT_COMMON_INFO_35 0x4000CD50

// XEVENT_COMMON_INFO_36, 52561, Info
#define XEVENT_COMMON_INFO_36 0x4000CD51

// XEVENT_COMMON_INFO_37, 52562, Info
#define XEVENT_COMMON_INFO_37 0x4000CD52

// XEVENT_COMMON_INFO_38, 52563, Info
#define XEVENT_COMMON_INFO_38 0x4000CD53

// XEVENT_COMMON_INFO_39, 52564, Info
#define XEVENT_COMMON_INFO_39 0x4000CD54

// XEVENT_COMMON_INFO_40, 52565, Info
#define XEVENT_COMMON_INFO_40 0x4000CD55

// XEVENT_MC_APPDOMAIN_STARTED, 52566, Info
#define XEVENT_MC_APPDOMAIN_STARTED 0x4000CD56

// XEVENT_MC_APPDOMAIN_STARTED_1, 52567, Info
#define XEVENT_MC_APPDOMAIN_STARTED_1 0x4000CD57

// XEVENT_COMMON_INFO_43, 52568, Info
#define XEVENT_COMMON_INFO_43 0x4000CD58

// XEVENT_COMMON_INFO_44, 52569, Info
#define XEVENT_COMMON_INFO_44 0x4000CD59

// XEVENT_COMMON_INFO_45, 52570, Info
#define XEVENT_COMMON_INFO_45 0x4000CD5A

// XEVENT_COMMON_INFO_46, 52571, Info
#define XEVENT_COMMON_INFO_46 0x4000CD5B

// XEVENT_COMMON_INFO_47, 52572, Info
#define XEVENT_COMMON_INFO_47 0x4000CD5C

// XEVENT_COMMON_INFO_48, 52573, Info
#define XEVENT_COMMON_INFO_48 0x4000CD5D

// XEVENT_MGMT_SRV_CONNECTED, 52574, Info
#define XEVENT_MGMT_SRV_CONNECTED 0x4000CD5E

// XEVENT_REPORTINGTARGET_RECONNECTED, 52575, Info
#define XEVENT_REPORTINGTARGET_RECONNECTED 0x4000CD5F

// XEVENT_CONFIG_CHANGE_PROCESSED, 52576, Info
#define XEVENT_CONFIG_CHANGE_PROCESSED 0x4000CD60

// XEVENT_HEALTH_REPORT_GREEN, 52577, Info
#define XEVENT_HEALTH_REPORT_GREEN 0x4000CD61

// XEVENT_COMMON_CONFIG_INFO_HEALTH_CHANGE, 52578, Info
#define XEVENT_COMMON_CONFIG_INFO_HEALTH_CHANGE 0x4000CD62

// XEVENT_COMMON_SETTING_BATCH_COUNT, 52579, Info
#define XEVENT_COMMON_SETTING_BATCH_COUNT 0x4000CD63

// XEVENT_COMMON_BUCKET_COUNT, 52580, Info
#define XEVENT_COMMON_BUCKET_COUNT 0x4000CD64

// XEVENT_COMMON_CONFIG_INFO_LIVE_REGISTRY_SETTINGS_CHANGE, 52581, Info
#define XEVENT_COMMON_CONFIG_INFO_LIVE_REGISTRY_SETTINGS_CHANGE 0x4000CD65

// XEVENT_COMMON_WARNING_0, 52725, Warning
#define XEVENT_COMMON_WARNING_0 0x8000CDF5

// XEVENT_HEALTH_REPORT_YELLOW, 52726, Warning
#define XEVENT_HEALTH_REPORT_YELLOW 0x8000CDF6

// XEVENT_AUDIT_INVALID_SUBSYSTEM, 63800, Error
#define XEVENT_AUDIT_INVALID_SUBSYSTEM 0xC000F938

// XEVENT_AUDIT_NO_SETTING, 63801, Error
#define XEVENT_AUDIT_NO_SETTING 0xC000F939

// XEVENT_AUDIT_LOG_FAILURE, 63802, Error
#define XEVENT_AUDIT_LOG_FAILURE 0xC000F93A

// XEVENT_MIX_COMMON_UNKNOWN_ERROR, 63083, Error
#define XEVENT_MIX_COMMON_UNKNOWN_ERROR 0xC000F66B

// XEVENT_MIX_COMMON_ENTITYFRAMEWORK_CONNECTION_ERROR, 63084, Error
#define XEVENT_MIX_COMMON_ENTITYFRAMEWORK_CONNECTION_ERROR 0xC000F66C

// XEVENT_MC_BAD_CODE_15, 63085, Error
#define XEVENT_MC_BAD_CODE_15 0xC000F66D

// XEVENT_MC_BAD_CODE_16, 63086, Error
#define XEVENT_MC_BAD_CODE_16 0xC000F66E

// XEVENT_COMMON_USER_1, 63087, Error
#define XEVENT_COMMON_USER_1 0xC000F66F

// XEVENT_COMMON_USER_2, 63089, Error
#define XEVENT_COMMON_USER_2 0xC000F671

// XEVENT_COMMON_USER_3, 63090, Error
#define XEVENT_COMMON_USER_3 0xC000F672

// XEVENT_COMMON_CATALOG_1, 63091, Error
#define XEVENT_COMMON_CATALOG_1 0xC000F673

// XEVENT_QUERY_PLUGIN_DATA_ERROR, 52750, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR 0xC000CE0E

// XEVENT_QUERY_PLUGIN_DATA_ERROR_1, 52751, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_1 0xC000CE0F

// XEVENT_QUERY_PLUGIN_DATA_ERROR_2, 52752, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_2 0xC000CE10

// XEVENT_QUERY_PLUGIN_DATA_ERROR_3, 52753, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_3 0xC000CE11

// XEVENT_QUERY_PLUGIN_DATA_ERROR_4, 52754, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_4 0xC000CE12

// XEVENT_QUERY_PLUGIN_DATA_ERROR_5, 52755, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_5 0xC000CE13

// XEVENT_QUERY_PLUGIN_DATA_ERROR_6, 52756, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_6 0xC000CE14

// XEVENT_QUERY_PLUGIN_DATA_ERROR_7, 52757, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_7 0xC000CE15

// XEVENT_QUERY_PLUGIN_DATA_ERROR_8, 52758, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_8 0xC000CE16

// XEVENT_QUERY_PLUGIN_DATA_ERROR_9, 52759, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_9 0xC000CE17

// XEVENT_QUERY_PLUGIN_DATA_ERROR_10, 52760, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_10 0xC000CE18

// XEVENT_QUERY_PLUGIN_DATA_ERROR_11, 52761, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_11 0xC000CE19

// XEVENT_QUERY_PLUGIN_DATA_ERROR_12, 52762, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_12 0xC000CE1A

// XEVENT_QUERY_PLUGIN_DATA_ERROR_13, 52763, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_13 0xC000CE1B

// XEVENT_QUERY_PLUGIN_DATA_ERROR_14, 52764, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_14 0xC000CE1C

// XEVENT_QUERY_PLUGIN_DATA_ERROR_15, 52765, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_15 0xC000CE1D

// XEVENT_QUERY_PLUGIN_DATA_ERROR_16, 52766, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_16 0xC000CE1E

// XEVENT_QUERY_PLUGIN_DATA_ERROR_17, 52767, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_17 0xC000CE1F

// XEVENT_QUERY_PLUGIN_DATA_ERROR_18, 52768, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_18 0xC000CE20

// XEVENT_QUERY_PLUGIN_DATA_ERROR_19, 52769, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_19 0xC000CE21

// XEVENT_QUERY_PLUGIN_DATA_ERROR_20, 52770, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_20 0xC000CE22

// XEVENT_QUERY_PLUGIN_DATA_ERROR_21, 52771, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_21 0xC000CE23

// XEVENT_QUERY_PLUGIN_DATA_ERROR_22, 52772, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_22 0xC000CE24

// XEVENT_QUERY_PLUGIN_DATA_ERROR_23, 52773, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_23 0xC000CE25

// XEVENT_QUERY_PLUGIN_DATA_ERROR_24, 52774, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_24 0xC000CE26

// XEVENT_QUERY_PLUGIN_DATA_ERROR_25, 52775, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_25 0xC000CE27

// XEVENT_QUERY_PLUGIN_DATA_ERROR_26, 52776, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_26 0xC000CE28

// XEVENT_QUERY_PLUGIN_DATA_ERROR_27, 52777, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_27 0xC000CE29

// XEVENT_QUERY_PLUGIN_DATA_ERROR_28, 52778, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_28 0xC000CE2A

// XEVENT_QUERY_PLUGIN_DATA_ERROR_29, 52779, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_29 0xC000CE2B

// XEVENT_QUERY_PLUGIN_DATA_ERROR_30, 52780, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_30 0xC000CE2C

// XEVENT_QUERY_PLUGIN_DATA_ERROR_31, 52781, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_31 0xC000CE2D

// XEVENT_QUERY_PLUGIN_DATA_ERROR_32, 52782, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_32 0xC000CE2E

// XEVENT_QUERY_PLUGIN_DATA_ERROR_33, 52783, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_33 0xC000CE2F

// XEVENT_QUERY_PLUGIN_DATA_ERROR_34, 52784, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_34 0xC000CE30

// XEVENT_QUERY_PLUGIN_DATA_ERROR_35, 52785, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_35 0xC000CE31

// XEVENT_QUERY_PLUGIN_DATA_ERROR_36, 52786, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_36 0xC000CE32

// XEVENT_QUERY_PLUGIN_DATA_ERROR_37, 52787, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_37 0xC000CE33

// XEVENT_MC_BAD_PARAMETER_4, 52788, Error
#define XEVENT_MC_BAD_PARAMETER_4 0xC000CE34

// XEVENT_MC_BAD_PARAMETER_5, 52789, Error
#define XEVENT_MC_BAD_PARAMETER_5 0xC000CE35

// XEVENT_QUERY_PLUGIN_DATA_ERROR_38, 52790, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_38 0xC000CE36

// XEVENT_QUERY_PLUGIN_DATA_ERROR_39, 52791, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_39 0xC000CE37

// XEVENT_QUERY_PLUGIN_DATA_ERROR_40, 52792, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_40 0xC000CE38

// XEVENT_QUERY_PLUGIN_DATA_ERROR_41, 52793, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_41 0xC000CE39

// XEVENT_QUERY_PLUGIN_DATA_ERROR_42, 52794, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_42 0xC000CE3A

// XEVENT_QUERY_PLUGIN_DATA_ERROR_43, 52795, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_43 0xC000CE3B

// XEVENT_QUERY_PLUGIN_DATA_ERROR_44, 52796, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_44 0xC000CE3C

// XEVENT_QUERY_PLUGIN_DATA_ERROR_45, 52797, Error
#define XEVENT_QUERY_PLUGIN_DATA_ERROR_45 0xC000CE3D

// XEVENT_COMPS_CODE_48, 52798, Error
#define XEVENT_COMPS_CODE_48 0xC000CE3E

// XEVENT_COMPS_CODE_49, 52799, Error
#define XEVENT_COMPS_CODE_49 0xC000CE3F

// XEVENT_COMPS_CODE_50, 52800, Error
#define XEVENT_COMPS_CODE_50 0xC000CE40

// XEVENT_COMPS_CODE_51, 52801, Error
#define XEVENT_COMPS_CODE_51 0xC000CE41

// XEVENT_MC_XRL_REQUEST_ERROR_1, 52850, Error
#define XEVENT_MC_XRL_REQUEST_ERROR_1 0xC000CE72

// XEVENT_MC_XRL_REQUEST_ERROR_2, 52851, Error
#define XEVENT_MC_XRL_REQUEST_ERROR_2 0xC000CE73

// XEVENT_MC_XRL_REQUEST_ERROR_3, 52852, Error
#define XEVENT_MC_XRL_REQUEST_ERROR_3 0xC000CE74

// XEVENT_QUERY_BAD_DATA, 52875, Error
#define XEVENT_QUERY_BAD_DATA 0xC000CE8B

// XEVENT_QUERY_BAD_DATA_1, 52876, Error
#define XEVENT_QUERY_BAD_DATA_1 0xC000CE8C

// XEVENT_QUERY_SERVER_HEALTH_WARNING, 52877, Warning
#define XEVENT_QUERY_SERVER_HEALTH_WARNING 0x8000CE8D

// XEVENT_QUERY_BAD_DATA_2, 52878, Error
#define XEVENT_QUERY_BAD_DATA_2 0xC000CE8E

// XEVENT_QUERY_PLUGIN_CONFIG_ERROR, 52879, Error
#define XEVENT_QUERY_PLUGIN_CONFIG_ERROR 0xC000CE8F

// XEVENT_QUERY_PLUGIN_CONFIG_ERROR_1, 52880, Error
#define XEVENT_QUERY_PLUGIN_CONFIG_ERROR_1 0xC000CE90

// XEVENT_QUERY_BAD_DATA_3, 52881, Error
#define XEVENT_QUERY_BAD_DATA_3 0xC000CE91

// XEVENT_QUERY_BAD_DATA_4, 52882, Error
#define XEVENT_QUERY_BAD_DATA_4 0xC000CE92

// XEVENT_QUERY_BAD_DATA_5, 52883, Error
#define XEVENT_QUERY_BAD_DATA_5 0xC000CE93

// XEVENT_QUERY_BAD_DATA_6, 52884, Error
#define XEVENT_QUERY_BAD_DATA_6 0xC000CE94

// XEVENT_COMPS_CONFIG_10, 52885, Error
#define XEVENT_COMPS_CONFIG_10 0xC000CE95

// XEVENT_MGMT_TITLE_LOG_ERROR, 52886, Error
#define XEVENT_MGMT_TITLE_LOG_ERROR 0xC000CE96

// XEVENT_MGMT_TITLE_LOG_ERROR_1, 52887, Error
#define XEVENT_MGMT_TITLE_LOG_ERROR_1 0xC000CE97

// XEVENT_CRON_CONFIG_FAILURE, 52888, Error
#define XEVENT_CRON_CONFIG_FAILURE 0xC000CE98

// XEVENT_CRON_CONFIG_FAILURE_1, 52889, Error
#define XEVENT_CRON_CONFIG_FAILURE_1 0xC000CE99

// XEVENT_QUERY_SERVER_HEALTH_WARNING_1, 52890, Warning
#define XEVENT_QUERY_SERVER_HEALTH_WARNING_1 0x8000CE9A

// XEVENT_QUERY_PLUGIN_CONFIG_ERROR_2, 52891, Error
#define XEVENT_QUERY_PLUGIN_CONFIG_ERROR_2 0xC000CE9B

// XEVENT_QUERY_BAD_DATA_7, 52892, Error
#define XEVENT_QUERY_BAD_DATA_7 0xC000CE9C

// XEVENT_QUERY_BAD_DATA_8, 52893, Error
#define XEVENT_QUERY_BAD_DATA_8 0xC000CE9D

// XEVENT_QUERY_PLUGIN_DATA_INFO, 52925, Info
#define XEVENT_QUERY_PLUGIN_DATA_INFO 0x4000CEBD

// XEVENT_COMPS_TITLEBUG_0, 52950, Error
#define XEVENT_COMPS_TITLEBUG_0 0xC000CED6

// XEVENT_CRON_JOB_FAILURE, 15000, Error
#define XEVENT_CRON_JOB_FAILURE 0xC0003A98

// XEVENT_CRON_PLUGIN_XMGMT_REGISTRATION_FAILURE, 15001, Warning
#define XEVENT_CRON_PLUGIN_XMGMT_REGISTRATION_FAILURE 0x80003A99

// XEVENT_CRON_UNEXPECTED_ERROR, 52975, Error
#define XEVENT_CRON_UNEXPECTED_ERROR 0xC000CEEF

// XEVENT_CRON_UNEXPECTED_ERROR_1, 52976, Error
#define XEVENT_CRON_UNEXPECTED_ERROR_1 0xC000CEF0

// XEVENT_CRON_CODE_2, 52977, Error
#define XEVENT_CRON_CODE_2 0xC000CEF1

// XEVENT_CRON_CODE_3, 52978, Error
#define XEVENT_CRON_CODE_3 0xC000CEF2

// XEVENT_CRON_DB_FAILURE, 53000, Error
#define XEVENT_CRON_DB_FAILURE 0xC000CF08

// XEVENT_CRON_DB_FAILURE_1, 53001, Error
#define XEVENT_CRON_DB_FAILURE_1 0xC000CF09

// XEVENT_CRON_DB_FAILURE_2, 53002, Error
#define XEVENT_CRON_DB_FAILURE_2 0xC000CF0A

// XEVENT_CRON_DB_FAILURE_3, 53003, Error
#define XEVENT_CRON_DB_FAILURE_3 0xC000CF0B

// XEVENT_CRON_DB_FAILURE_4, 53004, Error
#define XEVENT_CRON_DB_FAILURE_4 0xC000CF0C

// XEVENT_CRON_DB_FAILURE_5, 53005, Error
#define XEVENT_CRON_DB_FAILURE_5 0xC000CF0D

// XEVENT_CRON_DB_FAILURE_6, 53006, Error
#define XEVENT_CRON_DB_FAILURE_6 0xC000CF0E

// XEVENT_CRON_DB_FAILURE_7, 53007, Error
#define XEVENT_CRON_DB_FAILURE_7 0xC000CF0F

// XEVENT_CRON_CONFIG_FAILURE_2, 53025, Error
#define XEVENT_CRON_CONFIG_FAILURE_2 0xC000CF21

// XEVENT_CRON_CONFIG_FAILURE_3, 53026, Error
#define XEVENT_CRON_CONFIG_FAILURE_3 0xC000CF22

// XEVENT_CRON_CONFIG_FAILURE_4, 53027, Error
#define XEVENT_CRON_CONFIG_FAILURE_4 0xC000CF23

// XEVENT_QUERY_PLUGIN_CREATION_ERROR, 53028, Error
#define XEVENT_QUERY_PLUGIN_CREATION_ERROR 0xC000CF24

// XEVENT_CRUX_CODE_1, 62550, Warning
#define XEVENT_CRUX_CODE_1 0x8000F456

// XEVENT_CRUX_CODE_2, 62551, Warning
#define XEVENT_CRUX_CODE_2 0x8000F457

// XEVENT_CRUX_MUSICNET_KEY_LOAD_ERROR, 62552, Error
#define XEVENT_CRUX_MUSICNET_KEY_LOAD_ERROR 0xC000F458

// XEVENT_EVENTSINK_CODE_0, 53050, Error
#define XEVENT_EVENTSINK_CODE_0 0xC000CF3A

// XEVENT_EVENTSINK_CODE_1, 53051, Error
#define XEVENT_EVENTSINK_CODE_1 0xC000CF3B

// XEVENT_EVENTSINK_CODE_2, 53052, Error
#define XEVENT_EVENTSINK_CODE_2 0xC000CF3C

// XEVENT_EVENTSINK_COMM_0, 53075, Error
#define XEVENT_EVENTSINK_COMM_0 0xC000CF53

// XEVENT_ESP_ENGINE_EXCEPTION, 1001, Error
#define XEVENT_ESP_ENGINE_EXCEPTION 0xC00003E9

// XEVENT_FEEDBACK_CODE_0, 53100, Error
#define XEVENT_FEEDBACK_CODE_0 0xC000CF6C

// XEVENT_FEEDBACK_CODE_1, 53101, Error
#define XEVENT_FEEDBACK_CODE_1 0xC000CF6D

// XEVENT_FEEDBACK_CODE_2, 53102, Error
#define XEVENT_FEEDBACK_CODE_2 0xC000CF6E

// XEVENT_FEEDBACK_CODE_3, 53103, Error
#define XEVENT_FEEDBACK_CODE_3 0xC000CF6F

// XEVENT_FEEDBACK_CODE_4, 53104, Error
#define XEVENT_FEEDBACK_CODE_4 0xC000CF70

// XEVENT_FEEDBACK_CODE_5, 53105, Error
#define XEVENT_FEEDBACK_CODE_5 0xC000CF71

// XEVENT_FEEDBACK_CODE_6, 53106, Error
#define XEVENT_FEEDBACK_CODE_6 0xC000CF72

// XEVENT_FEEDBACK_CODE_7, 53107, Error
#define XEVENT_FEEDBACK_CODE_7 0xC000CF73

// XEVENT_FEEDBACK_CONFIG_0, 53125, Warning
#define XEVENT_FEEDBACK_CONFIG_0 0x8000CF85

// XEVENT_FEEDBACK_CONFIG_1, 53126, Warning
#define XEVENT_FEEDBACK_CONFIG_1 0x8000CF86

// XEVENT_FEEDBACK_CONFIG_2, 53127, Warning
#define XEVENT_FEEDBACK_CONFIG_2 0x8000CF87

// XEVENT_FEEDBACK_CONFIG_3, 53128, Warning
#define XEVENT_FEEDBACK_CONFIG_3 0x8000CF88

// XEVENT_FEEDBACK_CONFIG_4, 53129, Warning
#define XEVENT_FEEDBACK_CONFIG_4 0x8000CF89

// XEVENT_FEEDBACK_CONFIG_5, 53130, Warning
#define XEVENT_FEEDBACK_CONFIG_5 0x8000CF8A

// XEVENT_FEEDBACK_CONFIG_6, 53131, Warning
#define XEVENT_FEEDBACK_CONFIG_6 0x8000CF8B

// XEVENT_FEEDBACK_HACK_0, 53150, Warning
#define XEVENT_FEEDBACK_HACK_0 0x8000CF9E

// XEVENT_FEEDBACK_HACK_1, 53151, Warning
#define XEVENT_FEEDBACK_HACK_1 0x8000CF9F

// XEVENT_FEEDBACK_HACK_2, 53152, Warning
#define XEVENT_FEEDBACK_HACK_2 0x8000CFA0

// XEVENT_FEEDBACK_HACK_3, 53153, Warning
#define XEVENT_FEEDBACK_HACK_3 0x8000CFA1

// XEVENT_FEEDBACK_HACK_4, 53154, Warning
#define XEVENT_FEEDBACK_HACK_4 0x8000CFA2

// XEVENT_FEEDBACK_HACK_5, 53155, Warning
#define XEVENT_FEEDBACK_HACK_5 0x8000CFA3

// XEVENT_FEEDBACK_HACK_6, 53156, Warning
#define XEVENT_FEEDBACK_HACK_6 0x8000CFA4

// XEVENT_FEEDBACK_HACK_7, 53157, Warning
#define XEVENT_FEEDBACK_HACK_7 0x8000CFA5

// XEVENT_FEEDBACK_HACK_8, 53158, Warning
#define XEVENT_FEEDBACK_HACK_8 0x8000CFA6

// XEVENT_FEEDBACK_HACK_9, 53159, Warning
#define XEVENT_FEEDBACK_HACK_9 0x8000CFA7

// XEVENT_FEEDBACK_HACK_10, 53160, Warning
#define XEVENT_FEEDBACK_HACK_10 0x8000CFA8

// XEVENT_FEEDBACK_HACK_11, 53161, Warning
#define XEVENT_FEEDBACK_HACK_11 0x8000CFA9

// XEVENT_FEEDBACK_HACK_12, 53162, Warning
#define XEVENT_FEEDBACK_HACK_12 0x8000CFAA

// XEVENT_FEEDBACK_HACK_13, 53163, Warning
#define XEVENT_FEEDBACK_HACK_13 0x8000CFAB

// XEVENT_FEEDBACK_HACK_14, 53164, Warning
#define XEVENT_FEEDBACK_HACK_14 0x8000CFAC

// XEVENT_FEEDBACK_INFO_0, 53200, Info
#define XEVENT_FEEDBACK_INFO_0 0x4000CFD0

// XEVENT_FEEDBACK_INFO_1, 53201, Info
#define XEVENT_FEEDBACK_INFO_1 0x4000CFD1

// XEVENT_FINBUS_PUBLISHER_STARTED, 15000, Info
#define XEVENT_FINBUS_PUBLISHER_STARTED 0x40003A98

// XEVENT_FINBUS_PUBLISHER_SHUTDOWN_STARTED, 15001, Info
#define XEVENT_FINBUS_PUBLISHER_SHUTDOWN_STARTED 0x40003A99

// XEVENT_FINBUS_PUBLISHER_SHUTDOWN_COMPLETE, 15002, Info
#define XEVENT_FINBUS_PUBLISHER_SHUTDOWN_COMPLETE 0x40003A9A

// XEVENT_FINBUS_PUBLISHER_STARTUP_ERROR, 15003, Error
#define XEVENT_FINBUS_PUBLISHER_STARTUP_ERROR 0xC0003A9B

// XEVENT_FINBUS_PUBLISHER_SHUTDOWN_ERROR, 15004, Error
#define XEVENT_FINBUS_PUBLISHER_SHUTDOWN_ERROR 0xC0003A9C

// XEVENT_FINBUS_PUBLISHER_PUBLISH_MESSAGE_ERROR, 15005, Error
#define XEVENT_FINBUS_PUBLISHER_PUBLISH_MESSAGE_ERROR 0xC0003A9D

// XEVENT_FINBUS_PUBLISHER_GET_PENDING_ITEMS_ERROR, 15006, Error
#define XEVENT_FINBUS_PUBLISHER_GET_PENDING_ITEMS_ERROR 0xC0003A9E

// XEVENT_FINBUS_PUBLISHER_RECORD_ITEM_FAILURE_ERROR, 15007, Error
#define XEVENT_FINBUS_PUBLISHER_RECORD_ITEM_FAILURE_ERROR 0xC0003A9F

// XEVENT_FINBUS_PUBLISHER_UNHANDLED_EXCEPTION_ERROR, 15008, Error
#define XEVENT_FINBUS_PUBLISHER_UNHANDLED_EXCEPTION_ERROR 0xC0003AA0

// XEVENT_KDC_CONFIG_KDCMANAGEDPROXY_INIT, 10000, Error
#define XEVENT_KDC_CONFIG_KDCMANAGEDPROXY_INIT 0xC0002710

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_1, 10001, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_1 0xC0002711

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_2, 10002, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_2 0xC0002712

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_3, 10003, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_3 0xC0002713

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_4, 10004, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_4 0xC0002714

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_5, 10005, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_5 0xC0002715

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_6, 10006, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_6 0xC0002716

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_7, 10007, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_7 0xC0002717

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_8, 10008, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_8 0xC0002718

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_9, 10009, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_9 0xC0002719

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_10, 10010, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_10 0xC000271A

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_11, 10011, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_11 0xC000271B

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_12, 10012, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_12 0xC000271C

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_13, 10013, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_13 0xC000271D

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_14, 10014, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_14 0xC000271E

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_15, 10015, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_15 0xC000271F

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_16, 10016, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_16 0xC0002720

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_17, 10017, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_17 0xC0002721

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_18, 10018, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_18 0xC0002722

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_19, 10019, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_19 0xC0002723

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_20, 10020, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_20 0xC0002724

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_21, 10021, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_21 0xC0002725

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_22, 10022, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_22 0xC0002726

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_23, 10023, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_23 0xC0002727

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_24, 10024, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_24 0xC0002728

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_25, 10025, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_25 0xC0002729

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_26, 10026, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_26 0xC000272A

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_27, 10027, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_27 0xC000272B

// XEVENT_KDC_CONFIG_HEALTHINTEROP_CREATE, 10028, Error
#define XEVENT_KDC_CONFIG_HEALTHINTEROP_CREATE 0xC000272C

// XEVENT_KDC_CONFIG_HEALTHINTEROP_INIT, 10029, Error
#define XEVENT_KDC_CONFIG_HEALTHINTEROP_INIT 0xC000272D

// XEVENT_KDC_KDCMANAGEDPROXY_BAD_OFFER_XML, 10030, Warning
#define XEVENT_KDC_KDCMANAGEDPROXY_BAD_OFFER_XML 0x8000272E

// XEVENT_KDC_KDCMANAGEDPROXY_FAILED_SET_CONSOLE_REGION, 10031, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_FAILED_SET_CONSOLE_REGION 0xC000272F

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_28, 10032, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_28 0xC0002730

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_29, 10033, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_29 0xC0002731

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_30, 10034, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_30 0xC0002732

// XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_31, 10035, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_INTEROP_31 0xC0002733

// XEVENT_KDC_KDCMANAGEDPROXY_DBLIMITER_THROTTLED_PARTITION, 10036, Warning
#define XEVENT_KDC_KDCMANAGEDPROXY_DBLIMITER_THROTTLED_PARTITION 0x80002734

// XEVENT_KDC_KDCMANAGEDPROXY_PASSPORT_INIT_FAILURE, 10037, Error
#define XEVENT_KDC_KDCMANAGEDPROXY_PASSPORT_INIT_FAILURE 0xC0002735

// XEVENT_KDC_BASE_AUDIT_TICKET_RENEWAL, 53305, Error
#define XEVENT_KDC_BASE_AUDIT_TICKET_RENEWAL 0xC000D039

// XEVENT_KDC_BASE_BAD_KERBCRYPT_1, 53306, Error
#define XEVENT_KDC_BASE_BAD_KERBCRYPT_1 0xC000D03A

// XEVENT_KDC_BASE_BAD_ETYPE, 53307, Error
#define XEVENT_KDC_BASE_BAD_ETYPE 0xC000D03B

// XEVENT_KDC_CODE_83, 53308, Error
#define XEVENT_KDC_CODE_83 0xC000D03C

// XEVENT_KDC_CODE_84, 53309, Error
#define XEVENT_KDC_CODE_84 0xC000D03D

// XEVENT_KDC_CODE_85, 53310, Error
#define XEVENT_KDC_CODE_85 0xC000D03E

// XEVENT_KDC_BASE_NO_MEMORY, 53311, Error
#define XEVENT_KDC_BASE_NO_MEMORY 0xC000D03F

// XEVENT_KDC_BASE_NO_MEMORY_1, 53312, Error
#define XEVENT_KDC_BASE_NO_MEMORY_1 0xC000D040

// XEVENT_KDC_CODE_88, 53313, Error
#define XEVENT_KDC_CODE_88 0xC000D041

// XEVENT_KDC_CODE_89, 53314, Error
#define XEVENT_KDC_CODE_89 0xC000D042

// XEVENT_KDC_CODE_90, 53315, Error
#define XEVENT_KDC_CODE_90 0xC000D043

// XEVENT_KDC_BASE_PATYPE_UNEXPECTED, 53673, Error
#define XEVENT_KDC_BASE_PATYPE_UNEXPECTED 0xC000D1A9

// XEVENT_KDC_BASE_PATYPE_NOTFOUND, 53674, Error
#define XEVENT_KDC_BASE_PATYPE_NOTFOUND 0xC000D1AA

// XEVENT_KDC_PERFCOUNTER_INIT_ERROR, 54233, Error
#define XEVENT_KDC_PERFCOUNTER_INIT_ERROR 0xC000D3D9

// XEVENT_KDC_CONFIG_25, 54275, Error
#define XEVENT_KDC_CONFIG_25 0xC000D403

// XEVENT_KDC_CONFIG_26, 54276, Error
#define XEVENT_KDC_CONFIG_26 0xC000D404

// XEVENT_KDC_CONFIG_27, 54277, Error
#define XEVENT_KDC_CONFIG_27 0xC000D405

// XEVENT_KDC_CONFIG_28, 54278, Error
#define XEVENT_KDC_CONFIG_28 0xC000D406

// XEVENT_KDC_CONFIG_29, 54279, Error
#define XEVENT_KDC_CONFIG_29 0xC000D407

// XEVENT_KDC_CONFIG_30, 54280, Error
#define XEVENT_KDC_CONFIG_30 0xC000D408

// XEVENT_KDC_CONFIG_31, 54281, Error
#define XEVENT_KDC_CONFIG_31 0xC000D409

// XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION, 54370, Error
#define XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION 0xC000D462

// XEVENT_KDC_HACK_6, 54656, Warning
#define XEVENT_KDC_HACK_6 0x8000D580

// XEVENT_KDC_HACK_7, 54657, Warning
#define XEVENT_KDC_HACK_7 0x8000D581

// XEVENT_KDC_HACK_8, 54658, Warning
#define XEVENT_KDC_HACK_8 0x8000D582

// XEVENT_KDC_BASE_UODB_CONNECTION_ESTABLISHED, 54758, Info
#define XEVENT_KDC_BASE_UODB_CONNECTION_ESTABLISHED 0x4000D5E6

// XEVENT_KDC_INFO_9, 54759, Info
#define XEVENT_KDC_INFO_9 0x4000D5E7

// XEVENT_LISTS_LOAD_SUCCESS, 63950, Info
#define XEVENT_LISTS_LOAD_SUCCESS 0x4000F9CE

// XEVENT_LISTS_LOAD_FAILURE, 63951, Error
#define XEVENT_LISTS_LOAD_FAILURE 0xC000F9CF

// XEVENT_LISTS_PROTOCOL_ERROR, 63952, Error
#define XEVENT_LISTS_PROTOCOL_ERROR 0xC000F9D0

// XEVENT_LISTS_XML_ERROR, 63953, Error
#define XEVENT_LISTS_XML_ERROR 0xC000F9D1

// XEVENT_LISTS_NONEXISTENT_LIST_TYPE, 63954, Error
#define XEVENT_LISTS_NONEXISTENT_LIST_TYPE 0xC000F9D2

// XEVENT_LISTS_NONEXISTENT_LIST_ID, 63955, Error
#define XEVENT_LISTS_NONEXISTENT_LIST_ID 0xC000F9D3

// XEVENT_LISTS_DATA_DRIVEN_ERROR, 63956, Warning
#define XEVENT_LISTS_DATA_DRIVEN_ERROR 0x8000F9D4

// XEVENT_LISTS_API_MISMATCH, 63957, Error
#define XEVENT_LISTS_API_MISMATCH 0xC000F9D5

// XEVENT_LIVECACHE_CODE_0, 54850, Error
#define XEVENT_LIVECACHE_CODE_0 0xC000D642

// XEVENT_LIVECACHE_CODE_1, 54851, Error
#define XEVENT_LIVECACHE_CODE_1 0xC000D643

// XEVENT_LIVECACHE_CODE_2, 54852, Error
#define XEVENT_LIVECACHE_CODE_2 0xC000D644

// XEVENT_LIVECACHE_CODE_3, 54853, Error
#define XEVENT_LIVECACHE_CODE_3 0xC000D645

// XEVENT_LIVECACHE_COMM_0, 54875, Error
#define XEVENT_LIVECACHE_COMM_0 0xC000D65B

// XEVENT_LIVECACHE_CONFIG_0, 54900, Error
#define XEVENT_LIVECACHE_CONFIG_0 0xC000D674

// XEVENT_LIVECACHE_CONFIG_1, 54901, Error
#define XEVENT_LIVECACHE_CONFIG_1 0xC000D675

// XEVENT_LIVECACHE_HACK_0, 54925, Warning
#define XEVENT_LIVECACHE_HACK_0 0x8000D68D

// XEVENT_LIVECACHE_HACK_1, 54926, Warning
#define XEVENT_LIVECACHE_HACK_1 0x8000D68E

// XEVENT_LIVECACHE_HACK_2, 54927, Warning
#define XEVENT_LIVECACHE_HACK_2 0x8000D68F

// XEVENT_LIVECACHE_HACK_3, 54928, Warning
#define XEVENT_LIVECACHE_HACK_3 0x8000D690

// XEVENT_LIVECACHE_HACK_4, 54929, Warning
#define XEVENT_LIVECACHE_HACK_4 0x8000D691

// XEVENT_GET_NETWORK_AUTHORIZATION_LIST_ERROR, 15000, Error
#define XEVENT_GET_NETWORK_AUTHORIZATION_LIST_ERROR 0xC0003A98

// XEVENT_GET_NETWORK_AUTHORIZATION_LIST_CONFIG_ERROR, 15001, Error
#define XEVENT_GET_NETWORK_AUTHORIZATION_LIST_CONFIG_ERROR 0xC0003A99

// XEVENT_GET_NETWORK_AUTHORIZATION_LIST_TITLE_NOT_ALLOWED, 15002, Error
#define XEVENT_GET_NETWORK_AUTHORIZATION_LIST_TITLE_NOT_ALLOWED 0xC0003A9A

// XEVENT_LIVEINFO_CLIENT_ERROR, 40000, Error
#define XEVENT_LIVEINFO_CLIENT_ERROR 0xC0009C40

// XEVENT_LIVEINFO_HIVE_HACK_ERROR_PROCESSING_REQUEST, 63975, Error
#define XEVENT_LIVEINFO_HIVE_HACK_ERROR_PROCESSING_REQUEST 0xC000F9E7

// XEVENT_LIVEINFO_HIVE_CONFIG_ERROR_LOADING, 63976, Error
#define XEVENT_LIVEINFO_HIVE_CONFIG_ERROR_LOADING 0xC000F9E8

// XEVENT_LIVEINFO_HIVE_CONFIG_ERROR_EMPTY_RESPONSE, 63977, Error
#define XEVENT_LIVEINFO_HIVE_CONFIG_ERROR_EMPTY_RESPONSE 0xC000F9E9

// XEVENT_LIVEINFO_HIVE_CONFIG_ERROR_TOO_LARGE_RESPONSE, 63978, Error
#define XEVENT_LIVEINFO_HIVE_CONFIG_ERROR_TOO_LARGE_RESPONSE 0xC000F9EA

// XEVENT_LIVEINFO_HIVE_CONFIG_ERROR_BAD_CONFIG_NAME, 63979, Error
#define XEVENT_LIVEINFO_HIVE_CONFIG_ERROR_BAD_CONFIG_NAME 0xC000F9EB

// XEVENT_WEBCACHE_CONTROL_REQUEST_ERROR, 53613, Error
#define XEVENT_WEBCACHE_CONTROL_REQUEST_ERROR 0xC000D16D

// XEVENT_MARKETPLACECATALOG_PARAMETER_MISSING, 35001, Error
#define XEVENT_MARKETPLACECATALOG_PARAMETER_MISSING 0xC00088B9

// XEVENT_MARKETPLACECATALOG_ERROR, 35002, Error
#define XEVENT_MARKETPLACECATALOG_ERROR 0xC00088BA

// XEVENT_MARKETPLACECATALOG_GUID_ERROR, 35003, Warning
#define XEVENT_MARKETPLACECATALOG_GUID_ERROR 0x800088BB

// XEVENT_MARKETPLACECATALOG_DETAIL_LEVEL_MISSING, 35004, Error
#define XEVENT_MARKETPLACECATALOG_DETAIL_LEVEL_MISSING 0xC00088BC

// XEVENT_XMATCHFD_WARN_GEN, 50869, Error
#define XEVENT_XMATCHFD_WARN_GEN 0xC000C6B5

// XEVENT_XMATCHFD_WARN_GEN_1, 50870, Error
#define XEVENT_XMATCHFD_WARN_GEN_1 0xC000C6B6

// XEVENT_XMATCHFD_WARN_GEN_2, 50872, Error
#define XEVENT_XMATCHFD_WARN_GEN_2 0xC000C6B8

// XEVENT_XMATCHFD_WARN_GEN_3, 50874, Error
#define XEVENT_XMATCHFD_WARN_GEN_3 0xC000C6BA

// XEVENT_XMATCHFD_WARN_GEN_4, 50875, Error
#define XEVENT_XMATCHFD_WARN_GEN_4 0xC000C6BB

// XEVENT_MATCH_CODE_0, 54950, Error
#define XEVENT_MATCH_CODE_0 0xC000D6A6

// XEVENT_MATCH_CODE_1, 54951, Error
#define XEVENT_MATCH_CODE_1 0xC000D6A7

// XEVENT_MATCH_CODE_2, 54952, Error
#define XEVENT_MATCH_CODE_2 0xC000D6A8

// XEVENT_MATCH_CODE_3, 54953, Error
#define XEVENT_MATCH_CODE_3 0xC000D6A9

// XEVENT_MATCH_CODE_4, 54954, Error
#define XEVENT_MATCH_CODE_4 0xC000D6AA

// XEVENT_MATCH_CODE_5, 54955, Error
#define XEVENT_MATCH_CODE_5 0xC000D6AB

// XEVENT_MATCH_CODE_6, 54956, Error
#define XEVENT_MATCH_CODE_6 0xC000D6AC

// XEVENT_MATCH_CODE_7, 54957, Error
#define XEVENT_MATCH_CODE_7 0xC000D6AD

// XEVENT_MATCH_CODE_8, 54958, Error
#define XEVENT_MATCH_CODE_8 0xC000D6AE

// XEVENT_MATCH_CODE_9, 54959, Error
#define XEVENT_MATCH_CODE_9 0xC000D6AF

// XEVENT_MATCH_CODE_10, 54960, Error
#define XEVENT_MATCH_CODE_10 0xC000D6B0

// XEVENT_MATCH_CODE_11, 54961, Error
#define XEVENT_MATCH_CODE_11 0xC000D6B1

// XEVENT_MATCH_CODE_12, 54962, Error
#define XEVENT_MATCH_CODE_12 0xC000D6B2

// XEVENT_MATCH_CODE_13, 54963, Error
#define XEVENT_MATCH_CODE_13 0xC000D6B3

// XEVENT_MATCH_CODE_14, 54964, Error
#define XEVENT_MATCH_CODE_14 0xC000D6B4

// XEVENT_MATCH_CODE_15, 54965, Error
#define XEVENT_MATCH_CODE_15 0xC000D6B5

// XEVENT_MATCH_CODE_16, 54966, Error
#define XEVENT_MATCH_CODE_16 0xC000D6B6

// XEVENT_MATCH_CODE_17, 54967, Error
#define XEVENT_MATCH_CODE_17 0xC000D6B7

// XEVENT_MATCH_CODE_18, 54968, Error
#define XEVENT_MATCH_CODE_18 0xC000D6B8

// XEVENT_MATCH_CODE_19, 54969, Error
#define XEVENT_MATCH_CODE_19 0xC000D6B9

// XEVENT_MATCH_CODE_20, 54970, Error
#define XEVENT_MATCH_CODE_20 0xC000D6BA

// XEVENT_MATCH_CODE_21, 54971, Error
#define XEVENT_MATCH_CODE_21 0xC000D6BB

// XEVENT_MATCH_CODE_22, 54972, Error
#define XEVENT_MATCH_CODE_22 0xC000D6BC

// XEVENT_MATCH_CODE_23, 54973, Error
#define XEVENT_MATCH_CODE_23 0xC000D6BD

// XEVENT_MATCH_CODE_24, 54974, Error
#define XEVENT_MATCH_CODE_24 0xC000D6BE

// XEVENT_MATCH_CODE_25, 54975, Error
#define XEVENT_MATCH_CODE_25 0xC000D6BF

// XEVENT_MATCH_CODE_26, 54976, Error
#define XEVENT_MATCH_CODE_26 0xC000D6C0

// XEVENT_MATCH_CODE_27, 54977, Error
#define XEVENT_MATCH_CODE_27 0xC000D6C1

// XEVENT_MATCH_CODE_28, 54978, Error
#define XEVENT_MATCH_CODE_28 0xC000D6C2

// XEVENT_MATCH_CODE_29, 54979, Error
#define XEVENT_MATCH_CODE_29 0xC000D6C3

// XEVENT_MATCH_CODE_30, 54980, Error
#define XEVENT_MATCH_CODE_30 0xC000D6C4

// XEVENT_MATCH_CODE_31, 54981, Error
#define XEVENT_MATCH_CODE_31 0xC000D6C5

// XEVENT_MATCH_CODE_32, 54982, Error
#define XEVENT_MATCH_CODE_32 0xC000D6C6

// XEVENT_MATCH_CODE_33, 54983, Error
#define XEVENT_MATCH_CODE_33 0xC000D6C7

// XEVENT_MATCH_CODE_34, 54984, Error
#define XEVENT_MATCH_CODE_34 0xC000D6C8

// XEVENT_MATCH_CODE_35, 54985, Error
#define XEVENT_MATCH_CODE_35 0xC000D6C9

// XEVENT_MATCH_CODE_36, 54986, Error
#define XEVENT_MATCH_CODE_36 0xC000D6CA

// XEVENT_MATCH_CODE_TITLECHANGE_ERROR, 54987, Error
#define XEVENT_MATCH_CODE_TITLECHANGE_ERROR 0xC000D6CB

// XEVENT_MATCH_CODE_SESSION_LIMIT_EXCEEDED, 54988, Error
#define XEVENT_MATCH_CODE_SESSION_LIMIT_EXCEEDED 0xC000D6CC

// XEVENT_MATCH_CODE_SESSION_LIMIT_APPROACHING, 54989, Error
#define XEVENT_MATCH_CODE_SESSION_LIMIT_APPROACHING 0xC000D6CD

// XEVENT_MATCH_COMM_0, 55050, Error
#define XEVENT_MATCH_COMM_0 0xC000D70A

// XEVENT_MATCH_COMM_1, 55051, Error
#define XEVENT_MATCH_COMM_1 0xC000D70B

// XEVENT_MATCH_COMM_FASTFAIL, 55052, Error
#define XEVENT_MATCH_COMM_FASTFAIL 0xC000D70C

// XEVENT_MATCH_COMM_OPEN_CONNECTION_FOR_INSERT, 55053, Error
#define XEVENT_MATCH_COMM_OPEN_CONNECTION_FOR_INSERT 0xC000D70D

// XEVENT_MATCH_COMM_EXECUTE_INSERT, 55054, Error
#define XEVENT_MATCH_COMM_EXECUTE_INSERT 0xC000D70E

// XEVENT_MATCH_COMM_UPDATE, 55055, Error
#define XEVENT_MATCH_COMM_UPDATE 0xC000D70F

// XEVENT_MATCH_COMM_DELETE, 55056, Error
#define XEVENT_MATCH_COMM_DELETE 0xC000D710

// XEVENT_MATCH_COMM_EXECUTE_FIND_XBOX, 55057, Error
#define XEVENT_MATCH_COMM_EXECUTE_FIND_XBOX 0xC000D711

// XEVENT_MATCH_COMM_EXECUTE_FINDBYID_XENON, 55058, Error
#define XEVENT_MATCH_COMM_EXECUTE_FINDBYID_XENON 0xC000D712

// XEVENT_MATCH_COMM_EXECUTE_FINDRANKED_XENON, 55059, Error
#define XEVENT_MATCH_COMM_EXECUTE_FINDRANKED_XENON 0xC000D713

// XEVENT_MATCH_COMM_EXECUTE_GET_NON_AFFILIATE_RESULTS, 55060, Error
#define XEVENT_MATCH_COMM_EXECUTE_GET_NON_AFFILIATE_RESULTS 0xC000D714

// XEVENT_MATCH_COMM_OPEN_CONNECTION, 55061, Error
#define XEVENT_MATCH_COMM_OPEN_CONNECTION 0xC000D715

// XEVENT_MATCH_COMM_EXECUTE_GET_AFFILIATE_RESULTS, 55062, Error
#define XEVENT_MATCH_COMM_EXECUTE_GET_AFFILIATE_RESULTS 0xC000D716

// XEVENT_MATCH_CONFIG_0, 55075, Error
#define XEVENT_MATCH_CONFIG_0 0xC000D723

// XEVENT_MATCH_CONFIG_1, 55076, Error
#define XEVENT_MATCH_CONFIG_1 0xC000D724

// XEVENT_MATCH_CONFIG_2, 55077, Error
#define XEVENT_MATCH_CONFIG_2 0xC000D725

// XEVENT_MATCH_CONFIG_3, 55078, Error
#define XEVENT_MATCH_CONFIG_3 0xC000D726

// XEVENT_MATCH_CONFIG_4, 55079, Error
#define XEVENT_MATCH_CONFIG_4 0xC000D727

// XEVENT_MATCH_CONFIG_5, 55080, Error
#define XEVENT_MATCH_CONFIG_5 0xC000D728

// XEVENT_MATCH_CONFIG_6, 55081, Error
#define XEVENT_MATCH_CONFIG_6 0xC000D729

// XEVENT_MATCH_CONFIG_7, 55082, Error
#define XEVENT_MATCH_CONFIG_7 0xC000D72A

// XEVENT_MATCH_CONFIG_8, 55083, Error
#define XEVENT_MATCH_CONFIG_8 0xC000D72B

// XEVENT_MATCH_CONFIG_9, 55084, Error
#define XEVENT_MATCH_CONFIG_9 0xC000D72C

// XEVENT_MATCH_CONFIG_10, 55085, Error
#define XEVENT_MATCH_CONFIG_10 0xC000D72D

// XEVENT_MATCH_CONFIG_11, 55086, Error
#define XEVENT_MATCH_CONFIG_11 0xC000D72E

// XEVENT_MATCH_CONFIG_12, 55087, Error
#define XEVENT_MATCH_CONFIG_12 0xC000D72F

// XEVENT_MATCH_CONFIG_13, 55088, Error
#define XEVENT_MATCH_CONFIG_13 0xC000D730

// XEVENT_MATCH_CONFIG_14, 55089, Error
#define XEVENT_MATCH_CONFIG_14 0xC000D731

// XEVENT_MATCH_CONFIG_15, 55090, Error
#define XEVENT_MATCH_CONFIG_15 0xC000D732

// XEVENT_MATCH_CONFIG_16, 55091, Error
#define XEVENT_MATCH_CONFIG_16 0xC000D733

// XEVENT_MATCH_CONFIG_17, 55092, Error
#define XEVENT_MATCH_CONFIG_17 0xC000D734

// XEVENT_MATCH_CONFIG_18, 55093, Error
#define XEVENT_MATCH_CONFIG_18 0xC000D735

// XEVENT_MATCH_CONFIG_19, 55094, Error
#define XEVENT_MATCH_CONFIG_19 0xC000D736

// XEVENT_MATCH_CONFIG_20, 55095, Error
#define XEVENT_MATCH_CONFIG_20 0xC000D737

// XEVENT_MATCH_CONFIG_21, 55096, Error
#define XEVENT_MATCH_CONFIG_21 0xC000D738

// XEVENT_MATCH_CONFIG_22, 55097, Error
#define XEVENT_MATCH_CONFIG_22 0xC000D739

// XEVENT_MATCH_CONFIG_23, 55098, Error
#define XEVENT_MATCH_CONFIG_23 0xC000D73A

// XEVENT_MATCH_CONFIG_24, 55099, Error
#define XEVENT_MATCH_CONFIG_24 0xC000D73B

// XEVENT_MATCH_CONFIG_25, 55100, Error
#define XEVENT_MATCH_CONFIG_25 0xC000D73C

// XEVENT_MATCH_CONFIG_26, 55101, Error
#define XEVENT_MATCH_CONFIG_26 0xC000D73D

// XEVENT_MATCH_CONFIG_27, 55102, Error
#define XEVENT_MATCH_CONFIG_27 0xC000D73E

// XEVENT_MATCH_CONFIG_28, 55103, Error
#define XEVENT_MATCH_CONFIG_28 0xC000D73F

// XEVENT_MATCH_CONFIG_29, 55104, Error
#define XEVENT_MATCH_CONFIG_29 0xC000D740

// XEVENT_MATCH_CONFIG_30, 55105, Error
#define XEVENT_MATCH_CONFIG_30 0xC000D741

// XEVENT_MATCH_CONFIG_31, 55106, Error
#define XEVENT_MATCH_CONFIG_31 0xC000D742

// XEVENT_MATCH_CONFIG_32, 55107, Error
#define XEVENT_MATCH_CONFIG_32 0xC000D743

// XEVENT_MATCH_CONFIG_33, 55108, Error
#define XEVENT_MATCH_CONFIG_33 0xC000D744

// XEVENT_MATCH_CONFIG_34, 55109, Error
#define XEVENT_MATCH_CONFIG_34 0xC000D745

// XEVENT_MATCH_CONFIG_35, 55110, Error
#define XEVENT_MATCH_CONFIG_35 0xC000D746

// XEVENT_MATCH_CONFIG_36, 55111, Error
#define XEVENT_MATCH_CONFIG_36 0xC000D747

// XEVENT_MATCH_CONFIG_37, 55112, Error
#define XEVENT_MATCH_CONFIG_37 0xC000D748

// XEVENT_MATCH_CONFIG_38, 55113, Error
#define XEVENT_MATCH_CONFIG_38 0xC000D749

// XEVENT_MATCH_CONFIG_39, 55114, Error
#define XEVENT_MATCH_CONFIG_39 0xC000D74A

// XEVENT_MATCH_CONFIG_40, 55115, Error
#define XEVENT_MATCH_CONFIG_40 0xC000D74B

// XEVENT_MATCH_CONFIG_41, 55116, Error
#define XEVENT_MATCH_CONFIG_41 0xC000D74C

// XEVENT_MATCH_CONFIG_42, 55117, Error
#define XEVENT_MATCH_CONFIG_42 0xC000D74D

// XEVENT_MATCH_CONFIG_43, 55118, Error
#define XEVENT_MATCH_CONFIG_43 0xC000D74E

// XEVENT_MATCH_CONFIG_44, 55119, Error
#define XEVENT_MATCH_CONFIG_44 0xC000D74F

// XEVENT_MATCH_CONFIG_45, 55120, Error
#define XEVENT_MATCH_CONFIG_45 0xC000D750

// XEVENT_MATCH_CONFIG_46, 55121, Error
#define XEVENT_MATCH_CONFIG_46 0xC000D751

// XEVENT_MATCH_CONFIG_47, 55122, Error
#define XEVENT_MATCH_CONFIG_47 0xC000D752

// XEVENT_MATCH_CONFIG_48, 55123, Error
#define XEVENT_MATCH_CONFIG_48 0xC000D753

// XEVENT_MATCH_CONFIG_49, 55124, Error
#define XEVENT_MATCH_CONFIG_49 0xC000D754

// XEVENT_MATCH_CONFIG_50, 55125, Error
#define XEVENT_MATCH_CONFIG_50 0xC000D755

// XEVENT_MATCH_CONFIG_51, 55126, Error
#define XEVENT_MATCH_CONFIG_51 0xC000D756

// XEVENT_MATCH_CONFIG_52, 55127, Error
#define XEVENT_MATCH_CONFIG_52 0xC000D757

// XEVENT_MATCH_CONFIG_53, 55128, Error
#define XEVENT_MATCH_CONFIG_53 0xC000D758

// XEVENT_MATCH_CONFIG_54, 55129, Error
#define XEVENT_MATCH_CONFIG_54 0xC000D759

// XEVENT_MATCH_CONFIG_55, 55130, Error
#define XEVENT_MATCH_CONFIG_55 0xC000D75A

// XEVENT_MATCH_CONFIG_56, 55131, Error
#define XEVENT_MATCH_CONFIG_56 0xC000D75B

// XEVENT_MATCH_CONFIG_57, 55132, Error
#define XEVENT_MATCH_CONFIG_57 0xC000D75C

// XEVENT_MATCH_CONFIG_58, 55133, Error
#define XEVENT_MATCH_CONFIG_58 0xC000D75D

// XEVENT_MATCH_CONFIG_59, 55134, Error
#define XEVENT_MATCH_CONFIG_59 0xC000D75E

// XEVENT_MATCH_CONFIG_60, 55135, Error
#define XEVENT_MATCH_CONFIG_60 0xC000D75F

// XEVENT_MATCH_CONFIG_61, 55136, Error
#define XEVENT_MATCH_CONFIG_61 0xC000D760

// XEVENT_MATCH_CONFIG_62, 55137, Error
#define XEVENT_MATCH_CONFIG_62 0xC000D761

// XEVENT_MATCH_CONFIG_63, 55138, Error
#define XEVENT_MATCH_CONFIG_63 0xC000D762

// XEVENT_MATCH_CONFIG_64, 55139, Error
#define XEVENT_MATCH_CONFIG_64 0xC000D763

// XEVENT_MATCH_CONFIG_65, 55140, Error
#define XEVENT_MATCH_CONFIG_65 0xC000D764

// XEVENT_MATCH_CONFIG_66, 55141, Error
#define XEVENT_MATCH_CONFIG_66 0xC000D765

// XEVENT_MATCH_CONFIG_67, 55142, Error
#define XEVENT_MATCH_CONFIG_67 0xC000D766

// XEVENT_MATCH_CONFIG_68, 55143, Error
#define XEVENT_MATCH_CONFIG_68 0xC000D767

// XEVENT_MATCH_CONFIG_69, 55144, Error
#define XEVENT_MATCH_CONFIG_69 0xC000D768

// XEVENT_MATCH_CONFIG_70, 55145, Error
#define XEVENT_MATCH_CONFIG_70 0xC000D769

// XEVENT_MATCH_CONFIG_71, 55152, Error
#define XEVENT_MATCH_CONFIG_71 0xC000D770

// XEVENT_MATCH_CONFIG_72, 55153, Error
#define XEVENT_MATCH_CONFIG_72 0xC000D771

// XEVENT_MATCH_CONFIG_73, 55154, Error
#define XEVENT_MATCH_CONFIG_73 0xC000D772

// XEVENT_MATCH_CONFIG_TOO_MANY_CROSS_PLATFORM_NODES, 55155, Error
#define XEVENT_MATCH_CONFIG_TOO_MANY_CROSS_PLATFORM_NODES 0xC000D773

// XEVENT_MATCH_CONFIG_LTC_ELEMENT_MISSING, 55156, Error
#define XEVENT_MATCH_CONFIG_LTC_ELEMENT_MISSING 0xC000D774

// XEVENT_MATCH_CONFIG_LTC_ELEMENT_TOO_MANY, 55157, Error
#define XEVENT_MATCH_CONFIG_LTC_ELEMENT_TOO_MANY 0xC000D775

// XEVENT_MATCH_CONFIG_LTC_ELEMENT_EMPTY, 55158, Error
#define XEVENT_MATCH_CONFIG_LTC_ELEMENT_EMPTY 0xC000D776

// XEVENT_MATCH_CONFIG_LTC_ELEMENT_PARSE_FAILED, 55159, Error
#define XEVENT_MATCH_CONFIG_LTC_ELEMENT_PARSE_FAILED 0xC000D777

// XEVENT_MATCH_HACK_0, 55275, Warning
#define XEVENT_MATCH_HACK_0 0x8000D7EB

// XEVENT_MATCH_HACK_1, 55276, Warning
#define XEVENT_MATCH_HACK_1 0x8000D7EC

// XEVENT_MATCH_HACK_2, 55277, Warning
#define XEVENT_MATCH_HACK_2 0x8000D7ED

// XEVENT_MATCH_HACK_3, 55278, Warning
#define XEVENT_MATCH_HACK_3 0x8000D7EE

// XEVENT_MATCH_HACK_4, 55279, Warning
#define XEVENT_MATCH_HACK_4 0x8000D7EF

// XEVENT_MATCH_HACK_5, 55280, Warning
#define XEVENT_MATCH_HACK_5 0x8000D7F0

// XEVENT_MATCH_HACK_6, 55281, Warning
#define XEVENT_MATCH_HACK_6 0x8000D7F1

// XEVENT_MATCH_HACK_7, 55282, Warning
#define XEVENT_MATCH_HACK_7 0x8000D7F2

// XEVENT_MATCH_HACK_8, 55283, Warning
#define XEVENT_MATCH_HACK_8 0x8000D7F3

// XEVENT_MATCH_HACK_9, 55284, Warning
#define XEVENT_MATCH_HACK_9 0x8000D7F4

// XEVENT_MATCH_HACK_10, 55285, Warning
#define XEVENT_MATCH_HACK_10 0x8000D7F5

// XEVENT_MATCH_HACK_11, 55286, Warning
#define XEVENT_MATCH_HACK_11 0x8000D7F6

// XEVENT_MATCH_HACK_12, 55287, Warning
#define XEVENT_MATCH_HACK_12 0x8000D7F7

// XEVENT_MATCH_HACK_13, 55288, Warning
#define XEVENT_MATCH_HACK_13 0x8000D7F8

// XEVENT_MATCH_HACK_14, 55289, Warning
#define XEVENT_MATCH_HACK_14 0x8000D7F9

// XEVENT_MATCH_HACK_15, 55290, Warning
#define XEVENT_MATCH_HACK_15 0x8000D7FA

// XEVENT_MATCH_HACK_16, 55291, Warning
#define XEVENT_MATCH_HACK_16 0x8000D7FB

// XEVENT_MATCH_HACK_17, 55292, Warning
#define XEVENT_MATCH_HACK_17 0x8000D7FC

// XEVENT_MATCH_HACK_18, 55293, Warning
#define XEVENT_MATCH_HACK_18 0x8000D7FD

// XEVENT_MATCH_HACK_19, 55294, Warning
#define XEVENT_MATCH_HACK_19 0x8000D7FE

// XEVENT_MATCH_HACK_20, 55295, Warning
#define XEVENT_MATCH_HACK_20 0x8000D7FF

// XEVENT_MATCH_HACK_21, 55296, Warning
#define XEVENT_MATCH_HACK_21 0x8000D800

// XEVENT_MATCH_HACK_22, 55297, Warning
#define XEVENT_MATCH_HACK_22 0x8000D801

// XEVENT_MATCH_HACK_23, 55298, Warning
#define XEVENT_MATCH_HACK_23 0x8000D802

// XEVENT_MATCH_HACK_24, 55299, Warning
#define XEVENT_MATCH_HACK_24 0x8000D803

// XEVENT_MATCH_HACK_25, 55300, Warning
#define XEVENT_MATCH_HACK_25 0x8000D804

// XEVENT_MATCH_HACK_26, 55301, Warning
#define XEVENT_MATCH_HACK_26 0x8000D805

// XEVENT_MATCH_HACK_27, 55302, Warning
#define XEVENT_MATCH_HACK_27 0x8000D806

// XEVENT_MATCH_HACK_28, 55303, Warning
#define XEVENT_MATCH_HACK_28 0x8000D807

// XEVENT_MATCH_HACK_29, 55304, Warning
#define XEVENT_MATCH_HACK_29 0x8000D808

// XEVENT_MATCH_HACK_30, 55305, Warning
#define XEVENT_MATCH_HACK_30 0x8000D809

// XEVENT_MATCH_HACK_31, 55306, Warning
#define XEVENT_MATCH_HACK_31 0x8000D80A

// XEVENT_MATCH_HACK_32, 55307, Warning
#define XEVENT_MATCH_HACK_32 0x8000D80B

// XEVENT_MATCH_HACK_33, 55308, Warning
#define XEVENT_MATCH_HACK_33 0x8000D80C

// XEVENT_MATCH_HACK_SPLIT_NUM_ATTR, 55309, Warning
#define XEVENT_MATCH_HACK_SPLIT_NUM_ATTR 0x8000D80D

// XEVENT_MATCH_HACK_SPLIT_END_OF_STREAM, 55310, Warning
#define XEVENT_MATCH_HACK_SPLIT_END_OF_STREAM 0x8000D80E

// XEVENT_MATCH_HACK_SESSION_NUM_ATTR, 55311, Warning
#define XEVENT_MATCH_HACK_SESSION_NUM_ATTR 0x8000D80F

// XEVENT_MATCH_HACK_SESSION_END_OF_STREAM, 55312, Warning
#define XEVENT_MATCH_HACK_SESSION_END_OF_STREAM 0x8000D810

// XEVENT_MATCH_HACK_SEARCH_NUM_PARAMS, 55313, Warning
#define XEVENT_MATCH_HACK_SEARCH_NUM_PARAMS 0x8000D811

// XEVENT_MATCH_HACK_SEARCH_END_OF_STREAM, 55314, Warning
#define XEVENT_MATCH_HACK_SEARCH_END_OF_STREAM 0x8000D812

// XEVENT_MATCH_HACK_MISMATCH_LANGUAGE_ATTR, 55315, Warning
#define XEVENT_MATCH_HACK_MISMATCH_LANGUAGE_ATTR 0x8000D813

// XEVENT_MATCH_HACK_MISMATCH_CLIENT_IPADDR, 55316, Warning
#define XEVENT_MATCH_HACK_MISMATCH_CLIENT_IPADDR 0x8000D814

// XEVENT_MATCH_HACK_SPLIT_SIZE_OVERFLOW, 55317, Warning
#define XEVENT_MATCH_HACK_SPLIT_SIZE_OVERFLOW 0x8000D815

// XEVENT_MATCH_HACK_XBOX1_PLATFORM_ATTRIBS, 55318, Warning
#define XEVENT_MATCH_HACK_XBOX1_PLATFORM_ATTRIBS 0x8000D816

// XEVENT_MATCH_INFO_0, 55375, Info
#define XEVENT_MATCH_INFO_0 0x4000D84F

// XEVENT_MATCH_TITLEBUG_0, 55400, Error
#define XEVENT_MATCH_TITLEBUG_0 0xC000D868

// XEVENT_MATCH_TITLEBUG_1, 55401, Error
#define XEVENT_MATCH_TITLEBUG_1 0xC000D869

// XEVENT_MATCH_TITLEBUG_2, 55402, Error
#define XEVENT_MATCH_TITLEBUG_2 0xC000D86A

// XEVENT_MATCH_TITLEBUG_3, 55403, Error
#define XEVENT_MATCH_TITLEBUG_3 0xC000D86B

// XEVENT_MATCH_TITLEBUG_4, 55404, Error
#define XEVENT_MATCH_TITLEBUG_4 0xC000D86C

// XEVENT_MATCH_TITLEBUG_5, 55405, Error
#define XEVENT_MATCH_TITLEBUG_5 0xC000D86D

// XEVENT_MATCH_TITLEBUG_6, 55406, Error
#define XEVENT_MATCH_TITLEBUG_6 0xC000D86E

// XEVENT_MATCH_TITLEBUG_7, 55407, Error
#define XEVENT_MATCH_TITLEBUG_7 0xC000D86F

// XEVENT_MATCH_TITLEBUG_8, 55408, Error
#define XEVENT_MATCH_TITLEBUG_8 0xC000D870

// XEVENT_MATCH_TITLEBUG_9, 55409, Error
#define XEVENT_MATCH_TITLEBUG_9 0xC000D871

// XEVENT_MATCH_TITLEBUG_10, 55410, Error
#define XEVENT_MATCH_TITLEBUG_10 0xC000D872

// XEVENT_MATCH_TITLEBUG_11, 55411, Error
#define XEVENT_MATCH_TITLEBUG_11 0xC000D873

// XEVENT_MATCH_TITLEBUG_12, 55412, Error
#define XEVENT_MATCH_TITLEBUG_12 0xC000D874

// XEVENT_MATCH_TITLEBUG_13, 55413, Error
#define XEVENT_MATCH_TITLEBUG_13 0xC000D875

// XEVENT_MATCH_TITLEBUG_14, 55414, Error
#define XEVENT_MATCH_TITLEBUG_14 0xC000D876

// XEVENT_MATCH_TITLEBUG_15, 55415, Error
#define XEVENT_MATCH_TITLEBUG_15 0xC000D877

// XEVENT_MATCH_TITLEBUG_16, 55416, Error
#define XEVENT_MATCH_TITLEBUG_16 0xC000D878

// XEVENT_MATCH_TITLEBUG_17, 55417, Error
#define XEVENT_MATCH_TITLEBUG_17 0xC000D879

// XEVENT_MATCH_TITLEBUG_18, 55418, Error
#define XEVENT_MATCH_TITLEBUG_18 0xC000D87A

// XEVENT_MATCH_TITLEBUG_19, 55419, Error
#define XEVENT_MATCH_TITLEBUG_19 0xC000D87B

// XEVENT_MATCH_TITLEBUG_20, 55420, Error
#define XEVENT_MATCH_TITLEBUG_20 0xC000D87C

// XEVENT_MATCH_TITLEBUG_21, 55421, Error
#define XEVENT_MATCH_TITLEBUG_21 0xC000D87D

// XEVENT_MATCH_TITLEBUG_22, 55422, Error
#define XEVENT_MATCH_TITLEBUG_22 0xC000D87E

// XEVENT_MATCH_TITLEBUG_23, 55423, Error
#define XEVENT_MATCH_TITLEBUG_23 0xC000D87F

// XEVENT_MATCH_TITLEBUG_24, 55424, Error
#define XEVENT_MATCH_TITLEBUG_24 0xC000D880

// XEVENT_MATCH_TITLEBUG_25, 55425, Error
#define XEVENT_MATCH_TITLEBUG_25 0xC000D881

// XEVENT_MATCH_TITLEBUG_26, 55426, Error
#define XEVENT_MATCH_TITLEBUG_26 0xC000D882

// XEVENT_MATCH_TITLEBUG_27, 55427, Error
#define XEVENT_MATCH_TITLEBUG_27 0xC000D883

// XEVENT_MATCH_TITLEBUG_28, 55428, Error
#define XEVENT_MATCH_TITLEBUG_28 0xC000D884

// XEVENT_MATCH_TITLEBUG_29, 55429, Error
#define XEVENT_MATCH_TITLEBUG_29 0xC000D885

// XEVENT_MATCH_TITLEBUG_30, 55430, Error
#define XEVENT_MATCH_TITLEBUG_30 0xC000D886

// XEVENT_MATCH_TITLEBUG_31, 55431, Error
#define XEVENT_MATCH_TITLEBUG_31 0xC000D887

// XEVENT_MATCH_TITLEBUG_32, 55432, Error
#define XEVENT_MATCH_TITLEBUG_32 0xC000D888

// XEVENT_MATCH_TITLEBUG_33, 55433, Error
#define XEVENT_MATCH_TITLEBUG_33 0xC000D889

// XEVENT_MATCH_TITLEBUG_34, 55434, Error
#define XEVENT_MATCH_TITLEBUG_34 0xC000D88A

// XEVENT_MATCH_TITLEBUG_35, 55435, Error
#define XEVENT_MATCH_TITLEBUG_35 0xC000D88B

// XEVENT_MATCH_TITLEBUG_36, 55436, Error
#define XEVENT_MATCH_TITLEBUG_36 0xC000D88C

// XEVENT_MATCH_TITLEBUG_37, 55437, Error
#define XEVENT_MATCH_TITLEBUG_37 0xC000D88D

// XEVENT_MATCH_TITLEBUG_38, 55438, Error
#define XEVENT_MATCH_TITLEBUG_38 0xC000D88E

// XEVENT_MATCH_TITLEBUG_39, 55439, Error
#define XEVENT_MATCH_TITLEBUG_39 0xC000D88F

// XEVENT_MATCH_TITLEBUG_40, 55440, Error
#define XEVENT_MATCH_TITLEBUG_40 0xC000D890

// XEVENT_MATCH_TITLEBUG_41, 55441, Error
#define XEVENT_MATCH_TITLEBUG_41 0xC000D891

// XEVENT_MATCH_TITLEBUG_42, 55442, Error
#define XEVENT_MATCH_TITLEBUG_42 0xC000D892

// XEVENT_MATCH_TITLEBUG_43, 55443, Error
#define XEVENT_MATCH_TITLEBUG_43 0xC000D893

// XEVENT_MATCH_TITLEBUG_44, 55444, Error
#define XEVENT_MATCH_TITLEBUG_44 0xC000D894

// XEVENT_MATCH_TITLEBUG_45, 55445, Error
#define XEVENT_MATCH_TITLEBUG_45 0xC000D895

// XEVENT_MATCH_TITLEBUG_46, 55446, Error
#define XEVENT_MATCH_TITLEBUG_46 0xC000D896

// XEVENT_MATCH_TITLEBUG_47, 55447, Error
#define XEVENT_MATCH_TITLEBUG_47 0xC000D897

// XEVENT_MATCH_TITLEBUG_48, 55448, Error
#define XEVENT_MATCH_TITLEBUG_48 0xC000D898

// XEVENT_MATCH_TITLEBUG_49, 55449, Error
#define XEVENT_MATCH_TITLEBUG_49 0xC000D899

// XEVENT_MATCH_TITLEBUG_50, 55450, Error
#define XEVENT_MATCH_TITLEBUG_50 0xC000D89A

// XEVENT_MATCH_TITLEBUG_51, 55451, Error
#define XEVENT_MATCH_TITLEBUG_51 0xC000D89B

// XEVENT_MATCH_TITLEBUG_52, 55452, Error
#define XEVENT_MATCH_TITLEBUG_52 0xC000D89C

// XEVENT_MATCH_TITLEBUG_FINDBYIDS_INVALID_SESSIONID, 55453, Error
#define XEVENT_MATCH_TITLEBUG_FINDBYIDS_INVALID_SESSIONID 0xC000D89D

// XEVENT_MATCH_TITLEBUG_FINDBYIDS_INVALID_BLOB_PARAM, 55454, Error
#define XEVENT_MATCH_TITLEBUG_FINDBYIDS_INVALID_BLOB_PARAM 0xC000D89E

// XEVENT_MIX_WEBSGVALIDATION_HEADERMISSING, 15000, Error
#define XEVENT_MIX_WEBSGVALIDATION_HEADERMISSING 0xC0003A98

// XEVENT_MIX_WEBSGVALIDATION_HEADERINVALID, 15001, Error
#define XEVENT_MIX_WEBSGVALIDATION_HEADERINVALID 0xC0003A99

// XEVENT_MIX_STATS_INVALID_TITLE_ID, 15002, Info
#define XEVENT_MIX_STATS_INVALID_TITLE_ID 0x40003A9A

// XEVENT_MIX_STATS_INVALID_LEADERBOARD_ID, 15003, Info
#define XEVENT_MIX_STATS_INVALID_LEADERBOARD_ID 0x40003A9B

// XEVENT_MIX_STATS_SUCCESS, 15004, Info
#define XEVENT_MIX_STATS_SUCCESS 0x40003A9C

// XEVENT_MIX_TITLEMANAGEMENT_INVALID_TITLE_ID, 15005, Info
#define XEVENT_MIX_TITLEMANAGEMENT_INVALID_TITLE_ID 0x40003A9D

// XEVENT_MIX_TITLEMANAGEMENT_SUCCESS, 15006, Info
#define XEVENT_MIX_TITLEMANAGEMENT_SUCCESS 0x40003A9E

// XEVENT_MIX_TITLEMANAGEMENT_INVALID_XLAST, 15007, Info
#define XEVENT_MIX_TITLEMANAGEMENT_INVALID_XLAST 0x40003A9F

// XEVENT_MIX_TITLEMANAGEMENT_DECOMPRESSION_ERROR, 15008, Info
#define XEVENT_MIX_TITLEMANAGEMENT_DECOMPRESSION_ERROR 0x40003AA0

// XEVENT_MIX_TITLEMANAGEMENT_INVALID_VERSION, 15009, Info
#define XEVENT_MIX_TITLEMANAGEMENT_INVALID_VERSION 0x40003AA1

// XEVENT_MIX_TITLEMANAGEMENT_INVALID_PLATFORM, 15010, Info
#define XEVENT_MIX_TITLEMANAGEMENT_INVALID_PLATFORM 0x40003AA2

// XEVENT_MIX_MATCH_SUCCESS, 15011, Info
#define XEVENT_MIX_MATCH_SUCCESS 0x40003AA3

// XEVENT_MIX_STORAGE_SUCCESS, 15012, Info
#define XEVENT_MIX_STORAGE_SUCCESS 0x40003AA4

// XEVENT_MIX_STORAGE_INVALID_FILE_TYPE, 15013, Info
#define XEVENT_MIX_STORAGE_INVALID_FILE_TYPE 0x40003AA5

// XEVENT_MIX_STORAGE_INVALID_GUID, 15014, Info
#define XEVENT_MIX_STORAGE_INVALID_GUID 0x40003AA6

// XEVENT_MIX_TITLEMANAGEMENT_INVALID_GUID, 15015, Info
#define XEVENT_MIX_TITLEMANAGEMENT_INVALID_GUID 0x40003AA7

// XEVENT_MIX_MATCH_NEW_MODE_FOUND, 15016, Error
#define XEVENT_MIX_MATCH_NEW_MODE_FOUND 0xC0003AA8

// XEVENT_MIX_BETAMANAGEMENT_SUCCESS, 15017, Info
#define XEVENT_MIX_BETAMANAGEMENT_SUCCESS 0x40003AA9

// XEVENT_MIX_BETAMANAGEMENT_INVALID_GUID, 15018, Info
#define XEVENT_MIX_BETAMANAGEMENT_INVALID_GUID 0x40003AAA

// XEVENT_MIX_BETAMANAGEMENT_INVALID_FLASH_VERSION, 15019, Info
#define XEVENT_MIX_BETAMANAGEMENT_INVALID_FLASH_VERSION 0x40003AAB

// XEVENT_MIX_BETAMANAGEMENT_NULL_ARGUMENT, 15020, Info
#define XEVENT_MIX_BETAMANAGEMENT_NULL_ARGUMENT 0x40003AAC

// XEVENT_MIX_STATS_FORBIDDEN_ENVIRONMENT, 15021, Info
#define XEVENT_MIX_STATS_FORBIDDEN_ENVIRONMENT 0x40003AAD

// XEVENT_MIX_CONCURRENCY_ERROR, 15022, Error
#define XEVENT_MIX_CONCURRENCY_ERROR 0xC0003AAE

// XEVENT_MIX_SUBSCRIPTION_FAMILY_ENUMERATION_ERROR, 15023, Error
#define XEVENT_MIX_SUBSCRIPTION_FAMILY_ENUMERATION_ERROR 0xC0003AAF

// XEVENT_MIX_SUBSCRIPTION_FAMILY_CREATE_ERROR, 15024, Error
#define XEVENT_MIX_SUBSCRIPTION_FAMILY_CREATE_ERROR 0xC0003AB0

// XEVENT_MIX_SUBSCRIPTION_FAMILY_GET_ERROR, 15025, Error
#define XEVENT_MIX_SUBSCRIPTION_FAMILY_GET_ERROR 0xC0003AB1

// XEVENT_MIX_BETAMANAGEMENT_INVALID_TITLE_VERSION, 15026, Info
#define XEVENT_MIX_BETAMANAGEMENT_INVALID_TITLE_VERSION 0x40003AB2

// XEVENT_MIX_BETAMANAGEMENT_INVALID_TITLE_ID, 15027, Info
#define XEVENT_MIX_BETAMANAGEMENT_INVALID_TITLE_ID 0x40003AB3

// XEVENT_MIX_SETTINGS_INVALID_ARGUMENT, 15028, Error
#define XEVENT_MIX_SETTINGS_INVALID_ARGUMENT 0xC0003AB4

// XEVENT_MIX_STATS_CUSTOMER_IMPACT, 15029, Info
#define XEVENT_MIX_STATS_CUSTOMER_IMPACT 0x40003AB5

// XEVENT_MIX_BETAMANAGEMENT_INVALID_ARGUMENT, 15030, Error
#define XEVENT_MIX_BETAMANAGEMENT_INVALID_ARGUMENT 0xC0003AB6

// XEVENT_MIX_STATS_FORCE_REQUIRED, 15031, Error
#define XEVENT_MIX_STATS_FORCE_REQUIRED 0xC0003AB7

// XEVENT_MIX_MATCH_MISSING_REMOVE_MODE, 15032, Error
#define XEVENT_MIX_MATCH_MISSING_REMOVE_MODE 0xC0003AB8

// XEVENT_MIX_MATCH_SQL_EXCEPTION, 15033, Error
#define XEVENT_MIX_MATCH_SQL_EXCEPTION 0xC0003AB9

// XEVENT_MIX_BETAMANAGEMENT_GROUP_MUST_BE_EMPTY, 15034, Error
#define XEVENT_MIX_BETAMANAGEMENT_GROUP_MUST_BE_EMPTY 0xC0003ABA

// XEVENT_MIX_BETAMANAGEMENT_XKDC_RELOAD_FAILED, 15035, Warning
#define XEVENT_MIX_BETAMANAGEMENT_XKDC_RELOAD_FAILED 0x80003ABB

// XEVENT_MIX_BETAMANAGEMENT_HIVE_RELOAD_FAILED, 15036, Warning
#define XEVENT_MIX_BETAMANAGEMENT_HIVE_RELOAD_FAILED 0x80003ABC

// XEVENT_MIX_BETAMANAGEMENT_CANNOT_MIGRATE_TO_SELF, 15037, Error
#define XEVENT_MIX_BETAMANAGEMENT_CANNOT_MIGRATE_TO_SELF 0xC0003ABD

// XEVENT_MIX_TITLEMANAGEMENT_NULL_ARGUMENT, 15038, Error
#define XEVENT_MIX_TITLEMANAGEMENT_NULL_ARGUMENT 0xC0003ABE

// XEVENT_MIX_TITLEMANAGEMENT_INVALID_ARGUMENT, 15039, Error
#define XEVENT_MIX_TITLEMANAGEMENT_INVALID_ARGUMENT 0xC0003ABF

// XEVENT_MIX_TITLEMANAGEMENT_ARGUMENT_TOO_LARGE, 15040, Error
#define XEVENT_MIX_TITLEMANAGEMENT_ARGUMENT_TOO_LARGE 0xC0003AC0

// XEVENT_MIX_TITLEMANAGEMENT_DUPLICATE_UPDATE_RANK_LOCATION, 15041, Error
#define XEVENT_MIX_TITLEMANAGEMENT_DUPLICATE_UPDATE_RANK_LOCATION 0xC0003AC1

// XEVENT_MIX_TITLEMANAGEMENT_DATABASE_RETURN_ERROR, 15042, Error
#define XEVENT_MIX_TITLEMANAGEMENT_DATABASE_RETURN_ERROR 0xC0003AC2

// XEVENT_MIX_TITLEMANAGEMENT_XBOS_RELOAD_FAILED, 15043, Warning
#define XEVENT_MIX_TITLEMANAGEMENT_XBOS_RELOAD_FAILED 0x80003AC3

// XEVENT_MIX_TOKEN_FILE_NOT_FOUND, 15044, Error
#define XEVENT_MIX_TOKEN_FILE_NOT_FOUND 0xC0003AC4

// XEVENT_MIX_TOKEN_MALFORMED_TOKEN_ENTRY_FOUND, 15045, Error
#define XEVENT_MIX_TOKEN_MALFORMED_TOKEN_ENTRY_FOUND 0xC0003AC5

// XEVENT_MIX_TOKEN_MALFORMED_5X5_TOKEN_CODE_FOUND, 15046, Error
#define XEVENT_MIX_TOKEN_MALFORMED_5X5_TOKEN_CODE_FOUND 0xC0003AC6

// XEVENT_MIX_TOKEN_FILE_DECRYPTION_ERROR, 15047, Error
#define XEVENT_MIX_TOKEN_FILE_DECRYPTION_ERROR 0xC0003AC7

// XEVENT_MIX_TOKEN_EOF_REACHED_BEFORE_ALL_TOKENS_RETRIEVED, 15048, Error
#define XEVENT_MIX_TOKEN_EOF_REACHED_BEFORE_ALL_TOKENS_RETRIEVED 0xC0003AC8

// XEVENT_MIX_TOKEN_JOB_NOT_IN_REQUIRED_STATE, 15049, Error
#define XEVENT_MIX_TOKEN_JOB_NOT_IN_REQUIRED_STATE 0xC0003AC9

// XEVENT_MIX_TITLEMANAGEMENT_DUPLICATE_UPDATE_XRL_LOCATION, 15050, Error
#define XEVENT_MIX_TITLEMANAGEMENT_DUPLICATE_UPDATE_XRL_LOCATION 0xC0003ACA

// XEVENT_MIX_COMMON_FRONT_DOOR_RESET_ERROR, 15051, Error
#define XEVENT_MIX_COMMON_FRONT_DOOR_RESET_ERROR 0xC0003ACB

// XEVENT_MIX_SETTINGS_ERROR_INGESTING_ETX_MANIFEST, 15052, Error
#define XEVENT_MIX_SETTINGS_ERROR_INGESTING_ETX_MANIFEST 0xC0003ACC

// XEVENT_MIX_TOKEN_MANAGEMENT_SERIALIZATION_ERROR, 15053, Error
#define XEVENT_MIX_TOKEN_MANAGEMENT_SERIALIZATION_ERROR 0xC0003ACD

// XEVENT_MIX_BETA_MANAGEMENT_DUPLICATE_APP_ERROR, 15054, Error
#define XEVENT_MIX_BETA_MANAGEMENT_DUPLICATE_APP_ERROR 0xC0003ACE

// XEVENT_MIX_COMMON_INVALID_LOGGING_FIELD, 15055, Warning
#define XEVENT_MIX_COMMON_INVALID_LOGGING_FIELD 0x80003ACF

// XEVENT_MIX_STS_CONFIGURATION_RELOAD_FAILED, 15056, Warning
#define XEVENT_MIX_STS_CONFIGURATION_RELOAD_FAILED 0x80003AD0

// XEVENT_MIX_STS_CONFIGURATION_DATABASE_LOAD_FAILED, 15057, Error
#define XEVENT_MIX_STS_CONFIGURATION_DATABASE_LOAD_FAILED 0xC0003AD1

// XEVENT_MIX_STS_CONFIGURATION_PARTNER_DOES_NOT_EXIST, 15058, Error
#define XEVENT_MIX_STS_CONFIGURATION_PARTNER_DOES_NOT_EXIST 0xC0003AD2

// XEVENT_MIX_STS_CONFIGURATION_TITLE_NOT_ASSOCIATED, 15059, Error
#define XEVENT_MIX_STS_CONFIGURATION_TITLE_NOT_ASSOCIATED 0xC0003AD3

// XEVENT_MIX_STS_CONFIGURATION_APPLIES_TO_DOES_NOT_EXIST, 15060, Error
#define XEVENT_MIX_STS_CONFIGURATION_APPLIES_TO_DOES_NOT_EXIST 0xC0003AD4

// XEVENT_MIX_STS_CONFIGURATION_DATABASE_WRITE_ERROR, 15061, Error
#define XEVENT_MIX_STS_CONFIGURATION_DATABASE_WRITE_ERROR 0xC0003AD5

// XEVENT_MIX_TITLE_MANAGEMENT_ERROR_SETTING_NACL_PRIVILEGE, 15062, Error
#define XEVENT_MIX_TITLE_MANAGEMENT_ERROR_SETTING_NACL_PRIVILEGE 0xC0003AD6

// XEVENT_MIX_STS_CONFIGURATION_UNSUPPORTED_TOKEN_TYPE, 15063, Error
#define XEVENT_MIX_STS_CONFIGURATION_UNSUPPORTED_TOKEN_TYPE 0xC0003AD7

// XEVENT_MIX_STS_CONFIGURATION_UNSUPPORTED_ENDPOINT_PROTOCOL, 15064, Error
#define XEVENT_MIX_STS_CONFIGURATION_UNSUPPORTED_ENDPOINT_PROTOCOL 0xC0003AD8

// XEVENT_MIX_STS_CONFIGURATION_INVALID_CLAIM_TYPE, 15065, Error
#define XEVENT_MIX_STS_CONFIGURATION_INVALID_CLAIM_TYPE 0xC0003AD9

// XEVENT_MIX_STS_CONFIGURATION_PRIVATE_CLAIM_TYPE, 15066, Error
#define XEVENT_MIX_STS_CONFIGURATION_PRIVATE_CLAIM_TYPE 0xC0003ADA

// XEVENT_MIX_STS_CONFIGURATION_PRIVATE_BUSINESS_PARTNER, 15067, Error
#define XEVENT_MIX_STS_CONFIGURATION_PRIVATE_BUSINESS_PARTNER 0xC0003ADB

// XEVENT_WEBCACHE_UNKNOWN_ERROR, 55500, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR 0xC000D8CC

// XEVENT_WEBCACHE_UNKNOWN_ERROR_1, 55501, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_1 0xC000D8CD

// XEVENT_WEBCACHE_UNKNOWN_ERROR_2, 55502, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_2 0xC000D8CE

// XEVENT_MGMT_GENERIC_ERROR_5, 55503, Error
#define XEVENT_MGMT_GENERIC_ERROR_5 0xC000D8CF

// XEVENT_MGMT_GENERIC_ERROR_6, 55504, Error
#define XEVENT_MGMT_GENERIC_ERROR_6 0xC000D8D0

// XEVENT_MGMT_GENERIC_ERROR_7, 55505, Error
#define XEVENT_MGMT_GENERIC_ERROR_7 0xC000D8D1

// XEVENT_MGMT_GENERIC_ERROR_8, 55506, Error
#define XEVENT_MGMT_GENERIC_ERROR_8 0xC000D8D2

// XEVENT_MGMT_GENERIC_ERROR_9, 55507, Error
#define XEVENT_MGMT_GENERIC_ERROR_9 0xC000D8D3

// XEVENT_MGMT_GENERIC_ERROR_10, 55508, Error
#define XEVENT_MGMT_GENERIC_ERROR_10 0xC000D8D4

// XEVENT_MGMT_GENERIC_ERROR_11, 55509, Error
#define XEVENT_MGMT_GENERIC_ERROR_11 0xC000D8D5

// XEVENT_MGMT_GENERIC_ERROR_12, 55510, Error
#define XEVENT_MGMT_GENERIC_ERROR_12 0xC000D8D6

// XEVENT_MGMT_GENERIC_ERROR_13, 55511, Error
#define XEVENT_MGMT_GENERIC_ERROR_13 0xC000D8D7

// XEVENT_MGMT_GENERIC_ERROR_14, 55512, Error
#define XEVENT_MGMT_GENERIC_ERROR_14 0xC000D8D8

// XEVENT_MGMT_GENERIC_ERROR_15, 55513, Error
#define XEVENT_MGMT_GENERIC_ERROR_15 0xC000D8D9

// XEVENT_MGMT_GENERIC_ERROR_16, 55514, Error
#define XEVENT_MGMT_GENERIC_ERROR_16 0xC000D8DA

// XEVENT_MGMT_GENERIC_ERROR_17, 55515, Error
#define XEVENT_MGMT_GENERIC_ERROR_17 0xC000D8DB

// XEVENT_MGMT_GENERIC_ERROR_18, 55516, Error
#define XEVENT_MGMT_GENERIC_ERROR_18 0xC000D8DC

// XEVENT_MGMT_GENERIC_ERROR_19, 55517, Error
#define XEVENT_MGMT_GENERIC_ERROR_19 0xC000D8DD

// XEVENT_MGMT_GENERIC_ERROR_20, 55518, Error
#define XEVENT_MGMT_GENERIC_ERROR_20 0xC000D8DE

// XEVENT_MGMT_GENERIC_ERROR_21, 55519, Error
#define XEVENT_MGMT_GENERIC_ERROR_21 0xC000D8DF

// XEVENT_MGMT_PING_ERROR, 55550, Error
#define XEVENT_MGMT_PING_ERROR 0xC000D8FE

// XEVENT_MGMT_PING_ERROR_1, 55551, Error
#define XEVENT_MGMT_PING_ERROR_1 0xC000D8FF

// XEVENT_MGMT_PING_ERROR_2, 55552, Error
#define XEVENT_MGMT_PING_ERROR_2 0xC000D900

// XEVENT_MGMT_PING_ERROR_3, 55553, Error
#define XEVENT_MGMT_PING_ERROR_3 0xC000D901

// XEVENT_MGMT_PING_ERROR_4, 55554, Error
#define XEVENT_MGMT_PING_ERROR_4 0xC000D902

// XEVENT_MGMT_PING_ERROR_5, 55555, Error
#define XEVENT_MGMT_PING_ERROR_5 0xC000D903

// XEVENT_MGMT_PING_ERROR_6, 55556, Error
#define XEVENT_MGMT_PING_ERROR_6 0xC000D904

// XEVENT_MGMT_PING_ERROR_7, 55557, Error
#define XEVENT_MGMT_PING_ERROR_7 0xC000D905

// XEVENT_MGMT_INIT_WARNING_1, 55575, Warning
#define XEVENT_MGMT_INIT_WARNING_1 0x8000D917

// XEVENT_MGMT_INIT_WARNING_2, 55576, Warning
#define XEVENT_MGMT_INIT_WARNING_2 0x8000D918

// XEVENT_MGMT_INIT_WARNING_3, 55577, Warning
#define XEVENT_MGMT_INIT_WARNING_3 0x8000D919

// XEVENT_MGMT_INIT_WARNING_4, 55578, Warning
#define XEVENT_MGMT_INIT_WARNING_4 0x8000D91A

// XEVENT_MGMT_INIT_WARNING_5, 55579, Warning
#define XEVENT_MGMT_INIT_WARNING_5 0x8000D91B

// XEVENT_MGMT_INIT_WARNING_6, 55580, Warning
#define XEVENT_MGMT_INIT_WARNING_6 0x8000D91C

// XEVENT_MGMT_INIT_WARNING_7, 55581, Warning
#define XEVENT_MGMT_INIT_WARNING_7 0x8000D91D

// XEVENT_MGMT_INIT_WARNING_8, 55582, Warning
#define XEVENT_MGMT_INIT_WARNING_8 0x8000D91E

// XEVENT_MGMT_INIT_WARNING_9, 55583, Warning
#define XEVENT_MGMT_INIT_WARNING_9 0x8000D91F

// XEVENT_MGMT_INIT_WARNING_10, 55584, Warning
#define XEVENT_MGMT_INIT_WARNING_10 0x8000D920

// XEVENT_MGMT_INIT_WARNING_11, 55585, Warning
#define XEVENT_MGMT_INIT_WARNING_11 0x8000D921

// XEVENT_MGMT_INIT_WARNING_12, 55586, Warning
#define XEVENT_MGMT_INIT_WARNING_12 0x8000D922

// XEVENT_MGMT_INIT_WARNING_13, 55587, Warning
#define XEVENT_MGMT_INIT_WARNING_13 0x8000D923

// XEVENT_MGMT_INIT_FAILURE_10, 55588, Error
#define XEVENT_MGMT_INIT_FAILURE_10 0xC000D924

// XEVENT_MGMT_INIT_WARNING_14, 55589, Warning
#define XEVENT_MGMT_INIT_WARNING_14 0x8000D925

// XEVENT_MGMT_CONFIG_15, 55590, Warning
#define XEVENT_MGMT_CONFIG_15 0x8000D926

// XEVENT_MGMT_CONFIG_16, 55591, Error
#define XEVENT_MGMT_CONFIG_16 0xC000D927

// XEVENT_MGMT_CONFIG_17, 55592, Error
#define XEVENT_MGMT_CONFIG_17 0xC000D928

// XEVENT_MGMT_CONFIG_18, 55593, Error
#define XEVENT_MGMT_CONFIG_18 0xC000D929

// XEVENT_MGMT_CONFIG_19, 55594, Error
#define XEVENT_MGMT_CONFIG_19 0xC000D92A

// XEVENT_MGMT_CONFIG_20, 55595, Error
#define XEVENT_MGMT_CONFIG_20 0xC000D92B

// XEVENT_MGMT_INIT_FAILURE_11, 55596, Error
#define XEVENT_MGMT_INIT_FAILURE_11 0xC000D92C

// XEVENT_MGMT_INIT_FAILURE_12, 55597, Error
#define XEVENT_MGMT_INIT_FAILURE_12 0xC000D92D

// XEVENT_MGMT_INIT_FAILURE_13, 55598, Error
#define XEVENT_MGMT_INIT_FAILURE_13 0xC000D92E

// XEVENT_MGMT_INIT_FAILURE_14, 55599, Error
#define XEVENT_MGMT_INIT_FAILURE_14 0xC000D92F

// XEVENT_MGMT_INIT_FAILURE_15, 55600, Error
#define XEVENT_MGMT_INIT_FAILURE_15 0xC000D930

// XEVENT_MGMT_INIT_FAILURE_16, 55601, Error
#define XEVENT_MGMT_INIT_FAILURE_16 0xC000D931

// XEVENT_MGMT_INIT_FAILURE_17, 55602, Error
#define XEVENT_MGMT_INIT_FAILURE_17 0xC000D932

// XEVENT_MGMT_INIT_FAILURE_18, 55603, Error
#define XEVENT_MGMT_INIT_FAILURE_18 0xC000D933

// XEVENT_MGMT_INIT_FAILURE_19, 55604, Error
#define XEVENT_MGMT_INIT_FAILURE_19 0xC000D934

// XEVENT_MGMT_INIT_FAILURE_20, 55605, Error
#define XEVENT_MGMT_INIT_FAILURE_20 0xC000D935

// XEVENT_MGMT_INIT_FAILURE_21, 55606, Error
#define XEVENT_MGMT_INIT_FAILURE_21 0xC000D936

// XEVENT_MGMT_INIT_FAILURE_22, 55607, Error
#define XEVENT_MGMT_INIT_FAILURE_22 0xC000D937

// XEVENT_MGMT_INIT_FAILURE_23, 55608, Error
#define XEVENT_MGMT_INIT_FAILURE_23 0xC000D938

// XEVENT_MGMT_INIT_FAILURE_24, 55609, Error
#define XEVENT_MGMT_INIT_FAILURE_24 0xC000D939

// XEVENT_MGMT_INIT_FAILURE_25, 55610, Error
#define XEVENT_MGMT_INIT_FAILURE_25 0xC000D93A

// XEVENT_MGMT_INIT_FAILURE_26, 55611, Error
#define XEVENT_MGMT_INIT_FAILURE_26 0xC000D93B

// XEVENT_MGMT_INIT_FAILURE_27, 55612, Error
#define XEVENT_MGMT_INIT_FAILURE_27 0xC000D93C

// XEVENT_MGMT_INIT_FAILURE_28, 55613, Error
#define XEVENT_MGMT_INIT_FAILURE_28 0xC000D93D

// XEVENT_MGMT_INIT_ACCEPT_FAILURE, 55614, Error
#define XEVENT_MGMT_INIT_ACCEPT_FAILURE 0xC000D93E

// XEVENT_MGMT_INIT_CONNECT_PIPE_FAILURE, 55615, Error
#define XEVENT_MGMT_INIT_CONNECT_PIPE_FAILURE 0xC000D93F

// XEVENT_MGMT_HACK_0, 55675, Warning
#define XEVENT_MGMT_HACK_0 0x8000D97B

// XEVENT_MGMT_HACK_1, 55676, Warning
#define XEVENT_MGMT_HACK_1 0x8000D97C

// XEVENT_MGMT_INIT_SUCCESS, 55700, Info
#define XEVENT_MGMT_INIT_SUCCESS 0x4000D994

// XEVENT_MGMT_INIT_SUCCESS_1, 55701, Info
#define XEVENT_MGMT_INIT_SUCCESS_1 0x4000D995

// XEVENT_MC_APPDOMAIN_STARTED_2, 55702, Info
#define XEVENT_MC_APPDOMAIN_STARTED_2 0x4000D996

// XEVENT_MC_APPDOMAIN_STOPPED, 55703, Info
#define XEVENT_MC_APPDOMAIN_STOPPED 0x4000D997

// XEVENT_MGMT_ADMIN_COMMAND, 55704, Info
#define XEVENT_MGMT_ADMIN_COMMAND 0x4000D998

// XEVENT_PRESENCE_HEADER_TRUNCATED, 15000, Warning
#define XEVENT_PRESENCE_HEADER_TRUNCATED 0x80003A98

// XEVENT_PRESENCE_REQUEST_TRUNCATED, 15001, Warning
#define XEVENT_PRESENCE_REQUEST_TRUNCATED 0x80003A99

// XEVENT_PRESENCE_NO_VINTERFACE, 15002, Warning
#define XEVENT_PRESENCE_NO_VINTERFACE 0x80003A9A

// XEVENT_PRESENCE_BAD_CONTENT_TYPE, 15003, Warning
#define XEVENT_PRESENCE_BAD_CONTENT_TYPE 0x80003A9B

// XEVENT_PRESENCE_NOTIFICATION_MESSAGE_TRUNCATED, 15004, Warning
#define XEVENT_PRESENCE_NOTIFICATION_MESSAGE_TRUNCATED 0x80003A9C

// XEVENT_PRESENCE_INVALID_USERID, 15005, Error
#define XEVENT_PRESENCE_INVALID_USERID 0xC0003A9D

// XEVENT_PRESENCE_INVALID_DC_MESSAGE_TYPE, 15006, Warning
#define XEVENT_PRESENCE_INVALID_DC_MESSAGE_TYPE 0x80003A9E

// XEVENT_PRESENCE_INVALID_CLIENT_MESSAGE_TYPE, 15007, Warning
#define XEVENT_PRESENCE_INVALID_CLIENT_MESSAGE_TYPE 0x80003A9F

// XEVENT_PRESENCE_UNKNOWN_MESSAGE_TYPE, 15008, Warning
#define XEVENT_PRESENCE_UNKNOWN_MESSAGE_TYPE 0x80003AA0

// XEVENT_PRESENCE_DO_NOT_LOG_EVENT, 15009, Info
#define XEVENT_PRESENCE_DO_NOT_LOG_EVENT 0x40003AA1

// XEVENT_PRESENCE_SGINFO_INVALID_PUID, 15010, Error
#define XEVENT_PRESENCE_SGINFO_INVALID_PUID 0xC0003AA2

// XEVENT_PRESENCE_ALIVE_INVALID_TITLEID, 15020, Warning
#define XEVENT_PRESENCE_ALIVE_INVALID_TITLEID 0x80003AAC

// XEVENT_PRESENCE_ALIVE_GAMERTAG_TOO_BIG, 15021, Warning
#define XEVENT_PRESENCE_ALIVE_GAMERTAG_TOO_BIG 0x80003AAD

// XEVENT_PRESENCE_ALIVE_DB_READ_ERROR, 15022, Error
#define XEVENT_PRESENCE_ALIVE_DB_READ_ERROR 0xC0003AAE

// XEVENT_PRESENCE_LOGIN_NAME_MISMATCH, 15023, Error
#define XEVENT_PRESENCE_LOGIN_NAME_MISMATCH 0xC0003AAF

// XEVENT_PRESENCE_LICENSE_MIGRATION_ERROR, 15024, Error
#define XEVENT_PRESENCE_LICENSE_MIGRATION_ERROR 0xC0003AB0

// XEVENT_PRESENCE_WELCOME_MESSAGE_ERROR, 15025, Error
#define XEVENT_PRESENCE_WELCOME_MESSAGE_ERROR 0xC0003AB1

// XEVENT_PRESENCE_INVALID_GAMERTAG, 15030, Error
#define XEVENT_PRESENCE_INVALID_GAMERTAG 0xC0003AB6

// XEVENT_PRESENCE_FRIEND_NOT_SPECIFIED, 15031, Error
#define XEVENT_PRESENCE_FRIEND_NOT_SPECIFIED 0xC0003AB7

// XEVENT_PRESENCE_FRIEND_IS_SENDER, 15032, Error
#define XEVENT_PRESENCE_FRIEND_IS_SENDER 0xC0003AB8

// XEVENT_PRESENCE_DATA_MISMATCH, 15033, Error
#define XEVENT_PRESENCE_DATA_MISMATCH 0xC0003AB9

// XEVENT_PRESENCE_FRIEND_LIST_ACCESS_DENIED, 15034, Warning
#define XEVENT_PRESENCE_FRIEND_LIST_ACCESS_DENIED 0x80003ABA

// XEVENT_PRESENCE_CACHE_NOTFOUND, 15040, Error
#define XEVENT_PRESENCE_CACHE_NOTFOUND 0xC0003AC0

// XEVENT_PRESENCE_CONFIG_PRESENCE_BLACKLIST, 15041, Warning
#define XEVENT_PRESENCE_CONFIG_PRESENCE_BLACKLIST 0x80003AC1

// XEVENT_PRESENCE_INVALID_QUEUE_TYPE, 15050, Error
#define XEVENT_PRESENCE_INVALID_QUEUE_TYPE 0xC0003ACA

// XEVENT_PRESENCE_UNSUPPORTED_QUEUE_TYPE, 15051, Error
#define XEVENT_PRESENCE_UNSUPPORTED_QUEUE_TYPE 0xC0003ACB

// XEVENT_PRESENCE_INVITE_SENDER_INVALID_USERID, 15070, Error
#define XEVENT_PRESENCE_INVITE_SENDER_INVALID_USERID 0xC0003ADE

// XEVENT_PRESENCE_INVITE_SENDER_IS_OFFLINE, 15071, Error
#define XEVENT_PRESENCE_INVITE_SENDER_IS_OFFLINE 0xC0003ADF

// XEVENT_PRESENCE_INVITE_MISSING_SESSION_ID, 15072, Error
#define XEVENT_PRESENCE_INVITE_MISSING_SESSION_ID 0xC0003AE0

// XEVENT_PRESENCE_INVITE_BAD_NUMBER_INVITEES, 15073, Error
#define XEVENT_PRESENCE_INVITE_BAD_NUMBER_INVITEES 0xC0003AE1

// XEVENT_PRESENCE_INVITEANSWER_INVALID_HOSTID, 15080, Error
#define XEVENT_PRESENCE_INVITEANSWER_INVALID_HOSTID 0xC0003AE8

// XEVENT_PRESENCE_INVITEANSWER_INVALID_SESSIONID, 15081, Error
#define XEVENT_PRESENCE_INVITEANSWER_INVALID_SESSIONID 0xC0003AE9

// XEVENT_PRESENCE_INVITEANSWER_INVALID_ANSWER, 15082, Error
#define XEVENT_PRESENCE_INVITEANSWER_INVALID_ANSWER 0xC0003AEA

// XEVENT_PRESENCE_INVITEANSWER_INVALID_USERID, 15083, Error
#define XEVENT_PRESENCE_INVITEANSWER_INVALID_USERID 0xC0003AEB

// XEVENT_PRESENCE_INVITEANSWER_SENDER_IS_OFFLINE, 15084, Error
#define XEVENT_PRESENCE_INVITEANSWER_SENDER_IS_OFFLINE 0xC0003AEC

// XEVENT_PRESENCE_INVITEANSWER_REVOKE_FAILED, 15085, Error
#define XEVENT_PRESENCE_INVITEANSWER_REVOKE_FAILED 0xC0003AED

// XEVENT_PRESENCE_CANCELINVITE_INVALID_SESSIONID, 15090, Error
#define XEVENT_PRESENCE_CANCELINVITE_INVALID_SESSIONID 0xC0003AF2

// XEVENT_PRESENCE_CANCELINVITE_INVALID_USERID, 15091, Error
#define XEVENT_PRESENCE_CANCELINVITE_INVALID_USERID 0xC0003AF3

// XEVENT_PRESENCE_CANCELINVITE_SENDER_IS_OFFLINE, 15092, Error
#define XEVENT_PRESENCE_CANCELINVITE_SENDER_IS_OFFLINE 0xC0003AF4

// XEVENT_PRESENCE_CANCELINVITE_REVOKE_FAILED, 15093, Error
#define XEVENT_PRESENCE_CANCELINVITE_REVOKE_FAILED 0xC0003AF5

// XEVENT_PRESENCE_MUTELIST_ADD_ERROR, 15100, Error
#define XEVENT_PRESENCE_MUTELIST_ADD_ERROR 0xC0003AFC

// XEVENT_PRESENCE_MUTELIST_DELETE_ERROR, 15101, Error
#define XEVENT_PRESENCE_MUTELIST_DELETE_ERROR 0xC0003AFD

// XEVENT_PRESENCE_NEVERLIST_ADD_ERROR, 15102, Error
#define XEVENT_PRESENCE_NEVERLIST_ADD_ERROR 0xC0003AFE

// XEVENT_PRESENCE_NEVERLIST_DELETE_ERROR, 15103, Error
#define XEVENT_PRESENCE_NEVERLIST_DELETE_ERROR 0xC0003AFF

// XEVENT_PRESENCE_NEVERLIST_INVALID_USER, 15104, Error
#define XEVENT_PRESENCE_NEVERLIST_INVALID_USER 0xC0003B00

// XEVENT_PRESENCE_INVALIDATE_USER_UNKNOWN_USER, 15110, Error
#define XEVENT_PRESENCE_INVALIDATE_USER_UNKNOWN_USER 0xC0003B06

// XEVENT_PRESENCE_KICK_UNKNOWN_USER, 15120, Error
#define XEVENT_PRESENCE_KICK_UNKNOWN_USER 0xC0003B10

// XEVENT_PRESENCE_PURGE_USER_TARGET_IS_ONLINE, 15130, Error
#define XEVENT_PRESENCE_PURGE_USER_TARGET_IS_ONLINE 0xC0003B1A

// XEVENT_PRESENCE_ADD_AFFILIATES_ZERO_AFFILIATES, 15140, Error
#define XEVENT_PRESENCE_ADD_AFFILIATES_ZERO_AFFILIATES 0xC0003B24

// XEVENT_PRESENCE_ADD_AFFILIATES_TOO_MANY_AFFILIATES, 15141, Error
#define XEVENT_PRESENCE_ADD_AFFILIATES_TOO_MANY_AFFILIATES 0xC0003B25

// XEVENT_PRESENCE_ADD_AFFILIATES_MULTIPLE_LISTS, 15142, Error
#define XEVENT_PRESENCE_ADD_AFFILIATES_MULTIPLE_LISTS 0xC0003B26

// XEVENT_PRESENCE_ADD_AFFILIATES_INVALID_LIST, 15143, Error
#define XEVENT_PRESENCE_ADD_AFFILIATES_INVALID_LIST 0xC0003B27

// XEVENT_PRESENCE_ADD_AFFILIATES_NO_BATCHING, 15144, Error
#define XEVENT_PRESENCE_ADD_AFFILIATES_NO_BATCHING 0xC0003B28

// XEVENT_PRESENCE_ADD_AFFILIATES_ADDING_SELF, 15145, Error
#define XEVENT_PRESENCE_ADD_AFFILIATES_ADDING_SELF 0xC0003B29

// XEVENT_PRESENCE_ADD_AFFILIATES_ADDING_ZERO_XUID, 15146, Error
#define XEVENT_PRESENCE_ADD_AFFILIATES_ADDING_ZERO_XUID 0xC0003B2A

// XEVENT_PRESENCE_QUERY_AFFILIATES_NO_LISTS, 15150, Error
#define XEVENT_PRESENCE_QUERY_AFFILIATES_NO_LISTS 0xC0003B2E

// XEVENT_PRESENCE_QUERY_AFFILIATES_MULTIPLE_LIST_LIMIT, 15151, Error
#define XEVENT_PRESENCE_QUERY_AFFILIATES_MULTIPLE_LIST_LIMIT 0xC0003B2F

// XEVENT_PRESENCE_IS_AFFILIATE_ZERO_AFFILIATE_ID, 15160, Error
#define XEVENT_PRESENCE_IS_AFFILIATE_ZERO_AFFILIATE_ID 0xC0003B38

// XEVENT_PRESENCE_IS_AFFILIATE_TO_SELF, 15161, Error
#define XEVENT_PRESENCE_IS_AFFILIATE_TO_SELF 0xC0003B39

// XEVENT_PRESENCE_TITLECONFIG_NO_GAMECONFIGPROJECT, 15170, Warning
#define XEVENT_PRESENCE_TITLECONFIG_NO_GAMECONFIGPROJECT 0x80003B42

// XEVENT_PRESENCE_TITLECONFIG_NO_LOCALIZEDSTRINGS, 15171, Warning
#define XEVENT_PRESENCE_TITLECONFIG_NO_LOCALIZEDSTRINGS 0x80003B43

// XEVENT_PRESENCE_TITLECONFIG_NO_SUPPORTEDLOCALE, 15172, Warning
#define XEVENT_PRESENCE_TITLECONFIG_NO_SUPPORTEDLOCALE 0x80003B44

// XEVENT_PRESENCE_TITLECONFIG_NO_PRESENCEMODE, 15173, Warning
#define XEVENT_PRESENCE_TITLECONFIG_NO_PRESENCEMODE 0x80003B45

// XEVENT_PRESENCE_TITLECONFIG_PARSE_FAILED, 15174, Error
#define XEVENT_PRESENCE_TITLECONFIG_PARSE_FAILED 0xC0003B46

// XEVENT_PRESENCE_TITLECONFIG_NO_CONTEXT, 15175, Error
#define XEVENT_PRESENCE_TITLECONFIG_NO_CONTEXT 0xC0003B47

// XEVENT_PRESENCE_TITLECONFIG_NO_CONTEXTVALUE, 15176, Error
#define XEVENT_PRESENCE_TITLECONFIG_NO_CONTEXTVALUE 0xC0003B48

// XEVENT_PRESENCE_TITLECONFIG_BAD_FILE, 15177, Error
#define XEVENT_PRESENCE_TITLECONFIG_BAD_FILE 0xC0003B49

// XEVENT_PRESENCE_TITLECONFIG_SQL_LOAD_FAILED, 15178, Error
#define XEVENT_PRESENCE_TITLECONFIG_SQL_LOAD_FAILED 0xC0003B4A

// XEVENT_PRESENCE_TITLECONFIG_NO_SCHEMA, 15179, Warning
#define XEVENT_PRESENCE_TITLECONFIG_NO_SCHEMA 0x80003B4B

// XEVENT_PRESENCE_TITLECONFIG_LODEGAMECONFIGPROC_FAILED, 15180, Error
#define XEVENT_PRESENCE_TITLECONFIG_LODEGAMECONFIGPROC_FAILED 0xC0003B4C

// XEVENT_PRESENCE_TITLECONFIG_TRANSLATION_NOT_FOUND, 15181, Warning
#define XEVENT_PRESENCE_TITLECONFIG_TRANSLATION_NOT_FOUND 0x80003B4D

// XEVENT_PRESENCE_TITLECONFIG_SCHEMA_NOT_LOADED, 15182, Warning
#define XEVENT_PRESENCE_TITLECONFIG_SCHEMA_NOT_LOADED 0x80003B4E

// XEVENT_PRESENCE_TITLECONFIG_PARSE_SUCCESS, 15183, Info
#define XEVENT_PRESENCE_TITLECONFIG_PARSE_SUCCESS 0x40003B4F

// XEVENT_PRESENCE_RICHPRESENCE_FORMAT_NOT_FOUND, 15190, Warning
#define XEVENT_PRESENCE_RICHPRESENCE_FORMAT_NOT_FOUND 0x80003B56

// XEVENT_PRESENCE_RICHPRESENCE_CONTEXT_LABEL_NOT_FOUND, 15191, Warning
#define XEVENT_PRESENCE_RICHPRESENCE_CONTEXT_LABEL_NOT_FOUND 0x80003B57

// XEVENT_PRESENCE_RICHPRESENCE_CONTEXT_NOT_FOUND, 15192, Warning
#define XEVENT_PRESENCE_RICHPRESENCE_CONTEXT_NOT_FOUND 0x80003B58

// XEVENT_PRESENCE_RICHPRESENCE_FORMAT_FAILED, 15193, Error
#define XEVENT_PRESENCE_RICHPRESENCE_FORMAT_FAILED 0xC0003B59

// XEVENT_PRESENCE_SGNOTIFYDELETE_INVALID_SERVICEID, 15200, Error
#define XEVENT_PRESENCE_SGNOTIFYDELETE_INVALID_SERVICEID 0xC0003B60

// XEVENT_PRESENCE_SGNOTIFYDELETE_REQUEST_TOO_SMALL, 15201, Error
#define XEVENT_PRESENCE_SGNOTIFYDELETE_REQUEST_TOO_SMALL 0xC0003B61

// XEVENT_PRESENCE_SGNOTIFYDELETE_REQUEST_INVALID_LENGTH, 15202, Error
#define XEVENT_PRESENCE_SGNOTIFYDELETE_REQUEST_INVALID_LENGTH 0xC0003B62

// XEVENT_PRESENCE_SGNOTIFYDELETE_INNER_REQUEST_INVALID_LENGTH, 15203, Error
#define XEVENT_PRESENCE_SGNOTIFYDELETE_INNER_REQUEST_INVALID_LENGTH 0xC0003B63

// XEVENT_PRESENCE_SGNOTIFYDELETE_INNER_REQUEST_INVALID_TYPE, 15204, Error
#define XEVENT_PRESENCE_SGNOTIFYDELETE_INNER_REQUEST_INVALID_TYPE 0xC0003B64

// XEVENT_PRESENCE_SGNOTIFYDELETE_UNEXPECTED_FAILURE, 15205, Error
#define XEVENT_PRESENCE_SGNOTIFYDELETE_UNEXPECTED_FAILURE 0xC0003B65

// XEVENT_PRESENCE_SGNOTIFYUPDATE_INVALID_SERVICEID, 15210, Error
#define XEVENT_PRESENCE_SGNOTIFYUPDATE_INVALID_SERVICEID 0xC0003B6A

// XEVENT_PRESENCE_SGNOTIFYUPDATE_REQUEST_TOO_SMALL, 15211, Error
#define XEVENT_PRESENCE_SGNOTIFYUPDATE_REQUEST_TOO_SMALL 0xC0003B6B

// XEVENT_PRESENCE_SGNOTIFYUPDATE_REQUEST_INVALID_LENGTH, 15212, Error
#define XEVENT_PRESENCE_SGNOTIFYUPDATE_REQUEST_INVALID_LENGTH 0xC0003B6C

// XEVENT_PRESENCE_SGNOTIFYUPDATE_REQUEST_INVALID_HEADER, 15213, Error
#define XEVENT_PRESENCE_SGNOTIFYUPDATE_REQUEST_INVALID_HEADER 0xC0003B6D

// XEVENT_PRESENCE_SGNOTIFYUPDATE_INNER_REQUEST_INVALID_LENGTH, 15214, Error
#define XEVENT_PRESENCE_SGNOTIFYUPDATE_INNER_REQUEST_INVALID_LENGTH 0xC0003B6E

// XEVENT_PRESENCE_SGNOTIFYUPDATE_INNER_REQUEST_INVALID_TYPE, 15215, Error
#define XEVENT_PRESENCE_SGNOTIFYUPDATE_INNER_REQUEST_INVALID_TYPE 0xC0003B6F

// XEVENT_PRESENCE_SGNOTIFYUPDATE_UNEXPECTED_FAILURE, 15216, Error
#define XEVENT_PRESENCE_SGNOTIFYUPDATE_UNEXPECTED_FAILURE 0xC0003B70

// XEVENT_PRESENCE_STATE_UNKNOWN_USER, 15217, Error
#define XEVENT_PRESENCE_STATE_UNKNOWN_USER 0xC0003B71

// XEVENT_PRESENCE_WEBALIVE_UNKNOWN_USER, 15220, Error
#define XEVENT_PRESENCE_WEBALIVE_UNKNOWN_USER 0xC0003B74

// XEVENT_PRESENCE_INFO_INVALID_USER_COUNT, 15230, Error
#define XEVENT_PRESENCE_INFO_INVALID_USER_COUNT 0xC0003B7E

// XEVENT_PRESENCE_SGNOTIFYTITLECHANGE_INVALID_SERVICEID, 15240, Error
#define XEVENT_PRESENCE_SGNOTIFYTITLECHANGE_INVALID_SERVICEID 0xC0003B88

// XEVENT_PRESENCE_SGNOTIFYTITLECHANGE_REQUEST_TOO_SMALL, 15241, Error
#define XEVENT_PRESENCE_SGNOTIFYTITLECHANGE_REQUEST_TOO_SMALL 0xC0003B89

// XEVENT_PRESENCE_SGNOTIFYTITLECHANGE_REQUEST_INVALID_LENGTH, 15242, Error
#define XEVENT_PRESENCE_SGNOTIFYTITLECHANGE_REQUEST_INVALID_LENGTH 0xC0003B8A

// XEVENT_PRESENCE_SGNOTIFYTITLECHANGE_INNER_REQUEST_INVALID_LENGTH, 15243, Error
#define XEVENT_PRESENCE_SGNOTIFYTITLECHANGE_INNER_REQUEST_INVALID_LENGTH 0xC0003B8B

// XEVENT_PRESENCE_SGNOTIFYTITLECHANGE_INNER_REQUEST_INVALID_TYPE, 15244, Error
#define XEVENT_PRESENCE_SGNOTIFYTITLECHANGE_INNER_REQUEST_INVALID_TYPE 0xC0003B8C

// XEVENT_PRESENCE_SGNOTIFYTITLECHANGE_UNEXPECTED_FAILURE, 15245, Error
#define XEVENT_PRESENCE_SGNOTIFYTITLECHANGE_UNEXPECTED_FAILURE 0xC0003B8D

// XEVENT_QUERY_BAD_DATA_9, 57700, Error
#define XEVENT_QUERY_BAD_DATA_9 0xC000E164

// XEVENT_QUERY_LSP_BACKCOMPAT_UNSUPPORTED_ATTRIBUTE, 57701, Error
#define XEVENT_QUERY_LSP_BACKCOMPAT_UNSUPPORTED_ATTRIBUTE 0xC000E165

// XEVENT_QUERY_INVALID_SETTING_LSPBACKCOMPTITLES, 57702, Error
#define XEVENT_QUERY_INVALID_SETTING_LSPBACKCOMPTITLES 0xC000E166

// XEVENT_QUERYLIB_CODE_0, 57725, Error
#define XEVENT_QUERYLIB_CODE_0 0xC000E17D

// XEVENT_QUERY_SERVER_HEALTH_ERROR, 57750, Error
#define XEVENT_QUERY_SERVER_HEALTH_ERROR 0xC000E196

// XEVENT_QUERY_BAD_DATA_10, 57775, Error
#define XEVENT_QUERY_BAD_DATA_10 0xC000E1AF

// XEVENT_QUERY_BAD_DATA_11, 57776, Error
#define XEVENT_QUERY_BAD_DATA_11 0xC000E1B0

// XEVENT_QUERY_BAD_DATA_12, 57777, Error
#define XEVENT_QUERY_BAD_DATA_12 0xC000E1B1

// XEVENT_QUERY_BAD_DATA_13, 57778, Error
#define XEVENT_QUERY_BAD_DATA_13 0xC000E1B2

// XEVENT_QUERY_BAD_DATA_14, 57779, Error
#define XEVENT_QUERY_BAD_DATA_14 0xC000E1B3

// XEVENT_QUERY_BAD_DATA_15, 57780, Error
#define XEVENT_QUERY_BAD_DATA_15 0xC000E1B4

// XEVENT_QUERY_BAD_DATA_16, 57781, Error
#define XEVENT_QUERY_BAD_DATA_16 0xC000E1B5

// XEVENT_QUERY_BAD_DATA_17, 57782, Error
#define XEVENT_QUERY_BAD_DATA_17 0xC000E1B6

// XEVENT_QUERY_BAD_DATA_18, 57783, Error
#define XEVENT_QUERY_BAD_DATA_18 0xC000E1B7

// XEVENT_MC_QUERY_TRUST_IS_OFF, 57784, Warning
#define XEVENT_MC_QUERY_TRUST_IS_OFF 0x8000E1B8

// XEVENT_QUERY_DATASET_CONFIG_ERROR, 57785, Error
#define XEVENT_QUERY_DATASET_CONFIG_ERROR 0xC000E1B9

// XEVENT_QUERY_DATASET_CONFIG_ERROR_1, 57786, Error
#define XEVENT_QUERY_DATASET_CONFIG_ERROR_1 0xC000E1BA

// XEVENT_QUERY_PLUGIN_CREATION_ERROR_1, 57787, Error
#define XEVENT_QUERY_PLUGIN_CREATION_ERROR_1 0xC000E1BB

// XEVENT_QUERYLIB_CONFIG_13, 57788, Error
#define XEVENT_QUERYLIB_CONFIG_13 0xC000E1BC

// XEVENT_QUERYLIB_CONFIG_14, 57789, Error
#define XEVENT_QUERYLIB_CONFIG_14 0xC000E1BD

// XEVENT_QUERYLIB_CONFIG_15, 57790, Error
#define XEVENT_QUERYLIB_CONFIG_15 0xC000E1BE

// XEVENT_QUERYLIB_CONFIG_16, 57791, Error
#define XEVENT_QUERYLIB_CONFIG_16 0xC000E1BF

// XEVENT_QUERY_PLUGIN_CREATION_ERROR_2, 57792, Error
#define XEVENT_QUERY_PLUGIN_CREATION_ERROR_2 0xC000E1C0

// XEVENT_SOCIALCACHE_STARTED, 20000, Info
#define XEVENT_SOCIALCACHE_STARTED 0x40004E20

// XEVENT_SOCIALCACHE_SHUTDOWN, 20001, Info
#define XEVENT_SOCIALCACHE_SHUTDOWN 0x40004E21

// XEVENT_SOCIALCACHE_STARTUP_FAILURE, 20002, Error
#define XEVENT_SOCIALCACHE_STARTUP_FAILURE 0xC0004E22

// XEVENT_SOCIALCACHE_PROTOCOL_VERSION_MISMATCH, 20003, Error
#define XEVENT_SOCIALCACHE_PROTOCOL_VERSION_MISMATCH 0xC0004E23

// XEVENT_SOCIALCACHE_MSGTYPE_UNKNOWN, 20004, Error
#define XEVENT_SOCIALCACHE_MSGTYPE_UNKNOWN 0xC0004E24

// XEVENT_SOCIALCACHE_MSG_BEFORE_CONNECT, 20005, Error
#define XEVENT_SOCIALCACHE_MSG_BEFORE_CONNECT 0xC0004E25

// XEVENT_SOCIALCACHE_USER_INDEX_MISMATCH, 20006, Error
#define XEVENT_SOCIALCACHE_USER_INDEX_MISMATCH 0xC0004E26

// XEVENT_SOCIALCACHE_MSG_TOO_SMALL, 20007, Error
#define XEVENT_SOCIALCACHE_MSG_TOO_SMALL 0xC0004E27

// XEVENT_SOCIALCACHE_INVALID_USER_FLAGS, 20008, Error
#define XEVENT_SOCIALCACHE_INVALID_USER_FLAGS 0xC0004E28

// XEVENT_SOCIALCACHE_TOO_MANY_USER_FLAGS, 20009, Error
#define XEVENT_SOCIALCACHE_TOO_MANY_USER_FLAGS 0xC0004E29

// XEVENT_SOCIALCACHE_NUM_USER_FLAGS_MISMATCH, 20010, Error
#define XEVENT_SOCIALCACHE_NUM_USER_FLAGS_MISMATCH 0xC0004E2A

// XEVENT_SOCIALCACHE_MSGTYPE_UNSUPPORTED, 20011, Error
#define XEVENT_SOCIALCACHE_MSGTYPE_UNSUPPORTED 0xC0004E2B

// XEVENT_SOCIALCACHE_MSG_TOO_BIG, 20012, Error
#define XEVENT_SOCIALCACHE_MSG_TOO_BIG 0xC0004E2C

// XEVENT_SOCIALCACHE_SGINFO_ERROR, 20013, Error
#define XEVENT_SOCIALCACHE_SGINFO_ERROR 0xC0004E2D

// XEVENT_SOCIALCACHE_USER_NOT_PRESENT, 20014, Error
#define XEVENT_SOCIALCACHE_USER_NOT_PRESENT 0xC0004E2E

// XEVENT_SOCIALCACHE_CONTEXT_EXCEPTION, 20015, Error
#define XEVENT_SOCIALCACHE_CONTEXT_EXCEPTION 0xC0004E2F

// XEVENT_SOCIALCACHE_DATA_TOO_SMALL, 20016, Error
#define XEVENT_SOCIALCACHE_DATA_TOO_SMALL 0xC0004E30

// XEVENT_SOCIALCACHE_DATA_INTEGRITY_ERROR, 20017, Error
#define XEVENT_SOCIALCACHE_DATA_INTEGRITY_ERROR 0xC0004E31

// XEVENT_SOCIALCACHE_TOO_MANY_OBJECTS, 20019, Error
#define XEVENT_SOCIALCACHE_TOO_MANY_OBJECTS 0xC0004E33

// XEVENT_SOCIALCACHE_TOO_MANY_SUBSCRIPTIONS, 20020, Error
#define XEVENT_SOCIALCACHE_TOO_MANY_SUBSCRIPTIONS 0xC0004E34

// XEVENT_SOCIALCACHE_EXCEPTION_WOULD_DEADLOCK, 20021, Warning
#define XEVENT_SOCIALCACHE_EXCEPTION_WOULD_DEADLOCK 0x80004E35

// XEVENT_SOCIALCACHE_THREADPOOL_EXCEPTION, 20022, Warning
#define XEVENT_SOCIALCACHE_THREADPOOL_EXCEPTION 0x80004E36

// XEVENT_SOCIALCACHE_NOTIFICATION_FORMATTING_ERROR, 20023, Error
#define XEVENT_SOCIALCACHE_NOTIFICATION_FORMATTING_ERROR 0xC0004E37

// XEVENT_SOCIALCACHE_DUPLICATE_USER, 20024, Error
#define XEVENT_SOCIALCACHE_DUPLICATE_USER 0xC0004E38

// XEVENT_SOCIALCACHE_PROXY_CONNECT_FAILED, 20025, Error
#define XEVENT_SOCIALCACHE_PROXY_CONNECT_FAILED 0xC0004E39

// XEVENT_SOCIALCACHE_PROXY_SEND_FAILED, 20026, Error
#define XEVENT_SOCIALCACHE_PROXY_SEND_FAILED 0xC0004E3A

// XEVENT_SOCIALCACHE_PROXY_RECEIVE_FAILED, 20027, Error
#define XEVENT_SOCIALCACHE_PROXY_RECEIVE_FAILED 0xC0004E3B

// XEVENT_SOCIALCACHE_PROXY_SERVER_CHANGE_FAILED, 20028, Error
#define XEVENT_SOCIALCACHE_PROXY_SERVER_CHANGE_FAILED 0xC0004E3C

// XEVENT_SOCIALCACHE_PROXY_BUCKET_MAP_FAILED, 20029, Error
#define XEVENT_SOCIALCACHE_PROXY_BUCKET_MAP_FAILED 0xC0004E3D

// XEVENT_SOCIALCACHE_PROXY_BUCKET_CHANGE_FAILED, 20030, Error
#define XEVENT_SOCIALCACHE_PROXY_BUCKET_CHANGE_FAILED 0xC0004E3E

// XEVENT_SOCIALCACHE_PROXY_REQUEST_FAILED, 20031, Error
#define XEVENT_SOCIALCACHE_PROXY_REQUEST_FAILED 0xC0004E3F

// XEVENT_XBOX_AVATAR_ASSETS_NOT_SUPPORTED, 15000, Error
#define XEVENT_XBOX_AVATAR_ASSETS_NOT_SUPPORTED 0xC0003A98

// XEVENT_XBOX360_AVATAR_ASSETS_NOT_SUPPORTED, 15001, Error
#define XEVENT_XBOX360_AVATAR_ASSETS_NOT_SUPPORTED 0xC0003A99

// XEVENT_PC_AVATAR_ASSETS_NOT_SUPPORTED, 15002, Error
#define XEVENT_PC_AVATAR_ASSETS_NOT_SUPPORTED 0xC0003A9A

// XEVENT_UNKNOWN_PLATFORM_AVATAR_ASSETS_NOT_SUPPORTED, 15003, Error
#define XEVENT_UNKNOWN_PLATFORM_AVATAR_ASSETS_NOT_SUPPORTED 0xC0003A9B

// XEVENT_CONSOLE_AUDIT_LIST_NOT_SUPPORTED, 15004, Error
#define XEVENT_CONSOLE_AUDIT_LIST_NOT_SUPPORTED 0xC0003A9C

// XEVENT_CONSOLE_AUDIT_LIST_EMPTY, 15005, Error
#define XEVENT_CONSOLE_AUDIT_LIST_EMPTY 0xC0003A9D

// XEVENT_AVATAR_ASSET_VALIDATION_FAILED, 15006, Error
#define XEVENT_AVATAR_ASSET_VALIDATION_FAILED 0xC0003A9E

// XEVENT_STATS_MISSING_SERVER_INFO, 15007, Warning
#define XEVENT_STATS_MISSING_SERVER_INFO 0x80003A9F

// XEVENT_MOBILE_ACHIEVEMENTS_NOT_SUPPORTED, 15008, Error
#define XEVENT_MOBILE_ACHIEVEMENTS_NOT_SUPPORTED 0xC0003AA0

// XEVENT_WEB_GAMES_ACHIEVEMENTS_NOT_SUPPORTED, 15009, Error
#define XEVENT_WEB_GAMES_ACHIEVEMENTS_NOT_SUPPORTED 0xC0003AA1

// XEVENT_MOBILE_AVATAR_ASSETS_NOT_SUPPORTED, 15010, Error
#define XEVENT_MOBILE_AVATAR_ASSETS_NOT_SUPPORTED 0xC0003AA2

// XEVENT_WEB_GAMES_AVATAR_ASSETS_NOT_SUPPORTED, 15011, Error
#define XEVENT_WEB_GAMES_AVATAR_ASSETS_NOT_SUPPORTED 0xC0003AA3

// XEVENT_STATS_PLATFORM_VISIBLE_LEADERBOARDS_GET_ALL_FAILURE, 15012, Error
#define XEVENT_STATS_PLATFORM_VISIBLE_LEADERBOARDS_GET_ALL_FAILURE 0xC0003AA4

// XEVENT_STATS_PLATFORM_VISIBLE_LEADERBOARDS_ADD_TO_MAP_FAILURE, 15013, Error
#define XEVENT_STATS_PLATFORM_VISIBLE_LEADERBOARDS_ADD_TO_MAP_FAILURE 0xC0003AA5

// XEVENT_STATS_PLATFORM_VISIBLE_LEADERBOARDS_LOAD_FAILURE, 15014, Error
#define XEVENT_STATS_PLATFORM_VISIBLE_LEADERBOARDS_LOAD_FAILURE 0xC0003AA6

// XEVENT_STATS_CODE_PERF_CREATE_FAILED, 20000, Error
#define XEVENT_STATS_CODE_PERF_CREATE_FAILED 0xC0004E20

// XEVENT_STATS_CODE_HEALTHINTEROP_CREATE_FAILED, 20001, Error
#define XEVENT_STATS_CODE_HEALTHINTEROP_CREATE_FAILED 0xC0004E21

// XEVENT_STATS_CODE_HEALTHINTEROP_INIT_FAILED, 20002, Error
#define XEVENT_STATS_CODE_HEALTHINTEROP_INIT_FAILED 0xC0004E22

// XEVENT_STFD_MISSING_OR_BAD_CONFIG, 51596, Error
#define XEVENT_STFD_MISSING_OR_BAD_CONFIG 0xC000C98C

// XEVENT_STFD_MISSING_OR_BAD_CONFIG_1, 51598, Error
#define XEVENT_STFD_MISSING_OR_BAD_CONFIG_1 0xC000C98E

// XEVENT_XSTATSFD_INVALID_REQUEST, 52354, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST 0x8000CC82

// XEVENT_XSTATSFD_INVALID_REQUEST_1, 52355, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_1 0x8000CC83

// XEVENT_XSTATSFD_INVALID_REQUEST_2, 52356, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_2 0x8000CC84

// XEVENT_XSTATSFD_INVALID_REQUEST_3, 52357, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_3 0x8000CC85

// XEVENT_XSTATSFD_INVALID_REQUEST_4, 52360, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_4 0x8000CC88

// XEVENT_XSTATSFD_INVALID_REQUEST_5, 52361, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_5 0x8000CC89

// XEVENT_XSTATSFD_INVALID_REQUEST_6, 52362, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_6 0x8000CC8A

// XEVENT_XSTATSFD_INVALID_REQUEST_7, 52363, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_7 0x8000CC8B

// XEVENT_XSTATSFD_INVALID_REQUEST_8, 52364, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_8 0x8000CC8C

// XEVENT_STATS_CODE_0, 58050, Error
#define XEVENT_STATS_CODE_0 0xC000E2C2

// XEVENT_STATS_CODE_1, 58051, Error
#define XEVENT_STATS_CODE_1 0xC000E2C3

// XEVENT_STATS_CODE_2, 58052, Error
#define XEVENT_STATS_CODE_2 0xC000E2C4

// XEVENT_STATS_CODE_3, 58053, Error
#define XEVENT_STATS_CODE_3 0xC000E2C5

// XEVENT_STATS_CODE_4, 58054, Error
#define XEVENT_STATS_CODE_4 0xC000E2C6

// XEVENT_STATS_CODE_5, 58055, Error
#define XEVENT_STATS_CODE_5 0xC000E2C7

// XEVENT_STATS_CODE_6, 58056, Error
#define XEVENT_STATS_CODE_6 0xC000E2C8

// XEVENT_MC_APPLICATION_ERROR_9, 58057, Error
#define XEVENT_MC_APPLICATION_ERROR_9 0xC000E2C9

// XEVENT_STATS_CODE_8, 58058, Error
#define XEVENT_STATS_CODE_8 0xC000E2CA

// XEVENT_STATS_CODE_9, 58059, Error
#define XEVENT_STATS_CODE_9 0xC000E2CB

// XEVENT_STATS_CODE_10, 58060, Error
#define XEVENT_STATS_CODE_10 0xC000E2CC

// XEVENT_STATS_CODE_11, 58061, Error
#define XEVENT_STATS_CODE_11 0xC000E2CD

// XEVENT_XSTATSFD_DATABASE_ERROR, 58062, Error
#define XEVENT_XSTATSFD_DATABASE_ERROR 0xC000E2CE

// XEVENT_MC_APPLICATION_ERROR_10, 58063, Error
#define XEVENT_MC_APPLICATION_ERROR_10 0xC000E2CF

// XEVENT_STATS_CODE_14, 58064, Error
#define XEVENT_STATS_CODE_14 0xC000E2D0

// XEVENT_STATS_CODE_15, 58065, Error
#define XEVENT_STATS_CODE_15 0xC000E2D1

// XEVENT_STATS_CODE_16, 58066, Error
#define XEVENT_STATS_CODE_16 0xC000E2D2

// XEVENT_STATS_CODE_17, 58067, Error
#define XEVENT_STATS_CODE_17 0xC000E2D3

// XEVENT_STATS_CODE_18, 58068, Error
#define XEVENT_STATS_CODE_18 0xC000E2D4

// XEVENT_STATS_CODE_19, 58069, Error
#define XEVENT_STATS_CODE_19 0xC000E2D5

// XEVENT_XSTATSFD_INVALID_ATTACHMENT, 58070, Error
#define XEVENT_XSTATSFD_INVALID_ATTACHMENT 0xC000E2D6

// XEVENT_XSTATSFD_DATABASE_ERROR_1, 58071, Error
#define XEVENT_XSTATSFD_DATABASE_ERROR_1 0xC000E2D7

// XEVENT_MC_APPLICATION_ERROR_11, 58072, Error
#define XEVENT_MC_APPLICATION_ERROR_11 0xC000E2D8

// XEVENT_MC_APPLICATION_ERROR_12, 58073, Error
#define XEVENT_MC_APPLICATION_ERROR_12 0xC000E2D9

// XEVENT_STATS_CODE_24, 58074, Error
#define XEVENT_STATS_CODE_24 0xC000E2DA

// XEVENT_XSTATSFD_DATABASE_ERROR_2, 58075, Error
#define XEVENT_XSTATSFD_DATABASE_ERROR_2 0xC000E2DB

// XEVENT_STATS_CODE_26, 58076, Error
#define XEVENT_STATS_CODE_26 0xC000E2DC

// XEVENT_STATS_CODE_27, 58077, Error
#define XEVENT_STATS_CODE_27 0xC000E2DD

// XEVENT_STATS_CODE_28, 58078, Error
#define XEVENT_STATS_CODE_28 0xC000E2DE

// XEVENT_STATS_CODE_29, 58079, Error
#define XEVENT_STATS_CODE_29 0xC000E2DF

// XEVENT_STATS_CODE_30, 58080, Error
#define XEVENT_STATS_CODE_30 0xC000E2E0

// XEVENT_STATS_CODE_31, 58081, Error
#define XEVENT_STATS_CODE_31 0xC000E2E1

// XEVENT_STATS_CODE_32, 58082, Error
#define XEVENT_STATS_CODE_32 0xC000E2E2

// XEVENT_STATS_CODE_33, 58083, Error
#define XEVENT_STATS_CODE_33 0xC000E2E3

// XEVENT_STATS_CODE_34, 58084, Error
#define XEVENT_STATS_CODE_34 0xC000E2E4

// XEVENT_STATS_CODE_35, 58085, Error
#define XEVENT_STATS_CODE_35 0xC000E2E5

// XEVENT_STATS_CODE_36, 58086, Error
#define XEVENT_STATS_CODE_36 0xC000E2E6

// XEVENT_STATS_CODE_37, 58087, Error
#define XEVENT_STATS_CODE_37 0xC000E2E7

// XEVENT_STATS_CODE_38, 58088, Error
#define XEVENT_STATS_CODE_38 0xC000E2E8

// XEVENT_STATS_CODE_39, 58089, Error
#define XEVENT_STATS_CODE_39 0xC000E2E9

// XEVENT_STATS_CODE_40, 58090, Error
#define XEVENT_STATS_CODE_40 0xC000E2EA

// XEVENT_STATS_CODE_41, 58091, Error
#define XEVENT_STATS_CODE_41 0xC000E2EB

// XEVENT_STATS_CODE_42, 58092, Error
#define XEVENT_STATS_CODE_42 0xC000E2EC

// XEVENT_STATS_CODE_43, 58093, Error
#define XEVENT_STATS_CODE_43 0xC000E2ED

// XEVENT_XSMT_UNEXPECTED, 58094, Error
#define XEVENT_XSMT_UNEXPECTED 0xC000E2EE

// XEVENT_XSMT_UNEXPECTED_1, 58095, Error
#define XEVENT_XSMT_UNEXPECTED_1 0xC000E2EF

// XEVENT_XSMT_UNEXPECTED_2, 58096, Error
#define XEVENT_XSMT_UNEXPECTED_2 0xC000E2F0

// XEVENT_XSMT_UNEXPECTED_3, 58097, Error
#define XEVENT_XSMT_UNEXPECTED_3 0xC000E2F1

// XEVENT_XSMT_MEMORY_ERROR, 58098, Error
#define XEVENT_XSMT_MEMORY_ERROR 0xC000E2F2

// XEVENT_STATS_CODE_49, 58099, Error
#define XEVENT_STATS_CODE_49 0xC000E2F3

// XEVENT_STATS_CODE_50, 58100, Error
#define XEVENT_STATS_CODE_50 0xC000E2F4

// XEVENT_STATS_CODE_51, 58101, Error
#define XEVENT_STATS_CODE_51 0xC000E2F5

// XEVENT_STATS_CODE_52, 58102, Error
#define XEVENT_STATS_CODE_52 0xC000E2F6

// XEVENT_STATS_CODE_53, 58103, Error
#define XEVENT_STATS_CODE_53 0xC000E2F7

// XEVENT_XSMT_UNEXPECTED_4, 58104, Error
#define XEVENT_XSMT_UNEXPECTED_4 0xC000E2F8

// XEVENT_XSMT_UNEXPECTED_5, 58105, Error
#define XEVENT_XSMT_UNEXPECTED_5 0xC000E2F9

// XEVENT_STATS_CODE_56, 58106, Error
#define XEVENT_STATS_CODE_56 0xC000E2FA

// XEVENT_XSMT_UNEXPECTED_6, 58107, Error
#define XEVENT_XSMT_UNEXPECTED_6 0xC000E2FB

// XEVENT_XSMT_UNEXPECTED_7, 58108, Error
#define XEVENT_XSMT_UNEXPECTED_7 0xC000E2FC

// XEVENT_STATS_CODE_59, 58109, Error
#define XEVENT_STATS_CODE_59 0xC000E2FD

// XEVENT_STATS_CODE_60, 58110, Error
#define XEVENT_STATS_CODE_60 0xC000E2FE

// XEVENT_XSMT_UNEXPECTED_8, 58111, Error
#define XEVENT_XSMT_UNEXPECTED_8 0xC000E2FF

// XEVENT_XSMT_UNEXPECTED_9, 58112, Error
#define XEVENT_XSMT_UNEXPECTED_9 0xC000E300

// XEVENT_XSMT_UNEXPECTED_10, 58113, Error
#define XEVENT_XSMT_UNEXPECTED_10 0xC000E301

// XEVENT_XSMT_UNEXPECTED_11, 58114, Error
#define XEVENT_XSMT_UNEXPECTED_11 0xC000E302

// XEVENT_STATS_CODE_65, 58115, Error
#define XEVENT_STATS_CODE_65 0xC000E303

// XEVENT_STATS_CODE_66, 58116, Error
#define XEVENT_STATS_CODE_66 0xC000E304

// XEVENT_STATS_CODE_67, 58117, Error
#define XEVENT_STATS_CODE_67 0xC000E305

// XEVENT_STATS_CODE_68, 58118, Error
#define XEVENT_STATS_CODE_68 0xC000E306

// XEVENT_STATS_CODE_69, 58119, Error
#define XEVENT_STATS_CODE_69 0xC000E307

// XEVENT_STATS_CODE_70, 58120, Error
#define XEVENT_STATS_CODE_70 0xC000E308

// XEVENT_STATS_CODE_71, 58121, Error
#define XEVENT_STATS_CODE_71 0xC000E309

// XEVENT_STATS_CODE_72, 58122, Error
#define XEVENT_STATS_CODE_72 0xC000E30A

// XEVENT_STATS_CODE_73, 58123, Error
#define XEVENT_STATS_CODE_73 0xC000E30B

// XEVENT_STATS_CODE_74, 58124, Error
#define XEVENT_STATS_CODE_74 0xC000E30C

// XEVENT_XSMT_UNEXPECTED_12, 58125, Error
#define XEVENT_XSMT_UNEXPECTED_12 0xC000E30D

// XEVENT_XSMT_UNEXPECTED_13, 58126, Error
#define XEVENT_XSMT_UNEXPECTED_13 0xC000E30E

// XEVENT_STATS_CODE_77, 58127, Error
#define XEVENT_STATS_CODE_77 0xC000E30F

// XEVENT_XSMT_UNEXPECTED_14, 58128, Error
#define XEVENT_XSMT_UNEXPECTED_14 0xC000E310

// XEVENT_XSMT_UNEXPECTED_15, 58129, Error
#define XEVENT_XSMT_UNEXPECTED_15 0xC000E311

// XEVENT_XSMT_UNEXPECTED_16, 58130, Error
#define XEVENT_XSMT_UNEXPECTED_16 0xC000E312

// XEVENT_STATS_CODE_81, 58131, Error
#define XEVENT_STATS_CODE_81 0xC000E313

// XEVENT_STATS_CODE_82, 58132, Error
#define XEVENT_STATS_CODE_82 0xC000E314

// XEVENT_XSMT_UNEXPECTED_17, 58133, Error
#define XEVENT_XSMT_UNEXPECTED_17 0xC000E315

// XEVENT_XSMT_UNEXPECTED_18, 58134, Error
#define XEVENT_XSMT_UNEXPECTED_18 0xC000E316

// XEVENT_STATS_CODE_85, 58135, Error
#define XEVENT_STATS_CODE_85 0xC000E317

// XEVENT_STATS_CODE_86, 58136, Error
#define XEVENT_STATS_CODE_86 0xC000E318

// XEVENT_STATS_CODE_87, 58137, Error
#define XEVENT_STATS_CODE_87 0xC000E319

// XEVENT_STATS_CODE_88, 58138, Error
#define XEVENT_STATS_CODE_88 0xC000E31A

// XEVENT_STATS_CODE_89, 58139, Error
#define XEVENT_STATS_CODE_89 0xC000E31B

// XEVENT_STATS_CODE_90, 58140, Error
#define XEVENT_STATS_CODE_90 0xC000E31C

// XEVENT_STATS_CODE_91, 58141, Error
#define XEVENT_STATS_CODE_91 0xC000E31D

// XEVENT_STATS_CODE_92, 58142, Error
#define XEVENT_STATS_CODE_92 0xC000E31E

// XEVENT_STATS_CODE_93, 58143, Error
#define XEVENT_STATS_CODE_93 0xC000E31F

// XEVENT_STATS_CODE_94, 58144, Error
#define XEVENT_STATS_CODE_94 0xC000E320

// XEVENT_STATS_CODE_95, 58145, Error
#define XEVENT_STATS_CODE_95 0xC000E321

// XEVENT_STATS_CODE_96, 58146, Error
#define XEVENT_STATS_CODE_96 0xC000E322

// XEVENT_STATS_CODE_97, 58147, Error
#define XEVENT_STATS_CODE_97 0xC000E323

// XEVENT_STATS_CODE_98, 58148, Error
#define XEVENT_STATS_CODE_98 0xC000E324

// XEVENT_STATS_CODE_99, 58149, Error
#define XEVENT_STATS_CODE_99 0xC000E325

// XEVENT_STATS_CODE_100, 58150, Error
#define XEVENT_STATS_CODE_100 0xC000E326

// XEVENT_STATS_CODE_101, 58151, Error
#define XEVENT_STATS_CODE_101 0xC000E327

// XEVENT_STATS_CODE_102, 58152, Error
#define XEVENT_STATS_CODE_102 0xC000E328

// XEVENT_STATS_CODE_103, 58153, Error
#define XEVENT_STATS_CODE_103 0xC000E329

// XEVENT_STATS_CODE_104, 58154, Error
#define XEVENT_STATS_CODE_104 0xC000E32A

// XEVENT_STATS_CODE_105, 58155, Error
#define XEVENT_STATS_CODE_105 0xC000E32B

// XEVENT_STATS_CODE_106, 58156, Error
#define XEVENT_STATS_CODE_106 0xC000E32C

// XEVENT_STATS_CODE_107, 58157, Error
#define XEVENT_STATS_CODE_107 0xC000E32D

// XEVENT_STATS_CODE_108, 58158, Error
#define XEVENT_STATS_CODE_108 0xC000E32E

// XEVENT_XBOX_ACHIEVEMENTS_NOT_SUPPORTED, 58159, Error
#define XEVENT_XBOX_ACHIEVEMENTS_NOT_SUPPORTED 0xC000E32F

// XEVENT_XBOX360_ACHIEVEMENTS_NOT_SUPPORTED, 58160, Error
#define XEVENT_XBOX360_ACHIEVEMENTS_NOT_SUPPORTED 0xC000E330

// XEVENT_PC_ACHIEVEMENTS_NOT_SUPPORTED, 58161, Error
#define XEVENT_PC_ACHIEVEMENTS_NOT_SUPPORTED 0xC000E331

// XEVENT_UNKNOWN_PLATFORM_ACHIEVEMENTS_NOT_SUPPORTED, 58162, Error
#define XEVENT_UNKNOWN_PLATFORM_ACHIEVEMENTS_NOT_SUPPORTED 0xC000E332

// XEVENT_STATS_COMM_0, 58250, Error
#define XEVENT_STATS_COMM_0 0xC000E38A

// XEVENT_STATS_COMM_1, 58251, Error
#define XEVENT_STATS_COMM_1 0xC000E38B

// XEVENT_STATS_COMM_2, 58252, Error
#define XEVENT_STATS_COMM_2 0xC000E38C

// XEVENT_STATS_COMM_3, 58253, Error
#define XEVENT_STATS_COMM_3 0xC000E38D

// XEVENT_STATS_COMM_4, 58254, Error
#define XEVENT_STATS_COMM_4 0xC000E38E

// XEVENT_STATS_COMM_5, 58255, Error
#define XEVENT_STATS_COMM_5 0xC000E38F

// XEVENT_STATS_COMM_6, 58256, Error
#define XEVENT_STATS_COMM_6 0xC000E390

// XEVENT_STATS_COMM_7, 58257, Error
#define XEVENT_STATS_COMM_7 0xC000E391

// XEVENT_STATS_COMM_8, 58258, Error
#define XEVENT_STATS_COMM_8 0xC000E392

// XEVENT_XSTATSFD_SQL_CONNECT_FAILED, 58259, Error
#define XEVENT_XSTATSFD_SQL_CONNECT_FAILED 0xC000E393

// XEVENT_STATS_COMM_10, 58260, Error
#define XEVENT_STATS_COMM_10 0xC000E394

// XEVENT_STATS_COMM_11, 58261, Error
#define XEVENT_STATS_COMM_11 0xC000E395

// XEVENT_STATS_COMM_12, 58262, Error
#define XEVENT_STATS_COMM_12 0xC000E396

// XEVENT_STATS_COMM_13, 58263, Error
#define XEVENT_STATS_COMM_13 0xC000E397

// XEVENT_LBS_NETWORK_ERROR, 58264, Error
#define XEVENT_LBS_NETWORK_ERROR 0xC000E398

// XEVENT_LBS_FATAL_ERROR, 58265, Error
#define XEVENT_LBS_FATAL_ERROR 0xC000E399

// XEVENT_LBS_NETWORK_ERROR_1, 58266, Error
#define XEVENT_LBS_NETWORK_ERROR_1 0xC000E39A

// XEVENT_LBS_LOAD_THREAD_ERROR_1, 58267, Error
#define XEVENT_LBS_LOAD_THREAD_ERROR_1 0xC000E39B

// XEVENT_LBS_LOAD_THREAD_WARNING_1, 58268, Warning
#define XEVENT_LBS_LOAD_THREAD_WARNING_1 0x8000E39C

// XEVENT_STATS_CONFIG_0, 58300, Error
#define XEVENT_STATS_CONFIG_0 0xC000E3BC

// XEVENT_STATS_CONFIG_1, 58301, Error
#define XEVENT_STATS_CONFIG_1 0xC000E3BD

// XEVENT_STATS_CONFIG_2, 58302, Error
#define XEVENT_STATS_CONFIG_2 0xC000E3BE

// XEVENT_STATS_CONFIG_3, 58303, Error
#define XEVENT_STATS_CONFIG_3 0xC000E3BF

// XEVENT_STATS_CONFIG_4, 58304, Error
#define XEVENT_STATS_CONFIG_4 0xC000E3C0

// XEVENT_STATS_CONFIG_5, 58305, Error
#define XEVENT_STATS_CONFIG_5 0xC000E3C1

// XEVENT_XSTATSFD_MISSING_DB_MAPPING, 58306, Error
#define XEVENT_XSTATSFD_MISSING_DB_MAPPING 0xC000E3C2

// XEVENT_XSTATSFD_MISSING_DB_MAPPING_1, 58307, Error
#define XEVENT_XSTATSFD_MISSING_DB_MAPPING_1 0xC000E3C3

// XEVENT_XSTATSFD_MISSING_DB_MAPPING_2, 58308, Error
#define XEVENT_XSTATSFD_MISSING_DB_MAPPING_2 0xC000E3C4

// XEVENT_STATS_CONFIG_9, 58309, Error
#define XEVENT_STATS_CONFIG_9 0xC000E3C5

// XEVENT_XSTATSFD_LEADERBOARD_READONLY, 58310, Warning
#define XEVENT_XSTATSFD_LEADERBOARD_READONLY 0x8000E3C6

// XEVENT_STATS_CONFIG_11, 58311, Warning
#define XEVENT_STATS_CONFIG_11 0x8000E3C7

// XEVENT_STATS_CONFIG_12, 58312, Warning
#define XEVENT_STATS_CONFIG_12 0x8000E3C8

// XEVENT_STATS_CONFIG_13, 58313, Warning
#define XEVENT_STATS_CONFIG_13 0x8000E3C9

// XEVENT_STATS_CONFIG_14, 58314, Warning
#define XEVENT_STATS_CONFIG_14 0x8000E3CA

// XEVENT_STATS_CONFIG_15, 58315, Warning
#define XEVENT_STATS_CONFIG_15 0x8000E3CB

// XEVENT_STATS_CONFIG_16, 58316, Warning
#define XEVENT_STATS_CONFIG_16 0x8000E3CC

// XEVENT_STATS_CONFIG_17, 58317, Error
#define XEVENT_STATS_CONFIG_17 0xC000E3CD

// XEVENT_STATS_CONFIG_18, 58318, Error
#define XEVENT_STATS_CONFIG_18 0xC000E3CE

// XEVENT_STATS_CONFIG_19, 58319, Error
#define XEVENT_STATS_CONFIG_19 0xC000E3CF

// XEVENT_STATS_CONFIG_20, 58320, Error
#define XEVENT_STATS_CONFIG_20 0xC000E3D0

// XEVENT_XSTATSFD_ALLOW_UNVERIFIED_STAT_WRITE_IS_ON, 58321, Warning
#define XEVENT_XSTATSFD_ALLOW_UNVERIFIED_STAT_WRITE_IS_ON 0x8000E3D1

// XEVENT_STATS_CONFIG_22, 58322, Warning
#define XEVENT_STATS_CONFIG_22 0x8000E3D2

// XEVENT_STATS_CONFIG_23, 58323, Warning
#define XEVENT_STATS_CONFIG_23 0x8000E3D3

// XEVENT_STATS_CONFIG_24, 58324, Warning
#define XEVENT_STATS_CONFIG_24 0x8000E3D4

// XEVENT_STATS_CONFIG_25, 58325, Warning
#define XEVENT_STATS_CONFIG_25 0x8000E3D5

// XEVENT_STATS_CONFIG_26, 58326, Error
#define XEVENT_STATS_CONFIG_26 0xC000E3D6

// XEVENT_XSMT_INIT_FAILED, 58327, Error
#define XEVENT_XSMT_INIT_FAILED 0xC000E3D7

// XEVENT_XSMT_INIT_FAILED_1, 58328, Error
#define XEVENT_XSMT_INIT_FAILED_1 0xC000E3D8

// XEVENT_STATS_CONFIG_29, 58329, Error
#define XEVENT_STATS_CONFIG_29 0xC000E3D9

// XEVENT_STATS_CONFIG_30, 58330, Error
#define XEVENT_STATS_CONFIG_30 0xC000E3DA

// XEVENT_STATS_CONFIG_31, 58331, Error
#define XEVENT_STATS_CONFIG_31 0xC000E3DB

// XEVENT_STATS_CONFIG_32, 58332, Error
#define XEVENT_STATS_CONFIG_32 0xC000E3DC

// XEVENT_STATS_CONFIG_33, 58333, Error
#define XEVENT_STATS_CONFIG_33 0xC000E3DD

// XEVENT_STATS_CONFIG_34, 58334, Error
#define XEVENT_STATS_CONFIG_34 0xC000E3DE

// XEVENT_STATS_CONFIG_35, 58335, Error
#define XEVENT_STATS_CONFIG_35 0xC000E3DF

// XEVENT_STATS_CONFIG_36, 58336, Error
#define XEVENT_STATS_CONFIG_36 0xC000E3E0

// XEVENT_STATS_CONFIG_37, 58337, Error
#define XEVENT_STATS_CONFIG_37 0xC000E3E1

// XEVENT_STATS_CONFIG_38, 58338, Error
#define XEVENT_STATS_CONFIG_38 0xC000E3E2

// XEVENT_STATS_CONFIG_39, 58339, Error
#define XEVENT_STATS_CONFIG_39 0xC000E3E3

// XEVENT_STATS_CONFIG_40, 58340, Error
#define XEVENT_STATS_CONFIG_40 0xC000E3E4

// XEVENT_STATS_CONFIG_41, 58341, Error
#define XEVENT_STATS_CONFIG_41 0xC000E3E5

// XEVENT_STATS_CONFIG_42, 58342, Error
#define XEVENT_STATS_CONFIG_42 0xC000E3E6

// XEVENT_STATS_CONFIG_43, 58343, Error
#define XEVENT_STATS_CONFIG_43 0xC000E3E7

// XEVENT_STATS_NO_XLAST_IN_TITLE_SYNC, 58344, Warning
#define XEVENT_STATS_NO_XLAST_IN_TITLE_SYNC 0x8000E3E8

// XEVENT_STATS_HACK_0, 58400, Warning
#define XEVENT_STATS_HACK_0 0x8000E420

// XEVENT_STATS_HACK_1, 58401, Warning
#define XEVENT_STATS_HACK_1 0x8000E421

// XEVENT_STATS_HACK_2, 58402, Warning
#define XEVENT_STATS_HACK_2 0x8000E422

// XEVENT_STATS_HACK_3, 58403, Warning
#define XEVENT_STATS_HACK_3 0x8000E423

// XEVENT_STATS_HACK_4, 58404, Warning
#define XEVENT_STATS_HACK_4 0x8000E424

// XEVENT_STATS_HACK_5, 58405, Warning
#define XEVENT_STATS_HACK_5 0x8000E425

// XEVENT_XSTATSFD_INVALID_REQUEST_9, 58406, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_9 0x8000E426

// XEVENT_XSTATSFD_INVALID_REQUEST_10, 58407, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_10 0x8000E427

// XEVENT_XSTATSFD_INVALID_REQUEST_11, 58408, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_11 0x8000E428

// XEVENT_XSTATSFD_INVALID_REQUEST_12, 58409, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_12 0x8000E429

// XEVENT_STATS_HACK_10, 58410, Warning
#define XEVENT_STATS_HACK_10 0x8000E42A

// XEVENT_XSTATSFD_INVALID_REQUEST_13, 58411, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_13 0x8000E42B

// XEVENT_XSTATSFD_INVALID_REQUEST_14, 58412, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_14 0x8000E42C

// XEVENT_XSTATSFD_INVALID_REQUEST_15, 58413, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_15 0x8000E42D

// XEVENT_STATS_HACK_14, 58414, Warning
#define XEVENT_STATS_HACK_14 0x8000E42E

// XEVENT_STATS_HACK_15, 58415, Warning
#define XEVENT_STATS_HACK_15 0x8000E42F

// XEVENT_STATS_HACK_16, 58416, Warning
#define XEVENT_STATS_HACK_16 0x8000E430

// XEVENT_STATS_HACK_17, 58417, Warning
#define XEVENT_STATS_HACK_17 0x8000E431

// XEVENT_XSTATSFD_INVALID_REQUEST_16, 58418, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_16 0x8000E432

// XEVENT_STATS_HACK_19, 58419, Warning
#define XEVENT_STATS_HACK_19 0x8000E433

// XEVENT_STATS_HACK_20, 58420, Warning
#define XEVENT_STATS_HACK_20 0x8000E434

// XEVENT_STATS_HACK_21, 58421, Warning
#define XEVENT_STATS_HACK_21 0x8000E435

// XEVENT_STATS_HACK_22, 58422, Warning
#define XEVENT_STATS_HACK_22 0x8000E436

// XEVENT_XSTATSFD_INVALID_REQUEST_17, 58423, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_17 0x8000E437

// XEVENT_STATS_HACK_24, 58424, Warning
#define XEVENT_STATS_HACK_24 0x8000E438

// XEVENT_STATS_HACK_25, 58425, Warning
#define XEVENT_STATS_HACK_25 0x8000E439

// XEVENT_XSTATSFD_INVALID_REQUEST_18, 58426, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_18 0x8000E43A

// XEVENT_STATS_HACK_27, 58427, Warning
#define XEVENT_STATS_HACK_27 0x8000E43B

// XEVENT_XSTATSFD_INVALID_REQUEST_19, 58428, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_19 0x8000E43C

// XEVENT_STATS_HACK_29, 58429, Warning
#define XEVENT_STATS_HACK_29 0x8000E43D

// XEVENT_XSTATSFD_INVALID_REQUEST_20, 58430, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_20 0x8000E43E

// XEVENT_XSTATSFD_INVALID_REQUEST_21, 58431, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_21 0x8000E43F

// XEVENT_XSTATSFD_INVALID_REQUEST_22, 58432, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_22 0x8000E440

// XEVENT_XSTATSFD_INVALID_REQUEST_23, 58433, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_23 0x8000E441

// XEVENT_XSTATSFD_INVALID_REQUEST_24, 58434, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_24 0x8000E442

// XEVENT_XSTATSFD_INVALID_REQUEST_25, 58435, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_25 0x8000E443

// XEVENT_XSTATSFD_INVALID_REQUEST_26, 58436, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_26 0x8000E444

// XEVENT_XSTATSFD_INVALID_REQUEST_27, 58437, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_27 0x8000E445

// XEVENT_XSTATSFD_INVALID_REQUEST_28, 58438, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_28 0x8000E446

// XEVENT_XSTATSFD_INVALID_REQUEST_29, 58439, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_29 0x8000E447

// XEVENT_XSTATSFD_INVALID_REQUEST_30, 58440, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_30 0x8000E448

// XEVENT_XSTATSFD_INVALID_REQUEST_31, 58441, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_31 0x8000E449

// XEVENT_XSTATSFD_INVALID_REQUEST_32, 58442, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_32 0x8000E44A

// XEVENT_XSTATSFD_INVALID_REQUEST_33, 58443, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_33 0x8000E44B

// XEVENT_XSTATSFD_INVALID_REQUEST_34, 58444, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_34 0x8000E44C

// XEVENT_XSTATSFD_INVALID_REQUEST_35, 58445, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_35 0x8000E44D

// XEVENT_XSTATSFD_INVALID_REQUEST_36, 58446, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_36 0x8000E44E

// XEVENT_XSTATSFD_INVALID_REQUEST_37, 58447, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_37 0x8000E44F

// XEVENT_XSTATSFD_INVALID_REQUEST_38, 58448, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_38 0x8000E450

// XEVENT_XSTATSFD_INVALID_REQUEST_39, 58449, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_39 0x8000E451

// XEVENT_XSTATSFD_INVALID_REQUEST_40, 58450, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_40 0x8000E452

// XEVENT_STATS_HACK_51, 58451, Warning
#define XEVENT_STATS_HACK_51 0x8000E453

// XEVENT_XSTATSFD_RESET_CHECK_FAILED, 58452, Warning
#define XEVENT_XSTATSFD_RESET_CHECK_FAILED 0x8000E454

// XEVENT_STATS_HACK_53, 58453, Warning
#define XEVENT_STATS_HACK_53 0x8000E455

// XEVENT_XSTATSFD_INVALID_REQUEST_41, 58454, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_41 0x8000E456

// XEVENT_XSTATSFD_INVALID_REQUEST_42, 58455, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_42 0x8000E457

// XEVENT_XSTATSFD_INVALID_REQUEST_43, 58456, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_43 0x8000E458

// XEVENT_STATS_HACK_57, 58457, Warning
#define XEVENT_STATS_HACK_57 0x8000E459

// XEVENT_STATS_HACK_58, 58458, Warning
#define XEVENT_STATS_HACK_58 0x8000E45A

// XEVENT_XSTATSFD_INVALID_REQUEST_44, 58459, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_44 0x8000E45B

// XEVENT_XSTATSFD_INVALID_REQUEST_45, 58460, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_45 0x8000E45C

// XEVENT_STATS_HACK_61, 58461, Warning
#define XEVENT_STATS_HACK_61 0x8000E45D

// XEVENT_STATS_HACK_62, 58462, Warning
#define XEVENT_STATS_HACK_62 0x8000E45E

// XEVENT_XSTATSFD_INVALID_REQUEST_46, 58463, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_46 0x8000E45F

// XEVENT_XSTATSFD_INVALID_REQUEST_47, 58464, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_47 0x8000E460

// XEVENT_XSTATSFD_INVALID_REQUEST_48, 58465, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_48 0x8000E461

// XEVENT_STATS_HACK_66, 58466, Warning
#define XEVENT_STATS_HACK_66 0x8000E462

// XEVENT_STATS_HACK_67, 58467, Warning
#define XEVENT_STATS_HACK_67 0x8000E463

// XEVENT_STATS_HACK_68, 58468, Warning
#define XEVENT_STATS_HACK_68 0x8000E464

// XEVENT_STATS_HACK_69, 58469, Warning
#define XEVENT_STATS_HACK_69 0x8000E465

// XEVENT_XSTATSFD_INVALID_REQUEST_49, 58470, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_49 0x8000E466

// XEVENT_STATS_HACK_71, 58471, Warning
#define XEVENT_STATS_HACK_71 0x8000E467

// XEVENT_STATS_HACK_72, 58472, Warning
#define XEVENT_STATS_HACK_72 0x8000E468

// XEVENT_STATS_HACK_73, 58473, Warning
#define XEVENT_STATS_HACK_73 0x8000E469

// XEVENT_STATS_HACK_74, 58474, Warning
#define XEVENT_STATS_HACK_74 0x8000E46A

// XEVENT_XSTATSFD_INVALID_REQUEST_50, 58475, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_50 0x8000E46B

// XEVENT_STATS_HACK_76, 58476, Warning
#define XEVENT_STATS_HACK_76 0x8000E46C

// XEVENT_STATS_HACK_77, 58477, Warning
#define XEVENT_STATS_HACK_77 0x8000E46D

// XEVENT_XSTATSFD_INVALID_REQUEST_51, 58478, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_51 0x8000E46E

// XEVENT_STATS_HACK_79, 58479, Warning
#define XEVENT_STATS_HACK_79 0x8000E46F

// XEVENT_STATS_HACK_80, 58480, Warning
#define XEVENT_STATS_HACK_80 0x8000E470

// XEVENT_XSTATSFD_INVALID_REQUEST_52, 58481, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_52 0x8000E471

// XEVENT_XSTATSFD_INVALID_REQUEST_53, 58482, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_53 0x8000E472

// XEVENT_XSTATSFD_INVALID_REQUEST_54, 58483, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_54 0x8000E473

// XEVENT_XSTATSFD_INVALID_REQUEST_55, 58484, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_55 0x8000E474

// XEVENT_XSTATSFD_INVALID_REQUEST_56, 58485, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_56 0x8000E475

// XEVENT_XSTATSFD_INVALID_REQUEST_57, 58486, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_57 0x8000E476

// XEVENT_XSTATSFD_INVALID_REQUEST_58, 58487, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_58 0x8000E477

// XEVENT_XSTATSFD_INVALID_REQUEST_59, 58488, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_59 0x8000E478

// XEVENT_XSTATSFD_INVALID_REQUEST_60, 58489, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_60 0x8000E479

// XEVENT_XSTATSFD_INVALID_REQUEST_61, 58490, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_61 0x8000E47A

// XEVENT_XSTATSFD_INVALID_REQUEST_62, 58491, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_62 0x8000E47B

// XEVENT_XSTATSFD_INVALID_REQUEST_63, 58492, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_63 0x8000E47C

// XEVENT_XSTATSFD_INVALID_REQUEST_64, 58493, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_64 0x8000E47D

// XEVENT_XSTATSFD_INVALID_REQUEST_65, 58494, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_65 0x8000E47E

// XEVENT_XSTATSFD_INVALID_REQUEST_66, 58495, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_66 0x8000E47F

// XEVENT_XSTATSFD_INVALID_REQUEST_67, 58496, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_67 0x8000E480

// XEVENT_STATS_HACK_97, 58497, Warning
#define XEVENT_STATS_HACK_97 0x8000E481

// XEVENT_STATS_HACK_98, 58498, Warning
#define XEVENT_STATS_HACK_98 0x8000E482

// XEVENT_STATS_HACK_99, 58499, Warning
#define XEVENT_STATS_HACK_99 0x8000E483

// XEVENT_XSTATSFD_INVALID_REQUEST_68, 58500, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_68 0x8000E484

// XEVENT_XSTATSFD_INVALID_REQUEST_69, 58501, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_69 0x8000E485

// XEVENT_XSTATSFD_INVALID_REQUEST_70, 58502, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_70 0x8000E486

// XEVENT_XSTATSFD_INVALID_REQUEST_71, 58503, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_71 0x8000E487

// XEVENT_XSTATSFD_INVALID_REQUEST_72, 58504, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_72 0x8000E488

// XEVENT_XSTATSFD_INVALID_REQUEST_73, 58505, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_73 0x8000E489

// XEVENT_XSTATSFD_INVALID_REQUEST_74, 58506, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_74 0x8000E48A

// XEVENT_STATS_HACK_100, 58507, Warning
#define XEVENT_STATS_HACK_100 0x8000E48B

// XEVENT_STATS_HACK_101, 58508, Warning
#define XEVENT_STATS_HACK_101 0x8000E48C

// XEVENT_STATS_HACK_102, 58509, Warning
#define XEVENT_STATS_HACK_102 0x8000E48D

// XEVENT_STATS_MUSIGMA_ARITHMETIC_NAN_1, 58510, Warning
#define XEVENT_STATS_MUSIGMA_ARITHMETIC_NAN_1 0x8000E48E

// XEVENT_STATS_MUSIGMA_ARITHMETIC_NAN_2, 58511, Warning
#define XEVENT_STATS_MUSIGMA_ARITHMETIC_NAN_2 0x8000E48F

// XEVENT_XSTATSFD_INVALID_REQUEST_75, 58512, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_75 0x8000E490

// XEVENT_XSTATSFD_MUSIGMA_NOT_GAME_MODE_1, 58513, Warning
#define XEVENT_XSTATSFD_MUSIGMA_NOT_GAME_MODE_1 0x8000E491

// XEVENT_XSTATSFD_INVALID_REQUEST_76, 58514, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_76 0x8000E492

// XEVENT_XSTATSFD_INVALID_REQUEST_77, 58515, Warning
#define XEVENT_XSTATSFD_INVALID_REQUEST_77 0x8000E493

// XEVENT_XSTATSFD_ESTIMATE_RANK_ERROR_1, 58516, Warning
#define XEVENT_XSTATSFD_ESTIMATE_RANK_ERROR_1 0x8000E494

// XEVENT_XSTATSFD_ESTIMATE_RANK_ERROR_2, 58517, Warning
#define XEVENT_XSTATSFD_ESTIMATE_RANK_ERROR_2 0x8000E495

// XEVENT_XSTATSFD_STATDB_INVALID_ATTACHMENT_SIZE_1, 58518, Warning
#define XEVENT_XSTATSFD_STATDB_INVALID_ATTACHMENT_SIZE_1 0x8000E496

// XEVENT_LB_WS_INTEROP_UNABLE_TO_RETRIEVE_STAT, 58519, Warning
#define XEVENT_LB_WS_INTEROP_UNABLE_TO_RETRIEVE_STAT 0x8000E497

// XEVENT_LB_WS_INTEROP_UNABLE_TO_CALL_READ, 58520, Warning
#define XEVENT_LB_WS_INTEROP_UNABLE_TO_CALL_READ 0x8000E498

// XEVENT_LB_WS_INTEROP_UNABLE_TO_CALL_GETNEXTROW, 58521, Warning
#define XEVENT_LB_WS_INTEROP_UNABLE_TO_CALL_GETNEXTROW 0x8000E499

// XEVENT_LB_WS_INTEROP_UNABLE_TO_CALL_STATS_UPDATE, 58522, Warning
#define XEVENT_LB_WS_INTEROP_UNABLE_TO_CALL_STATS_UPDATE 0x8000E49A

// XEVENT_LB_WS_INTEROP_UNABLE_TO_CALL_STATS_REMOVE, 58523, Warning
#define XEVENT_LB_WS_INTEROP_UNABLE_TO_CALL_STATS_REMOVE 0x8000E49B

// XEVENT_LB_WS_INTEROP_UNABLE_TO_CALL_LOAD_STATS, 58524, Warning
#define XEVENT_LB_WS_INTEROP_UNABLE_TO_CALL_LOAD_STATS 0x8000E49C

// XEVENT_LB_WS_INTEROP_UNABLE_TO_CALL_REMOVE_LB, 58525, Warning
#define XEVENT_LB_WS_INTEROP_UNABLE_TO_CALL_REMOVE_LB 0x8000E49D

// XEVENT_LB_WS_INTEROP_UNABLE_TO_GET_PHYSICAL_PARTITION_COUNT, 58526, Warning
#define XEVENT_LB_WS_INTEROP_UNABLE_TO_GET_PHYSICAL_PARTITION_COUNT 0x8000E49E

// XEVENT_LB_WS_INTEROP_UNABLE_TO_GET_LOGICAL_PARTITION_COUNT, 58527, Warning
#define XEVENT_LB_WS_INTEROP_UNABLE_TO_GET_LOGICAL_PARTITION_COUNT 0x8000E49F

// XEVENT_STATS_INFO_0, 58800, Info
#define XEVENT_STATS_INFO_0 0x4000E5B0

// XEVENT_STATS_INFO_1, 58801, Info
#define XEVENT_STATS_INFO_1 0x4000E5B1

// XEVENT_STATS_INFO_2, 58802, Info
#define XEVENT_STATS_INFO_2 0x4000E5B2

// XEVENT_STATS_INFO_3, 58803, Info
#define XEVENT_STATS_INFO_3 0x4000E5B3

// XEVENT_STATS_INFO_4, 58804, Info
#define XEVENT_STATS_INFO_4 0x4000E5B4

// XEVENT_STATS_INFO_5, 58805, Info
#define XEVENT_STATS_INFO_5 0x4000E5B5

// XEVENT_STATS_INFO_6, 58806, Info
#define XEVENT_STATS_INFO_6 0x4000E5B6

// XEVENT_STATS_INFO_7, 58807, Info
#define XEVENT_STATS_INFO_7 0x4000E5B7

// XEVENT_STATS_INFO_8, 58808, Info
#define XEVENT_STATS_INFO_8 0x4000E5B8

// XEVENT_STATS_INFO_9, 58809, Info
#define XEVENT_STATS_INFO_9 0x4000E5B9

// XEVENT_STATS_INFO_10, 58810, Info
#define XEVENT_STATS_INFO_10 0x4000E5BA

// XEVENT_STATS_INFO_11, 58811, Info
#define XEVENT_STATS_INFO_11 0x4000E5BB

// XEVENT_STATS_INFO_12, 58812, Info
#define XEVENT_STATS_INFO_12 0x4000E5BC

// XEVENT_STATS_INFO_13, 58813, Info
#define XEVENT_STATS_INFO_13 0x4000E5BD

// XEVENT_STATS_INFO_14, 58814, Info
#define XEVENT_STATS_INFO_14 0x4000E5BE

// XEVENT_STATS_INFO_15, 58815, Info
#define XEVENT_STATS_INFO_15 0x4000E5BF

// XEVENT_STATS_INFO_16, 58816, Info
#define XEVENT_STATS_INFO_16 0x4000E5C0

// XEVENT_STATS_INFO_17, 58817, Info
#define XEVENT_STATS_INFO_17 0x4000E5C1

// XEVENT_STATS_INFO_18, 58818, Info
#define XEVENT_STATS_INFO_18 0x4000E5C2

// XEVENT_STATS_INFO_19, 58819, Info
#define XEVENT_STATS_INFO_19 0x4000E5C3

// XEVENT_STATS_INFO_20, 58820, Info
#define XEVENT_STATS_INFO_20 0x4000E5C4

// XEVENT_STATS_INFO_21, 58821, Info
#define XEVENT_STATS_INFO_21 0x4000E5C5

// XEVENT_STATS_INFO_22, 58822, Info
#define XEVENT_STATS_INFO_22 0x4000E5C6

// XEVENT_STATS_INFO_23, 58823, Info
#define XEVENT_STATS_INFO_23 0x4000E5C7

// XEVENT_STATS_INFO_24, 58824, Info
#define XEVENT_STATS_INFO_24 0x4000E5C8

// XEVENT_STATS_INFO_25, 58825, Info
#define XEVENT_STATS_INFO_25 0x4000E5C9

// XEVENT_STATS_INFO_26, 58826, Info
#define XEVENT_STATS_INFO_26 0x4000E5CA

// XEVENT_LBSVR_LOAD_SUCCESS_INFO_1, 58827, Info
#define XEVENT_LBSVR_LOAD_SUCCESS_INFO_1 0x4000E5CB

// XEVENT_LBSVR_DB_LOAD_NUM_RETRY_SETTING, 58828, Info
#define XEVENT_LBSVR_DB_LOAD_NUM_RETRY_SETTING 0x4000E5CC

// XEVENT_LBSVR_DB_LOAD_INTERVAL_SECONDS_SETTING, 58829, Info
#define XEVENT_LBSVR_DB_LOAD_INTERVAL_SECONDS_SETTING 0x4000E5CD

// XEVENT_XSTATSFD_FORBIDDEN_CERT_REQUEST, 58900, Error
#define XEVENT_XSTATSFD_FORBIDDEN_CERT_REQUEST 0xC000E614

// XEVENT_XSTATSFD_BAD_PARTIAL_PLAY, 58901, Error
#define XEVENT_XSTATSFD_BAD_PARTIAL_PLAY 0xC000E615

// XEVENT_XSTATSFD_BAD_SKILL_LEARNING_FACTOR, 58902, Error
#define XEVENT_XSTATSFD_BAD_SKILL_LEARNING_FACTOR 0xC000E616

// XEVENT_XSTATSFD_BAD_BETA_OVERRIDE, 58903, Error
#define XEVENT_XSTATSFD_BAD_BETA_OVERRIDE 0xC000E617

// XEVENT_XSTATSFD_BAD_TAU_OVERRIDE, 58904, Error
#define XEVENT_XSTATSFD_BAD_TAU_OVERRIDE 0xC000E618

// XEVENT_XSTATSFD_BAD_DRAW_PROBABILITY_OVERRIDE, 58905, Error
#define XEVENT_XSTATSFD_BAD_DRAW_PROBABILITY_OVERRIDE 0xC000E619

// XEVENT_STFD_PATHNAME_BROKEN_LINK_REPORT, 58975, Error
#define XEVENT_STFD_PATHNAME_BROKEN_LINK_REPORT 0xC000E65F

// XEVENT_STFD_PATHNAME_UNKNOWN_DOMAIN, 58976, Error
#define XEVENT_STFD_PATHNAME_UNKNOWN_DOMAIN 0xC000E660

// XEVENT_STFD_MISSING_OR_BAD_CONFIG_2, 58977, Error
#define XEVENT_STFD_MISSING_OR_BAD_CONFIG_2 0xC000E661

// XEVENT_STFD_MISSING_OR_BAD_CONFIG_3, 58979, Error
#define XEVENT_STFD_MISSING_OR_BAD_CONFIG_3 0xC000E663

// XEVENT_STFD_SECURITY_ERROR, 59003, Warning
#define XEVENT_STFD_SECURITY_ERROR 0x8000E67B

// XEVENT_STFD_SECURITY_ERROR_1, 59009, Warning
#define XEVENT_STFD_SECURITY_ERROR_1 0x8000E681

// XEVENT_STFD_SECURITY_ERROR_2, 59010, Warning
#define XEVENT_STFD_SECURITY_ERROR_2 0x8000E682

// XEVENT_STFD_INVALID_REQUEST, 59016, Warning
#define XEVENT_STFD_INVALID_REQUEST 0x8000E688

// XEVENT_STFD_SECURITY_ERROR_3, 59018, Warning
#define XEVENT_STFD_SECURITY_ERROR_3 0x8000E68A

// XEVENT_STFD_SECURITY_ERROR_4, 59020, Warning
#define XEVENT_STFD_SECURITY_ERROR_4 0x8000E68C

// XEVENT_STFD_INVALID_REQUEST_1, 59022, Warning
#define XEVENT_STFD_INVALID_REQUEST_1 0x8000E68E

// XEVENT_STFD_INVALID_REQUEST_2, 59028, Warning
#define XEVENT_STFD_INVALID_REQUEST_2 0x8000E694

// XEVENT_STFD_SECURITY_ERROR_5, 59030, Warning
#define XEVENT_STFD_SECURITY_ERROR_5 0x8000E696

// XEVENT_STFD_SECURITY_ERROR_6, 59032, Warning
#define XEVENT_STFD_SECURITY_ERROR_6 0x8000E698

// XEVENT_STFD_INVALID_REQUEST_3, 59033, Warning
#define XEVENT_STFD_INVALID_REQUEST_3 0x8000E699

// XEVENT_STFD_FILE_TOO_BIG, 59100, Error
#define XEVENT_STFD_FILE_TOO_BIG 0xC000E6DC

// XEVENT_STFD_FILE_TOO_BIG_1, 59101, Error
#define XEVENT_STFD_FILE_TOO_BIG_1 0xC000E6DD

// XEVENT_STFD_READTITLEFILES_ERROR, 15000, Error
#define XEVENT_STFD_READTITLEFILES_ERROR 0xC0003A98

// XEVENT_STORAGE_CODE_0, 58925, Error
#define XEVENT_STORAGE_CODE_0 0xC000E62D

// XEVENT_STORAGE_CODE_1, 58926, Error
#define XEVENT_STORAGE_CODE_1 0xC000E62E

// XEVENT_STORAGE_CODE_2, 58927, Error
#define XEVENT_STORAGE_CODE_2 0xC000E62F

// XEVENT_STORAGE_CODE_3, 58928, Error
#define XEVENT_STORAGE_CODE_3 0xC000E630

// XEVENT_STORAGE_CODE_4, 58929, Error
#define XEVENT_STORAGE_CODE_4 0xC000E631

// XEVENT_STORAGE_CODE_5, 58930, Error
#define XEVENT_STORAGE_CODE_5 0xC000E632

// XEVENT_STORAGE_CODE_6, 58931, Error
#define XEVENT_STORAGE_CODE_6 0xC000E633

// XEVENT_STORAGE_CODE_7, 58932, Error
#define XEVENT_STORAGE_CODE_7 0xC000E634

// XEVENT_STORAGE_CODE_8, 58933, Error
#define XEVENT_STORAGE_CODE_8 0xC000E635

// XEVENT_STORAGE_CODE_9, 58934, Error
#define XEVENT_STORAGE_CODE_9 0xC000E636

// XEVENT_STORAGE_CODE_10, 58935, Error
#define XEVENT_STORAGE_CODE_10 0xC000E637

// XEVENT_STORAGE_CODE_11, 58936, Error
#define XEVENT_STORAGE_CODE_11 0xC000E638

// XEVENT_STORAGE_CODE_12, 58937, Error
#define XEVENT_STORAGE_CODE_12 0xC000E639

// XEVENT_STORAGE_CODE_13, 58938, Error
#define XEVENT_STORAGE_CODE_13 0xC000E63A

// XEVENT_STORAGE_CODE_14, 58939, Error
#define XEVENT_STORAGE_CODE_14 0xC000E63B

// XEVENT_STORAGE_COMM_0, 58950, Error
#define XEVENT_STORAGE_COMM_0 0xC000E646

// XEVENT_STORAGE_DEFAULT_EVENT, 58951, Error
#define XEVENT_STORAGE_DEFAULT_EVENT 0xC000E647

// XEVENT_STORAGE_CONFIG_3, 58978, Error
#define XEVENT_STORAGE_CONFIG_3 0xC000E662

// XEVENT_STORAGE_INVALID_PATH, 58980, Warning
#define XEVENT_STORAGE_INVALID_PATH 0x8000E664

// XEVENT_STORAGE_INVALID_INPUT, 58981, Warning
#define XEVENT_STORAGE_INVALID_INPUT 0x8000E665

// XEVENT_STORAGE_HACK_0, 59000, Warning
#define XEVENT_STORAGE_HACK_0 0x8000E678

// XEVENT_STORAGE_HACK_1, 59001, Warning
#define XEVENT_STORAGE_HACK_1 0x8000E679

// XEVENT_STORAGE_HACK_2, 59002, Warning
#define XEVENT_STORAGE_HACK_2 0x8000E67A

// XEVENT_STORAGE_HACK_4, 59004, Warning
#define XEVENT_STORAGE_HACK_4 0x8000E67C

// XEVENT_STORAGE_HACK_5, 59005, Warning
#define XEVENT_STORAGE_HACK_5 0x8000E67D

// XEVENT_STORAGE_HACK_6, 59006, Warning
#define XEVENT_STORAGE_HACK_6 0x8000E67E

// XEVENT_STORAGE_HACK_7, 59007, Warning
#define XEVENT_STORAGE_HACK_7 0x8000E67F

// XEVENT_STORAGE_HACK_8, 59008, Warning
#define XEVENT_STORAGE_HACK_8 0x8000E680

// XEVENT_STORAGE_HACK_11, 59011, Warning
#define XEVENT_STORAGE_HACK_11 0x8000E683

// XEVENT_STORAGE_HACK_12, 59012, Warning
#define XEVENT_STORAGE_HACK_12 0x8000E684

// XEVENT_STORAGE_HACK_13, 59013, Warning
#define XEVENT_STORAGE_HACK_13 0x8000E685

// XEVENT_STORAGE_HACK_14, 59014, Warning
#define XEVENT_STORAGE_HACK_14 0x8000E686

// XEVENT_STORAGE_HACK_15, 59015, Warning
#define XEVENT_STORAGE_HACK_15 0x8000E687

// XEVENT_STORAGE_HACK_17, 59017, Warning
#define XEVENT_STORAGE_HACK_17 0x8000E689

// XEVENT_STORAGE_HACK_19, 59019, Warning
#define XEVENT_STORAGE_HACK_19 0x8000E68B

// XEVENT_STORAGE_HACK_21, 59021, Warning
#define XEVENT_STORAGE_HACK_21 0x8000E68D

// XEVENT_AUTHDATA_CALL_SOURCE_CHECK, 59023, Warning
#define XEVENT_AUTHDATA_CALL_SOURCE_CHECK 0x8000E68F

// XEVENT_STORAGE_HACK_24, 59024, Warning
#define XEVENT_STORAGE_HACK_24 0x8000E690

// XEVENT_STORAGE_HACK_25, 59025, Warning
#define XEVENT_STORAGE_HACK_25 0x8000E691

// XEVENT_STORAGE_HACK_26, 59026, Warning
#define XEVENT_STORAGE_HACK_26 0x8000E692

// XEVENT_STORAGE_HACK_27, 59027, Warning
#define XEVENT_STORAGE_HACK_27 0x8000E693

// XEVENT_STORAGE_HACK_29, 59029, Warning
#define XEVENT_STORAGE_HACK_29 0x8000E695

// XEVENT_STORAGE_HACK_31, 59031, Warning
#define XEVENT_STORAGE_HACK_31 0x8000E697

// XEVENT_STORAGE_HACK_34, 59034, Warning
#define XEVENT_STORAGE_HACK_34 0x8000E69A

// XEVENT_STORAGE_MODULE_INVALID_CONFIGURATION, 59035, Error
#define XEVENT_STORAGE_MODULE_INVALID_CONFIGURATION 0xC000E69B

// XEVENT_STORAGE_MODULE_CONFIG_INFO, 59036, Info
#define XEVENT_STORAGE_MODULE_CONFIG_INFO 0x4000E69C

// XEVENT_STORAGE_MODULE_XBANC_ERROR, 59037, Error
#define XEVENT_STORAGE_MODULE_XBANC_ERROR 0xC000E69D

// XEVENT_STORAGE_MODULE_INTERNAL_ERROR, 59038, Error
#define XEVENT_STORAGE_MODULE_INTERNAL_ERROR 0xC000E69E

// XEVENT_LOGCOLLECTOR_MODULE_INVALID_CONFIGURATION, 15000, Error
#define XEVENT_LOGCOLLECTOR_MODULE_INVALID_CONFIGURATION 0xC0003A98

// XEVENT_LOGCOLLECTOR_MODULE_CONFIG_INFO, 15001, Info
#define XEVENT_LOGCOLLECTOR_MODULE_CONFIG_INFO 0x40003A99

// XEVENT_LOGCOLLECTOR_MODULE_INTERNAL_ERROR, 15002, Error
#define XEVENT_LOGCOLLECTOR_MODULE_INTERNAL_ERROR 0xC0003A9A

// XEVENT_LOGCOLLECTOR_DEFAULT_EVENT, 15003, Error
#define XEVENT_LOGCOLLECTOR_DEFAULT_EVENT 0xC0003A9B

// XEVENT_STRINGSVR_CODE_0, 59125, Error
#define XEVENT_STRINGSVR_CODE_0 0xC000E6F5

// XEVENT_STRINGSVR_CODE_1, 59126, Error
#define XEVENT_STRINGSVR_CODE_1 0xC000E6F6

// XEVENT_STRINGSVR_CODE_2, 59127, Error
#define XEVENT_STRINGSVR_CODE_2 0xC000E6F7

// XEVENT_STRINGSVR_CODE_3, 59128, Error
#define XEVENT_STRINGSVR_CODE_3 0xC000E6F8

// XEVENT_STRINGSVR_INVALID_MEASUREMENT_LINE, 59129, Error
#define XEVENT_STRINGSVR_INVALID_MEASUREMENT_LINE 0xC000E6F9

// XEVENT_STRINGSVR_CONFIG_0, 59150, Error
#define XEVENT_STRINGSVR_CONFIG_0 0xC000E70E

// XEVENT_STRINGSVR_CONFIG_1, 59151, Error
#define XEVENT_STRINGSVR_CONFIG_1 0xC000E70F

// XEVENT_STRINGSVR_CONFIG_2, 59152, Error
#define XEVENT_STRINGSVR_CONFIG_2 0xC000E710

// XEVENT_STRINGSVR_CONFIG_3, 59153, Error
#define XEVENT_STRINGSVR_CONFIG_3 0xC000E711

// XEVENT_STRINGSVR_CONFIG_PREFIX_LINE_MISSING_PREFIX, 59154, Error
#define XEVENT_STRINGSVR_CONFIG_PREFIX_LINE_MISSING_PREFIX 0xC000E712

// XEVENT_STRINGSVR_CONFIG_PREFIX_LINE_MISSING_TYPE, 59155, Error
#define XEVENT_STRINGSVR_CONFIG_PREFIX_LINE_MISSING_TYPE 0xC000E713

// XEVENT_STRINGSVR_CONFIG_PREFIX_LINE_INVALID, 59156, Error
#define XEVENT_STRINGSVR_CONFIG_PREFIX_LINE_INVALID 0xC000E714

// XEVENT_STRINGSVR_CONFIG_PREFIX_LINE_BAD_THRESHOLD, 59157, Error
#define XEVENT_STRINGSVR_CONFIG_PREFIX_LINE_BAD_THRESHOLD 0xC000E715

// XEVENT_STRINGSVR_CONFIG_DUPLICATE_PREFIX, 59158, Error
#define XEVENT_STRINGSVR_CONFIG_DUPLICATE_PREFIX 0xC000E716

// XEVENT_STRINGSVR_HACK_0, 59175, Warning
#define XEVENT_STRINGSVR_HACK_0 0x8000E727

// XEVENT_STRINGSVR_HACK_1, 59176, Warning
#define XEVENT_STRINGSVR_HACK_1 0x8000E728

// XEVENT_STRINGSVR_HACK_2, 59177, Warning
#define XEVENT_STRINGSVR_HACK_2 0x8000E729

// XEVENT_STRINGSVR_HACK_3, 59178, Warning
#define XEVENT_STRINGSVR_HACK_3 0x8000E72A

// XEVENT_LOGCOLLECTOR_MODULE_URL_PROCESSING_FAILED, 59179, Error
#define XEVENT_LOGCOLLECTOR_MODULE_URL_PROCESSING_FAILED 0xC000E72B

// XEVENT_SUPPORT_GETXMLFROMXNAME_GENERIC_FAILURE, 40000, Error
#define XEVENT_SUPPORT_GETXMLFROMXNAME_GENERIC_FAILURE 0xC0009C40

// XEVENT_SUPPORT_GETXMLFROMXNAME_XNAME_FAILURE, 40001, Error
#define XEVENT_SUPPORT_GETXMLFROMXNAME_XNAME_FAILURE 0xC0009C41

// XEVENT_SUPPORT_GETXMLFROMXNAME_USER_LOAD_FAILURE, 40002, Error
#define XEVENT_SUPPORT_GETXMLFROMXNAME_USER_LOAD_FAILURE 0xC0009C42

// XEVENT_SUPPORT_GETXMLFROMXNAME_WRITE_XML_FAILURE, 40003, Error
#define XEVENT_SUPPORT_GETXMLFROMXNAME_WRITE_XML_FAILURE 0xC0009C43

// XEVENT_XSUPPAPI_EXCEPTION, 59200, Error
#define XEVENT_XSUPPAPI_EXCEPTION 0xC000E740

// XEVENT_SUPPORT_CODE_1, 59201, Error
#define XEVENT_SUPPORT_CODE_1 0xC000E741

// XEVENT_SUPPORT_CODE_2, 59202, Error
#define XEVENT_SUPPORT_CODE_2 0xC000E742

// XEVENT_SUPPORT_CODE_3, 59203, Error
#define XEVENT_SUPPORT_CODE_3 0xC000E743

// XEVENT_SUPPORT_CODE_4, 59204, Error
#define XEVENT_SUPPORT_CODE_4 0xC000E744

// XEVENT_SUPPORT_CODE_5, 59205, Error
#define XEVENT_SUPPORT_CODE_5 0xC000E745

// XEVENT_SUPPORT_CODE_6, 59206, Error
#define XEVENT_SUPPORT_CODE_6 0xC000E746

// XEVENT_SUPPORT_CODE_7, 59207, Error
#define XEVENT_SUPPORT_CODE_7 0xC000E747

// XEVENT_SUPPORT_CODE_8, 59208, Error
#define XEVENT_SUPPORT_CODE_8 0xC000E748

// XEVENT_SUPPORT_CODE_9, 59209, Error
#define XEVENT_SUPPORT_CODE_9 0xC000E749

// XEVENT_SUPPORT_CODE_10, 59210, Error
#define XEVENT_SUPPORT_CODE_10 0xC000E74A

// XEVENT_SUPPORT_CODE_11, 59211, Error
#define XEVENT_SUPPORT_CODE_11 0xC000E74B

// XEVENT_SUPPORT_CODE_12, 59212, Error
#define XEVENT_SUPPORT_CODE_12 0xC000E74C

// XEVENT_SUPPORT_CODE_13, 59213, Error
#define XEVENT_SUPPORT_CODE_13 0xC000E74D

// XEVENT_SUPPORT_CODE_14, 59214, Error
#define XEVENT_SUPPORT_CODE_14 0xC000E74E

// XEVENT_SUPPORT_CODE_15, 59215, Error
#define XEVENT_SUPPORT_CODE_15 0xC000E74F

// XEVENT_SUPPORT_INCREMENT_MAXIMUM_LICENSE_COUNT_FAILURE, 59216, Error
#define XEVENT_SUPPORT_INCREMENT_MAXIMUM_LICENSE_COUNT_FAILURE 0xC000E750

// XEVENT_SVCTUNNEL_CODE_0, 59250, Error
#define XEVENT_SVCTUNNEL_CODE_0 0xC000E772

// XEVENT_SVCTUNNEL_CODE_1, 59251, Error
#define XEVENT_SVCTUNNEL_CODE_1 0xC000E773

// XEVENT_SVCTUNNEL_CODE_2, 59252, Error
#define XEVENT_SVCTUNNEL_CODE_2 0xC000E774

// XEVENT_SVCTUNNEL_CODE_3, 59253, Error
#define XEVENT_SVCTUNNEL_CODE_3 0xC000E775

// XEVENT_SVCTUNNEL_CODE_4, 59254, Error
#define XEVENT_SVCTUNNEL_CODE_4 0xC000E776

// XEVENT_SVCTUNNEL_CODE_5, 59255, Error
#define XEVENT_SVCTUNNEL_CODE_5 0xC000E777

// XEVENT_SVCTUNNEL_CODE_6, 59256, Error
#define XEVENT_SVCTUNNEL_CODE_6 0xC000E778

// XEVENT_SVCTUNNEL_CODE_7, 59257, Error
#define XEVENT_SVCTUNNEL_CODE_7 0xC000E779

// XEVENT_SVCTUNNEL_CODE_8, 59258, Error
#define XEVENT_SVCTUNNEL_CODE_8 0xC000E77A

// XEVENT_SVCTUNNEL_CODE_9, 59259, Error
#define XEVENT_SVCTUNNEL_CODE_9 0xC000E77B

// XEVENT_SVCTUNNEL_CODE_10, 59260, Error
#define XEVENT_SVCTUNNEL_CODE_10 0xC000E77C

// XEVENT_SVCTUNNEL_CODE_11, 59261, Error
#define XEVENT_SVCTUNNEL_CODE_11 0xC000E77D

// XEVENT_SVCTUNNEL_CODE_12, 59262, Error
#define XEVENT_SVCTUNNEL_CODE_12 0xC000E77E

// XEVENT_SVCTUNNEL_CODE_13, 59263, Error
#define XEVENT_SVCTUNNEL_CODE_13 0xC000E77F

// XEVENT_SVCTUNNEL_CODE_14, 59264, Error
#define XEVENT_SVCTUNNEL_CODE_14 0xC000E780

// XEVENT_SVCTUNNEL_CODE_15, 59265, Error
#define XEVENT_SVCTUNNEL_CODE_15 0xC000E781

// XEVENT_SVCTUNNEL_CODE_16, 59266, Error
#define XEVENT_SVCTUNNEL_CODE_16 0xC000E782

// XEVENT_SVCTUNNEL_CODE_17, 59267, Error
#define XEVENT_SVCTUNNEL_CODE_17 0xC000E783

// XEVENT_SVCTUNNEL_CODE_18, 59268, Error
#define XEVENT_SVCTUNNEL_CODE_18 0xC000E784

// XEVENT_SVCTUNNEL_CODE_19, 59269, Error
#define XEVENT_SVCTUNNEL_CODE_19 0xC000E785

// XEVENT_SVCTUNNEL_CODE_20, 59270, Error
#define XEVENT_SVCTUNNEL_CODE_20 0xC000E786

// XEVENT_SVCTUNNEL_CODE_21, 59271, Error
#define XEVENT_SVCTUNNEL_CODE_21 0xC000E787

// XEVENT_SVCTUNNEL_CODE_22, 59272, Error
#define XEVENT_SVCTUNNEL_CODE_22 0xC000E788

// XEVENT_SVCTUNNEL_COMM_0, 59275, Error
#define XEVENT_SVCTUNNEL_COMM_0 0xC000E78B

// XEVENT_SVCTUNNEL_COMM_1, 59276, Error
#define XEVENT_SVCTUNNEL_COMM_1 0xC000E78C

// XEVENT_SVCTUNNEL_COMM_2, 59277, Error
#define XEVENT_SVCTUNNEL_COMM_2 0xC000E78D

// XEVENT_SVCTUNNEL_COMM_3, 59278, Error
#define XEVENT_SVCTUNNEL_COMM_3 0xC000E78E

// XEVENT_SVCTUNNEL_COMM_4, 59279, Error
#define XEVENT_SVCTUNNEL_COMM_4 0xC000E78F

// XEVENT_SVCTUNNEL_COMM_5, 59280, Error
#define XEVENT_SVCTUNNEL_COMM_5 0xC000E790

// XEVENT_SVCTUNNEL_COMM_6, 59281, Error
#define XEVENT_SVCTUNNEL_COMM_6 0xC000E791

// XEVENT_SVCTUNNEL_COMM_7, 59282, Error
#define XEVENT_SVCTUNNEL_COMM_7 0xC000E792

// XEVENT_SVCTUNNEL_COMM_8, 59283, Error
#define XEVENT_SVCTUNNEL_COMM_8 0xC000E793

// XEVENT_SVCTUNNEL_COMM_9, 59284, Error
#define XEVENT_SVCTUNNEL_COMM_9 0xC000E794

// XEVENT_SVCTUNNEL_COMM_10, 59285, Error
#define XEVENT_SVCTUNNEL_COMM_10 0xC000E795

// XEVENT_SVCTUNNEL_COMM_11, 59286, Error
#define XEVENT_SVCTUNNEL_COMM_11 0xC000E796

// XEVENT_SVCTUNNEL_COMM_12, 59287, Error
#define XEVENT_SVCTUNNEL_COMM_12 0xC000E797

// XEVENT_SVCTUNNEL_COMM_13, 59288, Error
#define XEVENT_SVCTUNNEL_COMM_13 0xC000E798

// XEVENT_SVCTUNNEL_COMM_14, 59289, Error
#define XEVENT_SVCTUNNEL_COMM_14 0xC000E799

// XEVENT_SVCTUNNEL_COMM_15, 59290, Error
#define XEVENT_SVCTUNNEL_COMM_15 0xC000E79A

// XEVENT_SVCTUNNEL_COMM_16, 59291, Error
#define XEVENT_SVCTUNNEL_COMM_16 0xC000E79B

// XEVENT_SVCTUNNEL_COMM_17, 59292, Error
#define XEVENT_SVCTUNNEL_COMM_17 0xC000E79C

// XEVENT_SVCTUNNEL_COMM_18, 59293, Error
#define XEVENT_SVCTUNNEL_COMM_18 0xC000E79D

// XEVENT_SVCTUNNEL_INFO_0, 59325, Info
#define XEVENT_SVCTUNNEL_INFO_0 0x4000E7BD

// XEVENT_SVCTUNNEL_INFO_1, 59326, Info
#define XEVENT_SVCTUNNEL_INFO_1 0x4000E7BE

// XEVENT_SVCTUNNEL_PARTNER_0, 59350, Error
#define XEVENT_SVCTUNNEL_PARTNER_0 0xC000E7D6

// XEVENT_SVCTUNNEL_PARTNER_1, 59351, Error
#define XEVENT_SVCTUNNEL_PARTNER_1 0xC000E7D7

// XEVENT_SVCTUNNEL_PARTNER_2, 59352, Error
#define XEVENT_SVCTUNNEL_PARTNER_2 0xC000E7D8

// XEVENT_SVCTUNNEL_PARTNER_3, 59353, Error
#define XEVENT_SVCTUNNEL_PARTNER_3 0xC000E7D9

// XEVENT_SVCTUNNEL_PARTNER_4, 59354, Error
#define XEVENT_SVCTUNNEL_PARTNER_4 0xC000E7DA

// XEVENT_SVCTUNNEL_PARTNER_5, 59355, Error
#define XEVENT_SVCTUNNEL_PARTNER_5 0xC000E7DB

// XEVENT_SVCTUNNEL_PARTNER_6, 59356, Error
#define XEVENT_SVCTUNNEL_PARTNER_6 0xC000E7DC

// XEVENT_TAG_RECYCLE_JOB_ERROR, 35001, Error
#define XEVENT_TAG_RECYCLE_JOB_ERROR 0xC00088B9

// XEVENT_XP_WARN_GEN, 59375, Error
#define XEVENT_XP_WARN_GEN 0xC000E7EF

// XEVENT_XP_WARN_GEN_1, 59376, Error
#define XEVENT_XP_WARN_GEN_1 0xC000E7F0

// XEVENT_XP_WARN_GEN_2, 59377, Error
#define XEVENT_XP_WARN_GEN_2 0xC000E7F1

// XEVENT_XP_WARN_GEN_3, 59378, Error
#define XEVENT_XP_WARN_GEN_3 0xC000E7F2

// XEVENT_TEST_CODE_4, 59379, Error
#define XEVENT_TEST_CODE_4 0xC000E7F3

// XEVENT_TEST_COMM_0, 59575, Error
#define XEVENT_TEST_COMM_0 0xC000E8B7

// XEVENT_TEST_COMM_1, 59576, Error
#define XEVENT_TEST_COMM_1 0xC000E8B8

// XEVENT_TEST_COMM_2, 59577, Error
#define XEVENT_TEST_COMM_2 0xC000E8B9

// XEVENT_TEST_COMM_3, 59578, Error
#define XEVENT_TEST_COMM_3 0xC000E8BA

// XEVENT_TEST_COMM_4, 59579, Error
#define XEVENT_TEST_COMM_4 0xC000E8BB

// XEVENT_TEST_COMM_5, 59580, Error
#define XEVENT_TEST_COMM_5 0xC000E8BC

// XEVENT_TEST_COMM_6, 59581, Error
#define XEVENT_TEST_COMM_6 0xC000E8BD

// XEVENT_TEST_COMM_7, 59582, Error
#define XEVENT_TEST_COMM_7 0xC000E8BE

// XEVENT_TEST_COMM_8, 59583, Error
#define XEVENT_TEST_COMM_8 0xC000E8BF

// XEVENT_TEST_COMM_9, 59584, Error
#define XEVENT_TEST_COMM_9 0xC000E8C0

// XEVENT_TEST_COMM_10, 59585, Error
#define XEVENT_TEST_COMM_10 0xC000E8C1

// XEVENT_TEST_COMM_11, 59586, Error
#define XEVENT_TEST_COMM_11 0xC000E8C2

// XEVENT_TEST_COMM_12, 59587, Error
#define XEVENT_TEST_COMM_12 0xC000E8C3

// XEVENT_TEST_COMM_13, 59588, Error
#define XEVENT_TEST_COMM_13 0xC000E8C4

// XEVENT_TEST_COMM_14, 59589, Error
#define XEVENT_TEST_COMM_14 0xC000E8C5

// XEVENT_TEST_COMM_15, 59590, Error
#define XEVENT_TEST_COMM_15 0xC000E8C6

// XEVENT_TEST_COMM_16, 59591, Error
#define XEVENT_TEST_COMM_16 0xC000E8C7

// XEVENT_TEST_COMM_17, 59592, Error
#define XEVENT_TEST_COMM_17 0xC000E8C8

// XEVENT_TEST_COMM_18, 59593, Error
#define XEVENT_TEST_COMM_18 0xC000E8C9

// XEVENT_TEST_COMM_19, 59594, Error
#define XEVENT_TEST_COMM_19 0xC000E8CA

// XEVENT_TEST_COMM_20, 59595, Error
#define XEVENT_TEST_COMM_20 0xC000E8CB

// XEVENT_TEST_COMM_21, 59596, Error
#define XEVENT_TEST_COMM_21 0xC000E8CC

// XEVENT_TEST_COMM_22, 59597, Error
#define XEVENT_TEST_COMM_22 0xC000E8CD

// XEVENT_TEST_COMM_23, 59598, Error
#define XEVENT_TEST_COMM_23 0xC000E8CE

// XEVENT_TEST_COMM_24, 59599, Error
#define XEVENT_TEST_COMM_24 0xC000E8CF

// XEVENT_TEST_COMM_25, 59600, Error
#define XEVENT_TEST_COMM_25 0xC000E8D0

// XEVENT_TEST_COMM_26, 59601, Error
#define XEVENT_TEST_COMM_26 0xC000E8D1

// XEVENT_TEST_COMM_27, 59602, Error
#define XEVENT_TEST_COMM_27 0xC000E8D2

// XEVENT_TEST_COMM_28, 59603, Error
#define XEVENT_TEST_COMM_28 0xC000E8D3

// XEVENT_TEST_COMM_29, 59604, Error
#define XEVENT_TEST_COMM_29 0xC000E8D4

// XEVENT_TEST_COMM_30, 59605, Error
#define XEVENT_TEST_COMM_30 0xC000E8D5

// XEVENT_TEST_COMM_31, 59606, Error
#define XEVENT_TEST_COMM_31 0xC000E8D6

// XEVENT_TEST_COMM_32, 59607, Error
#define XEVENT_TEST_COMM_32 0xC000E8D7

// XEVENT_TEST_COMM_33, 59608, Error
#define XEVENT_TEST_COMM_33 0xC000E8D8

// XEVENT_TEST_COMM_34, 59609, Error
#define XEVENT_TEST_COMM_34 0xC000E8D9

// XEVENT_TEST_COMM_35, 59610, Error
#define XEVENT_TEST_COMM_35 0xC000E8DA

// XEVENT_TEST_COMM_36, 59611, Error
#define XEVENT_TEST_COMM_36 0xC000E8DB

// XEVENT_TEST_COMM_37, 59612, Error
#define XEVENT_TEST_COMM_37 0xC000E8DC

// XEVENT_TEST_COMM_38, 59613, Error
#define XEVENT_TEST_COMM_38 0xC000E8DD

// XEVENT_TEST_COMM_39, 59614, Error
#define XEVENT_TEST_COMM_39 0xC000E8DE

// XEVENT_TEST_COMM_40, 59615, Error
#define XEVENT_TEST_COMM_40 0xC000E8DF

// XEVENT_TEST_COMM_41, 59616, Error
#define XEVENT_TEST_COMM_41 0xC000E8E0

// XEVENT_TEST_COMM_42, 59617, Error
#define XEVENT_TEST_COMM_42 0xC000E8E1

// XEVENT_TEST_COMM_43, 59618, Error
#define XEVENT_TEST_COMM_43 0xC000E8E2

// XEVENT_TEST_COMM_44, 59619, Error
#define XEVENT_TEST_COMM_44 0xC000E8E3

// XEVENT_TEST_COMM_45, 59620, Error
#define XEVENT_TEST_COMM_45 0xC000E8E4

// XEVENT_TEST_COMM_46, 59621, Error
#define XEVENT_TEST_COMM_46 0xC000E8E5

// XEVENT_TEST_CONFIG_3, 59678, Warning
#define XEVENT_TEST_CONFIG_3 0x8000E91E

// XEVENT_TEST_CONFIG_4, 59679, Error
#define XEVENT_TEST_CONFIG_4 0xC000E91F

// XEVENT_TEST_CONFIG_5, 59680, Error
#define XEVENT_TEST_CONFIG_5 0xC000E920

// XEVENT_TEST_CONFIG_6, 59681, Error
#define XEVENT_TEST_CONFIG_6 0xC000E921

// XEVENT_TEST_CONFIG_7, 59682, Error
#define XEVENT_TEST_CONFIG_7 0xC000E922

// XEVENT_TEST_CONFIG_8, 59683, Error
#define XEVENT_TEST_CONFIG_8 0xC000E923

// XEVENT_TEST_CONFIG_9, 59684, Error
#define XEVENT_TEST_CONFIG_9 0xC000E924

// XEVENT_TEST_CONFIG_10, 59685, Error
#define XEVENT_TEST_CONFIG_10 0xC000E925

// XEVENT_TEST_CONFIG_11, 59686, Error
#define XEVENT_TEST_CONFIG_11 0xC000E926

// XEVENT_TEST_CONFIG_12, 59687, Error
#define XEVENT_TEST_CONFIG_12 0xC000E927

// XEVENT_TEST_CONFIG_13, 59688, Error
#define XEVENT_TEST_CONFIG_13 0xC000E928

// XEVENT_TEST_CONFIG_14, 59689, Error
#define XEVENT_TEST_CONFIG_14 0xC000E929

// XEVENT_TEST_CONFIG_15, 59690, Error
#define XEVENT_TEST_CONFIG_15 0xC000E92A

// XEVENT_TEST_CONFIG_16, 59691, Error
#define XEVENT_TEST_CONFIG_16 0xC000E92B

// XEVENT_TEST_CONFIG_17, 59692, Error
#define XEVENT_TEST_CONFIG_17 0xC000E92C

// XEVENT_TEST_CONFIG_18, 59693, Error
#define XEVENT_TEST_CONFIG_18 0xC000E92D

// XEVENT_TEST_CONFIG_19, 59694, Error
#define XEVENT_TEST_CONFIG_19 0xC000E92E

// XEVENT_TEST_CONFIG_20, 59695, Error
#define XEVENT_TEST_CONFIG_20 0xC000E92F

// XEVENT_TEST_CONFIG_21, 59696, Error
#define XEVENT_TEST_CONFIG_21 0xC000E930

// XEVENT_TEST_CONFIG_22, 59697, Error
#define XEVENT_TEST_CONFIG_22 0xC000E931

// XEVENT_TEST_CONFIG_23, 59698, Error
#define XEVENT_TEST_CONFIG_23 0xC000E932

// XEVENT_TEST_CONFIG_24, 59699, Error
#define XEVENT_TEST_CONFIG_24 0xC000E933

// XEVENT_TEST_CONFIG_25, 59700, Error
#define XEVENT_TEST_CONFIG_25 0xC000E934

// XEVENT_TEST_CONFIG_26, 59701, Error
#define XEVENT_TEST_CONFIG_26 0xC000E935

// XEVENT_TEST_CONFIG_27, 59702, Warning
#define XEVENT_TEST_CONFIG_27 0x8000E936

// XEVENT_TEST_CONFIG_28, 59703, Error
#define XEVENT_TEST_CONFIG_28 0xC000E937

// XEVENT_TEST_CONFIG_29, 59704, Error
#define XEVENT_TEST_CONFIG_29 0xC000E938

// XEVENT_TEST_CONFIG_30, 59705, Error
#define XEVENT_TEST_CONFIG_30 0xC000E939

// XEVENT_TEST_CONFIG_31, 59706, Error
#define XEVENT_TEST_CONFIG_31 0xC000E93A

// XEVENT_TEST_CONFIG_32, 59707, Error
#define XEVENT_TEST_CONFIG_32 0xC000E93B

// XEVENT_TEST_CONFIG_33, 59708, Error
#define XEVENT_TEST_CONFIG_33 0xC000E93C

// XEVENT_TEST_CONFIG_34, 59709, Error
#define XEVENT_TEST_CONFIG_34 0xC000E93D

// XEVENT_TEST_CONFIG_35, 59710, Error
#define XEVENT_TEST_CONFIG_35 0xC000E93E

// XEVENT_TEST_CONFIG_36, 59711, Error
#define XEVENT_TEST_CONFIG_36 0xC000E93F

// XEVENT_TEST_CONFIG_37, 59712, Error
#define XEVENT_TEST_CONFIG_37 0xC000E940

// XEVENT_TEST_CONFIG_38, 59713, Error
#define XEVENT_TEST_CONFIG_38 0xC000E941

// XEVENT_TEST_CONFIG_39, 59714, Error
#define XEVENT_TEST_CONFIG_39 0xC000E942

// XEVENT_TEST_CONFIG_40, 59715, Error
#define XEVENT_TEST_CONFIG_40 0xC000E943

// XEVENT_TEST_CONFIG_41, 59716, Error
#define XEVENT_TEST_CONFIG_41 0xC000E944

// XEVENT_TEST_CONFIG_42, 59717, Error
#define XEVENT_TEST_CONFIG_42 0xC000E945

// XEVENT_TEST_CONFIG_43, 59718, Error
#define XEVENT_TEST_CONFIG_43 0xC000E946

// XEVENT_TEST_CONFIG_44, 59719, Error
#define XEVENT_TEST_CONFIG_44 0xC000E947

// XEVENT_TEST_CONFIG_45, 59720, Error
#define XEVENT_TEST_CONFIG_45 0xC000E948

// XEVENT_TEST_CONFIG_46, 59721, Error
#define XEVENT_TEST_CONFIG_46 0xC000E949

// XEVENT_TEST_CONFIG_47, 59722, Error
#define XEVENT_TEST_CONFIG_47 0xC000E94A

// XEVENT_TEST_CONFIG_48, 59723, Error
#define XEVENT_TEST_CONFIG_48 0xC000E94B

// XEVENT_TEST_CONFIG_49, 59724, Error
#define XEVENT_TEST_CONFIG_49 0xC000E94C

// XEVENT_TEST_CONFIG_50, 59725, Error
#define XEVENT_TEST_CONFIG_50 0xC000E94D

// XEVENT_TEST_CONFIG_51, 59726, Error
#define XEVENT_TEST_CONFIG_51 0xC000E94E

// XEVENT_TEST_CONFIG_52, 59727, Error
#define XEVENT_TEST_CONFIG_52 0xC000E94F

// XEVENT_TEST_CONFIG_53, 59728, Error
#define XEVENT_TEST_CONFIG_53 0xC000E950

// XEVENT_TEST_CONFIG_54, 59729, Error
#define XEVENT_TEST_CONFIG_54 0xC000E951

// XEVENT_TEST_CONFIG_55, 59730, Error
#define XEVENT_TEST_CONFIG_55 0xC000E952

// XEVENT_TEST_CONFIG_56, 59731, Error
#define XEVENT_TEST_CONFIG_56 0xC000E953

// XEVENT_TEST_CONFIG_57, 59732, Error
#define XEVENT_TEST_CONFIG_57 0xC000E954

// XEVENT_TEST_CONFIG_58, 59733, Error
#define XEVENT_TEST_CONFIG_58 0xC000E955

// XEVENT_TEST_CONFIG_59, 59734, Error
#define XEVENT_TEST_CONFIG_59 0xC000E956

// XEVENT_TEST_CONFIG_60, 59735, Warning
#define XEVENT_TEST_CONFIG_60 0x8000E957

// XEVENT_TEST_CONFIG_61, 59736, Error
#define XEVENT_TEST_CONFIG_61 0xC000E958

// XEVENT_TEST_CONFIG_62, 59737, Error
#define XEVENT_TEST_CONFIG_62 0xC000E959

// XEVENT_TEST_CONFIG_63, 59738, Error
#define XEVENT_TEST_CONFIG_63 0xC000E95A

// XEVENT_TEST_CONFIG_64, 59739, Error
#define XEVENT_TEST_CONFIG_64 0xC000E95B

// XEVENT_TEST_CONFIG_65, 59740, Error
#define XEVENT_TEST_CONFIG_65 0xC000E95C

// XEVENT_TEST_CONFIG_66, 59741, Error
#define XEVENT_TEST_CONFIG_66 0xC000E95D

// XEVENT_TEST_CONFIG_67, 59742, Error
#define XEVENT_TEST_CONFIG_67 0xC000E95E

// XEVENT_TEST_CONFIG_68, 59743, Error
#define XEVENT_TEST_CONFIG_68 0xC000E95F

// XEVENT_TEST_CONFIG_69, 59744, Error
#define XEVENT_TEST_CONFIG_69 0xC000E960

// XEVENT_TEST_CONFIG_70, 59745, Error
#define XEVENT_TEST_CONFIG_70 0xC000E961

// XEVENT_TEST_CONFIG_71, 59746, Error
#define XEVENT_TEST_CONFIG_71 0xC000E962

// XEVENT_TEST_CONFIG_72, 59747, Error
#define XEVENT_TEST_CONFIG_72 0xC000E963

// XEVENT_TEST_CONFIG_73, 59748, Error
#define XEVENT_TEST_CONFIG_73 0xC000E964

// XEVENT_TEST_CONFIG_74, 59749, Error
#define XEVENT_TEST_CONFIG_74 0xC000E965

// XEVENT_TEST_CONFIG_75, 59750, Error
#define XEVENT_TEST_CONFIG_75 0xC000E966

// XEVENT_TEST_CONFIG_76, 59751, Error
#define XEVENT_TEST_CONFIG_76 0xC000E967

// XEVENT_TEST_CONFIG_77, 59752, Error
#define XEVENT_TEST_CONFIG_77 0xC000E968

// XEVENT_TEST_CONFIG_78, 59753, Error
#define XEVENT_TEST_CONFIG_78 0xC000E969

// XEVENT_TEST_CONFIG_79, 59754, Error
#define XEVENT_TEST_CONFIG_79 0xC000E96A

// XEVENT_TEST_CONFIG_80, 59755, Error
#define XEVENT_TEST_CONFIG_80 0xC000E96B

// XEVENT_TEST_CONFIG_81, 59756, Error
#define XEVENT_TEST_CONFIG_81 0xC000E96C

// XEVENT_TEST_CONFIG_82, 59757, Error
#define XEVENT_TEST_CONFIG_82 0xC000E96D

// XEVENT_TEST_CONFIG_83, 59758, Warning
#define XEVENT_TEST_CONFIG_83 0x8000E96E

// XEVENT_TEST_CONFIG_84, 59759, Warning
#define XEVENT_TEST_CONFIG_84 0x8000E96F

// XEVENT_TEST_CONFIG_85, 59760, Error
#define XEVENT_TEST_CONFIG_85 0xC000E970

// XEVENT_TEST_CONFIG_86, 59761, Error
#define XEVENT_TEST_CONFIG_86 0xC000E971

// XEVENT_TEST_CONFIG_87, 59762, Error
#define XEVENT_TEST_CONFIG_87 0xC000E972

// XEVENT_TEST_CONFIG_88, 59763, Error
#define XEVENT_TEST_CONFIG_88 0xC000E973

// XEVENT_TEST_CONFIG_89, 59764, Error
#define XEVENT_TEST_CONFIG_89 0xC000E974

// XEVENT_TEST_CONFIG_90, 59765, Error
#define XEVENT_TEST_CONFIG_90 0xC000E975

// XEVENT_TEST_CONFIG_91, 59766, Error
#define XEVENT_TEST_CONFIG_91 0xC000E976

// XEVENT_TEST_CONFIG_92, 59767, Error
#define XEVENT_TEST_CONFIG_92 0xC000E977

// XEVENT_TEST_CONFIG_93, 59768, Error
#define XEVENT_TEST_CONFIG_93 0xC000E978

// XEVENT_TEST_CONFIG_94, 59769, Error
#define XEVENT_TEST_CONFIG_94 0xC000E979

// XEVENT_TEST_CONFIG_95, 59770, Error
#define XEVENT_TEST_CONFIG_95 0xC000E97A

// XEVENT_TEST_CONFIG_96, 59771, Error
#define XEVENT_TEST_CONFIG_96 0xC000E97B

// XEVENT_TEST_CONFIG_97, 59772, Error
#define XEVENT_TEST_CONFIG_97 0xC000E97C

// XEVENT_TEST_CONFIG_98, 59773, Error
#define XEVENT_TEST_CONFIG_98 0xC000E97D

// XEVENT_TEST_CONFIG_99, 59774, Error
#define XEVENT_TEST_CONFIG_99 0xC000E97E

// XEVENT_TEST_CONFIG_100, 59775, Warning
#define XEVENT_TEST_CONFIG_100 0x8000E97F

// XEVENT_TEST_CONFIG_101, 59776, Error
#define XEVENT_TEST_CONFIG_101 0xC000E980

// XEVENT_TEST_CONFIG_102, 59777, Error
#define XEVENT_TEST_CONFIG_102 0xC000E981

// XEVENT_TEST_CONFIG_103, 59778, Error
#define XEVENT_TEST_CONFIG_103 0xC000E982

// XEVENT_TEST_CONFIG_104, 59779, Error
#define XEVENT_TEST_CONFIG_104 0xC000E983

// XEVENT_TEST_CONFIG_105, 59780, Error
#define XEVENT_TEST_CONFIG_105 0xC000E984

// XEVENT_TEST_CONFIG_106, 59781, Error
#define XEVENT_TEST_CONFIG_106 0xC000E985

// XEVENT_TEST_CONFIG_107, 59782, Error
#define XEVENT_TEST_CONFIG_107 0xC000E986

// XEVENT_TEST_CONFIG_108, 59783, Warning
#define XEVENT_TEST_CONFIG_108 0x8000E987

// XEVENT_TEST_CONFIG_109, 59784, Error
#define XEVENT_TEST_CONFIG_109 0xC000E988

// XEVENT_TEST_CONFIG_110, 59785, Error
#define XEVENT_TEST_CONFIG_110 0xC000E989

// XEVENT_TEST_CONFIG_111, 59786, Error
#define XEVENT_TEST_CONFIG_111 0xC000E98A

// XEVENT_TEST_CONFIG_112, 59787, Error
#define XEVENT_TEST_CONFIG_112 0xC000E98B

// XEVENT_TEST_CONFIG_113, 59788, Warning
#define XEVENT_TEST_CONFIG_113 0x8000E98C

// XEVENT_TEST_CONFIG_114, 59789, Warning
#define XEVENT_TEST_CONFIG_114 0x8000E98D

// XEVENT_TEST_CONFIG_115, 59790, Error
#define XEVENT_TEST_CONFIG_115 0xC000E98E

// XEVENT_TEST_CONFIG_116, 59791, Error
#define XEVENT_TEST_CONFIG_116 0xC000E98F

// XEVENT_TEST_CONFIG_117, 59792, Error
#define XEVENT_TEST_CONFIG_117 0xC000E990

// XEVENT_TEST_CONFIG_118, 59793, Error
#define XEVENT_TEST_CONFIG_118 0xC000E991

// XEVENT_TEST_CONFIG_119, 59794, Error
#define XEVENT_TEST_CONFIG_119 0xC000E992

// XEVENT_TEST_CONFIG_120, 59795, Error
#define XEVENT_TEST_CONFIG_120 0xC000E993

// XEVENT_TEST_CONFIG_121, 59796, Error
#define XEVENT_TEST_CONFIG_121 0xC000E994

// XEVENT_TEST_CONFIG_122, 59797, Error
#define XEVENT_TEST_CONFIG_122 0xC000E995

// XEVENT_TEST_CONFIG_123, 59798, Error
#define XEVENT_TEST_CONFIG_123 0xC000E996

// XEVENT_TEST_CONFIG_124, 59799, Error
#define XEVENT_TEST_CONFIG_124 0xC000E997

// XEVENT_TEST_CONFIG_125, 59800, Error
#define XEVENT_TEST_CONFIG_125 0xC000E998

// XEVENT_TEST_CONFIG_126, 59801, Error
#define XEVENT_TEST_CONFIG_126 0xC000E999

// XEVENT_TEST_CONFIG_127, 59802, Error
#define XEVENT_TEST_CONFIG_127 0xC000E99A

// XEVENT_TEST_CONFIG_128, 59803, Error
#define XEVENT_TEST_CONFIG_128 0xC000E99B

// XEVENT_TEST_CONFIG_129, 59804, Error
#define XEVENT_TEST_CONFIG_129 0xC000E99C

// XEVENT_TEST_CONFIG_130, 59805, Error
#define XEVENT_TEST_CONFIG_130 0xC000E99D

// XEVENT_TEST_CONFIG_131, 59806, Error
#define XEVENT_TEST_CONFIG_131 0xC000E99E

// XEVENT_TEST_CONFIG_132, 59807, Error
#define XEVENT_TEST_CONFIG_132 0xC000E99F

// XEVENT_TEST_CONFIG_133, 59808, Error
#define XEVENT_TEST_CONFIG_133 0xC000E9A0

// XEVENT_TEST_CONFIG_134, 59809, Error
#define XEVENT_TEST_CONFIG_134 0xC000E9A1

// XEVENT_TEST_CONFIG_135, 59810, Error
#define XEVENT_TEST_CONFIG_135 0xC000E9A2

// XEVENT_TEST_CONFIG_136, 59811, Error
#define XEVENT_TEST_CONFIG_136 0xC000E9A3

// XEVENT_TEST_CONFIG_137, 59812, Error
#define XEVENT_TEST_CONFIG_137 0xC000E9A4

// XEVENT_TEST_CONFIG_138, 59813, Error
#define XEVENT_TEST_CONFIG_138 0xC000E9A5

// XEVENT_TEST_CONFIG_139, 59814, Error
#define XEVENT_TEST_CONFIG_139 0xC000E9A6

// XEVENT_TEST_CONFIG_140, 59815, Error
#define XEVENT_TEST_CONFIG_140 0xC000E9A7

// XEVENT_TEST_CONFIG_141, 59816, Error
#define XEVENT_TEST_CONFIG_141 0xC000E9A8

// XEVENT_TEST_CONFIG_142, 59817, Error
#define XEVENT_TEST_CONFIG_142 0xC000E9A9

// XEVENT_TEST_CONFIG_143, 59818, Error
#define XEVENT_TEST_CONFIG_143 0xC000E9AA

// XEVENT_TEST_CONFIG_144, 59819, Error
#define XEVENT_TEST_CONFIG_144 0xC000E9AB

// XEVENT_TEST_CONFIG_145, 59820, Error
#define XEVENT_TEST_CONFIG_145 0xC000E9AC

// XEVENT_TEST_CONFIG_146, 59821, Error
#define XEVENT_TEST_CONFIG_146 0xC000E9AD

// XEVENT_TEST_CONFIG_147, 59822, Error
#define XEVENT_TEST_CONFIG_147 0xC000E9AE

// XEVENT_TEST_CONFIG_148, 59823, Error
#define XEVENT_TEST_CONFIG_148 0xC000E9AF

// XEVENT_TEST_CONFIG_149, 59824, Error
#define XEVENT_TEST_CONFIG_149 0xC000E9B0

// XEVENT_TEST_CONFIG_150, 59825, Warning
#define XEVENT_TEST_CONFIG_150 0x8000E9B1

// XEVENT_TEST_CONFIG_151, 59826, Error
#define XEVENT_TEST_CONFIG_151 0xC000E9B2

// XEVENT_TEST_CONFIG_152, 59827, Error
#define XEVENT_TEST_CONFIG_152 0xC000E9B3

// XEVENT_TEST_CONFIG_153, 59828, Error
#define XEVENT_TEST_CONFIG_153 0xC000E9B4

// XEVENT_TEST_CONFIG_154, 59829, Error
#define XEVENT_TEST_CONFIG_154 0xC000E9B5

// XEVENT_TEST_CONFIG_155, 59830, Error
#define XEVENT_TEST_CONFIG_155 0xC000E9B6

// XEVENT_TEST_CONFIG_156, 59831, Error
#define XEVENT_TEST_CONFIG_156 0xC000E9B7

// XEVENT_TEST_CONFIG_157, 59832, Warning
#define XEVENT_TEST_CONFIG_157 0x8000E9B8

// XEVENT_TEST_CONFIG_158, 59833, Error
#define XEVENT_TEST_CONFIG_158 0xC000E9B9

// XEVENT_TEST_CONFIG_159, 59834, Error
#define XEVENT_TEST_CONFIG_159 0xC000E9BA

// XEVENT_TEST_CONFIG_160, 59835, Error
#define XEVENT_TEST_CONFIG_160 0xC000E9BB

// XEVENT_TEST_CONFIG_161, 59836, Error
#define XEVENT_TEST_CONFIG_161 0xC000E9BC

// XEVENT_TEST_CONFIG_162, 59837, Warning
#define XEVENT_TEST_CONFIG_162 0x8000E9BD

// XEVENT_XSTORAGE_SESSION_INSERT_FAILED, 59840, Error
#define XEVENT_XSTORAGE_SESSION_INSERT_FAILED 0xC000E9C0

// XEVENT_XSTORAGE_SESSION_UPDATE_FAILED, 59841, Error
#define XEVENT_XSTORAGE_SESSION_UPDATE_FAILED 0xC000E9C1

// XEVENT_XSTORAGE_SESSION_DELETE_FAILED, 59842, Error
#define XEVENT_XSTORAGE_SESSION_DELETE_FAILED 0xC000E9C2

// XEVENT_TEST_HACK_0, 60075, Warning
#define XEVENT_TEST_HACK_0 0x8000EAAB

// XEVENT_TEST_HACK_1, 60076, Warning
#define XEVENT_TEST_HACK_1 0x8000EAAC

// XEVENT_TEST_HACK_2, 60077, Warning
#define XEVENT_TEST_HACK_2 0x8000EAAD

// XEVENT_TEST_HACK_3, 60078, Warning
#define XEVENT_TEST_HACK_3 0x8000EAAE

// XEVENT_TEST_HACK_4, 60079, Warning
#define XEVENT_TEST_HACK_4 0x8000EAAF

// XEVENT_TEST_HACK_5, 60080, Warning
#define XEVENT_TEST_HACK_5 0x8000EAB0

// XEVENT_TEST_HACK_6, 60081, Warning
#define XEVENT_TEST_HACK_6 0x8000EAB1

// XEVENT_TEST_HACK_7, 60082, Warning
#define XEVENT_TEST_HACK_7 0x8000EAB2

// XEVENT_TEST_HACK_8, 60083, Warning
#define XEVENT_TEST_HACK_8 0x8000EAB3

// XEVENT_TEST_INFO_0, 60100, Info
#define XEVENT_TEST_INFO_0 0x4000EAC4

// XEVENT_TEST_INFO_1, 60101, Info
#define XEVENT_TEST_INFO_1 0x4000EAC5

// XEVENT_TEST_INFO_2, 60102, Info
#define XEVENT_TEST_INFO_2 0x4000EAC6

// XEVENT_TEST_INFO_3, 60103, Info
#define XEVENT_TEST_INFO_3 0x4000EAC7

// XEVENT_TEST_INFO_4, 60104, Info
#define XEVENT_TEST_INFO_4 0x4000EAC8

// XEVENT_TEST_INFO_5, 60105, Info
#define XEVENT_TEST_INFO_5 0x4000EAC9

// XEVENT_TEST_INFO_6, 60106, Info
#define XEVENT_TEST_INFO_6 0x4000EACA

// XEVENT_TEST_INFO_7, 60107, Info
#define XEVENT_TEST_INFO_7 0x4000EACB

// XEVENT_TEST_INFO_8, 60108, Info
#define XEVENT_TEST_INFO_8 0x4000EACC

// XEVENT_TEST_INFO_9, 60109, Info
#define XEVENT_TEST_INFO_9 0x4000EACD

// XEVENT_TEST_INFO_10, 60110, Info
#define XEVENT_TEST_INFO_10 0x4000EACE

// XEVENT_TEST_INFO_11, 60111, Info
#define XEVENT_TEST_INFO_11 0x4000EACF

// XEVENT_TEST_INFO_12, 60112, Info
#define XEVENT_TEST_INFO_12 0x4000EAD0

// XEVENT_TEST_INFO_13, 60113, Info
#define XEVENT_TEST_INFO_13 0x4000EAD1

// XEVENT_TEST_INFO_14, 60114, Info
#define XEVENT_TEST_INFO_14 0x4000EAD2

// XEVENT_TEST_INFO_15, 60115, Info
#define XEVENT_TEST_INFO_15 0x4000EAD3

// XEVENT_TEST_INFO_16, 60116, Info
#define XEVENT_TEST_INFO_16 0x4000EAD4

// XEVENT_TEST_INFO_17, 60117, Info
#define XEVENT_TEST_INFO_17 0x4000EAD5

// XEVENT_TEST_INFO_18, 60118, Info
#define XEVENT_TEST_INFO_18 0x4000EAD6

// XEVENT_TEST_INFO_19, 60119, Info
#define XEVENT_TEST_INFO_19 0x4000EAD7

// XEVENT_TEST_INFO_20, 60120, Info
#define XEVENT_TEST_INFO_20 0x4000EAD8

// XEVENT_TEST_INFO_21, 60121, Info
#define XEVENT_TEST_INFO_21 0x4000EAD9

// XEVENT_TEST_INFO_22, 60122, Info
#define XEVENT_TEST_INFO_22 0x4000EADA

// XEVENT_TEST_INFO_23, 60123, Info
#define XEVENT_TEST_INFO_23 0x4000EADB

// XEVENT_TEST_INFO_24, 60124, Info
#define XEVENT_TEST_INFO_24 0x4000EADC

// XEVENT_TEST_INFO_25, 60125, Info
#define XEVENT_TEST_INFO_25 0x4000EADD

// XEVENT_TEST_INFO_26, 60126, Info
#define XEVENT_TEST_INFO_26 0x4000EADE

// XEVENT_TEST_INFO_27, 60127, Info
#define XEVENT_TEST_INFO_27 0x4000EADF

// XEVENT_TEST_INFO_28, 60128, Info
#define XEVENT_TEST_INFO_28 0x4000EAE0

// XEVENT_TEST_INFO_29, 60129, Info
#define XEVENT_TEST_INFO_29 0x4000EAE1

// XEVENT_TEST_INFO_30, 60130, Info
#define XEVENT_TEST_INFO_30 0x4000EAE2

// XEVENT_TEST_INFO_31, 60131, Info
#define XEVENT_TEST_INFO_31 0x4000EAE3

// XEVENT_TEST_INFO_32, 60132, Info
#define XEVENT_TEST_INFO_32 0x4000EAE4

// XEVENT_TEST_INFO_33, 60133, Info
#define XEVENT_TEST_INFO_33 0x4000EAE5

// XEVENT_TEST_INFO_34, 60134, Info
#define XEVENT_TEST_INFO_34 0x4000EAE6

// XEVENT_TEST_INFO_35, 60135, Info
#define XEVENT_TEST_INFO_35 0x4000EAE7

// XEVENT_TOKEN_GENERATION_INVALID_CRON_JOB_PARAMETER, 10001, Error
#define XEVENT_TOKEN_GENERATION_INVALID_CRON_JOB_PARAMETER 0xC0002711

// XEVENT_TOKEN_GENERATION_CRON_JOB_FAILED, 10002, Error
#define XEVENT_TOKEN_GENERATION_CRON_JOB_FAILED 0xC0002712

// XEVENT_TOKEN_GENERATION_RECORD_TOKEN_JOB_FAILURE_FAILED, 10003, Error
#define XEVENT_TOKEN_GENERATION_RECORD_TOKEN_JOB_FAILURE_FAILED 0xC0002713

// XEVENT_TOKEN_GENERATION_TOKENDB_ADD_TOKENS_FAILED, 10004, Error
#define XEVENT_TOKEN_GENERATION_TOKENDB_ADD_TOKENS_FAILED 0xC0002714

// XEVENT_TOKEN_GENERATION_GET_SEQUENCE_NUMBER_FOR_PKPN_FAILURE, 10005, Error
#define XEVENT_TOKEN_GENERATION_GET_SEQUENCE_NUMBER_FOR_PKPN_FAILURE 0xC0002715

// XEVENT_TOKEN_KEY_ENCRYPTION_KEY_LOAD_FAILURE, 10006, Error
#define XEVENT_TOKEN_KEY_ENCRYPTION_KEY_LOAD_FAILURE 0xC0002716

// XEVENT_TOKEN_NOT_YET_REDEEMABLE, 10007, Error
#define XEVENT_TOKEN_NOT_YET_REDEEMABLE 0xC0002717

// XEVENT_TOKEN_LOAD_SCS_UNKNOWN_ERROR, 10008, Error
#define XEVENT_TOKEN_LOAD_SCS_UNKNOWN_ERROR 0xC0002718

// XEVENT_LIVEMATCH_DRAINRR_FAILED_MIGRATION_UNDERWAY, 40000, Error
#define XEVENT_LIVEMATCH_DRAINRR_FAILED_MIGRATION_UNDERWAY 0xC0009C40

// XEVENT_LIVEMATCH_DRAINRR_FAILED_NO_ELIGIBLE_BUCKETS, 40001, Error
#define XEVENT_LIVEMATCH_DRAINRR_FAILED_NO_ELIGIBLE_BUCKETS 0xC0009C41

// XEVENT_LIVEMATCH_DRAINRR_FAILED_NO_BUCKETS_FOUND, 40002, Error
#define XEVENT_LIVEMATCH_DRAINRR_FAILED_NO_BUCKETS_FOUND 0xC0009C42

// XEVENT_LIVEMATCH_REMOVERR_FAILED_MIGRATION_UNDERWAY, 40003, Error
#define XEVENT_LIVEMATCH_REMOVERR_FAILED_MIGRATION_UNDERWAY 0xC0009C43

// XEVENT_LIVEMATCH_REMOVERR_FAILED_NO_ELIGIBLE_BUCKETS, 40004, Error
#define XEVENT_LIVEMATCH_REMOVERR_FAILED_NO_ELIGIBLE_BUCKETS 0xC0009C44

// XEVENT_LIVEMATCH_REMOVERR_FAILED_NO_BUCKETS_FOUND, 40005, Error
#define XEVENT_LIVEMATCH_REMOVERR_FAILED_NO_BUCKETS_FOUND 0xC0009C45

// XEVENT_LIVEMATCH_REMOVERR_FAILED_NOT_DRAINING, 40006, Warning
#define XEVENT_LIVEMATCH_REMOVERR_FAILED_NOT_DRAINING 0x80009C46

// XEVENT_FIXTRACES_OUTPUT_RANGE_CHECK, 50941, Error
#define XEVENT_FIXTRACES_OUTPUT_RANGE_CHECK 0xC000C6FD

// XEVENT_COMMON_CODE_206, 51031, Error
#define XEVENT_COMMON_CODE_206 0xC000C757

// XEVENT_COMMON_CODE_207, 51032, Error
#define XEVENT_COMMON_CODE_207 0xC000C758

// XEVENT_TEST_CODE_5, 59380, Error
#define XEVENT_TEST_CODE_5 0xC000E7F4

// XEVENT_TEST_CODE_6, 59381, Error
#define XEVENT_TEST_CODE_6 0xC000E7F5

// XEVENT_TEST_CODE_7, 59382, Error
#define XEVENT_TEST_CODE_7 0xC000E7F6

// XEVENT_TEST_CODE_8, 59383, Error
#define XEVENT_TEST_CODE_8 0xC000E7F7

// XEVENT_TEST_CODE_9, 59384, Error
#define XEVENT_TEST_CODE_9 0xC000E7F8

// XEVENT_TEST_CODE_10, 59385, Error
#define XEVENT_TEST_CODE_10 0xC000E7F9

// XEVENT_TEST_CODE_11, 59386, Error
#define XEVENT_TEST_CODE_11 0xC000E7FA

// XEVENT_TEST_CODE_12, 59387, Error
#define XEVENT_TEST_CODE_12 0xC000E7FB

// XEVENT_TEST_CONFIG_0, 59675, Warning
#define XEVENT_TEST_CONFIG_0 0x8000E91B

// XEVENT_TEST_CONFIG_1, 59676, Error
#define XEVENT_TEST_CONFIG_1 0xC000E91C

// XEVENT_TEST_CONFIG_2, 59677, Error
#define XEVENT_TEST_CONFIG_2 0xC000E91D

// XEVENT_MGMT_INIT_WARNING_15, 59838, Warning
#define XEVENT_MGMT_INIT_WARNING_15 0x8000E9BE

// XEVENT_MGMT_INIT_WARNING_16, 59839, Warning
#define XEVENT_MGMT_INIT_WARNING_16 0x8000E9BF

// XEVENT_BATMAN_REQUIRED_FIX, 60200, Error
#define XEVENT_BATMAN_REQUIRED_FIX 0xC000EB28

// XEVENT_BATMAN_REQUIRED_FIX_1, 60201, Error
#define XEVENT_BATMAN_REQUIRED_FIX_1 0xC000EB29

// XEVENT_TOOLS_CODE_2, 60202, Error
#define XEVENT_TOOLS_CODE_2 0xC000EB2A

// XEVENT_TOOLS_CODE_3, 60203, Error
#define XEVENT_TOOLS_CODE_3 0xC000EB2B

// XEVENT_GENEALOGY_OUT_OF_MEMORY, 60204, Error
#define XEVENT_GENEALOGY_OUT_OF_MEMORY 0xC000EB2C

// XEVENT_GENEALOGY_ERROR_CALL_SPROC, 60205, Error
#define XEVENT_GENEALOGY_ERROR_CALL_SPROC 0xC000EB2D

// XEVENT_GENEALOGY_OUT_OF_MEMORY_1, 60206, Error
#define XEVENT_GENEALOGY_OUT_OF_MEMORY_1 0xC000EB2E

// XEVENT_GENEALOGY_OUT_OF_MEMORY_2, 60207, Error
#define XEVENT_GENEALOGY_OUT_OF_MEMORY_2 0xC000EB2F

// XEVENT_GENEALOGY_OUT_OF_MEMORY_3, 60208, Error
#define XEVENT_GENEALOGY_OUT_OF_MEMORY_3 0xC000EB30

// XEVENT_GENEALOGY_OUT_OF_MEMORY_4, 60209, Error
#define XEVENT_GENEALOGY_OUT_OF_MEMORY_4 0xC000EB31

// XEVENT_GENEALOGY_OUT_OF_MEMORY_5, 60210, Error
#define XEVENT_GENEALOGY_OUT_OF_MEMORY_5 0xC000EB32

// XEVENT_GENEALOGY_OUT_OF_MEMORY_6, 60211, Error
#define XEVENT_GENEALOGY_OUT_OF_MEMORY_6 0xC000EB33

// XEVENT_GENEALOGY_OUT_OF_MEMORY_7, 60212, Error
#define XEVENT_GENEALOGY_OUT_OF_MEMORY_7 0xC000EB34

// XEVENT_GENEALOGY_ERROR_DESTROYING_KEY_HANDLE, 60213, Error
#define XEVENT_GENEALOGY_ERROR_DESTROYING_KEY_HANDLE 0xC000EB35

// XEVENT_GENEALOGY_ERROR_RELEASING_CRYPT_CONTEXT, 60214, Error
#define XEVENT_GENEALOGY_ERROR_RELEASING_CRYPT_CONTEXT 0xC000EB36

// XEVENT_GENEALOGY_ERROR_AQUIRE_CRYPT_CONTEXT, 60215, Error
#define XEVENT_GENEALOGY_ERROR_AQUIRE_CRYPT_CONTEXT 0xC000EB37

// XEVENT_GENEALOGY_ERROR_GET_USER_KEY, 60216, Error
#define XEVENT_GENEALOGY_ERROR_GET_USER_KEY 0xC000EB38

// XEVENT_GENEALOGY_UPDATE_ERROR_CLOSE_DATA_FEED, 60217, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_CLOSE_DATA_FEED 0xC000EB39

// XEVENT_GENEALOGY_VERIFY_ERROR_CLOSE_EEPROM_DAT_FILE, 60218, Error
#define XEVENT_GENEALOGY_VERIFY_ERROR_CLOSE_EEPROM_DAT_FILE 0xC000EB3A

// XEVENT_GENEALOGY_UPDATE_ERROR_CLOSE_DATA_FEED_1, 60219, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_CLOSE_DATA_FEED_1 0xC000EB3B

// XEVENT_GENEALOGY_ERROR_CALL_SPROC_1, 60220, Error
#define XEVENT_GENEALOGY_ERROR_CALL_SPROC_1 0xC000EB3C

// XEVENT_GENEALOGY_ERROR_CALL_SPROC_2, 60221, Error
#define XEVENT_GENEALOGY_ERROR_CALL_SPROC_2 0xC000EB3D

// XEVENT_GENEALOGY_OUT_OF_MEMORY_8, 60222, Error
#define XEVENT_GENEALOGY_OUT_OF_MEMORY_8 0xC000EB3E

// XEVENT_GENEALOGY_OUT_OF_MEMORY_9, 60223, Error
#define XEVENT_GENEALOGY_OUT_OF_MEMORY_9 0xC000EB3F

// XEVENT_GENEALOGY_OUT_OF_MEMORY_10, 60224, Error
#define XEVENT_GENEALOGY_OUT_OF_MEMORY_10 0xC000EB40

// XEVENT_GENEALOGY_SET_STATUS_FAILED, 60225, Error
#define XEVENT_GENEALOGY_SET_STATUS_FAILED 0xC000EB41

// XEVENT_GENEALOGY_SET_STATUS_FAILED_1, 60226, Error
#define XEVENT_GENEALOGY_SET_STATUS_FAILED_1 0xC000EB42

// XEVENT_GENEALOGY_SET_STATUS_FAILED_2, 60227, Error
#define XEVENT_GENEALOGY_SET_STATUS_FAILED_2 0xC000EB43

// XEVENT_GENEALOGY_SET_STATUS_FAILED_3, 60228, Error
#define XEVENT_GENEALOGY_SET_STATUS_FAILED_3 0xC000EB44

// XEVENT_TOOLS_CODE_29, 60229, Error
#define XEVENT_TOOLS_CODE_29 0xC000EB45

// XEVENT_GENEALOGY_OUT_OF_MEMORY_11, 60230, Error
#define XEVENT_GENEALOGY_OUT_OF_MEMORY_11 0xC000EB46

// XEVENT_GENEALOGY_SET_STATUS_FAILED_4, 60231, Error
#define XEVENT_GENEALOGY_SET_STATUS_FAILED_4 0xC000EB47

// XEVENT_TOOLS_CODE_32, 60232, Error
#define XEVENT_TOOLS_CODE_32 0xC000EB48

// XEVENT_TOOLS_CODE_33, 60233, Error
#define XEVENT_TOOLS_CODE_33 0xC000EB49

// XEVENT_TOOLS_CODE_34, 60234, Error
#define XEVENT_TOOLS_CODE_34 0xC000EB4A

// XEVENT_GENEALOGY_SET_STATUS_FAILED_5, 60235, Error
#define XEVENT_GENEALOGY_SET_STATUS_FAILED_5 0xC000EB4B

// XEVENT_GENEALOGY_SET_STATUS_FAILED_6, 60236, Error
#define XEVENT_GENEALOGY_SET_STATUS_FAILED_6 0xC000EB4C

// XEVENT_GENEALOGY_SET_STATUS_FAILED_7, 60237, Error
#define XEVENT_GENEALOGY_SET_STATUS_FAILED_7 0xC000EB4D

// XEVENT_GENEALOGY_SET_STATUS_FAILED_8, 60238, Error
#define XEVENT_GENEALOGY_SET_STATUS_FAILED_8 0xC000EB4E

// XEVENT_GENEALOGY_ERROR_DESTROYING_KEY_HANDLE_1, 60239, Error
#define XEVENT_GENEALOGY_ERROR_DESTROYING_KEY_HANDLE_1 0xC000EB4F

// XEVENT_GENEALOGY_ERROR_RELEASING_CRYPT_CONTEXT_1, 60240, Error
#define XEVENT_GENEALOGY_ERROR_RELEASING_CRYPT_CONTEXT_1 0xC000EB50

// XEVENT_GENEALOGY_ERROR_AQUIRE_CRYPT_CONTEXT_1, 60241, Error
#define XEVENT_GENEALOGY_ERROR_AQUIRE_CRYPT_CONTEXT_1 0xC000EB51

// XEVENT_GENEALOGY_ERROR_GET_USER_KEY_1, 60242, Error
#define XEVENT_GENEALOGY_ERROR_GET_USER_KEY_1 0xC000EB52

// XEVENT_GENEALOGY_ERROR_FILE_READ, 60243, Error
#define XEVENT_GENEALOGY_ERROR_FILE_READ 0xC000EB53

// XEVENT_TOOLS_CODE_44, 60244, Error
#define XEVENT_TOOLS_CODE_44 0xC000EB54

// XEVENT_TOOLS_CODE_45, 60245, Error
#define XEVENT_TOOLS_CODE_45 0xC000EB55

// XEVENT_MB_BAN_FAILED, 60246, Error
#define XEVENT_MB_BAN_FAILED 0xC000EB56

// XEVENT_MB_UNBAN_FAILED, 60247, Error
#define XEVENT_MB_UNBAN_FAILED 0xC000EB57

// XEVENT_TOOLS_CODE_48, 60248, Error
#define XEVENT_TOOLS_CODE_48 0xC000EB58

// XEVENT_PROXIMITY_W_GENERIC, 60249, Error
#define XEVENT_PROXIMITY_W_GENERIC 0xC000EB59

// XEVENT_PROXIMITY_E_GENERIC, 60250, Error
#define XEVENT_PROXIMITY_E_GENERIC 0xC000EB5A

// XEVENT_PROXIMITY_E_ABORTED, 60251, Error
#define XEVENT_PROXIMITY_E_ABORTED 0xC000EB5B

// XEVENT_TOOLS_CODE_52, 60252, Error
#define XEVENT_TOOLS_CODE_52 0xC000EB5C

// XEVENT_TOOLS_CODE_53, 60253, Error
#define XEVENT_TOOLS_CODE_53 0xC000EB5D

// XEVENT_TOOLS_CODE_54, 60254, Error
#define XEVENT_TOOLS_CODE_54 0xC000EB5E

// XEVENT_SPSPROXY_EXCEPTION, 60255, Error
#define XEVENT_SPSPROXY_EXCEPTION 0xC000EB5F

// XEVENT_SPUT_GENERAL_ERROR, 60256, Error
#define XEVENT_SPUT_GENERAL_ERROR 0xC000EB60

// XEVENT_TITLEMGR_GENERAL_ERROR, 60257, Error
#define XEVENT_TITLEMGR_GENERAL_ERROR 0xC000EB61

// XEVENT_TOOLS_CODE_58, 60258, Error
#define XEVENT_TOOLS_CODE_58 0xC000EB62

// XEVENT_TOOLS_CODE_59, 60259, Error
#define XEVENT_TOOLS_CODE_59 0xC000EB63

// XEVENT_XWIRETAP_GENERIC_ERROR, 60260, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR 0xC000EB64

// XEVENT_XWIRETAP_GENERIC_ERROR_1, 60261, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_1 0xC000EB65

// XEVENT_XWIRETAP_GENERIC_ERROR_2, 60262, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_2 0xC000EB66

// XEVENT_XWIRETAP_GENERIC_ERROR_3, 60263, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_3 0xC000EB67

// XEVENT_XWIRETAP_GENERIC_ERROR_4, 60264, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_4 0xC000EB68

// XEVENT_XWIRETAP_MEMORY_WARNING, 60265, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING 0xC000EB69

// XEVENT_XWIRETAP_MEMORY_WARNING_1, 60266, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_1 0xC000EB6A

// XEVENT_XWIRETAP_MEMORY_WARNING_2, 60267, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_2 0xC000EB6B

// XEVENT_XWIRETAP_MEMORY_WARNING_3, 60268, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_3 0xC000EB6C

// XEVENT_XWIRETAP_MEMORY_WARNING_4, 60269, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_4 0xC000EB6D

// XEVENT_XWIRETAP_MEMORY_WARNING_5, 60270, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_5 0xC000EB6E

// XEVENT_XWIRETAP_MEMORY_WARNING_6, 60271, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_6 0xC000EB6F

// XEVENT_XWIRETAP_MEMORY_WARNING_7, 60272, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_7 0xC000EB70

// XEVENT_XWIRETAP_MEMORY_WARNING_8, 60273, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_8 0xC000EB71

// XEVENT_XWIRETAP_MEMORY_WARNING_9, 60274, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_9 0xC000EB72

// XEVENT_KDC_BASE_NO_MEMORY_2, 60275, Error
#define XEVENT_KDC_BASE_NO_MEMORY_2 0xC000EB73

// XEVENT_XWIRETAP_GENERIC_ERROR_5, 60276, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_5 0xC000EB74

// XEVENT_XWIRETAP_MEMORY_WARNING_10, 60277, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_10 0xC000EB75

// XEVENT_XWIRETAP_MEMORY_WARNING_11, 60278, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_11 0xC000EB76

// XEVENT_XWIRETAP_MEMORY_WARNING_12, 60279, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_12 0xC000EB77

// XEVENT_XWIRETAP_MEMORY_WARNING_13, 60280, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_13 0xC000EB78

// XEVENT_XWIRETAP_MEMORY_WARNING_14, 60281, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_14 0xC000EB79

// XEVENT_XWIRETAP_MEMORY_WARNING_15, 60282, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_15 0xC000EB7A

// XEVENT_XWIRETAP_MEMORY_WARNING_16, 60283, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_16 0xC000EB7B

// XEVENT_XWIRETAP_MEMORY_WARNING_17, 60284, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_17 0xC000EB7C

// XEVENT_XWIRETAP_GENERIC_ERROR_6, 60285, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_6 0xC000EB7D

// XEVENT_XWIRETAP_GENERIC_ERROR_7, 60286, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_7 0xC000EB7E

// XEVENT_XWIRETAP_MEMORY_WARNING_18, 60287, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_18 0xC000EB7F

// XEVENT_XWIRETAP_MEMORY_WARNING_19, 60288, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_19 0xC000EB80

// XEVENT_XWIRETAP_MEMORY_WARNING_20, 60289, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_20 0xC000EB81

// XEVENT_XWIRETAP_MEMORY_WARNING_21, 60290, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_21 0xC000EB82

// XEVENT_XWIRETAP_GENERIC_ERROR_8, 60291, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_8 0xC000EB83

// XEVENT_XWIRETAP_GENERIC_ERROR_9, 60292, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_9 0xC000EB84

// XEVENT_XWIRETAP_MEMORY_WARNING_22, 60293, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_22 0xC000EB85

// XEVENT_XWIRETAP_MEMORY_WARNING_23, 60294, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_23 0xC000EB86

// XEVENT_XWIRETAP_MEMORY_WARNING_24, 60295, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_24 0xC000EB87

// XEVENT_XWIRETAP_CAP_FILE_WRITE_FAILED, 60296, Error
#define XEVENT_XWIRETAP_CAP_FILE_WRITE_FAILED 0xC000EB88

// XEVENT_XWIRETAP_CAP_FILE_WRITE_FAILED_1, 60297, Error
#define XEVENT_XWIRETAP_CAP_FILE_WRITE_FAILED_1 0xC000EB89

// XEVENT_XWIRETAP_CAP_FILE_WRITE_FAILED_2, 60298, Error
#define XEVENT_XWIRETAP_CAP_FILE_WRITE_FAILED_2 0xC000EB8A

// XEVENT_XWIRETAP_MEMORY_WARNING_25, 60299, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_25 0xC000EB8B

// XEVENT_XWIRETAP_GENERIC_ERROR_10, 60300, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_10 0xC000EB8C

// XEVENT_XWIRETAP_MEMORY_WARNING_26, 60301, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_26 0xC000EB8D

// XEVENT_XWIRETAP_MEMORY_WARNING_27, 60302, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_27 0xC000EB8E

// XEVENT_XWIRETAP_INIT_FAIL, 60303, Error
#define XEVENT_XWIRETAP_INIT_FAIL 0xC000EB8F

// XEVENT_XWIRETAP_MEMORY_WARNING_28, 60304, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_28 0xC000EB90

// XEVENT_XWIRETAP_MEMORY_WARNING_29, 60305, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_29 0xC000EB91

// XEVENT_XWIRETAP_INIT_FAIL_1, 60306, Error
#define XEVENT_XWIRETAP_INIT_FAIL_1 0xC000EB92

// XEVENT_XWIRETAP_MEMORY_WARNING_30, 60307, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_30 0xC000EB93

// XEVENT_XWIRETAP_MEMORY_WARNING_31, 60308, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_31 0xC000EB94

// XEVENT_XWIRETAP_MEMORY_WARNING_32, 60309, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_32 0xC000EB95

// XEVENT_XWIRETAP_MEMORY_WARNING_33, 60310, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_33 0xC000EB96

// XEVENT_XWIRETAP_MEMORY_WARNING_34, 60311, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_34 0xC000EB97

// XEVENT_XWIRETAP_INIT_FAIL_2, 60312, Error
#define XEVENT_XWIRETAP_INIT_FAIL_2 0xC000EB98

// XEVENT_XWIRETAP_INIT_FAIL_3, 60313, Error
#define XEVENT_XWIRETAP_INIT_FAIL_3 0xC000EB99

// XEVENT_XWIRETAP_TERM_FAIL, 60314, Error
#define XEVENT_XWIRETAP_TERM_FAIL 0xC000EB9A

// XEVENT_XWIRETAP_MEMORY_WARNING_35, 60315, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_35 0xC000EB9B

// XEVENT_XWIRETAP_TERM_FAIL_1, 60316, Error
#define XEVENT_XWIRETAP_TERM_FAIL_1 0xC000EB9C

// XEVENT_XWIRETAP_GENERIC_ERROR_11, 60317, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_11 0xC000EB9D

// XEVENT_XWIRETAP_GENERIC_ERROR_12, 60318, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_12 0xC000EB9E

// XEVENT_TOOLS_CODE_119, 60319, Error
#define XEVENT_TOOLS_CODE_119 0xC000EB9F

// XEVENT_XWIRETAP_INIT_FAIL_4, 60320, Error
#define XEVENT_XWIRETAP_INIT_FAIL_4 0xC000EBA0

// XEVENT_XWIRETAP_INIT_FAIL_5, 60321, Error
#define XEVENT_XWIRETAP_INIT_FAIL_5 0xC000EBA1

// XEVENT_XWIRETAP_MEMORY_WARNING_36, 60322, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_36 0xC000EBA2

// XEVENT_XWIRETAP_MEMORY_WARNING_37, 60323, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_37 0xC000EBA3

// XEVENT_XWIRETAP_TAP_CLOSE_ERROR, 60324, Error
#define XEVENT_XWIRETAP_TAP_CLOSE_ERROR 0xC000EBA4

// XEVENT_XWIRETAP_TAP_CLOSE_ERROR_1, 60325, Error
#define XEVENT_XWIRETAP_TAP_CLOSE_ERROR_1 0xC000EBA5

// XEVENT_XWIRETAP_MEMORY_WARNING_38, 60326, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_38 0xC000EBA6

// XEVENT_XWIRETAP_VLAN_ERROR, 60327, Error
#define XEVENT_XWIRETAP_VLAN_ERROR 0xC000EBA7

// XEVENT_XWIRETAP_TAP_CLOSE_ERROR_2, 60328, Error
#define XEVENT_XWIRETAP_TAP_CLOSE_ERROR_2 0xC000EBA8

// XEVENT_XWIRETAP_TAP_CLOSE_ERROR_3, 60329, Error
#define XEVENT_XWIRETAP_TAP_CLOSE_ERROR_3 0xC000EBA9

// XEVENT_XWIRETAP_MEMORY_WARNING_39, 60330, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_39 0xC000EBAA

// XEVENT_XWIRETAP_MEMORY_WARNING_40, 60331, Error
#define XEVENT_XWIRETAP_MEMORY_WARNING_40 0xC000EBAB

// XEVENT_XWIRETAP_GENERIC_ERROR_13, 60332, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_13 0xC000EBAC

// XEVENT_XWIRETAP_GENERIC_ERROR_14, 60333, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_14 0xC000EBAD

// XEVENT_XWIRETAP_GENERIC_ERROR_15, 60334, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_15 0xC000EBAE

// XEVENT_XWIRETAP_GENERIC_ERROR_16, 60335, Error
#define XEVENT_XWIRETAP_GENERIC_ERROR_16 0xC000EBAF

// XEVENT_XWIRETAP_INIT_FAIL_6, 60336, Error
#define XEVENT_XWIRETAP_INIT_FAIL_6 0xC000EBB0

// XEVENT_XWIRETAP_INIT_FAIL_7, 60337, Error
#define XEVENT_XWIRETAP_INIT_FAIL_7 0xC000EBB1

// XEVENT_TOOLS_CODE_138, 60338, Error
#define XEVENT_TOOLS_CODE_138 0xC000EBB2

// XEVENT_TOOLS_CODE_139, 60339, Error
#define XEVENT_TOOLS_CODE_139 0xC000EBB3

// XEVENT_TOOLS_CODE_140, 60340, Error
#define XEVENT_TOOLS_CODE_140 0xC000EBB4

// XEVENT_TOOLS_CODE_141, 60341, Error
#define XEVENT_TOOLS_CODE_141 0xC000EBB5

// XEVENT_TOOLS_CODE_142, 60342, Error
#define XEVENT_TOOLS_CODE_142 0xC000EBB6

// XEVENT_TOOLS_CODE_143, 60343, Error
#define XEVENT_TOOLS_CODE_143 0xC000EBB7

// XEVENT_UDPADPT_GENERIC_ERROR, 60344, Error
#define XEVENT_UDPADPT_GENERIC_ERROR 0xC000EBB8

// XEVENT_UDPADPT_GENERIC_ERROR_1, 60345, Error
#define XEVENT_UDPADPT_GENERIC_ERROR_1 0xC000EBB9

// XEVENT_UDPADPT_GENERIC_ERROR_2, 60346, Error
#define XEVENT_UDPADPT_GENERIC_ERROR_2 0xC000EBBA

// XEVENT_UDPADPT_GENERIC_ERROR_3, 60347, Error
#define XEVENT_UDPADPT_GENERIC_ERROR_3 0xC000EBBB

// XEVENT_UDPADPT_GENERIC_ERROR_4, 60348, Error
#define XEVENT_UDPADPT_GENERIC_ERROR_4 0xC000EBBC

// XEVENT_UDPADPT_GENERIC_ERROR_5, 60349, Error
#define XEVENT_UDPADPT_GENERIC_ERROR_5 0xC000EBBD

// XEVENT_UDPADPT_GENERIC_ERROR_6, 60350, Error
#define XEVENT_UDPADPT_GENERIC_ERROR_6 0xC000EBBE

// XEVENT_UDPADPT_GENERIC_ERROR_7, 60351, Error
#define XEVENT_UDPADPT_GENERIC_ERROR_7 0xC000EBBF

// XEVENT_UDPADPT_GENERIC_ERROR_8, 60352, Error
#define XEVENT_UDPADPT_GENERIC_ERROR_8 0xC000EBC0

// XEVENT_UDPADPT_GENERIC_ERROR_9, 60353, Error
#define XEVENT_UDPADPT_GENERIC_ERROR_9 0xC000EBC1

// XEVENT_UDPADPT_INIT_FAILURE, 60354, Error
#define XEVENT_UDPADPT_INIT_FAILURE 0xC000EBC2

// XEVENT_UDPADPT_INIT_FAILURE_1, 60355, Error
#define XEVENT_UDPADPT_INIT_FAILURE_1 0xC000EBC3

// XEVENT_UDPADPT_GENERIC_ERROR_10, 60356, Error
#define XEVENT_UDPADPT_GENERIC_ERROR_10 0xC000EBC4

// XEVENT_UDPADPT_GENERIC_ERROR_11, 60357, Error
#define XEVENT_UDPADPT_GENERIC_ERROR_11 0xC000EBC5

// XEVENT_UDPADPT_GENERIC_ERROR_12, 60358, Error
#define XEVENT_UDPADPT_GENERIC_ERROR_12 0xC000EBC6

// XEVENT_UDPADPT_WINHTTP_ERROR, 60359, Error
#define XEVENT_UDPADPT_WINHTTP_ERROR 0xC000EBC7

// XEVENT_UDPADPT_GENERIC_ERROR_13, 60360, Error
#define XEVENT_UDPADPT_GENERIC_ERROR_13 0xC000EBC8

// XEVENT_UDPADPT_UDPMGR_ERROR, 60361, Error
#define XEVENT_UDPADPT_UDPMGR_ERROR 0xC000EBC9

// XEVENT_UDPADPT_GENERIC_ERROR_14, 60362, Error
#define XEVENT_UDPADPT_GENERIC_ERROR_14 0xC000EBCA

// XEVENT_UDPADPT_TERM_FAIL, 60363, Error
#define XEVENT_UDPADPT_TERM_FAIL 0xC000EBCB

// XEVENT_TOOLS_CODE_164, 60364, Error
#define XEVENT_TOOLS_CODE_164 0xC000EBCC

// XEVENT_TOOLS_CODE_165, 60365, Error
#define XEVENT_TOOLS_CODE_165 0xC000EBCD

// XEVENT_TOOLS_CODE_166, 60366, Error
#define XEVENT_TOOLS_CODE_166 0xC000EBCE

// XEVENT_TOOLS_CODE_167, 60367, Error
#define XEVENT_TOOLS_CODE_167 0xC000EBCF

// XEVENT_TOOLS_CODE_168, 60368, Error
#define XEVENT_TOOLS_CODE_168 0xC000EBD0

// XEVENT_TOOLS_CODE_169, 60369, Error
#define XEVENT_TOOLS_CODE_169 0xC000EBD1

// XEVENT_UDPADPT_GENERIC_ERROR_15, 60370, Error
#define XEVENT_UDPADPT_GENERIC_ERROR_15 0xC000EBD2

// XEVENT_UDPADPT_INIT_FAILURE_2, 60371, Error
#define XEVENT_UDPADPT_INIT_FAILURE_2 0xC000EBD3

// XEVENT_TOOLS_CODE_172, 60372, Error
#define XEVENT_TOOLS_CODE_172 0xC000EBD4

// XEVENT_TOOLS_CODE_173, 60373, Error
#define XEVENT_TOOLS_CODE_173 0xC000EBD5

// XEVENT_TOOLS_CODE_174, 60374, Error
#define XEVENT_TOOLS_CODE_174 0xC000EBD6

// XEVENT_TOOLS_CODE_175, 60375, Error
#define XEVENT_TOOLS_CODE_175 0xC000EBD7

// XEVENT_VOUCHERMGR_INVALID_OFFER, 60376, Error
#define XEVENT_VOUCHERMGR_INVALID_OFFER 0xC000EBD8

// XEVENT_VOUCHERMGR_FAILED_ATTEMPT, 60377, Error
#define XEVENT_VOUCHERMGR_FAILED_ATTEMPT 0xC000EBD9

// XEVENT_VOUCHERMGR_FAILED_COMPLETE, 60384, Warning
#define XEVENT_VOUCHERMGR_FAILED_COMPLETE 0x8000EBE0

// XEVENT_GENERIC_TOOLS_ERROR, 60385, Warning
#define XEVENT_GENERIC_TOOLS_ERROR 0x8000EBE1

// XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY, 60600, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY 0xC000ECB8

// XEVENT_GENEALOGY_UPDATE_ERROR_NUM_DB_FIELDS_WRONG, 60601, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_NUM_DB_FIELDS_WRONG 0xC000ECB9

// XEVENT_GENEALOGY_UPDATE_ERROR_BAD_DATA_PARSE, 60602, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_BAD_DATA_PARSE 0xC000ECBA

// XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_1, 60603, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_1 0xC000ECBB

// XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_2, 60604, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_2 0xC000ECBC

// XEVENT_GENEALOGY_WARN_TITLE_ROW_DISCARDED, 60605, Error
#define XEVENT_GENEALOGY_WARN_TITLE_ROW_DISCARDED 0xC000ECBD

// XEVENT_GENEALOGY_UPDATE_ERROR_EOL_FOUND_TOO_EARLY, 60606, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_EOL_FOUND_TOO_EARLY 0xC000ECBE

// XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_3, 60607, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_3 0xC000ECBF

// XEVENT_GENEALOGY_UPDATE_ERROR_LINE_TOO_LONG, 60608, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_LINE_TOO_LONG 0xC000ECC0

// XEVENT_GENEALOGY_VERIFY_ERROR_WRONG_NUMBER_BYTES_READ, 60609, Error
#define XEVENT_GENEALOGY_VERIFY_ERROR_WRONG_NUMBER_BYTES_READ 0xC000ECC1

// XEVENT_GENEALOGY_VERIFY_ERROR_CREATING_SERIAL_NUMBER, 60610, Error
#define XEVENT_GENEALOGY_VERIFY_ERROR_CREATING_SERIAL_NUMBER 0xC000ECC2

// XEVENT_GENEALOGY_ERROR_INVALID_PART_NUMBER, 60611, Error
#define XEVENT_GENEALOGY_ERROR_INVALID_PART_NUMBER 0xC000ECC3

// XEVENT_GENEALOGY_VERIFY_WRONG_STRING_LENGTH, 60612, Error
#define XEVENT_GENEALOGY_VERIFY_WRONG_STRING_LENGTH 0xC000ECC4

// XEVENT_GENEALOGY_VERIFY_BAD_STRING_DATA, 60613, Error
#define XEVENT_GENEALOGY_VERIFY_BAD_STRING_DATA 0xC000ECC5

// XEVENT_GENEALOGY_VERIFY_ERROR_RC4_DECRYPT, 60614, Error
#define XEVENT_GENEALOGY_VERIFY_ERROR_RC4_DECRYPT 0xC000ECC6

// XEVENT_GENEALOGY_VERIFY_ERROR_COMPUTE_PPA, 60615, Error
#define XEVENT_GENEALOGY_VERIFY_ERROR_COMPUTE_PPA 0xC000ECC7

// XEVENT_GENEALOGY_VERIFY_ERROR_INTERNAL_EXTERNAL_COMPARE, 60616, Error
#define XEVENT_GENEALOGY_VERIFY_ERROR_INTERNAL_EXTERNAL_COMPARE 0xC000ECC8

// XEVENT_GENEALOGY_VERIFY_BAD_SERIAL_NUMBER_VALUE, 60617, Error
#define XEVENT_GENEALOGY_VERIFY_BAD_SERIAL_NUMBER_VALUE 0xC000ECC9

// XEVENT_GENEALOGY_ERROR_GET_NEXT_ROW, 60618, Error
#define XEVENT_GENEALOGY_ERROR_GET_NEXT_ROW 0xC000ECCA

// XEVENT_GENEALOGY_SERIAL_NUMBER_NOT_FOUND, 60619, Error
#define XEVENT_GENEALOGY_SERIAL_NUMBER_NOT_FOUND 0xC000ECCB

// XEVENT_GENEALOGY_ERROR_DB_INIT_STRING_CREATE, 60620, Error
#define XEVENT_GENEALOGY_ERROR_DB_INIT_STRING_CREATE 0xC000ECCC

// XEVENT_GENEALOGY_ERROR_DB_OPEN_FAILED, 60621, Error
#define XEVENT_GENEALOGY_ERROR_DB_OPEN_FAILED 0xC000ECCD

// XEVENT_GENEALOGY_ERROR_DECODE_ONLINE_KEY, 60622, Error
#define XEVENT_GENEALOGY_ERROR_DECODE_ONLINE_KEY 0xC000ECCE

// XEVENT_GENEALOGY_ERROR_DECRYPT_ONLINE_KEY, 60623, Error
#define XEVENT_GENEALOGY_ERROR_DECRYPT_ONLINE_KEY 0xC000ECCF

// XEVENT_GENEALOGY_UPDATE_ERROR_BAD_DATA_PARSE_1, 60624, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_BAD_DATA_PARSE_1 0xC000ECD0

// XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_4, 60625, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_4 0xC000ECD1

// XEVENT_GENEALOGY_UPDATE_ERROR_NUM_DB_FIELDS_WRONG_1, 60626, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_NUM_DB_FIELDS_WRONG_1 0xC000ECD2

// XEVENT_GENEALOGY_UPDATE_ERROR_BAD_DATA_PARSE_2, 60627, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_BAD_DATA_PARSE_2 0xC000ECD3

// XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_5, 60628, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_5 0xC000ECD4

// XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_6, 60629, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_6 0xC000ECD5

// XEVENT_GENEALOGY_WARN_TITLE_ROW_DISCARDED_1, 60630, Error
#define XEVENT_GENEALOGY_WARN_TITLE_ROW_DISCARDED_1 0xC000ECD6

// XEVENT_GENEALOGY_UPDATE_ERROR_EOL_FOUND_TOO_EARLY_1, 60631, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_EOL_FOUND_TOO_EARLY_1 0xC000ECD7

// XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_7, 60632, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_7 0xC000ECD8

// XEVENT_GENEALOGY_UPDATE_ERROR_LINE_TOO_LONG_1, 60633, Error
#define XEVENT_GENEALOGY_UPDATE_ERROR_LINE_TOO_LONG_1 0xC000ECD9

// XEVENT_GENEALOGY_ERROR_DB_INIT_STRING_CREATE_1, 60634, Error
#define XEVENT_GENEALOGY_ERROR_DB_INIT_STRING_CREATE_1 0xC000ECDA

// XEVENT_GENEALOGY_ERROR_DB_OPEN_FAILED_1, 60635, Error
#define XEVENT_GENEALOGY_ERROR_DB_OPEN_FAILED_1 0xC000ECDB

// XEVENT_GENEALOGY_ERROR_INVALID_PART_NUMBER_1, 60636, Error
#define XEVENT_GENEALOGY_ERROR_INVALID_PART_NUMBER_1 0xC000ECDC

// XEVENT_GENEALOGY_VERIFY_WRONG_STRING_LENGTH_1, 60637, Error
#define XEVENT_GENEALOGY_VERIFY_WRONG_STRING_LENGTH_1 0xC000ECDD

// XEVENT_GENEALOGY_VERIFY_BAD_STRING_DATA_1, 60638, Error
#define XEVENT_GENEALOGY_VERIFY_BAD_STRING_DATA_1 0xC000ECDE

// XEVENT_GENEALOGY_VERIFY_ERROR_COMPUTE_PPA_1, 60639, Error
#define XEVENT_GENEALOGY_VERIFY_ERROR_COMPUTE_PPA_1 0xC000ECDF

// XEVENT_GENEALOGY_ERROR_MISSING_PPA_DATA_IN_ROW, 60640, Error
#define XEVENT_GENEALOGY_ERROR_MISSING_PPA_DATA_IN_ROW 0xC000ECE0

// XEVENT_GENEALOGY_VERIFY_ERROR_INTERNAL_EXTERNAL_COMPARE_1, 60641, Error
#define XEVENT_GENEALOGY_VERIFY_ERROR_INTERNAL_EXTERNAL_COMPARE_1 0xC000ECE1

// XEVENT_GENEALOGY_VERIFY_BAD_SERIAL_NUMBER_VALUE_1, 60642, Error
#define XEVENT_GENEALOGY_VERIFY_BAD_SERIAL_NUMBER_VALUE_1 0xC000ECE2

// XEVENT_GENEALOGY_ERROR_DECODE_ONLINE_KEY_1, 60643, Error
#define XEVENT_GENEALOGY_ERROR_DECODE_ONLINE_KEY_1 0xC000ECE3

// XEVENT_GENEALOGY_ERROR_DECRYPT_ONLINE_KEY_1, 60644, Error
#define XEVENT_GENEALOGY_ERROR_DECRYPT_ONLINE_KEY_1 0xC000ECE4

// XEVENT_TOOLS_COMM_45, 60645, Error
#define XEVENT_TOOLS_COMM_45 0xC000ECE5

// XEVENT_TOOLS_COMM_46, 60646, Error
#define XEVENT_TOOLS_COMM_46 0xC000ECE6

// XEVENT_TOOLS_COMM_47, 60647, Error
#define XEVENT_TOOLS_COMM_47 0xC000ECE7

// XEVENT_TOOLS_COMM_48, 60648, Error
#define XEVENT_TOOLS_COMM_48 0xC000ECE8

// XEVENT_KDC_BASE_WINHTTP_ERROR, 60649, Error
#define XEVENT_KDC_BASE_WINHTTP_ERROR 0xC000ECE9

// XEVENT_TOOLS_COMM_50, 60650, Error
#define XEVENT_TOOLS_COMM_50 0xC000ECEA

// XEVENT_TOOLS_COMM_51, 60651, Error
#define XEVENT_TOOLS_COMM_51 0xC000ECEB

// XEVENT_TOOLS_COMM_52, 60652, Error
#define XEVENT_TOOLS_COMM_52 0xC000ECEC

// XEVENT_TOOLSSRV_TMR_FILE_UNLOCK_FAILED, 60653, Error
#define XEVENT_TOOLSSRV_TMR_FILE_UNLOCK_FAILED 0xC000ECED

// XEVENT_TOOLSSRV_TMR_FILE_LOCK_FAILED, 60654, Error
#define XEVENT_TOOLSSRV_TMR_FILE_LOCK_FAILED 0xC000ECEE

// XEVENT_TOOLS_COMM_55, 60655, Error
#define XEVENT_TOOLS_COMM_55 0xC000ECEF

// XEVENT_XWIRETAP_SG_COMMUNICATION_FAILURE, 60656, Error
#define XEVENT_XWIRETAP_SG_COMMUNICATION_FAILURE 0xC000ECF0

// XEVENT_XWIRETAP_SG_COMMUNICATION_FAILURE_1, 60657, Error
#define XEVENT_XWIRETAP_SG_COMMUNICATION_FAILURE_1 0xC000ECF1

// XEVENT_XWIRETAP_SG_COMMUNICATION_FAILURE_2, 60658, Error
#define XEVENT_XWIRETAP_SG_COMMUNICATION_FAILURE_2 0xC000ECF2

// XEVENT_TOOLS_COMM_59, 60659, Error
#define XEVENT_TOOLS_COMM_59 0xC000ECF3

// XEVENT_TOOLS_COMM_60, 60660, Error
#define XEVENT_TOOLS_COMM_60 0xC000ECF4

// XEVENT_TOOLS_COMM_61, 60661, Error
#define XEVENT_TOOLS_COMM_61 0xC000ECF5

// XEVENT_TOOLS_COMM_62, 60662, Error
#define XEVENT_TOOLS_COMM_62 0xC000ECF6

// XEVENT_TOOLS_CONFIG_0, 60800, Warning
#define XEVENT_TOOLS_CONFIG_0 0x8000ED80

// XEVENT_XMACS_INVALID_PRINCIPAL_9, 60801, Error
#define XEVENT_XMACS_INVALID_PRINCIPAL_9 0xC000ED81

// XEVENT_XMACS_INVALID_PRINCIPAL_10, 60802, Error
#define XEVENT_XMACS_INVALID_PRINCIPAL_10 0xC000ED82

// XEVENT_GENEALOGY_ERROR_SETUP_TABLE_BINDINGS, 60803, Error
#define XEVENT_GENEALOGY_ERROR_SETUP_TABLE_BINDINGS 0xC000ED83

// XEVENT_GENEALOGY_ERROR_OPEN_FILE, 60804, Error
#define XEVENT_GENEALOGY_ERROR_OPEN_FILE 0xC000ED84

// XEVENT_GENEALOGY_ERROR_GET_SETTING, 60805, Error
#define XEVENT_GENEALOGY_ERROR_GET_SETTING 0xC000ED85

// XEVENT_GENEALOGY_ERROR_XMGMT_INIT_FAIL, 60806, Error
#define XEVENT_GENEALOGY_ERROR_XMGMT_INIT_FAIL 0xC000ED86

// XEVENT_GENEALOGY_ERROR_OPEN_FILE_1, 60807, Error
#define XEVENT_GENEALOGY_ERROR_OPEN_FILE_1 0xC000ED87

// XEVENT_TOOLS_CONFIG_8, 60808, Error
#define XEVENT_TOOLS_CONFIG_8 0xC000ED88

// XEVENT_TOOLS_CONFIG_9, 60809, Error
#define XEVENT_TOOLS_CONFIG_9 0xC000ED89

// XEVENT_TOOLS_CONFIG_10, 60810, Error
#define XEVENT_TOOLS_CONFIG_10 0xC000ED8A

// XEVENT_GENEALOGY_SERVICE_START_FAILED, 60811, Error
#define XEVENT_GENEALOGY_SERVICE_START_FAILED 0xC000ED8B

// XEVENT_GENEALOGY_SERVICE_START_FAILED_1, 60812, Error
#define XEVENT_GENEALOGY_SERVICE_START_FAILED_1 0xC000ED8C

// XEVENT_TOOLS_CONFIG_13, 60813, Error
#define XEVENT_TOOLS_CONFIG_13 0xC000ED8D

// XEVENT_TOOLS_CONFIG_14, 60814, Error
#define XEVENT_TOOLS_CONFIG_14 0xC000ED8E

// XEVENT_TOOLS_CONFIG_15, 60815, Error
#define XEVENT_TOOLS_CONFIG_15 0xC000ED8F

// XEVENT_TOOLS_CONFIG_16, 60816, Error
#define XEVENT_TOOLS_CONFIG_16 0xC000ED90

// XEVENT_TOOLS_CONFIG_17, 60817, Error
#define XEVENT_TOOLS_CONFIG_17 0xC000ED91

// XEVENT_TOOLS_CONFIG_18, 60818, Error
#define XEVENT_TOOLS_CONFIG_18 0xC000ED92

// XEVENT_TOOLS_CONFIG_19, 60819, Error
#define XEVENT_TOOLS_CONFIG_19 0xC000ED93

// XEVENT_TOOLS_CONFIG_20, 60820, Error
#define XEVENT_TOOLS_CONFIG_20 0xC000ED94

// XEVENT_TOOLS_CONFIG_21, 60821, Error
#define XEVENT_TOOLS_CONFIG_21 0xC000ED95

// XEVENT_TOOLS_CONFIG_22, 60822, Warning
#define XEVENT_TOOLS_CONFIG_22 0x8000ED96

// XEVENT_GENEALOGY_SERVICE_START_FAILED_2, 60823, Error
#define XEVENT_GENEALOGY_SERVICE_START_FAILED_2 0xC000ED97

// XEVENT_GENEALOGY_SERVICE_START_FAILED_3, 60824, Error
#define XEVENT_GENEALOGY_SERVICE_START_FAILED_3 0xC000ED98

// XEVENT_TOOLS_CONFIG_25, 60825, Error
#define XEVENT_TOOLS_CONFIG_25 0xC000ED99

// XEVENT_TOOLS_CONFIG_26, 60826, Error
#define XEVENT_TOOLS_CONFIG_26 0xC000ED9A

// XEVENT_TOOLS_CONFIG_27, 60827, Error
#define XEVENT_TOOLS_CONFIG_27 0xC000ED9B

// XEVENT_TOOLS_CONFIG_28, 60828, Error
#define XEVENT_TOOLS_CONFIG_28 0xC000ED9C

// XEVENT_GENEALOGY_ERROR_OPEN_FILE_2, 60829, Error
#define XEVENT_GENEALOGY_ERROR_OPEN_FILE_2 0xC000ED9D

// XEVENT_GENEALOGY_ERROR_GET_SETTING_1, 60830, Error
#define XEVENT_GENEALOGY_ERROR_GET_SETTING_1 0xC000ED9E

// XEVENT_TOOLS_CONFIG_31, 60831, Error
#define XEVENT_TOOLS_CONFIG_31 0xC000ED9F

// XEVENT_TOOLS_CONFIG_32, 60832, Error
#define XEVENT_TOOLS_CONFIG_32 0xC000EDA0

// XEVENT_GENEALOGY_ERROR_XMGMT_INIT_FAIL_1, 60833, Error
#define XEVENT_GENEALOGY_ERROR_XMGMT_INIT_FAIL_1 0xC000EDA1

// XEVENT_TOOLS_CONFIG_34, 60834, Error
#define XEVENT_TOOLS_CONFIG_34 0xC000EDA2

// XEVENT_TOOLS_CONFIG_35, 60835, Error
#define XEVENT_TOOLS_CONFIG_35 0xC000EDA3

// XEVENT_XKDC_BAD_TITLEID_2, 60836, Error
#define XEVENT_XKDC_BAD_TITLEID_2 0xC000EDA4

// XEVENT_XKDC_BAD_TITLEID_3, 60837, Error
#define XEVENT_XKDC_BAD_TITLEID_3 0xC000EDA5

// XEVENT_XKDC_BAD_SERVICEID, 60838, Error
#define XEVENT_XKDC_BAD_SERVICEID 0xC000EDA6

// XEVENT_XMACS_INVALID_PRINCIPAL_11, 60839, Error
#define XEVENT_XMACS_INVALID_PRINCIPAL_11 0xC000EDA7

// XEVENT_TOOLSSRV_TASKS_CANCELED, 60840, Warning
#define XEVENT_TOOLSSRV_TASKS_CANCELED 0x8000EDA8

// XEVENT_TOOLS_CONFIG_41, 60841, Error
#define XEVENT_TOOLS_CONFIG_41 0xC000EDA9

// XEVENT_TOOLS_CONFIG_42, 60842, Error
#define XEVENT_TOOLS_CONFIG_42 0xC000EDAA

// XEVENT_TOOLS_CONFIG_43, 60843, Error
#define XEVENT_TOOLS_CONFIG_43 0xC000EDAB

// XEVENT_XWIRETAP_XMGMT_CONNECTION_FAILED, 60844, Error
#define XEVENT_XWIRETAP_XMGMT_CONNECTION_FAILED 0xC000EDAC

// XEVENT_XWIRETAP_XMGMT_CONNECTION_FAILED_1, 60845, Error
#define XEVENT_XWIRETAP_XMGMT_CONNECTION_FAILED_1 0xC000EDAD

// XEVENT_XWIRETAP_TAP_CREATION_ERROR, 60846, Warning
#define XEVENT_XWIRETAP_TAP_CREATION_ERROR 0x8000EDAE

// XEVENT_XWIRETAP_TAP_CREATION_ERROR_1, 60847, Warning
#define XEVENT_XWIRETAP_TAP_CREATION_ERROR_1 0x8000EDAF

// XEVENT_XWIRETAP_TAP_CREATION_ERROR_2, 60848, Warning
#define XEVENT_XWIRETAP_TAP_CREATION_ERROR_2 0x8000EDB0

// XEVENT_XWIRETAP_TAP_CREATION_ERROR_3, 60849, Warning
#define XEVENT_XWIRETAP_TAP_CREATION_ERROR_3 0x8000EDB1

// XEVENT_XWIRETAP_TAP_CREATION_ERROR_4, 60850, Warning
#define XEVENT_XWIRETAP_TAP_CREATION_ERROR_4 0x8000EDB2

// XEVENT_XWIRETAP_TAP_CREATION_ERROR_5, 60851, Warning
#define XEVENT_XWIRETAP_TAP_CREATION_ERROR_5 0x8000EDB3

// XEVENT_XWIRETAP_TAP_CREATION_ERROR_6, 60852, Warning
#define XEVENT_XWIRETAP_TAP_CREATION_ERROR_6 0x8000EDB4

// XEVENT_XWIRETAP_TAP_CREATION_ERROR_7, 60853, Warning
#define XEVENT_XWIRETAP_TAP_CREATION_ERROR_7 0x8000EDB5

// XEVENT_XWIRETAP_TAP_CREATION_ERROR_8, 60854, Warning
#define XEVENT_XWIRETAP_TAP_CREATION_ERROR_8 0x8000EDB6

// XEVENT_XWIRETAP_TAP_CREATION_ERROR_9, 60855, Warning
#define XEVENT_XWIRETAP_TAP_CREATION_ERROR_9 0x8000EDB7

// XEVENT_XWIRETAP_CAP_FILE_CREATION_FAILED, 60856, Error
#define XEVENT_XWIRETAP_CAP_FILE_CREATION_FAILED 0xC000EDB8

// XEVENT_XWIRETAP_CAP_FILE_CREATION_FAILED_1, 60857, Error
#define XEVENT_XWIRETAP_CAP_FILE_CREATION_FAILED_1 0xC000EDB9

// XEVENT_TOOLS_CONFIG_58, 60858, Error
#define XEVENT_TOOLS_CONFIG_58 0xC000EDBA

// XEVENT_TOOLS_CONFIG_59, 60859, Error
#define XEVENT_TOOLS_CONFIG_59 0xC000EDBB

// XEVENT_TOOLS_CONFIG_60, 60860, Error
#define XEVENT_TOOLS_CONFIG_60 0xC000EDBC

// XEVENT_XWIRETAP_INVALID_SETTING, 60861, Error
#define XEVENT_XWIRETAP_INVALID_SETTING 0xC000EDBD

// XEVENT_XWIRETAP_TAP_CREATION_ERROR_10, 60862, Warning
#define XEVENT_XWIRETAP_TAP_CREATION_ERROR_10 0x8000EDBE

// XEVENT_XWIRETAP_TAP_CREATION_ERROR_11, 60863, Warning
#define XEVENT_XWIRETAP_TAP_CREATION_ERROR_11 0x8000EDBF

// XEVENT_TOOLS_CONFIG_64, 60864, Error
#define XEVENT_TOOLS_CONFIG_64 0xC000EDC0

// XEVENT_TOOLS_CONFIG_65, 60865, Error
#define XEVENT_TOOLS_CONFIG_65 0xC000EDC1

// XEVENT_TOOLS_CONFIG_66, 60866, Error
#define XEVENT_TOOLS_CONFIG_66 0xC000EDC2

// XEVENT_TOOLS_CONFIG_67, 60867, Error
#define XEVENT_TOOLS_CONFIG_67 0xC000EDC3

// XEVENT_TOOLS_CONFIG_68, 60868, Error
#define XEVENT_TOOLS_CONFIG_68 0xC000EDC4

// XEVENT_TOOLS_CONFIG_69, 60869, Error
#define XEVENT_TOOLS_CONFIG_69 0xC000EDC5

// XEVENT_TOOLS_CONFIG_70, 60870, Warning
#define XEVENT_TOOLS_CONFIG_70 0x8000EDC6

// XEVENT_XWIRETAP_INVALID_SETTING_1, 60871, Error
#define XEVENT_XWIRETAP_INVALID_SETTING_1 0xC000EDC7

// XEVENT_XWIRETAP_INVALID_SETTING_2, 60872, Error
#define XEVENT_XWIRETAP_INVALID_SETTING_2 0xC000EDC8

// XEVENT_TOOLS_CONFIG_73, 60873, Error
#define XEVENT_TOOLS_CONFIG_73 0xC000EDC9

// XEVENT_TOOLS_CONFIG_74, 60874, Error
#define XEVENT_TOOLS_CONFIG_74 0xC000EDCA

// XEVENT_TOOLS_CONFIG_75, 60875, Error
#define XEVENT_TOOLS_CONFIG_75 0xC000EDCB

// XEVENT_TOOLS_CONFIG_76, 60876, Error
#define XEVENT_TOOLS_CONFIG_76 0xC000EDCC

// XEVENT_TOOLS_CONFIG_77, 60877, Error
#define XEVENT_TOOLS_CONFIG_77 0xC000EDCD

// XEVENT_TOOLS_CONFIG_78, 60878, Error
#define XEVENT_TOOLS_CONFIG_78 0xC000EDCE

// XEVENT_TOOLS_CONFIG_79, 60879, Error
#define XEVENT_TOOLS_CONFIG_79 0xC000EDCF

// XEVENT_TOOLS_CONFIG_80, 60880, Warning
#define XEVENT_TOOLS_CONFIG_80 0x8000EDD0

// XEVENT_UDPADPT_INVALID_PORT_LIST_WARNING, 60881, Warning
#define XEVENT_UDPADPT_INVALID_PORT_LIST_WARNING 0x8000EDD1

// XEVENT_TOOLS_CONFIG_82, 60882, Error
#define XEVENT_TOOLS_CONFIG_82 0xC000EDD2

// XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 60883, Error
#define XEVENT_REGCLIENTAUTO_CONFIG_ERROR 0xC000EDD3

// XEVENT_TOOLS_HACK_0, 61000, Warning
#define XEVENT_TOOLS_HACK_0 0x8000EE48

// XEVENT_TOOLS_HACK_1, 61001, Warning
#define XEVENT_TOOLS_HACK_1 0x8000EE49

// XEVENT_TOOLS_HACK_2, 61002, Warning
#define XEVENT_TOOLS_HACK_2 0x8000EE4A

// XEVENT_TOOLS_HACK_3, 61003, Warning
#define XEVENT_TOOLS_HACK_3 0x8000EE4B

// XEVENT_TOOLS_HACK_4, 61004, Warning
#define XEVENT_TOOLS_HACK_4 0x8000EE4C

// XEVENT_TOOLS_HACK_5, 61005, Warning
#define XEVENT_TOOLS_HACK_5 0x8000EE4D

// XEVENT_TOOLS_HACK_6, 61006, Warning
#define XEVENT_TOOLS_HACK_6 0x8000EE4E

// XEVENT_TOOLS_HACK_7, 61007, Warning
#define XEVENT_TOOLS_HACK_7 0x8000EE4F

// XEVENT_TOOLS_HACK_8, 61008, Warning
#define XEVENT_TOOLS_HACK_8 0x8000EE50

// XEVENT_TOOLS_HACK_9, 61009, Warning
#define XEVENT_TOOLS_HACK_9 0x8000EE51

// XEVENT_TOOLS_HACK_10, 61010, Warning
#define XEVENT_TOOLS_HACK_10 0x8000EE52

// XEVENT_TOOLS_HACK_11, 61011, Warning
#define XEVENT_TOOLS_HACK_11 0x8000EE53

// XEVENT_TOOLS_HACK_12, 61012, Warning
#define XEVENT_TOOLS_HACK_12 0x8000EE54

// XEVENT_TOOLS_HACK_13, 61013, Warning
#define XEVENT_TOOLS_HACK_13 0x8000EE55

// XEVENT_TOOLS_HACK_14, 61014, Warning
#define XEVENT_TOOLS_HACK_14 0x8000EE56

// XEVENT_TOOLS_HACK_15, 61015, Warning
#define XEVENT_TOOLS_HACK_15 0x8000EE57

// XEVENT_ASKDC_DOS_EXISTING_CLIENT, 61016, Warning
#define XEVENT_ASKDC_DOS_EXISTING_CLIENT 0x8000EE58

// XEVENT_XKDC_DOS_REPLAY, 61017, Warning
#define XEVENT_XKDC_DOS_REPLAY 0x8000EE59

// XEVENT_XMACS_INACTIVE_XBOX_1, 61018, Warning
#define XEVENT_XMACS_INACTIVE_XBOX_1 0x8000EE5A

// XEVENT_XMACS_DOS_MAXIMUM_ALLOWANCE, 61019, Warning
#define XEVENT_XMACS_DOS_MAXIMUM_ALLOWANCE 0x8000EE5B

// XEVENT_TOOLS_INFO_0, 61050, Info
#define XEVENT_TOOLS_INFO_0 0x4000EE7A

// XEVENT_TOOLS_INFO_1, 61051, Info
#define XEVENT_TOOLS_INFO_1 0x4000EE7B

// XEVENT_TOOLS_INFO_2, 61052, Info
#define XEVENT_TOOLS_INFO_2 0x4000EE7C

// XEVENT_TOOLS_INFO_3, 61053, Info
#define XEVENT_TOOLS_INFO_3 0x4000EE7D

// XEVENT_TOOLS_INFO_4, 61054, Info
#define XEVENT_TOOLS_INFO_4 0x4000EE7E

// XEVENT_TOOLS_INFO_5, 61055, Info
#define XEVENT_TOOLS_INFO_5 0x4000EE7F

// XEVENT_TOOLS_INFO_6, 61056, Info
#define XEVENT_TOOLS_INFO_6 0x4000EE80

// XEVENT_TOOLS_INFO_7, 61057, Info
#define XEVENT_TOOLS_INFO_7 0x4000EE81

// XEVENT_TOOLS_INFO_8, 61058, Info
#define XEVENT_TOOLS_INFO_8 0x4000EE82

// XEVENT_TOOLS_INFO_9, 61059, Info
#define XEVENT_TOOLS_INFO_9 0x4000EE83

// XEVENT_GENEALOGY_INFO_EEPROM_VERIFY_COMPLETE, 61060, Info
#define XEVENT_GENEALOGY_INFO_EEPROM_VERIFY_COMPLETE 0x4000EE84

// XEVENT_GENEALOGY_INFO_APP_START, 61061, Info
#define XEVENT_GENEALOGY_INFO_APP_START 0x4000EE85

// XEVENT_GENEALOGY_INFO_UPDATE_COMPLETE, 61062, Info
#define XEVENT_GENEALOGY_INFO_UPDATE_COMPLETE 0x4000EE86

// XEVENT_GENEALOGY_SERVICE_STOPPED, 61063, Info
#define XEVENT_GENEALOGY_SERVICE_STOPPED 0x4000EE87

// XEVENT_GENEALOGY_SERVICE_STARTED, 61064, Info
#define XEVENT_GENEALOGY_SERVICE_STARTED 0x4000EE88

// XEVENT_GENEALOGY_INFO_FILES_IN_DROP_DIR, 61065, Info
#define XEVENT_GENEALOGY_INFO_FILES_IN_DROP_DIR 0x4000EE89

// XEVENT_GENEALOGY_SERVICE_STOPPED_1, 61066, Info
#define XEVENT_GENEALOGY_SERVICE_STOPPED_1 0x4000EE8A

// XEVENT_GENEALOGY_INFO_UPDATE_COMPLETE_1, 61067, Info
#define XEVENT_GENEALOGY_INFO_UPDATE_COMPLETE_1 0x4000EE8B

// XEVENT_GENEALOGY_INFO_UPDATE_COMPLETE_2, 61068, Info
#define XEVENT_GENEALOGY_INFO_UPDATE_COMPLETE_2 0x4000EE8C

// XEVENT_XMACS_PPALOADER_LOADING_INFO_2, 61069, Info
#define XEVENT_XMACS_PPALOADER_LOADING_INFO_2 0x4000EE8D

// XEVENT_XMACS_PUID_ATTAINED_NEW_BLOCK_1, 61070, Info
#define XEVENT_XMACS_PUID_ATTAINED_NEW_BLOCK_1 0x4000EE8E

// XEVENT_XMACS_NONUNIQUE_SERIALNUMBER_REQUEST_1, 61071, Info
#define XEVENT_XMACS_NONUNIQUE_SERIALNUMBER_REQUEST_1 0x4000EE8F

// XEVENT_XMACS_PPALOADER_LOADING_INFO_3, 61072, Info
#define XEVENT_XMACS_PPALOADER_LOADING_INFO_3 0x4000EE90

// XEVENT_MB_MACHINE_ACCOUNT_BANNED, 61073, Info
#define XEVENT_MB_MACHINE_ACCOUNT_BANNED 0x4000EE91

// XEVENT_MB_MACHINE_ACCOUNT_UNBANNED, 61074, Info
#define XEVENT_MB_MACHINE_ACCOUNT_UNBANNED 0x4000EE92

// XEVENT_TOOLSSRV_SHUTDOWN_COMPLETED, 61075, Info
#define XEVENT_TOOLSSRV_SHUTDOWN_COMPLETED 0x4000EE93

// XEVENT_TOOLSSRV_STARTUP_COMPLETED, 61076, Info
#define XEVENT_TOOLSSRV_STARTUP_COMPLETED 0x4000EE94

// XEVENT_TOOLS_INFO_27, 61077, Info
#define XEVENT_TOOLS_INFO_27 0x4000EE95

// XEVENT_TOOLS_INFO_28, 61078, Info
#define XEVENT_TOOLS_INFO_28 0x4000EE96

// XEVENT_TOOLS_INFO_29, 61079, Info
#define XEVENT_TOOLS_INFO_29 0x4000EE97

// XEVENT_TOOLS_INFO_30, 61080, Info
#define XEVENT_TOOLS_INFO_30 0x4000EE98

// XEVENT_TOOLS_INFO_31, 61081, Info
#define XEVENT_TOOLS_INFO_31 0x4000EE99

// XEVENT_TOOLS_INFO_32, 61082, Info
#define XEVENT_TOOLS_INFO_32 0x4000EE9A

// XEVENT_TOOLS_INFO_33, 61083, Info
#define XEVENT_TOOLS_INFO_33 0x4000EE9B

// XEVENT_TOOLS_INFO_34, 61084, Info
#define XEVENT_TOOLS_INFO_34 0x4000EE9C

// XEVENT_TOOLS_INFO_35, 61085, Info
#define XEVENT_TOOLS_INFO_35 0x4000EE9D

// XEVENT_TOOLS_INFO_36, 61086, Info
#define XEVENT_TOOLS_INFO_36 0x4000EE9E

// XEVENT_TOOLS_INFO_37, 61087, Info
#define XEVENT_TOOLS_INFO_37 0x4000EE9F

// XEVENT_TOOLS_INFO_38, 61088, Info
#define XEVENT_TOOLS_INFO_38 0x4000EEA0

// XEVENT_XWIRETAP_TAP_CLOSE, 61089, Info
#define XEVENT_XWIRETAP_TAP_CLOSE 0x4000EEA1

// XEVENT_XWIRETAP_INIT_SUCCESS, 61090, Info
#define XEVENT_XWIRETAP_INIT_SUCCESS 0x4000EEA2

// XEVENT_XWIRETAP_TERM_SUCCESS, 61091, Info
#define XEVENT_XWIRETAP_TERM_SUCCESS 0x4000EEA3

// XEVENT_TOOLS_INFO_42, 61092, Info
#define XEVENT_TOOLS_INFO_42 0x4000EEA4

// XEVENT_TOOLS_INFO_43, 61093, Info
#define XEVENT_TOOLS_INFO_43 0x4000EEA5

// XEVENT_TOOLS_INFO_44, 61094, Info
#define XEVENT_TOOLS_INFO_44 0x4000EEA6

// XEVENT_UDPADPT_INIT_SUCCESS, 61095, Info
#define XEVENT_UDPADPT_INIT_SUCCESS 0x4000EEA7

// XEVENT_UDPADPT_TERM_SUCCESS, 61096, Info
#define XEVENT_UDPADPT_TERM_SUCCESS 0x4000EEA8

// XEVENT_VOUCHERMGR_COMPLETION, 61097, Info
#define XEVENT_VOUCHERMGR_COMPLETION 0x4000EEA9

// XEVENT_GENERIC_TOOLS_SUCCESS, 61104, Info
#define XEVENT_GENERIC_TOOLS_SUCCESS 0x4000EEB0

// XEVENT_REPORTING_CUBE_INSTALL_FAILED, 62575, Warning
#define XEVENT_REPORTING_CUBE_INSTALL_FAILED 0x8000F46F

// XEVENT_REPORTING_WMIS_SQL_TICK_CODE_ERROR, 62576, Error
#define XEVENT_REPORTING_WMIS_SQL_TICK_CODE_ERROR 0xC000F470

// XEVENT_REPORTING_WMIS_RECORD_TICK_CODE_ERROR, 62577, Error
#define XEVENT_REPORTING_WMIS_RECORD_TICK_CODE_ERROR 0xC000F471

// XEVENT_REPORTING_WMIS_ENUMERATE_WEB_CODE_ERROR, 62578, Error
#define XEVENT_REPORTING_WMIS_ENUMERATE_WEB_CODE_ERROR 0xC000F472

// XEVENT_REPORTING_WMIS_DELETE_CODE_ERROR, 62579, Error
#define XEVENT_REPORTING_WMIS_DELETE_CODE_ERROR 0xC000F473

// XEVENT_REPORTING_WMIS_FILE_DOWNLOAD_ERROR, 62580, Error
#define XEVENT_REPORTING_WMIS_FILE_DOWNLOAD_ERROR 0xC000F474

// XEVENT_REPORTING_WMIS_DOWNLOAD_CODE_ERROR, 62581, Error
#define XEVENT_REPORTING_WMIS_DOWNLOAD_CODE_ERROR 0xC000F475

// XEVENT_REPORTING_WMIS_TICK_CODE_ERROR, 62582, Error
#define XEVENT_REPORTING_WMIS_TICK_CODE_ERROR 0xC000F476

// XEVENT_REPORTING_WMIS_TICK_WRITE_ERROR, 62583, Error
#define XEVENT_REPORTING_WMIS_TICK_WRITE_ERROR 0xC000F477

// XEVENT_REPORTING_OLAPAUTOBUILD_ERROR, 62584, Error
#define XEVENT_REPORTING_OLAPAUTOBUILD_ERROR 0xC000F478

// XEVENT_REPORTING_SSASQUERYCUBE_ERROR, 62585, Error
#define XEVENT_REPORTING_SSASQUERYCUBE_ERROR 0xC000F479

// XEVENT_REPORTING_WMIS_SQL_TICK_SQL_ERROR, 62600, Error
#define XEVENT_REPORTING_WMIS_SQL_TICK_SQL_ERROR 0xC000F488

// XEVENT_REPORTING_WMIS_RECORD_TICK_SQL_ERROR, 62601, Error
#define XEVENT_REPORTING_WMIS_RECORD_TICK_SQL_ERROR 0xC000F489

// XEVENT_REPORTING_WMIS_ENUMERATE_WEB_ERROR, 62602, Error
#define XEVENT_REPORTING_WMIS_ENUMERATE_WEB_ERROR 0xC000F48A

// XEVENT_REPORTING_WMIS_NO_FILES_FOUND, 62603, Error
#define XEVENT_REPORTING_WMIS_NO_FILES_FOUND 0xC000F48B

// XEVENT_REPORTING_WMIS_FILE_DOWNLOAD_WEB_ERROR, 62604, Error
#define XEVENT_REPORTING_WMIS_FILE_DOWNLOAD_WEB_ERROR 0xC000F48C

// XEVENT_REPORTING_WMIS_NO_NEW_FILE, 62625, Info
#define XEVENT_REPORTING_WMIS_NO_NEW_FILE 0x4000F4A1

// XEVENT_REPORTING_WMIS_SYNC_SUCCESS, 62626, Info
#define XEVENT_REPORTING_WMIS_SYNC_SUCCESS 0x4000F4A2

// XEVENT_REPORTING_OLAPAUTOBUILD_SUCCESS, 62627, Info
#define XEVENT_REPORTING_OLAPAUTOBUILD_SUCCESS 0x4000F4A3

// XEVENT_REPORTING_OLAPAUTOBUILD_INFO, 62628, Info
#define XEVENT_REPORTING_OLAPAUTOBUILD_INFO 0x4000F4A4

// XEVENT_REPORTING_SSASQUERYCUBE_INFO, 62629, Info
#define XEVENT_REPORTING_SSASQUERYCUBE_INFO 0x4000F4A5

// XEVENT_REPORTING_WMIS_DELETE_PATH_NOT_FOUND, 62650, Error
#define XEVENT_REPORTING_WMIS_DELETE_PATH_NOT_FOUND 0xC000F4BA

// XEVENT_REPORTING_WMIS_DELETE_NO_ACCESS, 62651, Error
#define XEVENT_REPORTING_WMIS_DELETE_NO_ACCESS 0xC000F4BB

// XEVENT_REPORTING_WMIS_DOWNLOAD_PATH_NOT_FOUND, 62652, Error
#define XEVENT_REPORTING_WMIS_DOWNLOAD_PATH_NOT_FOUND 0xC000F4BC

// XEVENT_REPORTING_WMIS_DOWNLOAD_PATH_NO_ACCESS, 62653, Error
#define XEVENT_REPORTING_WMIS_DOWNLOAD_PATH_NO_ACCESS 0xC000F4BD

// XEVENT_REPORTING_WMIS_TICK_PATH_NOT_FOUND, 62654, Error
#define XEVENT_REPORTING_WMIS_TICK_PATH_NOT_FOUND 0xC000F4BE

// XEVENT_REPORTING_WMIS_TICK_PATH_NO_ACCESS, 62655, Error
#define XEVENT_REPORTING_WMIS_TICK_PATH_NO_ACCESS 0xC000F4BF

// XEVENT_REPORTING_WMIS_CERTIFICATE_ERROR, 62656, Error
#define XEVENT_REPORTING_WMIS_CERTIFICATE_ERROR 0xC000F4C0

// XEVENT_PARTITION_TOOL_ERROR, 63225, Error
#define XEVENT_PARTITION_TOOL_ERROR 0xC000F6F9

// XEVENT_PARTITION_TOOL_LOG_NON_ERROR, 63226, Info
#define XEVENT_PARTITION_TOOL_LOG_NON_ERROR 0x4000F6FA

// XEVENT_PARTITION_TOOL_INFO, 63227, Info
#define XEVENT_PARTITION_TOOL_INFO 0x4000F6FB

// XEVENT_WCQUERY_WEBALIVE_CODE_1, 15001, Error
#define XEVENT_WCQUERY_WEBALIVE_CODE_1 0xC0003A99

// XEVENT_WCQUERY_WEBALIVE_CODE_2, 15002, Error
#define XEVENT_WCQUERY_WEBALIVE_CODE_2 0xC0003A9A

// XEVENT_WCQUERY_WEBALIVE_CODE_3, 15003, Error
#define XEVENT_WCQUERY_WEBALIVE_CODE_3 0xC0003A9B

// XEVENT_WEBCACHE_BULK_USER_ERROR, 15000, Error
#define XEVENT_WEBCACHE_BULK_USER_ERROR 0xC0003A98

// XEVENT_WEBCACHE_CREATE_BULK_USER_ERROR, 15001, Error
#define XEVENT_WEBCACHE_CREATE_BULK_USER_ERROR 0xC0003A99

// XEVENT_WEBCACHE_BULKUSER_GAMERTAG_ERROR, 15002, Error
#define XEVENT_WEBCACHE_BULKUSER_GAMERTAG_ERROR 0xC0003A9A

// XEVENT_WEBCACHE_REWARDS_ELIGIBILITY_ERROR, 15003, Error
#define XEVENT_WEBCACHE_REWARDS_ELIGIBILITY_ERROR 0xC0003A9B

// XEVENT_WEBCACHE_UNKNOWN_ERROR_3, 61150, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_3 0xC000EEDE

// XEVENT_WEBCACHE_UNKNOWN_ERROR_4, 61151, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_4 0xC000EEDF

// XEVENT_WEBCACHE_UNKNOWN_ERROR_5, 61152, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_5 0xC000EEE0

// XEVENT_WEBCACHE_UNKNOWN_ERROR_6, 61153, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_6 0xC000EEE1

// XEVENT_WEBCACHE_UNKNOWN_ERROR_7, 61154, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_7 0xC000EEE2

// XEVENT_WEBCACHE_UNKNOWN_ERROR_8, 61155, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_8 0xC000EEE3

// XEVENT_WEBCACHE_WEBSG_ERROR, 61156, Error
#define XEVENT_WEBCACHE_WEBSG_ERROR 0xC000EEE4

// XEVENT_WEBCACHE_MANAGEMENT_COMMAND_ERROR, 61157, Error
#define XEVENT_WEBCACHE_MANAGEMENT_COMMAND_ERROR 0xC000EEE5

// XEVENT_WEBCACHE_UNKNOWN_ERROR_9, 61158, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_9 0xC000EEE6

// XEVENT_WEBCACHE_UNKNOWN_ERROR_10, 61159, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_10 0xC000EEE7

// XEVENT_WEBCACHE_UNKNOWN_ERROR_11, 61160, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_11 0xC000EEE8

// XEVENT_WEBCACHE_UNKNOWN_ERROR_12, 61161, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_12 0xC000EEE9

// XEVENT_WEBCACHE_UNKNOWN_ERROR_13, 61162, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_13 0xC000EEEA

// XEVENT_WEBCACHE_UNKNOWN_ERROR_14, 61163, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_14 0xC000EEEB

// XEVENT_WEBCACHE_UNKNOWN_ERROR_15, 61164, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_15 0xC000EEEC

// XEVENT_WEBCACHE_UNKNOWN_ERROR_16, 61165, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_16 0xC000EEED

// XEVENT_WEBCACHE_UNKNOWN_ERROR_17, 61166, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_17 0xC000EEEE

// XEVENT_WEBCACHE_UNKNOWN_ERROR_18, 61167, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_18 0xC000EEEF

// XEVENT_WEBCACHE_UNKNOWN_ERROR_19, 61168, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_19 0xC000EEF0

// XEVENT_WEBCACHE_UNKNOWN_ERROR_20, 61169, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_20 0xC000EEF1

// XEVENT_WEBCACHE_INTERNAL_NONFATAL_ERROR, 61170, Error
#define XEVENT_WEBCACHE_INTERNAL_NONFATAL_ERROR 0xC000EEF2

// XEVENT_WEBCACHE_UNKNOWN_ERROR_21, 61171, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_21 0xC000EEF3

// XEVENT_WEBCACHE_UNKNOWN_ERROR_22, 61172, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_22 0xC000EEF4

// XEVENT_WEBCACHE_UNKNOWN_ERROR_23, 61173, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_23 0xC000EEF5

// XEVENT_WEBCACHE_UNKNOWN_ERROR_24, 61174, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_24 0xC000EEF6

// XEVENT_WEBCACHE_UNKNOWN_ERROR_25, 61175, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_25 0xC000EEF7

// XEVENT_WEBCACHE_UNKNOWN_ERROR_26, 61176, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_26 0xC000EEF8

// XEVENT_WEBCACHE_UNKNOWN_ERROR_27, 61177, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_27 0xC000EEF9

// XEVENT_WEBCACHE_UNKNOWN_ERROR_28, 61178, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_28 0xC000EEFA

// XEVENT_WEBCACHE_UNKNOWN_ERROR_29, 61179, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_29 0xC000EEFB

// XEVENT_WEBCACHE_UNKNOWN_ERROR_30, 61180, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_30 0xC000EEFC

// XEVENT_WEBCACHE_UNKNOWN_ERROR_31, 61181, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_31 0xC000EEFD

// XEVENT_WEBCACHE_UNKNOWN_ERROR_32, 61182, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_32 0xC000EEFE

// XEVENT_WEBCACHE_UNKNOWN_ERROR_33, 61183, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_33 0xC000EEFF

// XEVENT_WEBCACHE_UNKNOWN_ERROR_34, 61184, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_34 0xC000EF00

// XEVENT_WEBCACHE_UNKNOWN_ERROR_35, 61185, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_35 0xC000EF01

// XEVENT_WEBCACHE_UNKNOWN_ERROR_36, 61186, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_36 0xC000EF02

// XEVENT_WEBCACHE_UNKNOWN_ERROR_37, 61187, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_37 0xC000EF03

// XEVENT_WEBCACHE_CODE_38, 61188, Error
#define XEVENT_WEBCACHE_CODE_38 0xC000EF04

// XEVENT_WEBCACHE_CODE_39, 61189, Error
#define XEVENT_WEBCACHE_CODE_39 0xC000EF05

// XEVENT_WEBCACHE_CODE_40, 61190, Error
#define XEVENT_WEBCACHE_CODE_40 0xC000EF06

// XEVENT_WEBCACHE_UNKNOWN_ERROR_38, 61191, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_38 0xC000EF07

// XEVENT_WEBCACHE_UNKNOWN_ERROR_39, 61192, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_39 0xC000EF08

// XEVENT_WEBCACHE_UNKNOWN_ERROR_40, 61193, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_40 0xC000EF09

// XEVENT_WEBCACHE_CODE_44, 61194, Error
#define XEVENT_WEBCACHE_CODE_44 0xC000EF0A

// XEVENT_WEBCACHE_CODE_45, 61195, Error
#define XEVENT_WEBCACHE_CODE_45 0xC000EF0B

// XEVENT_WEBCACHE_CODE_46, 61196, Error
#define XEVENT_WEBCACHE_CODE_46 0xC000EF0C

// XEVENT_WEBCACHE_CODE_47, 61197, Error
#define XEVENT_WEBCACHE_CODE_47 0xC000EF0D

// XEVENT_WEBCACHE_INTERNAL_NONFATAL_ERROR_1, 61198, Error
#define XEVENT_WEBCACHE_INTERNAL_NONFATAL_ERROR_1 0xC000EF0E

// XEVENT_WEBCACHE_INTERNAL_NONFATAL_ERROR_2, 61199, Error
#define XEVENT_WEBCACHE_INTERNAL_NONFATAL_ERROR_2 0xC000EF0F

// XEVENT_WEBCACHE_UNKNOWN_ERROR_41, 61200, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_41 0xC000EF10

// XEVENT_WEBCACHE_UNKNOWN_ERROR_42, 61201, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_42 0xC000EF11

// XEVENT_WEBCACHE_UNKNOWN_ERROR_43, 61202, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_43 0xC000EF12

// XEVENT_WEBCACHE_UNKNOWN_ERROR_44, 61203, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_44 0xC000EF13

// XEVENT_WEBCACHE_UNKNOWN_ERROR_45, 61204, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_45 0xC000EF14

// XEVENT_WEBCACHE_UNKNOWN_ERROR_46, 61205, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_46 0xC000EF15

// XEVENT_WEBCACHE_UNKNOWN_ERROR_47, 61206, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_47 0xC000EF16

// XEVENT_WEBCACHE_UNKNOWN_ERROR_48, 61207, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_48 0xC000EF17

// XEVENT_WEBCACHE_UNKNOWN_ERROR_49, 61208, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_49 0xC000EF18

// XEVENT_WEBCACHE_UNKNOWN_ERROR_50, 61209, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_50 0xC000EF19

// XEVENT_WEBCACHE_UNKNOWN_ERROR_51, 61210, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_51 0xC000EF1A

// XEVENT_WEBCACHE_UNKNOWN_ERROR_52, 61211, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_52 0xC000EF1B

// XEVENT_WEBCACHE_UNKNOWN_ERROR_53, 61212, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_53 0xC000EF1C

// XEVENT_WEBCACHE_UNKNOWN_ERROR_54, 61213, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_54 0xC000EF1D

// XEVENT_WEBCACHE_UNKNOWN_ERROR_55, 61214, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_55 0xC000EF1E

// XEVENT_WEBCACHE_UNKNOWN_ERROR_56, 61215, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_56 0xC000EF1F

// XEVENT_WEBCACHE_UNKNOWN_ERROR_57, 61216, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_57 0xC000EF20

// XEVENT_WEBCACHE_UNKNOWN_ERROR_58, 61217, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_58 0xC000EF21

// XEVENT_WEBCACHE_UNKNOWN_ERROR_59, 61218, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_59 0xC000EF22

// XEVENT_WEBCACHE_UNKNOWN_ERROR_60, 61219, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_60 0xC000EF23

// XEVENT_WEBCACHE_CODE_70, 61220, Error
#define XEVENT_WEBCACHE_CODE_70 0xC000EF24

// XEVENT_WEBCACHE_CODE_71, 61221, Error
#define XEVENT_WEBCACHE_CODE_71 0xC000EF25

// XEVENT_WEBCACHE_CODE_72, 61222, Error
#define XEVENT_WEBCACHE_CODE_72 0xC000EF26

// XEVENT_WEBCACHE_CODE_73, 61223, Error
#define XEVENT_WEBCACHE_CODE_73 0xC000EF27

// XEVENT_WEBCACHE_CODE_74, 61224, Error
#define XEVENT_WEBCACHE_CODE_74 0xC000EF28

// XEVENT_WEBCACHE_CODE_75, 61225, Error
#define XEVENT_WEBCACHE_CODE_75 0xC000EF29

// XEVENT_WEBCACHE_CODE_76, 61226, Error
#define XEVENT_WEBCACHE_CODE_76 0xC000EF2A

// XEVENT_WEBCACHE_CODE_77, 61227, Error
#define XEVENT_WEBCACHE_CODE_77 0xC000EF2B

// XEVENT_WEBCACHE_CODE_78, 61228, Error
#define XEVENT_WEBCACHE_CODE_78 0xC000EF2C

// XEVENT_WEBCACHE_CODE_79, 61229, Error
#define XEVENT_WEBCACHE_CODE_79 0xC000EF2D

// XEVENT_WEBCACHE_CODE_80, 61230, Error
#define XEVENT_WEBCACHE_CODE_80 0xC000EF2E

// XEVENT_WEBCACHE_CODE_81, 61231, Error
#define XEVENT_WEBCACHE_CODE_81 0xC000EF2F

// XEVENT_WEBCACHE_CODE_82, 61232, Error
#define XEVENT_WEBCACHE_CODE_82 0xC000EF30

// XEVENT_WEBCACHE_CODE_83, 61233, Error
#define XEVENT_WEBCACHE_CODE_83 0xC000EF31

// XEVENT_WEBCACHE_CODE_84, 61234, Error
#define XEVENT_WEBCACHE_CODE_84 0xC000EF32

// XEVENT_WEBCACHE_CODE_85, 61235, Error
#define XEVENT_WEBCACHE_CODE_85 0xC000EF33

// XEVENT_WEBCACHE_UNKNOWN_ERROR_61, 61236, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_61 0xC000EF34

// XEVENT_WEBCACHE_UNKNOWN_ERROR_62, 61237, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_62 0xC000EF35

// XEVENT_WEBCACHE_UNKNOWN_ERROR_63, 61238, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_63 0xC000EF36

// XEVENT_WEBCACHE_UNKNOWN_ERROR_64, 61239, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_64 0xC000EF37

// XEVENT_WEBCACHE_UNKNOWN_ERROR_65, 61240, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_65 0xC000EF38

// XEVENT_WEBCACHE_UNKNOWN_ERROR_66, 61241, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_66 0xC000EF39

// XEVENT_WEBCACHE_UNKNOWN_ERROR_67, 61242, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_67 0xC000EF3A

// XEVENT_WEBCACHE_UNKNOWN_ERROR_68, 61243, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_68 0xC000EF3B

// XEVENT_WEBCACHE_UNKNOWN_ERROR_69, 61244, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_69 0xC000EF3C

// XEVENT_WEBCACHE_UNKNOWN_ERROR_70, 61245, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_70 0xC000EF3D

// XEVENT_WEBCACHE_UNKNOWN_ERROR_71, 61246, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_71 0xC000EF3E

// XEVENT_WEBCACHE_CODE_97, 61247, Error
#define XEVENT_WEBCACHE_CODE_97 0xC000EF3F

// XEVENT_WEBCACHE_CODE_98, 61248, Error
#define XEVENT_WEBCACHE_CODE_98 0xC000EF40

// XEVENT_WEBCACHE_CODE_99, 61249, Error
#define XEVENT_WEBCACHE_CODE_99 0xC000EF41

// XEVENT_WEBCACHE_INTERNAL_NONFATAL_ERROR_3, 61250, Error
#define XEVENT_WEBCACHE_INTERNAL_NONFATAL_ERROR_3 0xC000EF42

// XEVENT_WEBCACHE_CODE_101, 61251, Error
#define XEVENT_WEBCACHE_CODE_101 0xC000EF43

// XEVENT_WEBCACHE_CODE_102, 61252, Error
#define XEVENT_WEBCACHE_CODE_102 0xC000EF44

// XEVENT_WEBCACHE_UNKNOWN_ERROR_72, 61253, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_72 0xC000EF45

// XEVENT_WEBCACHE_UNKNOWN_ERROR_73, 61254, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_73 0xC000EF46

// XEVENT_WEBCACHE_UNKNOWN_ERROR_74, 61255, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_74 0xC000EF47

// XEVENT_WEBCACHE_UNKNOWN_ERROR_75, 61256, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_75 0xC000EF48

// XEVENT_WEBCACHE_UNKNOWN_ERROR_76, 61257, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_76 0xC000EF49

// XEVENT_WEBCACHE_UNKNOWN_ERROR_77, 61258, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_77 0xC000EF4A

// XEVENT_WEBCACHE_UNKNOWN_ERROR_78, 61259, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_78 0xC000EF4B

// XEVENT_WEBCACHE_UNKNOWN_ERROR_79, 61260, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_79 0xC000EF4C

// XEVENT_WEBCACHE_UNKNOWN_ERROR_80, 61261, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_80 0xC000EF4D

// XEVENT_WEBCACHE_UNKNOWN_ERROR_81, 61262, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_81 0xC000EF4E

// XEVENT_WEBCACHE_CODE_113, 61263, Error
#define XEVENT_WEBCACHE_CODE_113 0xC000EF4F

// XEVENT_WEBCACHE_CODE_114, 61264, Error
#define XEVENT_WEBCACHE_CODE_114 0xC000EF50

// XEVENT_WEBCACHE_CODE_115, 61265, Error
#define XEVENT_WEBCACHE_CODE_115 0xC000EF51

// XEVENT_WEBCACHE_CODE_116, 61266, Error
#define XEVENT_WEBCACHE_CODE_116 0xC000EF52

// XEVENT_WEBCACHE_CODE_117, 61267, Error
#define XEVENT_WEBCACHE_CODE_117 0xC000EF53

// XEVENT_WEBCACHE_CODE_118, 61268, Error
#define XEVENT_WEBCACHE_CODE_118 0xC000EF54

// XEVENT_WEBCACHE_UNKNOWN_ERROR_82, 61269, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_82 0xC000EF55

// XEVENT_WEBCACHE_CODE_120, 61270, Error
#define XEVENT_WEBCACHE_CODE_120 0xC000EF56

// XEVENT_WEBCACHE_UNKNOWN_ERROR_83, 61271, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_83 0xC000EF57

// XEVENT_WEBCACHE_CODE_122, 61272, Error
#define XEVENT_WEBCACHE_CODE_122 0xC000EF58

// XEVENT_WEBCACHE_CODE_123, 61273, Error
#define XEVENT_WEBCACHE_CODE_123 0xC000EF59

// XEVENT_WEBCACHE_UNKNOWN_ERROR_84, 61274, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_84 0xC000EF5A

// XEVENT_WEBCACHE_CODE_125, 61275, Error
#define XEVENT_WEBCACHE_CODE_125 0xC000EF5B

// XEVENT_WEBCACHE_CODE_126, 61276, Error
#define XEVENT_WEBCACHE_CODE_126 0xC000EF5C

// XEVENT_WEBCACHE_UNKNOWN_ERROR_85, 61277, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_85 0xC000EF5D

// XEVENT_WEBCACHE_UNKNOWN_ERROR_86, 61278, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_86 0xC000EF5E

// XEVENT_WEBCACHE_CODE_129, 61279, Error
#define XEVENT_WEBCACHE_CODE_129 0xC000EF5F

// XEVENT_WEBCACHE_CODE_130, 61280, Error
#define XEVENT_WEBCACHE_CODE_130 0xC000EF60

// XEVENT_WEBCACHE_CODE_131, 61281, Error
#define XEVENT_WEBCACHE_CODE_131 0xC000EF61

// XEVENT_WEBCACHE_CODE_132, 61282, Error
#define XEVENT_WEBCACHE_CODE_132 0xC000EF62

// XEVENT_WEBCACHE_UNKNOWN_ERROR_87, 61283, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_87 0xC000EF63

// XEVENT_WEBCACHE_UNKNOWN_ERROR_88, 61284, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_88 0xC000EF64

// XEVENT_WEBCACHE_UNKNOWN_ERROR_89, 61285, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_89 0xC000EF65

// XEVENT_WEBCACHE_UNKNOWN_ERROR_90, 61286, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_90 0xC000EF66

// XEVENT_WEBCACHE_UNKNOWN_ERROR_91, 61287, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_91 0xC000EF67

// XEVENT_WEBCACHE_UNKNOWN_ERROR_92, 61288, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_92 0xC000EF68

// XEVENT_WEBCACHE_UNKNOWN_ERROR_93, 61289, Error
#define XEVENT_WEBCACHE_UNKNOWN_ERROR_93 0xC000EF69

// XEVENT_WEBCACHE_INTERNAL_NONFATAL_ERROR_4, 61290, Error
#define XEVENT_WEBCACHE_INTERNAL_NONFATAL_ERROR_4 0xC000EF6A

// XEVENT_WEBCACHE_CODE_133, 61291, Error
#define XEVENT_WEBCACHE_CODE_133 0xC000EF6B

// XEVENT_WEBCACHE_CODE_134, 61292, Error
#define XEVENT_WEBCACHE_CODE_134 0xC000EF6C

// XEVENT_WEBCACHE_CODE_135, 61293, Info
#define XEVENT_WEBCACHE_CODE_135 0x4000EF6D

// XEVENT_WEBCACHE_CODE_136, 61294, Error
#define XEVENT_WEBCACHE_CODE_136 0xC000EF6E

// XEVENT_WEBCACHE_CODE_137, 61295, Error
#define XEVENT_WEBCACHE_CODE_137 0xC000EF6F

// XEVENT_WEBCACHE_CODE_138, 61296, Error
#define XEVENT_WEBCACHE_CODE_138 0xC000EF70

// XEVENT_WEBCACHE_CODE_139, 61297, Error
#define XEVENT_WEBCACHE_CODE_139 0xC000EF71

// XEVENT_WEBCACHE_CODE_140, 61298, Error
#define XEVENT_WEBCACHE_CODE_140 0xC000EF72

// XEVENT_WEBCACHE_CODE_141, 61299, Error
#define XEVENT_WEBCACHE_CODE_141 0xC000EF73

// XEVENT_WEBCACHE_CODE_142, 61300, Error
#define XEVENT_WEBCACHE_CODE_142 0xC000EF74

// XEVENT_WEBCACHE_CODE_143, 61301, Error
#define XEVENT_WEBCACHE_CODE_143 0xC000EF75

// XEVENT_WEBCACHE_CODE_144, 61302, Error
#define XEVENT_WEBCACHE_CODE_144 0xC000EF76

// XEVENT_WEBCACHE_CODE_145, 61303, Error
#define XEVENT_WEBCACHE_CODE_145 0xC000EF77

// XEVENT_WEBCACHE_CODE_146, 61304, Error
#define XEVENT_WEBCACHE_CODE_146 0xC000EF78

// XEVENT_WEBCACHE_CODE_147, 61305, Error
#define XEVENT_WEBCACHE_CODE_147 0xC000EF79

// XEVENT_WEBCACHE_CODE_159, 61309, Error
#define XEVENT_WEBCACHE_CODE_159 0xC000EF7D

// XEVENT_WEBCACHE_CODE_48, 61310, Error
#define XEVENT_WEBCACHE_CODE_48 0xC000EF7E

// XEVENT_WEBCACHE_CODE_49, 61311, Error
#define XEVENT_WEBCACHE_CODE_49 0xC000EF7F

// XEVENT_WEBCACHE_CODE_50, 61312, Error
#define XEVENT_WEBCACHE_CODE_50 0xC000EF80

// XEVENT_WEBCACHE_CODE_51, 61313, Error
#define XEVENT_WEBCACHE_CODE_51 0xC000EF81

// XEVENT_WEBCACHE_CODE_52, 61314, Error
#define XEVENT_WEBCACHE_CODE_52 0xC000EF82

// XEVENT_WEBCACHE_CODE_53, 61315, Error
#define XEVENT_WEBCACHE_CODE_53 0xC000EF83

// XEVENT_WEBCACHE_CODE_54, 61316, Error
#define XEVENT_WEBCACHE_CODE_54 0xC000EF84

// XEVENT_WEBCACHE_CODE_55, 61317, Error
#define XEVENT_WEBCACHE_CODE_55 0xC000EF85

// XEVENT_WEBCACHE_CODE_56, 61318, Error
#define XEVENT_WEBCACHE_CODE_56 0xC000EF86

// XEVENT_WEBCACHE_CODE_57, 61319, Error
#define XEVENT_WEBCACHE_CODE_57 0xC000EF87

// XEVENT_WEBCACHE_CODE_58, 61320, Error
#define XEVENT_WEBCACHE_CODE_58 0xC000EF88

// XEVENT_WEBCACHE_CODE_59, 61321, Error
#define XEVENT_WEBCACHE_CODE_59 0xC000EF89

// XEVENT_WEBCACHE_CODE_60, 61322, Error
#define XEVENT_WEBCACHE_CODE_60 0xC000EF8A

// XEVENT_WEBCACHE_CODE_61, 61323, Error
#define XEVENT_WEBCACHE_CODE_61 0xC000EF8B

// XEVENT_WEBCACHE_CODE_62, 61324, Error
#define XEVENT_WEBCACHE_CODE_62 0xC000EF8C

// XEVENT_WEBCACHE_CODE_63, 61325, Error
#define XEVENT_WEBCACHE_CODE_63 0xC000EF8D

// XEVENT_WEBCACHE_CODE_64, 61326, Error
#define XEVENT_WEBCACHE_CODE_64 0xC000EF8E

// XEVENT_WEBCACHE_CODE_65, 61327, Error
#define XEVENT_WEBCACHE_CODE_65 0xC000EF8F

// XEVENT_WEBCACHE_WHOLESALE_PARTNER_ERROR, 61328, Error
#define XEVENT_WEBCACHE_WHOLESALE_PARTNER_ERROR 0xC000EF90

// XEVENT_WEBCACHE_WHOLESALE_ERROR, 61329, Error
#define XEVENT_WEBCACHE_WHOLESALE_ERROR 0xC000EF91

// XEVENT_WEBCACHE_WHOLESALE_PASSPORT_ERROR, 61330, Error
#define XEVENT_WEBCACHE_WHOLESALE_PASSPORT_ERROR 0xC000EF92

// XEVENT_WEBCACHE_WHOLESALE_GAMERTAG_ERROR, 61331, Error
#define XEVENT_WEBCACHE_WHOLESALE_GAMERTAG_ERROR 0xC000EF93

// XEVENT_WEBCACHE_WHOLESALE_ACCOUNT_ERROR, 61332, Error
#define XEVENT_WEBCACHE_WHOLESALE_ACCOUNT_ERROR 0xC000EF94

// XEVENT_WEBCACHE_COMM_0, 61550, Error
#define XEVENT_WEBCACHE_COMM_0 0xC000F06E

// XEVENT_WEBCACHE_COMM_1, 61551, Error
#define XEVENT_WEBCACHE_COMM_1 0xC000F06F

// XEVENT_WEBCACHE_COMM_2, 61552, Error
#define XEVENT_WEBCACHE_COMM_2 0xC000F070

// XEVENT_WEBCACHE_COMM_3, 61553, Error
#define XEVENT_WEBCACHE_COMM_3 0xC000F071

// XEVENT_WEBCACHE_FRONT_DOOR_ERROR, 61554, Error
#define XEVENT_WEBCACHE_FRONT_DOOR_ERROR 0xC000F072

// XEVENT_WEBCACHE_FRONT_DOOR_ERROR_1, 61555, Error
#define XEVENT_WEBCACHE_FRONT_DOOR_ERROR_1 0xC000F073

// XEVENT_WEBCACHE_FRONT_DOOR_ERROR_2, 61556, Error
#define XEVENT_WEBCACHE_FRONT_DOOR_ERROR_2 0xC000F074

// XEVENT_WEBCACHE_FRONT_DOOR_ERROR_3, 61557, Error
#define XEVENT_WEBCACHE_FRONT_DOOR_ERROR_3 0xC000F075

// XEVENT_WEBCACHE_FRONT_DOOR_INTERNAL_ERROR, 61558, Error
#define XEVENT_WEBCACHE_FRONT_DOOR_INTERNAL_ERROR 0xC000F076

// XEVENT_WEBCACHE_FRONT_DOOR_INTERNAL_ERROR_1, 61559, Error
#define XEVENT_WEBCACHE_FRONT_DOOR_INTERNAL_ERROR_1 0xC000F077

// XEVENT_WEBCACHE_FRONT_DOOR_INTERNAL_ERROR_2, 61560, Error
#define XEVENT_WEBCACHE_FRONT_DOOR_INTERNAL_ERROR_2 0xC000F078

// XEVENT_WEBCACHE_FRONT_DOOR_INTERNAL_ERROR_3, 61561, Error
#define XEVENT_WEBCACHE_FRONT_DOOR_INTERNAL_ERROR_3 0xC000F079

// XEVENT_WEBCACHE_COMM_12, 61562, Error
#define XEVENT_WEBCACHE_COMM_12 0xC000F07A

// XEVENT_WEBCACHE_COMM_13, 61563, Error
#define XEVENT_WEBCACHE_COMM_13 0xC000F07B

// XEVENT_WEBCACHE_COMM_14, 61564, Error
#define XEVENT_WEBCACHE_COMM_14 0xC000F07C

// XEVENT_WEBCACHE_COMM_15, 61565, Error
#define XEVENT_WEBCACHE_COMM_15 0xC000F07D

// XEVENT_WEBCACHE_COMM_16, 61566, Error
#define XEVENT_WEBCACHE_COMM_16 0xC000F07E

// XEVENT_WEBCACHE_COMM_17, 61567, Error
#define XEVENT_WEBCACHE_COMM_17 0xC000F07F

// XEVENT_WEBCACHE_UNLINK_GAMERTAG_ERROR, 61568, Error
#define XEVENT_WEBCACHE_UNLINK_GAMERTAG_ERROR 0xC000F080

// XEVENT_WEBCACHE_GENERIC_INTERNAL_ERROR_WHILE_DELETE_XUID, 61569, Error
#define XEVENT_WEBCACHE_GENERIC_INTERNAL_ERROR_WHILE_DELETE_XUID 0xC000F081

// XEVENT_WEBCACHE_GENERIC_INTERNAL_ERROR_WHILE_DELETE_XUID_FOR_ALL_LB, 61570, Error
#define XEVENT_WEBCACHE_GENERIC_INTERNAL_ERROR_WHILE_DELETE_XUID_FOR_ALL_LB 0xC000F082

// XEVENT_WEBCACHE_CONFIG_0, 61600, Error
#define XEVENT_WEBCACHE_CONFIG_0 0xC000F0A0

// XEVENT_WEBCACHE_CONFIG_1, 61601, Error
#define XEVENT_WEBCACHE_CONFIG_1 0xC000F0A1

// XEVENT_WEBCACHE_CONFIG_2, 61602, Error
#define XEVENT_WEBCACHE_CONFIG_2 0xC000F0A2

// XEVENT_WEBCACHE_CONFIG_3, 61603, Error
#define XEVENT_WEBCACHE_CONFIG_3 0xC000F0A3

// XEVENT_WEBCACHE_PROFILE_HACK_1, 61604, Error
#define XEVENT_WEBCACHE_PROFILE_HACK_1 0xC000F0A4

// XEVENT_WEBCACHE_PROFILE_BUG_1, 61605, Error
#define XEVENT_WEBCACHE_PROFILE_BUG_1 0xC000F0A5

// XEVENT_WEBCACHE_PROFILE_BUG_2, 61606, Error
#define XEVENT_WEBCACHE_PROFILE_BUG_2 0xC000F0A6

// XEVENT_WEBCACHE_PROFILE_BUG_3, 61607, Error
#define XEVENT_WEBCACHE_PROFILE_BUG_3 0xC000F0A7

// XEVENT_WEBCACHE_PROFILE_BUG_4, 61608, Error
#define XEVENT_WEBCACHE_PROFILE_BUG_4 0xC000F0A8

// XEVENT_WCDEBUGTEST_INITIALIZATION_1, 61609, Error
#define XEVENT_WCDEBUGTEST_INITIALIZATION_1 0xC000F0A9

// XEVENT_WCDEBUGTEST_HACK_2, 61611, Error
#define XEVENT_WCDEBUGTEST_HACK_2 0xC000F0AB

// XEVENT_WCDEBUGTEST_UNEXPECTED_ERROR_1, 61612, Error
#define XEVENT_WCDEBUGTEST_UNEXPECTED_ERROR_1 0xC000F0AC

// XEVENT_WEBCACHE_HACK_0, 61625, Warning
#define XEVENT_WEBCACHE_HACK_0 0x8000F0B9

// XEVENT_LIVEPROXY_INVALID_MSGFORMAT, 61626, Warning
#define XEVENT_LIVEPROXY_INVALID_MSGFORMAT 0x8000F0BA

// XEVENT_LIVEPROXY_INVALID_MSGFORMAT_1, 61627, Warning
#define XEVENT_LIVEPROXY_INVALID_MSGFORMAT_1 0x8000F0BB

// XEVENT_LIVEPROXY_INVALID_MSGFORMAT_2, 61628, Warning
#define XEVENT_LIVEPROXY_INVALID_MSGFORMAT_2 0x8000F0BC

// XEVENT_WEBCACHE_HACK_4, 61629, Warning
#define XEVENT_WEBCACHE_HACK_4 0x8000F0BD

// XEVENT_WEBCACHE_HACK_5, 61630, Warning
#define XEVENT_WEBCACHE_HACK_5 0x8000F0BE

// XEVENT_WEBCACHE_HACK_6, 61631, Warning
#define XEVENT_WEBCACHE_HACK_6 0x8000F0BF

// XEVENT_WEBCACHE_HACK_7, 61632, Warning
#define XEVENT_WEBCACHE_HACK_7 0x8000F0C0

// XEVENT_WEBCACHE_HACK_8, 61633, Warning
#define XEVENT_WEBCACHE_HACK_8 0x8000F0C1

// XEVENT_WEBCACHE_HACK_9, 61634, Warning
#define XEVENT_WEBCACHE_HACK_9 0x8000F0C2

// XEVENT_WEBCACHE_HACK_10, 61635, Warning
#define XEVENT_WEBCACHE_HACK_10 0x8000F0C3

// XEVENT_WEBCACHE_HACK_11, 61636, Warning
#define XEVENT_WEBCACHE_HACK_11 0x8000F0C4

// XEVENT_WEBCACHE_HACK_12, 61637, Warning
#define XEVENT_WEBCACHE_HACK_12 0x8000F0C5

// XEVENT_WEBCACHE_HACK_13, 61638, Warning
#define XEVENT_WEBCACHE_HACK_13 0x8000F0C6

// XEVENT_WEBCACHE_HACK_14, 61639, Warning
#define XEVENT_WEBCACHE_HACK_14 0x8000F0C7

// XEVENT_WEBCACHE_HACK_15, 61640, Warning
#define XEVENT_WEBCACHE_HACK_15 0x8000F0C8

// XEVENT_WEBCACHE_HACK_16, 61641, Warning
#define XEVENT_WEBCACHE_HACK_16 0x8000F0C9

// XEVENT_WEBCACHE_HACK_17, 61642, Warning
#define XEVENT_WEBCACHE_HACK_17 0x8000F0CA

// XEVENT_WEBCACHE_HACK_18, 61643, Warning
#define XEVENT_WEBCACHE_HACK_18 0x8000F0CB

// XEVENT_WEBCACHE_HACK_19, 61644, Warning
#define XEVENT_WEBCACHE_HACK_19 0x8000F0CC

// XEVENT_WEBCACHE_HACK_20, 61645, Warning
#define XEVENT_WEBCACHE_HACK_20 0x8000F0CD

// XEVENT_LIVEPROXY_INVALID_CHARACTER_SUBMISSION, 61646, Warning
#define XEVENT_LIVEPROXY_INVALID_CHARACTER_SUBMISSION 0x8000F0CE

// XEVENT_WEBCACHE_HACK_22, 61647, Warning
#define XEVENT_WEBCACHE_HACK_22 0x8000F0CF

// XEVENT_WCDEBUGTEST_HACK_1, 61648, Error
#define XEVENT_WCDEBUGTEST_HACK_1 0xC000F0D0

// XEVENT_WEBCACHE_INFO_0, 61675, Info
#define XEVENT_WEBCACHE_INFO_0 0x4000F0EB

// XEVENT_WEBCACHE_INFO_1, 61676, Info
#define XEVENT_WEBCACHE_INFO_1 0x4000F0EC

// XEVENT_WEBCACHE_INFO_2, 61677, Info
#define XEVENT_WEBCACHE_INFO_2 0x4000F0ED

// XEVENT_WEBCACHE_BAD_REQUEST_FROM_PARTNER, 61700, Error
#define XEVENT_WEBCACHE_BAD_REQUEST_FROM_PARTNER 0xC000F104

// XEVENT_WEBCACHE_PARTNER_NOT_FOUND_ERROR, 61701, Error
#define XEVENT_WEBCACHE_PARTNER_NOT_FOUND_ERROR 0xC000F105

// XEVENT_WEBCACHE_PARTNER_NOT_FOUND_ERROR_1, 61702, Error
#define XEVENT_WEBCACHE_PARTNER_NOT_FOUND_ERROR_1 0xC000F106

// XEVENT_WEBCACHE_API_NOT_ALLOWED_ERROR, 61703, Error
#define XEVENT_WEBCACHE_API_NOT_ALLOWED_ERROR 0xC000F107

// XEVENT_WEBCACHE_API_NOT_ALLOWED_ERROR_1, 61704, Error
#define XEVENT_WEBCACHE_API_NOT_ALLOWED_ERROR_1 0xC000F108

// XEVENT_WEBCACHE_TITLE_NOT_ALLOWED_ERROR, 61705, Error
#define XEVENT_WEBCACHE_TITLE_NOT_ALLOWED_ERROR 0xC000F109

// XEVENT_WEBCACHE_TITLE_NOT_ALLOWED_ERROR_1, 61706, Error
#define XEVENT_WEBCACHE_TITLE_NOT_ALLOWED_ERROR_1 0xC000F10A

// XEVENT_WEBCACHE_INVALID_IP_ERROR, 61707, Error
#define XEVENT_WEBCACHE_INVALID_IP_ERROR 0xC000F10B

// XEVENT_WEBCACHE_INVALID_IP_ERROR_1, 61708, Error
#define XEVENT_WEBCACHE_INVALID_IP_ERROR_1 0xC000F10C

// XEVENT_WEBCACHE_TOO_MANY_SIGNATURES, 61709, Error
#define XEVENT_WEBCACHE_TOO_MANY_SIGNATURES 0xC000F10D

// XEVENT_WEBCACHE_INVALID_DIGEST_SIZE, 61710, Error
#define XEVENT_WEBCACHE_INVALID_DIGEST_SIZE 0xC000F10E

// XEVENT_WEBCACHE_TOO_MANY_SIGNATURES_1, 61711, Error
#define XEVENT_WEBCACHE_TOO_MANY_SIGNATURES_1 0xC000F10F

// XEVENT_WEBCACHE_BAD_REQUEST_FROM_PARTNER_1, 61712, Error
#define XEVENT_WEBCACHE_BAD_REQUEST_FROM_PARTNER_1 0xC000F110

// XEVENT_WEBCACHE_PARTNER_NOT_FOUND_ERROR_2, 61713, Error
#define XEVENT_WEBCACHE_PARTNER_NOT_FOUND_ERROR_2 0xC000F111

// XEVENT_WEBCACHE_PARTNER_14, 61714, Error
#define XEVENT_WEBCACHE_PARTNER_14 0xC000F112

// XEVENT_WEBCACHE_PARTNER_15, 61715, Error
#define XEVENT_WEBCACHE_PARTNER_15 0xC000F113

// XEVENT_WEBCACHE_PARTNER_16, 61716, Error
#define XEVENT_WEBCACHE_PARTNER_16 0xC000F114

// XEVENT_WEBCACHE_PARTNER_17, 61717, Error
#define XEVENT_WEBCACHE_PARTNER_17 0xC000F115

// XEVENT_WEBCACHE_PARTNER_18, 61718, Error
#define XEVENT_WEBCACHE_PARTNER_18 0xC000F116

// XEVENT_WEBCACHE_PARTNER_19, 61719, Error
#define XEVENT_WEBCACHE_PARTNER_19 0xC000F117

// XEVENT_WEBCACHE_PARTNER_20, 61720, Error
#define XEVENT_WEBCACHE_PARTNER_20 0xC000F118

// XEVENT_WEBCACHE_PARTNER_21, 61721, Error
#define XEVENT_WEBCACHE_PARTNER_21 0xC000F119

// XEVENT_WEBCACHE_PARTNER_22, 61722, Error
#define XEVENT_WEBCACHE_PARTNER_22 0xC000F11A

// XEVENT_WEBCACHE_PARTNER_23, 61723, Error
#define XEVENT_WEBCACHE_PARTNER_23 0xC000F11B

// XEVENT_WEBCACHE_INTERNAL_ERROR, 61724, Error
#define XEVENT_WEBCACHE_INTERNAL_ERROR 0xC000F11C

// XEVENT_WEBCACHE_LICENSE_TRANSFER_COMMIT_FAILED, 61726, Error
#define XEVENT_WEBCACHE_LICENSE_TRANSFER_COMMIT_FAILED 0xC000F11E

// XEVENT_DEPRECATED_WEBCACHE_LICENSE_TRANSFER_CONSOLE_REGISTRATION_FAILED, 61727, Error
#define XEVENT_DEPRECATED_WEBCACHE_LICENSE_TRANSFER_CONSOLE_REGISTRATION_FAILED 0xC000F11F

// XEVENT_WEBSG_CAPTUREUPDATE_FAILED, 10000, Warning
#define XEVENT_WEBSG_CAPTUREUPDATE_FAILED 0x80002710

// XEVENT_WEBSG_WINHTTP_ERROR, 61750, Error
#define XEVENT_WEBSG_WINHTTP_ERROR 0xC000F136

// XEVENT_WEBSG_CODE_1, 61751, Error
#define XEVENT_WEBSG_CODE_1 0xC000F137

// XEVENT_WEBSG_WINHTTP_ERROR_1, 61752, Error
#define XEVENT_WEBSG_WINHTTP_ERROR_1 0xC000F138

// XEVENT_WEBSG_SEND_ERROR_PAGE, 61775, Error
#define XEVENT_WEBSG_SEND_ERROR_PAGE 0xC000F14F

// XEVENT_WEBSG_COMM_1, 61776, Error
#define XEVENT_WEBSG_COMM_1 0xC000F150

// XEVENT_WEBSG_COMM_2, 61777, Error
#define XEVENT_WEBSG_COMM_2 0xC000F151

// XEVENT_WEBSG_COMM_3, 61778, Error
#define XEVENT_WEBSG_COMM_3 0xC000F152

// XEVENT_WEBSG_COMM_4, 61779, Error
#define XEVENT_WEBSG_COMM_4 0xC000F153

// XEVENT_WEBSG_COMM_5, 61780, Error
#define XEVENT_WEBSG_COMM_5 0xC000F154

// XEVENT_WEBSG_FAIL_TO_GET_WEBCACHE_RESPONSE_DATA, 61781, Error
#define XEVENT_WEBSG_FAIL_TO_GET_WEBCACHE_RESPONSE_DATA 0xC000F155

// XEVENT_WEBSG_CONFIG_ERROR, 61800, Error
#define XEVENT_WEBSG_CONFIG_ERROR 0xC000F168

// XEVENT_WEBSG_CONFIG_ERROR_1, 61801, Error
#define XEVENT_WEBSG_CONFIG_ERROR_1 0xC000F169

// XEVENT_WEBSG_CONFIG_ERROR_2, 61802, Error
#define XEVENT_WEBSG_CONFIG_ERROR_2 0xC000F16A

// XEVENT_WEBSG_INVALID_CRYPTO_HANDLE, 61803, Error
#define XEVENT_WEBSG_INVALID_CRYPTO_HANDLE 0xC000F16B

// XEVENT_WEBSG_CONFIG_ERROR_3, 61804, Error
#define XEVENT_WEBSG_CONFIG_ERROR_3 0xC000F16C

// XEVENT_WEBSG_CONFIG_5, 61805, Error
#define XEVENT_WEBSG_CONFIG_5 0xC000F16D

// XEVENT_WEBSG_CONFIG_6, 61806, Error
#define XEVENT_WEBSG_CONFIG_6 0xC000F16E

// XEVENT_WEBSG_CONFIG_7, 61807, Error
#define XEVENT_WEBSG_CONFIG_7 0xC000F16F

// XEVENT_WEBSG_CONFIG_8, 61808, Error
#define XEVENT_WEBSG_CONFIG_8 0xC000F170

// XEVENT_DEPRECATED_WEBSG_CONFIG_9, 61809, Error
#define XEVENT_DEPRECATED_WEBSG_CONFIG_9 0xC000F171

// XEVENT_DEPRECATED_WEBSG_CONFIG_10, 61810, Error
#define XEVENT_DEPRECATED_WEBSG_CONFIG_10 0xC000F172

// XEVENT_WEBSG_CONFIG_11, 61811, Error
#define XEVENT_WEBSG_CONFIG_11 0xC000F173

// XEVENT_WEBSG_CONFIG_12, 61812, Error
#define XEVENT_WEBSG_CONFIG_12 0xC000F174

// XEVENT_WEBSG_CONFIG_13, 61813, Error
#define XEVENT_WEBSG_CONFIG_13 0xC000F175

// XEVENT_WEBSG_CONFIG_14, 61814, Error
#define XEVENT_WEBSG_CONFIG_14 0xC000F176

// XEVENT_WEBSG_CONFIG_15, 61815, Error
#define XEVENT_WEBSG_CONFIG_15 0xC000F177

// XEVENT_WEBSG_CONFIG_16, 61816, Error
#define XEVENT_WEBSG_CONFIG_16 0xC000F178

// XEVENT_WEBSG_CONFIG_17, 61817, Error
#define XEVENT_WEBSG_CONFIG_17 0xC000F179

// XEVENT_WEBSG_CONFIG_18, 61818, Error
#define XEVENT_WEBSG_CONFIG_18 0xC000F17A

// XEVENT_WEBSG_CONFIG_19, 61819, Error
#define XEVENT_WEBSG_CONFIG_19 0xC000F17B

// XEVENT_WEBSG_NO_WEBCACHE, 61820, Error
#define XEVENT_WEBSG_NO_WEBCACHE 0xC000F17C

// XEVENT_WEBSG_UNSUPPORTED_METHOD, 61850, Warning
#define XEVENT_WEBSG_UNSUPPORTED_METHOD 0x8000F19A

// XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER, 61851, Warning
#define XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER 0x8000F19B

// XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_1, 61852, Warning
#define XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_1 0x8000F19C

// XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_2, 61853, Warning
#define XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_2 0x8000F19D

// XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_3, 61854, Warning
#define XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_3 0x8000F19E

// XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_4, 61855, Warning
#define XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_4 0x8000F19F

// XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_5, 61856, Warning
#define XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_5 0x8000F1A0

// XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_6, 61857, Warning
#define XEVENT_WEBSG_WEBCLIENT_INVALID_HEADER_6 0x8000F1A1

// XEVENT_XBANC_CONFIG_HEALTHINTEROP_CREATE, 20000, Error
#define XEVENT_XBANC_CONFIG_HEALTHINTEROP_CREATE 0xC0004E20

// XEVENT_XBANC_CONFIG_HEALTHINTEROP_INIT, 20001, Error
#define XEVENT_XBANC_CONFIG_HEALTHINTEROP_INIT 0xC0004E21

// XEVENT_XBANC_CODE_0, 63500, Error
#define XEVENT_XBANC_CODE_0 0xC000F80C

// XEVENT_XBANC_CODE_1, 63501, Error
#define XEVENT_XBANC_CODE_1 0xC000F80D

// XEVENT_XBANC_CODE_2, 63502, Error
#define XEVENT_XBANC_CODE_2 0xC000F80E

// XEVENT_XBANC_CODE_3, 63503, Error
#define XEVENT_XBANC_CODE_3 0xC000F80F

// XEVENT_XBANC_CODE_4, 63504, Error
#define XEVENT_XBANC_CODE_4 0xC000F810

// XEVENT_XBANC_CODE_5, 63505, Error
#define XEVENT_XBANC_CODE_5 0xC000F811

// XEVENT_XBANC_CODE_6, 63506, Error
#define XEVENT_XBANC_CODE_6 0xC000F812

// XEVENT_XBANC_CODE_7, 63507, Error
#define XEVENT_XBANC_CODE_7 0xC000F813

// XEVENT_XBANC_CODE_8, 63508, Error
#define XEVENT_XBANC_CODE_8 0xC000F814

// XEVENT_XBANC_CODE_9, 63509, Error
#define XEVENT_XBANC_CODE_9 0xC000F815

// XEVENT_XBANC_CODE_10, 63510, Error
#define XEVENT_XBANC_CODE_10 0xC000F816

// XEVENT_XBANC_CODE_11, 63511, Error
#define XEVENT_XBANC_CODE_11 0xC000F817

// XEVENT_XBANC_CODE_12, 63512, Error
#define XEVENT_XBANC_CODE_12 0xC000F818

// XEVENT_XBANC_CODE_13, 63513, Error
#define XEVENT_XBANC_CODE_13 0xC000F819

// XEVENT_XBANC_CODE_14, 63514, Error
#define XEVENT_XBANC_CODE_14 0xC000F81A

// XEVENT_XBANC_CODE_15, 63515, Error
#define XEVENT_XBANC_CODE_15 0xC000F81B

// XEVENT_XBANC_CODE_16, 63516, Error
#define XEVENT_XBANC_CODE_16 0xC000F81C

// XEVENT_XBANC_CODE_17, 63517, Error
#define XEVENT_XBANC_CODE_17 0xC000F81D

// XEVENT_XBANC_CODE_18, 63518, Error
#define XEVENT_XBANC_CODE_18 0xC000F81E

// XEVENT_XBANC_CODE_19, 63519, Error
#define XEVENT_XBANC_CODE_19 0xC000F81F

// XEVENT_XBANC_CODE_20, 63520, Error
#define XEVENT_XBANC_CODE_20 0xC000F820

// XEVENT_XBANC_CODE_21, 63521, Error
#define XEVENT_XBANC_CODE_21 0xC000F821

// XEVENT_XBANC_CODE_22, 63522, Error
#define XEVENT_XBANC_CODE_22 0xC000F822

// XEVENT_XBANC_CODE_23, 63523, Error
#define XEVENT_XBANC_CODE_23 0xC000F823

// XEVENT_XBANC_CODE_24, 63524, Error
#define XEVENT_XBANC_CODE_24 0xC000F824

// XEVENT_XBANC_CODE_25, 63525, Error
#define XEVENT_XBANC_CODE_25 0xC000F825

// XEVENT_XBANC_CODE_26, 63526, Error
#define XEVENT_XBANC_CODE_26 0xC000F826

// XEVENT_XBANC_CODE_27, 63527, Error
#define XEVENT_XBANC_CODE_27 0xC000F827

// XEVENT_XBANC_SERVER_TOO_BUSY, 63528, Error
#define XEVENT_XBANC_SERVER_TOO_BUSY 0xC000F828

// XEVENT_XBANC_PROXY_NOT_INITIALIZED, 63529, Error
#define XEVENT_XBANC_PROXY_NOT_INITIALIZED 0xC000F829

// XEVENT_XBANC_CODE_30, 63530, Error
#define XEVENT_XBANC_CODE_30 0xC000F82A

// XEVENT_XBANC_CODE_31, 63531, Error
#define XEVENT_XBANC_CODE_31 0xC000F82B

// XEVENT_XBANC_CODE_32, 63532, Error
#define XEVENT_XBANC_CODE_32 0xC000F82C

// XEVENT_XBANC_INFO_0, 63700, Info
#define XEVENT_XBANC_INFO_0 0x4000F8D4

// XEVENT_XBANC_INFO_1, 63701, Info
#define XEVENT_XBANC_INFO_1 0x4000F8D5

// XEVENT_XBANC_INFO_2, 63702, Info
#define XEVENT_XBANC_INFO_2 0x4000F8D6

// XEVENT_XBANC_INFO_SETTINGS_CHANGE, 63703, Info
#define XEVENT_XBANC_INFO_SETTINGS_CHANGE 0x4000F8D7

// XEVENT_XBANC_INFO_SERVER_RESUME, 63704, Info
#define XEVENT_XBANC_INFO_SERVER_RESUME 0x4000F8D8

// XEVENT_XBANC_WARN_0, 63750, Warning
#define XEVENT_XBANC_WARN_0 0x8000F906

// XEVENT_XBOS_ACTIVEAUTH_CANCEL_SUBSCRIPTION_NOT_ALLOWED, 15000, Error
#define XEVENT_XBOS_ACTIVEAUTH_CANCEL_SUBSCRIPTION_NOT_ALLOWED 0xC0003A98

// XEVENT_XBOS_INVALID_LIMITED_CHILD_CONTENT_PURCHASE_COUNTRY_CODE_FOUND, 15001, Error
#define XEVENT_XBOS_INVALID_LIMITED_CHILD_CONTENT_PURCHASE_COUNTRY_CODE_FOUND 0xC0003A99

// XEVENT_XBOS_INVALID_LIMITED_CHILD_CONTENT_PURCHASE_MEDIA_TYPE_FOUND, 15002, Error
#define XEVENT_XBOS_INVALID_LIMITED_CHILD_CONTENT_PURCHASE_MEDIA_TYPE_FOUND 0xC0003A9A

// XEVENT_XBOS_SCS_RECORD_MEDIA_PURCHASE_INTENT_FAILURE, 15003, Error
#define XEVENT_XBOS_SCS_RECORD_MEDIA_PURCHASE_INTENT_FAILURE 0xC0003A9B

// XEVENT_XBOS_SCS_RECORD_MEDIA_PURCHASE_SUCCESS_FAILURE, 15004, Error
#define XEVENT_XBOS_SCS_RECORD_MEDIA_PURCHASE_SUCCESS_FAILURE 0xC0003A9C

// XEVENT_XBOS_SCS_RECORD_MEDIA_PURCHASE_FAILURE_FAILURE, 15005, Error
#define XEVENT_XBOS_SCS_RECORD_MEDIA_PURCHASE_FAILURE_FAILURE 0xC0003A9D

// XEVENT_XBOS_SCS_SUBMIT_ORDER_WEB_EXCEPTION, 15006, Error
#define XEVENT_XBOS_SCS_SUBMIT_ORDER_WEB_EXCEPTION 0xC0003A9E

// XEVENT_XBOS_PURCHASE_MEDIA_OFFERS_ERROR, 15007, Error
#define XEVENT_XBOS_PURCHASE_MEDIA_OFFERS_ERROR 0xC0003A9F

// XEVENT_XBOS_SCS_GET_PENDING_COUNT_FAILURE, 15008, Error
#define XEVENT_XBOS_SCS_GET_PENDING_COUNT_FAILURE 0xC0003AA0

// XEVENT_XBOS_SCS_GET_PENDING_TRANSACTION_FAILURE, 15009, Error
#define XEVENT_XBOS_SCS_GET_PENDING_TRANSACTION_FAILURE 0xC0003AA1

// XEVENT_XBOS_SCS_GET_PENDING_SUBMIT_ORDER_FAILURE, 15010, Error
#define XEVENT_XBOS_SCS_GET_PENDING_SUBMIT_ORDER_FAILURE 0xC0003AA2

// XEVENT_XBOS_SCS_GET_PENDING_OFFSET_ORDER_FAILURE, 15011, Error
#define XEVENT_XBOS_SCS_GET_PENDING_OFFSET_ORDER_FAILURE 0xC0003AA3

// XEVENT_XBOS_SCS_SUBMIT_ORDER_QUEUE_TIMER_RESET_ERROR, 15012, Error
#define XEVENT_XBOS_SCS_SUBMIT_ORDER_QUEUE_TIMER_RESET_ERROR 0xC0003AA4

// XEVENT_XBOS_SCS_SUBMIT_ORDER_QUEUE_PUMP_ERROR, 15013, Error
#define XEVENT_XBOS_SCS_SUBMIT_ORDER_QUEUE_PUMP_ERROR 0xC0003AA5

// XEVENT_XBOS_SCS_SUBMIT_ORDER_QUEUE_IMPERSONATION_UNDO_ERROR, 15014, Error
#define XEVENT_XBOS_SCS_SUBMIT_ORDER_QUEUE_IMPERSONATION_UNDO_ERROR 0xC0003AA6

// XEVENT_XBOS_SCS_SUBMIT_ORDER_QUEUE_SUBMIT_ORDER_ERROR, 15015, Error
#define XEVENT_XBOS_SCS_SUBMIT_ORDER_QUEUE_SUBMIT_ORDER_ERROR 0xC0003AA7

// XEVENT_XBOS_SCS_SUBMIT_ORDER_QUEUE_OFFSET_ORDER_ERROR, 15016, Error
#define XEVENT_XBOS_SCS_SUBMIT_ORDER_QUEUE_OFFSET_ORDER_ERROR 0xC0003AA8

// XEVENT_XBOS_INVALID_LIMITED_CHILD_PURCHASE_OFFER_TYPE_FOUND, 15017, Error
#define XEVENT_XBOS_INVALID_LIMITED_CHILD_PURCHASE_OFFER_TYPE_FOUND 0xC0003AA9

// XEVENT_XBOS_INVALID_LIMITED_CHILD_OFFER_PURCHASE_COUNTRY_CODE_FOUND, 15018, Error
#define XEVENT_XBOS_INVALID_LIMITED_CHILD_OFFER_PURCHASE_COUNTRY_CODE_FOUND 0xC0003AAA

// XEVENT_XBOS_IN_GAME_CONTENT_AVAILABLE_ERROR, 15019, Error
#define XEVENT_XBOS_IN_GAME_CONTENT_AVAILABLE_ERROR 0xC0003AAB

// XEVENT_XBOS_IN_GAME_CONTENT_ENUMERATE_ERROR, 15020, Error
#define XEVENT_XBOS_IN_GAME_CONTENT_ENUMERATE_ERROR 0xC0003AAC

// XEVENT_XBOS_OFFER_PURCHASE_ERROR, 15021, Error
#define XEVENT_XBOS_OFFER_PURCHASE_ERROR 0xC0003AAD

// XEVENT_XBOS_SUBSCRIPTION_DETAILS_ERROR, 15022, Error
#define XEVENT_XBOS_SUBSCRIPTION_DETAILS_ERROR 0xC0003AAE

// XEVENT_XBOS_VERIFY_TOKEN_ERROR, 15023, Error
#define XEVENT_XBOS_VERIFY_TOKEN_ERROR 0xC0003AAF

// XEVENT_XBOS_CONTENT_AVAILABLE_ERROR, 15024, Error
#define XEVENT_XBOS_CONTENT_AVAILABLE_ERROR 0xC0003AB0

// XEVENT_XBOS_CONTENT_DETAILS_ERROR, 15025, Error
#define XEVENT_XBOS_CONTENT_DETAILS_ERROR 0xC0003AB1

// XEVENT_XBOS_CONTENT_ENUMERATE_ERROR, 15026, Error
#define XEVENT_XBOS_CONTENT_ENUMERATE_ERROR 0xC0003AB2

// XEVENT_XBOS_CONTENT_REFERRAL_ERROR, 15027, Error
#define XEVENT_XBOS_CONTENT_REFERRAL_ERROR 0xC0003AB3

// XEVENT_XBOS_VERIFY_NICKNAME_ERROR, 15028, Error
#define XEVENT_XBOS_VERIFY_NICKNAME_ERROR 0xC0003AB4

// XEVENT_XBOS_AUTOUPD_REFERRAL_ERROR, 15029, Error
#define XEVENT_XBOS_AUTOUPD_REFERRAL_ERROR 0xC0003AB5

// XEVENT_XBOS_OFFERING_DETAILS_ERROR, 15030, Error
#define XEVENT_XBOS_OFFERING_DETAILS_ERROR 0xC0003AB6

// XEVENT_XBOS_OFFERING_DETAILS_NO_USER_ERROR, 15031, Error
#define XEVENT_XBOS_OFFERING_DETAILS_NO_USER_ERROR 0xC0003AB7

// XEVENT_XBOS_ASSET_CONSUME_ERROR, 15032, Error
#define XEVENT_XBOS_ASSET_CONSUME_ERROR 0xC0003AB8

// XEVENT_XBOS_ASSET_ENUMERATE_ERROR, 15033, Error
#define XEVENT_XBOS_ASSET_ENUMERATE_ERROR 0xC0003AB9

// XEVENT_XBOS_FIND_MEDIA_INSTANCE_URLS_ERROR, 15034, Error
#define XEVENT_XBOS_FIND_MEDIA_INSTANCE_URLS_ERROR 0xC0003ABA

// XEVENT_XBOS_OFFER_PURCHASE_GAMERTAG_ERROR, 15035, Error
#define XEVENT_XBOS_OFFER_PURCHASE_GAMERTAG_ERROR 0xC0003ABB

// XEVENT_XBOS_CONTENT_REFRESH_LICENSE_ERROR, 15036, Error
#define XEVENT_XBOS_CONTENT_REFRESH_LICENSE_ERROR 0xC0003ABC

// XEVENT_XBOS_GET_TITLE_ACTIVATION_LIST_ERROR, 15037, Error
#define XEVENT_XBOS_GET_TITLE_ACTIVATION_LIST_ERROR 0xC0003ABD

// XEVENT_XBOS_GET_TITLE_DETAILS_ERROR, 15038, Error
#define XEVENT_XBOS_GET_TITLE_DETAILS_ERROR 0xC0003ABE

// XEVENT_XBOS_CONTENT_UPDATE_ACCESS_TIMES_ERROR, 15039, Error
#define XEVENT_XBOS_CONTENT_UPDATE_ACCESS_TIMES_ERROR 0xC0003ABF

// XEVENT_XBOS_CONTENT_HISTORY_ENUMERATE_ERROR, 15040, Error
#define XEVENT_XBOS_CONTENT_HISTORY_ENUMERATE_ERROR 0xC0003AC0

// XEVENT_XBOS_ENUMERATE_GENRES_ERROR, 15041, Error
#define XEVENT_XBOS_ENUMERATE_GENRES_ERROR 0xC0003AC1

// XEVENT_XBOS_ENUMERATE_TITLES_BY_FILTER_ERROR, 15042, Error
#define XEVENT_XBOS_ENUMERATE_TITLES_BY_FILTER_ERROR 0xC0003AC2

// XEVENT_XBOS_GET_REVOCATION_LIST_ERROR, 15043, Error
#define XEVENT_XBOS_GET_REVOCATION_LIST_ERROR 0xC0003AC3

// XEVENT_XBOS_OFFERING_VERIFY_TOKEN_ERROR, 15044, Error
#define XEVENT_XBOS_OFFERING_VERIFY_TOKEN_ERROR 0xC0003AC4

// XEVENT_XBOS_SIGN_ASSETS_ERROR, 15045, Error
#define XEVENT_XBOS_SIGN_ASSETS_ERROR 0xC0003AC5

// XEVENT_XBOS_CREATE_CERTIFICATE_ERROR, 15046, Error
#define XEVENT_XBOS_CREATE_CERTIFICATE_ERROR 0xC0003AC6

// XEVENT_XBOS_GET_POINTS_PURCHASE_STATUS_ERROR, 15047, Error
#define XEVENT_XBOS_GET_POINTS_PURCHASE_STATUS_ERROR 0xC0003AC7

// XEVENT_XBOS_OFFER_PURCHASE_PLATFORM_ERROR, 15048, Error
#define XEVENT_XBOS_OFFER_PURCHASE_PLATFORM_ERROR 0xC0003AC8

// XEVENT_XBOS_OFFER_PURCHASE_OFFERID_ERROR, 15049, Error
#define XEVENT_XBOS_OFFER_PURCHASE_OFFERID_ERROR 0xC0003AC9

// XEVENT_XBOS_OFFER_PURCHASE_DEVICEID_ERROR, 15050, Error
#define XEVENT_XBOS_OFFER_PURCHASE_DEVICEID_ERROR 0xC0003ACA

// XEVENT_XBOS_SCS_GET_FAILED_SUBMIT_ORDER_FAILURE, 15051, Error
#define XEVENT_XBOS_SCS_GET_FAILED_SUBMIT_ORDER_FAILURE 0xC0003ACB

// XEVENT_XBOS_CTP_PURCHASE_GET_PENDING_TRANSACTION_FAILURE, 15052, Error
#define XEVENT_XBOS_CTP_PURCHASE_GET_PENDING_TRANSACTION_FAILURE 0xC0003ACC

// XEVENT_XBOS_CTP_QUEUE_RETRY_FAILED, 15053, Error
#define XEVENT_XBOS_CTP_QUEUE_RETRY_FAILED 0xC0003ACD

// XEVENT_XBOS_CTP_PURCHASE_QUEUE_IMPERSONATION_UNDO_ERROR, 15054, Error
#define XEVENT_XBOS_CTP_PURCHASE_QUEUE_IMPERSONATION_UNDO_ERROR 0xC0003ACE

// XEVENT_XBOS_CTP_PURCHASE_QUEUE_PUMP_ERROR, 15055, Error
#define XEVENT_XBOS_CTP_PURCHASE_QUEUE_PUMP_ERROR 0xC0003ACF

// XEVENT_XBOS_CTP_PURCHASE_QUEUE_TIMER_RESET_ERROR, 15056, Error
#define XEVENT_XBOS_CTP_PURCHASE_QUEUE_TIMER_RESET_ERROR 0xC0003AD0

// XEVENT_XBOS_CTP_PURCHASE_QUEUE_GET_RETRY_COUNT_FAILURE, 15057, Error
#define XEVENT_XBOS_CTP_PURCHASE_QUEUE_GET_RETRY_COUNT_FAILURE 0xC0003AD1

// XEVENT_XBOS_CTP_PURCHASE_QUEUE_UPDATE_STATUS_FAILURE, 15058, Error
#define XEVENT_XBOS_CTP_PURCHASE_QUEUE_UPDATE_STATUS_FAILURE 0xC0003AD2

// XEVENT_XONLINE_E_BILLING_CTP_QUEUE_PURCHASE_INTENT_FAILURE, 15059, Error
#define XEVENT_XONLINE_E_BILLING_CTP_QUEUE_PURCHASE_INTENT_FAILURE 0xC0003AD3

// XEVENT_XONLINE_E_BILLING_SUBSCRIPTION_UTILS_ERROR, 15061, Error
#define XEVENT_XONLINE_E_BILLING_SUBSCRIPTION_UTILS_ERROR 0xC0003AD5

// XEVENT_XONLINE_E_SUBSCRIPTION_ENUMERATE_FLUSH_ERROR, 15060, Error
#define XEVENT_XONLINE_E_SUBSCRIPTION_ENUMERATE_FLUSH_ERROR 0xC0003AD4

// XEVENT_BILLING_CODE_0, 50425, Error
#define XEVENT_BILLING_CODE_0 0xC000C4F9

// XEVENT_BILLING_CODE_2, 50427, Error
#define XEVENT_BILLING_CODE_2 0xC000C4FB

// XEVENT_BILLING_CODE_3, 50428, Error
#define XEVENT_BILLING_CODE_3 0xC000C4FC

// XEVENT_BILLING_CODE_5, 50430, Error
#define XEVENT_BILLING_CODE_5 0xC000C4FE

// XEVENT_BILLING_CODE_7, 50432, Error
#define XEVENT_BILLING_CODE_7 0xC000C500

// XEVENT_BILLING_CODE_8, 50433, Error
#define XEVENT_BILLING_CODE_8 0xC000C501

// XEVENT_BILLING_CODE_14, 50439, Error
#define XEVENT_BILLING_CODE_14 0xC000C507

// XEVENT_BILLING_CODE_16, 50441, Error
#define XEVENT_BILLING_CODE_16 0xC000C509

// XEVENT_BILLING_CODE_18, 50443, Error
#define XEVENT_BILLING_CODE_18 0xC000C50B

// XEVENT_BILLING_CODE_19, 50444, Error
#define XEVENT_BILLING_CODE_19 0xC000C50C

// XEVENT_BILLING_CODE_20, 50445, Error
#define XEVENT_BILLING_CODE_20 0xC000C50D

// XEVENT_BILLING_CODE_21, 50446, Error
#define XEVENT_BILLING_CODE_21 0xC000C50E

// XEVENT_BILLING_CODE_22, 50447, Error
#define XEVENT_BILLING_CODE_22 0xC000C50F

// XEVENT_BILLING_CODE_23, 50448, Error
#define XEVENT_BILLING_CODE_23 0xC000C510

// XEVENT_BILLING_CODE_24, 50449, Error
#define XEVENT_BILLING_CODE_24 0xC000C511

// XEVENT_BILLING_CODE_25, 50450, Error
#define XEVENT_BILLING_CODE_25 0xC000C512

// XEVENT_BILLING_CODE_26, 50451, Error
#define XEVENT_BILLING_CODE_26 0xC000C513

// XEVENT_BILLING_CODE_27, 50452, Error
#define XEVENT_BILLING_CODE_27 0xC000C514

// XEVENT_BILLING_CODE_28, 50453, Error
#define XEVENT_BILLING_CODE_28 0xC000C515

// XEVENT_BILLING_CODE_29, 50454, Error
#define XEVENT_BILLING_CODE_29 0xC000C516

// XEVENT_BILLING_CODE_32, 50457, Error
#define XEVENT_BILLING_CODE_32 0xC000C519

// XEVENT_BILLING_CODE_33, 50458, Error
#define XEVENT_BILLING_CODE_33 0xC000C51A

// XEVENT_BILLING_CODE_34, 50459, Error
#define XEVENT_BILLING_CODE_34 0xC000C51B

// XEVENT_BILLING_CODE_35, 50460, Error
#define XEVENT_BILLING_CODE_35 0xC000C51C

// XEVENT_BILLING_CODE_36, 50461, Error
#define XEVENT_BILLING_CODE_36 0xC000C51D

// XEVENT_BILLING_CODE_37, 50462, Error
#define XEVENT_BILLING_CODE_37 0xC000C51E

// XEVENT_BILLING_CODE_38, 50463, Error
#define XEVENT_BILLING_CODE_38 0xC000C51F

// XEVENT_BILLING_CODE_39, 50464, Error
#define XEVENT_BILLING_CODE_39 0xC000C520

// XEVENT_BILLING_CODE_40, 50465, Error
#define XEVENT_BILLING_CODE_40 0xC000C521

// XEVENT_BILLING_CODE_41, 50466, Error
#define XEVENT_BILLING_CODE_41 0xC000C522

// XEVENT_BILLING_CODE_42, 50467, Error
#define XEVENT_BILLING_CODE_42 0xC000C523

// XEVENT_BILLING_CODE_43, 50468, Error
#define XEVENT_BILLING_CODE_43 0xC000C524

// XEVENT_BILLING_CODE_44, 50469, Error
#define XEVENT_BILLING_CODE_44 0xC000C525

// XEVENT_BILLING_CODE_45, 50470, Error
#define XEVENT_BILLING_CODE_45 0xC000C526

// XEVENT_BILLING_CODE_46, 50471, Error
#define XEVENT_BILLING_CODE_46 0xC000C527

// XEVENT_BILLING_CODE_47, 50472, Error
#define XEVENT_BILLING_CODE_47 0xC000C528

// XEVENT_BILLING_CODE_48, 50473, Error
#define XEVENT_BILLING_CODE_48 0xC000C529

// XEVENT_BILLING_CODE_51, 50476, Error
#define XEVENT_BILLING_CODE_51 0xC000C52C

// XEVENT_BILLING_CODE_52, 50477, Error
#define XEVENT_BILLING_CODE_52 0xC000C52D

// XEVENT_BILLING_CODE_53, 50478, Error
#define XEVENT_BILLING_CODE_53 0xC000C52E

// XEVENT_BILLING_CODE_54, 50479, Error
#define XEVENT_BILLING_CODE_54 0xC000C52F

// XEVENT_BILLING_CODE_55, 50480, Error
#define XEVENT_BILLING_CODE_55 0xC000C530

// XEVENT_BILLING_CODE_56, 50481, Error
#define XEVENT_BILLING_CODE_56 0xC000C531

// XEVENT_BILLING_CODE_57, 50482, Error
#define XEVENT_BILLING_CODE_57 0xC000C532

// XEVENT_BILLING_CODE_58, 50483, Error
#define XEVENT_BILLING_CODE_58 0xC000C533

// XEVENT_BILLING_CODE_59, 50484, Error
#define XEVENT_BILLING_CODE_59 0xC000C534

// XEVENT_BILLING_CODE_60, 50485, Error
#define XEVENT_BILLING_CODE_60 0xC000C535

// XEVENT_BILLING_CODE_61, 50486, Error
#define XEVENT_BILLING_CODE_61 0xC000C536

// XEVENT_BILLING_CODE_62, 50487, Error
#define XEVENT_BILLING_CODE_62 0xC000C537

// XEVENT_BILLING_CODE_63, 50488, Error
#define XEVENT_BILLING_CODE_63 0xC000C538

// XEVENT_BILLING_CODE_64, 50489, Error
#define XEVENT_BILLING_CODE_64 0xC000C539

// XEVENT_BILLING_CODE_66, 50491, Error
#define XEVENT_BILLING_CODE_66 0xC000C53B

// XEVENT_BILLING_CODE_67, 50492, Error
#define XEVENT_BILLING_CODE_67 0xC000C53C

// XEVENT_PURCHASE_OFFERS_CLIENT_PRICE_MISMATCH, 50501, Error
#define XEVENT_PURCHASE_OFFERS_CLIENT_PRICE_MISMATCH 0xC000C545

// XEVENT_PURCHASE_OFFERS_MEDIA_INSTANCE_NOT_ACQUIRABLE, 50502, Error
#define XEVENT_PURCHASE_OFFERS_MEDIA_INSTANCE_NOT_ACQUIRABLE 0xC000C546

// XEVENT_PURCHASE_OFFERS_INVALID_ARG, 50503, Error
#define XEVENT_PURCHASE_OFFERS_INVALID_ARG 0xC000C547

// XEVENT_BILLING_NOT_XENON_USER, 50504, Error
#define XEVENT_BILLING_NOT_XENON_USER 0xC000C548

// XEVENT_PURCHASE_OFFERS_INVALID_OFFER_CONFIGURATION, 50505, Error
#define XEVENT_PURCHASE_OFFERS_INVALID_OFFER_CONFIGURATION 0xC000C549

// XEVENT_BILLING_AUTHDATA_VERIFICATION_ERROR_1, 50506, Error
#define XEVENT_BILLING_AUTHDATA_VERIFICATION_ERROR_1 0xC000C54A

// XEVENT_BILLING_AUTHDATA_VERIFICATION_ERROR_2, 50507, Error
#define XEVENT_BILLING_AUTHDATA_VERIFICATION_ERROR_2 0xC000C54B

// XEVENT_PURCHASE_OFFERS_EDITORIAL_PRIVILEGE_DENIED, 50508, Error
#define XEVENT_PURCHASE_OFFERS_EDITORIAL_PRIVILEGE_DENIED 0xC000C54C

// XEVENT_PURCHASE_OFFERS_TOO_MANY_ZERO_POINT_EDITORIAL_PURCHASES, 50509, Error
#define XEVENT_PURCHASE_OFFERS_TOO_MANY_ZERO_POINT_EDITORIAL_PURCHASES 0xC000C54D

// XEVENT_OFFER_PURCHASE_INVALID_PAYMENT_TYPE, 50510, Error
#define XEVENT_OFFER_PURCHASE_INVALID_PAYMENT_TYPE 0xC000C54E

// XEVENT_PURCHASE_OFFERS_MEDIA_TYPE_MISMATCH, 50511, Error
#define XEVENT_PURCHASE_OFFERS_MEDIA_TYPE_MISMATCH 0xC000C54F

// XEVENT_PURCHASE_HISTORY_FLUSH_ERROR, 50512, Error
#define XEVENT_PURCHASE_HISTORY_FLUSH_ERROR 0xC000C550

// XEVENT_OFFER_PURCHASE_INVALID_PLATFORM_TYPE, 50513, Error
#define XEVENT_OFFER_PURCHASE_INVALID_PLATFORM_TYPE 0xC000C551

// XEVENT_BILLING_COMM_0, 50525, Error
#define XEVENT_BILLING_COMM_0 0xC000C55D

// XEVENT_BILLING_COMM_3, 50528, Error
#define XEVENT_BILLING_COMM_3 0xC000C560

// XEVENT_BILLING_COMM_4, 50529, Error
#define XEVENT_BILLING_COMM_4 0xC000C561

// XEVENT_BILLING_COMM_5, 50530, Error
#define XEVENT_BILLING_COMM_5 0xC000C562

// XEVENT_BILLING_COMM_7, 50532, Error
#define XEVENT_BILLING_COMM_7 0xC000C564

// XEVENT_BILLING_COMM_8, 50533, Error
#define XEVENT_BILLING_COMM_8 0xC000C565

// XEVENT_XBOS_AUTOUPD_REFERRAL_NO_LOCATIONS, 50552, Error
#define XEVENT_XBOS_AUTOUPD_REFERRAL_NO_LOCATIONS 0xC000C578

// XEVENT_BILLING_CONFIG_7, 50557, Error
#define XEVENT_BILLING_CONFIG_7 0xC000C57D

// XEVENT_BILLING_CONFIG_8, 50558, Error
#define XEVENT_BILLING_CONFIG_8 0xC000C57E

// XEVENT_BILLING_CONFIG_9, 50559, Error
#define XEVENT_BILLING_CONFIG_9 0xC000C57F

// XEVENT_BILLING_CONFIG_11, 50561, Error
#define XEVENT_BILLING_CONFIG_11 0xC000C581

// XEVENT_BILLING_CONFIG_12, 50562, Error
#define XEVENT_BILLING_CONFIG_12 0xC000C582

// XEVENT_BILLING_CONFIG_13, 50563, Warning
#define XEVENT_BILLING_CONFIG_13 0x8000C583

// XEVENT_BILLING_CONFIG_14, 50564, Warning
#define XEVENT_BILLING_CONFIG_14 0x8000C584

// XEVENT_BILLING_CONFIG_15, 50565, Error
#define XEVENT_BILLING_CONFIG_15 0xC000C585

// XEVENT_BILLING_CONFIG_19, 50569, Warning
#define XEVENT_BILLING_CONFIG_19 0x8000C589

// XEVENT_BILLING_CONFIG_20, 50570, Error
#define XEVENT_BILLING_CONFIG_20 0xC000C58A

// XEVENT_BILLING_CONFIG_21, 50571, Error
#define XEVENT_BILLING_CONFIG_21 0xC000C58B

// XEVENT_BILLING_CONFIG_22, 50572, Error
#define XEVENT_BILLING_CONFIG_22 0xC000C58C

// XEVENT_BILLING_CONFIG_23, 50573, Warning
#define XEVENT_BILLING_CONFIG_23 0x8000C58D

// XEVENT_BILLING_CONFIG_24, 50574, Error
#define XEVENT_BILLING_CONFIG_24 0xC000C58E

// XEVENT_BILLING_CONFIG_26, 50576, Error
#define XEVENT_BILLING_CONFIG_26 0xC000C590

// XEVENT_BILLING_CONFIG_27, 50577, Warning
#define XEVENT_BILLING_CONFIG_27 0x8000C591

// XEVENT_BILLING_CONFIG_28, 50578, Warning
#define XEVENT_BILLING_CONFIG_28 0x8000C592

// XEVENT_BILLING_CONFIG_29, 50579, Error
#define XEVENT_BILLING_CONFIG_29 0xC000C593

// XEVENT_BILLING_CONFIG_30, 50580, Error
#define XEVENT_BILLING_CONFIG_30 0xC000C594

// XEVENT_BILLING_CONFIG_31, 50581, Error
#define XEVENT_BILLING_CONFIG_31 0xC000C595

// XEVENT_BILLING_OFFERING_DMP_INIT_FAILED, 50584, Error
#define XEVENT_BILLING_OFFERING_DMP_INIT_FAILED 0xC000C598

// XEVENT_BILLING_OFFERING_WMIS_INIT_FAILED, 50585, Error
#define XEVENT_BILLING_OFFERING_WMIS_INIT_FAILED 0xC000C599

// XEVENT_BILLING_OFFERING_XBOSMGMT_INIT_FAILED, 50586, Error
#define XEVENT_BILLING_OFFERING_XBOSMGMT_INIT_FAILED 0xC000C59A

// XEVENT_BILLING_OFFERING_MUSICNET_INIT_FAILED, 50587, Error
#define XEVENT_BILLING_OFFERING_MUSICNET_INIT_FAILED 0xC000C59B

// XEVENT_BILLING_OFFERING_BANNER_LIST_INIT_FAILED, 50589, Error
#define XEVENT_BILLING_OFFERING_BANNER_LIST_INIT_FAILED 0xC000C59D

// XEVENT_XBOS_PURCHASE_HACK, 50650, Warning
#define XEVENT_XBOS_PURCHASE_HACK 0x8000C5DA

// XEVENT_BILLING_HACK_1, 50651, Warning
#define XEVENT_BILLING_HACK_1 0x8000C5DB

// XEVENT_BILLING_HACK_2, 50652, Warning
#define XEVENT_BILLING_HACK_2 0x8000C5DC

// XEVENT_BILLING_HACK_3, 50653, Warning
#define XEVENT_BILLING_HACK_3 0x8000C5DD

// XEVENT_BILLING_HACK_4, 50654, Warning
#define XEVENT_BILLING_HACK_4 0x8000C5DE

// XEVENT_BILLING_HACK_7, 50657, Warning
#define XEVENT_BILLING_HACK_7 0x8000C5E1

// XEVENT_BILLING_HACK_14, 50664, Warning
#define XEVENT_BILLING_HACK_14 0x8000C5E8

// XEVENT_BILLING_HACK_15, 50665, Warning
#define XEVENT_BILLING_HACK_15 0x8000C5E9

// XEVENT_BILLING_HACK_16, 50666, Warning
#define XEVENT_BILLING_HACK_16 0x8000C5EA

// XEVENT_BILLING_HACK_17, 50667, Warning
#define XEVENT_BILLING_HACK_17 0x8000C5EB

// XEVENT_BILLING_HACK_18, 50668, Warning
#define XEVENT_BILLING_HACK_18 0x8000C5EC

// XEVENT_BILLING_HACK_19, 50669, Warning
#define XEVENT_BILLING_HACK_19 0x8000C5ED

// XEVENT_BILLING_HACK_20, 50670, Warning
#define XEVENT_BILLING_HACK_20 0x8000C5EE

// XEVENT_BILLING_HACK_UNKNOWN_OFFER_TYPE, 50671, Warning
#define XEVENT_BILLING_HACK_UNKNOWN_OFFER_TYPE 0x8000C5EF

// XEVENT_BILLING_HACK_UNKNOWN_PAYMENT_TYPE, 50672, Warning
#define XEVENT_BILLING_HACK_UNKNOWN_PAYMENT_TYPE 0x8000C5F0

// XEVENT_BILLING_INFO_0, 50700, Info
#define XEVENT_BILLING_INFO_0 0x4000C60C

// XEVENT_BILLING_INFO_1, 50701, Info
#define XEVENT_BILLING_INFO_1 0x4000C60D

// XEVENT_XBOS_OFFER_INELIGIBLE_FOR_PURCHASE, 50702, Info
#define XEVENT_XBOS_OFFER_INELIGIBLE_FOR_PURCHASE 0x4000C60E

// XEVENT_XBOS_OFFER_INELIGIBLE_FOR_PURCHASE_1, 50703, Info
#define XEVENT_XBOS_OFFER_INELIGIBLE_FOR_PURCHASE_1 0x4000C60F

// XEVENT_BILLING_INFO_4, 50704, Info
#define XEVENT_BILLING_INFO_4 0x4000C610

// XEVENT_BILLING_OFFERING_CANCEL_ERROR, 64000, Error
#define XEVENT_BILLING_OFFERING_CANCEL_ERROR 0xC000FA00

// XEVENT_BILLING_OFFERING_PURCHASE_OFFERS_ERROR, 64001, Error
#define XEVENT_BILLING_OFFERING_PURCHASE_OFFERS_ERROR 0xC000FA01

// XEVENT_BILLING_OFFERING_PURCHASE_BILLING_OFFER_ERROR, 64002, Error
#define XEVENT_BILLING_OFFERING_PURCHASE_BILLING_OFFER_ERROR 0xC000FA02

// XEVENT_BILLING_OFFERING_SUBSCRIPTION_ENUMERATE_ERROR, 64003, Error
#define XEVENT_BILLING_OFFERING_SUBSCRIPTION_ENUMERATE_ERROR 0xC000FA03

// XEVENT_BILLING_OFFERING_UPDATE_PROFILE_ERROR, 64004, Error
#define XEVENT_BILLING_OFFERING_UPDATE_PROFILE_ERROR 0xC000FA04

// XEVENT_PURCHASE_OFFERS_INVALID_OFFER_TYPE, 64005, Error
#define XEVENT_PURCHASE_OFFERS_INVALID_OFFER_TYPE 0xC000FA05

// XEVENT_PURCHASE_OFFERS_CTP_TRANSACTIONSERVICE_TIMEOUT, 64006, Error
#define XEVENT_PURCHASE_OFFERS_CTP_TRANSACTIONSERVICE_TIMEOUT 0xC000FA06

// XEVENT_PURCHASE_OFFERS_INVALID_RENEWAL_PATH, 64007, Error
#define XEVENT_PURCHASE_OFFERS_INVALID_RENEWAL_PATH 0xC000FA07

// XEVENT_PURCHASE_OFFERS_SUBSCRIPTION_CTP_INVALID_TIMEEXTENSION, 64008, Error
#define XEVENT_PURCHASE_OFFERS_SUBSCRIPTION_CTP_INVALID_TIMEEXTENSION 0xC000FA08

// XEVENT_PURCHASE_OFFERS_SUBSCRIPTION_REINSTATE_ERROR, 64009, Error
#define XEVENT_PURCHASE_OFFERS_SUBSCRIPTION_REINSTATE_ERROR 0xC000FA09

// XEVENT_PURCHASE_OFFERS_SUBSCRIPTION_PENDINGMOVE_ERROR, 64010, Error
#define XEVENT_PURCHASE_OFFERS_SUBSCRIPTION_PENDINGMOVE_ERROR 0xC000FA0A

// XEVENT_PURCHASE_OFFERS_SUBSCRIPTION_CTP_INVALID_PRICE, 64011, Error
#define XEVENT_PURCHASE_OFFERS_SUBSCRIPTION_CTP_INVALID_PRICE 0xC000FA0B

// XEVENT_PURCHASE_OFFERS_SUBSCRIPTION_PENDING_MOVE_ERROR, 64012, Error
#define XEVENT_PURCHASE_OFFERS_SUBSCRIPTION_PENDING_MOVE_ERROR 0xC000FA0C

// XEVENT_XCACHE_STARTED, 20010, Info
#define XEVENT_XCACHE_STARTED 0x40004E2A

// XEVENT_XCACHE_SHUTDOWN, 20011, Info
#define XEVENT_XCACHE_SHUTDOWN 0x40004E2B

// XEVENT_XCACHE_STARTUP_FAILURE, 20012, Error
#define XEVENT_XCACHE_STARTUP_FAILURE 0xC0004E2C

// XEVENT_XCACHE_SHUTDOWN_STARTED, 20013, Info
#define XEVENT_XCACHE_SHUTDOWN_STARTED 0x40004E2D

// XEVENT_XCACHE_SHUTDOWN_FAILURE, 20014, Info
#define XEVENT_XCACHE_SHUTDOWN_FAILURE 0x40004E2E

// XEVENT_XCACHE_MSG_TOO_BIG, 20020, Error
#define XEVENT_XCACHE_MSG_TOO_BIG 0xC0004E34

// XEVENT_XCACHE_PROTOCOL_ERROR, 20021, Error
#define XEVENT_XCACHE_PROTOCOL_ERROR 0xC0004E35

// XEVENT_XCACHE_UNKNOWN_LOOKUP_TYPE, 20022, Error
#define XEVENT_XCACHE_UNKNOWN_LOOKUP_TYPE 0xC0004E36

// XEVENT_XCACHE_CONTEXT_EXCEPTION, 20030, Error
#define XEVENT_XCACHE_CONTEXT_EXCEPTION 0xC0004E3E

// XEVENT_XCACHE_THREADPOOL_EXCEPTION, 20031, Warning
#define XEVENT_XCACHE_THREADPOOL_EXCEPTION 0x80004E3F

// XEVENT_XCACHE_DBREADER_INIT_FAIL, 20040, Error
#define XEVENT_XCACHE_DBREADER_INIT_FAIL 0xC0004E48

// XEVENT_XCACHE_DBREADER_INVALID_PARTITION_COUNT, 20041, Error
#define XEVENT_XCACHE_DBREADER_INVALID_PARTITION_COUNT 0xC0004E49

// XEVENT_XCACHE_DBREADER_READ_FAIL, 20042, Error
#define XEVENT_XCACHE_DBREADER_READ_FAIL 0xC0004E4A

// XEVENT_XCACHE_DBTHREAD_EXCEPTION, 20043, Warning
#define XEVENT_XCACHE_DBTHREAD_EXCEPTION 0x80004E4B

// XEVENT_XCACHE_INIT_COMPLETE, 61900, Info
#define XEVENT_XCACHE_INIT_COMPLETE 0x4000F1CC

// XEVENT_XCONNSRV_STARTED, 20000, Info
#define XEVENT_XCONNSRV_STARTED 0x40004E20

// XEVENT_XCONNSRV_SHUTDOWN, 20001, Info
#define XEVENT_XCONNSRV_SHUTDOWN 0x40004E21

// XEVENT_XCONNSRV_STARTUP_FAILURE, 20002, Error
#define XEVENT_XCONNSRV_STARTUP_FAILURE 0xC0004E22

// XEVENT_XCONNSRV_PROTOCOL_VERSION_MISMATCH, 20003, Error
#define XEVENT_XCONNSRV_PROTOCOL_VERSION_MISMATCH 0xC0004E23

// XEVENT_XCONNSRV_MSGTYPE_UNKNOWN, 20004, Error
#define XEVENT_XCONNSRV_MSGTYPE_UNKNOWN 0xC0004E24

// XEVENT_XCONNSRV_MSG_BEFORE_CONNECT, 20005, Error
#define XEVENT_XCONNSRV_MSG_BEFORE_CONNECT 0xC0004E25

// XEVENT_XCONNSRV_USER_INDEX_MISMATCH, 20006, Error
#define XEVENT_XCONNSRV_USER_INDEX_MISMATCH 0xC0004E26

// XEVENT_XCONNSRV_MSG_TOO_SMALL, 20007, Error
#define XEVENT_XCONNSRV_MSG_TOO_SMALL 0xC0004E27

// XEVENT_XCONNSRV_INVALID_USER_FLAGS, 20008, Error
#define XEVENT_XCONNSRV_INVALID_USER_FLAGS 0xC0004E28

// XEVENT_XCONNSRV_TOO_MANY_USER_FLAGS, 20009, Error
#define XEVENT_XCONNSRV_TOO_MANY_USER_FLAGS 0xC0004E29

// XEVENT_XCONNSRV_NUM_USER_FLAGS_MISMATCH, 20010, Error
#define XEVENT_XCONNSRV_NUM_USER_FLAGS_MISMATCH 0xC0004E2A

// XEVENT_XCONNSRV_MSGTYPE_UNSUPPORTED, 20011, Error
#define XEVENT_XCONNSRV_MSGTYPE_UNSUPPORTED 0xC0004E2B

// XEVENT_XCONNSRV_MSG_TOO_BIG, 20012, Error
#define XEVENT_XCONNSRV_MSG_TOO_BIG 0xC0004E2C

// XEVENT_XCONNSRV_SGINFO_ERROR, 20013, Error
#define XEVENT_XCONNSRV_SGINFO_ERROR 0xC0004E2D

// XEVENT_XCONNSRV_USER_NOT_PRESENT, 20014, Error
#define XEVENT_XCONNSRV_USER_NOT_PRESENT 0xC0004E2E

// XEVENT_XCONNSRV_CONTEXT_EXCEPTION, 20015, Error
#define XEVENT_XCONNSRV_CONTEXT_EXCEPTION 0xC0004E2F

// XEVENT_XCONNSRV_DATA_TOO_SMALL, 20016, Error
#define XEVENT_XCONNSRV_DATA_TOO_SMALL 0xC0004E30

// XEVENT_XCONNSRV_DATA_INTEGRITY_ERROR, 20017, Error
#define XEVENT_XCONNSRV_DATA_INTEGRITY_ERROR 0xC0004E31

// XEVENT_XCONNSRV_VELOCITY_NOTIFICATION_FAILURE, 20018, Error
#define XEVENT_XCONNSRV_VELOCITY_NOTIFICATION_FAILURE 0xC0004E32

// XEVENT_XCONNSRV_TOO_MANY_OBJECTS, 20019, Error
#define XEVENT_XCONNSRV_TOO_MANY_OBJECTS 0xC0004E33

// XEVENT_XCONNSRV_TOO_MANY_SUBSCRIPTIONS, 20020, Error
#define XEVENT_XCONNSRV_TOO_MANY_SUBSCRIPTIONS 0xC0004E34

// XEVENT_XCONNSRV_EXCEPTION_WOULD_DEADLOCK, 20021, Warning
#define XEVENT_XCONNSRV_EXCEPTION_WOULD_DEADLOCK 0x80004E35

// XEVENT_XCONNSRV_THREADPOOL_EXCEPTION, 20022, Warning
#define XEVENT_XCONNSRV_THREADPOOL_EXCEPTION 0x80004E36

// XEVENT_XCONNSRV_NOTIFICATION_FORMATTING_ERROR, 20023, Error
#define XEVENT_XCONNSRV_NOTIFICATION_FORMATTING_ERROR 0xC0004E37

// XEVENT_XCONNSRV_DUPLICATE_USER, 20024, Error
#define XEVENT_XCONNSRV_DUPLICATE_USER 0xC0004E38

// XEVENT_XCRYPTO_INIT_SUCCESS, 40000, Info
#define XEVENT_XCRYPTO_INIT_SUCCESS 0x40009C40

// XEVENT_XCRYPTO_CONFIG_ERROR, 40001, Error
#define XEVENT_XCRYPTO_CONFIG_ERROR 0xC0009C41

// XEVENT_XCRYPTO_REQUEST_FAILED, 40002, Error
#define XEVENT_XCRYPTO_REQUEST_FAILED 0xC0009C42

// XEVENT_XCRYPTO_CRYPTO_KEY_ERROR, 63875, Error
#define XEVENT_XCRYPTO_CRYPTO_KEY_ERROR 0xC000F983

// XEVENT_XCRYPTO_GENERIC_ERROR, 63876, Error
#define XEVENT_XCRYPTO_GENERIC_ERROR 0xC000F984

// XEVENT_XCRYPTO_NCIPHER_ERROR, 63877, Error
#define XEVENT_XCRYPTO_NCIPHER_ERROR 0xC000F985

// XEVENT_XCRYPTO_PROXY_FAILED, 63900, Error
#define XEVENT_XCRYPTO_PROXY_FAILED 0xC000F99C

// XEVENT_XCRYPTO_PROXY_BUFFER_TOO_SMALL, 63901, Error
#define XEVENT_XCRYPTO_PROXY_BUFFER_TOO_SMALL 0xC000F99D

// XEVENT_XDS_CONFIG_HEALTHINTEROP_CREATE, 20000, Error
#define XEVENT_XDS_CONFIG_HEALTHINTEROP_CREATE 0xC0004E20

// XEVENT_XDS_CONFIG_HEALTHINTEROP_INIT, 20001, Error
#define XEVENT_XDS_CONFIG_HEALTHINTEROP_INIT 0xC0004E21

// XEVENT_XDS_CODE_0, 62100, Error
#define XEVENT_XDS_CODE_0 0xC000F294

// XEVENT_XDS_CODE_1, 62101, Error
#define XEVENT_XDS_CODE_1 0xC000F295

// XEVENT_XDS_CODE_2, 62102, Error
#define XEVENT_XDS_CODE_2 0xC000F296

// XEVENT_XDS_CODE_3, 62103, Error
#define XEVENT_XDS_CODE_3 0xC000F297

// XEVENT_XDS_CODE_4, 62104, Error
#define XEVENT_XDS_CODE_4 0xC000F298

// XEVENT_XDS_CODE_5, 62105, Error
#define XEVENT_XDS_CODE_5 0xC000F299

// XEVENT_XDS_CODE_6, 62106, Error
#define XEVENT_XDS_CODE_6 0xC000F29A

// XEVENT_XDS_CODE_7, 62107, Error
#define XEVENT_XDS_CODE_7 0xC000F29B

// XEVENT_XDS_CODE_8, 62108, Error
#define XEVENT_XDS_CODE_8 0xC000F29C

// XEVENT_XDS_CODE_9, 62109, Error
#define XEVENT_XDS_CODE_9 0xC000F29D

// XEVENT_XDS_CODE_10, 62110, Error
#define XEVENT_XDS_CODE_10 0xC000F29E

// XEVENT_XDS_CODE_11, 62111, Error
#define XEVENT_XDS_CODE_11 0xC000F29F

// XEVENT_XDS_CODE_12, 62112, Error
#define XEVENT_XDS_CODE_12 0xC000F2A0

// XEVENT_XDS_CODE_13, 62113, Error
#define XEVENT_XDS_CODE_13 0xC000F2A1

// XEVENT_XDS_CODE_14, 62114, Error
#define XEVENT_XDS_CODE_14 0xC000F2A2

// XEVENT_XDS_CODE_15, 62115, Error
#define XEVENT_XDS_CODE_15 0xC000F2A3

// XEVENT_XDS_CODE_16, 62116, Error
#define XEVENT_XDS_CODE_16 0xC000F2A4

// XEVENT_XDS_CODE_17, 62117, Error
#define XEVENT_XDS_CODE_17 0xC000F2A5

// XEVENT_XDS_CODE_18, 62118, Error
#define XEVENT_XDS_CODE_18 0xC000F2A6

// XEVENT_XDS_CODE_19, 62119, Error
#define XEVENT_XDS_CODE_19 0xC000F2A7

// XEVENT_XDS_CODE_20, 62120, Error
#define XEVENT_XDS_CODE_20 0xC000F2A8

// XEVENT_XDS_CODE_21, 62121, Error
#define XEVENT_XDS_CODE_21 0xC000F2A9

// XEVENT_XDS_CODE_22, 62122, Error
#define XEVENT_XDS_CODE_22 0xC000F2AA

// XEVENT_XDS_CODE_23, 62123, Error
#define XEVENT_XDS_CODE_23 0xC000F2AB

// XEVENT_XDS_CODE_24, 62124, Error
#define XEVENT_XDS_CODE_24 0xC000F2AC

// XEVENT_XDS_CODE_25, 62125, Error
#define XEVENT_XDS_CODE_25 0xC000F2AD

// XEVENT_XDS_CODE_26, 62126, Error
#define XEVENT_XDS_CODE_26 0xC000F2AE

// XEVENT_XDS_CODE_27, 62127, Error
#define XEVENT_XDS_CODE_27 0xC000F2AF

// XEVENT_XDS_CODE_28, 62128, Error
#define XEVENT_XDS_CODE_28 0xC000F2B0

// XEVENT_XDS_CODE_29, 62129, Error
#define XEVENT_XDS_CODE_29 0xC000F2B1

// XEVENT_XDS_CODE_30, 62130, Error
#define XEVENT_XDS_CODE_30 0xC000F2B2

// XEVENT_XDS_CODE_31, 62131, Error
#define XEVENT_XDS_CODE_31 0xC000F2B3

// XEVENT_XDS_CODE_32, 62132, Error
#define XEVENT_XDS_CODE_32 0xC000F2B4

// XEVENT_XDS_CODE_33, 62133, Error
#define XEVENT_XDS_CODE_33 0xC000F2B5

// XEVENT_XDS_CODE_34, 62134, Error
#define XEVENT_XDS_CODE_34 0xC000F2B6

// XEVENT_XDS_CODE_35, 62135, Error
#define XEVENT_XDS_CODE_35 0xC000F2B7

// XEVENT_XDS_CODE_36, 62136, Error
#define XEVENT_XDS_CODE_36 0xC000F2B8

// XEVENT_XDS_CODE_37, 62137, Error
#define XEVENT_XDS_CODE_37 0xC000F2B9

// XEVENT_XDS_CODE_38, 62138, Error
#define XEVENT_XDS_CODE_38 0xC000F2BA

// XEVENT_XDS_CODE_39, 62139, Error
#define XEVENT_XDS_CODE_39 0xC000F2BB

// XEVENT_XDS_CODE_40, 62140, Error
#define XEVENT_XDS_CODE_40 0xC000F2BC

// XEVENT_XDS_CODE_41, 62141, Error
#define XEVENT_XDS_CODE_41 0xC000F2BD

// XEVENT_XDS_CODE_42, 62142, Error
#define XEVENT_XDS_CODE_42 0xC000F2BE

// XEVENT_XDS_CODE_43, 62143, Error
#define XEVENT_XDS_CODE_43 0xC000F2BF

// XEVENT_XDS_CODE_44, 62144, Error
#define XEVENT_XDS_CODE_44 0xC000F2C0

// XEVENT_XDS_CODE_45, 62145, Error
#define XEVENT_XDS_CODE_45 0xC000F2C1

// XEVENT_XDS_CODE_46, 62146, Error
#define XEVENT_XDS_CODE_46 0xC000F2C2

// XEVENT_XDS_CODE_47, 62147, Error
#define XEVENT_XDS_CODE_47 0xC000F2C3

// XEVENT_XDS_CODE_48, 62148, Error
#define XEVENT_XDS_CODE_48 0xC000F2C4

// XEVENT_XDS_CODE_49, 62149, Error
#define XEVENT_XDS_CODE_49 0xC000F2C5

// XEVENT_XDS_CODE_50, 62150, Error
#define XEVENT_XDS_CODE_50 0xC000F2C6

// XEVENT_XDS_CODE_51, 62151, Error
#define XEVENT_XDS_CODE_51 0xC000F2C7

// XEVENT_XDS_CODE_52, 62152, Error
#define XEVENT_XDS_CODE_52 0xC000F2C8

// XEVENT_XDS_CODE_53, 62153, Error
#define XEVENT_XDS_CODE_53 0xC000F2C9

// XEVENT_XDS_CODE_54, 62154, Error
#define XEVENT_XDS_CODE_54 0xC000F2CA

// XEVENT_XDS_CODE_55, 62155, Error
#define XEVENT_XDS_CODE_55 0xC000F2CB

// XEVENT_XDS_CODE_56, 62156, Error
#define XEVENT_XDS_CODE_56 0xC000F2CC

// XEVENT_XDS_CODE_57, 62157, Error
#define XEVENT_XDS_CODE_57 0xC000F2CD

// XEVENT_XDS_CODE_58, 62158, Error
#define XEVENT_XDS_CODE_58 0xC000F2CE

// XEVENT_XDS_CODE_59, 62159, Error
#define XEVENT_XDS_CODE_59 0xC000F2CF

// XEVENT_XDS_CODE_60, 62160, Error
#define XEVENT_XDS_CODE_60 0xC000F2D0

// XEVENT_XDS_COMM_0, 62300, Error
#define XEVENT_XDS_COMM_0 0xC000F35C

// XEVENT_XDS_CONFIG_0, 62325, Error
#define XEVENT_XDS_CONFIG_0 0xC000F375

// XEVENT_XDS_CONFIG_1, 62326, Error
#define XEVENT_XDS_CONFIG_1 0xC000F376

// XEVENT_XDS_CONFIG_2, 62327, Error
#define XEVENT_XDS_CONFIG_2 0xC000F377

// XEVENT_XDS_CONFIG_3, 62328, Error
#define XEVENT_XDS_CONFIG_3 0xC000F378

// XEVENT_XDS_CONFIG_4, 62329, Error
#define XEVENT_XDS_CONFIG_4 0xC000F379

// XEVENT_XDS_CONFIG_5, 62330, Error
#define XEVENT_XDS_CONFIG_5 0xC000F37A

// XEVENT_XDS_HACK_0, 62350, Warning
#define XEVENT_XDS_HACK_0 0x8000F38E

// XEVENT_XDS_HACK_1, 62351, Warning
#define XEVENT_XDS_HACK_1 0x8000F38F

// XEVENT_XDS_HACK_2, 62352, Warning
#define XEVENT_XDS_HACK_2 0x8000F390

// XEVENT_XDS_HACK_3, 62353, Warning
#define XEVENT_XDS_HACK_3 0x8000F391

// XEVENT_XDS_HACK_4, 62354, Warning
#define XEVENT_XDS_HACK_4 0x8000F392

// XEVENT_XDS_HACK_5, 62355, Warning
#define XEVENT_XDS_HACK_5 0x8000F393

// XEVENT_XDS_HACK_6, 62356, Warning
#define XEVENT_XDS_HACK_6 0x8000F394

// XEVENT_XDS_HACK_7, 62357, Warning
#define XEVENT_XDS_HACK_7 0x8000F395

// XEVENT_XDS_HACK_8, 62358, Warning
#define XEVENT_XDS_HACK_8 0x8000F396

// XEVENT_XDS_HACK_9, 62359, Warning
#define XEVENT_XDS_HACK_9 0x8000F397

// XEVENT_XDS_HACK_10, 62360, Warning
#define XEVENT_XDS_HACK_10 0x8000F398

// XEVENT_XDS_HACK_11, 62361, Warning
#define XEVENT_XDS_HACK_11 0x8000F399

// XEVENT_XDS_HACK_12, 62362, Warning
#define XEVENT_XDS_HACK_12 0x8000F39A

// XEVENT_XDS_HACK_13, 62363, Warning
#define XEVENT_XDS_HACK_13 0x8000F39B

// XEVENT_XDS_HACK_14, 62364, Warning
#define XEVENT_XDS_HACK_14 0x8000F39C

// XEVENT_XDS_HACK_15, 62365, Warning
#define XEVENT_XDS_HACK_15 0x8000F39D

// XEVENT_XDS_HACK_16, 62366, Warning
#define XEVENT_XDS_HACK_16 0x8000F39E

// XEVENT_XDS_HACK_17, 62367, Warning
#define XEVENT_XDS_HACK_17 0x8000F39F

// XEVENT_XDS_HACK_18, 62368, Warning
#define XEVENT_XDS_HACK_18 0x8000F3A0

// XEVENT_XDS_HACK_19, 62369, Warning
#define XEVENT_XDS_HACK_19 0x8000F3A1

// XEVENT_XDS_HACK_20, 62370, Warning
#define XEVENT_XDS_HACK_20 0x8000F3A2

// XEVENT_XDS_HACK_21, 62371, Warning
#define XEVENT_XDS_HACK_21 0x8000F3A3

// XEVENT_XDS_HACK_22, 62372, Warning
#define XEVENT_XDS_HACK_22 0x8000F3A4

// XEVENT_XDS_HACK_23, 62373, Warning
#define XEVENT_XDS_HACK_23 0x8000F3A5

// XEVENT_XDS_HACK_24, 62374, Warning
#define XEVENT_XDS_HACK_24 0x8000F3A6

// XEVENT_XDS_HACK_25, 62375, Warning
#define XEVENT_XDS_HACK_25 0x8000F3A7

// XEVENT_XDS_HACK_26, 62376, Warning
#define XEVENT_XDS_HACK_26 0x8000F3A8

// XEVENT_XDS_HACK_27, 62377, Warning
#define XEVENT_XDS_HACK_27 0x8000F3A9

// XEVENT_XDS_HACK_28, 62378, Warning
#define XEVENT_XDS_HACK_28 0x8000F3AA

// XEVENT_XDS_HACK_29, 62379, Warning
#define XEVENT_XDS_HACK_29 0x8000F3AB

// XEVENT_XDS_HACK_30, 62380, Warning
#define XEVENT_XDS_HACK_30 0x8000F3AC

// XEVENT_XDS_INFO_0, 62450, Info
#define XEVENT_XDS_INFO_0 0x4000F3F2

// XEVENT_XDS_INFO_1, 62451, Info
#define XEVENT_XDS_INFO_1 0x4000F3F3

// XEVENT_XKDC_FLASH_VERSION_ROLLED_BACK, 10000, Warning
#define XEVENT_XKDC_FLASH_VERSION_ROLLED_BACK 0x80002710

// XEVENT_XKDC_CONSOLE_REGION_CHANGED, 10001, Warning
#define XEVENT_XKDC_CONSOLE_REGION_CHANGED 0x80002711

// XEVENT_XKDC_FLASH_MULTIPLE_GROUPS, 10002, Error
#define XEVENT_XKDC_FLASH_MULTIPLE_GROUPS 0xC0002712

// XEVENT_XKDC_TITLE_MULTIPLE_GROUPS, 10003, Error
#define XEVENT_XKDC_TITLE_MULTIPLE_GROUPS 0xC0002713

// XEVENT_XKDC_SERVICE_ID_INVALID, 10004, Error
#define XEVENT_XKDC_SERVICE_ID_INVALID 0xC0002714

// XEVENT_XKDC_TITLE_BAD_START_END_TIME, 10005, Error
#define XEVENT_XKDC_TITLE_BAD_START_END_TIME 0xC0002715

// XEVENT_XKDC_NO_MEMORY_PARSE_HEX_VALUES, 10006, Error
#define XEVENT_XKDC_NO_MEMORY_PARSE_HEX_VALUES 0xC0002716

// XEVENT_XKDC_FAILURE_PARSE_LEGACY_PC_TITLES, 10007, Error
#define XEVENT_XKDC_FAILURE_PARSE_LEGACY_PC_TITLES 0xC0002717

// XEVENT_XKDC_INVALID_SERVICE_REQUEST_VERSION, 10008, Error
#define XEVENT_XKDC_INVALID_SERVICE_REQUEST_VERSION 0xC0002718

// XEVENT_XKDC_BAD_PARAMETER, 53316, Error
#define XEVENT_XKDC_BAD_PARAMETER 0xC000D044

// XEVENT_XKDC_BAD_PARAMETER_1, 53317, Error
#define XEVENT_XKDC_BAD_PARAMETER_1 0xC000D045

// XEVENT_XKDC_BAD_PARAMETER_2, 53318, Error
#define XEVENT_XKDC_BAD_PARAMETER_2 0xC000D046

// XEVENT_XKDC_BAD_PARAMETER_3, 53319, Error
#define XEVENT_XKDC_BAD_PARAMETER_3 0xC000D047

// XEVENT_KDC_CODE_95, 53320, Error
#define XEVENT_KDC_CODE_95 0xC000D048

// XEVENT_KDC_CODE_96, 53321, Error
#define XEVENT_KDC_CODE_96 0xC000D049

// XEVENT_XKDC_NO_MEMORY, 53322, Error
#define XEVENT_XKDC_NO_MEMORY 0xC000D04A

// XEVENT_XKDC_NO_MEMORY_1, 53323, Error
#define XEVENT_XKDC_NO_MEMORY_1 0xC000D04B

// XEVENT_KDC_CODE_99, 53324, Error
#define XEVENT_KDC_CODE_99 0xC000D04C

// XEVENT_XKDC_BAD_PARAMETER_4, 53325, Error
#define XEVENT_XKDC_BAD_PARAMETER_4 0xC000D04D

// XEVENT_XKDC_CHECKSUM_OVERFLOW, 53326, Error
#define XEVENT_XKDC_CHECKSUM_OVERFLOW 0xC000D04E

// XEVENT_XKDC_NO_MEMORY_2, 53327, Error
#define XEVENT_XKDC_NO_MEMORY_2 0xC000D04F

// XEVENT_XKDC_NO_MEMORY_3, 53328, Error
#define XEVENT_XKDC_NO_MEMORY_3 0xC000D050

// XEVENT_XKDC_NO_MEMORY_4, 53329, Error
#define XEVENT_XKDC_NO_MEMORY_4 0xC000D051

// XEVENT_XKDC_NO_MEMORY_5, 53330, Error
#define XEVENT_XKDC_NO_MEMORY_5 0xC000D052

// XEVENT_XKDC_BAD_PARAMETER_5, 53331, Error
#define XEVENT_XKDC_BAD_PARAMETER_5 0xC000D053

// XEVENT_XKDC_BAD_PARAMETER_6, 53332, Error
#define XEVENT_XKDC_BAD_PARAMETER_6 0xC000D054

// XEVENT_KDC_CODE_108, 53333, Error
#define XEVENT_KDC_CODE_108 0xC000D055

// XEVENT_XKDC_BAD_PARAMETER_7, 53334, Error
#define XEVENT_XKDC_BAD_PARAMETER_7 0xC000D056

// XEVENT_XKDC_WSREADER_ERROR, 53335, Error
#define XEVENT_XKDC_WSREADER_ERROR 0xC000D057

// XEVENT_XKDC_WSREADER_ERROR_1, 53336, Error
#define XEVENT_XKDC_WSREADER_ERROR_1 0xC000D058

// XEVENT_XKDC_WSREADER_ERROR_2, 53337, Error
#define XEVENT_XKDC_WSREADER_ERROR_2 0xC000D059

// XEVENT_XKDC_WSREADER_ERROR_3, 53338, Error
#define XEVENT_XKDC_WSREADER_ERROR_3 0xC000D05A

// XEVENT_XKDC_WSREADER_ERROR_4, 53339, Error
#define XEVENT_XKDC_WSREADER_ERROR_4 0xC000D05B

// XEVENT_XKDC_WSREADER_ERROR_5, 53340, Error
#define XEVENT_XKDC_WSREADER_ERROR_5 0xC000D05C

// XEVENT_XKDC_WSREADER_ERROR_6, 53341, Error
#define XEVENT_XKDC_WSREADER_ERROR_6 0xC000D05D

// XEVENT_XKDC_UODB_MISMATCH, 53342, Error
#define XEVENT_XKDC_UODB_MISMATCH 0xC000D05E

// XEVENT_XKDC_WSREADER_ERROR_7, 53343, Error
#define XEVENT_XKDC_WSREADER_ERROR_7 0xC000D05F

// XEVENT_XKDC_WSREADER_ERROR_8, 53344, Error
#define XEVENT_XKDC_WSREADER_ERROR_8 0xC000D060

// XEVENT_XKDC_WSREADER_ERROR_9, 53345, Error
#define XEVENT_XKDC_WSREADER_ERROR_9 0xC000D061

// XEVENT_XKDC_WSREADER_ERROR_10, 53346, Error
#define XEVENT_XKDC_WSREADER_ERROR_10 0xC000D062

// XEVENT_KDC_CODE_125, 53350, Error
#define XEVENT_KDC_CODE_125 0xC000D066

// XEVENT_XKDC_BAD_PARAMETER_8, 53351, Error
#define XEVENT_XKDC_BAD_PARAMETER_8 0xC000D067

// XEVENT_XKDC_BAD_PARAMETER_9, 53352, Error
#define XEVENT_XKDC_BAD_PARAMETER_9 0xC000D068

// XEVENT_KDC_CODE_128, 53353, Error
#define XEVENT_KDC_CODE_128 0xC000D069

// XEVENT_XKDC_BAD_PARAMETER_10, 53354, Error
#define XEVENT_XKDC_BAD_PARAMETER_10 0xC000D06A

// XEVENT_XKDC_BAD_PARAMETER_11, 53355, Error
#define XEVENT_XKDC_BAD_PARAMETER_11 0xC000D06B

// XEVENT_ASKDC_NO_MEMORY_30, 53356, Error
#define XEVENT_ASKDC_NO_MEMORY_30 0xC000D06C

// XEVENT_KDC_CODE_132, 53357, Error
#define XEVENT_KDC_CODE_132 0xC000D06D

// XEVENT_KDC_CODE_133, 53358, Error
#define XEVENT_KDC_CODE_133 0xC000D06E

// XEVENT_XKDC_POLICY_BAD_PARAMETER, 53359, Error
#define XEVENT_XKDC_POLICY_BAD_PARAMETER 0xC000D06F

// XEVENT_XKDC_DB_GETMACHINEAUTH_NOTFOUND, 53360, Error
#define XEVENT_XKDC_DB_GETMACHINEAUTH_NOTFOUND 0xC000D070

// XEVENT_XKDC_DB_GETUSERAUTH_NOTFOUND, 53361, Error
#define XEVENT_XKDC_DB_GETUSERAUTH_NOTFOUND 0xC000D071

// XEVENT_XKDC_DB_GETMACHINEAUTH_ERROR, 53362, Error
#define XEVENT_XKDC_DB_GETMACHINEAUTH_ERROR 0xC000D072

// XEVENT_XKDC_DB_GETUSERAUTH_ERROR, 53363, Error
#define XEVENT_XKDC_DB_GETUSERAUTH_ERROR 0xC000D073

// XEVENT_XKDC_DOSCACHE_NORECORD, 53364, Error
#define XEVENT_XKDC_DOSCACHE_NORECORD 0xC000D074

// XEVENT_XKDC_DOSCACHE_RELEASE_ERROR, 53365, Error
#define XEVENT_XKDC_DOSCACHE_RELEASE_ERROR 0xC000D075

// XEVENT_XKDC_BAD_PARAMETER_12, 53417, Error
#define XEVENT_XKDC_BAD_PARAMETER_12 0xC000D0A9

// XEVENT_XKDC_BAD_PARAMETER_13, 53418, Error
#define XEVENT_XKDC_BAD_PARAMETER_13 0xC000D0AA

// XEVENT_XKDC_BAD_PARAMETER_14, 53419, Error
#define XEVENT_XKDC_BAD_PARAMETER_14 0xC000D0AB

// XEVENT_KDC_CODE_195, 53420, Error
#define XEVENT_KDC_CODE_195 0xC000D0AC

// XEVENT_XKDC_BAD_PARAMETER_15, 53421, Error
#define XEVENT_XKDC_BAD_PARAMETER_15 0xC000D0AD

// XEVENT_KDC_CODE_197, 53422, Error
#define XEVENT_KDC_CODE_197 0xC000D0AE

// XEVENT_KDC_CODE_198, 53423, Error
#define XEVENT_KDC_CODE_198 0xC000D0AF

// XEVENT_XKDC_BAD_PARAMETER_16, 53424, Error
#define XEVENT_XKDC_BAD_PARAMETER_16 0xC000D0B0

// XEVENT_KDC_CODE_200, 53425, Error
#define XEVENT_KDC_CODE_200 0xC000D0B1

// XEVENT_KDC_CODE_201, 53426, Error
#define XEVENT_KDC_CODE_201 0xC000D0B2

// XEVENT_XKDC_NO_MEMORY_6, 53427, Error
#define XEVENT_XKDC_NO_MEMORY_6 0xC000D0B3

// XEVENT_KDC_CODE_203, 53428, Error
#define XEVENT_KDC_CODE_203 0xC000D0B4

// XEVENT_KDC_CODE_204, 53429, Error
#define XEVENT_KDC_CODE_204 0xC000D0B5

// XEVENT_XKDC_BAD_PARAMETER_17, 53430, Error
#define XEVENT_XKDC_BAD_PARAMETER_17 0xC000D0B6

// XEVENT_XKDC_BAD_PARAMETER_18, 53431, Error
#define XEVENT_XKDC_BAD_PARAMETER_18 0xC000D0B7

// XEVENT_KDC_CODE_207, 53432, Error
#define XEVENT_KDC_CODE_207 0xC000D0B8

// XEVENT_XKDC_BAD_PARAMETER_19, 53433, Error
#define XEVENT_XKDC_BAD_PARAMETER_19 0xC000D0B9

// XEVENT_XKDC_BAD_PARAMETER_20, 53434, Error
#define XEVENT_XKDC_BAD_PARAMETER_20 0xC000D0BA

// XEVENT_XKDC_NO_MEMORY_7, 53435, Error
#define XEVENT_XKDC_NO_MEMORY_7 0xC000D0BB

// XEVENT_XKDC_NO_MEMORY_8, 53436, Error
#define XEVENT_XKDC_NO_MEMORY_8 0xC000D0BC

// XEVENT_XKDC_NO_MEMORY_9, 53437, Error
#define XEVENT_XKDC_NO_MEMORY_9 0xC000D0BD

// XEVENT_KDC_CODE_213, 53438, Error
#define XEVENT_KDC_CODE_213 0xC000D0BE

// XEVENT_XKDC_NO_MEMORY_10, 53439, Error
#define XEVENT_XKDC_NO_MEMORY_10 0xC000D0BF

// XEVENT_KDC_CODE_215, 53440, Error
#define XEVENT_KDC_CODE_215 0xC000D0C0

// XEVENT_KDC_CODE_216, 53441, Error
#define XEVENT_KDC_CODE_216 0xC000D0C1

// XEVENT_KDC_CODE_217, 53442, Error
#define XEVENT_KDC_CODE_217 0xC000D0C2

// XEVENT_KDC_CODE_218, 53443, Error
#define XEVENT_KDC_CODE_218 0xC000D0C3

// XEVENT_KDC_CODE_219, 53444, Error
#define XEVENT_KDC_CODE_219 0xC000D0C4

// XEVENT_KDC_CODE_220, 53445, Error
#define XEVENT_KDC_CODE_220 0xC000D0C5

// XEVENT_KDC_CODE_221, 53446, Error
#define XEVENT_KDC_CODE_221 0xC000D0C6

// XEVENT_KDC_CODE_222, 53447, Error
#define XEVENT_KDC_CODE_222 0xC000D0C7

// XEVENT_XKDC_BAD_PARAMETER_21, 53448, Error
#define XEVENT_XKDC_BAD_PARAMETER_21 0xC000D0C8

// XEVENT_KDC_CODE_224, 53449, Error
#define XEVENT_KDC_CODE_224 0xC000D0C9

// XEVENT_KDC_CODE_225, 53450, Error
#define XEVENT_KDC_CODE_225 0xC000D0CA

// XEVENT_KDC_CODE_226, 53451, Error
#define XEVENT_KDC_CODE_226 0xC000D0CB

// XEVENT_KDC_CODE_227, 53452, Error
#define XEVENT_KDC_CODE_227 0xC000D0CC

// XEVENT_KDC_CODE_228, 53453, Error
#define XEVENT_KDC_CODE_228 0xC000D0CD

// XEVENT_KDC_CODE_229, 53454, Error
#define XEVENT_KDC_CODE_229 0xC000D0CE

// XEVENT_KDC_CODE_230, 53455, Error
#define XEVENT_KDC_CODE_230 0xC000D0CF

// XEVENT_KDC_CODE_231, 53456, Error
#define XEVENT_KDC_CODE_231 0xC000D0D0

// XEVENT_KDC_CODE_232, 53457, Error
#define XEVENT_KDC_CODE_232 0xC000D0D1

// XEVENT_KDC_CODE_233, 53458, Error
#define XEVENT_KDC_CODE_233 0xC000D0D2

// XEVENT_KDC_CODE_234, 53459, Error
#define XEVENT_KDC_CODE_234 0xC000D0D3

// XEVENT_KDC_CODE_235, 53460, Error
#define XEVENT_KDC_CODE_235 0xC000D0D4

// XEVENT_KDC_CODE_236, 53461, Error
#define XEVENT_KDC_CODE_236 0xC000D0D5

// XEVENT_XKDC_BAD_PARAMETER_22, 53462, Error
#define XEVENT_XKDC_BAD_PARAMETER_22 0xC000D0D6

// XEVENT_XKDC_NO_MEMORY_11, 53463, Error
#define XEVENT_XKDC_NO_MEMORY_11 0xC000D0D7

// XEVENT_KDC_CODE_239, 53464, Error
#define XEVENT_KDC_CODE_239 0xC000D0D8

// XEVENT_KDC_CODE_240, 53465, Error
#define XEVENT_KDC_CODE_240 0xC000D0D9

// XEVENT_KDC_CODE_241, 53466, Error
#define XEVENT_KDC_CODE_241 0xC000D0DA

// XEVENT_ASKDC_NO_MEMORY_31, 53467, Error
#define XEVENT_ASKDC_NO_MEMORY_31 0xC000D0DB

// XEVENT_XKDC_WSREADER_ERROR_11, 53468, Error
#define XEVENT_XKDC_WSREADER_ERROR_11 0xC000D0DC

// XEVENT_XKDC_NO_MEMORY_12, 53469, Error
#define XEVENT_XKDC_NO_MEMORY_12 0xC000D0DD

// XEVENT_XKDC_WSREADER_ERROR_12, 53470, Error
#define XEVENT_XKDC_WSREADER_ERROR_12 0xC000D0DE

// XEVENT_XKDC_UODB_MISMATCH_1, 53471, Error
#define XEVENT_XKDC_UODB_MISMATCH_1 0xC000D0DF

// XEVENT_XKDC_WSREADER_ERROR_13, 53472, Error
#define XEVENT_XKDC_WSREADER_ERROR_13 0xC000D0E0

// XEVENT_XKDC_NO_MEMORY_13, 53473, Error
#define XEVENT_XKDC_NO_MEMORY_13 0xC000D0E1

// XEVENT_XKDC_UODB_MISMATCH_2, 53474, Error
#define XEVENT_XKDC_UODB_MISMATCH_2 0xC000D0E2

// XEVENT_KDC_CODE_250, 53475, Error
#define XEVENT_KDC_CODE_250 0xC000D0E3

// XEVENT_KDC_CODE_251, 53476, Error
#define XEVENT_KDC_CODE_251 0xC000D0E4

// XEVENT_ASKDC_NO_MEMORY_32, 53477, Error
#define XEVENT_ASKDC_NO_MEMORY_32 0xC000D0E5

// XEVENT_XKDC_WSREADER_ERROR_14, 53478, Error
#define XEVENT_XKDC_WSREADER_ERROR_14 0xC000D0E6

// XEVENT_XKDC_NO_MEMORY_14, 53479, Error
#define XEVENT_XKDC_NO_MEMORY_14 0xC000D0E7

// XEVENT_XKDC_WSREADER_ERROR_15, 53480, Error
#define XEVENT_XKDC_WSREADER_ERROR_15 0xC000D0E8

// XEVENT_XKDC_UODB_MISMATCH_3, 53481, Error
#define XEVENT_XKDC_UODB_MISMATCH_3 0xC000D0E9

// XEVENT_XKDC_WSREADER_ERROR_16, 53482, Error
#define XEVENT_XKDC_WSREADER_ERROR_16 0xC000D0EA

// XEVENT_XKDC_NO_MEMORY_15, 53483, Error
#define XEVENT_XKDC_NO_MEMORY_15 0xC000D0EB

// XEVENT_KDC_CODE_259, 53484, Error
#define XEVENT_KDC_CODE_259 0xC000D0EC

// XEVENT_XKDC_WSREADER_ERROR_17, 53485, Error
#define XEVENT_XKDC_WSREADER_ERROR_17 0xC000D0ED

// XEVENT_XKDC_WSREADER_ERROR_18, 53486, Error
#define XEVENT_XKDC_WSREADER_ERROR_18 0xC000D0EE

// XEVENT_XKDC_WSREADER_ERROR_19, 53487, Error
#define XEVENT_XKDC_WSREADER_ERROR_19 0xC000D0EF

// XEVENT_XKDC_WSREADER_ERROR_20, 53488, Error
#define XEVENT_XKDC_WSREADER_ERROR_20 0xC000D0F0

// XEVENT_XKDC_WSREADER_ERROR_21, 53489, Error
#define XEVENT_XKDC_WSREADER_ERROR_21 0xC000D0F1

// XEVENT_XKDC_WSREADER_ERROR_22, 53490, Error
#define XEVENT_XKDC_WSREADER_ERROR_22 0xC000D0F2

// XEVENT_XKDC_WSREADER_ERROR_23, 53491, Error
#define XEVENT_XKDC_WSREADER_ERROR_23 0xC000D0F3

// XEVENT_XKDC_WSREADER_ERROR_24, 53492, Error
#define XEVENT_XKDC_WSREADER_ERROR_24 0xC000D0F4

// XEVENT_XKDC_WSREADER_ERROR_25, 53493, Error
#define XEVENT_XKDC_WSREADER_ERROR_25 0xC000D0F5

// XEVENT_XKDC_WSREADER_ERROR_26, 53494, Error
#define XEVENT_XKDC_WSREADER_ERROR_26 0xC000D0F6

// XEVENT_XKDC_WSREADER_ERROR_27, 53495, Error
#define XEVENT_XKDC_WSREADER_ERROR_27 0xC000D0F7

// XEVENT_XKDC_WSREADER_ERROR_28, 53496, Error
#define XEVENT_XKDC_WSREADER_ERROR_28 0xC000D0F8

// XEVENT_XKDC_WSREADER_ERROR_29, 53497, Error
#define XEVENT_XKDC_WSREADER_ERROR_29 0xC000D0F9

// XEVENT_XKDC_WSREADER_ERROR_30, 53498, Error
#define XEVENT_XKDC_WSREADER_ERROR_30 0xC000D0FA

// XEVENT_XKDC_WSREADER_ERROR_31, 53499, Error
#define XEVENT_XKDC_WSREADER_ERROR_31 0xC000D0FB

// XEVENT_XKDC_WSREADER_ERROR_32, 53500, Error
#define XEVENT_XKDC_WSREADER_ERROR_32 0xC000D0FC

// XEVENT_XKDC_WSREADER_ERROR_33, 53501, Error
#define XEVENT_XKDC_WSREADER_ERROR_33 0xC000D0FD

// XEVENT_XKDC_WSREADER_ERROR_34, 53502, Error
#define XEVENT_XKDC_WSREADER_ERROR_34 0xC000D0FE

// XEVENT_KDC_CODE_278, 53503, Error
#define XEVENT_KDC_CODE_278 0xC000D0FF

// XEVENT_XKDC_WSREADER_ERROR_35, 53504, Error
#define XEVENT_XKDC_WSREADER_ERROR_35 0xC000D100

// XEVENT_XKDC_WSREADER_ERROR_36, 53505, Error
#define XEVENT_XKDC_WSREADER_ERROR_36 0xC000D101

// XEVENT_XKDC_WSREADER_ERROR_37, 53506, Error
#define XEVENT_XKDC_WSREADER_ERROR_37 0xC000D102

// XEVENT_XKDC_WSREADER_ERROR_38, 53507, Error
#define XEVENT_XKDC_WSREADER_ERROR_38 0xC000D103

// XEVENT_XKDC_WSREADER_ERROR_39, 53508, Error
#define XEVENT_XKDC_WSREADER_ERROR_39 0xC000D104

// XEVENT_XKDC_WSREADER_ERROR_40, 53509, Error
#define XEVENT_XKDC_WSREADER_ERROR_40 0xC000D105

// XEVENT_XKDC_NO_MEMORY_16, 53510, Error
#define XEVENT_XKDC_NO_MEMORY_16 0xC000D106

// XEVENT_KDC_CODE_286, 53511, Error
#define XEVENT_KDC_CODE_286 0xC000D107

// XEVENT_KDC_CODE_287, 53512, Error
#define XEVENT_KDC_CODE_287 0xC000D108

// XEVENT_XKDC_BAD_PARAMETER_23, 53513, Error
#define XEVENT_XKDC_BAD_PARAMETER_23 0xC000D109

// XEVENT_KDC_CODE_289, 53514, Error
#define XEVENT_KDC_CODE_289 0xC000D10A

// XEVENT_KDC_CODE_290, 53515, Error
#define XEVENT_KDC_CODE_290 0xC000D10B

// XEVENT_XKDC_BAD_PARAMETER_24, 53516, Error
#define XEVENT_XKDC_BAD_PARAMETER_24 0xC000D10C

// XEVENT_KDC_CODE_292, 53517, Error
#define XEVENT_KDC_CODE_292 0xC000D10D

// XEVENT_XKDC_BAD_PARAMETER_25, 53518, Error
#define XEVENT_XKDC_BAD_PARAMETER_25 0xC000D10E

// XEVENT_XKDC_NO_MEMORY_17, 53519, Error
#define XEVENT_XKDC_NO_MEMORY_17 0xC000D10F

// XEVENT_XKDC_BAD_PARAMETER_26, 53520, Error
#define XEVENT_XKDC_BAD_PARAMETER_26 0xC000D110

// XEVENT_XKDC_BAD_PARAMETER_27, 53521, Error
#define XEVENT_XKDC_BAD_PARAMETER_27 0xC000D111

// XEVENT_XKDC_CODE_TOO_MANY_DWORD_SERVICES, 53671, Error
#define XEVENT_XKDC_CODE_TOO_MANY_DWORD_SERVICES 0xC000D1A7

// XEVENT_XKDC_REQUEST_INVALID_1, 53677, Error
#define XEVENT_XKDC_REQUEST_INVALID_1 0xC000D1AD

// XEVENT_XKDC_INIT_WARNING, 54225, Error
#define XEVENT_XKDC_INIT_WARNING 0xC000D3D1

// XEVENT_XKDC_INIT_WARNING_1, 54226, Error
#define XEVENT_XKDC_INIT_WARNING_1 0xC000D3D2

// XEVENT_XKDC_RELOAD_FAIL, 54234, Error
#define XEVENT_XKDC_RELOAD_FAIL 0xC000D3DA

// XEVENT_KDC_CONFIG_32, 54282, Error
#define XEVENT_KDC_CONFIG_32 0xC000D40A

// XEVENT_XKDC_DOS_CACHE_TOO_SMALL, 54283, Error
#define XEVENT_XKDC_DOS_CACHE_TOO_SMALL 0xC000D40B

// XEVENT_XKDC_DOS_CACHE_TOO_SMALL_1, 54284, Error
#define XEVENT_XKDC_DOS_CACHE_TOO_SMALL_1 0xC000D40C

// XEVENT_XKDC_UNKNOWN_XBOX, 54285, Warning
#define XEVENT_XKDC_UNKNOWN_XBOX 0x8000D40D

// XEVENT_KDC_CONFIG_36, 54286, Error
#define XEVENT_KDC_CONFIG_36 0xC000D40E

// XEVENT_KDC_CONFIG_37, 54287, Error
#define XEVENT_KDC_CONFIG_37 0xC000D40F

// XEVENT_DEPRECATED_XKDC_BAD_TITLEID, 54288, Error
#define XEVENT_DEPRECATED_XKDC_BAD_TITLEID 0xC000D410

// XEVENT_KDC_CONFIG_39, 54289, Error
#define XEVENT_KDC_CONFIG_39 0xC000D411

// XEVENT_KDC_CONFIG_40, 54290, Error
#define XEVENT_KDC_CONFIG_40 0xC000D412

// XEVENT_XKDC_REGISTER_FAILURE, 54291, Error
#define XEVENT_XKDC_REGISTER_FAILURE 0xC000D413

// XEVENT_XKDC_REGISTER_FAILURE_1, 54292, Error
#define XEVENT_XKDC_REGISTER_FAILURE_1 0xC000D414

// XEVENT_XKDC_REGISTER_FAILURE_2, 54293, Error
#define XEVENT_XKDC_REGISTER_FAILURE_2 0xC000D415

// XEVENT_XKDC_REGISTER_FAILURE_3, 54294, Error
#define XEVENT_XKDC_REGISTER_FAILURE_3 0xC000D416

// XEVENT_KDC_CONFIG_45, 54295, Error
#define XEVENT_KDC_CONFIG_45 0xC000D417

// XEVENT_XKDC_INIT_FAILURE, 54296, Error
#define XEVENT_XKDC_INIT_FAILURE 0xC000D418

// XEVENT_XKDC_INIT_FAILURE_1, 54297, Error
#define XEVENT_XKDC_INIT_FAILURE_1 0xC000D419

// XEVENT_KDC_CONFIG_48, 54298, Error
#define XEVENT_KDC_CONFIG_48 0xC000D41A

// XEVENT_XKDC_INIT_FAILURE_2, 54299, Error
#define XEVENT_XKDC_INIT_FAILURE_2 0xC000D41B

// XEVENT_XKDC_INIT_FAILURE_3, 54300, Error
#define XEVENT_XKDC_INIT_FAILURE_3 0xC000D41C

// XEVENT_DEPRECATED_XKDC_INIT_FAILURE_4, 54301, Error
#define XEVENT_DEPRECATED_XKDC_INIT_FAILURE_4 0xC000D41D

// XEVENT_XKDC_BAD_TITLEID_1, 54302, Error
#define XEVENT_XKDC_BAD_TITLEID_1 0xC000D41E

// XEVENT_KDC_CONFIG_53, 54303, Error
#define XEVENT_KDC_CONFIG_53 0xC000D41F

// XEVENT_XKDC_DECRYPTION_FAILED, 54304, Error
#define XEVENT_XKDC_DECRYPTION_FAILED 0xC000D420

// XEVENT_XKDC_MISMATCHED_CLIENT_VERSION, 54371, Error
#define XEVENT_XKDC_MISMATCHED_CLIENT_VERSION 0xC000D463

// XEVENT_XKDC_DYNAMIC_CONFIG_INIT_ERROR, 54374, Error
#define XEVENT_XKDC_DYNAMIC_CONFIG_INIT_ERROR 0xC000D466

// XEVENT_XKDC_NO_MEMORY_18, 54375, Error
#define XEVENT_XKDC_NO_MEMORY_18 0xC000D467

// XEVENT_XKDC_FAILED_TO_LOAD_SERVICE_PRINCIPAL_IPSTR, 54376, Error
#define XEVENT_XKDC_FAILED_TO_LOAD_SERVICE_PRINCIPAL_IPSTR 0xC000D468

// XEVENT_XKDC_FAILED_TO_LOAD_SERVICE_PRINCIPAL_IP, 54377, Error
#define XEVENT_XKDC_FAILED_TO_LOAD_SERVICE_PRINCIPAL_IP 0xC000D469

// XEVENT_XKDC_FAILED_TO_LOAD_SERVICE_PRINCIPAL_NONE, 54378, Error
#define XEVENT_XKDC_FAILED_TO_LOAD_SERVICE_PRINCIPAL_NONE 0xC000D46A

// XEVENT_XKDC_FAILED_TO_PARSE_SITE1_IPSTR, 54379, Error
#define XEVENT_XKDC_FAILED_TO_PARSE_SITE1_IPSTR 0xC000D46B

// XEVENT_XKDC_FAILED_TO_PARSE_SITE1_IP, 54380, Error
#define XEVENT_XKDC_FAILED_TO_PARSE_SITE1_IP 0xC000D46C

// XEVENT_XKDC_INFO_SITE1_IPS, 54381, Info
#define XEVENT_XKDC_INFO_SITE1_IPS 0x4000D46D

// XEVENT_XKDC_NO_MEMORY_SITE1_IPS, 54382, Error
#define XEVENT_XKDC_NO_MEMORY_SITE1_IPS 0xC000D46E

// XEVENT_KDC_HACK_9, 54659, Warning
#define XEVENT_KDC_HACK_9 0x8000D583

// XEVENT_KDC_HACK_10, 54660, Warning
#define XEVENT_KDC_HACK_10 0x8000D584

// XEVENT_KDC_HACK_11, 54661, Warning
#define XEVENT_KDC_HACK_11 0x8000D585

// XEVENT_KDC_HACK_12, 54662, Warning
#define XEVENT_KDC_HACK_12 0x8000D586

// XEVENT_KDC_HACK_13, 54663, Warning
#define XEVENT_KDC_HACK_13 0x8000D587

// XEVENT_XKDC_NO_SERVICES, 54664, Warning
#define XEVENT_XKDC_NO_SERVICES 0x8000D588

// XEVENT_KDC_HACK_15, 54665, Warning
#define XEVENT_KDC_HACK_15 0x8000D589

// XEVENT_KDC_HACK_16, 54666, Warning
#define XEVENT_KDC_HACK_16 0x8000D58A

// XEVENT_XKDC_AS_REQUEST, 54667, Warning
#define XEVENT_XKDC_AS_REQUEST 0x8000D58B

// XEVENT_KDC_HACK_18, 54668, Warning
#define XEVENT_KDC_HACK_18 0x8000D58C

// XEVENT_XKDC_BAD_REQUEST, 54669, Warning
#define XEVENT_XKDC_BAD_REQUEST 0x8000D58D

// XEVENT_XKDC_NO_SERVICES_1, 54670, Warning
#define XEVENT_XKDC_NO_SERVICES_1 0x8000D58E

// XEVENT_KDC_HACK_21, 54671, Warning
#define XEVENT_KDC_HACK_21 0x8000D58F

// XEVENT_KDC_HACK_22, 54672, Warning
#define XEVENT_KDC_HACK_22 0x8000D590

// XEVENT_KDC_HACK_23, 54673, Warning
#define XEVENT_KDC_HACK_23 0x8000D591

// XEVENT_KDC_HACK_24, 54674, Warning
#define XEVENT_KDC_HACK_24 0x8000D592

// XEVENT_XKDC_AS_REQUEST_1, 54675, Warning
#define XEVENT_XKDC_AS_REQUEST_1 0x8000D593

// XEVENT_KDC_HACK_26, 54676, Warning
#define XEVENT_KDC_HACK_26 0x8000D594

// XEVENT_KDC_HACK_27, 54677, Warning
#define XEVENT_KDC_HACK_27 0x8000D595

// XEVENT_KDC_HACK_28, 54678, Warning
#define XEVENT_KDC_HACK_28 0x8000D596

// XEVENT_KDC_HACK_29, 54679, Warning
#define XEVENT_KDC_HACK_29 0x8000D597

// XEVENT_XKDC_HACK_DOS_ATTACK, 54708, Warning
#define XEVENT_XKDC_HACK_DOS_ATTACK 0x8000D5B4

// XEVENT_XKDC_HACK_INVALID_PRE_AUTH_TYPE, 54714, Warning
#define XEVENT_XKDC_HACK_INVALID_PRE_AUTH_TYPE 0x8000D5BA

// XEVENT_XKDC_REGISTER_SUCCESS, 54760, Info
#define XEVENT_XKDC_REGISTER_SUCCESS 0x4000D5E8

// XEVENT_XKDC_REGISTER_SUCCESS_1, 54761, Info
#define XEVENT_XKDC_REGISTER_SUCCESS_1 0x4000D5E9

// XEVENT_XKDC_INIT_SUCCESS, 54762, Info
#define XEVENT_XKDC_INIT_SUCCESS 0x4000D5EA

// XEVENT_XKDC_TERM_SUCCESS, 54763, Info
#define XEVENT_XKDC_TERM_SUCCESS 0x4000D5EB

// XEVENT_XKDC_RELOAD_SUCCESS, 54764, Info
#define XEVENT_XKDC_RELOAD_SUCCESS 0x4000D5EC

// XEVENT_KDC_INFO_15, 54765, Info
#define XEVENT_KDC_INFO_15 0x4000D5ED

// XEVENT_XMACS_FAILED_TO_GET_USER_ID_FOR_PASSPORT_ID, 10000, Warning
#define XEVENT_XMACS_FAILED_TO_GET_USER_ID_FOR_PASSPORT_ID 0x80002710

// XEVENT_XMACS_DB_USE_VOUCHER_ERROR, 10001, Error
#define XEVENT_XMACS_DB_USE_VOUCHER_ERROR 0xC0002711

// XEVENT_XMACS_DB_ACTIVATE_MACHINE_ERROR, 10002, Error
#define XEVENT_XMACS_DB_ACTIVATE_MACHINE_ERROR 0xC0002712

// XEVENT_XMACS_DB_ACTIVATE_USER_ERROR, 10003, Error
#define XEVENT_XMACS_DB_ACTIVATE_USER_ERROR 0xC0002713

// XEVENT_XMACS_WSREADER_ERROR_1, 10004, Error
#define XEVENT_XMACS_WSREADER_ERROR_1 0xC0002714

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING, 53522, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING 0xC000D112

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_1, 53523, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_1 0xC000D113

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_2, 53524, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_2 0xC000D114

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_3, 53525, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_3 0xC000D115

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_4, 53526, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_4 0xC000D116

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_5, 53527, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_5 0xC000D117

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_6, 53528, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_6 0xC000D118

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_7, 53529, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_7 0xC000D119

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_8, 53530, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_8 0xC000D11A

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_9, 53531, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_9 0xC000D11B

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_10, 53532, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_10 0xC000D11C

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_11, 53533, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_11 0xC000D11D

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_12, 53534, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_12 0xC000D11E

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_13, 53535, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_13 0xC000D11F

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_14, 53536, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_14 0xC000D120

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_15, 53537, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_15 0xC000D121

// XEVENT_XMACS_PREAUTH_DATA_CORRUPTION_WARNING, 53538, Error
#define XEVENT_XMACS_PREAUTH_DATA_CORRUPTION_WARNING 0xC000D122

// XEVENT_XMACS_PREAUTH_DATA_CORRUPTION_WARNING_1, 53539, Error
#define XEVENT_XMACS_PREAUTH_DATA_CORRUPTION_WARNING_1 0xC000D123

// XEVENT_KDC_CODE_315, 53540, Error
#define XEVENT_KDC_CODE_315 0xC000D124

// XEVENT_KDC_CODE_316, 53541, Error
#define XEVENT_KDC_CODE_316 0xC000D125

// XEVENT_KDC_CODE_317, 53542, Error
#define XEVENT_KDC_CODE_317 0xC000D126

// XEVENT_KDC_CODE_318, 53543, Error
#define XEVENT_KDC_CODE_318 0xC000D127

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_16, 53544, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_16 0xC000D128

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_17, 53545, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_17 0xC000D129

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_18, 53546, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_18 0xC000D12A

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_19, 53547, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_19 0xC000D12B

// XEVENT_KDC_CODE_323, 53548, Error
#define XEVENT_KDC_CODE_323 0xC000D12C

// XEVENT_KDC_CODE_324, 53549, Error
#define XEVENT_KDC_CODE_324 0xC000D12D

// XEVENT_KDC_CODE_325, 53550, Error
#define XEVENT_KDC_CODE_325 0xC000D12E

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_20, 53551, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_20 0xC000D12F

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_21, 53552, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_21 0xC000D130

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_22, 53553, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_22 0xC000D131

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_23, 53554, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_23 0xC000D132

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_24, 53555, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_24 0xC000D133

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_25, 53556, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_25 0xC000D134

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_26, 53557, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_26 0xC000D135

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_27, 53558, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_27 0xC000D136

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_28, 53559, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_28 0xC000D137

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_29, 53560, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_29 0xC000D138

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_30, 53561, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_30 0xC000D139

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_31, 53562, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_31 0xC000D13A

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_32, 53563, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_32 0xC000D13B

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_33, 53564, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_33 0xC000D13C

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_34, 53565, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_34 0xC000D13D

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_35, 53566, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_35 0xC000D13E

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_36, 53567, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_36 0xC000D13F

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_37, 53568, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_37 0xC000D140

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_38, 53569, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_38 0xC000D141

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_39, 53570, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_39 0xC000D142

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_40, 53571, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_40 0xC000D143

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_41, 53572, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_41 0xC000D144

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_42, 53573, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_42 0xC000D145

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_43, 53574, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_43 0xC000D146

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_44, 53575, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_44 0xC000D147

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_45, 53576, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_45 0xC000D148

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_46, 53577, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_46 0xC000D149

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_47, 53578, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_47 0xC000D14A

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_48, 53579, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_48 0xC000D14B

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_49, 53580, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_49 0xC000D14C

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_50, 53581, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_50 0xC000D14D

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_51, 53582, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_51 0xC000D14E

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_52, 53583, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_52 0xC000D14F

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_53, 53584, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_53 0xC000D150

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_54, 53585, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_54 0xC000D151

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_55, 53586, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_55 0xC000D152

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_56, 53587, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_56 0xC000D153

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_57, 53588, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_57 0xC000D154

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_58, 53589, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_58 0xC000D155

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_59, 53590, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_59 0xC000D156

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_60, 53591, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_60 0xC000D157

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_61, 53592, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_61 0xC000D158

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_62, 53593, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_62 0xC000D159

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_63, 53594, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_63 0xC000D15A

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_64, 53595, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_64 0xC000D15B

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_65, 53596, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_65 0xC000D15C

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_66, 53597, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_66 0xC000D15D

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_67, 53598, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_67 0xC000D15E

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_68, 53599, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_68 0xC000D15F

// XEVENT_XMACS_UPDATE_SEQUENCE_NUMBER_FAILURE, 53600, Error
#define XEVENT_XMACS_UPDATE_SEQUENCE_NUMBER_FAILURE 0xC000D160

// XEVENT_XMACS_UPDATE_SEQUENCE_NUMBER_FAILURE_1, 53601, Error
#define XEVENT_XMACS_UPDATE_SEQUENCE_NUMBER_FAILURE_1 0xC000D161

// XEVENT_KDC_CODE_377, 53602, Error
#define XEVENT_KDC_CODE_377 0xC000D162

// XEVENT_KDC_CODE_378, 53603, Error
#define XEVENT_KDC_CODE_378 0xC000D163

// XEVENT_KDC_CODE_379, 53604, Error
#define XEVENT_KDC_CODE_379 0xC000D164

// XEVENT_KDC_CODE_380, 53605, Error
#define XEVENT_KDC_CODE_380 0xC000D165

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_69, 53606, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_69 0xC000D166

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_70, 53607, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_70 0xC000D167

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_71, 53608, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_71 0xC000D168

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_72, 53609, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_72 0xC000D169

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_73, 53610, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_73 0xC000D16A

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_74, 53611, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_74 0xC000D16B

// XEVENT_XMACS_HASH_TABLE_RESOURCE_WARNING, 53612, Error
#define XEVENT_XMACS_HASH_TABLE_RESOURCE_WARNING 0xC000D16C

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_75, 53613, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_75 0xC000D16D

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_76, 53614, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_76 0xC000D16E

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_77, 53615, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_77 0xC000D16F

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_78, 53616, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_78 0xC000D170

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_79, 53617, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_79 0xC000D171

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_80, 53618, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_80 0xC000D172

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_81, 53619, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_81 0xC000D173

// XEVENT_XMACS_NCIPHER_NOT_FUNCTIONING, 53620, Error
#define XEVENT_XMACS_NCIPHER_NOT_FUNCTIONING 0xC000D174

// XEVENT_XMACS_NCIPHER_NOT_FUNCTIONING_1, 53621, Error
#define XEVENT_XMACS_NCIPHER_NOT_FUNCTIONING_1 0xC000D175

// XEVENT_XMACS_PUID_THREAD_ERROR, 53622, Error
#define XEVENT_XMACS_PUID_THREAD_ERROR 0xC000D176

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_82, 53623, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_82 0xC000D177

// XEVENT_XMACS_PUID_THREAD_ERROR_1, 53624, Error
#define XEVENT_XMACS_PUID_THREAD_ERROR_1 0xC000D178

// XEVENT_XMACS_PUID_THREAD_ERROR_2, 53625, Error
#define XEVENT_XMACS_PUID_THREAD_ERROR_2 0xC000D179

// XEVENT_XMACS_PUID_THREAD_ERROR_3, 53626, Error
#define XEVENT_XMACS_PUID_THREAD_ERROR_3 0xC000D17A

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_83, 53627, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_83 0xC000D17B

// XEVENT_DEPRECATED_XMACS_GENERIC_RESOURCE_WARNING_84, 53628, Error
#define XEVENT_DEPRECATED_XMACS_GENERIC_RESOURCE_WARNING_84 0xC000D17C

// XEVENT_DEPRECATED_XMACS_GENERIC_RESOURCE_WARNING_85, 53629, Error
#define XEVENT_DEPRECATED_XMACS_GENERIC_RESOURCE_WARNING_85 0xC000D17D

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_86, 53630, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_86 0xC000D17E

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_87, 53631, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_87 0xC000D17F

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_88, 53632, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_88 0xC000D180

// XEVENT_XMACS_PUID_THREAD_ERROR_4, 53633, Error
#define XEVENT_XMACS_PUID_THREAD_ERROR_4 0xC000D181

// XEVENT_KDC_CODE_409, 53634, Error
#define XEVENT_KDC_CODE_409 0xC000D182

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_89, 53635, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_89 0xC000D183

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_90, 53636, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_90 0xC000D184

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_91, 53637, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_91 0xC000D185

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_92, 53638, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_92 0xC000D186

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_93, 53639, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_93 0xC000D187

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_94, 53640, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_94 0xC000D188

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_95, 53641, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_95 0xC000D189

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_96, 53642, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_96 0xC000D18A

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_97, 53643, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_97 0xC000D18B

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_98, 53644, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_98 0xC000D18C

// XEVENT_XMACS_HASH_TABLE_RESOURCE_WARNING_1, 53645, Error
#define XEVENT_XMACS_HASH_TABLE_RESOURCE_WARNING_1 0xC000D18D

// XEVENT_KDC_CODE_421, 53646, Error
#define XEVENT_KDC_CODE_421 0xC000D18E

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_99, 53647, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_99 0xC000D18F

// XEVENT_XMACS_HASH_TABLE_RESOURCE_WARNING_2, 53648, Error
#define XEVENT_XMACS_HASH_TABLE_RESOURCE_WARNING_2 0xC000D190

// XEVENT_XMACS_PPALOADER_THREAD_ERROR, 53649, Error
#define XEVENT_XMACS_PPALOADER_THREAD_ERROR 0xC000D191

// XEVENT_XMACS_PPALOADER_THREAD_ERROR_1, 53650, Error
#define XEVENT_XMACS_PPALOADER_THREAD_ERROR_1 0xC000D192

// XEVENT_XMACS_PPALOADER_THREAD_ERROR_2, 53651, Error
#define XEVENT_XMACS_PPALOADER_THREAD_ERROR_2 0xC000D193

// XEVENT_XMACS_PUID_THREAD_ERROR_5, 53652, Error
#define XEVENT_XMACS_PUID_THREAD_ERROR_5 0xC000D194

// XEVENT_XMACS_GENERIC_RESOURCE_WARNING_100, 53653, Error
#define XEVENT_XMACS_GENERIC_RESOURCE_WARNING_100 0xC000D195

// XEVENT_KDC_CODE_429, 53654, Error
#define XEVENT_KDC_CODE_429 0xC000D196

// XEVENT_KDC_CODE_430, 53655, Error
#define XEVENT_KDC_CODE_430 0xC000D197

// XEVENT_KDC_CODE_431, 53656, Error
#define XEVENT_KDC_CODE_431 0xC000D198

// XEVENT_KDC_CODE_432, 53657, Error
#define XEVENT_KDC_CODE_432 0xC000D199

// XEVENT_XMACS_CODE_MEMORY_ALLOCATION_ERROR, 53658, Error
#define XEVENT_XMACS_CODE_MEMORY_ALLOCATION_ERROR 0xC000D19A

// XEVENT_XMACS_CODE_FAILED_TO_ENCRYPT_REPLY, 53659, Error
#define XEVENT_XMACS_CODE_FAILED_TO_ENCRYPT_REPLY 0xC000D19B

// XEVENT_XMACS_CODE_FAILED_TO_GET_CIPHERTEXT_SIZE, 53660, Error
#define XEVENT_XMACS_CODE_FAILED_TO_GET_CIPHERTEXT_SIZE 0xC000D19C

// XEVENT_XMACS_CODE_MEMORY_ALLOCATION_ERROR_2, 53661, Error
#define XEVENT_XMACS_CODE_MEMORY_ALLOCATION_ERROR_2 0xC000D19D

// XEVENT_XMACS_CODE_FAILED_TO_PACK_REPLY, 53662, Error
#define XEVENT_XMACS_CODE_FAILED_TO_PACK_REPLY 0xC000D19E

// XEVENT_XMACS_PC_ACCOUNT_CREATION_FAILED, 53663, Error
#define XEVENT_XMACS_PC_ACCOUNT_CREATION_FAILED 0xC000D19F

// XEVENT_XMACS_FAILED_TO_INSTANTIATE_WSPARAMETERS, 53670, Error
#define XEVENT_XMACS_FAILED_TO_INSTANTIATE_WSPARAMETERS 0xC000D1A6

// XEVENT_XMACS_NO_CONNECT_FD, 54227, Error
#define XEVENT_XMACS_NO_CONNECT_FD 0xC000D3D3

// XEVENT_XMACS_NO_CONNECT_FD_1, 54228, Error
#define XEVENT_XMACS_NO_CONNECT_FD_1 0xC000D3D4

// XEVENT_XMACS_GENEALOGY_ERROR, 54229, Error
#define XEVENT_XMACS_GENEALOGY_ERROR 0xC000D3D5

// XEVENT_XMACS_DB_PC_ACCOUNT_LOOKUP_ERROR, 54230, Error
#define XEVENT_XMACS_DB_PC_ACCOUNT_LOOKUP_ERROR 0xC000D3D6

// XEVENT_XMACS_DB_PC_ACCOUNT_CREATE_ERROR, 54231, Error
#define XEVENT_XMACS_DB_PC_ACCOUNT_CREATE_ERROR 0xC000D3D7

// XEVENT_XMACS_DB_PC_PUIDVOUCHER_ADD_ERROR, 54232, Error
#define XEVENT_XMACS_DB_PC_PUIDVOUCHER_ADD_ERROR 0xC000D3D8

// XEVENT_XMACS_INVALID_PRINCIPAL, 54305, Error
#define XEVENT_XMACS_INVALID_PRINCIPAL 0xC000D421

// XEVENT_KDC_CONFIG_56, 54306, Error
#define XEVENT_KDC_CONFIG_56 0xC000D422

// XEVENT_XMACS_NO_CONNECT_GENEALOGY, 54307, Error
#define XEVENT_XMACS_NO_CONNECT_GENEALOGY 0xC000D423

// XEVENT_XMACS_INVALID_GENEALOGY_DATA, 54308, Error
#define XEVENT_XMACS_INVALID_GENEALOGY_DATA 0xC000D424

// XEVENT_XMACS_REGISTER_FAILURE, 54309, Error
#define XEVENT_XMACS_REGISTER_FAILURE 0xC000D425

// XEVENT_XMACS_REGISTER_FAILURE_1, 54310, Error
#define XEVENT_XMACS_REGISTER_FAILURE_1 0xC000D426

// XEVENT_KDC_CONFIG_61, 54311, Error
#define XEVENT_KDC_CONFIG_61 0xC000D427

// XEVENT_XMACS_REGISTER_FAILURE_2, 54312, Error
#define XEVENT_XMACS_REGISTER_FAILURE_2 0xC000D428

// XEVENT_XMACS_REGISTER_FAILURE_3, 54313, Error
#define XEVENT_XMACS_REGISTER_FAILURE_3 0xC000D429

// XEVENT_KDC_CONFIG_64, 54314, Error
#define XEVENT_KDC_CONFIG_64 0xC000D42A

// XEVENT_XMACS_INIT_FAILURE, 54315, Error
#define XEVENT_XMACS_INIT_FAILURE 0xC000D42B

// XEVENT_XMACS_INIT_FAILURE_1, 54316, Error
#define XEVENT_XMACS_INIT_FAILURE_1 0xC000D42C

// XEVENT_XMACS_INIT_FAILURE_2, 54317, Error
#define XEVENT_XMACS_INIT_FAILURE_2 0xC000D42D

// XEVENT_XMACS_INIT_FAILURE_3, 54318, Error
#define XEVENT_XMACS_INIT_FAILURE_3 0xC000D42E

// XEVENT_XMACS_INIT_FAILURE_4, 54319, Error
#define XEVENT_XMACS_INIT_FAILURE_4 0xC000D42F

// XEVENT_XMACS_INIT_FAILURE_5, 54320, Error
#define XEVENT_XMACS_INIT_FAILURE_5 0xC000D430

// XEVENT_XMACS_INIT_FAILURE_6, 54321, Error
#define XEVENT_XMACS_INIT_FAILURE_6 0xC000D431

// XEVENT_KDC_CONFIG_72, 54322, Error
#define XEVENT_KDC_CONFIG_72 0xC000D432

// XEVENT_KDC_CONFIG_73, 54323, Error
#define XEVENT_KDC_CONFIG_73 0xC000D433

// XEVENT_KDC_CONFIG_74, 54324, Error
#define XEVENT_KDC_CONFIG_74 0xC000D434

// XEVENT_KDC_CONFIG_75, 54325, Error
#define XEVENT_KDC_CONFIG_75 0xC000D435

// XEVENT_KDC_CONFIG_76, 54326, Warning
#define XEVENT_KDC_CONFIG_76 0x8000D436

// XEVENT_KDC_CONFIG_77, 54327, Error
#define XEVENT_KDC_CONFIG_77 0xC000D437

// XEVENT_KDC_CONFIG_78, 54328, Error
#define XEVENT_KDC_CONFIG_78 0xC000D438

// XEVENT_XMACS_INIT_FAILURE_7, 54329, Error
#define XEVENT_XMACS_INIT_FAILURE_7 0xC000D439

// XEVENT_KDC_CONFIG_80, 54330, Error
#define XEVENT_KDC_CONFIG_80 0xC000D43A

// XEVENT_XMACS_INIT_FAILURE_8, 54331, Error
#define XEVENT_XMACS_INIT_FAILURE_8 0xC000D43B

// XEVENT_KDC_CONFIG_82, 54332, Warning
#define XEVENT_KDC_CONFIG_82 0x8000D43C

// XEVENT_KDC_CONFIG_83, 54333, Error
#define XEVENT_KDC_CONFIG_83 0xC000D43D

// XEVENT_KDC_CONFIG_84, 54334, Error
#define XEVENT_KDC_CONFIG_84 0xC000D43E

// XEVENT_KDC_CONFIG_85, 54335, Error
#define XEVENT_KDC_CONFIG_85 0xC000D43F

// XEVENT_KDC_CONFIG_86, 54336, Error
#define XEVENT_KDC_CONFIG_86 0xC000D440

// XEVENT_KDC_CONFIG_87, 54337, Error
#define XEVENT_KDC_CONFIG_87 0xC000D441

// XEVENT_KDC_CONFIG_88, 54338, Error
#define XEVENT_KDC_CONFIG_88 0xC000D442

// XEVENT_KDC_CONFIG_89, 54339, Error
#define XEVENT_KDC_CONFIG_89 0xC000D443

// XEVENT_XMACS_INIT_WARNING, 54340, Warning
#define XEVENT_XMACS_INIT_WARNING 0x8000D444

// XEVENT_XMACS_INIT_FAILURE_9, 54341, Error
#define XEVENT_XMACS_INIT_FAILURE_9 0xC000D445

// XEVENT_KDC_CONFIG_92, 54342, Error
#define XEVENT_KDC_CONFIG_92 0xC000D446

// XEVENT_XMACS_INVALID_PRINCIPAL_1, 54343, Error
#define XEVENT_XMACS_INVALID_PRINCIPAL_1 0xC000D447

// XEVENT_XMACS_INVALID_PRINCIPAL_2, 54344, Error
#define XEVENT_XMACS_INVALID_PRINCIPAL_2 0xC000D448

// XEVENT_XMACS_INVALID_PRINCIPAL_3, 54345, Error
#define XEVENT_XMACS_INVALID_PRINCIPAL_3 0xC000D449

// XEVENT_XMACS_INVALID_PRINCIPAL_4, 54346, Error
#define XEVENT_XMACS_INVALID_PRINCIPAL_4 0xC000D44A

// XEVENT_XMACS_INVALID_PRINCIPAL_5, 54347, Error
#define XEVENT_XMACS_INVALID_PRINCIPAL_5 0xC000D44B

// XEVENT_XMACS_INVALID_PRINCIPAL_6, 54348, Error
#define XEVENT_XMACS_INVALID_PRINCIPAL_6 0xC000D44C

// XEVENT_XMACS_INVALID_PRINCIPAL_7, 54349, Error
#define XEVENT_XMACS_INVALID_PRINCIPAL_7 0xC000D44D

// XEVENT_XMACS_INVALID_PRINCIPAL_8, 54350, Error
#define XEVENT_XMACS_INVALID_PRINCIPAL_8 0xC000D44E

// XEVENT_KDC_CONFIG_101, 54351, Error
#define XEVENT_KDC_CONFIG_101 0xC000D44F

// XEVENT_XMACS_NO_CONNECT_GENEALOGY_1, 54352, Error
#define XEVENT_XMACS_NO_CONNECT_GENEALOGY_1 0xC000D450

// XEVENT_XMACS_NO_CONNECT_GENEALOGY_2, 54353, Error
#define XEVENT_XMACS_NO_CONNECT_GENEALOGY_2 0xC000D451

// XEVENT_KDC_CONFIG_104, 54354, Error
#define XEVENT_KDC_CONFIG_104 0xC000D452

// XEVENT_KDC_CONFIG_105, 54355, Error
#define XEVENT_KDC_CONFIG_105 0xC000D453

// XEVENT_XMACS_INVALID_GENEALOGY_DATA_1, 54356, Error
#define XEVENT_XMACS_INVALID_GENEALOGY_DATA_1 0xC000D454

// XEVENT_XMACS_FAILED_NCIPHER_DECRYPTION, 54357, Error
#define XEVENT_XMACS_FAILED_NCIPHER_DECRYPTION 0xC000D455

// XEVENT_XMACS_FAILED_NCIPHER_DECRYPTION_1, 54358, Error
#define XEVENT_XMACS_FAILED_NCIPHER_DECRYPTION_1 0xC000D456

// XEVENT_KDC_CONFIG_109, 54359, Error
#define XEVENT_KDC_CONFIG_109 0xC000D457

// XEVENT_XMACS_SERVICE_KEY_FAILURE, 54360, Error
#define XEVENT_XMACS_SERVICE_KEY_FAILURE 0xC000D458

// XEVENT_XMACS_SERVICE_KEY_FAILURE_1, 54361, Error
#define XEVENT_XMACS_SERVICE_KEY_FAILURE_1 0xC000D459

// XEVENT_XMACS_SERVICE_KEY_FAILURE_2, 54362, Error
#define XEVENT_XMACS_SERVICE_KEY_FAILURE_2 0xC000D45A

// XEVENT_XMACS_SERVICE_KEY_FAILURE_3, 54363, Error
#define XEVENT_XMACS_SERVICE_KEY_FAILURE_3 0xC000D45B

// XEVENT_XMACS_NO_CONNECT_GENEALOGY_3, 54364, Error
#define XEVENT_XMACS_NO_CONNECT_GENEALOGY_3 0xC000D45C

// XEVENT_XMACS_INVALID_GENEALOGY_DATA_2, 54365, Error
#define XEVENT_XMACS_INVALID_GENEALOGY_DATA_2 0xC000D45D

// XEVENT_XMACS_INVALID_GENEALOGY_DATA_3, 54366, Error
#define XEVENT_XMACS_INVALID_GENEALOGY_DATA_3 0xC000D45E

// XEVENT_XMACS_INVALID_GENEALOGY_DATA_4, 54367, Error
#define XEVENT_XMACS_INVALID_GENEALOGY_DATA_4 0xC000D45F

// XEVENT_XMACS_FAILED_TO_INITIALIZE_PASSPORT, 54369, Error
#define XEVENT_XMACS_FAILED_TO_INITIALIZE_PASSPORT 0xC000D461

// XEVENT_XMACS_INACTIVE_XBOX, 54680, Warning
#define XEVENT_XMACS_INACTIVE_XBOX 0x8000D598

// XEVENT_KDC_HACK_31, 54681, Warning
#define XEVENT_KDC_HACK_31 0x8000D599

// XEVENT_KDC_HACK_32, 54682, Warning
#define XEVENT_KDC_HACK_32 0x8000D59A

// XEVENT_KDC_HACK_33, 54683, Warning
#define XEVENT_KDC_HACK_33 0x8000D59B

// XEVENT_KDC_HACK_34, 54684, Warning
#define XEVENT_KDC_HACK_34 0x8000D59C

// XEVENT_KDC_HACK_35, 54685, Warning
#define XEVENT_KDC_HACK_35 0x8000D59D

// XEVENT_KDC_HACK_36, 54686, Warning
#define XEVENT_KDC_HACK_36 0x8000D59E

// XEVENT_KDC_HACK_37, 54687, Warning
#define XEVENT_KDC_HACK_37 0x8000D59F

// XEVENT_KDC_HACK_38, 54688, Warning
#define XEVENT_KDC_HACK_38 0x8000D5A0

// XEVENT_KDC_HACK_39, 54689, Warning
#define XEVENT_KDC_HACK_39 0x8000D5A1

// XEVENT_KDC_HACK_40, 54690, Warning
#define XEVENT_KDC_HACK_40 0x8000D5A2

// XEVENT_KDC_HACK_41, 54691, Warning
#define XEVENT_KDC_HACK_41 0x8000D5A3

// XEVENT_KDC_HACK_42, 54692, Warning
#define XEVENT_KDC_HACK_42 0x8000D5A4

// XEVENT_KDC_HACK_43, 54693, Warning
#define XEVENT_KDC_HACK_43 0x8000D5A5

// XEVENT_KDC_HACK_44, 54694, Warning
#define XEVENT_KDC_HACK_44 0x8000D5A6

// XEVENT_KDC_HACK_45, 54695, Warning
#define XEVENT_KDC_HACK_45 0x8000D5A7

// XEVENT_KDC_HACK_46, 54696, Warning
#define XEVENT_KDC_HACK_46 0x8000D5A8

// XEVENT_XMACS_HACK_INVALID_PRE_AUTH_TYPE, 54697, Warning
#define XEVENT_XMACS_HACK_INVALID_PRE_AUTH_TYPE 0x8000D5A9

// XEVENT_XMACS_HACK_MALFORMED_PRE_AUTH, 54698, Warning
#define XEVENT_XMACS_HACK_MALFORMED_PRE_AUTH 0x8000D5AA

// XEVENT_XMACS_HACK_FAILED_TO_CRACK_PASSPORT_TICKET, 54699, Warning
#define XEVENT_XMACS_HACK_FAILED_TO_CRACK_PASSPORT_TICKET 0x8000D5AB

// XEVENT_XMACS_HACK_INVALID_CLIENT_NAME, 54700, Warning
#define XEVENT_XMACS_HACK_INVALID_CLIENT_NAME 0x8000D5AC

// XEVENT_XMACS_HACK_INVALID_SERVER_NAME, 54701, Warning
#define XEVENT_XMACS_HACK_INVALID_SERVER_NAME 0x8000D5AD

// XEVENT_XMACS_HACK_DOS_ATTACK, 54706, Warning
#define XEVENT_XMACS_HACK_DOS_ATTACK 0x8000D5B2

// XEVENT_XMACS_HACK_CONSOLE_TYPE_NOT_ALLOWED, 54709, Warning
#define XEVENT_XMACS_HACK_CONSOLE_TYPE_NOT_ALLOWED 0x8000D5B5

// XEVENT_XMACS_HACK_TESTKIT_NOT_ALLOWED, 54710, Warning
#define XEVENT_XMACS_HACK_TESTKIT_NOT_ALLOWED 0x8000D5B6

// XEVENT_XMACS_HACK_MALFORMED_PRE_AUTH_2, 54711, Warning
#define XEVENT_XMACS_HACK_MALFORMED_PRE_AUTH_2 0x8000D5B7

// XEVENT_XMACS_HACK_MALFORMED_PRE_AUTH_3, 54712, Warning
#define XEVENT_XMACS_HACK_MALFORMED_PRE_AUTH_3 0x8000D5B8

// XEVENT_XMACS_HACK_MALFORMED_PRE_AUTH_4, 54713, Warning
#define XEVENT_XMACS_HACK_MALFORMED_PRE_AUTH_4 0x8000D5B9

// XEVENT_XMACS_NONUNIQUE_SERIALNUMBER_REQUEST, 54766, Info
#define XEVENT_XMACS_NONUNIQUE_SERIALNUMBER_REQUEST 0x4000D5EE

// XEVENT_XMACS_REGISTER_SUCCESS, 54767, Info
#define XEVENT_XMACS_REGISTER_SUCCESS 0x4000D5EF

// XEVENT_XMACS_REGISTER_SUCCESS_1, 54768, Info
#define XEVENT_XMACS_REGISTER_SUCCESS_1 0x4000D5F0

// XEVENT_XMACS_INIT_SUCCESS, 54769, Info
#define XEVENT_XMACS_INIT_SUCCESS 0x4000D5F1

// XEVENT_XMACS_TERM_SUCCESS, 54770, Info
#define XEVENT_XMACS_TERM_SUCCESS 0x4000D5F2

// XEVENT_XMACS_STOPPING, 54771, Info
#define XEVENT_XMACS_STOPPING 0x4000D5F3

// XEVENT_XMACS_RELOAD_SUCCESS, 54772, Info
#define XEVENT_XMACS_RELOAD_SUCCESS 0x4000D5F4

// XEVENT_KDC_INFO_23, 54773, Info
#define XEVENT_KDC_INFO_23 0x4000D5F5

// XEVENT_KDC_INFO_24, 54774, Info
#define XEVENT_KDC_INFO_24 0x4000D5F6

// XEVENT_KDC_INFO_25, 54775, Info
#define XEVENT_KDC_INFO_25 0x4000D5F7

// XEVENT_KDC_INFO_26, 54776, Info
#define XEVENT_KDC_INFO_26 0x4000D5F8

// XEVENT_XMACS_CONNECT_GENEALOGY, 54777, Info
#define XEVENT_XMACS_CONNECT_GENEALOGY 0x4000D5F9

// XEVENT_KDC_INFO_28, 54778, Info
#define XEVENT_KDC_INFO_28 0x4000D5FA

// XEVENT_XMACS_PUID_ATTAINED_NEW_BLOCK, 54779, Info
#define XEVENT_XMACS_PUID_ATTAINED_NEW_BLOCK 0x4000D5FB

// XEVENT_XMACS_PPALOADER_LOADING_INFO, 54780, Info
#define XEVENT_XMACS_PPALOADER_LOADING_INFO 0x4000D5FC

// XEVENT_XMACS_PPALOADER_LOADING_INFO_1, 54781, Info
#define XEVENT_XMACS_PPALOADER_LOADING_INFO_1 0x4000D5FD

// XEVENT_XRLSCAN_PUT_COMPONENTNAME_FAILED, 10000, Warning
#define XEVENT_XRLSCAN_PUT_COMPONENTNAME_FAILED 0x80002710

// XEVENT_XRLSCAN_GETNEXTROWSET_FAILED, 10001, Warning
#define XEVENT_XRLSCAN_GETNEXTROWSET_FAILED 0x80002711

// XEVENT_XRLSCAN_SETBINDINGS_FAILED, 10002, Warning
#define XEVENT_XRLSCAN_SETBINDINGS_FAILED 0x80002712

// XEVENT_XRLSCAN_GETROWS_FAILED, 10003, Warning
#define XEVENT_XRLSCAN_GETROWS_FAILED 0x80002713

// XEVENT_XRLSCAN_LOADCONTENTTYPES_FAILED, 10004, Warning
#define XEVENT_XRLSCAN_LOADCONTENTTYPES_FAILED 0x80002714

// XEVENT_XRLSCAN_CONFIG_0, 62475, Error
#define XEVENT_XRLSCAN_CONFIG_0 0xC000F40B

// XEVENT_XRLSCAN_CONFIG_1, 62476, Error
#define XEVENT_XRLSCAN_CONFIG_1 0xC000F40C

// XEVENT_XRLSCAN_CONFIG_2, 62477, Error
#define XEVENT_XRLSCAN_CONFIG_2 0xC000F40D

// XEVENT_DEPRECATED_XRLSCAN_CONFIG_3, 62478, Error
#define XEVENT_DEPRECATED_XRLSCAN_CONFIG_3 0xC000F40E

// XEVENT_DEPRECATED_XRLSCAN_CONFIG_4, 62479, Error
#define XEVENT_DEPRECATED_XRLSCAN_CONFIG_4 0xC000F40F

// XEVENT_XRLSCAN_CONFIG_5, 62480, Error
#define XEVENT_XRLSCAN_CONFIG_5 0xC000F410

// XEVENT_XRLSCAN_CONFIG_6, 62481, Error
#define XEVENT_XRLSCAN_CONFIG_6 0xC000F411

// XEVENT_XRLSCAN_CONFIG_7, 62482, Error
#define XEVENT_XRLSCAN_CONFIG_7 0xC000F412

// XEVENT_XRLSCAN_CONFIG_8, 62483, Error
#define XEVENT_XRLSCAN_CONFIG_8 0xC000F413

// XEVENT_XRLSCAN_CONFIG_9, 62484, Error
#define XEVENT_XRLSCAN_CONFIG_9 0xC000F414

// XEVENT_XRLSCAN_HACK_0, 62525, Warning
#define XEVENT_XRLSCAN_HACK_0 0x8000F43D

// XEVENT_XRLSCAN_E_INVALID_URL, 62526, Warning
#define XEVENT_XRLSCAN_E_INVALID_URL 0x8000F43E

// XEVENT_XRLSCAN_E_INVALID_URL_1, 62527, Warning
#define XEVENT_XRLSCAN_E_INVALID_URL_1 0x8000F43F

// XEVENT_XRLSCAN_LIMITED_NO_SGINFO, 62528, Warning
#define XEVENT_XRLSCAN_LIMITED_NO_SGINFO 0x8000F440

// XEVENT_SIGNATURE_GETSECUREBLOB_ERROR, 15000, Error
#define XEVENT_SIGNATURE_GETSECUREBLOB_ERROR 0xC0003A98

// XEVENT_SIGNATURE_VALIDATE_CERTIFICATE_ERROR, 15001, Error
#define XEVENT_SIGNATURE_VALIDATE_CERTIFICATE_ERROR 0xC0003A99

// XEVENT_PLAYREADY_DEVICE_CERT_EMPTY, 15002, Error
#define XEVENT_PLAYREADY_DEVICE_CERT_EMPTY 0xC0003A9A

// XEVENT_PLAYREADY_DEVICE_CERT_TOO_LONG, 15003, Error
#define XEVENT_PLAYREADY_DEVICE_CERT_TOO_LONG 0xC0003A9B

// XEVENT_PLAYREADY_DEVICE_CERT_GENERATION_FAILURE, 15004, Error
#define XEVENT_PLAYREADY_DEVICE_CERT_GENERATION_FAILURE 0xC0003A9C

// XEVENT_PLAYREADY_DEVICE_CERT_GENERAL_ERROR, 15005, Error
#define XEVENT_PLAYREADY_DEVICE_CERT_GENERAL_ERROR 0xC0003A9D

// XEVENT_PLAYREADY_DEVICE_CERT_INVALID_DEVICE, 15006, Error
#define XEVENT_PLAYREADY_DEVICE_CERT_INVALID_DEVICE 0xC0003A9E

// XEVENT_SIGNATURE_CODE_0, 57950, Error
#define XEVENT_SIGNATURE_CODE_0 0xC000E25E

// XEVENT_SIGNATURE_CODE_1, 57951, Error
#define XEVENT_SIGNATURE_CODE_1 0xC000E25F

// XEVENT_SIGNATURE_CODE_2, 57952, Error
#define XEVENT_SIGNATURE_CODE_2 0xC000E260

// XEVENT_SIGNATURE_CODE_3, 57953, Error
#define XEVENT_SIGNATURE_CODE_3 0xC000E261

// XEVENT_SIGNATURE_CODE_4, 57954, Error
#define XEVENT_SIGNATURE_CODE_4 0xC000E262

// XEVENT_SIGNATURE_CODE_5, 57955, Error
#define XEVENT_SIGNATURE_CODE_5 0xC000E263

// XEVENT_SIGNATURE_CONFIG_0, 57975, Error
#define XEVENT_SIGNATURE_CONFIG_0 0xC000E277

// XEVENT_SIGNATURE_CONFIG_1, 57976, Error
#define XEVENT_SIGNATURE_CONFIG_1 0xC000E278

// XEVENT_SIGNATURE_CONFIG_2, 57977, Error
#define XEVENT_SIGNATURE_CONFIG_2 0xC000E279

// XEVENT_SIGNATURE_CONFIG_3, 57978, Error
#define XEVENT_SIGNATURE_CONFIG_3 0xC000E27A

// XEVENT_SIGNATURE_CONFIG_CALLSOURCE, 57979, Error
#define XEVENT_SIGNATURE_CONFIG_CALLSOURCE 0xC000E27B

// XEVENT_SIGNATURE_HACK_0, 58000, Warning
#define XEVENT_SIGNATURE_HACK_0 0x8000E290

// XEVENT_SIGNATURE_INFO_0, 58025, Info
#define XEVENT_SIGNATURE_INFO_0 0x4000E2A9

// XEVENT_SIGNATURE_INFO_1, 58026, Info
#define XEVENT_SIGNATURE_INFO_1 0x4000E2AA

// XEVENT_SIGNATURE_INFO_2, 58027, Info
#define XEVENT_SIGNATURE_INFO_2 0x4000E2AB

// XEVENT_LICENSE_GENERAL, 58028, Error
#define XEVENT_LICENSE_GENERAL 0xC000E2AC

// XEVENT_LICENSE_INVALID_REQUEST, 58029, Error
#define XEVENT_LICENSE_INVALID_REQUEST 0xC000E2AD

// XEVENT_LICENSE_XML_ERROR, 58030, Error
#define XEVENT_LICENSE_XML_ERROR 0xC000E2AE

// XEVENT_DEPRECATED_XSIG_APP_FAILED_GEOFENCING_INIT, 58031, Error
#define XEVENT_DEPRECATED_XSIG_APP_FAILED_GEOFENCING_INIT 0xC000E2AF

// XEVENT_DEPRECATED_GEO_DB_FILE_TOO_OLD, 58032, Error
#define XEVENT_DEPRECATED_GEO_DB_FILE_TOO_OLD 0xC000E2B0

// XEVENT_XSIG_BLACKLIST_DIGEST_FAILURE, 58033, Error
#define XEVENT_XSIG_BLACKLIST_DIGEST_FAILURE 0xC000E2B1

// XEVENT_LICENSE_AUTHDATA_VERIFICATION_FAILED, 58034, Error
#define XEVENT_LICENSE_AUTHDATA_VERIFICATION_FAILED 0xC000E2B2

// XEVENT_XMSTV_CA, 57956, Error
#define XEVENT_XMSTV_CA 0xC000E264

// XEVENT_XMSTV_CERT_REQUEST_CHECK, 57957, Error
#define XEVENT_XMSTV_CERT_REQUEST_CHECK 0xC000E265

// XEVENT_XMSTV_GENERAL, 57958, Error
#define XEVENT_XMSTV_GENERAL 0xC000E266

// XEVENT_AAINFO_GETAAINFO_GENERAL, 57959, Error
#define XEVENT_AAINFO_GETAAINFO_GENERAL 0xC000E267

// XEVENT_CASVC_INVALID_REQUEST, 57960, Error
#define XEVENT_CASVC_INVALID_REQUEST 0xC000E268

// XEVENT_WEBCACHE_SIGNATURE_BLACKLIST_DIGEST_WRONG_SIZE, 61725, Error
#define XEVENT_WEBCACHE_SIGNATURE_BLACKLIST_DIGEST_WRONG_SIZE 0xC000F11D

// XEVENT_XUACS_SUBSCRIPTION_NOT_FOUND, 15000, Error
#define XEVENT_XUACS_SUBSCRIPTION_NOT_FOUND 0xC0003A98

// XEVENT_XUACS_REPLACE_USER_PASSPORT_QUEUE_DEQUEUE_ERROR, 15001, Error
#define XEVENT_XUACS_REPLACE_USER_PASSPORT_QUEUE_DEQUEUE_ERROR 0xC0003A99

// XEVENT_XUACS_REPLACE_USER_PASSPORT_QUEUE_IMPERSONATION_ERROR, 15002, Error
#define XEVENT_XUACS_REPLACE_USER_PASSPORT_QUEUE_IMPERSONATION_ERROR 0xC0003A9A

// XEVENT_XUACS_REPLACE_USER_PASSPORT_QUEUE_TIMER_RESET_ERROR, 15003, Error
#define XEVENT_XUACS_REPLACE_USER_PASSPORT_QUEUE_TIMER_RESET_ERROR 0xC0003A9B

// XEVENT_XUACS_REPLACE_USER_PASSPORT_QUEUE_GET_PENDING_ERROR, 15004, Error
#define XEVENT_XUACS_REPLACE_USER_PASSPORT_QUEUE_GET_PENDING_ERROR 0xC0003A9C

// XEVENT_XUACS_REPLACE_OWNER_PASSPORT_ERROR, 15005, Error
#define XEVENT_XUACS_REPLACE_OWNER_PASSPORT_ERROR 0xC0003A9D

// XEVENT_XUACS_REPLACE_USER_PASSPORT_ERROR, 15006, Error
#define XEVENT_XUACS_REPLACE_USER_PASSPORT_ERROR 0xC0003A9E

// XEVENT_XUACS_GET_USER_TENURE_ERROR, 15007, Error
#define XEVENT_XUACS_GET_USER_TENURE_ERROR 0xC0003A9F

// XEVENT_XUACS_GET_USER_TENURE_DATABASE_ERROR, 15008, Error
#define XEVENT_XUACS_GET_USER_TENURE_DATABASE_ERROR 0xC0003AA0

// XEVENT_XUACS_GET_USER_TENURE_CONFIG_ERROR, 15009, Error
#define XEVENT_XUACS_GET_USER_TENURE_CONFIG_ERROR 0xC0003AA1

// XEVENT_XUACS_UPS_GET_BIRTHDATE_ERROR, 15010, Info
#define XEVENT_XUACS_UPS_GET_BIRTHDATE_ERROR 0x40003AA2

// XEVENT_XUACS_RECOVERY_USER_THRESHOLD_EXCEEDED, 15011, Warning
#define XEVENT_XUACS_RECOVERY_USER_THRESHOLD_EXCEEDED 0x80003AA3

// XEVENT_XUACS_RECOVERY_MACHINE_THRESHOLD_EXCEEDED, 15012, Warning
#define XEVENT_XUACS_RECOVERY_MACHINE_THRESHOLD_EXCEEDED 0x80003AA4

// XEVENT_BILLING_ACCOUNTS_GET_SUBSCRIPTION_INFO_ERROR, 15013, Error
#define XEVENT_BILLING_ACCOUNTS_GET_SUBSCRIPTION_INFO_ERROR 0xC0003AA5

// XEVENT_XUACS_SWITCH_USER_DATE_OF_BIRTH_ERROR, 15014, Error
#define XEVENT_XUACS_SWITCH_USER_DATE_OF_BIRTH_ERROR 0xC0003AA6

// XEVENT_XUACS_SWITCH_OWNER_PASSPORT_ERROR, 15015, Error
#define XEVENT_XUACS_SWITCH_OWNER_PASSPORT_ERROR 0xC0003AA7

// XEVENT_XUACS_MAX_ACCOUNTS_PER_MACHINEID_REACHED, 15016, Warning
#define XEVENT_XUACS_MAX_ACCOUNTS_PER_MACHINEID_REACHED 0x80003AA8

// XEVENT_XUACS_ACCEPT_TERMS_OF_SERVICE_ERROR, 15017, Warning
#define XEVENT_XUACS_ACCEPT_TERMS_OF_SERVICE_ERROR 0x80003AA9

// XEVENT_XUACS_SET_CONSOLE_TRUST_LEVEL_ERROR, 15019, Warning
#define XEVENT_XUACS_SET_CONSOLE_TRUST_LEVEL_ERROR 0x80003AAB

// XEVENT_XUACS_ENUM_FAMILY_MEMBERS_ERROR, 15020, Warning
#define XEVENT_XUACS_ENUM_FAMILY_MEMBERS_ERROR 0x80003AAC

// XEVENT_XUACS_ADD_DEPENDENT_ERROR, 15021, Warning
#define XEVENT_XUACS_ADD_DEPENDENT_ERROR 0x80003AAD

// XEVENT_XUACS_ADD_DEPENDENT_INVALID_SIGNED_PASSPORT_PUID, 15022, Warning
#define XEVENT_XUACS_ADD_DEPENDENT_INVALID_SIGNED_PASSPORT_PUID 0x80003AAE

// XEVENT_XUACS_GAMERTAG_HISTORY_GET_ERROR, 15023, Error
#define XEVENT_XUACS_GAMERTAG_HISTORY_GET_ERROR 0xC0003AAF

// XEVENT_XUACS_USER_HISTORY_GET_ERROR, 15024, Error
#define XEVENT_XUACS_USER_HISTORY_GET_ERROR 0xC0003AB0

// XEVENT_XUACS_MACHINE_HISTORY_GET_ERROR, 15025, Error
#define XEVENT_XUACS_MACHINE_HISTORY_GET_ERROR 0xC0003AB1

// XEVENT_XUACS_FAMILY_SUB_GOLD_USER_COUNT_ERROR, 15026, Warning
#define XEVENT_XUACS_FAMILY_SUB_GOLD_USER_COUNT_ERROR 0x80003AB2

// XEVENT_XUACS_FAMILY_SUB_ASSIGN_GOLD_USER_ERROR, 15027, Warning
#define XEVENT_XUACS_FAMILY_SUB_ASSIGN_GOLD_USER_ERROR 0x80003AB3

// XEVENT_XUACS_FAMILY_SUB_REMOVE_GOLD_USER_ERROR, 15028, Warning
#define XEVENT_XUACS_FAMILY_SUB_REMOVE_GOLD_USER_ERROR 0x80003AB4

// XEVENT_XUACS_REMOVE_DEPENDENT_ERROR, 15029, Warning
#define XEVENT_XUACS_REMOVE_DEPENDENT_ERROR 0x80003AB5

// XEVENT_XUACS_GET_PARENTAL_CONTROLS_ERROR, 15030, Warning
#define XEVENT_XUACS_GET_PARENTAL_CONTROLS_ERROR 0x80003AB6

// XEVENT_XUACS_MISSING_OR_BAD_CONFIG_PASSPORTCREATEGNERATED, 15031, Error
#define XEVENT_XUACS_MISSING_OR_BAD_CONFIG_PASSPORTCREATEGNERATED 0xC0003AB7

// XEVENT_XUACS_GET_DEPENDENT_SIGNED_PUID_ERROR, 15032, Warning
#define XEVENT_XUACS_GET_DEPENDENT_SIGNED_PUID_ERROR 0x80003AB8

// XEVENT_XUACS_CONSOLE_APPLICATIONS_GET_ERROR, 15033, Error
#define XEVENT_XUACS_CONSOLE_APPLICATIONS_GET_ERROR 0xC0003AB9

// XEVENT_XUACS_SWITCH_USER_COUNTRY_ERROR, 15034, Error
#define XEVENT_XUACS_SWITCH_USER_COUNTRY_ERROR 0xC0003ABA

// XEVENT_XUACS_GET_PARENTAL_CONTROL_GROUP_TEMPLATES_ERROR, 15035, Warning
#define XEVENT_XUACS_GET_PARENTAL_CONTROL_GROUP_TEMPLATES_ERROR 0x80003ABB

// XEVENT_XUACS_GET_USER_PARENTAL_CONTROL_GROUP_ERROR, 15036, Warning
#define XEVENT_XUACS_GET_USER_PARENTAL_CONTROL_GROUP_ERROR 0x80003ABC

// XEVENT_XUACS_UPDATE_PARENTAL_CONTROL_GROUP_ERROR, 15037, Warning
#define XEVENT_XUACS_UPDATE_PARENTAL_CONTROL_GROUP_ERROR 0x80003ABD

// XEVENT_BILLING_ACCOUNTS_INVALID_FAMILY_CONVERSION_VALUE, 15038, Error
#define XEVENT_BILLING_ACCOUNTS_INVALID_FAMILY_CONVERSION_VALUE 0xC0003ABE

// XEVENT_BILLING_ACCOUNTS_ERROR_POINTS_TRANSFER, 15039, Error
#define XEVENT_BILLING_ACCOUNTS_ERROR_POINTS_TRANSFER 0xC0003ABF

// XEVENT_XUACS_ACCOUNTS_RESERVE_GAMERTAG_ERROR, 15040, Error
#define XEVENT_XUACS_ACCOUNTS_RESERVE_GAMERTAG_ERROR 0xC0003AC0

// XEVENT_XUACS_OFFLINE_XUID_ALREADY_REGISTERED, 15041, Error
#define XEVENT_XUACS_OFFLINE_XUID_ALREADY_REGISTERED 0xC0003AC1

// XEVENT_XUACS_SWITCH_USER_COUNTRY_DATABASE_ERROR, 15042, Warning
#define XEVENT_XUACS_SWITCH_USER_COUNTRY_DATABASE_ERROR 0x80003AC2

// XEVENT_XUACS_SWITCH_USER_COUNTRY_NO_MIGRATION_OFFER, 15043, Warning
#define XEVENT_XUACS_SWITCH_USER_COUNTRY_NO_MIGRATION_OFFER 0x80003AC3

// XEVENT_XUACS_SWITCH_USER_COUNTRY_MIGRATE_ACCOUNT_TIMEOUT, 15044, Error
#define XEVENT_XUACS_SWITCH_USER_COUNTRY_MIGRATE_ACCOUNT_TIMEOUT 0xC0003AC4

// XEVENT_BILLING_ACCOUNTS_ERROR_GET_DEPENDENT_POINTS, 15045, Error
#define XEVENT_BILLING_ACCOUNTS_ERROR_GET_DEPENDENT_POINTS 0xC0003AC5

// XEVENT_XUACS_CREATEUSERANDBILLABLEACCOUNT_ERROR, 15046, Error
#define XEVENT_XUACS_CREATEUSERANDBILLABLEACCOUNT_ERROR 0xC0003AC6

// XEVENT_XUACS_MIGRATE_COM_USER_GET_OFFERINSTANCE_ERROR, 15047, Error
#define XEVENT_XUACS_MIGRATE_COM_USER_GET_OFFERINSTANCE_ERROR 0xC0003AC7

// XEVENT_XONLINE_E_ACCOUNTS_USER_GET_AGE_ERROR, 15048, Error
#define XEVENT_XONLINE_E_ACCOUNTS_USER_GET_AGE_ERROR 0xC0003AC8

// XEVENT_XONLINE_E_ACCOUNTS_USER_GET_AGE_GROUP_ERROR, 15049, Error
#define XEVENT_XONLINE_E_ACCOUNTS_USER_GET_AGE_GROUP_ERROR 0xC0003AC9

// XEVENT_XUACS_CREATEBULKUSER_ERROR, 15050, Error
#define XEVENT_XUACS_CREATEBULKUSER_ERROR 0xC0003ACA

// XEVENT_XUACS_MERGE_USER_ENTITLEMENTS_ERROR, 15051, Error
#define XEVENT_XUACS_MERGE_USER_ENTITLEMENTS_ERROR 0xC0003ACB

// XEVENT_XUACS_PREVIEW_SWITCH_USER_COUNTRY_ERROR, 15052, Error
#define XEVENT_XUACS_PREVIEW_SWITCH_USER_COUNTRY_ERROR 0xC0003ACC

// XEVENT_XUACS_SWITCH_USER_PASSPORT_ERROR, 15053, Error
#define XEVENT_XUACS_SWITCH_USER_PASSPORT_ERROR 0xC0003ACD

// XEVENT_XUACS_HCP_SERVICE_CALL_FAILURE, 15054, Error
#define XEVENT_XUACS_HCP_SERVICE_CALL_FAILURE 0xC0003ACE

// XEVENT_TEST_ENCRYPTION_ERROR, 19999, Error
#define XEVENT_TEST_ENCRYPTION_ERROR 0xC0004E1F

// XEVENT_XUACS_UNABLE_TO_COMPLETE_RENEWAL, 50531, Error
#define XEVENT_XUACS_UNABLE_TO_COMPLETE_RENEWAL 0xC000C563

// XEVENT_XUACS_MISSING_OR_BAD_CONFIG, 50560, Error
#define XEVENT_XUACS_MISSING_OR_BAD_CONFIG 0xC000C580

// XEVENT_XUACS_MISSING_OR_BAD_CONFIG_1, 50566, Error
#define XEVENT_XUACS_MISSING_OR_BAD_CONFIG_1 0xC000C586

// XEVENT_XUACS_UODB_ACCESS_ERROR_1, 50575, Error
#define XEVENT_XUACS_UODB_ACCESS_ERROR_1 0xC000C58F

// XEVENT_XUACS_UNEXPECTED_REQUEST, 50655, Warning
#define XEVENT_XUACS_UNEXPECTED_REQUEST 0x8000C5DF

// XEVENT_XUACS_UNEXPECTED_REQUEST_1, 50656, Warning
#define XEVENT_XUACS_UNEXPECTED_REQUEST_1 0x8000C5E0

// XEVENT_XUACS_LINK_WEB_ACCOUNT_BLOCKED, 50658, Warning
#define XEVENT_XUACS_LINK_WEB_ACCOUNT_BLOCKED 0x8000C5E2

// XEVENT_XUACS_SUSPICIOUS_CLIENT, 50659, Warning
#define XEVENT_XUACS_SUSPICIOUS_CLIENT 0x8000C5E3

// XEVENT_XUACS_SUSPICIOUS_CLIENT_1, 50660, Warning
#define XEVENT_XUACS_SUSPICIOUS_CLIENT_1 0x8000C5E4

// XEVENT_XUACS_RESTORE_ACCOUNT_BLOCKED, 50661, Warning
#define XEVENT_XUACS_RESTORE_ACCOUNT_BLOCKED 0x8000C5E5

// XEVENT_XUACS_RESTORE_ACCOUNT_BLOCKED_1, 50662, Warning
#define XEVENT_XUACS_RESTORE_ACCOUNT_BLOCKED_1 0x8000C5E6

// XEVENT_XUACS_UNEXPECTED_REQUEST_2, 50663, Warning
#define XEVENT_XUACS_UNEXPECTED_REQUEST_2 0x8000C5E7

// XEVENT_XUACS_GRADUATE_USER_NO_PRIVILEGE, 50673, Error
#define XEVENT_XUACS_GRADUATE_USER_NO_PRIVILEGE 0xC000C5F1

// XEVENT_XUACS_GRADUATE_USER_NOT_CHILD, 50674, Error
#define XEVENT_XUACS_GRADUATE_USER_NOT_CHILD 0xC000C5F2

// XEVENT_XUACS_GRADUATE_USER_NOT_ADULT, 50675, Error
#define XEVENT_XUACS_GRADUATE_USER_NOT_ADULT 0xC000C5F3

// XEVENT_XUACS_GRADUATE_USER_NO_PI, 50676, Error
#define XEVENT_XUACS_GRADUATE_USER_NO_PI 0xC000C5F4

// XEVENT_XUACS_GRADUATE_USER_ADD_PI_ERROR, 50677, Error
#define XEVENT_XUACS_GRADUATE_USER_ADD_PI_ERROR 0xC000C5F5

// XEVENT_XUACS_GRADUATE_USER_ALREADY, 50678, Error
#define XEVENT_XUACS_GRADUATE_USER_ALREADY 0xC000C5F6

// XEVENT_XUACS_GRADUATE_USER_IMPERSONATION_ERROR, 50683, Error
#define XEVENT_XUACS_GRADUATE_USER_IMPERSONATION_ERROR 0xC000C5FB

// XEVENT_XUACS_CLIENT_TYPE_MISSING, 50684, Error
#define XEVENT_XUACS_CLIENT_TYPE_MISSING 0xC000C5FC

// XEVENT_XUACS_CLIENT_TYPE_INVALID, 50685, Error
#define XEVENT_XUACS_CLIENT_TYPE_INVALID 0xC000C5FD

// XEVENT_XUACS_CLIENT_TYPE_CONFIG_ERROR, 50686, Error
#define XEVENT_XUACS_CLIENT_TYPE_CONFIG_ERROR 0xC000C5FE

// XEVENT_BILLING_USERACCOUNT_CODE_0, 62675, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_0 0xC000F4D3

// XEVENT_BILLING_USERACCOUNT_CODE_1, 62676, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_1 0xC000F4D4

// XEVENT_BILLING_USERACCOUNT_CODE_2, 62677, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_2 0xC000F4D5

// XEVENT_BILLING_USERACCOUNT_CODE_3, 62678, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_3 0xC000F4D6

// XEVENT_BILLING_USERACCOUNT_CODE_4, 62679, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_4 0xC000F4D7

// XEVENT_BILLING_USERACCOUNT_CODE_5, 62680, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_5 0xC000F4D8

// XEVENT_BILLING_USERACCOUNT_CODE_6, 62681, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_6 0xC000F4D9

// XEVENT_BILLING_USERACCOUNT_CODE_7, 62682, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_7 0xC000F4DA

// XEVENT_BILLING_USERACCOUNT_CODE_8, 62683, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_8 0xC000F4DB

// XEVENT_BILLING_USERACCOUNT_CODE_9, 62684, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_9 0xC000F4DC

// XEVENT_BILLING_USERACCOUNT_CODE_10, 62685, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_10 0xC000F4DD

// XEVENT_BILLING_USERACCOUNT_CODE_11, 62686, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_11 0xC000F4DE

// XEVENT_BILLING_USERACCOUNT_CODE_12, 62687, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_12 0xC000F4DF

// XEVENT_BILLING_USERACCOUNT_CODE_13, 62688, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_13 0xC000F4E0

// XEVENT_BILLING_USERACCOUNT_CODE_14, 62689, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_14 0xC000F4E1

// XEVENT_BILLING_USERACCOUNT_CODE_15, 62690, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_15 0xC000F4E2

// XEVENT_BILLING_USERACCOUNT_CODE_16, 62691, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_16 0xC000F4E3

// XEVENT_BILLING_USERACCOUNT_CODE_17, 62692, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_17 0xC000F4E4

// XEVENT_BILLING_USERACCOUNT_CODE_18, 62693, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_18 0xC000F4E5

// XEVENT_BILLING_USERACCOUNT_CODE_19, 62694, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_19 0xC000F4E6

// XEVENT_BILLING_USERACCOUNT_CODE_20, 62695, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_20 0xC000F4E7

// XEVENT_BILLING_USERACCOUNT_CODE_21, 62696, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_21 0xC000F4E8

// XEVENT_BILLING_USERACCOUNT_CODE_22, 62697, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_22 0xC000F4E9

// XEVENT_BILLING_USERACCOUNT_CODE_23, 62698, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_23 0xC000F4EA

// XEVENT_BILLING_USERACCOUNT_CODE_24, 62699, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_24 0xC000F4EB

// XEVENT_BILLING_USERACCOUNT_CODE_25, 62700, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_25 0xC000F4EC

// XEVENT_BILLING_USERACCOUNT_CODE_26, 62701, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_26 0xC000F4ED

// XEVENT_BILLING_USERACCOUNT_CODE_27, 62702, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_27 0xC000F4EE

// XEVENT_BILLING_USERACCOUNT_CODE_28, 62703, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_28 0xC000F4EF

// XEVENT_BILLING_USERACCOUNT_CODE_29, 62704, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_29 0xC000F4F0

// XEVENT_BILLING_USERACCOUNT_CODE_30, 62705, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_30 0xC000F4F1

// XEVENT_BILLING_USERACCOUNT_CODE_31, 62706, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_31 0xC000F4F2

// XEVENT_BILLING_USERACCOUNT_CODE_32, 62707, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_32 0xC000F4F3

// XEVENT_BILLING_USERACCOUNT_CODE_33, 62708, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_33 0xC000F4F4

// XEVENT_BILLING_USERACCOUNT_CODE_34, 62709, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_34 0xC000F4F5

// XEVENT_BILLING_USERACCOUNT_CODE_35, 62710, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_35 0xC000F4F6

// XEVENT_BILLING_USERACCOUNT_CODE_36, 62711, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_36 0xC000F4F7

// XEVENT_BILLING_USERACCOUNT_CODE_37, 62712, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_37 0xC000F4F8

// XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_38, 62713, Error
#define XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_38 0xC000F4F9

// XEVENT_BILLING_USERACCOUNT_CODE_39, 62714, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_39 0xC000F4FA

// XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_40, 62715, Error
#define XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_40 0xC000F4FB

// XEVENT_BILLING_USERACCOUNT_CODE_41, 62716, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_41 0xC000F4FC

// XEVENT_BILLING_USERACCOUNT_CODE_42, 62717, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_42 0xC000F4FD

// XEVENT_BILLING_USERACCOUNT_CODE_43, 62718, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_43 0xC000F4FE

// XEVENT_BILLING_USERACCOUNT_CODE_44, 62719, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_44 0xC000F4FF

// XEVENT_BILLING_USERACCOUNT_CODE_45, 62720, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_45 0xC000F500

// XEVENT_BILLING_USERACCOUNT_CODE_46, 62721, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_46 0xC000F501

// XEVENT_BILLING_USERACCOUNT_CODE_47, 62722, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_47 0xC000F502

// XEVENT_BILLING_USERACCOUNT_CODE_48, 62723, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_48 0xC000F503

// XEVENT_BILLING_USERACCOUNT_CODE_49, 62724, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_49 0xC000F504

// XEVENT_BILLING_USERACCOUNT_CODE_50, 62725, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_50 0xC000F505

// XEVENT_BILLING_USERACCOUNT_CODE_51, 62726, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_51 0xC000F506

// XEVENT_BILLING_USERACCOUNT_CODE_52, 62727, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_52 0xC000F507

// XEVENT_BILLING_USERACCOUNT_CODE_53, 62728, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_53 0xC000F508

// XEVENT_BILLING_USERACCOUNT_CODE_54, 62729, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_54 0xC000F509

// XEVENT_BILLING_USERACCOUNT_CODE_55, 62730, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_55 0xC000F50A

// XEVENT_BILLING_USERACCOUNT_CODE_56, 62731, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_56 0xC000F50B

// XEVENT_BILLING_USERACCOUNT_CODE_57, 62732, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_57 0xC000F50C

// XEVENT_BILLING_USERACCOUNT_CODE_58, 62733, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_58 0xC000F50D

// XEVENT_BILLING_USERACCOUNT_CODE_59, 62734, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_59 0xC000F50E

// XEVENT_BILLING_USERACCOUNT_CODE_60, 62735, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_60 0xC000F50F

// XEVENT_BILLING_USERACCOUNT_CODE_61, 62736, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_61 0xC000F510

// XEVENT_BILLING_USERACCOUNT_CODE_62, 62737, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_62 0xC000F511

// XEVENT_BILLING_USERACCOUNT_CODE_63, 62738, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_63 0xC000F512

// XEVENT_BILLING_USERACCOUNT_CODE_64, 62739, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_64 0xC000F513

// XEVENT_BILLING_USERACCOUNT_CODE_65, 62740, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_65 0xC000F514

// XEVENT_BILLING_USERACCOUNT_CODE_66, 62741, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_66 0xC000F515

// XEVENT_BILLING_USERACCOUNT_CODE_67, 62742, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_67 0xC000F516

// XEVENT_BILLING_USERACCOUNT_CODE_68, 62743, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_68 0xC000F517

// XEVENT_BILLING_USERACCOUNT_CODE_69, 62744, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_69 0xC000F518

// XEVENT_BILLING_USERACCOUNT_CODE_70, 62745, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_70 0xC000F519

// XEVENT_BILLING_USERACCOUNT_CODE_71, 62746, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_71 0xC000F51A

// XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_72, 62747, Error
#define XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_72 0xC000F51B

// XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_73, 62748, Error
#define XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_73 0xC000F51C

// XEVENT_BILLING_USERACCOUNT_CODE_74, 62749, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_74 0xC000F51D

// XEVENT_BILLING_USERACCOUNT_CODE_75, 62750, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_75 0xC000F51E

// XEVENT_BILLING_USERACCOUNT_CODE_76, 62751, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_76 0xC000F51F

// XEVENT_BILLING_USERACCOUNT_CODE_77, 62752, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_77 0xC000F520

// XEVENT_BILLING_USERACCOUNT_CODE_78, 62753, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_78 0xC000F521

// XEVENT_BILLING_USERACCOUNT_CODE_79, 62754, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_79 0xC000F522

// XEVENT_BILLING_USERACCOUNT_CODE_80, 62755, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_80 0xC000F523

// XEVENT_BILLING_USERACCOUNT_CODE_81, 62756, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_81 0xC000F524

// XEVENT_BILLING_USERACCOUNT_CODE_82, 62757, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_82 0xC000F525

// XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_83, 62758, Error
#define XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_83 0xC000F526

// XEVENT_BILLING_USERACCOUNT_CODE_84, 62759, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_84 0xC000F527

// XEVENT_BILLING_USERACCOUNT_CODE_85, 62760, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_85 0xC000F528

// XEVENT_BILLING_USERACCOUNT_CODE_86, 62761, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_86 0xC000F529

// XEVENT_BILLING_USERACCOUNT_CODE_87, 62762, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_87 0xC000F52A

// XEVENT_BILLING_USERACCOUNT_CODE_88, 62763, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_88 0xC000F52B

// XEVENT_BILLING_USERACCOUNT_CODE_89, 62764, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_89 0xC000F52C

// XEVENT_BILLING_USERACCOUNT_CODE_90, 62765, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_90 0xC000F52D

// XEVENT_BILLING_USERACCOUNT_CODE_91, 62766, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_91 0xC000F52E

// XEVENT_BILLING_USERACCOUNT_CODE_92, 62767, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_92 0xC000F52F

// XEVENT_BILLING_USERACCOUNT_CODE_93, 62768, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_93 0xC000F530

// XEVENT_BILLING_USERACCOUNT_CODE_94, 62769, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_94 0xC000F531

// XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_95, 62770, Error
#define XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_95 0xC000F532

// XEVENT_BILLING_USERACCOUNT_CODE_96, 62771, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_96 0xC000F533

// XEVENT_BILLING_USERACCOUNT_CODE_97, 62772, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_97 0xC000F534

// XEVENT_BILLING_USERACCOUNT_CODE_98, 62773, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_98 0xC000F535

// XEVENT_BILLING_USERACCOUNT_CODE_99, 62774, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_99 0xC000F536

// XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_100, 62775, Error
#define XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_100 0xC000F537

// XEVENT_BILLING_USERACCOUNT_CODE_101, 62776, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_101 0xC000F538

// XEVENT_BILLING_USERACCOUNT_CODE_102, 62777, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_102 0xC000F539

// XEVENT_BILLING_USERACCOUNT_CODE_103, 62778, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_103 0xC000F53A

// XEVENT_BILLING_USERACCOUNT_CODE_104, 62779, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_104 0xC000F53B

// XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_105, 62780, Error
#define XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_105 0xC000F53C

// XEVENT_BILLING_USERACCOUNT_NOT_CONNECTED_106, 62781, Error
#define XEVENT_BILLING_USERACCOUNT_NOT_CONNECTED_106 0xC000F53D

// XEVENT_BILLING_USERACCOUNT_CODE_107, 62782, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_107 0xC000F53E

// XEVENT_BILLING_USERACCOUNT_CODE_108, 62783, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_108 0xC000F53F

// XEVENT_BILLING_USERACCOUNT_CODE_109, 62784, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_109 0xC000F540

// XEVENT_BILLING_USERACCOUNT_CODE_110, 62785, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_110 0xC000F541

// XEVENT_BILLING_USERACCOUNT_CODE_111, 62786, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_111 0xC000F542

// XEVENT_BILLING_USERACCOUNT_CODE_112, 62787, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_112 0xC000F543

// XEVENT_BILLING_USERACCOUNT_CODE_113, 62788, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_113 0xC000F544

// XEVENT_BILLING_USERACCOUNT_CODE_114, 62789, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_114 0xC000F545

// XEVENT_BILLING_USERACCOUNT_CODE_115, 62790, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_115 0xC000F546

// XEVENT_BILLING_USERACCOUNT_CODE_116, 62791, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_116 0xC000F547

// XEVENT_BILLING_USERACCOUNT_CODE_117, 62792, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_117 0xC000F548

// XEVENT_BILLING_USERACCOUNT_CODE_118, 62793, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_118 0xC000F549

// XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_119, 62794, Error
#define XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_119 0xC000F54A

// XEVENT_BILLING_USERACCOUNT_CODE_120, 62795, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_120 0xC000F54B

// XEVENT_BILLING_USERACCOUNT_CODE_121, 62796, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_121 0xC000F54C

// XEVENT_BILLING_USERACCOUNT_CODE_122, 62797, Error
#define XEVENT_BILLING_USERACCOUNT_CODE_122 0xC000F54D

// XEVENT_BILLING_USERACCOUNT_FRIEND_PMN_ERROR, 62798, Error
#define XEVENT_BILLING_USERACCOUNT_FRIEND_PMN_ERROR 0xC000F54E

// XEVENT_BILLING_USERACCOUNT_BUDDY_GAMERTAG_ERROR, 62799, Error
#define XEVENT_BILLING_USERACCOUNT_BUDDY_GAMERTAG_ERROR 0xC000F54F

// XEVENT_BILLING_USERACCOUNT_CONTACTLIST_GAMERTAGS_ERROR_0, 62800, Error
#define XEVENT_BILLING_USERACCOUNT_CONTACTLIST_GAMERTAGS_ERROR_0 0xC000F550

// XEVENT_BILLING_USERACCOUNT_CONTACTLIST_GAMERTAGS_ERROR_1, 62801, Error
#define XEVENT_BILLING_USERACCOUNT_CONTACTLIST_GAMERTAGS_ERROR_1 0xC000F551

// XEVENT_BILLING_SWITCH_USER_PASSPORT_NOT_LINKED, 62802, Error
#define XEVENT_BILLING_SWITCH_USER_PASSPORT_NOT_LINKED 0xC000F552

// XEVENT_BILLING_SWITCH_USER_PASSPORT_LOAD_USER_FAILED, 62803, Error
#define XEVENT_BILLING_SWITCH_USER_PASSPORT_LOAD_USER_FAILED 0xC000F553

// XEVENT_BILLING_SWITCH_USER_PASSPORT_INVALID_USER, 62804, Error
#define XEVENT_BILLING_SWITCH_USER_PASSPORT_INVALID_USER 0xC000F554

// XEVENT_BILLING_USERACCOUNT_PAYMENT_INSTRUMENT_ADDITION_RESTRICTED, 62808, Error
#define XEVENT_BILLING_USERACCOUNT_PAYMENT_INSTRUMENT_ADDITION_RESTRICTED 0xC000F558

// XEVENT_BILLING_USERACCOUNT_PAYMENT_INSTRUMENT_REMOVAL_RESTRICTED, 62809, Error
#define XEVENT_BILLING_USERACCOUNT_PAYMENT_INSTRUMENT_REMOVAL_RESTRICTED 0xC000F559

// XEVENT_BILLING_USERACCOUNT_PAYMENT_INSTRUMENT_CHANGES_RESTRICTED, 62810, Error
#define XEVENT_BILLING_USERACCOUNT_PAYMENT_INSTRUMENT_CHANGES_RESTRICTED 0xC000F55A

// XEVENT_BILLING_USERACCOUNT_PASSPORT_SWITCHING_RESTRICTED, 62811, Error
#define XEVENT_BILLING_USERACCOUNT_PASSPORT_SWITCHING_RESTRICTED 0xC000F55B

// XEVENT_BILLING_USERACCOUNT_INVALID_CLIENT, 62812, Error
#define XEVENT_BILLING_USERACCOUNT_INVALID_CLIENT 0xC000F55C

// XEVENT_BILLING_USERACCOUNT_USER_NOT_FOUND, 62813, Error
#define XEVENT_BILLING_USERACCOUNT_USER_NOT_FOUND 0xC000F55D

// XEVENT_BILLING_USERACCOUNT_PUID_TO_ANID_FAILED, 62814, Error
#define XEVENT_BILLING_USERACCOUNT_PUID_TO_ANID_FAILED 0xC000F55E

// XEVENT_BILLING_USERACCOUNT_MUSICNET_FAILURE, 62815, Error
#define XEVENT_BILLING_USERACCOUNT_MUSICNET_FAILURE 0xC000F55F

// XEVENT_BILLING_USERACCOUNT_XUID_DOES_NOT_MATCH_USER, 62816, Error
#define XEVENT_BILLING_USERACCOUNT_XUID_DOES_NOT_MATCH_USER 0xC000F560

// XEVENT_BILLING_USERACCOUNT_AUTHDATA_VERIFICATION_ERROR, 62817, Error
#define XEVENT_BILLING_USERACCOUNT_AUTHDATA_VERIFICATION_ERROR 0xC000F561

// XEVENT_BILLING_CREATE_ACCOUNT_TWO_PASSPORTS, 62818, Error
#define XEVENT_BILLING_CREATE_ACCOUNT_TWO_PASSPORTS 0xC000F562

// XEVENT_BILLING_QUEUE_RESET_ITEMS_ERROR, 62820, Error
#define XEVENT_BILLING_QUEUE_RESET_ITEMS_ERROR 0xC000F564

// XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_123, 62822, Error
#define XEVENT_BILLING_QUEUED_ACCOUNT_NOT_FOUND_123 0xC000F566

// XEVENT_BILLING_ACCOUNTS_VERIFY_BILLING_INFO_ERROR, 64256, Error
#define XEVENT_BILLING_ACCOUNTS_VERIFY_BILLING_INFO_ERROR 0xC000FB00

// XEVENT_BILLING_ACCOUNTS_SET_NO_AGE_OUT_QUEUE_ERROR, 64257, Error
#define XEVENT_BILLING_ACCOUNTS_SET_NO_AGE_OUT_QUEUE_ERROR 0xC000FB01

// XEVENT_BILLING_ACCOUNTS_SET_NO_AGE_OUT_IMPERSONATION_ERROR, 64258, Error
#define XEVENT_BILLING_ACCOUNTS_SET_NO_AGE_OUT_IMPERSONATION_ERROR 0xC000FB02

// XEVENT_BILLING_ACCOUNTS_SET_NO_AGE_OUT_DEQUEUE_ERROR, 64259, Error
#define XEVENT_BILLING_ACCOUNTS_SET_NO_AGE_OUT_DEQUEUE_ERROR 0xC000FB03

// XEVENT_BILLING_ACCOUNTS_SET_NO_AGE_OUT_GET_PENDING_ERROR, 64260, Error
#define XEVENT_BILLING_ACCOUNTS_SET_NO_AGE_OUT_GET_PENDING_ERROR 0xC000FB04

// XEVENT_BILLING_ACCOUNTS_SET_NO_AGE_OUT_TIMER_ERROR, 64261, Error
#define XEVENT_BILLING_ACCOUNTS_SET_NO_AGE_OUT_TIMER_ERROR 0xC000FB05

// XEVENT_BILLING_ACCOUNTS_GET_NO_AGE_OUT_BLOCKED, 64262, Error
#define XEVENT_BILLING_ACCOUNTS_GET_NO_AGE_OUT_BLOCKED 0xC000FB06

// XEVENT_BILLING_ACCOUNTS_UPS_UPDATE_PROFILE_FAILED, 64263, Error
#define XEVENT_BILLING_ACCOUNTS_UPS_UPDATE_PROFILE_FAILED 0xC000FB07

// XEVENT_BILLING_ACCOUNTS_GET_POINTS_BALANCE_ERROR, 64264, Error
#define XEVENT_BILLING_ACCOUNTS_GET_POINTS_BALANCE_ERROR 0xC000FB08

// XEVENT_BILLING_ACCOUNTS_VERIFY_PARENT_CREDIT_CARD_ERROR, 64265, Error
#define XEVENT_BILLING_ACCOUNTS_VERIFY_PARENT_CREDIT_CARD_ERROR 0xC000FB09

// XEVENT_BILLING_ACCOUNTS_ADD_PAYMENT_INSTRUMENT_ERROR, 64266, Error
#define XEVENT_BILLING_ACCOUNTS_ADD_PAYMENT_INSTRUMENT_ERROR 0xC000FB0A

// XEVENT_BILLING_ACCOUNTS_GET_PAYMENT_INSTRUMENTS_ERROR, 64267, Error
#define XEVENT_BILLING_ACCOUNTS_GET_PAYMENT_INSTRUMENTS_ERROR 0xC000FB0B

// XEVENT_BILLING_ACCOUNTS_CHANGE_PAYMENT_INSTURMENT_ERROR, 64268, Error
#define XEVENT_BILLING_ACCOUNTS_CHANGE_PAYMENT_INSTURMENT_ERROR 0xC000FB0C

// XEVENT_BILLING_ACCOUNTS_GET_ACCOUNT_INFO_ERROR, 64269, Error
#define XEVENT_BILLING_ACCOUNTS_GET_ACCOUNT_INFO_ERROR 0xC000FB0D

// XEVENT_BILLING_ACCOUNTS_PAYPAL_UNSUPPORTED_COUNTRY, 64270, Error
#define XEVENT_BILLING_ACCOUNTS_PAYPAL_UNSUPPORTED_COUNTRY 0xC000FB0E

// XEVENT_BILLING_ACCOUNTS_ADD_PAYPAL_PAYIN_ERROR, 64271, Error
#define XEVENT_BILLING_ACCOUNTS_ADD_PAYPAL_PAYIN_ERROR 0xC000FB0F

// XEVENT_BILLING_ACCOUNTS_BILLING_NOT_CONNECTED, 64272, Error
#define XEVENT_BILLING_ACCOUNTS_BILLING_NOT_CONNECTED 0xC000FB10

// XEVENT_BILLING_DECLINE_NOTIFICATION_VALUE_NEGATIVE, 64273, Warning
#define XEVENT_BILLING_DECLINE_NOTIFICATION_VALUE_NEGATIVE 0x8000FB11

// XEVENT_XUACS_FAMILY_HISTORY_GET_ERROR, 64274, Error
#define XEVENT_XUACS_FAMILY_HISTORY_GET_ERROR 0xC000FB12

// XEVENT_XUACS_SET_FREE_GAMERTAG_ELIGIBLE_ERROR, 64275, Error
#define XEVENT_XUACS_SET_FREE_GAMERTAG_ELIGIBLE_ERROR 0xC000FB13

// XEVENT_XUACS_SET_FAMILY_GOLD_SEAT_EXEMPTION_ERROR, 64276, Error
#define XEVENT_XUACS_SET_FAMILY_GOLD_SEAT_EXEMPTION_ERROR 0xC000FB14

// XEVENT_RATINGS_FD_SUBMITRATING, 15550, Error
#define XEVENT_RATINGS_FD_SUBMITRATING 0xC0003CBE

// XEVENT_RATINGS_PROTOCOL_ERROR, 15551, Error
#define XEVENT_RATINGS_PROTOCOL_ERROR 0xC0003CBF

// XEVENT_RATINGS_COMMON_MEDIA, 15552, Error
#define XEVENT_RATINGS_COMMON_MEDIA 0xC0003CC0

// XEVENT_RATINGS_UNKNOWN_RATING_ERROR, 15553, Error
#define XEVENT_RATINGS_UNKNOWN_RATING_ERROR 0xC0003CC1

// XEVENT_RATINGS_INVALID_ARGS, 15554, Error
#define XEVENT_RATINGS_INVALID_ARGS 0xC0003CC2

// XEVENT_RATINGS_MSN_ERROR, 15555, Error
#define XEVENT_RATINGS_MSN_ERROR 0xC0003CC3

// XEVENT_RATINGS_CONFIG_MULTISETTINGS_ERROR, 15556, Error
#define XEVENT_RATINGS_CONFIG_MULTISETTINGS_ERROR 0xC0003CC4

// XEVENT_RATINGS_CONFIG_MULTISETTINGS_LOAD, 15557, Info
#define XEVENT_RATINGS_CONFIG_MULTISETTINGS_LOAD 0x40003CC5

// XEVENT_XONLINE_E_RATINGS_CONTENTTYPE_LOAD, 15558, Info
#define XEVENT_XONLINE_E_RATINGS_CONTENTTYPE_LOAD 0x40003CC6

// XEVENT_RATINGS_FD_GETRATING, 15559, Error
#define XEVENT_RATINGS_FD_GETRATING 0xC0003CC7

// XEVENT_XONLINE_E_RATINGS_CRON_ERROR, 15560, Error
#define XEVENT_XONLINE_E_RATINGS_CRON_ERROR 0xC0003CC8

// XEVENT_RATINGS_CONFIG_SETTINGS_LOAD, 15561, Info
#define XEVENT_RATINGS_CONFIG_SETTINGS_LOAD 0x40003CC9

// XEVENT_XONLINE_E_RATINGS_CRON_JOB_FAILED, 15562, Error
#define XEVENT_XONLINE_E_RATINGS_CRON_JOB_FAILED 0xC0003CCA

// XEVENT_XONLINE_E_RATINGS_CRON_JOB_SUCCESS, 15563, Info
#define XEVENT_XONLINE_E_RATINGS_CRON_JOB_SUCCESS 0x40003CCB

// XEVENT_XONLINE_E_RATINGS_HACK_1, 15564, Warning
#define XEVENT_XONLINE_E_RATINGS_HACK_1 0x80003CCC

// XEVENT_XONLINE_E_RATINGS_HACK_2, 15565, Warning
#define XEVENT_XONLINE_E_RATINGS_HACK_2 0x80003CCD

// XEVENT_CONTENTINGESTION_ERROR_UNKNOWN, 15001, Error
#define XEVENT_CONTENTINGESTION_ERROR_UNKNOWN 0xC0003A99

// XEVENT_CONTENTINGESTION_ERROR_INTERFACE, 15002, Error
#define XEVENT_CONTENTINGESTION_ERROR_INTERFACE 0xC0003A9A

// XEVENT_CONTENTINGESTION_ERROR_WEBCONFIGURATION, 15003, Warning
#define XEVENT_CONTENTINGESTION_ERROR_WEBCONFIGURATION 0x80003A9B

// XEVENT_CONTENTINGESTION_INVALID_ARGS, 15004, Error
#define XEVENT_CONTENTINGESTION_INVALID_ARGS 0xC0003A9C

// XEVENT_STS_FD_ERROR, 15000, Error
#define XEVENT_STS_FD_ERROR 0xC0003A98

// XEVENT_STS_FD_CONFIGERROR, 15001, Error
#define XEVENT_STS_FD_CONFIGERROR 0xC0003A99

// XEVENT_STS_GETSECURITYTICKET_ERROR, 15002, Error
#define XEVENT_STS_GETSECURITYTICKET_ERROR 0xC0003A9A

// XEVENT_KDC_POLICYCHECK_TITLEID_MULTIPLEGROUPS, 40000, Warning
#define XEVENT_KDC_POLICYCHECK_TITLEID_MULTIPLEGROUPS 0x80009C40

// XEVENT_KDC_DUPLICATE_TITLEKEY, 40001, Error
#define XEVENT_KDC_DUPLICATE_TITLEKEY 0xC0009C41

// XEVENT_TEST_FD_GENERIC, 15000, Error
#define XEVENT_TEST_FD_GENERIC 0xC0003A98

// XEVENT_TESTREFL_STARTED, 15100, Info
#define XEVENT_TESTREFL_STARTED 0x40003AFC

// XEVENT_TESTREFL_SHUTDOWN, 15101, Info
#define XEVENT_TESTREFL_SHUTDOWN 0x40003AFD

// XEVENT_TESTREFL_STARTUP_FAILURE, 15102, Error
#define XEVENT_TESTREFL_STARTUP_FAILURE 0xC0003AFE

// XEVENT_TESTREFL_THREAD_FAILURE, 15103, Error
#define XEVENT_TESTREFL_THREAD_FAILURE 0xC0003AFF

// XEVENT_MESSAGING_HEADER_TRUNCATED, 15000, Warning
#define XEVENT_MESSAGING_HEADER_TRUNCATED 0x80003A98

// XEVENT_MESSAGING_REQUEST_TRUNCATED, 15001, Warning
#define XEVENT_MESSAGING_REQUEST_TRUNCATED 0x80003A99

// XEVENT_MESSAGING_NO_VINTERFACE, 15002, Warning
#define XEVENT_MESSAGING_NO_VINTERFACE 0x80003A9A

// XEVENT_MESSAGING_BAD_CONTENT_TYPE, 15003, Warning
#define XEVENT_MESSAGING_BAD_CONTENT_TYPE 0x80003A9B

// XEVENT_MESSAGING_NOTIFICATION_MESSAGE_TRUNCATED, 15004, Warning
#define XEVENT_MESSAGING_NOTIFICATION_MESSAGE_TRUNCATED 0x80003A9C

// XEVENT_MESSAGING_INVALID_USERID, 15005, Error
#define XEVENT_MESSAGING_INVALID_USERID 0xC0003A9D

// XEVENT_MESSAGING_INVALID_DC_MESSAGE_TYPE, 15006, Warning
#define XEVENT_MESSAGING_INVALID_DC_MESSAGE_TYPE 0x80003A9E

// XEVENT_MESSAGING_INVALID_CLIENT_MESSAGE_TYPE, 15007, Warning
#define XEVENT_MESSAGING_INVALID_CLIENT_MESSAGE_TYPE 0x80003A9F

// XEVENT_MESSAGING_DO_NOT_LOG_EVENT, 15008, Info
#define XEVENT_MESSAGING_DO_NOT_LOG_EVENT 0x40003AA0

// XEVENT_MESSAGING_SGINFO_INVALID_PUID, 15009, Error
#define XEVENT_MESSAGING_SGINFO_INVALID_PUID 0xC0003AA1

// XEVENT_MESSAGING_UNKNOWN_MESSAGE_TYPE, 15010, Warning
#define XEVENT_MESSAGING_UNKNOWN_MESSAGE_TYPE 0x80003AA2

// XEVENT_MESSAGING_GETMESSAGESUMMARY_INVALID_USERID, 15020, Error
#define XEVENT_MESSAGING_GETMESSAGESUMMARY_INVALID_USERID 0xC0003AAC

// XEVENT_MESSAGING_GETMESSAGESUMMARY_INVALID_MESSAGEID, 15021, Warning
#define XEVENT_MESSAGING_GETMESSAGESUMMARY_INVALID_MESSAGEID 0x80003AAD

// XEVENT_MESSAGING_GETMESSAGESUMMARY_MESSAGEID_FROM_FAILED_SEND, 15022, Warning
#define XEVENT_MESSAGING_GETMESSAGESUMMARY_MESSAGEID_FROM_FAILED_SEND 0x80003AAE

// XEVENT_MESSAGING_GETMESSAGEDETAILS_INVALID_USERID, 15030, Error
#define XEVENT_MESSAGING_GETMESSAGEDETAILS_INVALID_USERID 0xC0003AB6

// XEVENT_MESSAGING_GETMESSAGEDETAILS_SETUNSET_SAME_FLAGS, 15031, Warning
#define XEVENT_MESSAGING_GETMESSAGEDETAILS_SETUNSET_SAME_FLAGS 0x80003AB7

// XEVENT_MESSAGING_GETMESSAGEDETAILS_SET_INVALID_FLAGS, 15032, Warning
#define XEVENT_MESSAGING_GETMESSAGEDETAILS_SET_INVALID_FLAGS 0x80003AB8

// XEVENT_MESSAGING_GETMESSAGEDETAILS_UNSET_INVALID_FLAGS, 15033, Warning
#define XEVENT_MESSAGING_GETMESSAGEDETAILS_UNSET_INVALID_FLAGS 0x80003AB9

// XEVENT_MESSAGING_GETMESSAGEDETAILS_INVALID_MESSAGEID, 15034, Warning
#define XEVENT_MESSAGING_GETMESSAGEDETAILS_INVALID_MESSAGEID 0x80003ABA

// XEVENT_MESSAGING_ENUMERATEMESSAGES_INVALID_USERID, 15040, Error
#define XEVENT_MESSAGING_ENUMERATEMESSAGES_INVALID_USERID 0xC0003AC0

// XEVENT_MESSAGING_DELETEMESSAGE_INVALID_USERID, 15050, Error
#define XEVENT_MESSAGING_DELETEMESSAGE_INVALID_USERID 0xC0003ACA

// XEVENT_MESSAGING_DELETEMESSAGE_INVALID_FLAGS, 15051, Warning
#define XEVENT_MESSAGING_DELETEMESSAGE_INVALID_FLAGS 0x80003ACB

// XEVENT_MESSAGING_DELETEMESSAGE_MESSAGEID_FROM_FAILED_SEND, 15052, Warning
#define XEVENT_MESSAGING_DELETEMESSAGE_MESSAGEID_FROM_FAILED_SEND 0x80003ACC

// XEVENT_MESSAGING_DELETEMESSAGE_INVALID_MESSAGEID, 15053, Warning
#define XEVENT_MESSAGING_DELETEMESSAGE_INVALID_MESSAGEID 0x80003ACD

// XEVENT_MESSAGING_GETSYSTEMMESSAGEDETAILS_INVALID_MESSAGEID, 15060, Warning
#define XEVENT_MESSAGING_GETSYSTEMMESSAGEDETAILS_INVALID_MESSAGEID 0x80003AD4

// XEVENT_MESSAGING_GETSYSTEMMESSAGEDETAILS_MESSAGE_NOT_FOUND, 15061, Warning
#define XEVENT_MESSAGING_GETSYSTEMMESSAGEDETAILS_MESSAGE_NOT_FOUND 0x80003AD5

// XEVENT_MESSAGING_DELETESYSTEMMESSAGE_INVALID_MESSAGEID, 15070, Warning
#define XEVENT_MESSAGING_DELETESYSTEMMESSAGE_INVALID_MESSAGEID 0x80003ADE

// XEVENT_MESSAGING_DELETESYSTEMMESSAGE_MESSAGE_NOT_FOUND, 15071, Warning
#define XEVENT_MESSAGING_DELETESYSTEMMESSAGE_MESSAGE_NOT_FOUND 0x80003ADF

// XEVENT_MESSAGING_MESSAGEFLAGS_INVALID_USERID, 15080, Error
#define XEVENT_MESSAGING_MESSAGEFLAGS_INVALID_USERID 0xC0003AE8

// XEVENT_MESSAGING_MESSAGEFLAGS_SET_AND_UNSET, 15081, Error
#define XEVENT_MESSAGING_MESSAGEFLAGS_SET_AND_UNSET 0xC0003AE9

// XEVENT_MESSAGING_MESSAGEFLAGS_FLAG_NOT_SETABLE, 15082, Error
#define XEVENT_MESSAGING_MESSAGEFLAGS_FLAG_NOT_SETABLE 0xC0003AEA

// XEVENT_MESSAGING_MESSAGEFLAGS_FLAG_NOT_UNSETABLE, 15083, Error
#define XEVENT_MESSAGING_MESSAGEFLAGS_FLAG_NOT_UNSETABLE 0xC0003AEB

// XEVENT_MESSAGING_MESSAGEFLAGS_MESSAGEID_FROM_FAILED_SEND, 15084, Warning
#define XEVENT_MESSAGING_MESSAGEFLAGS_MESSAGEID_FROM_FAILED_SEND 0x80003AEC

// XEVENT_MESSAGING_MESSAGEFLAGS_INVALID_MESSAGEID, 15085, Warning
#define XEVENT_MESSAGING_MESSAGEFLAGS_INVALID_MESSAGEID 0x80003AED

// XEVENT_MESSAGING_REVOKEMESSAGE_TOO_MANY_RECIPIENTS, 15090, Error
#define XEVENT_MESSAGING_REVOKEMESSAGE_TOO_MANY_RECIPIENTS 0xC0003AF2

// XEVENT_MESSAGING_REVOKEMESSAGE_PROP_SIZE_TOO_LARGE, 15091, Error
#define XEVENT_MESSAGING_REVOKEMESSAGE_PROP_SIZE_TOO_LARGE 0xC0003AF3

// XEVENT_MESSAGING_REVOKEMESSAGE_BLOCK_SENDER_NOT_SPECIFIED, 15092, Error
#define XEVENT_MESSAGING_REVOKEMESSAGE_BLOCK_SENDER_NOT_SPECIFIED 0xC0003AF4

// XEVENT_MESSAGING_REVOKEMESSAGE_CANT_BLOCK_MORE_THAN_ONE, 15093, Error
#define XEVENT_MESSAGING_REVOKEMESSAGE_CANT_BLOCK_MORE_THAN_ONE 0xC0003AF5

// XEVENT_MESSAGING_REVOKEMESSAGE_NO_RECIPIENTS, 15094, Error
#define XEVENT_MESSAGING_REVOKEMESSAGE_NO_RECIPIENTS 0xC0003AF6

// XEVENT_MESSAGING_REVOKEMESSAGE_RECIPIENT_ID_ZERO, 15095, Error
#define XEVENT_MESSAGING_REVOKEMESSAGE_RECIPIENT_ID_ZERO 0xC0003AF7

// XEVENT_MESSAGING_REVOKEMESSAGE_SENDER_ID_ZERO, 15096, Error
#define XEVENT_MESSAGING_REVOKEMESSAGE_SENDER_ID_ZERO 0xC0003AF8

// XEVENT_MESSAGING_REVOKEMESSAGE_BAD_SENDER_CONTEXT, 15097, Error
#define XEVENT_MESSAGING_REVOKEMESSAGE_BAD_SENDER_CONTEXT 0xC0003AF9

// XEVENT_MESSAGING_REVOKEMESSAGE_MISSING_USE_TYPE, 15098, Error
#define XEVENT_MESSAGING_REVOKEMESSAGE_MISSING_USE_TYPE 0xC0003AFA

// XEVENT_MESSAGING_REVOKEMESSAGE_CANT_REVOKE_PERSISTENT_BY_PROP, 15099, Error
#define XEVENT_MESSAGING_REVOKEMESSAGE_CANT_REVOKE_PERSISTENT_BY_PROP 0xC0003AFB

// XEVENT_MESSAGING_REVOKEMESSAGE_BAD_PROP_TAG, 15100, Error
#define XEVENT_MESSAGING_REVOKEMESSAGE_BAD_PROP_TAG 0xC0003AFC

// XEVENT_MESSAGING_REVOKEMESSAGE_BAD_MESSAGE_TYPE, 15101, Error
#define XEVENT_MESSAGING_REVOKEMESSAGE_BAD_MESSAGE_TYPE 0xC0003AFD

// XEVENT_MESSAGING_REVOKEMESSAGE_USE_TYPE_OR_USE_ID_MUST_BE_SET, 15102, Error
#define XEVENT_MESSAGING_REVOKEMESSAGE_USE_TYPE_OR_USE_ID_MUST_BE_SET 0xC0003AFE

// XEVENT_MESSAGING_REVOKEMESSAGE_USING_RESERVED_FLAGS, 15103, Error
#define XEVENT_MESSAGING_REVOKEMESSAGE_USING_RESERVED_FLAGS 0xC0003AFF

// XEVENT_MESSAGING_REVOKEMESSAGE_INVALID_MESSAGE_ID, 15104, Error
#define XEVENT_MESSAGING_REVOKEMESSAGE_INVALID_MESSAGE_ID 0xC0003B00

// XEVENT_MESSAGING_SENDMESSAGE_INVALID_USERID, 15110, Error
#define XEVENT_MESSAGING_SENDMESSAGE_INVALID_USERID 0xC0003B06

// XEVENT_MESSAGING_SENDMESSAGE_INVALID_MESSAGE, 15111, Error
#define XEVENT_MESSAGING_SENDMESSAGE_INVALID_MESSAGE 0xC0003B07

// XEVENT_MESSAGING_SENDMESSAGE_INSUFFICIENT_PRIVILEGES, 15112, Error
#define XEVENT_MESSAGING_SENDMESSAGE_INSUFFICIENT_PRIVILEGES 0xC0003B08

// XEVENT_MESSAGING_SENDMESSAGE_BAD_MESSAGE_TYPE, 15113, Error
#define XEVENT_MESSAGING_SENDMESSAGE_BAD_MESSAGE_TYPE 0xC0003B09

// XEVENT_MESSAGING_SENDSYSTEMMESSAGE_DATABASE_FAILURE, 15120, Error
#define XEVENT_MESSAGING_SENDSYSTEMMESSAGE_DATABASE_FAILURE 0xC0003B10

// XEVENT_MESSAGING_SENDSYSTEMMESSAGE_SPROC_ERROR, 15121, Error
#define XEVENT_MESSAGING_SENDSYSTEMMESSAGE_SPROC_ERROR 0xC0003B11

// XEVENT_MESSAGING_SENDSYSTEMMESSAGE_SYSID_ERROR, 15122, Error
#define XEVENT_MESSAGING_SENDSYSTEMMESSAGE_SYSID_ERROR 0xC0003B12

// XEVENT_MESSAGING_SENDSYSTEMMESSAGE_INVALID_MESSAGE, 15123, Error
#define XEVENT_MESSAGING_SENDSYSTEMMESSAGE_INVALID_MESSAGE 0xC0003B13

// XEVENT_XTOU_GETTERMSOFUSE_GENERIC_ERROR, 15000, Error
#define XEVENT_XTOU_GETTERMSOFUSE_GENERIC_ERROR 0xC0003A98

// XEVENT_XTOU_GETTERMSOFUSE_PARSE_ERROR, 15001, Error
#define XEVENT_XTOU_GETTERMSOFUSE_PARSE_ERROR 0xC0003A99

// XEVENT_XTOU_GETTERMOFUSE_GET_FILE_ERROR, 15002, Error
#define XEVENT_XTOU_GETTERMOFUSE_GET_FILE_ERROR 0xC0003A9A

// XEVENT_XTOU_GETLANGUAGESFORCOUNTRY_GENERIC_ERROR, 15003, Error
#define XEVENT_XTOU_GETLANGUAGESFORCOUNTRY_GENERIC_ERROR 0xC0003A9B

// XEVENT_VORTEX_PERFCOUNTER_FAILURE, 15000, Error
#define XEVENT_VORTEX_PERFCOUNTER_FAILURE 0xC0003A98

// XEVENT_VORTEX_HTTPLISTENER_CALLBACK, 15001, Error
#define XEVENT_VORTEX_HTTPLISTENER_CALLBACK 0xC0003A99

// XEVENT_VORTEX_HTTPLISTENER_NEXTREQUEST, 15002, Error
#define XEVENT_VORTEX_HTTPLISTENER_NEXTREQUEST 0xC0003A9A

// XEVENT_VORTEX_HTTPLISTENER_PROCESSREQUEST, 15003, Warning
#define XEVENT_VORTEX_HTTPLISTENER_PROCESSREQUEST 0x80003A9B

// XEVENT_VORTEX_EVENTPROVIDER_MAKECALLBACK, 15004, Warning
#define XEVENT_VORTEX_EVENTPROVIDER_MAKECALLBACK 0x80003A9C

// XEVENT_VORTEX_SI_QUERY_START, 15005, Error
#define XEVENT_VORTEX_SI_QUERY_START 0xC0003A9D

// XEVENT_VORTEX_SI_QUERY_LOAD, 15006, Error
#define XEVENT_VORTEX_SI_QUERY_LOAD 0xC0003A9E

// XEVENT_VORTEX_SI_QUERYTEMPLATE_LOAD, 15007, Error
#define XEVENT_VORTEX_SI_QUERYTEMPLATE_LOAD 0xC0003A9F

// XEVENT_VORTEX_CONFIG_NPDB, 15008, Warning
#define XEVENT_VORTEX_CONFIG_NPDB 0x80003AA0

// XEVENT_VORTEX_CONFIG_LOCAL, 15009, Warning
#define XEVENT_VORTEX_CONFIG_LOCAL 0x80003AA1

// XEVENT_VORTEX_CONFIG_SAVE, 15010, Warning
#define XEVENT_VORTEX_CONFIG_SAVE 0x80003AA2

// XEVENT_VORTEX_SERVICE_INIT_WARNING, 15011, Warning
#define XEVENT_VORTEX_SERVICE_INIT_WARNING 0x80003AA3

// XEVENT_VORTEX_SERVICE_INIT_ERROR, 15012, Error
#define XEVENT_VORTEX_SERVICE_INIT_ERROR 0xC0003AA4

// XEVENT_VORTEX_VXINPUTADAPTER_START, 15013, Info
#define XEVENT_VORTEX_VXINPUTADAPTER_START 0x40003AA5

// XEVENT_VORTEX_VXINPUTADAPTER_RESUME, 15014, Info
#define XEVENT_VORTEX_VXINPUTADAPTER_RESUME 0x40003AA6

// XEVENT_VORTEX_VXINPUTADAPTER_DISPOSE, 15015, Info
#define XEVENT_VORTEX_VXINPUTADAPTER_DISPOSE 0x40003AA7

// XEVENT_VORTEX_VXINPUTADAPTER_STOP, 15016, Info
#define XEVENT_VORTEX_VXINPUTADAPTER_STOP 0x40003AA8

// XEVENT_VORTEX_VXINPUTADAPTER_PAUSE, 15017, Info
#define XEVENT_VORTEX_VXINPUTADAPTER_PAUSE 0x40003AA9

// XEVENT_VORTEX_VXINPUTADAPTER_CREATEEVENT, 15018, Warning
#define XEVENT_VORTEX_VXINPUTADAPTER_CREATEEVENT 0x80003AAA

// XEVENT_VORTEX_VXINPUTADAPTER_FAIL, 15019, Error
#define XEVENT_VORTEX_VXINPUTADAPTER_FAIL 0xC0003AAB

// XEVENT_VORTEX_CONFIG_RELOAD, 15020, Error
#define XEVENT_VORTEX_CONFIG_RELOAD 0xC0003AAC

// XEVENT_VORTEX_VEI_ADAPTER_UPDATE_SUCCESS, 15021, Info
#define XEVENT_VORTEX_VEI_ADAPTER_UPDATE_SUCCESS 0x40003AAD

// XEVENT_VORTEX_VEI_ADAPTER_UPDATE_FAILURE, 15022, Error
#define XEVENT_VORTEX_VEI_ADAPTER_UPDATE_FAILURE 0xC0003AAE

// XEVENT_VORTEX_VEI_CONFIG_TEMPLATE_LOAD_ERROR, 15023, Error
#define XEVENT_VORTEX_VEI_CONFIG_TEMPLATE_LOAD_ERROR 0xC0003AAF

// XEVENT_VORTEX_VEI_CONFIG_LOG_LOAD_ERROR, 15024, Error
#define XEVENT_VORTEX_VEI_CONFIG_LOG_LOAD_ERROR 0xC0003AB0

// XEVENT_VORTEX_VEI_CONFIG_QUERY_LOAD_ERROR, 15025, Error
#define XEVENT_VORTEX_VEI_CONFIG_QUERY_LOAD_ERROR 0xC0003AB1

// XEVENT_VORTEX_VEI_CONFIG_SCHEMA_VALIDATOR_ERROR, 15026, Error
#define XEVENT_VORTEX_VEI_CONFIG_SCHEMA_VALIDATOR_ERROR 0xC0003AB2

// XEVENT_VORTEX_VEI_CONFIG_DUPLICATE_OBJECT_MAPPER_FIELD, 15027, Error
#define XEVENT_VORTEX_VEI_CONFIG_DUPLICATE_OBJECT_MAPPER_FIELD 0xC0003AB3

// XEVENT_VORTEX_VEI_CONFIG_TEMPLATE_REFERENCE_MISSING, 15028, Error
#define XEVENT_VORTEX_VEI_CONFIG_TEMPLATE_REFERENCE_MISSING 0xC0003AB4

// XEVENT_VORTEX_VEI_CONFIG_DUPLICATE_STREAM_NAME, 15029, Error
#define XEVENT_VORTEX_VEI_CONFIG_DUPLICATE_STREAM_NAME 0xC0003AB5

// XEVENT_VORTEX_VEI_CONFIG_DUPLICATE_SINK_NAME, 15030, Error
#define XEVENT_VORTEX_VEI_CONFIG_DUPLICATE_SINK_NAME 0xC0003AB6

// XEVENT_VORTEX_VEI_INPUT_ADAPTER_START, 15031, Info
#define XEVENT_VORTEX_VEI_INPUT_ADAPTER_START 0x40003AB7

// XEVENT_VORTEX_VEI_INPUT_ADAPTER_RESUME, 15032, Info
#define XEVENT_VORTEX_VEI_INPUT_ADAPTER_RESUME 0x40003AB8

// XEVENT_VORTEX_VEI_INPUT_ADAPTER_CONSUMPTION_ERROR, 15033, Error
#define XEVENT_VORTEX_VEI_INPUT_ADAPTER_CONSUMPTION_ERROR 0xC0003AB9

// XEVENT_VORTEX_VEI_EVENT_BUILDER_FIELD_MISSING, 15034, Error
#define XEVENT_VORTEX_VEI_EVENT_BUILDER_FIELD_MISSING 0xC0003ABA

// XEVENT_VORTEX_VEI_SINK_BUILDER_FIELD_MISSING, 15035, Error
#define XEVENT_VORTEX_VEI_SINK_BUILDER_FIELD_MISSING 0xC0003ABB

// XEVENT_VORTEX_VEI_OUTPUT_ADAPTER_NO_SINKS, 15036, Warning
#define XEVENT_VORTEX_VEI_OUTPUT_ADAPTER_NO_SINKS 0x80003ABC

// XEVENT_VORTEX_VEI_OUTPUT_ADAPTER_INVALID_SINK, 15037, Error
#define XEVENT_VORTEX_VEI_OUTPUT_ADAPTER_INVALID_SINK 0xC0003ABD

// XEVENT_VORTEX_UDPLISTENER_CALLBACK, 15038, Error
#define XEVENT_VORTEX_UDPLISTENER_CALLBACK 0xC0003ABE

// XEVENT_VORTEX_UDPLISTENER_NEXTREQUEST, 15039, Error
#define XEVENT_VORTEX_UDPLISTENER_NEXTREQUEST 0xC0003ABF

// XEVENT_VORTEX_UDPLISTENER_PROCESSREQUEST, 15040, Warning
#define XEVENT_VORTEX_UDPLISTENER_PROCESSREQUEST 0x80003AC0

// XEVENT_VORTEX_SINKBUILDER_NO_INITIALIZE, 15041, Warning
#define XEVENT_VORTEX_SINKBUILDER_NO_INITIALIZE 0x80003AC1

// XEVENT_VORTEX_SERVICE_STOP_ERROR, 15042, Error
#define XEVENT_VORTEX_SERVICE_STOP_ERROR 0xC0003AC2

// XEVENT_VORTEX_CONFIG_ETX, 15043, Error
#define XEVENT_VORTEX_CONFIG_ETX 0xC0003AC3

// XEVENT_VORTEX_REQUEST_AAINFO_ERROR, 15044, Warning
#define XEVENT_VORTEX_REQUEST_AAINFO_ERROR 0x80003AC4

// XEVENT_VORTEX_REQUEST_SGINFO_ERROR, 15045, Warning
#define XEVENT_VORTEX_REQUEST_SGINFO_ERROR 0x80003AC5

// XEVENT_VORTEX_REQUEST_UNHANDLED_ERROR, 15046, Error
#define XEVENT_VORTEX_REQUEST_UNHANDLED_ERROR 0xC0003AC6

// XEVENT_VORTEX_HTTPLISTENER_FAILED_VALIDATION, 15047, Warning
#define XEVENT_VORTEX_HTTPLISTENER_FAILED_VALIDATION 0x80003AC7

// XEVENT_VORTEX_CONFIG_XRL_MAPPINGS, 15048, Warning
#define XEVENT_VORTEX_CONFIG_XRL_MAPPINGS 0x80003AC8

// XEVENT_XLFS_ADMIN_INIT_PERF_COUNTER_FAILURE, 15000, Error
#define XEVENT_XLFS_ADMIN_INIT_PERF_COUNTER_FAILURE 0xC0003A98

// XEVENT_XLFS_INIT_PERF_COUNTER_FAILURE, 15000, Error
#define XEVENT_XLFS_INIT_PERF_COUNTER_FAILURE 0xC0003A98

// XEVENT_XSTS_GET_OUTPUT_CLAIMS_IDENTITY_PROVIDER_ERROR, 15000, Error
#define XEVENT_XSTS_GET_OUTPUT_CLAIMS_IDENTITY_PROVIDER_ERROR 0xC0003A98

// XEVENT_XSTS_SERVICE_HOST_OPENED_ERROR, 15001, Error
#define XEVENT_XSTS_SERVICE_HOST_OPENED_ERROR 0xC0003A99

// XEVENT_XSTS_FD_SERVICE_HOST_CLOSED_ERROR, 15002, Error
#define XEVENT_XSTS_FD_SERVICE_HOST_CLOSED_ERROR 0xC0003A9A

// XEVENT_XSTS_FD_CONFIGURATIONPROVIDER_LOAD_ERROR, 15003, Error
#define XEVENT_XSTS_FD_CONFIGURATIONPROVIDER_LOAD_ERROR 0xC0003A9B

// XEVENT_XSTS_CONFIG_CP_DUPLICATE_CLAIM_TYPE, 15004, Error
#define XEVENT_XSTS_CONFIG_CP_DUPLICATE_CLAIM_TYPE 0xC0003A9C

// XEVENT_XSTS_CONFIG_CP_NO_PROVIDER_FOR_CLAIM_TYPE, 15005, Error
#define XEVENT_XSTS_CONFIG_CP_NO_PROVIDER_FOR_CLAIM_TYPE 0xC0003A9D

// XEVENT_XSTS_CONFIG_RP_CLAIM_TYPE_NOT_SUPPORTED, 15006, Error
#define XEVENT_XSTS_CONFIG_RP_CLAIM_TYPE_NOT_SUPPORTED 0xC0003A9E

// XEVENT_XSTS_CP_OPEN_ERROR, 15007, Error
#define XEVENT_XSTS_CP_OPEN_ERROR 0xC0003A9F

// XEVENT_XSTS_CP_UNLOAD_ERROR, 15008, Error
#define XEVENT_XSTS_CP_UNLOAD_ERROR 0xC0003AA0

// XEVENT_XSTS_CONFIG_RP_USE_OF_PRIVATE_CLAIM_TYPE_INVALID, 15009, Error
#define XEVENT_XSTS_CONFIG_RP_USE_OF_PRIVATE_CLAIM_TYPE_INVALID 0xC0003AA1

// XEVENT_XSTS_MXA_EVENT_AUTHENTICATE_ERROR, 15010, Error
#define XEVENT_XSTS_MXA_EVENT_AUTHENTICATE_ERROR 0xC0003AA2

// XEVENT_XSTS_CONFIG_DUPLICATE_BUSINESSPARTNER_CERTIFICATE_SUBJECTNAME, 15011, Error
#define XEVENT_XSTS_CONFIG_DUPLICATE_BUSINESSPARTNER_CERTIFICATE_SUBJECTNAME 0xC0003AA3

// XEVENT_XSTS_XBLTOKENHANDLER_ERROR, 15012, Error
#define XEVENT_XSTS_XBLTOKENHANDLER_ERROR 0xC0003AA4

// XEVENT_XSTS_ISSUE_ERROR, 15013, Error
#define XEVENT_XSTS_ISSUE_ERROR 0xC0003AA5

// XEVENT_ZUNEDB_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR, 20100, Error
#define XEVENT_ZUNEDB_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR 0xC0004E84

// XEVENT_ZUNEDB_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING, 20101, Warning
#define XEVENT_ZUNEDB_CATALOG_WATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING 0x80004E85

// XEVENT_ZUNEDB_CATALOG_WATCHER_MEDIA_EXTRACTOR_ERROR, 20102, Warning
#define XEVENT_ZUNEDB_CATALOG_WATCHER_MEDIA_EXTRACTOR_ERROR 0x80004E86

// XEVENT_ZUNEDB_CATALOG_WATCHER_MEDIA_PRODUCER_ERROR, 20103, Warning
#define XEVENT_ZUNEDB_CATALOG_WATCHER_MEDIA_PRODUCER_ERROR 0x80004E87 
/////////////////////////////////////////////////////////////////////////////// 
// AUTO GENERATED FILE 
// MODIFY THE CORRESPONDING .xml AND .xsl FILES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\XHandlerBase.h ===
//---------------------------------------------------------------------------------------
//
//   xhandlerbase.h 
//    
//   Author: darrenan
//   
//   Date: 01/16/2001 
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
//---------------------------------------------------------------------------------------

#if !defined(XHANDLERBASE_H_INCLUDED__)
#define XHANDLERBASE_H_INCLUDED__

#pragma once

#if (!defined(_UNICODE) || !defined(UNICODE) ) 
#error XBox Handler must be built with _UNICODE and UNICODE defined.
#endif // built w/ UNICODE only, all CString are assumed as CStringW

//-----------------------------------------------------------------------------
//
//  @class XHandlerBase | non-template interface class.
//
//-----------------------------------------------------------------------------
class XHandlerBase 
{
public:
    // @cmember retrieve global object
    virtual HRESULT GetGlobalObj(REFGUID objid,	REFIID riid, void**pobj) = 0;
};

#endif //PPHANDLERBASE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\xexception.h ===
// XException.h: interface for the XException class.
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//////////////////////////////////////////////////////////////////////

#pragma once
#ifndef __XEXCEPTION_H
#define __XEXCEPTION_H

// The way to use XException
//
//      throw XException(__FILE__, __LINE__, hr, long1, long2, long3)
//
//  1.  don't ever pass anything other than __FILE__, __LINE__ as the first two
//      argument.
//  2.  You may pass some description through compile time time string
//      concatenation as __FILE__";description".   Make sure ";" is the first
//      character after __FILE__.   
//      A separate description argument is explicit avoided so that
//          a) XException doesn't have to alloc another copy of string.
//          b) or have to worry about freeing things.
//          c) to keep XException very small in size.
//
//
class XException  
{
public:
	XException(LPCSTR szFilename, long lLine, HRESULT hr, 
					long lLong1=0, long lLong2=0, long lLong3=0)
        :	m_szFilename(szFilename), m_lLine(lLine), m_hr(hr), m_lStatus1(lLong1), 
			m_lStatus2(lLong2), m_lStatus3(lLong3) {}
    virtual ~XException() {};
	inline LPCSTR GetFilename() { return m_szFilename; }
	inline long GetFilelineno() { return m_lLine; }
	inline HRESULT GetHr() { return m_hr; }
	inline long GetStatus1() { return m_lStatus1; }
	inline long GetStatus2() { return m_lStatus2; }
	inline long GetStatus3() { return m_lStatus3; }
private:
    LPCSTR m_szFilename;
    long m_lLine;
    HRESULT m_hr;
    long m_lStatus1;
    long m_lStatus2;
    long m_lStatus3;

};

#define THROW_WITH_HR(hr, text) throw XException(__FILE__ text,__LINE__,hr)
#define THROW_IF_FAILED_HR(hr, text) if(FAILED(hr)) THROW_WITH_HR(hr, text)
#define THROW_IF_NULL_PTR(ptr, hr, text) if(ptr == NULL) THROW_WITH_HR(hr, text)

#endif // __XEXCEPTION_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\xhash.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once
#ifndef __XHASH_H
#define __XHASH_H

#pragma warning( disable : 4172 )
#include "lkrhash.h"

using namespace LKRhash;
using namespace HashFn;

///////////////////////////////////////////////////////////////////////////////
//
//  String-String Hash Table.
//

class XStrStrRecord
{
public:
    XStrStrRecord() { ZeroMemory(this, sizeof(*this)); }

    LPSTR   m_szKey;
    DWORD   m_dwKeyLen;
    LPSTR   m_szValue;
    DWORD   m_dwValueLen;
    
    mutable LONG m_cRefs;
};

class XStrStrHash : public CTypedHashTable<XStrStrHash, const XStrStrRecord, const char*>
{
public:

    XStrStrHash(DWORD initsize=LK_DFLT_INITSIZE) : 
      CTypedHashTable<XStrStrHash, const XStrStrRecord, const char*> ("XStrStrHash", LK_DFLT_MAXLOAD, initsize) 
    {}

    static const char* ExtractKey(const XStrStrRecord* pRec) 
    { 
        return pRec->m_szKey; 
    }

    static DWORD CalcKeyHash(const char* szKey) 
    { 
        return HashStringNoCase(szKey); 
    }

    static bool EqualKeys(const char* szKey1, const char* szKey2) 
    { 
        return (lstrcmpiA(szKey1, szKey2) == 0); 
    }

    static void AddRefRecord(const XStrStrRecord* pRec, int nIncr)
    {
        InterlockedExchangeAdd(&pRec->m_cRefs, nIncr);
    }
};

///////////////////////////////////////////////////////////////////////////////
//
//  Handler Info Hash Table.  Maps file names to CLSIDs.
//

class XHandlerInfoRecord
{
public:
    XHandlerInfoRecord() { ZeroMemory(this, sizeof(*this)); }

    CHAR            m_szFilename[MAX_PATH + 1];   // key
    CLSID           m_clsidHandler;
    
    mutable LONG m_cRefs;
};

class XHandlerInfoHash : public 
    CTypedHashTable<XHandlerInfoHash, XHandlerInfoRecord, const char*>
{
public:

    XHandlerInfoHash(DWORD initsize=LK_DFLT_INITSIZE) : 
      CTypedHashTable<XHandlerInfoHash, XHandlerInfoRecord, const char*> ("XHandlerInfoHash", LK_DFLT_MAXLOAD, initsize) 
    {}

    static const char* ExtractKey(const XHandlerInfoRecord* pRec) 
    { 
        return pRec->m_szFilename; 
    }

    static DWORD CalcKeyHash(const char* szKey) 
    { 
        return HashStringNoCase(szKey); 
    }

    static bool EqualKeys(const char* szKey1, const char* szKey2) 
    { 
        return (lstrcmpiA(szKey1, szKey2) == 0); 
    }

    static void AddRefRecord(const XHandlerInfoRecord* pRec, int nIncr)
    {
        InterlockedExchangeAdd(&pRec->m_cRefs, nIncr);
    }
};

#endif // __XHASH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\xfile.h ===
//---------------------------------------------------------------------------------------
//
//   @doc
// 
//   @module XFile.h | XBox smart class to wrap FILE*
//    
//   Author: stevefu/darrenan
//   
//   Date: 05/28/2000 
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------------------

#ifndef XFile_HPP
#define XFile_HPP

#pragma once

#include <stdio.h>
#include <tchar.h>

class XFile
{
private:
	FILE* m_hFile;

public:
	XFile() : m_hFile(NULL) { }

	~XFile() 
	{ 
	 	if ( m_hFile != NULL) fclose(m_hFile); 
	}

	BOOL Open( const TCHAR* filename, const TCHAR* mode)
	{
		m_hFile = _tfopen(filename, mode);
		return ( NULL != m_hFile );
	}

	void Close()
	{	
		ATLASSERT(m_hFile != NULL);
		fclose(m_hFile);
	}

	// return length,   -1 if error or eof
	int ReadLine(TCHAR* string, int n)
	{
		ATLASSERT(m_hFile != NULL);
		int len = -1;
		if ( _fgetts(string, n, m_hFile) )
		{
			len = _tcslen(string);
			// trim the new line
			if ( len > 0 && string[len-1] == TEXT('\n') )
			{
				string[len-1] = TEXT('\0');
				len--;
			}
		}
		return len;
	}
	
	inline operator FILE*() { return m_hFile; }
	
};

#endif // XFile_HPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\XRedirect.h ===
// PassportRedirect.h: interface for the XRedirect class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XREDIRECT_H__A2A35B12_5D1F_43C0_BC03_05189E612CA9__INCLUDED_)
#define AFX_XREDIRECT_H__A2A35B12_5D1F_43C0_BC03_05189E612CA9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class XRedirect  
{
public:
    XRedirect(LPCSTR pszUrl, ULONG ulFlags, HRESULT hr = 0)
            : m_cszRedirect(pszUrl), m_lFlags(ulFlags), m_hr(hr) {};
    virtual ~XRedirect() {};
	CStringA & GetUrl() { return m_cszRedirect; }
	ULONG GetFlags() { return m_lFlags; }
    HRESULT GetHr() { return m_hr; }
protected: 
	CStringA m_cszRedirect;
	ULONG m_lFlags;
    HRESULT m_hr;
private:
	XRedirect(XRedirect &) {};
};

#endif // !defined(AFX_XREDIRECT_H__A2A35B12_5D1F_43C0_BC03_05189E612CA9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\XRc4Crypt.h ===
#pragma once
#ifndef __XRC4CRYPT_H
#define __XRC4CRYPT_H

#include "xcrypt.h"
#include "rc4sha1.h"

class XRc4Crypt : public XCrypt
{
public:

    XRc4Crypt();
    ~XRc4Crypt();

    DWORD HeaderSize();
    DWORD MACSize();
    
    bool Encrypt(LPBYTE pbInput, DWORD cbInput, LPBYTE pbOutput, PDWORD pcbOutput);
    bool Decrypt(LPBYTE pbInput, DWORD cbInput, LPBYTE pbOutput, PDWORD pcbOutput);
    bool MAC(LPBYTE pBuf, DWORD dwBufLen, LPBYTE pMAC);
    bool SetKey(LPBYTE pKey, DWORD dwKeyLen);

protected:
    RC4_SHA_HMAC_STATE_BUFFER m_stateBuffer;
};


#endif // __XRC4CRYPT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\benaloh.h ===
#ifndef __BENALOH_H__
#define __BENALOH_H__

#ifdef __cplusplus
extern "C" {
#endif

/*
This variable controls if the power-table is scrambled in memory,  which mitigates 
side-channel attacks using the shared L1/L2 caches on some Pentium and AMD processors.
To undo the fix, change this value to zero.
*/
#define 	SIDECHANNELSAFE		1

struct BenalohData
{
    DWORD N;            /* length of modulus */
    LPDWORD M;          /* a multiple of modulus, with highest bit set */
    LPDWORD U;          /* base**(N+1) mod modulus */
    LPDWORD V;          /* modulus - U */
    LPDWORD product;
};

BOOL BenalohSetup(struct BenalohData *context, LPDWORD M, DWORD N);
void BenalohTeardown(struct BenalohData *context);
void BenalohMod(struct BenalohData *context, LPDWORD T, LPDWORD X);
void BenalohModSquare(struct BenalohData *context, LPDWORD A, LPDWORD B);
void BenalohModMultiply(struct BenalohData *context, LPDWORD A, LPDWORD B, LPDWORD C);
BOOL BenalohModExp(LPDWORD A, LPDWORD B, LPDWORD C, LPDWORD D, DWORD len);
BOOL BenalohModRoot(LPDWORD M, LPDWORD C, LPDWORD PP, LPDWORD QQ, LPDWORD DP, LPDWORD DQ, LPDWORD CR, DWORD PSize);
DWORD BenalohEstimateQuotient(DWORD a1, DWORD a2, DWORD m1);

#ifdef __cplusplus
}
#endif

#endif // __BENALOH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\XUtils.h ===
//---------------------------------------------------------------------------------------
//
//   @doc
// 
//   @module xutils.h | Xbox server utilities. 
//    
//   Author: stevefu/darrenan
//   
//   Date: 05/01/2000 
//
//---------------------------------------------------------------------------------------

#if !defined(XUTILITIES_H__INCLUDED_)
#define XUTILITIES_H__INCLUDED_

#pragma once

// Useful macros
#define XF_BOOL(b)		(((b) == false) ? (k_szFalse) : (k_szTrue))
#define XF_CHAR(p)		((((LPCSTR )(p)) == NULL) ? ("<NULL>") : ((LPCSTR )(p)))
#define XF_WCHAR(p)	    ((((LPCWSTR )(p)) == NULL) ? (L"<NULL>") : ((LPCWSTR )(p)))

////////////////////////////////////////////////////////////////////////////////////////
// String utilities
void Mbcs2Unicode(LPCSTR  pszIn, unsigned codepage, BOOL bNEC, CStringW& wOut);
void Unicode2Mbcs(LPCWSTR pwszIn, unsigned codepage, BOOL bNEC, CStringA& wOut);
void FixUpHtmlDecimalCharacters(CStringW& str);
void HtmlEscapeString(CStringW& str, LPCWSTR escch = L"\"<>" );
void UrlEscapeString(CStringW& wStr );
void UrlEscapeString(CStringA& oStr);
CStringA UrlEscapeStr(const CStringA& oStr);
void UrlUnescapeString(CStringW& wStr );
void BSTRMove(BSTR& src, CStringW& dest);
void BSTRMove(BSTR& src, CStringA& dest);
long HexToNum(wchar_t c);
long FromHex(LPCWSTR pszHexString);

////////////////////////////////////////////////////////////////////////////////////////
// ini file processing
typedef struct tag_ConfigIniPair
{
	CString strIniKey;
	CString strIniValue;
} IniSettingPair;

BOOL GetPrivateProfilePairs(
  			LPCTSTR lpFileName,          
  			LPCTSTR lpSectionName,      
  			CAtlArray<IniSettingPair>& r 
            );	


#endif //XUTILITIES_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\XHandler.h ===
//---------------------------------------------------------------------------------------
//
//   xhandler.h
//
//   xbox handler baseclass that replaces AtlSvr CRequestHandler
//    
//   Author: darrenan
//   
//   Date: 04/28/2000 
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
//---------------------------------------------------------------------------------------

#if !defined(XHANDLER_H_INCLUDED__)
#define XHANDLER_H_INCLUDED__

#pragma once

#include "atlstencil.h"
#include "xhandlerbase.h"
#include "xutils.h"

#include "xexception.h"
#include "xredirect.h"

#define X_REPLACEMENT_METHOD_ENTRY_EX_STR(methodName, methodFunc)\
                REPLACEMENT_METHOD_ENTRY_EX_STR(methodName, methodFunc)


/*********************************************************************************

 @class XRequestHandlerT | The template implementation of xbox
 SRF handler. 
 
 This is the baseclass to be used by all xbox SRF handlers. It has all the features 
 from CRequestHandler and provides the following additionss:
    1. Global error handling
    2. Retrieve global objects

 Usage:
    A. Use XRequestHandlerT as your handler's base class to replace ATL server's
       CRequestHandlerT.
    B. Anywhere in your code where you use ATL server handler map, use xbox version as:
        BEGIN_X_HANDLER_MAP                BEGIN_HANDLER_MAP        
        X_HANDLER_ENTRY                    HANDLER_ENTRY
        END_X_HANDLER_MAP                  END_HANDLER_MAP
        BEGIN_X_REPLACEMENT_METHOD_MAP     BEGIN_REPLACEMENT_METHOD_MAP
        X_REPLACEMENT_METHOD_ENTRY         REPLACEMENT_METHOD_ENTRY
        X_REPLACEMENT_METHOD_ENTRY_EX      REPLACEMENT_METHOD_ENTRY_EX
        END_X_REPLACEMENT_METHOD_MAP       END_REPLACEMENT_METHOD_MAP
**********************************************************************************/


// this is the list of SRF replacements provided by XRequestHandlerT.
// other base handler classes ( derived from XRequestHandlerT and intended
// to be used as base for other apps ) should define its own base 
// replacements by defining X_HANDLER_METHODS_ADDON before #including
// this file
#define X_HANDLER_METHODS_BASE \

#if !defined( X_HANDLER_METHODS_ADDON )
#define X_HANDLER_METHODS  \
        X_HANDLER_METHODS_BASE
#else
#define X_HANDLER_METHODS \
        X_HANDLER_METHODS_BASE \
        X_HANDLER_METHODS_ADDON
#endif


// hijack the Manta maps to add base method list at the end
#define BEGIN_X_REPLACEMENT_METHOD_MAP(className)\
		BEGIN_REPLACEMENT_METHOD_MAP(className)
		
#define X_REPLACEMENT_METHOD_ENTRY(methodName, methodFunc)\
		REPLACEMENT_METHOD_ENTRY(methodName, methodFunc)

#define X_REPLACEMENT_METHOD_ENTRY_EX(methodName, methodFunc, paramType, parseFunc)\
		REPLACEMENT_METHOD_ENTRY_EX(methodName, methodFunc, paramType, parseFunc)

#define END_X_REPLACEMENT_METHOD_MAP() \
	X_HANDLER_METHODS \
    { 0, NULL, NULL } };\
    *ppOut = methods;\
  }

#define X_HANDLER_CONFIG_ROUTINES(name,obj) \
__if_not_exists(InitHandlerConfig) \
{ \
BOOL g_bConfigInitialized = FALSE; \
extern "C" ATL_NOINLINE inline BOOL __declspec(dllexport) __stdcall InitHandlerConfig(LPCSTR szConfigFilePath) throw() \
{ \
    HRESULT hr; \
    if(g_bConfigInitialized) return TRUE; \
    hr = g_xomcentral.Init(name, szConfigFilePath); \
    if(hr != S_OK) return FALSE; \
    if(obj != NULL) hr = g_xomcentral.RegisterControlCallback(obj); \
    if(hr == S_OK) g_bConfigInitialized = TRUE; \
    return (hr == S_OK); \
} \
extern "C" ATL_NOINLINE inline  void __declspec(dllexport) __stdcall UninitHandlerConfig(void) throw() \
{ \
    if(!g_bConfigInitialized) return; \
    g_xomcentral.Term(); \
    g_bConfigInitialized = FALSE; \
} \
}

#define BEGIN_X_HANDLER_MAP(name) \
        BEGIN_HANDLER_MAP() \
        X_HANDLER_CONFIG_ROUTINES(name,NULL)
#define BEGIN_X_HANDLER_MAP_AND_CONTROL_CALLBACK(name,obj) \
        BEGIN_HANDLER_MAP() \
        X_HANDLER_CONFIG_ROUTINES(name,obj)
#define X_HANDLER_ENTRY(handlerName, className) \
        HANDLER_ENTRY(handlerName, className)
#define END_X_HANDLER_MAP() \
		END_HANDLER_MAP()


template <class THandler>
class XRequestHandlerT : 
	public CRequestHandlerT<THandler>,
 	public XHandlerBase
{ 

#define XH_TRY try 
#define XH_CATCH \
        catch (XRedirect &cpRedirect)             \
		{                                                 \
			m_HttpResponse.Redirect(cpRedirect.GetUrl()); \
			return HTTP_FOUND;                            \
		}                                                 \
		catch (XException &cpException)           \
		{                                                 \
			THandler* pT = static_cast<THandler *>(this); \
            pT->HandleCriticalErr(cpException);           \
            SendResponse();                               \
            return HTTP_SUCCESS;                          \
        }                                                 \

#if 0		
		catch(...)                                        \
		{                                                 \
			XException e ("unexpected_crash", 0, E_FAIL);  \
			HandleCriticalErr(e);                         \
			return HTTP_SUCCESS_NO_PROCESS;               \
		}
#endif

public:
	BEGIN_COM_MAP(CRequestHandlerT<THandler>)
		COM_INTERFACE_ENTRY(IRequestHandler)
		COM_INTERFACE_ENTRY(ITagReplacer)
	END_COM_MAP()

public:
	XRequestHandlerT() 
	:m_bXHInit(FALSE)
	{
	}
	
	~XRequestHandlerT() 
	{
	}

public:
    // Used to initialize the class
    // function is stored in the handler map in user's code.
    static BOOL InitRequestHandlerClass(IHttpServerContext*, IIsapiExtension *pExt) throw()
    {
        BOOL                        bReturn;
        HRESULT                     hr;
        CComPtr<IServiceProvider>   piServices;
        CComPtr<IXExtService>       piXExtService;
        CComBSTR                    cbstrConfigFilePath;

        USES_CONVERSION;

        //
        //  Initialize logging/tracing/config
        //

        hr = pExt->QueryInterface(&piServices);
        if(FAILED(hr))
        {
            bReturn = FALSE;
            goto Cleanup;
        }

        hr = piServices->QueryService(CLSID_XExtService, &piXExtService);
        if(FAILED(hr))
        {
            bReturn = FALSE;
            goto Cleanup;
        }

        hr = piXExtService->GetConfigFilePath(&cbstrConfigFilePath);
        if(FAILED(hr))
        {
            bReturn = FALSE;
            goto Cleanup;
        }

        bReturn = InitHandlerConfig(W2A(cbstrConfigFilePath));

Cleanup:

        return bReturn;
    }

    // Used to uninitialize the class
    // function is stored in the handler map in user's code.
    static void UninitRequestHandlerClass() throw()
    {
        UninitHandlerConfig();
    }

public:
    // TODO - REMOVE THIS FUNCTION
 	//  @mfunc override baseclass InitializeHandler
 	//    Initialize members and data
	HTTP_CODE InitializeHandler(
					AtlServerRequest *pRequestInfo, 
					IServiceProvider *pProvider) throw()
	{
		HTTP_CODE       dwRtn = HTTP_FAIL;
		XHandlerBase*   p;

		m_pAtlServerRequest = pRequestInfo;

		XH_TRY
		{
			// the base init initialized m_HttpReqeust and m_HttpResponse etc.	
			// also call ValidateAndExchange()
			dwRtn =  CRequestHandlerT<THandler>
				::InitializeHandler(pRequestInfo, pProvider);
			if ( HTTP_SUCCESS != dwRtn ) goto done;

			// the real init from derived classes
			THandler* pT = static_cast<THandler *>(this);
			dwRtn = pT->ValidateAndExchangeEx();						
		}
		XH_CATCH ;

done:		
		return dwRtn;		
	}

    //  @mfunc xbox base XRequestHandlerT<...> specific init function
 	//         derived class must NOT override this
 	//  @rdesc
	HTTP_CODE ValidateAndExchange() 
	{
		HRESULT hr = S_OK;
		m_bXHInit = TRUE;		
		return SUCCEEDED(hr) ? HTTP_SUCCESS : HTTP_FAIL;
	}


 	//  @mfunc derived handler class init function
 	//  @rdesc
	HTTP_CODE ValidateAndExchangeEx()
	{	
		return HTTP_SUCCESS;
	}

 	//  @mfunc override baseclass HandleRequest
 	//       - global un-recoverable error handling
 	//  @rdesc same as baseclass
 	HTTP_CODE HandleRequest(AtlServerRequest *pRequestInfo, 
		                IServiceProvider *pServiceProvider) throw()
    {
		HTTP_CODE rtn;

    	// If ( ! m_bXHInit ) XRequestHandlerT object is not 
		// initialized. Most likely you override ValidateAndExchange in 
		// your handler class. 
    	// Rename it to ValidateAndExchangeEx should fix this problem 
    	ATLASSERT( m_bXHInit );
		if ( ! m_bXHInit ) return HTTP_FAIL; 

		try
		{
			rtn = CRequestHandlerT<THandler>::
        				HandleRequest(pRequestInfo, pServiceProvider);
		}
		catch (XException &cpException)           
		{                                                 
			THandler* pT = static_cast<THandler *>(this); 
            pT->HandleCriticalErr(cpException);
            SendResponse();
            return HTTP_SUCCESS;
        }                                                 

		return rtn;
    }

    //
    //  handle critical errors caught in exception
	//  if you override this in your handler, promise never never
	//  throw an exception within or from any of your callees, 
	//  they will not be caught and crash IIS...
	//    
	void HandleCriticalErr(XException &cpException) throw()
	{
		//TODO: this must be logged into event log

        char buff[ATL_URL_MAX_URL_LENGTH+1]; 

        _snprintf(buff, 
                  ATL_URL_MAX_URL_LENGTH+1,
                  "<HTML><BODY>File = %s<BR>Line = %d<BR>Code = 0x%08X</BODY></HTML>", 
                  cpException.GetFilename(),
                  cpException.GetFilelineno(),
                  cpException.GetHr());

		m_HttpResponse.ClearResponse();
        m_HttpResponse.SetStatusCode(500);
        m_HttpResponse.WriteLen(buff, lstrlenA(buff));
	}

    void SendErrorResponse(ULONG ulError)
    {
        CHAR szError[30];
        m_HttpResponse.SetStatusCode(500);
        m_HttpResponse.AppendHeader("X-Err", _ultoa(ulError, szError, 16));

        CComPtr<IHttpServerContext> piContext;

        m_HttpResponse.GetServerContext(&piContext);

        if( piContext )
        {
            _snprintf( szError, sizeof(szError), "X-Err(%x)", ulError );
            szError[ (sizeof(szError)/sizeof(szError[0])) - 1 ] = '\0';
            piContext->AppendToLog( szError, NULL );
        }
    }

    void SendResponse()
    {
        CComPtr<IHttpServerContext> piServerContext;
        CAtlIsapiBuffer<>           cszResponse;
        CStringA                    csz;
		char                        szProtocol[ATL_URL_MAX_URL_LENGTH];
        LPCSTR                      szError;
        
        //
        //  Format content-length and add header
        //

        _itoa(m_HttpResponse.m_strContent.GetLength(), szProtocol, 10);
		m_HttpResponse.AppendHeader("Content-Length", szProtocol);

        //
        //  Status Line
        //

        CDefaultErrorProvider::GetErrorText(m_HttpResponse.GetStatusCode(), 0, &szError, NULL);
        csz.Format("HTTP/1.0 %d %s\r\n", m_HttpResponse.GetStatusCode(), szError);

        //
        //  Headers
        //

        m_HttpResponse.RenderHeaders(csz);
        cszResponse.Append((LPCSTR)csz, csz.GetLength());

        //
        //  Body
        //

        cszResponse.Append((LPCSTR)m_HttpResponse.m_strContent, m_HttpResponse.m_strContent.GetLength());

        m_HttpResponse.ClearContent();

        //
        //  Send the response
        //

        m_HttpResponse.HaveSentHeaders(TRUE);

        m_HttpResponse.WriteLen(cszResponse, cszResponse.GetLength());
    }
    
	//  @mfunc  retrieve global object
	//  @rdesc  S_OK or error code
	HRESULT GetGlobalObj(REFGUID objid,	 // @parm  class ID 
	                     REFIID riid,    // @parm  interface ID	                     
	                     void** pobj     // @parm: returned interface pointer
	                     )
    {
        *pobj = NULL;
		return m_spServiceProvider->QueryService(objid, riid, pobj);
    }

//////////////////
protected:

    AtlServerRequest* m_pAtlServerRequest;

	BOOL m_bXHInit;         //is sandler Initialzed?
    CStringA m_strXService; //xbox service
    CStringA m_strXPage;    //xbox page
};


#endif //XHANDLER_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\xonlinep.h ===
/*==========================================================================;
 *
 *  xonline.h -- This module defines the XBox Live APIs
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#ifndef __XONLINE__
#define __XONLINE__

#ifdef __cplusplus
extern "C" {
#endif

//@@BEGIN_MSINTERNAL
//@@END_MSINTERNAL

//
// XOnline Error Codes
//

#define FACILITY_XONLINE                                21

// Generic Errors                                       = 0x80150XXX
#define XONLINE_E_OVERFLOW                              _HRESULT_TYPEDEF_(0x80150001L)
#define XONLINE_E_NO_SESSION                            _HRESULT_TYPEDEF_(0x80150002L)
#define XONLINE_E_USER_NOT_LOGGED_ON                    _HRESULT_TYPEDEF_(0x80150003L)
#define XONLINE_E_NO_GUEST_ACCESS                       _HRESULT_TYPEDEF_(0x80150004L)
#define XONLINE_E_NOT_INITIALIZED                       _HRESULT_TYPEDEF_(0x80150005L)
#define XONLINE_E_NO_USER                               _HRESULT_TYPEDEF_(0x80150006L)
#define XONLINE_E_INTERNAL_ERROR                        _HRESULT_TYPEDEF_(0x80150007L)
#define XONLINE_E_OUT_OF_MEMORY                         _HRESULT_TYPEDEF_(0x80150008L)
#define XONLINE_E_TASK_BUSY                             _HRESULT_TYPEDEF_(0x80150009L)
#define XONLINE_E_SERVER_ERROR                          _HRESULT_TYPEDEF_(0x8015000AL)
#define XONLINE_E_IO_ERROR                              _HRESULT_TYPEDEF_(0x8015000BL)
#define XONLINE_E_BAD_CONTENT_TYPE                      _HRESULT_TYPEDEF_(0x8015000CL)
#define XONLINE_E_USER_NOT_PRESENT                      _HRESULT_TYPEDEF_(0x8015000DL)
#define XONLINE_E_PROTOCOL_MISMATCH                     _HRESULT_TYPEDEF_(0x8015000EL)
#define XONLINE_E_INVALID_SERVICE_ID                    _HRESULT_TYPEDEF_(0x8015000FL)
#define XONLINE_E_INVALID_REQUEST                       _HRESULT_TYPEDEF_(0x80150010L)
#define XONLINE_E_TASK_THROTTLED                        _HRESULT_TYPEDEF_(0x80150011L)
#define XONLINE_E_TASK_ABORTED_BY_DUPLICATE             _HRESULT_TYPEDEF_(0x80150012L)
#define XONLINE_E_INVALID_TITLE_ID                      _HRESULT_TYPEDEF_(0x80150013L)
#define XONLINE_E_SERVER_CONFIG_ERROR                   _HRESULT_TYPEDEF_(0x80150014L)
#define XONLINE_E_END_OF_STREAM                         _HRESULT_TYPEDEF_(0x80150015L)


// Failures from XOnlineLogon                           = 0x801510XX
#define XONLINE_E_LOGON_NO_NETWORK_CONNECTION           _HRESULT_TYPEDEF_(0x80151000L)

// XOnlineLogon task successful return states
#define XONLINE_S_LOGON_CONNECTION_ESTABLISHED          _HRESULT_TYPEDEF_(0x001510F0L)

// XOnlineLogon task failure return values
#define XONLINE_E_LOGON_CANNOT_ACCESS_SERVICE           _HRESULT_TYPEDEF_(0x80151001L)
#define XONLINE_E_LOGON_UPDATE_REQUIRED                 _HRESULT_TYPEDEF_(0x80151002L)
#define XONLINE_E_LOGON_SERVERS_TOO_BUSY                _HRESULT_TYPEDEF_(0x80151003L)
#define XONLINE_E_LOGON_CONNECTION_LOST                 _HRESULT_TYPEDEF_(0x80151004L)
#define XONLINE_E_LOGON_KICKED_BY_DUPLICATE_LOGON       _HRESULT_TYPEDEF_(0x80151005L)
#define XONLINE_E_LOGON_INVALID_USER                    _HRESULT_TYPEDEF_(0x80151006L)
#define XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED           _HRESULT_TYPEDEF_(0x80151007L)
#define XONLINE_E_LOGON_TITLE_ACTIVATION_REQUIRED       _HRESULT_TYPEDEF_(0x80151008L)
#define XONLINE_E_LOGON_USER_TITLE_ACTIVATION_REQUIRED  _HRESULT_TYPEDEF_(0x80151009L)
#define XONLINE_E_LOGON_OTHER_TITLE_ACTIVATED           _HRESULT_TYPEDEF_(0x8015100AL)
#define XONLINE_E_LOGON_SG_CONNECTION_TERMINATED        _HRESULT_TYPEDEF_(0x8015100BL)
#define XONLINE_E_LOGON_SG_CONNECTION_TIMEDOUT          _HRESULT_TYPEDEF_(0x8015100CL)
#define XONLINE_E_LOGON_SG_CONNECTION_RESET             _HRESULT_TYPEDEF_(0x8015100DL)
#define XONLINE_E_LOGON_SG_CONNECTION_FAILED            _HRESULT_TYPEDEF_(0x8015100EL)
#define XONLINE_E_LOGON_USER_NOT_TRUSTED                _HRESULT_TYPEDEF_(0x8015100FL)
#define XONLINE_E_LOGON_USER_RPS_EXPIRED                _HRESULT_TYPEDEF_(0x80151010L)
#define XONLINE_E_LOGON_PPLOGIN_PASSWORD_PROBLEM        _HRESULT_TYPEDEF_(0x80151011L)
#define XONLINE_E_LOGON_PPLOGIN_VERIFICATION_REQUIRED   _HRESULT_TYPEDEF_(0x80151012L)
#define XONLINE_E_LOGON_USER_UNKNOWN_TRUST              _HRESULT_TYPEDEF_(0x80151013L)
#define XONLINE_E_LOGON_PPLOGIN_MISMATCH                _HRESULT_TYPEDEF_(0x80151014L)
#define XONLINE_E_LOGON_SETTINGS_SYNC_FAILED            _HRESULT_TYPEDEF_(0x80151015L)
#define XONLINE_E_LOGON_SETTINGS_SYNC_CONFLICT          _HRESULT_TYPEDEF_(0x80151016L)
#define XONLINE_E_LOGON_BLOCKED_BY_CURFEW               _HRESULT_TYPEDEF_(0x80151017L)

// Failures from XOnlineSilentLogon
#define XONLINE_E_SILENT_LOGON_DISABLED                 _HRESULT_TYPEDEF_(0x80151080L)
#define XONLINE_E_SILENT_LOGON_NO_ACCOUNTS              _HRESULT_TYPEDEF_(0x80151081L)
#define XONLINE_E_SILENT_LOGON_PASSCODE_REQUIRED        _HRESULT_TYPEDEF_(0x80151082L)

// Service errors after XOnlineLogon task completion    = 0x801511XX
#define XONLINE_E_LOGON_SERVICE_NOT_REQUESTED           _HRESULT_TYPEDEF_(0x80151100L)
#define XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED          _HRESULT_TYPEDEF_(0x80151101L)
#define XONLINE_E_LOGON_SERVICE_TEMPORARILY_UNAVAILABLE _HRESULT_TYPEDEF_(0x80151102L)

// User warnings after XOnlineLogon task completion     = 0x801512XX
#define XONLINE_S_LOGON_USER_HAS_MESSAGE                _HRESULT_TYPEDEF_(0x001512F0L)
//@@BEGIN_MSINTERNAL
#define XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED _HRESULT_TYPEDEF_(0x001512F1L)
//@@END_MSINTERNAL

// User errors after XOnlineLogon task completion
#define XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT _HRESULT_TYPEDEF_(0x80151200L)

// XOnlineChangeLogonUsers task successful return states = 0x801513XX
#define XONLINE_S_LOGON_COMMIT_USER_CHANGE              _HRESULT_TYPEDEF_(0x001513F0L)
#define XONLINE_S_LOGON_USER_CHANGE_COMPLETE            _HRESULT_TYPEDEF_(0x001513F1L)

// XOnlineChangeLogonUsers task failure return values
#define XONLINE_E_LOGON_CHANGE_USER_FAILED              _HRESULT_TYPEDEF_(0x80151300L)

// Other generic auth related errors                    = 0x801518XX
#define XONLINE_E_LOGON_MU_NOT_MOUNTED                  _HRESULT_TYPEDEF_(0x80151800L)
#define XONLINE_E_LOGON_MU_IO_ERROR                     _HRESULT_TYPEDEF_(0x80151801L)
#define XONLINE_E_LOGON_NOT_LOGGED_ON                   _HRESULT_TYPEDEF_(0x80151802L)


// Errors returned by Presence/Notification             = 0x801520XX
#define XONLINE_E_NOTIFICATION_SERVER_BUSY              _HRESULT_TYPEDEF_(0x80152001L)
#define XONLINE_E_NOTIFICATION_LIST_FULL                _HRESULT_TYPEDEF_(0x80152002L)
#define XONLINE_E_NOTIFICATION_BLOCKED                  _HRESULT_TYPEDEF_(0x80152003L)
#define XONLINE_E_NOTIFICATION_FRIEND_PENDING           _HRESULT_TYPEDEF_(0x80152004L)
#define XONLINE_E_NOTIFICATION_FLUSH_TICKETS            _HRESULT_TYPEDEF_(0x80152005L)
#define XONLINE_E_NOTIFICATION_TOO_MANY_REQUESTS        _HRESULT_TYPEDEF_(0x80152006L)
#define XONLINE_E_NOTIFICATION_USER_ALREADY_EXISTS      _HRESULT_TYPEDEF_(0x80152007L)
#define XONLINE_E_NOTIFICATION_USER_NOT_FOUND           _HRESULT_TYPEDEF_(0x80152008L)
#define XONLINE_E_NOTIFICATION_OTHER_LIST_FULL          _HRESULT_TYPEDEF_(0x80152009L)
#define XONLINE_E_NOTIFICATION_SELF                     _HRESULT_TYPEDEF_(0x8015200AL)
#define XONLINE_E_NOTIFICATION_SAME_TITLE               _HRESULT_TYPEDEF_(0x8015200BL)
#define XONLINE_E_NOTIFICATION_NO_TASK                  _HRESULT_TYPEDEF_(0x8015200CL)
#define XONLINE_E_NOTIFICATION_NO_DATA                  _HRESULT_TYPEDEF_(0x8015200DL)
#define XONLINE_E_PRESENCE_USER_MIGRATED                _HRESULT_TYPEDEF_(0x8015200EL)
#define XONLINE_E_PRESENCE_DEFER_REQUEST                _HRESULT_TYPEDEF_(0x8015200FL)

#define XONLINE_S_NOTIFICATION_NO_PEER_SUBSCRIBE        _HRESULT_TYPEDEF_(0x0015200EL)

// Errors returned by teams                             = 0x801521XX
#define XONLINE_E_TEAMS_SERVER_BUSY                     _HRESULT_TYPEDEF_(0x80152100L)
#define XONLINE_E_TEAMS_TEAM_FULL                       _HRESULT_TYPEDEF_(0x80152101L)
#define XONLINE_E_TEAMS_MEMBER_PENDING                  _HRESULT_TYPEDEF_(0x80152102L)
#define XONLINE_E_TEAMS_TOO_MANY_REQUESTS               _HRESULT_TYPEDEF_(0x80152103L)
#define XONLINE_E_TEAMS_USER_ALREADY_EXISTS             _HRESULT_TYPEDEF_(0x80152104L)
#define XONLINE_E_TEAMS_USER_NOT_FOUND                  _HRESULT_TYPEDEF_(0x80152105L)
#define XONLINE_E_TEAMS_USER_TEAMS_FULL                 _HRESULT_TYPEDEF_(0x80152106L)
#define XONLINE_E_TEAMS_SELF                            _HRESULT_TYPEDEF_(0x80152107L)
#define XONLINE_E_TEAMS_NO_TASK                         _HRESULT_TYPEDEF_(0x80152108L)
#define XONLINE_E_TEAMS_TOO_MANY_TEAMS                  _HRESULT_TYPEDEF_(0x80152109L)
#define XONLINE_E_TEAMS_TEAM_ALREADY_EXISTS             _HRESULT_TYPEDEF_(0x8015210AL)
#define XONLINE_E_TEAMS_TEAM_NOT_FOUND                  _HRESULT_TYPEDEF_(0x8015210BL)
#define XONLINE_E_TEAMS_INSUFFICIENT_PRIVILEGES         _HRESULT_TYPEDEF_(0x8015210CL)
#define XONLINE_E_TEAMS_NAME_CONTAINS_BAD_WORDS         _HRESULT_TYPEDEF_(0x8015210DL)
#define XONLINE_E_TEAMS_DESCRIPTION_CONTAINS_BAD_WORDS  _HRESULT_TYPEDEF_(0x8015210EL)
#define XONLINE_E_TEAMS_MOTTO_CONTAINS_BAD_WORDS        _HRESULT_TYPEDEF_(0x8015210FL)
#define XONLINE_E_TEAMS_URL_CONTAINS_BAD_WORDS          _HRESULT_TYPEDEF_(0x80152110L)
#define XONLINE_E_TEAMS_NOT_A_MEMBER                    _HRESULT_TYPEDEF_(0x80152111L)
#define XONLINE_E_TEAMS_NO_ADMIN                        _HRESULT_TYPEDEF_(0x80152112L)

// Errors returned by offering service                  = 0x801530XX + 0x801531XX
#define XONLINE_S_OFFERING_NEW_CONTENT                  _HRESULT_TYPEDEF_(0x00153101L)  // new content is available
#define XONLINE_S_OFFERING_NO_NEW_CONTENT               _HRESULT_TYPEDEF_(0x00153102L)  // no new content is available
#define XONLINE_E_OFFERING_BAD_REQUEST                  _HRESULT_TYPEDEF_(0x80153001L)  // server received incorrectly formatted request
#define XONLINE_E_OFFERING_INVALID_USER                 _HRESULT_TYPEDEF_(0x80153002L)  // cannot find account for this user
#define XONLINE_E_OFFERING_INVALID_OFFER_ID             _HRESULT_TYPEDEF_(0x80153003L)  // offer does not exist
#define XONLINE_E_OFFERING_INELIGIBLE_FOR_OFFER         _HRESULT_TYPEDEF_(0x80153004L)  // )] private /title not allowed to purchase offer
#define XONLINE_E_OFFERING_OFFER_EXPIRED                _HRESULT_TYPEDEF_(0x80153005L)  // offer no longer available
#define XONLINE_E_OFFERING_SERVICE_UNREACHABLE          _HRESULT_TYPEDEF_(0x80153006L)  // apparent connectivity problems
#define XONLINE_E_OFFERING_PURCHASE_BLOCKED             _HRESULT_TYPEDEF_(0x80153007L)  // this user is not allowed to make purchases
#define XONLINE_E_OFFERING_PURCHASE_DENIED              _HRESULT_TYPEDEF_(0x80153008L)  // this user's payment is denied by billing provider
#define XONLINE_E_OFFERING_BILLING_SERVER_ERROR         _HRESULT_TYPEDEF_(0x80153009L)  // nonspecific billing provider error
#define XONLINE_E_OFFERING_OFFER_NOT_CANCELABLE         _HRESULT_TYPEDEF_(0x8015300AL)  // either this offer doesn't exist, or it's marked as un-cancelable
#define XONLINE_E_OFFERING_NOTHING_TO_CANCEL            _HRESULT_TYPEDEF_(0x8015300BL)  // this user doesn't have one of these anyways
#define XONLINE_E_OFFERING_ALREADY_OWN_MAX              _HRESULT_TYPEDEF_(0x8015300CL)  // this user already owns the maximum allowed
#define XONLINE_E_OFFERING_NO_CHARGE                    _HRESULT_TYPEDEF_(0x8015300DL)  // this is a free offer; no purchase is necessary
#define XONLINE_E_OFFERING_PERMISSION_DENIED            _HRESULT_TYPEDEF_(0x8015300EL)  // permission denied
#define XONLINE_E_OFFERING_NAME_TAKEN                   _HRESULT_TYPEDEF_(0x8015300FL)  // Name given to XOnlineVerifyNickname is taken (dosen't vet)
#define XONLINE_E_OFFERING_UNKNOWN_OFFER_TYPE           _HRESULT_TYPEDEF_(0x8015301AL)  // Unknown offer type
#define XONLINE_E_OFFERING_PAYMENT_TYPE                 _HRESULT_TYPEDEF_(0x8015301BL)  // Unknown payment type

//  Errors returned by xcbk service                     = 0x801535XX

//  Errors returned by uacs service                     = 0x801540XX

#define XONLINE_E_ACCOUNTS_USER_GET_ACCOUNT_INFO_ERROR  _HRESULT_TYPEDEF_(0x80154098L) // non-specific (catch all) api error
#define XONLINE_E_ACCOUNTS_USER_OPTED_OUT               _HRESULT_TYPEDEF_(0x80154099L)

// Errors returned by Notification                      = 0x801550XX
#define XONLINE_E_NOTIFICATION_BAD_CONTENT_TYPE         _HRESULT_TYPEDEF_(0x80155000L)
#define XONLINE_E_NOTIFICATION_REQUEST_TOO_SMALL        _HRESULT_TYPEDEF_(0x80155001L)
#define XONLINE_E_NOTIFICATION_INVALID_MESSAGE_TYPE     _HRESULT_TYPEDEF_(0x80155002L)
#define XONLINE_E_NOTIFICATION_NO_ADDRESS               _HRESULT_TYPEDEF_(0x80155003L)
#define XONLINE_E_NOTIFICATION_INVALID_PUID             _HRESULT_TYPEDEF_(0x80155004L)
#define XONLINE_E_NOTIFICATION_NO_CONNECTION            _HRESULT_TYPEDEF_(0x80155005L)
#define XONLINE_E_NOTIFICATION_SEND_FAILED              _HRESULT_TYPEDEF_(0x80155006L)
#define XONLINE_E_NOTIFICATION_RECV_FAILED              _HRESULT_TYPEDEF_(0x80155007L)
#define XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED        _HRESULT_TYPEDEF_(0x80155008L)
#define XONLINE_E_NOTIFICATION_INVALID_TITLE_ID         _HRESULT_TYPEDEF_(0x80155009L)

// Errors returned by Messages                          = 0x80155AXX
#define XONLINE_E_MESSAGE_INVALID_MESSAGE_ID            _HRESULT_TYPEDEF_(0x80155A01L)  // the specified message was not found
#define XONLINE_E_MESSAGE_PROPERTY_DOWNLOAD_REQUIRED    _HRESULT_TYPEDEF_(0x80155A02L)  // the property was too large to fit into the details block, it must be retrieved separately using XOnlineMessageDownloadAttachmentxxx
#define XONLINE_E_MESSAGE_PROPERTY_NOT_FOUND            _HRESULT_TYPEDEF_(0x80155A03L)  // the specified property tag was not found
#define XONLINE_E_MESSAGE_NO_VALID_SENDS_TO_REVOKE      _HRESULT_TYPEDEF_(0x80155A04L)  // no valid sends to revoke were found
#define XONLINE_E_MESSAGE_NO_MESSAGE_DETAILS            _HRESULT_TYPEDEF_(0x80155A05L)  // the specified message does not have any details
#define XONLINE_E_MESSAGE_INVALID_TITLE_ID              _HRESULT_TYPEDEF_(0x80155A06L)  // an invalid title ID was specified
#define XONLINE_E_MESSAGE_SENDER_BLOCKED                _HRESULT_TYPEDEF_(0x80155A07L)  // a send failed because the recipient has blocked the sender
#define XONLINE_E_MESSAGE_MAX_DETAILS_SIZE_EXCEEDED     _HRESULT_TYPEDEF_(0x80155A08L)  // the property couldn't be added because the maximum details size would be exceeded
#define XONLINE_E_MESSAGE_INVALID_MESSAGE_TYPE          _HRESULT_TYPEDEF_(0x80155A09L)
#define XONLINE_E_MESSAGE_USER_OPTED_OUT                _HRESULT_TYPEDEF_(0x80155A0AL)  // a send failed because the message is marketing and the recipient has opted-out for the sending title
#define XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES       _HRESULT_TYPEDEF_(0x80155A0BL)  // the sender does not have permissions to send this message
#define XONLINE_E_MESSAGE_UNDELIVERABLE                 _HRESULT_TYPEDEF_(0x80155A0CL)  // the recipient does not have permissions to receive this message
#define XONLINE_E_MESSAGE_THROTTLED                     _HRESULT_TYPEDEF_(0x80155A0DL)  // the sender has sent too many messages today.
// Success codes returned by Messages                   = 0x00155AXX
#define XONLINE_S_MESSAGE_PENDING_SYNC                  _HRESULT_TYPEDEF_(0x00155A01L)  // updated message list is currently being retrieved (after logon or disabling summary refresh), returned results may be out of date


//  Errors returned by matchmaking                      = 0x801551XX
#define XONLINE_E_MATCH_INVALID_SESSION_ID              _HRESULT_TYPEDEF_(0x80155100L)  // specified session id does not exist
#define XONLINE_E_MATCH_INVALID_TITLE_ID                _HRESULT_TYPEDEF_(0x80155101L)  // specified title id is zero, or does not exist
#define XONLINE_E_MATCH_INVALID_DATA_TYPE               _HRESULT_TYPEDEF_(0x80155102L)  // attribute ID or parameter type specifies an invalid data type
#define XONLINE_E_MATCH_REQUEST_TOO_SMALL               _HRESULT_TYPEDEF_(0x80155103L)  // the request did not meet the minimum length for a valid request
#define XONLINE_E_MATCH_REQUEST_TRUNCATED               _HRESULT_TYPEDEF_(0x80155104L)  // the self described length is greater than the actual buffer size
#define XONLINE_E_MATCH_INVALID_SEARCH_REQ              _HRESULT_TYPEDEF_(0x80155105L)  // the search request was invalid
#define XONLINE_E_MATCH_INVALID_OFFSET                  _HRESULT_TYPEDEF_(0x80155106L)  // one of the attribute/parameter offsets in the request was invalid.  Will be followed by the zero based offset number.
#define XONLINE_E_MATCH_INVALID_ATTR_TYPE               _HRESULT_TYPEDEF_(0x80155107L)  // the attribute type was something other than user or session
#define XONLINE_E_MATCH_INVALID_VERSION                 _HRESULT_TYPEDEF_(0x80155108L)  // bad protocol version in request
#define XONLINE_E_MATCH_OVERFLOW                        _HRESULT_TYPEDEF_(0x80155109L)  // an attribute or parameter flowed past the end of the request
#define XONLINE_E_MATCH_INVALID_RESULT_COL              _HRESULT_TYPEDEF_(0x8015510AL)  // referenced stored procedure returned a column with an unsupported data type
#define XONLINE_E_MATCH_INVALID_STRING                  _HRESULT_TYPEDEF_(0x8015510BL)  // string with length-prefix of zero, or string with no terminating null
#define XONLINE_E_MATCH_STRING_TOO_LONG                 _HRESULT_TYPEDEF_(0x8015510CL)  // string exceeded 400 characters
#define XONLINE_E_MATCH_BLOB_TOO_LONG                   _HRESULT_TYPEDEF_(0x8015510DL)  // blob exceeded 800 bytes
#define XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID            _HRESULT_TYPEDEF_(0x80155110L)  // attribute id is invalid
#define XONLINE_E_MATCH_SESSION_ALREADY_EXISTS          _HRESULT_TYPEDEF_(0x80155112L)  // session id already exists in the db
#define XONLINE_E_MATCH_CRITICAL_DB_ERR                 _HRESULT_TYPEDEF_(0x80155115L)  // critical error in db
#define XONLINE_E_MATCH_NOT_ENOUGH_COLUMNS              _HRESULT_TYPEDEF_(0x80155116L)  // search result set had too few columns
#define XONLINE_E_MATCH_PERMISSION_DENIED               _HRESULT_TYPEDEF_(0x80155117L)  // incorrect permissions set on search sp
#define XONLINE_E_MATCH_INVALID_PART_SCHEME             _HRESULT_TYPEDEF_(0x80155118L)  // title specified an invalid partitioning scheme
#define XONLINE_E_MATCH_INVALID_PARAM                   _HRESULT_TYPEDEF_(0x80155119L)  // bad parameter passed to sp
#define XONLINE_E_MATCH_DATA_TYPE_MISMATCH              _HRESULT_TYPEDEF_(0x8015511DL)  // data type specified in attr id did not match type of attr being set
#define XONLINE_E_MATCH_SERVER_ERROR                    _HRESULT_TYPEDEF_(0x8015511EL)  // error on server not correctable by client
#define XONLINE_E_MATCH_NO_USERS                        _HRESULT_TYPEDEF_(0x8015511FL)  // no authenticated users in search request.
#define XONLINE_E_MATCH_INVALID_BLOB                    _HRESULT_TYPEDEF_(0x80155120L)  // invalid blob attribute
#define XONLINE_E_MATCH_TOO_MANY_USERS                  _HRESULT_TYPEDEF_(0x80155121L)  // too many users in search request
#define XONLINE_E_MATCH_INVALID_FLAGS                   _HRESULT_TYPEDEF_(0x80155122L)  // invalid flags were specified in a search request
#define XONLINE_E_MATCH_PARAM_MISSING                   _HRESULT_TYPEDEF_(0x80155123L)  // required parameter not passed to sp
#define XONLINE_E_MATCH_TOO_MANY_PARAM                  _HRESULT_TYPEDEF_(0x80155124L)  // too many paramters passed to sp
#define XONLINE_E_MATCH_DUPLICATE_PARAM                 _HRESULT_TYPEDEF_(0x80155125L)  // a paramter was passed to twice to a search procedure

//  Errors returned by session APIs                     = 0x801552XX
#define XONLINE_E_SESSION_NOT_FOUND                     _HRESULT_TYPEDEF_(0x80155200L)  // specified session id does not exist
#define XONLINE_E_SESSION_INSUFFICIENT_PRIVILEGES       _HRESULT_TYPEDEF_(0x80155201L)  // the requester does not have permissions to perform this operation

// Errors returned by uodb procs                        = 0x801560XX
#define XONLINE_E_UODB_KEY_ALREADY_EXISTS               _HRESULT_TYPEDEF_(0x80156000L)  // service key already exists when attempting to insert key

// Errors returned by Query service                     = 0x801561XX
#define XONLINE_E_QUERY_QUOTA_FULL                      _HRESULT_TYPEDEF_(0x80156101L)  // this user or team's quota for the dataset is full.  you must remove an entity first.
#define XONLINE_E_QUERY_ENTITY_NOT_FOUND                _HRESULT_TYPEDEF_(0x80156102L)  // the requested entity didn't exist in the provided dataset.
#define XONLINE_E_QUERY_PERMISSION_DENIED               _HRESULT_TYPEDEF_(0x80156103L)  // the user tried to update or delete an entity that he didn't own.
#define XONLINE_E_QUERY_ATTRIBUTE_TOO_LONG              _HRESULT_TYPEDEF_(0x80156104L)  // attribute passed exceeds schema definition
#define XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE            _HRESULT_TYPEDEF_(0x80156105L)  // attribute passed was a bad param for the database operation
#define XONLINE_E_QUERY_INVALID_ACTION                  _HRESULT_TYPEDEF_(0x80156107L)  // the specified action (or dataset) doesn't have a select action associated with it.
#define XONLINE_E_QUERY_SPEC_COUNT_MISMATCH             _HRESULT_TYPEDEF_(0x80156108L)  // the provided number of QUERY_ATTRIBUTE_SPECs doesn't match the number returned by the procedure
#define XONLINE_E_QUERY_DATASET_NOT_FOUND               _HRESULT_TYPEDEF_(0x80156109L)  // The specified dataset id was not found.
#define XONLINE_E_QUERY_PROCEDURE_NOT_FOUND             _HRESULT_TYPEDEF_(0x8015610AL)  // The specified proc index was not found.
#define XONLINE_E_QUERY_DUPLICATE_ENTRY                 _HRESULT_TYPEDEF_(0x8015610BL)  // An entry already exists that conflicts with the unique data index specified for this dataset
#define XONLINE_E_QUERY_RETRY                           _HRESULT_TYPEDEF_(0x8015610CL)  // An error occurred in the database requiring a retry


// Errors returned by Competitions service              = 0x801562XX
#define XONLINE_E_COMP_ACCESS_DENIED                    _HRESULT_TYPEDEF_(0x80156202L)  // The specified source (client) is not permitted to execute this method
#define XONLINE_E_COMP_REGISTRATION_CLOSED              _HRESULT_TYPEDEF_(0x80156203L)  // The competition is closed to registration
#define XONLINE_E_COMP_FULL                             _HRESULT_TYPEDEF_(0x80156204L)  // The competition has reached it's max enrollment
#define XONLINE_E_COMP_NOT_REGISTERED                   _HRESULT_TYPEDEF_(0x80156205L)  // The user or team isn't registered for the competition
#define XONLINE_E_COMP_CANCELLED                        _HRESULT_TYPEDEF_(0x80156206L)  // The competition has been cancelled, and the operation is invalid.
#define XONLINE_E_COMP_CHECKIN_TIME_INVALID             _HRESULT_TYPEDEF_(0x80156207L)  // The user is attempting to checkin to an event outside the allowed time.
#define XONLINE_E_COMP_CHECKIN_BAD_EVENT                _HRESULT_TYPEDEF_(0x80156208L)  // The user is attempting to checkin to an event in which they are not a valid participant.
#define XONLINE_E_COMP_EVENT_SCORED                     _HRESULT_TYPEDEF_(0x80156209L)  // The user is attempting to checkin to an event which has already been scored by the service (user has forfeited or been ejected)
#define XONLINE_S_COMP_EVENT_SCORED                     _HRESULT_TYPEDEF_(0x00156209L)  // The user is attempting to checkin to an event but the users event has been updated. Re-query for a new event
#define XONLINE_E_COMP_UNEXPECTED                       _HRESULT_TYPEDEF_(0x80156210L)  // Results from the Database are unexpected or inconsistent with the current operation.
#define XONLINE_E_COMP_TOPOLOGY_ERROR                   _HRESULT_TYPEDEF_(0x80156216L)  // The topology request cannot be fulfilled by the server
#define XONLINE_E_COMP_TOPOLOGY_PENDING                 _HRESULT_TYPEDEF_(0x80156217L)  // The topology request has not completed yet
#define XONLINE_E_COMP_CHECKIN_TOO_EARLY                _HRESULT_TYPEDEF_(0x80156218L)  // The user is attempting to checkin to an event before the allowed time.
#define XONLINE_E_COMP_ALREADY_REGISTERED               _HRESULT_TYPEDEF_(0x80156219L)  // The user has already registered for this competition.
#define XONLINE_E_COMP_INVALID_ENTRANT_TYPE             _HRESULT_TYPEDEF_(0x8015621AL)  // dwTeamId was non-0 for a user competition, or dwTeamId was 0 for a team competition
#define XONLINE_E_COMP_TOO_LATE                         _HRESULT_TYPEDEF_(0x8015621BL)  // The time alloted for performing the requested action has already passed.
#define XONLINE_E_COMP_TOO_EARLY                        _HRESULT_TYPEDEF_(0x8015621CL)  // The specified action cannot yet be peformed .
#define XONLINE_E_COMP_NO_BYES_AVAILABLE                _HRESULT_TYPEDEF_(0x8015621DL)  // No byes remain to be granted
#define XONLINE_E_COMP_SERVICE_OUTAGE                   _HRESULT_TYPEDEF_(0x8015621EL)  // A service outage has occured, try again in a bit

// Errors returned by the v1 Message Service            = 0x801570XX
#define XONLINE_E_MSGSVR_INVALID_REQUEST                _HRESULT_TYPEDEF_(0x80157001L)  // an invalid request type was received

// Errors returned by the String Service                = 0x801571XX
#define XONLINE_E_STRING_TOO_LONG                       _HRESULT_TYPEDEF_(0x80157101L)  // the string was longer than the allowed maximum
#define XONLINE_E_STRING_OFFENSIVE_TEXT                 _HRESULT_TYPEDEF_(0x80157102L)  // the string contains offensive text
#define XONLINE_E_STRING_NO_DEFAULT_STRING              _HRESULT_TYPEDEF_(0x80157103L)  // returned by AddString when no string of the language specified as the default is found
#define XONLINE_E_STRING_INVALID_LANGUAGE               _HRESULT_TYPEDEF_(0x80157104L)  // returned by AddString when an invalid language is specified for a string
#define XONLINE_E_STRING_LANGUAGE_DUPLICATE             _HRESULT_TYPEDEF_(0x80157105L)  // returned by AddString when a language is specified more than once in a single request

// Errors returned by the Feedback Service              = 0x801580XX
#define XONLINE_E_FEEDBACK_NULL_TARGET                  _HRESULT_TYPEDEF_(0x80158001L) // target PUID of feedback is NULL
#define XONLINE_E_FEEDBACK_BAD_TYPE                     _HRESULT_TYPEDEF_(0x80158002L) // bad feedback type
#define XONLINE_E_FEEDBACK_CANNOT_LOG                   _HRESULT_TYPEDEF_(0x80158006L) // cannot write to feedback log

// Errors returned by the lists service                 = 0x801581XX
#define XONLINE_E_LISTS_ERROR                           _HRESULT_TYPEDEF_(0x80158100)   // non-specific (catch-all) component error
#define XONLINE_E_LISTS_PROPERTIES_TOO_LONG             _HRESULT_TYPEDEF_(0x80158101)   // list properties XML exceeds maximum length (1000)
#define XONLINE_E_LISTS_INVALID_XML                     _HRESULT_TYPEDEF_(0x80158102)   // XML failed schema validation
#define XONLINE_E_LISTS_MALFORMED_XML                   _HRESULT_TYPEDEF_(0x80158103)   // XML not well-formed
#define XONLINE_E_LISTS_ID_MUST_BE_WILDCARD             _HRESULT_TYPEDEF_(0x80158104)   // list ID must be wildcard when list type is wildcard
#define XONLINE_E_LISTS_ITEM_TOO_LONG                   _HRESULT_TYPEDEF_(0x80158105)   // list item XML exceeds maximum length
#define XONLINE_E_LISTS_DUPLICATE_IDS                   _HRESULT_TYPEDEF_(0x80158106)   // arguments contain duplicate item IDs
#define XONLINE_E_LISTS_EMPTY_PARAMETER                 _HRESULT_TYPEDEF_(0x80158107)   // null or empty parameter array
#define XONLINE_E_LISTS_NONEXISTENT_LIST_TYPE           _HRESULT_TYPEDEF_(0x80158108)   // nonexistent list type
#define XONLINE_E_LISTS_TOO_MANY_INSTANCES              _HRESULT_TYPEDEF_(0x80158109)   // new list would exceed maximum instances
#define XONLINE_E_LISTS_NAME_TOO_LONG                   _HRESULT_TYPEDEF_(0x8015810A)   // list name exceeds maximum length (100)
#define XONLINE_E_LISTS_NONEXISTENT_LIST                _HRESULT_TYPEDEF_(0x80158110)   // nonexistent list instance
#define XONLINE_E_LISTS_TOO_MANY_ITEMS                  _HRESULT_TYPEDEF_(0x80158111)   // new items would exceed maximum items
#define XONLINE_E_LISTS_DUPLICATE_ITEM                  _HRESULT_TYPEDEF_(0x80158112)   // item with given ID already exists in the list
#define XONLINE_E_LISTS_NONEXISTENT_ITEM                _HRESULT_TYPEDEF_(0x80158113)   // nonexistent list item
#define XONLINE_E_LISTS_DUPLICATE_INDEX                 _HRESULT_TYPEDEF_(0x80158114)   // duplicate index given
#define XONLINE_E_LISTS_INVALID_INDEX                   _HRESULT_TYPEDEF_(0x80158115)   // invalid index given
#define XONLINE_E_LISTS_DUPLICATE_LIST                  _HRESULT_TYPEDEF_(0x80158116)   // user already has list with given name
#define XONLINE_E_LISTS_INVALID_PAGE_SIZE               _HRESULT_TYPEDEF_(0x80158117)   // invalid page size (1 <= pageSize <= max results)
#define XONLINE_E_LISTS_INCONSISTENT_VIEW               _HRESULT_TYPEDEF_(0x80158118)   // timestamp argument does not match list timestamp
#define XONLINE_E_LISTS_INVALID_ORDER                   _HRESULT_TYPEDEF_(0x80158119)   // invalid order direction (1 ascending, 2 descending)
#define XONLINE_E_LISTS_API_MISMATCH                    _HRESULT_TYPEDEF_(0x80158120)   // lists of this type should use a different API set

#define XONLINE_E_LISTS_CREATE_LIST_ERROR               _HRESULT_TYPEDEF_(0x80158180)   // non-specific (catch-all) api error
#define XONLINE_E_LISTS_DELETE_ITEMS_ERROR              _HRESULT_TYPEDEF_(0x80158181)   // non-specific (catch-all) api error
#define XONLINE_E_LISTS_DELETE_LIST_ERROR               _HRESULT_TYPEDEF_(0x80158182)   // non-specific (catch-all) api error
#define XONLINE_E_LISTS_GRANT_ACCESS_ERROR              _HRESULT_TYPEDEF_(0x80158183)   // non-specific (catch-all) api error
#define XONLINE_E_LISTS_INSERT_ITEMS_ERROR              _HRESULT_TYPEDEF_(0x80158184)   // non-specific (catch-all) api error
#define XONLINE_E_LISTS_MODIFY_ITEMS_ERROR              _HRESULT_TYPEDEF_(0x80158185)   // non-specific (catch-all) api error
#define XONLINE_E_LISTS_MODIFY_LIST_ERROR               _HRESULT_TYPEDEF_(0x80158186)   // non-specific (catch-all) api error
#define XONLINE_E_LISTS_QUERY_ITEMS_ERROR               _HRESULT_TYPEDEF_(0x80158187)   // non-specific (catch-all) api error
#define XONLINE_E_LISTS_QUERY_LISTS_ERROR               _HRESULT_TYPEDEF_(0x80158188)   // non-specific (catch-all) api error
#define XONLINE_E_LISTS_REVOKE_ACCESS_ERROR             _HRESULT_TYPEDEF_(0x80158189)   // non-specific (catch-all) api error
#define XONLINE_E_LISTS_MOVE_ITEMS_ERROR                _HRESULT_TYPEDEF_(0x8015818A)   // non-specific (catch-all) api error

#define XONLINE_E_DOWNLOAD_QUEUE_CREATE_QUEUE_ERROR     _HRESULT_TYPEDEF_(0x801581C0)   // non-specific (catch-all) api error
#define XONLINE_E_DOWNLOAD_QUEUE_DELETE_ITEMS_ERROR     _HRESULT_TYPEDEF_(0x801581C1)   // non-specific (catch-all) api error
#define XONLINE_E_DOWNLOAD_QUEUE_DELETE_QUEUE_ERROR     _HRESULT_TYPEDEF_(0x801581C2)   // non-specific (catch-all) api error (not used)
#define XONLINE_E_DOWNLOAD_QUEUE_GRANT_ACCESS_ERROR     _HRESULT_TYPEDEF_(0x801581C3)   // non-specific (catch-all) api error
#define XONLINE_E_DOWNLOAD_QUEUE_INSERT_ITEMS_ERROR     _HRESULT_TYPEDEF_(0x801581C4)   // non-specific (catch-all) api error
#define XONLINE_E_DOWNLOAD_QUEUE_MODIFY_ITEMS_ERROR     _HRESULT_TYPEDEF_(0x801581C5)   // non-specific (catch-all) api error
#define XONLINE_E_DOWNLOAD_QUEUE_MODIFY_QUEUE_ERROR     _HRESULT_TYPEDEF_(0x801581C6)   // non-specific (catch-all) api error
#define XONLINE_E_DOWNLOAD_QUEUE_QUERY_ITEMS_ERROR      _HRESULT_TYPEDEF_(0x801581C7)   // non-specific (catch-all) api error
#define XONLINE_E_DOWNLOAD_QUEUE_QUERY_QUEUES_ERROR     _HRESULT_TYPEDEF_(0x801581C8)   // non-specific (catch-all) api error
#define XONLINE_E_DOWNLOAD_QUEUE_REVOKE_ACCESS_ERROR    _HRESULT_TYPEDEF_(0x801581C9)   // non-specific (catch-all) api error
#define XONLINE_E_DOWNLOAD_QUEUE_MOVE_ITEMS_ERROR       _HRESULT_TYPEDEF_(0x801581CA)   // non-specific (catch-all) api error

// Errors returned by the Statistics Service            = 0x80159XXX
#define XONLINE_E_STAT_BAD_REQUEST                      _HRESULT_TYPEDEF_(0x80159001L)   // server received incorrectly formatted request.
#define XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD     _HRESULT_TYPEDEF_(0x80159002L)   // title or leaderboard id were not recognized by the server.
#define XONLINE_E_STAT_TOO_MANY_SPECS                   _HRESULT_TYPEDEF_(0x80159004L)   // too many stat specs in a request.
#define XONLINE_E_STAT_TOO_MANY_STATS                   _HRESULT_TYPEDEF_(0x80159005L)   // too many stats in a spec or already stored for the user.
#define XONLINE_E_STAT_USER_NOT_FOUND                   _HRESULT_TYPEDEF_(0x80159003L)   // user not found.
#define XONLINE_E_STAT_SET_FAILED_0                     _HRESULT_TYPEDEF_(0x80159100L)   // set operation failed on spec index 0
#define XONLINE_E_STAT_PERMISSION_DENIED                _HRESULT_TYPEDEF_(0x80159200L)   // operation failed because of credentials. UserId is not logged in or this operation is not supported in production (e.g. userId=0 in XOnlineStatReset)
#define XONLINE_E_STAT_LEADERBOARD_WAS_RESET            _HRESULT_TYPEDEF_(0x80159201L)   // operation failed because user was logged on before the leaderboard was reset.
#define XONLINE_E_STAT_INVALID_ATTACHMENT               _HRESULT_TYPEDEF_(0x80159202L)   // attachment is invalid.
#define XONLINE_S_STAT_CAN_UPLOAD_ATTACHMENT            _HRESULT_TYPEDEF_(0x00159203L)   // Use XOnlineStatWriteGetResults to get a handle to upload a attachment.
#define XONLINE_E_STAT_TOO_MANY_PARAMETERS              _HRESULT_TYPEDEF_(0x80159204L)
#define XONLINE_E_STAT_TOO_MANY_PROCEDURES              _HRESULT_TYPEDEF_(0x80159205L)
#define XONLINE_E_STAT_STAT_POST_PROC_ERROR             _HRESULT_TYPEDEF_(0x80159206L)

//  Errors returned by xsuppapi service                 = 0x8015A0XX

// Errors returned by Signature Service                 = 0x8015B0XX
#define XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE       _HRESULT_TYPEDEF_(0x8015B001L)  // presented signature does not match
#define XONLINE_E_SIGNATURE_VER_UNKNOWN_KEY_VER         _HRESULT_TYPEDEF_(0x8015B002L)  // signature key version specified is not found among the valid signature keys
#define XONLINE_E_SIGNATURE_VER_UNKNOWN_SIGNATURE_VER   _HRESULT_TYPEDEF_(0x8015B003L)  // signature version is unknown, currently only version 1 is supported
#define XONLINE_E_SIGNATURE_BANNED_XBOX                 _HRESULT_TYPEDEF_(0x8015B004L)  // signature is not calculated or revoked because Xbox is banned
#define XONLINE_E_SIGNATURE_BANNED_USER                 _HRESULT_TYPEDEF_(0x8015B005L)  // signature is not calculated or revoked because at least one user is banned
#define XONLINE_E_SIGNATURE_BANNED_TITLE                _HRESULT_TYPEDEF_(0x8015B006L)  // signature is not calculated or revoked because the given title and version is banned
#define XONLINE_E_SIGNATURE_BANNED_DIGEST               _HRESULT_TYPEDEF_(0x8015B007L)  // signature is not calculated or revoked because the digest is banned
#define XONLINE_E_SIGNATURE_GET_BAD_AUTH_DATA           _HRESULT_TYPEDEF_(0x8015B008L)  // fail to retrieve AuthData from SG, returned by GetSigningKey api
#define XONLINE_E_SIGNATURE_SERVICE_UNAVAILABLE         _HRESULT_TYPEDEF_(0x8015B009L)  // fail to retrieve a signature server master key, returned by GetSigningKey or SignOnBehalf api

// Errors returned by Arbitration Service                          = 0x8015B1XX
#define XONLINE_E_ARBITRATION_SERVICE_UNAVAILABLE                  _HRESULT_TYPEDEF_(0x8015B101L)   // Service temporarily unavailable
#define XONLINE_E_ARBITRATION_INVALID_REQUEST                      _HRESULT_TYPEDEF_(0x8015B102L)   // The request is invalidly formatted
#define XONLINE_E_ARBITRATION_SESSION_NOT_FOUND                    _HRESULT_TYPEDEF_(0x8015B103L)   // The session is not found or has expired
#define XONLINE_E_ARBITRATION_REGISTRATION_FLAGS_MISMATCH          _HRESULT_TYPEDEF_(0x8015B104L)   // The session was registered with different flags by another Xbox
#define XONLINE_E_ARBITRATION_REGISTRATION_SESSION_TIME_MISMATCH   _HRESULT_TYPEDEF_(0x8015B105L)   // The session was registered with a different session time by another Xbox
#define XONLINE_E_ARBITRATION_REGISTRATION_TOO_LATE                _HRESULT_TYPEDEF_(0x8015B106L)   // Registration came too late, the session has already been arbitrated
#define XONLINE_E_ARBITRATION_NEED_TO_REGISTER_FIRST               _HRESULT_TYPEDEF_(0x8015B107L)   // Must register in seesion first, before any other activity
#define XONLINE_E_ARBITRATION_TIME_EXTENSION_NOT_ALLOWED           _HRESULT_TYPEDEF_(0x8015B108L)   // Time extension of this session not allowed, or session is already arbitrated
#define XONLINE_E_ARBITRATION_INCONSISTENT_FLAGS                   _HRESULT_TYPEDEF_(0x8015B109L)   // Inconsistent flags are used in the request
#define XONLINE_E_ARBITRATION_INCONSISTENT_COMPETITION_STATUS      _HRESULT_TYPEDEF_(0x8015B10AL)   // Whether the session is a competition is inconsistent between registration and report
#define XONLINE_E_ARBITRATION_REPORT_ALREADY_CALLED                _HRESULT_TYPEDEF_(0x8015b10BL)   // Report call for this session already made by this client
#define XONLINE_E_ARBITRATION_TOO_MANY_XBOXES_IN_SESSION           _HRESULT_TYPEDEF_(0x8015b10CL)   // Only up to 255 Xboxes can register in a session
#define XONLINE_E_ARBITRATION_1_XBOX_1_USER_SESSION_NOT_ALLOWED    _HRESULT_TYPEDEF_(0x8015b10DL)   // Single Xbox single user sessions should not be arbitrated
#define XONLINE_E_ARBITRATION_REPORT_TOO_LARGE                     _HRESULT_TYPEDEF_(0x8015b10EL)   // The stats or query submission is too large
#define XONLINE_E_ARBITRATION_INVALID_TEAMTICKET                   _HRESULT_TYPEDEF_(0x8015b10FL)   // An invalid team ticket was submitted
// Arbitration success HRESULTS
#define XONLINE_S_ARBITRATION_INVALID_XBOX_SPECIFIED               _HRESULT_TYPEDEF_(0x0015b1F0L)   // Invalid/duplicate Xbox specified in lost connectivity or suspicious info. Never the less, this report is accepted
#define XONLINE_S_ARBITRATION_INVALID_USER_SPECIFIED               _HRESULT_TYPEDEF_(0x0015b1F1L)   // Invalid/duplicate user specified in lost connectivity or suspicious info. Never the less, this report is accepted
#define XONLINE_S_ARBITRATION_DIFFERENT_RESULTS_DETECTED           _HRESULT_TYPEDEF_(0x0015b1F2L)   // Differing result submissions have been detected in this session. Never the less, this report submission is accepted

// Errors returned by the Storage services              = 0x8015C0XX
#define XONLINE_E_STORAGE_INVALID_REQUEST               _HRESULT_TYPEDEF_(0x8015c001L)  // Request is invalid
#define XONLINE_E_STORAGE_ACCESS_DENIED                 _HRESULT_TYPEDEF_(0x8015c002L)  // Client doesn't have the rights to upload the file
#define XONLINE_E_STORAGE_FILE_IS_TOO_BIG               _HRESULT_TYPEDEF_(0x8015c003L)  // File is too big
#define XONLINE_E_STORAGE_FILE_NOT_FOUND                _HRESULT_TYPEDEF_(0x8015c004L)  // File not found
#define XONLINE_E_STORAGE_INVALID_ACCESS_TOKEN          _HRESULT_TYPEDEF_(0x8015c005L)  // Access token signature is invalid
#define XONLINE_E_STORAGE_CANNOT_FIND_PATH              _HRESULT_TYPEDEF_(0x8015c006L)  // name resolution failed
#define XONLINE_E_STORAGE_FILE_IS_ELSEWHERE             _HRESULT_TYPEDEF_(0x8015c007L)  // redirection request
#define XONLINE_E_STORAGE_INVALID_STORAGE_PATH          _HRESULT_TYPEDEF_(0x8015c008L)  // Invalid storage path
#define XONLINE_E_STORAGE_INVALID_FACILITY              _HRESULT_TYPEDEF_(0x8015c009L)  // Invalid facility code
#define XONLINE_E_STORAGE_UNKNOWN_DOMAIN                _HRESULT_TYPEDEF_(0x8015c00AL)  // Bad pathname
#define XONLINE_E_STORAGE_SYNC_TIME_SKEW                _HRESULT_TYPEDEF_(0x8015c00BL)  // SyncDomain timestamp skew
#define XONLINE_E_STORAGE_SYNC_TIME_SKEW_LOCALTIME      _HRESULT_TYPEDEF_(0x8015c00CL)  // SyncDomain timestamp appears to be localtime
#define XONLINE_E_STORAGE_QUOTA_EXCEEDED                _HRESULT_TYPEDEF_(0x8015c00DL)  // Quota exceeded for storage domain
#define XONLINE_E_STORAGE_UNSUPPORTED_CONTENT_TYPE      _HRESULT_TYPEDEF_(0x8015c00EL)  // The type of the content is not supported by this API

#define XONLINE_S_STORAGE_FILE_NOT_MODIFIED             _HRESULT_TYPEDEF_(0x0015c013L)  // The file was not modified since the last installation

// Errors returned by the LIVEINFO Service              = 0x8015C1XX
#define XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG          _HRESULT_TYPEDEF_(0x8015c101L)  // Config name is invalid
#define XONLINE_E_LIVEINFO_HIVE_ERROR_LOADING_CONFIG    _HRESULT_TYPEDEF_(0x8015C102L)  // Error occured loading config

// Errors used by the KDC internally
#define XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY         _HRESULT_TYPEDEF_(0x8015C301L)  // A backend resource was too busy to service the request

// Errors returned by billing services                      = 0x80162XXX - 0x8016EXXX
#define XONLINE_E_BILLING_AUTHORIZATION_FAILED              _HRESULT_TYPEDEF_(0x80167611) // Credit card authorization failed; user should update credit card info in Dash.
#define XONLINE_E_BILLING_CREDIT_CARD_EXPIRED               _HRESULT_TYPEDEF_(0x80167531) // The credit card has expired or will expire this month; user should update card info in Dash.
#define XONLINE_E_BILLING_NON_ACTIVE_ACCOUNT                _HRESULT_TYPEDEF_(0x80169d94) // The account specified is no longer active; user should call customer service
#define XONLINE_E_BILLING_INVALID_PAYMENT_INSTRUMENT_STATUS _HRESULT_TYPEDEF_(0x80169e7f) // User's payment instrument is in a bad state. They should call customer service to rectify the issue.


//@@BEGIN_MSINTERNAL
// ====================================================================
// Localization defines

#define XOnlineIsOnlineError(hr) (((hr) & 0xFFFF0000L) == 0x80150000L)


//@@END_MSINTERNAL



//@@BEGIN_MSINTERNAL

// ====================================================================
// SGADDR

#pragma pack(push, 1)

typedef struct _SGADDR {
    IN_ADDR         inaSg;              // IP address of the SG for the client
    DWORD           dwSpiSg;            // Pseudo-random identifier assigned by the SG
    ULONGLONG       qwXboxID;           // Unique identifier of client machine account
    BYTE            abReserved[4];      // Reserved (must be zero)
} SGADDR;

typedef struct _SGADDR2 {
    IN_ADDR         inaSg;
    DWORD           dwSpiSg;            // Pseudo-random identifier assigned by the SG
    ULONGLONG       qwXboxID;           // Unique identifier of client machine account
    BYTE            bPlatform;          // Platform type XPLT_*
    BYTE            abReserved[3];      // Reserved (must be zero)
} SGADDR2;

#pragma pack(pop)

//@@END_MSINTERNAL


//@@BEGIN_MSINTERNAL

// ====================================================================
// XBOX_LIBRARY_VERSION

#pragma pack(push, 1)

typedef struct _XBOX_LIBRARY_VERSION
{
    WORD wMajorVersion;
    WORD wMinorVersion;
    WORD wBuildNumber;
    WORD wQFENumber;
} XBOX_LIBRARY_VERSION;

// How to convert an XBOX_LIBRARY_VERSION (aka ClientVersion) to a DWORD, from
// XamUpdateGetCurrentSystemVersion in \private\xam\xam\update.cpp in client tree.
//
// dwVersion |= ((DWORD) (XboxKrnlVersion->Major & 0xF)) << 28;
// dwVersion |= ((DWORD) (XboxKrnlVersion->Minor & 0xF)) << 24;
// dwVersion |= ((DWORD) (XboxKrnlVersion->Build & 0xFFFF)) << 8;
// dwVersion |= XboxKrnlVersion->Qfe & 0xFF;
//
// DWORD dwVersion bits:  MMMMmmmm BBBBBBBB BBBBBBBB QQQQQQQQ

#define CLIENTVERSION_TO_DWORD(xlVer) \
    ((xlVer).wMajorVersion & 0xF)    << 28 | \
    ((xlVer).wMinorVersion & 0xF)    << 24 | \
    ((xlVer).wBuildNumber  & 0xFFFF) << 8  | \
    ((xlVer).wQFENumber    & 0xFF)

#define DWORD_TO_CLIENTVERSION(dwVer) { \
    (WORD)(dwVer >> 28) & 0xF, \
    (WORD)(dwVer >> 24) & 0xF, \
    (WORD)(dwVer >>  8) & 0xFFFF, \
    (WORD)(dwVer      ) & 0xFF }

#pragma pack(pop)

//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
//@@END_MSINTERNAL


//
// XOnline Authentication
//

#define XONLINE_GAMERTAG_SIZE                   16
#define XONLINE_MAX_GAMERTAG_LENGTH             (XONLINE_GAMERTAG_SIZE - 1)
#define XONLINE_PASSCODE_LENGTH                  4
#define XONLINE_MAX_LOGON_USERS                  4
#define XONLINE_PC_SPONSOR_TOKEN_MAX_LENGTH      40
#define XONLINE_PC_ID_LENGTH                     8
#define XONLINE_PRESENCE_LOCALE_SIZE             40
#define XONLINE_MAX_CONSOLE_SERIAL_NUMBER_LENGTH 12

typedef enum {
    XONLINE_PASSCODE_DPAD_UP = 1,
    XONLINE_PASSCODE_DPAD_DOWN,
    XONLINE_PASSCODE_DPAD_LEFT,
    XONLINE_PASSCODE_DPAD_RIGHT,
    XONLINE_PASSCODE_GAMEPAD_X,
    XONLINE_PASSCODE_GAMEPAD_Y,
    XONLINE_PASSCODE_GAMEPAD_LEFT_TRIGGER = 9,
    XONLINE_PASSCODE_GAMEPAD_RIGHT_TRIGGER
} XONLINE_PASSCODE_TYPE;

typedef enum {
    XONLINE_NAT_OPEN = 1,
    XONLINE_NAT_MODERATE,
    XONLINE_NAT_STRICT
} XONLINE_NAT_TYPE;

//@@BEGIN_MSINTERNAL
//
// Services that can be passed to XOnlineLogon
//
//@@END_MSINTERNAL


#define XONLINE_PRESENCE_SERVICE                ((DWORD)1)
#define XONLINE_STRING_SERVICE                  ((DWORD)2)
#define XONLINE_AUTO_UPDATE_SERVICE             ((DWORD)3)
#define XONLINE_BASE_SUBSCRIPTION_SERVICE       ((DWORD)4)
#define XONLINE_USER_ACCOUNT_SERVICE            ((DWORD)5)
#define XONLINE_MATCHMAKING_SERVICE             ((DWORD)6)
#define XONLINE_STATISTICS_SERVICE              ((DWORD)7)
#define XONLINE_FEEDBACK_SERVICE                ((DWORD)8)
#define XONLINE_BILLING_OFFERING_SERVICE        ((DWORD)9)
#define XONLINE_NICKNAME_VERIFICATION_SERVICE   ((DWORD)9)
#define XONLINE_LISTS_SERVICE                   ((DWORD)10)
#define XONLINE_TOU_SERVICE                     ((DWORD)11)
#define XONLINE_SIGNATURE_SERVICE               ((DWORD)12)
#define XONLINE_QUERY_SERVICE                   ((DWORD)13)
#define XONLINE_NAME_RESOLUTION_SERVICE         ((DWORD)14)
#define XONLINE_STORAGE_SERVICE                 ((DWORD)15)
#define XONLINE_ARBITRATION_SERVICE             ((DWORD)16)
//@@BEGIN_MSINTERNAL
// Following service id is internal because it is referenced
// in the net stack but we are not exposing this service
#define XONLINE_USAGE_DATA_SERVICE              ((DWORD)17)
//@@END_MSINTERNAL
#define XONLINE_MESSAGING_SERVICE               ((DWORD)18)
#define XONLINE_TEAM_SERVICE                    ((DWORD)19)
#define XONLINE_NAT_TYPE_DETECTION_SERVICE      ((DWORD)20)
#define XONLINE_DRM_SERVICE                     ((DWORD)21)
#define XONLINE_MASSIVE_SERVICE                 ((DWORD)22)
#define XONLINE_PC_LOCATOR_SERVICE              ((DWORD)23)
//@@BEGIN_MSINTERNAL
#define XONLINE_XCRYPTO_SERVICE                 ((DWORD)24)
//@@END_MSINTERNAL
#define XONLINE_LIVEINFO_SERVICE                ((DWORD)25)
#define XONLINE_CONNECTION_SERVICE              ((DWORD)26)
#define XONLINE_RATINGS_SERVICE                 ((DWORD)27)
#define XONLINE_TESTFD_SERVICE                  ((DWORD)28)
#define XONLINE_STS_SERVICE                     ((DWORD)29)
#define XONLINE_REFLECTOR_SERVICE               ((DWORD)30)
#define XONLINE_SOCIAL_QUERY_SERVICE            ((DWORD)31)
#define XONLINE_VORTEX_SERVICE                  ((DWORD)32)
#define XONLINE_XSTS_SERVICE                    ((DWORD)33)
#define XONLINE_PROFILE_SERVICE                 ((DWORD)34)
#define XONLINE_PROGRESS_SERVICE                ((DWORD)35)

#define XONLINE_MAX_SERVICE                     ((DWORD)35)
#define XONLINE_INVALID_SERVICE                 ((DWORD)0)

//@@BEGIN_MSINTERNAL
//
// Used in dwUserFlags in XUID
//
//@@END_MSINTERNAL

#define XONLINE_USER_GUEST_MASK                 0x00000003
#define XONLINE_USER_NOSHOW_RATING_MASK         0x0000001C
#define XONLINE_USER_DISCONNECT_RATING_MASK     0x000000E0
#define XONLINE_USER_COUNTRY_MASK               0x0000ff00
#define XONLINE_USER_VOICE_NOT_ALLOWED          0x00010000
#define XONLINE_USER_PURCHASE_NOT_ALLOWED       0x00020000
#define XONLINE_USER_NICKNAME_NOT_ALLOWED       0x00040000
#define XONLINE_USER_SHARED_CONTENT_NOT_ALLOWED 0x00080000
#define XONLINE_USER_PARENTAL_CONTROLLED        0x01000000
#define XONLINE_USER_LANGUAGE_MASK              0x3E000000
#define XONLINE_USER_BILLING_NOTIFICATION       0x40000000

#define XONLINE_USER_TIER_BITS                  4
#define XONLINE_USER_TIER_OFFSET                20
#define XONLINE_USER_TIER_MAXIMUM               ((1 << XONLINE_USER_TIER_BITS) - 1)
#define XONLINE_USER_TIER_MASK                  (XONLINE_USER_TIER_MAXIMUM << XONLINE_USER_TIER_OFFSET)

#define XOnlineUserCountryId(dwUserFlags) ((BYTE)(((dwUserFlags) & XONLINE_USER_COUNTRY_MASK) >> 8))

#define XOnlineIsUserVoiceAllowed(dwUserFlags) (((dwUserFlags) & XONLINE_USER_VOICE_NOT_ALLOWED) == 0)

#define XOnlineIsUserPurchaseAllowed(dwUserFlags) (((dwUserFlags) & XONLINE_USER_PURCHASE_NOT_ALLOWED) == 0)

#define XOnlineIsUserNicknameAllowed(dwUserFlags) (((dwUserFlags) & XONLINE_USER_NICKNAME_NOT_ALLOWED) == 0)

#define XOnlineIsUserSharedContentAllowed(dwUserFlags) (((dwUserFlags) & XONLINE_USER_SHARED_CONTENT_NOT_ALLOWED) == 0)

#define XOnlineUserNoShowRating(dwUserFlags) (((dwUserFlags) & XONLINE_USER_NOSHOW_RATING_MASK) >> 2)

#define XOnlineUserDisconnectRating(dwUserFlags) (((dwUserFlags) & XONLINE_USER_DISCONNECT_RATING_MASK) >> 5)

#define XOnlineIsUserGuest(dwUserFlags) (((dwUserFlags) & XONLINE_USER_GUEST_MASK) != 0)

#define XOnlineUserGuestNumber(dwUserFlags) ((dwUserFlags) & XONLINE_USER_GUEST_MASK)

#define XOnlineSetUserGuestNumber(dwUserFlags,guestNumber) ((dwUserFlags) = ((dwUserFlags) & ~XONLINE_USER_GUEST_MASK) | (guestNumber & XONLINE_USER_GUEST_MASK))

#define XOnlineUserLanguageId(dwUserFlags) ((BYTE)(((dwUserFlags) & XONLINE_USER_LANGUAGE_MASK) >> 25))

#define XOnlineIsUserBillingNotification(dwUserFlags) (((dwUserFlags) & XONLINE_USER_BILLING_NOTIFICATION) != 0)

#pragma pack(push, 4)

typedef struct _XUID {
    union
    {
        ULONGLONG qwUserID;
        ULONGLONG qwTeamID;
    };
    DWORD dwUserFlags;
} XUID;

#pragma pack(pop)

#define XOnlineAreUsersIdentical(pXUID1, pXUID2) (((pXUID1)->qwUserID == (pXUID2)->qwUserID) && \
                (XOnlineUserGuestNumber((pXUID1)->dwUserFlags) == XOnlineUserGuestNumber((pXUID2)->dwUserFlags)))

#define XOnlineXUIDIsTeam(pxuid) (((pxuid)->qwUserID & 0xFF00000000000000) == 0xFE00000000000000)


//@@BEGIN_MSINTERNAL
//
//  Type of a offering ID
//
//@@END_MSINTERNAL
typedef ULONGLONG XOFFERING_ID;

//@@BEGIN_MSINTERNAL
//@@END_MSINTERNAL

//
// Offering enumeration APIs
//




//@@BEGIN_MSINTERNAL
//
// Country Codes
//
//@@END_MSINTERNAL
#define XONLINE_COUNTRY_UNITED_ARAB_EMIRATES 1
#define XONLINE_COUNTRY_ALBANIA              2
#define XONLINE_COUNTRY_ARMENIA              3
#define XONLINE_COUNTRY_ARGENTINA            4
#define XONLINE_COUNTRY_AUSTRIA              5
#define XONLINE_COUNTRY_AUSTRALIA            6
#define XONLINE_COUNTRY_AZERBAIJAN           7
#define XONLINE_COUNTRY_BELGIUM              8
#define XONLINE_COUNTRY_BULGARIA             9
#define XONLINE_COUNTRY_BAHRAIN              10
#define XONLINE_COUNTRY_BRUNEI_DARUSSALAM    11
#define XONLINE_COUNTRY_BOLIVIA              12
#define XONLINE_COUNTRY_BRAZIL               13
#define XONLINE_COUNTRY_BELARUS              14
#define XONLINE_COUNTRY_BELIZE               15
#define XONLINE_COUNTRY_CANADA               16
#define XONLINE_COUNTRY_SWITZERLAND          18
#define XONLINE_COUNTRY_CHILE                19
#define XONLINE_COUNTRY_CHINA                20
#define XONLINE_COUNTRY_COLOMBIA             21
#define XONLINE_COUNTRY_COSTA_RICA           22
#define XONLINE_COUNTRY_CZECH_REPUBLIC       23
#define XONLINE_COUNTRY_GERMANY              24
#define XONLINE_COUNTRY_DENMARK              25
#define XONLINE_COUNTRY_DOMINICAN_REPUBLIC   26
#define XONLINE_COUNTRY_ALGERIA              27
#define XONLINE_COUNTRY_ECUADOR              28
#define XONLINE_COUNTRY_ESTONIA              29
#define XONLINE_COUNTRY_EGYPT                30
#define XONLINE_COUNTRY_SPAIN                31
#define XONLINE_COUNTRY_FINLAND              32
#define XONLINE_COUNTRY_FAROE_ISLANDS        33
#define XONLINE_COUNTRY_FRANCE               34
#define XONLINE_COUNTRY_GREAT_BRITAIN        35
#define XONLINE_COUNTRY_GEORGIA              36
#define XONLINE_COUNTRY_GREECE               37
#define XONLINE_COUNTRY_GUATEMALA            38
#define XONLINE_COUNTRY_HONG_KONG            39
#define XONLINE_COUNTRY_HONDURAS             40
#define XONLINE_COUNTRY_CROATIA              41
#define XONLINE_COUNTRY_HUNGARY              42
#define XONLINE_COUNTRY_INDONESIA            43
#define XONLINE_COUNTRY_IRELAND              44
#define XONLINE_COUNTRY_ISRAEL               45
#define XONLINE_COUNTRY_INDIA                46
#define XONLINE_COUNTRY_IRAQ                 47
#define XONLINE_COUNTRY_IRAN                 48
#define XONLINE_COUNTRY_ICELAND              49
#define XONLINE_COUNTRY_ITALY                50
#define XONLINE_COUNTRY_JAMAICA              51
#define XONLINE_COUNTRY_JORDAN               52
#define XONLINE_COUNTRY_JAPAN                53
#define XONLINE_COUNTRY_KENYA                54
#define XONLINE_COUNTRY_KYRGYZSTAN           55
#define XONLINE_COUNTRY_KOREA                56
#define XONLINE_COUNTRY_KUWAIT               57
#define XONLINE_COUNTRY_KAZAKHSTAN           58
#define XONLINE_COUNTRY_LEBANON              59
#define XONLINE_COUNTRY_LIECHTENSTEIN        60
#define XONLINE_COUNTRY_LITHUANIA            61
#define XONLINE_COUNTRY_LUXEMBOURG           62
#define XONLINE_COUNTRY_LATVIA               63
#define XONLINE_COUNTRY_LIBYA                64
#define XONLINE_COUNTRY_MOROCCO              65
#define XONLINE_COUNTRY_MONACO               66
#define XONLINE_COUNTRY_MACEDONIA            67
#define XONLINE_COUNTRY_MONGOLIA             68
#define XONLINE_COUNTRY_MACAU                69
#define XONLINE_COUNTRY_MALDIVES             70
#define XONLINE_COUNTRY_MEXICO               71
#define XONLINE_COUNTRY_MALAYSIA             72
#define XONLINE_COUNTRY_NICARAGUA            73
#define XONLINE_COUNTRY_NETHERLANDS          74
#define XONLINE_COUNTRY_NORWAY               75
#define XONLINE_COUNTRY_NEW_ZEALAND          76
#define XONLINE_COUNTRY_OMAN                 77
#define XONLINE_COUNTRY_PANAMA               78
#define XONLINE_COUNTRY_PERU                 79
#define XONLINE_COUNTRY_PHILIPPINES          80
#define XONLINE_COUNTRY_PAKISTAN             81
#define XONLINE_COUNTRY_POLAND               82
#define XONLINE_COUNTRY_PUERTO_RICO          83
#define XONLINE_COUNTRY_PORTUGAL             84
#define XONLINE_COUNTRY_PARAGUAY             85
#define XONLINE_COUNTRY_QATAR                86
#define XONLINE_COUNTRY_ROMANIA              87
#define XONLINE_COUNTRY_RUSSIAN_FEDERATION   88
#define XONLINE_COUNTRY_SAUDI_ARABIA         89
#define XONLINE_COUNTRY_SWEDEN               90
#define XONLINE_COUNTRY_SINGAPORE            91
#define XONLINE_COUNTRY_SLOVENIA             92
#define XONLINE_COUNTRY_SLOVAK_REPUBLIC      93
#define XONLINE_COUNTRY_EL_SALVADOR          95
#define XONLINE_COUNTRY_SYRIA                96
#define XONLINE_COUNTRY_THAILAND             97
#define XONLINE_COUNTRY_TUNISIA              98
#define XONLINE_COUNTRY_TURKEY               99
#define XONLINE_COUNTRY_TRINIDAD_AND_TOBAGO  100
#define XONLINE_COUNTRY_TAIWAN               101
#define XONLINE_COUNTRY_UKRAINE              102
#define XONLINE_COUNTRY_UNITED_STATES        103
#define XONLINE_COUNTRY_URUGUAY              104
#define XONLINE_COUNTRY_UZBEKISTAN           105
#define XONLINE_COUNTRY_VENEZUELA            106
#define XONLINE_COUNTRY_VIET_NAM             107
#define XONLINE_COUNTRY_YEMEN                108
#define XONLINE_COUNTRY_SOUTH_AFRICA         109
#define XONLINE_COUNTRY_ZIMBABWE             110




//@@BEGIN_MSINTERNAL
//
// Offering Type bitflags
// This is a bitmask, so the next thing we define should be 0x4, not 0x3.
//
//@@END_MSINTERNAL

#define    XONLINE_OFFERING_SUBSCRIPTION        0x1
#define    XONLINE_OFFERING_CONTENT             0x2
//@@BEGIN_MSINTERNAL
#define    XONLINE_OFFERING_RENEWAL             0x4
//@@END_MSINTERNAL



//@@BEGIN_MSINTERNAL
//
// Common enumerate bit filters
//
//@@END_MSINTERNAL

#define XONLINE_OFFERING_BITFILTER_ALL          0xffffffff
#define XONLINE_OFFERING_TYPE_ALL               0xffffffff


//@@BEGIN_MSINTERNAL
//
// OfferingFlags bitflags
//
//@@END_MSINTERNAL

#define    XONLINE_OFFERING_IS_NOT_FREE         0x1
//@@BEGIN_MSINTERNAL
#define    XONLINE_OFFERING_REQUIRES_SUB_CODE   0x2
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
//
//  Macro to determine whether an offering back from enumeration is free.
//  This is to be passed the fOfferingFlags field of an XONLINEOFFERING_INFO.
//
//@@END_MSINTERNAL

#define XOnlineOfferingIsFree(x)    (((x) & XONLINE_OFFERING_IS_NOT_FREE) == 0)

//@@BEGIN_MSINTERNAL
//
// Offering enumeration parameters struct
//
//@@END_MSINTERNAL

#pragma pack(push, 1)
typedef struct _XONLINEOFFERING_ENUM_PARAMS
{
    DWORD       dwOfferingType;    // Filter on offering type
    DWORD       dwBitFilter;       // Bitfield for filtering offerings
    DWORD       dwDescriptionIndex;// Publisher-specific index
    WORD        wStartingIndex;    // Starting index to enumerate
    WORD        wMaxResults;       // Desired max number of results
} XONLINEOFFERING_ENUM_PARAMS, *PXONLINEOFFERING_ENUM_PARAMS;
#pragma pack(pop)

//@@BEGIN_MSINTERNAL
//
// Offering enumeration record
// XONLINEOFFERING_ENUM_MAX_TITLE_DATA_SIZE should be equal to
// MAX_BINTEXT_SIZE in private\sdktools\content\common\metadata.c
//
//@@END_MSINTERNAL

#pragma pack(push, 1)
typedef struct _XONLINEOFFERING_INFO{
    XOFFERING_ID        OfferingId;             // Offering ID
    DWORD               dwOfferingType;         // Offering type
    DWORD               dwBitFlags;             // Package-specific flags
    DWORD               dwPackageSize;          // Package wire size (bytes)
    DWORD               dwInstallSize;          // Installed size (blocks)
    FILETIME            ftActivationDate;       // Activation date of package
    DWORD               dwRating;               // Package rating
    WORD                fOfferingFlags;         // Per-offering flags
    DWORD               dwTitleSpecificData;    // Size of data blob (bytes)
    PBYTE               pbTitleSpecificData;    // Pointer to data blob
} XONLINEOFFERING_INFO, *PXONLINEOFFERING_INFO;
#pragma pack(pop)

#define XONLINEOFFERING_ENUM_MAX_TITLE_DATA_SIZE    (8000)

//@@BEGIN_MSINTERNAL
//@@END_MSINTERNAL

//
// Messaging
//

#define XONLINE_MAX_NUM_MESSAGES        125
#define XONLINE_MAX_MESSAGE_RECIPIENTS  100
#define XONLINE_MAX_MESSAGE_DETAILS     4096

//@@BEGIN_MSINTERNAL
//@@END_MSINTERNAL

//
// Message Flags
//
#define XONLINE_MSG_FLAG_REQUIRED               0x00000001 // The user is required to read this message
#define XONLINE_MSG_FLAG_RECOMMENDED            0x00000002 // The user has a system recommended message
#define XONLINE_MSG_FLAG_HAS_VOICE              0x00000004 // This message contains a voice attachment
#define XONLINE_MSG_FLAG_HAS_TEXT               0x00000008 // This message contains a text body
#define XONLINE_MSG_FLAG_READ                   0x00000010 // This message has been read
#define XONLINE_MSG_FLAG_NON_EXPORTABLE         0x00000020 // This message should only be displayed on Xbox consoles, not the web
#define XONLINE_MSG_FLAG_TEAM_CONTEXT           0x00000040 // This message's sender context refers to a team ID
#define XONLINE_MSG_FLAG_COMP_CONTEXT           0x00000080 // This message's sender context refers to a competition event or entity ID
#define XONLINE_MSG_FLAG_ALTERNATE_TITLE        0x00000100 // This message is from an alternate Title of the currently logged on title (only available on Xbox consoles)
#define XONLINE_MSG_FLAG_MARKETING              0x00000200 // Used on title-sent messages to indicate the message is marketing-related and opt-in settings should be checked
#define XONLINE_MSG_FLAG_MS_MARKETING           0x00000400 // Used on title-sent messages to indicate the message is a Microsoft marketing-related and MS opt-in settings should be checked
#define XONLINE_MSG_FLAG_HAS_PHOTO              0x00000800 // This message has a photo attachment
#define XONLINE_MSG_FLAG_XENON_COMPATIBLE       0x00001000 // This message is xenon only
#define XONLINE_MSG_FLAGS_TITLE_RESERVED        0xFF000000 // Flags reserved for title custom messages
//@@BEGIN_MSINTERNAL
#define XONLINE_MSG_FLAG_SENDER_IS_FRIEND       0x00800000 // Used by Notification to detect invites that should go to V1 clients, also used by clients to allow cross-title invites
#define XONLINE_MSG_FLAG_RECV_DETAILS_NEEDED    0x00200000 // Used by the client on received summaries to indicate that the title has requested downloading details
#define XONLINE_MSG_FLAG_SEND_MSG_OWNED         0x00200000 // Used by the client on message sends to indicate that the message handle is owned by the Send operation
#define XONLINE_MSG_FLAGS_RESERVED              0x005FF000 // Flags reserved for future use
#define XONLINE_MSG_FLAGS_VALID_SEND_MASK       ( XONLINE_MSG_FLAGS_TITLE_RESERVED | \
                                                  XONLINE_MSG_FLAG_NON_EXPORTABLE | \
                                                  XONLINE_MSG_FLAG_REQUIRED | \
                                                  XONLINE_MSG_FLAG_RECOMMENDED | \
                                                  XONLINE_MSG_FLAG_HAS_VOICE | \
                                                  XONLINE_MSG_FLAG_HAS_TEXT | \
                                                  XONLINE_MSG_FLAG_TEAM_CONTEXT | \
                                                  XONLINE_MSG_FLAG_COMP_CONTEXT | \
                                                  XONLINE_MSG_FLAG_MARKETING | \
                                                  XONLINE_MSG_FLAG_MS_MARKETING | \
                                                  XONLINE_MSG_FLAG_HAS_PHOTO | \
                                                  XONLINE_MSG_FLAG_XENON_COMPATIBLE) // Flags valid in a call to send a message
#define XONLINE_MSG_FLAGS_TITLE_SETABLE         ( XONLINE_MSG_FLAG_READ | \
                                                  XONLINE_MSG_FLAGS_TITLE_RESERVED ) // Flags a title is allowed to set on an already sent message
#define XONLINE_MSG_FLAGS_TITLE_CLEARABLE       ( XONLINE_MSG_FLAGS_TITLE_RESERVED ) // Flags a title is allowed to clear on an already sent message
//@@END_MSINTERNAL

//
// Message Property Types
//
#define XONLINE_MSG_PROP_TYPE_NULL         ((BYTE)  1) // The property contains no data
#define XONLINE_MSG_PROP_TYPE_I1           ((BYTE)  2) // The property value points to 8-bits of data
#define XONLINE_MSG_PROP_TYPE_I2           ((BYTE)  3) // The property value points to 16-bits of data
#define XONLINE_MSG_PROP_TYPE_I4           ((BYTE)  4) // The property value points to 32-bits of data
#define XONLINE_MSG_PROP_TYPE_I8           ((BYTE)  5) // The property value points to 64-bits of data
#define XONLINE_MSG_PROP_TYPE_STRING       ((BYTE)  6) // The property value points to a NULL-terminated wide character string
#define XONLINE_MSG_PROP_TYPE_FILETIME     ((BYTE)  7) // The property value points to a time value
#define XONLINE_MSG_PROP_TYPE_BINARY       ((BYTE)  8) // The property value points to a binary blob that fits in the message details
#define XONLINE_MSG_PROP_TYPE_ATTACHMENT   ((BYTE)  9) // The property value points to a binary blob (or directory path, depending on attachment flags) that will be uploaded to storage during XOnlineMessageSend
#define XONLINE_MSG_PROP_TYPE_BOOL         ((BYTE) 10) // The property value points to a boolean value (1=TRUE, 0=FALSE)
#define XONLINE_MSG_PROP_TYPE_STRING_ID    ((BYTE) 11) // The property value contains a string ID whose text can be requested from the string service

//
// Attachment Flags
//
#define XONLINE_MSG_ATTACHMENT_FLAG_NON_EXPORTABLE  0x00000001 // This attachment should not be visible when the message is displayed on the web
#define XONLINE_MSG_ATTACHMENT_FLAG_DIRECTORY       0x00000002 // The property value points to an ANSI path string to a local directory that will be uploaded to storage, instead of a binary blob
//@@BEGIN_MSINTERNAL
#define XONLINE_MSG_ATTACHMENT_FLAGS_RESERVED       0xFFFFFFFC // Flags reserved for future use
//@@END_MSINTERNAL


//
// Message Property Tags
// Property tags occupy a word where the upper byte indicates the property's data type, and
// the lower byte indicates a unique identifier for the property.  Property identifiers only
// need to be unique within a given message type.
//
#define XONLINE_MSG_PROP_TAG(type, id)      ((BYTE)(type) << 8 | (BYTE)(id))
#define XOnlineMessageGetPropId(tag)        (BYTE)((WORD)(tag) & 0xFF)
#define XOnlineMessageGetPropType(tag)      (BYTE)((WORD)(tag) >> 8)

//
// Message Property IDs
// Property IDs should adhere to the following ranges:
//
// Range           Purpose
// 0x00-0x7F       Reserved for use by titles
// 0x80-0xBF       Reserved for use by Microsoft for non-global properties
// 0xC0-0xFF       Reserved for use by Microsoft for properties that span all message types
#define XONLINE_MSG_PROP_ID_BUILTIN        0x80 // Used for properties defined by Microsoft
#define XONLINE_MSG_PROP_ID_GLOBAL         0x40 // Used for properties that can span all message types

//@@BEGIN_MSINTERNAL
//
// Message IDs
//
#define XONLINE_MSG_ID_SEND_FAILED         0x80000000 // NOTE: This high bit must not be used so that send can use it to return failed HRESULTs
#define XONLINE_MSG_ID_SYSTEM_MESSAGE      0x40000000 // A message sent by the Live service or a publisher
#define XONLINE_MSG_ID_TRANSIENT_MESSAGE   0x20000000 // A special type of message that goes away when the sender goes offline
#define XONLINE_MSG_ID_BASE_MASK           0x00FFFFFF
#define XONLINE_MSG_ID_RESERVED_MASK       0x1F000000

#define IsMsgTransient( msgid ) ( ( msgid ) & XONLINE_MSG_ID_TRANSIENT_MESSAGE )

//
// Message Notifications (Internal)
//
#define XONLINE_MSG_NOTIFICATION_FLAG_SAME_TITLE         0x000001
#define XONLINE_MSG_NOTIFICATION_FLAG_SAME_PUBLISHER     0x000002
#define XONLINE_MSG_NOTIFICATION_FLAG_INVITE_FROM_FRIEND 0x000004
#define XONLINE_MSG_NOTIFICATION_FLAG_HAS_VOICE          0x000008
#define XONLINE_MSG_NOTIFICATION_FLAG_HAS_TEXT           0x000010
#define XONLINE_MSG_NOTIFICATION_FLAG_ALT_TITLE          0x000020
#define XONLINE_MSG_NOTIFICATION_FLAG_TITLE_RESERVED     0xFF0000
#define XONLINE_MSG_NOTIFICATION_FLAG_RESERVED           0x00FFC0

#pragma pack(push, 1)
struct Q_MESSAGE_NOTIFICATION
{
    DWORD dwTypeAndFlags; // The upper byte is the message type
};

#define XOnlineMessageNotificationGetMsgType( dwTypeAndFlags ) (BYTE)( ( dwTypeAndFlags ) >> 24 )
#define XOnlineMessageNotificationGetFlags( dwTypeAndFlags ) (DWORD)( ( dwTypeAndFlags ) & 0x00FFFFFF )

typedef struct Q_MESSAGE_NOTIFICATION XONLINE_MESSAGE_NOTIFICATION;
#pragma pack(pop)

//@@END_MSINTERNAL

//
// Message Types
//
// A message type establishes the purpose of the message and the properties that
// are required for a message of that type.
//
#define XONLINE_MSG_TYPE_TITLE_CUSTOM           ((BYTE) 1) // context: title defined;    required props: title defined
#define XONLINE_MSG_TYPE_FRIEND_REQUEST         ((BYTE) 2) // context: 0;                required props: none
#define XONLINE_MSG_TYPE_GAME_INVITE            ((BYTE) 3) // context: see msg flags;    required props: XONLINE_MSG_PROP_SESSION_ID for Xbox, XONLINE_MSG_PROP_SESSION_DESCRIPTION, XONLINE_MSG_PROP_SESSION_HOST_XNADDR, XONLINE_MSG_PROP_SESSION_HOST_KEY in addition for Xenon.
#define XONLINE_MSG_TYPE_TEAM_RECRUIT           ((BYTE) 4) // context: inviting team ID; required props: none
#define XONLINE_MSG_TYPE_COMP_REMINDER          ((BYTE) 5) // context: comp event ID;    required props: XONLINE_MSG_PROP_COMP_NAME, XONLINE_MSG_PROP_COMP_EVENT_START
#define XONLINE_MSG_TYPE_COMP_REQUEST           ((BYTE) 6) // context: comp entity ID;   required props: XONLINE_MSG_PROP_COMP_NAME, XONLINE_MSG_PROP_COMP_START, XONLINE_MSG_PROP_COMP_REG_CLOSE
#define XONLINE_MSG_TYPE_LIVE_MESSAGE           ((BYTE) 7) // context: 0                 required props: XONLINE_MSG_PROP_SYSTEM_TEXT
#define XONLINE_MSG_TYPE_PERSONAL_MESSAGE       ((BYTE) 8) // context: 0                 required props: XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VOICE_DATA.
#define XONLINE_MSG_TYPE_VIDEO_MESSAGE          ((BYTE) 9) // context: 0                 required props: XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VIDEO_DATA
#define XONLINE_MSG_TYPE_QUICK_CHAT_INVITE      ((BYTE) 10) // context: 0
#define XONLINE_MSG_TYPE_VIDEO_CHAT_INVITE      ((BYTE) 11) // context: 0
#define XONLINE_MSG_TYPE_PARTY_CHAT_INVITE      ((BYTE) 12) // context: 0

//
// Global property tags, allowed in any message type
//

// All message types can contain a voice attachment specified in the following properties.  All three
// of the following properties should be specified together.  The XONLINE_MSG_FLAG_HAS_VOICE message
// flag can be used to test for the presence of these properties before the message details have been
// retrieved.
#define XONLINE_MSG_PROP_VOICE_DATA               XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_ATTACHMENT, XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 1)
#define XONLINE_MSG_PROP_VOICE_DATA_CODEC         XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I2,         XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 2)
#define XONLINE_MSG_PROP_VOICE_DATA_DURATION      XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I4,         XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 3)

// All message types can contain a text summary specified in the following properties.  Both
// of the following properties should be specified together.  The XONLINE_MSG_FLAG_HAS_TEXT message
// flag can be used to test for the presence of these properties before the message details have been
// retrieved.  The text should be 256 characters or less and may be used by Live anywhere that a text
// summary of the message is useful, such as in a Messenger Alert, on the web, or in the Dashboard.
#define XONLINE_MSG_PROP_TEXT                     XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_STRING,     XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 4)
#define XONLINE_MSG_PROP_TEXT_LANGUAGE            XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I4,         XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 5)

// All message types can contain a photo attachment in the following properties.  Both
// of the following properties should be specified together.  The XONLINE_MSG_FLAG_HAS_PHOTO message
// flag can be used to test for the presence of these properties before the message details have been
// retrieved.
#define XONLINE_MSG_PROP_PHOTO_DATA               XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_ATTACHMENT, XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 6)
#define XONLINE_MSG_PROP_PHOTO_DATA_CODEC         XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I2,         XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 7)


// The subject is a UNICODE array of fixed length.
#define XONLINE_MAX_SUBJECT_SIZE                  20

//
//Video Message Properties
//
#define XONLINE_MSG_PROP_VIDEO_FRAME_DATA         XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_ATTACHMENT, XONLINE_MSG_PROP_ID_BUILTIN | 1)
#define XONLINE_MSG_PROP_VIDEO_FRAME_CODEC        XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I2,         XONLINE_MSG_PROP_ID_BUILTIN | 2)           //This defines the First Frame of the Video as JPG, BMPetc if we wanted to show the First Frame of the Video in the HUD.
#define XONLINE_MSG_PROP_VIDEO_DATA               XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_ATTACHMENT, XONLINE_MSG_PROP_ID_BUILTIN | 3)
#define XONLINE_MSG_PROP_VIDEO_DATA_CODEC         XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I2,         XONLINE_MSG_PROP_ID_BUILTIN | 4)
#define XONLINE_MSG_PROP_VIDEO_DATA_DURATION      XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I4,         XONLINE_MSG_PROP_ID_BUILTIN | 5)



//
// Invite message properties
//
#define XONLINE_MSG_PROP_SESSION_ID               XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I8,         XONLINE_MSG_PROP_ID_BUILTIN | 1)
#define XONLINE_MSG_PROP_SESSION_DESCRIPTION      XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_STRING,     XONLINE_MSG_PROP_ID_BUILTIN | 2)
#define XONLINE_MSG_PROP_SESSION_HOST_XNADDR      XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I8,         XONLINE_MSG_PROP_ID_BUILTIN | 3)
#define XONLINE_MSG_PROP_SESSION_HOST_KEY         XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I8,         XONLINE_MSG_PROP_ID_BUILTIN | 4)

//
// Custom message properties
//
#define XONLINE_MSG_PROP_GAME_MESSAGE             XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_STRING,     XONLINE_MSG_PROP_ID_BUILTIN | 1)
#define XONLINE_MSG_PROP_PLAYER_MESSAGE           XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_STRING,     XONLINE_MSG_PROP_ID_BUILTIN | 2)
#define XONLINE_MSG_PROP_CUSTOM_ACTIONS           XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_BINARY,     XONLINE_MSG_PROP_ID_BUILTIN | 3)
#define XONLINE_MSG_PROP_CUSTOM_PAYLOAD           XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_BINARY,     XONLINE_MSG_PROP_ID_BUILTIN | 4)

//
// Live system message properties
//
#define XONLINE_MSG_PROP_SYSTEM_TEXT              XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_STRING_ID,  XONLINE_MSG_PROP_ID_BUILTIN | 1)

//
// Team Recruit message properties
//
#define XONLINE_MSG_PROP_TEAM_NAME                XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_STRING,     XONLINE_MSG_PROP_ID_BUILTIN | 1)

//
// Competitions message properties
//
#define XONLINE_MSG_PROP_COMP_DATASET             XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I4,         XONLINE_MSG_PROP_ID_BUILTIN | 0x1 )
#define XONLINE_MSG_PROP_COMP_NAME                XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_STRING,     XONLINE_MSG_PROP_ID_BUILTIN | 0x2 )
#define XONLINE_MSG_PROP_COMP_START               XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_FILETIME,   XONLINE_MSG_PROP_ID_BUILTIN | 0x3 )
#define XONLINE_MSG_PROP_COMP_ROUND               XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I2,         XONLINE_MSG_PROP_ID_BUILTIN | 0x4 )
#define XONLINE_MSG_PROP_COMP_OPPONENT            XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_STRING_ID,  XONLINE_MSG_PROP_ID_BUILTIN | 0x5 )
#define XONLINE_MSG_PROP_COMP_ADMIN               XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I8,         XONLINE_MSG_PROP_ID_BUILTIN | 0x6 )
#define XONLINE_MSG_PROP_COMP_REG_CLOSE           XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_FILETIME,   XONLINE_MSG_PROP_ID_BUILTIN | 0x7 )
#define XONLINE_MSG_PROP_COMP_PRIVATE_SLOTS       XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I2,         XONLINE_MSG_PROP_ID_BUILTIN | 0x8 )
#define XONLINE_MSG_PROP_COMP_PUBLIC_SLOTS        XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I2,         XONLINE_MSG_PROP_ID_BUILTIN | 0x9 )
#define XONLINE_MSG_PROP_COMP_UNITS               XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I2,         XONLINE_MSG_PROP_ID_BUILTIN | 0xA )
#define XONLINE_MSG_PROP_COMP_INTERVAL            XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I2,         XONLINE_MSG_PROP_ID_BUILTIN | 0xB )
#define XONLINE_MSG_PROP_COMP_DAYMASK             XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I2,         XONLINE_MSG_PROP_ID_BUILTIN | 0xC )
#define XONLINE_MSG_PROP_COMP_DESCRIPTION         XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_STRING,     XONLINE_MSG_PROP_ID_BUILTIN | 0xD )
#define XONLINE_MSG_PROP_COMP_URL                 XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_STRING,     XONLINE_MSG_PROP_ID_BUILTIN | 0xE )
#define XONLINE_MSG_PROP_COMP_EVENT_ID            XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I8,         XONLINE_MSG_PROP_ID_BUILTIN | 0x10 )
#define XONLINE_MSG_PROP_COMP_EVENT_START         XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_FILETIME,   XONLINE_MSG_PROP_ID_BUILTIN | 0x11 )

//
// Voice Codec types (values for XONLINE_MSG_PROP_VOICE_DATA_CODEC)
//
#define XONLINE_PROP_VOICE_DATA_CODEC_WMAVOICE_V90      1
#define ONLINE_PROP_VOICE_DATA_CODEC_SASE3200           2

//
// Photo Codec types (values for XONLINE_MSG_PROP_PHOTO_DATA_CODEC)
//
#define XONLINE_PROP_PHOTO_DATA_CODEC_PNG                 1

//
//Personal Message Properties
//None beyond the text and voice stuff above:
//

//
//Quick Chat Invite Properties.
//
#define XONLINE_HUD_MSG_PROP_VOICECHAT_PORT       XONLINE_MSG_PROP_TAG(XONLINE_MSG_PROP_TYPE_I2,            XONLINE_MSG_PROP_ID_BUILTIN | 0x1 )

//@@BEGIN_MSINTERNAL
//
// Message Details
// Messaging property definitions should be something titles never
// access directly so that the contents are free to change in the
// future.
//
#pragma pack(push, 1)
typedef struct _XMSG_DETAILS
{
    WORD wPropCount;
    WORD cbData; // This is redundant with cbDetails in Q_MESSAGE_SUMMARY, but makes life easier for C# protocol parsing logic

    // XMSG_PROPERTY rgProperties[wPropCount]; // Property descriptors
    // BYTE rgbData[cbData]; // Property data

} XMSG_DETAILS, *PXMSG_DETAILS;

typedef struct _XMSG_PROPERTY
{
    WORD wPropTag;    // This property's type and unique identifier
    union
    {
        WORD wPropOffset; // The offset from the start of rgbData of this property's data
        WORD wData; // For type XONLINE_MSG_PROP_TYPE_I2 this contains the actual data
        BYTE bData; // For type XONLINE_MSG_PROP_TYPE_I1 and XONLINE_MSG_PROP_TYPE_BOOL this contains the actual data
    };

} XMSG_PROPERTY, *PXMSG_PROPERTY;

typedef struct _XMSG_PROPERTY_BINARY
{
    WORD cbData;
    // BYTE rgbData[cbData];

} XMSG_PROPERTY_BINARY, *PXMSG_PROPERTY_BINARY;

typedef struct _XMSG_PROPERTY_STRING
{
    WORD cbString;
    // char szString[cbString];

} XMSG_PROPERTY_STRING, *PXMSG_PROPERTY_STRING;

typedef struct _XMSG_PROPERTY_ATTACHMENT
{
    DWORD cbAttach;
    DWORD dwAttachFlags;
    DWORD cbAttachUrl;
    // char szAttachUrl[cbAttachUrl];

} XMSG_PROPERTY_ATTACHMENT, *PXMSG_PROPERTY_ATTACHMENT;

#pragma pack(pop)

//
// These defines the possibles relationships between a console and a user
//
#define XONLINE_PRESENCE_LOGON_KNOWN_CONSOLE            0
#define XONLINE_PRESENCE_LOGON_FIRST_TIME_CONSOLE       1
#define XONLINE_PRESENCE_LOGON_FIRST_TIME_LIVE          2

//@@END_MSINTERNAL



//
// XOnline Matchmaking
//

typedef struct _XONLINE_ATTRIBUTE {
    DWORD dwAttributeID;
    BOOL fChanged;
    union {
        struct {
            ULONGLONG      qwValue;
        } integer;
        struct {
            LPWSTR         lpValue;
        } string;
        struct {
            PVOID          pvValue;
            DWORD          dwLength;
        } blob;
    } info;
} XONLINE_ATTRIBUTE, *PXONLINE_ATTRIBUTE;

typedef struct _XONLINE_ATTRIBUTE_SPEC {
    DWORD            dwType;
    DWORD            dwLength;
} XONLINE_ATTRIBUTE_SPEC, *PXONLINE_ATTRIBUTE_SPEC;

#define X_MAX_STRING_ATTRIBUTE_LEN         400
#define X_MAX_BLOB_ATTRIBUTE_LEN           800

//@@BEGIN_MSINTERNAL
#define X_ATTRIBUTE_SCOPE_MASK             0x80000000
#define X_ATTRIBUTE_SCOPE_GLOBAL           0x80000000
//@@END_MSINTERNAL
#define X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC   0x00000000

#define X_ATTRIBUTE_DATATYPE_MASK          0x00F00000
#define X_ATTRIBUTE_DATATYPE_INTEGER       0x00000000
#define X_ATTRIBUTE_DATATYPE_STRING        0x00100000
#define X_ATTRIBUTE_DATATYPE_BLOB          0x00200000
#define X_ATTRIBUTE_DATATYPE_NULL          0x00F00000

#define X_ATTRIBUTE_ID_MASK                0x0000FFFF

//@@BEGIN_MSINTERNAL

#define X_ATTRIBUTE_TYPE_MASK              0x0F000000
#define X_ATTRIBUTE_TYPE_SESSION           0x00000000
#define X_ATTRIBUTE_TYPE_PARAM             0x02000000
#define X_ATTRIBUTE_TYPE_BUILTIN           0x03000000
#define X_ATTRIBUTE_TYPE_CONSTANT          0x05000000

#define X_ATTRIBUTE_RESERVED               ~(X_ATTRIBUTE_SCOPE_MASK | \
                                             X_ATTRIBUTE_DATATYPE_MASK | \
                                             X_ATTRIBUTE_TYPE_MASK | \
                                             X_ATTRIBUTE_ID_MASK)

// NOTE: Changing these values impacts both the client and the server.
#define X_MATCH_MAX_QUERY_PARAMS           30
#define X_MATCH_MAX_QUERY_RESULTS          50
#define X_MATCH_MAX_TITLE_SCHEMA_ATTRS     50
#define X_MATCH_MAX_ATTRIBUTE_DATA         4096

#pragma pack(push, 1)

// NOTE: The client doesn't use this at all
typedef struct _XMATCH_SEARCHRESULT_HEADER
{
    DWORD               dwMessageLength;
    USHORT              nNumSearchResults;
    USHORT              fFlags;             // Unused, always zero
    DWORD               dwLoggingThreshold; // Unused, always zero
} XMATCH_SEARCHRESULT_HEADER, *PXMATCH_SEARCHRESULT_HEADER;

typedef struct _XMATCH_SEARCHRESULT
{
    DWORD     dwResultLength;
    XNKID     SessionID;
    XNADDR    HostAddress;
    XNKEY     KeyExchangeKey;
    DWORD     dwPublicOpen;
    DWORD     dwPrivateOpen;
    DWORD     dwPublicFilled;
    DWORD     dwPrivateFilled;
    DWORD     dwNumAttributes;
} XMATCH_SEARCHRESULT, *PXMATCH_SEARCHRESULT;

#pragma pack(pop)

//@@END_MSINTERNAL


//
// Teams
//

#define XONLINE_MAX_TEAM_COUNT                   8
#define XONLINE_MAX_TEAM_MEMBER_COUNT            100

//
// Unicode zero-teminated strings length
//

#define XONLINE_MAX_TEAM_NAME_SIZE               16
#define XONLINE_MAX_TEAM_DESCRIPTION_SIZE        256
#define XONLINE_MAX_TEAM_MOTTO_SIZE              256
#define XONLINE_MAX_TEAM_URL_SIZE                256

//
// Custom data (bytes)
//

#define XONLINE_MAX_TEAM_DATA_SIZE               100
#define XONLINE_MAX_TEAM_MEMBER_DATA_SIZE        100


//@@BEGIN_MSINTERNAL

// ********************************************************************
// Internal structures and functions begin here
// ********************************************************************

// ====================================================================
// Internal API hresults
//

#define XONLINE_S_ACCOUNTS_NAME_TAKEN                              _HRESULT_TYPEDEF_(0x00000010L)

#define XONLINE_E_ACCOUNTS_NAME_TAKEN                              _HRESULT_TYPEDEF_(0x80154000L)
#define XONLINE_E_ACCOUNTS_INVALID_USER                            _HRESULT_TYPEDEF_(0x80154002L)
#define XONLINE_E_ACCOUNTS_BAD_CREDIT_CARD                         _HRESULT_TYPEDEF_(0x80154003L)
#define XONLINE_E_ACCOUNTS_BAD_BILLING_ADDRESS                     _HRESULT_TYPEDEF_(0x80154004L)
#define XONLINE_E_ACCOUNTS_ACCOUNT_BANNED                          _HRESULT_TYPEDEF_(0x80154005L)
#define XONLINE_E_ACCOUNTS_PERMISSION_DENIED                       _HRESULT_TYPEDEF_(0x80154006L)
#define XONLINE_E_ACCOUNTS_INVALID_VOUCHER                         _HRESULT_TYPEDEF_(0x80154007L)
#define XONLINE_E_ACCOUNTS_DATA_CHANGED                            _HRESULT_TYPEDEF_(0x80154008L) // unexpected modifications made during request.  commit is aborted to avoid overwriting modifcations.
#define XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED                    _HRESULT_TYPEDEF_(0x80154009L)
#define XONLINE_E_ACCOUNTS_OPERATION_BLOCKED                       _HRESULT_TYPEDEF_(0x8015400AL)
#define XONLINE_E_ACCOUNTS_POSTAL_CODE_REQUIRED                    _HRESULT_TYPEDEF_(0x8015400BL)
#define XONLINE_E_ACCOUNTS_TRY_AGAIN_LATER                         _HRESULT_TYPEDEF_(0x8015400CL)
#define XONLINE_E_ACCOUNTS_NOT_A_RENEWAL_OFFER                     _HRESULT_TYPEDEF_(0x8015400DL)
#define XONLINE_E_ACCOUNTS_RENEWAL_IS_LOCKED                       _HRESULT_TYPEDEF_(0x8015400EL)
#define XONLINE_E_ACCOUNTS_VOUCHER_REQUIRED                        _HRESULT_TYPEDEF_(0x8015400FL)
#define XONLINE_E_ACCOUNTS_ALREADY_DEPROVISIONED                   _HRESULT_TYPEDEF_(0x80154010L)
#define XONLINE_E_ACCOUNTS_INVALID_PRIVILEGE                       _HRESULT_TYPEDEF_(0x80154011L)
#define XONLINE_E_ACCOUNTS_INVALID_SIGNED_PASSPORT_PUID            _HRESULT_TYPEDEF_(0x80154012L)
#define XONLINE_E_ACCOUNTS_PASSPORT_ALREADY_LINKED                 _HRESULT_TYPEDEF_(0x80154013L)


#define XONLINE_USER_SIGNATURE_LENGTH           8

#define XONLINE_USERDOMAIN_SIZE                 20
#define XONLINE_MAX_USERDOMAIN_LENGTH           (XONLINE_USERDOMAIN_SIZE - 1)
#define XONLINE_KERBEROSREALM_SIZE              24
#define XONLINE_MAX_KERBEROSREALM_LENGTH        (XONLINE_KERBEROSREALM_SIZE - 1)

#define XONLINE_KEY_LENGTH                      16

typedef struct {

    XUID xuid;
    CHAR gamertag[XONLINE_GAMERTAG_SIZE];
    DWORD dwUserOptions;
    BYTE passcode[XONLINE_PASSCODE_LENGTH];

    //
    // The following 5 fields are marked as reserved in the public structure
    // The combined size should add up to XONLINE_USER_RESERVED_SIZE
    //
    CHAR domain[XONLINE_USERDOMAIN_SIZE];
    CHAR kerberosRealm[XONLINE_KERBEROSREALM_SIZE];
    BYTE key[XONLINE_KEY_LENGTH];
    DWORD dwSignatureTime;
    BYTE signature[XONLINE_USER_SIGNATURE_LENGTH];

    HRESULT hr;
} XONLINEP_USER, *PXONLINEP_USER;

//
// Internal errors code to forward info within the client logon process
//
#define XONLINE_E_LOGON_NO_IP_ADDRESS                  _HRESULT_TYPEDEF_(0x80151901L)
#define XONLINE_E_LOGON_NO_DNS_SERVICE                 _HRESULT_TYPEDEF_(0x80151902L)
#define XONLINE_E_LOGON_DNS_LOOKUP_FAILED              _HRESULT_TYPEDEF_(0x80151903L)
#define XONLINE_E_LOGON_DNS_LOOKUP_TIMEDOUT            _HRESULT_TYPEDEF_(0x80151904L)
#define XONLINE_E_LOGON_INVALID_XBOX_ONLINE_INFO       _HRESULT_TYPEDEF_(0x80151905L)
#define XONLINE_E_LOGON_MACS_FAILED                    _HRESULT_TYPEDEF_(0x80151906L)
#define XONLINE_E_LOGON_MACS_TIMEDOUT                  _HRESULT_TYPEDEF_(0x80151907L)
#define XONLINE_E_LOGON_AUTHENTICATION_FAILED          _HRESULT_TYPEDEF_(0x80151908L)
#define XONLINE_E_LOGON_AUTHENTICATION_TIMEDOUT        _HRESULT_TYPEDEF_(0x80151909L)
#define XONLINE_E_LOGON_AUTHORIZATION_FAILED           _HRESULT_TYPEDEF_(0x8015190AL)
#define XONLINE_E_LOGON_AUTHORIZATION_TIMEDOUT         _HRESULT_TYPEDEF_(0x8015190BL)
#define XONLINE_E_LOGON_XBOX_ACCOUNT_INVALID           _HRESULT_TYPEDEF_(0x8015190CL)
#define XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED            _HRESULT_TYPEDEF_(0x8015190DL)
#define XONLINE_E_LOGON_SG_SERVICE_FAILED              _HRESULT_TYPEDEF_(0x8015190EL)
#define XONLINE_E_LOGON_PRESENCE_SERVICE_FAILED        _HRESULT_TYPEDEF_(0x8015190FL)
#define XONLINE_E_LOGON_PRESENCE_SERVICE_TIMEDOUT      _HRESULT_TYPEDEF_(0x80151910L)
#define XONLINE_E_LOGON_TIMEDOUT                       _HRESULT_TYPEDEF_(0x80151911L)
#define XONLINE_E_LOGON_UNKNOWN_TITLE                  _HRESULT_TYPEDEF_(0x80151912L)
#define XONLINE_E_LOGON_INTERNAL_ERROR                 _HRESULT_TYPEDEF_(0x80151913L)
#define XONLINE_E_LOGON_MACHINE_AUTHENTICATION_FAILED  _HRESULT_TYPEDEF_(0x80151914L)
#define XONLINE_E_LOGON_TGT_REVOKED                    _HRESULT_TYPEDEF_(0x80151915L)
#define XONLINE_E_LOGON_CACHE_MISS                     _HRESULT_TYPEDEF_(0x80151916L)
#define XONLINE_E_LOGON_NOT_UPNP_NAT                   _HRESULT_TYPEDEF_(0x80151917L)
#define XONLINE_E_LOGON_INCONCLUSIVE_UPNP_NAT          _HRESULT_TYPEDEF_(0x80151918L)
#define XONLINE_E_LOGON_UPNP_NAT_HARD_FAILURE          _HRESULT_TYPEDEF_(0x80151919L)
#define XONLINE_E_LOGON_UPNP_PORT_UNAVAILABLE          _HRESULT_TYPEDEF_(0x8015191AL)
#define XONLINE_E_LOGON_PPLOGIN_OFFLINE                _HRESULT_TYPEDEF_(0x8015191BL)
#define XONLINE_E_LOGON_KERBEROS_BIND_FAILURE          _HRESULT_TYPEDEF_(0x8015191CL)
#define XONLINE_E_LOGON_LIVE_PORT_UNAVAILABLE          _HRESULT_TYPEDEF_(0x8015191DL)
#define XONLINE_E_LOGON_LIVE_PORT_OVERRIDE_UNAVAILABLE _HRESULT_TYPEDEF_(0x8015191EL)
#define XONLINE_E_LOGON_SG_SERVICE_NIC_MISMATCH        _HRESULT_TYPEDEF_(0x8015191FL)
#define XONLINE_E_LOGON_WLID_XUID_MISMATCH             _HRESULT_TYPEDEF_(0x80151920L)
#define XONLINE_E_LOGON_SU_MANIFEST_MISMATCH           _HRESULT_TYPEDEF_(0x80151921L)
#define XONLINE_E_LOGON_SU_FLASH_MISMATCH              _HRESULT_TYPEDEF_(0x80151922L)
#define XONLINE_E_LOGON_SYSTEM_UPDATE_REQUIRED         _HRESULT_TYPEDEF_(0x80151923L)
#define XONLINE_E_LOGON_UPDATE_NOT_PROPPED             _HRESULT_TYPEDEF_(0x80151924L)
#define XONLINE_E_LOGON_LIVEHIVE_FAILED                _HRESULT_TYPEDEF_(0x80151925L)
#define XONLINE_E_LOGON_INVALID_CONSOLE_ID             _HRESULT_TYPEDEF_(0x80151926L)
#define XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED_TEMP       _HRESULT_TYPEDEF_(0x80151927L)
#define XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED_REPAIR     _HRESULT_TYPEDEF_(0x80151928L)
#define XONLINE_E_LOGON_DUPLICATE_CONSOLE_ID           _HRESULT_TYPEDEF_(0x80151929L)
#define XONLINE_E_LOGON_MISSING_CONSOLE_ID             _HRESULT_TYPEDEF_(0x8015192AL)
#define XONLINE_E_LOGON_XBOX_ACCOUNT_TITLE_BANNED      _HRESULT_TYPEDEF_(0x8015192BL)
#define XONLINE_E_LOGON_XBOX_ACCOUNT_TITLE_BANNED_TEMP _HRESULT_TYPEDEF_(0x8015192CL)

#define XOnlineIsPrivateLogonHR( hr ) (((hr) & 0xFFFFFF00L) == 0x80151900L)

//
// If 2 or 3 bits are used in any status flag, then the meaning is as follows
//
#define XONLINE_LOGON_STATUS_INITIAL                             0x0
#define XONLINE_LOGON_STATUS_START                               0x1
#define XONLINE_LOGON_STATUS_SUCCESS                             0x2
#define XONLINE_LOGON_STATUS_FAIL                                0x3
#define XONLINE_LOGON_STATUS_SOCKET_FAIL                         0x4
#define XONLINE_LOGON_STATUS_RECV_FAIL                           0x5
#define XONLINE_LOGON_STATUS_MEMORY_FAIL                         0x6
#define XONLINE_LOGON_STATUS_TIMEOUT_FAIL                        0x7

//
// Meaning of bits on the Online Logon Status DWORD
//
#define XONLINE_LOGON_STATUS_XNET_FAILED                            0x00000001
#define XONLINE_LOGON_STATUS_EEPROM_FAILED                          0x00000002
#define XONLINE_LOGON_STATUS_GENEALOGY_FAILED                       0x00000004
#define XONLINE_LOGON_STATUS_OUT_OF_MEMORY                          0x00000008
#define XONLINE_LOGON_STATUS_USER_KEY_INCORRECT                     0x00000010

#define XONLINE_LOGON_STATUS_UPNP_EXCHANGE                          0x00000060
#define XONLINE_LOGON_STATUS_UPNP_EXCHANGE_SHIFT                    5

#define XONLINE_LOGON_STATUS_MACS_EXCHANGE                          0x00000380
#define XONLINE_LOGON_STATUS_MACS_EXCHANGE_SHIFT                    7

#define XONLINE_LOGON_STATUS_AS_EXCHANGE                            0x00001C00
#define XONLINE_LOGON_STATUS_AS_EXCHANGE_SHIFT                      10

#define XONLINE_LOGON_STATUS_TGS_EXCHANGE                           0x0000E000
#define XONLINE_LOGON_STATUS_TGS_EXCHANGE_SHIFT                     13

#define XONLINE_LOGON_STATUS_MACS_DNS_LOOKUP                        0x00030000
#define XONLINE_LOGON_STATUS_MACS_DNS_LOOKUP_SHIFT                  16

#define XONLINE_LOGON_STATUS_AS_DNS_LOOKUP                          0x000C0000
#define XONLINE_LOGON_STATUS_AS_DNS_LOOKUP_SHIFT                    18

#define XONLINE_LOGON_STATUS_TGS_DNS_LOOKUP                         0x00300000
#define XONLINE_LOGON_STATUS_TGS_DNS_LOOKUP_SHIFT                   20

#define XONLINE_LOGON_STATUS_MACHINE_ACCOUNT_LOOKUP                 0x00C00000
#define XONLINE_LOGON_STATUS_MACHINE_ACCOUNT_LOOKUP_SHIFT           22

#define XONLINE_LOGON_STATUS_COMBINED_TICKET_CACHE                  0x03000000
#define XONLINE_LOGON_STATUS_COMBINED_TICKET_CACHE_SHIFT            24

#define XONLINE_LOGON_STATUS_SERVICE_TICKET_CACHE                   0x0C000000
#define XONLINE_LOGON_STATUS_SERVICE_TICKET_CACHE_SHIFT             26

#define XONLINE_LOGON_STATUS_SG_EXCHANGE                            0x30000000
#define XONLINE_LOGON_STATUS_SG_EXCHANGE_SHIFT                      28

#define XONLINE_LOGON_STATUS_PRESENCE_EXCHANGE                      0xC0000000
#define XONLINE_LOGON_STATUS_PRESENCE_EXCHANGE_SHIFT                30

//
// Macro to set a status field
//
#define XOnlineSetLogonStatus( dwStatus, field, status ) (dwStatus = ((dwStatus) & ~(field)) | ((status) << field##_SHIFT));
#define XOnlineGetLogonStatus( dwStatus, field ) (((dwStatus) & (field)) >> field##_SHIFT)

#define XONLINE_UPNP_NAT_SERVICE                ((DWORD)0xFFFFFFFF)

//
// Current protocol versions for services
//
#define MAKE_DWORD_VERSION(major, minor) \
            ((((DWORD)(major)) << 16) | (minor))

#define XONLINE_PRESENCE_SERVICE_VER            MAKE_DWORD_VERSION(1, 0) //  1 = XONLINE_PRESENCE_SERVICE
#define XONLINE_STRING_SERVICE_VER              MAKE_DWORD_VERSION(1, 0) //  2 = XONLINE_STRING_SERVICE
#define XONLINE_AUTO_UPDATE_SERVICE_VER         MAKE_DWORD_VERSION(1, 0) //  3 = XONLINE_AUTO_UPDATE_SERVICE
#define XONLINE_BASE_SUBSCRIPTION_SERVICE_VER   MAKE_DWORD_VERSION(1, 0) //  4 = XONLINE_BASE_SUBSCRIPTION_SERVICE, XONLINE_CONTENT_AVAILABLE_SERVICE
#define XONLINE_USER_ACCOUNT_SERVICE_VER        MAKE_DWORD_VERSION(1, 0) //  5 = XONLINE_USER_ACCOUNT_SERVICE
#define XONLINE_MATCHMAKING_SERVICE_VER         MAKE_DWORD_VERSION(1, 0) //  6 = XONLINE_MATCHMAKING_SERVICE
#define XONLINE_STATISTICS_SERVICE_VER          MAKE_DWORD_VERSION(1, 0) //  7 = XONLINE_STATISTICS_SERVICE
#define XONLINE_FEEDBACK_SERVICE_VER            MAKE_DWORD_VERSION(1, 0) //  8 = XONLINE_FEEDBACK_SERVICE
#define XONLINE_BILLING_OFFERING_SERVICE_VER    MAKE_DWORD_VERSION(1, 0) //  9 = XONLINE_BILLING_OFFERING_SERVICE, XONLINE_NICKNAME_VERIFICATION_SERVICE
#define XONLINE_LISTS_SERVICE_VER               MAKE_DWORD_VERSION(1, 0) // 10 = XONLINE_LISTS_SERVICE
#define XONLINE_TOU_SERVICE_VER                 MAKE_DWORD_VERSION(1, 0) // 11 = XONLINE_TOU_SERVICE
#define XONLINE_SIGNATURE_SERVICE_VER           MAKE_DWORD_VERSION(1, 0) // 12 = XONLINE_SIGNATURE_SERVICE
#define XONLINE_QUERY_SERVICE_VER               MAKE_DWORD_VERSION(1, 0) // 13 = XONLINE_QUERY_SERVICE
#define XONLINE_NAME_RESOLUTION_SERVICE_VER     MAKE_DWORD_VERSION(1, 0) // 14 = XONLINE_NAME_RESOLUTION_SERVICE
#define XONLINE_STORAGE_SERVICE_VER             MAKE_DWORD_VERSION(1, 0) // 15 = XONLINE_STORAGE_SERVICE
#define XONLINE_ARBITRATION_SERVICE_VER         MAKE_DWORD_VERSION(1, 0) // 16 = XONLINE_ARBITRATION_SERVICE
#define XONLINE_USAGE_DATA_SERVICE_VER          MAKE_DWORD_VERSION(1, 0) // 17 = XONLINE_USAGE_DATA_SERVICE
#define XONLINE_MESSAGING_SERVICE_VER           MAKE_DWORD_VERSION(1, 0) // 18 = XONLINE_MESSAGING_SERVICE
#define XONLINE_TEAM_SERVICE_VER                MAKE_DWORD_VERSION(1, 0) // 19 = XONLINE_TEAM_SERVICE
#define XONLINE_NAT_TYPE_DETECTION_SERVICE_VER  MAKE_DWORD_VERSION(1, 0) // 20 = XONLINE_NAT_TYPE_DETECTION_SERVICE
#define XONLINE_LIVEINFO_SERVICE_VER            MAKE_DWORD_VERSION(1, 0) // 25 = XONLINE_LIVE_INFO_SERVICE
#define XONLINE_CONNECTION_SERVICE_VER          MAKE_DWORD_VERSION(1, 0) // 26 = XONLINE_CONNECTION_SERVICE

// Xbox Live specific kerberos errors (0x1000 - 0x1FFFF)

#define IS_KDC_XBOX_ERROR(err)  \
    (err >= 0x1000 && err <= 0x1FFFF)

#define KDC_ERR_XBOX_TOKEN_INVALID              ((DWORD)0x1000)   // Token is invalid
#define KDC_ERR_XBOX_TOKEN_BANNED               ((DWORD)0x1001)   // Token is banned
#define KDC_ERR_XBOX_TOKEN_USAGE_EXCEEDED       ((DWORD)0x1002)   // Token's usage exceeded
#define KDC_ERR_XBOX_TOKEN_IN_USE               ((DWORD)0x1003)   // Token used by different user

//
// These Services are for testing against the sgs
//
#define XONLINE_SG_SITE_1_AUTH_SERVICE          ((DWORD)129)
#define XONLINE_SG_SITE_2_AUTH_SERVICE          ((DWORD)130)

#define XONLINE_SG_SITE_1_TEST_SERVICE          ((DWORD)129)
#define XONLINE_SG_SITE_2_TEST_SERVICE          ((DWORD)130)


// ====================================================================
// XOnline Game Instrumentation
//

struct GI_CONTEXT
{
    DWORD id;
    DWORD value;
};


struct GI_PROPERTY
{
    DWORD id;   // encodes type, which denotes length of data following
    // BYTE rgbValue[];
};


// ====================================================================
// XOnline Presence & Notification
//

//
// Current version is v1.0
//
#define CURRENT_XPPROTOCOL_VER 0x00010000

//
// Various protocol related constants
//
#define MIN_PMSG_SIZE               4
#define MAX_PMSG_SIZE               0x10000 //~64k
#define MAX_HELLO_DESCRIPTION_LEN   80
#define MAX_ACCTNAME_BYTES          XONLINE_GAMERTAG_SIZE
#define MAX_TITLE_STATE_BYTES       32
#define MAX_NICKNAME_BYTES          24
#define MAX_BUDDIES                 100
#define MAX_BLOCKS                  250
#define MAX_PEER_SUBSCRIPTIONS      1000

// Constants for spliting state into the old notification message
#define MAX_NOT_TITLE_STATE_BYTES   8
#define MAX_NOT_NICKNAME_BYTES      24

// Messaging constants
#define MAX_RETURNED_USER_TITLES    100 // The maximum number of titles that QMSG_ENUM_TITLES will return
#define MAX_RETURNED_SYSTEM_MSGS    100 // The maximum number of messages that QMSG_ENUM_SYSTEM_MESSAGES will return
#define MAX_TRANSIENT_MESSAGES      25
#define MAX_PERSISTENT_MESSAGES     100
#define MAX_TOTAL_USER_MESSAGES     ( MAX_TRANSIENT_MESSAGES + MAX_PERSISTENT_MESSAGES )
#define INVITE_EXPIRATION_MINUTES   1440 // Invites expire after 1-day
#define FRIEND_REQUEST_EXPIRATION_MINUTES 43200 // Friend requests expire in 30 days
#define TEAM_RECRUIT_EXPIRATION_MINUTES   43200 // Team recruits expire in 30 days

typedef DWORD MSGTIME;
#define FT_MSGTIME_BEGIN 0x01C2B128BA2B4000 // 1/1/2003 - used for conversion between FILETIME and MSGTIME
#define FileTimeToMsgTime( pFileTime ) (MSGTIME)( ( *((ULONGLONG*)(pFileTime)) - FT_MSGTIME_BEGIN ) / 10000000 )
#define MsgTimeToFileTimeQW( msgTime ) ((ULONGLONG)(msgTime) * 10000000 + FT_MSGTIME_BEGIN)

// Team constants
#define MAX_TEAMS                   XONLINE_MAX_TEAM_COUNT
#define MAX_TEAM_NAME_CHAR          XONLINE_MAX_TEAM_NAME_SIZE
#define MAX_TEAM_NAME_BYTES         (XONLINE_MAX_TEAM_NAME_SIZE * sizeof(WCHAR))
#define MAX_TEAM_DESCRIPTION_CHAR   XONLINE_MAX_TEAM_DESCRIPTION_SIZE
#define MAX_TEAM_DESCRIPTION_BYTES  (MAX_TEAM_DESCRIPTION_CHAR * sizeof(WCHAR))
#define MAX_TEAM_MOTTO_CHAR         XONLINE_MAX_TEAM_MOTTO_SIZE
#define MAX_TEAM_MOTTO_BYTES        (MAX_TEAM_MOTTO_CHAR * sizeof(WCHAR))
#define MAX_TEAM_URL_CHAR           XONLINE_MAX_TEAM_URL_SIZE
#define MAX_TEAM_URL_BYTES          (MAX_TEAM_URL_CHAR * sizeof(WCHAR))
#define MAX_TEAM_DATA_BYTES         XONLINE_MAX_TEAM_DATA_SIZE
#define MAX_TEAM_MEMBER_DATA_BYTES  XONLINE_MAX_TEAM_MEMBER_DATA_SIZE



enum P_MSG_TYPES
{
    // Incoming messages
    PMSG_MIN_REQ_TYPE                   = 1000,
    PMSG_HELLO                          = 1000,
    PMSG_ALIVE                          = 1001,
    PMSG_SYNC                           = 1002,
    PMSG_REFRESH                        = 1003,
    PMSG_ADD                            = 1004,
    PMSG_DELETE                         = 1005,
    PMSG_ACCEPT                         = 1006,
    PMSG_REJECT                         = 1007,
    PMSG_BLOCK                          = 1008,
    PMSG_UNBLOCK                        = 1009,
    PMSG_INVITE                         = 1010,
    PMSG_CANCEL                         = 1011,
    PMSG_INVITE_ANSWER                  = 1012,
    PMSG_NICKNAME                       = 1013,
    PMSG_STATE                          = 1014,
    PMSG_DEAD_XBOX                      = 1015,
    PMSG_DEAD_SG                        = 1016,
    PMSG_ANNOUNCE                       = 1017,
    PMSG_SUBSCRIBED                     = 1018,
    PMSG_UNSUBSCRIBE                    = 1019,
    PMSG_ADDED                          = 1020,
    PMSG_ACCEPTED                       = 1021,
    PMSG_REMOVED                        = 1022,
    PMSG_KICK                           = 1023,
    PMSG_DEAD_USER                      = 1024,
    PMSG_ALIVE_2                        = 1025,
    PMSG_WEB_FRIENDS                    = 1026,
    PMSG_WEB_ALIVE                      = 1027,
    PMSG_WEB_ANNOUNCE                   = 1028,
    PMSG_WEB_SUBSCRIBED                 = 1029,
    PMSG_WEB_UNSUBSCRIBE                = 1030,
    PMSG_PEER_SESSION                   = 1031,
    PMSG_TEAM_LIST_TEAMS                = 1032,
    PMSG_TEAM_LIST_MEMBERS              = 1033,
    PMSG_TEAM_CREATE                    = 1034,
    PMSG_TEAM_DELETE                    = 1035,
    PMSG_TEAM_REMOVE                    = 1036,
    PMSG_TEAM_MANAGE_TEAM               = 1037,
    PMSG_TEAM_MANAGE_MEMBER             = 1038,
    PMSG_TEAM_RECRUIT                   = 1039,
    PMSG_TEAM_JOIN                      = 1040,
    PMSG_TEAM_GET_TICKET                = 1041,
    PMSG_PEER_SUBSCRIBE                 = 1042,
    PMSG_PEER_UNSUBSCRIBE               = 1043,
    PMSG_WATCH_START                    = 1044,
    PMSG_WATCH_STOP                     = 1045,
    PMSG_ADD_2                          = 1046,
    PMSG_INVITE_2                       = 1047,
    PMSG_ALIVE_INTERNAL                 = 1048,
    PMSG_STATE_2                        = 1049,
    PMSG_GET_STATE                      = 1050,
    PMSG_TEAM_CREATE_XE                 = 1051,
    PMSG_TEAM_MANAGE_TEAM_XE            = 1052,
    PMSG_ADD_AFFILIATES                 = 1053,
    PMSG_IS_AFFILIATE                   = 1054,
    PMSG_QUERY_AFFILIATES               = 1055,
    PMSG_GET_PRESENCE_INFO              = 1056,
    PMSG_PRESENCE_INFO_REPLY            = 1057,
    PMSG_INVALIDATE_USER                = 1058,
    PMSG_FIND_USER                      = 1059,
    PMSG_CHECK_TITLE_MESSAGES           = 1060,
    PMSG_TEAM_LIST_USER_TEAMS           = 1061,
    PMSG_USER_PRE_MIGRATION             = 1062,
    PMSG_USER_FULL_MIGRATION            = 1063,
    PMSG_LOGON_CHECK                    = 1064,
    PMSG_FIND_USERS                     = 1065,
    PMSG_ALIVE_INTERNAL_2               = 1066,
    PMSG_PEER_SUBSCRIBE_EX              = 1067,
    PMSG_PURGE_USER                     = 1068,
    PMSG_GET_FRIENDS_LIST               = 1069,
    PMSG_CONTINUATION                   = 1070,
    PMSG_CONNECTION_HEALTH              = 1071,
    PMSG_MAX_REQ_TYPE                   = 1071,

    // Outgoing messages
    PMSG_MIN_REPLY_TYPE                 = 1101,
    PMSG_ALIVE_REPLY                    = 1101,
    PMSG_SYNC_REPLY                     = 1102,
    PMSG_WEB_FRIENDS_REPLY              = 1103,
    PMSG_WEB_ALIVE_REPLY                = 1104,
    PMSG_PEER_SESSION_REPLY             = 1105,
    PMSG_INVITE_REPLY                   = 1106,
    PMSG_TEAM_LIST_TEAMS_REPLY          = 1107,
    PMSG_TEAM_LIST_MEMBERS_REPLY        = 1108,
    PMSG_TEAM_CREATE_REPLY              = 1109,
    PMSG_TEAM_DELETE_REPLY              = 1110,
    PMSG_TEAM_REMOVE_REPLY              = 1111,
    PMSG_TEAM_MANAGE_TEAM_REPLY         = 1112,
    PMSG_TEAM_MANAGE_MEMBER_REPLY       = 1113,
    PMSG_TEAM_RECRUIT_REPLY             = 1114,
    PMSG_TEAM_JOIN_REPLY                = 1115,
    PMSG_TEAM_GET_TICKET_REPLY          = 1116,
    PMSG_PEER_SUBSCRIBE_REPLY           = 1117,
    PMSG_PEER_UNSUBSCRIBE_REPLY         = 1118,
    PMSG_GET_STATE_REPLY                = 1119,
    PMSG_IS_AFFILIATE_REPLY             = 1120,
    PMSG_QUERY_AFFILIATES_REPLY         = 1121,
    PMSG_FIND_USER_REPLY                = 1122,
    PMSG_CHECK_TITLE_MESSAGES_REPLY     = 1123,
    PMSG_TEAM_LIST_USER_TEAMS_REPLY     = 1124,
    PMSG_LOGON_CHECK_REPLY              = 1125,
    PMSG_FIND_USERS_REPLY               = 1126,
    PMSG_PEER_SUBSCRIBE_EX_REPLY        = 1127,
    PMSG_PURGE_USER_REPLY               = 1128,
    PMSG_GET_FRIENDS_LIST_REPLY         = 1129,
    PMSG_CONNECTION_HEALTH_REPLY        = 1130,
    PMSG_MAX_REPLY_TYPE                 = 1130
};

#define P_STATE_MASK_NONE           0x0000
#define P_STATE_MASK_ONLINE         0x0001 // Set if online
#define P_STATE_MASK_PLAYING        0x0002 // Set if playing a game
#define P_STATE_MASK_CLOAKED        0x0004 // Set to fake being offline
#define P_STATE_MASK_VOICE          0x0008 // Set if supports voice
#define P_STATE_MASK_JOINABLE       0x0010 // Set if session is joinable
#define P_STATE_MASK_GUESTS         0x0060
#define P_STATE_MASK_RESERVED0      0x0080
#define P_STATE_MASK_JOINABLE_FRIENDS_ONLY 0x00000100
#define P_STATE_MASK_PARTY_JOINABLE 0x00000200
#define P_STATE_MASK_PARTY_JOINABLE_FRIENDS_ONLY 0x00000400
#define P_STATE_MASK_PARTY_PLAYING               0x00000800

#define P_STATE_MASK_CONSOLE_TYPE   0x00007000
#define P_STATE_ENUM_CONSOLE_XBOX   0x00000000
#define P_STATE_ENUM_CONSOLE_XENON  0x00001000
#define P_STATE_ENUM_CONSOLE_WINPC  0x00002000
#define P_STATE_ENUM_CONSOLE_RSVD1  0x00003000
#define P_STATE_ENUM_CONSOLE_RSVD2  0x00004000
#define P_STATE_ENUM_CONSOLE_RSVD3  0x00005000
#define P_STATE_ENUM_CONSOLE_RSVD4  0x00006000
#define P_STATE_ENUM_CONSOLE_RSVD5  0x00007000

#define P_STATE_ENUM_ONLINE         0x00000000
#define P_STATE_ENUM_AWAY           0x00010000
#define P_STATE_ENUM_BUSY           0x00020000
#define P_STATE_ENUM_WEB            0x00030000
#define P_STATE_MASK_USER_STATE     0x000F0000

#define P_STATE_MASK_PARTY_COUNTER  0x00300000

// reuse of client flags for server-specific flags
#define P_STATE_MASK_CLIENTFLAGS 0xFC000000
#define P_STATE_MASK_TITLEID_CHANGED 0x80000000
#define P_STATE_MASK_TITLEDATA_CHANGED 0x40000000
#define P_STATE_MASK_SESSIONID_CHANGED 0x20000000
#define P_STATE_MASK_RICHPRES_CHANGED 0x10000000

// notification filters
#define P_STATE_MASK_NOTIFY_XBOX (~P_STATE_MASK_RICHPRES_CHANGED)
#define P_STATE_MASK_NOTIFY_XENON_PEER (~P_STATE_MASK_TITLEDATA_CHANGED)
// #define P_STATE_MASK_NOTIFY_XENON_FRIEND (this is now variable, via config setting)

#define P_STATE_MASK_SENTREQUEST     0x40000000
#define P_STATE_MASK_RECEIVEDREQUEST 0x80000000

#define P_BUDDY_STATUS_OK      0 // Mutualy accepted buddy
#define P_BUDDY_STATUS_PENDING 1 // Buddy request pending accetance
#define P_BUDDY_STATUS_REQUEST 2 // Buddy request to accept or reject

// affiliates
// actual affiliate lists
#define X_AFFILIATE_ENCOUNTERED_INDEX 0
#define X_AFFILIATE_COMPLETED_GAME_INDEX 1
#define X_AFFILIATE_POSITIVE_FEEDBACK_INDEX 2
#define X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX 3
#define X_AFFILIATE_AVOIDING_ME_INDEX 4
#define X_AFFILIATE_FAVORITES_INDEX 5

#define NUM_STORED_AFFILIATE_LISTS 6

// emulated lists
#define X_AFFILIATE_FRIEND_INDEX 16
#define X_AFFILIATE_BLOCK_INDEX 17
#define X_AFFILIATE_MUTE_INDEX 18

#define X_AFFILIATE_INDEX_ERROR 0xFFFFFFFF

#define X_AFFILIATE_FLAGS_IN_USE 0x0007003F

#define X_ADD_AFFILIATE_MAX 16

#define X_AFFILIATE_INDEX_TO_FLAG(dwIndex) (1 << dwIndex)
#define X_AFFILIATE_FLAG_TO_INDEX(dwFlag) (\
    ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_ENCOUNTERED_INDEX)) ? X_AFFILIATE_ENCOUNTERED_INDEX : \
    ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_COMPLETED_GAME_INDEX)) ? X_AFFILIATE_COMPLETED_GAME_INDEX : \
    ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_POSITIVE_FEEDBACK_INDEX)) ? X_AFFILIATE_POSITIVE_FEEDBACK_INDEX : \
    ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX)) ? X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX : \
    ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_AVOIDING_ME_INDEX)) ? X_AFFILIATE_AVOIDING_ME_INDEX : \
    ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_FAVORITES_INDEX)) ? X_AFFILIATE_FAVORITES_INDEX : \
    ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_FRIEND_INDEX)) ? X_AFFILIATE_FRIEND_INDEX : \
    ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_BLOCK_INDEX)) ? X_AFFILIATE_BLOCK_INDEX : \
    ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_MUTE_INDEX)) ? X_AFFILIATE_MUTE_INDEX : X_AFFILIATE_INDEX_ERROR)

#define X_PEER_SUBSCRIBE_EX_USER_FLAGS_MASK       0xFF00000000000000
#define X_PEER_SUBSCRIBE_EX_USER_FLAGS_ADD        0x0100000000000000
#define X_PEER_SUBSCRIBE_EX_USER_FLAGS_REMOVE     0x0200000000000000
#define X_PEER_SUBSCRIBE_EX_FLAGS_USE_DIFFS       0x1

// Used by all Presence and Notification protocols that accept an answer member
enum P_INVITE_REPLIES
{
    PINVITE_REPLY_NO    = 0,
    PINVITE_REPLY_YES   = 1,
    PINVITE_REPLY_NEVER = 2,
};

enum P_QUEUE_TYPES
{
    //
    // Outgoing queued response items
    //
    PQUEUE_BUDDY_REQ     = 0,
    PQUEUE_LIST_CHANGE   = 1,
    PQUEUE_PRESENCE      = 2,
    PQUEUE_INVITE        = 3,
    PQUEUE_INVITE_ANSWER = 4,
    PQUEUE_TRANSIENT_MSGS= 5,
    PQUEUE_PEER_PRESENCE = 6,
    PQUEUE_PRESENCE_2    = 7,

    PQUEUE_NUM_TYPES     = 8
};

#define QFLAG_MASK(QType)   ( 1 << (QType))

enum P_LIST_OPERATIONS
{
    PLIST_BUDDY_NOP     = 0,
    PLIST_BUDDY_ADD     = 1,
    PLIST_BUDDY_ADDED   = 2,
    PLIST_BUDDY_ACCEPT  = 3,
    PLIST_BUDDY_REJECT  = 4,
    PLIST_BUDDY_DELETE  = 5
};

#define IGNOREME_SESSID     0
#define MSGTYPE_ACK         0xffffffff

//
// Current version is v1.00
//
#define CURRENT_XQPROTOCOL_VER 0x00010000

//
// Various protocol related constants
//
#define MIN_QMSG_SIZE               4
#define MAX_QMSG_SIZE               0x10000 //~64k
#define MAX_HELLO_DESCRIPTION_LEN   80

enum Q_MSG_TYPES
{
    //
    // Incoming messages
    //
    QMSG_MIN_REQ_TYPE                   =  0,
    QMSG_HELLO                          =  0,
    QMSG_USER_INFO                      =  1,
    QMSG_ADD                            =  2,
    QMSG_DELETE                         =  3,
    QMSG_DELETE_MATCHES                 =  4,
    QMSG_DEAD_XBOX                      =  5,
    QMSG_DEAD_SG                        =  6,
    QMSG_LIST                           =  7,
    QMSG_DEQUEUE                        =  8,
    QMSG_DEAD_USER                      =  9,
    QMSG_WEB_USER_INFO                  = 10,
    QMSG_WEB_PRESENCE                   = 11,
    QMSG_WEB_LIST                       = 12,
    QMSG_ENUM_MESSAGES                  = 13,
    QMSG_MESSAGE_SUMMARY                = 14,
    QMSG_MESSAGE_DETAILS                = 15,
    QMSG_DELETE_MESSAGE                 = 16,
    QMSG_SEND_MESSAGE                   = 17,
    QMSG_REVOKE_MESSAGE                 = 18,
    QMSG_DELETE_TITLE                   = 19,
    QMSG_ENUM_TITLES                    = 20,
    QMSG_MESSAGE_FLAGS                  = 21,
    QMSG_ENUM_SYSTEM_MESSAGES           = 22,
    QMSG_SYSTEM_MESSAGE_DETAILS         = 23,
    QMSG_DELETE_SYSTEM_MESSAGE          = 24,
    QMSG_SEND_SYSTEM_MESSAGE            = 25,
    QMSG_REVOKE_MESSAGE_EX              = 26,
    QMSG_ENUM_MESSAGES_2                = 27,
    QMSG_MESSAGE_SUMMARY_2              = 28,
    QMSG_MAX_REQ_TYPE                   = 28,

    //
    // Outgoing messages
    //
    QMSG_MIN_REPLY_TYPE                 = 100,
    QMSG_LIST_REPLY                     = 100,
    QMSG_WEB_LIST_REPLY                 = 101,
    QMSG_ENUM_MESSAGES_REPLY            = 102,
    QMSG_MESSAGE_SUMMARY_REPLY          = 103,
    QMSG_MESSAGE_DETAILS_REPLY          = 104,
    QMSG_DELETE_MESSAGE_REPLY           = 105,
    QMSG_SEND_MESSAGE_REPLY             = 106,
    QMSG_REVOKE_MESSAGE_REPLY           = 107,
    QMSG_DELETE_TITLE_REPLY             = 108,
    QMSG_ENUM_TITLES_REPLY              = 109,
    QMSG_MESSAGE_FLAGS_REPLY            = 110,
    QMSG_ENUM_SYSTEM_MESSAGES_REPLY = 111,
    QMSG_SYSTEM_MESSAGE_DETAILS_REPLY = 112,
    QMSG_DELETE_SYSTEM_MESSAGE_REPLY = 113,
    QMSG_SEND_SYSTEM_MESSAGE_REPLY      = 114,
    QMSG_ENUM_MESSAGES_2_REPLY          = 115,
    QMSG_MESSAGE_SUMMARY_2_REPLY        = 116,
    QMSG_LIST_REPLY_2                   = 117,
    QMSG_MAX_REPLY_TYPE                 = 117
};
//----------------------------------------------------------------------------+
//  Structures
//

#ifdef __cplusplus

#pragma pack(push, 1)

// connection/notificaiton server data protocol

namespace XONLINE_SUBNOTI
{
    // Schema identifier for data objects.
    enum DATA_TYPES
    {
        eMinType = 1000,

        eFriendsList = 1000,
        eBasicPresence = 1001,
        eExtendedPresence = 1002,
        eRichPresenceString = 1003,
        eBasicProfile = 1004,
        eExtendedProfile = 1005,
        eAvatar = 1006,
        ePartyInfo = 1007,

        eMaxType = 1007
    };

    // substructure used to identify data objects for subscription, query, etc.
    struct DATA_OBJECT_SPECIFIER
    {
        // Schema version identifier.
        WORD wObjectSize;

        // schema identifier.  see DATA_TYPES.
        WORD wDataType;

        // optional subtype for data.  e.g. TitleID for data specific to a title.  Zero if unused.
        DWORD dwDataSubType;

        // User who owns the data
        ULONGLONG qwOwnerXUID;
    };

    // header for all data types in the subscription/notification system.
    struct BASE_DATA_HEADER
    {
        // object specifier info.
        DATA_OBJECT_SPECIFIER doSpec;

        // Extra flags for this piece of data.
        DWORD dwHeaderFlags;
    };

// data header flags.
#define XONLINE_CONNSRV_DATA_FLAG_SHARE_EVERYONE 0x1
#define XONLINE_CONNSRV_DATA_FLAG_SHARE_FRIENDS 0x2
#define XONLINE_CONNSRV_DATA_FLAG_LANGUAGE_SPECIFIC 0x4

    // Schema definition for DATA_TYPES.eFriendsList, etc.
    struct USER_LIST_DATA :
        public BASE_DATA_HEADER
    {
        // list version.
        DWORD dwListVersion;

        // Count of users.
        DWORD dwNumUsers;

        // the list of users.
        // USER_DATA rgUsers[dwNumUsers];
    };

    // substructure for USER_LIST_DATA representing a single User.
    struct USER_DATA
    {
        // The XUID of the user.
        ULONGLONG qwXUID;

        // Extra flags for this user.
        DWORD dwUserFlags;
    };

// user list data flags
#define XONLINE_CONNSRV_USER_LIST_MASK_FRIEND_STATUS 0x3
#define XONLINE_CONNSRV_USER_LIST_SHIFT_FRIEND_STATUS 0

    // Schema definition for DATA_TYPES.eBasicPresence
    struct BASIC_PRESENCE_DATA :
        public BASE_DATA_HEADER
    {
        // The gamertag of the user.
        char szGamertag[XONLINE_GAMERTAG_SIZE];

        // The title the user is playing.
        DWORD dwTitleID;

        // Last seen time for this user.
        DWORD mtLastSeen;

        // SessionID for the user.
        ULONGLONG qwSessionID;

        // Basic presence state.
        DWORD dwState;
    };
}

//
// This is the basic message framing structure from which the queue and presence
// server protocols are derived.
//
// dwMsgType is an enumerated value unique across protocols
// dwMsgLen is the amount of message data that follows this header
// dwSeqNum is a client-assigned sequence number used to resolve async races
// dwSessID is a connection server assigned session ID used to resolve async races
//
struct BASE_MSG_HEADER
{
    DWORD dwMsgType;
    DWORD dwMsgLen;
    DWORD dwSeqNum;
    SGADDR sgaddr;

    // BYTE rgbMsgData[ dwMsgLen ];
};

//
// This is the basic acknowledgement message used in all derived protocols to
// signal reception of certain messages and indicate their resulting status.
//
struct BASE_ACK_MSG : public BASE_MSG_HEADER
{
    DWORD dwAckMsgType;     // dwMsgType of message being acknowledged
    DWORD dwAckSeqNum;      // dwSeqNum of message being acknowledged
    ULONGLONG qwAckUserID;
    HRESULT hrAck;
};

//
// Web Friends basic structure
//
struct PQ_WEB_FRIEND
{
    ULONGLONG qwUserID;
    DWORD dwState;
    DWORD dwTitleID;
    WORD cbTitleStuff;
    // byte rgbTitleStuff[];            // Binary
};

//
// This must be the first message sent to the server after establishing
// a TCP connection
//
struct Q_HELLO_MSG : public BASE_MSG_HEADER
{
    DWORD dwProtocolVersion;    // Hi word | lo word

    // char szDescription[];    // NULL-terminated ASCII string
};

//
// Before sending any messages pertaining to a user, this message must be
// sent to the server to establish the user's queues.
//
struct Q_USER_INFO_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwTitleID;
    DWORD dwAltTitleID1;
    DWORD dwAltTitleID2;
    DWORD dwAltTitleID3;
    DWORD dwAltTitleID4;
    WORD wBlockCount;
    // ULONGLONG qwBlockedUsers[ wBlockCount ];
};

//
// Add a new item asynchronously to one or more users' Qs, given the item type
//
struct Q_ADD_MSG : public BASE_MSG_HEADER
{
    WORD wQType;
    WORD wUserCount;

    // ULONGLONG qwUserIDs[ dwUserCount ];
    // BYTE rgbData[];
};

//
// Delete an item or range of items of the given item type from a user's Q
//
struct Q_DELETE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    WORD wQType;
    DWORD dwFirstItemID;
    DWORD dwLastItemID;      // Set == dwFirstItemID to delete one item
};

//
// Delete any matching items of the given item type from one or more users' Qs
//
struct Q_DELETE_MATCHES_MSG : public BASE_MSG_HEADER
{
    WORD wQType;
    WORD wMatchAttrNum;   // must be zero for now
    WORD wUserCount;

    // ULONGLONG qwUserIDs[ dwUserCount ];
    // BYTE rgbMatchData[ MatchAttrLen ];
};

//
// Inform the Q server that the given user just went offline.
//
struct Q_DEAD_USER_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

//
// Inform the Q server that the given XBox just went offline, so any
// items pertaining to this address that are no longer relevant should be
// deleted.
//
struct Q_DEAD_XBOX_MSG : public BASE_MSG_HEADER
{
};

//
// Inform the Q server that the given SG just went offline, so any users
// who were on this SG should be considered offline also.  This will end
// up emptying many Q's, as well as potentially deleting many individual items.
//
struct Q_DEAD_SG_MSG : public BASE_MSG_HEADER
{
};

//
// Ask the Q server to send a Q_LIST_REPLY_MSG containing up to the number of
// items given of a particular type for a certain user.
//
struct Q_LIST_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    WORD  wQType;
    DWORD dwStartItemID;
    WORD  wMaxItems;
    DWORD dwMaxTotalItemDataSize;
};

//
// Ask the Q server to send a Q_LIST_REPLY_MSG containing up to the number of
// items given of a particular type for a certain user.  The items returned
// are removed from the queue.
//
struct Q_DEQUEUE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    WORD  wQType;
    DWORD dwStartItemID;
    WORD  wMaxItems;
    DWORD dwMaxTotalItemDataSize;
};

//
// Register a Web user with the Q Server
//
struct Q_WEB_USER_INFO_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    // ULONGLONG rgqwFriendIDs[];
};

//
// Send the Q server updated presence information for a Web user
//
struct Q_WEB_PRESENCE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwFriendID;
    DWORD dwFriendState;
    DWORD dwFriendTitleID;
    WORD cbTitleStuff;
    // byte rgbTitleStuff[];            // Binary
};

//
// Ask the Q server to send a Q_WEB_LIST_REPLY_MSG containing the presence information
// for all online friends.
//
struct Q_WEB_LIST_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

//
// The asynchronous reply to a Q_LIST_MSG or Q_DEQUEUE_MSG
//
struct Q_LIST_REPLY_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    WORD  wQType;
    HRESULT hr;
    DWORD dwNextItemID;
    WORD  wQLeft;
    WORD  wNumItems;
    DWORD dwTotalItemDataSize;
    DWORD cdwQVals;

    // CQVal rgdwQVals[ cdwQVals ];
    // Q_LIST_ITEM rgItems[ wNumItems ];
};

//
// The asynchronous reply to a Q_LIST_MSG or Q_DEQUEUE_MSG
//
struct Q_LIST_REPLY_2_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    WORD  wQType;
    HRESULT hr;
    DWORD dwNextItemID;
    WORD  wQLeft;
    WORD  wNumItems;
    DWORD dwTotalItemDataSize;
    DWORD cdwQVals;
    BYTE szLocale[XONLINE_PRESENCE_LOCALE_SIZE];

    // CQVal rgdwQVals[ cdwQVals ];
    // Q_LIST_ITEM rgItems[ wNumItems ];
};

struct Q_LIST_ITEM
{
    DWORD dwItemID;
    WORD wItemLen;

    // BYTE rgbItemData[dwItemLen];
};

//
// The asynchronous reply to a Q_WEB_LIST
//
struct Q_WEB_LIST_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    WORD  wNumItems;

    // PQ_WEB_FRIEND rgFriends[ wNumItems ];
};

// Protocol structures for Messaging
struct Q_ENUM_MESSAGES_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID; // XPNFD requires that UserID be the first member
};

struct Q_MESSAGE_SUMMARY
{
    ULONGLONG qwSenderID;
    ULONGLONG qwSenderContext;
    MSGTIME mtSentTime;
    DWORD dwMessageID;
    DWORD dwMessageFlags;
    DWORD dwSenderTitleID;
    WORD wExpireMinutes; // An offset in minutes from the sent time
    WORD cbDetails;
    BYTE bMessageType;
    char szSenderName[XONLINE_GAMERTAG_SIZE-1];
};

struct Q_ENUM_MESSAGES_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    WORD cMessages;
    // Q_MESSAGE_SUMMARY rgMessages[];
};

struct Q_MESSAGE_SUMMARY_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID; // XPNFD requires that UserID be the first member
    DWORD dwMessageID;
};

struct Q_MESSAGE_SUMMARY_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    Q_MESSAGE_SUMMARY summary;
};

struct Q_ENUM_MESSAGES_2_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID; // XPNFD requires that UserID be the first member
};

struct Q_MESSAGE_SUMMARY_2
{
    ULONGLONG qwSenderID;
    ULONGLONG qwSenderContext;
    MSGTIME mtSentTime;
    DWORD dwMessageID;
    DWORD dwMessageFlags;
    DWORD dwSenderTitleID;
    WORD wExpireMinutes; // An offset in minutes from the sent time
    WORD cbDetails;
    BYTE bMessageType;
    CHAR szSenderName[XONLINE_GAMERTAG_SIZE-1];
    WCHAR szSubject[XONLINE_MAX_SUBJECT_SIZE]; // Subject line - unicode
};

struct Q_ENUM_MESSAGES_2_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    WORD cMessages;
    // Q_MESSAGE_SUMMARY_2 rgMessages[];
};

struct Q_MESSAGE_SUMMARY_2_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID; // XPNFD requires that UserID be the first member
    DWORD dwMessageID;
};

struct Q_MESSAGE_SUMMARY_2_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    Q_MESSAGE_SUMMARY_2 summary;
};

struct Q_MESSAGE_DETAILS_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID; // XPNFD requires that UserID be the first member
    DWORD dwMessageID;
    DWORD dwSetFlags;
    DWORD dwUnsetFlags;
};

struct Q_MESSAGE_DETAILS_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    Q_MESSAGE_SUMMARY summary;
    // BYTE pbDetails[];
};

#define XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER 0x00000001

struct Q_DELETE_MESSAGE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID; // XPNFD requires that UserID be the first member
    DWORD dwMessageID;
    DWORD dwFlags;
};

struct Q_DELETE_MESSAGE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
};

struct Q_SEND_MESSAGE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwSenderID; // XPNFD requires that UserID be the first member
    ULONGLONG qwSenderContext;
    DWORD dwMessageFlags;
    DWORD dwSenderTitleID;
    WORD wExpireMinutes;
    WORD cbDetails;
    WORD cRecipients;
    BYTE bMessageType;
    char szSenderName[XONLINE_GAMERTAG_SIZE-1];

    // ULONGLONG qwRecipientIDs[];
    // BYTE pbDetails[];
};

//
// Invite Messages between Presence & Notification clusters include the following information
//  tacked on to the end of a Q_SEND_MESSAGE_MSG, one per recipient.
//
struct Q_SEND_MESSAGE_ADDENDUM
{
    BYTE        fFriend;
    ULONGLONG   qwWebID;
};

struct Q_RECIPIENT_RESULT
{
    ULONGLONG qwUserID;
    union // If the send failed, this is the error code, if it succeeded this is the message ID
    {
        DWORD dwMessageID;
        HRESULT hrRecipient;
    };
};

struct Q_SEND_MESSAGE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    WORD cRecipients;
    // Q_RECIPIENT_RESULT recipients[];
};

struct Q_SEND_MESSAGE_INTERNAL_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    DWORD dwContext;
    WORD cRecipients;
    // Q_RECIPIENT_RESULT recipients[];
};

// This has been superseded by Q_REVOKE_MESSAGE_EX_MSG, but must be kept for
// compatibility with the December 2003 XDK.
struct Q_REVOKE_MESSAGE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwSenderID; // XPNFD requires that UserID be the first member
    ULONGLONG qwSenderContext; // Never used, must be zero
    WORD cRecipients;
    BYTE bMessageType; // Never used, must be zero
    // Q_RECIPIENT_RESULT recipients[];
};

#define XMSG_REVOKE_MESSAGE_EX_FLAG_BLOCK_SENDER 0x00000001
#define XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID       0x00000002
#define XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER   0x00000004
#define XMSG_REVOKE_MESSAGE_EX_FLAG_USE_CONTEXT  0x00000008
#define XMSG_REVOKE_MESSAGE_EX_FLAG_USE_PROP     0x00000010
#define XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE     0x00000020
#define XMSG_REVOKE_MESSAGE_EX_FLAGS_RESERVED    0xFFFFFFC0

struct Q_REVOKE_MESSAGE_EX_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwSenderID; // XPNFD requires that UserID be the first member
    ULONGLONG qwSenderContext;
    DWORD dwFlags;
    WORD wPropTag;
    WORD cRecipients;
    WORD cbProp;
    BYTE bMessageType;
    // Q_RECIPIENT_RESULT rgRecipients[ cRecipients ];
    // BYTE rgbProp[ cbProp ];
};

// Common reply structure shared by Revoke and RevokeEx
struct Q_REVOKE_MESSAGE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
};

struct Q_DELETE_TITLE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID; // XPNFD requires that UserID be the first member
    DWORD dwTitleID;
};

struct Q_DELETE_TITLE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
};

struct Q_ENUM_TITLES_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID; // XPNFD requires that UserID be the first member
};

#define USER_TITLE_FLAG_ACCEPT_MARKETING 0x00000001 // The user has opted in to marketing for this title

struct Q_USER_TITLE
{
    DWORD dwTitleID;
    FILETIME ftLastLogon;
    DWORD dwFlags;
};

struct Q_ENUM_TITLES_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    WORD cTitles;
    // Q_USER_TITLE rgTitles[cTitles];
};

struct Q_MESSAGE_FLAGS_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID; // XPNFD requires that UserID be the first member
    DWORD dwMessageID;
    DWORD dwSetFlags;
    DWORD dwUnsetFlags;
};

struct Q_MESSAGE_FLAGS_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
};

//
// System message support (includes system, title, region messages)
//

struct Q_ENUM_SYSTEM_MESSAGES_MSG : public BASE_MSG_HEADER
{
    DWORD dwTitleID; // XPNFD requires that TitleID be the first member for system messages
};

#define XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN 64

struct Q_SYSTEM_MESSAGE_SUMMARY
{
    DWORD dwTitleID; // XPNFD requires that TitleID be the first member for system messages

    ULONGLONG qwSenderContext;
    FILETIME ftSentTime;
    DWORD dwRegion;
    DWORD dwMessageID;
    DWORD dwMessageFlags;
    WORD wExpireMinutes; // An offset in minutes from the sent time
    WORD cbDetails;
    BYTE bMessageType;
    char szSenderName[XONLINE_GAMERTAG_SIZE-1];
    char szDescription[XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN];
};

struct Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    WORD cMessages;
    // Q_SYSTEM_MESSAGE_SUMMARY rgMessages[cMessages];
};

struct Q_SYSTEM_MESSAGE_DETAILS_MSG : public BASE_MSG_HEADER
{
    DWORD dwTitleID; // XPNFD requires that TitleID be the first member for system messages
    DWORD dwMessageID;
};

struct Q_SYSTEM_MESSAGE_DETAILS_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    Q_SYSTEM_MESSAGE_SUMMARY summary;
    // BYTE pbDetails[summary.cbDetails];
};

#define XMSG_DELETE_SYSTEM_MESSAGE_FLAG_REVOKE_ALL  0x00000001

struct Q_DELETE_SYSTEM_MESSAGE_MSG : public BASE_MSG_HEADER
{
    DWORD dwTitleID; // XPNFD requires that TitleID be the first member for system messages
    DWORD dwMessageID;
    DWORD dwFlags;
};

struct Q_DELETE_SYSTEM_MESSAGE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
};

struct Q_SEND_SYSTEM_MESSAGE_MSG : public BASE_MSG_HEADER
{
    DWORD dwTitleID; // XPNFD requires that TitleID be the first member for system messages
    ULONGLONG qwSenderContext;
    FILETIME ftSentTime;
    DWORD dwRegion;
    DWORD dwMessageFlags;
    WORD wExpireMinutes;
    WORD cbDetails;
    BYTE bMessageType;
    char szSenderName[XONLINE_GAMERTAG_SIZE-1];
    char szDescription[XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN];
    // BYTE pbDetails[cbDetails];
};

struct Q_SEND_SYSTEM_MESSAGE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    DWORD dwMessageID;
};


// End messaging structures

//
// This must be the first message sent to the server after establishing
// a TCP connection
//
struct P_HELLO_MSG : public BASE_MSG_HEADER
{
    DWORD dwProtocolVersion;    // Hi word | lo word
    // char szDescription[];    // NULL-terminated ASCII string
};

//
// This checks to see if the user is already logged on in a different location.
//
struct P_LOGON_CHECK_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

//
// this is the reply type for P_LOGON_CHECK_MSG.
//
struct P_LOGON_CHECK_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
};

//
// This establishes the user's presence in the system
//
struct P_ALIVE_MSG : public BASE_MSG_HEADER
{
    // User Info
    ULONGLONG qwUserID;
    DWORD dwTitleID;
    WORD  cbAcctName;
    // Sync info
    DWORD dwBuddyListVersion;
    DWORD dwBlockListVersion;
    // State into
    DWORD dwState;
    ULONGLONG qwMatchSessionID;
    WORD  cbNickname;
    WORD  cbTitleStuff;
    // char szAcctName[];               // ASCII Null terminated
    // byte rgbTitleStuff[];            // Binary
    // byte rgbNickName[];              // Binary
};

struct P_ALIVE_2_MSG : public BASE_MSG_HEADER
{
    // User Info
    ULONGLONG            qwUserID;                  // User Id
    WORD                 cbAcctName;                // Size of szAcctName

    // Peer Session
    XNADDR xnaddr;
    XNKID xnkid;
    XNKEY xnkey;

    // Sync info
    DWORD                dwBuddyListVersion;        // Client Friend list version
    DWORD                dwBlockListVersion;        // Client Mute list version

    // Auth info
    XBOX_LIBRARY_VERSION clientVersion;             // Client library version
    DWORD                dwTitleID;                 // Title Id
    DWORD                dwTitleVersion;            // Title version
    DWORD                dwTitleRegion;             // Title region
    WORD                 ipportI;                   // IP port of the client on the Internet
    IN_ADDR              ipaI;                      // IP address of the client on the Internet
    LARGE_INTEGER        liNonce;                   // A random nonce associated with this session
    LARGE_INTEGER        liTimeInit;                // FILETIME marking session initiation with SG

    // char szAcctName[];               // ASCII Null terminated
};

struct P_ALIVE_INTERNAL_MSG : public BASE_MSG_HEADER
{
    // User Info
    ULONGLONG             qwUserID;                  // User Id
    WORD                  cbAcctName;                // Size of szAcctName

    // Peer Session
    XNADDR xnaddr;
    XNKID xnkid;
    XNKEY xnkey;

    // Sync info
    DWORD                 dwBuddyListVersion;       // Client Friend list version
    DWORD                 dwBlockListVersion;       // Client Mute list version

    // Auth info
    XBOX_LIBRARY_VERSION  clientVersion;            // Client library version
    DWORD                 dwAuthDataFlags;          // Auth Flags
    DWORD                 dwTitleID;                // Title Id
    DWORD                 dwAltTitleID1;            // Alt Title Id1
    DWORD                 dwAltTitleID2;            // Alt Title Id2
    DWORD                 dwAltTitleID3;            // Alt Title Id3
    DWORD                 dwAltTitleID4;            // Alt Title Id4
    DWORD                 dwTitleVersion;           // Title version
    DWORD                 dwTitleRegion;            // Title region
    WORD                  ipportI;                  // IP port of the client on the Internet
    IN_ADDR               ipaI;                     // IP address of the client on the Internet
    LARGE_INTEGER         liNonce;                  // A random nonce associated with this session
    LARGE_INTEGER         liTimeInit;               // FILETIME marking session initiation with SG

    // char szAcctName[];               // ASCII Null terminated
};

struct P_ALIVE_INTERNAL_2_MSG : public BASE_MSG_HEADER
{
    // User Info
    ULONGLONG             qwUserID;                  // User Id
    WORD                  cbAcctName;                // Size of szAcctName

    // Peer Session
    XNADDR xnaddr;
    XNKID xnkid;
    XNKEY xnkey;

    // Sync info
    DWORD                 dwBuddyListVersion;       // Client Friend list version
    DWORD                 dwBlockListVersion;       // Client Mute list version

    // Auth info
    XBOX_LIBRARY_VERSION  clientVersion;            // Client library version
    DWORD                 dwAuthDataFlags;          // Auth Flags
    DWORD                 dwTitleID;                // Title Id
    DWORD                 dwAltTitleID1;            // Alt Title Id1
    DWORD                 dwAltTitleID2;            // Alt Title Id2
    DWORD                 dwAltTitleID3;            // Alt Title Id3
    DWORD                 dwAltTitleID4;            // Alt Title Id4
    DWORD                 dwTitleVersion;           // Title version
    DWORD                 dwTitleRegion;            // Title region
    WORD                  ipportI;                  // IP port of the client on the Internet
    IN_ADDR               ipaI;                     // IP address of the client on the Internet
    LARGE_INTEGER         liNonce;                  // A random nonce associated with this session
    LARGE_INTEGER         liTimeInit;               // FILETIME marking session initiation with SG
    BYTE                  szLocale[XONLINE_PRESENCE_LOCALE_SIZE]; // cached user's locale for use in localizing strings

    ULONGLONG             qwVersionFlags;

    // char szAcctName[];               // ASCII Null terminated
};

#define XONLINE_PRESENCE_VERSION_FLAGS_USE_CONNECTION_SERVER 0x0001000000000000

//
// The asynchronous reply to a P_ALIVE_MSG is contained in one of these
//
struct P_REPLY_BUDDY
{
    ULONGLONG qwBuddyID;
    WORD  cbAcctName;                   // Includes the '\0'
    BYTE  bStatus;
    // char szAcctName;                 // ASCII Null terminated
};

struct P_REPLY_BLOCK
{
    ULONGLONG qwBlockID;
};

struct P_ALIVE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;                         // On fail other fields set to 0
    DWORD dwBuddyListVersion;
    WORD  cBuddiesSent;
    DWORD dwBlockListVersion;
    WORD  cBlocksSent;
    // P_REPLY_BUDDY rgBuddies[]
    // P_REPLY_BLOCK rgBlocks[]
};

//
// Check for system messages on a title change
//
struct P_CHECK_TITLE_MESSAGES_MSG : public BASE_MSG_HEADER
{
    ULONGLONG             qwUserID;                 // User Id
    DWORD                 dwTitleID;                // Title Id
    DWORD                 dwAltTitleID1;            // Alt Title Id1
    DWORD                 dwAltTitleID2;            // Alt Title Id2
    DWORD                 dwAltTitleID3;            // Alt Title Id3
    DWORD                 dwAltTitleID4;            // Alt Title Id4
    DWORD                 dwTitleVersion;           // Title version
    DWORD                 dwTitleRegion;            // Title region
};

struct P_CHECK_TITLE_MESSAGES_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
};

//
// Resync the buddy and block lists
//
struct P_SYNC_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwBuddyListVersion;
    DWORD dwBlockListVersion;
};

//
// The asynchronous reply to a P_SYNC_MSG is contained in one of these
//
struct P_SYNC_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;                         // On fail other fields set to 0
    DWORD dwBuddyListVersion;
    WORD  cBuddiesSent;
    DWORD dwBlockListVersion;
    WORD  cBlocksSent;
    // P_REPLY_BUDDY rgBuddies[]
    // P_REPLY_BLOCK rgBlocks[]
};

//
// Refresh the presence and invitation notification queues
//
struct P_REFRESH_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

//
// Attempt to add the given person to the sender's buddy list, either by the
// person's ID or name.
//
struct P_ADD_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwSenderID;
    ULONGLONG qwBuddyID;
    WORD  cbBuddyAcctname;
    // char szBuddyAcctName[ cbBuddyAcctname];   // ASCII Null terminated
                                                 // only used if qwBuddyID == 0
};

//
// Attempt to add the given person to the sender's buddy list, either by the
// person's ID or name.  Includes a message.
//
struct P_ADD_2_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwSenderID;
    ULONGLONG qwBuddyID;
    DWORD dwMessageFlags;
    WORD cbDetails;
    char szBuddyAcctName[ XONLINE_GAMERTAG_SIZE ]; // ASCII Null terminated
                                                   // only used if qwBuddyID == 0
    // BYTE pbDetails[cbDetails];
};

//
// Attempt to add the given users to the sender's affiliate list.
// Includes flags describing the type of affiliation.
//
struct P_ADD_AFFILIATES_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwSenderID;
    DWORD dwListFlag;
    DWORD dwTitleID;
    WORD cwAffiliates;
    // ULONGLONG pqwAfilliateIDs[cwAffiliates];
};

//
// query if a user is on the sender's affiliates lists.
//
struct P_IS_AFFILIATE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwSenderID;
    ULONGLONG qwAffiliateID;
};

//
// query if a user is on the sender's affiliates lists.
//
struct P_IS_AFFILIATE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    ULONGLONG qwAffiliateID;
    DWORD dwListFlags;
};

//
// query the sender's affiliates lists.
//
struct P_QUERY_AFFILIATES_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwSenderID;
    DWORD dwListFlags;
    DWORD cdwLimit;
    DWORD dwOnlineTitleID;
};

//
// query if a user is on the sender's affiliates lists.
//
struct P_QUERY_AFFILIATES_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    DWORD cdwResults;

    // P_QUERY_AFFILIATES_REPLY_DATA_MSG rgResults[cdwResults];
};

//
// query if a user is on the sender's affiliates lists.
//
struct P_QUERY_AFFILIATES_REPLY_DATA_MSG
{
    ULONGLONG qwAffiliateID;
    DWORD dwListFlags;
    DWORD dwTitleID;
    ULONGLONG qwSessionID;
    MSGTIME mtDateUpdated;
    char szGamerTag[XONLINE_GAMERTAG_SIZE];
};


//
// internal message to migrate a user to another xpserver
//
struct P_USER_PRE_MIGRATION_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

//
// internal message to migrate a user to another xpserver
//
#define XONLINE_PRESENCE_FULL_MIGRATION_VERSION 2

struct P_USER_FULL_MIGRATION_MSG : public BASE_MSG_HEADER
{
    DWORD dwVersion;
    DWORD dwMigrationFlags;
    DWORD dwNow;

    // base record
    ULONGLONG qwUserID;
    ULONGLONG qwNonce;
    DWORD dwLastActive;
    MSGTIME mtUserStateChanged;
    DWORD dwLastSeenTitleID;
    DWORD dwFlags;
    ULONGLONG qwWebID;
    DWORD dwState;
    WORD cMessagesToday;
    WORD cRecipientsToday;
    MSGTIME mtMessageThrottle;
    WORD cBuddies;
    WORD cNeverList;
    DWORD dwBuddyListVersion;
    DWORD cWatchers;
    DWORD cbAcctName;
    CHAR szAcctName[MAX_ACCTNAME_BYTES];

    BOOL fOnlineRecordExists;

    // ULONGLONG rgBuddies[cBuddies];
    // ULONGLONG rgNevers[cNeverList];
    // ULONGLONG rgWatchers[cWatchers];

    // P_ONLINE_PRESENCE_RECORD_MSG onlineRecord;
};

struct P_ONLINE_PRESENCE_RECORD_MSG
{
    // online record
    SGADDR sgaddr;
    DWORD dwClientVersion;
    DWORD dwTitleID;
    DWORD dwAltTitleID1;
    DWORD dwAltTitleID2;
    DWORD dwAltTitleID3;
    DWORD dwAltTitleID4;
    DWORD dwTitleVersion;
    DWORD dwTitleRegion;
    XNADDR xnaddr;
    XNKID xkid;
    XNKEY xnkey;
    IN_ADDR ipaXbox;
    WORD ipportXbox;
    DWORD dwAliveTime;
    DWORD dwPlayStart;
    DWORD dwTitleStart;
    DWORD dwAuthDataFlags;
    BYTE szLocale[XONLINE_PRESENCE_LOCALE_SIZE];
    ULONGLONG qwVersionFlags;

    // State info
    ULONGLONG qwMatchSessionID;
    DWORD cbTitleStuff;
    DWORD cbRichPresence;
    DWORD cbPresenceData;
    DWORD cbNickname;
    BYTE rgbNickname[MAX_NICKNAME_BYTES];

    // Reporting data
    WORD wDequeues;
    WORD wStates;

    // Invitation info
    DWORD dwInviteTitleID;
    ULONGLONG qwInviteSessionID;
    FILETIME ftInviteSent;
    DWORD cInvitees;

    // Block list info (Mute List)
    DWORD dwBlockListVersion;

    // Watch lists
    DWORD cWatches;

    // Messaging members
    DWORD dwNextXMsgItemID;

    // QVals
    DWORD dwSeqQVals;
    DWORD dwSeqXMsgAddQVal;
    DWORD dwSeqXMsgDeleteQVal;
    DWORD rgdwQVals[15];    // TODO:  find a way to make this compile using QVAL_COUNT instead of 15.

    // The user's actual Queues
    DWORD dwTotalQLength;
    DWORD dwNextItemID;

    // ULONGLONG rgInvitees[cInvitees];
    // ULONGLONG rgWatches[cWatches];
    // BYTE rgbPresenceData[cbPresenceData];

    // P_QUEUE_ITEM_MSG rgQueueItems[dwTotalQLength];

};


struct P_QUEUE_ITEM_MSG
{
    DWORD dwQueueType;
    DWORD dwItemID;
    DWORD dwTimestamp;
    BOOL  fDequeued;
    DWORD cbData;

    // BYTE rgbData[cbData];
};

//
// internal message to gather users' state from the other xpservers
//
struct P_GET_PRESENCE_INFO_MSG : public BASE_MSG_HEADER
{
    DWORD dwContext;
    ULONGLONG qwSenderID;
    DWORD cdwUsers;

    // ULONGLONG rgUsers[cdwUsers]; (for request)
    // -- OR --
    // P_PRESENCE_INFO_DATA_MSG rgReplies[cdwUsers]; (for reply)
};

//
// internal message to gather users' state from the other xpservers
//
struct P_PRESENCE_INFO_DATA_MSG
{
    ULONGLONG qwUserID;
    DWORD dwState;
    DWORD dwTitleID;
    MSGTIME mtLastActive;
    ULONGLONG qwSessionID;
    WORD cbStateData;
    DWORD cbRichPresence;
    char szGamerTag[XONLINE_GAMERTAG_SIZE];
    //BYTE pStateData[cbStateData];
    //BYTE pRichPresence[cbRichPresence];
};

//
// Invalidate the presence cache for a user
//
struct P_INVALIDATE_USER_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

//
// Find a user by userID or gamertag
//
struct P_FIND_USER_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;                         // Userid making the request

    ULONGLONG qwFindID;                         // Userid to find
    char szGamerTag[XONLINE_GAMERTAG_SIZE];     // Gamertag to find
};

//
// IResponse to a FindUser message
//
struct P_FIND_USER_REPLY_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwFoundID;                        // Userid found
    char szGamerTag[XONLINE_GAMERTAG_SIZE];     // Gamertag found
};

//
// per-user data blob for find_users api
//
struct P_FIND_USERS_DATA
{
    ULONGLONG qwUserID;
    char szGamerTag[XONLINE_GAMERTAG_SIZE];
};

//
// Find a user by userID or gamertag
//
struct P_FIND_USERS_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;                         // Userid making the request
    DWORD cdwQueries;

    // P_FIND_USERS_DATA[cdwQueries];
};

//
// IResponse to a FindUser message
//
struct P_FIND_USERS_REPLY_MSG : public BASE_MSG_HEADER
{
    DWORD cdwResults;

    // P_FIND_USERS_DATA[cdwResults];
};

//
// Delete a buddy from my buddy list
//
struct P_DELETE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBuddyID;
};

//
// Accept a request to be someone's buddy
//
struct P_ACCEPT_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBuddyID;
};

//
// Reject a request to be someone's buddy
//
struct P_REJECT_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBuddyID;
    BOOL fNever;
};

//
// Add a user to my blocklist
//
struct P_BLOCK_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBlockID;
};

//
// Remove the a user from my blocklist
// If qwBlockID == 0, clear the entire block list.
//
struct P_UNBLOCK_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBlockID;
};

struct P_INVITE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwTitleID;
    ULONGLONG qwMatchSessionID;
    WORD  cInvitees;
    // ULONGLONG rgqwInvitees[ cInvitees ];
};

struct P_INVITE_2_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwSenderContext;
    DWORD dwTitleID;
    DWORD dwMessageFlags;
    WORD cInvitees;
    WORD cbDetails;

    // ULONGLONG rgqwInvitees[ cInvitees ];
    // BYTE pbDetails[cbDetails];
};

struct P_CANCEL_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwMatchSessionID;
    WORD  cInvitees;
    // ULONGLONG rgqwInvitees[ dwNumInvitees ];
};

struct P_INVITE_ANSWER_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwHostID;
    ULONGLONG qwMatchSessionID;
    WORD wAnswer;
};

//
// This supplies the latest nickname info for a user
//
struct P_NICKNAME_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    WORD cbNickname;
    // byte rgbNickName[];              // Binary
};

//
// This supplies the latest state info for a user
//
struct P_STATE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwState;
    ULONGLONG qwMatchSessionID;
    WORD cbTitleStuff;
    // byte rgbTitleStuff[];            // Binary
};

//
// STructure encapsulating all rich presence data. This must
//  match the bottom parts of P_STATE_2_MSG and
//  P_GET_STATE_REPLY_MSG structures, as this is passed
//  around as an opaque entity in the middle tier.
//
struct P_RICH_PRESENCE
{
    // format string specifier
    DWORD titlePresence;

    WORD cContexts;
    WORD cProperties;

    // GI_CONTEXT  rgContexts[];         // Array of contexts
    // GI_PROPERTY rgProps[];            // Array of properties
};

//
//
// This supplies the latest state info for a user
//
struct P_STATE_2_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwState;
    ULONGLONG qwMatchSessionID;

    // Xenon state conveys title changes
    DWORD dwTitleID;
    DWORD cbRichPresence;

    // formatted blob that we write to memcache.
    WORD cbMemcacheBlob;

    // Rich presence
    P_RICH_PRESENCE rp;

    // BYTE rgbMemcacheBlob[cbMemcacheBlob];
};


//
// Fetch the latest state info for a user
//
struct P_GET_STATE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

//
// Reply from a P_GET_STATE_MSG
//
struct P_GET_STATE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;

    DWORD dwState;
    ULONGLONG qwMatchSessionID;

    // Xenon state conveys title changes
    DWORD dwTitleID;

    // Rich presence
    P_RICH_PRESENCE rp;
};

// Inform the P server that the given user just went offline.
//
struct P_DEAD_USER_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

//
// Inform the P server that the given XBox just went offline, so any users
// who were on this XBox should be considered offline also.
//
struct P_DEAD_XBOX_MSG : public BASE_MSG_HEADER
{
};

//
// Inform the P server that the given SG just went offline, so any users
// who were on this SG should be considered offline also.
//
struct P_DEAD_SG_MSG : public BASE_MSG_HEADER
{
};

//
// This tells the destination user's P server that the listed source users
// have added a subscription for the destination user and are expected to
// subscribe back if online
//
struct P_ANNOUNCE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG   qwDestUserID;                              // sender PUID
    BOOL        fAlert;                                    // should we generate alerts on this announce?
    DWORD       dwTitleID;                                 // sender titleID
    char        szGamerTag[XONLINE_GAMERTAG_SIZE];         // sender gamertag
    WORD        cSourceUserIDs;
    // ULONGLONG qwSourceUserIDs[ dwCountSourceUsers ];
};

//
// This tells the destination user's P server that the listed source users
// have added a subscription for the destination user
//
struct P_SUBSCRIBED_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwDestUserID;
    WORD  cSourceUserIDs;
    // ULONGLONG qwSourceUserIDs[ dwCountSourceUsers ];
};

//
// This tells the destination users' P server that the source user just went
// offline, which implies that any subscription for the source user should
// be removed.
//
struct P_UNSUBSCRIBE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwSourceUserID;
    WORD  cDestUserIDs;
    // ULONGLONG qwDestUserIDs[ dwCountDestUsers ];
};

//
// Tell your new buddy's P server that you made a request to become buddies.
//
struct P_ADDED_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBuddyID;
    DWORD dwVersion;
    WORD  cbBuddyAcctName;
    // char szBuddyAcctName[ cbBuddyAcctName ];  // ASCII string null terminated
};

//
// Tell your new buddy's P server that you accepted his request to become buddies.
//
struct P_ACCEPTED_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBuddyID;
    DWORD dwVersion;
    WORD  cbBuddyAcctName;
    // char szBuddyAcctName[ cbBuddyAcctName ];  // ASCII string null terminated
};

//
// Tell your ex-buddy's P server that you are no longer buddies.
//
struct P_REMOVED_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBuddyID;
    DWORD dwVersion;
};

//
// Kick a user off the system
//
struct P_KICK_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    BOOL fFlushTickets;
};

struct P_PURGE_USER_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

struct P_PURGE_USER_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    CHAR szGamertag[XONLINE_GAMERTAG_SIZE];
};

struct P_WEB_FRIENDS_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

struct P_GET_FRIENDS_LIST_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwSenderID;
    ULONGLONG qwTargetID;
};

struct P_GET_FRIENDS_LIST_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    ULONGLONG qwUserID;
    DWORD dwVersion;
    DWORD cdwFriends;

    // P_GET_FRIENDS_LIST_REPLY_DATA rgFriends[cdwFriends];
};

struct P_GET_FRIENDS_LIST_REPLY_DATA
{
    ULONGLONG qwFriendID;
    DWORD dwStatus;
    DWORD dwOnlineState;
    DWORD dwTitleID;
    MSGTIME mtLastActive;
    WORD cbStateData;
    DWORD cbRichPresence;
    char szGamerTag[XONLINE_GAMERTAG_SIZE];

    // BYTE rgbStateData[cbStateData];
    // BYTE rgbRichPresence[cbRichPresence];
};

struct P_WEB_ALIVE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

struct P_WEB_ALIVE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    ULONGLONG qwUserID;
};

struct P_WEB_ANNOUNCE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwDestUserID;
    WORD  cSourceUserIDs;
    // ULONGLONG qwSourceUserIDs[ dwCountSourceUsers ];
};

struct P_WEB_SUBSCRIBED_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwDestUserID;
    WORD  cSourceUserIDs;
    // ULONGLONG qwSourceUserIDs[ dwCountSourceUsers ];
};

struct P_WEB_UNSUBSCRIBE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwSourceUserID;
    WORD  cDestUserIDs;
    // ULONGLONG qwDestUserIDs[ dwCountDestUsers ];
};

struct P_CONNECTION_HEALTH_MSG : public BASE_MSG_HEADER
{
    DWORD dwVersion;
    DWORD dwFlags;
};

struct P_CONNECTION_HEALTH_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    DWORD dwFlags;
};

struct P_PEER_SESSION_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwHostUserID;
};

struct P_PEER_SESSION_REPLY_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwHostUserID;

    DWORD dwTitleID;
    DWORD dwTitleVersion;
    DWORD dwTitleRegion;

    XNADDR xnaddr;
    XNKID xkid;
    XNKEY xnkey;
};

struct P_REPLY_TEAM
{
    ULONGLONG qwTeamID;
    DWORD dwNumMembers;
    WORD cbTeamName;
    WORD cbTeamDescription;
    WORD cbTeamMotto;
    WORD cbTeamURL;
    WORD cbTeamData;
    FILETIME ftCreated;

    // WCHAR wszTeamName[cbTeamName]
    // WCHAR wszTeamDescription[cbTeamDescription]
    // WCHAR wszTeamMotto[cbTeamMotto]
    // WCHAR wszTeamURL[cbTeamURL]
    // BYTE pbTeamData[cbTeamData]
};

struct P_REPLY_USER_TEAM
{
    ULONGLONG qwTeamID;
    BOOL fMember;
    WCHAR wszTeamName[MAX_TEAM_NAME_CHAR];
};


struct P_REPLY_TEAM_MEMBER
{
    ULONGLONG qwMemberID;
    BYTE cbMemberName;
    BOOL fMember;
    DWORD dwMemberPriv;
    WORD cbMemberData;
    FILETIME ftJoined;

    // CHAR szMemberName[cbMemberName]
    // BYTE pbMemberData[cbMemberData]
};

struct P_TEAM_TICKET
{
    ULONGLONG qwUserID;
    WORD cTeams;
    WORD cbSignature;

    // ULONGLONG rgqwTeamIDs[];    // actual length dictated by cTeams, max MAX_TEAMS
    // BYTE rgbSignature[];        // actual length dictated by cbSignature. For now fixed at 8
};


struct P_TEAM_LIST_TEAMS_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwTitleID;
    DWORD cTeamIDs;
    // ULONGLONG rgqwTeamIDs[]
};

struct P_TEAM_LIST_TEAMS_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    DWORD cTeams;
    //P_REPLY_TEAM rgsTeams[]
};

struct P_TEAM_LIST_USER_TEAMS_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwTitleID;
};

struct P_TEAM_LIST_USER_TEAMS_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    DWORD cTeams;
    //P_REPLY_USER_TEAM rgsUserTeams[]
};


struct P_TEAM_LIST_MEMBERS_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwTitleID;
    ULONGLONG qwTeamID;
    BOOL fShowRecruits;
};

struct P_TEAM_LIST_MEMBERS_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    ULONGLONG qwTeamID;
    WORD cMembers;
    //P_REPLY_TEAM_MEMBER rgsMembers[]
};

struct P_TEAM_CREATE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwTitleID;

    DWORD dwMaxMembers;
    WORD cbTeamName;
    WORD cbTeamDescription;
    WORD cbTeamMotto;
    WORD cbTeamURL;
    WORD cbTeamData;
    WORD cbCreatorData;

    // WCHAR wszTeamName[cbTeamName]
    // WCHAR wszTeamDescription[cbTeamDescription]
    // WCHAR wszTeamMotto[cbTeamMotto]
    // WCHAR wszTeamURL[cbTeamURL]
    // BYTE pbTeamData[cbTeamData]
    // BYTE pbCreatorData[cbCreatorData]
};

struct P_TEAM_CREATE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    ULONGLONG qwTeamID;
    FILETIME ftCreated;
};

struct P_TEAM_DELETE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwTitleID;
    ULONGLONG qwTeamID;
};

struct P_TEAM_DELETE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
};

struct P_TEAM_REMOVE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwTitleID;
    ULONGLONG qwTeamID;
    ULONGLONG qwMemberID;
};

struct P_TEAM_REMOVE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
};

struct P_TEAM_MANAGE_TEAM_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwTitleID;
    ULONGLONG qwTeamID;
    WORD cbTeamName;
    WORD cbTeamDescription;
    WORD cbTeamMotto;
    WORD cbTeamURL;
    WORD cbTeamData;

    // WCHAR wszTeamName[cbTeamName]
    // WCHAR wszTeamDescription[cbTeamDescription]
    // WCHAR wszTeamMotto[cbTeamMotto]
    // WCHAR wszTeamURL[cbTeamURL]
    // BYTE pbTeamData[cbTeamData]
};

struct P_TEAM_MANAGE_TEAM_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
};

struct P_TEAM_MANAGE_MEMBER_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwTitleID;
    ULONGLONG qwTeamID;
    ULONGLONG qwMemberID;
    DWORD dwMemberPriv;
    WORD cbMemberData;

    // BYTE pbMemberData[cbMemberData]
};

struct P_TEAM_MANAGE_MEMBER_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
};

struct P_TEAM_RECRUIT_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwTitleID;
    ULONGLONG qwTeamID;
    ULONGLONG qwMemberID;
    CHAR szMemberName[XONLINE_GAMERTAG_SIZE];
    DWORD dwMemberPriv;
    DWORD dwMessageFlags;
    WORD cbMemberData;
    WORD cbDetails;

    // BYTE pbDetails[cbDetails];
    // BYTE pbMemberData[cbMemberData]
};

struct P_TEAM_RECRUIT_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
};

struct P_TEAM_JOIN_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwTitleID;
    ULONGLONG qwTeamID;
    DWORD dwRecruitMsgID;
    BYTE bAnswer;
};

struct P_TEAM_JOIN_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
};

struct P_TEAM_GET_TICKET_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwTitleID;
};

struct P_TEAM_GET_TICKET_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    P_TEAM_TICKET sTeamTicket;
};

struct P_PEER_SUBSCRIBE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    WORD cSrcUserIDs;
    //ULONGLONG qwSrcUserIDs[];
};

struct P_PEER_SUBSCRIBE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
};

struct P_PEER_UNSUBSCRIBE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

struct P_PEER_UNSUBSCRIBE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
};

struct P_PEER_SUBSCRIBE_EX_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwFlags;
    WORD cUserIDs;
    //ULONGLONG rgqwUserIDs[cUsersID];
};

struct P_PEER_SUBSCRIBE_EX_DATA
{
    ULONGLONG qwUserID;
    DWORD dwState;
    DWORD dwTitleID;
    MSGTIME mtUserTime;
    CHAR szGamertag[XONLINE_GAMERTAG_SIZE];
};

struct P_PEER_SUBSCRIBE_EX_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;
    WORD cResults;
    // P_PEER_SUBSCRIBE_EX_DATA rgResults[cResults];
};

struct P_WATCH_START_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwDestUserID;
    WORD  cSourceUserIDs;
    // ULONGLONG qwSourceUserIDs[ dwCountSourceUsers ];
};

struct P_WATCH_STOP_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwDestUserID;
    WORD  cSourceUserIDs;
    // ULONGLONG qwSourceUserIDs[ dwCountSourceUsers ];
};

//
// Notifications
//
struct P_LIST_CHANGE_ITEM
{
    DWORD dwListVersion;
    ULONGLONG qwTargetID;
    WORD  wOperationID;
    HRESULT hr;
    WORD  cbTargetAcctName;
    // char szTargetAcctName[ cbTargetAcctName ];  // ASCII string null terminated
};

struct P_PRESENCE_ITEM
{
    ULONGLONG qwBuddyID;
    DWORD dwTitleID;
    DWORD dwState;
    ULONGLONG qwMatchSessionID;
    WORD  cbNickname;
    WORD  cbTitleStuff;
    // byte rgbNickName[];              // Binary
    // byte rgbTitleStuff[];            // Binary
};

struct P_INVITATION_ITEM
{
    ULONGLONG qwHostID;
    ULONGLONG qwMatchSessionID;
    DWORD dwTitleID;
    FILETIME ftSent;
};

struct P_INVITATION_ANSWER_ITEM
{
    ULONGLONG qwInviteeID;
    ULONGLONG qwMatchSessionID;
    FILETIME ftSent;
    WORD  wAnswer;
};

struct P_PEER_PRESENCE_ITEM
{
    ULONGLONG qwUserID;
    DWORD dwTitleID;
    DWORD dwState;
    ULONGLONG qwMatchSessionID;
    WORD  cbTitleStuff;
    // byte rgbTitleStuff[];            // Binary
};

struct P_PRESENCE_2_ITEM
{
    ULONGLONG   qwUserID;
    DWORD       dwTitleID;
    DWORD       dwState;
    ULONGLONG   qwMatchSessionID;
    MSGTIME     mtUserTime;
    WORD        cbRichPresence;
    WORD        cbData;
    // byte     szRichPresence[];       // utf-8 encoded
    // byte     rgbData[];
};

// ====================================================================
// Alerts
//
#define XONLINE_ALERT_CLASS_MESSAGING             ((BYTE) 0)
#define XONLINE_ALERT_CLASS_PRESENCE              ((BYTE) 1)

#define XONLINE_ALERT_TYPE_TITLE_CUSTOM           ((WORD) (XONLINE_ALERT_CLASS_MESSAGING << 8) | XONLINE_MSG_TYPE_TITLE_CUSTOM)
#define XONLINE_ALERT_TYPE_FRIEND_REQUEST         ((WORD) (XONLINE_ALERT_CLASS_MESSAGING << 8) | XONLINE_MSG_TYPE_FRIEND_REQUEST)
#define XONLINE_ALERT_TYPE_GAME_INVITE            ((WORD) (XONLINE_ALERT_CLASS_MESSAGING << 8) | XONLINE_MSG_TYPE_GAME_INVITE)
#define XONLINE_ALERT_TYPE_TEAM_RECRUIT           ((WORD) (XONLINE_ALERT_CLASS_MESSAGING << 8) | XONLINE_MSG_TYPE_TEAM_RECRUIT)
#define XONLINE_ALERT_TYPE_COMP_REMINDER          ((WORD) (XONLINE_ALERT_CLASS_MESSAGING << 8) | XONLINE_MSG_TYPE_COMP_REMINDER)
#define XONLINE_ALERT_TYPE_COMP_REQUEST           ((WORD) (XONLINE_ALERT_CLASS_MESSAGING << 8) | XONLINE_MSG_TYPE_COMP_REQUEST)
#define XONLINE_ALERT_TYPE_LIVE_MESSAGE           ((WORD) (XONLINE_ALERT_CLASS_MESSAGING << 8) | XONLINE_MSG_TYPE_LIVE_MESSAGE)

#define XONLINE_ALERT_TYPE_LOGON                  ((WORD) (XONLINE_ALERT_CLASS_PRESENCE  << 8) | 0)



#pragma pack(push, 1)
typedef struct _XONLINE_ALERT {
    DWORD       dwTitleID;                                 // sender titleID
    WORD        wType;                                     // alert Type
    WORD        wFlags;                                    // alert Flags
    WORD        wRecipients;                               // count of recipients
    BYTE        cbSender;                                  // size of szGamertag
    BYTE        cchData;                                   // size of szData in wchars
    ULONGLONG   qwSenderUserID;                            // sender userID
    // struct {
    //     ULONGLONG    qwWebID;                           // recipients webIDs
    //     ULONGLONG    qwUserID;                          // recipients userIDs
    // } recipients[wRecipients]
    // WCHAR    wszAlertData[cchData];                     // optional Alert data
    // CHAR     szSenderGamertag[cbSender];                // sender Gamertag
} XONLINE_ALERT, *PXONLINE_ALERT;
#pragma pack(pop)


#define XONLINE_MAX_ALERT_SIZE                      1432   // max size of a UDP packet



// ====================================================================
// Ticket list information
//

#define TEAM_TICKETS_TYPE       0x0001
#define MAXIMUM_TEAM_TICKETS    1024

struct P_TEAM_TICKETS
{
    WORD wType;    // TEAM_TICKETS_TYPE
    WORD wLength;  // number of bytes following this WORD
    WORD cTickets; // number of tickets (must be <= MAXIMUM_TEAM_TICKETS)

    //P_TEAM_TICKET rgTickets[];
};

#define MAX_TEAM_TICKET_SIGNATURE_SIZE      8
#define MAX_TEAM_TICKET_VARIABLE_SIZE       ((sizeof(ULONGLONG) * XONLINE_MAX_TEAM_COUNT) + MAX_TEAM_TICKET_SIGNATURE_SIZE)
#define MAX_TEAM_TICKET_SIZE                (sizeof(P_TEAM_TICKET) + MAX_TEAM_TICKET_VARIABLE_SIZE)
#define MAX_LOCAL_TEAM_TICKETS_SIZE         (sizeof(P_TEAM_TICKETS) + (XONLINE_MAX_LOGON_USERS * MAX_TEAM_TICKET_SIZE))


#pragma pack(pop)

#endif // __cplusplus

// ====================================================================
// XOnline Matchmaking
//

#define X_ATTRIBUTE_RESERVED1_MASK          0x70000000
#define X_ATTRIBUTE_RESERVED2_MASK          0x000F0000
#define X_ATTRIBUTE_RESERVED3_MASK          0x0F000000

#define X_MATCH_PROTOCOL_VERSION        0x01000000 // 1.0.0000
#define X_MIN_SEARCH_RESULT_COLUMNS     8

//
//  Reserved title search sproc indices
//
#define X_SSINDEX_GET_SESSION             0xFFFFFFFF   // special sproc to retrieve session by session id
#define X_SSINDEX_GET_SESSION_ATTRIBUTES  0xFFFFFFFE   // special sproc to retrieve session by session id with attribute data
#define XMATCH_QUERYID_FLAG_SUMMARY_QUERY 0x80000000
#define XMATCH_QUERYID_FLAG_RESERVED      0x7FFF0000

//----------------------------------------------------------------------------+
//  Structures
//

#pragma pack(push, 1)


//
//  This structure defines a session.  When used on the client, will be
//  included in a larger structure pre-pended with an async task struct.
//  The following structure is identical to the host advertisement wire
//  protocol.
//  The raw data for session title, application data and attributes will
//  typically follow this structure in the same area of memory, and on the
//  wire.
//
typedef struct _XMATCH_SESSION
{
    DWORD               dwMessageLength;
    XNKID               SessionID;
    DWORD               dwTitleID;
    XNADDR              HostAddress;
    DWORD               dwPublicOpen;
    DWORD               dwPrivateOpen;
    DWORD               dwPublicFilled;
    DWORD               dwPrivateFilled;
    DWORD               dwNumAttributes;
} XMATCH_SESSION, *PXMATCH_SESSION;

//
//  This structure defines the information returned to the client
//  after a session has been created.
//
typedef struct _XMATCH_SESSION_INFO
{
    XNKID               SessionID;
    XNKEY               KeyExchangeKey;
} XMATCH_SESSION_INFO, *PXMATCH_SESSION_INFO;

//
//  This structure is passed up to delete a session.
//
typedef struct _XMATCH_SESSION_DELETE
{
    DWORD               dwMessageLength;
    XNKID               SessionID;
    DWORD               dwTitleID;
} XMATCH_SESSION_DELETE, *PXMATCH_SESSION_DELETE;

//
//  This structure defines the information passed to the server
//  to initiate a search for a game session.
//

#define XONLINE_MATCH_FLAG_NAT_TYPE_MASK 0x0003
#define XONLINE_MATCH_FLAGS_RESERVED     0xFFFC

typedef struct _XMATCH_SEARCH
{
    DWORD                dwMessageLength;
    DWORD                dwTitleID;
    DWORD                dwProcedureIndex;
    XNADDR               ClientAddress;
    WORD                 wNumUsers;
    WORD                 wFlags;
    DWORD                dwNumParameters;
} XMATCH_SEARCH, *PXMATCH_SEARCH;

//
//  This structure defines a session split request on the wire.
//
//  The following structure is similar to the host advertisement wire
//  protocol with the addition of requiring an existing session ID
//  which must exist in one of the partitions for the specified title ID.
//  SplitSessionID must be a valid known match session.
//
//  The return from a split request is a single XMATCH_SEARCHRESULT
//  structure.
//
typedef struct _XMATCH_SPLIT
{
    DWORD               dwMessageLength;
    XNKID               SessionID;
    XNKID               SplitSessionID;
    DWORD               dwTitleID;
    XNADDR              HostAddress;
    DWORD               dwPublicOpen;
    DWORD               dwPrivateOpen;
    DWORD               dwPublicFilled;
    DWORD               dwPrivateFilled;
    DWORD               dwNumAttributes;
} XMATCH_SPLIT, *PXMATCH_SPLIT;

#pragma pack(pop)


// ====================================================================
// XOnline String Server
//

#pragma pack(push, 1)

#define MAX_STRINGSVR_STRING_LEN 512 // characters

#define STRING_LOOKUP_URL "/msgserver/getstring.ashx"

struct STRING_LOOKUP_REQUEST
{
    DWORD dwTitleID;
    WORD  wLanguage;
    WORD wNumStrings;
    // rgdwStringIDs[ wNumStrings ];
};

struct STRING_DATA
{
    WORD wStringSize;
    // char szString[ wStringSize ];
};

struct STRING_LOOKUP_RESPONSE
{
    WORD wNumStrings;
    // STRING_DATA rgStringData[ wNumStrings ];
};

struct LANGUAGE_STRING
{
    WORD wLanguage;
    WORD wStringSize;
    // char szString[ wStringSize ];
};

#define STRING_ADD_URL "/msgserver/addstring.ashx"

struct STRING_ADD_REQUEST
{
    DWORD dwTitleID;
    DWORD dwStringID; // Use 0xFFFFFFFF to have the service pick an available ID
    FILETIME ftExpire;
    WORD  wDefaultLanguage;
    BYTE  cLangStrings;
    BYTE  fVetText;
    // LANGUAGE_STRING rgLangStrings[ cLangStrings ];
};

struct STRING_ADD_RESPONSE
{
    DWORD dwStringID;
};

#define STRING_VET_URL "/msgserver/vetstring.ashx"

struct STRING_VET_REQUEST
{
    DWORD dwTitleID;
    WORD  wLanguage;
    WORD wNumStrings;
    // STRING_DATA rgStringData[ wNumStrings ];
};

struct STRING_VET_RESPONSE
{
    WORD wNumStrings;
    // HRESULT rghrString[ wNumStrings ];
};

#define STRING_V1_TITLE_ID_URL "/msgserver/msgserver.ashx"

struct STRING_V1_TITLE_ID_REQUEST
{
    WORD wType; // Always 1
    WORD wLanguage;
    WORD wNumTitles;
    // DWORD rgdwTitleIDs[ wNumTitles ];
};

#pragma pack(pop)


// ====================================================================
// XOnline Feedback
//

#pragma pack(push, 1)

#define FEEDBACK_XRL "/fbserver/fbserver.ashx"

typedef struct {
    ULONGLONG   qwSenderPUID;
    ULONGLONG   qwTargetPUID;
    DWORD       dwTitleID;
    BYTE        bFeedbackType;
    BYTE        bTextLength;
} XONFEEDBACK_SEND_REQUEST, *PXONFEEDBACK_SEND_REQUEST;

#pragma pack(pop)


// ====================================================================
// XOnline Billing
//

//
// Wire structures can't be shared with the c# ISAPIs, so
// this section has been moved to the top of billing.cpp. Visit us
// there at our new home!
//

// ====================================================================
// XOnline Statistics
//

#pragma pack(push, 1)

struct XSTATS_MSG_SETDATA
{
    DWORD dwTitleId;
    ULONGLONG ullUserId;
    DWORD dwLeaderBoardType;
    DWORD dwAttrCount;
};

struct XSTATS_MSG_ATTRIBUTEDATA
{
    WORD wAttrId;
    BYTE bAttrType;
};

struct XSTATS_MSG_GETDATA
{
    DWORD dwTitleId;
    ULONGLONG ullUserId;
    DWORD dwLeaderBoardType;
    DWORD dwAttrCount;
    // (implicit) WORD rgAttrId[];
};

struct XSTATS_MSG_RESP_GETDATA
{
    ULONGLONG ullUserId;
    DWORD dwLeaderBoardType;
};

struct XSTATS_MSG_ENUMLEADERBOARD
{
    DWORD dwTitleId;
    DWORD dwLeaderBoardType;
    ULONGLONG ullPivot;
    BYTE fUser;
    DWORD dwPageSize;
    DWORD dwAttrCount;
    // (implicit) WORD rgAttrId[];
};

struct XSTATS_MSG_RESP_ENUMLEADERBOARD
{
    DWORD dwLeaderboardSize;
    DWORD dwRespUserCount;
    DWORD dwAttrPerUser;
    // (implicit) XSTATS_MSG_RESP_ENUMLEADERBOARD_USER rgUsers[dwRespUserCount];
};

struct XSTATS_MSG_RESP_ENUMLEADERBOARD_USER
{
    ULONGLONG ullUserId;
    DWORD dwRank;
    LONGLONG llRating;
    BYTE bXNameSize;
    BYTE bNicknameSize;
    // (implicit) CHAR rgXName[];
    // (implicit) WCHAR rgNickname[];
    // (implicit) XSTATS_MSG_ATTRIBUTEDATA rgAttr[];
};

struct XSTATS_MSG_RESET
{
    DWORD dwTitleId;
    ULONGLONG ullUserId;
    DWORD dwLeaderBoardType;
};

#define STAT_PARAM_NONE         0 // 0 byte value
#define STAT_PARAM_INT8         1 // 1 byte value
#define STAT_PARAM_INT16        2 // 2 byte value
#define STAT_PARAM_INT32        3 // 4 byte value
#define STAT_PARAM_INT64        4 // 8 byte value
#define STAT_PARAM_FLOAT        5 // 8 byte double precision value
#define STAT_PARAM_UTF8STRING   6 // UTF-8 encoded string
#define STAT_PARAM_PUID         7 // 8 byte value

struct XSTATS_MSG_STATPOST_PROC_PARAM
{
    BYTE bParamType;

    // parameter value
};

struct XSTATS_MSG_STATPOST_PROC
{
    WORD wProcedureId;
    WORD wParameterCount;

    // XSTATS_MSG_STATPOST_PROC_PARAM rgProcParams[];
};

struct XSTATS_MSG_STATPOST
{
    DWORD dwTitleId;
    WORD wProcedureCount;

    // XSTATS_MSG_STATPOST_PROC rgProcs[];
};

struct XSTATS_MSG_UNITSPEC
{
    DWORD dwLeaderBoardId;
    WORD wAttrCount;
    // (implicit) WORD rgAttrId[];
};

struct XSTATS_MSG_UNITGETDATA
{
    DWORD dwTitleId;
    ULONGLONG ullUnitMemberIds[4];
    WORD wSpecCount;
    // (implicit) XSTATS_MSG_UNITSPEC rgSpecs[];
};

struct XSTATS_MSG_RESP_UNITSPEC
{
    DWORD dwLeaderBoardId;
    WORD wAttrCount;
    // (implicit) XSTATS_MSG_ATTRIBUTEDATA rgAttrs[];
};

struct XSTATS_MSG_RESP_UNITGETDATA
{
    WORD wSpecCount;
    // (implicit) XSTATS_MSG_RESP_UNITSPEC rgSpecs[];
};

#define UNIT_ENUM_SORT_ACTIVITY     0x00000001
#define UNIT_ENUM_SORT_RATING       0x00000002

struct XSTATS_MSG_UNITENUM
{
    DWORD dwTitleId;
    DWORD dwLeaderBoardId;
    DWORD dwFlags;
    ULONGLONG ullMember;
    WORD wPageSize;
    WORD wAttrCount;
    // (implicit) WORD rgAttrId[];
};

struct XSTATS_MSG_RESP_UNIT
{
    ULONGLONG ullUnitMemberIds[4];
    // (implicit) WORD wSizeName1;
    // (implicit) char rgName1;
    // (implicit) WORD wSizeName2;
    // (implicit) char rgName2;
    // (implicit) WORD wSizeName3;
    // (implicit) char rgName3;
    // (implicit) WORD wSizeName4;
    // (implicit) char rgName4;
    // (implicit) WORD wAttrCount;
    // (implicit) XSTATS_MSG_ATTRIBUTEDATA rgAttrs[];
};

struct XSTATS_MSG_RESP_UNITENUM
{
    WORD wUnitCount;
    // (implicit) XSTATS_MSG_RESP_UNIT rgUnits[];
};

#pragma pack(pop)



// ====================================================================
// XOnline Arbitration
//

#pragma pack(push, 1)

#define XARB_PROTOCOL_VERSION   1

#define XARB_FLAG_IS_TOURNAMENT                     0x0001
#define XARB_FLAG_CAN_EXTEND_TIME                   0x0002
#define XARB_FLAG_USES_SESSION_HOST                 0x0004
#define XARB_FLAG_FOR_TEAMS                         0x0008
#define XARB_FLAG_FFA                               0x0010
#define XARB_FLAG_IS_PUBLISHER_TOURNAMENT           0x0020

#define XARB_FLAG_I_VOLUNTARILY_QUIT                0x8000
#define XARB_FLAG_I_WAS_HOST                        0x4000
#define XARB_FLAG_LOST_CONNECTIVITY                 0x2000
#define XARB_FLAG_LOST_CONNECTIVITY_SUBMITTED       0x1000
#define XARB_FLAG_TYPE_1_SUSPICIOUS_INFO_SUBMITTED  0x0800
#define XARB_FLAG_TYPE_2_SUSPICIOUS_INFO_SUBMITTED  0x0400
#define XARB_FLAG_TYPE_3_SUSPICIOUS_INFO_SUBMITTED  0x0200
#define XARB_FLAG_STATS_BUNDLE_SUBMITTED            0x0100
#define XARB_FLAG_TOURNAMENT_BUNDLE_SUBMITTED       0x0080





struct XARB_MSG_REGISTER
{
    WORD wProtocolVersion;
    WORD wRequestFlags;
    DWORD dwTitleID;
    ULONGLONG qwSessionID;
    ULONGLONG qwSessionNonce;
    WORD wMaxSessionSeconds;
    // (implicit) XARB_TEAMTICKETLIST TeamTicketList;
};

struct XARB_REGISTRANT
{
    ULONGLONG qwMachineID;
    BYTE bTrustworthiness;
    BYTE bNumUsers;
    // (implicit) XUID rgUsers[];
};

struct XARB_MSG_REGISTER_REPLY
{
    WORD wNumRegistrants;
    // (implicit) XARB_REGISTRANT rgRegistrants[];
};

struct XARB_MSG_TIMEEXTEND
{
    WORD wProtocolVersion;
    WORD wRequestFlags;
    DWORD dwTitleID;
    ULONGLONG qwSessionID;
    ULONGLONG qwSessionNonce;
    WORD wMaxSessionSecondsFromNow;
};

struct XARB_SUSPICIOUSINFO
{
    BYTE bMessageLength;
    // (implicit) char szMessage[];
    // (implicit) BYTE bNumRelatedMachineIDs
    // (implicit) ULONGLONG rgRelatedMachineIDs[];
    // (implicit) BYTE bNumRelatedUsers
    // (implicit) ULONGLONG rgRelatedUsers[];
};

struct XARB_MSG_REPORT
{
    WORD wProtocolVersion;
    WORD wRequestFlags;
    DWORD dwTitleID;
    ULONGLONG qwSessionID;
    ULONGLONG qwSessionNonce;
    // (implicit) BYTE bNumLostConnectivityMachineIDs;
    // (implicit) ULONGLONG rgLostConnectivityMachineIDs[];
    // (implicit) XARB_SUSPICIOUSINFO rgSuspiciousInfo1;
    // (implicit) XARB_SUSPICIOUSINFO rgSuspiciousInfo2;
    // (implicit) XARB_SUSPICIOUSINFO rgSuspiciousInfo3;
    // (implicit) DWORD dwStatsBundleByteCount;
    // (implicit) BYTE rgStatsBundle[];
    // (implicit) DWORD dwCompetitionBundleByteCount;
    // (implicit) BYTE rgCompetitionBundle[];
};

struct XARB_MSG_DEBUGRESULT
{
    WORD wProtocolVersion;
    WORD wRequestFlags;
    DWORD dwTitleID;
    ULONGLONG qwSessionID;
    ULONGLONG qwSessionNonce;
};

struct XARB_USERINFO
{
    ULONGLONG qwUserID;
    DWORD dwUserFlags;
    FLOAT UserTrust;
};

struct XARB_XBOXINFO
{
    BYTE bTimeExtendCount;
    BYTE bReportCount;
    WORD wReportFlags;
    ULONGLONG qwXboxID;
    INT iUserCount;
    // (implicit) XARB_USERINFO rgUsers[];
    // (implicit) double dTrust;
    // (implicit) BYTE bNormalizedTrust;
    // (implicit) INT iBundleIndex;
    // (implicit) INT iDisconnectedXboxCount;
    // (implicit) ULONGLONG rgDisconnectedXboxes[];
};

struct XARB_BUNDLE
{
    INT iIndex;
    DWORD dwCount;
    double dTotalTrust;
};

struct XARB_SUBMITTEDSUSPICIOUSINFO
{
    INT iType; // 1, 2, or 3
    INT iMessageLen;
    // (implicit) char szMessage[];
    // (implicit) INT iXboxCount;
    // (implicit) ULONGLONG rgXboxes[];
    // (implicit) INT iUserCount;
    // (implicit) ULONGLONG rgUsers[];
};

struct XARB_MSG_DEBUGRESULT_REPLY
{
    DWORD dwTitleID;
    ULONGLONG qwSessionID;
    ULONGLONG qwSessionNonce;

    // Title parameters
    double dBaseTrust;
    double dMinorityQuorum;
    double dUserTournamentAmplification;
    double dPublisherTournamentAmplification;
    DWORD dwBaseSessionTime;
    double dFermiK;

    WORD wFlags;
    WORD wMaxSessionSeconds;
    WORD wSecondsLeftTillTimeout;
    FILETIME ftStartTime;
    double dSessionSeconds;
    INT iXboxCount;
    // (implicit) XARB_XBOXINFO rgXboxes[];
    // (implicit) INT iTeamTicketCount;
    // (implicit) double dTotalTrust;
    // (implicit) DWORD dwReportCount;
    // (implicit) BYTE bArbitrated;
    // (implicit) INT iResult;
    // (implicit) INT iNonProblematicResult;
    // (implicit) FLOAT TrustModificationScale;
    // (implicit) INT iBundleCount;
    // (implicit) XARB_BUNDLE rgBundles[];
    // (implicit) INT iSubmittedBundleIndex;
    // (implicit) INT iSuspiciousInfoCount;
    // (implicit) XARB_SUBMITTEDSUSPICIOUSINFO rgSuspiciousInfo[];
};

#pragma pack(pop)

// PUID bases
const UINT64 PUID_BASE_MASK          = 0xFFFF000000000000;
const UINT64 PUID_BASE_USER          = 0x0009000000000000;
const UINT64 PUID_BASE_XBOX          = 0x0009000000000000;
const UINT64 PUID_BASE_XENON         = 0xFA00000000000000;
const UINT64 PUID_BASE_XENON_CONSOLE = 0xF000000000000000;
const UINT64 PUID_BASE_PC            = 0xFB00000000000000;
const UINT64 PUID_BASE_MOBILE        = 0xFC00000000000000;

#define IS_USER_PUID(puid)          ((puid & PUID_BASE_MASK) == PUID_BASE_USER)
#define IS_XBOX_MACHINE_PUID(puid)  ((puid & PUID_BASE_MASK) == PUID_BASE_XBOX)
#define IS_XENON_MACHINE_PUID(puid) ((puid & PUID_BASE_MASK) == PUID_BASE_XENON)
#define IS_PC_MACHINE_PUID(puid)    ((puid & PUID_BASE_MASK) == PUID_BASE_PC)
#define IS_PC_MOBILE_PUID(puid)     ((puid & PUID_BASE_MASK) == PUID_BASE_MOBILE)

// Title-id
#define IS_XENON_TITLE_ID(x) ((x & 0xFFFF) >= 0x07D1 && (x & 0xFFFF) < 0x0BB8)

// ---------------------------------------------------------------------------------------
// Platform types
// These constants are used by CAuthData3 and SGADDR2 to identify the platform type
// ---------------------------------------------------------------------------------------

#define XPLT_XBOX1      0
#define XPLT_XBOX360    1
#define XPLT_PC         2
#define XPLT_INTERNAL   3
#define XPLT_MOBILE     15

// ---------------------------------------------------------------------------------------
// Console Certificate
// ---------------------------------------------------------------------------------------

const int CONSOLE_PUBLIC_KEY_EXPONENT_SIZE   = 4;
const int CONSOLE_PUBLIC_KEY_MODULUS_SIZE    = 128;
const int CONSOLE_ID_SIZE                    = 5;
const int CONSOLE_PART_NUMBER_SIZE           = 8;
const int CONSOLE_CERT_PART_NUMBER_SIZE      = 11;
const int CONSOLE_CERTIFICATE_RESERVED_SIZE  = 6;
const int CONSOLE_CERTIFICATE_HASH_SIZE      = 20;
const int CONSOLE_CERTIFICATE_SIGNATURE_SIZE = 256;

// Console type flags
const int CONSOLE_CERTIFICATE_TYPE_DEVKIT       = 0x00000001;  // Devkit: runs red-signed binaries and has access to test environments only
const int CONSOLE_CERTIFICATE_TYPE_RETAIL       = 0x00000002;  // Retail: runs green-signed binaries and has access to test and retail environments
const int CONSOLE_CERTIFICATE_TYPE_TESTKIT      = 0x40000000;  // Testkit: can switch between devkit and retail kit modes
const int CONSOLE_CERTIFICATE_TYPE_TEST_SIGNED  = 0x80000000;  // Console certificate was signed using the test manufacturing key

const int PC_MACHINE_TYPE_NORMAL                = 0x00000000;  //default for normal PC machine accounts
const int PC_MACHINE_TYPE_LIMITED               = 0x00000001;  //to be placed in CertConsoleType - since this is only used on PCs this will not collide with CONSOLE_CERTIFICATE_TYPE_DEVKIT


#pragma pack(push, 1)

struct CONSOLE_PUBLIC_KEY
{
    BYTE abPublicExp[CONSOLE_PUBLIC_KEY_EXPONENT_SIZE]; // Big endian
    BYTE abModulus[CONSOLE_PUBLIC_KEY_MODULUS_SIZE];    // QWORD Big endian
};

// This is the new cert that conforms to spec. CONSOLE_CERTIFICATE will eventuall go away
typedef struct _XE_CONSOLE_CERTIFICATE
{
    USHORT              CertSize;                                       // Size of this sturcture (424)
    BYTE                ConsoleId[CONSOLE_ID_SIZE];                    // Uniquely ids console
    BYTE                ConsolePartNumber[CONSOLE_CERT_PART_NUMBER_SIZE];   // Identifies mfg part number
    BYTE                Reserved[CONSOLE_CERTIFICATE_RESERVED_SIZE];   // Reserved for future use
    ULONG               ConsoleType;                                   // States whether console is a retail or dev/test kit
    UINT64              ManufacturingDate;                             // Date of mfg for console
    CONSOLE_PUBLIC_KEY  ConsolePublicKey;                              // Console's Public Key
    BYTE                Signature[CONSOLE_CERTIFICATE_SIGNATURE_SIZE]; // RsaSign(MasterKey.Private, CertSize thru ConsolePublicKey)
} XE_CONSOLE_CERTIFICATE;

typedef struct _XE_CONSOLE_SIGNATURE
{
    XE_CONSOLE_CERTIFICATE Cert;
    BYTE                    Signature[CONSOLE_PUBLIC_KEY_MODULUS_SIZE];
} XE_CONSOLE_SIGNATURE;


#pragma pack(pop)

// ====================================================================
// Common structures for Kerberos pre-auth and authdata
//

#define XBOX_KERBEROS_REALM      "XBOX.COM"
#define MACS_KERBEROS_REALM      "MACS.XBOX.COM"
#define PASSPORT_KERBEROS_REALM  "PASSPORT.NET"

#define XBOX_KERBEROS_REALM_L      L"XBOX.COM"
#define MACS_KERBEROS_REALM_L      L"MACS.XBOX.COM"
#define PASSPORT_KERBEROS_REALM_L  L"PASSPORT.NET"

//
// Xbox special ASN.1 Pre-auth data types
//
#define KRB5_PADATA_XBOX_SERVICE_REQUEST_DEPRACATED   201
#define KRB5_PADATA_XBOX_SERVICE_ADDRESS_DEPRACATED   202
#define KRB5_PADATA_XBOX_ACCOUNT_CREATION             203
#define KRB5_PADATA_XBOX_PPA                          204
#define KRB5_PADATA_XBOX_ECHO                         205
#define KRB5_PADATA_XBOX_CLIENT_VERSION               206
#define KRB5_PADATA_XENON_MAC_REQUEST                 209
#define KRB5_PADATA_XENON_SERVICE_REQUEST2            210
#define KRB5_PADATA_XENON_SERVICE_ADDRESS2            211
#define KRB5_PADATA_PC_ACCOUNT_CREATION               212
#define KRB5_PADATA_PASSPORT_AUTHENTICATION           213
#define KRB5_PADATA_XENON_SERVICE_REQUEST3            214
#define KRB5_PADATA_XENON_SERVICE_ADDRESS3            215
#define KRB5_PADATA_XENON_PPA                         216
#define KRB5_PADATA_XENON_SERVICE_ADDRESS_FAILED      217
#define KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION 218
#define KRB5_PADATA_XENON_MAC_REQUEST2                219
#define KRB5_PADATA_PC_ACCOUNT_CREATION2              220

#define XONLINE_PPA_HASH_SIZE               20

#define XONLINE_PPA2_STORAGE_LENGTH         8

#define XONLINE_CLIENT_VERSION_SIGNATURE_SIZE         20
#define XONLINE_MAX_CLIENT_VERSION_SIZE              128

//
// SALT flags for pre-auth encryption
//
#define KERB_KDC_REQ_NONCE_CKSUM_SALT        1026
#define KERB_PA_CLIENT_VER_SALT              1027
#define KERB_PA_XBOX_SERVICE_REQUEST_SALT    1201
#define KERB_PA_XBOX_SERVICE_ADDRESS_SALT    1202
#define KERB_PA_XBOX_ACCOUNT_CREATION_SALT   1203
#define KERB_PA_PC_ACCOUNT_CREATION_SALT     1204
#define KERB_PA_PC_ACCOUNT_CREATION_REP_SALT 1205
#define KERB_PA_PASSPORT_AUTHENTICATION_SALT 1206

//
// Maximum services per logon
//
#define XONLINE_MAX_NUMBER_SERVICE              16
#define XONLINE_LEGACY_MAX_NUMBER_SERVICE       12
#define XONLINE_MAX_NUMBER_SERVICE_PER_TICKET   12

#define XONLINE_MAX_ALTERNATE_TITLE_ID      4
#define XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID 4
#define XONLINE_MAX_SINGLE_BYTE_SERVICEIDS  12
#define XONLINE_MAX_DWORD_SERVICEIDS        4
#define XONLINE_MAX_SERVICE_ALTERNATE_TITLE_ID  4

//
// Privilege ID Space Definition
//   0 - 127 - Services
// 128 - 159 - Machine Privileges across all users
// 160 - 255 - User Privileges (unique to user)
//
#define XONLINE_MAX_PRIVILEGE_ID                256
#define XONLINE_NUM_PRIVILEGE_DWORDS            (XONLINE_MAX_PRIVILEGE_ID / (sizeof(DWORD)*8) )
#define XONLINE_NUM_PRIVILEGE_BYTES             (XONLINE_MAX_PRIVILEGE_ID / (sizeof(BYTE)*8) )
#define XONLINE_MAX_BASE_SERVICES_ID            128
#define XONLINE_NUM_BASE_SERVICES_DWORDS        (XONLINE_MAX_BASE_SERVICES_ID / (sizeof(DWORD)*8) )
#define XONLINE_NUM_BASE_SERVICES_BYTES         (XONLINE_MAX_BASE_SERVICES_ID / (sizeof(BYTE)*8) )
#define XONLINE_MAX_MACHINE_PRIVILEGES_ID       160
#define XONLINE_NUM_MACHINE_PRIVILEGES_DWORDS   ( (XONLINE_MAX_MACHINE_PRIVILEGES_ID - XONLINE_MAX_BASE_SERVICES_ID) / (sizeof(DWORD)*8) )
#define XONLINE_NUM_MACHINE_PRIVILEGES_BYTES    ( (XONLINE_MAX_MACHINE_PRIVILEGES_ID - XONLINE_MAX_BASE_SERVICES_ID) / (sizeof(BYTE)*8) )
#define XONLINE_NUM_USER_PRIVILEGES_DWORDS      ( (XONLINE_MAX_PRIVILEGE_ID - XONLINE_MAX_MACHINE_PRIVILEGES_ID) / (sizeof(DWORD)*8) )
#define XONLINE_NUM_USER_PRIVILEGES_BYTES       ( (XONLINE_MAX_PRIVILEGE_ID - XONLINE_MAX_MACHINE_PRIVILEGES_ID) / (sizeof(BYTE)*8) )
#define XONLINE_FIRST_USER_PRIVILEGE_DWORD_INDEX     (XONLINE_MAX_MACHINE_PRIVILEGES_ID/(sizeof(DWORD)*8))

#define XENON_SERVICE_STATUS_SUCCESS        ((BYTE) 0) // Equivalent to S_OK
#define XENON_SERVICE_STATUS_OTHER_SITE     ((BYTE) 1) // Equivalent to S_FALSE
#define XENON_SERVICE_STATUS_NOT_AUTHORIZED ((BYTE) 2) // Equivalent to XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED
#define XENON_SERVICE_STATUS_UNAVAILABLE    ((BYTE) 3) // Equivalent to XONLINE_E_LOGON_SERVICE_TEMPORARILY_UNAVAILABLE

// Up to 32 single byte service IDs may be requested in Xenon
#define XONLINE_XE_MAX_BYTE_SERVICEIDS      32
#define XONLINE_XE_MAX_BYTE_SERVICEIDS_2    128

#define BW_HYSTERESIS_MASK      0x000000FF
#define BW_BIT_PER_SEC_MASK     0xFFFFFF00

#define RESERVED_DWORDS_IN_XBOX_PA      8

#define XONLINE_XBOX_DASH_TITLE_ID     0xfffe0000
#define XONLINE_XENON_DASH_TITLE_ID    0xfffe07d1
#define XONLINE_PC_DASH_TITLE_ID       0x585207d1
#define XONLINE_NETFLIX_TITLE_ID       0x584807D5

//
// machine privilege bits
//

#define MPRIVILEGE_MIN                                      128

#define MPRIVILEGE_XONWATCH                                 128
#define MPRIVILEGE_EDITORIAL                                129
#define MPRIVILEGE_NULL_ENCRYPTION                          130
#define MPRIVILEGE_CHALLENGE_BYPASS                         131
#define MPRIVILEGE_GEOFENCE_EXEMPT                          132

#define MPRIVILEGE_MAX                                      160

//
// user privilege bits
//

#define XPRIVILEGE_MAX                                      255
#define XPRIVILEGE_MIN                                      209

// Add Friends
#define XPRIVILEGE_ADD_FRIEND                               255

// Sessions
#define XPRIVILEGE_MULTIPLAYER_SESSIONS                     254
#define XPRIVILEGE_MULTIPLAYER_ENABLED_BY_TIER              253

// Communications
#define XPRIVILEGE_COMMUNICATIONS                           252
#define XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY              251

// sending video messages is restricted by tier and needs a second bit
#define XPRIVILEGE_VIDEO_MESSAGING_SEND                     250

// Profile
#define XPRIVILEGE_PROFILE_VIEWING                          249
#define XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY             248

// Viewing of User Created Content
#define XPRIVILEGE_USER_CREATED_CONTENT                     247
#define XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY        246

// Premium Content Purchases
#define XPRIVILEGE_PURCHASE_CONTENT                         245

// Presence
#define XPRIVILEGE_PRESENCE                                 244
#define XPRIVILEGE_PRESENCE_FRIENDS_ONLY                    243

// Xbox1 Live Access
#define XPRIVILEGE_XBOX1_LIVE_ACCESS                        242

// Cross platform gameplay (PCs <-> Consoles)
#define XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER               241

// Cross platform system communication (PCs <-> Consoles)
#define XPRIVILEGE_CROSS_PLATFORM_SYSTEM_COMMUNICATION      240

// Only users on consoles flagged for selective updates will have this
#define XPRIVILEGE_PREVIOUS_LIVE_PROTOCOLS                  239

// Player-to-player trading
#define XPRIVILEGE_TRADE_CONTENT                            238

// Ability to see and purchase music with explicit content
#define XPRIVILEGE_MUSIC_EXPLICIT_CONTENT                   237

// Ability to test beta Live features
#define XPRIVILEGE_TESTER_ACCESS                            236 // on (allow) | off (disallow)

// Video Communications
#define XPRIVILEGE_VIDEO_COMMUNICATIONS                         235
#define XPRIVILEGE_VIDEO_COMMUNICATIONS_FRIENDS_ONLY            234

// Discoverability - let XBL-Friends send me a WL-Buddy request
#define XPRIVILEGE_SHARE_WLID_WITH_FRIENDS                      233 // on (allow) | off (disallow)

// Discoverability - let WL-Buddies send me an XBL-Friend request
#define XPRIVILEGE_SHARE_GAMERTAG_WITH_BUDDIES                  232 // on (allow) | off (disallow)

#define XPRIVILEGE_METRO_ACCESS                                 231 // on (allow) | off (disallow)

#define XPRIVILEGE_SHARE_FRIENDS_LIST                           230 // on (allow) | off (disallow)
#define XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY              229 // on (allow) | off (disallow)

// Allow passport switching
#define XPRIVILEGE_PASSPORT_SWITCHING                           228 // on (allow) | off (disallow)

// Allow user to manage their payment instruments
#define XPRIVILEGE_BILLING_SWITCHING                            227 // on (allow) | off (disallow)

// Use of dedicated servers for multiplayer games (mainly PCs)
#define XPRIVILEGE_MULTIPLAYER_DEDICATED_SERVER                 226 // on (allow) | off (disallow)

// user has a child account and is eligible to graduate
#define XPRIVILEGE_USER_GRADUATION                              225 // on (allow) | off (disallow)

// access to Netflix app
#define XPRIVILEGE_PREMIUM_VIDEO                                224 // on (allow) | off (disallow)

// access to Xbox Live Primetime (Server-Backed Games)
#define XPRIVILEGE_PRIMETIME                                    223 // on (allow) | off (disallow)

// user can publish content to their console
#define XPRIVILEGE_CONTENT_AUTHOR                               222 // on (allow) | off (disallow)

// user can query user PII
#define XPRIVILEGE_PII_ACCESS                                   221 // on (allow) | off (disallow)

// user can change their social network discoverability
#define XPRIVILEGE_SOCIAL_NETWORKS                              220 // on (allow) | off (disallow)

// user has subscription title privilege
#define XPRIVILEGE_SUBSCRIPTION_TITLE                           219 // true | false

// user has subscription content privilege   
#define XPRIVILEGE_SUBSCRIPTION_CONTENT                         218 // true | false

// purchase privilege can be onbtained with pin
#define XPRIVILEGE_PURCHASE_CONTENT_REQUIRES_PIN                217 // true | false

// passport switching can be obtained with pin
#define XPRIVILEGE_PASSPORT_SWITCHING_REQUIRES_PIN              216 // true | false

// billing switching can be obtain with pin
#define XPRIVILEGE_BILLING_SWITCHING_REQUIRES_PIN               215 // true | false

// user is entitled to premium content
#define XPRIVILEGE_PREMIUM_CONTENT                              214 // true | false

// user is entitled to family subscription functionality (family center)
#define XPRIVILEGE_FAMILY                                       213 // true | false

// unsafe or family programming for the user.
#define XPRIVILEGE_UNSAFE_PROGRAMMING                           212 // on (regular programming) | off (family programming)

// user is allowed to upload content to external providers
#define XPRIVILEGE_SHARE_CONTENT                                211 // on (allow) | off (disallow)

// used by customer support personnel to override default behaviour
#define XPRIVILEGE_SUPPORT_OVERRIDE                             210 // on (allow) | off (disallow)

// user is allowed to save games in cloud storage
#define XPRIVILEGE_CLOUD_SAVED_GAMES                            209 // on (allow) | off (disallow)

#pragma pack(push, 1)

//
// Pre-pre-auth structure sent from client to server during AS request
//
typedef struct _XKERB_PA_XBOX_PPA
{
    FILETIME currentTime;
    BYTE ppa1[XONLINE_PPA_HASH_SIZE];
    BYTE sppa2[XONLINE_PPA_HASH_SIZE];
} XKERB_PA_XBOX_PPA, *PXKERB_PA_XBOX_PPA;

//
// Xbox echo preauth. We send this to the client, it sends it back to us. It is opaque to
// the client.
//
#define XONLINE_MAX_ECHO_PREAUTH_LENGTH     40

typedef struct _XKERB_PA_XBOX_ECHO
{
    union
    {
        struct
        {
            LARGE_INTEGER   liTimestamp;
            DWORD           dwIpAddr;
            BYTE            abRandomBits[3];
            BYTE            checksum;
        };
        BYTE abEncryptedData[16];
    };

    BYTE ComputeChecksum() const
    {
        DWORD ch = 0;
        for (DWORD i = 0; i < sizeof(abEncryptedData) - sizeof(checksum); i++)
        {
            ch += abEncryptedData[i];
        }
        return (BYTE)(ch % 256);
    }

} XKERB_PA_XBOX_ECHO, *PXKERB_PA_XBOX_ECHO;

C_ASSERT(sizeof(XKERB_PA_XBOX_ECHO) <= XONLINE_MAX_ECHO_PREAUTH_LENGTH);

//
// Xbox client version Pre-auth structure sent from client to server during all KDC requests
//
typedef struct _XKERB_PA_XBOX_CLIENT_VERSION
{
    BYTE abSignature[XONLINE_CLIENT_VERSION_SIGNATURE_SIZE];
    char acVersionString[XONLINE_MAX_CLIENT_VERSION_SIZE];
} XKERB_PA_XBOX_CLIENT_VERSION, *PXKERB_PA_XBOX_CLIENT_VERSION;

// The (hopefully) definitive Xenon version of service request preauth.
//
// pa-type is KRB5_PADATA_XENON_SERVICE_REQUEST2
typedef struct _XKERB_PA_XENON_SERVICE_REQUEST2
{
    //#define XONLINE_SERVICE_REQUEST_VERSION 4
    WORD                    wServiceRequestVersion;
    WORD                    wServiceRequestSize;
    XBOX_LIBRARY_VERSION    clientVersion;
    DWORD                   dwFlashVersion;
    DWORD                   dwTitleID;
    DWORD                   dwTitleVersion;
    DWORD                   dwTitleRegion;
    DWORD                   dwConsoleRegion;
    DWORD                   dwMediaID;
    WORD                    wLanguageID;
    WORD                    wAutoDiscoverServices;
    //
    // Specifies the qwUserIDs in the order that they should be in
    // the returned XKERB_PA_XENON_SERVICE_ADDRESS and XKERB_AD_XBOX.
    // The Xbox KDC will check that the qwUserIDs in this list
    // are all specified in the TGT.
    //
    ULONGLONG               qwUserID[XONLINE_MAX_LOGON_USERS];

    WORD                    wNumByteServices;
    WORD                    wNumDwordServices;
    BYTE                    bServiceID[XONLINE_XE_MAX_BYTE_SERVICEIDS];
    DWORD                   dwServiceID[XONLINE_MAX_DWORD_SERVICEIDS];
} XKERB_PA_XENON_SERVICE_REQUEST2, *PXKERB_PA_XENON_SERVICE_REQUEST2;

#define XONLINE_SERVICE_REQUEST2_MIN_VERSION    4
#define XONLINE_SERVICE_REQUEST2_MAX_VERSION    4


// Wrapper for flow tokens. May have value added later.
typedef struct _FLOKEN
{
    ULONGLONG   flowToken;

    BOOL IsValid() { return flowToken != 0; }

} FLOKEN;

// The xenon version of the service request rev'ed to use pin authentication
//
// pa-type is KRB5_PADATA_XENON_SERVICE_REQUEST3
#define XONLINE_XE_NUM_BYTES_FOR_BYTE_SERVICES_REQUEST (XONLINE_XE_MAX_BYTE_SERVICEIDS_2/8)
// This is a really lame define...
typedef struct _XKERB_PA_XENON_SERVICE_REQUEST3
{
    //#define XONLINE_SERVICE_REQUEST_VERSION 5
    WORD                    wServiceRequestVersion;
    XBOX_LIBRARY_VERSION    clientVersion;
    DWORD                   dwFlashVersion;
    DWORD                   dwTitleID;
    DWORD                   dwTitleVersion;
    DWORD                   dwTitleRegion;
    DWORD                   dwConsoleRegion;
    DWORD                   dwMediaID;
    WORD                    wLanguageID;
    WORD                    wAutoDiscoverServices;
    ULONGLONG               qwUserID[XONLINE_MAX_LOGON_USERS];
    BYTE                    bServiceIDBits[XONLINE_XE_NUM_BYTES_FOR_BYTE_SERVICES_REQUEST];          //one bit per service id, in order (128 total)
    DWORD                   dwServiceID[XONLINE_MAX_DWORD_SERVICEIDS];
    DWORD                   dwReservedForUserPINInTheFuture[XONLINE_MAX_LOGON_USERS];
    FLOKEN                  flowToken;
} XKERB_PA_XENON_SERVICE_REQUEST3, *PXKERB_PA_XENON_SERVICE_REQUEST3;

#define XONLINE_SERVICE_REQUEST3_MIN_VERSION              5
#define XONLINE_SERVICE_REQUEST3_ROAMING_PROFILES_VERSION 6
#define XONLINE_SERVICE_REQUEST3_MAX_VERSION              65535

typedef struct _XKERB_PA_XENON_SERVICE_RESULT
{
    DWORD       dwServiceID;
    WORD        wServicePort;
    BYTE        bResult;        // XENON_SERVICE_STATUS_*
} XKERB_PA_XENON_SERVICE_RESULT;

typedef struct _XKERB_PA_XENON_SINGLE_BYTE_SERVICE_RESULT
{
    BYTE        bServiceID;
    WORD        wServicePort;
    BYTE        bResult;        // XENON_SERVICE_STATUS_*
} XKERB_PA_XENON_SINGLE_BYTE_SERVICE_RESULT;

typedef struct _XKERB_PA_XENON_MAC_REQUEST
{
    BYTE   abEncSessionKey[256];        // RsaEncrypt(XmacsKey, SessionKey);
    UINT64 qwAuthtime;                  // Authtime
    BYTE   abSignAtSk[128];             // RsaSign(ConsoleXenonKey, qwAuthtime | Sha1(SessionKey))
    XE_CONSOLE_CERTIFICATE ConsoleCert; // Console certificate
} XKERB_PA_XENON_MAC_REQUEST;

//
// Some base service IDs (e.g. matchmaking, content download) may be
// remapped to an alternate title ID.
//
typedef struct _XKERB_PA_XBOX_SERVICE_ALTERNATE_TITLE_ID
{
    BYTE        bServiceID;
    DWORD       dwAltTitleID;
} XKERB_PA_XBOX_SERVICE_ALTERNATE_TITLE_ID;


// pa-type is KRB5_PADATA_XENON_SERVICE_ADDRESS2
typedef struct _XKERB_PA_XENON_SERVICE_ADDRESS2
{
    HRESULT     hr;
    HRESULT     hrUser[XONLINE_MAX_LOGON_USERS];
    // The high 16 bits of dwUserFlags should come from the UODB User Table.
    DWORD       dwUserFlags[XONLINE_MAX_LOGON_USERS];
    DWORD       dwBwLimit;
    IN_ADDR     siteIPAddress;
    DWORD       dwUserPrivileges[XONLINE_MAX_LOGON_USERS][XONLINE_NUM_PRIVILEGE_DWORDS];
    WORD        wNumServices;
    XKERB_PA_XENON_SINGLE_BYTE_SERVICE_RESULT byteServiceResult[XONLINE_XE_MAX_BYTE_SERVICEIDS];
    XKERB_PA_XENON_SERVICE_RESULT dwordServiceResult[XONLINE_MAX_DWORD_SERVICEIDS];
    DWORD       dwLiveTitleId;
    XKERB_PA_XBOX_SERVICE_ALTERNATE_TITLE_ID altLiveTitleIds[XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID];
} XKERB_PA_XENON_SERVICE_ADDRESS2, *PXKERB_PA_XENON_SERVICE_ADDRESS2;

//
// New response supports flow tokens and 128 base services (soon).
//
// pa-type is KRB5_PADATA_XENON_SERVICE_ADDRESS3
// We now store byte services as a set of two-bit values, meaning a byte can store four of them.
#define XONLINE_XE_NUM_BYTES_FOR_BYTE_SERVICES_ADDRESS (XONLINE_XE_MAX_BYTE_SERVICEIDS_2/4)
typedef struct _XKERB_PA_XENON_SERVICE_ADDRESS3
{
    HRESULT     hr;
    HRESULT     hrUser[XONLINE_MAX_LOGON_USERS];
    DWORD       dwUserFlags[XONLINE_MAX_LOGON_USERS];
    IN_ADDR     siteIPAddress;
    DWORD       dwUserPrivileges[XONLINE_MAX_LOGON_USERS][XONLINE_NUM_USER_PRIVILEGES_DWORDS];  //96 bits of privileges per user
    DWORD       dwMachinePrivileges;
    BYTE        byteServiceResult[XONLINE_XE_NUM_BYTES_FOR_BYTE_SERVICES_ADDRESS];   //one two-bit-nibble per service id, in order (128 total)
    XKERB_PA_XENON_SERVICE_RESULT               dwordServiceResult[XONLINE_MAX_DWORD_SERVICEIDS];
    DWORD       dwLiveTitleId;
    XKERB_PA_XBOX_SERVICE_ALTERNATE_TITLE_ID    altLiveTitleIds[XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID];
    FLOKEN   flowToken;
} XKERB_PA_XENON_SERVICE_ADDRESS3, *PXKERB_PA_XENON_SERVICE_ADDRESS3;

// pa-type is KRB5_PADATA_XENON_PPA
typedef struct _XKERB_PA_XENON_PPA
{
    BYTE         abConsoleCertHash[XONLINE_PPA_HASH_SIZE];
} XKERB_PA_XENON_PPA, *PXKERB_PA_XENON_PPA;

// pa-type is KRB5_PADATA_XENON_SERVICE_ADDRESS_FAILED
typedef struct _XKERB_PA_XENON_SERVICE_ADDRESS_FAILED
{
    HRESULT      hrConsole;
    HRESULT      hrUser[XONLINE_MAX_LOGON_USERS];
    FILETIME     ftConsoleBanExpireTime;
    FILETIME     ftUserBanExpireTime[XONLINE_MAX_LOGON_USERS];
} XKERB_PA_XENON_SERVICE_ADDRESS_FAILED, *PXKERB_PA_XENON_SERVICE_ADDRESS_FAILED;

// pa-type is KRB5_PADATA_XENON_MAC_REQUEST2          
typedef struct _XKERB_PA_XENON_MAC_REQUEST2
{
    BYTE   abEncSessionKey[256];                                  // RsaEncrypt(XmacsKey, SessionKey);
    UINT64 qwAuthtime;                                            // Authtime
    BYTE   abSerialNum[XONLINE_MAX_CONSOLE_SERIAL_NUMBER_LENGTH]; // SerialNumber
    BYTE   abSignAtSk[128];                                       // RsaSign(ConsoleXenonKey, qwAuthtime | SerialNumber | Sha1(SessionKey))
    XE_CONSOLE_CERTIFICATE ConsoleCert;                           // Console certificate
} XKERB_PA_XENON_MAC_REQUEST2;

//
// Pre-auth structure sent back from MACS server
// for newly created machine account
// Encrypted with online key
//
typedef struct _XKERB_PA_XBOX_ACCOUNT_CREATION
{
    ULONGLONG qwUserID;
    CHAR gamertag[XONLINE_GAMERTAG_SIZE];
    CHAR domain[XONLINE_USERDOMAIN_SIZE];
    CHAR kerberosRealm[XONLINE_KERBEROSREALM_SIZE];
    BYTE key[XONLINE_KEY_LENGTH];
} XKERB_PA_XBOX_ACCOUNT_CREATION, *PXKERB_PA_XBOX_ACCOUNT_CREATION;

#define KERB_AUTH_DATA_XBOX     200
#define KERB_AUTH_DATA_XENON    300
#define KERB_AUTH_DATA_XENON2   400

//
// auth-data structure (version 2)
//
typedef struct _XKERB_AD_XBOX2
{
    #define XONLINE_AUTHDATA_VERSION 2
    WORD                     wAuthDataVersion;
    WORD                     wAuthDataSize;
    XBOX_LIBRARY_VERSION     clientVersion;
    DWORD                    dwTitleID;
    DWORD                    dwTitleVersion;
    DWORD                    dwTitleRegion;
    ULONGLONG                qwXboxID;
    // The high 16 bits of dwUserFlags should come from the UODB User Table.
    XUID                     users[XONLINE_MAX_LOGON_USERS];
    DWORD                    dwNumServices;
    DWORD                    dwServiceID[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];
    FLOAT                    afltTrustFactor[XONLINE_MAX_LOGON_USERS];
    DWORD                    dwAltTitleID[XONLINE_MAX_ALTERNATE_TITLE_ID];
    BYTE                     abKey[XONLINE_KEY_LENGTH];
} XKERB_AD_XBOX2, *PXKERB_AD_XBOX2;

typedef struct _XKERB_AD_XBOX_WITH_SIGNATURE2
{
    BYTE                     ServerSignature[XONLINE_KEY_LENGTH];
    XKERB_AD_XBOX2           authData;
} XKERB_AD_XBOX_WITH_SIGNATURE2, *PXKERB_AD_XBOX_WITH_SIGNATURE2;

//
// Xenon auth-data structure (version 3)
//
#define XONLINE_AUTHDATA_FLAGS_ISXENON           0x01   // Legacy
#define XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT 0x02   // Xbox 360 in back-compat mode
#define XONLINE_AUTHDATA_FLAGS_ISDEVKIT          0x04   // Xbox 360 devkit (console cert contains CONSOLE_CERTIFICATE_TYPE_DEVKIT flag)
#define XONLINE_AUTHDATA_FLAGS_ISTESTKIT         0x08   // Xbox 360 testkit (console cert contains CONSOLE_CERTIFICATE_TYPE_TESTKIT flag)
#define XONLINE_AUTHDATA_FLAGS_ISBETAMACHINE     0x10   // Machine marked for beta (t_machines.i_beta_title_id != 0)
#define XONLINE_AUTHDATA_FLAGS_ISLIMITEDMACHINE  0x20   // Limited machine account (currently only used for PC's)

typedef struct _XKERB_AD_XENON
{
    #define XONLINE_XENON_AUTHDATA_VERSION 3
    WORD                     wAuthDataVersion;
    WORD                     wAuthDataSize;
    XBOX_LIBRARY_VERSION     clientVersion;
    DWORD                    dwTitleID;
    DWORD                    dwTitleVersion;
    DWORD                    dwTitleRegion;
    DWORD                    dwConsoleRegion;
    DWORD                    dwMediaID;
    WORD                     wLanguageID;
    DWORD                    dwAuthDataFlags;
    WORD                     wNumPrivileges;
    DWORD                    dwPrivileges[XONLINE_NUM_PRIVILEGE_DWORDS];

    ULONGLONG                qwXboxID;
    // The high 16 bits of dwUserFlags should come from the UODB User Table.
    XUID                     users[XONLINE_MAX_LOGON_USERS];
    FLOAT                    afltTrustFactor[XONLINE_MAX_LOGON_USERS];
    WORD                     wNumDwordServices;
    DWORD                    dwServiceID[XONLINE_MAX_DWORD_SERVICEIDS];
    DWORD                    dwAltTitleID[XONLINE_MAX_ALTERNATE_TITLE_ID];
    BYTE                     abKey[XONLINE_KEY_LENGTH];
} XKERB_AD_XENON, *PXKERB_AD_XENON;

typedef struct _XKERB_AD_XENON_WITH_SIGNATURE
{
    BYTE                     ServerSignature[XONLINE_KEY_LENGTH];
    XKERB_AD_XENON           authData;
} XKERB_AD_XENON_WITH_SIGNATURE, *PXKERB_AD_XENON_WITH_SIGNATURE;

//
// Xenon2  auth-data structure
//
// Note that this structure is exactly 256 bytes in size.
//
typedef struct _XKERB_AD_XENON2
{
    #define XONLINE_XENON2_AUTHDATA_VERSION 4
    WORD                     wAuthDataVersion;
    WORD                     wAuthDataSize;
    XBOX_LIBRARY_VERSION     clientVersion;
    DWORD                    dwAuthDataFlags;
    ULONGLONG                qwXboxID;
    FLOAT                    fltConsoleTrustFactor;
    DWORD                    dwTitleID;
    DWORD                    dwTitleVersion;
    DWORD                    dwTitleRegion;
    DWORD                    dwConsoleRegion;
    DWORD                    dwMediaID;
    WORD                     wLanguageID;
    WORD                     wNumExtendedServices;
    DWORD                    dwExtendedServices[XONLINE_MAX_DWORD_SERVICEIDS]; // This is *not* a bitmask of services
    XUID                     users[XONLINE_MAX_LOGON_USERS];
    FLOAT                    afltTrustFactor[XONLINE_MAX_LOGON_USERS];
    DWORD                    dwBaseServices[XONLINE_NUM_BASE_SERVICES_DWORDS];                              // This is a bitmask of services
    DWORD                    dwMachinePrivileges[XONLINE_NUM_MACHINE_PRIVILEGES_DWORDS];                    // This is a bitmask of privileges
    DWORD                    dwUserPrivileges[XONLINE_MAX_LOGON_USERS][XONLINE_NUM_USER_PRIVILEGES_DWORDS]; // This is a bitmask of privileges
    DWORD                    dwAltTitleID[XONLINE_MAX_ALTERNATE_TITLE_ID];
    FLOKEN                   flowToken;
    BYTE                     abReserved[16];  // 24 - sizeof(flowToken)
    BYTE                     abKey[XONLINE_KEY_LENGTH];
} XKERB_AD_XENON2, *PXKERB_AD_XENON2;

// Corresponds with comment above, though this is a totally arbitrary decision.
C_ASSERT(sizeof(XKERB_AD_XENON2) == 256);

typedef struct _XKERB_AD_XENON2_WITH_SIGNATURE
{
    BYTE                     ServerSignature[XONLINE_KEY_LENGTH];
    XKERB_AD_XENON2          authData;
} XKERB_AD_XENON_WITH_SIGNATURE2, *PXKERB_AD_XENON_WITH_SIGNATURE2;

// Specifies the user trust relationship with the console
typedef enum {
    XONLINE_USER_MACHINE_TRUST_LEVEL_UNKNOWN_MACHINE = -2,
    XONLINE_USER_MACHINE_TRUST_LEVEL_NOT_TRUSTED = 0, 
    XONLINE_USER_MACHINE_TRUST_LEVEL_TRUSTED = 1,
} XONLINE_USER_MACHINE_TRUST_LEVEL;

#pragma pack(pop)

// ---------------------------------------------------------------------------------------
// XB/SG/Server shared definitions
// ---------------------------------------------------------------------------------------

#ifdef __cplusplus

#include <pshpack1.h>

struct CQVal
{
    // Definitions -----------------------------------------------------------------------

    #define QVAL_QFLAGS                         QVAL(0, 1)  // Payload is dwQFlags
    #define QVAL_NEW_GAME_INVITE                QVAL(2, 0)  // Boolean (no extra data)
    #define QVAL_NEW_MSG_IDS                    QVAL(3, 3)  // 3 DWORDs of the last 3 message IDs that arrived
    #define QVAL_NEW_MSG_DATA                   QVAL(7, 3)  // 3 DWORDs of data for the last 3 messages that arrived
    #define QVAL_MSG_DELETED                    QVAL(11,3)  // 3 DWORDs of the last 3 messages deleted
    #define QVAL_MAX                            QVAL_MSG_DELETED
    #define QVAL_COUNT                          QVAL_INDEX_NEXT(QVAL_MAX)

    #define QVAL(idx, size)                     (((idx) << QVAL_INDEX_SHIFT) | (size))
    #define QVAL_INDEX(qval)                    (((qval) & QVAL_INDEX_MASK) >> QVAL_INDEX_SHIFT)
    #define QVAL_DSIZE(qval)                    (((qval) & QVAL_DSIZE_MASK))
    #define QVAL_INDEX_NEXT(qval)               (QVAL_INDEX(qval) + 1 + QVAL_DSIZE(qval))
    #define QVAL_SEQ(qval)                      (((qval) & QVAL_SEQ_MASK) >> QVAL_SEQ_SHIFT)

    #define QVAL_DSIZE_MASK     0x00000003      // Payload size in DWORDs
    #define QVAL_INDEX_MASK     0x0000007C      // Index of this value in vector of CQVal
    #define QVAL_BOOL_MASK      0x00000080      // Boolean value (for when there is no payload)
    #define QVAL_SEQ_MASK       0xFFFFFF00      // Sequence number associated with value

    #define QVAL_INDEX_SHIFT    2               // How far left to shift index
    #define QVAL_SEQ_SHIFT      8               // How far left to shift sequence number

    // Data ------------------------------------------------------------------------------

    DWORD           _dw;                            // Sequence | Bool | Index | Size

};


struct CAuthData2 : public XKERB_AD_XBOX2
{
    UINT            GetCb()             { return(wAuthDataSize); }
    void            SetCb(UINT cb)      { wAuthDataSize = (WORD)cb; }
};


struct CAuthData3 : public XKERB_AD_XENON
{
    UINT            GetCb()             { return(wAuthDataSize); }
    void            SetCb(UINT cb)      { wAuthDataSize = (WORD)cb; }
    BOOL            IsSvcAuthorized(DWORD dwSvcId)
    {
        if( 0 == dwSvcId )
        {
            return FALSE;
        }
        else if( dwSvcId < 32 )
        {
            return dwPrivileges[ 0 ] & ( 1 << dwSvcId );
        }
        else
        {
            for( DWORD iSvc = 0; iSvc < wNumDwordServices; iSvc++ )
            {
                if( dwSvcId == dwServiceID[ iSvc ] )
                {
                    return TRUE;
                }
            }
            return FALSE;
        }
    }

    // Returns the platform type associated with the authdata
    BYTE GetPlatform()
    {
        if(IS_XBOX_MACHINE_PUID(this->qwXboxID) ||
           (this->dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT))
        {
            return XPLT_XBOX1;
        }
        else if(IS_XENON_MACHINE_PUID(this->qwXboxID))
        {
            return XPLT_XBOX360;
        }
        else if(IS_PC_MACHINE_PUID(this->qwXboxID))
        {
            return XPLT_PC;
        }
        else if(IS_PC_MOBILE_PUID(this->qwXboxID))
        {
            return XPLT_MOBILE;
        }
        else
        {
            return 0;
        }
    }

    // Returns the client version as a DWORD
    DWORD GetClientVersion()
    {
        return CLIENTVERSION_TO_DWORD(clientVersion);
    }

    DWORD GetNumUsers()
    {
        DWORD c = 0;
        c += (users[0].qwUserID == 0) ? 0 : 1;
        c += (users[1].qwUserID == 0) ? 0 : 1;
        c += (users[2].qwUserID == 0) ? 0 : 1;
        c += (users[3].qwUserID == 0) ? 0 : 1;
        return c;
    }

};

struct CAuthData4 : public XKERB_AD_XENON2
{
    UINT            GetCb()             { return(wAuthDataSize); }
    void            SetCb(UINT cb)      { wAuthDataSize = (WORD)cb; }
    BOOL            IsSvcAuthorized(DWORD dwSvcId)
    {
        if( 0 == dwSvcId )
        {
            return FALSE;
        }
        else if( dwSvcId < 32 )
        {
            return dwBaseServices[ 0 ] & ( 1 << dwSvcId );
        }
        else
        {
            for( DWORD iSvc = 0; iSvc < wNumExtendedServices; iSvc++ )
            {
                if( dwSvcId == dwExtendedServices[ iSvc ] )
                {
                    return TRUE;
                }
            }
            return FALSE;
        }
    }

    // Returns the platform type associated with the authdata
    BYTE GetPlatform()
    {
        if(IS_XBOX_MACHINE_PUID(this->qwXboxID) ||
           (this->dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT))
        {
            return XPLT_XBOX1;
        }
        else if(IS_XENON_MACHINE_PUID(this->qwXboxID))
        {
            return XPLT_XBOX360;
        }
        else if(IS_PC_MACHINE_PUID(this->qwXboxID))
        {
            return XPLT_PC;
        }
        else if(IS_PC_MOBILE_PUID(this->qwXboxID))
        {
            return XPLT_MOBILE;
        }
        else
        {
            return 0;
        }
    }

    // Returns the client version as a DWORD
    DWORD GetClientVersion()
    {
        return CLIENTVERSION_TO_DWORD(clientVersion);
    }

    DWORD GetNumUsers()
    {
        DWORD c = 0;
        c += (users[0].qwUserID == 0) ? 0 : 1;
        c += (users[1].qwUserID == 0) ? 0 : 1;
        c += (users[2].qwUserID == 0) ? 0 : 1;
        c += (users[3].qwUserID == 0) ? 0 : 1;
        return c;
    }
};

struct CKeyExHdr
{
    // Definitions (0x58 is 'X') ---------------------------------------------------------

    #define KEYEX_VERSION           0x0000  // Current KeyEx version

    #define KEYEX_TYPE_XBTOXB_INIT  0x5800  // CKeyExXbToXb | DH_GX | HMAC_SHA
    #define KEYEX_TYPE_XBTOXB_RESP  0x5801  // CKeyExXbToXb | DH_GX | HMAC_SHA
    #define KEYEX_TYPE_XBTOSG_INIT  0x5802  // CKeyExXbToSgInit | DH_GX | APREQ
    #define KEYEX_TYPE_SGTOXB_RESP  0x5803  // CKeyExSgToXbResp | DH_GX | APREP
    #define KEYEX_TYPE_NATOPEN_INIT 0x5804  // CKeyExNatOpen
    #define KEYEX_TYPE_NATOPEN_RESP 0x5805  // CKeyExNatOpen
    #define KEYEX_TYPE_QOS_INIT     0x5806  // CKeyExQosInit
    #define KEYEX_TYPE_QOS_RESP     0x5807  // CKeyExQosResp
    #define KEYEX_TYPE_XBTOTS_INIT  0x5808  // CKeyExXbToTs | APREQ
    #define KEYEX_TYPE_TSTOXB_RESP  0x5809  // CKeyExTsToXb | APREP

    #define KEYEX_TYPE_DH_GX        0x5880  // diffie-hellman g^X (or g^Y)
    #define KEYEX_TYPE_HMAC_SHA     0x5881  // HMAC-SHA-1 digest (XbToXb)
    #define KEYEX_TYPE_KERB_APREQ   0x5882  // CKeyExKerbApReq (XbToSg)
    #define KEYEX_TYPE_KERB_APREP   0x5883  // CKeyExKerbApRep (SgToXb)
    #define KEYEX_TYPE_NULL_APREQ   0x5884  // CKeyExNullApReq (XbToSg; insecure; test only)
    #define KEYEX_TYPE_NULL_APREP   0x5885  // CKeyExNullApRep (SgToXb; insecure; test only)
    #define KEYEX_TYPE_PADDING      0x5886  // random padding to make packet larger
    #define KEYEX_TYPE_SGTOXB_CHAL  0x5887  // CKeyExSgToXbChal

    // Data --------------------------------------------------------------------------

    WORD            _wType;             // See KEYEX_TYPE_* above
    WORD            _cbEnt;             // Size of this entry (including header)
};

struct CKeyExXbToSgInit : public CKeyExHdr
{
    // Definitions -----------------------------------------------------------------------

    #define XSIF_CONNECTION_SERVICE     0x0001  // Initiator requests connection service

    #define KEYEX_USER_GUEST_MASK         0x1F
    #define KEYEX_USER_PERMUTE_MASK       0x20
    #define KEYEX_USER_PERMUTATION_SHIFT     6

    // Data ------------------------------------------------------------------------------

    WORD            _wVersion;                  // KEYEX_VERSION
    WORD            _wFlags;                    // See XSIF_* above
    DWORD           _dwSpiInit;                 // SPI of the initiator
    BYTE            _abNonceInit[8];            // Nonce of the initiator
    DWORD           _dwUserPerm;                // Permutation and guest bits for all 4 users
};

struct CKeyExSgToXbResp : public CKeyExHdr
{
    // Definitions -----------------------------------------------------------------------

    #define SXRF_ENCRYPT_DES            0x0001  // SG wants DES encryption
    #define SXRF_ENCRYPT_3DES           0x0002  // SG wants 3DES encryption
    #define SXRF_ENCRYPT_AES            0x0004  // SG wants AES encryption
    #define SXRF_ENCRYPT_NULL           0x0008  // SG wants no encryption

    // Data ------------------------------------------------------------------------------

    WORD            _wVersion;                  // KEYEX_VERSION
    WORD            _wFlags;                    // See SXRF_* above
    DWORD           _dwSpiInit;                 // SPI of the initiator
    DWORD           _dwSpiResp;                 // SPI of the responder
    BYTE            _abNonceInit[8];            // Nonce of the initiator
    BYTE            _abNonceResp[8];            // Nonce of the responder

    // Note that everything from here down must be a multiple of 16 bytes and is encrypted
    // using the negotiated 3DES key and _abNonceResp as the IV.

    SGADDR          _sgaddrInit;                // SGADDR assigned to the initiator
    IN_ADDR         _inaInit;                   // IP address of initiator (as seen by SG)
    WORD            _wPortInit;                 // IP port of initiator (as seen by SG)
    WORD            _wXbToSgTimeoutInSecs;      // Secs of no inbound data/pulse before disconnecting
    WORD            _wXbToSgPulseTimeoutInSecs; // Secs of no outbound data/pulse before sending SECMSG_TYPE_XBTOSG_PULSE
    WORD            _wPadZero;                  // To make the encrypted area a multiple of 16 bytes
};

struct CKeyExXbToTsInit : public CKeyExHdr
{
    WORD            _wVersion;                  // KEYEX_VERSION
    WORD            _wFlags;                    // See XSIF_* above
    XNKID           _xnkid;                     // key identifier of key-exchange-key
    DWORD           _dwSpiInit;                 // SPI of the initiator
    BYTE            _abNonceInit[8];            // Nonce of the initiator
    DWORD           _dwUserPerm;                // Permutation and guest bits for all 4 users
};

struct CKeyExTsToXbResp : public CKeyExHdr
{
    WORD            _wVersion;                  // KEYEX_VERSION
    WORD            _wFlags;                    // See SXRF_* above
    DWORD           _dwSpiInit;                 // SPI of the initiator
    DWORD           _dwSpiResp;                 // SPI of the responder
    BYTE            _abNonceInit[8];            // Nonce of the initiator
    BYTE            _abNonceResp[8];            // Nonce of the responder
    WORD            _wXbToTsTimeoutInSecs;      // Secs of no inbound data/pulse before disconnecting
    WORD            _wXbToTsPulseTimeoutInSecs; // Secs of no outbound data/pulse before sending SECMSG_TYPE_PULSE

};

struct CKeyExKerbApReq : public CKeyExHdr
{
    // Definitions -----------------------------------------------------------------------

    #define CBKERBAPREQ            1300         // Maximum size of Kerberos Ap request

    // Data ------------------------------------------------------------------------------

    BYTE            _ab[CBKERBAPREQ];           // Kerberos AP request
};

struct CKeyExKerbApRep : public CKeyExHdr
{
    // Definitions -----------------------------------------------------------------------

    #define CBKERBAPREP             800         // Maximum size of Kerberos Ap reply

    // Data ------------------------------------------------------------------------------

    BYTE            _ab[CBKERBAPREP];           // Kerberos AP reply
};

// Used for SG testing
struct CKeyExNullApReq : public CKeyExHdr
{
    BYTE            _abSha[20];                 // SHA of the rest of key-exchange message
    LARGE_INTEGER   _liTime;                    // Authenticator time of client
    CAuthData3      _AuthData;                  // AuthData of client
};

// Used for SG testing
struct CKeyExNullApRep : public CKeyExHdr
{
    BYTE            _abSha[20];                 // SHA of the rest of key-exchange message
};

struct CKeyExSgToXbChal : public CKeyExHdr
{
    DWORD           _dwDvdBlock;                // DVD block to read
    WORD            _ibDvdHash;                 // Offset in block to start hashing
    WORD            _ibDvdCopy;                 // Offset in block to start copying
    BYTE            _abParams[16];              // Challenge parameters
    BYTE            _abPkSig[256];              // Digest of the rest of this entry

    // The rest of this entry is filled with challenge code that needs to be run
    // on the challenged xbox.  The result of running the code will be to modify
    // the 256 bytes immediately preceeding it (where the _abPkSig is above).
    // The size of the entry must be a multiple of 8 bytes because it is encrypted
    // during transport.
};

struct CSecMsgHdr
{
    // Definitions (0x53 is 'S') ---------------------------------------------------------

    #define SECMSG_TYPE_DELETE              0x5300  // CSecMsgDelete
    #define SECMSG_TYPE_PULSE               0x5301  // CSecMsgPulse
    #define SECMSG_TYPE_XBTOSG_PULSE        0x5302  // CSecMsgXbToSgPulse
    #define SECMSG_TYPE_SGTOXB_PULSE        0x5303  // CSecMsgSgToXbPulse (Obsolete)
    #define SECMSG_TYPE_XBTOXB_FORWARD      0x5304  // CSecMsgXbToXbForward
    #define SECMSG_TYPE_CHANGE_USERS_REQ    0x5305  // CSecMsgChangeUsersReq
    #define SECMSG_TYPE_CHANGE_USERS_REP    0x5306  // CSecMsgChangeUsersRep
    #define SECMSG_TYPE_XBTOSG_QOS_INIT     0x5307  // CSecMsgXbToSgQosInit
    #define SECMSG_TYPE_SGTOXB_QOS_RESP     0x5308  // CSecMsgSgToXbQosResp
    #define SECMSG_TYPE_SGTOXB_PULSE_2      0x5309  // CSecMsgSgToXbPulse
    #define SECMSG_TYPE_XBTOSG_CHALRESP     0x530A  // CSecMsgXbToSgChalResp
    #define SECMSG_TYPE_XBTOSG_NATDET_REQ   0x530B  // No payload
    #define SECMSG_TYPE_SGTOXB_NATDET_REP   0x530C  // No payload
    #define SECMSG_TYPE_CHANGE_USERS_NULL   0x530D  // CSecMsgChangeUsersReq; insecure; test only
    #define SECMSG_TYPE_SGTOXB_CHAL         0x530E  // CSecMsgSgToXbChal
    #define SECMSG_TYPE_XBTOSG_CHALRESP_2   0x530F  // CSecMsgXbToSgChalResp2
    #define SECMSG_TYPE_XBTOSG_CHAL_ACK     0x5310  // CSecMsgXbToSgChalAck
    #define SECMSG_TYPE_SGTOXB_CHALRESP_ACK 0x5311  // CSecMsgSgToXbChalRespAck
    #define SECMSG_TYPE_XBTOXB_FORWARD2     0x5312  // CSecMsgXbToXbForward2
    #define SECMSG_TYPE_XBTOSG_CHALRESP_3   0x5313  // CSecMsgXbToSgChalResp3 


    // Data ------------------------------------------------------------------------------

    WORD            _wType;                     // See SECMSG_TYPE_* above
    WORD            _cbEnt;                     // Size of this entry (including header)
};

struct CSecMsgDelete : public CSecMsgHdr
{
    // Definitions -----------------------------------------------------------------------

    #define SECMSG_DELETE_SHUTDOWN      0x0000  // Client is shutting down or logging off
    #define SECMSG_DELETE_UNREGISTER    0x0001  // Client unregistered key
    #define SECMSG_DELETE_KICK          0x0002  // Client has been kicked for duplicate logon
    #define SECMSG_DELETE_QOS           0x0003  // Client finished Qos lookup
    #define SECMSG_DELETE_KILL          0x0004  // Server is terminating the session

    // Data ------------------------------------------------------------------------------

    DWORD           _dwReason;                  // See SECMSG_DELETE_* above

};

struct CSecMsgPulse : public CSecMsgHdr
{
    // No additional data members
};

struct CSecMsgXbToSgPulse : public CSecMsgHdr
{
    // Definitions -----------------------------------------------------------------------

    #define XBPULSE_STATE_CHANGE        0x01    // dwUserState changed
    #define XBPULSE_XNKID_CHANGE        0x02    // xnkidSession changed
    #define XBPULSE_TDATA_CHANGE        0x04    // abTitleData changed
    #define XBPULSE_TITLE_CHANGE        0x08    // dwTitleId changed

    // Data ------------------------------------------------------------------------------

    DWORD           _dwSeqAck;                  // Acknowledgement sequence number

    // The rest of this entry is filled with a padded series of changes.
    //
    // Byte 0    - change type
    // Byte 1-8  - user PUID
    //
    // Type XBPULSE_STATE_CHANGE:
    // Byte 9-12 - new state
    //
    // Type XBPULSE_XNKID_CHANGE:
    // Byte 9-16 - new XNKID
    //
    // Type XBPULSE_TDATA_CHANGE:
    // Byte 9    - size in bytes of title data
    // Byte 10-x - new title data
    //
    // Type XBPULSE_TITLE_CHANGE:
    // Byte 9-12 - new title ID
};

struct CSecMsgSgToXbPulse : public CSecMsgHdr
{
    DWORD           _dwSeqAck;                  // Acknowledgement sequence number

    // The rest of this entry contains a series of _qwUserId / CQVal-list pairs.
    // The end of the CQVal list specified by a zero DWORD or the end of this
    // entry, whichever comes first.
};

struct CSecMsgXbToXbForward : public CSecMsgHdr
{
    SGADDR          _sgaddr;                    // SGADDR of the target client

    // The rest of this entry contains the actual message being forwarded.
};

struct CSecMsgXbToXbForward2 : public CSecMsgHdr
{
    SGADDR          _sgaSender;              // SGADDR of the sender client
    SGADDR          _sgaTarget;              // SGADDR of the target client

    // The rest of this entry contains the actual message being forwarded.
};

struct CSecMsgChangeUsersReq : public CSecMsgHdr
{
    DWORD           _dwUserPerm;                // Permutation and guest bits for all 4 users
    LARGE_INTEGER   _liTime;                    // Kerberos time of AP request

    // The rest of this entry contains the Kerberos AP request.
};

struct CSecMsgChangeUsersRep : public CSecMsgHdr
{
    LARGE_INTEGER   _liTime;                    // Kerberos time of corresponding request
};

struct CSecMsgXbToSgQosInit : public CSecMsgHdr
{
    BYTE            _abNonce[8];        // Nonce assigned by the initiator
    WORD            _wQosIdx;           // Index assigned by the initiator
    BYTE            _bPktIdx;           // Packet sequence number
    BYTE            _bFlags;            // See QPF_* below
};

struct CSecMsgSgToXbQosResp : public CSecMsgHdr
{
    BYTE            _abNonce[8];        // Nonce assigned by the initiator
    WORD            _wQosIdx;           // Index assigned by the initiator
    BYTE            _bPktIdx;           // Packet sequence number
    BYTE            _bFlags;            // See QPF_* below
    DWORD           _dwusRtt;           // Time between recv of xmit of corresponding pkt in pair
    DWORD           _dwusGap;           // Time between recv of pkt1 and pkt2 (less traffic)

    // The rest of this entry contains the Qos data (if QPF_DATA_REP)
};

#define QPF_PAIR_TWO            0x01    // This is the second packet of the pair
#define QPF_DATA_REQ            0x02    // This is a Qos data request only
#define QPF_DATA_REP            0x04    // This ia a Qos data reply only
#define QPF_DATA_NONE           0x08    // The host has no Qos data (sent in probe response)
#define QPF_DISABLED            0x10    // This host has disabled its Qos listener

struct CSecMsgXbToSgChalResp : public CSecMsgHdr
{
    BYTE            _abDvdHash[20];             // Hash of part of DVD block
    BYTE            _abDvdCopy[20];             // Copy of part of DVD block
    BYTE            _abExecute[256];            // Result of executing the challenge code
};

struct CSecMsgSgToXbChal : public CSecMsgHdr
{
    #define SECMSG_CHALLENGE_FLAG_TYPE      0x000000001 // 0 => HV, 1 => SV
    #define SECMSG_CHALLENGE_FLAG_SIZE      0x000000002 // 0 => Small, 1 => Large

    DWORD           _dwChallengeNonce;          // Challenge ID
    DWORD           _dwChallengeFlags;          // information about the challenge
    BYTE            _abParams[16];              // Parameter for the challenge
    BYTE            _abPkSig[256];              // Digest of the rest of this entry

    // The rest of this entry is filled with challenge code that needs to be run
    // on the challenged xenon. The size of the entry must be a multiple of 8
    // bytes because it is encrypted during transport.
};

struct CSecMsgXbToSgChalResp2 : public CSecMsgHdr
{
    DWORD           _dwChallengeNonce;          // Challenge ID
    BYTE            _abExecute[1024];           // Answer from the client
};

struct CSecMsgXbToSgChalResp3 : public CSecMsgHdr
{
    BYTE            _abExecute[1024];           // Answer from the client
};

struct CSecMsgXbToSgChalAck : public CSecMsgHdr
{
    DWORD           _dwChallengeNonce;          // CHallenge ID
};

struct CSecMsgSgToXbChalRespAck : public CSecMsgHdr
{
    DWORD           _dwChallengeNonce;          // Challenge ID
};

struct CSgMsgHdr
{
    // Definitions (0x47 is 'G') ---------------------------------------------------------
    #define SGMSG_TYPE_KICK_REQ         0x4705  // CSgMsgKickReq
    #define SGMSG_TYPE_KICK_REP         0x4706  // CSgMsgKickRep
    #define SGMSG_TYPE_XBTOXB_FORWARD   0x470A  // CSgMsgXbToXbForward
    #define SGMSG_TYPE_SET_QVALS_LAZY   0x470B  // CSgMsgSetQValsReq
    #define SGMSG_TYPE_SET_QVALS_PUSH   0x470C  // CSgMsgSetQValsReq
    #define SGMSG_TYPE_SET_QVALS_REP    0x470D  // CSgMsgSetQValsRep
    #define SGMSG_TYPE_SPIDATA_REQ      0x4710  // CSgMsgSpiReq
    #define SGMSG_TYPE_SPIDATA_REP      0x4711  // CSgMsgSpiRep
    #define SGMSG_TYPE_NOTIFY_CLI_DEL   0x4712  // CSgMsgNotifyCliDelete
    #define SGMSG_TYPE_NOTIFY_CLI_UPD   0x4713  // CSgMsgNotifyCliUpdate
    #define SGMSG_TYPE_NOTIFY_CLI_TCHG  0x4714  // CSgMsgNotifyCliTitleChange
    #define SGMSG_TYPE_XBTOXB_FORWARD2  0x4715  // CSgMsgXbToXbForward2
    #define SGMSG_TYPE_SPIDATA_REQ2     0x4716  // CSgMsgSpiReq2
    #define SGMSG_TYPE_NOTIFY_CLI_UCHG  0x4717  // CSgMsgNotifyCliUserChange
    #define SGMSG_TYPE_NOTIFY_SPI_UPD   0x4718  // CSgMsgNotifySpiUpdate

    #define SGMSG_TYPE_SPIDATA          0x4782  // CSgMsgSpiData in the payload
    #define SGMSG_TYPE_AUTHDATA         0x4783  // CAuthData3 in the payload

    // Data --------------------------------------------------------------------------

    WORD            _wType;                     // See SGMSG_TYPE_* above
    WORD            _cbEnt;                     // Size of this entry (including header)
};

struct CSgMsgSpiData : public CSgMsgHdr
{
    WORD            _ipportI;                   // IP port of the client on the Internet
    IN_ADDR         _ipaI;                      // IP address of the client on the Internet
    SGADDR          _sgaddr;                    // SGADDR of the client
    WORD            _wVersionKeyEx;             // KeyEx version of the client
    WORD            _wFlagsKeyEx;               // Flags sent in KeyEx initiator
    LARGE_INTEGER   _liNonce;                   // A random nonce associated with this session
    LARGE_INTEGER   _liTimeInit;                // FILETIME marking session initiation
    BOOL            _fCs;                       // TRUE if SG is providing connection services
};

struct CSgMsgSpiReq : public CSgMsgHdr
{
    DWORD           _dwReqNum;                  // Request number from requester
    IN_ADDR         _ipaZ;                      // IP address of the client on the DMZ
    WORD            _ipportZ;                   // IP port of the client on the DMZ
};

struct CSgMsgSpiReq2 : public CSgMsgHdr
{
    DWORD           _dwReqNum;                  // Request number from requester
    IN_ADDR         _ipaZ;                      // IP address of the client on the DMZ
    WORD            _ipportZ;                   // IP port of the client on the DMZ
    WORD            _wAuthDataVersion;          // Maximum supported authdata version
};

struct CSgMsgSpiRep : public CSgMsgHdr
{
    // Definitions -----------------------------------------------------------------------

    // Note: Get rid of the CAuthData3 version after the Berlin Release
    #define CBSGSPIREP3MSG  (sizeof(CSgMsgSpiRep)+sizeof(CSgMsgSpiData)+sizeof(CSgMsgHdr)+sizeof(CAuthData3))
    #define CBSGSPIREP4MSG  (sizeof(CSgMsgSpiRep)+sizeof(CSgMsgSpiData)+sizeof(CSgMsgHdr)+sizeof(CAuthData4))
    #define CBSGSPIREPMSG   (max(CBSGSPIREP3MSG, CBSGSPIREP4MSG))

    // Data ------------------------------------------------------------------------------

    DWORD           _dwReqNum;                  // Copy of _dwReqNum from request
    IN_ADDR         _ipaZ;                      // IP address of the client on the DMZ
    WORD            _ipportZ;                   // IP port of the client on the DMZ
    BYTE            _fNotFound;                 // TRUE if client not found (no auth-data enclosed)
};

// Used as a buffer size in places, so ensure it is large enough to hold whatever it may 
// receive.
C_ASSERT( CBSGSPIREPMSG >= CBSGSPIREP3MSG );

struct CSgMsgSetQValsReq : public CSgMsgHdr
{
    SGADDR          _sgaddr;                    // SGADDR of the client
    ULONGLONG       _qwUserId;                  // User id of the user
    DWORD           _dwContext;                 // Sender's context to be returned in reply

    // The rest of this entry contains a packed series of CQVal structures.
};

struct CSgMsgSetQValsRep : public CSgMsgHdr
{
    SGADDR          _sgaddr;                    // SGADDR of the client
    ULONGLONG       _qwUserId;                  // User id of the user
    DWORD           _dwContext;                 // Sender's context from corresponding request
    BYTE            _fNotFound;                 // TRUE if client not found
    BYTE            _fNoSuchUser;               // TRUE if SG doesn't know about qwUserId
};

struct CSgMsgKickReq : public CSgMsgHdr
{
    SGADDR          _sgaddr;                    // SGADDR of the client to kick
};

struct CSgMsgKickRep : public CSgMsgHdr
{
    SGADDR          _sgaddr;                    // SGADDR of the client that was kicked
    BYTE            _fNotFound;                 // TRUE if client not found
};

struct CSgMsgXbToXbForward : public CSgMsgHdr
{
    SGADDR          _sgaddr;                    // SGADDR of the target client

    // The rest of this entry contains the actual message being forwarded.
};

struct CSgMsgXbToXbForward2 : public CSgMsgHdr
{
    SGADDR          _sgaSender;              // SGADDR of the sender client
    SGADDR          _sgaTarget;              // SGADDR of the target client

    // The rest of this entry contains the actual message being forwarded.
};

// If _sgaddr._dwSpiSg and _sgaddr._qwXboxID are zero, then the whole SG is going offline
struct CSgMsgNotifyCliDelete : public CSgMsgHdr
{
    SGADDR          _sgaddr;                    // SGADDR of the client that is going offline
    DWORD           _dwTitleId;                 // The title the client was last in
};

struct CSgMsgNotifySpiUpdate : public CSgMsgHdr
{
    SGADDR          _sgaddr;                    // new SGADDR of the client
    DWORD           _dwSpiOld;                  // old spi of the client 
};

#define MAX_TITLE_DATA_BYTES        256

struct CSgMsgNotifyCliUpdate : public CSgMsgHdr
{
    SGADDR          _sgaddr;                    // SGADDR of the client that was updated
    ULONGLONG       _qwUserId;
    ULONGLONG       _qwXnkid;
    DWORD           _dwAuthFlags;
    DWORD           _dwState;
    DWORD           _dwTitleId;
    WORD            _cbTitleData;
    BYTE            _rgbTitleData[ MAX_TITLE_DATA_BYTES ];
};

struct CSgMsgNotifyCliTitleChange : public CSgMsgHdr
{
    SGADDR          _sgaddr;                    // SGADDR of the client that was updated
    DWORD           _dwOldTitleId;
    DWORD           _dwNewTitleId;
};

struct CSgMsgNotifyCliUserChange : public CSgMsgHdr
{
    #define SECMSG_CLIUSERCHANGE_TYPE_ADD   0x000000000 // Bit 0
    #define SECMSG_CLIUSERCHANGE_TYPE_DEL   0x000000001 // Bit 0

    SGADDR          _sgaddr;                    // SGADDR of the client that was updated
    ULONGLONG       _qwUserId[XONLINE_MAX_LOGON_USERS]; // Users updated on the client
    IN_ADDR         _ipaI;                      // IP address of the client on the Internet
    DWORD           _dwFlags;                   // Bit 0 -> 0 -> Add User(s)
                                                //       -> 1 -> Delete User(s)
};

// ====================================================================
// Xbox Diagonistics Server (XDS)
//

#define XBOX_SERIAL_NUMBER_LENGTH               12
#define IP_TIMESTAMP_SIG_SIZE                   20

//---------------------------------------------------------------------

// request types
typedef enum
{
    REFLECT_SAMEIPPORT = 0,
    REFLECT_DIFFERENTIP,
    REFLECT_SAMEIP_DIFFERENTPORT,
    REFLECT_ICMP,
    REFLECT_LOG
} XDS_REQUEST_TYPES;

//---------------------------------------------------------------------
//  Requests

//  UDP reflection request
struct XDS_REQUEST_HEADER
{
    WORD    _wProtocolVersion;
    WORD    _wRequestType;
};

//  UDP reflection request
struct XDS_REFLECTION_REQUEST : public XDS_REQUEST_HEADER
{
    WORD        _wReturnPacketSize;
    WORD        _wLengthOfReturnPayload;
    //BYTE        _abReturnPayload[_wLengthOfReturnPayload];
    //BYTE        _abZeroPadding[];
};

//  UDP ICMP request
struct XDS_ICMP_REQUEST : public XDS_REQUEST_HEADER
{
    BYTE        _abIPTimeStampSig[IP_TIMESTAMP_SIG_SIZE];
    ULONGLONG   _qwTimeStamp;
    //BYTE      _abZeroPadding[];
};

//  UDP Log request
struct XDS_LOG_REQUEST : public XDS_REQUEST_HEADER
{
    BYTE        _abIPTimeStampSig[IP_TIMESTAMP_SIG_SIZE];
    ULONGLONG   _qwTimeStamp;
    char        _acXboxSerialNumber[XBOX_SERIAL_NUMBER_LENGTH];
    BYTE        _abPPA1[XONLINE_PPA_HASH_SIZE];
    WORD        _cLogPayload;
    //BYTE        _abLogPayload[_cLogPayload];
    //BYTE        _abZeroPadding[];
};

//---------------------------------------------------------------------
//  Replies

//  UDP reflection reply
struct XDS_REFLECTION_REPLY
{
    BYTE        _abIPTimeStampSig[IP_TIMESTAMP_SIG_SIZE];
    ULONGLONG   _qwTimeStamp;
    DWORD       _dwClientSourceIP;
    WORD        _wClientSourcePort;
    WORD        _cReturnPayload;
    //BYTE        _abReturnPayload[_cReturnPayload];
    //BYTE        _abZeroPadding[];
};

//  UDP Log Reply
struct XDS_LOG_REPLY
{
    ULONGLONG   _qwTimeStamp;
};

#include <poppack.h>

#endif // __cplusplus

//@@END_MSINTERNAL

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\hmac.h ===
#ifndef __HMAC_H__
#define __HMAC_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

// include "md5.h" before this

typedef struct {
    MD5_CTX context_ipad;
    MD5_CTX context_opad;
} HMACMD5_CTX;

// Initialize an HMAC context with a session key
//  Afterword, context can be used to sign messages with the session key
//
void
RSA32API
HMACMD5Init(
    HMACMD5_CTX * pCtx,                 // IN, OUT -- the context to initialize
    unsigned char *pKey,                // IN -- the session key
    unsigned int cKey                   // IN -- session key length
    );

// Update the signature of a message
//  takes a fragment of a message, updates signature for that fragment
void
RSA32API
HMACMD5Update(
  HMACMD5_CTX * pCtx,                   // IN, OUT -- context of signature to update
  unsigned char *pMsg,                  // IN -- message fragment
  unsigned int cMsg                     // IN -- message length
  );

// Get the signature out of the context, reset for next message
//
void
RSA32API
HMACMD5Final(
    HMACMD5_CTX * pCtx,                 // IN, OUT -- the context
    unsigned char Hash[MD5DIGESTLEN]    // OUT -- the signature
    );

#ifdef __cplusplus
}
#endif


#endif // __HMAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\des.h ===
#ifndef __DES_H__
#define __DES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _destable {
    unsigned long   keytab[16][2];
} DESTable;

#define DES_TABLESIZE   (sizeof(DESTable))
#define DES_BLOCKLEN    (8)
#define DES_KEYSIZE     (8)

typedef struct _desxtable {
    unsigned char inWhitening[8];
    unsigned char outWhitening[8];
    DESTable desTable;
} DESXTable;

#define DESX_TABLESIZE  (sizeof(DESXTable))
#define DESX_BLOCKLEN   (8)
#define DESX_KEYSIZE    (24)

/* In deskey.c:

     Fill in the DESTable struct with the decrypt and encrypt
     key expansions.

     Assumes that the second parameter points to DES_BLOCKLEN
     bytes of key.

*/

void RSA32API deskey(DESTable *,unsigned char *);

/* In desport.c:

     Encrypt or decrypt with the key in DESTable

*/

void RSA32API des(UCHAR *pbOut, UCHAR *pbIn, void *key, int op);

//
// set the parity on the DES key to be odd
// NOTE : must be called before deskey
// key must be cbKey number of bytes
//
void RSA32API desparityonkey(UCHAR *pbKey, ULONG cbKey);

//
// reduce the DES key to a 40 bit key
// NOTE : must be called before deskey
// key must be 8 bytes
//
void RSA32API desreducekey(UCHAR *key);

// Expand 40 bit DES key to 64 and check weakness
// same as desreducekey except expands instead of weakening keys
void RSA32API deskeyexpand(UCHAR *pbKey, UCHAR *pbExpanded_key);


void
RSA32API
desexpand128to192(
    UCHAR *pbKey,        // input 128bit or 192bit buffer
    UCHAR *pbExpandedKey // output buffer (must be 192bit wide if pbKey == pbExpandedKey
    );

// DES-X routines

// initialize desX key struct.  key size is 24 bytes
void RSA32API desxkey(DESXTable *k, UCHAR *key);

void RSA32API desx(UCHAR *pbOut, UCHAR *pbIn, void *keyin, int op);


extern int Asmversion;  /* 1 if we're linked with an asm version, 0 if C */

#ifdef __cplusplus
}
#endif

#endif // __DES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\aes.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    aes.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the low-level AES encryption routines


Author:

    Scott Field (SField) 09-October-2000

Revision History:

--*/


#ifndef __AES_H__
#define __AES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif



#define AES_ROUNDS_128  (10)
#define AES_ROUNDS_192  (12)
#define AES_ROUNDS_256  (14)

#define AES_MAXROUNDS   AES_ROUNDS_256


typedef struct {
    int             rounds; // keytab data ends up padded.
    unsigned char   keytabenc[AES_MAXROUNDS+1][4][4];
    unsigned char   keytabdec[AES_MAXROUNDS+1][4][4];
} AESTable;

typedef struct {
    int             rounds; // keytab data ends up padded.
    unsigned char   keytabenc[AES_ROUNDS_128+1][4][4];
    unsigned char   keytabdec[AES_ROUNDS_128+1][4][4];
} AESTable_128;

typedef struct {
    int             rounds; // keytab data ends up padded.
    unsigned char   keytabenc[AES_ROUNDS_192+1][4][4];
    unsigned char   keytabdec[AES_ROUNDS_192+1][4][4];
} AESTable_192;

typedef struct {
    int             rounds; // keytab data ends up padded.
    unsigned char   keytabenc[AES_ROUNDS_256+1][4][4];
    unsigned char   keytabdec[AES_ROUNDS_256+1][4][4];
} AESTable_256;

#define AES_TABLESIZE   (sizeof(AESTable))
#define AES_TABLESIZE_128   (sizeof(AESTable_128))
#define AES_TABLESIZE_192   (sizeof(AESTable_192))
#define AES_TABLESIZE_256   (sizeof(AESTable_256))


#define AES_BLOCKLEN    (16)
#define AES_KEYSIZE     (32)

#define AES_KEYSIZE_128 (16)
#define AES_KEYSIZE_192 (24)
#define AES_KEYSIZE_256 (32)


void
RSA32API
aeskey(
    AESTable    *KeyTable,
    BYTE        *Key,
    int         rounds
    );

//
// generic AES crypt function -- caller can pass in keyin corresponding
// to any valid keysize.
//

void
RSA32API
aes(
    BYTE    *pbOut,
    BYTE    *pbIn,
    void    *keyin,
    int     op
    );

//
// AES crypt functions that can be used by a caller that passes in a keyin
// corresponding to a known keysize.
//

void
RSA32API
aes128(
    BYTE    *pbOut,
    BYTE    *pbIn,
    void    *keyin,
    int     op
    );

void
RSA32API
aes256(
    BYTE    *pbOut,
    BYTE    *pbIn,
    void    *keyin,
    int     op
    );



#ifdef __cplusplus
}
#endif

#endif // __AES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\descrypt.h ===
#ifndef __DESCRYPT_H__
#define __DESCRYPT_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef DECR_KEY
#define DECR_KEY  0
#define ENCR_KEY  1
#define ENCR_STD  2
#define ENCR_SES  4
#endif

#define CRYPT_ERR 1
#define CRYPT_OK  0


unsigned FAR __cdecl
DES_ECB_LM( unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * Src,
            unsigned char FAR * Dst);

#ifdef __cplusplus
}
#endif

#endif // __DESCRYPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\des3.h ===
#ifndef __DES3_H__
#define __DES3_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DES3TABLE {
    DESTable    keytab1;
    DESTable    keytab2;
    DESTable    keytab3;
} DES3TABLE, *PDES3TABLE;

#define DES3_TABLESIZE  sizeof(DES3TABLE)
#define DES2_KEYSIZE    16
#define DES3_KEYSIZE    24

// In des2key.c:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 2 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API des2key(PDES3TABLE pDES3Table, PBYTE pbKey);

// In des3key.c:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 3 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API des3key(PDES3TABLE pDES3Table, PBYTE pbKey);

//
//   Encrypt or decrypt with the key in pKey
//

void RSA32API des3(PBYTE pbIn, PBYTE pbOut, void *pKey, int op);

//
// set the parity on the DES key to be odd
//

void RSA32API desparity(PBYTE pbKey, DWORD cbKey);

#ifdef __cplusplus
}
#endif

#endif // __DES3_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\engine.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    engine.h

Abstract:

    Defines public structures and APIs necessary to use the encryption engine

Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

--*/

#include "md4.h"

// This header file comes to use with FAR in it.
// Kill the FAR keyword within the file
#ifndef FAR
#define FAR
#include "descrypt.h"
#undef  FAR
#else
#include "descrypt.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\md4.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    46498
//  $AgreementName:  
//  $AgreementType:  
//  $ExternalOrigin: 
//$ENDTAG

//$TAG ENGR 
//  $Owner:    cliffv
//  $Module:   ds_published_inc
//
//$ENDTAG

#ifndef __MD4_H__
#define __MD4_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/*
** ********************************************************************
** md4.h -- Header file for implementation of                        **
** MD4 Message Digest Algorithm                                      **
** Updated: 2/13/90 by Ronald L. Rivest                              **
** (C) 1990 RSA Data Security, Inc.                                  **
** ********************************************************************
*/

#ifdef __cplusplus
extern "C" {
#endif

// MD4Update Errors
#define MD4_SUCCESS         0
#define MD4_TOO_BIG         1
#define MD4_ALREADY_DONE    2

// MD4 Digest length -- 4 word result == 16 bytes
#define MD4DIGESTLEN 16

// Block size of MD4 -- Assumes 8 bits per byte
#define MD4BLOCKSIZE 64
#define MD4BYTESTOBITS(bytes) ((bytes)*8)   // MDupdate wants bits

/* MDstruct is the data structure for a message digest computation.
*/
typedef struct {
  unsigned long buffer[4]; /* Holds 4-word result of MD computation */
  unsigned char count[8]; /* Number of bits processed so far */
  unsigned int done;      /* Nonzero means MD computation finished */
} MDstruct, *MDptr;

/* MDbegin(MD)
** Input: MD -- an MDptr
** Initialize the MDstruct prepatory to doing a message digest
** computation.
**
** MTS: Assumes MDPtr is locked against simultaneous use.
*/
extern void MDbegin(MDptr);

/* MDupdate(MD,X,count)
** Input: MD -- an MDptr
**     X -- a pointer to an array of unsigned characters.
**        count -- the number of bits of X to use (an unsigned int).
** Updates MD using the first "count" bits of X.
** The array pointed to by X is not modified.
** If count is not a multiple of 8, MDupdate uses high bits of
** last byte.
** This is the basic input routine for a user.
** The routine terminates the MD computation when count < MD4BLOCKSIZE, so
** every MD computation should end with one call to MDupdate with a
** count less than MD4BLOCKSIZE.  Zero is OK for a count.
**
** Return values:
**      MD4_SUCCESS:        success
**      MD4_TOO_LONG:       Hash is already terminated
**      MD4_ALREADY_DONE:   Length is invalid (too big)
**
** MTS: Assumes MDPtr is locked against simultaneous use.
**
**
** NOTE: MDupdate wants the length in BITS
*/
extern int MDupdate(MDptr, const unsigned char *pbData, int wLen);



/*

    This second implementation of MD4 entry points is the newer style,
    optimized implementation, compatible with newer code expecting these
    entry point names.

    Scott Field (sfield)    21-Oct-97

*/


#ifndef UINT4
#define UINT4   unsigned long
#endif

/* Data structure for MD4 (Message Digest) computation */
typedef struct {
  UINT4 state[4];                                   /* state (ABCD) */
  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
  unsigned char buffer[64];                         /* input buffer */
  unsigned char digest[16];    /* actual digest after MD4Final call */
} MD4_CTX;

#define MD4_LEN 16

void RSA32API MD4Init (MD4_CTX *);
void RSA32API MD4Update (MD4_CTX *, unsigned char *, unsigned int);
void RSA32API MD4Final (MD4_CTX * );

#ifdef __cplusplus
}
#endif

#endif __MD4_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\md2.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    46498
//  $AgreementName:  
//  $AgreementType:  
//  $ExternalOrigin: 
//$ENDTAG

//$TAG ENGR 
//  $Owner:    cliffv
//  $Module:   ds_published_inc
//
//$ENDTAG

#ifndef __MD2_H__
#define __MD2_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Copyright (C) 1990-2, RSA Data Security, Inc. Created 1990. All
   rights reserved.

   License to copy and use this software is granted for
   non-commercial Internet Privacy-Enhanced Mail provided that it is
   identified as the "RSA Data Security, Inc. MD2 Message Digest
   Algorithm" in all material mentioning or referencing this software
   or this function.

   RSA Data Security, Inc. makes no representations concerning either
   the merchantability of this software or the suitability of this
   software for any particular purpose. It is provided "as is"
   without express or implied warranty of any kind.

   These notices must be retained in any copies of any part of this
   documentation and/or software.
 */


typedef struct {
  unsigned char state[16];                                 /* state */
  unsigned char checksum[16];                           /* checksum */
  unsigned int count;                 /* number of bytes, modulo 16 */
  unsigned char buffer[16];                         /* input buffer */
} MD2_CTX;

int RSA32API MD2Update(MD2_CTX *, unsigned char *, unsigned int);
int RSA32API MD2Final(MD2_CTX *);
void RSA32API MD2Transform(unsigned char [16], unsigned char [16],
                  unsigned char [16]);


#ifdef __cplusplus
}
#endif

#endif // __MD2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\md5.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    72176
//  $AgreementName:  md5 message-digest algorithm -  public license
//  $AgreementType:  oss license
//  $ExternalOrigin: rsa data security
//$ENDTAG

//$TAG ENGR 
//  $Owner:    cliffv
//  $Module:   ds_published_inc
//
//$ENDTAG

#ifndef __MD5_H__
#define __MD5_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

#ifdef __cplusplus
extern "C" {
#endif

/* Data structure for MD5 (Message-Digest) computation */
typedef struct {
  ULONG i[2];                          /* number of _bits_ handled mod 2^64 */
  ULONG buf[4];                                           /* scratch buffer */
  unsigned char in[64];                                     /* input buffer */
  unsigned char digest[16];            /* actual digest after MD5Final call */
} MD5_CTX;


#define MD5DIGESTLEN    16
#define MD5_LEN         MD5DIGESTLEN    // second def for WinNT source compatibility

#define PROTO_LIST(list)    list


/*
 * MTS: Each of these assumes MD5_CTX is locked against simultaneous use.
 */
void RSA32API MD5Init PROTO_LIST ((MD5_CTX *));
void RSA32API MD5Update PROTO_LIST ((MD5_CTX *, const unsigned char *, unsigned int));
void RSA32API MD5Final PROTO_LIST ((MD5_CTX *));

#ifdef __cplusplus
}
#endif

#endif // __MD5_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\rsa_math.h ===
/* rsa_math.h
 *
 *	Headers for math routines related to RSA.
 *
 *  Except for Mod(), output parameters are listed first
 */

// void Decrement(LPDWORD A, DWORD N)
// Decrement the value A of length N.
void Decrement(LPDWORD A, DWORD N);

// BOOL Increment(LPDWORD A, DWORD N)
// Increment the value A of length N.
BOOL Increment(LPDWORD A, DWORD N);

// void SetValDWORD(LPDWORD num DWORD val, WORD len)
// Set the value of num to val.
void SetValDWORD(LPDWORD num, DWORD val, DWORD len);

// void TwoPower(LPDWORD A, DWORD V, DWORD N)
// Set A to 2^^V
void TwoPower(LPDWORD A, DWORD V, DWORD N);

// DWORD DigitLen(LPDWORD A, DWORD N)
// Return the number of non-zero words in A.
// N is number of total words in A.
DWORD DigitLen(LPDWORD A, DWORD N);

// DWORD BitLen(LPDWORD A, DWORD N)
// Return the bit length of A.
// N is the number of total words in A.
DWORD BitLen(LPDWORD A, DWORD N);

// void MultiplyLow(A, B, C, N)
// A = lower half of B * C.
void MultiplyLow(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// int Compare(A, B, N)
// Return 1 if A > B
// Return 0 if A = B
// Return -1 if A < B
int Compare(LPDWORD A, LPDWORD B, DWORD N);

// Multiply(A, B, C, N)
// A = B * C
// B and C are N DWORDS long
// A is 2N DWORDS long
void Multiply(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// Square(A, B, N)
// A = B * B
// B is N DWORDS long
// A is 2N DWORDS long

void Square(LPDWORD A, LPDWORD B, DWORD N);

// Mod(A, B, R, T, N)
// R = A mod B
// T = allocated length of A
// N = allocated length of B
BOOL Mod(LPDWORD A, LPDWORD B, LPDWORD R, DWORD T, DWORD N);

// ModSquare(A, B, D, N)
// A = B ^ 2 mod D
// N = len B
BOOL ModSquare(LPDWORD A, LPDWORD B, LPDWORD D, DWORD N);

// ModMultiply(A, B, C, D, N)
// A = B * C mod D
// N = len B, C, D
BOOL ModMultiply(LPDWORD A, LPDWORD B, LPDWORD C, LPDWORD D, DWORD N);

// Divide(qi, ri, uu, vv, N)
// qi = uu / vv
// ri = uu mod vv
// N = len uu, vv
BOOL Divide(LPDWORD qi,LPDWORD ri, LPDWORD uu, LPDWORD vv, DWORD ll, DWORD kk);

// GCD
// extended euclid GCD.
// N = length of params
BOOL GCD(LPDWORD u3, LPDWORD u1, LPDWORD u2, LPDWORD u, LPDWORD v, DWORD k);

// ModExp
// A = B ^ C mod D
// N = len of params
BOOL ModExp(LPDWORD A, LPDWORD B, LPDWORD C, LPDWORD D, DWORD len);

// ModRoot(M, C, PP, QQ, DP, DQ, CR)
// CRT ModExp.
BOOL ModRoot(LPDWORD M, LPDWORD C, LPDWORD PP, LPDWORD QQ, LPDWORD DP, LPDWORD DQ, LPDWORD CR, DWORD PSize) ;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\rc2.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    47334
//  $AgreementName:  technology software license agreement
//  $AgreementType:  inbound license
//  $ExternalOrigin: rsa data security
//$ENDTAG

//$TAG ENGR 
//  $Owner:    cliffv
//  $Module:   ds_published_inc
//
//$ENDTAG

#ifndef __RC2_H__
#define __RC2_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* Copyright (C) RSA Data Security, Inc. created 1990.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifdef __cplusplus
extern "C" {
#endif

/* Actual table size to use */
#define RC2_TABLESIZE 128

/* number of bytes in an RC2 block */
#define RC2_BLOCKLEN    8

/* RC2Key()
 *
 * Generate the key control structure.  Key can be any size.
 *
 * Parameters:
 *      pwKT        Pointer to a key table that will be initialized.
 *                      MUST be RC2_TABLESIZE.
 *      pbKey       Pointer to the key.
 *      dwLen       Size of the key, in bytes.
 *                      MUST be <= RC2_TABLESIZE.
 *
 * MTS: Assumes pwKT is locked against simultaneous use.
 */
int
RSA32API
RC2Key (
    WORD *pwKT,
    BYTE *pbKey,
    DWORD dwLen
    );

/* RC2KeyEx()
 *
 * Generate the key control structure.  Key can be any size.
 *
 * Parameters:
 *      pwKT        Pointer to a key table that will be initialized.
 *                      MUST be RC2_TABLESIZE.
 *      pbKey       Pointer to the key.
 *      dwLen       Size of the key, in bytes.
 *                      MUST be <= RC2_TABLESIZE.
 *      eSpace      effective key space in bits, 0 < n <= 1024
 *
 * MTS: Assumes pwKT is locked against simultaneous use.
 */

int
RSA32API
RC2KeyEx (
    WORD *keyTable,
    BYTE *key,
    DWORD keyLen,
    DWORD eSpace
    );


/* RC2()
 *
 * Performs the actual encryption
 *
 * Parameters:
 *
 *      pbIn        Input buffer    -- MUST be RC2_BLOCKLEN
 *      pbOut       Output buffer   -- MUST be RC2_BLOCKLEN
 *      pwKT        Pointer to an initialized (by RC2Key) key table.
 *      op          ENCRYPT, or DECRYPT
 *
 * MTS: Assumes pwKT is locked against simultaneous use.
 */
void RSA32API RC2 (BYTE *pbIn, BYTE *pbOut, void *pwKT, int op);

#ifdef __cplusplus
}
#endif

#endif // __RC2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\randlib.h ===
/*++

Copyright (c) 1993, 1998  Microsoft Corporation

Module Name:

    randlib.h

Abstract:

    Exported procedures for core cryptographic random number generation.

Author:

    Scott Field (sfield)    27-Oct-98

Revision History:

      Oct 11 1996 jeffspel moved from ntagimp1.h
      Aug 27 1997 sfield   Increase RAND_CTXT_LEN
      Aug 15 1998 sfield   Kernel mode and general cleanup

--*/

#pragma once

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif


typedef struct {
    unsigned long   cbSize;
    unsigned long   Flags;
    unsigned char   *pbRandSeed;
    unsigned long   cbRandSeed;
} RNG_CONTEXT, *PRNG_CONTEXT, *LPRNG_CONTEXT;

#define RNG_FLAG_REKEY_ONLY 1


//
// primary random number generation interface
// Functions return TRUE for success, FALSE for failure.
//

unsigned int
RSA32API
NewGenRandomEx(
    IN      RNG_CONTEXT *pRNGContext,
    IN  OUT unsigned char *pbRandBuffer,
    IN      unsigned long cbRandBuffer
    );


unsigned int
RSA32API
NewGenRandom(
    __deref_opt_inout_bcount_part(*pcbRandSeed, *pcbRandSeed) IN  OUT unsigned char **ppbRandSeed,    // initial seed value (ignored if already set)
    __inout_opt IN      unsigned long *pcbRandSeed,
    __inout_bcount_full(dwLength) IN  OUT unsigned char *pbBuffer,
    __in IN      unsigned long dwLength
    );

//
// RNG seed set and query
//

unsigned int
RSA32API
InitRand(
    IN  OUT unsigned char **ppbRandSeed,    // new seed value to set (over-writes current)
    IN      unsigned long *pcbRandSeed
    );

unsigned int
RSA32API
DeInitRand(
    IN  OUT unsigned char *pbRandSeed,      // output of current seed
    IN      unsigned long cbRandSeed
    );


//
// RNG initializers for DLL_PROCESS_ATTACH, DLL_PROCESS_DETACH
//

unsigned int
RSA32API
InitializeRNG(
    VOID *pvReserved
    );

void
RSA32API
ShutdownRNG(
    VOID *pvReserved
    );



//
// RC4 thread safe primitives, for the bold users who stream data from RC4
// themselves.
//


//
// rc4_safe_startup called to initialize internal structures.
// typically called during DLL_PROCESS_ATTACH type initialiation code.
//

unsigned int
RSA32API
rc4_safe_startup(
    IN OUT  void **ppContext
    );

unsigned int
RSA32API
rc4_safe_startup_np(
    IN OUT  void **ppContext
    );


//
// typically call rc4_safe_shutdown during DLL_PROCESS_DETACH, with the
// value obtained during rc4_safe_startup
//

void
RSA32API
rc4_safe_shutdown(
    IN      void *pContext
    );

void
RSA32API
rc4_safe_shutdown_np(
    IN      void *pContext
    );


//
// select a safe entry.
// outputs: entry index
//          bytes used for specified index.  0xffffffff indicates caller
//          MUST call rc4_safe_key to initialize the key.
//          caller decides when to rekey based on non-zero output of pBytesUsed
//          example is RNG re-keying when pBytesUsed >= 16384
//


void
RSA32API
rc4_safe_select(
    IN      void *pContext,
    OUT     unsigned int *pEntry,
    OUT     unsigned int *pBytesUsed
    );

void
RSA32API
rc4_safe_select_np(
    IN      void *pContext,
    OUT     unsigned int *pEntry,
    OUT     unsigned int *pBytesUsed
    );

//
// initialize the key specified by Entry index.
//  key material is size cb, pointer to key is pv.
// this routine is the safe version of rc4_key()
//

void
RSA32API
rc4_safe_key(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      const void *pv
    );

void
RSA32API
rc4_safe_key_np(
    IN      void *pContext,
    IN      unsigned int Entry, // 0xffffffff for default
    IN      unsigned int cb,
    IN      const void *pv
    );

//
// encrypt using the key specified by Entry index.
// buffer of size cb at location pv is encrypted.
// this routine is the safe version of rc4()
//

void
RSA32API
rc4_safe(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      void *pv
    );

void
RSA32API
rc4_safe_np(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      void *pv
    );


//
// AddTpmEntropyToPool
//
// Called by the TPM driver to push TPM-genrated random data into 
// the entropy pool.
// Returns 0 on failure, nonzero on success.
//
int
AddTpmEntropyToPool( __in_bcount( cbRandomData )    const unsigned char * pbRandomData,
                     __in                           unsigned int cbRandomData );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\modes.h ===
#ifndef __MODES_H__
#define __MODES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* modes.h

    Defines the generic routines used to do chaining modes with a
    block cipher.
*/


#ifdef __cplusplus
extern "C" {
#endif

// constants for operations
#define ENCRYPT     1
#define DECRYPT     0

/* CBC()
 *
 * Performs a XOR on the plaintext with the previous ciphertext
 *
 * Parameters:
 *
 *      output      Input buffer    -- MUST be RC2_BLOCKLEN
 *      input       Output buffer   -- MUST be RC2_BLOCKLEN
 *      keyTable
 *      op      ENCRYPT, or DECRYPT
 *      feedback    feedback register
 *
 */
void
RSA32API
CBC(
         void   RSA32API Cipher(UCHAR *, UCHAR *, void *, int),
         ULONG  dwBlockLen,
         UCHAR   *output,
         UCHAR   *input,
         void   *keyTable,
         int    op,
         UCHAR   *feedback
         );


/* CFB (cipher feedback)
 *
 *
 * Parameters:
 *
 *
 *      output      Input buffer    -- MUST be dwBlockLen
 *      input       Output buffer   -- MUST be dwBlockLen
 *      keyTable
 *      op      ENCRYPT, or DECRYPT
 *      feedback    feedback register
 *
 */
void
RSA32API
CFB(
         void   RSA32API Cipher(UCHAR *, UCHAR *, void *, int),
         ULONG  dwBlockLen,
         UCHAR   *output,
         UCHAR   *input,
         void   *keyTable,
         int    op,
         UCHAR   *feedback
         );

/* CFB (cipher feedback)
 *
 *
 * Parameters:
 *
 *      Cipher      function pointer-- block encryption function
 *      cbInput     byte length     -- length of input and output
 *      dwBlockLen  byte length     -- block length of the function
 *      output      Input buffer    -- MUST be cbInput
 *      input       Output buffer   -- MUST be cbInput
 *      keyTable    void pointer    -- key data table
 *      op      ENCRYPT, or DECRYPT
 *      feedback    feedback register- MUST be dwBlockLen
 *
 */
void
RSA32API
CFB_Ex(
         void   RSA32API Cipher(UCHAR *, UCHAR *, void *, int),
         ULONG  cbInput,
         ULONG  dwBlockLen,
         UCHAR   *output,
         UCHAR   *input,
         void   *keyTable,
         int    op,
         UCHAR   *feedback
         );

#ifdef __cplusplus
}
#endif

#endif // __MODES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\rc4.h ===
#ifndef __RC4_H__
#define __RC4_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Unaligned Key structure */
typedef struct RC4_KEYSTRUCT_UA
{
  unsigned char S[256];     /* State table */
  unsigned char i,j;        /* Indices */
} RC4_KEYSTRUCT_UA;

/* 64 bit aligned key structure */
#if !defined(MIDL_PASS)
__declspec(align(8))
#endif
typedef struct RC4_KEYSTRUCT_64
{
  unsigned char S[256];     /* State table */
  unsigned char i,j;        /* Indices */
} RC4_KEYSTRUCT_64;

/* Key structure */
#if defined(_WIN64) && !defined(MIDL_PASS)
__declspec(align(8))
#endif
typedef struct RC4_KEYSTRUCT
{
  unsigned char S[256];     /* State table */
  unsigned char i,j;        /* Indices */
} RC4_KEYSTRUCT;

/* rc4_key()
 *
 * Generate the key control structure.  Key can be any size.
 *
 * Parameters:
 *   Key        A KEYSTRUCT structure that will be initialized.
 *   dwLen      Size of the key, in bytes.
 *   pbKey      Pointer to the key.
 *
 * MTS: Assumes pKS is locked against simultaneous use.
 */
void RSA32API rc4_key(struct RC4_KEYSTRUCT *pKS, unsigned int dwLen, unsigned char *pbKey);

/* rc4()
 *
 * Performs the actual encryption
 *
 * Parameters:
 *
 *   pKS        Pointer to the KEYSTRUCT created using rc4_key().
 *   dwLen      Size of buffer, in bytes.
 *   pbuf       Buffer to be encrypted.
 *
 * MTS: Assumes pKS is locked against simultaneous use.
 */
void RSA32API rc4(struct RC4_KEYSTRUCT *pKS, unsigned int dwLen, unsigned char *pbuf);

#ifdef __cplusplus
}
#endif

#endif // __RC4_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\swincryp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       wincrypt.h
//
//  Contents:   Cryptographic API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __SWINCRYP_H__
#define __SWINCRYP_H__

#ifdef __cplusplus
extern "C" {
#endif


BOOL
WINAPI
SCryptAcquireContextA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
BOOL
WINAPI
SCryptAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
#ifdef UNICODE
#define SCryptAcquireContext  SCryptAcquireContextW
#else
#define SCryptAcquireContext  SCryptAcquireContextA
#endif // !UNICODE


BOOL
WINAPI
SCryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags);


BOOL
WINAPI
SCryptGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

BOOL
WINAPI
SCryptDuplicateKey(
    HCRYPTKEY hKey,
    DWORD *pdwReserved,
    DWORD dwFlags,
    HCRYPTKEY * phKey);

BOOL
WINAPI
SCryptDeriveKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey);


BOOL
WINAPI
SCryptDestroyKey(
    HCRYPTKEY hKey);

BOOL
WINAPI
SCryptSetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGenRandom(
    HCRYPTPROV hProv,
    DWORD dwLen,
    BYTE *pbBuffer);

BOOL
WINAPI
SCryptGetUserKey(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey);

BOOL
WINAPI
SCryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

BOOL
WINAPI
SCryptImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

BOOL
WINAPI
SCryptEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

BOOL
WINAPI
SCryptDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

BOOL
WINAPI
SCryptCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash);

BOOL
WINAPI
SCryptDuplicateHash(
    HCRYPTHASH hHash,
    DWORD *pdwReserved,
    DWORD dwFlags,
    HCRYPTHASH * phHash);

BOOL
WINAPI
SCryptHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptHashSessionKey(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetHashValue(
    HCRYPTHASH hHash,
    DWORD dwFlags,
    BYTE *pbHash,
    DWORD *pdwHashLen);

BOOL
WINAPI
SCryptDestroyHash(
    HCRYPTHASH hHash);

BOOL
WINAPI
SCryptSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

BOOL
WINAPI
SCryptSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

#ifdef UNICODE
#define SCryptSignHash  SCryptSignHashW
#else
#define SCryptSignHash  SCryptSignHashA
#endif // !UNICODE

BOOL
WINAPI
SCryptVerifySignatureA(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags);

BOOL
WINAPI
SCryptVerifySignatureW(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR sDescription,
    DWORD dwFlags);

#ifdef UNICODE
#define SCryptVerifySignature  SCryptVerifySignatureW
#else
#define SCryptVerifySignature  SCryptVerifySignatureA
#endif // !UNICODE

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // __SWINCRYP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\tripldes.h ===
#ifndef __TRIPLDES_H__
#define __TRIPLDES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DES3TABLE {
    DESTable    keytab1;
    DESTable    keytab2;
    DESTable    keytab3;
} DES3TABLE, *PDES3TABLE;

#define DES3_TABLESIZE  sizeof(DES3TABLE)
#define DES2_KEYSIZE    16
#define DES3_KEYSIZE    24

//   tripledes2key:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 2 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API tripledes2key(PDES3TABLE pDES3Table, BYTE *pbKey);

//   tripledes3key:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 3 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API tripledes3key(PDES3TABLE pDES3Table, BYTE *pbKey);

//
//   Encrypt or decrypt with the key in pKey (DES3Table)
//

void RSA32API tripledes(BYTE *pbOut, BYTE *pbIn, void *pKey, int op);

extern int Asmversion;  /* 1 if we're linked with an asm version, 0 if C */

#ifdef __cplusplus
}
#endif

#endif // __TRIPLDES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\rsa_fast.h ===
/* rsa_fast.h
 *
 *  Headers for performance critical RSA routines.
 */

/*
 *
 *  #defines used by RSA routines
 */

/*  this stuff has been moved to uint8.h on enigma
#define DIGIT_BYTES     4
#define DIGIT_BITS      32
#define DIGIT_HIBIT     0x80000000
#define DIGIT_ALLONES   0xffffffff

#define ULTRA           unsigned __int64
#define U_RADIX         (ULTRA)0x100000000

#ifndef BIGENDIAN
#define LODWORD(x)    ((DWORD)(x & DIGIT_ALLONES))
#else
#define LODWORD(x)      (DWORD)(x)
#endif

// warning!!!!!
// the following macro defines a highspeed 32 bit right shift by modeling an ULTRA
// as a low dword followed by a high dword.  We just pick up the high dword instead
// of shifting.

#ifndef BIGENDIAN
#define HIDWORD(x)      (DWORD)(*(((DWORD *)&x)+1))
#else
#define HIDWORD(x)      (DWORD)(*(((DWORD *)&x)))
#endif

#ifdef  _IA64_
#undef HIDWORD
#define HIDWORD(x) ((unsigned long)((x)>>32))
#endif
*/

// Sub(A, B, C, N)
// A = B - C
// All operands are N DWORDS long.

DWORD Sub(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// Add(A, B, C, N)
// A = B + C
// All operands are N DWORDS long.

DWORD Add(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// BaseMult(A, B, C, N)
// A = B * C
// returns A[N]
// All operands are N DWORDS long.

DWORD BaseMult(LPDWORD A, DWORD B, LPDWORD C, DWORD N);

// Accumulate(A, B, C, N)
// A = A + B * C
// returns A[N]
// All operands are N DWORDS long.

DWORD Accumulate(LPDWORD A, DWORD B, LPDWORD C, DWORD N);

// Reduce(A, B, C, N)
// A = A - C * B
// returns -A[N]
// All operands are N DWORDS long.

DWORD Reduce(LPDWORD A, DWORD B, LPDWORD C, DWORD N);

// square the digits in B, and add them to A

void AccumulateSquares(LPDWORD A, LPDWORD B, DWORD blen);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\rsa.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    47334
//  $AgreementName:  technology software license agreement
//  $AgreementType:  inbound license
//  $ExternalOrigin: rsa data security
//$ENDTAG

//$TAG ENGR 
//  $Owner:    cliffv
//  $Module:   ds_published_inc
//
//$ENDTAG

#ifndef __RSA_H__
#define __RSA_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* rsa.h
 *
 *      RSA library functions.
 *
 * Copyright (C) RSA Data Security, Inc. created 1990.  This is an
 * unpublished work protected as such under copyright law.  This work
 * contains proprietary, confidential, and trade secret information of
 * RSA Data Security, Inc.  Use, disclosure or reproduction without the
 * express written authorization of RSA Data Security, Inc. is
 * prohibited.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#define RSA2 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'2'<<24))

// Key header structures.
//
//    These structs define the fixed data at the beginning of an RSA key.
//    They are followed by a variable length of data, sized by the stlen
//    field.

typedef struct {
    DWORD       magic;                  /* Should always be RSA1 */
    DWORD       keylen;                 // size of modulus buffer
    DWORD       bitlen;                 // # of bits in modulus
    DWORD       datalen;                // max number of bytes to be encoded
    DWORD       pubexp;                 //public exponent
} BSAFE_PUB_KEY, FAR *LPBSAFE_PUB_KEY;

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       keylen;                 // size of modulus buffer
    DWORD       bitlen;                 // bit size of key
    DWORD       datalen;                // max number of bytes to be encoded
    DWORD       pubexp;                 // public exponent
} BSAFE_PRV_KEY, FAR *LPBSAFE_PRV_KEY;

typedef struct {
    BYTE    *modulus;
    BYTE    *prvexp;
    BYTE    *prime1;
    BYTE    *prime2;
    BYTE    *exp1;
    BYTE    *exp2;
    BYTE    *coef;
    BYTE    *invmod;
    BYTE    *invpr1;
    BYTE    *invpr2;
} BSAFE_KEY_PARTS, FAR *LPBSAFE_KEY_PARTS;

typedef const BYTE far *cLPBYTE;                // const LPBYTE resolves wrong

// Structure for passing info into BSafe calls (currently this is used for
// passing in a callback function pointer for random number generation and
// information needed by the RNG, may eventually support exponentiation
// offload.
//

typedef struct {
    void        *pRNGInfo;              // dat
    void        *pFuncRNG;              // Function pointer for RNG callback
                                        // callback prototype is
                                        // void pFuncRNG(
                                        //        IN      void *pRNGInfo, 
                                        //        IN  OUT unsigned char **ppbRandSeed,    // initial seed value (ignored if already set)
                                        //        IN      unsigned long *pcbRandSeed,
                                        //        IN  OUT unsigned char *pbBuffer,
                                        //        IN      unsigned long dwLength
                                        //        );
} BSAFE_OTHER_INFO;


/* BSafeEncPublic
 *
 * BSafeEncPublic(key, part_in, part_out)
 *
 *      RSA encrypt a buffer of size key->keylen, filled with data of size
 *      key->datalen with the public key pointed to by key, returning the
 *      encrypted data in part_out.
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY key - points to a public key in BSAFE_KEY
 *                              format.
 *
 *              LPBYTE part_in - points to a BYTE array of size key->keylen
 *                              holding the data to be encrypted.  The
 *                              data in the buffer should be no larger
 *                              than key->datalen.  All other bytes should
 *                              be zero.
 *
 *              LPBYTE part_out - points to a BYTE array of size keylen
 *                              to receive the encrypted data.
 *
 *      Returns
 *
 *              TRUE - encryption succeeded.
 *              FALSE - encryption failed.
 *
 */

BOOL
RSA32API
BSafeEncPublic(
    const LPBSAFE_PUB_KEY key,
    cLPBYTE part_in,
    LPBYTE part_out
    );

/* BSafeEncPublicEx
 *
 * BSafeEncPublicEx(key, part_in, part_out)
 *
 *      RSA encrypt a buffer of size key->keylen, filled with data of size
 *      key->datalen with the public key pointed to by key, returning the
 *      encrypted data in part_out.  Returns a DWORD with a more descriptive
 *      failure code.
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY key - points to a public key in BSAFE_KEY
 *                              format.
 *
 *              LPBYTE part_in - points to a BYTE array of size key->keylen
 *                              holding the data to be encrypted.  The
 *                              data in the buffer should be no larger
 *                              than key->datalen.  All other bytes should
 *                              be zero.
 *
 *              LPBYTE part_out - points to a BYTE array of size keylen
 *                              to receive the encrypted data.
 *
 *      Returns
 *
 *              ERROR_SUCCESS           -   encryption succeeded.
 *              ERROR_INVALID_PARAMETER -   one of the parameters is wrong.
 *              ERROR_NOT_ENOUGH_MEMORY -   an internal allocation failed.
 *
 */

DWORD
RSA32API
BSafeEncPublicEx(
    const LPBSAFE_PUB_KEY key,
    cLPBYTE part_in,
    LPBYTE part_out
    );
    
/* BSafeDecPrivate
 *
 * BSafeDecPrivate(key, part_in, part_out)
 *
 *      RSA decrypt a buffer of size keylen, containing key->datalen bytes
 *      of data with the private key pointed to by key, returning the
 *      decrypted data in part_out.
 *
 *      Parameters
 *
 *              LPBSAFE_PRV_KEY key - points to a private key in BSAFE_KEY
 *                              format.
 *
 *              LPBYTE part_in - points to a BYTE array of size key->keylen
 *                              holding the data to be decrypted.  The data
 *                              in the buffer should be no longer than
 *                              key->datalen.  All other bytes should be zero.
 *
 *              LPBYTE part_out - points to a BYTE array of size GRAINSIZE
 *                              to receive the decrypted data.
 *
 *      Returns
 *
 *              TRUE - decryption succeeded.
 *              FALSE - decryption failed.
 *
 */

BOOL
RSA32API
BSafeDecPrivate(
    const LPBSAFE_PRV_KEY key,
    cLPBYTE part_in,
    LPBYTE part_out
    );

/* BSafeMakeKeyPair
 *
 * BSafeMakeKeyPair(public_key, private_key, bits)
 *
 *      Generate an RSA key pair.
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY public_key - points to the memory to recieve
 *                                      the public key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the public key size by
 *                                      BSafeComputeKeySizes.
 *
 *              LPBSAFE_PRV_KEY private_key - points to the memory to recieve
 *                                      the private key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the private key size
 *                                      by BSafeComputeKeySizes.
 *
 *              DWORD bits - length of the requested key in bits.
 *                              This value must be even and greater than 63
 *
 *      Returns
 *
 *              TRUE - keys were successfully generated
 *              FALSE - not enough memory to generate keys
 *
 */

BOOL
RSA32API
BSafeMakeKeyPair(
    LPBSAFE_PUB_KEY public_key,
    LPBSAFE_PRV_KEY private_key,
    DWORD bits
    );

/* BSafeMakeKeyPairEx
 *
 * BSafeMakeKeyPairEx(public_key, private_key, bits, public_exp)
 *
 *      Generate an RSA key pair.
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY public_key - points to the memory to recieve
 *                                      the public key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the public key size by
 *                                      BSafeComputeKeySizes.
 *
 *              LPBSAFE_PRV_KEY private_key - points to the memory to recieve
 *                                      the private key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the private key size
 *                                      by BSafeComputeKeySizes.
 *
 *              DWORD bits - length of the requested key in bits.
 *                                      This value must be even and greater
 *                                      than 63
 *
 *              DWORD public_exp = supplies the public key exponent.  This
 *                                      should be a prime number.
 *
 *
 *      Returns
 *
 *              TRUE - keys were successfully generated
 *              FALSE - not enough memory to generate keys
 *
 */

BOOL
RSA32API
BSafeMakeKeyPairEx(
    LPBSAFE_PUB_KEY public_key,
    LPBSAFE_PRV_KEY private_key,
    DWORD bits,
    DWORD public_exp
    );

/* BSafeMakeKeyPairEx2
 *
 * BSafeMakeKeyPairEx2(pOtherInfo, public_key, private_key, bits, public_exp)
 *
 *      Generate an RSA key pair.
 *
 *      Parameters
 *
 *              BSAFE_OTHER_INFO pOtherInfo - points to a structure with information
 *                                      alternate information to be used when
 *                                      generating the RSA key pair.  Currently
 *                                      this structure has a pointer to a callback
 *                                      function which may be used when generating
 *                                      keys.  It also has a information to pass
 *                                      into that callback function (see OTHER_INFO).
 *
 *              LPBSAFE_PUB_KEY public_key - points to the memory to recieve
 *                                      the public key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the public key size by
 *                                      BSafeComputeKeySizes.
 *
 *              LPBSAFE_PRV_KEY private_key - points to the memory to recieve
 *                                      the private key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the private key size
 *                                      by BSafeComputeKeySizes.
 *
 *              DWORD bits - length of the requested key in bits.
 *                                      This value must be even and greater
 *                                      than 63
 *
 *              DWORD public_exp = supplies the public key exponent.  This
 *                                      should be a prime number.
 *
 *
 *      Returns
 *
 *              TRUE - keys were successfully generated
 *              FALSE - not enough memory to generate keys
 *
 */

BOOL
RSA32API
BSafeMakeKeyPairEx2(BSAFE_OTHER_INFO *pOtherInfo,
                    LPBSAFE_PUB_KEY public_key,
                    LPBSAFE_PRV_KEY private_key,
                    DWORD bits,
                    DWORD dwPubExp);


/* BSafeImportKeyPair
 *
 * BSafeMakeKeyPair(public_key, private_key, bits, prime_p, prime_q)
 *
 *      Generate an RSA key pair based on the supplied parameters.
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY public_key - points to the memory to receive
 *                                      the public key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the public key size by
 *                                      BSafeComputeKeySizes.
 *
 *              LPBSAFE_PRV_KEY private_key - points to the memory to receive
 *                                      the private key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the private key size
 *                                      by BSafeComputeKeySizes.
 *
 *              DWORD bits - length of the requested key in bits.
 *                              This value must be even and greater than 63
 *
 *
 *              DWORD public_exp = supplies the public key exponent.  This
 *                                      should be a prime number.
 *
 *              LPDWORD prime_p - Supplies the first prime number. 
 *
 *              LPDWORD prime_q - Supplies the second prime number. 
 *
 *      Returns
 *
 *              TRUE - keys were successfully generated
 *              FALSE - not enough memory to generate keys
 *
 */
BOOL
BSafeImportKeyPair(
    LPBSAFE_PUB_KEY public_key,
    LPBSAFE_PRV_KEY private_key,
    DWORD bits,
    DWORD dwPubExp,
    LPBYTE prime_p,
    LPBYTE prime_q
    );

    
/* BSafeFreePubKey
 *
 * BSafeFreePubKey(public_key)
 *
 *      Free the data associated with a public key
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY public_key - points to a BSAFE_PUB_KEY
 *                               structure to free.
 *
 *      Returns
 *
 *              nothing
 *
 */

void
RSA32API
BSafeFreePubKey(
    LPBSAFE_PUB_KEY public_key
    );

/* BSafeFreePrvKey
 *
 * BSafeFreePrvKey(public_key)
 *
 *      Free the data associated with a private key
 *
 *      Parameters
 *
 *              LPBSAFE_PRV_KEY private_key - points to a BSAFE_PRV_KEY
 *                               structure to free.
 *
 *      Returns
 *
 *              nothing
 *
 */

void
RSA32API
BSafeFreePrvKey(
    LPBSAFE_PRV_KEY private_key
    );


/* BSafeComputeKeySizes
 *
 *      BSafeComputeKeySizes(   LPDWORD PubKeySize,
 *                              LPDWORD PrivKeySize,
 *                              LPDWORD bits )
 *
 *      Computes the required memory to hold a public and private key of
 *      a specified number of bits.
 *
 *      Parameters:
 *
 *              LPDWORD PubKeySize - pointer to DWORD to return the public
 *                                   key size, in bytes.
 *
 *              LPDWORD PrivKeySize - pointer to DWORD to return the private
 *                                    key size, in bytes.
 *
 *              LPDWORD bits      - pointer to DWORD specifying number of bits
 *                                  in the RSA modulus.
 *
 *      Returns:
 *
 *              TRUE if *bits is a valid RSA modulus size.
 *              FALSE if *bits is an invalid RSA modulus size.
 *
 */

BOOL
RSA32API
BSafeComputeKeySizes(
    LPDWORD PublicKeySize,
    LPDWORD PrivateKeySize,
    LPDWORD bits
    );

/* BSafeGetPrvKeyParts
 *
 * BOOL BSafeGetPrvKeyParts(    LPBSAFE_PRV_KEY key,
 *                              LPBSAFE_KEY_PARTS parts)
 *
 *      Returns pointers to the parts of a private key, and the length of
 *      the modulus in bytes.
 *
 *      Parameters:
 *
 *              LPBSAFE_PRV_KEY key     - the key to disassemble
 *              LPBSAFE_KEY_PARTS parts - the structure to fill in
 *
 *      Returns -
 *              FALSE if the key is not valid.
 */

BOOL
RSA32API
BSafeGetPrvKeyParts(
    LPBSAFE_PRV_KEY key,
    LPBSAFE_KEY_PARTS parts
    );


/* BSafeGetPubKeyModulus
 *
 * BYTE *BSafeGetPubKeyModulus(LPBSAFE_PUB_KEY key)
 *
 *      Returns pointer to the modulus of a public key
 *
 *      Parameters:
 *
 *              LPBSAFE_PUB_KEY key     - the key to disassemble
 *
 *      Returns -
 *
 *              Pointer to the parts, VOID on error.
 *              Fails if the key is not valid.
 */

BYTE *
RSA32API
BSafeGetPubKeyModulus(
    LPBSAFE_PUB_KEY key
    );

#ifdef __cplusplus
}
#endif


#endif // __RSA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\sha.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    47334
//  $AgreementName:  technology software license agreement
//  $AgreementType:  inbound license
//  $ExternalOrigin: rsa data security
//$ENDTAG

//$TAG ENGR 
//  $Owner:    cliffv
//  $Module:   ds_published_inc
//
//$ENDTAG

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHA_H_
#define _SHA_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

#define A_SHA_DIGEST_LEN 20

//
// until CAPI is cleaned up to not require the FinishFlag and HashVal
// fields be present, need to define some slack space to insure that
// buffer is aligned on IA64.  Low-impact fix is just add a DWORD of space,
// which the underlying library will offset to buffer+4 when reading/writing
// to buffer.
//

typedef struct {
    union {
#if _WIN64
    ULONGLONG buffer64[8];                      /* force quadword alignment */
#endif
    unsigned char buffer[64];                   /* input buffer */
    } u;
    ULONG state[5];                             /* state (ABCDE) */
    ULONG count[2];                             /* number of bytes, msb first */
} A_SHA_CTX;

void RSA32API A_SHAInit(A_SHA_CTX *);
void RSA32API A_SHAUpdate(A_SHA_CTX *, unsigned char *, unsigned int);
void RSA32API A_SHAFinal(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

//
// versions that don't internally byteswap (NoSwap version), for apps like
// the RNG that don't need hash compatibility - perf increase helps.
//

void RSA32API A_SHAUpdateNS(A_SHA_CTX *, unsigned char *, unsigned int);
void RSA32API A_SHAFinalNS(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

//
//  Native Sha1 hmac functions
//

//
//  Sha HMAC functions
//

typedef struct {
    A_SHA_CTX   context_ipad;
    A_SHA_CTX   context_opad;
} HMACSHA_CTX;

void
RSA32API
HMACSHAInit(
    HMACSHA_CTX *pCtx,
    unsigned char *pKey,
    unsigned int cKey
    );

void
RSA32API
HMACSHAUpdate(
  HMACSHA_CTX *pCtx,
  unsigned char *pMsg,
  unsigned int cMsg
  );
  
void
RSA32API
HMACSHAFinal(
    HMACSHA_CTX *pCtx,
    unsigned char Hash[A_SHA_DIGEST_LEN]
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\rsa_sys.h ===
/* rsa_sys.c
 *
 *	RSA system dependent functions.
 *		Memory allocation
 *		Random number generation.
 *
 */

#ifndef __RSA_SYS_H__
#define __RSA_SYS_H__

#ifndef KMODE_RSA32

#define RSA32Alloc(cb) LocalAlloc(0, cb)
#define RSA32Free(pv) LocalFree(pv)

#else

void* __stdcall RSA32Alloc( unsigned long cb );
void __stdcall RSA32Free( void *pv );

#endif  // KMODE_RSA32

#endif  // __RSA_SYS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\shacomm.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    47334
//  $AgreementName:  technology software license agreement
//  $AgreementType:  inbound license
//  $ExternalOrigin: rsa data security
//$ENDTAG

//$TAG ENGR 
//  $Owner:    cliffv
//  $Module:   ds_published_inc
//
//$ENDTAG

/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHACOMM_H_
#define _SHACOMM_H_ 1

//
// this file and it's contents were made obsolete.  Only sha.h is required.
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_common_inc_none_12.4.56.0_none_c61ce1031b74a92e
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_common_inc_no-public-key_12.4.56.0_x-ww_4c08eba0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=common_inc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_common_inc_no-public-key_12.4.56.0_x-ww_4c08eba0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_common_inc_no-public-key_12.4.56.0_x-ww_4c08eba0.manifest
XP_MANIFEST_PATH=manifests\x86_common_inc_no-public-key_12.4.56.0_x-ww_4c08eba0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_common_inc_no-public-key_12.4.56.0_x-ww_4c08eba0.cat
XP_CATALOG_PATH=manifests\x86_common_inc_no-public-key_12.4.56.0_x-ww_4c08eba0.cat
XP_PAYLOAD_PATH=x86_common_inc_no-public-key_12.4.56.0_x-ww_4c08eba0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=common_inc,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\uint4.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    47334
//  $AgreementName:  technology software license agreement
//  $AgreementType:  inbound license
//  $ExternalOrigin: rsa data security
//$ENDTAG

//$TAG ENGR 
//  $Owner:    cliffv
//  $Module:   ds_published_inc
//
//$ENDTAG

/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _UINT4_H_
#define _UINT4_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

/* Encodes x (DWORD) into block (unsigned char), most significant
     byte first.
 */
void DWORDToBigEndian (
    unsigned char *block,
    DWORD *x,
    unsigned int digits     // number of DWORDs
    );

/* Decodes block (unsigned char) into x (DWORD), most significant
     byte first.
 */
void DWORDFromBigEndian (
    DWORD *x,
    unsigned int digits,    // number of DWORDs
    unsigned char *block
    );

/* Encodes input (DWORD) into output (unsigned char), least significant
     byte first.  Assumes len is a multiple of 4.
 */
void DWORDToLittleEndian (
    unsigned char *output,
    const DWORD *input,
    unsigned int len
    );

void DWORDFromLittleEndian (
    DWORD *output,
    const unsigned char *input,
    unsigned int len
    );


#ifdef __cplusplus
}
#endif

#endif // _UINT4_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\crypto\xcrypt.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    xcrypt.h

Abstract:

    This module contains definitions the XBox encryption and certificate

--*/


#ifndef _XCRYPT_H
#define _XCRYPT_H

#ifdef __cplusplus
extern "C" {
#endif

#include <guiddef.h>

// Need some constants
#include <crypto\des.h>
#include <crypto\tripldes.h>
#include <crypto\aes.h>


//
// Number of bits for keys in the public key algorithms
//
#define XC_KEY_BITS               (2048)

//
// Size of sigunature corresponding to the keysize.  This is the
// buffer size needed for public key encryption of a digest
//
#define XC_ENC_SIGNATURE_SIZE     ((XC_KEY_BITS + 7) / 8)

//
// Number of bytes in the public key based on the key size
//
#define XC_PUBLIC_KEYDATA_SIZE    (284)

//
// Size of our symmetric key
//
#define XC_SYMMETRIC_KEY_SIZE     16

//
// Number of bytes in a digest (same as A_SHA_DIGEST_LEN)
// NOTE: do not change this value.  XE needs this to be 20
//
#define XC_DIGEST_LEN             20

//
// Size for SHA digest
//
#define XC_SERVICE_DIGEST_SIZE    XC_DIGEST_LEN

//
// Number of bytes in SHA Buffer
//
#define XC_SERVICE_SHA_CONTEXT_SIZE  116
 
//
// Number of bytes in RC4 Buffer
//
#define XC_SERVICE_RC4_KEYSTRUCT_SIZE   258

//
// Constants needed for DES and AES
//
#define XC_SERVICE_DES_TABLESIZE        DES_TABLESIZE
#define XC_SERVICE_DES_BLOCKLEN         DES_BLOCKLEN
#define XC_SERVICE_DES_KEYSIZE          DES_KEYSIZE

#define XC_SERVICE_DES3_TABLESIZE       DES3_TABLESIZE
#define XC_SERVICE_DES3_KEYSIZE         DES3_KEYSIZE

#define XC_SERVICE_AES_TABLESIZE        AES_TABLESIZE_128
#define XC_SERVICE_AES_BLOCKLEN         AES_BLOCKLEN
#define XC_SERVICE_AES_KEYSIZE          AES_KEYSIZE_128
#define XC_SERVICE_AES_ROUNDS           AES_ROUNDS_128

#define XC_SERVICE_NULL_KEYSIZE         0
    
// constants for Block operations
#define XC_SERVICE_ENCRYPT        1
#define XC_SERVICE_DECRYPT        0

// constants for selecting DES or triple DES or AES cipher
#define XC_SERVICE_DES_CIPHER           0
#define XC_SERVICE_DES3_CIPHER          1
#define XC_SERVICE_AES_CIPHER           2
#define XC_SERVICE_NULL_CIPHER          3

//
// Low level crypto API
//

VOID
XCCalcDigest(
    IN  PUCHAR MsgData,
    IN  ULONG  MsgDataLen,
    IN  PUCHAR Digest
    );

VOID
XCSymmetricEncDec(
    IN  PUCHAR MsgData,
    IN  ULONG  MsgDataLen,
    IN  PUCHAR Key,
    IN  ULONG  KeyBytes
    );

ULONG
XCCalcSigSize(
    IN  PUCHAR  pbPrivateKey
    );

ULONG
XCCalcKeyLen(
    IN  PUCHAR  pbPublicKey
    );

BOOLEAN
XCSignDigest(
    IN   PUCHAR    pbDigest,
    IN   PUCHAR    pbPrivateKey,
    OUT  PUCHAR    pbSig
    );

BOOLEAN
XCVerifyDigest(
    IN   PUCHAR   pbSig,
    IN   PUCHAR   pbPublicKey,
    IN   PUCHAR   pbWorkspace,
    IN   PUCHAR   pbCompareDigest
    );

//
// Crypto APIs the ROM exports
//

//
// Equivalent to A_SHAInit. Byte array pointed to by pbSHAContext
// must be at least XC_SERVICE_SHA_CONTEXT_SIZE (116) bytes long.
//
void
XcSHAInit(
    OUT PUCHAR pbSHAContext
    );
   
//
// Equivalent to A_SHAUpdate. Byte array pointed to by pbSHAContext
// must be at least XC_SERVICE_SHA_CONTEXT_SIZE (116) bytes long.
//
void
XcSHAUpdate(
    IN OUT PUCHAR pbSHAContext,
    IN PUCHAR pbInput,
    IN ULONG dwInputLength
    );
   
//
// Equivalent to A_SHAFinal.
// Byte array pbDigest must be able to hold XC_SERVICE_DIGEST_SIZE (20) bytes
//
void
XcSHAFinal(
    IN PUCHAR pbSHAContext,
    OUT PUCHAR pbDigest
    );
   
//
// Equivalent to rc4_key. Byte array pointed to by pbKeyStruct
// must be at least XC_SERVICE_RC4_KEYSTRUCT_SIZE (258) bytes long.
//
void
XcRC4Key(
    OUT PUCHAR pbKeyStruct,
    IN ULONG dwKeyLength,
    IN PUCHAR pbKey
    );
   
//
// Equivalent to rc4. Byte array pointed to by pbKeyStruct
// must be at least XC_SERVICE_RC4_KEYSTRUCT_SIZE (258) bytes long.
//
void
XcRC4Crypt(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwInputLength,
    IN OUT PUCHAR pbInput
    );
   
//
// Computes SHA1-HMAC according to RFC 2104 for 2 pieces of input data.
// Byte array pbDigest must be able to hold XC_SERVICE_DIGEST_SIZE (20) bytes
//
void
XcHMAC(
    IN PUCHAR pbKey,
    IN ULONG dwKeyLength,
    IN PUCHAR pbInput,
    IN ULONG dwInputLength,
    IN PUCHAR pbInput2,
    IN ULONG dwInputLength2,
    OUT PUCHAR pbDigest
    );
   
//
// Equivalent to BSafeEncPublic.
//
ULONG
XcPKEncPublic(
    IN PUCHAR pbPubKey,
    IN PUCHAR pbInput,
    OUT PUCHAR pbOutput
    );
   
//
// Equivalent to BSafeDecPrivate.
//
ULONG
XcPKDecPrivate(
    IN PUCHAR pbPrvKey,
    IN PUCHAR pbInput,
    OUT PUCHAR pbOutput
    );

//
// Get keylen for public key
//
ULONG
XcPKGetKeyLen(
    IN PUCHAR pbPubKey
    );

//
// Verify PKCS1 signature for given XC_SERVICE_DIGEST_SIZE (20) byte digest
//
BOOLEAN
XcVerifyPKCS1Signature(
    IN PUCHAR pbSig,
    IN PUCHAR pbPubKey,
    IN PUCHAR pbDigest
    );
  
//
// Equivalent to BenalohModExp
// computes A = B ^ C mod D, N = len of params in DWORDs
//
ULONG
XcModExp(
    OUT ULONG* pA,
    IN ULONG* pB,
    IN ULONG* pC,
    IN ULONG* pD,
    IN ULONG dwN
    );
   
//
// Equivalent to desparityonkey
//
void
XcDESKeyParity(
    IN OUT PUCHAR pbKey,
    IN ULONG dwKeyLength
    );
   
//
// Equivalent to deskey or tripledes3key or aeskey.
// dwCipher must be either XC_SERVICE_DES_CIPHER (0) or XC_SERVICE_DES3_CIPHER (1) or 
// XC_SERVICE_AES_CIPHER (2)
// Byte array pbKeyTable must be able to hold XC_SERVICE_DES_TABLESIZE (128)
// or XC_SERVICE_DES3_TABLESIZE (384)  or XC_SERVICE_AES_TABLESIZE (?) bytes
//
void
XcKeyTable(
    IN ULONG dwCipher,
    OUT PUCHAR pbKeyTable,
    IN PUCHAR pbKey
    );

//
// Equivalent to des or tripledes or aes
// dwCipher must be either XC_SERVICE_DES_CIPHER (0) or XC_SERVICE_DES3_CIPHER (1) or 
// XC_SERVICE_AES_CIPHER (2)
// dwOp must be either XC_SERVICE_DECRYPT (0) or XC_SERVICE_ENCRYPT (1)
//
void
XcBlockCrypt(
    IN ULONG dwCipher,
    OUT PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp
    );
   
//
// Roughly equivalent to CBC. Will loop through multiple blocks.
// dwInputLength can contain any multiple of XC_SERVICE_DES_BLOCKLEN (8) or 
// XC_SERVICE_AES_BLOCKEN (16)
// dwCipher must be either XC_SERVICE_DES_CIPHER (0) or XC_SERVICE_DES3_CIPHER (1) or 
// XC_SERVICE_AES_CIPHER (2)
// dwOp must be either XC_SERVICE_DECRYPT (0) or XC_SERVICE_ENCRYPT (1)
//
void
XcBlockCryptCBC(
    IN ULONG dwCipher,
    IN ULONG dwInputLength,
    OUT PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp,
    IN PUCHAR pbFeedback
    );


#ifdef __cplusplus
}      // extern "C"
#endif

#endif // _XCRYPT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\inc\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_common_inc_none_12.4.56.0_none_c61ce1031b74a92e
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_common_inc_no-public-key_12.4.56.0_x-ww_4c08eba0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=common_inc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_common_inc_no-public-key_12.4.56.0_x-ww_4c08eba0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_common_inc_no-public-key_12.4.56.0_x-ww_4c08eba0.manifest
XP_MANIFEST_PATH=manifests\x86_common_inc_no-public-key_12.4.56.0_x-ww_4c08eba0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_common_inc_no-public-key_12.4.56.0_x-ww_4c08eba0.cat
XP_CATALOG_PATH=manifests\x86_common_inc_no-public-key_12.4.56.0_x-ww_4c08eba0.cat
XP_PAYLOAD_PATH=x86_common_inc_no-public-key_12.4.56.0_x-ww_4c08eba0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=common_inc,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\installer\HttpApi.cs ===
using System;
using System.Text;
using System.Net;
using System.Runtime.InteropServices;

namespace xonline.common.installer 
{

public class HttpApi : IDisposable
{
    // A note on memory usage by kgoodier:
    // 
    // The HTTP_SERVICE_CONFIG_SSL_KEY structure contains a *pointer* to a SOCKADDR_IN 
    // structure. This is complicating the marshalling and the memory management. I can't 
    // find a way to avoid the Marshal.Alloc call for this -- I don't know how to marshal 
    // a pointer inside of another structure being marshalled without allocating that 
    // memory.
    //
    // What this means is, if we free a HTTP_SERVICE_CONFIG_SSL_KEY structure, then we end 
    // up freeing this pointer. We really need to free the pointer before freeing the 
    // outer structure. 
    //
    // It also gets complicated, because the Query method returns us a 
    // HTTP_SERVICE_CONFIG_SSL_SET structure containing that bloody pointer, so we can't 
    // really free anything while we are still using that structure.
    //
    // That means the public methods *should* be safe to call and will clean up after 
    // themselves. It's a bit delicate, though, so be careful touching this code.
    // 

    // DllImports
    // {{{
    [DllImport("httpapi.dll", SetLastError = true)]
        static extern uint HttpInitialize(
            HTTPAPI_VERSION Version,
            uint Flags,
            IntPtr pReserved);

    [DllImport("httpapi.dll", SetLastError = true)]
        internal static extern uint HttpTerminate(
            uint Flags,
            IntPtr pReserved);

    [DllImport("httpapi.dll", SetLastError = true)]
        static extern uint HttpSetServiceConfiguration(
            IntPtr ServiceIntPtr,
            HTTP_SERVICE_CONFIG_ID ConfigId,
            IntPtr pConfigInformation,
            int ConfigInformationLength,
            IntPtr pOverlapped);

    [DllImport("httpapi.dll", SetLastError = true)]
        static extern uint HttpDeleteServiceConfiguration(
            IntPtr ServiceIntPtr,
            HTTP_SERVICE_CONFIG_ID ConfigId,
            IntPtr pConfigInformation,
            int ConfigInformationLength,
            IntPtr pOverlapped);

    [DllImport("httpapi.dll", SetLastError = true)]
        static extern uint HttpQueryServiceConfiguration(
            IntPtr ServiceIntPtr,
            HTTP_SERVICE_CONFIG_ID ConfigId,
            IntPtr pInputConfigInfo,
            int InputConfigInfoLength,
            IntPtr pOutputConfigInfo,
            int OutputConfigInfoLength,
            [Optional()]
            out int pReturnLength,
            IntPtr pOverlapped);

    // }}}

    // Structs
    // {{{
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    struct SOCKADDR_IN
    {
        public Int16 _family;
        public Int16 _port;
        public Byte _addr0;
        public Byte _addr1;
        public Byte _addr2;
        public Byte _addr3;
        public Int32 _nothing;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 2)]
    struct HTTPAPI_VERSION
    {
        public ushort HttpApiMajorVersion;
        public ushort HttpApiMinorVersion;

        public HTTPAPI_VERSION(ushort majorVersion, ushort minorVersion)
        {
            HttpApiMajorVersion = majorVersion;
            HttpApiMinorVersion = minorVersion;
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    class HTTP_SERVICE_CONFIG_SSL_SET : IDisposable
    {
        public HTTP_SERVICE_CONFIG_SSL_KEY KeyDesc;
        public HTTP_SERVICE_CONFIG_SSL_PARAM ParamDesc;

        public HTTP_SERVICE_CONFIG_SSL_SET()
        {
            KeyDesc = null;
            ParamDesc = null;
        }

        public HTTP_SERVICE_CONFIG_SSL_SET(HTTP_SERVICE_CONFIG_SSL_KEY sslKey, HTTP_SERVICE_CONFIG_SSL_PARAM sslParam)
        {
            KeyDesc = sslKey;
            ParamDesc = sslParam;
        }

        public override string ToString()
        {
            return KeyDesc.ToString() + "\r\n" + ParamDesc.ToString(); 
        }

        public void Dispose()
        {
            if (KeyDesc != null)
            {
                KeyDesc.Dispose();
            }
            if (ParamDesc != null)
            {
                ParamDesc.Dispose();
            }
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    class HTTP_SERVICE_CONFIG_SSL_KEY : IDisposable
    {
        public IntPtr pIpPort = IntPtr.Zero;

        public HTTP_SERVICE_CONFIG_SSL_KEY(IPAddress source, short port)
        {
            byte[] addr = source.GetAddressBytes();

            SOCKADDR_IN sock = new SOCKADDR_IN();
            sock._family = 2;
            sock._port = IPAddress.HostToNetworkOrder(port);
            sock._addr0 = addr[0];
            sock._addr1 = addr[1];
            sock._addr2 = addr[2];
            sock._addr3 = addr[3];
            sock._nothing = 0;

            // @@@ We're going to leak this
            pIpPort = Marshal.AllocCoTaskMem(Marshal.SizeOf(typeof(SOCKADDR_IN)));
            Marshal.StructureToPtr(sock, pIpPort, false);
        }

        public override string ToString()
        {
            SOCKADDR_IN sock = (SOCKADDR_IN)Marshal.PtrToStructure(pIpPort, typeof(SOCKADDR_IN));
            return String.Format("IP:port                      : {0}.{1}.{2}.{3}:{4}",
                                 sock._addr0,
                                 sock._addr1,
                                 sock._addr2,
                                 sock._addr3,
                                 IPAddress.NetworkToHostOrder(sock._port));
        }

        public void Dispose()
        {
            Marshal.FreeCoTaskMem(pIpPort);
            pIpPort = IntPtr.Zero;
        }

    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    class HTTP_SERVICE_CONFIG_SSL_PARAM : IDisposable
    {
        public int SslHashLength;
        public IntPtr pSslHash = IntPtr.Zero;
        public Guid AppId;
        [MarshalAs(UnmanagedType.LPWStr)]
        public string pSslCertStoreName;
        public uint DefaultCertCheckMode;
        public int DefaultRevocationFreshnessTime;
        public int DefaultRevocationUrlRetrievalTimeout;
        [MarshalAs(UnmanagedType.LPWStr)]
        public string pDefaultSslCtlIdentifier;
        [MarshalAs(UnmanagedType.LPWStr)]
        public string pDefaultSslCtlStoreName;
        public uint DefaultFlags;

        public HTTP_SERVICE_CONFIG_SSL_PARAM(byte[] certHash, string guid, bool enableCrlCheck)
        {
            if (certHash != null)
            {
                pSslHash = Marshal.AllocHGlobal(certHash.Length); 
                Marshal.Copy(certHash, 0, pSslHash, certHash.Length); 
                SslHashLength = certHash.Length;
            }
            else
            {
                pSslHash = IntPtr.Zero;
                SslHashLength = 0;
            }

            AppId = new Guid(guid);
            pSslCertStoreName = "My";
            DefaultCertCheckMode = enableCrlCheck ? (uint)0 : (uint)1;
            DefaultRevocationFreshnessTime = 0;
            DefaultRevocationUrlRetrievalTimeout = 0;
            pDefaultSslCtlIdentifier = null;
            pDefaultSslCtlStoreName = null;
            DefaultFlags = 0;
        }

        public override string ToString()
        {
            byte[] certHash = new byte[SslHashLength];
            Marshal.Copy(pSslHash, certHash, 0, SslHashLength);
            StringBuilder sbCertHash = new StringBuilder();
            foreach (byte b in certHash)
            {
                sbCertHash.Append(b.ToString("x2"));
            }

            StringBuilder sb = new StringBuilder();
            sb.AppendFormat("Certificate Hash             : {0}\r\n", sbCertHash.ToString());
            sb.AppendFormat("Application ID               : {0}\r\n", AppId);
            sb.AppendFormat("Certificate Store Name       : {0}\r\n", pSslCertStoreName);
            sb.AppendFormat("Verify Client Certificate Revocation : {0}\r\n", 
                            (DefaultCertCheckMode & 1) > 0 ? "Disabled" : "Enabled");
            sb.AppendFormat("Verify Revocation Using Cached Client Certificate Only : {0}\r\n",
                            (DefaultCertCheckMode & 2)  > 0? "Enabled" : "Disabled");
            sb.AppendFormat("Usage Check                  : {0}\r\n",
                            (DefaultCertCheckMode & 0x10000)  > 0? "Disabled" : "Enabled");
            sb.AppendFormat("Revocation Freshness Time    : {0}\r\n", DefaultRevocationFreshnessTime);
            sb.AppendFormat("URL Retrieval Timeout        : {0}\r\n", DefaultRevocationUrlRetrievalTimeout);
            sb.AppendFormat("Ctl Identifier               : {0}\r\n", pDefaultSslCtlIdentifier);
            sb.AppendFormat("Ctl Store Name               : {0}\r\n", pDefaultSslCtlStoreName);
            sb.AppendFormat("DS Mapper Usage              : {0}\r\n", (DefaultFlags & 1) > 0 ? "Enabled" : "Disabled");
            sb.AppendFormat("Negotiate Client Certificate : {0}\r\n", (DefaultFlags & 2) > 0 ? "Enabled" : "Disabled");

            return sb.ToString();
        }

        public void Dispose()
        {
            Marshal.FreeHGlobal(pSslHash);
            pSslHash = IntPtr.Zero;
        }

    }

    [StructLayout(LayoutKind.Sequential)]
    class HTTP_SERVICE_CONFIG_SSL_QUERY 
    {
        public HTTP_SERVICE_CONFIG_QUERY_TYPE QueryDesc;
        public HTTP_SERVICE_CONFIG_SSL_KEY KeyDesc;
        public uint dwToken;

        public HTTP_SERVICE_CONFIG_SSL_QUERY(IPAddress source, short port)
        {
            // Look up a single item
            QueryDesc = HTTP_SERVICE_CONFIG_QUERY_TYPE.HttpServiceConfigQueryExact;
            KeyDesc = new HTTP_SERVICE_CONFIG_SSL_KEY(source, port);
            dwToken = 0;
        }
    }


    // }}}

    // Flags
    // {{{{

    static readonly HTTPAPI_VERSION HTTPAPI_VERSION_1 = new HTTPAPI_VERSION(1, 0);
    const uint HTTP_INITIALIZE_SERVER = 0x00000001;
    const uint HTTP_INITIALIZE_CONFIG = 0x00000002;

    // }}}

    // Enums
    // {{{

    enum HTTP_SERVICE_CONFIG_ID
    {
        HttpServiceConfigIPListenList = 0,
        HttpServiceConfigSSLCertInfo,
        HttpServiceConfigUrlAclInfo,
        HttpServiceConfigMax
    }

    public enum HTTP_SERVICE_CONFIG_QUERY_TYPE
    {
        HttpServiceConfigQueryExact = 0,
        HttpServiceConfigQueryNext,
        HttpServiceConfigQueryMax
    }

    // }}}

    // HttpApiException and HttpApiNoCertificateException
    // {{{

    public class HttpApiException : Exception
    {
        public uint ErrorCode;

        public HttpApiException(uint win32error, string fmt, params object[] args)
            : base(String.Format(fmt, args))
        {
            ErrorCode = win32error;
        }
    }

    public class HttpApiNoCertificateException : HttpApiException
    {
        public HttpApiNoCertificateException(uint win32error, string fmt, params object[] args)
            : base(win32error, fmt, args)
        {
        }
    }

    // }}}

    public HttpApi()
    {
        uint retval;

        retval = HttpInitialize(HTTPAPI_VERSION_1, HTTP_INITIALIZE_CONFIG, IntPtr.Zero);
        if (retval != 0)
        {
            throw new HttpApiException(retval, "HttpInitialize failed");
        }
    }

    ~HttpApi()
    {
        Dispose();
    }

    public void Dispose()
    {
        HttpTerminate(HTTP_INITIALIZE_CONFIG, IntPtr.Zero);
    }

    public void SetSsl(IPAddress ip, short port, byte[] certHash, string guid, bool enableCrlCheck, StringBuilder strLog)
    {
        HTTP_SERVICE_CONFIG_SSL_KEY sslKey = new HTTP_SERVICE_CONFIG_SSL_KEY(ip, port);
        HTTP_SERVICE_CONFIG_SSL_PARAM sslParam = new HTTP_SERVICE_CONFIG_SSL_PARAM(certHash, guid, enableCrlCheck);
        using (HTTP_SERVICE_CONFIG_SSL_SET sslSet = new HTTP_SERVICE_CONFIG_SSL_SET(
                new HTTP_SERVICE_CONFIG_SSL_KEY(ip, port),
                new HTTP_SERVICE_CONFIG_SSL_PARAM(certHash, guid, enableCrlCheck)))
        {
            if (strLog != null)
            {
                strLog.Append("\r\nSSL Certficate bindings before HttpSetServiceConfiguration:\r\n");
                strLog.Append("------------------------\r\n");
                strLog.Append(sslSet.ToString() + "\r\n");
            }

            SetSsl(sslSet, strLog);
        }
    }

    public void ChangeCrlChecking(IPAddress ip, short port, bool enableCrlCheck, StringBuilder strLog)
    {
        HTTP_SERVICE_CONFIG_SSL_SET sslSet = null;
        HTTP_SERVICE_CONFIG_SSL_SET sslSetAfter = null;
        IntPtr pSslSet = IntPtr.Zero;
        IntPtr pSslSetAfter = IntPtr.Zero;
        try
        {
            if (strLog != null)
            {
                strLog.AppendFormat("Querying certificate for {0}:{1}\r\n", ip, port);
            }

            // Get existing one. Will throw exception if not found.
            QuerySsl(ip, port, out sslSet, out pSslSet, strLog);

            if (strLog != null)
            {
                strLog.Append("\r\nSSL Certficate bindings:\r\n");
                strLog.Append("------------------------\r\n");
                strLog.Append(sslSet.ToString() + "\r\n");
            }

            if (strLog != null)
            {
                strLog.AppendFormat("ChangeCrlChecking: DefaultCertCheckMode was {0}\r\n", sslSet.ParamDesc.DefaultCertCheckMode);
            }

            // Remove bit, then add ours
            sslSet.ParamDesc.DefaultCertCheckMode &= (uint)(~(uint)1);
            sslSet.ParamDesc.DefaultCertCheckMode |= enableCrlCheck ? (uint)0 : (uint)1;

            if (strLog != null)
            {
                strLog.AppendFormat("ChangeCrlChecking: DefaultCertCheckMode is now {0}\r\n", sslSet.ParamDesc.DefaultCertCheckMode);
            }

            // Now set it (actually delete then set)
            SetSsl(sslSet, strLog);

            // Query again to verify
            if (strLog != null)
            {
                QuerySsl(ip, port, out sslSetAfter, out pSslSetAfter, strLog);
                strLog.Append("\r\nSSL Certficate bindings after changing CRL checking:\r\n");
                strLog.Append("------------------------\r\n");
                strLog.Append(sslSetAfter.ToString() + "\r\n");
            }
        }
        finally
        {
            // Don't dispose sslSet, it will be taken care of when we free the pSslSet 
            // memory.
            Marshal.FreeCoTaskMem(pSslSet);
            Marshal.FreeCoTaskMem(pSslSetAfter);
            pSslSet = IntPtr.Zero;
            pSslSetAfter = IntPtr.Zero;
        }

    }

    //
    // Private functions
    // {{{

    private void SetSsl(HTTP_SERVICE_CONFIG_SSL_SET inputConfigInfo, StringBuilder strLog)
    {
        uint retval;
        IntPtr pInputConfigInfo = IntPtr.Zero;

        try
        {
            // @@@ We're going to leak this
            pInputConfigInfo = Marshal.AllocCoTaskMem(Marshal.SizeOf(typeof(HTTP_SERVICE_CONFIG_SSL_SET)));
            Marshal.StructureToPtr(inputConfigInfo, pInputConfigInfo, false);

            if (strLog != null)
            {
                strLog.Append("Calling HttpSetServiceConfiguration\r\n");
            }

            retval = HttpSetServiceConfiguration(
                IntPtr.Zero,
                HTTP_SERVICE_CONFIG_ID.HttpServiceConfigSSLCertInfo,
                pInputConfigInfo,
                Marshal.SizeOf(inputConfigInfo),
                IntPtr.Zero);

            if (183 == retval)  // ERROR_ALREADY_EXISTS
            {
                if (strLog != null)
                {
                    strLog.Append("Certificate exists, calling HttpDeleteServiceConfiguration\r\n");
                }

                // Delete it
                retval = HttpDeleteServiceConfiguration(
                    IntPtr.Zero,
                    HTTP_SERVICE_CONFIG_ID.HttpServiceConfigSSLCertInfo,
                    pInputConfigInfo,
                    Marshal.SizeOf(inputConfigInfo),
                    IntPtr.Zero);
                if (retval != 0)
                {
                    throw new HttpApiException(retval, "HttpDeleteServiceConfiguration failed");
                }

                if (strLog != null)
                {
                    strLog.Append("Calling HttpSetServiceConfiguration again\r\n");
                }

                // Try to set it again
                retval = HttpSetServiceConfiguration(
                    IntPtr.Zero,
                    HTTP_SERVICE_CONFIG_ID.HttpServiceConfigSSLCertInfo,
                    pInputConfigInfo,
                    Marshal.SizeOf(inputConfigInfo),
                    IntPtr.Zero);
            }

            if (strLog != null)
            {
                strLog.AppendFormat("Final HttpSetServiceConfiguration Win32 return value is {0}\r\n", retval);
            }

            if (1312 == retval) // ERROR_NO_SUCH_LOGON_SESSION
            {
                // Maybe this is true:
                // Check for ERROR_NO_SUCH_LOGON_SESSION.  According to MSDN in documentation for 
                // HttpSetServiceConfiguration, it fails with this error message when the certificate
                // is invalid.  Would be nice to have a more descriptive error 
                // message, though.
                throw new HttpApiException(retval, "HttpSetServiceConfiguration failed with ERROR_NO_SUCH_LOGON_SESSION. This may mean the certificate is invalid... maybe.");
            }
            else if (retval != 0)
            {
                throw new HttpApiException(retval, "HttpSetServiceConfiguration failed");
            }
        }
        finally
        {
            Marshal.FreeCoTaskMem(pInputConfigInfo);
            pInputConfigInfo = IntPtr.Zero;
        }

    }

    private void QuerySsl(IPAddress ip, short port, out HTTP_SERVICE_CONFIG_SSL_SET outputConfigInfo, out IntPtr pOutputConfigInfo, StringBuilder strLog)
    {
        uint retval;
        IntPtr pInputConfigInfo = IntPtr.Zero;

        try
        {
            HTTP_SERVICE_CONFIG_SSL_QUERY inputConfigInfo = new HTTP_SERVICE_CONFIG_SSL_QUERY(ip, port);
            pInputConfigInfo = Marshal.AllocCoTaskMem(Marshal.SizeOf(inputConfigInfo));
            Marshal.StructureToPtr(inputConfigInfo, pInputConfigInfo, false);

            pOutputConfigInfo = Marshal.AllocCoTaskMem(0);
            int returnLength = 0;

            if (strLog != null)
            {
                strLog.Append("Calling HttpQueryServiceConfiguration\r\n");
            }

            retval = HttpQueryServiceConfiguration(
                IntPtr.Zero,
                HTTP_SERVICE_CONFIG_ID.HttpServiceConfigSSLCertInfo,
                pInputConfigInfo,
                Marshal.SizeOf(inputConfigInfo),
                pOutputConfigInfo,
                returnLength,
                out returnLength,
                IntPtr.Zero);

            if (retval == 122)  // ERROR_INSUFFICIENT_BUFFER
            {
                // Try again with a large enough buffer
                Marshal.FreeCoTaskMem(pOutputConfigInfo);
                // @@@ We're going to leak this
                pOutputConfigInfo = Marshal.AllocCoTaskMem(Convert.ToInt32(returnLength));

                if (strLog != null)
                {
                    strLog.AppendFormat("Calling HttpQueryServiceConfiguration again using a buffer of size {0}\r\n", returnLength);
                }

                retval = HttpQueryServiceConfiguration(
                    IntPtr.Zero,
                    HTTP_SERVICE_CONFIG_ID.HttpServiceConfigSSLCertInfo,
                    pInputConfigInfo,
                    Marshal.SizeOf(inputConfigInfo),
                    pOutputConfigInfo,
                    returnLength,
                    out returnLength,
                    IntPtr.Zero);
            }

            if (strLog != null)
            {
                strLog.AppendFormat("Final HttpQueryServiceConfiguration Win32 return value is {0}\r\n", retval);
            }

            if (retval == 2)  // ERROR_FILE_NOT_FOUND
            {
                throw new HttpApiNoCertificateException(retval, "HttpQueryServiceConfiguration could not find a certificate for " +
                                    ip.ToString() + ":" + port);
            }
            else if (retval != 0)
            {
                throw new HttpApiException(retval, "HttpQueryServiceConfiguration failed");
            }


            outputConfigInfo = (HTTP_SERVICE_CONFIG_SSL_SET)Marshal.PtrToStructure(pOutputConfigInfo, typeof(HTTP_SERVICE_CONFIG_SSL_SET));
        }
        finally
        {
             Marshal.FreeCoTaskMem(pInputConfigInfo);
        }
    }

    // }}}

}



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\installer\machineconfig.cs ===
using System;
using System.Xml;
using System.IO;
using System.Threading;
using System.Runtime.InteropServices;
using System.Collections;
using System.DirectoryServices;
using System.Reflection;

namespace xonline.common.installer 
{

    class MachineConfigEditor
    {
        private XmlDocument _doc            = null;
        private XmlNode     _sysdiag        = null;
        private XmlNode     _sysweb         = null;
        private XmlNode     _sysnet         = null;
        private XmlNode     _sysnetSettings = null;
        private string      _path           = null;


        public XmlDocument Doc
        {
            get
            {
                if (_doc == null)
                {
                    _doc = new XmlDocument();
                    _doc.Load(Path);
                }
                return _doc;
            }
        }
            

        public string Path
        {
            get
            {
                if (_path == null)
                {
                    // $REVIEW (michion): Need to remove this hardcoded version/path for something better...
                    _path = Environment.GetEnvironmentVariable("systemroot") + "\\microsoft.net\\framework\\v2.0.50727\\config\\machine.config";

                    if (!File.Exists(_path))
                        throw new ApplicationException("Unable to local configuration file: " + _path);
                }
                return _path;
            }
        }
            

        public XmlNode SysDiag
        {
            get
            {
                if (_sysdiag == null)
                {
                    _sysdiag = Doc.DocumentElement.SelectSingleNode("system.diagnostics");
    
                    if (_sysdiag == null)
                    {
                        _sysdiag = Doc.CreateNode(XmlNodeType.Element, "system.diagnostics", "");
                        Doc.DocumentElement.AppendChild(_sysdiag);
                    }
                }
                return _sysdiag;
            }
        }
            

        public XmlNode SysWeb
        {
            get
            {
                if (_sysweb == null)
                {
                    _sysweb = Doc.DocumentElement.SelectSingleNode("system.web");
    
                    if (_sysweb == null)
                    {
                        _sysweb = Doc.CreateNode(XmlNodeType.Element, "system.web", "");
                        Doc.DocumentElement.AppendChild(_sysweb);
                    }
                }
                return _sysweb;
            }
        }
            
        public XmlNode SysNet
        {
            get
            {
                if (_sysnet == null)
                {
                    _sysnet = Doc.DocumentElement.SelectSingleNode("system.net");
    
                    if (_sysnet == null)
                    {
                        _sysnet = Doc.CreateNode(XmlNodeType.Element, "system.net", "");
                        Doc.DocumentElement.AppendChild(_sysnet);
                    }
                }
                return _sysnet;
            }
        }

        public XmlNode SysNetSettings
        {
            get
            {
                if (_sysnetSettings == null)
                {
                
                    _sysnetSettings = SysNet.SelectSingleNode("settings");
                    
                    if (_sysnetSettings == null)
                    {
                        _sysnetSettings = Doc.CreateNode(XmlNodeType.Element, "settings", "");
                        SysNet.AppendChild(_sysnetSettings);
                    }
                }
                
                return _sysnetSettings;
            }
        }


        public void ClearVersionHeader()
        {
            XmlNode http = SysWeb.SelectSingleNode("httpRuntime");
            if (http == null)
            {

                http = Doc.CreateNode(XmlNodeType.Element, "httpRuntime", null);
                SysWeb.AppendChild(http);
            }

            if (http.Attributes["enableVersionHeader"] == null)
            {
                XmlNode attr = Doc.CreateNode(XmlNodeType.Attribute, "enableVersionHeader", null);
                attr.Value = "false";
                http.Attributes.SetNamedItem(attr);
            }
            else
            {
                http.Attributes["enableVersionHeader"].Value = "false";
            }
        }


    
        public void SetPerfCtrFileMapSize()
        {
            SetPerfCtrFileMapSize(5242880);
        }


        public void SetPerfCtrFileMapSize(uint size)
        {
            XmlNode perf = SysDiag.SelectSingleNode("performanceCounters");
            if (perf == null)
            {
                perf = Doc.CreateNode(XmlNodeType.Element, "performanceCounters", null);
                SysDiag.AppendChild(perf);
            }

            IncreaseAttribute(perf, "filemappingsize", size);
        }


        
    
    
        public void SetProcessModel()
        {
            SetProcessModel(60,100,100);
        }


        public void SetProcessModel(uint cMemory, uint ctWork, uint ctIO)
        {
            XmlNode proc = SysWeb.SelectSingleNode("processModel");
            if (proc == null)
            {
                proc = Doc.CreateNode(XmlNodeType.Element, "processModel", null);
                SysDiag.AppendChild(proc);
            }

            IncreaseAttribute(proc, "memoryLimit", cMemory);
            IncreaseAttribute(proc, "maxWorkerThreads", ctWork);
            IncreaseAttribute(proc, "maxIoThreads", ctIO);
        }

        /*
            <settings>
                <servicePointManager expect100Continue="false"/>
            </settings>
        */
        public void SetHttpContinue(bool bSet)
        {
            XmlNode node = SysNetSettings.SelectSingleNode("servicePointManager");
            if (node == null)
            {
                node = Doc.CreateNode(XmlNodeType.Element, "servicePointManager", null);
                SysNetSettings.AppendChild(node);
            }

            SetAttribute(node, "expect100Continue", bSet.ToString());
        }
    
        private void SetAttribute(XmlNode node, string attrName, string attrValue)
        {
            if (node.Attributes[attrName] == null)
            {
                XmlNode attr = Doc.CreateNode(XmlNodeType.Attribute, attrName, null);
                attr.Value = attrValue.ToString();
                node.Attributes.SetNamedItem(attr);
            }
            else
            {
                node.Attributes[attrName].Value = attrValue;
            }
        }
        
        private void IncreaseAttribute(XmlNode node, string attrName, uint attrValue)
        {
            if (node.Attributes[attrName] == null)
            {
                XmlNode attr = Doc.CreateNode(XmlNodeType.Attribute, attrName, null);
                attr.Value = attrValue.ToString();
                node.Attributes.SetNamedItem(attr);
            }
            else
            {
                uint currSize = Convert.ToUInt32(node.Attributes[attrName].Value);

                if (attrValue > currSize)
                    node.Attributes[attrName].Value = attrValue.ToString();
            }
        }
        
    
    
    
        public void Commit()
        {
            int     retriesLeft = 10;
            bool    complete   = false;

            while (retriesLeft>0 && !complete)
            {
                try
                {
                    Doc.Save(Path);
                    complete = true;
                }
                catch (System.IO.IOException)
                {
                    retriesLeft--;
                    Thread.Sleep(3000);     // based on empirical data from XeTestNet, 3 second seems to 
                                            // be around the amount of time needed to avoid a second retry
                }
            }

            if (!complete)
            {
                throw new Exception("ERROR: Unable to write changes to machine.config after 10 retries");
            }
        }
    }



/*
    class test
    {
        [STAThread]
        static void Main(string[] args)
        {
            MachineConfigEditor foo = new MachineConfigEditor();

            foo.SetPerfCtrFileMapSize(88908803);
            foo.ClearVersionHeader();
            foo.SetProcessModel(88, 88, 888);
            foo.Commit();
        }
    
    }
*/


} //namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\CleanserProtocol.cs ===
// 
// CleanserProtocol.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// The ideal location for this file is in private/common/protocol
// However, that would require CommonConfig to pull in all of the
// protocols in building out the dll, and for C++ components using
// CommonConfig.tlh, we'll get duplicate struct definitions.
// Alternatively, we could specify a new XLUSE macro in the sources
// files (either to pull in just this file or to pull in a new 
// directory for reporting protocols), but that adds a step to component
// creation. Since any component that wants instrumentation will 
// have to pull in the management infrastructure, this is the best
// middle ground.
//

using System;
using System.Runtime.InteropServices;
using xonline.common.service;
using xonline.common.utilities2;

namespace xonline.common.mgmt 
{    
    using WireData = xonline.common.service.WireData;
    
    [ComVisible(false)]
    public enum RPT_MSG_TYPE : byte
    {
        RPT_MSG_NONE = 0,
        RPT_MSG_CONNECT = 1,
        RPT_MSG_DISCONNECT = 2,
        RPT_MSG_DATA = 3,
        RPT_MSG_KEEPALIVE = 4,
        RPT_MSG_DATA_2 = 5,
        RPT_MSG_DATA_3 = 6
    }

    [ComVisible(false)]
    public class ReportMessageBase : WireData
    {
	static public int cMinMessageSizeBytes = 12;

        public ReportMessageBase() 
            : this(0)
        {
        }

        public ReportMessageBase(RPT_MSG_TYPE msgType)
        {
            bMsgType = (byte)msgType;
            bReserved = 0;
            usSize = 0;
            llTime = DateTime.UtcNow.ToFileTimeUtc( );
        }

        public byte bMsgType;
        public byte bReserved;

        // Note: this is normally supposed to be the size of the payload after the 12 
        // bytes of headers. There seem to be some exceptions to this rule, such as for 
        // ReportMessageConnect. Head's up, here be dragons.

        public ushort usSize;
        public long llTime;
    }

    [ComVisible(false)]
    public class ReportMessageConnect : ReportMessageBase
    {
        public ReportMessageConnect( ) 
            : base(RPT_MSG_TYPE.RPT_MSG_CONNECT)
        {
            vcServer = "Unknown";
            iComponentID = 0;
        }
    
        public Int32 iComponentID;

        // Note: using usSize for this is WRONG, but we have to maintain back-compat, so 
        // it is what it is.
        [WireInfo(SizeParam = "usSize")]
        public string vcServer;  // NPDB t_Servers.VC_SERVER nvarchar(64)
    }

    [ComVisible(false)]
    public class ReportMessageData : ReportMessageBase
    {
        public ReportMessageData( ) 
            : base(RPT_MSG_TYPE.RPT_MSG_DATA)
        {
            szMessage = null;
        }

        // Note: this is lazy... but it works.
        [WireInfo(SizeParam="usSize")]
        public string szMessage;
    }

    [ComVisible(false)]
    public class ReportMessageData2 : ReportMessageBase 
    {
        public ReportMessageData2( ) 
            : base(RPT_MSG_TYPE.RPT_MSG_DATA_2)
        {
            szMessageSize = 0;
            szMessage = null;
            LogStringIdSize = 0;
            EtxEventFingerprintSize = 0;
            WebRepGroupId = 0;
            EtxEventHeaderVersion = 0;
            EtxEventFingerprint = null;
            LogStringId = null;
        }

        public ReportMessageData2(ReportMessageData md)
            : this()
        {
            szMessageSize = md.usSize;
            szMessage = md.szMessage;
        }

        public ushort szMessageSize;
        [WireInfo(SizeParam="szMessageSize")]
        public string szMessage;

        public ushort LogStringIdSize;
        [WireInfo(Max=16)]
        public ushort EtxEventFingerprintSize;
        public uint WebRepGroupId;
        public byte EtxEventHeaderVersion;

        [WireInfo(SizeParam="EtxEventFingerprintSize")]
        public byte[] EtxEventFingerprint;
        [WireInfo(SizeParam="LogStringIdSize")]
        public string LogStringId;
    }

    [ComVisible(false)]
    public class ReportMessageData3 : ReportMessageBase
    {
        public ReportMessageData3()
            : base(RPT_MSG_TYPE.RPT_MSG_DATA_3)
        {
            szMessageSize = 0;
            szMessage = null;
            LogStringIdSize = 0;
            EtxEventFingerprintSize = 0;
            EtxEventHeaderVersion = 0;
            EtxEventFingerprint = null;
            LogStringId = null;
            FileNameKeySize = 0;
            FileNameKey = null;
        }

        public ReportMessageData3(ReportMessageData md)
            : this()
        {
            szMessageSize = md.usSize;
            szMessage = md.szMessage;
        }

        public ReportMessageData3(ReportMessageData2 md)
            : this()
        {
            szMessageSize = md.usSize;
            szMessage = md.szMessage;
            LogStringIdSize = md.LogStringIdSize;
            EtxEventFingerprintSize = md.EtxEventFingerprintSize;
            EtxEventHeaderVersion = md.EtxEventHeaderVersion;
            EtxEventFingerprint = md.EtxEventFingerprint;
            LogStringId = md.LogStringId;

            if (md.EtxEventFingerprint != null && md.EtxEventFingerprint.Length > 0)
            {
                FileNameKey = String.Format("{0}-{1}", (Blob)md.EtxEventFingerprint, EtxEventHeaderVersion);
            }
            else
            {
                FileNameKey = String.Format("EMPTY-{0}", EtxEventHeaderVersion); 
            }

            FileNameKeySize = (ushort)FileNameKey.Length;
        }

        public ushort szMessageSize;
        [WireInfo(SizeParam = "szMessageSize")]
        public string szMessage;

        public ushort LogStringIdSize;
        [WireInfo(Max = 16)]
        public ushort EtxEventFingerprintSize;
        public byte EtxEventHeaderVersion;

        [WireInfo(SizeParam = "EtxEventFingerprintSize")]
        public byte[] EtxEventFingerprint;
        [WireInfo(SizeParam = "LogStringIdSize")]
        public string LogStringId;

        public ushort FileNameKeySize;
        [WireInfo(SizeParam = "FileNameKeySize")]
        public string FileNameKey;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\lsp\lsplib.cs ===
//
// lsplib.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Lsp common code  
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Data;
using System.Data.SqlClient;

using xonline.common.service;
using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.protocol;
using xonline.common.sql.sqlclient;
using xonline.common.mgmt;

namespace xonline.common.lsp
{
    public class LspLib
    {
        static LspLib()
        {
            _LspCacheLock = new object();
            _LspCache = new Dictionary<string, LspCacheValue>(100);  // arbitrary

            _FastFail = new FastFailHelper(
                Setting.lspfd_fastFailTimeoutThresholdCount,
                Setting.lspfd_fastFailTimeoutTimespanSeconds,
                Setting.lspfd_fastFailBlockIntervalSeconds,
                XEvent.Id.COMMON_CODE_LSPLIB_SQLEXCEPTION,
                XEvent.Id.FAIL_FAST_EXIT);
        }


        // Update
        // Update a Lsp advertisement row in the database. If the row doesn't
        // exist, it will be inserted. The key is [title-id, ipSgLsp]
        public static void Update(
            uint            titleId,
            uint            ipSgLsp,
            uint            ttlInSeconds,
            uint            flags,
            string          userData,
            byte[]          xnkid,
            byte[]          xnkey
        )
        {
            Assert.IsTrue(xnkid != null && xnkid.Length == LspProtocolConstants.XONLINE_LSP_XNKID_LEN);
            Assert.IsTrue(xnkey != null && xnkey.Length == LspProtocolConstants.XONLINE_LSP_XNKEY_LEN);
            Assert.IsTrue(ttlInSeconds <= LspProtocolConstants.XONLINE_LSP_MAX_EXPIRATION_SECONDS);

            SqlClient cmd = null;

            if (_FastFail.InFastFailState(Interface.querydb))
            {
                // @@@ kgoodier Failing gracefully may be smarter, but we're just going to
                // throw an exception for now. Same behavior as before, but faster!
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_RESOURCE_UNAVAILABLE,
                    String.Format("'{0}' is in a fast-fail state, operation aborted.", Interface.querydb));
            }

            try
            {
                cmd = new SqlClient(Interface.querydb,
                                    titleId,
                                    LspProtocolConstants.XONLINE_LSP_DEFAULT_DATASET);

                cmd.StoredProc = "dbo.p_lsp_update";
                cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);

                cmd.AddParameter("@i_title_id",         (int)titleId);
                cmd.AddParameter("@i_sglsp_ip",         (int)ipSgLsp);
                cmd.AddParameter("@i_ttl_in_seconds",   (int)ttlInSeconds);
                cmd.AddParameter("@i_flags",            (int)flags);
                cmd.AddParameter("@vc_user_data",       userData);
                cmd.AddParameter("@b_xnkid",            xnkid);
                cmd.AddParameter("@b_xnkey",            xnkey);

                cmd.ExecuteNonQuery();

                // Stored procedure will never return a non-zero status
                // unaccompanied of a SQL exception.
                Assert.IsTrue(cmd.GetIntParameter("@ret") == 0);
            }
            catch (Exception e)
            {
                if (FastFailHelper.ConsiderExceptionAsTimeout(e))
                {
                    _FastFail.ReportFailure(Interface.querydb, e.ToString());
                }
                throw;
            }
            finally
            {
                if(cmd != null)
                    cmd.Close();

                // ok to report success after failure, it will be ignored
                _FastFail.ReportSuccess(Interface.querydb);
            }
        }

        public class LspInfo
        {
            public uint     titleId;
            public uint     ipSgLsp;
            public uint     flags;
            public string   userData;
            public byte[]   xnkid;
            public byte[]   xnkey;
        }

        // Enumerate
        // Enumerate Lsp advertisements for a title
        // - titleId: the title-id of the entries to be enumerated
        // - userData: if userData is not null, only results with matching userData will
        // be returned. If it's null, all results will be returned
        // - startingIndex: the index of the first entry
        // - lspInfoCount: maximum number of entries to retrieve starting at the
        // 'startingIndex'
        // - lspInfo (out): receive new array with enumerated entries
        // - totalEntries (out): receive the total number of entries in the database (not
        // the number of entries being returned)
        public static void Enumerate(
            uint            titleId,
            string          userData,
            uint            startingIndex,
            uint            lspInfoCount,
            out LspInfo[]   lspInfo,
            out uint        totalEntries
        )
        {
            Assert.IsTrue(userData == null || userData.Length <= LspProtocolConstants.XONLINE_LSP_MAX_USER_DATA_LEN);
            Assert.IsTrue(lspInfoCount > 0 && lspInfoCount <= LspProtocolConstants.XONLINE_LSP_MAX_LSP_INFO);

            SqlClient       cmd     = null;
            SqlDataReader   reader  = null;
            ArrayList       results = new ArrayList((int)lspInfoCount);

            totalEntries = 0;

            if (_FastFail.InFastFailState(Interface.querydb))
            {
                // @@@ kgoodier Failing gracefully may be smarter, but we're just going to
                // throw an exception for now. Same behavior as before, but faster!
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_RESOURCE_UNAVAILABLE,
                    String.Format("'{0}' is in a fast-fail state, operation aborted.", Interface.querydb));
            }

            try
            {
                cmd = new SqlClient(Interface.querydb,
                                    titleId,
                                    LspProtocolConstants.XONLINE_LSP_DEFAULT_DATASET);

                cmd.StoredProc = "dbo.p_lsp_enumerate";
                cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);

                cmd.AddParameter("@i_title_id", (int)titleId);

                if(userData != null)
                {
                    cmd.AddParameter("@vc_user_data", userData);
                }
                else
                {
                    cmd.AddParameterObject("@vc_user_data", DBNull.Value);
                }

                try {
                    reader = cmd.Execute();

                    //
                    // skip entries at the beginning until we reach the one we want
                    //

                    for(int skipped=0; skipped < startingIndex; skipped++)
                    {
                        if(!reader.Read())
                            break;

                        totalEntries++;
                    }

                    //
                    // read at most 'lspInfoCount' entries
                    //

                    for(int count=0; count < lspInfoCount; count++)
                    {
                        if(!reader.Read())
                            break;

                        totalEntries++;

                        LspInfo info  = new LspInfo();
                        info.titleId  = titleId;
                        info.ipSgLsp  = (uint) reader.GetInt32(0);
                        info.flags    = (uint) reader.GetInt32(1);
                        info.userData = reader.GetString(2);
                        info.xnkid    = reader.GetSqlBinary(3).Value;
                        info.xnkey    = reader.GetSqlBinary(4).Value;

                        if(info.xnkid == null
                           || info.xnkid.Length != LspProtocolConstants.XONLINE_LSP_XNKID_LEN
                           || info.xnkey == null
                           || info.xnkey.Length != LspProtocolConstants.XONLINE_LSP_XNKEY_LEN)
                        {
                            string log = string.Format(
                                "Command: {0} returned an invalid entry ipSgLsp:0x{1} with " +
                                "invalid key size.", cmd.Command,
                                info.ipSgLsp.ToString("x8"));

                          Xom.NtEvent(XEvent.Id.COMMON_CODE_26, log);
                            continue;
                        }

                        results.Add(info);
                    }

                    //
                    // count remaining entries but discard them
                    //

                    while(reader.Read())
                    {
                        totalEntries++;
                    }

                    reader.Close();
                    reader = null;
                }
                catch (SqlException e) {
                    HResult hr = HResult.XONLINE_E_DATABASE_ERROR;
                    if (e.Message.Contains("deadlock")) hr = HResult.XONLINE_E_DATABASE_DEADLOCK;

                    throw new XRLException(
                        hr, XEvent.Id.LSPLIB_DATABASE_ERROR, "Error reading from query db", e
                    );
                }

                //
                // Stored procedure will never return a non-zero status
                // unaccompanied of a SQL exception.
                //

                Assert.IsTrue(cmd.GetIntParameter("@ret") == 0);
            }
            catch (ApplicationException ae)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_LSP_BUCKET_INTERFACE_CONFIG_ERROR,
                    ae,
                    "LspLib.Enumerate({0},...) threw an ApplicationException",
                    titleId
                    );
            }
            catch (Exception e)
            {
                if (FastFailHelper.ConsiderExceptionAsTimeout(e))
                {
                    _FastFail.ReportFailure(Interface.querydb, e.ToString());
                }
                throw;
            }
            finally
            {
                if(reader != null)
                    reader.Close();

                if(cmd != null)
                    cmd.Close();

                // ok to report success after failure, it will be ignored
                _FastFail.ReportSuccess(Interface.querydb);
            }

            lspInfo = (LspInfo[])results.ToArray(typeof(LspInfo));
        }

        public enum EnumStatus
        {
            Unknown,
            FromDb,
            FromCache,
            FromCacheDbDown
        }

        // EnumerateWithCache
        // Enumerate Lsp advertisements for a title. Uses a local cache, and if entry is
        // not present there or is expired, will hit the DB to refresh it.
        //
        // See Enumerate() for param descriptions.
        //
        public static EnumStatus EnumerateWithCache(
            uint            titleId,
            string          userData,
            uint            startingIndex,
            uint            lspInfoCount,
            out LspInfo[]   lspInfo,
            out uint        totalEntries
        )
        {
            string          key;
            LspCacheValue   record = null;
            bool            bRecordInCache = false;

            // Retrieve record
            key = LspCacheValue.MakeKey(titleId, userData, startingIndex, lspInfoCount);
            lock (_LspCacheLock)
            {
                // Note: it's possible this lock, for reading, isn't necessary. It's
                // inconclusive right now, so safer to leave it in.
                bRecordInCache = _LspCache.TryGetValue(key, out record);
            }

            // Found an entry and not expired, then use it!
            if (bRecordInCache && !record.IsExpired)
            {
                totalEntries = record._TotalEntries;
                lspInfo = record._LspInfo;
                return EnumStatus.FromCache;
            }

            try
            {
                // Time to hit the querydb again. Good luck.
                Enumerate(titleId, userData, startingIndex, lspInfoCount, out lspInfo, out totalEntries);
            }
            catch (Exception e)
            {
                // Did we fail b/c the querydb is unavailable?
                if (e is XRLExceptionWithoutEvent ||  // kinda fragile...
                    FastFailHelper.ConsiderExceptionAsTimeout(e))
                {
                    if (bRecordInCache)
                    {
                        // Record is perfectly valid except it's expired, so we're going to
                        // keep using it since we're getting sql exceptions. Should help with
                        // the zero-downtime scenario for querydb.
                        // @@@ kgoodier Bump up the expiration time?
                        totalEntries = record._TotalEntries;
                        lspInfo = record._LspInfo;
                        return EnumStatus.FromCacheDbDown;
                    }
                }
                throw;
            }

            // Put it in the cache
            record = new LspCacheValue(startingIndex, lspInfoCount, lspInfo, totalEntries);

            lock (_LspCacheLock)
            {
                _LspCache[key] = record;
            }

            return EnumStatus.FromDb;
        }


        // RemoveAll
        // Remove all entries related associated to a title
        public static void RemoveAll(uint titleId)
        {
            SqlClient cmd = null;

            try
            {
                cmd = new SqlClient(Interface.querydb,
                                    titleId,
                                    LspProtocolConstants.XONLINE_LSP_DEFAULT_DATASET);

                cmd.StoredProc = "dbo.p_lsp_remove_all";
                cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);
                cmd.AddParameter("@i_title_id", (int)titleId);

                cmd.ExecuteNonQuery();

                // Stored procedure will never return a non-zero status
                // unaccompanied of a SQL exception.
                Assert.IsTrue(cmd.GetIntParameter("@ret") == 0);
            }
            finally
            {
                if(cmd != null)
                    cmd.Close();
            }



        }

        public static string GetStatus()
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendFormat("Enumerate cache entries    : {0}\r\n", _LspCache.Count);
            sb.AppendFormat("FastFail state for querydb : {0}\r\n", _FastFail.GetCurrentStatus(Interface.querydb));

            return sb.ToString();
        }

        public static void ResetCache()
        {
            lock (_LspCacheLock)
            {
                _LspCache.Clear();
            }
        }

        public static int CacheEntries
        {
            get { return _LspCache.Count; }
        }

        public static FastFailInternal.FFState FastFailState
        {
            get { return _FastFail.GetCurrentStatus(Interface.querydb); }
        }

        private static Dictionary<string, LspCacheValue> _LspCache;
        private static object                            _LspCacheLock;
        private static FastFailHelper                    _FastFail;

        // Note: one might think that a ReaderWriterLock would make more sense then a
        // traditional lock for the _LspCache, and you would be right. But the .Net
        // ReaderWriterLock has some pretty bad characteristics (performance, reader
        // priority) that make it ill-suited for most tasks, including this one.

    }


    class LspCacheValue
    {
        public LspCacheValue(
            uint             startingIndex,
            uint             lspInfoCount,
            LspLib.LspInfo[] lspInfo,
            uint             totalEntries
            )
        {
            _StartingIndex = startingIndex;
            _LspInfoCount  = lspInfoCount;
            _LspInfo       = lspInfo;
            _TotalEntries  = totalEntries;

            // We don't know the original expiration time, so use something less than the
            // LSPSG's default advertise rate (30 seconds if call is failing, 120 seconds
            // mainline).
            //_ExpireTime    = DateTime.Now.AddSeconds(totalEntries == 0 ? 15 : 120);
            _ExpireTime = DateTime.Now.AddSeconds(30);
        }

        public static string MakeKey(uint titleId, string userData, uint startingIndex, uint lspInfoCount)
        {
            return titleId.ToString("X8") + startingIndex.ToString("X8") + lspInfoCount.ToString("X8") + userData;
        }

        public bool IsExpired
        {
            get
            {
                return DateTime.Now > _ExpireTime;
            }
        }


        public uint             _StartingIndex;
        public uint             _LspInfoCount;
        public LspLib.LspInfo[] _LspInfo;
        public uint             _TotalEntries;
        public DateTime         _ExpireTime;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\installer\XomConfiguratorInstall.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Threading;
using System.Web;
using System.Web.Caching;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;

namespace xonline.common.installer 
{
    /// <summary>
    /// Installer Attribute Class
    /// </summary>
    [AttributeUsage( AttributeTargets.Assembly, AllowMultiple=true )]
    public class XomInstallerAttribute : Attribute
    {
        public XomInstallerAttribute( string interfaceKey, Type configuratorType )
        {
            this.interfaceKey = interfaceKey;
            this.configuratorType = configuratorType;
        }

        private string interfaceKey;
        private Type configuratorType;

        public string InterfaceKey
        {
            get { return interfaceKey; }
        }

        public virtual Type ConfiguratorType
        {
            get { return configuratorType; }
        }
    }

    /// <summary>
    /// IIS Installer Attribute Class
    /// </summary>
    [AttributeUsage( AttributeTargets.Assembly, AllowMultiple=true )]
    public class XomIisInstallerAttribute : XomInstallerAttribute
    {
        public XomIisInstallerAttribute( string interfaceKey) : base(interfaceKey, typeof(XomIisConfigurator)) {}
    }

    /// <summary>
    /// SSL Installer Attribute Class
    /// Creates an SSL secured VSite/VDir (applicable to XCBK front doors)
    /// </summary>
    [AttributeUsage( AttributeTargets.Assembly, AllowMultiple=true )]
    public class XomSslInstallerAttribute : XomInstallerAttribute
    {
        public XomSslInstallerAttribute(string interfaceKey) : base(interfaceKey, typeof(XomIisConfiguratorSSL)) { }
    }

    /// <summary>
    /// SSL Installer Attribute Class
    /// Creates an SSL secured VSite/VDir (applicable to XCBK front doors)
    /// </summary>
    [AttributeUsage( AttributeTargets.Assembly, AllowMultiple=true )]
    public class XomXCBKInstallerAttribute : XomInstallerAttribute
    {
        public XomXCBKInstallerAttribute(string interfaceKey) : base(interfaceKey, typeof(XomIisConfiguratorXCBK)) { }
    }


    /// <summary>
    /// SRF Installer Attribute Class
    /// Creates a standard VSite/VDir but adds a mapping for .SRF extensions to be processed
    /// </summary>
    [AttributeUsage( AttributeTargets.Assembly, AllowMultiple=true )]
    public class XomSrfInstallerAttribute : XomInstallerAttribute
    {
        public XomSrfInstallerAttribute(string interfaceKey) : base(interfaceKey, typeof(XomIisConfiguratorSRF)) { }
    }


    [AttributeUsage( AttributeTargets.Assembly, AllowMultiple=true )]
    public class XomXTOUInstallerAttribute : XomInstallerAttribute
    {
        public XomXTOUInstallerAttribute(string interfaceKey) : base(interfaceKey, typeof(XomIisConfiguratorXTOU)) { }
    }

    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
    public class XomIisNet4InstallerAttribute : XomInstallerAttribute
    {
        public XomIisNet4InstallerAttribute(string interfaceKey)
            : base(interfaceKey, typeof(XomIisNet4Configurator)) 
        {
        }
    }


    [AttributeUsage( AttributeTargets.Assembly, AllowMultiple=true )]
    public class XomDLInstallerAttribute : XomInstallerAttribute
    {
        public XomDLInstallerAttribute(string interfaceKey) : base(interfaceKey, typeof(XomIisConfiguratorDL)) { }
    }



    [AttributeUsage( AttributeTargets.Assembly, AllowMultiple=true )]
    public class XomWBSGInstallerAttribute : XomInstallerAttribute
    {
        public XomWBSGInstallerAttribute(string interfaceKey) : base(interfaceKey, typeof(XomWBSGConfigurator)) { }
    }



    [AttributeUsage( AttributeTargets.Assembly, AllowMultiple=true )]
    public class XomXRLScanInstallerAttribute : XomInstallerAttribute
    {
        public XomXRLScanInstallerAttribute(string interfaceKey) : base(interfaceKey, typeof(XomXRLScanConfigurator)) { }
    }


    [AttributeUsage( AttributeTargets.Assembly, AllowMultiple=true )]
    public class XomMachineCertsConfiguratorAttribute : XomInstallerAttribute
    {
        public XomMachineCertsConfiguratorAttribute(string certIdentifier) : base(certIdentifier, typeof(XomMachineCertsConfigurator)) { }
    }





    // Installs the performance counters in the machine. Run InstallUtil.exe
    // against this assembly to get the counters installed before running the
    // service.

    [RunInstaller(true)]
    public class XomConfiguratorInstall : System.Configuration.Install.Installer
    {
        private Assembly GetAssembly()
        {
            return Assembly.GetAssembly(this.GetType());
        }

        /// <summary>
        /// Install()
        /// Function to called upon invocation of installutil.exe in install mode.
        /// This method will examine the assembly and find all classes derived from
        /// the XomInterfaceConfigurator class and will invoke the Commit() method
        /// on those classes to have them "install" their interface
        /// </summary>
        public override void Install(IDictionary stateSaver)
        {
            base.Install(stateSaver);
            
            LogMessage("Configurator: Beginning Install()");

            Xom.NtEvent( XEvent.Id.COMMON_INFO_43, "Beginning Install of component " + Config.ComponentName );

            // we want the assembly for the installer so we  can  get
            // the attributes associated with that specific installer

            // Enumerate through all the XomInstallerAttribute derived 
            // classes in the assembly for the installer.

            XomInstallerAttribute[] rgInstallAttributes = (XomInstallerAttribute[]) Attribute.GetCustomAttributes(GetAssembly(), typeof( XomInstallerAttribute ) );
 
            foreach( XomInstallerAttribute a in rgInstallAttributes )
            {
                Type t = a.ConfiguratorType;

                XomInterfaceConfigurator  baseConfigurator = null;
                
                Object[] parms = new Object[1] {Context};

                LogMessage("Configurator: Processing subclass " + t.Name);

                baseConfigurator = (XomInterfaceConfigurator) Activator.CreateInstance(t);

                if (baseConfigurator != null)
                {
                    baseConfigurator.Assembly = GetAssembly();
                    baseConfigurator.InterfaceKey = a.InterfaceKey;
                    baseConfigurator.Context = Context;
                    baseConfigurator.Commit(stateSaver);
                }
                else
                {
                    LogMessage("ERROR: Failed to CreateInstance of " + t.Name);
                }
            }

          Xom.NtEvent( XEvent.Id.COMMON_INFO_44, "Install of component " + Config.ComponentName + " complete.");
            
        }


        // Called by the installer on uninstall. Removes all counters associated
        // to the classes of the local assembly.
        public override void Uninstall(IDictionary savedState)
        {
            base.Uninstall(savedState);

            LogMessage("Configurator: Begining Uninstall()");

            // Enumerate through all the XomInstallerAttribute derived 
            // classes in the installer's assembly.
 
            XomInstallerAttribute[] rgInstallAttributes = (XomInstallerAttribute[]) Attribute.GetCustomAttributes(GetAssembly(), typeof( XomInstallerAttribute ) );
 
            foreach( XomInstallerAttribute a in rgInstallAttributes )
            {
                Type t = a.ConfiguratorType;

                XomInterfaceConfigurator  baseConfigurator = null;
                
                Object[] parms = new Object[1] {Context};

                LogMessage("Configurator: Processing subclass " + t.Name);

                baseConfigurator = (XomInterfaceConfigurator) Activator.CreateInstance(t);

                if (baseConfigurator != null)
                {
                    baseConfigurator.Assembly = GetAssembly();
                    baseConfigurator.InterfaceKey = a.InterfaceKey;
                    baseConfigurator.Context = Context;
                    baseConfigurator.UnCommit(savedState);
                }
                else
                {
                    LogMessage("ERROR: Failed to CreateInstance of " + t.Name);
                }
            }


//            foreach (DictionaryEntry foo in savedState)


        }

        public void LogMessage(String message)
        {
            String stampedMessage = String.Format("[{0:dd-MM-yyyy HH:mm:ss.fff}] {1}", DateTime.Now, message).
                            Replace("\n", "\n                             ");

            Context.LogMessage(stampedMessage);
        }

        public void LogMessage(String message, Object[] args)
        {
            String formattedMessage = String.Format(message, args);

            LogMessage(message);
        }

    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\ReportConnection.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Threading;
using xonline.common.mgmt;
using xonline.common.service;

// trace area for ReportConnection code
[assembly: XomAreaDefinition(XomAreaName.ReportConnection)]

namespace xonline.common.mgmt
{
    using WireData = xonline.common.service.WireData;

    [ComVisible(false)]
    public class ReportConnection
    {
        private class ConnectionContext
        {
            public byte[] ReceiveBuffer;
            public int ReceiveBufferOffset;
            public int Receiving;
            public int State;
            public NetworkStream NetworkStream;
            public TcpClient TcpClient;
            public object ConnectionLock = new object();

            public bool IsConnected
            {
                get { return (State != S_NOT_CONNECTED && NetworkStream != null); }
            }
        }
        
        public int MaxQueueSize { get; set; }

        private const int s_iReceiveBufferSize = 16384;

        public ReportConnection( )
            : this(10240)
        {
        }

        public ReportConnection( int maxQueueSize )
        {
            MaxQueueSize = maxQueueSize;

            _listBuffers = new LinkedList<WireData>();
            _iDroppedEvent = 0;

            // Try to obtain the host name
            string hostName = "Unknown";
            try{
                hostName = Dns.GetHostName();
            }
            catch(Exception) // Silently fail - use "Unknown"
            {

            }
            _vcServer = hostName;
            _iComponentID = 0;

            _iInitialized = 0;
            _threadSend = null;
            _iShutdown = 0;
            _hSendThread = new AutoResetEvent( false );

        }

        public void Startup( )
        {
            //
            // Just return if we've already been called
            //
            if( 1 == Interlocked.Exchange( ref _iInitialized, 1 ) )
            {
                goto lDone;
            }

            ReportTargetCounters.Current(Component).MessagesTotal.RawValue = 0;
            ReportTargetCounters.Current(Component).QueueLength.RawValue = 0;

            try
            {
                _threadSend = new XboxLiveThread( new ThreadStart( this._SendThread ) );
                _threadSend.Start( );
            }
            catch( Exception )
            {
                Interlocked.Exchange( ref _iInitialized, 0 );
                throw;
            }

        lDone:

            return;
        }

        public void Shutdown( )
        {
            //
            // Return if we're not initialized
            //
            if( 0 == _iInitialized )
            {
                goto lDone;
            }

            //
            // Just return if we've already been called
            //
            if( 1 == Interlocked.Exchange( ref _iShutdown, 1 ) )
            {
                goto lDone;
            }

            //
            // Abort the send thread
            //
            if( !_hSendThread.Set( ) )
            {
                Xom.NtEvent( XEvent.Id.COMMON_CODE_27, "[ReportConnection.Shutdown]: Unable to signal thread to shutdown. Going to abort the thread." );
                _threadSend.Abort( );
            }

        lDone:
            return;
        }

        private void OnConnect( ConnectionContext context )
        {
            ReportMessageConnect msgConnect;

            msgConnect = new ReportMessageConnect( );
            msgConnect.vcServer = _vcServer;
            msgConnect.iComponentID = _iComponentID;

            try
            {
                WireData wireData;
                wireData = msgConnect;
                byte[] rgbData = ( byte[] ) wireData;
                lock (context.ConnectionLock)
                {
                    context.NetworkStream.Write( rgbData, 0, rgbData.Length );
                    context.State = S_CONNECTED;
                }
                _hSendThread.Set( );
                StartReceiving( context );
            }
            catch(Exception e)
            {
                Xom.NtEvent( XEvent.Id.COMMON_CODE_28, e, "[ReportConnection.OnConnect]: NetStream::Write failed");

                // uhhh
                throw;
            }
        }

        public void AttachAndConnect(string host, int port)
        {
            //
            // We require a valid end point
            //
            if (String.IsNullOrEmpty(host))
            {
                throw new ArgumentNullException("host");
            }

            AttachAndConnect(() =>
                {
                    TcpClient client = new TcpClient();
                    client.Connect(host, port);
                    return client;
                });

            Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_NORMAL, "[ReportConnnection.AttachAndConnect]: Attached TcpClient to {0}:{1}", host, port);
        }

        public void AttachAndConnect(IPEndPoint ipAddr)
        {
            //
            // We require a valid end point
            //
            if (null == ipAddr)
            {
                throw new ArgumentNullException("ipAddr");
            }

            AttachAndConnect(() =>
            {
                TcpClient client = new TcpClient();
                client.Connect(ipAddr);
                return client;
            });

            Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_NORMAL, "[ReportConnnection.AttachAndConnect]: Attached TcpClient to " + ipAddr.ToString());
        }

        private void AttachAndConnect(Func<TcpClient> clientFactory)
        {
            ConnectionContext context;
            ConnectionContext old;

            context = new ConnectionContext();

            context.ReceiveBuffer = new byte[s_iReceiveBufferSize];
            context.ReceiveBufferOffset = 0;
            context.Receiving = 0;
            context.State = S_NOT_CONNECTED;

            // Heads up, This may throw if the write fails.
            for (int retry = 0; retry < 3; retry++)
            {
                try
                {
                    //
                    // Connect to the server
                    //
                    context.TcpClient = clientFactory();
                    context.NetworkStream = context.TcpClient.GetStream();

                    OnConnect(context);
                    break;
                }
                catch (Exception e)
                {
                    Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_ERROR,
                              "[AttachAndConnect]: Connection attempt #{0} of 3 failed: {1}", 
                              retry+1, e.ToString());

                    try
                    {
                        if (context.NetworkStream != null)
                        {
                            context.NetworkStream.Close();
                            context.NetworkStream = null;
                        }
                        if (context.TcpClient != null)
                        {
                            context.TcpClient.Close( );
                        }
                    }
                    catch (Exception)
                    {
                    }

                    if (retry == 2)
                    {
                        // aw crap
                        throw;
                    }
                }
            }

            old = Interlocked.Exchange(ref _connectionContext, context);

            //
            // Close any existing tcp client object and net stream object
            //
            if (null != old)
            {
                Disconnect(old);
            }
        }

        public void Send( WireData wireData )
        {
            lock( _listBuffers )
            {
                //
                // If the queue is full, drop the buffer.
                // We'll slightly cheat for a "must send first" package and just send that one.
                //
                if( _listBuffers.Count >= MaxQueueSize )
                {
                    Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_LOW, "[ReportConnection.Send]: Outbound queue is full. Dropping buffer.");
                    if( 1 != Interlocked.Exchange( ref _iDroppedEvent, 1 ) )
                    {
                        Xom.NtEvent( XEvent.Id.COMMON_COMM_8, "[ReportConnection.Send]: Outbound queue is full. Dropping buffer. Queue size is: " + MaxQueueSize.ToString() );
                    }
                    goto lDone;
                }

                if( 0 != Interlocked.Exchange( ref _iDroppedEvent, 0 ) )
                {
                    Xom.NtEvent( XEvent.Id.COMMON_INFO_45, "[ReportConnection.Send]: Outbound queue is no longer full. Accepting new buffers." );
                }
                _listBuffers.AddLast( wireData );
            }

            ReportTargetCounters.Current(Component).MessagesPerSecond.Increment();
            ReportTargetCounters.Current(Component).MessagesTotal.Increment();
            ReportTargetCounters.Current(Component).QueueLength.Increment();

        lDone:
            _hSendThread.Set( );

            return;
        }

        public void Disconnect( )
        {
            Disconnect(_connectionContext);
        }

        private void Disconnect( ConnectionContext context )
        {
            lock (context.ConnectionLock)
            {
                if( S_NOT_CONNECTED != Interlocked.Exchange( ref context.State, S_NOT_CONNECTED ) )
                {
                    Interlocked.Exchange( ref context.Receiving, 0 );

                    context.NetworkStream.Close();
                    context.NetworkStream = null;

                    context.TcpClient.Close( );
                }
            }
        }        

        public bool IsConnected
        {
            get 
            {
                ConnectionContext context = _connectionContext;

                return null != context && context.IsConnected;
            }
        }

        protected void ParseReceiveBuffer( byte[] rgbBuffer, ref int iBufferBytes )
        {
            iBufferBytes = 0;
        }

        private void StartReceiving( ConnectionContext context )
        {
            if( !context.IsConnected )
            {
                //
                // Socket isn't connected, can't receive
                //
                return;
            }

            if( 0 != Interlocked.Exchange( ref context.Receiving, 1 ) )
            {
                //
                // We are already receiving something
                //
                return;
            }

            try
            {
                lock (context.ConnectionLock)
                {
                    if (context.IsConnected)
                    {
                        context.NetworkStream.BeginRead(
                            context.ReceiveBuffer, 
                            context.ReceiveBufferOffset, 
                            context.ReceiveBuffer.Length,
                            new AsyncCallback(this.ReadCallback), 
                            context);
                    }
                }
            }
            catch
            {
                Disconnect( context );
                throw;
            }
        }

        private void ReadCallback( IAsyncResult ar )
        {
            int iBytesRead = 0;

            // use this instead of the member function because it is possible that the service disconnected before the callback
            // leaving the member variable null.
            ConnectionContext context = (ConnectionContext)ar.AsyncState;

            Interlocked.Exchange(ref context.Receiving, 0);
            
            try
            {
                lock (context.ConnectionLock)
                {
                    if (context.IsConnected)
                    {
                        iBytesRead = context.NetworkStream.EndRead( ar );
                    }
                }
            }
            catch( Exception exc )
            {
                Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_LOW, "[ReportConnection.ReadCallback]: EndRead failed: " + exc.ToString());
                goto lDone;
            }

            if( 0 != iBytesRead )
            {
                //
                // _iReceiveBufferOffset is how much data we have to process - so include received data
                //
                context.ReceiveBufferOffset += iBytesRead;

                ParseReceiveBuffer(context.ReceiveBuffer, ref context.ReceiveBufferOffset);
                
                if (context.ReceiveBufferOffset >= context.ReceiveBuffer.Length)
                {
                    Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_LOW, "[ReportConnection.ReadCallback]: Receive buffer is completely full after ParseReceiveBuffer.");
                    Disconnect( context );
                }

                //
                // If we're connected, keep things going
                //
                if( context.IsConnected )
                {
                    try
                    {
                        StartReceiving( context );
                    }
                    catch( Exception exc )
                    {
                        Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_LOW, "[ReportConnection.ReadCallback]: StartReceiving failed: " + exc.ToString());
                        Disconnect( context );
                    }
                }
            }

        lDone:

            if( 0 == iBytesRead )
            {
                Disconnect( context );
            }

            return;
        }

        private void _SendThread()
        {
            WireData wireData;
            byte[] rgbData;

        Restart:
            try
            {
                while( true )
                {
                    ConnectionContext context;
                    
                    if( ( true == _hSendThread.WaitOne( ) ) && ( _iShutdown == 1 ) )
                    {
                        //
                        // Received a signal and the target is shutting down
                        //
                        break;
                    }

                    context = _connectionContext;

                    wireData = null;

                    if (context == null || !context.IsConnected)
                    {
                        //
                        // Socket isn't connected, can't send
                        //
                        continue;
                    }

                    while( true )
                    {
                        lock( _listBuffers ) 
                        {
                            if( 0 == _listBuffers.Count )
                            {
                                //
                                // Empty queue, nothing to send
                                //
                                break;
                            }
                            wireData = _listBuffers.First.Value;
                            _listBuffers.RemoveFirst();

                            ReportTargetCounters.Current(Component).QueueLength.Decrement();
                        }

                        if( null != wireData )
                        {
                            try
                            {
                                XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

                                rgbData = ( byte[] ) wireData;

                                if (wireData is ReportMessageData2)
                                {
                                    // We need to set the usSize member to the size of 
                                    // this message minus the 12 bytes of headers. It's a 
                                    // bit of a hack, sorry.
                                    ushort sizeMsg = (ushort)(rgbData.Length - ReportMessageBase.cMinMessageSizeBytes);
                                    byte[] sizeBytes = BitConverter.GetBytes(sizeMsg);
                                    Array.Copy(sizeBytes, 0, rgbData, 2, 2);
                                }
                                
                                // Grab the freshest one
                                context = _connectionContext;

                                lock (context.ConnectionLock)
                                {
                                    if (context.IsConnected)
                                    {
                                        context.NetworkStream.Write( rgbData, 0, rgbData.Length );
                                        wireData = null; // indicates we consumed this
                                    }
                                }

                                ReportTargetCounters.Current(Component).AverageSendTime.IncrementBy(timeElapsed.TimeElapsed);
                                ReportTargetCounters.Current(Component).AverageSendTimeBase.Increment();
                            }
                            catch( Exception exc )
                            {
                                Disconnect( context );

                                Xom.Trace(XomAreaName.ReportConnection, LogLevel.L_LOW, "[ReportConnection._SendThread] - Send error: " + exc.ToString());
                                throw;
                            }
                            finally
                            {
                                if (null != wireData)
                                {
                                    //
                                    // Throw the item back at the beginning of the queue
                                    //
                                    lock( _listBuffers )
                                    {
                                        _listBuffers.AddFirst( wireData );
                                    }
                                    ReportTargetCounters.Current(Component).QueueLength.Increment();
                                }
                            }
                            if (null != wireData)
                            {
                                goto Restart;
                            }
                        }
                    }
                }
            }
            catch( ThreadAbortException threadExc )
            {
                //
                // We are being forced to shutdown
                //
                Xom.NtEvent( XEvent.Id.COMMON_CODE_29, threadExc, "[ReportConnection._SendThread] - Thread being aborted");
                goto lDone;
            }
            catch( Exception exc )
            {
              Xom.NtEvent( XEvent.Id.COMMON_CODE_30, exc, "[ReportConnection._SendThread] - Restarting send logic from unexpected exception");
                goto Restart;
            }

        lDone:
            return;
        }

        public string Server
        {
            get { return _vcServer; }
            set { _vcServer = value; }
        }

        public Int32 ComponentID
        {
            get { return _iComponentID; }
            set { _iComponentID = value; }
        }

        public string Component
        {
            get { return _strComponent; }
            set { _strComponent = value; }
        }

        //
        // Some state information
        //
        private const Int32 S_NOT_CONNECTED = 0; // Not connected.
        private const Int32 S_CONNECTED = 1; // Connected

        ConnectionContext _connectionContext;

        private LinkedList<WireData> _listBuffers;

        private Int32 _iDroppedEvent;

        private string _vcServer;
        private Int32 _iComponentID;
        private string _strComponent;

        private int _iInitialized;
        private XboxLiveThread _threadSend;
        private int _iShutdown;
        private AutoResetEvent _hSendThread;
    };

    [ComVisible(false)]
    [XomPerformanceCounterCategoryAttr( "Reporting Target", "XBox Live Reporting Target", true )]
    public class ReportTargetCounters : XomPerformanceCounterCategory
    {
        static private ReportTargetCounters _instance = new ReportTargetCounters();

        static public ReportTargetCounters Current()
        {
            return Current(null);
        }

        static public ReportTargetCounters Current(string component)
        {
            if (component == null)
            {
                component = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (ReportTargetCounters)_instance.GetInstance(component);
        }

        [XomPerformanceCounterAttr(
            "Messages/sec",
            "Messages per second collected from core XBL components",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter MessagesPerSecond;

        [XomPerformanceCounterAttr(
            "Messages total",
            "Total messages collected from core XBL components from the service startup.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter MessagesTotal;

        [XomPerformanceCounterAttr(
            "Queued messages",
            "Total messages in the target queue.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter QueueLength;

        [XomPerformanceCounterAttr(
            "Reporting target avg. send time",
            "Reporting target average request send time in the current service.",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageSendTime;

        [XomPerformanceCounterAttr(
            "Reporting target avg. send time base",
            "Reporting target base for the average request send time in the current service.",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageSendTimeBase;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\PipeStream.cs ===
using System;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Security;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;


namespace xonline.common.mgmt
{

    [ComVisible(false)]
    public class PipeStream : IDisposable
    {

        private FileStream _stream;
        private BinaryReader _reader;
        private BinaryWriter _writer;

        public PipeStream(string name, int bufferSize)
        {
            Open(name, bufferSize);
        }


        public void Open(string name, int bufferSize)
        {
            SafeFileHandle hPipe = new SafeFileHandle(PipeNative.CreateFile(
                                            name,
                                            PipeNative.GENERIC_READ | PipeNative.GENERIC_WRITE, 
                                            0,
                                            0, 
                                            PipeNative.OPEN_EXISTING, 
                                            PipeNative.FILE_FLAG_OVERLAPPED, 
                                            0), true);

            if( hPipe.IsInvalid )
            {
                ulong err =(ulong) Marshal.GetLastWin32Error();
                if ( err!= PipeNative.ERROR_PIPE_BUSY )
                {
                    throw new Exception("Could not open pipe: " + name + ": 0x" + Marshal.GetLastWin32Error().ToString("x"));
                }
                // if pipe is busy, retry later
                if ( PipeNative.WaitNamedPipe ( name, 60000 ) )
                {
                    hPipe = new SafeFileHandle(PipeNative.CreateFile(
                        name,
                        PipeNative.GENERIC_READ | PipeNative.GENERIC_WRITE, 
                        0,
                        0, 
                        PipeNative.OPEN_EXISTING, 
                        PipeNative.FILE_FLAG_OVERLAPPED, 
                        0), true);

                    if( hPipe.IsInvalid )
                    {
                        throw new Exception("Second attempt to open pipe failed: " + name + ": 0x" + Marshal.GetLastWin32Error().ToString("x"));
                    }
                }

                if( hPipe.IsInvalid )
                {
                    throw new Exception("Timed out waiting for named pipe to connect: " + name + ": 0x" + Marshal.GetLastWin32Error().ToString("x"));
                }
            }

            
            uint dwMode = PipeNative.PIPE_READMODE_MESSAGE;

            int iRes = PipeNative.SetNamedPipeHandleState(
                                            hPipe.DangerousGetHandle(),
                                            ref dwMode,
                                            IntPtr.Zero,
                                            IntPtr.Zero );

            if( iRes == 0 )
            {
                throw new Exception( "SetNamedPipeHandleState failed: 0x" + Marshal.GetLastWin32Error().ToString("x") );
            }

            _stream = new FileStream( hPipe, FileAccess.ReadWrite, bufferSize, true );
            _reader = new BinaryReader( _stream );
            _writer = new BinaryWriter( _stream );
        }

        public IAsyncResult BeginRead(byte[] array, int offset, int numBytes,  AsyncCallback userCallback, object stateObject)
        {
            return _stream.BeginRead(array, offset, numBytes, userCallback, stateObject);
        }

        public IAsyncResult BeginWrite(byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject)
        {
            return _stream.BeginWrite(array, offset, numBytes, userCallback, stateObject);
        }

        public int EndRead(IAsyncResult result)
        {
            return _stream.EndRead(result);
        }
        
        public void EndWrite(IAsyncResult result)
        {
            _stream.EndWrite(result);
        }

        public int Read(byte[] array, int offset, int count)
        {
            return _stream.Read(array, offset, count);
        }

        public void Write(byte[] array, int offset, int count)
        {
            _stream.Write(array, offset, count);
        }

        public bool CanRead
        {
            get { return _stream.CanRead; }
        }

        public bool CanWrite
        {
            get { return _stream.CanWrite; }
        }
        

        public void Flush()
        {
            _stream.Flush();
        }

        public void Close()
        {
            _stream.Close();
        }

        public BinaryReader Reader
        {
            get { return _reader; }
        }

        public BinaryWriter Writer
        {
            get { return _writer; }
        }

        public void Dispose()
        {
            Close();
            GC.SuppressFinalize(this);
        }

        
    }

    [ComVisible(false)]
    [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
    [SuppressUnmanagedCodeSecurity]
    public class PipeNative 
    {
        public const uint PIPE_ACCESS_OUTBOUND = 0x00000002;
        public const uint PIPE_ACCESS_DUPLEX = 0x00000003;
        public const uint PIPE_ACCESS_INBOUND = 0x00000001;
        
        public const uint PIPE_WAIT = 0x00000000;
        public const uint PIPE_NOWAIT = 0x00000001;
        public const uint PIPE_READMODE_BYTE = 0x00000000;
        public const uint PIPE_READMODE_MESSAGE = 0x00000002;
        public const uint PIPE_TYPE_BYTE = 0x00000000;
        public const uint PIPE_TYPE_MESSAGE = 0x00000004;
        
        public const uint PIPE_CLIENT_END = 0x00000000;
        public const uint PIPE_SERVER_END = 0x00000001;
        
        public const uint PIPE_UNLIMITED_INSTANCES = 255;
        
        public const uint NMPWAIT_WAIT_FOREVER = 0xffffffff;
        public const uint NMPWAIT_NOWAIT = 0x00000001;
        public const uint NMPWAIT_USE_DEFAULT_WAIT = 0x00000000;
        
        public const uint GENERIC_READ = (0x80000000);
        public const uint GENERIC_WRITE = (0x40000000);
        public const uint GENERIC_EXECUTE = (0x20000000);
        public const uint GENERIC_ALL = (0x10000000);

        public const uint FILE_FLAG_OVERLAPPED = 0x40000000;
        
        public const uint CREATE_NEW        = 1;
        public const uint CREATE_ALWAYS     = 2;
        public const uint OPEN_EXISTING     = 3;
        public const uint OPEN_ALWAYS       = 4;
        public const uint TRUNCATE_EXISTING = 5;
        
        public const int INVALID_HANDLE_VALUE = -1;
        public const ulong ERROR_PIPE_BUSY = 231;
        public const ulong ERROR_NO_DATA = 232;
        public const ulong ERROR_PIPE_NOT_CONNECTED = 233;
        public const ulong ERROR_PIPE_CONNECTED = 535;
        public const ulong ERROR_PIPE_LISTENING = 536;


        [DllImport("kernel32.dll", SetLastError = true, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        public static extern IntPtr CreateFile(
                                            [MarshalAs(UnmanagedType.LPStr)] String lpFileName,				// file name
                                            uint dwDesiredAccess,			// access mode
                                            uint dwShareMode,				// share mode
                                            uint attr,				        // SD
                                            uint dwCreationDisposition,		// how to create
                                            uint dwFlagsAndAttributes,		// file attributes
                                            uint hTemplateFile);			// handle to template file
        
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern int SetNamedPipeHandleState(
                                            IntPtr hPipe,
                                            ref uint dwMode,
                                            IntPtr MaxCollectionCount,
                                            IntPtr CollectDataTimeout );

        [DllImport("kernel32.dll", SetLastError = true, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        public static extern bool WaitNamedPipe(
            [MarshalAs(UnmanagedType.LPStr)] String lpNamedPipeName,
            uint nTimeOut
            );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\TargetDictionary.cs ===
using System.Runtime.InteropServices;

using xonline.common.config;

namespace xonline.common.mgmt
{
[ComVisible(false)]
public class TargetDictionary : XomDictionary<XomLogTarget>
{
    public TargetDictionary() : base()
    {
    }

    private XomLogTarget Add(string key, string[,] parameters, uint requestnum)
    {
        XomLogTarget target = null;
        string type = null;
        bool persist = true;

        //
        // find the target type
        //
        for (int n = 0; n < parameters.GetLength(0); n++)
        {
            if (parameters[n,0] == "type")
            {
                type = parameters[n,1];
            }
            else if (parameters[n, 0] == "persist")
            {
                string val = parameters[n, 1].ToLower();
                persist = val == "true" || val == "on" || val == "1";
            }
        }

        if (type == null)
        {
            // TODO: log event
            return null;
        }

        type = type.ToLower();

        //
        // create a log of the appropriate type
        //
        switch (type)
        {
        case "debugoutput":
            target = new XomDebugOutputTarget(null);
            break;

        case "console":
            target = new XomConsoleTarget(null);
            break;

        case "ntlog":
            target = new XomNtLogTarget(parameters);
            break;

        case "remote":
            target = new XomRemoteTarget(parameters);
            break;

        case "file":
            target = new XomFileTarget(parameters);
            break;

        case "report":
            target = new XomReportTarget(parameters);
            break;

        default:
            // TODO: log event
            break;
        }

        if (target != null)
        {
            target.Name = key;
            target.Session = persist ? 0 : requestnum;
            target.Params = ConfigUtil.GetParams(parameters);
            this[key] = target;
        }
        return target;
    }

    public XomLogTarget Add(string key, string settings)
    {
        string[,] parameters = ConfigUtil.GetParams(settings);

        return Add(key, parameters, 0 );
    }

    public XomLogTarget Add(string key, string settings, string defaultSettings)
    {

        string[,] parameters = ConfigUtil.GetParams(settings, defaultSettings);

        return Add(key, parameters, 0 );
    }

    public XomLogTarget Add(string key, string settings, uint requestnum)
    {
        string[,] parameters = ConfigUtil.GetParams(settings);

        return Add(key, parameters, requestnum );
    }

}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\XomAdmin.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Collections;

using xonline.common.service;

namespace xonline.common.mgmt
{
    // this class provides a simple, syncronous, way to issue xon management
    // commands remotely
    [ComVisible(false)]
    public class XomAdminSession
    {
        // this constant is taken from private\mgmt\inc\xomcontrolprot.h
        // don't change it unless you're chaning xomcontrolprot.h.
        // it came first, so it's the master copy
        const int XOMCTRL_ADMIN_PORT = 4100;

        private Socket m_socket;
        private NetworkStream m_networkStream;

        private StreamReader m_streamReader;
        private delegate int StreamReaderReadBlock(char[] rgc, int iIndex, int iMaxCount);
        private delegate string StreamReaderReadLine();
        private StreamReaderReadBlock m_delegateStreamReaderReadBlock;
        private StreamReaderReadLine m_delegateStreamReaderReadLine;

        private StreamWriter m_streamWriter;
        private delegate void StreamWriterWrite(string s);
        private StreamWriterWrite m_delegateStreamWriterWrite;

        // this is the constructor we expect to use most of the time, which knows
        // the port we're trying to connect to. The other constructor is useful
        // for unit testing purposes
        public XomAdminSession(IPAddress ipAddress) : this(ipAddress, XOMCTRL_ADMIN_PORT)
        {
        }

        public XomAdminSession(IPAddress ipAddress, int iPort)
        {
            m_socket = new Socket(
                ipAddress.AddressFamily, 
                SocketType.Stream, 
                ProtocolType.Tcp);

            IPEndPoint ipEndPoint = new IPEndPoint(ipAddress, iPort);

            m_socket.Connect(ipEndPoint);

            // new network stream to wrap the raw socket
            m_networkStream = new NetworkStream(m_socket);

            // a stream reader to wrap the network stream using ASCII encoding
            // the C++ code that implement xmgmtsrv uses char* with the expectation
            // that all messages are text, so ASCII is the right choice.
            m_streamReader = new StreamReader(m_networkStream, new ASCIIEncoding());
            
            // delgates for the stream reader methods we want to be able to call asyncronously
            m_delegateStreamReaderReadBlock = new StreamReaderReadBlock(m_streamReader.ReadBlock);
            m_delegateStreamReaderReadLine = new StreamReaderReadLine(m_streamReader.ReadLine);

            // a stream writer around the network stream using ASCII encoding
            m_streamWriter = new StreamWriter(m_networkStream, new ASCIIEncoding());

            // without this, our command doesn't get sent in a timely fashion, and
            // we'll timeout waiting for the reply to command that still sitting in
            // an output buffer on our machine!
            m_streamWriter.AutoFlush = true;

            // delgate for the stream writer method we want to be able to call asyncronously
            m_delegateStreamWriterWrite = new StreamWriterWrite(m_streamWriter.Write);
        }

        public void Close()
        {
            m_streamReader.Close();
            m_streamWriter.Close();
            m_networkStream.Close();
            m_socket.Shutdown(SocketShutdown.Both);
            m_socket.Close();
        }

        public void SendRequest(
            string sRequest,
            int iTimeoutMilliseconds,
            out string[] rgsResponses,
            out int hrResultCode
        )
        {
            HResult hr;
            SendRequest(sRequest, iTimeoutMilliseconds, out rgsResponses, out hr);
            hrResultCode = (int) (uint) hr;
        }
        
        public void SendRequest(
            string sRequest,
            int iTimeoutMilliseconds,
            out string[] rgsResponses,
            out HResult hrResultCode
        )
        {
            if (sRequest == null)
            {
                throw new ArgumentNullException("sRequest");
            }

            // add \r\n to the request string, if they are not already there...
            if (!sRequest.EndsWith("\r\n"))
            {
                sRequest += "\r\n";
            }

            WriteString(sRequest, iTimeoutMilliseconds);

            // reply is in the following format:
            // first comes zero or more response blocks
            // each response block is in the form of:
            // Size=<size-of-response-block-in-bytes>\r\n<response-block>
            // after all response blocks comes the result block
            // the result block is in the form of:
            // Result=<unsigned-32bit-result-code>\r\n

            ArrayList alResponses = new ArrayList();
            while(true)
            {
                // read a line
                string sLine = ReadLine(iTimeoutMilliseconds);

                // split the line into the token before the = 
                // and the value after the =
                string[] sLineSplit = sLine.Split('=');

                // make sure we have two parts
                if (sLineSplit.Length != 2)
                {
                    string sErr = "Format of admin command response is not correct. "
                        + "Admin command: " + sRequest
                        + "Invalid response fragment: " + sLine;
                    throw new XomException(sErr);
                }

                // let's be nice about accepting whitespace and case
                string sBlockType = sLineSplit[0].Trim().ToUpper();
                string sBlockData = sLineSplit[1].Trim().ToUpper();

                if (sBlockType == "SIZE")
                {
                    // how big is the response block?
                    int iSize;
                    try
                    {
                        iSize = (int)UInt32.Parse(sBlockData);
                    }
                    catch (Exception e)
                    {
                        string sErr = "Unable to parse size of admin command response. "
                            + "Admin command: " + sRequest
                            + "Invalid response fragment: " + sLine
                            + "Exception details: " + e.Message;
                        throw new XomException(sErr);
                    }

                    string sResponse = ReadString(iSize, iTimeoutMilliseconds);
                    alResponses.Add(sResponse);
                }
                else if (sBlockType == "RESULT")
                {
                    // parse the result code
                    try
                    {
                        hrResultCode = UInt32.Parse(sBlockData);
                    }
                    catch (Exception e)
                    {
                        string sErr = "Unable to parse result code in admin command response. "
                            + "Admin command: " + sRequest
                            + "Invalid response fragment: " + sLine
                            + "Exception details: " + e.Message;
                        throw new XomException(sErr);
                    }
                    // this marks the end of the command response, so break out of the loop
                    break;
                }
                else
                {
                    // only "Size" and "Result" are expected!
                    string sErr = "Unknown admin command response. "
                        + "Admin command: " + sRequest
                        + "Unknown response fragment: " + sLine;
                    throw new XomException(sErr);
                }
            }

            // translate the array list into an array to return
            rgsResponses = new string[alResponses.Count];
            alResponses.CopyTo(rgsResponses);
        }

        // a little wrapper around SendRequest that composes a command string
        public void SendCommand(
            string sProcess,
            string sComponent,
            string sCommand,
            int iTimeoutMilliseconds,
            out string[] rgsResponses,
            out int hrResultCode
        )
        {
            HResult hr;
            SendCommand(sProcess, sComponent, sCommand, iTimeoutMilliseconds, out rgsResponses, out hr);
            hrResultCode = (int) (uint) hr;
        }

        public void SendCommand(
            string sProcess,
            string sComponent,
            string sCommand,
            int iTimeoutMilliseconds,
            out string[] rgsResponses,
            out HResult hrResultCode
        )
        {
            // need to have either a process or a compoent to send the command to
            if (sProcess == null && sComponent == null)
            {
                throw new ArgumentNullException("sProcess and sComponent");
            }

            // need to have a command
            if (sCommand == null)
            {
                throw new ArgumentNullException("sCommand");
            }

            // assemble the request string
            string sRequest
                = "exec "
                + (sProcess == null ? String.Empty : sProcess)
                + ":"
                + (sComponent == null ? String.Empty : sComponent)
                + " "
                + sCommand;

            // send the request
            SendRequest(sRequest, iTimeoutMilliseconds, out rgsResponses, out hrResultCode);
        }

        // a wrapper to grab and parse the output of the list command into a
        // convenient form
        public XomProcessComponentPair[] List(int iTimeoutMilliseconds)
        {
            string[] rgsResponses = null;
            int hrResultCode = -1;
            SendRequest(
                "list",
                iTimeoutMilliseconds,
                out rgsResponses,
                out hrResultCode);
            if (hrResultCode != 0)
            {
                throw new XomException(
                    "non-zero hresult returned from 'list' request. hr=" 
                    + hrResultCode.ToString());
            }

            XomProcessComponentPair[] rgXomProcessComponentPairs 
                = new XomProcessComponentPair[rgsResponses.Length];
            for (int i = 0; i < rgsResponses.Length; ++i)
            {
                string sResponse = rgsResponses[i];

                // we expect one process / component pair per response
                // the expected format of each response is:
                // process-name(pid) component-name

                // trim the string, then split it on the space in the middle
                string[] rgsResponseSplit = sResponse.Trim().Split(' ');

                // we should only get two parts from the split
                if (rgsResponseSplit.Length != 2)
                {
                    throw new XomException("Unable to parse response to list command. Reponse fragment: "
                        + sResponse);
                }

                // the second part is the component name
                string sComponent = rgsResponseSplit[1];

                // if we split again on the '('character, we'll get the process name by itself
                string []rgsProcessSplit = rgsResponseSplit[0].Split('(');

                // again, we should only get two parts from the split
                if (rgsProcessSplit.Length != 2)
                {
                    throw new XomException("Unable to parse response to list command. Reponse fragment: "
                        + sResponse);
                }

                // the first part is the process name
                string sProcess = rgsProcessSplit[0];

                // now create the process component pair object in the array
                rgXomProcessComponentPairs[i] = new XomProcessComponentPair(sProcess, sComponent);
            }

            // done, return the array
            return rgXomProcessComponentPairs;
        }

        private string ReadLine(int iTimeoutMilliseconds)
        {
            IAsyncResult iAsyncResult = m_delegateStreamReaderReadLine.BeginInvoke(null, null);

            // wait for up to iTimeoutMilliseconds for the read operation
            // to complete
            bool bSignal = iAsyncResult.AsyncWaitHandle.WaitOne(iTimeoutMilliseconds, false);
            if (!bSignal)
            {
                // the wait timed out!
                throw new XomException("Error: " 
                    + iTimeoutMilliseconds 
                    + " millisecond timeout expired waiting for response from admin server");
            }

            string sLine = m_delegateStreamReaderReadLine.EndInvoke(iAsyncResult);
            return sLine;
        }

        private string ReadString(int iLength, int iTimeoutMilliseconds)
        {
            int iTotalCharsRead = 0;
            char[] rgc = new char[iLength];

            while (iTotalCharsRead < iLength)
            {
                IAsyncResult iAsyncResult 
                    = m_delegateStreamReaderReadBlock.BeginInvoke(
                        rgc,
                        iTotalCharsRead, 
                        iLength - iTotalCharsRead,
                        null, 
                        null);

                // wait for up to iTimeoutMilliseconds for the read operation
                // to complete
                bool bSignal = iAsyncResult.AsyncWaitHandle.WaitOne(iTimeoutMilliseconds, false);
                if (!bSignal)
                {
                    // the wait timed out!
                    throw new XomException("Error: " 
                        + iTimeoutMilliseconds 
                        + " millisecond timeout expired waiting for response from admin server");
                }

                iTotalCharsRead += m_delegateStreamReaderReadBlock.EndInvoke(iAsyncResult);
            }

            return new String(rgc);
        }

        private void WriteString(string s, int iTimeoutMilliseconds)
        {
            IAsyncResult iAsyncResult 
                = m_delegateStreamWriterWrite.BeginInvoke(
                    s,
                    null, 
                    null);

            // wait for up to iTimeoutMilliseconds for the read operation
            // to complete
            bool bSignal = iAsyncResult.AsyncWaitHandle.WaitOne(iTimeoutMilliseconds, false);
            if (!bSignal)
            {
                // the wait timed out!
                throw new XomException("Error: " 
                    + iTimeoutMilliseconds 
                    + " millisecond timeout expired waiting for response from admin server");
            }

            m_delegateStreamWriterWrite.EndInvoke(iAsyncResult);
        }
    }


    [ComVisible(false)]
    public class XomProcessComponentPair
    {
        private string m_sProcess;
        private string m_sComponent;

        public string Process
        {
            get
            {
                return m_sProcess;
            }
        }

        public string Component
        {
            get
            {
                return m_sComponent;
            }
        }

        public XomProcessComponentPair(string sProcess, string sComponent)
        {
            if (sProcess == null)
            {
                throw new ArgumentNullException("sProcess");
            }
            if (sComponent == null)
            {
                throw new ArgumentNullException("sComponent");
            }

            m_sProcess = sProcess;
            m_sComponent = sComponent;
        }
    }

    [ComVisible(false)]
    public class XomException : ApplicationException
    {
        public XomException() : base() {}
        public XomException(string s) : base(s) {}
        protected XomException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public XomException(string s, Exception e) : base(s, e) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\XomControl.cs ===
using System;
using System.Collections;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using xonline.common.service;


namespace xonline.common.mgmt
{
[ComVisible(false)]
public static class XomControl
{
    // 
    // event callback stuff
    //
    [ComVisible(false)]
    public delegate void ControlRequestEventHandler (object sender, ControlRequestEventArgs args);

    private static ControlRequestEventHandler eventHandler;

    public static event ControlRequestEventHandler ControlRequestEvent
    {
        [MethodImpl(MethodImplOptions.Synchronized)]
        add
        {
            ControlRequestEventHandler prev = eventHandler;
            eventHandler = (ControlRequestEventHandler)Delegate.Combine(eventHandler, value);

            // Only startup if this is the first entry to be added
            if (prev == null && eventHandler != null && _isXmgmtConnectionOn)
            {
                XomControlConnection.Startup();
            }
        }

        [MethodImpl(MethodImplOptions.Synchronized)]
        remove
        {
            ControlRequestEventHandler prev = eventHandler;
            eventHandler = (ControlRequestEventHandler)Delegate.Remove(eventHandler, value);

            if (prev != null && eventHandler == null && _isXmgmtConnectionOn)
            {
                XomControlConnection.Shutdown();
            }
        }
    }

    [MethodImpl(MethodImplOptions.Synchronized)]
    public static void OnControlRequest(ControlRequestEventArgs args)
    {
        if (!_isXmgmtConnectionOn)
            return;
        
        if (eventHandler != null)
        {
            eventHandler(null, args);
        }

        if (args.Handled == false)
        {
            XomControlConnection.SendMessage("Unknown command.\r\n", args.RequestId);
        }
    }

    public static bool ConnectToXmgmt
    {
        get { return _isXmgmtConnectionOn; }
        set { 
                if ( null == eventHandler ) // otherwise it's too late to turn the XMgmt Connection off
                    _isXmgmtConnectionOn = value;
            }
    }
    
    private static bool _isXmgmtConnectionOn = true;
}


[ComVisible(false)]
public class ControlRequestEventArgs : EventArgs
{
    public string FullCommand;
    public string Command;
    public string[] CommandArgs;
    public uint RequestId;

    private HResult _hr = HResult.S_OK;

    public HResult hr
    {
        get
        {
            return _hr;
        }
        set
        {
            if (_hr.IsOk())
            {
                // We're going to keep the first hr != S_OK
                _hr = value;
            }
        }
    }

    // NOTE: this should only be set by event handlers to true when 
    //       an event is responded to.    otherwise, don't set it!
    public bool Handled;
    
    public ControlRequestEventArgs (string message, uint requestId)
    {
        FullCommand = message.Trim();

        // BUGBUG: this won't accept spaces in params values
        string[] parts = FullCommand.Split(new char[] {' '});
        
        //  Remove any zero-length parameters
        ArrayList tempPartsArray = new ArrayList();
        foreach(string part in parts)
        {
            if(part.Length != 0)
                tempPartsArray.Add(part);
        }

        //  Copy to final array
        parts = new string[tempPartsArray.Count];
        tempPartsArray.CopyTo(parts);

        //  Process the command
        this.Command = parts[0].ToLower();
        this.CommandArgs = new string[parts.Length-1]; // Always make it safe for callers to check the length of this
        if (parts.Length > 1)
        {
            Array.Copy(parts, 1, this.CommandArgs, 0, parts.Length-1);
        }
        
        this.RequestId = requestId;
        this.Handled = false;
    }
}

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\XomAreaName.cs ===
namespace xonline.common.mgmt
{
    //------------------------------------------------------------------------
    // Constant strings for all log areas
    //------------------------------------------------------------------------
    public class XomAreaName
    {
        public const string aainfo                      = "aainfo";
        public const string aamodule                    = "aamodule";
        public const string aamoduleLog                 = "aamoduleLog";
        public const string AccelerationProxy           = "AccelerationProxy";
        public const string atTrace                     = "atTrace";
        public const string audit                       = "audit";
        public const string authsglog                   = "authsglog";
        public const string authsgtrace                 = "authsgtrace";
        public const string bcfgtrace                   = "bcfgtrace";
        public const string catalog                     = "catalog";
        public const string catalogwatcherlog           = "catalogwatcherlog";
        public const string cfgtrace                    = "cfgtrace";
        public const string checkready                  = "checkready";
        public const string cleanclips                  = "cleanclips";
        public const string cleansermissingdata         = "cleansermissingdata";
        public const string cleansertrace               = "cleansertrace";
        public const string computil                    = "computil";
        public const string contentutiltrace            = "contentutiltrace";
        public const string crontest                    = "crontest";
        public const string crontrace                   = "crontrace";
        public const string cryptomgr                   = "cryptomgr";
        public const string cryptotools                 = "cryptotools";
        public const string ctpTransactionServiceLog    = "ctpTransactionServiceLog";
        public const string ctpTransactionServiceTrace  = "ctpTransactionServiceTrace";
        public const string ctxDebug                    = "ctxDebug";
        public const string deactivator                 = "deactivator";
        public const string DefaultNtLog                = "DefaultNtLog";
        public const string dmplog                      = "dmplog";
        public const string dmptrace                    = "dmptrace";
        public const string domTrace                    = "domTrace";
        public const string ElimEntrants                = "ElimEntrants";
        public const string ElimEvents                  = "ElimEvents";
        public const string Elimination                 = "Elimination";
        public const string elimtest                    = "elimtest";
        public const string enfTrace                    = "enfTrace";
        public const string enmrdfTrace                 = "enmrdfTrace";
        public const string espengine                   = "espengine";
        public const string EventService                = "EventService";
        public const string feedbacklog                 = "feedbacklog";
        public const string FeedbackProxy               = "FeedbackProxy";
        public const string feedbackTrace               = "feedbackTrace";
        public const string finbusLog                   = "finbusLog";
        public const string finbusTrace                 = "finbusTrace";
        public const string fseLog                      = "fseLog";
        public const string fseTrace                    = "fseTrace";
        public const string marketplacecatalog          = "marketplacecatalog";
        public const string geoFenceLog                 = "geoFenceLog";
        public const string geoFenceTrace               = "geoFenceTrace";
        public const string glcTrace                    = "glcTrace";
        public const string graduateUserTrace           = "graduateUserTrace";
        public const string gtqTrace                    = "gtqTrace";
        public const string kdcmanaged                  = "kdcmanaged";
        public const string lbsvrclient                 = "lbsvrclient";
        public const string listsTrace                  = "listsTrace";
        public const string livecachelog                = "livecachelog";
        public const string livecachetrace              = "livecachetrace";
        public const string livepxy                     = "livepxy";
        public const string livepxylog                  = "livepxylog";
        public const string log                         = "log";
        public const string LogCollectorModuleLog       = "LogCollectorModuleLog";
        public const string LogCollectorModuleTrace     = "LogCollectorModuleTrace";
        public const string matchdbtrace                = "matchdbtrace";
        public const string matchprestrace              = "matchprestrace";
        public const string MatchProxy                  = "MatchProxy";
        public const string matchtrace                  = "matchtrace";
        public const string MessageProxy                = "MessageProxy";
        public const string messagingfd                 = "messagingfd";
        public const string messagingfdLog              = "messagingfdLog";
        public const string metro                       = "metro";
        public const string mllog                       = "mllog";
        public const string mltrace                     = "mltrace";
        public const string msgmanager                  = "msgmanager";
        public const string msnrraggregationlog         = "msnrraggregationlog";
        public const string msnrraggregationtrace       = "msnrraggregationtrace";
        public const string msnrrLog                    = "msnrrLog";
        public const string msnrrTrace                  = "msnrrTrace";
        public const string musicnetLog                 = "musicnetLog";
        public const string musicnetTrace               = "musicnetTrace";
        public const string nametrace                   = "nametrace";
        public const string nrTrace                     = "nrTrace";
        public const string offer                       = "offer";
        public const string passportLog                 = "passportLog";
        public const string passportTrace               = "passportTrace";
        public const string pathTrace                   = "pathTrace";
        public const string plugintest                  = "plugintest";
        public const string PresenceFDDebug             = "PresenceFDDebug";
        public const string PresenceLog                 = "PresenceLog";
        public const string PresenceProxy               = "PresenceProxy";
        public const string PresenceRPDebug             = "PresenceRPDebug";
        public const string provisioning                = "provisioning";
        public const string progresslog                 = "progresslog";
        public const string profilelog                  = "profilelog";
        public const string pss                         = "pss";
        public const string puidmgr                     = "puidmgr";
        public const string QueryTest                   = "QueryTest";
        public const string ratingstrace                = "ratingstrace";
        public const string rdfTrace                    = "rdfTrace";
        public const string readsitekeys                = "readsitekeys";
        public const string replacePassportTrace        = "replacePassportTrace";
        public const string ReflectorFD                 = "ReflectorFD";
        public const string ReflectorFDLog              = "ReflectorFDLog";
        public const string ReportConnection            = "ReportConnection";
        public const string Reporting                   = "Reporting";
        public const string Reporting_v2                = "Reporting_v2";
        public const string rfhTrace                    = "rfhTrace";
        public const string rmfTrace                    = "rmfTrace";
        public const string selog                       = "selog";
        public const string serialnumber                = "serialnumber";
        public const string sginfotrace                 = "sginfotrace";
        public const string SGProxy                     = "SGProxy";
        public const string soaptrace                   = "soaptrace";
        public const string SocialCacheAPI              = "SocialCacheAPI";
        public const string SocialCacheConnection       = "SocialCacheConnection";
        public const string SocialCacheLog              = "SocialCacheLog";
        public const string socialqueryfd               = "socialqueryfd";
        public const string spslog                      = "spslog";
        public const string spsproxy                    = "spsproxy";
        public const string spsproxyLog                 = "spsproxyLog";
        public const string spsqueuetrace               = "spsqueuetrace";
        public const string spstrace                    = "spstrace";
        public const string sqltrace                    = "sqltrace";
        public const string statdb                      = "statdb";
        public const string statslog                    = "statslog";
        public const string stfdTrace                   = "stfdTrace";
        public const string stlog                       = "stlog";
        public const string storageHealthTrace          = "storageHealthTrace";
        public const string StorageModuleLog            = "StorageModuleLog";
        public const string storageModuleTrace          = "storageModuleTrace";
        public const string storageUtilsTrace           = "storageUtilsTrace";
        public const string stringLog                   = "stringLog";
        public const string StringProxy                 = "StringProxy";
        public const string stringSvrHealthTrace        = "stringSvrHealthTrace";
        public const string stringTrace                 = "stringTrace";
        public const string sts                         = "sts";
        public const string ststrace                    = "ststrace";
        public const string subcodemgr                  = "subcodemgr";
        public const string switchPassportTrace         = "switchPassportTrace";
        public const string TagRecycleCronJobs          = "TagRecycleCronJobs";
        public const string TeamProxy                   = "TeamProxy";
        public const string Test                        = "Test";
        public const string testfdtrace                 = "testfdtrace";
        public const string TestUtilities               = "TestUtilities";
        public const string title                       = "title";
        public const string titleConfig                 = "TitleConfig";
        public const string tmrlog                      = "tmrlog";
        public const string tokenTrace                  = "tokenTrace";
        public const string toolspslog                  = "toolspslog";
        public const string ToolsSrv                    = "ToolsSrv";
        public const string ToolsSrvLog                 = "ToolsSrvLog";
        public const string trace                       = "trace";
        public const string userbillinginfo             = "userbillinginfo";
        public const string user2                       = "user2";
        public const string VortexTrace                 = "VortexTrace";
        public const string VortexFlow                  = "VortexFlow";
        public const string VortexOutput                = "VortexOutput";
        public const string VortexOutputUnknown         = "VortexOutputUnknown";
        public const string voucher                     = "voucher";
        public const string wcgenerallog                = "wcgenerallog";
        public const string wcgeneraltrace              = "wcgeneraltrace";
        public const string wcMessagingLog              = "wcMessagingLog";
        public const string wcMessagingTrace            = "wcMessagingTrace";
        public const string wcmusiclog                  = "wcmusiclog";
        public const string wcpresencelog               = "wcpresencelog";
        public const string wcQueryLog                  = "wcQueryLog";
        public const string wcsignaturelog              = "wcsignaturelog";
        public const string wcstatscache                = "wcstatscache";
        public const string wcstatsdomain               = "wcstatsdomain";
        public const string wcstatslog                  = "wcstatslog";
        public const string wcstatstrace                = "wcstatstrace";
        public const string wcstoragelog                = "wcstoragelog";
        public const string wcteamslog                  = "wcteamslog";
        public const string wctoolsmgmtlog              = "wctoolsmgmtlog";
        public const string wctoolsmgmttrace            = "wctoolsmgmttrace";
        public const string wcuserslog                  = "wcuserslog";
        public const string wcutilitieslog              = "wcutilitieslog";
        public const string wcutilitiestrace            = "wcutilitiestrace";
        public const string WireDataBin                 = "WireDataBin";
        public const string WireDataTxt                 = "WireDataTxt";
        public const string wmisLog                     = "wmisLog";
        public const string wmisTrace                   = "wmisTrace";
        public const string wrfTrace                    = "wrfTrace";
        public const string wsttrace                    = "wsttrace";
        public const string xarblog                     = "xarblog";
        public const string XBancProxy                  = "XBancProxy";
        public const string XomInstrumentation          = "XomInstrumentation";
        public const string xbos                        = "xbos";
        public const string XCacheProxy                 = "XCacheProxy";
        public const string XCacheDatabase              = "XCacheDatabase";
        public const string XCacheLookup                = "XCacheLookup";
        public const string XCacheClient                = "XCacheClient";
        public const string XCacheLog                   = "XCacheLog";
        public const string XCacheService               = "XCacheService";
        public const string xcbk                        = "xcbk";
        public const string XConnSrvAPI                 = "XConnSrvAPI";
        public const string XConnSrvCache               = "XConnSrvCache";
        public const string XConnSrvConnection          = "XConnSrvConnection";
        public const string XConnSrvLog                 = "XConnSrvLog";
        public const string XConnSrvSubscription        = "XConnSrvSubscription";
        public const string XCrypto                     = "XCrypto";
        public const string xlastutil                   = "xlastutil";
        public const string xlisttrace                  = "xlisttrace";
        public const string xmachine                    = "xmachine";
        public const string xqry                        = "xqry";
        public const string xrltrace                    = "xrltrace";
        public const string xsig                        = "xsigv";
        public const string xsiglog                     = "xsiglog";
        public const string xsuppapi                    = "xsuppapi";
        public const string xsuppapiEmailSentLog        = "xsuppapiEmailSentLog";
        public const string xsuppapiLog                 = "xsuppapiLog";
        public const string xtou                        = "xtou";
        public const string xuacs                       = "xuacs";
        public const string xuser                       = "xuser";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\XomDictionary.cs ===
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Linq;

namespace xonline.common.mgmt
{
    [ComVisible(false)]
    public class XomDictionary<TObject>
    {
        // IMPORTANT NOTE:
        //
        // This file follows this pattern when accessing _ObjectsByName:
        //
        // READ operations:
        //   1. Get local reference to _ObjectsByName
        //   2. Do read operation
        //
        // Note: if read operation requires a single reference to _ObjectsByName, there is 
        // no need to get a local reference.
        //
        // WRITE operations:
        //   1. Get local reference to _ObjectsByName
        //   2. Perform a copy of it
        //   3. Do write operation
        //   4. Assign _ObjectsByName to local reference
        //

        private volatile Dictionary<string, TObject>  _ObjectsByName;
        private object                                _WriterLock;

        public XomDictionary()
        {
            _ObjectsByName = new Dictionary<string, TObject>(StringComparer.InvariantCultureIgnoreCase);
            _WriterLock = new object();
        }

        public TObject this[string key]
        {
            get
            {
                // We're changing the expected behavior -- this will return null if the 
                // key does not exist. Dictionary would throw an exception, but the 
                // xmgmt code seems to expect a null.

                TObject obj;
                if (!_ObjectsByName.TryGetValue(key, out obj))
                {
                    obj = default(TObject);
                }
                return obj;
            }

            set
            {
                Add(key, value);
            }
        }

        public int Count
        {
            get { return _ObjectsByName.Count; }
        }

        public bool ContainsKey(string name)
        {
            return _ObjectsByName.ContainsKey(name);
        }

        public bool TryGetValue(string name, out TObject obj)
        {
            return _ObjectsByName.TryGetValue(name, out obj);
        }

        public void Add(string name, TObject obj)
        {
            // This is expected to be an infrequent operation. Every add requires O(n 
            // log n) time since we have to copy the existing dictionary and "re-sort" 
            // it.
            Dictionary<string, TObject> objects, newObjects;
            lock (_WriterLock)
            {
                objects = _ObjectsByName;

                newObjects = new Dictionary<string, TObject>(
                    _ObjectsByName, 
                    StringComparer.InvariantCultureIgnoreCase);
                newObjects[name] = obj;

                // plunk it back in
                _ObjectsByName = newObjects;
            }
        }

        public bool Remove(string name)
        {
            Dictionary<string, TObject> objects, newObjects;
            lock (_WriterLock)
            {
                objects = _ObjectsByName;
                
                // Shortcut - if object isn't in dictionary, bail out
                if (!objects.ContainsKey(name))
                {
                    return false;
                }

                newObjects = new Dictionary<string, TObject>(
                    objects, 
                    StringComparer.InvariantCultureIgnoreCase);
                bool ret = newObjects.Remove(name);

                // plunk it back in
                _ObjectsByName = newObjects;

                return ret;
            }
        }

        public void ForEach(Action<TObject> action)
        {
            // Must get local reference
            Dictionary<string, TObject> objects = _ObjectsByName;
            foreach (TObject obj in objects.Values)
            {
                action(obj);
            }
        }

        public void SortedForEach(Action<TObject> action)
        {
            // Must get local reference
            Dictionary<string, TObject> objects = _ObjectsByName;
            var sortedKeys = objects
                .Select(d => d.Key)
                .OrderBy(d => d, StringComparer.InvariantCultureIgnoreCase);

            foreach (string key in sortedKeys)
            {
                TObject obj = objects[key];
                // obj can't be null since the dictionary can't change from under us
                action(obj);
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\XomControlConnection.cs ===
using System;
using System.IO;
using System.Text;
using SysDiag = System.Diagnostics ;
using System.Threading;
using System.Runtime.InteropServices;
using System.Security.Principal;

using xonline.common.service;

namespace xonline.common.mgmt
{
[ComVisible(false)]
public static class XomControlConnection
{

    const uint XOMCTRL_MAXPROCESSNAME = 256;
    const uint XOMCTRL_MAXCOMPONENTNAME = 256;
    const uint XOMCTRL_MAXMESSAGESIZE = 30720;
    const int PIPE_BUFFER_SIZE = (int)XOMCTRL_MAXMESSAGESIZE;

    const uint XOMCTRLMSGID_REGISTER = 0x01;
    const uint XOMCTRLMSGID_REQUEST = 0x02;
    const uint XOMCTRLMSGID_RESPONSE = 0x03;
    const uint XOMCTRLMSGID_RESPONSE_DONE = 0x04;

    class RegisterMsg
    {
        public uint Size = 12 + XOMCTRL_MAXPROCESSNAME + XOMCTRL_MAXCOMPONENTNAME;
        public uint Type = XomControlConnection.XOMCTRLMSGID_REGISTER;
        public uint ProcessId = 0;
        public string ProcessName = "";
        public string ComponentName = "";


        public void Write(PipeStream pipe, UTF8Encoding enc)
        {
            byte[] processNameBytes = enc.GetBytes(ProcessName);
            byte[] componentNameBytes = enc.GetBytes(ComponentName);

            pipe.Writer.Write(Size);
            pipe.Writer.Write(Type);
            pipe.Writer.Write(ProcessId);

            pipe.Writer.Write(processNameBytes);
            if (processNameBytes.Length < XOMCTRL_MAXPROCESSNAME)
            {
                pipe.Writer.Write(new byte[XOMCTRL_MAXPROCESSNAME - processNameBytes.Length]);
            }

            pipe.Writer.Write(componentNameBytes);
            if (componentNameBytes.Length < XOMCTRL_MAXPROCESSNAME)
            {
                pipe.Writer.Write(new byte[XOMCTRL_MAXCOMPONENTNAME - componentNameBytes.Length]);
            }

            pipe.Flush();

        }
    }

    class RequestMsg
    {
        public uint Size = 0;
        public uint Type = XomControlConnection.XOMCTRLMSGID_REQUEST;
        public uint RequestId;
        public string Message = "";

        public byte[] SizeBytes = new byte[4];

        public void Read(byte[] bytes, int cb, UTF8Encoding enc)
        {
            MemoryStream memstream = new MemoryStream(bytes);
            BinaryReader reader = new BinaryReader(memstream);

            if (cb <= 12)
            {
                Xom.NtEvent( XEvent.Id.COMMON_HACK_4, "Invalid control message received! Size=" + Size + "; Expected size > 12." );
                Type = 0;
                return;
            }

            Size = reader.ReadUInt32();
            if (Size != cb)
            {
                Xom.NtEvent( XEvent.Id.COMMON_HACK_5, "Invalid control message received! Size (" + Size + ") != msg size (" + cb + ")" );
                Type = 0;
                return;
            }

            Type = reader.ReadUInt32();
            if (Type != XomControlConnection.XOMCTRLMSGID_REQUEST)
            {
                Xom.NtEvent( XEvent.Id.COMMON_HACK_6, "Invalid control message received! Type=" + Type + "; Expected Type=" + XomControlConnection.XOMCTRLMSGID_REQUEST );
                Type = 0;
                return;
            }

            RequestId = reader.ReadUInt32();
            Message = enc.GetString(reader.ReadBytes((int)Size - 12));
        }

    }


    class ResponseMsg
    {
        public const uint ResponseMsgSize = 12;  // plus message body 

        public uint Type = XomControlConnection.XOMCTRLMSGID_RESPONSE;
        public uint RequestId = 0;
        public string Message = "";

        public void Write(PipeStream pipe, UTF8Encoding enc)
        {
            byte[] messageBytes = enc.GetBytes(Message);
            uint messageSize = (uint)messageBytes.Length;
            uint messageIndex = 0;  // once in a while, I miss pointers
            
            while (messageSize > 0)
            {
                // Don't exceed max message size, or else xmgmtsrv will fizzle and burn.
                uint bytesToSend = Math.Min(
                    messageSize, 
                    XomControlConnection.XOMCTRL_MAXMESSAGESIZE - ResponseMsgSize);

                pipe.Writer.Write(ResponseMsgSize + bytesToSend);
                pipe.Writer.Write(Type);
                pipe.Writer.Write(RequestId);
                pipe.Writer.Write(messageBytes, (int)messageIndex, (int)bytesToSend);

                messageSize -= bytesToSend;
                messageIndex += bytesToSend;
            }
            
            pipe.Flush();
        }
    }

    class ResponseDoneMsg
    {
        public uint Size = 16;
        public uint Type = XomControlConnection.XOMCTRLMSGID_RESPONSE_DONE;
        public uint RequestId = 0;
        public HResult hr = HResult.S_OK;

        public void Write(PipeStream pipe, UTF8Encoding enc)
        {
            pipe.Writer.Write(Size);
            pipe.Writer.Write(Type);
            pipe.Writer.Write(RequestId);
            pipe.Writer.Write(hr);
            pipe.Flush();
        }
    }

    public static void Startup()
    {
        Connect();
        _timer = new System.Threading.Timer(new TimerCallback(XmgmtWatchDogFunc), _id, 30 * 1000, 30 * 1000);
        _init = true;
    }

    private static void Connect()
    {
        if (_pipe != null)
        {
            return;
        }

        // Try to get a global lock, multiple timers events or callers
        // should be protected from multi-init problems
        lock (objectLock)
        {
            try
            {
                // Allow quick test above but serialize access to initialization
                // code path
                if(_pipe != null)
                {
                    return;
                }

                // Use a cached identity so that we can restart the xomcontrolconnection
                // from the health URL. This is required to reopen the pipe connection.
                // and property run the watchdog
                if(null == _id)
                {
                    _id = WindowsIdentity.GetCurrent();
                }
                else
                {
                    _id.Impersonate();
                }

                _pipe = new PipeStream("\\\\.\\pipe\\xmgmtsrvpipe", PIPE_BUFFER_SIZE);

                // register
                RegisterMsg msg = new RegisterMsg();
                msg.ProcessId = (uint) SysDiag.Process.GetCurrentProcess().Id;
                msg.ProcessName = SysDiag.Process.GetCurrentProcess().MainModule.ModuleName;
                msg.ComponentName = XomLoggingControl.AssemblyName;

                if (msg.ProcessName.EndsWith(".exe", StringComparison.InvariantCultureIgnoreCase))
                {
                    msg.ProcessName = msg.ProcessName.Substring(0, msg.ProcessName.Length - 4);
                }

                msg.Write(_pipe, _enc);

                StartReading();

                Xom.NtEvent( XEvent.Id.COMMON_INFO_46, "Connection with Xmgmtsrv is established."  );

            }
            catch(Exception e)
            {
                Xom.NtEvent( XEvent.Id.COMMON_CONFIG_252, e, "Failed to connect to Xmgmtsrv. No remote administration is available.");
                _pipe = null;
            }
        }
    }

    private static void StartReading()
    {
        try
        {
            lock (objectLock)
            {
                if( ( _pipe != null ) && _pipe.CanRead )
                {
                    byte[] buf= new byte[PIPE_BUFFER_SIZE];

                    _pipe.BeginRead(buf, 0, PIPE_BUFFER_SIZE, new AsyncCallback(XomControlConnection.ReadMessage), buf);
                }
            }
        }
        catch(Exception e)
        {
            Xom.NtEvent( XEvent.Id.MGMT_READ_FAILURE, e, "XomControlConnection.StartReading() failed to begin reading, the pipe connection will be released.");
            Disconnect();
        }
    }

    public static void ReadMessage(IAsyncResult ar)
    {
        int cb = 0;

        try
        {
            lock (objectLock)
            {
                cb = ( _pipe != null ) ? _pipe.EndRead(ar) : 0;

                if (cb==0)  // end of stream
                {
                    if (_pipe != null)
                    {
                        // Only fire this event if there is an unexpected shutdown of the connection, standard close (_pipe = null)
                        // is perfectly reasonable and should not be the cause of an event.
                        Xom.NtEvent(XEvent.Id.COMMON_CONFIG_253, "Xmgmtsrv pipe closed. No remote administration is available.");
                    }
                    Disconnect();
                }
            }
        }
        catch ( Exception e )
        {
            Disconnect();
            Xom.NtEvent( XEvent.Id.COMMON_CONFIG_254, e, "Failed to read from Xmgmtsrv pipe. No remote administration is available.");
            cb = 0;
        }

        if (cb > 0)
        {
            RequestMsg msg = new RequestMsg();
            msg.Read((byte[])ar.AsyncState, cb, _enc);

            ControlRequestEventArgs args = new ControlRequestEventArgs(msg.Message, msg.RequestId);

            try
            {
                XomControl.OnControlRequest(args);
            }
            catch(Exception)
            {
                args.hr = HResult.E_FAIL;
            }

            ResponseDoneMsg msgDone = new ResponseDoneMsg();
            msgDone.RequestId = msg.RequestId;
            msgDone.hr = args.hr;

            
            try
            {
                lock (objectLock)
                {
                    if( _pipe != null )
                    {
                        // The service may have stopped after sending 'AdminSessionDied'
                        // at which point the pipe has been disposed. The write will fail
                        // if we don't handle this the containing process will crash
                        msgDone.Write(_pipe, _enc);
                    }
                }
            }
            catch( Exception e )
            {
                Disconnect();
                Xom.NtEvent( XEvent.Id.COMMON_CONFIG_PIPE_HANDLE_DISPOSED, e, "Xmgmtsrv pipe disposed, No remote administration is available.");
                cb = 0;
            }
        }

        // Only if all of the previous work resulted succeeded (bytes read and returned) should another read be scheduled.
        if (cb > 0)
        {
            StartReading();
        }
    }

    public static void SendMessage(string message, uint requestId)
    {
        ResponseMsg msg = new ResponseMsg();
        msg.RequestId = requestId;
        msg.Message = message;

        try
        {
            lock (objectLock)
            {
                msg.Write(_pipe, _enc);
            }
        }
        catch ( Exception e )
        {
            Disconnect();
            Xom.NtEvent( XEvent.Id.COMMON_CONFIG_255, e, "Failed to write to Xmgmtsrv pipe. No remote administration is available.");
        }
    }



    private static void Disconnect()
    {
        lock (objectLock)
        {
            // The watchdog timer serves to reconnect the pipe when it gets closed (by 
            // this function). Please don't also kill the watchdog function here. When you 
            // call _timer.Dispose(), it will NOT make a "final" callback.

            // Cleanup pipe
            try
            {
                if (_pipe != null)
                {
                    _pipe.Dispose();
                }
            }
            catch(Exception)
            {
            }
            finally
            {
                _pipe = null;
            }
        }
    }

    public static void Shutdown()
    {
        _init = false;
        if (_timer != null)
        {
            _timer.Dispose();
            _timer = null;
        }

        Disconnect();
    }
    public static void XmgmtWatchDogFunc(object o)
    {
        lock (objectLock)
        {
            if (_init)
            {
                Connect();
            }
        }
    }

    private static volatile bool _init = false;
    private static WindowsIdentity _id = null;
    private static Timer _timer = null;
    private static UTF8Encoding _enc = new UTF8Encoding();
    private static PipeStream _pipe;

    private static object objectLock = new object();
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\XomLogTarget.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Web;

using xonline.common.config;
using xonline.common.service;
using xonline.common.utilities2;

namespace xonline.common.mgmt
{
[ComVisible(false)]
public abstract class XomLogTarget
{
    protected string _name;
    protected string _params;
    protected uint _session;

    //
    // Property accessors
    //
    public string Name
    {
        get { return _name; }
        set { _name = value; }
    }
    public string Params
    {
        get { return _params; }
        set { _params = value; }
    }

    public uint Session
    {
        get { return _session; }
        set { _session = value; }
    }

    public override bool Equals(object o)
    {
        return ( o is XomLogTarget ) && ( ((XomLogTarget) o).Name.Equals(_name, StringComparison.InvariantCultureIgnoreCase) ) ;
    }

    public override int GetHashCode()
    {
        return( _name.GetHashCode() );
    }

    public virtual void Init( string[,] parameters ) {}
    public abstract void Log( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte[] msgData, string message, Exception e);
    public virtual void Close() {}
    public virtual void Reset() {}
    public virtual void Startup() {}

    protected virtual DateTime CurrentTime
    {
        get { return XDateTime.Now; }
    }

    protected static bool ParseBool(string paramName, string paramValue)
    {
        if (paramValue.Equals("true", StringComparison.OrdinalIgnoreCase) ||
            paramValue.Equals("on", StringComparison.OrdinalIgnoreCase) ||
            paramValue.Equals("1"))
        {
            return true;
        }
        else if (paramValue.Equals("false", StringComparison.OrdinalIgnoreCase) ||
                 paramValue.Equals("off", StringComparison.OrdinalIgnoreCase) ||
                 paramValue.Equals("0"))
        {
            return false;
        }
        else
        {
            throw new ArgumentOutOfRangeException(
                paramName, paramValue, 
                "Error converting parameter to boolean. Must be 'true/false', 'on/off', or '1/0'.");
        }
    }

}

[ComVisible(false)]
public struct XomLogTargetContext
{
    public readonly static XomLogTargetContext Empty = new XomLogTargetContext()
    {
        LogStringId = null,
        FlowToken = Floken.None,
        EventData = null,
        LineData = null
    };

    public XomLogTargetContext(Floken flowToken) : this()
    {
        FlowToken = flowToken;
    }

    public string LogStringId
    {
        get;
        set;
    }

    public Floken FlowToken
    {
        get;
        set;
    }

    public EtxEvent? EventData
    {
        get;
        set;
    }

    public SchematizedLine? LineData
    {
        get;
        set;
    }

    [ComVisible(false)]
    public struct EtxEvent
    {
        public Blob Fingerprint
        {
            get;
            set;
        }

        public byte HeaderVersion
        {
            get;
            set;
        }

        public uint WebRepGroupId
        {
            get;
            set;
        }
    }

    [ComVisible(false)]
    public struct SchematizedLine
    {
        public Blob Fingerprint
        {
            get;
            set;
        }

        public string Key
        {
            get;
            set;
        }

        public byte HeaderVersion
        {
            get;
            set;
        }
    }
}

[ComVisible(false)]
public class XomDebugOutputTarget : XomLogTarget
{
    public XomDebugOutputTarget( string[,] parameters )
    {
        Init( parameters );
    }

    public override void Log( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte [] msgData, string message, Exception e)
    {
        string lvlStr;

        switch( level )
        {
        case XomLogLevel.Low:
            lvlStr = "VBS";
            break;

        case XomLogLevel.Info:
            lvlStr = "INF";
            break;

        case XomLogLevel.Warning:
            lvlStr = "WRN";
            break;

        case XomLogLevel.Error:
            lvlStr = "ERR";
            break;

        default:
            lvlStr = "";
            break;
        }

        if (e != null)
        {
            message += "\r\n" + EventBuilder.ExceptionToString(e);
        }

        System.Diagnostics.Trace.WriteLine( lvlStr + "[" + area+ "] " + msgCtx.FlowToken.ToString() + ": " + message );
    }
}

[ComVisible(false)]
public class XomConsoleTarget : XomLogTarget
{
    public XomConsoleTarget( string[,] parameters )
    {
        Init( parameters );
    }

    public override void Log( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte [] msgData, string message, Exception e )
    {
        string lvlStr;

        switch( level )
        {
        case XomLogLevel.Low:
            lvlStr = "VBS";
            break;

        case XomLogLevel.Info:
            lvlStr = "INF";
            break;

        case XomLogLevel.Warning:
            lvlStr = "WRN";
            break;

        case XomLogLevel.Error:
            lvlStr = "ERR";
            break;

        default:
            lvlStr = "";
            break;
        }

        if (e != null)
        {
            message += "\r\n" + EventBuilder.ExceptionToString(e);
        }

        if (msgCtx.FlowToken.IsValid)
        {
            System.Console.WriteLine(lvlStr + "[" + area + "] " + msgCtx.FlowToken.ToString() + ": " + message);
        }
        else
        {
            System.Console.WriteLine( lvlStr + "[" + area+ "]: " + message );
        }
    }
}


[ComVisible(false)]
public class XomNtLogTarget : XomLogTarget
{
    public XomNtLogTarget( string[,] parameters )
    {
        Init( parameters );
    }

    public override void Init( string[,] parameters )
    {
        string log = "Application";

        for( int n=0; n < parameters.GetLength(0); n++ )
        {
            switch( parameters[ n, 0 ].ToLower() )
            {
            case "type":
                // already know this
                break;

            case "source":
                _source = parameters[ n, 1 ];
                break;

            case "log":
                log = parameters[ n, 1 ];
                break;

            default:
                parameters[n,0] = null;
                break;
            }
        }

        if( _source == null )
        {
            // no source specified, use the name of the assembly
            _source = Path.GetFileNameWithoutExtension( Config.AssemblyPath );
        }

        if( !System.Diagnostics.EventLog.SourceExists( _source ) )
        {
            System.Diagnostics.EventLog.CreateEventSource( _source, log );
        }
    }

    public override void Log( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte [] msgData, string message, Exception e )
    {
        EventBuilder.LogEvent(msgCtx, area, level, msgId, msgData, message, e);

        // if we are handling an http request, then cache  the
        // last event id to put into the response header later

        HttpContext context = HttpContext.Current;
        if (context != null) context.Items["XEvent"] = msgId.ToString();
    }

    private string _source = null;
    private EventLogEntryType[] _typeMapping = {
            EventLogEntryType.Information,
            EventLogEntryType.Information,
            EventLogEntryType.Warning,
            EventLogEntryType.Error
        };
}


[ComVisible(false)]
public class XomRemoteTarget : XomLogTarget
{
    const int DEFAULT_REMOTE_PORT = 4101;

    public XomRemoteTarget( string[,] parameters )
    {
        Init( parameters );
    }

    public override void Init( string[,] parameters )
    {
        string address = null;
        int port = DEFAULT_REMOTE_PORT;

        for( int n = 0; n < parameters.GetLength( 0 ); n++ )
        {
            switch( parameters[ n, 0 ].ToLower() )
            {
            case "type":
                // already know this
                break;

            case "address":
                address = parameters[ n, 1 ];
                break;

            case "port":
                port = Convert.ToInt32( parameters[ n, 1 ] );
                break;

            default:
                parameters[n,0] = null;
                break;
            }

        }

        if( address == null )
        {
            throw new ArgumentNullException( "address", "Address not specified!" );
        }

        IPAddress remoteAddr;

        //  First try to parse the address as an IP address.  If
        //  that fails, then we'll try a DNS lookup.
        try
        {
            remoteAddr = IPAddress.Parse(address);
        }
        catch
        {
            remoteAddr = Dns.GetHostEntry( address ).AddressList[ 0 ];
        }

        _socket = new UdpClient();
        _socket.Connect( remoteAddr, port );

        // Cache frequently used items. These are non-trivial to retrieve, say, 10,000 
        // times per second.
        s_szProcessName = Process.GetCurrentProcess().ProcessName;
        s_szProcessId = Process.GetCurrentProcess().Id.ToString();
        s_szComponentName = Config.ComponentName;

        // Old:
        //s_szProcessName = Process.GetCurrentProcess().MainModule.ModuleName;
        //s_szCurrentDomain = AppDomain.CurrentDomain.ToString();
        //s_szAssemblyPath = Path.GetFileNameWithoutExtension(Config.AssemblyPath);
    }


    public override void Log( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte[] msgData, string message, Exception e)
    {
        byte[] dg;

        if (String.IsNullOrEmpty(s_szThreadId))
        {
            s_szThreadId = Thread.CurrentThread.ManagedThreadId.ToString();
        }

        string szLevel = level.ToString();

        if (e != null)
        {
            message += "\r\n" + EventBuilder.ExceptionToString(e);
        }

        // These header values should probably match the ones in native code 
        // (xomremotetarget.cpp). And now they do.

        string header = s_szProcessName + ";" +
                        s_szProcessId + ";" +
                        s_szComponentName + ";" +
                        s_szThreadId + ";" +
                        area + ";" + 
                        szLevel + ";" + 
                        msgId + ";" +
                        msgCtx.FlowToken.ToString() + "::";

        dg = _enc.GetBytes(header + message);

        _socket.Send( dg, dg.Length );
    }

    public override void Close()
    {
        _socket.Close();
    }

    private static string s_szProcessName;
    private static string s_szProcessId;
    private static string s_szComponentName;

    [ThreadStatic]
    private static string s_szThreadId;

    private UdpClient _socket;
    private UTF8Encoding _enc = new UTF8Encoding();
}

[ComVisible(false)]
public class XomReportTarget : XomLogTarget
{
    private class Context
    {
        public Context(int queueSize)
        {
            DisconnectNotified = false;
            LastMessage = 0;
            LastReset = 0;

            ReportConnection = new ReportConnection(queueSize);
            ReportConnection.Startup();
        }

        public ReportConnection ReportConnection;
        public bool DisconnectNotified;
        public long LastMessage;
        public long LastReset;
    }
    
    public XomReportTarget( string[,] parameters )
    {
        _iConnectResetInterval = 0; // Default connection reset interval 0 ms - disabled        
        _iHeartBeatInterval = 15 * 1000; // Default heartbeat interval is 15 seconds
        _iKeepAliveInterval = 5 * 60 * 1000; // Default keep alive interval of 5 minutes
        _iQueueSize = 100000;  // Default max number of items in queue is 100,000
        _iConnectionCount = 1; // Default number of report connections        
        Init( parameters );

        _pConnections = null;       
        _threadHeartBeat = null;
        _iInitialized = 0;
        _iShutdown = 0;
        _hShutdown = new AutoResetEvent( false );
        _iConnectionIndex = 0;        
    }

    public override void Init( string[,] parameters )
    {
        bool checkConnections = false;
        bool checkQueueSize = false;
        int connectionCount = 0;
        
        for( int n = 0; n < parameters.GetLength( 0 ); n++ )
        {
            switch( parameters[ n, 0 ].ToLower() )
            {
            case "type":
                // already know this
                break;

            case "connectionresetintervalsec":
                _iConnectResetInterval = Convert.ToInt32( parameters[n, 1] ) * 1000;
                break;
            
            case "heartbeatintervalsec":
                _iHeartBeatInterval = Convert.ToInt32( parameters[ n, 1 ] ) * 1000;
                break;

            case "keepaliveintervalsec":
                _iKeepAliveInterval = Convert.ToInt32( parameters[ n, 1 ] ) * 1000;
                break;

            case "queuesize":
                _iQueueSize = Convert.ToInt32( parameters[ n, 1 ] );
                checkQueueSize = true;
                break;

            case "connections":
                connectionCount = Math.Max(Convert.ToInt32(parameters[n, 1]), 1);
                checkConnections = true;
                break;

            default:
                parameters[n,0] = null;
                break;
            }

            if (_pConnections != null)
            {
                // Resize queues if neccessary
                for (int c = 0; c < _pConnections.Count && checkQueueSize; c++)
                {
                    _pConnections[c].ReportConnection.MaxQueueSize = _iQueueSize;
                }

                // Adjust connection counts if neccessary
                while (checkConnections && _pConnections.Count > connectionCount)
                {
                    int index = _pConnections.Count - 1;

                    Interlocked.Decrement(ref _iConnectionCount);

                    _pConnections[index].ReportConnection.Disconnect();

                    _pConnections.RemoveAt(index);
                }

                while (checkConnections && _pConnections.Count < connectionCount)
                {
                    _pConnections.Add(CreateContext());

                    Interlocked.Increment(ref _iConnectionCount);
                }

                if (checkConnections)
                {
                    _InternalConnect(false);
                }
            }
            else if (checkConnections)
            {
                _iConnectionCount = connectionCount;
            }
        }
    }

    public override void Log( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte [] msgData, string message, Exception e )
    {
        WireData rptMsgDataWire;

        //
        // If we are shutdown or not initialized, just return
        //
        if( 1 == _iShutdown || 0 == _iInitialized )
        {
            return;
        }

        if (e != null)
        {
            message += "\r\n" + EventBuilder.ExceptionToString(e);
        }

        //
        // Remove "naughties"
        //
        if (!String.IsNullOrEmpty(message))
        {
            message = message.ReplaceControlCharacters('#');
        }

        //
        // Fill the message header
        //

        if (msgCtx.EventData.HasValue)
        {
            ReportMessageData2 report;

            report = new ReportMessageData2();

            report.WebRepGroupId = msgCtx.EventData.Value.WebRepGroupId;
            report.LogStringId = msgCtx.LogStringId;
            report.EtxEventFingerprint = (byte[])msgCtx.EventData.Value.Fingerprint;
            report.EtxEventHeaderVersion = msgCtx.EventData.Value.HeaderVersion;
            report.szMessage = message;

            rptMsgDataWire = report;
        }
        else if (msgCtx.LineData.HasValue)
        {
            ReportMessageData3 report;

            report = new ReportMessageData3();

            report.LogStringId = msgCtx.LogStringId;
            report.EtxEventFingerprint = msgCtx.LineData.Value.Fingerprint;
            report.EtxEventHeaderVersion = msgCtx.LineData.Value.HeaderVersion;
            report.FileNameKey = msgCtx.LineData.Value.Key;
            report.szMessage = message;

            rptMsgDataWire = report;
        }
        else
        {
            ReportMessageData rptMsgData = new ReportMessageData();
            rptMsgData.szMessage = message;

            rptMsgDataWire = rptMsgData;
        }

        //
        // Send the message
        //
        try
        {
            Context context;

            int idx = (int)(Interlocked.Increment(ref _iConnectionIndex) % _iConnectionCount);
            context = _pConnections[idx];
            context.ReportConnection.Send(rptMsgDataWire);

            Interlocked.Exchange( ref context.LastMessage, DateTime.Now.Ticks );           
        }
        catch( Exception exc )
        {
            Xom.NtEvent( XEvent.Id.COMMON_CODE_33, exc, "XomReportTarget::Log - ReportConnection::Send failed");
        }
    }

    public override void Close()
    {
        ReportMessageBase msgDisconnect;

        //
        // Return if we're not initialized
        //
        if( 0 == _iInitialized )
        {
            return;
        }

        //
        // Just return if we've already been called
        //
        if( 1 == Interlocked.Exchange( ref _iShutdown, 1 ) )
        {
            return;
        }

        foreach (Context context in _pConnections)
        {
            //
            // Send a disconnect message
            //
            msgDisconnect = new ReportMessageBase( );
            msgDisconnect.bMsgType = ( byte ) RPT_MSG_TYPE.RPT_MSG_DISCONNECT;        

            //
            // Send the disconnect message
            //
            try
            {
                context.ReportConnection.Send( msgDisconnect );
            }
            catch (Exception e)
            {
                Xom.NtEvent( XEvent.Id.COMMON_CODE_34, e, "XomReportTarget::Close - ReportConnection::Send failed");
            }
        }

        //
        // Abort the heartbeat thread
        //
        if( !_hShutdown.Set( ) )
        {
            Xom.NtEvent( XEvent.Id.COMMON_CODE_35, "XomReportTarget::Close - Unable to signal thread to shutdown. Going to abort the thread." );
            _threadHeartBeat.Abort( );
        }

        //
        // Sleep a couple of seconds for the disconnect to get sent, then disconnect
        //
        Thread.Sleep( 2000 );

        ShutdownConnections();

        _pConnections = null;
        _iInitialized = 0;
        _threadHeartBeat = null;
    }

    private Context CreateContext()
    {
        Context context;

        //
        // Create and initialize individual report Context object.
        //
        context = new Context(_iQueueSize);

        //
        // Set server and component ID on the connection object
        //
        context.ReportConnection.ComponentID = _componentID;
        context.ReportConnection.Component = _component;

        return context;
    }

    public override void Startup()
    {
        IVirtualInterfaceInfo pVirtualInterface;

        //
        // Bail out if Component ID is not set
        //
        if (0 == Config.ReportMessageComponentId)
        {
            // 
            // Since this is a XomLogTarget Startup method the area may not be completely
            // established - so the ntlog target maynot be in place, in order to ensure
            // the message reaches the event logs this bootstrapping logging method will
            // be used instead
            // 
            XomLoggingControl.WriteEarlyEvent(
                XEvent.Id.MGMT_MISSING_REPORTING_COMPONENT_ID,
                "XomReportTarget::Startup component missing reporting component id, no reporting connection will be established.");

            return;
        }

        //
        // Just return if we've already been called
        //
        if( 1 == Interlocked.Exchange( ref _iInitialized, 1 ) )
        {
           return;
        }

        //
        // Retrieve the cleanser server information, and create the endpoint
        //
        try
        {
            _component = Config.ComponentName;
            _componentID = Config.ReportMessageComponentId;

            pVirtualInterface = Config.GetVirtualInterface( Config.ReportMessageCleanserVirtualInterface );
            _epCleanserHost = pVirtualInterface.IPAddressString;
            _epCleanserPort = pVirtualInterface.Port;

            //
            // Create instances of the ReportConnection object
            //
            _pConnections = new List<Context>();

            for (int c = 0; c < _iConnectionCount; c++)
            {
                _pConnections.Add(CreateContext());
            }            

            //
            // Connect to our desired server
            //
            try
            {
                _InternalConnect(false);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.COMMON_COMM_9, e, "XomReportTarget::Startup - Reporting target was unable to connect to the cleanser {0}:{1}. We will keep trying.", _epCleanserHost, _epCleanserPort);
            }

            //
            // Create the heartbeat thread
            //
            _threadHeartBeat = new XboxLiveThread( new ThreadStart( this._HeartBeatThread ) );
            _threadHeartBeat.Start( );

            Config.VirtualInterfaceChange += new VirtualInterfaceChangeEventHandler( VirtualInterfaceChanged );
        }
        catch( Exception )
        {
            ShutdownConnections();

            _pConnections = null;
           
            Interlocked.Exchange( ref _iInitialized, 0 );
            
            throw;
        }
    }

    public void VirtualInterfaceChanged(object sender, VirtualInterfaceChangeEventArgs eventArgs)
    {
        IVirtualInterfaceInfo pInterface;

        if( ( eventArgs.Environment == Config.Environment ) &&
            ( eventArgs.VirtualInterface == Config.ReportMessageCleanserVirtualInterface ) )
        {
            pInterface = eventArgs.ValueNew;
            _epCleanserHost = pInterface.IPAddressString;
            _epCleanserPort = pInterface.Port;

            DisconnectConnections();
        }
    }

    private void ShutdownConnections()
    {
        if (null == _pConnections)
        {
            return;
        }

        foreach (Context context in _pConnections)
        {
            if (null == context || null == context.ReportConnection)
            {
                break;
            }

            context.ReportConnection.Disconnect();
            context.ReportConnection.Shutdown();
        }
    }

    private void DisconnectConnections()
    {
        if (null == _pConnections)
        {
            return;
        }

        foreach (Context context in _pConnections)
        {
            if (null == context || null == context.ReportConnection)
            {
                break;
            }

            context.ReportConnection.Disconnect();
        }
    }

    private void _InternalConnect(bool forced)
    {
        foreach (Context context in _pConnections)
        {
            _InternalConnect(context, forced);
        }
    }

    private void _InternalConnect(Context context, bool forced)
    {
        if (context.ReportConnection.IsConnected && !forced)
        {
            return;
        }

        //
        // Connect to our cleansing server
        //
        context.ReportConnection.AttachAndConnect(_epCleanserHost, _epCleanserPort);
        context.LastReset = DateTime.Now.Ticks;
    }
    

    private void _HeartBeatThread()
    {
        Restart:
        try
        {
            while( true )
            {
                int wait;

                wait = _iConnectResetInterval == 0 ? _iHeartBeatInterval : Math.Min(_iHeartBeatInterval, _iConnectResetInterval);

                if( ( _hShutdown.WaitOne( wait, false ) ) && ( _iShutdown == 1 ) )
                {
                
                    //
                    // Received a signal and the target is shutting down
                    //
                    break;
                }

                for (int index=0; index<_pConnections.Count; index++)
                {
                    ReportMessageBase msgKeepAlive;
                    Context context;
                    long tickNow;
                    long tickStored;

                    context = _pConnections[index];
               
                    //
                    // If we're not connected, reconnect
                    //
                    if (!context.ReportConnection.IsConnected)
                    {
                        if (!context.DisconnectNotified)
                        {
                            Xom.NtEvent(XEvent.Id.COMMON_COMM_10, "XomReportTarget::_HeartBeatThread - Reporting target has lost connection to the cleansing server {0}:{1}. Attempting to reconnect", _epCleanserHost, _epCleanserPort);
                        }

                        try
                        {
                            _InternalConnect(context, false);
                        }
                        catch (Exception e)
                        {
                            if (!context.DisconnectNotified)
                            {
                                Xom.NtEvent(XEvent.Id.COMMON_COMM_11, e, "XomReportTarget::_HeartBeatThread - XomReportTarget::_InternalConnect failed to {0}:{1}", _epCleanserHost, _epCleanserPort);
                                context.DisconnectNotified = true;
                            }
                            continue;
                        }

                        //
                        // Force sending of a keepalive message to kick start the queue
                        //
                        if (context.DisconnectNotified)
                        {
                            Xom.NtEvent(XEvent.Id.REPORTINGTARGET_RECONNECTED, "XomReportTarget::_HeartBeatThread - Reporting target has reconnected to the cleansing server {0}:{1}.", _epCleanserHost, _epCleanserPort);
                            context.DisconnectNotified = false;
                        }
                        Interlocked.Exchange(ref context.LastMessage, (long)0);
                    }

                    //
                    // If sufficient time has elapsed without sending a prior message, trigger a connection reset
                    //
                    tickNow = DateTime.Now.Ticks;

                    tickStored = context.LastReset;

                    if (_iConnectResetInterval > 0)
                    {
                        if ((tickNow - tickStored) > ((long)_iConnectResetInterval * 10 * 1000))
                        {
                            _InternalConnect(context, true);
                        }
                    }

                    //
                    // If sufficient time has elapsed without sending a prior message, send a keep alive message
                    //
                    tickNow = DateTime.Now.Ticks;

                    tickStored = context.LastMessage;
                    
                    if ((tickNow - tickStored) <= ((long)_iKeepAliveInterval * 10 * 1000))
                    {
                        continue;
                    }

                    msgKeepAlive = new ReportMessageBase();
                    msgKeepAlive.bMsgType = (byte)RPT_MSG_TYPE.RPT_MSG_KEEPALIVE;

                    //
                    // Send the keepalive message
                    //
                    try
                    {
                        context.ReportConnection.Send(msgKeepAlive);
                    }
                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.COMMON_CODE_36, e, "XomReportTarget::_HeartBeatThread - ReportConnection::Send failed ({0})", index);
                        continue;
                    }
                    Interlocked.Exchange(ref context.LastMessage, tickNow);
                }
            }
        }
        catch( ThreadAbortException threadExc )
        {
            //
            // We are being forced to shutdown
            //
            Xom.NtEvent( XEvent.Id.COMMON_CODE_37, threadExc, "XomReportTarget::_HeartBeatThread - Thread being aborted");
            goto lDone;
        }
        catch (Exception e)
        {
            Xom.NtEvent( XEvent.Id.COMMON_CODE_38, e, "XomReportTarget::_HeartBeatThread - Restarting heartbeat logic from unexpected exception");
            goto Restart;
        }

    lDone:
        return;
    }

    string _epCleanserHost;
    int _epCleanserPort;

    Int32 _iConnectResetInterval;    
    Int32 _iHeartBeatInterval;
    Int32 _iKeepAliveInterval;
    Int32 _iQueueSize;
    Int64 _iConnectionIndex;  // need a 64-bit number so we don't roll into negative
    Int32 _iConnectionCount;

    List<Context> _pConnections;
    
    XboxLiveThread _threadHeartBeat;
    string _component;
    int _componentID;

    int _iInitialized;
    int _iShutdown;
    AutoResetEvent _hShutdown;
}

[ComVisible(false)]
public class XomFileTarget : XomLogTarget
{
    public XomFileTarget( string[,] parameters )
    {
        _dtNextRotation = CurrentTime;
        Init( parameters );
    }

    public override void Init( string[,] parameters )
    {
        for( int n = 0; n < parameters.GetLength( 0 ); n++ )
        {
            switch( parameters[ n, 0 ].ToLower() )
            {
            case "type":
                // already know this
                break;

            case "prefix":
                _prefix = parameters[ n, 1 ];
                break;

            case "rotationtime":
                try
                {
                    _iRotationMinutes = Convert.ToInt32( parameters[ n, 1 ] );
                }
                catch( Exception )
                {
                    throw new ArgumentOutOfRangeException(
                        parameters[ n, 0 ], parameters[ n, 1 ], "Error converting paramater to signed int." );
                }
                break;

            case "rotationsize":
                try
                {
                    _iRotationSize = Convert.ToInt32( parameters[ n, 1 ] );
                }
                catch( Exception )
                {
                    throw new ArgumentOutOfRangeException(
                        parameters[ n, 0 ], parameters[ n, 1 ], "Error converting paramater to signed int." );
                }
                break;

            case "flushtime":
                try
                {
                    // get flush time in milliseconds
                    _flushDelay = Convert.ToInt32( parameters[ n, 1 ]);
                }
                catch( Exception )
                {
                    throw new ArgumentOutOfRangeException(
                        parameters[ n, 0 ], parameters[ n, 1 ], "Error converting paramater to unsigned int." );
                }
                break;

            case "emitthreadid":
                _emitThreadId = ParseBool(parameters[n, 0], parameters[n, 1]);
                break;

            case "deleteempty":
                _deleteEmptyLogs = ParseBool(parameters[n, 0], parameters[n, 1]);
                break;

            case "emitflowtoken":
                _emitFlowToken = ParseBool(parameters[n, 0], parameters[n, 1]);
                break;

            default:
                parameters[n,0] = null;
                break;
            }

        }

    }

    public void LazyCreateFile( bool force )
    {
        //
        // Only proceed if a new file is needed
        //
        if( !( force ||
               ( _stream == null ) ||
               ( ( _iRotationMinutes != 0 ) && ( CurrentTime > _dtNextRotation ) ) ||
               ( ( _iRotationSize != 0 ) && ( _iBytesThisFile >= _iRotationSize ) ) ) )
        {
            return;
        }

        StreamWriter curStream = _stream;

        string newName;
        StreamWriter newStream = CreateNewLogFile( out newName );

        lock( _streamLock )
        {
            //
            // Either replace the current stream with the new one (if nothing's changed),
            // or get rid of the new one if we lost the race.
            //
            if( _stream == curStream )
            {
                Close();

                _stream = newStream;
                _streamFilename = newName;

                if(_iRotationMinutes != 0)
                {
                    ScheduleRotation(30);
                }
            }
            else
            {
                newStream.Close();
                newStream = null;

                try
                {
                    File.Delete( newName );
                }
                catch
                {
                }
            }
        }
    }

    protected void ScheduleRotation(int delaySeconds)
    {
        // Calculate next time to rotate the file
        long lRotationInTicks = ((long)_iRotationMinutes) * 60 * 10000000;
        _dtNextRotation = (new DateTime((CurrentTime.Ticks / lRotationInTicks) * lRotationInTicks)).AddMinutes(_iRotationMinutes);

        // This timer rotates files for "sparse" logs, where there isn't a constant stream 
        // of new loglines coming in, thus causing long spans where there isn't a 
        // rotation.
        // Schedule delaySeconds beyond the due time just so we don't run early.
        TimeSpan dueTime = (_dtNextRotation - CurrentTime) + TimeSpan.FromSeconds(delaySeconds);
        TimeSpan period = TimeSpan.FromMinutes(_iRotationMinutes);

        if (_rotationTimer == null)
        {
            _rotationTimer = new Timer(
                new TimerCallback(RotationThread),
                null,
                dueTime,
                period);
        }
        else
        {
            _rotationTimer.Change(dueTime, period);
        }
    }

    private void RotationThread(object param)
    {
        try
        {
            LazyCreateFile(false);
        }
        catch (Exception exc)
        {
            try
            {
                Xom.NtEvent(XEvent.Id.LOGTARGET_CREATE_ERROR, exc, "Log file create failed in rotation timer");
            }
            catch (Exception)
            {
            }
        }
    }

    private StreamWriter CreateNewLogFile( out string filename )
    {
        StreamWriter sw = null;
        Exception    eCreate = null;
        DateTime     now = CurrentTime;

        //
        // Reset the file number every hour
        //
        int iCurHour = now.Hour;
        int iLastHour = _iLastHour;

        if( ( iCurHour != iLastHour ) &&
            ( Interlocked.CompareExchange( ref _iLastHour, iCurHour, iLastHour ) == iLastHour ) )
        {
            Interlocked.Exchange( ref _iFileNum, 0 );
        }

        //
        // Build filename using the prefix, the date and a hour-specific file number.
        //
        filename = "";

        int nNameTry = 0;

        for( int nFileTry = 0; ( sw == null ) && ( nFileTry < 1000 ); nFileTry++ )
        {
            for( ; nNameTry < 10000; nNameTry++ )
            {
                int iFileNum = Interlocked.Increment( ref _iFileNum );

                // _prefix may have time-related tokens. Replace them.
                string newPrefix = _prefix;

                // No padding for these, just plain ToString to maintain compatibility 
                // with what the Cleansers used to do. If we want padded versions, we'll 
                // have to make new tokens.
                newPrefix = newPrefix.Replace("#HOUR#", now.Day.ToString());
                newPrefix = newPrefix.Replace("#DAY#", now.Day.ToString());
                newPrefix = newPrefix.Replace("#MONTH#", now.Month.ToString());
                newPrefix = newPrefix.Replace("#YEAR#", now.Year.ToString());

                filename = newPrefix + now.ToString( "yyyyMMddHH" ) +  iFileNum.ToString( "d4" ) + ".log";

                string dir = Path.GetDirectoryName( filename );
                if( !Directory.Exists( dir ) )
                {
                    Directory.CreateDirectory( dir );
                }

                if( !File.Exists( filename ) )
                {
                    break;
                }
            }

            try
            {
                sw = File.CreateText( filename );
            }
            catch (Exception e)
            {
                sw = null;
                eCreate = e;
            }
        }

        //
        // Never return null from this function. If we failed, throw the first
        // exception we obtained
        //
        if (sw == null && eCreate != null)
        {
            throw eCreate;
        }
        return( sw );
    }

    public override void Log( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte [] msgData, string message, Exception e )
    {
        if (e != null)
        {
            message += "\r\n" + e.ToString();
        }

        //
        // Optionally roll over to new log file
        //
        try
        {
            LazyCreateFile( false );
        } catch (Exception exc)
        {
            Xom.NtEvent(XEvent.Id.LOGTARGET_CREATE_ERROR, exc, "Log file create failed");
            return;
        }

        //
        // Build the date/time line prefix string, count the bytes being written, and write them
        //
        string szDateTime = XDateTime.ToString(CurrentTime) + "|";

        // Add the ubiquitous flow token as param #2
        if (_emitFlowToken)
        {
            szDateTime = szDateTime + msgCtx.FlowToken.ToString() + "|";
        }

        // TODO: optionally log level if appropriate target param is set
        //      level.ToString()
        // @@@ kgoodier Warning: this changes the field # of the datetime & flowtoken.  
        // That's not good.
        //
        if (_emitThreadId)
        {
            szDateTime = Thread.CurrentThread.GetHashCode().ToString("X4") + "|" +  szDateTime;
        }

        //
        // Do the equivalent of the Win32 API InterlockedExchangeAdd to bump up the accumulated
        // file size
        //
        if( _iRotationSize > 0 )
        {
            int iLineBytes = szDateTime.Length + message.Length + 2;

            int iBytesThisFile = _iBytesThisFile;

            while( Interlocked.CompareExchange( ref _iBytesThisFile, iBytesThisFile + iLineBytes, iBytesThisFile ) != iBytesThisFile )
            {
                iBytesThisFile = _iBytesThisFile;
            }
        }

        lock( _streamLock )
        {
            try
            {
                // Make sure each line is prefaced with the same text so that any formatting the caller
                // has done with multiline output will look correct.
                // NOTE: We are ignoring text with \n embedded (i.e. not \r\n) as the file stream will ignore
                // them also.  Callers should always use \r\n as that works for all log targets.
                _stream.WriteLine( szDateTime + message.Replace( "\r\n", "\r\n" + szDateTime ) );
            }
            catch (Exception exc)
            {
                Close();
                Xom.NtEvent( XEvent.Id.COMMON_CONFIG_262, exc, "Log file write failed");
                return;
            }
        }

        //
        // See if we should flush the file contents to disk now, based on the configured interval
        //
        int lastFlushToLog = _lastFlush;
        int nowTicks = GetNowTicks();
        int msSinceLastFlush = nowTicks - lastFlushToLog;

        if ( msSinceLastFlush >= _flushDelay )
        {
            //
            // If we are the ones who bump up the last flush time, we are allowed to flush the file to disk
            //
            if( Interlocked.CompareExchange( ref _lastFlush, nowTicks, lastFlushToLog ) == lastFlushToLog )
            {
                lock( _streamLock )
                {
                    try
                    {
                        _stream.Flush();
                    }
                    catch(Exception exc)
                    {
                      Xom.NtEvent( XEvent.Id.COMMON_CONFIG_263, exc, "Log file flush failed");
                    }
                }
            }
        }

    }

    public override void Close()
    {
        if (_rotationTimer != null)
        {
            _rotationTimer.Dispose();
            _rotationTimer = null;
        }

        if( _stream != null )
        {
            string fileName;
            int fileSize;

            _stream.Close();

            fileSize = _iBytesThisFile;
            fileName = _streamFilename;

            _stream = null;
            _streamFilename = null;
            _iBytesThisFile = 0;

            if (_deleteEmptyLogs && fileSize == 0)
            {
                try
                {
                    // destroy empty files when that option is set
                    File.Delete(fileName);
                }
                catch { }
            }
        }
    }

    public override void Reset()
    {
        //
        // Force roll over to new log file
        //
        LazyCreateFile( true );
    }

    private int GetNowTicks()
    {
        // DateTime.Now is really slow
        // DateTime.UtcNow is slow
        // Environment.TickCount is fast if you can live with a 24.9 day rollover.
        return Environment.TickCount;
    }

    private int         _lastFlush          = 0;
    private int         _flushDelay         = 1000;                     //milliseconds.
    private int         _iRotationSize      = 0;     // Max log file size in bytes before rotating
    private int         _iBytesThisFile     = 0;
    private int         _iRotationMinutes   = 60;     // One hour default rotation time
    private DateTime    _dtNextRotation;
    private Timer       _rotationTimer      = null;
    private string      _prefix             = "C:\\log\\";
    private UTF8Encoding _enc               = new UTF8Encoding();
    private StreamWriter _stream            = null;
    private string       _streamFilename    = null;
    private object      _streamLock         = new object();

    private int         _iFileNum           = 0;
    private int         _iLastHour          = 24;
    private bool        _emitThreadId       = false;
    private bool        _deleteEmptyLogs    = true;
    private bool        _emitFlowToken      = false;
}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\xomlogarea.cs ===
using System;
using System.Runtime.InteropServices;

using xonline.common.config;
using xonline.common.service;

namespace xonline.common.mgmt
{
    [ComVisible(false)]
    public class XomLogLevel
    {
        public const sbyte Muted = -1;
        public const sbyte Off = -1;
        public const sbyte Low = 0;
        public const sbyte On = 0;
        public const sbyte Yes = 0;
        public const sbyte Info = 1;
        public const sbyte Normal = 1;
        public const sbyte High = 2;
        public const sbyte Warning = 2;
        public const sbyte Error = 3;
        public const byte Max = 4;
    }


    [ComVisible(false)]
    public class XomLogArea
    {
        // ResetContextLogging
        // Called at the beggining of a request to reset the context logging flag
        // for the thread.
        public static void ResetContextLogging()
        {
            _threadContextLogStatus = false;
        }

        // SetContextLogging
        // Can be called anywhere to enable/disable context logging for the local
        // thread.
        public static void SetContextLogging(bool fLog)
        {
            _threadContextLogStatus = fLog;
        }

        public static bool GetContextLogging()
        {
            // Context logging is on if there is status is true
            return _threadContextLogStatus;
        }

        public static sbyte GetLevel(string level)
        {
            sbyte n;

            switch(level.ToLower())
            {
                case "-1":
                case "muted":
                case "off":
                case "no":
                    n = -1;
                    break;

                case "0":
                case "low":
                case "on":
                case "yes":
                    n = 0;
                    break;

                case "1":
                case "info":
                case "normal":
                    n = 1;
                    break;

                case "2":
                case "high":
                case "warning":
                    n = 2;
                    break;

                case "3":
                case "error":
                    n = 3;
                    break;

                // Level '4' is added to be consistent with the C++ implementation
                // It's the same thing as the '-1' or muted level
                case "4":
                    n = -1;
                    break;

                default:
                    throw new ArgumentOutOfRangeException("level", level, "Unrecognized value.");
            }

            return n;
        }

        public static bool ParseContextOnlySetting(string sw)
        {
            if (sw == "on" || sw == "true" || sw == "yes" || sw == "1")
            {
                return true;
            }
            else if (sw == "off" || sw == "false" || sw == "no" || sw == "0")
            {
                return false;
            }
            else
            {
                throw new ArgumentOutOfRangeException("Invalid value for ContextOnly area setting");
            }
        }


        //
        // Per-instance initialization
        //
        public XomLogArea( string name, string setting )
        {
            _name = name;
            _setting = setting;
        }

        public void Init( string settings )
        {
            //
            // Create a the parameter list
            //
            string[,] parameters = ConfigUtil.GetParams( settings );
            if ( parameters == null )
            {
                return;
            }

            for ( int n = 0; n < parameters.GetLength( 0 ); n++ )
            {
                switch( parameters[ n, 0 ] )
                {
                case "target":

                    string        targetName = parameters[ n, 1 ];
                    XomLogTarget  target = null;

                    //
                    // Find or build the target
                    //

                    if (!XomLoggingControl.Targets.TryGetValue(targetName, out target))
                    {
                        target = XomLoggingControl.CreateTarget( targetName );
                    }

                    //
                    // Insert the target into the list
                    //

                    if (target != null)
                    {
                        AddTarget( target );
                    }
                    else
                    {
                        throw new Exception(String.Format(
                            "The setting \"{0}\" for XMGMT area \"{1}\" specified an unknown target \"{2}\".",
                            Setting, Name, targetName));
                    }
                    break;

                case "enable":
                    _filterLevel = XomLogArea.GetLevel( parameters[ n, 1 ] );
                    break;

                case "contextonly":
                    _fContextOnly = XomLogArea.ParseContextOnlySetting(parameters[n,1]);
                    break;

                default:
                    throw new ArgumentOutOfRangeException( _name, parameters[ n, 0 ], "Unrecognized setting." );
                }
            }
        }

        //
        // Property accessors
        //
        public string Name
        {
            get { return _name; }
        }

        public string Setting
        {
            get { return _setting; }
        }

        public sbyte FilterLevel
        {
            get { return _filterLevel; }
            set { _filterLevel = value; }
        }

        public XomDictionary<XomLogTarget> Targets
        {
            get { return _logTargets; }
        }

        public bool ContextOnly
        {
            get { return _fContextOnly; }
            set { _fContextOnly = value; }
        }

        public bool Enabled
        {
            get { return FilterLevel > XomLogLevel.Muted && FilterLevel < XomLogLevel.Max && Targets.Count > 0; }
        }

        // RIP CtxLog. 2001 - 2009.
        // CtxLog is dead for managed. Not used, and won't be unless we fix it up. But it 
        // used to be here, if you want to reference it.

        // RIP macro-based logging. 2001 - 2009.

        // Log function used by new macro-free Xom logging.  This function only checks the 
        // areas themselves for the log level, it
        // no longer considers file+line overrides.  It is a combination of the Log() function above, plus the necessary code 
        // from the CanLog() function below.  Once all of the logging has switched to the new system, the Log() functions above
        // can be removed.
        public void Log(XomLogTargetContext msgCtx, sbyte level, ushort msgId, byte[] msgData, Exception e, string formatStr, params object[] args)
        {
            // Don't log if muted, or there are no targets
            if (!Enabled)
            {
                return;
            }

            // Don't log if message is below the area's level
            if(level < _filterLevel) {
                return;
            }

            try {
                _logTargets.ForEach(
                    delegate(XomLogTarget targ)
                    {
                        try {
                            // Format the string to be logged
                            string message = string.Format(formatStr, args);
                            targ.Log(msgCtx, _name, level, msgId, msgData, message, e);
                        }
                        catch {
                            // review: is there something we can do if an exception is caught??
                        }
                    });
            }
            catch {
                // exception thrown while logging?  OH NOES!!
            }
        }

        public void AddTarget(XomLogTarget target)
        {
            _logTargets.Add(target.Name, target);
            target.Startup( );
        }

        public bool RemoveTarget(XomLogTarget target)
        {
            bool ret = _logTargets.Remove(target.Name);
            return ret;
        }

        //
        // Helper methods
        //
        private bool CanLog( sbyte level, int line, string file, ref uint sig )
        {
            bool fCanLog = false;

            if( ( sig & 0xffff0000 ) == XomLoggingControl.LastChangeSignature )
            {
                // Use last CanLog result stored in the signature. That will save us from checking if the area is
                // enabled, has targets and stuff. However, if this area is marked as 'Context Only', we can only log
                // if the thread has the context logging flag on.
                fCanLog = ( 0 != ( sig & 0x0000ffff ) ) && (!_fContextOnly || XomLogArea.GetContextLogging());
            }
            else
            {
                uint uiLastChangeSig;

                do
                {
                    uiLastChangeSig = XomLoggingControl.LastChangeSignature;

                    //
                    // If not special-cased in the override list, the current level of the area
                    // determines if we should log or not.
                    //
                    if( !XomLoggingControl.CheckOverrideList( file, line, ref fCanLog ) )
                    {
                        fCanLog = (_filterLevel != XomLogLevel.Muted) && ( level >= _filterLevel );
                    }

                    //
                    // No matter how it got figured out, we only want to log if there's a destination
                    //
                    fCanLog = fCanLog && ( _logTargets.Count > 0 );

                }
                while( XomLoggingControl.LastChangeSignature != uiLastChangeSig );

                //
                // (Atomically?) update the caller's copy of the signature + flags uint
                //
                uint uiNewSig = uiLastChangeSig | ( fCanLog ? (uint)1 : (uint)0 );


                // Interlocked.Exchange( sig, uiNewSig );
                sig = uiNewSig;
            }

            return fCanLog;
        }

        //
        // Private data members
        //
        private string _name = "";
        private string _setting;
        private sbyte _filterLevel = XomLogLevel.Muted;
        private XomDictionary<XomLogTarget> _logTargets = new XomDictionary<XomLogTarget>();
        private bool _fContextOnly = false;

        // Thread local storage to keep track of thread context log status. We'll
        // use it to determine weather or not a context-only area should log or
        // not.
        [ThreadStaticAttribute]
        private static bool _threadContextLogStatus = false;
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\XomPerformanceCounterLib.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Globalization;
using System.ComponentModel;
using Microsoft.Win32;

// This class is basically a copy of the internal PerformanceCounterLib class. Red Gate's 
// .NET Reflector was used to extract this code. There is a significant performance issue 
// with PerformanceCounterCategory.Create() in that it takes around 2 seconds per 
// category. The code below takes about 400ms per category.  
//
// The call to PerformanceCounterLib.CategoryExists() requires a cache to be built of all 
// performance counters in the system. This is what takes a while. 
//
// However, at the end of PerformanceCounterLib.RegisterCategory(), that cache is 
// destroyed. This presumably happens because you just added a new category, and rather 
// than add it to the existing cache, the developer decided to throw away the cache and 
// let it get rebuilt on the next call to CategoryExists().  
//
// This is what our code bypasses.
//
// The other major differences are:
// * We don't do any security checks
// * We don't check that this is an NT environment
// * We don't grab the global mutex "netfxperf.1.0"
// * And of course, we don't throw away the cache
//
// All we really do is add a few registry entries, build a temporary perf .h file and .ini 
// file, then launch lodctr.exe to import those. This is, believe it or not, what .Net 
// does under the hood. These are well-defined, well-documented files, and in fact this 
// process is exactly what you would have to do for native perf counters. Except you'd 
// have to do it by hand. 
//
// --kgoodier and paulram, July, 2009.

namespace xonline.common.mgmt
{

    public static class XomPerformanceCounterLib
    {
        
        private static bool IsBaseCounter(PerformanceCounterType type)
        {
            if (((type != PerformanceCounterType.AverageBase) &&
              (type != PerformanceCounterType.CounterMultiBase)) &&
              (((int)type != 0x40030403) &&
              (type != PerformanceCounterType.SampleBase)))
            {
                return (type == PerformanceCounterType.SampleBase);
            }
            return true;
        }

        private static void CheckValidCounterLayout(CounterCreationDataCollection counterData)
        {
            Dictionary<String, Object> hashtable = new Dictionary<String, Object>();

            for (int i = 0; i < counterData.Count; i++)
            {
                if ((counterData[i].CounterName == null) || (counterData[i].CounterName.Length == 0))
                {
                    throw new ArgumentException("InvalidCounterName");
                }
                PerformanceCounterType counterType = (PerformanceCounterType)counterData[i].CounterType;
                switch (counterType)
                {
                    case PerformanceCounterType.AverageCount64:
                    case PerformanceCounterType.CounterMultiTimer100Ns:
                    case PerformanceCounterType.CounterMultiTimer100NsInverse:
                    case PerformanceCounterType.CounterMultiTimer:
                    case PerformanceCounterType.CounterMultiTimerInverse:
                    case PerformanceCounterType.RawFraction:
                    case PerformanceCounterType.SampleFraction:
                    case PerformanceCounterType.AverageTimer32:
                        if (counterData.Count <= (i + 1))
                        {
                            throw new InvalidOperationException("CounterLayout");
                        }
                        if (!IsBaseCounter(counterData[i + 1].CounterType))
                        {
                            throw new InvalidOperationException("CounterLayout");
                        }
                        break;

                    default:
                        if (IsBaseCounter(counterType))
                        {
                            if (i == 0)
                            {
                                throw new InvalidOperationException("CounterLayout");
                            }
                            counterType = counterData[i - 1].CounterType;
                            if (((
                                (counterType != PerformanceCounterType.AverageCount64) &&
                                (counterType != PerformanceCounterType.CounterMultiTimer100Ns)) &&
                                ((counterType != PerformanceCounterType.CounterMultiTimer100NsInverse) &&
                                (counterType != PerformanceCounterType.CounterMultiTimer))) &&
                                (((counterType != PerformanceCounterType.CounterMultiTimerInverse) &&
                                (counterType != PerformanceCounterType.RawFraction)) &&
                                ((counterType != PerformanceCounterType.SampleFraction) &&
                                (counterType != PerformanceCounterType.AverageTimer32))))
                            {
                                throw new InvalidOperationException("CounterLayout");
                            }
                        }
                        break;
                }
                if (hashtable.ContainsKey(counterData[i].CounterName))
                {
                    throw new ArgumentException(String.Format("DuplicateCounterName: {0}", counterData[i].CounterName));
                }
                hashtable.Add(counterData[i].CounterName, string.Empty);
                if ((counterData[i].CounterHelp == null) || (counterData[i].CounterHelp.Length == 0))
                {
                    counterData[i].CounterHelp = counterData[i].CounterName;
                }
            }
        }

        private static void CreateRegistryEntry(string categoryName, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection creationData, ref bool iniRegistered)
        {
            RegistryKey key = null;
            RegistryKey key2 = null;
            RegistryKey key3 = null;

            try
            {
                key = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Services", true);
                key2 = key.OpenSubKey(categoryName + @"\Performance", true);
                if (key2 == null)
                {
                    key2 = key.CreateSubKey(categoryName + @"\Performance");
                }
                key2.SetValue("Open", "OpenPerformanceData");
                key2.SetValue("Collect", "CollectPerformanceData");
                key2.SetValue("Close", "ClosePerformanceData");
                key2.SetValue("Library", "netfxperf.dll");
                key2.SetValue("IsMultiInstance", (int)categoryType, RegistryValueKind.DWord);
                key2.SetValue("CategoryOptions", 3, RegistryValueKind.DWord);
                string[] strArray = new string[creationData.Count];
                string[] strArray2 = new string[creationData.Count];
                for (int i = 0; i < creationData.Count; i++)
                {
                    strArray[i] = creationData[i].CounterName;
                    strArray2[i] = ((int)creationData[i].CounterType).ToString(CultureInfo.InvariantCulture);
                }
                key3 = key.OpenSubKey(categoryName + @"\Linkage", true);
                if (key3 == null)
                {
                    key3 = key.CreateSubKey(categoryName + @"\Linkage");
                }
                key3.SetValue("Export", new string[] { categoryName });
                key2.SetValue("Counter Types", strArray2);
                key2.SetValue("Counter Names", strArray);
                if (key2.GetValue("First Counter") != null)
                {
                    iniRegistered = true;
                }
                else
                {
                    iniRegistered = false;
                }
            }
            finally
            {
                if (key2 != null)
                {
                    key2.Close();
                }
                if (key3 != null)
                {
                    key3.Close();
                }
                if (key != null)
                {
                    key.Close();
                }
            }
        }

        private static void CreateIniFile(string IniFilePath, string SymbolFilePath, string categoryName, string categoryHelp, CounterCreationDataCollection creationData, string[] languageIds)
        {
            StreamWriter writer = new StreamWriter(IniFilePath, false, Encoding.Unicode);
            try
            {
                writer.WriteLine("");
                writer.WriteLine("[info]");
                writer.Write("drivername");
                writer.Write("=");
                writer.WriteLine(categoryName);
                writer.Write("symbolfile");
                writer.Write("=");
                writer.WriteLine(Path.GetFileName(SymbolFilePath));
                writer.WriteLine("");
                writer.WriteLine("[languages]");
                foreach (string str in languageIds)
                {
                    writer.Write(str);
                    writer.Write("=");
                    writer.Write("language");
                    writer.WriteLine(str);
                }
                writer.WriteLine("");
                writer.WriteLine("[objects]");
                foreach (string str2 in languageIds)
                {
                    writer.Write("OBJECT_");
                    writer.Write("1_");
                    writer.Write(str2);
                    writer.Write("_NAME");
                    writer.Write("=");
                    writer.WriteLine(categoryName);
                }
                writer.WriteLine("");
                writer.WriteLine("[text]");
                foreach (string str3 in languageIds)
                {
                    writer.Write("OBJECT_");
                    writer.Write("1_");
                    writer.Write(str3);
                    writer.Write("_NAME");
                    writer.Write("=");
                    writer.WriteLine(categoryName);
                    writer.Write("OBJECT_");
                    writer.Write("1_");
                    writer.Write(str3);
                    writer.Write("_HELP");
                    writer.Write("=");
                    if ((categoryHelp == null) || (categoryHelp == string.Empty))
                    {
                        writer.WriteLine("HelpNotAvailable");
                    }
                    else
                    {
                        writer.WriteLine(categoryHelp);
                    }
                    int num = 0;
                    foreach (CounterCreationData data in creationData)
                    {
                        num++;
                        writer.WriteLine("");
                        writer.Write("DEVICE_COUNTER_");
                        writer.Write(num.ToString(CultureInfo.InvariantCulture));
                        writer.Write("_");
                        writer.Write(str3);
                        writer.Write("_NAME");
                        writer.Write("=");
                        writer.WriteLine(data.CounterName);
                        writer.Write("DEVICE_COUNTER_");
                        writer.Write(num.ToString(CultureInfo.InvariantCulture));
                        writer.Write("_");
                        writer.Write(str3);
                        writer.Write("_HELP");
                        writer.Write("=");
                        writer.WriteLine(data.CounterHelp);
                    }
                }
                writer.WriteLine("");
            }
            finally
            {
                writer.Close();
            }
        }

        private static void CreateSymbolFile(String SymbolFilePath, CounterCreationDataCollection creationData)
        {
            StreamWriter writer = new StreamWriter(SymbolFilePath);
            try
            {
                writer.Write("#define");
                writer.Write(" ");
                writer.Write("OBJECT_");
                writer.WriteLine("1 0;");
                for (int i = 1; i <= creationData.Count; i++)
                {
                    writer.Write("#define");
                    writer.Write(" ");
                    writer.Write("DEVICE_COUNTER_");
                    writer.Write(i.ToString(CultureInfo.InvariantCulture));
                    writer.Write(" ");
                    writer.Write((i * 2).ToString(CultureInfo.InvariantCulture));
                    writer.WriteLine(";");
                }
                writer.WriteLine("");
            }
            finally
            {
                writer.Close();
            }
        }

        private static string[] GetLanguageIds()
        {
            RegistryKey key = null;
            string[] subKeyNames = new string[0];

            try
            {
                key = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Perflib");
                if (key != null)
                {
                    subKeyNames = key.GetSubKeyNames();
                }
            }
            finally
            {
                if (key != null)
                {
                    key.Close();
                }
            }
            return subKeyNames;
        }

        private static void RegisterFiles(string arg0, bool unregister)
        {
            ProcessStartInfo startInfo = new ProcessStartInfo();
            startInfo.UseShellExecute = false;
            startInfo.CreateNoWindow = true;
            startInfo.ErrorDialog = false;
            startInfo.WindowStyle = ProcessWindowStyle.Hidden;
            startInfo.WorkingDirectory = Environment.SystemDirectory;
            if (unregister)
            {
                startInfo.FileName = Environment.SystemDirectory + @"\unlodctr.exe";
            }
            else
            {
                startInfo.FileName = Environment.SystemDirectory + @"\lodctr.exe";
            }
            int error = 0;

            startInfo.Arguments = "\"" + arg0 + "\"";
            Process process = Process.Start(startInfo);
            process.WaitForExit();
            error = process.ExitCode;


            if (unregister && (error == 2))
            {
                error = 0;
            }
            if (error != 0)
            {
                throw new Win32Exception(error);
            }
        }

        public static void CreateCategory(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection creationData)
        {
            String tempFileName = Guid.NewGuid().ToString();
            String iniFilePath = Path.Combine(Path.GetTempPath(), tempFileName + ".ini");
            String symbolFilePath = Path.Combine(Path.GetTempPath(), tempFileName + ".h");

            CheckValidCounterLayout(creationData);
            try
            {
                bool iniRegistered = false;
                CreateRegistryEntry(categoryName, categoryType, creationData, ref iniRegistered);
                if (!iniRegistered)
                {
                    string[] languageIds = GetLanguageIds();
                    CreateIniFile(iniFilePath, symbolFilePath, categoryName, categoryHelp, creationData, languageIds);
                    CreateSymbolFile(symbolFilePath, creationData);
                    RegisterFiles(iniFilePath, false);
                }
            }
            finally
            {
                File.Delete(iniFilePath);
                File.Delete(symbolFilePath);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\XomLoggingControl.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

//
// We always have one default area that's used by Xom.NtEvent and Xom.NtDataEvent statements
//
[assembly: XomAreaDefinition(XomAreaName.DefaultNtLog)]

[assembly: XomAreaDefinition(XomAreaName.XomInstrumentation)]

namespace xonline.common.mgmt
{
    [ComVisible(false)]
public class XomLineOverride
{
    public XomLineOverride(
        string szFileName,
        uint uiLineNum,
        bool fLogIt )
    {
        szFile = szFileName;
        uiLine = uiLineNum;
        fCanLog = fLogIt;
    }

    public string szFile;
    public uint uiLine;
    public bool fCanLog;
}

[ComVisible(false)]
public class XomLoggingControl
{
    /// <summary>maximum length of string sent to event log</summary>
    public const int MaxEventLength = ConfigEventLogger.MaxEventLength;

    private static TargetDictionary _targets = new TargetDictionary();
    private static XomDictionary<XomLogArea> _areas = new XomDictionary<XomLogArea>();
    private static int _iLastChangeSignature = 0x10000;
    private static string _overrideAssemblyName;
    private static string _logRoot = null;
    private static string _defaultTargetSettings = null;

    private static ArrayList _overrides;

    private static DateTime _initTime;

    public static TargetDictionary Targets
    {
        get { return _targets; }
    }

    public static XomDictionary<XomLogArea> Areas
    {
        get { return _areas; }
    }

    public static uint LastChangeSignature
    {
        get { return( (uint) _iLastChangeSignature ); }
    }

    public static string OverrideAssemblyName
    {
        get { return _overrideAssemblyName; }
        set { _overrideAssemblyName = value; }
    }

    public static string AssemblyName
    {
        get
        {
            if (_overrideAssemblyName==null)
                return Path.GetFileNameWithoutExtension(Config.AssemblyPath);
            else
                return _overrideAssemblyName;
        }
    }

    public static string LogRoot
    {
        get { return _logRoot; }
    }

    public static string DefaultTargetSettings
    {
        get { return _defaultTargetSettings; }
    }

    public static TimeSpan UpTime
    {
        get { return DateTime.UtcNow - _initTime; }
    }

    public static void RegisterNewChange()
    {
        int iOldSig;

        do
        {
            iOldSig = _iLastChangeSignature;
        }
        while( Interlocked.CompareExchange(
                                ref _iLastChangeSignature,
                                (int)( ( (uint) iOldSig + 0x00010000) & 0xFFFF0000 ),
                                iOldSig ) != iOldSig );
    }

    static XomLoggingControl()
    {
        _overrides = ArrayList.Synchronized( new ArrayList() );
        _initTime = DateTime.UtcNow;
    }

    public static void WriteEarlyEvent(
        XEvent.Id eventId,
        string eventText)
    {
        // since log targets are not yet initialized, try writing directly to the event
        // log. We'll try to use the component name (name of the dll), but if that fails
        // for some reason, we'll use "xmgmt". We will also ensure the source has been
        // created.

        string source = "commonconfig";
        try
        {
            source = Config.ComponentName;
        }
        catch {};

        // Since the code isn't guaranteed to be running as an admin, we can't be nice and
        // create a source. So you're kinda screwed if you want to actually write an
        // event. instead of simply returning, let's try it and let an exception happen if
        // it happens.

        // 1=info, 2=warning, 3=error
        uint level = ((((uint) eventId) >> 30) & 0x3);
        EventLogEntryType entryType =
            level == 1 ? EventLogEntryType.Information :
            level == 2 ? EventLogEntryType.Warning :
            EventLogEntryType.Error;

        int start;
        int len;
        int maxIndex = eventText.Length - 1;

        for( start = 0; start < maxIndex; start += len ) { // event string must be < 32766 characters
            len = Math.Min( eventText.Length - start, MaxEventLength );
            EventLog.WriteEntry(
                source,
                eventText.Substring( start, len ),
                entryType,
                (int) (((uint) eventId) & 0xFFFF));
        }
    }

    private static volatile bool _init = false;
    private static object _initLock = new object();

    public static void Init()
    {
        if (!_init)
        {
            lock (_initLock)
            {
                if (!_init)
                {
                    Init(Config.Assembly);

                    // initialize the Config-related xmgmt commands
                    ConfigXmgmtCmd.Init();
                    _init = true;
                }
            }
        }
    }

    private static void Init(Assembly assembly)
    {
        try
        {
            // Create default targets
            //
            XomLoggingControl.Targets.Add( "debugoutput", "type=debugoutput" );
            XomLoggingControl.Targets.Add( "ntlog", "type=ntlog;source=" + Config.ComponentName);
            XomLoggingControl.Targets.Add( "console", "type=console" );

        }
        catch (Exception e)
        {
            WriteEarlyEvent(
                XEvent.Id.COMMON_CONFIG_256,
                "LoggingControl: An error occurred while constructing default targets: " + e);
            throw;
        }

        // Attempt to cache settings to be loaded:
        Config.TryCacheSettings(Setting.setup_logroot, Setting.xmgmt_default_target_settings);
        try
        {
            _logRoot = Config.GetSetting(Setting.setup_logroot);
        }
        catch (Exception e)
        {
            _logRoot = null;
            WriteEarlyEvent(
                XEvent.Id.COMMON_CONFIG_257,
                "LoggingControl: An error occurred while retrieving the log root setting: " + e);
            throw;
        }

        try
        {
            _defaultTargetSettings = Config.GetSetting(Setting.xmgmt_default_target_settings);
        }
        catch (Exception e)
        {
            _defaultTargetSettings = null;
            WriteEarlyEvent(
                XEvent.Id.COMMON_CONFIG_258,
                "LoggingControl: An error occurred while retrieving target settings: " + e);
            throw;
        }

        try
        {
            //
            // Do the necessary search and replace on the default target settings
            //

            if (_defaultTargetSettings != null)
            {
                //
                // The targetList specification is a concatenation of multiple,
                // comma delimited setting strings, each of which describes a single
                // target.  Each of these specifications may contain one or more
                // replacable string tokens (identified by surrounding '#'
                // characters) which can be computed from the machine name,
                // component name, or config setting
                //

                if ( _logRoot != null )
                {
                    _defaultTargetSettings = _defaultTargetSettings.Replace(
                        "#LOGROOT#",
                        _logRoot
                        );
                }
                if ( Config.ComponentName != null )
                {
                    _defaultTargetSettings = _defaultTargetSettings.Replace(
                        "#COMPONENT#",
                        Config.ComponentName
                        );
                }
                if ( Config.Server != null )
                {
                    _defaultTargetSettings = _defaultTargetSettings.Replace(
                        "#MACHINE#",
                        Config.Server.ToLower()
                        );
                }
            }

            // register the application  assembly, this assembly (XblCore.dll, unless you've XLUSE_'d this feature),  and
            // all of the assemblies that it references
            RegisterAssembly(Assembly.GetExecutingAssembly());

            RegisterAssemblyAndReferences(assembly);

            //
            // Configure the target settings for our built-in area. This area is
            // added when we register the assembly, so we unfortunately can't
            // move these lines up to the top.
            //

            XomLogArea ntLogArea = XomLoggingControl.Areas[XomAreaName.DefaultNtLog];  // will throw if not exist
            ntLogArea.AddTarget(XomLoggingControl.Targets["ntlog"]);
            ntLogArea.AddTarget(XomLoggingControl.Targets["debugoutput"]);
            ntLogArea.FilterLevel = XomLogLevel.Low;

            Config.DefaultInstance.HandleLogEvent += OnConfigLogEvent;

            if ( 2 == XomLoggingControl.Targets.Count )
            {
              Xom.NtEvent( XEvent.Id.COMMON_CONFIG_260, "No new targets found." );
            }

            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(XomLoggingControl.OnControlRequest);

        }
        catch (Exception e)
        {
            WriteEarlyEvent(XEvent.Id.COMMON_CONFIG_261, "XomLoggingControl: An error occurred while retrieving target settings: " + e.ToString());
        }
    }

    private static void OnConfigLogEvent(uint eventId, string message, string componentName)
    {
        // ComponentName is configured as part of the nt event infrastructure, so no need to specify here.
      Xom.NtEvent((XEvent.Id)eventId, message);
    }

    private static List<Assembly> _registeredAssemblies = new List<Assembly>();
    public static void RegisterAssembly(Assembly a)
    {
        // Don't register assembly if it's already been registered
        if( _registeredAssemblies.Contains(a)) {
            return;
        }
        _registeredAssemblies.Add(a);

        // Find all areas defined in this assembly using the XomAreaDefinition attribute
        List<string> xomAreaNames = new List<string>();
        object[] atts = a.GetCustomAttributes(false);
        for(int i = 0; i < atts.Length; i++) {
            XomAreaDefinitionAttribute xaa = atts[i] as XomAreaDefinitionAttribute;
            if(xaa != null) {
                if(xomAreaNames.Contains(xaa.Name) == false) {
                    xomAreaNames.Add(xaa.Name);
                }
            }
        }

        // Build list of area setting names and cache the settings
        List<string> areaSettingNames = new List<string>();
        foreach(string areaName in xomAreaNames) {
            areaSettingNames.Add("xmgmt_area_" + areaName);
        }
        Config.TryCacheSettings(areaSettingNames.ToArray());

        // Register areas found by XomAreaDefinition attribute
        foreach(string areaName in xomAreaNames) {
            string settingVarName = "xmgmt_area_" + areaName;

            // Get the config setting for the area
            Type t = typeof(xonline.common.config.Setting);
            FieldInfo fi = t.GetField(settingVarName);
            if(fi == null) {
                WriteEarlyEvent(XEvent.Id.COMMON_CONFIG_259,
                                string.Format("Failed to register XMGMT area \"{0}\" in assembly {1}. Field '{2}' not found in the xonline.common.config.Setting class.",
                                              areaName, a.FullName, settingVarName));
            } else {
                string settingVal = (string)fi.GetValue(null);

                // Create an area and register it
                XomLogArea area = new XomLogArea(areaName, settingVal);
                XomLoggingControl.RegisterArea(area);
            }
        }
    }

    public static void RegisterAssemblyAndReferences(Assembly a)
    {
        RegisterAssembly(a);

        foreach (AssemblyName assemblyName in a.GetReferencedAssemblies())
        {
            try
            {
                RegisterAssembly(Assembly.Load(assemblyName));
            }
            catch (Exception e)
            {
                WriteEarlyEvent(XEvent.Id.XMGMT_FAILED_TO_REGISTER_ASSEMBLY, String.Format(
                    "XomLoggingControl: An error occurred while registering assembly {0} referenced " +
                    "by assembly {1}. This is likely not fatal. Exception: {2}",
                    assemblyName,
                    a,
                    e.Message));
            }
        }
    }

    public static void RegisterArea( XomLogArea theArea )
    {
        theArea.Init( Config.GetSetting( theArea.Setting ) );

        XomLoggingControl.Areas[ theArea.Name ] = theArea;
    }

    public static bool RegisterNewArea( string areaName, string areaSettings )
    {
        // Already exists? We won't do anything.

        XomLogArea area;
        if (XomLoggingControl.Areas.TryGetValue(areaName, out area))
        {
            return false;
        }

        // No NPDB setting name
        area = new XomLogArea(areaName, null);

        // But we have the settings passed into us
        area.Init(areaSettings);

        // Will throw if it already exists, for the rare race condition. But that's ok.
        XomLoggingControl.Areas.Add(area.Name, area);

        return true;
    }

    public static XomLogTarget CreateTarget( string theTarget )
    {
        string       targetSettings = null;
        XomLogTarget target = null;

        try
        {
            targetSettings = Config.GetSetting( "xmgmt_target_" + theTarget );
            if ( targetSettings != null )
            {
                //
                // The targetList specification is a concatenation of multiple,
                // comma delimited setting strings, each of which describes a
                // single target.  Each of these specifications may contain one
                // or more replacable string tokens (identified by surrounding
                // '#' characters) which can be computed from the machine name,
                // component name, or config setting
                //

                if ( LogRoot != null )
                {
                    targetSettings = targetSettings.Replace(
                        "#LOGROOT#",
                        LogRoot
                        );
                }
                if ( Config.ComponentName != null )
                {
                    targetSettings = targetSettings.Replace(
                        "#COMPONENT#",
                        Config.ComponentName
                        );
                }

                if ( Config.Server != null )
                {
                    targetSettings = targetSettings.Replace(
                        "#MACHINE#",
                        Config.Server.ToLower()
                        );
                }

                // Debug.WriteLine("XMGMT: calling XomLoggingControl.Targets.Add(\"" + theTarget + "\", \"" + targetSettings + "\")...");
                try
                {
                    target = XomLoggingControl.Targets.Add(
                        theTarget,
                        targetSettings,
                        DefaultTargetSettings
                        );
                }
                catch (Exception e)
                {
                    WriteEarlyEvent(
                        XEvent.Id.COMMON_CONFIG_259,
                        String.Format("Failed to add target {0}, params {1}. Exception: {2}\r\n",
                            theTarget,
                            targetSettings,
                            e.Message
                                      )
                        );
                }
            }
        }
        catch (Exception e)
        {
            WriteEarlyEvent(XEvent.Id.COMMON_CONFIG_261, "XomLoggingControl: An error occurred while creating a target: " + e.ToString());
        }
        return target;
    }

    public static void OnControlRequest(object sender, ControlRequestEventArgs args)
    {
        try
        {
            switch (args.Command)
            {
            case "h":
            case "help":
                ProcessHelpRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "gv":
            case "getversion":
                ProcessGetVersionRequest(args);
                args.Handled = true;
                break;

            case "la":
            case "listareas":
                ProcessListAreasRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "lt":
            case "listtargets":
                ProcessListTargetsRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "cal":
            case "changearealevel":
                ProcessChangeAreaLevelRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "nt":
            case "newtarget":
                ProcessNewTargetRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "dt":
            case "deletetarget":
                ProcessDeleteTargetRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "at":
            case "addtarget":
                ProcessAddTargetRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "rt":
            case "removetarget":
                ProcessRemoveTargetRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "rst":
            case "resettarget":
                ProcessResetTargetRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "lo":
            case "listoverrides":
                ProcessListOverridesRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "so":
            case "setoverride":
                ProcessSetOverrideRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "ro":
            case "removeoverride":
                ProcessRemoveOverrideRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "sco":
            case "setcontextonly":
                ProcessSetContextOnlyRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "ut":
            case "uptime":
                ProcessUpTimeRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "na":
            case "newarea":
                ProcessNewAreaRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "da":
            case "deletearea":
                ProcessDeleteAreaRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;

            case "adminsessiondied":
                ProcessAdminSessionDiedRequest(args.CommandArgs, args.RequestId);
                args.Handled = true;
                break;
            }
        }
        catch(Exception e)
        {
            XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
        }

    }

    public static void ProcessHelpRequest(string[] args, uint requestId)
    {
        // Note: NewArea and DeleteArea are not shown because no one should ever need to
        // run them. They are really only useful for testing.

        XomControlConnection.SendMessage(
            "Logging and tracing help:\r\n" +
            "  GetVersion\r\n" +
            "  UpTime\r\n" +
            "  ListAreas\r\n" +
            "  ListTargets\r\n" +
            //"  NewArea <area name> <settings>\r\n" +
            //"  DeleteArea <area name>\r\n" +
            "  ChangeAreaLevel <area name> <level = 0,1,2,3,4>\r\n" +
            "  NewTarget <target name> <target parameters>\r\n" +
            "    where <target parameters> can be:\r\n" +
            "       type=File;prefix=<filename prefix>;RotationTime=<time in minutes>;RotationSize=<size in bytes>\r\n" +
            "       type=Remote;address=<ip or hostname of rtrace terminal>\r\n" +
            "  DeleteTarget <target name>\r\n" +
            "  AddTarget <target name> <area name>\r\n" +
            "  RemoveTarget <target name> <area name>\r\n" +
            "  ResetTarget <target name>\r\n" +
            "  ListOverrides\r\n" +
            "  SetOverride <filename> <line> <log 0=no, 1=yes>\r\n" +
            "  RemoveOverride <override index>\r\n" +
            "  SetContextOnly <area name> <yes/no>\r\n\r\n", requestId);
    }

    public static void ProcessGetVersionRequest(ControlRequestEventArgs args)
    {
        try
        {
            Module mod = Config.Assembly.GetModules()[0];
            FileVersionInfo version = FileVersionInfo.GetVersionInfo(mod.FullyQualifiedName);
            XomControlConnection.SendMessage(version.FileVersion, args.RequestId);
        }
        catch(Exception)
        {
            args.hr = HResult.E_FAIL;
        }
    }

    public static void ProcessListAreasRequest(string[] args, uint requestId)
    {
        string areaFilter = args.Length > 0 ? args[0].ToLower() : null;

        StringBuilder strB = new StringBuilder();

        // It's nice when the areas are in sorted order, so we'll incur the more expensive
        // hit since this is a rare operation.
        XomLoggingControl.Areas.SortedForEach(
            delegate(XomLogArea area) {
                string areaName = area.Name.ToLower();
                if ( areaFilter == null || areaName.StartsWith(areaFilter, StringComparison.InvariantCultureIgnoreCase) )
                {
                    strB.Append("Area: ");
                    strB.Append(areaName.PadRight(22));
                    strB.Append(" Lvl: ");
                    strB.Append(area.FilterLevel.ToString().PadLeft(2));
                    strB.Append(" Targets: ");

                    area.Targets.ForEach(
                        delegate(XomLogTarget target)
                        {
                            strB.Append(target.Name);
                            strB.Append(" ");
                        });

                    if (area.ContextOnly)
                    {
                        strB.Append(" ContextOnly=Yes");
                    }

                    strB.Append("\r\n");
                }
            }
        );

        strB.Append("\r\n\r\n");
        XomControlConnection.SendMessage(strB.ToString(), requestId);
    }

    public static void ProcessListTargetsRequest(string[] args, uint requestId)
    {
        StringBuilder strB = new StringBuilder();

        XomLoggingControl.Targets.ForEach(
            delegate(XomLogTarget target)
            {
                strB.Append("Target: ");
                strB.Append(target.Name.PadRight(20));
                strB.Append(" Params: ");
                strB.Append(target.Params);
                strB.Append("\r\n");
            });

        strB.Append("\r\n\r\n");
        XomControlConnection.SendMessage(strB.ToString(), requestId);
    }

    public static void ProcessChangeAreaLevelRequest(string[] args, uint requestId)
    {
        XomLogArea area;
        sbyte oldLvl;

        if (args.Length != 2)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }

        area = Areas[args[0]];
        if (area == null)
        {
            XomControlConnection.SendMessage("Error: Area '" + args[0] + "' not found.", requestId);
            return;
        }

        oldLvl = area.FilterLevel;
        area.FilterLevel = XomLogArea.GetLevel(args[1]);

        RegisterNewChange();

        XomControlConnection.SendMessage("Changed filter level of area '" + args[0] + "' from " + oldLvl + " to " + area.FilterLevel + "\r\n\r\n" , requestId);
    }


    public static void ProcessNewTargetRequest(string[] args, uint requestId)
    {
        if (args.Length != 2)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }
        XomLogTarget target = Targets[args[0]];

        if (target != null)
        {
            XomControlConnection.SendMessage("Target " + args[0] + " already exists, cannot replace.\r\n\r\n" , requestId);
        }
        else
        {
            Targets.Add(args[0], args[1], requestId);

            RegisterNewChange();

            XomControlConnection.SendMessage("Added target " + args[0] + "\r\n\r\n" , requestId);
        }
    }

    public static void ProcessDeleteTargetRequest(string[] args, uint requestId)
    {
        StringBuilder strB = new StringBuilder();
        bool found = false;

        //
        // remove from areas
        //
        XomLogTarget target = Targets[args[0]];

        if (target != null)
        {
            XomLoggingControl.Areas.ForEach(
                delegate(XomLogArea area)
                {
                    if (area.RemoveTarget(target))
                    {
                        strB.Append("Removed " + args[0] + " from " + area.Name + "\r\n");
                        found = true;
                    }
                }
            );

            if (Targets.Remove(target.Name))
            {
                strB.Append("Removed " + args[0] + " from targets list\r\n\r\n");
                found = true;
            }
        }

        if ( !found )
        {
            XomControlConnection.SendMessage("Error: Target '" + args[0] + "' not found!\r\n\r\n" , requestId);
        }
        else
        {
            RegisterNewChange();

            XomControlConnection.SendMessage(strB.ToString() , requestId);
        }
    }

    public static void ProcessAddTargetRequest(string[] args, uint requestId)
    {
        XomLogTarget target;
        XomLogArea area;

        if (args.Length != 2)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }

        area = Areas[args[1]];
        if (area == null)
        {
            XomControlConnection.SendMessage("Error: Area '" + args[1] + "' not found!\r\n\r\n" , requestId);
            return;
        }

        target = Targets[args[0]];
        if (target == null)
        {
            XomControlConnection.SendMessage("Error: Target '" + args[0] + "' not found!\r\n\r\n" , requestId);
            return;
        }

        area.AddTarget(target);

        RegisterNewChange();

        XomControlConnection.SendMessage("Target '" + args[0] + "' assigned to area '" + args[1] + "'\r\n\r\n" , requestId);
    }

    public static void ProcessRemoveTargetRequest(string[] args, uint requestId)
    {
        XomLogTarget target;
        XomLogArea area;

        if (args.Length != 2)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }

        if (!XomLoggingControl.Areas.TryGetValue(args[1], out area))
        {
            XomControlConnection.SendMessage("Error: Area '" + args[1] + "' not found!\r\n\r\n" , requestId);
            return;
        }

        target = Targets[args[0]];
        if (target == null)
        {
            XomControlConnection.SendMessage("Error: Target '" + args[0] + "' not found!\r\n\r\n" , requestId);
            return;
        }

        area.RemoveTarget(target);

        RegisterNewChange();

        XomControlConnection.SendMessage("Target '" + args[0] + "' removed from area '" + args[1] + "'\r\n\r\n" , requestId);
    }

    public static void ProcessResetTargetRequest(string[] args, uint requestId)
    {
        XomLogTarget target = Targets[args[0]];

        if( target == null )
        {
            XomControlConnection.SendMessage("Error: Target '" + args[0] + "' not found!\r\n\r\n" , requestId);
            return;
        }

        target.Reset();

        RegisterNewChange();

        XomControlConnection.SendMessage("Target '" + args[0] + "' has been reset.\r\n\r\n" , requestId);
    }

    public static void ProcessListOverridesRequest( string[] args, uint requestId )
    {
        StringBuilder strB = new StringBuilder();

        IEnumerator overEnum = _overrides.GetEnumerator();
        int iOverride = 0;

        while( overEnum.MoveNext() )
        {
            XomLineOverride lo = (XomLineOverride) overEnum.Current;

            // "%d: F:%s L:%d On:%d\r\n"
            strB.Append( iOverride );
            strB.Append( ": F:" );
            strB.Append( lo.szFile );
            strB.Append( " L:" );
            strB.Append( lo.uiLine );
            strB.Append( " On:" );
            strB.Append( lo.fCanLog ? "1\r\n" : "0\r\n" );

            iOverride++;
        }

        if( 0 == iOverride )
        {
            strB.Append( "No overrides currently active\r\n" );
        }

        XomControlConnection.SendMessage( strB.ToString(), requestId );
    }

    public static void ProcessSetOverrideRequest( string[] args, uint requestId )
    {
        //
        // Find out what the caller wants to override
        //
        if( args.Length != 3 )
        {
            ProcessHelpRequest( args, requestId );
            return;
        }

        string szFile = args[ 0 ].ToLower();
        uint uiLine = Convert.ToUInt32( args[ 1 ] );
        bool fCanLog = true;

        try
        {
            fCanLog = Convert.ToBoolean( args[ 2 ] );
        }
        catch
        {
            fCanLog = ( Convert.ToInt32( args[ 2 ] ) != 0 );
        }

        //
        // See if this override already exists
        //
        XomLineOverride lo = null;
        IEnumerator overEnum = _overrides.GetEnumerator();
        int iOverride = 0;

        while( overEnum.MoveNext() )
        {
            lo = (XomLineOverride) overEnum.Current;

            if( ( lo.uiLine == uiLine ) && ( lo.szFile == szFile ) )
            {
                break;
            }

            lo = null;
            iOverride++;
        }

        if( lo != null )
        {
            lo.fCanLog = fCanLog;
        }
        else
        {
            lo = new XomLineOverride( szFile, uiLine, fCanLog );

            iOverride = _overrides.Add( lo );
        }

        RegisterNewChange();

        XomControlConnection.SendMessage(
                                "Override #" + iOverride + " added/altered\r\n",
                                requestId );
    }

    public static void ProcessRemoveOverrideRequest( string[] args, uint requestId )
    {
        if( args.Length != 1 )
        {
            ProcessHelpRequest( args, requestId );
            return;
        }

        int iIndex = Convert.ToInt32( args[ 0 ] );

        try
        {
            _overrides.RemoveAt( iIndex );
        }
        catch
        {
            XomControlConnection.SendMessage( "Override remove of index " + iIndex + " failed\r\n", requestId );
            return;
        }

        RegisterNewChange();

        XomControlConnection.SendMessage( "Override " + iIndex + " removed\r\n", requestId );
    }

    public static void ProcessSetContextOnlyRequest(string[] args, uint requestId)
    {
        if (args.Length != 2)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }

        XomLogArea area;
        if (!XomLoggingControl.Areas.TryGetValue(args[1], out area))
        {
            XomControlConnection.SendMessage("Error: Area '" + args[0] + "' not found.", requestId);
            return;
        }

        area.ContextOnly = XomLogArea.ParseContextOnlySetting(args[1]);

        RegisterNewChange();

        XomControlConnection.SendMessage("Area context only setting updated." , requestId);
    }

    private static void ProcessUpTimeRequest(string[] args, uint requestId)
    {
        if (args.Length != 0)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }

        XomControlConnection.SendMessage(UpTime.ToString() , requestId);
    }

    private static void ProcessNewAreaRequest(string[] args, uint requestId)
    {
        if (args.Length < 1 || args.Length > 2)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }

        bool fOk = RegisterNewArea(args[0], args.Length > 1 ? args[1] : null);

        RegisterNewChange();

        XomControlConnection.SendMessage("Area \"" + args[0] + "\" " + (string)((fOk) ? "" : "not ") + "created.", requestId);
    }
    private static void ProcessDeleteAreaRequest(string[] args, uint requestId)
    {
        if (args.Length != 1)
        {
            ProcessHelpRequest(args, requestId);
            return;
        }

        XomLoggingControl.Areas.Remove(args[0]);

        RegisterNewChange();

        XomControlConnection.SendMessage("Area \"" + args[0] + "\" removed.", requestId);
    }

    public static void ProcessAdminSessionDiedRequest(string[] args, uint requestId)
    {
        List<XomLogTarget> targets = new List<XomLogTarget>();

        XomLoggingControl.Targets.ForEach(
            delegate(XomLogTarget target)
            {
                if (target.Session == requestId)
                {
                    targets.Add(target);
                }
            });

        // If there is nothing to remove, cut out early.
        if (targets.Count == 0)
        {
            return;
        }

        foreach (XomLogTarget target in targets)
        {
            //
            // remove from areas
            //

            XomLoggingControl.Areas.ForEach(
                delegate(XomLogArea area)
                {
                    area.RemoveTarget(target);
                }
            );

            Targets.Remove(target.Name);
        }

        RegisterNewChange();
    }

    public static void Close()
    {
        XomLoggingControl.Targets.ForEach(
            delegate(XomLogTarget target)
            {
                target.Close();
            });

        XomControl.ControlRequestEvent -= new XomControl.ControlRequestEventHandler(XomLoggingControl.OnControlRequest);
    }

    public static bool CheckOverrideList( string szFile, int iLine, ref bool fCanLog )
    {
        //
        // See if this override already exists
        //
        XomLineOverride lo = null;
        IEnumerator overEnum = _overrides.GetEnumerator();

        bool fRet = false;
        int cchFile = 0;

        while( overEnum.MoveNext() )
        {
            lo = (XomLineOverride) overEnum.Current;

            if( lo.uiLine == iLine )
            {
                int cchPattern = lo.szFile.Length;

                if( 0 == cchFile )
                {
                    cchFile = szFile.Length;
                }

                if( ( cchFile >= cchPattern ) &&
                    ( szFile.Substring( cchFile - cchPattern ) == lo.szFile ) )
                {
                    fCanLog = lo.fCanLog;
                    fRet = true;
                    break;
                }
            }
        }

        return( fRet );
    }
}

//------------------------------------------------------------------------
// New public entrypoints for all Xom logging/tracing/eventing
//------------------------------------------------------------------------
public static class Xom
{
    //
    // XomTrace
    //

    public static void Trace(string areaName, XomLogTargetContext msgCtx, LogLevel level, string msgFormat, params object[] args)
    {
        // Lookup the area by name
        XomLogArea area = GetAreaByName(areaName);
        if(area == null) {
            return;
        }

        area.Log(msgCtx, (sbyte)level, 0, null, null, msgFormat, args);
    }

    public static void Trace(string areaName, LogLevel level, string msgFormat, params object[] args)
    {
        //Instrument(XomAreaName.DefaultNtLog);
        Trace(areaName, new XomLogTargetContext(Floken.Current), level, msgFormat, args);
    }

    //
    // XomLog
    //

    public static void Log(string areaName, XomLogTargetContext msgCtx, Exception e, string msgFormat, params object[] args)
    {
        // Lookup the area by name
        XomLogArea area = GetAreaByName(areaName);
        if(area == null) {
            return;
        }

        area.Log(msgCtx, (sbyte)LogLevel.L_NORMAL, 0, null, e, msgFormat, args);
    }

    public static void Log(string areaName, XomLogTargetContext msgCtx, string msgFormat, params object[] args)
    {
        Log(areaName, msgCtx, null, msgFormat, args);
    }

    public static void Log(string areaName, string msgFormat, params object[] args)
    {
        Instrument(areaName);
        Log(areaName, new XomLogTargetContext(Floken.Current), null, msgFormat, args);
    }

    public static void Log(string areaName, Exception ex, string msgFormat, params object[] args)
    {
        Instrument(areaName);
        Log(areaName, new XomLogTargetContext(Floken.Current), ex, msgFormat, args);
    }

    //
    // XomNtEvent
    //

    // Replacements for XomNtDataEvent
    public static void NtDataEvent(XEvent.Id eventId, XomLogTargetContext msgCtx, byte[] msgData, string msgFormat, params object[] args)
    {
        NtDataEvent(eventId, msgCtx, null, msgData, msgFormat, args);
    }
    public static void NtDataEvent(XEvent.Id eventId, XomLogTargetContext msgCtx, Exception ex, byte[] msgData, string msgFormat, params object[] args)
    {
        // Get the DefaultNtLog area
        XomLogArea area = GetAreaByName(XomAreaName.DefaultNtLog);
        if(area == null) {
            return;
        }

        // Pull the level out of the EventID
        sbyte level = (sbyte)((((uint)XEvent.SeverityFromId(eventId)) >> 30) & 0x3);

        // Log to the area
        area.Log(msgCtx, level, XEvent.MessageFromId(eventId), msgData, ex, msgFormat, args);
    }

    // Replacements for XomNtEvent
    public static void NtEvent(XEvent.Id eventId, XomLogTargetContext msgCtx, string msgFormat, params object[] args)
    {
        NtDataEvent(eventId, msgCtx, null, msgFormat, args);
    }
    public static void NtEvent(XEvent.Id eventId, XomLogTargetContext msgCtx, Exception ex, string msgFormat, params object[] args)
    {
        NtDataEvent(eventId, msgCtx, ex, null, msgFormat, args);
    }

    // Replacements for XomNtDataDynEvent
    public static void NtDataDynEvent(XEvent.Id eventId, XomLogTargetContext msgCtx, byte[] msgData, string msgFormat, params object[] args)
    {
        NtDataEvent(eventId, msgCtx, null, msgData, "Dynamic Event: " + msgFormat, args);
    }
    public static void NtDataDynEvent(XEvent.Id eventId, XomLogTargetContext msgCtx, Exception ex, byte[] msgData, string msgFormat, params object[] args)
    {
        NtDataEvent(eventId, msgCtx, ex, msgData, "Dynamic Event: " + msgFormat, args);
    }

    //
    // Non-flowtoken-providing overrides for events.
    //

    // Replacements for XomNtDataEvent
    public static void NtDataEvent(XEvent.Id eventId, byte[] msgData, string msgFormat, params object[] args)
    {
        Instrument(XomAreaName.DefaultNtLog);
        NtDataEvent(eventId, new XomLogTargetContext(Floken.Current), null, msgData, msgFormat, args);
    }
    public static void NtDataEvent(XEvent.Id eventId, Exception ex, byte[] msgData, string msgFormat, params object[] args)
    {
        Instrument(XomAreaName.DefaultNtLog);
        NtDataEvent(eventId, new XomLogTargetContext(Floken.Current), ex, msgData, msgFormat, args);
    }

    // Replacements for XomNtEvent
    public static void NtEvent(XEvent.Id eventId, string msgFormat, params object[] args)
    {
        Instrument(XomAreaName.DefaultNtLog);
        NtDataEvent(eventId, new XomLogTargetContext(Floken.Current), null, msgFormat, args);
    }
    public static void NtEvent(XEvent.Id eventId, Exception ex, string msgFormat, params object[] args)
    {
        Instrument(XomAreaName.DefaultNtLog);
        NtDataEvent(eventId, new XomLogTargetContext(Floken.Current), ex, null, msgFormat, args);
    }

    // Replacements for XomNtDataDynEvent
    public static void NtDataDynEvent(XEvent.Id eventId, byte[] msgData, string msgFormat, params object[] args)
    {
        Instrument(XomAreaName.DefaultNtLog);
        NtDataEvent(eventId, new XomLogTargetContext(Floken.Current), null, msgData, "Dynamic Event: " + msgFormat, args);
    }
    public static void NtDataDynEvent(XEvent.Id eventId, Exception ex, byte[] msgData, string msgFormat, params object[] args)
    {
        Instrument(XomAreaName.DefaultNtLog);
        NtDataEvent(eventId, new XomLogTargetContext(Floken.Current), ex, msgData, "Dynamic Event: " + msgFormat, args);
    }

    public static XomLogArea GetAreaByName(string areaName)
    {
        XomLogArea area;
        if (!XomLoggingControl.Areas.TryGetValue(areaName, out area))
        {
            return null;
        }
        return area;
    }

    private static class Throttler
    {
        private class ThrottleInfo
        {
            public long Count;
            public DateTime LastReportTime;
        }

        private static Dictionary<string, ThrottleInfo> _ThrottledMessages = new Dictionary<string, ThrottleInfo>();
        private static object _ThrottledMessagesLock = new object();

        internal static bool ShouldSquelch(string key, out long count, int secondsToSquelch, bool resetCount)
        {
            count = 0;
            try
            {
                ThrottleInfo info;

                // Minimize lock time
                lock (_ThrottledMessagesLock)
                {
                    if (!_ThrottledMessages.TryGetValue(key, out info))
                    {
                        info = new ThrottleInfo();
                        info.Count = 0;
                        info.LastReportTime = DateTime.MinValue;
                        _ThrottledMessages[key] = info;
                    }
                }

                // Tick
                count = Interlocked.Increment(ref info.Count);
                TimeSpan elapsedTime = DateTime.Now - info.LastReportTime;

                // Time to report?
                if (elapsedTime.TotalSeconds >= secondsToSquelch)
                {
                    info.LastReportTime = DateTime.Now;
                    if (resetCount)
                    {
                        info.Count = 0;
                    }

                    // false = don't throttle
                    return false;
                }

                // true = throttle
                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

    }

    [ThreadStatic]
    private static int _InstrumentCount = 0;

    private static void Instrument(string areaName)
    {
        try
        {
            if (++_InstrumentCount > 1)
            {
                // recursion FAIL!
                return;
            }

            // Write to our special area
            XomLogArea area = GetAreaByName(XomAreaName.XomInstrumentation);
            if (area == null) {
                return;
            }

            // No targets = feature shut off (as much as possible)
            if (area.Targets.Count <= 0)
            {
                return;
            }

            // Is SgInfo available?
            // Bail out for mainline cases
            string sgInfoState;
            if (AAInfo.IsCached)
            {
                sgInfoState = "aacache";
                //return;
            }
            else if (AAInfo.IsActiveAuthAvailable)
            {
                sgInfoState = "aaget";
            }
            else if (SGInfo.IsCached)
            {
                sgInfoState = "cache";
                //return;
            }
            else if (SGInfo.IsAvailable)
            {
                sgInfoState = "get";
            }
            else
            {
                sgInfoState = "none";
                //return;
            }

            // Get file and line number of the original Xom.Log / Xom.NtEvent call
            string srcFile;
            ushort srcLine;
            EventBuilder.GetStackSrc(new StackTrace(true), out srcFile, out srcLine);
            int pos = srcFile.IndexOf("\\private\\");
            if (pos > 0)
            {
                srcFile = srcFile.Substring(pos);
            }

            // Throttle messages...
            string key = srcFile + ":" + srcLine + ":" + sgInfoState;
            long count;

            // once per hour
            if (!Throttler.ShouldSquelch(key, out count, 3600, false))
            {
                // Log it
                area.Log(XomLogTargetContext.Empty, (sbyte)LogLevel.L_NORMAL, 0, null, null,
                         "SGINFOSTATE|{0}|{1}|{2}:{3}|{4}",
                         sgInfoState, areaName, srcFile, srcLine, count);
            }
        }
        catch (Exception)
        {
        }
        finally
        {
            _InstrumentCount--;
        }
    }
}

//------------------------------------------------------------------------
// Log level enumeration (matches levels used by old macros)
//------------------------------------------------------------------------
public enum LogLevel : sbyte {
    L_ON      = 0, L_LOW    = 0,
    L_INFO    = 1, L_NORMAL = 1,
    L_WARNING = 2, L_HIGH   = 2,
    L_ERROR   = 3,
    L_MUTED   = 4, L_OFF    = 4,
};

//------------------------------------------------------------------------
// Attrubite used to tag an assembly that defines a log area
//------------------------------------------------------------------------
[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
public class XomAreaDefinitionAttribute : Attribute
{
    public XomAreaDefinitionAttribute(string areaName)
    {
        this.Name = areaName;
    }

    public readonly string Name;
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\xomperfctrs.cs ===
/*
NT Performance Counters

Declare your own class following like in the example:

    [XomPerformanceCounterCategoryAttr(
        "TestApp Counters", 
        "The counters for your nice test app",
        true  //If this is a Shared PerfCategory installed by more than one component
    )]
    public class TestAppCounters : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
            "Operations per second", 
            "Number of operations executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RatingsPerSecond;

        static public TestAppCounters Counters = new TestAppCounters();
    }

Then access the PerformanceCounter fields directly. E.g.:

    TestAppCounters.Counters.RatingsPerSecond.Increment();

For more information look for 'PerformanceCounter class' on MSDN. 

One more thing, if you're using counters then you will first have to install 
your assembly using InstallUtil.exe which is located in the .NET framework
directory: %WINDIR%\Microsoft.NET\Framework\vXXXX\InstallUtil.exe.

*/

using System;
using System.Collections;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Threading;
using System.Web;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.service;

namespace xonline.common.mgmt
{
    // Useful little class to use with AverageTimer counters. Just instantiate
    // one at the begining of the request and increment the counter at the end
    // of the request using the TimeElapsed field.

    [ComVisible(false)]
    public class XomRequestTimeElapsed
    {
        // Static constructor.  Gets the system timer frequency.
        
        static XomRequestTimeElapsed()
        {
            QueryPerformanceFrequency(ref _freq); 
            
            _msFreq = _freq / 1000;
        }
        
        // Constructor. Gets the current time for reference.                

        public XomRequestTimeElapsed()
        {
            QueryPerformanceCounter(ref _started);
        }

        // Returns the time elapsed since the object was constructed.

        public long TimeElapsed 
        {
            get
            {
                long now = 0;
                QueryPerformanceCounter(ref now);

                return now - _started;
            }
        }
        
        public long SecondsElapsed
        {
            get
            {
                long now = 0;
                QueryPerformanceCounter(ref now);                

                return ((now - _started) / _freq);                
            }
        }
        
        public long MillisecondsElapsed
        {
            get
            {
                long now = 0;
                QueryPerformanceCounter(ref now);                

                return (long)((now - _started) / _msFreq); 
            }
        }

        // Win32 imports

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [DllImport("KERNEL32"), System.Security.SuppressUnmanagedCodeSecurityAttribute()]
        protected static extern int QueryPerformanceCounter(ref long time);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [DllImport("KERNEL32"), System.Security.SuppressUnmanagedCodeSecurityAttribute()]
        protected static extern int QueryPerformanceFrequency(ref long freq);

        private long _started;
            // Time when object was instantiated.
            
        private static long _freq;
            // Nonchanging frequency of the high resolution system counter.    
            
        private static float _msFreq;
            // pre-calculated float divisor
    }

    // Performance Counter category attribute class used to define the name and 
    // the help text for that category.

    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Class)]
    public class XomPerformanceCounterCategoryAttr : System.Attribute
    {
        public XomPerformanceCounterCategoryAttr(string ctgName, string ctgHelp)
            : this(ctgName, ctgHelp, PerformanceCounterInstanceLifetime.Global , false)
        {
            // "Global" instance lifetime is the .Net default. The instances will be 
            // around forever, especially since this class doesn't support deleting 
            // instances (yet).  Your other choice is "Process", which means when the 
            // process dies, the instances go away.
        }

        public XomPerformanceCounterCategoryAttr(string ctgName, string ctgHelp, bool isCommon)
            : this(ctgName, ctgHelp, PerformanceCounterInstanceLifetime.Global , isCommon)
        {
            // "Global" instance lifetime is the .Net default. The instances will be 
            // around forever, especially since this class doesn't support deleting 
            // instances (yet).  Your other choice is "Process", which means when the 
            // process dies, the instances go away.
        }

        public XomPerformanceCounterCategoryAttr(string ctgName, string ctgHelp, PerformanceCounterInstanceLifetime ctrInstanceLifetime)
        : this (ctgName , ctgHelp, ctrInstanceLifetime, false)
        {
        }

        public XomPerformanceCounterCategoryAttr(string ctgName, string ctgHelp, PerformanceCounterInstanceLifetime ctrInstanceLifetime , bool isCommon)
        {
            _isShared = isCommon;
            _ctgName = ctgName;
            _ctgHelp = ctgHelp;
            _ctrInstanceLifetime = ctrInstanceLifetime;
        }

        public bool IsShared
        {
            get { return _isShared; }
        }

        public string CtgName
        {
            get 
            { 
                // DANGER!  DANGER!  WILLL ROBINSON!  DANGER!  DANGER!

                // do not change this without first consulting the ops
                // team which looks for performance counters with this
                // specific formula (most notably the  leading  "XBL")

                return "XBL " + _ctgName; 

                // DANGER!  DANGER!  WILLL ROBINSON!  DANGER!  DANGER!
            }
        }

        public string CtgHelp
        {
            get { return _ctgHelp; }
        }

        public PerformanceCounterInstanceLifetime CtrInstanceLifetime
        {
            get { return _ctrInstanceLifetime; }
        }

        private bool   _isShared;
        private string _ctgName;
        private string _ctgHelp;
        private PerformanceCounterInstanceLifetime _ctrInstanceLifetime;  // applies to all counters & all instances in this category
        
    }


    // Performance Counter category attribute class used to define the name and the help 
    // text for that category. Uses the ConfigAttribute friendly component name in 
    // addition to a caller-supplied suffix.

    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Class)]
    public class XomComponentPerformanceCounterCategoryAttr : XomPerformanceCounterCategoryAttr
    {
        public XomComponentPerformanceCounterCategoryAttr(string ctgSuffix, string ctgHelp)
            : base(
                ConfigAttribute.GetFriendlyComponent() + " - " + ctgSuffix, 
                ConfigAttribute.GetComponent() + ": " + ctgHelp, 
                PerformanceCounterInstanceLifetime.Global, 
                false)
        {
        }
    }

    
    // Performance counter attribute class used to define the name, help text
    // and counter type.

    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
    public class XomPerformanceCounterAttr : System.Attribute
    {
        public XomPerformanceCounterAttr(string ctrName, string ctrHelp, PerformanceCounterType ctrType)
        {
            _ctrName = ctrName;
            _ctrHelp = ctrHelp;
            _ctrType = ctrType;
        }

        public string _ctrName;
        public string _ctrHelp;
        public PerformanceCounterType _ctrType;

        public bool Equals(XomPerformanceCounterAttr anotherInstance )
        {
            if (anotherInstance._ctrName != this._ctrName)
            {
                return false;
            }
            else if (anotherInstance._ctrHelp != this._ctrHelp)
            {
                return false;
            }
            else if (anotherInstance._ctrType != this._ctrType)
            {
                return false;
            }
            else
            {
                return true;
            }
        }
    }
    
    // Performance counter category class. Declare one of this for each counter
    // category that your application needs. Declare counters of the type 
    // PerformanceCounter inside it.

    [ComVisible(false)]
    public class XomPerformanceCounterCategory
    {
        public const string DEFAULT_INSTANCE = "_Total_";

        [ThreadStaticAttribute]
        private static string _categoryInstanceName;

        // Gets the instance name associated with the current thread, or the default instance
        // if none is specified.
        
        private static string GetInstanceName() {
            return _categoryInstanceName ?? XomPerformanceCounterCategory.DEFAULT_INSTANCE;
        }

        private static void SetInstanceName(string instance) {
            _categoryInstanceName = instance;
        }
        
        public XomPerformanceCounterCategory() : this(false)
        {
        }
        public XomPerformanceCounterCategory(bool fInitToZero)
        {
            // Extract the name and the instanceLifeTime text from the class's custom attribute. 
            XomPerformanceCounterCategoryAttr catAttr = XomPerformanceCounterInstall.GetCategoryAttribute(GetType());

            string categoryName = catAttr.CtgName;
            string categoryHelp = catAttr.CtgHelp;

            _categoryName = categoryName;
            _instanceLifetime = catAttr.CtrInstanceLifetime;

            InitializeCategory(GetInstanceName(), fInitToZero);
        }
        
        // You can use this method to create/access other instances. The first
        // time you access the instance will create it. Since the method returns
        // an XomPerformanceCounterCategory object  you will have to cast it
        // to your own class before accessing its counters. One practical way of
        // doing it is to declare your own [] operator. Hmmm, maybe we should 
        // have a method that destroys an instance, huh?

        public XomPerformanceCounterCategory GetInstance(string instanceName)
        {
            XomPerformanceCounterCategory instance;
            
            // access to instance list must be protected against writes.
            
            _lockInstances.AcquireReaderLock(-1);

            try
            {
                // search for instance
            
                instance = (XomPerformanceCounterCategory) _instances[instanceName];

                if(instance == null)
                {
                    try {
                        // object instance will be actived with, the 
                        // XomPerformanceCounterCategory::ctor will catch the 
                        // correct counter instance names to initialize with
                        SetInstanceName(instanceName);
                        instance = (XomPerformanceCounterCategory)Activator.CreateInstance(GetType());
                    }
                    finally {
                        SetInstanceName(null);
                    }

                    // We need write access to the instance list to add this new
                    // instance
                    
                    LockCookie lockCookie = _lockInstances.UpgradeToWriterLock(-1);

                    try
                    {
                        // Now that we are inside, make sure that no other thread
                        // added the instance before us.

                        if(_instances[instanceName] == null)
                        {
                            // Add instance to instance list
                            
                            _instances[instanceName] = instance;
                        }
                        else
                        {
                            // Some other thread got here first. Well, let's use
                            // the object that is already there, then.
                            
                            instance = (XomPerformanceCounterCategory) _instances[instanceName];
                        }
                    }
                    finally
                    {
                        _lockInstances.DowngradeFromWriterLock(ref lockCookie);
                    }
                }
            }
            finally
            {
                _lockInstances.ReleaseReaderLock();
            }

            return instance;
        }

        #region Force Init Perf Counters

        // The goal of this static method is to force the initialization of all
        // perfctrs category objects in the assembly, as opposed to the usual
        // managed code behavior of initializing on demand. This method should 
        // be called upon the initialization of the assembly. In the case of 
        // ASP.NET, when the assembly is loaded by IIS.

        public static void InitPerfCtrs()
        {
            Assembly assembly = Config.Assembly;
            InitPerfCtrs(assembly);

            foreach (AssemblyName assemblyName in assembly.GetReferencedAssemblies()) {
                try {
                    assembly = Assembly.Load(assemblyName);
                    InitPerfCtrs(assembly);
                }
                catch (FileNotFoundException) {
                    // ignore
                }
            }
        }    

        public static void InitPerfCtrs(Assembly asm)
        {
            try
            {
                FieldInfo[] fields = GetAssemblyPerfCounters(asm);
                
                for (int i = 0; i < fields.Length; i++)
                {
                    fields[i].GetValue(null);
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.COMMON_CONFIG_264, e,
                    "Failed to initialize the performance counter categories in this "+
                    "application. This is the initial attempt and will be ignored. " + 
                    "However, problems may occur when the counters get used. " +
                    "Attached to this event should be the reason why it failed. " +
                    "If you cannot figure it out, write down the description and " +
                    "contact dev. After correcting the problem, recycling the service " +
                    "is probably a good idea."
                );
            }
        }

        

        // Same thing as InitPerfCtrs(), but initalizes a specific instance 
        public static void InitInstPerfCtrs(string instance)
        {
            InitInstPerfCtrs(Config.Assembly, instance);
        }
        public static void InitInstPerfCtrs(Assembly asm, string instance)
        {
        
            try
            {
                FieldInfo[] fields = GetAssemblyPerfCounters(asm);
                
                for (int i = 0; i < fields.Length; i++)
                {
                    // make sure the default instance is initalized
                    ((XomPerformanceCounterCategory)fields[i].GetValue(null)).GetInstance(DEFAULT_INSTANCE);
                    // as well as the requested instance
                    ((XomPerformanceCounterCategory)fields[i].GetValue(null)).GetInstance(instance);
                }    
            }
            catch(Exception e)
            {
                Xom.NtEvent(XEvent.Id.COMMON_CONFIG_265, e,
                    "Failed to initialize the performance counter categories in this "+
                    "application. This is the initial attempt and will be ignored. " + 
                    "However, problems may occur when the counters get used. " +
                    "Attached to this event should be the reason why it failed. " +
                    "If you cannot figure it out, write down the description and " +
                    "contact dev. After correcting the problem, recycling the service " +
                    "is probably a good idea."
                );
            }
        }

        private static FieldInfo[] GetAssemblyPerfCounters(Assembly asm)
        {

            FieldInfo[] fields;
            
            // check for field info in http cache.
            // this is useful as this cache automatically cleans up items that may not be
            // referenced often (like this) if/when necessary.
            //
            if (HttpContext.Current != null)
            {
                fields = (FieldInfo[])HttpContext.Current.Cache[asm.FullName + ":PerfCounterFields"];
                if (fields != null)
                {
                    return fields;
                }
            }
            
            // nothing found in the cache, so build the list
            //
            Type[] allTypes = asm.GetTypes();
            ArrayList fieldList = new ArrayList();
            
            foreach( Type t in allTypes )
            {
                if(XomPerformanceCounterInstall.IsValidPerformanceCounterCategory(t))
                {
                    // Query all the static/public fields from this class.
                    fields = t.GetFields(BindingFlags.Static | BindingFlags.Public);
    
                    foreach(FieldInfo field in fields)
                    {
                        // If the field has the same type as the class itself,
                        // then that's what we're looking for.
                        if( field.MemberType == MemberTypes.Field &&
                            field.ReflectedType == t)
                        {
                            fieldList.Add(field);
                        }
                    }
                }
            }
            
            fields = new FieldInfo[fieldList.Count];
            fieldList.CopyTo(fields, 0);
            
            
            if (HttpContext.Current != null)
            {
                HttpContext.Current.Cache[asm.FullName + ":PerfCounterFields"] = fields;
            }
            
            return fields;
        }

        #endregion Force Init Perf Counters

        // Verifies that a field is a valid perform counter field.
        // Validity requires that is the right type, and has the required attribute
        
        private bool IsValidPerformanceCounterField(FieldInfo field) {
            return 
                field.FieldType == typeof(PerformanceCounter) &&
                Attribute.IsDefined(field, typeof(XomPerformanceCounterAttr), false);
        }

        // Get the attribute from a performance counter field, it is assumed that
        // the field is valid
        
        private XomPerformanceCounterAttr GetPerformanceCounterAttr(FieldInfo field) {
            return field.GetCustomAttributes(
                typeof(XomPerformanceCounterAttr), 
                false)[0] as XomPerformanceCounterAttr;
        }

        // Enumerate all fields that are valid performance counter fields for this
        // class
        
        private FieldInfo[] EnumerateValidPerformanceCounterFields() {
            FieldInfo[]     fields;
            List<FieldInfo> validFields;

            fields      = GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
            validFields = new List<FieldInfo>(fields.Length);
            
            for (int c=0; c<fields.Length; c++) {
                if (IsValidPerformanceCounterField(fields[c]))
                    validFields.Add(fields[c]);
            }

            return validFields.ToArray();
        }
        
        // Loads all the performance counters for the valid performance counter fields
        
        private void InitializeCategory(string instanceName, bool fInitToZero) 
        {
            foreach (FieldInfo field in EnumerateValidPerformanceCounterFields()) {
                XomPerformanceCounterAttr attr = GetPerformanceCounterAttr(field);

                PerformanceCounter counter;

                counter = CreateCounter(
                    attr._ctrName,
                    instanceName);

                if (fInitToZero)
                {
                    counter.RawValue = 0;
                }

                field.SetValue(this, counter);
            }
        }

        // Creates a new performance counter object

        private PerformanceCounter CreateCounter(string counterName, string instanceName) {
            PerformanceCounter counter;
            long raw;

            try {
                counter = new PerformanceCounter();
                counter.CategoryName     = _categoryName;
                counter.CounterName      = counterName;
                counter.InstanceName     = instanceName;
                counter.ReadOnly         = false;
                counter.InstanceLifetime = _instanceLifetime;
                
                //force initialization of the counter
                raw = counter.RawValue;

                return counter;
            }
            catch (Exception e) {
                Xom.NtEvent(XEvent.Id.PERFORMANCE_COUNTERS_0, e, 
                    "Failed to create the performance counter '{0}' in category '{1}' " +
                    "for instance '{2}'. " +
                    "This may be due to an improper installation of the component, if so running " +
                    "installutil.exe against against this component may fix the issue.",
                    counterName, _categoryName, instanceName
                );

                throw;
            }
        }

        private string _categoryName = null; 
            // Name of the performance counter category

        private Hashtable _instances = new Hashtable();
            // Hash table to store the instance objects
            
        private ReaderWriterLock _lockInstances = new ReaderWriterLock();
            // Sync access to the _instances

        private PerformanceCounterInstanceLifetime _instanceLifetime = PerformanceCounterInstanceLifetime.Global;
            // How long do counter instances in this cateogory live?
            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\xomperfctrsinstall.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration.Install;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using Microsoft.Win32;
using System.Text;
using System.Security.Cryptography;
using System.Threading;

using xonline.common.service;

namespace xonline.common.mgmt
{
    using CounterCategoryDictionary = Dictionary<string, XomPerformanceCounterAttr>;

    // Installs the performance counters in the machine. Run InstallUtil.exe
    // against this assembly to get the counters installed before running the
    // service.
    
    [ComVisible(false)]
    [RunInstaller(true)]
    public class XomPerformanceCounterInstall : Installer
    {
        private const string XboxLiveRegistryKey = @"SOFTWARE\Microsoft\XboxLive";
        private const string CounterHashRegistryKeyName = "PerfCountersInstalled";
        private const string CounterHashRegistryKey = XboxLiveRegistryKey + @"\" + CounterHashRegistryKeyName;

        // Verifies that the type meets the inheritence and attribute requirements
        // of a XomPerformanceCounterCategory

        public static bool IsValidPerformanceCounterCategory(Type t)
        {
            return 
                t.IsSubclassOf(typeof(XomPerformanceCounterCategory)) &&
                t != typeof(XomPerformanceCounterCategory) &&
                Attribute.IsDefined(t, typeof(XomPerformanceCounterCategoryAttr));
        }

        // Non-static implementation can be overridden!
        public virtual bool IsInstallablePerformanceCounterCategory(Type t)
        {
            return XomPerformanceCounterInstall.IsValidPerformanceCounterCategory(t);
        }

        // Retrieves the performance counter category attribute from the type.
        // It is assumed that the type is a valid performance counter category
        // type.

        public static XomPerformanceCounterCategoryAttr GetCategoryAttribute(Type t) {
            return t.GetCustomAttributes(typeof(XomPerformanceCounterCategoryAttr), false)[0] 
               as XomPerformanceCounterCategoryAttr;
        }
        
        // Called by the installer on install. Builds the counters for all the
        // classes in the local assembly.
    
        public override void Install(IDictionary stateSaver)
        {
            base.Install(stateSaver);

            // Log an event to setup the EventSource for this component. We do this at 
            //  install time since some of the users executing FD code may not have
            //  appropriate permissions to create EventSources. 
            // We don't want to init proper logging here because that is way too 
            //  heavyweight requiring communication with configdb, etc.

            EventLog.WriteEntry(
                xonline.common.config.Config.ComponentName, 
                "Beginning Install of perfctrs for " + xonline.common.config.Config.ComponentName, 
                EventLogEntryType.Information,
                (int) XEvent.MessageFromId(XEvent.Id.COMMON_INFO_47),
                0,
                null);

            LogMessage("Beginning Install of perfctrs for " + CounterRegistryName);
    
            // Enumerate through all the XomPerformanceCounterCategory derived 
            // classes in the local assembly (except for XomPerformanceCounterCategory
            // itself.

            Type[] allTypes = Assembly.GetAssembly(this.GetType()).GetTypes();

            // Go through all counters and get a hash of the list
            string countersHash = GetHashOnCounters(allTypes);

            // Check if counters hash exists in registry, if it is, we can skip the counters creation
            if (CheckCounterHashExistsInRegistry(countersHash))
            {
                LogMessage("Skipping counter installation, found matching counter hash token in registry for " + CounterRegistryName);
            }
            else
            {                
                foreach( Type t in allTypes )
                {
                    if(IsInstallablePerformanceCounterCategory(t)) 
                        InstallCategory(t);
                }

                // Drop counters hash token in registry after a successful install of counters.
                WriteCounterHashToRegistry(countersHash);
            }
        }
        
        // Called by the installer on uninstall. Removes all counters associated
        // to the classes of the local assembly.
    
        public override void Uninstall(IDictionary savedState)
        {
            base.Uninstall(savedState);
            UninstallAllCategories(); 
        }

        // Called by the installer when this, or another, Install() fails. Try to remove 
        // all perf counters in this assembly.

        public override void Rollback(IDictionary savedState)
        {
            base.Rollback(savedState);

            // Try to delete everything, even if we didn't actually install it. We could 
            // store this info in savedState, but this is quick and simple.
            UninstallAllCategories(); 
        }
    
        // Uninstall as many catgories as possible

        protected void UninstallAllCategories()
        {
            // To be safe, remove the registry key hash before attempting to uninstall
            DeleteCounterHashFromRegistry();

            // Enumerate through all the XomPerformanceCounterCategory derived classes in 
            // the local assembly (except for XomPerformanceCounterCategory
            // itself.                       

            Type[] allTypes = Assembly.GetAssembly(this.GetType()).GetTypes();

            int numFail = 0;
            int numTotal = 0;
            Exception lastException = null;
            foreach( Type t in allTypes )
            {
                if(IsInstallablePerformanceCounterCategory(t))
                {
                    try
                    {
                        numTotal++;
                        UninstallCategory(t);
                    }
                    catch (Exception e)
                    {
                        lastException = e;
                        numFail++;
                    }
                }
            }

            if (numFail > 0)
            {
                throw new Exception("Failed to uninstall " + numFail + " performance counter categories out of " + numTotal, lastException);
            }
        }

        // Uninstall logic used by the InstallCategory and UninstallCategory methods
        
        protected void UninstallCategoryHelper(XomPerformanceCounterCategoryAttr attr) {
            try {
                PerformanceCounterCategory.Delete(attr.CtgName);
                LogMessage("\t\tsuccessfully removed category.");
            }
            catch (InvalidOperationException e) { // category does not exist
                LogMessage("\t\tsuccessfully removed category. [" + e.Message + "]");
            }
            catch (Exception e) {
                LogMessage("\t\tfailed to remove category\n" + e.ToString());
                throw;
            }
        }

        // Given a category name, this function will return the performance counter category
        // associated with it, if that category does not exist null will be returned instead.

        protected PerformanceCounterCategory GetCategoryOrNull(string category) 
        {
            const int LoopCount = 15;

            for (int i = 0; i < LoopCount; ++i)
            {
                try
                {
                    PerformanceCounterCategory pcc = null;
                    string probe;

                    pcc = new PerformanceCounterCategory(category);
                    probe = pcc.CategoryHelp; //will raise exception if the category does not exist.

                    return pcc;
                }
                catch (FormatException)
                {
                    // This is the ugliest most hacktastic thing in the history of Xbox LIVE.
                    // Windows perf counters are stored in two locations - in a .dat file and in a blob in the registry
                    // There is a known race condition in the perf counter system that allows a reader to access the registry component of the perf counter system
                    // while NT is synchronizing the .dat file and the registry.  If the two aren't fully synchronized, the registry may appear corrupt.
                    // This loop will not solve registry corruption, which can only be resolved with lodctr /R, but will mitigate the timing issue
                    LogMessage(String.Format("Registry entry for performance counter {0} appears corrupted.  Retry {1} of {2} starting in 100ms", category, i + 1, LoopCount));
                    Thread.Sleep(100);
                    continue;
                }
                catch (InvalidOperationException)
                { // category does not exist
                    LogMessage("\t\tcategory is not present");
                    return null;
                }
                catch (Exception e)
                {
                    LogMessage("\t\tfailed to load category : " + e.ToString());
                    throw;
                }
            }

            throw new Exception(String.Format("Unable to load performance counter '{0}' - the registry is currently corrupted.  To resolve this, please run lodctr /R and rerun Octopus.", category));
        }
        
        // Uninstall the performance counter category from the system.  In the interest
        // of performance it will be assumed that the performance counters exist.
        
        protected void UninstallCategory(Type categoryType) {
            XomPerformanceCounterCategoryAttr attr;
            Stopwatch w = new Stopwatch();

            w.Start();
            attr = GetCategoryAttribute(categoryType);

            LogMessage("\tUninstall Counter Category Type - " + categoryType.Name);
            LogMessage("\t\tCategory = " + attr.CtgName);
            LogMessage("\t\tHelp     = " + attr.CtgHelp);
            LogMessage("\t\tShared   = " + attr.IsShared);

            if (!attr.IsShared)
                UninstallCategoryHelper(attr);
            else
                LogMessage("\t\tskipping removal of shared category.");

            w.Stop();
            
            LogMessage("\t\toperation completed in " + w.ElapsedMilliseconds.ToString() + " ms.");
        }

        
        
        // Install the performance counter category to the system.  It is assumed that
        // the performance counters are already installed.  If that is false, or the
        // existing performance counters are wrong they will be re-installed.

        protected void InstallCategory(Type categoryType) {
            XomPerformanceCounterCategoryAttr attr;
            CounterCreationDataCollection     creation;
            PerformanceCounterCategory        category = null;
            CounterCategoryDictionary         newCounterSet;
            Stopwatch                         w = new Stopwatch();

            w.Start();
            
            attr = GetCategoryAttribute(categoryType);
            
            LogMessage("\t Installing Counter Category Type - " + categoryType.Name);
            LogMessage("\t\tCategory = " + attr.CtgName);
            LogMessage("\t\tHelp     = " + attr.CtgHelp);
            LogMessage("\t\tShared   = " + attr.IsShared);
            
            creation = new CounterCreationDataCollection();
            newCounterSet = new CounterCategoryDictionary();

            //Load New Counters for the category 
            LogMessage("\t\tReflecting counter configuration");
            LoadCountersInCategory(categoryType, out creation, out newCounterSet);

            LogMessage("\t\tFetch existing counter group");
            category = GetCategoryOrNull(attr.CtgName);
            LogMessage("\t\tDone");

            if (null != category) { // compare the existing
                if (IsCategoryRemovalRequired(category, newCounterSet)) {
                    category = null;
                    LogMessage("\t\tRemoving the group");
                    UninstallCategoryHelper(attr);
                }
            }

            if (null == category) { // create new categories
                try {
                    // perf ctr lib may falsely report that the category is not present
                    PerformanceCounterCategory.Delete(attr.CtgName);                    
                }
                catch (InvalidOperationException) { /* the category really isn't present */ }
                catch (Exception e) {
                    LogMessage("\t\twarning: error encountered deleting category, continuing : " + e.ToString());
                }

                try {
                    LogMessage("\t\tCreating category");
                    XomPerformanceCounterLib.CreateCategory(
                        attr.CtgName,
                        attr.CtgHelp,
                        PerformanceCounterCategoryType.MultiInstance,
                        creation);

                    LogMessage("\t\tsuccessfully created category.");
                }
                catch (Exception e) { // failed to create category
                    LogMessage("\t\tfailed to created category : " + e.ToString());
                    throw;
                }
            }

            // Verify perf category and counters. Throws exception if not valid.

            LogMessage("\t\tVerifying all counters in category");
            try
            {
                VerifyCategory(categoryType);
            }
            catch (Exception e) 
            {
                LogMessage("\t\tError: Failed to verify performance counters in " + attr.CtgName);
                LogMessage("\t\t" + e.ToString());
                throw;
            }

            w.Stop();
            LogMessage("\t\toperation completed in " + w.ElapsedMilliseconds.ToString() + " ms.");


        }

        // Uses .Net libraries to open up each counter in the category. Should ensure 
        // everything exists.

        protected virtual void VerifyCategory(Type categoryType)
        {
            if (!IsInstallablePerformanceCounterCategory(categoryType)) 
            {
                LogMessage("\t\tNot a valid XomPerformanceCounterCategory type: " + categoryType.ToString());
                throw new InvalidOperationException("Not a valid category type");
            }

            XomPerformanceCounterCategory o = (XomPerformanceCounterCategory)Activator.CreateInstance(categoryType);

            // The XomPerformanceCounterCategory constructor initializes perf 
            // counters, which reads a value for each one. No exceptions == good to go

        }

        // Examines the old and new counter set for a specific category and reports
        // the differences between them

        protected void CalculateCategoryDifferences(
            PerformanceCounterCategory category,
            Dictionary<string, XomPerformanceCounterAttr> newCounters,
            List<string> missingSet /* counters in new set but not old set */,
            List<string> differenceSet /* counters in both sets but are different */,
            List<string> extraSet /* counters in old set but not new set */)
        {
            PerformanceCounter[] counters;
            List<string>         allCounters;
            string[]             instances;

            instances = category.GetInstanceNames();

            counters = (instances.Length > 0) ?
                category.GetCounters(instances[0]) : //get the name instanced
                category.GetCounters(); //or not

            allCounters = new List<string>(newCounters.Keys);

            for (int c=0; c<counters.Length; c++) {
                string name = counters[c].CounterName;
                
                if (!newCounters.ContainsKey(name))
                    extraSet.Add(name);
                else {
                    XomPerformanceCounterAttr oldAttr, newAttr;

                    oldAttr = new XomPerformanceCounterAttr(name, counters[c].CounterHelp, counters[c].CounterType);
                    newAttr = newCounters[name];
                    
                    if (! newAttr.Equals(oldAttr) )
                        differenceSet.Add(name);
                    else
                        allCounters.Remove(name);
                }
            }

            missingSet.AddRange(allCounters);
        }
        
        // This function indicates whether not the perf counter installer should uninstall
        // an existing category.
        
        protected bool IsCategoryRemovalRequired(
            PerformanceCounterCategory category,
            Dictionary<string, XomPerformanceCounterAttr> newCounterSet)
        {
            List<string> missingSet = new List<string>();
            List<string> differenceSet = new List<string>();
            List<string> extraSet = new List<string>();

            try
            {
                CalculateCategoryDifferences(category, newCounterSet, missingSet, differenceSet, extraSet);
            }
            catch
            {   // There have been intermittent exceptions in CalculateCategoryDifferences (e.g. TFS# 115728 and 158615)
                // In cases where they occur let's just remove the category and start over from scratch
                return true;
            }
            
            if (missingSet.Count == 0 && differenceSet.Count == 0 && extraSet.Count == 0) {
               LogMessage("\t\tcategory matches existing definition, no removal neccessary.");
               return false;
            }
            else {
               LogMessage("\t\tcategory does not match existing definition.");

               if (missingSet.Count > 0) {
                  LogMessage("\t\told category definition missing the following counters:");
                  LogMessage("\t\t\t" + string.Join("\n\t\t\t", missingSet.ToArray()));
               }

               if (differenceSet.Count > 0) {
                  LogMessage("\t\told and new category defintion differ for the following counters:");
                  LogMessage("\t\t\t" + string.Join("\n\t\t\t", differenceSet.ToArray()));
               }

               if (extraSet.Count > 0) {
                  LogMessage("\t\tnew category definition missing the following counters:");
                  LogMessage("\t\t\t" + string.Join("\n\t\t\t", differenceSet.ToArray()));
               }

               return true;
            }
        }

        protected int LoadCountersInCategory(Type categoryType, out CounterCreationDataCollection counterCollection, out Dictionary<string, XomPerformanceCounterAttr> newCounterSet)
        {
            return LoadCountersInCategory(categoryType, out counterCollection, out newCounterSet, true);
        }

        protected int LoadCountersInCategory(Type categoryType, out CounterCreationDataCollection counterCollection, out Dictionary<string, XomPerformanceCounterAttr> newCounterSet, bool logMessages)
        {
            int count = 0;
            counterCollection = new CounterCreationDataCollection();
            newCounterSet = new Dictionary<string, XomPerformanceCounterAttr>();

            FieldInfo[] newFields = categoryType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

            
            foreach (FieldInfo newField in newFields)
            {
                if (newField.FieldType == typeof(PerformanceCounter))
                {
                    // Get the perf counter's attributes.                    
                    XomPerformanceCounterAttr[] xomCounterAttributes = ( XomPerformanceCounterAttr[]) newField.GetCustomAttributes(typeof(XomPerformanceCounterAttr), false);
                    if (xomCounterAttributes.Length <= 0)
                    {
                        string message = String.Format("Failed to initialize the performance counter. The counter does not have a valid attribute. Counter name = " + newField.Name);

                        //Xom.NtEvent(XEvent.Id.COMMON_CONFIG_265,message);

                        //The field MUST have a XomPerformanceCounterAttr attribute to it
                        throw (new System.ArgumentException(message));
                    }

                    XomPerformanceCounterAttr newCounterAttributes = xomCounterAttributes[0] as XomPerformanceCounterAttr;

                    if (logMessages)
                    {
                        LogMessage("\t\tCounter {0}:", count++);
                        LogMessage("\t\t\t{0}", newCounterAttributes._ctrName);
                        LogMessage("\t\t\t{0}", newCounterAttributes._ctrHelp);
                        LogMessage("\t\t\t{0}", newCounterAttributes._ctrType);
                    }

                    newCounterSet.Add(newCounterAttributes._ctrName, newCounterAttributes);
                    counterCollection.Add(new CounterCreationData(newCounterAttributes._ctrName, newCounterAttributes._ctrHelp, newCounterAttributes._ctrType));
                }

            }
            return count;
        }

        private string GetHashOnCounters(Type[] allTypes)
        {
            StringBuilder countersString = new StringBuilder();

            // Go through all counters, combine them up into a string list.
            foreach (Type t in allTypes)
            {
                if (IsInstallablePerformanceCounterCategory(t))
                {
                    string categoryName = GetCategoryAttribute(t).CtgName;
                                        
                    CounterCreationDataCollection creation = new CounterCreationDataCollection();
                    CounterCategoryDictionary newCounterSet = new CounterCategoryDictionary();
                                        
                    LoadCountersInCategory(t, out creation, out newCounterSet, false /* don't log messages */);

                    foreach (string counterName in newCounterSet.Keys)
                    {
                        countersString.AppendLine(categoryName + "-" + counterName);
                    }
                }
            }

            // Get the MD5 hash from the counter string.
            byte[] hashData = MD5.Create().ComputeHash(Encoding.Default.GetBytes(countersString.ToString()));

            StringBuilder counterHash = new StringBuilder();
            foreach (byte b in hashData)
            {
                counterHash.Append(b.ToString("X2"));
            }

            return counterHash.ToString();
        }

        private bool CheckCounterHashExistsInRegistry(string countersHash)
        {
            using (RegistryKey regKey = Registry.LocalMachine.CreateSubKey(CounterHashRegistryKey))
            {
                string registryValue = (string)regKey.GetValue(CounterRegistryName);

                return registryValue == null ? false : registryValue.Equals(countersHash);
            }
        }

        private void WriteCounterHashToRegistry(string countersHash)
        {
            using (RegistryKey regKey = Registry.LocalMachine.CreateSubKey(CounterHashRegistryKey))
            {
                regKey.SetValue(CounterRegistryName, countersHash);
            }

            LogMessage("Counter hash written to registry for " + CounterRegistryName);
        }

        private void DeleteCounterHashFromRegistry()
        {
            using (RegistryKey regKey = Registry.LocalMachine.CreateSubKey(CounterHashRegistryKey))
            {
                regKey.DeleteValue(CounterRegistryName);
            }

            LogMessage("Counter hash deleted from registry for " + CounterRegistryName);
        }

        private string CounterRegistryName
        {
            get
            {
                return this.GetType().AssemblyQualifiedName;
            }
        }

        public void LogMessage(String message)
        {
            String stampedMessage = String.Format("[{0:dd-MM-yyyy HH:mm:ss.fff}] {1}", DateTime.Now, message).
                Replace("\n", "\n                             ");

            Context.LogMessage(stampedMessage);
        }

        public void LogMessage(String message, params Object[] args)
        {
            String formattedMessage = String.Format(message, args);

            LogMessage(formattedMessage);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\mgmt\XomRequestContext.cs ===
/*==========================================================================
 *
 *  XomRequestContext.cs
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.Collections;
using System.Diagnostics;

using xonline.common.service;

namespace xonline.common.mgmt
{
    public interface IXomRequestPerfCounters
    {
        PerformanceCounter ExecPerSecond         { get; }
        PerformanceCounter ExecTotal             { get; }
        PerformanceCounter ExecFailedPerSecond   { get; }
        PerformanceCounter ExecFailedTotal       { get; }
        PerformanceCounter ExecTime              { get; }
        PerformanceCounter ExecTimeBase          { get; }
    }

    public class XomRequestPerfCounters
    {
        public static void AddRequestPerfCounters(string api, IXomRequestPerfCounters rpc)
        {
            _requestCountersTable.Add(api, rpc);
        }

        public static IXomRequestPerfCounters GetCounters(string api)
        {
            return (IXomRequestPerfCounters) _requestCountersTable[api];
        }

        private static Hashtable _requestCountersTable = new Hashtable();
    }

    public class XomRequestContext : IDisposable
    {
        public XomRequestContext(string apiName): this(apiName, null)
        {
        }

        public XomRequestContext(string apiName, XomLogArea traceArea)
        {
            _apiName = apiName;
            _hr = HResult.E_FAIL;
            _traceArea = traceArea;

            if ( _traceArea != null )
            {
                string msg = _apiName + ": entering...";
                _traceArea.Log(new XomLogTargetContext(Floken.Current), XomLogLevel.Low, 0, null, null, msg);
            }

            _timeElapsed = new XomRequestTimeElapsed();
        }

        public virtual void Close()
        {
            Dispose();
        }

        public virtual void Dispose()
        {
            if ( _traceArea != null )
            {
                string msg = _apiName + ": hr = " + _hr + ": completed in " + _timeElapsed.MillisecondsElapsed + " ms.";
                _traceArea.Log(new XomLogTargetContext(Floken.Current), XomLogLevel.Low, 0, null, null, msg);
            }
        }

        public string ApiName
        {
            get { return _apiName; }
        }

        public HResult HResult
        {
            get { return _hr; }
            set { _hr = value; }
        }

        protected string _apiName;
        protected HResult _hr;
        protected XomRequestTimeElapsed _timeElapsed = null;
        protected XomLogArea _traceArea = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\nameutil\AdjectiveList.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;

using xonline.common.service;
using xonline.common.config;
using xonline.common.mgmt;

namespace xonline.common.user
{
    public class AdjectiveList : StringCollection
    {


        // CreateInstance
        //
        //      returns a cached instance of the object.
        //
        public static AdjectiveList CreateInstance(ushort countryId)
        {
            Hashtable lists = _lists;
            
            if (lists.ContainsKey(countryId))
            {
                return (AdjectiveList) lists[countryId];
            }

            AdjectiveList list = new AdjectiveList(countryId);
            lists[countryId] = list;

            return list;
        }

        private static Hashtable _lists = new Hashtable();

        static AdjectiveList()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(AdjectiveList.OnControlRequest);
        }

        public static void OnFlushCache(object o, EventArgs e)
        {
            _lists = new Hashtable();
        }


        private Random _rand;
        private Hashtable _charRanges;




        //
        // ctor
        //
        //      normally doing any real work in the
        //      constructor is discouraged, but given this object
        //      will be created once, cached, and used by many readers, the
        //      thread saftey of the ctor makes it the ideal place to do
        //      initialization.
        //
        private AdjectiveList(ushort countryId)
        {
            int[] prev;
            int i;

            _charRanges = new Hashtable();

            using (SqlConnection conn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                conn.Open();

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "dbo.p_xuacs_get_adjective_suggestions";
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add("@ti_country_id", SqlDbType.TinyInt).Value = (byte) countryId;

                    SqlParameter ret = cmd.CreateParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);

                    using (SqlDataReader r = cmd.ExecuteReader())
                    {
                        prev = new int[] { 0, -1 };
                        i = -1;

                        while (r.Read())
                        {
                            string str = r.GetString(0);
                            i = this.Add(str);

                            if (!_charRanges.Contains(str[0]))
                            {
                                // note: this assumes an ordered list from the resultset.
                                prev[1] = i - 1;
                                prev = new int[] { i, -1 };

                                _charRanges[str[0]] = prev;
                            }
                        }
                        r.Close();

                        prev[1] = i;
                        
                        HResult hr = (uint) ((int) ret.Value);
                        if (HResult.Failed(hr))
                        {
                            throw new XRLException(hr, XEvent.Id.COMMON_CODE_208,
                                "Calling p_xuacs_get_adjective_suggestions {0} returned 0 results!", countryId);

                        }
                    }
                }
            }

            _rand = new Random();
       }


        public string RandomItem(char startsWith, int chance)
        {
            Debug.Assert(_rand != null);
            Debug.Assert(_charRanges != null);


            int[] range = (int[])_charRanges[startsWith];

            if (range != null && _rand.Next(100) < chance)
            {
                Debug.Assert(range[1] < this.Count);
                return base[_rand.Next(range[0], range[1])];
            }
            else
            {
                return base[_rand.Next(this.Count)];
            }
        }

        public string RandomItem()
        {
            Debug.Assert(_rand != null);
            return base[_rand.Next(this.Count)];
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                string cmd = args.Command.ToLower();
                switch (args.Command)
                {
                    case "help":
                        XomControlConnection.SendMessage(
                            "AdjectiveList help\r\n" +
                            "    AdjectiveCacheFlush -- flushes adjectivelist.  AdjectiveList will reload on first use\r\n" +
                            "\r\n",
                            args.RequestId);
                        args.Handled = true;
                        break;

                    case "adjectivecacheflush":
                        AdjectiveList.OnFlushCache(sender, args);
                        XomControlConnection.SendMessage("AdjectiveList flushed.\r\n", args.RequestId);
                        args.Handled = true;
                        break;
                }
            }
            catch (Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\nameutil\CurseMgr.cs ===
//
// UnicodeCurseMgr.cs
//
// Original CurseMgr by MarkV.
// Updated with Unicode support by BenZotto.
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//

using System;
using System.Collections.Specialized;
using System.Diagnostics;

using xonline.common.mgmt;

namespace xonline.common.user
{
    public class UnicodeCurseManager
    {
        public const uint MAX_VET_NAME_LEN       = 512;

        const uint MAX_OUTPUT_SYMBOLS            = 0x10000;
        const uint NUM_ASCII_LATIN_INPUT_SYMBOLS = 0xE0;
        const uint START_STATE                   = 0;
        const uint STATE_FLAG_SUBSTR_MATCH       = 0x80000000;
        const uint STATE_FLAG_EXACT_MATCH        = 0x40000000;
        const uint STATE_FLAG_SUBSTR_LEN_MASK    = 0x3F000000;
        const byte STATE_FLAG_SUBSTR_LEN_SHIFT   = 24;
        const uint STATE_FLAG_NEXT_STATE_MASK    = 0x00FFFFFF;
        const uint END_STATE                     = 0x00FFFFFF;

        public UnicodeCurseManager()
        {
            _buffer = null;
        }

        public UnicodeCurseManager(uint[] buffer)
        {
            _buffer = buffer;
        }

        //
        // A few read-only properties
        //
        public uint TableSize
        {
            get
            {
                // 4 is used because it is sizeof( uint )
                return  ( _cOutputSymbols * _cMaxStates * 4 ) + ( ( (uint) _rguiOutputMapping.Length ) * 4 );
            }
        }

        public uint MaxStates
        {
            get { return( _cMaxStates ); }
        }

        public ushort OutputSymbols
        {
            get { return( _cOutputSymbols ); }
        }

        public uint[] Buffer
        {
            get { return _buffer; }
        }

        public int BufferLength
        {
            get { return ( _buffer == null ? 0 : _buffer.Length ); }
        }

        public static uint[] ComputeMaxTableSize( StringCollection substrWords, StringCollection exactWords, out uint maxStates, out ushort numOutputSymbols )
        {
            maxStates = 0;
            numOutputSymbols = 0;

            uint[] outputMapping = new uint[ MAX_OUTPUT_SYMBOLS ];

            foreach( string word in substrWords )
            {
                maxStates += (uint) word.Length;

                bool[] wordBreaks = new bool[ word.Length + 1 ];
                string flatWord = Flatten( word, ref wordBreaks );
                for( int i = 0; i < flatWord.Length; i++ )
                {
                    if ( outputMapping[ flatWord[ i ] ] == 0)
                    {
                        outputMapping[ flatWord[ i ] ] = ++numOutputSymbols;
                    }
                }
            }

            foreach( string word in exactWords )
            {
                maxStates += (uint) word.Length;

                bool[] wordBreaks = new bool[ word.Length + 1 ];
                string flatWord = Flatten( word, ref wordBreaks );
                for( int i = 0; i < flatWord.Length; i++ )
                {

                    if( outputMapping[ flatWord[ i ] ] == 0 )
                    {
                        outputMapping[ flatWord[ i ] ] = ++numOutputSymbols;
                    }
                }
            }


            Debug.Assert( numOutputSymbols > 0 );

            return outputMapping;
        }

        //
        // Build state machine table from supplied word lists
        //
        public void Load( StringCollection OrigSubstrWords, StringCollection OrigExactWords )
        {
            _rguiOutputMapping = ComputeMaxTableSize( OrigSubstrWords, OrigExactWords, out _cMaxStates, out _cOutputSymbols );

            Debug.Assert( _cOutputSymbols > 0 );

            if( _cOutputSymbols == 0 )
            {
                return;
            }

            uint stateMachineSize = _cOutputSymbols * _cMaxStates;

            _StateMachine = NewStateMachine(stateMachineSize);

            Xom.Trace(XomAreaName.nametrace, LogLevel.L_NORMAL, "UnicodeCurseMgr.Load: _cOutputSymbols=" + _cOutputSymbols + ", _cMaxStates=" + _cMaxStates + ", _StateMachine.Length=" + _StateMachine.Length );

            _cStates = 0;

            Debug.Assert( _StateMachine[ 0 ] == 0 );

            foreach( string word in OrigSubstrWords )
            {
                bool[] rgfWordBreaks = new bool[ word.Length + 1 ];
                string flatWord = Flatten( word, ref rgfWordBreaks );

                AddToStateMachine( flatWord, STATE_FLAG_SUBSTR_MATCH );
            }

            foreach( string word in OrigExactWords )
            {
                bool[] rgfWordBreaks = new bool[ word.Length + 1 ];
                string flatWord = Flatten( word, ref rgfWordBreaks );

                AddToStateMachine( flatWord, STATE_FLAG_EXACT_MATCH );
            }

            if ( _buffer != null )
            {
                Xom.Trace(XomAreaName.nametrace, LogLevel.L_NORMAL, "UnicodeCurseMgr.Load: _StateMachine.Length=" + _StateMachine.Length + ", _cOutputSymbols=" + _cOutputSymbols + ", _cStates+1=" + (_cStates + 1).ToString() + " --> headroom=" + (_StateMachine.Length - (_cStates + 1) * _cOutputSymbols).ToString());
            }
        }

        private uint[] NewStateMachine( uint length )
        {
            if ( _buffer != null )
            {
                Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "UnicodeCurseManager.NewStateMachine: reusing _buffer (required=" + length + ", actual=" + _buffer.Length + ")...");

                Array.Clear(_buffer, 0, _buffer.Length);
                return _buffer;
            }
            else
            {
                return new uint[ length ];
            }
        }

        private void AddToStateMachine( string szWord, uint uiFinalState )
        {
            uint uiCurState = START_STATE;

            for( int i = 0; i < szWord.Length; i++ )
            {
                uint uiIndex = _rguiOutputMapping[ szWord[ i ] ];
                Debug.Assert( uiIndex > 0 );
                uiIndex--;
                uint uiNextState = _StateMachine[ ( uiCurState * _cOutputSymbols ) + uiIndex ];

                if( i < szWord.Length - 1 )
                {
                    if( ( uiNextState & STATE_FLAG_SUBSTR_MATCH ) != 0 )
                    {
                        //
                        // There is already a shorter substring match covering this sequence - do nothing
                        //
                        return;
                    }

                    if( ( uiNextState & STATE_FLAG_NEXT_STATE_MASK ) != 0 )
                    {
                        //
                        // Simply move on to next state
                        //
                        uiCurState = ( uiNextState & STATE_FLAG_NEXT_STATE_MASK );
                    }
                    else
                    {
                        //
                        // This state may already be the end of an exact match - be careful
                        // not to overwrite that fact.
                        //
                        Debug.Assert( _cStates < _cMaxStates, "No more room in the state machine" );

                        _StateMachine[ ( uiCurState * _cOutputSymbols ) + uiIndex ] |= ++_cStates;
                        uiCurState = _cStates;
                    }
                }
                else
                {
                    //
                    // This state has now been converted either to an exact match (which can coexist
                    // with other longer paths) or a substring match (which trumps exact matches).
                    //
                    _StateMachine[ ( uiCurState * _cOutputSymbols ) + uiIndex ] |= uiFinalState;

                    if( uiFinalState == STATE_FLAG_SUBSTR_MATCH )
                    {
                        _StateMachine[ ( uiCurState * _cOutputSymbols ) + uiIndex ] |=
                            ( (uint) szWord.Length ) << STATE_FLAG_SUBSTR_LEN_SHIFT;
                    }
                }
            }
        }

        public bool VetName( string strName, ref string strExact, ref string strSubstr )
        {
            //
            // If there's no mapping table, there are no bad words.
            //

            if( _cOutputSymbols == 0 )
            {
                return( true );
            }

            if( strName.Length > MAX_VET_NAME_LEN )
            {
                throw new ApplicationException( "String passed to UnicodeCurseManager::VetName is too long" );
            }

            //
            // Eliminate most creative spelling alternatives
            //
            bool[] rgfWordBreaks = new bool[ strName.Length + 1 ];
            strName = Flatten( strName, ref rgfWordBreaks );

            // Initialize the state machine for this text.  Each slot represents the current state for bad word checking beginning from that
            // letter.  For example, if the string is 'hello', then slot 0 represents bad state checking starting from the letter 'h', slot 1
            // represents bad state checking starting from the letter 'e', and so on.  When any state reaches a match, we stop.
            //
            uint[] uiCurStates = new uint[ strName.Length ];
            int cCurStates = 0;

            // Each successive inner loop will start from the first non-END_STATE slot
            int iPosPriorAreAllEndState = 0;

            for( int iChar = 0; iChar < strName.Length; iChar++ )
            {
                //
                // Add a new state tracking the string starting at this offset in the flattened name
                //
                if( cCurStates < MAX_VET_NAME_LEN )
                {
                    uiCurStates[ cCurStates++ ] = START_STATE;
                }

                //
                // Convert the current character into a symbol array index
                //
                uint uiIndex = _rguiOutputMapping[ strName[ iChar ] ];
                bool fUnknownSymbol = ( uiIndex == 0 ) ? true : false;
                uiIndex--;

                //
                // Loop through all current states updating them as we go
                //
                for( int iState = iPosPriorAreAllEndState; iState < cCurStates; iState++ )
                {
                    if( uiCurStates[ iState ] == END_STATE )
                    {
                        continue;
                    }

                    //
                    // If the current symbol is unknown to the state machine,
                    // we terminate all currently ongoing searches.  Strings
                    // beginning after the unknown symbol may still match.
                    //
                    if( fUnknownSymbol )
                    {
                        uiCurStates[ iState ] = END_STATE;

                        // We don't need to start from the beginning next round of the 'for' loop if all previous states are END_STATE
                        if( iState == iPosPriorAreAllEndState )
                        {
                            while( iPosPriorAreAllEndState < uiCurStates.Length &&
                                END_STATE == uiCurStates[ iPosPriorAreAllEndState ] )
                            {
                                iPosPriorAreAllEndState++;
                            }
                        }
                        continue;
                    }

                    uint uiNextState = _StateMachine[ ( uiCurStates[ iState ] * _cOutputSymbols ) + uiIndex ];

                    //
                    // All exact matches must begin at a word break boundary (including an entire string match)
                    //
                    if( ( uiNextState & STATE_FLAG_EXACT_MATCH ) != 0 &&
                        rgfWordBreaks[ iState ] )
                    {
                        //
                        // Ignore spanning across words if matching the entire string
                        //
                        if( ( iState == 0 ) && ( iChar == strName.Length - 1 ) )
                        {
                            strExact = strName;
                            strSubstr = "";
                            return( false );
                        }

                        //
                        // Check that the substring ends on a word break boundary without crossing any others
                        //
                        // original string:  up yours dude
                        // word break bits:  10 10000 1000
                        // flattened pos:    01 23456 789A
                        //                      ^   ^
                        //                  iState iChar
                        //
                        if( rgfWordBreaks[ iChar + 1 ] && ( iChar > iState ) )
                        {
                            // We've already checked location iState (the beginning), and iChar + 1 (the end), now
                            // make sure no character in the middle is a word break (ours in the example above).
                            bool fFoundWordBreak = false;
                            for( int iPos = iState + 1; iPos <= iChar; iPos++ )
                            {
                                if( rgfWordBreaks[ iPos ] )
                                {
                                    fFoundWordBreak = true;
                                    break;
                                }
                            }

                            if( !fFoundWordBreak )
                            {
                                strExact = strName.Substring( iState, 1 + iChar - iState );
                                strSubstr = "";
                                return( false );
                            }
                        }
                    }

                    //
                    // Look for substring matches (on an arbitrary boundary)
                    //
                    if( ( uiNextState & STATE_FLAG_SUBSTR_MATCH ) != 0 )
                    {
                        strExact = "";

                        int iSubStrLen = (int)( ( uiNextState & STATE_FLAG_SUBSTR_LEN_MASK ) >> STATE_FLAG_SUBSTR_LEN_SHIFT );
                        Debug.Assert( iSubStrLen > 1 );

                        strSubstr = strName.Substring( iChar + 1 - iSubStrLen, iSubStrLen );

                        return( false );
                    }

                    if( ( uiNextState & STATE_FLAG_NEXT_STATE_MASK ) != 0 )
                    {
                        uiCurStates[ iState ] = ( uiNextState & STATE_FLAG_NEXT_STATE_MASK );
                    }
                    else
                    {
                        uiCurStates[ iState ] = END_STATE;

                        // We don't need to start from the beginning next round of the 'for' loop if all previous states are END_STATE
                        if( iState == iPosPriorAreAllEndState )
                        {
                            while( iPosPriorAreAllEndState < uiCurStates.Length &&
                                   END_STATE == uiCurStates[ iPosPriorAreAllEndState ] )
                            {
                                iPosPriorAreAllEndState++;
                            }
                        }
                    }
                }
            }

            return( true );
        }

        //
        // This is the mapping of the characters that NameUtil.Flatten knows about.
        // It's the ASCII and LATIN-1 character sets.  Control chars are skipped.
        //
        //     0 or out of range = skip character
        //     in range value = convert to given character
        //     -1 = multi-character or special case substitution
        //
        private static sbyte[] rgbAllowedChars = new sbyte[]
        {
            // space !     "     #     $     %     &     '     (     )     *     +     ,     -     .     /
            // 0x20  0x21  0x22  0x23  0x24  0x25  0x26  0x27  0x28  0x29  0x2A  0x2B  0x2C  0x2D  0x2E  0x2F
               0,    0x69, 0,    0,    0x73, 0,    0,    0,    -1,   -1,   0,    0,    0,    0,    0,    -1,

            // 0     1     2     3     4     5     6     7     8     9     :     ;     <     =     >     ?
            // 0x30  0x31  0x32  0x33  0x34  0x35  0x36  0x37  0x38  0x39  0x3A  0x3B  0x3C  0x3D  0x3E  0x3F
               0x6F, -1,   0x32, 0x62, 0x61, 0x73, 0x62, 0x74, 0x62, 0x67, 0,    0,    0x63, 0,    0x64, 0x3F,

            // @     A     B     C     D     E     F     G     H     I     J     K     L     M     N     O
            // 0x40  0x41  0x42  0x43  0x44  0x45  0x46  0x47, 0x48  0x49  0x4A  0x4B  0x4C  0x4D  0x4E  0x4F
               0,    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, -1,   0x6A, 0x6B, -1,   0x6D, 0x6E, 0x6F,

            // P     Q     R     S     T     U     V     W     X     Y     Z     [     \     ]     ^     _
            // 0x50  0x51  0x55  0x53  0x54  0x55  0x56  0x57  0x58  0x59  0x5A  0x5B  0x5C  0x5D  0x5E  0x5F
               0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x75, 0x77, 0x68, 0x79, 0x7A, 0,    -1,   0,    0,    0,

            // `     a     b     c     d     e     f     g     h     i     j     k     l     m     n     o
            // 0x60  0x61  0x62  0x63  0x64  0x65  0x66  0x67  0x68  0x69  0x6A  0x6B  0x6C  0x6D  0x6E  0x6F
               0,    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, -1,   0x6A, 0x6B, -1,   0x6D, 0x6E, 0x6F,

            // p     q     r     s     t     u     v     w     x     y     z     {     |     }     ~     DEL
            // 0x70  0x71  0x72  0x73  0x74  0x75  0x76  0x77  0x78  0x79  0x7A  0x7B  0x7C  0x7D  0x7E  0x7F
               0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x75, 0x77, 0x68, 0x79, 0x7A, 0,    -1,   0,    0,    0,

            // XXX   XXX   BPH   NBH   IND   NEL   SSA   ESA   HTS   HTJ   VTS   PLD   PLU   RI    SS2   SS3
            // 0x80  0x81  0x82  0x83  0x84  0x85  0x86  0x87  0x88  0x89  0x8A  0x8B  0x8C  0x8D  0x8E  0x8F
               0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

            // DCS   PU1   PU2   STS   CCH   MW    SPA   EPA   SOS   XXX   SCI   CSI   ST    OSC   PM    APC
            // 0x90  0x91  0x92  0x93  0x94  0x95  0x96  0x97  0x98  0x99  0x9A  0x9B  0x9C  0x9D  0x9E  0x9F
               0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

            // NBSP                                |                 (c)         <<          SHY   (R)
            // 0xA0  0xA1  0xA2  0xA3  0xA4  0xA5  0xA6  0xA7, 0xA8  0xA9  0xAA  0xAB  0xAC  0xAD  0xAE  0xAF
               0,    0x69, 0x63, -1,   0x6F, 0x79, -1,   0x73, 0,    0x63, 0,    0x63, 0,    0,    0x72, 0,

            //       +-    ^2    ^3                                  ^1          >>    1/4   1/2   3/4
            // 0xB0  0xB1  0xB2  0xB3  0xB4  0xB5  0xB6  0xB7, 0xB8  0xB9  0xBA  0xBB  0xBC  0xBD  0xBE  0xBF
               0x6F, 0,    0x32, 0x33, 0,    0x75, 0,    0,    0,    0,    0,    0x64, 0,    0,    0,    0x3F,

            // `A    'A    ^A    ~A    :A    oA    AE    C,    `E    'E    ^E    :E    `I    'I    ^I    :I
            // 0xC0  0xC1  0xC2  0xC3  0xC4  0xC5  0xC6  0xC7  0xC8  0xC9  0xCA  0xCB  0xCC  0xCD  0xCE  0xCF
               0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x65, 0x63, 0x65, 0x65, 0x65, 0x65, 0x69, 0x69, 0x69, 0x69,

            // -D    ~N    `O    'O    ^O    ~O    :O    X     /O    `U    'U    ^U    :U    'Y          B
            // 0xD0  0xD1  0xD2  0xD3  0xD4  0xD5  0xD6  0xD7  0xD8  0xD9  0xDA  0xDB  0xDC  0xDD  0xDE  0xDF
               0x64, 0x6E, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x68, 0x6F, 0x75, 0x75, 0x75, 0x75, 0x79, 0,    0x62,

            // `a    'a    ^a    ~a    :a    oa    ae    c,    `e    'e    ^e    :e    `i    'i    ^i    :i
            // 0xE0  0xE1  0xE2  0xE3  0xE4  0xE5  0xE6  0xE7  0xE8  0xE9  0xEA  0xEB  0xEC  0xED  0xEE  0xEF
               0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x65, 0x63, 0x65, 0x65, 0x65, 0x65, 0x69, 0x69, 0x69, 0x69,

            // eth   ~n    `o    'o    ^o    ~o    :o          /o    `u    'u    ^u    :u    'y          :Y
            // 0xF0  0xF1  0xF2  0xF3  0xF4  0xF5  0xF6  0xF7  0xF8  0xF9  0xFA  0xFB  0xFC  0xFD  0xFE  0xFF
               0x64, 0x6E, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0,    0x6F, 0x75, 0x75, 0x75, 0x75, 0x79, 0,    0x79
        };

        //
        // Helper method that shifts any word break bits 'above' the given position down by a number of slots
        //
        private static void AdjustWordBreaks( int iPos, int nToRemove, ref bool[] rgfWordBreaks )
        {
            for( int iChar = iPos + 1; iChar < rgfWordBreaks.GetLength(0); iChar++ )
            {
                if( iChar < rgfWordBreaks.GetLength(0) - nToRemove )
                {
                    rgfWordBreaks[ iChar ] = rgfWordBreaks[ iChar + nToRemove ];
                }
                else
                {
                    // This shouldn't be necessary because if someone reads this far they are reading past the flattened
                    // length which is invalid.  Better safe than sorry, though.
                    rgfWordBreaks[ iChar ] = false;
                }
            }
        }

        // Flatten
        //
        // Collapse a given string into a form more suitable for
        // use in vetting naughty words using a one-way transform.
        //
        public static string Flatten( string szOrig, ref bool[] rgfWordBreaks )
        {
            string szRet = "";

            //
            // 0-based position of any word breaks that preceded the corresponding character in the
            // original input string.  There are always at least two: at position zero & string length
            //
            rgfWordBreaks[ 0 ] = true;

            int cchRet = 0;

            //
            // Make a first pass stripping out entirely impossible characters such as spaces
            //
            for( int i = 0; i < szOrig.Length; i++ )
            {
                char ch = szOrig[ i ];

                if( ch < 0x20 )
                {
                    continue;
                }

                sbyte sbNew = -1;

                if( ch < 0x100 )
                {
                    sbNew = rgbAllowedChars[ ch - 0x20 ];
                }

                if( sbNew != 0 )
                {
                    szRet += ch;
                    cchRet++;
                }

                //
                // Flag any character positions followed by one or more space characters as a word break
                //
                if( ch == 0x20 )
                {
                    rgfWordBreaks[ cchRet ] = true;
                }
            }

            //
            // Make a second pass building the final output string while special-casing certain
            // multi-character combinations
            //
            szOrig = szRet;
            szRet = "";

            for( int i = 0; i < szOrig.Length; i++ )
            {
                char ch = szOrig[ i ];

                //
                // No flattening rules apply to high characters
                //

                if( ch >= 0x100 )
                {
                    szRet += ch;
                    continue;
                }

                sbyte sbNew = rgbAllowedChars[ ch - 0x20 ];

                if( sbNew > 0 )
                {
                    szRet += (char) sbNew;
                }
                else if( sbNew == -1 )
                {
                    int cchLeft = szOrig.Length - i - 1;

                    if( ch == '/' )
                    {
                        if( ( cchLeft >= 3 ) && ( szOrig[ i + 1 ] == '\\' ) && ( szOrig[ i + 2 ] == '/' ) && ( szOrig[ i + 3 ] == '\\' ) )
                        {
                            // name = name.Replace(@"/\/\", "m");
                            szRet += 'm';
                            AdjustWordBreaks( i, 3, ref rgfWordBreaks );
                            i += 3;
                        }
                        else
                        {
                            szRet += '/';
                        }
                    }
                    else if( ch == '\\' )
                    {
                        if( ( cchLeft >= 3 ) && ( szOrig[ i + 1 ] == '/' ) && ( szOrig[ i + 2 ] == '\\' ) && ( szOrig[ i + 3 ] == '/' ) )
                        {
                            // name = name.Replace(@"\/\/", "w");
                            szRet += 'w';
                            AdjustWordBreaks( i, 3, ref rgfWordBreaks );
                            i += 3;
                        }
                        else if( ( cchLeft >= 1 ) && ( szOrig[ i + 1 ] == '/' ) )
                        {
                            // name = name.Replace(@"\/", "u");
                            szRet += 'u';
                            AdjustWordBreaks( i, 1, ref rgfWordBreaks );
                            i++;
                        }
                        else
                        {
                            szRet += '\\';
                        }
                    }
                    else if( ( ch == '|' ) || ( ch == 0x00A6 ) )
                    {
                        if( ( cchLeft >= 1 ) && ( szOrig[ i + 1 ] == '<' ) )
                        {
                            // name = name.Replace("|<", "k");
                            szRet += 'k';
                            AdjustWordBreaks( i, 1, ref rgfWordBreaks );
                            i++;
                        }
                        else if( ( cchLeft >= 1 ) && ( szOrig[ i + 1 ] == ')' ) )
                        {
                            // name = name.Replace("|)", "d");
                            szRet += 'd';
                            AdjustWordBreaks( i, 1, ref rgfWordBreaks );
                            i++;
                        }
                        else if( ( cchLeft >= 1 ) && ( szOrig[ i + 1 ] == '>' ) )
                        {
                            // name = name.Replace("|>", "d");
                            szRet += 'd';
                            AdjustWordBreaks( i, 1, ref rgfWordBreaks );
                            i++;
                        }
                        else
                        {
                            // name = name.Replace("|", "i");
                            szRet += 'i';
                        }
                    }
                    else if( ( ch == 'i' ) || ( ch == 'l' ) || ( ch == 'I' ) || ( ch == 'L' ) || ( ch == '1' ) || ( ch == 0x00A3 ) )
                    {
                        if( ( cchLeft >= 1 ) && ( szOrig[ i + 1 ] == ')' ) )
                        {
                            // name = name.Replace("i)", "d");
                            // name = name.Replace("1)", "d");
                            // name = name.Replace("l)", "d");
                            szRet += 'd';
                            AdjustWordBreaks( i, 1, ref rgfWordBreaks );
                            i++;
                        }
                        else if( ( cchLeft >= 1 ) && ( szOrig[ i + 1 ] == '>' ) )
                        {
                            // name = name.Replace("i>", "d");
                            // name = name.Replace("1>", "d");
                            // name = name.Replace("l>", "d");
                            szRet += 'd';
                            AdjustWordBreaks( i, 1, ref rgfWordBreaks );
                            i++;
                        }
                        else
                        {
                            // name = name.Replace("1", "i");
                            // name = name.Replace("l", "i");
                            szRet += 'i';
                        }
                    }
                    else if( ch == '(' )
                    {
                        if( ( cchLeft >= 1 ) && ( szOrig[ i + 1 ] == ')' ) )
                        {
                            // name = name.Replace("()", "o");
                            szRet += 'o';
                            AdjustWordBreaks( i, 1, ref rgfWordBreaks );
                            i++;
                        }
                        else
                        {
                            // name = name.Replace("(", "c");
                            szRet += 'c';
                        }
                    }
                    else if( ch == ')' )
                    {
                        if( ( cchLeft >= 2 ) && ( szOrig[ i + 1 ] == '(' ) && ( szOrig[ i + 2 ] == ')' ) )
                        {
                            // name = name.Replace("()", "o"); takes precedence over the next case
                            szRet += ')';
                        }
                        else if( ( cchLeft >= 1 ) && ( szOrig[ i + 1 ] == '(' ) )
                        {
                            // name = name.Replace(")(", "h");
                            szRet += 'h';
                            AdjustWordBreaks( i, 1, ref rgfWordBreaks );
                            i++;
                        }
                        else
                        {
                            szRet += ')';
                        }
                    }
                }
            }

            rgfWordBreaks[ szRet.Length ] = true;

            return( szRet );
        }

        // For debugging purposes
        public void OutputTable( out string strTable )
        {
            strTable = "   ";

            for( ulong iSymbol = 1; iSymbol <= _cOutputSymbols; iSymbol++ )
            {
                ulong iMapping;
                for( iMapping = 0; iMapping < 65535; iMapping++ )
                {
                    if( iSymbol == _rguiOutputMapping[ iMapping ] )
                    {
                        break;
                    }
                }
                strTable += ((char)iMapping).ToString() + ",";
            }
            strTable += "\n";

            for( ulong iState = 0; iState < _cMaxStates; iState++ )
            {
                strTable += iState.ToString("X") + " ";
                for( ulong iSymbol = 0; iSymbol < _cOutputSymbols; iSymbol++ )
                {
                    strTable += _StateMachine[ ( iState * _cOutputSymbols ) + iSymbol ].ToString("X") + ",";
                }
                strTable += "\n";
            }
        }

        private uint[] _buffer = null;
        private uint[] _StateMachine;
        private uint   _cMaxStates = 0;
        private uint   _cStates    = 0;


        private uint[] _rguiOutputMapping;
        private ushort _cOutputSymbols = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\nameutil\ForbiddenNames.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;

using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.config;

[assembly: XomAreaDefinition(XomAreaName.nametrace)]

namespace xonline.common.user
{

    public class ForbiddenNameList
    {
        private const int MSPERMIN = 60000;

        private static Dictionary<uint, string> _excludedTitles = new Dictionary<uint, string>();
        private static UnicodeCurseManager _CurseMgr;
        private static Hashtable _ExactMatchTable;
        private static bool _NeverReload = false;
        private static Timer _ReloadTimer;

        public static UnicodeCurseManager CurseMgr
        {
            get
            {
                return _CurseMgr;
            }
        }

        public static Hashtable ExactMatchTable
        {
            get
            {
                return _ExactMatchTable;
            }
        }


        public static bool VetName( string strName, ref string strExact, ref string strSubstr )
        {
            return VetName( strName, ref strExact, ref strSubstr, 0 );
        }

        public static bool VetName( string strName, ref string strExact, ref string strSubstr, uint titleId )
        {
            if (_excludedTitles != null) {
                if (_excludedTitles.ContainsKey(titleId)) {
                    Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "ForbiddenNameList.VetName: title 0x" + titleId.ToString("08X") + " is excluded returning true ...");
                    return true;
                }
            }

            if( _CurseMgr == null )
            {
                if (! LoadForbiddenNames())
                {
                    Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "ForbiddenNameList.VetName: no _CurseMgr instance, returning true...");
                    Xom.NtEvent(XEvent.Id.FORBIDDEN_NAMES_UNVETTED_STRING, "String {0} was not vetted.", strName);
                    return true;
                }
            }

            Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "ForbiddenNameList.VetName: using cached _CurseMgr instance...");

            if ( _ExactMatchTable != null )
            {
                bool[] wordBreaks = new bool[strName.Length + 1];
                string flattenedName = UnicodeCurseManager.Flatten(strName, ref wordBreaks);

                // check the entire string
                if ( _ExactMatchTable[flattenedName] != null )
                {
                    Xom.Trace(XomAreaName.nametrace, LogLevel.L_NORMAL, "ForbiddenNameList.VetName: found '" + strName + "' in exact match list.");
                    strExact = flattenedName;
                    return false;
                }

                // check the individual words
                int i, j;
                for (i=0; i < flattenedName.Length-1; )
                {
                    // found the start of a word
                    if ( wordBreaks[i] )
                    {
                        // find the end of the word
                        for (j=i+1; j <= wordBreaks.Length && wordBreaks[j] == false; j++)
                        {
                        }

                        // the entire string was already verified so if there are no smaller
                        // substrings, stop here
                        if ( i == 0 && j == flattenedName.Length )
                        {
                            break;
                        }
                        
                        string word = flattenedName.Substring(i, j-i);
                        Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "ForbiddenNameList.VetName: found word: " + word + "...");

                        if ( _ExactMatchTable[word] != null )
                        {
                            Xom.Trace(XomAreaName.nametrace, LogLevel.L_NORMAL, "ForbiddenNameList.VetName: found substring'" + word + "' of '" + strName + "' in exact match list.");
                            strExact = word;
                            return false;
                        }

                        // advance i to start of next word
                        i = j;
                    }
                }
            }
            return( _CurseMgr.VetName( strName, ref strExact, ref strSubstr ) );
        }

        [Flags]
        enum WordUsage
        {
           Exact      = 0x0,
           Substring  = 0x1
        }

        // there is no direct call of this method.  It is called by
        // feapp by reflecting on application initializers on start

        public static void Initialize()
        {
            Config.SettingChange                += new SettingChangeEventHandler(ForbiddenNameList.SettingsChanged);
            Config.MultiSettingChange           += new MultiSettingChangeEventHandler(ForbiddenNameList.MultiSettingsChanged);
            XomControl.ControlRequestEvent      += new XomControl.ControlRequestEventHandler(ForbiddenNameList.OnControlRequest);

            LoadExcludedTitles(Config.GetMultiSetting(MultiSetting.user_forbiddenNamesExcludedTitles));
            LoadForbiddenNames();

            uint reloadInterval = Config.GetUIntSetting(Setting.user_forbiddenNamesReloadIntervalMinutes);
            TimerCallback flush = new TimerCallback(ForbiddenNameList.FlushCache);
            _ReloadTimer = new Timer(flush, null, 0, reloadInterval * MSPERMIN);
        }

        public static void SettingsChanged(object sender, SettingChangeEventArgs e)
        {
            if(e.Setting != Setting.user_forbiddenNamesReloadIntervalMinutes)
                return;

            uint reloadInterval = UInt32.Parse(e.ValueNew);

            _ReloadTimer.Change(0, reloadInterval * MSPERMIN);
        }

        private static void MultiSettingsChanged(object sender, MultiSettingChangeEventArgs e)
        {
            if (e.MultiSetting == MultiSetting.user_forbiddenNamesExcludedTitles) {
                LoadExcludedTitles(e.ValueNew);
            }
        }

        private static void LoadExcludedTitles(string[] titleExclusions)
        {
            Dictionary<uint, string> excludedTitles = new Dictionary<uint, string>();
            uint titleId = 0;

            // add all the titles in the list of exclusions
            // it's okay if they list titles multiple times

            foreach (string s in titleExclusions) {
                try {
                    titleId = SafeConvert.ToUInt32(s);
                    if (! excludedTitles.ContainsKey(titleId)) excludedTitles.Add(titleId, null);
                }

                catch (Exception e) {
                  Xom.NtEvent(XEvent.Id.FORBIDDEN_NAMES_EXCLUDED_TITLES_CONFIG_ERROR, e,
                        "Error parsing title exclusion, '{0}'.", s
                    );
                }
            }

            // replace the existing set of excluded titles.  if we
            // incurred an error above then keep using the old set

            _excludedTitles = excludedTitles;
        }

        private static bool LoadForbiddenNames()
        {
            if ( _NeverReload == true )
            {
                Xom.Trace(XomAreaName.nametrace, LogLevel.L_HIGH, "ForbiddenNameList.Load: _NeverReload=true, returning now...");
                return false;
            }

            try
            {
                Hashtable emt = null;
                UnicodeCurseManager ucm = null;
                NewUnicodeCurseManager(out ucm, out emt);

                Xom.Trace(XomAreaName.nametrace, LogLevel.L_NORMAL, "ForbiddenNameList.Load: instantiated new UnicodeCurseManager (tablesize: " + ucm.TableSize + " bytes)...");
                Xom.NtEvent(XEvent.Id.FORBIDDEN_NAMES_LOAD_SUCCESS, "ForbiddenNamesList was successfully loaded.");

                // we never want to wipe out existing tables/mgrs
                // only do it if we have a  replacement table/mgr

                if (ucm != null) _CurseMgr = ucm;
                if (emt != null) _ExactMatchTable = emt;
            }

            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.FORBIDDEN_NAMES_LOAD_FAILURE, e, "ForbiddenNamesList failed to load! Allowing all names.");
                _NeverReload = true;
            }

            return _CurseMgr != null;
        }

        private static void NewUnicodeCurseManager(out UnicodeCurseManager ucm, out Hashtable emt)
        {
            StringCollection newSubWords = new StringCollection();
            StringCollection newExactWords = new StringCollection();

            using (SqlConnection conn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                conn.Open();

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "dbo.p_xuacs_get_forbidden_names";
                    cmd.CommandType = CommandType.StoredProcedure;

                    using (SqlDataReader r = cmd.ExecuteReader())
                    {
                        while(r.Read())
                        {
                            string str = r.GetString(0);
                            WordUsage flags = (WordUsage) r.GetInt32(1);

                            if ((flags & WordUsage.Substring) != 0)
                            {
                                newSubWords.Add(str);
                            }
                            else
                            {
                                newExactWords.Add(str);
                            }
                        }
                    }
                }
            }

            if (newSubWords.Count == 0 && newExactWords.Count == 0)
            {
                throw new XRLException(HResult.XONLINE_E_DATABASE_RESULT_ERROR, XEvent.Id.COMMON_CODE_209,
                    "Calling 'p_xuacs_get_forbidden_names " +
                    "returned 0 results!   (is the table populated?)");

            }

            Xom.Trace(XomAreaName.nametrace, LogLevel.L_INFO, "ForbiddenNameList.NewUnicodeCurseManager: loaded forbidden names: " + newSubWords.Count + " substring matches, " + newExactWords.Count + " exact matches.");

            //
            // In order to partially optimize the memory used by
            // the CurseMgr, first create an instance with only
            // the substring matches.  Go through each of the
            // exact matches and discard all of the exact matches
            // that would fail to vet due to a substring match.
            //
            // Finally, instantiate the actual CurseMgr instance
            // using the substrings.
            //
            // QFE to Fall07SP1:
            // Previously, exact matches were also loaded into the CurseMgr
            // instance. However, as the list of exact matches exploded in
            // size, the amount of contiguous memory required became
            // impractical without moving to x86 and so now exact matches
            // are vetted using a Hashtable.
            ucm = new UnicodeCurseManager();
            emt = new Hashtable();

            StringCollection emptyWordList = new StringCollection();
            ucm.Load( newSubWords, emptyWordList );

            StringCollection vettedExactWords = new StringCollection();
            string exactMatch = string.Empty;
            string substrMatch = string.Empty;

            foreach (string word in newExactWords)
            {
                if ( false == ucm.VetName(word, ref exactMatch, ref substrMatch) )
                {
                    Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "ForbiddenNameList.NewUnicodeCurseManager: discarding exact match: '" + word + "' vetted by substring: " + substrMatch + "...");
                }
                else
                {
                    bool[] wordBreaks = new bool[word.Length+1];
                    string flattenedWord = UnicodeCurseManager.Flatten(word, ref wordBreaks);
                    if ( emt[flattenedWord] == null )
                    {
                        emt.Add(flattenedWord, flattenedWord);
                    }
                }
            }

            Xom.Trace(XomAreaName.nametrace, LogLevel.L_INFO, "ForbiddenNameList.NewUnicodeCurseManager: newExactWords.Count: " + newExactWords.Count.ToString() + ", vettedExactWords.Count: " + emt.Count.ToString());

            return;
        }

        public static void FlushCache(object o)
        {
            Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "ForbiddenNameList.FlushCache: clearing forbidden name cache...");

            _NeverReload = false;
            LoadForbiddenNames();
        }

        public static void OnFlushCache(object o, EventArgs e)
        {
            Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "ForbiddenNameList.OnFlushCache: calling FlushCache...");

            FlushCache(o);
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                string cmd = args.Command.ToLower();
                switch (args.Command)
                {
                case "help":
                    XomControlConnection.SendMessage(
                        "ForbiddenNames help\r\n" +
                        " NameCacheFlush -- effectively flushes the cache of all forbidden names,\r\n" +
                        "                   forcing them to be reloaded from UODB.\r\n" +
                        " CurseMgrInfo   -- display some memory usage info for CurseMgr\r\n" +
                        " VetName        -- check a given string to see if it passes name vetting\r\n" +
                        "\r\n",
                        args.RequestId);
                    args.Handled = true;
                    break;
                case "cursemgrinfo":
                    if ( _CurseMgr != null )
                    {
                        string curseMgrInfo = "\r\n" +
                            "Allocated CurseMgr:\r\n" +
                            "  MaxStates: " + _CurseMgr.MaxStates + "\r\n" +
                            "  OutputSymbols: " + _CurseMgr.OutputSymbols + "\r\n" +
                            "  TableSize: " + _CurseMgr.TableSize + " bytes\r\n";

                        if ( _ExactMatchTable != null )
                        {
                            curseMgrInfo += "\r\n" +
                                "ExactMatchTable:\r\n" +
                                "  Count: " + _ExactMatchTable.Count + " items.\r\n";
                        }

                        curseMgrInfo += "\r\n";

                        XomControlConnection.SendMessage( curseMgrInfo, args.RequestId );
                    }
                    else
                    {
                        XomControlConnection.SendMessage( "No allocated CurseMgr instance.\r\n", args.RequestId );
                    }
                    args.Handled = true;
                    break;
                case "vetname":
                    if ( args.CommandArgs.Length == 0 )
                    {
                        XomControlConnection.SendMessage( "Usage: VetName <string>\r\n\r\n", args.RequestId );
                    }
                    else
                    {
                        string name = args.CommandArgs[0];
                        for (int i=1; i<args.CommandArgs.Length; i++)
                        {
                            name += " " + args.CommandArgs[i];
                        }

                        string exact = null;
                        string substr = null;

                        string notAllowedMsg = null;

                        bool allowed = ForbiddenNameList.VetName(name, ref exact, ref substr);

                        if ( !allowed )
                        {
                            notAllowedMsg = "not allowed due to: " + (substr == null ? ("exact match '" + exact + "'") : ("substring '" + substr + "'"));
                        }
                        string msg = "string: '" + name + "': " + (allowed ? "allowed" : notAllowedMsg) + "\r\n";

                        XomControlConnection.SendMessage( msg, args.RequestId );
                    }
                    args.Handled = true;
                    break;

                case "namecacheflush":
                    FlushCache(null);
                    XomControlConnection.SendMessage("Forbidden name cache flushed.\r\n", args.RequestId);
                    args.Handled = true;
                    break;
                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\nameutil\NounList.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;

namespace xonline.common.user
{
    public class NounList : StringCollection
    {

        // CreateInstance
        //
        //      returns a cached instance of the object.
        //
        public static NounList CreateInstance(ushort countryId)
        {
            Hashtable lists = _lists;
            
            if (lists.ContainsKey(countryId))
            {
                return (NounList) lists[countryId];
            }

            NounList list = new NounList(countryId);
            lists[countryId] = list;

            return list;
        }

        private static Hashtable _lists = new Hashtable();

        static NounList()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(NounList.OnControlRequest);
        }

        public static void OnFlushCache(object o, EventArgs e)
        {
            _lists = new Hashtable();
        }




        private Random _rand;


        //
        // ctor
        //
        //      normally doing any real work in the
        //      constructor is discouraged, but given this object
        //      will be created once, cached, and used by many readers, the
        //      thread saftey of the ctor makes it the ideal place to do
        //      initialization.
        //
        private NounList(ushort countryId)
        {
            using (SqlConnection conn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                conn.Open();

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "dbo.p_xuacs_get_noun_suggestions";
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add("@ti_country_id", SqlDbType.TinyInt).Value = (byte) countryId;

                    SqlParameter ret = cmd.CreateParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);

                    using (SqlDataReader r = cmd.ExecuteReader())
                    {
                        while (r.Read())
                        {
                            string str = r.GetString(0);

                            this.Add(str);
                        }
                        r.Close();

                        HResult hr = (uint) ((int) ret.Value);
                        if (HResult.Failed(hr))
                        {
                            throw new XRLException(hr, XEvent.Id.COMMON_CODE_212,
                                "Calling p_xuacs_get_noun_suggestions {0} returned 0 results!", countryId);
                        }
                    }
                }
            }

            _rand = new Random();
        }


        public string RandomItem()
        {
            Debug.Assert(_rand != null);
            return base[_rand.Next(this.Count)];
        }


        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                string cmd = args.Command.ToLower();
                switch (args.Command)
                {
                    case "help":
                        XomControlConnection.SendMessage(
                            "NounList help\r\n" +
                            "    NounCacheFlush -- flushes nounlist.  NounList will reload on first use\r\n" +
                            "\r\n",
                            args.RequestId);
                        args.Handled = true;
                        break;

                    case "nouncacheflush":
                        NounList.OnFlushCache(sender, args);
                        XomControlConnection.SendMessage("NounList flushed.\r\n", args.RequestId);
                        args.Handled = true;
                        break;
                }
            }
            catch (Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\plugins\PluginUtil.cs ===
using System;
using System.Collections;
using System.IO;
using System.Xml;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;


namespace xonline.common.plugins 
{
    public class PluginUtil
    {
        public static string GetThisAssemblyFileName()
        {
            return Path.GetFileName(Config.AssemblyPath);
        }            
        
        static bool _loggingInit = false;
        
        public static void InitLogging()
        {
            if (_loggingInit == true) return;

            lock(typeof(PluginUtil))
            {
                if (_loggingInit == true) return;
            
                XomLoggingControl.Init();

                _loggingInit = true;
            }
        }
        
    
        public const string TYPE_STRING = "string";
        public const string TYPE_NUMERIC = "number";
        public const string TYPE_BINARY = "binary";
        public const string TYPE_DATE = "date";
        
        
        public static string HashtableToXml(Hashtable h)
        {
            object val;
            StringWriter stream = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(stream);
            
            writer.Formatting = Formatting.Indented;
            
            writer.WriteStartElement("PluginContext");
            
            
            foreach (object key in h.Keys)
            {
                writer.WriteStartElement("attribute");
                
                if (!(key is string))
                {
                    throw new Exception("key of type " + key.GetType().ToString() + " detected!  Only string keys can be used.");
                }
                
                writer.WriteAttributeString("name", (string)key);
                
                
                val = h[key];
                if (val is string)
                {
                    writer.WriteAttributeString("type", typeof(string).ToString());
                    writer.WriteString((string)val);
                }
                else if (val is byte[])
                {
                    writer.WriteAttributeString("type", typeof(byte[]).ToString());
                    writer.WriteString(ByteConvert.ToString((byte[])val));
                }
                else
                {
                    // only System* classes are allowed, to ensure we can recreate it on the cron end
                    if (!val.GetType().ToString().StartsWith("System"))
                    {
                        throw new Exception("Cannot convert type " + val.GetType().ToString() + " to hashtable!  Use a type that starts with System.*");
                    }
                        
                    writer.WriteAttributeString("type", val.GetType().ToString());
                    writer.WriteString(Convert.ToString(Convert.ChangeType(val, val.GetType())));
                }
                
                writer.WriteEndElement();
            }
            
            writer.WriteEndElement();
            
            writer.Flush();
            writer.Close();
            return stream.ToString();
            
        }
        
        /// <summary>
        /// Parses a given XML and converts all "attribute" xml elements into a hashtable which is returned
        /// </summary>
        /// <param name="xml">XML to convert, sample is as follows:
        ///     <PluginContext><attribute name=\"totalbuckets\" type=\"System.Int32\">3</attribute> <attribute name=\"bucketnumber\" type=\"System.Int32\">0</attribute></PluginContext>
        /// </param>
        /// <returns>Hashtable with each attribute element pulled out and placed in the hashtable</returns>
        public static Hashtable XmlToHashtable(string xml)
        {
            StringReader stream;
            XmlTextReader reader;
            Hashtable hash = new Hashtable();
            
            string xmlname;
            string xmltype;
            string xmlvalue;
            
            if (xml != null && xml != "")
            {
                stream = new StringReader(xml);
                reader = new XmlTextReader(stream);

                while (!reader.EOF)
                {
                    if (reader.NodeType != XmlNodeType.Element)
                    {
                        reader.Read();
                        continue;
                    } else if (reader.Name == "PluginContext")
                    {
                        reader.Read();
                        continue;
                    }
                    else if (reader.Name == "attribute")
                    {
                        xmlname = reader["name"];
                        xmltype = reader["type"];
                        xmlvalue = reader.ReadElementString();

                        if (xmltype == typeof(string).ToString())
                        {
                            hash.Add(xmlname, xmlvalue);
                        }
                        else if (xmltype == typeof(Int32).ToString())
                        {
                            hash.Add(xmlname, Int32.Parse(xmlvalue));
                        }
                        else if (xmltype == typeof(byte[]).ToString())
                        {
                            hash.Add(xmlname, ByteConvert.FromString(xmlvalue));
                        }
                        else
                        {
                            hash.Add(xmlname, Convert.ChangeType(xmlvalue, Type.GetType(xmltype)));
                        }
                    }                                       
                }    
            }    
            
            return hash;
        }
    }
    
    public class PluginException : XRLException
    {
        protected static string GetMsgHeader()
        { 
            return "Plugin Assembly: " + PluginUtil.GetThisAssemblyFileName() + "\r\n---------------\r\n";
        }    

        public PluginException(HResult hr, string message) : base(hr, XEvent.Id.MC_PLUGIN_ERROR_1, GetMsgHeader() + message)
        {
        }
        
        public PluginException(HResult hr, XEvent.Id eventId, string message) : base(hr, eventId, GetMsgHeader() + message)        
        {
        }
        
        public PluginException(HResult hr, XEvent.Id eventId, string message, Exception innerException) : base(hr, eventId, GetMsgHeader() + message, innerException)        
        {
        }
        
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\installer\XomConfigurator.cs ===
/*

Configurator base class

To incorporate IIS configurator support into your front door, mark the
assembly with a XomIisInstallerAttribute 


    [assembly: XomIisInstallerAttribute( Interface.my_interface_name )]


Then add the new Interface enum values to \private\common\config\CommonConfigEnum.cs file.
Then ensure that the configDB initialization script is updated to configure the interface
correctly (correct Port, siteID, impersonation, etc

*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration.Install;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Threading;
using System.Management;
using System.DirectoryServices;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Xml;
using System.Text;
using System.Net;
using Microsoft.Win32;
using Microsoft.Web.Administration;

using xonline.common.service;
using xonline.common.config;
using xonline.common.wmi.iisv2;


namespace xonline.common.installer 
{
    public class XomInterfaceConfigurator
    {
        // See MSDN info on Win32_ACE.AccessMask for details on the assignment
        // of these bit flags
        //
        protected const FileSystemRights        FOLDER_DACL_READEXEC = FileSystemRights.ReadAndExecute;
        protected const FileSystemRights        FOLDER_DACL_MODIFY   = FileSystemRights.Modify;

        private     InstallContext                context;


        protected   string                        interfaceKey;
        protected   IInterfaceInfo                interfaceinfo             = null;
        protected   string                        serverName                = null;
        protected   string                        asmPath                   = null;
        protected   string                        iisLogPath                = null;
        protected   Assembly                      assembly                  = null;

        // determine if our exception is due to attempting to add member to a
        // group to which he already belongs
        
        private bool IsMemberInAliasException(Exception e) {
            const int       ERROR_MEMBER_IN_ALIAS = unchecked( (int)0x80070562 );
            COMException    com;

            com = e.InnerException as COMException;
            
            return null != com && com.ErrorCode == ERROR_MEMBER_IN_ALIAS;
        }

        // add a user to a group on the local machine.  if the user is null or empty no action
        // is taken.

        public void AddGroupMember(string group, string user) {
            DirectoryEntry localMachine;
            DirectoryEntry groupEntry;
            object[]       args;

            if (null == group)
                throw new ArgumentNullException("group");
                
            if (string.IsNullOrEmpty(user))
                return; //nothing to do

            try {
                // get the directory entry associated with the local machine
                localMachine = new DirectoryEntry("WinNT://" + Config.Server);

                // get entry for group specific group
                groupEntry = localMachine.Children.Find(group, "Group");

                // group membership add parameters (just the formatted user name)
                args = new object[] { "WinNT://" + user.Replace('\\', '/') }; 
                
                try { 
                    groupEntry.Invoke("Add", args);
                    
                    LogMessage(string.Format("User successfully '{0}' added to '{1}' group", user, group));
                }
                catch (TargetInvocationException e) {
                    if (!IsMemberInAliasException(e))
                        throw;
                }
             }
             catch (Exception e) {
                throw new ApplicationException(string.Format("Failed to add '{0}' to '{1}' group.", user, group), e);
             }           
        }
        
        public virtual bool Commit(IDictionary stateSaver)
        {
            return false;
        }
        

        public virtual bool UnCommit(IDictionary stateSaver)
        {
            return false;
        }

        
        public string InterfaceKey
        {
            get { return interfaceKey; }
            set { interfaceKey = value; }
        }

        public Assembly Assembly
        {
            get {
                if (assembly != null) return assembly;
                return Config.Assembly;
            }

            set { assembly = value; }
        }

        public string ServerName
        {
            get
            {
                // $REVIEW (michion): this _WILL_ break on clustered servers.  MSDN says it only returns physical node names
                if (serverName == null)
                    serverName = Config.Server;
    
                return serverName;
            }
        }

        public string AsmPath
        {
            get
            {
                if (asmPath == null)
                {
                    asmPath = Directory.GetParent(assembly.Location).FullName;
                }
    
                return asmPath;
            }
        }

        public IInterfaceInfo Interface
        {
            get
            {
                if (interfaceinfo == null)
                    interfaceinfo = Config.GetInterface(ServerName, interfaceKey);
    
                return interfaceinfo;
            }
        }


        public string IislogPath
        {
            get
            {
                if (iisLogPath == null)
                    iisLogPath = Config.GetSetting(Setting.setup_logroot) + "\\iis";
    
                return iisLogPath;
            }
        }


        public InstallContext Context
        {
            get
            {
                if (context == null)
                {
                    // $REVIEW (michion): Throw an exception?
                }

                return context;
            }
            set
            {
                context = value;
            }
        }



        protected static void SetSystemTempFolderACL(string sDomainUser, FileSystemRights rights)
        {
            try
            {
                if (sDomainUser != null && sDomainUser.Length > 0)
                {
                    // Get the system environment variables, to get at the TEMP and TMP folder paths
                    RegistryKey rk       = Registry.LocalMachine;
                    RegistryKey rkSysEnv = rk.OpenSubKey("system\\currentcontrolset\\control\\session manager\\environment");
                    
                    if (rkSysEnv.GetValue("TEMP") != null)
                    {
                        DirectorySecurity s = Directory.GetAccessControl(rkSysEnv.GetValue("TEMP").ToString());
                        s.AddAccessRule(new FileSystemAccessRule(sDomainUser, rights, AccessControlType.Allow));
                        Directory.SetAccessControl(rkSysEnv.GetValue("TEMP").ToString(), s);
                    }
                    
                    if (rkSysEnv.GetValue("TMP") != null)
                    {
                        DirectorySecurity s = Directory.GetAccessControl(rkSysEnv.GetValue("TMP").ToString());
                        s.AddAccessRule(new FileSystemAccessRule(sDomainUser, rights, AccessControlType.Allow));
                        Directory.SetAccessControl(rkSysEnv.GetValue("TMP").ToString(), s);
                    }
                }
            }
            catch (System.Exception e)
            {
                Console.WriteLine("ERROR setting temp folder permissions: " + e.ToString()); 
            }

            return;
        }



        protected virtual void AddEventLogRegkeyAccess(string target)
        {
            RegistryKey rk = Registry.LocalMachine.OpenSubKey( "System\\CurrentControlSet\\Services\\Eventlog", true);
            RegistrySecurity rs = rk.GetAccessControl();
            RegistryAccessRule rule = new RegistryAccessRule(
                                                             target,
                                                             RegistryRights.SetValue | RegistryRights.CreateSubKey, 
                                                             InheritanceFlags.ContainerInherit, 
                                                             PropagationFlags.None, 
                                                             AccessControlType.Allow
                                                            );

            rs.AddAccessRule(rule);
            rk.SetAccessControl(rs);
        }


        public void LogMessage(String message)
        {
            String stampedMessage = String.Format("[{0:dd-MM-yyyy HH:mm:ss.fff}] {1}", DateTime.Now, message).
                Replace("\n", "\n                             ");

            Context.LogMessage(stampedMessage);
        }

        public void LogMessage(String message, Object[] args)
        {
            String formattedMessage = String.Format(message, args);

            LogMessage(message);
        }
    }
    




    public class XomIisConfigurator  :  XomInterfaceConfigurator
    {
        /// siteId --    The ID number associated with the VSite for the application.
        ///              Since IIS 6.0 no longer requires sequential site numbering, 
        ///              we use the service ID + xxxx as the site ID in order to 
        ///              be able to routinely identify sites programmatically.
        ///
        /// siteName --  The name to assign to the VSite's ServerComment attribute.
        ///              This is essentially an administrative name that has no
        ///              bearing on the actual functioning of the service.
        ///              For XBL services, this is normally configured as a 
        ///              the name of the service.
        ///
        /// sitePath --  The directory associated with the \ROOT Vdir created 
        ///              for the VSite.  For XBL services, this is normally
        ///              irrelevant because most front door services access
        ///              their functionality off of a non-default VDIR (non-Root)
        ///              explicitly created for the service.  As such we 
        ///              typically lock down the functionality of the VSite to
        ///              minimize its attack surface area
        ///
        /// vdirName --  The name to assign to the virtual directory for the service.
        ///              For most XBL services (webcache widgets excluded) the service
        ///              name is generally used (IE XBOS front doors have VDirs called
        ///              XBOS, etc).  This setting is important in that the client 
        ///              libraries are coded to make their requests (through the SG)
        ///              to these XRLS, so variations here must take into consideration
        ///              backwards compatibility
        ///
        /// vdirPath --  The physical directory path to associate with the virtual
        ///              directory for the service.
        ///
        ///
//        private bool                           isSSL                   = false;

        private bool                           loadUserProfile         = true;
        private int                            siteId                  = 0;
        private string                         siteName                = null;
        private string                         sitePath                = "";
        private string                         vdirName                = null;
        protected string                       vdirPath                = "";
        private string                         impersonateUser         = null;
        private string                         impersonatePass         = null;
        private ManagementScope                iisManagementScope      = null;
        private ManagementBaseObject[]         serverBindings          = null;
    
        protected const int                    DEFAULT_REQUEST_QUEUE_LENGTH = 1000;

        //  This section defines member variables which control various VSite and VDir
        //  characteristics.  These are defaulted to values considered to be the ones
        //  most commonly used for XBL front door services.  When appropriate, these
        //  values should be overriden (or hidden?) by a derived class to effect 
        //  different configurations
        //
        // the prefixes used here are used to identify the object (VSite or VDir) that 
        // are affected 

        protected bool                            vdirAccessExecute         = false;
        protected bool                            vdirAccessRead            = true;
        protected bool                            vdirAccessWrite           = false;
        protected bool                            vdirAccessSource          = false;  // Script source access
        protected bool                            vdirAccessScript          = true;   // Controls whether scripts may execute (Execute Permissions drop down)

        protected bool                            vdirAnonymousPasswordSync = false;  // $REVIEW (michion): this disabled IIS5 control of the anonymous pwd, but that ui is gone in IIS6?

        protected bool                            vdirBasicAuth             = false;  
        protected bool                            vdirMD5Auth               = false;
        protected bool                            vdirNTLMAuth              = false;
        protected bool                            vdirPassportAuth          = false;  // $REVIEW (michion): UI enforces exclusion of other  types with the selection of this


        protected int                             vdirBrowseFlags           = 0x3E;   




        /// <summary>
        /// This method is the 'top-level' Function that is responsible for performing any actions
        /// that the configurator needs to do in order to create the interface that it is designed
        /// to manage.
        ///
        /// In this case, since the configuration is the IIS configurator, it will create the IIS
        /// Virtual Site (VSite) and Virtual Directory (VDir) for the application.
        ///
        ///  Site Id
        ///  Site Name (?)
        ///  IP:PORT bindings
        ///
        /// </summary>
        public override bool Commit(IDictionary stateSaver)
        {
            string keyName = "W3SVC/" + SiteId.ToString();
            
            bool            exists   = false;
            ArrayList       conflicts = null;
            
            
            //-------------------------------------------------------------------------
            // Because some configurators create site\root level applications, we need
            // to create any application pools that they may need before we start
            // calling CreateVSite (which is where the root VDir and application would
            // be created).
            //
            CreateAppPool();
            

            //-----------------------------------------------------------------
            // CheckSiteExists() does a simple check to see if the site ID we
            // are supposed to use is already in use....
            //
            exists = CheckSiteExists();


            //-----------------------------------------------------------------
            // CheckSiteBindings() is a little more complex.  It scans through
            // the Server and Secure bindings of all IIS sites on this server
            // and compares them to the IP:Port binding that this interface
            // is supposed to occupy.  If there are conflicts, it records the
            // metabase path of the object and returns that list in an ArrayList
            //
            conflicts = CheckSiteBindings();



            if (!exists)
            {
                switch (conflicts.Count)
                {
                    case 0:     
                        //-------------------------------------------------------------------------
                        // Easy! no existing site and no conflicts.  Just create the site a we're
                        // done
                        //
                        CreateVSite();
                        break;


                    case 1:
                        //-------------------------------------------------------------------------
                        // Bad.  We want to create a new site but someone already has this binding
                        // in another site.  This is indicative of a configuration error
                        //
                        LogMessage("Error: Site bindings for " + keyName + " conflict with an existing site");
                        break;


                    default:
                        //-------------------------------------------------------------------------
                        // Really bad.  Not only does someone else have the binding we want, but 
                        // more than one site actually does, which means that there's already one
                        // site that isn't going to start even when we bail out here without doing
                        // anything (E.G.  It was broken before we got started)
                        //
                        LogMessage("Error: Site bindings for " + keyName + " conflict with MULTIPLE existing sites");
                        break;
                }
            }
            else
            {
                switch (conflicts.Count)
                {
                    case 0:     
                        //-------------------------------------------------------------------------
                        // The site we want to use exists but apparently doesn't have the binding
                        // that we want to use.  We're clear to add it to the existing site though
                        // because the binding isn't in use anywhere else
                        //
                        UpdateVSite();
                        break;


                    case 1:
                        if ((string)conflicts[0] == keyName)
                        {
                            //-------------------------------------------------------------------------
                            // The 'conflict' is actually with the site we want to expose the interface
                            // on, so this is actually OK.   In fact it means that the site already
                            // exposees the binding we want, so we don't have any site work to perform
                            //
                            //
                        }
                        else
                        {
                            //-------------------------------------------------------------------------
                            // The conflict is real because the binding we want is already on some other
                            // site.  This is indicative of a configuration error
                            //
                            LogMessage("Error: Additional Site bindings for " + keyName + " are already in use on an another site");
                        }
                        break;


                    default:
                        //-------------------------------------------------------------------------
                        // Really bad.  Not only does someone else have the binding we want, but 
                        // more than one site actually does, which means that there's already one
                        // site that isn't going to start even when we bail out here without doing
                        // anything (E.G.  It was broken before we got started)
                        //
                        LogMessage("Error: Site bindings for " + keyName + " conflict with MULTIPLE existing sites");
                        break;
                }
            }


            //-------------------------------------------------------------------------
            // Nothing fancy here, just create the VDir as specified
            // NOTE: If the VDir name is duplicated in two interfaces, this code does
            //       not currently perform any fancy merging as we do for sites.  It
            //       ends up being a simple case of last-one-wins
            //
            // $REVIEW (michion): Is there value in writing a VDir merge?
            //
            //
            CreateVDir();


            //-------------------------------------------------------------------------
            // Before we start up the site, fixup the .NET machine.config file with
            // some values more agreeable to our service
            //
            EditMachineConfig();

            //-------------------------------------------------------------------------
            // IIS6 create new sites in a stopped state.  So we have to go kick the 
            // site to get it running.
            //
            // $REVIEW (michion):  Is this a problem if we have VSite updates and 
            //                     VDir build/rebuilds going on while the site is still
            //                     active?
            //
            // $REVIEW (michion):  We could make this synchronous and wait for the 
            //                     state to go to running... that would be good for
            //                     identifying config errors that prevent the site from
            //                     running (though binding conflicts should already
            //                     be handled by us...)
            //
            StartVSite();

            return true;
        }
        




        public override bool UnCommit(IDictionary stateSaver)
        {
            // For now, we're going to do this the dumb way and just look for a matching siteId
            // Eventually this should be done by scanning through ALL the sites and checking 
            // the bound IP/Ports on them... 
            //

            string keyName = "W3SVC/" + SiteId;
            string vDirName = keyName + "/root/" + VdirName;

            DeleteVDir(vDirName);

            IIsWebServer.IIsWebServerCollection sites = IIsWebServer.GetInstances();
            foreach(IIsWebServer aSite in sites)
            {
                if (String.Compare(aSite.Name, keyName, true) != 0) continue;

                bool foundVdir = false;

                foreach(ManagementObject siteRelatedObject in aSite.GetRelated())
                {
                    //  The first vdir we find will be W3SVC/<num>/root.  The 'real' vdirs 
                    //  will be related/nested under this one.

                    if (siteRelatedObject.ClassPath.ClassName != "IIsWebVirtualDir") continue;

                    foreach(ManagementObject rootRelatedObject in siteRelatedObject.GetRelated())
                    {
                        if(rootRelatedObject.ClassPath.ClassName != "IIsWebVirtualDir") continue;
                        foundVdir = true;
                        break;
                    }

                    if(foundVdir) break;
                }

                //  Didn't find any virtual directories remaining, so it should
                //  be safe to remove the web site and the app pool.

                if (!foundVdir)
                {
                    DeleteVSite();
                }

                break;
            }
            
            DeleteAppPool();

            return true;
        }







        protected virtual IIsWebServerSetting CreateVSite()
        {
            ManagementScope mScope = IisManagementScope;

            string keyName = "W3SVC/" + SiteId.ToString();

            LogMessage("Creating VSite for " + keyName);


            //-----------------------------------------------------------------
            // This call is designed to check to ensure that the root metabase
            // node is configured to use the current version of ASP.NET for
            // newly created child nodes.  If the root node is not correctly
            // set it will force the 'installation' of the new version of 
            // ASP.NET using the aspnet_regiis.exe -i.  This will result in
            // an IISRESET as the utility completes its work, but once this
            // is done, subsequent calls will only check and confirm that the
            // version on the root node is correct (and not call regiis).
            // In addition, all subsequent Sites/Vdirs created will 'inherit'
            // the ASP.NET version which means that we won't have to call
            // aspnet_regiis.exe on them either (which means we don't invoke
            // any IISRESETs during subsequent setups --- a good thing for QFE
            // stories)
            //
            SetDotNetVersionOnVSite(null);
            

            if (!Directory.Exists(SitePath))
            {
                Directory.CreateDirectory(SitePath);
            }
    
            
            //-----------------------------------------------------------------
            // VSites are created using the IIsWebService object
            //
            IIsWebService webService = new IIsWebService(mScope, "W3SVC");
            webService.CreateNewSite(SitePath, ServerBindings, SiteName, SiteId);

            //-----------------------------------------------------------------
            // WMI tries to be nice and creates the /ROOT vdir for us 
            // automatically, but unfortunately, it is configured as an 
            // application as well.  Since we don't want things happening at
            // the root, we're going to neuter that  application immediately
            //
            IIsWebVirtualDir vDirObj = new IIsWebVirtualDir(mScope, keyName + "/root");
            vDirObj.AppDelete(true);


            //-----------------------------------------------------------------
            // Set some basic defaults on the site's VDir to ensure that the 
            // children can't default to anything bad
            //
            IIsWebVirtualDirSetting vDirSet = new IIsWebVirtualDirSetting(mScope, keyName + "/root");
            vDirSet.EnableDefaultDoc = false;
            vDirSet.DefaultDoc = "";
            vDirSet.CommitObject();


            

            //-----------------------------------------------------------------
            // I really really really hate WMI... this is cryptic enough in ADSI
            // (for some reason .Clear() does something different from looping
            // and calling .RemoveAt()), but at least this works.  By clearing
            // this out at the site object, the deletion should be 'inherited'
            // all the way down to the vdirs
            //
            DirectoryEntry site = new DirectoryEntry ("IIS://localhost/w3svc/" + SiteId.ToString());

            int cOldHeaders = site.Properties["HttpCustomHeaders"].Count;
            for (int idx = cOldHeaders-1; idx >= 0 ; idx--)
            {
                site.Properties["HttpCustomHeaders"].RemoveAt(idx);
            }

            site.Properties["LogFileDirectory"][0]  = IislogPath;
            site.Properties["LogFilePeriod"]   [0]  = "4";                  // 1=daily, 4=hourly rollover

            site.CommitChanges();




            //-----------------------------------------------------------------
            // Update this site to the correct version of .NET
            //
            SetDotNetVersionOnVSite(keyName);




            //-----------------------------------------------------------------
            // Now get the vSite object for return to the caller
            //
            IIsWebServerSetting vSite = new IIsWebServerSetting(mScope, keyName);

            return vSite;
        }




        //-----------------------------------------------------
        // This method shells out to aspnet_regiis.exe to set
        // the correct .NET version on a VSite.
        //
        // If keyName is supplied as null, then this method will check
        // the ASP.NET version on the metabase root node and reset it
        // so that all subsequent sites that are created with the correct
        // version.  This approach isn't perfect since it will result 
        // in an IIS reset the one (and only) time this version 
        // discrepancy is detected, 
        //  
        protected virtual void SetDotNetVersionOnVSite(string keyName)
        {
            // Xenon#119011
            // Here's the thing:  ASP.NET 2.0 installations are designed to be... nice
            // in that they don't reset the W3SVC root metabase node to use ASP.NET 2.0
            // (which would affect any sites/subnodes that might be inheriting their
            // setting rather than explicitly specifying which version of ASP.NET they 
            // use).  So what you end up with, is an IIS configuration that defaults to 
            // creating sites using the old v1.1.4322 of ASP.NET, even after installing 2.0
            // This isn't a problem, per se, since we can use aspnet_regiis.exe to set 
            // the ASP.NET version for any metabase subtree.  The complication comes from
            // aspnet_regiis.exe and it's propensity to perform W3SVC restarts when
            // you tweak a site (EG change it's ASP.NET version from v1.1 to v2.0).  We
            // want to avoid an IIS reset as much as possible (since it affects all
            // other IIS based services on a machine), so we'll put a simple check here
            // to determine if our default setting will require adjustment or not.

            // $REVIEW (michion): We _could_ error out here rather than perform an IIS reset
            //                    but this approach favors setup resiliancy over an accidental
            //                    IIS reset.... maybe this needs to be an OPS decision

            RegistryKey rk       = Registry.LocalMachine;
            RegistryKey rkSysEnv = rk.OpenSubKey("SOFTWARE\\Microsoft\\ASP.NET");


            // If we can't pull the ASP.NET node or version, the best we can do is
            // assume we have to manually (aspnet_regiis) set the ASP.NET version
            // on the site
            //
            if (rkSysEnv != null && rkSysEnv.GetValue("RootVer") != null)
            {
                // This is rich... the RTE and registry hold the .NET version in different formats...

                Version aspnetver = new Version(rkSysEnv.GetValue("RootVer").ToString());               // example value: "2.0.50727.0"
                Version clrver    = new Version(RuntimeEnvironment.GetSystemVersion().Substring(1));    // example value: "v2.0.50727"
                
                // Great... so the Version class can't do an equality check because the CLR version doesn't include a revision
                // which, I guess, sets the value to NULL and doesn't allow a match to a revision == 0.  So we do it the 
                // tedious way...
                //
                if ((aspnetver.Major == clrver.Major)  && (aspnetver.Minor == clrver.Minor) && (aspnetver.Build == clrver.Build))
                {
                    // We appear to have our root metabase node configured with the
                    // current version (IE matching the CLR).  So we should be
                    // able to bypass any aspnet_regiis activities and thereby
                    // avoid any IISReset activity.  Home, James!
                    return;
                }
            }
            else
            {
                LogMessage("ERROR: Unable to access REGKEY to determine default ASP.NET version, assuming a mismatch and calling aspnet_regiis.exe");
            }



            //
            //  First get the path to aspnet_regiis.exe
            //

            string exePath = Path.Combine(RuntimeEnvironment.GetRuntimeDirectory(), "aspnet_regiis.exe");
            if (!File.Exists(exePath))
            {
                LogMessage("File not found: " + exePath);
                return;
            }

            //
            //  Construct command line
            //

            string parms;

            if (keyName == null)
            {
                // According to the v2.0 usage, the -i parm is the correct one to reconfigure IIS to default to ASP.NET v2.0, but when you try to downgrade
                // a server to v1.1 using -i, it doesn't work.  That's probably something specific with downgrading, so I think using -i in the upgrade
                // case here is safe.  That's what I think....
                //
                parms = "-i";
                LogMessage("WARNING: Root metabase node is not configured for the current ASP.NET version.  This will be corrected and an IISRESET will occur");
            }
            else
            {
                parms =  "-s " + keyName;
                LogMessage("WARNING: Metabase defaulting is not in place!  (WHY?) Using aspnet_regiis to explicitly configure " + keyName);
            }

            ProcessStartInfo startInfo = new ProcessStartInfo(exePath, parms);
            startInfo.CreateNoWindow = true;
            startInfo.LoadUserProfile = true;
            Process p = Process.Start(startInfo);
            p.WaitForExit();

            return;
        }    




        protected virtual IIsWebServerSetting UpdateVSite()
        {
            ManagementScope mScope = IisManagementScope;

            int     idx       = 0;
            string  keyName   = "W3SVC/" + SiteId.ToString();
            
            LogMessage("Modifying VSite bindings for " + keyName);


            IIsWebServerSetting     vSite       = new IIsWebServerSetting(mScope, keyName);
            ManagementBaseObject[]  newBindings = null;


            if (vSite.ServerBindings != null)
            {
                newBindings = new ManagementBaseObject[vSite.ServerBindings.Length + 1];

                for (idx=0; idx < vSite.ServerBindings.Length; idx++)
                {
                    newBindings[idx] = vSite.ServerBindings[idx];
                }
            }
            else
            {
                idx = 0;
                newBindings = new ManagementBaseObject[1];
            }


            newBindings[idx]  = ServerBindings[0];

            vSite.ServerBindings = newBindings;

            return vSite;
        }
        



        

    
        protected virtual IIsWebVirtualDirSetting CreateVDir()
        {
            ManagementScope mScope = IisManagementScope;

            string keyName = VdirKeyName;

            if (VdirName == null || VdirName.Length == 0)
            {
                // If the VdirName property is returning null, we really don't want to be trying to 
                // create a metbase object wiht a key from that.  We're just going to bail without
                // any theatrics as certain types of configurators (DL/XTOU) will do this intentionally
                //
                return null;
            }

            LogMessage("Creating VDir bindings for " + keyName);

            DeleteVDir(keyName);
    
            if (!Directory.Exists(VdirPath))
            {
                Directory.CreateDirectory(VdirPath);
            }
    


            // NOTE: This was exceedingly painful to figure out... but it seems that
            //       since the IIsWebVirtualDir object is 'read-only', it has to be
            //       the one used to create a new instance.... i think...

            // $REVIEW (michion): For now, were going to recycle the site name
            // for the AppPool that we associate with this vdir application.  Ideally
            // in the future we will make this configurable from the configdb

            IIsWebVirtualDir virtualDir = IIsWebVirtualDir.CreateInstance();
    
            virtualDir.LateBoundObject["Name"] = keyName;
            virtualDir.CommitObject();



            //-----------------------------------------------------------------
            // AppCreate works much better if called after CommitObject()... if
            // called beforehand, it ends up missing important properties like
            // AppRoot!
            //
            virtualDir.AppCreate3(2, AppPoolName, false);   // 2 = Pooled

            
    
            //=================================================================
            // Configure the Virtual Directory
            //=================================================================
            IIsWebVirtualDirSetting vDirSet = new IIsWebVirtualDirSetting(mScope, keyName);
    
            vDirSet.AppFriendlyName = VdirName + " Application";
            vDirSet.Path0          = VdirPath;
            vDirSet.AccessExecute  = vdirAccessExecute;
            vDirSet.AccessRead     = vdirAccessRead   ;
            vDirSet.AccessWrite    = vdirAccessWrite  ;
            vDirSet.AccessSource   = vdirAccessSource ;
            vDirSet.AccessScript   = vdirAccessScript ;
            
            // $REVIEW (michion): isn't this redundant with the Access* flags?
            vDirSet.AccessFlags = 0x0201;
            vDirSet.DirBrowseFlags = vdirBrowseFlags;

            if (ImpersonateUser.Length > 0)
            {
                vDirSet.AuthAnonymous         = true;
                vDirSet.AnonymousUserName     = ImpersonateUser;
                vDirSet.AnonymousUserPass     = ImpersonatePass;
                vDirSet.AnonymousPasswordSync = vdirAnonymousPasswordSync;
            }

            vDirSet.AuthBasic        = vdirBasicAuth;
            vDirSet.AuthMD5          = vdirMD5Auth;
            vDirSet.AuthNTLM         = vdirNTLMAuth;
            vDirSet.AuthPassport     = vdirPassportAuth;

            vDirSet.CommitObject();
    
    


            return vDirSet;
        }
    
    


        protected virtual void StartVSite()
        {
            ManagementScope mScope = IisManagementScope;

            string  keyName = "W3SVC/" + SiteId.ToString();
            
            IIsWebServer     vSite       = new IIsWebServer(mScope, keyName);

            try
            {
                vSite.Start();
            }
            catch (System.Exception e)
            {
                // Any misconfiguration of the site can result in exceptions
                // being thrown when we try to start the site. 
                LogMessage("ERROR: Exception thrown when site " + keyName + " was started: " +  e);
            }

            return;
        }
        


        protected  virtual void CreateAppPool()
        {
            bool            fExists = false;
            ManagementScope mScope = IisManagementScope;

            string  keyName = "W3SVC/AppPools/" + AppPoolName;
            
            LogMessage("Creating AppPool for: " + AppPoolName);

            //--------------------------------------------------------------------
            // IIS 6 requires that in order for an Application Pool to run under
            // an identity, that account must be a member of the local machine's
            // IIS_IUSRS local group.  Regardless of the state of the App Pool 
            // itself, we'll modify the local group.
            //
            // $REVIEW (michion): we don't reverse this due to reference counting issues
            // $REVIEW (michion): this code has the potential to be optimized by
            //                    only executing the group.Invoke if the group membership
            // actually needs to be modified.  Unfortunately, I can't figure out an
            // easy way to test this.  The WindowsPrincipal.IsInRole() code will do this
            // exact test, but in order to create a WindowsIdentity for the user being
            // tested, you have to format the name in UPN format
            // (E.G. michion@redmond.corp.microsoft.com and note that michion@microsoft.com 
            // does NOT appear to be sufficient).  So that seems to me like it would require
            // an AD lookup which seems like we're adding potentially slow code in order
            // to speed up other code.  Not to mention that XBLOB accounts, being
            // local machine, would probably not work the same way either...
            //
            if (PoolImpersonate && ImpersonateUser.Length > 0)
            {
                if (!CheckIfUserIsMemberOfLocalGroup(ImpersonateUser, ImpersonatePass, "IIS_IUSRS"))
                {
                    DirectoryEntry localMachine = new DirectoryEntry("WinNT://" + ServerName);
                    DirectoryEntry group  = null;
    
                    string ldapUser = ImpersonateUser.Replace('\\', '/');
    
                    try
                    {
                        group = localMachine.Children.Find("IIS_IUSRS", "Group");
                    }
                    catch
                    {
                        throw new ApplicationException("Unable to find local group IIS_IUSRS");
                    }
                    
                    try
                    {
                        group.Invoke("Add", new Object[] {"WinNT://" + ldapUser});     // E.G. WinNT://test/uodb_user
                    }
                    catch
                    {
                        // $REVIEW (michion): assume failures are from adding a user already present
                    }
                }
            }


            //--------------------------------------------------------------------
            // In order for event logging to work properly, the accounts that are
            // impersonated in the App Pools may be called upon to create subkeys
            // in the registry to represent new event log sources/applications.  
            //
            // In order to ensure that the user account the app pool is running
            // has sufficient rights, we must set explicit ACLs to it for the registry
            // node, which .NET is horribly inadequate for.  As a result, we use
            // a setup utility DLL that encapsulates the functionality we want 
            // (strategically avoiding the need to marshall any complex data types)
            //

            if (PoolImpersonate && ImpersonateUser.Length > 0)
            {
                AddEventLogRegkeyAccess(ImpersonateUser);
                SetSystemTempFolderACL(ImpersonateUser, FOLDER_DACL_READEXEC);
            }
            else
            {
                AddEventLogRegkeyAccess("NETWORK SERVICE");
            }
            


            //--------------------------------------------------------------------
            // WMI will let you instantiate an object even though there isn't
            // an actual WMI behind it.  So the only way to determine if something
            // is there is to either catch the exception when you try to access 
            // properties off the object, or search through an enumeration
            //
            // $REVIEW (michion):  For some reason my enumeration test code stopped
            // working and I can't enum app pools?  Have to resort to exception
            // catching
            //
            IIsApplicationPoolSetting pool = new IIsApplicationPoolSetting(mScope, keyName);

            try
            {
                if (pool.Name == keyName)
                {
                    fExists = true;
                }

            }
            catch (System.IO.DirectoryNotFoundException)
            {
            }



            //--------------------------------------------------------------------
            // If we couldn't find an app pool, then we're on the hook to create 
            // one
            //
            // $REVIEW (michion): Probably shouldn't rely on default settings
            // that we get on create here.  The defaults are probably coming from
            // something that could be hand tweaked to mess things up
            //
            if (!fExists)
            {
                pool = IIsApplicationPoolSetting.CreateInstance();
                pool.LateBoundObject["Name"]   = keyName;
            }

            if (PoolImpersonate && ImpersonateUser.Length > 0)
            {
                pool.AppPoolIdentityType = 3;
                pool.WAMUserPass = ImpersonatePass;
                pool.WAMUserName = ImpersonateUser;
            }
            else
            {
                pool.AppPoolIdentityType = 2;
                pool.WAMUserPass = "";
                pool.WAMUserName = "";
            }

            //  If a queue length override was specified for this interface,
            //  then set it.
            if (HasRequestQueueLength)
            {
                pool.AppPoolQueueLength = RequestQueueLength;
            }

            pool.ManagedPipelineMode = IIsApplicationPoolSetting.ManagedPipelineModeIntegrated;
            pool.Enable32BitAppOnWin64 = IntPtr.Size == 4;
            pool.PeriodicRestartTime = 0;
            pool.IdleTimeout         = 0;

            pool.CommitObject(); 


            // everything above was done using the old IIS 6 object model. a
            // few new IIS 7 properties require us to use a different  model

            ManagementClass applicationPoolClass = new ManagementClass(@"\\.\root\WebAdministration", "ApplicationPool", null);
            ManagementObjectCollection applicationPools = applicationPoolClass.GetInstances();

            foreach (ManagementObject applicationPool in applicationPools)
            {
                string name = (string)applicationPool.GetPropertyValue("Name");
                if (! name.Equals(AppPoolName, StringComparison.InvariantCultureIgnoreCase)) continue;

                ManagementBaseObject processModel = (ManagementBaseObject) applicationPool.GetPropertyValue("ProcessModel");
                processModel.SetPropertyValue("LoadUserProfile", loadUserProfile);
                applicationPool.SetPropertyValue("ProcessModel", processModel);

                applicationPool.Put();
                break;
            }
    
            //--------------------------------------------------------------------
            // Platform#20196
            // It seems that IIS can sometimes work too fast and starts the app 
            // pool before the password is set (!?!).  For whatever reason, it
            // appears that cycling the app pool with a brief pause seems to
            // help matters...  blech
            //
            // @@TODO -- Need to verify if this is still needed, as the WMI code in IIS7 isn't quick about updating the
            // object (jelien)
            //IIsApplicationPool pool2 = new IIsApplicationPool(mScope, keyName);
            //pool2.Stop();
            //Thread.Sleep(1000);
            //pool2.Start();

            return;
        }
        



        /* XomIisConfigurator::EditMachineConfig
         * -------------------------------------
         * This method locates uses the MachineConfigEditor class defined in
         * MachineConfig.cs to perform some standard tweaks to the .NET
         * machine.config.  The editor attempts to be 'additive' in nature, 
         * IE it will try to ensure that the most common denominator of a
         * setting is used.  If a max value is being specified, it will only
         * modify the setting if the value being specified is greater than 
         * one that already exists.  This is necessary since the machine.config
         * is 'shared' amongst all processes on a server
        */
        protected virtual void EditMachineConfig()
        {
            MachineConfigEditor mce = new MachineConfigEditor();

            mce.SetProcessModel();
            mce.SetPerfCtrFileMapSize();
            mce.ClearVersionHeader();
            // [darrenan] .NET 2.0 does not like this so commenting it out until we have
            // a correct fix for .NET 2.0
            //mce.SetHttpContinue(false);
            
            mce.Commit();
            
            return;
        }
        

        


    
        protected virtual void DeleteVSite()
        {
            string keyName = "W3SVC/" + SiteId.ToString();
            // LogMessage("Deleteing web server at " + keyName);
    
            ManagementScope mScope = IisManagementScope;
            IIsWebServerSetting webServerSetting = new IIsWebServerSetting(mScope, keyName);
    
            try
            {
                webServerSetting.Delete();
            }
            catch (System.IO.DirectoryNotFoundException)
            {
                // The key did not exist. ignore the exception
            }
        }
    
    
    
        protected virtual void DeleteVDir(string keyName)
        {
            ManagementScope mScope = IisManagementScope;
            IIsWebVirtualDirSetting virtualDirSetting = new IIsWebVirtualDirSetting(mScope, keyName);
            
            LogMessage("Deleting VDir: " + keyName);
            try
            {
                virtualDirSetting.Delete();
            }
            catch (System.IO.DirectoryNotFoundException)
            {
                // The virtual directory did not exist. ignore the exception
                LogMessage("Exception Deleting VDir: " + keyName);
            }
        }
    

        protected virtual void DeleteAppPool()
        {
            DirectoryEntry  pools = new DirectoryEntry("IIS://localhost/w3svc/AppPools");

            //We cant remove fromteh collection, while Enumerating over it. 
            //Hence we use an additional object to store the removal candidates
            List<DirectoryEntry> removals = new List<DirectoryEntry>(); 
            foreach (DirectoryEntry pool in pools.Children)
            {
                if (pool.Name == AppPoolName)
                {
                    try
                    {
                        object[] rgApplications = (object [])pool.Invoke("EnumAppsInPool", null);

                        if (rgApplications.Length == 0)
                        {
                            LogMessage("Deleting Application pool: " + pool.Name);
                            removals.Add(pool); 
                        }
                        else
                        {
                            LogMessage("Application pool has " + rgApplications.Length + " remainin references, skipping delete");
                        }
                    }
                    catch (Exception ex)
                    {
                        LogMessage("Failed in EnumerateApplicationsInPool with the following exception: \n" + ex.ToString());
                        return;
                    }

                    break;
                }
            }
            foreach (Object aPool in removals)
            {
                pools.Children.Remove( (DirectoryEntry) aPool);
            }


        }







        public virtual string SiteName
        {
            get
            {
                if (siteName == null)
                {
                    siteName = Interface.VSite;
                }

                if (siteName == null)
                {
                    LogMessage("WARNING: SiteName requested on an interface that did not have a populated vc_site column.");
                    siteName = "";
                }

                return siteName;
            }
        }
    

        public virtual string AppPoolName
        {
            get
            {
                if (String.IsNullOrEmpty(VdirName))
                {
                    return SiteName;
                }
                else
                {
                    return  SiteName + "-" + VdirName;
                }
            }
        }
    

        public virtual int SiteId
        {
            get
            {
                if (siteId == 0)
                {
                    siteId = Interface.VSiteId;
                }

                if (siteId == 0)
                {
                    LogMessage("WARNING: SiteId requested on an interface that did not have a non-zero i_vsite_id column.");
                }

                return siteId;
            }
        }


        public virtual string SitePath
        {
            get
            {
                if (sitePath.Length == 0)
                {
                    // $REVIEW (michion): Need to guard against non-standard file placements.  This code will
                    // throw an exception if we back up too far
                    sitePath = Directory.GetParent(assembly.Location).Parent.Parent.FullName;
                }
                return sitePath;
            }
        }
    

        public virtual string VdirPath
        {
            get
            {
                if (vdirPath.Length == 0)
                {
                    vdirPath = Directory.GetParent(assembly.Location).Parent.FullName;
                }
                return vdirPath;
            }
        }


        public virtual string VdirName
        {
            get
            {
                if (vdirName == null)
                {
                    vdirName = Interface.VDir;
                }

                if (vdirName == null)
                {
                    LogMessage("WARNING: VdirName requested on an interface (" + Interface.Interface + ") that did not have a populated vc_vdir column.");
                    vdirName = "";
                }

                return vdirName;
            }
        }

        public virtual string VdirKeyName
        {
            get
            {
               return ConstructVdirKeyName(VdirName);
            }
        }

        protected string ConstructVdirKeyName(string vdir)
        {
            return "W3SVC/" + SiteId.ToString() + "/root/" + vdir;
        }

        public virtual string ImpersonateUser
        {
            get
            {
                if (impersonateUser == null)
                {
                    impersonateUser = (Interface.Username == null) ? "" : Interface.Username;
                }
                    
                return impersonateUser;
            }
        }
    

        public virtual string ImpersonatePass
        {
            get
            {
                if (ImpersonateUser.Length > 0)
                {
                     if (impersonatePass == null)
                     {
                         CSetupSecureResolver decoder = new CSetupSecureResolver();

                         string  cfgdbPassword = Interface.Password;

                         impersonatePass = decoder.UserSecret(cfgdbPassword);
                     }

                     return impersonatePass;
                }
                else
                    return "";
            }
        }
    

        public virtual ManagementScope IisManagementScope
        {
            get
            {
                if (iisManagementScope == null)
                {
                    ConnectionOptions cnOpts = new ConnectionOptions();
    
                    iisManagementScope = new ManagementScope("\\\\.\\root\\MicrosoftIISv2", cnOpts);
                    iisManagementScope.Connect();
                }
                return iisManagementScope;
            }
        }


        public virtual ManagementBaseObject[] ServerBindings
        {
            get
            {
                if (serverBindings == null)
                {
                    serverBindings = new ManagementBaseObject[1];

                    ServerBinding binding = ServerBinding.CreateInstance();
        
                    if (String.Compare(Config.Environment, "XBLOB", true) != 0)
                    {
                        binding.IP        = Interface.IPAddressString;
                    }
                    else
                    {
                        // For Xblobs, if we don't bind an IP address, then life will be 
                        // much better if the IP address changes. Some people use DHCP for 
                        // convenience, and mapping all the IIS sites to the new IP 
                        // address (when it changes) is the most painful part. I can't 
                        // think of any reason why we couldn't bind to all IPs on the 
                        // Xblob... can you?
                        binding.IP        = "";
                    }

                    binding.Hostname  = "";
                    binding.Port      = Interface.Port.ToString();

                    serverBindings[0] = binding.LateBoundObject;
                }

                return serverBindings;
            }
        }

        public virtual string ServerBindingString
        {
            get
            {
                if (String.Compare(Config.Environment, "XBLOB", true) == 0)
                {
                    // For Xblobs, if we don't bind an IP address, then life will be 
                    // much better if the IP address changes. Some people use DHCP for 
                    // convenience, and mapping all the IIS sites to the new IP 
                    // address (when it changes) is the most painful part. I can't 
                    // think of any reason why we couldn't bind to all IPs on the 
                    // Xblob... can you?
                    return ":" + Interface.Port.ToString() + ":";
                }
                else
                {
                    return Interface.IPAddressString + ":" + Interface.Port.ToString() + ":";
                }
            }
        }

        public virtual bool PoolImpersonate
        {
            get
            {
                return true;
            }
        }

        public virtual bool HasRequestQueueLength
        {
            get
            {
                return (Interface.Info1 != null);
            }
        }

        public virtual int RequestQueueLength
        {
            get
            {
                if (Interface.Info1 == null)
                    throw new System.InvalidOperationException("Usage:  Call HasRequestQueueLength first to determine if there is an override specified for this interface.");

                int ret = Int32.Parse(Interface.Info1);
                return ret;
            }
        }
    

    

        /* XomIisConfigurator::CheckSiteExists
         * -----------------------------------
         * This method is responsible for determining if the site specified
         * for this configurator (SiteId) already exists
         *
         * Returns:  true - site with id SiteId already exists
         *          false - not
         *
        */
        protected virtual bool CheckSiteExists()
        {
            ManagementScope         mScope   = IisManagementScope;
    
            string keyName = "W3SVC/" + SiteId.ToString();
    
            IIsWebServerSetting.IIsWebServerSettingCollection sites = IIsWebServerSetting.GetInstances();
    
            foreach(IIsWebServerSetting aSite in sites)
            {
                if (String.Compare(aSite.Name, keyName, true) == 0)
                {
                    return true;
                }
            }
    
            return false;
        }
    
    
    
        /* XomIisConfigurator::CheckSiteBindings
         * -------------------------------------
         * This method compares the current configurators IP:Port specification
         * against the bindings of all the other sites on the machine currently
         * and constructs an ArrayList of all those entries that conflict with
         * it.  
         *
         * NB: The algorithm here follows the IIS interpretation of the binding
         *     info, namely that an empy IP setting indicates 
         *     "* All unassigned *"
         *
         * NB: The behavior of the IIS Manager MMC snapin is a little 
         *     misleading because when a site has no serverBindings, it
         *     displays * All unassigned * and port 80.  It displays the same
         *     when a server binding has "" for an IP and 80 for a port. So
         *     though the UI might suggest a conflict, there really isn't 
         *     one.  This method will not consider this condition to be a 
         *     conflict because it will not enumerate a non-existing binding
         *     in the first place, and thus cannot consider it for testing
         *
         * Returns:  an ArrayList of strings containg the metabase paths of
         *           all sites whose bindings conflict with the IP:Port
         *           specification that this configurator wants to use
        */
        protected virtual ArrayList CheckSiteBindings()
        {
            string     targetIP   = ServerBindings[0]["IP"].ToString();
            string     targetPort = ServerBindings[0]["Port"].ToString();
            string     checkIP;
            string     checkPort;
    
            ArrayList  result  = new ArrayList(0);
    
            //-----------------------------------------------------------------
            // Pull up a collection of site setting objects for analysis
            //
            IIsWebServerSetting.IIsWebServerSettingCollection sites = IIsWebServerSetting.GetInstances();
    
            foreach(IIsWebServerSetting aSite in sites)
            {
                if (aSite.ServerBindings != null)
                {
                    foreach (ManagementBaseObject checkBinding in aSite.ServerBindings)
                    {
                        checkIP   = "";
                        checkPort = "";

                        try
                        {
                            checkIP   = checkBinding["IP"].ToString();
                            checkPort = checkBinding["Port"].ToString();
                        }
                        catch (System.Exception)
                        {
                            // This is a safeguard... I've not seen a serverBinding
                            // come back in a weird state like the secureBindings
                            // can (see below) but no harm in guarding the code
                        }

                        //-----------------------------------------------------
                        // Truth be told, I haven't encountered these errors
                        // from the serverBindings collection, only the secure
                        // ones being processed below.  But if there's a chance
                        // that the WMI code behind them is the same, then it 
                        // probably is worth guarding against the same possible
                        // behaviors (can't hurt)
                        //
                        if (checkPort.Length == 0 && checkIP.Length == 0)
                            continue;

                        if (checkPort.EndsWith(":"))
                        {
                            char [] trimchar = {':'};
                            checkPort = checkPort.Trim(trimchar);
                        }
                        
                        // LogMessage("Comparing to serverBinding: " + aSite.Name + " @ [" + checkIP + "]:[" + checkPort + "]  compared to [" + targetIP + "]:[" + targetPort + "]");
                        if (targetIP == "" || checkIP == "" || targetIP == checkIP)
                        {
                            if (targetPort == checkPort)
                            {
                                result.Add(aSite.Name);
                            }
                        }
                    }
                }

                if (aSite.SecureBindings != null)
                {
                    foreach (ManagementBaseObject checkBinding in aSite.SecureBindings)
                    {
                        checkIP   = "";
                        checkPort = "";

                        try
                        {
                            checkIP   = checkBinding["IP"].ToString();
                            checkPort = checkBinding["Port"].ToString();
                        }
                        catch (System.Exception)
                        {
                            // Dunno why but somtimes, i think when there are no bindings
                            // an object gets returned with a "" IP and a null Port.
                            // to save on headaches, just default bad values to ""
                            // and eat the exceptions
                        }
                        

                        //-----------------------------------------------------
                        // WMI provider is F'd up.  It returns the Port of a secure
                        // binding with a trailing colon!  It doesn't do this for
                        // unsecured bindings, so who knows what's going on over 
                        // there...
                        //
                        if (checkPort.Length == 0 && checkIP.Length == 0)
                            continue;

                        if (checkPort.EndsWith(":"))
                        {
                            char [] trimchar = {':'};
                            checkPort = checkPort.Trim(trimchar);
                        }

                        
                        // LogMessage("Comparing to secureBinding: " + aSite.Name + " @ [" + checkIP + "]:[" + checkPort + "]  compared to [" + targetIP + "]:[" + targetPort + "]");
                        if (targetIP == "" || checkIP == "" || targetIP == checkIP)
                        {
                            if (targetPort == checkPort)
                            {
                                result.Add(aSite.Name);
                            }
                        }
                    }
                }
            }
    
           return result;
        }




        /* XomIisConfigurator::GetAspnetIsapiPath
         * -------------------------------------
         * This method locates, in the W3SVC root node's ScriptMaps property,
         * the DLL path for an ISAPI extension
         *
         * Returns:  a string containing the path to the DLL assigned to the
         *           specified extension.   If no mapping was found, a null
         *           will be returned.
        */
        protected virtual string  GetW3SVCIsapiExtensionPath(string extension)
        {
            DirectoryEntry w3svc = new DirectoryEntry ("IIS://localhost/w3svc");

            Array       rootmaps;
            string []   mapFields;
            
            rootmaps = (Array) w3svc.Properties["ScriptMaps"].Value;
                
            foreach(Object aMap in rootmaps)
            {
                if (aMap.GetType() != typeof(System.String))
                    continue;   // $REVIEW (michion):  Assert instead?

                char []  delimiter = {','};
                string aMapString = (string) aMap;

                mapFields = aMapString.Split(delimiter, 30);

                if (mapFields.Length <4)
                    continue; // line doesn't appear to be formatted correctly.  Ignore it

                if (mapFields[0].ToLower() == extension.ToLower())
                {
                    return mapFields[1];
                }
            }

            return null;
        }


        protected virtual string GetAspNetDllPath()
        {
            string exePath = Path.Combine(RuntimeEnvironment.GetRuntimeDirectory(), "aspnet_isapi.dll");
            if (!File.Exists(exePath))
            {
                LogMessage("GetAspNetDllPath: File not found: " + exePath);
                return null;
            }
            return exePath;
        }


        protected virtual bool EnableIsapiExtension(string newExtName, string newExtFile)
        {
            string []                   fields;

            bool                        found   = false;
            bool                        enabled = false;

            DirectoryEntry w3svc = new DirectoryEntry ("IIS://localhost/w3svc");

                
            foreach(Object ext in w3svc.Properties["WebSvcExtRestrictionList"])
            {
                if (ext.GetType() != typeof(System.String))
                {
                    Console.WriteLine("Not a string?");
                    continue;   // $REVIEW (michion):  Assert instead?
                }

                char []  delimiter = {','};
                string extString = (string) ext;

                fields = extString.Split(delimiter, 30);

                if (fields.Length < 5)
                    continue; // line doesn't appear to be formatted correctly.  Ignore it

                if (fields[1].ToLower() == newExtFile.ToLower())
                {
                    found = true;

                    if (fields[0] == "1")
                        enabled = true;
                }
            }


            if (!found) 
            {
                // $REVIEW (michion): Dunno what the 3rd parameter ('1') is for, but UI created extensions
                //                    seem to get this value, so we'll emulate
                //
                w3svc.Properties["WebSvcExtRestrictionList"].Add("1," + newExtFile + ",1," + newExtName + "," + newExtName);
                w3svc.CommitChanges();
            }
            else
            {
                if (!enabled) 
                {
                    // $REVIEW (michion): Should we enable an existing extension mapping if it is currently disabled?
                }
            }

            return !found;
        }





        protected virtual bool EnableMimeExtension(DirectoryEntry site, string newExtName, string newMimeType)
        {
            IISOle.IISMimeType      oExisting   = null;
            PropertyValueCollection pvcMimeMap  = site.Properties["MimeMap"];
            
            foreach ( IISOle.IISMimeType o in pvcMimeMap)
            {
                if (o.Extension.ToUpper() == newExtName.ToUpper())
                    oExisting = o;
            }

            if (oExisting != null)
            {
                pvcMimeMap.Remove(oExisting);
            }

            IISOle.MimeMapClass newMap = new IISOle.MimeMapClass();
            newMap.Extension = newExtName;
            newMap.MimeType = newMimeType;
            
            pvcMimeMap.Add(newMap);

            return true;
        }







        [DllImport("advapi32.dll", SetLastError=true, CharSet=CharSet.Unicode)]
        static extern bool LogonUser(string userName, string domain, string password, int logonType, int logonProvider, ref IntPtr accessToken);

        [DllImport("Kernel32", SetLastError=true)]
        static extern bool CloseHandle( IntPtr handle );


        const int LOGON32_PROVIDER_DEFAULT  = 0;
        const int LOGON32_LOGON_NETWORK     = 3;

        static string cacheUser     = null;
        static string cacheGroup    = null;
        static bool   cacheResult   = false;


        private static bool CheckIfUserIsMemberOfLocalGroup(string userspec, string pass, string group)
        {
            bool    result      = false;
            IntPtr  accessToken = IntPtr.Zero;


            // This is a little application specific, but we recognize here that this check is 
            // only going to be called by the setup code, which means the caching is intended to 
            // optimize the code by preventing unnecessary calls to try to add the impersonating
            // user to the IIS_IUSRS group (which involves a very expensive .Invoke which kills our
            // perf).  So we only cache sucessful results because we know that we have no setup
            // code that REMOVES a user from a group once added.
            // 
            if ((cacheUser == userspec) && (cacheGroup == group) && cacheResult)
            {
                return true;
            }


            int idxDelimiter = userspec.IndexOf("\\");
            string sDomain = (idxDelimiter > 0) ? userspec.Substring(0, idxDelimiter) : ".";
            string sUser   = (idxDelimiter > 0) ? userspec.Substring(idxDelimiter+1) : userspec;


            bool success = LogonUser(sUser,sDomain,pass,LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, ref accessToken);


            if(!success)
            {
                string  errText = String.Format("LogonUser for {0} failed with error {1}", userspec,  Marshal.GetLastWin32Error());
                throw new System.Exception(errText);
            }
            else
            {
                try
                {
                    WindowsIdentity     wi = new WindowsIdentity(accessToken);
                    WindowsPrincipal    wp = new WindowsPrincipal(wi);
    
                    result = wp.IsInRole(group);

                    if (result)
                    {
                        cacheUser   = String.Copy(userspec);
                        cacheGroup  = String.Copy(group);
                        cacheResult = result;
                    }
                }
                finally
                {
                    CloseHandle(accessToken);
                }
            }

            return result;
        }

    }




    //=============================================================================================
    //=============================================================================================
    //=============================================================================================
    public class CertImpXAPI
    {
        #region Crypto API imports
  
        [DllImport("certimpx.dll", CharSet=CharSet.Unicode)] 
        public static extern string ImportCompletePFX(
                                    string  szCertPath,
                                    string  szCertPassword,
                                    bool    importClientCertInSystemStore
                                    );

        [DllImport("certimpx.dll", CharSet=CharSet.Unicode)] 
        public static extern string ImportCompleteSTL(
                                    string  szCertPath
                                    );

        [DllImport("certimpx.dll", CharSet=CharSet.Unicode)] 
        public static extern Int32  ImportCompleteP7B(
                                    string  szCertPath
                                    );

        #endregion    
    }

    // IIS + SSL installer that creates two virtual directories for the XCBK site.
    // Both virtual directories point to the same physical, they vary in authentication
    // modes.
    public class XomIisConfiguratorXCBK : XomIisConfiguratorSSL
    {
        public override bool UnCommit(IDictionary stateSaver) 
        {
            DeleteVDir(ConstructVdirKeyName(SecondaryVdirName));

            return base.UnCommit(stateSaver);
        }

        protected virtual void ResetSecondaryVDir()
        {
            DirectoryEntry vRoot = new DirectoryEntry("IIS://localhost/w3svc/" + SiteId.ToString() + "/root/" + SecondaryVdirName);

            //-----------------------------------------------------------------
            // Set the AccessSSLFlags to 360 = 0x168 = 
            // AccessSSL | AccessSSL128 | AccessSSLRequireCert | NegotiateCert
            // which should force the use of SSL and 128 bit encryption,
            // respectively 
            //
            vRoot.Properties["AccessSSLFlags"][0] = "360";

            //-----------------------------------------------------------------
            // Set the Authorization to 1 (Anonymous)
            //
            vRoot.Properties["AuthFlags"][0] = "1";

            ConfigureImpersonation(vRoot);

            vRoot.CommitChanges();
        }

        protected void ConfigureImpersonation(DirectoryEntry vRoot)
        {
            //-----------------------------------------------------------------
            // Now, if a user is to be impersonated, we want to set the default
            // logon domain to match the domain prefix of that user (this is
            // because SPS doesn't send the domain prefix to us in its request
            // so we have to provide it)
            //
            if (ImpersonateUser.Length > 0) {
                int idxDelimiter = ImpersonateUser.IndexOf("\\");

                string sDomain = (idxDelimiter > 0) ? ImpersonateUser.Substring(0, idxDelimiter) : "";
                string sUser = (idxDelimiter > 0) ? ImpersonateUser.Substring(idxDelimiter + 1) : ImpersonateUser;

                if (sDomain.Length > 0)
                    vRoot.Properties["DefaultLogonDomain"][0] = sDomain;


                //-----------------------------------------------------------------
                // XCBK needs (for some reason) permissions in the system's temp
                // directory (prolly for some SPS stuff) so we're going to 
                // give the ImpersonateUser account read/write permissions in the
                // SYSTEM's TEMP and TMP directories
                //
                SetSystemTempFolderACL(ImpersonateUser, FOLDER_DACL_MODIFY);
            }
        }

        protected override IIsWebServerSetting CreateVSite() 
        {
            IIsWebServerSetting result;

            result = base.CreateVSite();

            if (String.Compare(Config.Environment, "XBLOB", true) != 0)
            {
               // CRL must be disabled for SNOT
               DisableCRL();
            }

            return result;
        }

        private void DisableCRL() 
        {
            Context.LogMessage("Disabling CRL Checking for Binding: " + ServerBindingString);

            // CRL disabling logic copied from XomSslGatewayConfigurator

            try 
            {
                using (HttpApi httpapi = new HttpApi()) 
                {
                    StringBuilder strLog = new StringBuilder();
                    try 
                    {
                        // The binding string may look like any of these:
                        // :443
                        // 10.10.10.10:443
                        // 0.0.0.0:443
                        //
                        // So we need to handle that.

                        string[] parts = ServerBindingString.Split(new char[] { ':' });
                        IPAddress ip;
                        short port;
                        if (!IPAddress.TryParse(parts[0], out ip)) {
                            ip = IPAddress.Parse("0.0.0.0");
                        }
                        if (!short.TryParse(parts[1], out port)) {
                            port = 0;
                        }

                        httpapi.ChangeCrlChecking(ip, port, false, strLog);

                        
                    }
                    finally 
                    {
                        Context.LogMessage("Output from HttpApi.ChangeCrlChecking:");
                        Context.LogMessage(strLog.ToString());
                    }
                }
            }
            catch (Exception e) 
            {
                Context.LogMessage("Exception while disabling CRL checking: " + e.ToString());
                throw;
            }
        }

        protected override IIsWebVirtualDirSetting CreateVDir() {
            Context.LogMessage("Installing Secondary Virtual Directory");
            
            vdirName = SecondaryVdirName;

            base.CreateVDir();

            Context.LogMessage("Installing Primary Virtual Directory");

            ResetSecondaryVDir();

            vdirName = PrimaryVdirName;

            // the result is currently not consumed [problems may rise if that changes]
            return base.CreateVDir();
        }

        private const string SecondaryVdirName = "snot";

        public string PrimaryVdirName 
        {
            get 
            {
                return base.VdirName;
            }
        }

        // Only one app-pool created, share the primary among both vdirs
        public override string AppPoolName
        {
            get 
            {
                if (string.IsNullOrEmpty(PrimaryVdirName))
                {
                    return SiteName;
                }
                else
                {
                    return SiteName + "-" + PrimaryVdirName;
                }
            }
        }

        public override string VdirName 
        {
            get 
            {
                if (null == vdirName)
                    vdirName = base.VdirName;

                return vdirName;
            }
        }

        private string vdirName;
    }

    //=============================================================================================
    //=============================================================================================
    //=============================================================================================
    public class XomIisConfiguratorSSL  :  XomIisConfigurator
    {
        Byte[]      sslCertHash             = null;
        string      sslInfoIdentifier       = null;
        string      sslCertFilePath         = null;
        string      sslCertFilePassword     = null;


        public virtual string SSLInfoIdentifier
        {
            get
            {
                if (sslInfoIdentifier == null)
                {
                     sslInfoIdentifier = Interface.Info1;
                }

                return sslInfoIdentifier;
            }
        }
    

        public virtual Byte[] SSLCertHash
        {
            get
            {
                string  szCertHash;

                if (sslCertHash == null)
                {
                    // Call our custom certimpx.dll to have the 
                    szCertHash = CertImpXAPI.ImportCompletePFX(SSLCertFilePath, SSLCertFilePassword, true);

                    if (szCertHash == null)
                    {
                        throw new ApplicationException("Unable to import SSL certificate from " + SSLCertFilePath);
                    }

                    sslCertHash = ByteConvert.FromString(szCertHash);
                }

                return sslCertHash;
            }
        }

      

        public virtual string SSLCertFilePath
        {
            get
            {
                if (sslCertFilePath == null)
                {
                    CSetupSecureResolver decoder = new CSetupSecureResolver();

                    sslCertFilePath = decoder.SSL_PFXFilePath(SSLInfoIdentifier);
                }
										
                return sslCertFilePath;
            }
        }

      
        public virtual string SSLCertFilePassword
        {
            get
            {

                if (sslCertFilePassword == null)
                {
                    CSetupSecureResolver decoder = new CSetupSecureResolver();

                    sslCertFilePassword = decoder.SSL_Secret(SSLInfoIdentifier);
                }
										
                return sslCertFilePassword;
            }
        }

        public override bool HasRequestQueueLength
        {
            get { return false; }
        }

        public override int RequestQueueLength
        {
            get { return DEFAULT_REQUEST_QUEUE_LENGTH; }
        }

        protected override IIsWebServerSetting CreateVSite()
        {
            // $REVIEW (michion): For now use the base site creation logic (WMI)
            base.CreateVSite();



            // $REVIEW (michion): This currently takes advantage of the knowledge that the only
            // component that uses this configurator is the XCBK.  Because that component has a
            // known issue which requires the Application log's CustomSD key (in the registry) to
            // be modified (presumably so that the impersonated user can write to the application
            // event log) 
            //             
            // This may be an issue with ALL iis components that impersonate, but for M3 we have
            // a lot of those componets running as uodb_user with domain admin (and thuse local 
            // machine admin) rights, so we may not be seeing this.
            //
            if (ImpersonateUser.Length > 0)
            {
                try
                {
                    GrantCustomSDAccess("Application",  0x0002);
                }
                catch
                {
                    LogMessage("ERROR: Failed to grant CustomSD access to Application log for " + ImpersonateUser + ".  Event logging may fail for this component");
                }
            }


            // The SSL file name and password should be stored in the site.xml under an identifier
            // that is specified in the vc_info1 column of the interface.  The one exception that
            // we allow for is XBLOB (which doesn't support SSL since the certs would have to be
            // custom generated), so if the vc_info1 column is blank in an XBLOB scenario, we won't
            // complain
            //
            if (SSLInfoIdentifier == null || SSLInfoIdentifier == "")
            {
                if (String.Compare(Config.Environment, "XBLOB", true) != 0)
                    throw new ApplicationException("Could not locate SSL certificate information in vc_info1 for interface '" + Interface.Interface);
                else
                    LogMessage("Warning: SSLInfoIdentifier was not found in vc_info1.  This is being ignored because config indicates this is an XBLOB environment");
            }
            else
            {
                // If the vc_info1 field is present, then we should be able to import
                // the specified SSL cert and bind it to our site

                // $REVIEW (michion): and then customize it using ADSI
                SetSSLCertHash();
                ResetSecureBindings();
                ResetRootVDir();
            }

            return null;
        }

        protected virtual void ResetSecureBindings()
        {
            string  binding;

            //-----------------------------------------------------------------
            // The site should already be created, but since we used WMI, the
            // secure bindings are not set.  To correct this, we'll use ADSI
            // to clear the serverBindings and set the secureBindings to match
            // the interface spec.
            //
            // $REVIEW (michion): Note that .Clear() seems to leave a :80: 
            //                    binding.  Not sure if that's bad or not.  In
            //                    the old setup scripts, we used to nuke the
            //                    attribute entirely
            //
            DirectoryEntry site = new DirectoryEntry ("IIS://localhost/w3svc/" + SiteId.ToString());

            binding = Interface.IPAddressString + ":" + Interface.Port.ToString() + ":";

            site.Properties["ServerBindings"].Clear();
            site.Properties["SecureBindings"].Add(binding);

            site.CommitChanges();
        }


        protected virtual void  ResetRootVDir()
        {
            DirectoryEntry vRoot = new DirectoryEntry ("IIS://localhost/w3svc/" + SiteId.ToString() + "/root");

            //-----------------------------------------------------------------
            // Set the AccessSSLFlags to 268 = 0x108 = AccessSSL | AccessSSL128
            // which should force the use of SSL and 128 bit encryption,
            // respectively
            //
            vRoot.Properties["AccessSSLFlags"][0] = "264";



            //-----------------------------------------------------------------
            // Set the Authorization to 2, which should be basic auth
            //
            vRoot.Properties["AuthFlags"][0] = "2";

            //-----------------------------------------------------------------
            // Now, if a user is to be impersonated, we want to set the default
            // logon domain to match the domain prefix of that user (this is
            // because SPS doesn't send the domain prefix to us in its request
            // so we have to provide it)
            //
            if (ImpersonateUser.Length > 0)
            {
                int idxDelimiter = ImpersonateUser.IndexOf("\\");

                string sDomain = (idxDelimiter > 0) ? ImpersonateUser.Substring(0, idxDelimiter) : "";
                string sUser   = (idxDelimiter > 0) ? ImpersonateUser.Substring(idxDelimiter+1) : ImpersonateUser;
    
                if (sDomain.Length > 0)
                    vRoot.Properties["DefaultLogonDomain"][0] = sDomain;


                //-----------------------------------------------------------------
                // XCBK needs (for some reason) permissions in the system's temp
                // directory (prolly for some SPS stuff) so we're going to 
                // give the ImpersonateUser account read/write permissions in the
                // SYSTEM's TEMP and TMP directories
                //
                SetSystemTempFolderACL(ImpersonateUser, FOLDER_DACL_MODIFY);
            }

            vRoot.CommitChanges();
        }




        protected virtual void SetSSLCertHash()
        {
            DirectoryEntry w3svc = new DirectoryEntry ("IIS://localhost/w3svc/" + SiteId.ToString());
            
            //-----------------------------------------------------------------
            // This is a cool little trick that seems to get around the stock
            // (non-SP1) ADSI provider's inability to directly set the 
            // binary SSLCertHash property.
            //
            w3svc.Invoke("Put", new object[] {"SSLCertHash", SSLCertHash});
            w3svc.Invoke("SetInfo", new object[] {});

            w3svc.Properties["SSLStoreName"][0] = "my";

            w3svc.CommitChanges();
        }




        protected override IIsWebVirtualDirSetting CreateVDir()
        {
            base.CreateVDir();

            //-----------------------------------------------------------------
            // We want to have the VDirs to inherit the auth flags and default
            // logon domain from the site's root vdir, so we need to clear
            // out these properties in order to allow the inheritance to work
            //
            DirectoryEntry vDir = new DirectoryEntry ("IIS://localhost/w3svc/" + SiteId.ToString() + "/root/" + VdirName);

            vDir.Properties["AuthFlags"].Clear();
            vDir.Properties["DefaultLogonDomain"].Clear();

            vDir.CommitChanges();

            return null;
        }



        private  void GrantCustomSDAccess(string logType, UInt32 targetFlags)
        {
            // The CustomSD attribute needs the SID for the user, so we need to map the NT account specification
            // into an S-x-x-x formatted SID
            //
            NTAccount nt = new NTAccount(ImpersonateUser);
            SecurityIdentifier sid = (SecurityIdentifier) nt.Translate(typeof(System.Security.Principal.SecurityIdentifier));
            string targetSID = sid.ToString();
    

            string  newValue = "";
            bool    first   = true;     // processing the first field?
            bool    append  = true;     // need to append a new ACE?
    
            RegistryKey rk = Registry.LocalMachine.OpenSubKey("SYSTEM\\CurrentControlSet\\Services\\Eventlog\\" + logType, true);
    
            string  delimKeystr = "()";
            char [] delimKey = delimKeystr.ToCharArray();
    
            string  delimACEstr = ";";
            char [] delimACE = delimACEstr.ToCharArray();
    
    
            string    oldValue = rk.GetValue("CustomSD").ToString();
    
            string [] rgFields = oldValue.Split(delimKey);
    
    
            foreach (string part in rgFields)
            {
                if (part.Length > 0)
                {
                    if (first)
                    {
                        // first field should be something like O:BAG:SYD:, we'll copy
                        // copy that over verbatim to start our new string off
                        newValue = part;
                        first = false;
                    }
                    else
                    {
                        string [] ACEBits = part.Split(delimACE);
    
                        if (ACEBits.Length == 6 && ACEBits[5] == targetSID && ACEBits[0] == "A")
                        {
                            // Ok, so we've found an ALLOW ACE for the same SID.  Check the rights 
                            // to see if we need to add the bits we want to set
    
                            UInt32 dwValue = Convert.ToUInt32(ACEBits[2].Substring(2),16);
    
                            if ((dwValue & targetFlags) != targetFlags)
                            {
                                dwValue = dwValue | targetFlags;
                                newValue += "(" + ACEBits[0] + ";" + ACEBits[1] + ";0x" + dwValue.ToString("X4") + ";" + ACEBits[3] + ";" + ACEBits[4] + ";" + ACEBits[5] + ")";
                            }
                            else
                            {
                                newValue += "(" + part + ")";
                            }
    
                            append = false; 
                        }
                        else
                        {
                            // The format of this entry seems wrong... only thing we can
                            // do is copy the whole mess over and hope that we don't 
                            // mess up what we don't understand
    
                            newValue += "(" + part + ")";
                        }
                    }
                }
            }
                                                 
    
            if (append)
            {
                newValue += "(A;;0x" + targetFlags.ToString("X4") + ";;;" + targetSID + ")";
            }
    
            rk.SetValue("CustomSD", newValue);
            
            return;
        }
    
    }





    //=============================================================================================
    //=============================================================================================
    //=============================================================================================
    public class XomIisConfiguratorSRF  :  XomIisConfigurator
    {
        protected override IIsWebServerSetting CreateVSite()
        {
            // $REVIEW (michion): For now use the base site creation logic (WMI)
            base.CreateVSite();

            UpdateScriptMap();

            return null;
        }
    

        protected virtual void  UpdateScriptMap()
        {
            //-----------------------------------------------------------------
            // Simple customization beyond the basic IIS configurator behavior:
            // Because the MTCH & XPNF front doors were ported from an older
            // C++ based ISAPI framework, they used non-standard .SRF extensions
            // which are not normally mapped to the ASP.NET extension.  To 
            // remedy this, we have to update the ScriptMaps property of the site
            //
            string  asmxMap = GetAspNetDllPath();

            if (asmxMap == null)
            {
                throw new ApplicationException("Unable to find ASP.NET extension mapping for '.asmx'.  Is ASP.NET installed?");
            }

            DirectoryEntry site = new DirectoryEntry ("IIS://localhost/w3svc/" + SiteId.ToString());

            string [] maps = 
            {
                ".ashx," + asmxMap + ",1,GET,HEAD,POST,DEBUG",
                ".srf," + asmxMap + ",1,GET,HEAD,POST,DEBUG",
            };

            site.Properties["ScriptMaps"].Value = maps;

            site.CommitChanges();
        }
    }


    public class XomIisNet4Configurator : XomIisConfigurator
    {
        protected override void CreateAppPool()
        {
            LogMessage("INFO: Creating app pool.");
            base.CreateAppPool();
            LogMessage("INFO: Done creating app pool");

            string path = Path.Combine(Environment.SystemDirectory, "inetsrv");
            if (!Directory.Exists(path))
            {
                throw new ApplicationException("ERROR: IIS Directory doesn't exists: " + path);
            }

            path = Path.Combine(path, "appcmd.exe");

            string parms = string.Format("set apppool /apppool.name:{0} /managedRuntimeVersion:v4.0", AppPoolName);

            ProcessStartInfo startInfo = new ProcessStartInfo(path, parms);
            startInfo.CreateNoWindow = true;
            startInfo.LoadUserProfile = true;
            Process p = Process.Start(startInfo);
            p.WaitForExit();

            return;
        }

        protected override void SetDotNetVersionOnVSite(string keyName)
        {
            RegistryKey rk = Registry.LocalMachine;
            RegistryKey rkSysEnv = rk.OpenSubKey("SOFTWARE\\Microsoft\\.NETFramework");

            string path = null;
            if (rkSysEnv != null && rkSysEnv.GetValue("InstallRoot") != null)
            {
                // This is rich... the RTE and registry hold the .NET version in different formats...

                path = rkSysEnv.GetValue("InstallRoot").ToString();
                path = Path.Combine(path, assembly.ImageRuntimeVersion);
            }
            else
            {
                LogMessage("ERROR: Unable to access REGKEY to determine .NET framework path");
            }

            //
            //  First get the path to aspnet_regiis.exe
            //
            string exePath = Path.Combine(path, "aspnet_regiis.exe");
            if (!File.Exists(exePath))
            {
                LogMessage("File not found: " + exePath);
                return;
            }

            //
            //  Construct command line
            //

            string parms;

            if (keyName == null)
            {
                // According to the v2.0 usage, the -i parm is the correct one to reconfigure IIS to default to ASP.NET v2.0, but when you try to downgrade
                // a server to v1.1 using -i, it doesn't work.  That's probably something specific with downgrading, so I think using -i in the upgrade
                // case here is safe.  That's what I think....
                //
                parms = "-i";
                LogMessage("WARNING: Root metabase node is not configured for the current ASP.NET version.  This will be corrected and an IISRESET will occur");
            }
            else
            {
                parms = "-s " + keyName;
                LogMessage("WARNING: Metabase defaulting is not in place!  (WHY?) Using aspnet_regiis to explicitly configure " + keyName);
            }

            ProcessStartInfo startInfo = new ProcessStartInfo(exePath, parms);
            startInfo.CreateNoWindow = true;
            startInfo.LoadUserProfile = true;
            Process p = Process.Start(startInfo);
            p.WaitForExit();

            return;
        }    

    }

    //=============================================================================================
    //=============================================================================================
    //=============================================================================================
    public class XomIisConfiguratorXTOU  :  XomIisConfigurator
    {
        public override string VdirKeyName
        {
            get
            {
                return "W3SVC/" + SiteId.ToString() + "/root/";
            }
        }

        protected override IIsWebServerSetting CreateVSite()
        {
            LogMessage("Creating VSite (static content):" + AsmPath);
            

            //-----------------------------------------------------------------
            // In theory, this isn't too hard.  We create a child node under
            // /w3svc node with a key type of IIsWebServer and then pump it
            // full of property values and then commit it.
            //
            DirectoryEntry w3svc   = new DirectoryEntry ("IIS://localhost/w3svc");
            DirectoryEntry newSite = w3svc.Children.Add(SiteId.ToString(),"IIsWebServer");
            

            //-----------------------------------------------------------------
            // Create the new site with autostart disabled to keep it offline
            // while this code is manipulating the various properties in the 
            // metabase.
            //
            newSite.Properties["ServerAutoStart"    ][0] = "false";
            newSite.Properties["ServerState"        ][0] = "4";   // $REVIEW (michion): This may not affect anything... autostart seems to control the initial state?            

            newSite.Properties["ServerComment"      ][0] = SiteName;

            newSite.Properties["ServerSize"         ][0] = "2";
            
            newSite.Properties["DefaultDoc"         ][0] = "";    // Remove all default content pages
            newSite.Properties["DirBrowseFlags"     ][0] = "62";  // Disable all default docs  0x40000000 = "Enable default contents page" checkbox

            newSite.Properties["HttpCustomHeaders"].Add("");      // $REVIEW (michion): This appears to behave like bindings and needs to be Add()'d instead of set?

            newSite.Properties["AllowKeepAlive"     ][0] = "false";

            newSite.Properties["LogFileDirectory"]   [0] = IislogPath;
            newSite.Properties["LogFilePeriod"]      [0] = "4";                  // 1=daily, 4=hourly rollover


            //-----------------------------------------------------------------
            // Bind this site to the IP:Port
            //
            newSite.Properties["ServerBindings"].Add(ServerBindingString);

            newSite.CommitChanges();


            //-----------------------------------------------------------------
            // Now configure the root vdir for this site
            //
            DirectoryEntries  roots = newSite.Children;
            DirectoryEntry  newRoot = roots.Add("root","IIsWebVirtualDir");

            newRoot.CommitChanges();

            newRoot.Invoke("AppCreate3", new object[] { 2, AppPoolName, false });

            newRoot.Properties["AppFriendlyName"][0] = SiteName + " Application";
            newRoot.Properties["AppRoot"][0] = "/LM/W3SVC/" + SiteId.ToString() + "/Root";
            newRoot.Properties["Path"               ][0] = VdirPath;    // NB: We don't have a non-root VDIR for contentdownload, so we use the VDirPath here
            newRoot.Properties["AccessFlags"        ][0] = "1";     // 0x1 = Read access
            newRoot.Properties["AuthFlags"          ][0] = "1";     // 0x1 = anonymous, 0x4 Windows integrated

//            newRoot.Properties["MimeMap"].Add(".*,text/html");      // $REVIEW (michion): Crap, ADSI provider can't do mime maps...

            newRoot.CommitChanges();

            return null;
        }

    }





    //=============================================================================================
    //=============================================================================================
    //=============================================================================================
    public class XomIisConfiguratorDL  :  XomIisConfigurator
    {
        #region P/Invoke
        const uint NERR_Success = 0;

        private enum NetError : uint
        {
            NERR_Success = 0,
            NERR_BASE = 2100,
            NERR_UnknownDevDir = (NERR_BASE + 16),
            NERR_DuplicateShare = (NERR_BASE + 18),
            NERR_BufTooSmall = (NERR_BASE + 23),
        }

        private enum SHARE_TYPE : uint
        {
            STYPE_DISKTREE = 0,
            STYPE_PRINTQ = 1,
            STYPE_DEVICE = 2,
            STYPE_IPC = 3,
            STYPE_SPECIAL = 0x80000000,
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct SHARE_INFO_502
        {
            [MarshalAs(UnmanagedType.LPWStr)]
            public string shi502_netname;
            public SHARE_TYPE shi502_type;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string shi502_remark;
            public Int32 shi502_permissions;
            public Int32 shi502_max_uses;
            public Int32 shi502_current_uses;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string shi502_path;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string shi502_passwd;
            public Int32 shi502_reserved;
            public IntPtr shi502_security_descriptor;
        }

        [DllImport("Netapi32.dll")]
        private static extern uint NetShareCheck(
            [MarshalAs(UnmanagedType.LPWStr)] string strServer,
            [MarshalAs(UnmanagedType.LPWStr)] string strDevice,
            UInt32 dwType
            );

        [DllImport("Netapi32.dll")]
        private static extern uint NetShareAdd(
            [MarshalAs(UnmanagedType.LPWStr)] string strServer,
            Int32 dwLevel,
            ref SHARE_INFO_502 buf,
            IntPtr parm_err
        );

        [DllImport("netapi32.dll", SetLastError = true)]
        private static extern uint NetShareDel(
                    [MarshalAs(UnmanagedType.LPWStr)] string strServer,
                    [MarshalAs(UnmanagedType.LPWStr)] string strNetName,
                    Int32 reserved //must be 0
                    );
        #endregion
        #region File Share Security
        [Flags]
        public enum ShareRights
        {
            FullControl = 0x1f01ff,
            Write = 0x10116,
            Execute = 0x20,
            Read = 0x120089,
            None = 0x0
        }
        public class ShareAccessRule : AccessRule
        {
            public new ShareRights AccessMask
            {
                get { return (ShareRights)base.AccessMask; }
            }
            public ShareAccessRule(IdentityReference identity, ShareRights accessMask, AccessControlType accessType)
                : base(identity, (int)accessMask, false, InheritanceFlags.None, PropagationFlags.None, accessType)
            {
            }
        }
        public class ShareAuditRule : AuditRule
        {
            public ShareAuditRule(IdentityReference identity, ShareRights accessMask, AuditFlags auditFlags)
                : base(identity, (int)accessMask, false, InheritanceFlags.None, PropagationFlags.None, auditFlags)
            {
            }
        }
        public class FileShareObjectSecurity : NativeObjectSecurity
        {
            public override Type AccessRightType
            {
                get { return typeof(int); }
            }

            public override Type AccessRuleType
            {
                get { return typeof(ShareAccessRule); }
            }

            public override Type AuditRuleType
            {
                get { return typeof(ShareAuditRule); }
            }

            public FileShareObjectSecurity()
                : base(false, ResourceType.LMShare)
            {
                this._fileShareName = null;
            }

            public FileShareObjectSecurity(string fileShare)
                : base(false, ResourceType.LMShare, fileShare, AccessControlSections.All)
            {
                this._fileShareName = fileShare;
            }

            public override AccessRule AccessRuleFactory(
                IdentityReference identityReference,
                int accessMask, bool isInherited,
                InheritanceFlags inheritanceFlags,
                PropagationFlags propagationFlags,
                AccessControlType type)
            {
                return new ShareAccessRule(identityReference, (ShareRights)accessMask, type);
            }

            public override AuditRule AuditRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
            {
                return new ShareAuditRule(identityReference, (ShareRights)accessMask, flags);
            }

            public void CommitSecurity(String shareName, AccessControlSections sections)
            {
                Persist(shareName, sections);
            }

            public void CommitSecurity(AccessControlSections sections)
            {
                Persist(this._fileShareName, sections);
            }

            private string _fileShareName;
        }
        #endregion
        
        private IUserRole _userRole;
        private string _userPass;

        public override bool PoolImpersonate
        {
            get
            {
                return String.Compare(Config.Environment, "xblob", true) == 0;
            }
        }

        public override string ImpersonateUser
        {
            get
            {
                if (!PoolImpersonate)
                    return base.ImpersonateUser;

                if (_userRole == null)
                {
                    // Definite hack, as this should really be in npdb. However, this only applies
                    // to xblob environments, and the mapping is all to effectively the same user
                    // so picking one that is known to exist.
                    _userRole = Config.GetUserRole("aasg.svc");
                }

                return _userRole.FullUsername;
            }
        }


        public override string ImpersonatePass
        {
            get
            {
                if (!PoolImpersonate)
                    return base.ImpersonatePass;

                if (_userPass == null)
                {
                    CSetupSecureResolver decoder = new CSetupSecureResolver();

                    if (_userRole == null)
                    {
                        // Definite hack, as this should really be in npdb. However, this only applies
                        // to xblob environments, and the mapping is all to effectively the same user
                        // so picking one that is known to exist.
                        _userRole = Config.GetUserRole("aasg.svc");
                    }

                    string cfgdbPassword = _userRole.Password;

                    _userPass = decoder.UserSecret(cfgdbPassword);
                }

                return _userPass;
            }
        }

        protected override IIsWebVirtualDirSetting CreateVDir()
        {
            return null;
        }

        protected override IIsWebServerSetting CreateVSite()
        {
            uint result;

            LogMessage("Creating VSite (static content):" + AsmPath);


			//-----------------------------------------------------------------
            // In theory, this isn't too hard.  We create a child node under
            // /w3svc node with a key type of IIsWebServer and then pump it
            // full of property values and then commit it.
            //
            DirectoryEntry w3svc   = new DirectoryEntry ("IIS://localhost/w3svc");
            DirectoryEntry newSite = w3svc.Children.Add(SiteId.ToString(),"IIsWebServer");
            

            //-----------------------------------------------------------------
            // Create the new site with autostart disabled to keep it offline
            // while this code is manipulating the various properties in the 
            // metabase.
            //
            newSite.Properties["ServerAutoStart"    ][0] = "false";
            newSite.Properties["ServerState"        ][0] = "4";   // $REVIEW (michion): This may not affect anything... autostart seems to control the initial state?            

            newSite.Properties["ServerComment"      ][0] = SiteName;

            newSite.Properties["ServerSize"         ][0] = "2";
            
            newSite.Properties["DefaultDoc"         ][0] = "";    // Remove all default content pages
            newSite.Properties["DirBrowseFlags"     ][0] = "62";  // Disable all default docs  0x40000000 = "Enable default contents page" checkbox

            newSite.Properties["HttpCustomHeaders"].Add("");      // $REVIEW (michion): This appears to behave like bindings and needs to be Add()'d instead of set?

            newSite.Properties["AllowKeepAlive"     ][0] = "false";

            newSite.Properties["LogFileDirectory"]   [0] = IislogPath;
            newSite.Properties["LogFilePeriod"]      [0] = "4";                  // 1=daily, 4=hourly rollover


            //-----------------------------------------------------------------
            // Bind this site to the IP:Port
            //
            newSite.Properties["ServerBindings"].Add(ServerBindingString);


            EnableMimeExtension(newSite, ".xcp", "text/html");
            EnableMimeExtension(newSite, ".pac", "text/html");
            EnableMimeExtension(newSite, ".ccgame", "application/octet-stream");
            EnableMimeExtension(newSite, ".cab", "application/octet-stream");
            EnableMimeExtension(newSite, ".rbs", "application/octet-stream");
            EnableMimeExtension(newSite, ".xex", "Application/octet-stream");
            EnableMimeExtension(newSite, ".xzp", "Application/octet-stream");
            EnableMimeExtension(newSite, ".lex", "Application/octet-stream");

            newSite.CommitChanges();


            //-----------------------------------------------------------------
            // Now configure the root vdir for this site
            //
            DirectoryEntries  roots = newSite.Children;
            DirectoryEntry  newRoot = roots.Add("root","IIsWebVirtualDir");

            newRoot.CommitChanges();

            newRoot.Properties["AppRoot"            ][0] = "/LM/W3SVC/" + SiteId.ToString() + "/Root";
            newRoot.Properties["Path"               ][0] = AsmPath;    // NB: We don't have a non-root VDIR for contentdownload, so we use the VDirPath here
            newRoot.Properties["AccessFlags"        ][0] = "1";     // 0x1 = Read access
            newRoot.Properties["AuthFlags"          ][0] = "1";     // 0x1 = anonymous, 0x4 Windows integrated

//            newRoot.Properties["MimeMap"].Add(".*,text/html");      // $REVIEW (michion): Crap, ADSI provider can't do mime maps...

            newRoot.CommitChanges();

            //-----------------------------------------------------------------
            // Now configure the content vdir for this site
            //
            roots = newRoot.Children;
            newRoot = roots.Add("Content", "IIsWebVirtualDir");

            newRoot.CommitChanges();

            newRoot.Invoke("AppCreate3", new object[] { 2, AppPoolName, false });

            newRoot.Properties["Path"][0] = Config.GetSetting(Setting.download_contentDirectory); // NB: We don't have a non-root VDIR for contentdownload, so we use the VDirPath here
            newRoot.Properties["AccessFlags"][0] = "1";   // 0x1 = Read access
            newRoot.Properties["AuthFlags"][0] = "1";     // 0x1 = anonymous, 0x4 Windows integrated

            newRoot.CommitChanges();

            //-----------------------------------------------------------------
            // And finally share it
            //
            IInterfaceInfo downloadShareInterface = 
                Config.GetInterface(ServerName, xonline.common.config.Interface.download_share);
            String downloadSharePath = Config.GetSetting(Setting.download_contentDirectory);

            if (!Directory.Exists(downloadSharePath))
                Directory.CreateDirectory(downloadSharePath);

            String netName = downloadShareInterface.Sharename.TrimStart('\\');

            SHARE_INFO_502 shareInfo = new SHARE_INFO_502();
            shareInfo.shi502_netname = netName;
            shareInfo.shi502_type = SHARE_TYPE.STYPE_DISKTREE;
            shareInfo.shi502_remark = "Content Download Share";
            shareInfo.shi502_permissions = 0;

            shareInfo.shi502_path = downloadSharePath;
            shareInfo.shi502_max_uses = -1;
            shareInfo.shi502_current_uses = 0;
            shareInfo.shi502_passwd = null;
            shareInfo.shi502_reserved = 0;
            shareInfo.shi502_security_descriptor = IntPtr.Zero;

			String shareName = @"\\" + Environment.MachineName + @"\" + netName;
            LogMessage(String.Format("Path:      {0}", shareInfo.shi502_path));
            LogMessage(String.Format("NetName:   {0}", shareInfo.shi502_netname));
            LogMessage(String.Format("ShareName: {0}", shareName));

            if (NetShareCheck(null, netName, (uint)SHARE_TYPE.STYPE_DISKTREE) == NERR_Success)
            {
                // Delete the share, and re-create it.  This makes sure that
                // the NetShareAdd will successfully share the right directory.
                result = NetShareDel(null, netName, 0);
                if (result != (uint)NetError.NERR_Success)
                {
                    // Only log the error, but don't throw anything or fail.
                    Win32Exception errorMessage = new Win32Exception((int)result);
                    LogMessage("Unable to delete the download share (" + result.ToString() + ")");
                    LogMessage(errorMessage.ToString());
                }
            }
            result = NetShareAdd(null, 502, ref shareInfo, IntPtr.Zero);
            if (result != (uint)NetError.NERR_Success)
            {
                // Only log the error, but don't throw anything or fail.
                // For some odd reason, this fails with error 2118 on install, 
                // but when resumed, it succeeds... very strange.
                Win32Exception errorMessage = new Win32Exception((int)result);
                LogMessage("Unable to create the download share (" + result.ToString() + ")");
                LogMessage(errorMessage.ToString());
            }

            NTAccount account = new NTAccount("BUILTIN","Administrators");
            Boolean modified;
            FileShareObjectSecurity security = new FileShareObjectSecurity();
            security.ModifyAccessRule(AccessControlModification.Add,
                new ShareAccessRule(account, ShareRights.FullControl, AccessControlType.Allow),
                out modified);
            security.CommitSecurity(shareName, AccessControlSections.All);

            LogMessage("Share ACLs:");
            foreach (ShareAccessRule accessRule in security.GetAccessRules(true, true, typeof(NTAccount)))
            {
                LogMessage(String.Format("    {0}{1}{2}", 
                    accessRule.AccessControlType.ToString().PadRight(10),
                    accessRule.IdentityReference.ToString().PadRight(30),
                    accessRule.AccessMask.ToString()));
            }

            return null;
        }

        protected override void  DeleteVSite()
        {
            IInterfaceInfo downloadShareInterface = 
                Config.GetInterface(ServerName, xonline.common.config.Interface.download_share);

            uint result = NetShareDel(null, downloadShareInterface.Sharename.TrimStart('\\'), 0);
            
            base.DeleteVSite();
        }
 
    }

    //=============================================================================================
    //=============================================================================================
    //=============================================================================================
    public class XomSslGatewayConfigurator  :  XomIisConfigurator
    {
        Byte[]      sslCertHash             = null;
        string      sslInfoIdentifier       = null;
        string      sslCertFilePath         = null;
        string      sslCertFilePassword     = null;

        string      ctlCertFilePath         = null;
        string      p7bCertFilePath         = null;

        public virtual string CTLCertFilePath
        {
            get
            {
                if (ctlCertFilePath == null)
                {
                    CSetupSecureResolver decoder = new CSetupSecureResolver();

                    ctlCertFilePath = decoder.SSL_CTLFilePath(SSLInfoIdentifier);
                }

                return ctlCertFilePath;
            }
        }

        public virtual string P7BCertFilePath
        {
            get
            {
                if (p7bCertFilePath == null)
                {
                    CSetupSecureResolver decoder = new CSetupSecureResolver();

                    p7bCertFilePath = decoder.SSL_P7BFilePath(SSLInfoIdentifier);
                }

                return p7bCertFilePath;
            }
        }

        // Sample formats for script mappings:
        //
        // WebSg:
        // ".asmx," + AsmPath + "\\websg.dll,0,GET,POST"
        // ".aspx," + AsmPath + "\\websg.dll,0,GET,POST"
        //
        // AuthSG (wildcard handler):
        // "*," + GetAspNetDllPath() + ",1,GET,HEAD,POST,DEBUG"
        //
        protected virtual string[] ScriptMappings
        {
            get
            {
                // Default value is for AuthSG example above. Remember to change if 
                // needed!
                return new string[] {
                    "*," + GetAspNetDllPath() + ",1,GET,HEAD,POST,DEBUG"
                };
            }
        }

        // Should we register IIS with this component? Override as appropriate.
        protected virtual bool RegisterAspNet
        {
            get { return true; }
        }
       
        // Is this interface a secure one, which means we should configure SSL?
        public bool IsInterfaceSecure
        {
            get
            {
                return String.Compare(Interface.Protocol, "https", true) == 0;
            }
        }

        // Is the necessary SSL cert information available?
        public bool SslConfigAvailable
        {
            get { return SSLInfoIdentifier != null && SSLInfoIdentifier != ""; }
        }


        public virtual string SSLInfoIdentifier
        {
            get
            {
                if (sslInfoIdentifier == null)
                {
                     sslInfoIdentifier = Interface.Info1;
                }

                return sslInfoIdentifier;
            }
        }
    

        public virtual Byte[] SSLCertHash
        {
            get
            {
                string  szCertHash;

                if (sslCertHash == null)
                {
                    // Call our custom certimpx.dll to have the 
                    szCertHash = CertImpXAPI.ImportCompletePFX(SSLCertFilePath, SSLCertFilePassword, true);

                    if (szCertHash == null)
                    {
                        throw new ApplicationException("Unable to import SSL certificate from " + SSLCertFilePath);
                    }

                    sslCertHash = ByteConvert.FromString(szCertHash);
                }
										
                return sslCertHash;
            }
        }

      

        public virtual string SSLCertFilePath
        {
            get
            {
                if (sslCertFilePath == null)
                {
                    CSetupSecureResolver decoder = new CSetupSecureResolver();

                    sslCertFilePath = decoder.SSL_PFXFilePath(SSLInfoIdentifier);
                }
										
                return sslCertFilePath;
            }
        }

      
        public virtual string SSLCertFilePassword
        {
            get
            {

                if (sslCertFilePassword == null)
                {
                    CSetupSecureResolver decoder = new CSetupSecureResolver();

                    sslCertFilePassword = decoder.SSL_Secret(SSLInfoIdentifier);
                }
										
                return sslCertFilePassword;
            }
        }
    
        public override bool HasRequestQueueLength
        {
            get { return false; }
        }

        public override int RequestQueueLength
        {
            get { return DEFAULT_REQUEST_QUEUE_LENGTH; }
        }

        public virtual void InstallCertificates(DirectoryEntry vSite)
        {
            //-----------------------------------------------------------------
            // $REVIEW (michion): 
            // Currently disabling CRL checks due to connectivity constraints
            // (If this key is not found or is zero, IIS attempts to retrieve 
            // CRL directly and becomes non-functional when it can't contact
            // the CRL distribution point).  There are issues with handling
            // this manually that ErnieC has investigated that we will have
            // to cope with (timing of installation of new CRLs vs their
            // lifetime)                                     
            //
            // vSite.Properties["CertCheckMode"][0] = "1";   // 0 = check for CRLs, 1 = don't


            //-----------------------------------------------------------------
            // SSL certs, OTOH, are not as fun... since the hash is a binary
            // value, we have to do some bizzare raw-COM stuff to get the 
            // value into the metabase
            //
            // vSite.Properties["SSLStoreName"][0] = "my";
            // vSite.Invoke("Put", new object[] { "SSLCertHash", SSLCertHash });

            string hashString = String.Empty;
            byte [] sslCertHash = SSLCertHash;
            foreach (System.Byte certhashbyte in sslCertHash)
            {
                hashString += certhashbyte.ToString("x") + " ";
            }
            LogMessage("CertHash: " + hashString);
            LogMessage("SiteName: " + SiteName);
            LogMessage("Binding:  " + ServerBindingString);

            using(ServerManager manager = new ServerManager())
            {
                Microsoft.Web.Administration.Site site = 
                    manager.Sites[SiteName];

                // Remove this ServerBindingString if it already exists.
                int bindingIndex = -1;        
                foreach (Microsoft.Web.Administration.Binding binding in site.Bindings)
                {
                    LogMessage("Found site binding: " + binding.BindingInformation);
                    if (binding.BindingInformation == ServerBindingString)
                    {
                        LogMessage("Removing site binding: " + binding.BindingInformation);
                        bindingIndex = site.Bindings.IndexOf(binding);
                        break;
                    }
                }
                if (bindingIndex != -1)
                {
                    site.Bindings.RemoveAt(bindingIndex);
                }

                LogMessage("Adding site binding: " + ServerBindingString);
                site.Bindings.Add(ServerBindingString, sslCertHash, "My");
                manager.CommitChanges();
            }

            // The certificate is now installed within IIS and http.sys, but the default 
            // is to enable CRL checking. We need that disabled, at least for now, as the 
            // WebSG machines are unable to access the Internet to download the CRL. This 
            // is a blocking problem. We used to do this by setting CertCheckMode to 1 
            // (don't check), but this was deprecated in IIS7. The only replacement I 
            // could find is to use HttpApi (or netsh.exe, or maybe appcmd.exe). So here 
            // we go.
            try
            {
                using (HttpApi httpapi = new HttpApi())
                {
                    StringBuilder strLog = new StringBuilder();
                    try
                    {
                        // The binding string may look like any of these:
                        // :443
                        // 10.10.10.10:443
                        // 0.0.0.0:443
                        //
                        // So we need to handle that.

                        string[] parts = ServerBindingString.Split(new char[] {':'});  
                        IPAddress ip;
                        short port;
                        if (!IPAddress.TryParse(parts[0], out ip))
                        {
                            ip = IPAddress.Parse("0.0.0.0");
                        }
                        if (!short.TryParse(parts[1], out port))
                        {
                            port = 0;
                        }

                        httpapi.ChangeCrlChecking(ip, port, false, strLog);
                    }
                    finally
                    {
                        LogMessage("Output from HttpApi.ChangeCrlChecking:");
                        LogMessage(strLog.ToString());
                    }
                }
            }
            catch (Exception e)
            {
                LogMessage("Exception while disabling CRL checking: " + e.ToString());
                throw;
            }

            //-----------------------------------------------------------------
            // CTL configuration, if needed
            if ( !string.IsNullOrEmpty(CTLCertFilePath) )
            {
                //-----------------------------------------------------------------
                // CTL properties are actually pretty bland... just a regular 
                // string to represent the GUID of the CTL 
                //

                // Call our custom certimpx.dll to have the 
                string ctlCertHash = CertImpXAPI.ImportCompleteSTL(CTLCertFilePath);

                if (ctlCertHash == null)
                {
                    throw new ApplicationException("Unable to import CTL from " + CTLCertFilePath);
                }
                
                vSite.Properties["SslCtlStoreName"][0] = "CA";
                vSite.Properties["SslCtlIdentifier"][0] = ctlCertHash;

                vSite.CommitChanges();

                //-----------------------------------------------------------------
                // Finally, we have a .P7B file that contains certificates between 
                // the root CA and the CA that issues the client certs we approve
                // Since we can't pile those into the .STL file, we need to get those
                // imported via a separate .P7B file
                //
                Int32 dwResult = CertImpXAPI.ImportCompleteP7B(P7BCertFilePath);

                if (dwResult != 0)
                    LogMessage("ERROR: Failed to import .P7B file " + P7BCertFilePath + " for CTL chain");
            }
        }

        protected override IIsWebServerSetting CreateVSite()
        {
            LogMessage("Creating VSite for " + SiteName + " for interface " + Interface.Interface);
                
            //-----------------------------------------------------------------
            // In theory, this isn't too hard.  We create a child node under
            // /w3svc node with a key type of IIsWebServer and then pump it
            // full of property values and then commit it.
            //
            string keyName = "W3SVC/" + SiteId.ToString();
            DirectoryEntry w3svc   = new DirectoryEntry ("IIS://localhost/w3svc");
            DirectoryEntry newSite = w3svc.Children.Add(SiteId.ToString(),"IIsWebServer");
            

            //-----------------------------------------------------------------
            // Create the new site with autostart disabled to keep it offline
            // while this code is manipulating the various properties in the 
            // metabase.
            //
            newSite.Properties["ServerAutoStart"    ][0] = "false";
            newSite.Properties["ServerState"        ][0] = "4";   // $REVIEW (michion): This may not affect anything... autostart seems to control the initial state?            
            newSite.Properties["ServerComment"      ][0] = SiteName;
            newSite.Properties["ServerSize"         ][0] = "2";
            newSite.Properties["DefaultDoc"         ][0] = "";    // Remove all default content pages
            newSite.Properties["DirBrowseFlags"     ][0] = "62";  // Disable all default docs  0x40000000 = "Enable default contents page" checkbox
            newSite.Properties["AllowKeepAlive"     ][0] = "true";

            newSite.Properties["LogFileDirectory"]   [0] = IislogPath;
            newSite.Properties["LogFilePeriod"]      [0] = "4";                  // 1=daily, 4=hourly rollover

            // $REVIEW (michion): Does this depend on the default being populated?   Or not populated?  Maybe pre/post commit sensitive?
            newSite.Properties["HttpCustomHeaders"  ].Add("");      

            //-----------------------------------------------------------------
            // Bind this site to the IP:Port; 
            //
            if (IsInterfaceSecure)
            {
                // https means SecureBindings
                newSite.Properties["SecureBindings"].Add(ServerBindingString);
            }
            else
            {
                // http, or otherwise i suppose, means ServerBindings
                newSite.Properties["ServerBindings"].Add(ServerBindingString);
            }




            //-----------------------------------------------------------------
            // Commit the changes
            //-----------------------------------------------------------------
            newSite.Invoke("SetInfo", new object[] {});



            //-----------------------------------------------------------------
            // Update this site to the correct version of .NET
            //
            if (RegisterAspNet)
            {
                LogMessage("Register ASP.NET for site");
                SetDotNetVersionOnVSite(keyName);
            }


            //-----------------------------------------------------------------
            // Now set up some extension mapping (ScriptMaps), but first delete the 
            // existing ones. We're doing this after the SetDotNetVersionsOnVSite() call, 
            // because it was apparently adding some odd extension handlers. At this 
            // point, we can clear them all out and explicitly add our own.
            //
            // @kgoodier: This is broken on IIS7. It ends up creating a Handler Mapping 
            // called "AboMapperCustom nnnnnn" that maps to aspnet_isapi, which is not 
            // allowed in the Integrated Mode (what we use).  It is only allowed in 
            // Classic Mode.  Seems to work OK without this.. stab in the dark FTW!
            //
            // newSite.Properties["ScriptMaps"].Value = ScriptMappings;
            
            newSite.CommitChanges();




            //-----------------------------------------------------------------
            // Now configure the root vdir for this site
            //
            DirectoryEntries  roots = newSite.Children;
            DirectoryEntry  newRoot = roots.Add("root","IIsWebVirtualDir");

            newRoot.CommitChanges();


            newRoot.Invoke("AppCreate3", new object[] {2, AppPoolName, false});

            newRoot.Properties["AppFriendlyName"    ][0] = SiteName + " Application";
            newRoot.Properties["AppRoot"            ][0] = "/LM/W3SVC/" + SiteId.ToString() + "/Root";
            newRoot.Properties["Path"               ][0] = VdirPath;  // e.g., d:\webroot\authsg 
            newRoot.Properties["AuthFlags"          ][0] = "1";       // 0x1 = anonymous, 0x2 = basic, 0x4 = windows integrated @@@review
            newRoot.Properties["AccessFlags"        ][0] = "513";     
            
            // If the gateway supports both SSL and non-SSL traffic, this is not necessary.  This is overriden in the websg code later.
            // @@@ need a way to be abl to flag this on creation.
            //if (SslConfigAvailable)
            //{
            //    newRoot.Properties["AccessSSLFlags"     ][0] = "264";     // SSL + 128bit
            //}
            
            newRoot.CommitChanges();

            //-----------------------------------------------------------------
            // Configure SSL/CTL related properties on the site
            //-----------------------------------------------------------------
            if (IsInterfaceSecure)
            {
                LogMessage("Interface is secure (https), configuring...");
                if (!SslConfigAvailable)
                {
                    if (String.Compare(Config.Environment, "XBLOB", true) != 0)
                        throw new ApplicationException("Could not locate SSL certificate information in vc_info1 for interface '" + Interface.Interface);
                    else
                        LogMessage("Warning: SSLInfoIdentifier was not found in vc_info1.  This is being ignored because config indicates this is an XBLOB environment");
                }
                else
                {
                    LogMessage("Installing SSL certificates(IIS 7)");

                    InstallCertificates(newSite);
                }
            }

            return null;
        }

        
        protected override IIsWebServerSetting UpdateVSite()
        {
            //-----------------------------------------------------------------
            // This basically just adds a new binding

            DirectoryEntry vRoot = new DirectoryEntry ("IIS://localhost/w3svc/" + SiteId.ToString());

            //-----------------------------------------------------------------
            // Bind this site to the IP:Port; rely on the implementor to provide the 
            // binding info.
            //
            if (IsInterfaceSecure)
            {
                // https means SecureBindings
                vRoot.Properties["SecureBindings"].Add(ServerBindingString);

            }
            else
            {
                // http, or otherwise i suppose, means ServerBindings
                vRoot.Properties["ServerBindings"].Add(ServerBindingString);
            }

            vRoot.CommitChanges();

            if (IsInterfaceSecure)
            {
                if (!SslConfigAvailable)
                {
                    if (String.Compare(Config.Environment, "XBLOB", true) != 0)
                        throw new ApplicationException("Could not locate SSL certificate information in vc_info1 for interface '" + Interface.Interface);
                    else
                        LogMessage("Warning: SSLInfoIdentifier was not found in vc_info1.  This is being ignored because config indicates this is an XBLOB environment");
                }
                else
                {
                    LogMessage("Installing SSL certificates(IIS 7)");

                    try
                    {
                        InstallCertificates(vRoot);
                    }
                    catch (COMException e)
                    {
                        // Check for ERROR_NO_SUCH_LOGON_SESSION.  According to MSDN in documentation for 
                        // HttpSetServiceConfiguration, it fails with this error message when the certificate
                        // is invalid.  Would be nice to have a more descriptive error message, though.
                        if (e.ErrorCode == unchecked((int)(0x80070520)))
                        {
                            throw new ApplicationException("The certificate attempting to be installed via path \"" + SSLCertFilePath + "\" is invalid, please verify that the cert is correct", e);
                        }
                        else
                        {
                            throw;
                        }
                    }
                }
            }

            return null;
        }


        protected override IIsWebVirtualDirSetting CreateVDir()
        {
            // No virtual directory for these components
            return null;
        }

    }




    //=============================================================================================
    //=============================================================================================
    //=============================================================================================
    public class XomAuthSGConfigurator  :  XomSslGatewayConfigurator
    {
        protected override IIsWebServerSetting CreateVSite()
        {
            // Mostly the same...
            //
            base.CreateVSite();
           
            if (IsInterfaceSecure)
            {
                // Applies to the vdir (root one)
                DirectoryEntry vRoot = new DirectoryEntry ("IIS://localhost/w3svc/" + SiteId.ToString() + "/root");

                // AuthSG has a few special config items
                //
                vRoot.Properties["AccessSSLFlags"][0] = "32"; // MD_ACCESS_NEGO_CERT, xcbk=264, websg=360
            
                vRoot.CommitChanges();
            }

            return null;
        }

        protected override IIsWebServerSetting UpdateVSite()
        {

            base.UpdateVSite();

            if (IsInterfaceSecure)
            {
                // Applies to the vdir (root one)
                DirectoryEntry vRoot = new DirectoryEntry ("IIS://localhost/w3svc/" + SiteId.ToString() + "/root");

                // AuthSG has a few special config items
                //
                vRoot.Properties["AccessSSLFlags"][0] = "32"; // MD_ACCESS_NEGO_CERT, xcbk=264, websg=360

                vRoot.CommitChanges();
            }

            return null;
        }
        
    }




    //=============================================================================================
    //=============================================================================================
    //=============================================================================================
    public class XomWBSGConfigurator  :  XomSslGatewayConfigurator
    {
        private IUserRole _userRole;
        private string _userPass;

        public override bool PoolImpersonate
        {
            get
            {
                return String.Compare(Config.Environment, "xblob", true) == 0;
            }
        }

        public override string ImpersonateUser
        {
            get
            {
                if (!PoolImpersonate)
                    return base.ImpersonateUser;

                if (_userRole == null)
                {
                    // Definite hack, as this should really be in npdb. However, this only applies
                    // to xblob environments, and the mapping is all to effectively the same user
                    // so picking one that is known to exist.
                    _userRole = Config.GetUserRole("aasg.svc");
                }

                return _userRole.FullUsername;
            }
        }


        public override string ImpersonatePass
        {
            get
            {
                if (!PoolImpersonate)
                    return base.ImpersonatePass;

                if (_userPass == null)
                {
                    CSetupSecureResolver decoder = new CSetupSecureResolver();

                    if (_userRole == null)
                    {
                        // Definite hack, as this should really be in npdb. However, this only applies
                        // to xblob environments, and the mapping is all to effectively the same user
                        // so picking one that is known to exist.
                        _userRole = Config.GetUserRole("aasg.svc");
                    }

                    string cfgdbPassword = _userRole.Password;

                    _userPass = decoder.UserSecret(cfgdbPassword);
                }

                return _userPass;
            }
        }

        protected override IIsWebServerSetting CreateVSite()
        {
            // Mostly the same...
            //
            base.CreateVSite();
           
            // Applies to the vdir (root one)
            DirectoryEntry vRoot = new DirectoryEntry ("IIS://localhost/w3svc/" + SiteId.ToString() + "/root");

            // Our websg has a few special config items
            //
            if (IsInterfaceSecure)
            {
                vRoot.Properties["AccessFlags"][0] = "517"; // websg=517, iis=513
                vRoot.Properties["AccessSSLFlags"][0] = "360"; // xcbk=264, websg=360
            }
            
            vRoot.Properties["AspAllowSessionState"][0] = "0";     // 0 = false
            vRoot.Properties["AspEnableParentPaths"][0] = "0";     // 0 = false
            vRoot.Properties["AspBufferingOn"      ][0] = "0";     // 0 = false

            vRoot.CommitChanges();

            EnableIsapiExtension(SiteName, AsmPath + "\\websg.dll");        // use the SiteName (WebSG) as the extension name

            UpdateIsapiHandlerSettings();
            return null;
        }

        private void UpdateIsapiHandlerSettings()
        {
            string fileLoc = AsmPath + "\\web.config";
            XmlDocument xml = new XmlDocument();
            xml.Load(fileLoc);

            var log = String.Format("Updating web.config file to point to websg location ({0}\\WebSg.dll) and bitness {1}",
                                        AsmPath, (IntPtr.Size == 4 ? "32" : "64"));

            LogMessage(log);
            XmlNodeList nodes = xml.SelectNodes("/configuration/system.webServer/handlers/add[@modules='IsapiModule']");

            foreach (XmlElement node in nodes)
            {
                node.SetAttribute("scriptProcessor", AsmPath + "\\WebSG.dll");
                node.SetAttribute("preCondition", "bitness" + (IntPtr.Size == 4 ? "32" : "64"));
            }

            xml.Save(fileLoc);
        }

        protected override IIsWebServerSetting UpdateVSite()
        {

            base.UpdateVSite();

            // Applies to the vdir (root one)
            DirectoryEntry vRoot = new DirectoryEntry ("IIS://localhost/w3svc/" + SiteId.ToString() + "/root");

            // Our websg has a few special config items
            //
            if (IsInterfaceSecure)
            {
                vRoot.Properties["AccessFlags"][0] = "517"; // websg=517, iis=513
                vRoot.Properties["AccessSSLFlags"][0] = "360"; // xcbk=264, websg=360
            }

            vRoot.CommitChanges();

            UpdateIsapiHandlerSettings();
            return null;
        }

        public override string VdirPath
        {
            get
            {
                // websg runs in \webroot\websg, not \webroot\websg\bin
                return AsmPath;
            }
        }
        
        protected override string[] ScriptMappings 
        {
            get
            {
                return new string[] {
                    ".asmx," + AsmPath + "\\websg.dll,0,GET,POST",
                    ".aspx," + AsmPath + "\\websg.dll,0,GET,POST"
                };
            }
        }

        // websg doesn't use asp.net and doesn't want it
        protected override bool RegisterAspNet
        {
            get { return false; }
        }
       
    }



    //=============================================================================================
    //=============================================================================================
    //=============================================================================================
    /// <summary>
    /// XRLScan configurator
    /// This is a bit different from the other configurators because XRLScan is
    /// an ISAPI filter rather than a web application.  As such, we don't have
    /// to create VSites or VDirs for it, so the normal XomIisConfigurator 
    /// derivation is not called for.  Instead we use the Commit/Uncommit
    /// methods to directly create/delete the metabase entries necessary for
    /// the XRLScan filter to operate
    ///
    /// </summary>
    public class XomXRLScanConfigurator  :  XomInterfaceConfigurator
    {
        public override bool Commit(IDictionary stateSaver)
        {
            bool            fResult   = false;
            string          filterPath = AsmPath + "\\xrlscan.dll";
            
            LogMessage("Installing XRLScan global ISAPI filter: " + filterPath);

            bool is32Bit = IntPtr.Size == 4;
            string isapiName = String.Format("XRLScan {0}bit Filter", is32Bit ? "32" : "64");
            // $REVIEW (michion):  This is a little goofy since XRLScan is a filter
            // and ends up running in a user context that is defined by the application
            // that loads it, but we can't pre-cog what that user context will be
            // (and actually don't have to since CreateAppPool() functions are
            // responsible for ACLing the regkey for any user context they run under)
            // The case that we're going to cover here is for sites without app
            // pools which ALSO are covered, but I'm being ultra paranoid and
            // adding the NETWORK SERVICE ACL here, just to be sure
            // AddEventLogRegkeyAccess("NETWORK SERVICE");

            // Playing it safe here: The DeleteFilter() method will remove any
            // filter that specifies the same DLL path, so we can make sure we
            // remove anything that might conflict, even it possibly uses a
            // different name for the filter
            fResult = DeleteFilter(filterPath);

            fResult = SetFilter(isapiName, filterPath);

            // Update the configuration with the correct bitness level of XRLScan, so it only loads in the correct app pool bitness.
            ManagementClass iisfilters = new ManagementClass(@"\\.\root\WebAdministration", "IsapiFiltersSection", null);
            ManagementObjectCollection coll = iisfilters.GetInstances();


            ManagementObject iisfiltersSection = null;
            // Find the correct instance of this class
            foreach (ManagementObject obj in coll)
            {
                // Search for the root definition of xrlscan.  There may be others defined to remove the binding.
                if (((string)obj.GetPropertyValue("Path")).Equals("MACHINE/WEBROOT/APPHOST", StringComparison.InvariantCultureIgnoreCase) &&
                    String.IsNullOrEmpty((string)obj.GetPropertyValue("Location")))
                {
                    iisfiltersSection = obj;
                    break;
                }
            }

            if (iisfiltersSection != null)
            {
                ManagementBaseObject[] fs = (ManagementBaseObject[])iisfiltersSection.GetPropertyValue("IsapiFilters");
                ManagementBaseObject o = Array.Find(fs,
                    delegate(ManagementBaseObject m)
                    {
                        string s = (string)m.Properties["Name"].Value;
                        return s.Equals(isapiName, StringComparison.InvariantCultureIgnoreCase);
                    });
                o.Properties["PreCondition"].Value = "bitness" + (IntPtr.Size == 4 ? "32" : "64");
                iisfiltersSection.SetPropertyValue("IsapiFilters", fs);
                iisfiltersSection.Put();
            }
            else
            {
                throw new Exception(String.Format("Unable to set specific bitness requirement for xrlscan because there is no IsapiFiltersSection with the path 'MACHINE/WEBROOT/APPHOST' among the '{0}' entries found.",
                                        coll.Count));
            }
            return true;
        }
        

        public override bool UnCommit(IDictionary stateSaver)
        {
            bool            fResult    = false;
            string          filterPath = AsmPath + "\\xrlscan.dll";

            LogMessage("Removing XRLScan global ISAPI filter: " + filterPath);
            fResult = DeleteFilter(filterPath);

            return true;
        }



        bool SetFilter(string name, string path)
        {
            DirectoryEntry filters = new DirectoryEntry ("IIS://localhost/w3svc/Filters");
        
            string      loadOrder = (string) filters.Properties["FilterLoadOrder"][0];
            char []     delimiter = {','};

            // First, get the ordered list of filters and parse it into an array for later use

            string [] filterNames = loadOrder.Split(delimiter);

            foreach(DirectoryEntry filter in filters.Children)
            {
                if (filter.Properties["FilterPath"].Count == 0)
                {
                    continue;
                }
                string testPath = (string)filter.Properties["FilterPath"][0];

                if (testPath.ToUpper() == path.ToUpper())
                {
                    // filter already exists, tell the caller we can't do this
                    return false;
                }
            }


            //-----------------------------------------------------------------
            // Create a new filter node in the metabase and populate it with
            // all the properties we know how to set
            DirectoryEntry  newFilter = filters.Children.Add(name, "IIsFilter");

            newFilter.Properties["FilterDescription"    ][0] = name + " Filter";
            newFilter.Properties["FilterPath"           ][0] = path;
            newFilter.Properties["FilterEnabled"        ][0] = "true";
            newFilter.CommitChanges();


            //-----------------------------------------------------------------
            // Now, construct a new FilterLoadOrder string that puts our filter
            // at the top of the load order and save this new string onto the
            // filters container object
            //
            loadOrder = name;     // wipe out the original string and build a new one

            foreach (string filterName in filterNames)
            {
                loadOrder = loadOrder + "," + filterName;
            }

            filters.Properties["FilterLoadOrder"][0] = loadOrder;
            filters.CommitChanges();

            return true;
        }

        

        bool DeleteFilter(string path)
        {
            DirectoryEntry filters = new DirectoryEntry ("IIS://localhost/w3svc/Filters");
        
            //-----------------------------------------------------------------
            // First, get the ordered list of filters and parse it into an 
            // so we can rearrange it 
            // for later use
            //
            string      name = "";
            string loadOrder = (string)filters.Properties["FilterLoadOrder"][0];
            char []     delimiter = {','};
            string [] filterNames = loadOrder.Split(delimiter);

            //We cant remove fromteh collection, while Enumerating over it. 
            //Hence we use an additional object to store the removal candidates
            List<DirectoryEntry> removals = new List<DirectoryEntry>();
            foreach(DirectoryEntry filter in filters.Children)
            {
                // Sometimes the array length is 0
                if (filter.Properties["FilterPath"].Count == 0)
                {
                    continue;
                }
                string testPath = (string)filter.Properties["FilterPath"][0];

                if (testPath.ToUpper() == path.ToUpper())
                {
                    name = (string) filter.Name;        // save the filter name so we can remove it from the FilterLoadOrder list
                    removals.Add(filter); 
                }
            }
            foreach (Object aFilter in removals)
            {
                filters.Children.Remove((DirectoryEntry) aFilter);
            }

            if (name.Length == 0)
                return false;       // nothing happened (couldn't find a filter to delete)


            //-----------------------------------------------------------------
            // Now, construct a new FilterLoadOrder string that removes the 
            // reference to the filter we just removed and save this new string
            //  onto the filters container object
            //
            loadOrder = "";     // wipe out the original string and build a new one

            foreach(string filterName in filterNames)
            {
                if (filterName.ToUpper() != name.ToUpper())
                {
                    if (loadOrder.Length > 0)
                        loadOrder = loadOrder + "," + filterName;
                    else
                        loadOrder = filterName;
                }
            }

            filters.Properties["FilterLoadOrder"][0] = loadOrder;
            filters.CommitChanges();

            return true;
        }
    }




    //=============================================================================================
    //=============================================================================================
    //=============================================================================================
    /// <summary>
    /// Machine CertStore Certificate configurator
    /// This is a simple configurator that installs one certificate to the machine cert store.
    ///
    /// </summary>
        public class XomMachineCertsConfigurator : XomInterfaceConfigurator
        {
            public override bool Commit(IDictionary stateSaver)
            {
                // Blatent hack: the InterfaceKey is NOT a interface name here. We just use it to pass in a string.
                // Which is actually the certificate identifier
                string certIdentifier = base.InterfaceKey;

                LogMessage("Installing certificate to local machine cert store. Identifier=" + certIdentifier);

                CSetupSecureResolver decoder = new CSetupSecureResolver();
                string certFilePath = decoder.SSL_PFXFilePath(certIdentifier);
                string certFilePassword = decoder.SSL_Secret(certIdentifier);

                if (null ==CertImpXAPI.ImportCompletePFX(certFilePath, certFilePassword, true))
                {
                    throw new ApplicationException("Unable to import certificate from " + certFilePath + " to machine store");
                }


                return true;
            }


            public override bool UnCommit(IDictionary stateSaver)
            {
                // we don't delete certificates upon uninstall
                return true;
            }

        }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\AccessToken.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using xonline.common.service;

using xonline.common.mgmt;
using xonline.common.config;

[assembly: XomAreaDefinition(XomAreaName.atTrace)]

namespace xonline.common.protocol 
{

    public class AccessToken
    {
        public ushort _operation;
        public ushort _version = accessTokenVersion;
        public uint   _serviceId;
        public uint   _flags;
        public ulong  _userPuid;
        public ulong  _xboxPuid;
        public ushort _pathNameSize;
        public string _pathName;
        public ushort _signatureSize;
        public byte[] _signature;
        
        // Alternative SignOnBehalf URL
        protected string _altSignUrl = null;
    
        public const ushort baseTokenSize = 32;
        public const ushort accessTokenVersion = 1;

        string _verifyUrl
        {
            get
            {
                IVirtualInterfaceInfo info = Config.GetVirtualInterface(VirtualInterface.xsig_int, Config.SiteId);
                return info.Protocol + "://" + info.IPAddressString + ':' + info.Port + '/' + info.VDir + "/VerifySignature.ashx";
            }
        }

        string _signUrl
        {
            get
            {
                if(_altSignUrl == null)
                {
                    IVirtualInterfaceInfo info = Config.GetVirtualInterface(VirtualInterface.xsig_int, Config.SiteId);
                    return info.Protocol + "://" + info.IPAddressString + ':' + info.Port + '/' + info.VDir + "/SignOnBehalf.ashx";
                }
                else
                {
                    return _altSignUrl;
                }
            }
        }

        int _xsigTimeout
        {
            get
            {
                IVirtualInterfaceInfo info = Config.GetVirtualInterface(VirtualInterface.xsig_int, Config.SiteId);
                return info.Timeout;
            }
        }

        public virtual void ReadFrom(BinaryReader r)
        {
            // read common data
            _operation    = r.ReadUInt16();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: operation="+_operation.ToString("d"));
            _version      = r.ReadUInt16();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: version="+_version.ToString("d"));
            _serviceId    = r.ReadUInt32();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: serviceId="+_serviceId.ToString("X"));
            _flags        = r.ReadUInt32();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: flags="+_flags.ToString("X"));
            _userPuid     = r.ReadUInt64();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: userPuid="+_userPuid.ToString("X"));
            _xboxPuid     = r.ReadUInt64();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: xboxPuid="+_xboxPuid.ToString("X"));
            _pathNameSize = r.ReadUInt16();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: pathNameSize="+_pathNameSize.ToString("d"));
            if ( _pathNameSize > 0 )
            {
                _pathName = Encoding.UTF8.GetString(r.ReadBytes(_pathNameSize));
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: pathName="+_pathName);
            }

            // read data specific to request token
            ReadFromInternal(r);

            // read signature data if present
            _signatureSize = r.ReadUInt16();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: signatureSize="+_signatureSize.ToString("d"));
            if ( _signatureSize > 0 )
            {
                _signature = r.ReadBytes(_signatureSize);
            }
        }
        
        public virtual void WriteTo(BinaryWriter w)
        {
            // write everything but the signature
            WriteToSign(w);
            
            // write the signature
            _signatureSize = (ushort) ((_signature == null ? 0 : ProtocolConstants.sizeSignature));

            w.Write(_signatureSize);
            if ( _signatureSize > 0 )
            {
                w.Write(_signature);
            }
        }
        
        // WriteToSign
        // Write all data excluding signature field.  Used to create byte array
        // to sign or validate using signature server.
        public virtual void WriteToSign(BinaryWriter w)
        {
            byte[] encodedName = null;
            
            _pathNameSize = 0;
            if ( _pathName != null )
            {
                encodedName = Encoding.UTF8.GetBytes(_pathName);
                _pathNameSize = (ushort) encodedName.Length;
            }
            
            w.Write(_operation);
            w.Write(_version);
            w.Write(_serviceId);
            w.Write(_flags);
            w.Write(_userPuid);
            w.Write(_xboxPuid);
            w.Write(_pathNameSize);
            if ( _pathNameSize > 0 )
            {
                w.Write(encodedName);
            }

            // write data specific to request token
            WriteToInternal(w);
        }
    
        protected virtual void ReadFromInternal(BinaryReader r)
        {
        }
        
        protected virtual void WriteToInternal(BinaryWriter w)
        {
        }

        protected virtual ushort SizeInternal()
        {
            return 0;
        }
        
        // Size
        // Return the size of the AccessToken in bytes
        public virtual ushort Size()
        {
            return (ushort) (baseTokenSize + _pathNameSize + _signatureSize + SizeInternal());
        }

        public virtual void Validate()
        {
            if ( _version != AccessToken.accessTokenVersion )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid version: " + _version);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_147, 
                    "Validate: invalid version: " + _version);
            }
            if ( _pathNameSize == 0 || _pathNameSize > ProtocolConstants.maxSizeName )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid pathNameSize: " + _pathNameSize);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_148, 
                    "Validate: invalid pathNameSize: " + _pathNameSize);
            }
            if ( _pathNameSize != _pathName.Length )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_149, 
                    "Validate: pathNameSize mismatch.");
            }
            if ( _signatureSize != 0 && _signatureSize != ProtocolConstants.sizeSignature )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid signature size: " + _signatureSize);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_150, 
                    "Validate: invalid signature size: " + _signatureSize);
            }
            
            // This check needs to be removed if we ever make use of the
            // flags field in the protocol.
            if ( _flags != 0 && _flags != 1 )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid flags: " + _flags);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_151, 
                    "Validate: invalid flags: " + _flags);
            }
        }

        // this version of SignOnBehalf will take the authData from SGInfo
        public virtual void SignOnBehalf(XOService serviceId)
        {
            SGInfo sgInfo = SGInfo.Current;
            
            XSigAuthData authData = new XSigAuthData();
            authData._titleID = sgInfo.TitleId;
            authData._titleVersion = sgInfo.TitleVersion;
            authData._userID1 = sgInfo.LogonUsers[0].qwUserID;
            authData._userID2 = sgInfo.LogonUsers[1].qwUserID;
            authData._userID3 = sgInfo.LogonUsers[2].qwUserID;
            authData._userID4 = sgInfo.LogonUsers[3].qwUserID;
            authData._XboxID = sgInfo.MachineId;
            
            SignOnBehalf(serviceId, authData);
        }

        public virtual void SignOnBehalf(XOService serviceId, XSigAuthData authData)
        {
            XSigSignOnBehalfRequest signRequest = new XSigSignOnBehalfRequest();
            signRequest._serviceId = (uint) serviceId;
            signRequest._authData = authData;            
            
            MemoryStream m = new MemoryStream();
            BinaryWriter w = new BinaryWriter(m);
            WriteToSign(w);
            byte[] b = m.ToArray();
            SHA1 sha1 = new SHA1CryptoServiceProvider();
            signRequest._digest = sha1.ComputeHash(b);

            // Make a single byte array with all of the required data needed
            // for the signature server request.  Making just 1 Write call
            // to send the request data instead of 3 separate Write calls for
            // the individual components makes the thread less likely to get
            // interrupted in midstream and thus less susceptable to timeouts.
            byte[] requestData = (byte[]) signRequest;
            
            HResult hr = HResult.S_OK;
            
            try
            {
                WebRequest req = WebRequest.Create( _signUrl);
                req.Timeout = _xsigTimeout;
                req.Method = "POST";
                req.ContentType = "xon/" + ((int)XOService.Signature_Server).ToString("x");
                req.ContentLength = requestData.Length;
                
                Stream reqStream = req.GetRequestStream();
                w = new BinaryWriter(reqStream);
                w.Write(requestData);
                reqStream.Close();

                WebResponse resp = req.GetResponse();
                Stream respStream = resp.GetResponseStream();
                BinaryReader r = new BinaryReader(respStream);
                hr = r.ReadUInt32();
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "SignOnBehalf: hr = " + hr);
                _signature = r.ReadBytes(ProtocolConstants.sizeSignature); //TODO: fix this
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "SignOnBehalf: XSig returned signature: " + ByteConvert.ToString(_signature));
            }
            catch (Exception e)
            {
                if ( e is WebException )
                {
                    WebException we = ((WebException) e);
                    string xerr = "";
                    string responseText = "";
                    
                    if ( we.Response != null )
                    {
                        StreamReader sr = new StreamReader(we.Response.GetResponseStream());
                        responseText = sr.ReadToEnd();
                        
                        if ( we.Response.Headers != null )
                        {
                            xerr = we.Response.Headers["X-Err"];
                        }
                    }
                    
                    Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "SignOnBehalf: caught exception: " + we + ", response: " + responseText);

                    if ( xerr != null && xerr != "" )
                    {
                        Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "SignOnBehalf: X-Err: " + xerr);
                        hr = HResult.Parse(xerr);
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "SignOnBehalf: No X-Err header found.");
                        hr = HResult.XONLINE_E_ACCESS_TOKEN_ERROR;
                    }
                }
                else
                {
                    Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "SignOnBehalf: caught exception: " + e);
                    hr = HResult.XONLINE_E_ACCESS_TOKEN_ERROR;
                }
            }
            
            if ( HResult.Failed(hr) )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "SignOnBehalf: failed with hr = " + hr);
                throw new XRLException(hr, XEvent.Id.COMMON_CODE_152, "SignOnBehalf: failed with hr = " + hr);
            }
        }

        public virtual uint SigningService
        {
            get
            {
                uint serviceId = BitConverter.ToUInt32(_signature, 4);
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "SigningService.get: signed on behalf of service: " + serviceId.ToString("x"));
                return serviceId;
            }
        }
    
        public virtual void VerifySignature()
        {
            VerifySignature((XOService)Int32.MinValue);
        }

        public virtual void VerifySignature(XOService serviceId)
        {
            MemoryStream m = new MemoryStream();
            BinaryWriter w = new BinaryWriter(m);
            WriteToSign(w);
            byte[] b = m.ToArray();
            SHA1 sha1 = new SHA1CryptoServiceProvider();
            byte[] digest = sha1.ComputeHash(b);
            
            HResult hr = HResult.E_FAIL;
            int expectedServiceId = (int) serviceId;
            
            try
            {
                // If serviceId == Int32.MinValue, then we don't care about
                // what service created the signature.
                if ( expectedServiceId != Int32.MinValue )
                {
                    // the service id that created the signature is stored as
                    // bytes 5-8 of the signature blob
                    uint actualServiceId = BitConverter.ToUInt32(_signature, 4);
                    Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, String.Format("VerifySignature: expected service id: {0}, actual service id: {1}", expectedServiceId, actualServiceId));

                    // Check the service id that was included in the
                    // signature.
                    if ( actualServiceId != expectedServiceId )
                    {
                        throw new
                            XRLException(HResult.XONLINE_E_STORAGE_INVALID_ACCESS_TOKEN, XEvent.Id.COMMON_CODE_153,
                                String.Format("VerifySignature: expected service id: {0}, found service id: {1}", expectedServiceId, actualServiceId));
                    }

                    // Also check the service id that was included in the
                    // protocol request.
                    if ( _serviceId != expectedServiceId )
                    {
                        throw new
                            XRLException(HResult.XONLINE_E_STORAGE_INVALID_ACCESS_TOKEN, XEvent.Id.COMMON_CODE_154,
                                String.Format("VerifySignature: expected service id: {0}, protocol service id: {1}", expectedServiceId, _serviceId));
                    }
                }

                // Make a single byte array with all of the required data
                // needed for the signature server request.  Making just 1
                // Write call to send the request data instead of 2 separate
                // Write calls for the digest and signature makes the thread
                // less likely to get interrupted in midstream and thus less
                // susceptable to timeouts.
                byte[] requestData = new byte[digest.Length + _signature.Length];
                Array.Copy(digest, 0, requestData, 0, digest.Length);
                Array.Copy(_signature, 0, requestData, digest.Length, _signature.Length);

                WebRequest req = WebRequest.Create(_verifyUrl);
                req.Timeout = _xsigTimeout;
                req.Method = "POST";
                req.ContentType = "xon/" + ((int)XOService.Signature_Server).ToString("x");
                req.ContentLength = digest.Length + _signature.Length;
                
                Stream reqStream = req.GetRequestStream();
                w = new BinaryWriter(reqStream);
                w.Write(requestData);
                reqStream.Close();

                WebResponse resp = req.GetResponse();
                Stream respStream = resp.GetResponseStream();
                BinaryReader r = new BinaryReader(respStream);
                hr = r.ReadUInt32();
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "VerifySignature: hr = " + hr);
            }
            catch (Exception e)
            {
                if ( e is WebException )
                {
                    WebException we = ((WebException) e);
                    string xerr = "";
                    string responseText = "";

                    if ( we.Response != null )
                    {
                        StreamReader sr = new StreamReader(we.Response.GetResponseStream());
                        responseText = sr.ReadToEnd();

                        if ( we.Response.Headers != null )
                        {
                            xerr = we.Response.Headers["X-Err"];
                        }
                    }
                    
                    Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "VerifySignature: caught exception: " + we + ", response: " + responseText);
                    
                    if ( xerr != null && xerr != "" )
                    {
                        Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "VerifySignature: X-Err: " + xerr);
                        hr = HResult.Parse(xerr);

                        // We will log a security error event that contains the
                        // specific xerr from the signature server and all of
                        // the SGInfo associated with the request.
                        Xom.NtEvent(XEvent.Id.COMMON_HACK_7, we,
                            "AccessToken.VerifySignature: signature server returned hr = " + xerr
                        );
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "VerifySignature: No X-Err header found.");

                        if (we.Status == WebExceptionStatus.Timeout)
                        {
                            Xom.NtEvent(XEvent.Id.COMMON_COMM_12, we, 
                               "AccessToken.VerifySignature: signature server timeout error; current timeout is " + _xsigTimeout + " ms.  " +
                               "Verify that the signature server is running and there is connectivity to STFD."
                            );
                        }
                        else
                        {
                            Xom.NtEvent(XEvent.Id.COMMON_COMM_13, we, 
                                "AccessToken.VerifySignature: failed to receive response from signature server."
                            );
                        }
                        hr = HResult.XONLINE_E_ACCESS_TOKEN_ERROR;
                    }
                }
                else
                {
                    Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "VerifySignature: caught exception: " + e);
                    hr = HResult.XONLINE_E_ACCESS_TOKEN_ERROR;
                }
            }
            
            if ( HResult.Failed(hr) )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "VerifySignature: failed with hr = " + hr);
                throw new XRLException(hr, XEvent.Id.COMMON_CODE_155, "VerifySignature: failed");
            }
        }
    
        public override string ToString()
        {
            return
                " _operation:"+((ushort)_operation)+
                " _version:"+_version+
                " _serviceId:0x"+_serviceId.ToString("X")+
                " _flags:"+_flags+
                " _userPuid:0x"+_userPuid.ToString("X")+
                " _xboxPuid:0x"+_xboxPuid.ToString("X")+
                " _pathNameSize:"+_pathNameSize+
                " _pathName:"+_pathName+
                " _signatureSize:"+_signatureSize+
                " _signature:"+(_signature!=null ? "(binary)" : "null");
        }
        
        public void SetAltSignUrl(
            string altSignUrl
        )
        {
            _altSignUrl = altSignUrl;
        }
    }

    public class ReadFileToken : AccessToken
    {
        public long _tokenExpirationDate;

        public ReadFileToken()
        {
        }
        
        public ReadFileToken(BinaryReader r)
        {
            this.ReadFrom(r);
        }
        
        protected override void ReadFromInternal(BinaryReader r)
        {
            _tokenExpirationDate = r.ReadInt64();
        }

        protected override void WriteToInternal(BinaryWriter w)
        {
            w.Write(_tokenExpirationDate);
        }

        protected override ushort SizeInternal()
        {
            return 8;
        }
        public override void Validate()
        {
            base.Validate();

            // TODO: there should be base class that ReadFileToken and EnumerateFilesToken derive from.  For now, let enumerate use ReadFileToken class
            if ( _operation != (ushort) Operation.FileRead && _operation != (ushort) Operation.FileEnumerate &&
                 _operation != (ushort) Operation.ReadTitleFiles)
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid operation: " + _operation);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_156, 
                    "Validate: invalid operation: " + _operation);
            }

            if ( _tokenExpirationDate != 0 && _tokenExpirationDate < DateTime.Now.ToFileTime() )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_157,
                    "Validate: tokenExpirationDate is in the past: " + _tokenExpirationDate);
            }
        }
    }

    public class WriteFileToken : AccessToken
    {
        public long _tokenExpirationDate;
        public long _fileExpirationDate;
        public uint _maxFileSize;

        public WriteFileToken()
        {
        }
        
        public WriteFileToken(BinaryReader r)
        {
            this.ReadFrom(r);
        }
        
        protected override void ReadFromInternal(BinaryReader r)
        {
            _tokenExpirationDate = r.ReadInt64();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "WriteFileToken: ReadFrom: tokenExpirationDate="+_tokenExpirationDate.ToString());
            _fileExpirationDate = r.ReadInt64();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "WriteFileToken: ReadFrom: fileExpirationDate="+_fileExpirationDate.ToString());
            _maxFileSize = r.ReadUInt32();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "WriteFileToken: ReadFrom: maxFileSize="+_maxFileSize.ToString());
        }

        protected override void WriteToInternal(BinaryWriter w)
        {
            w.Write(_tokenExpirationDate);
            w.Write(_fileExpirationDate);
            w.Write(_maxFileSize);
        }

        protected override ushort SizeInternal()
        {
            return 20;
        }

        public override void Validate()
        {
            base.Validate();
            
            if ( _operation != (ushort) Operation.FileWrite )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid operation: " + _operation);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_158, 
                    "Validate: invalid operation: " + _operation);
            }

            // DateTime.Now gives us localtime; calling ToFileTime() adds
            // UTC offset giving us a result that is the current time in UTC
            long now = DateTime.Now.ToFileTime();
            
            if ( _fileExpirationDate != 0 && _fileExpirationDate < now )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: fileExpirationDate is in the past.");
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_159,
                    "Validate: fileExpirationDate is in the past: " + _fileExpirationDate);
            }
            if ( _tokenExpirationDate != 0 && _tokenExpirationDate < now )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_160,
                    "Validate: tokenExpirationDate is in the past: " + _tokenExpirationDate);
            }
        }

        public override string ToString()
        {
            string baseString = base.ToString();
            return baseString +
                " _fileExpirationDate:" + 
                " _maxFileSize:"+_maxFileSize;
        }
    }
    
    public class RemoveFileToken : AccessToken
    {
        public long _tokenExpirationDate;

        public RemoveFileToken()
        {
        }
        
        public RemoveFileToken(BinaryReader r)
        {
            this.ReadFrom(r);
        }
        
        protected override void ReadFromInternal(BinaryReader r)
        {
            _tokenExpirationDate = r.ReadInt64();
        }

        protected override void WriteToInternal(BinaryWriter w)
        {
            w.Write(_tokenExpirationDate);
        }

        protected override ushort SizeInternal()
        {
            return 8;
        }
    
        public override void Validate()
        {
            base.Validate();
            
            if ( _operation != (ushort) Operation.FileRemove )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid operation: " + _operation);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_161, 
                    "Validate: invalid operation: " + _operation);
            }
            if ( _tokenExpirationDate != 0 && _tokenExpirationDate < DateTime.Now.ToFileTime() )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_162,
                    "Validate: tokenExpirationDate is in the past: " + _tokenExpirationDate);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\plugins\ProvisioningUtil.cs ===
namespace xonline.common.plugins
{

    // parallel to npdb.dbo.t_provisioning_events
    // Event: n., describes the type of change in status from a billing partner perspective
    public enum ProvisioningEvent 
    {
        InvalidEvent    = 0,
        Provision       = 1,
        Enable          = 2,
        Disable         = 3,
        Deprovision     = 4,
        MaxEvent        = 5
    }


    //since these strings will be used to retrieve parameters from the XML-Hashtable, 
    //these string constants will help standardize them so fewer parameter spelling issues will occur
    //having them collected in one place here should make them more discoverable.
    //...it bugs me to have to look at running services or read lots of code 
    //to find the names of name-value pairs...
    public class ProvConst
    {
        //if you change these, you must change code in Provisioning.cs
        public const    string ProvisionJobPreface = "Prov Action=";
        public const    string ServiceJobPreface = "ProvSA";

        // For Provisioning Plug-in jobs
        // these jobs get info from XCBK
        public const    string EventID = "ProvEvtID";           // what kind of provisioning event occurred?
//        public const    string ComponentIDString = "PCmptID";   
//        public const    string lPUIDHigh = "lPUIDHigh";             
//        public const    string lPUIDLow = "lPUIDLow";
        public const    string bstrServiceComponentId = "SvcCpt";  // what component was the subject of the action?

        //not all provisioning events have the same info... 
        public const    string bstrServiceInstanceId = "strScInstId";
        public const    string bstrServiceInstanceFriendlyName = "strSvcInstFrNm";
        public const    string bstrBaseServiceInstanceId = "strBsSvcInstId";
        public const    string bstrDetails = "strDetails";

        // For Service-Specific Plug-in jobs
        // these jobs get their info from the provisioning plug-in and the provisioning actions table
        public const    string SvcPreface = "Svc";                  // what service-specific plug-in
        public const    string SvcActionPreface = "SA";
        public const    string PUIDKey = "PUID";          // what PUID was the subject of the action? (combined hi/lo)

        public const    int    MaxJobNameLength = 100;  // corresponds to t_cron_job.vc_name width... 
    }	

    internal class ProvisioningUtil
    {

        //this is the string XCBK uses to create jobs, and which Decision Plug-in uses to search 
        // for other jobs for the same user.  Not to be confused with creating jobs for Service Specific Plug-ins... 
        // Centralizing this code keeps the string format consistent... 
        // ANY changes to these should consider the need for backwards compatibility of strings... 
        public static string CreateProvisioningJobName( ProvisioningEvent eventType, long puid, string svcComponentID )
        {
            // check params first
            if ( ( eventType <= ProvisioningEvent.InvalidEvent ) || ( eventType >= ProvisioningEvent.MaxEvent ) )
            {
                throw new InvalidProvisioningTaskNameException("Invalid event type ( " + eventType + " ) passed to CreateJobName." );
            }


//NOTE: commented out these checks to resolve 19769, but I still think *some* checks should be done.  I'll revisit this later.
            // min_puid = CAST(0x0009000000000000 AS BIGINT) from init_puid_idgen.sql
//            if ( puid < 2533274790395904 )
//            {
//               throw new InvalidProvisioningTaskNameException("Invalid PUID ( " + puid + " ) passed to CreateJobName." );
//            }

            //per bug 19769, relaxing this restrction
            if ( svcComponentID.Length < 1 )
            {
                throw new InvalidProvisioningTaskNameException("Invalid svcComponentID ( " + svcComponentID + " ) passed to CreateJobName." );
            }

            string tmpName = ProvConst.ProvisionJobPreface + eventType + " PUID=" + puid + " " + ProvConst.bstrServiceComponentId + "=" + svcComponentID;

            if ( tmpName.Length > ProvConst.MaxJobNameLength )
            {
                throw new InvalidProvisioningTaskNameException("The provisioning job name must be less than " + ProvConst.MaxJobNameLength + " chars long, but was " + tmpName.Length + " chars long. Name was: " +  tmpName); // Might be Service Component (" + svcComponentID + ") or event type (" + eventType + ")." );
            }

            return tmpName;
        }


        //task: suffix job "name" information from npdb to this string

        //format a name string for service-specific cron jobs
        public static string CreateServiceSpecificJobName( ProvisioningEvent eventType, long puid, string svcComponentID, string service, byte svcAction )
        {
            // check params 

            // valid ProvisioningEvent
            if ( ( eventType <= ProvisioningEvent.InvalidEvent ) || ( eventType >= ProvisioningEvent.MaxEvent ) )
            {
                throw new InvalidServiceTaskNameException("Invalid event type ( " + eventType + " ) passed to CreateJobName." );
            }


//NOTE: commented out these checks to resolve 19769, but I still think *some* checks should be done.  I'll revisit this later.            
            // min_puid = CAST(0x0009000000000000 AS BIGINT) from init_puid_idgen.sql
//            if ( puid < 2533274790395904 )
//            {
//                throw new InvalidServiceTaskNameException("Invalid PUID ( " + puid + " ) passed to CreateJobName." );
//            }
            
            // ComponentID must have *something*
            if ( svcComponentID.Length < 1 )
            {
                throw new InvalidServiceTaskNameException("Invalid svcComponentID ( " + svcComponentID + " ) passed to CreateJobName. Must be at least 5 chars." );
            }

            // service
            if ( service.Length < 1 )
            {
                throw new InvalidServiceTaskNameException("Service name must be at least 1 chars." );
            }

            //type checking makes sure svcAction is < 256

            string tmpName = ProvConst.ServiceJobPreface + " " + (int)eventType + " " + ProvConst.PUIDKey + "=" + puid + " " + ProvConst.bstrServiceComponentId + "=" + svcComponentID + " " + ProvConst.SvcPreface + "=" + service + " " + ProvConst.SvcActionPreface + "=" + svcAction;

            if ( tmpName.Length > ProvConst.MaxJobNameLength )
            {
                throw new InvalidServiceTaskNameException("The svc action job name must be less than " + ProvConst.MaxJobNameLength + " chars long, but was " + tmpName.Length + " chars long. Name was: " +  tmpName); // Might be Service Component (" + svcComponentID + ") or event type (" + eventType + ")." );
            }

            return tmpName;
        }

    } //provisioningutil

    
    public class InvalidProvisioningTaskNameException : System.Exception
    {
        const string message = "An Invalid parameter for a provisioning task name was encountered.";
        public InvalidProvisioningTaskNameException( ) :  base( message ) { }
        public InvalidProvisioningTaskNameException( string exceptionString ) :  base( message + exceptionString ) { }
    }

    public class InvalidServiceTaskNameException : System.Exception
    {
        const string message = "An Invalid parameter for a provisioning task name was encountered.";
        public InvalidServiceTaskNameException( ) :  base( message ) { }
        public InvalidServiceTaskNameException( string exceptionString ) :  base( message + exceptionString ) { }
    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\BlockUtil.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;

namespace xonline.common.protocol
{
    public class XeGenericBlock : WireData
    {
        public const int BLOCK_MAX_LEN = 3000;

        [WireInfo(Min=1, Max=BLOCK_MAX_LEN)]
        public ushort blockLength;

        [WireInfo(SizeParam="blockLength", LimitString=true)]
        public byte[] block;
    }

    public class BlockSerializer
    {
        public BlockSerializer(byte[] bytes, int minBlocks, int maxBlocks)
        {
            _bytes = bytes;
            if (minBlocks > maxBlocks)
            {
                throw new ArgumentException("minBlocks cannot be greater than maxBlocks");
            }
            _minBlocks = minBlocks;
            _maxBlocks = maxBlocks;
            _blockCount = ( (bytes.Length - 1) / MAX_BLOCK_LEN) + 1;
        }

        public bool IsEmptyBlockCount
        {
            get
            {
                return _bytes.Length == 0;
            }
        }

        public bool IsBlockCountOutOfRange
        {
            get
            {
                return _blockCount < _minBlocks || _blockCount > _maxBlocks;
            }
        }

        public XeGenericBlock[] Serialize()
        {
            if (IsEmptyBlockCount || IsBlockCountOutOfRange)
            {
                throw new Exception("Cannot serialize the bytes into a XeGenericblock--you should do verification with IsEmptyBlockCount and IsBlockCountOutOfRange.");
            }

            int currentBlockLen = _bytes.Length;
            int thisBlockLen = 0;

            XeGenericBlock[] blocks = new XeGenericBlock[_blockCount];

            for (int i = 0; i < _blockCount; ++i)
            {
                thisBlockLen = Math.Min( MAX_BLOCK_LEN, currentBlockLen );
                currentBlockLen -= thisBlockLen;

                blocks[i] = new XeGenericBlock();
                blocks[i].blockLength = (ushort)thisBlockLen;
                blocks[i].block = new byte[thisBlockLen];
                Array.Copy(_bytes, i * MAX_BLOCK_LEN, blocks[i].block, 0, thisBlockLen);
            }

            return blocks;
        }

        private readonly byte[] _bytes;
        private readonly int _minBlocks;
        private readonly int _maxBlocks;
        private readonly int _blockCount;

        private const int MAX_BLOCK_LEN = XeGenericBlock.BLOCK_MAX_LEN;
    }

    public class BlockDeserializer
    {
        public BlockDeserializer(XeGenericBlock[] blocks)
        {
            _blocks = blocks;
        }

        public byte[] Deserialize()
        {
            List<byte> listBytes = new List<byte>();
            foreach (XeGenericBlock block in _blocks)
            {
                listBytes.AddRange(block.block);
            }
            return listBytes.ToArray();
        }

        private readonly XeGenericBlock[] _blocks;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\ArbitrationProt.cs ===
/*==========================================================================
 *
 *  ArbitrationProt.cs -- This module defines the wire protocol for Arbitration service apis
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.IO;
using xonline.common.service;


namespace xonline.common.protocol 
{
    public enum ArbitrationSessionOutcome { Undetermined, Successful, Minority, Failed, Problematic }

    public class ArbitrationXUIDAndTrust : WireData
    {
        [WireInfo(HexString=true)]
        public ulong qwUserID;
        [WireInfo(HexString=true)]
        public uint dwUserFlags;
        public float userTrust;
    }
    
    public class ArbitrationBundle : WireData
    {
        public int index;
        public uint count;
        public double totalTrust;
    }
    
    public class ArbitrationXboxInfo : WireData
    {
        public byte timeExtendCount;
        public byte reportCount;
        [WireInfo(HexString=true)]
        public ushort reportFlags;
        [WireInfo(HexString=true)]
        public ulong xboxID;
        public int userCount;
        [WireInfo(SizeParam="userCount")]        
        public ArbitrationXUIDAndTrust[] users;
        public double trust;
        public byte normalizedTrust;
        public int bundleIndex;
        public int diconnectedXboxCount;
        [WireInfo(SizeParam="diconnectedXboxCount", HexString=true)]        
        public ulong[] diconnectedXboxes;
    }

    public class ArbitrationSuspiciousInfo : WireData
    {
        public int type; // 1, 2, or 3
        public int messageLen;
        public string message;
        public int xboxCount;
        [WireInfo(SizeParam="xboxCount", HexString=true)]        
        public ulong[] xboxes;
        public int userCount;
        [WireInfo(SizeParam="userCount", HexString=true)]        
        public ulong[] users;
    }

    public class ArbitrationTitleParameters : WireData
    {
        public double BaseTrust; // Base trust rewarded per Xbox
        public double MinorityQuorum;
        public double UserTournamentAmplification;
        public double PublisherTournamentAmplification;
        public uint BaseSessionTime;
        public double FermiK; // Constant in Fermi function
    }

    //
    // Request for DebugResult
    //
    public class ArbitrationDebugResultRequest : XRLObject2
    {
        public ushort version;
        [WireInfo(HexString=true)]
        public ushort flags;
        [WireInfo(HexString=true)]
        public uint titleID;
        [WireInfo(HexString=true)]
        public ulong sessionID;
        [WireInfo(HexString=true)]
        public ulong sessionNonce;

        public byte[] sessionKey
        {
            get
            {
                MemoryStream titleIDSessionIDAndNonceMemStream = new MemoryStream(20);
                BinaryWriter writer = new BinaryWriter(titleIDSessionIDAndNonceMemStream);
                writer.Write(titleID);
                writer.Write(sessionID);
                writer.Write(sessionNonce);
                return (byte[])titleIDSessionIDAndNonceMemStream.ToArray();
            }
        }
    }
    
    //
    // Response from DebugResult request
    //
    public class ArbitrationDebugResultResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public uint titleID;
        [WireInfo(HexString=true)]
        public ulong sessionID;
        [WireInfo(HexString=true)]
        public ulong sessionNonce;
        public ArbitrationTitleParameters titleParameters;
        [WireInfo(HexString=true)]
        public ushort flags;
        public ushort maxSessionSeconds;
        public ushort secondsLeftTillTimeout;
        public DateTime startTime;
        public double sessionSeconds;
        
        public int xboxCount;
        [WireInfo(SizeParam="xboxCount")]        
        public ArbitrationXboxInfo[] xboxes;

        public int teamTicketCount;
        
        public double totalTrust;
        public uint reportCount;
        public bool arbitrated;
        
        public int result; // ArbitrationSessionOutcome
        public int nonProblematicResult; // ArbitrationSessionOutcome
        public float trustModificationScale;

        public int bundleCount;
        [WireInfo(SizeParam="bundleCount")]        
        public ArbitrationBundle[] bundles;
        public int submittedBundleIndex;
        
        public int suspiciousInfoCount;
        [WireInfo(SizeParam="suspiciousInfoCount")]        
        public ArbitrationSuspiciousInfo[] suspiciousInfo;
    }
    
    
    // 
    // Request for ReportResult
    //
    public class ArbitrationReportResultRequest : XRLObject2
	{
		public class Flags
		{
			public const ushort VoluntarilyQuit=0x8000;
			public const ushort SessionHost=0x4000;
			public const ushort LostConnectivity=0x2000;
			public const ushort LostConnectivityInfoSubmit=0x1000;
			public const ushort SuspiciousInfo1Submit=0x0800;
			public const ushort SuspiciousInfo2Submit=0x0400;
			public const ushort SuspiciousInfo3Submit=0x0200;
			public const ushort StatsBundleInfoSubmit=0x0100;
			public const ushort TournamentBundleInfoSubmit=0x0080;

			public const ushort flagMask=VoluntarilyQuit|SessionHost|LostConnectivity|LostConnectivityInfoSubmit|SuspiciousInfo1Submit|SuspiciousInfo2Submit|SuspiciousInfo3Submit|StatsBundleInfoSubmit|TournamentBundleInfoSubmit;

		}

		public ushort protocolVersion=1;
		public ushort flags=0;
		public uint titleId=XOn.DASH_TITLE_ID;
		public ulong sessionId=0UL;
		public ulong sessionNonce=0UL;
		public LostConnectivityInfo lostConnectivityInfo=null;
		public SuspiciousInfo type1SuspiciousInfo= null;
		public SuspiciousInfo type2SuspiciousInfo= null;
		public SuspiciousInfo type3SuspiciousInfo= null;
		public StatsBundle statsBundle= null;
		public TournamentBundle tournamentBundle=null;
        

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(protocolVersion);
            binaryWriter.Write(flags);
            binaryWriter.Write(titleId);
            binaryWriter.Write(sessionId);
            binaryWriter.Write(sessionNonce);
            if (lostConnectivityInfo != null) lostConnectivityInfo.WriteStream(binaryWriter);
    		if (type1SuspiciousInfo != null) type1SuspiciousInfo.WriteStream(binaryWriter);
    		if (type2SuspiciousInfo!= null) type2SuspiciousInfo.WriteStream(binaryWriter);
    		if (type3SuspiciousInfo!= null) type3SuspiciousInfo.WriteStream(binaryWriter);
    		if (statsBundle!= null) statsBundle.WriteStream(binaryWriter);
    		if (tournamentBundle!= null) tournamentBundle.WriteStream(binaryWriter);;
            
        }
            
        

    }
    
	/// <summary>
	/// Arbitration ReportResult request LostConnectivityInfo wiredata
	/// </summary>
	public class LostConnectivityInfo : WireData
	{
		public byte xboxPuidLen=0;
		public ulong[] xboxPuid=null;
	}
	
	/// <summary>
	/// Arbitration ReportResult request SuspiciousInfo wiredata
	/// </summary>
	public class SuspiciousInfo : WireData
	{
		public byte messageLen=0;
		public byte[] message=null;
		public byte relatedXboxLen=0;
		public ulong[] relatedXbox=null;
		public byte relatedUserLen=0;
		public ulong[] relatedUser=null;
	}

	/// <summary>
	/// Arbitration ReportResult request StatsBundle wiredata
	/// </summary>
	public class StatsBundle : WireData
	{
		public uint bundleLen=0;
		public byte[] bundle=null;
	}

	/// <summary>
	/// Arbitration ReportResult request TournamentBundle wiredata
	/// </summary>
	public class TournamentBundle : WireData
	{
		public uint bundleLen=0;
		public byte[] bundle=null;
	}
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\clientVersion.cs ===
// 
// ClientVersion.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Client Version Data
// Xbox Online Service
// 

using xonline.common.service;


namespace xonline.common.protocol 
{
    public class ClientVersion : WireData
    {
        // Need default constructor for deserialization
        public ClientVersion()
        {
        }
        
        public ClientVersion(ulong version)
        {
            Version = version;
        }
        
        public ClientVersion(ushort wMajor, ushort wMinor, ushort wQFE, ushort wBuild)
        {
            wMajorVersion = wMajor;
            wMinorVersion = wMinor;
            wQFENumber = wQFE;
            wBuildNumber = wBuild;
        }
        
        public ushort               wMajorVersion;
        public ushort               wMinorVersion;
        public ushort               wBuildNumber;
        public ushort               wQFENumber;

        public ulong Version
        {
            get 
            { 
                return Create(wMajorVersion, wMinorVersion, wQFENumber, wBuildNumber);
            }
                
            set 
            {
                wMajorVersion = (ushort) (value >> (int)48);
                wMinorVersion = (ushort) (value >> (int)32);
                wQFENumber = (ushort) (value >> (int)16);
                wBuildNumber = (ushort) (value);
            }
        }

        public static explicit operator ulong (ClientVersion client)
        {
            return client.Version;
        }
        
        public static ulong Create(ushort wMajor, ushort wMinor, ushort wQFE, ushort wBuild)
        {
            return ((ulong)wMajor << 48) + ((ulong)wMinor << 32) + ((ulong)wQFE << 16) + ((ulong)wBuild); 
        }               
    }


    public class XboxVersion
    {
        //
        // Xenon XDK Released Clients    
        //  This data is pulled from http://teams/sites/xsoft/Release%20and%20Status/XeDKReleaseHistory.xls
        //
        public static ulong FEB_2005_ALPHA_XEDK      = ClientVersion.Create( 0, 0, 0, 1242 ); // released 1/31/2005
        public static ulong DEC_2004_ALPHA_XEDK      = ClientVersion.Create( 0, 0, 0, 1141 ); // released 12/10/2004
        public static ulong NOV_2004_ALPHA_XEDK      = ClientVersion.Create( 0, 0, 0, 1029 ); // released 10/29/2004
        public static ulong OCT_2004_ALPHA_XEDK      = ClientVersion.Create( 0, 0, 0, 0930 ); // released 9/30/2004
        public static ulong SEPT_2004_ALPHA_XEDK     = ClientVersion.Create( 0, 0, 0, 0834 ); // released 9/2/2004
        public static ulong AUG_2004_ALPHA_XEDK      = ClientVersion.Create( 0, 0, 0, 0731 ); // released 8/2/2004
        public static ulong JULY_2004_ALPHA_XEDK     = ClientVersion.Create( 0, 0, 0, 0634 ); // released 7/2/2004
        public static ulong JUNE_2004_ALPHA_XEDK_2   = ClientVersion.Create( 0, 0, 1, 0530 ); // released 6/16/2004
        public static ulong JUNE_2004_ALPHA_XEDK     = ClientVersion.Create( 0, 0, 0, 0530 ); // released 5/27/2004
        public static ulong MAY_2004_ALPHA_XEDK      = ClientVersion.Create( 0, 0, 0, 0431 ); // released 4/30/2004
        public static ulong APRIL_2004_ALPHA_XEDK    = ClientVersion.Create( 0, 0, 0, 0338 ); // released 4/2/2004
        public static ulong A6_ALPHA_XEDK            = ClientVersion.Create( 0, 0, 0, 0211 ); // released 2/20/2004
        public static ulong A5_ALPHA_XEDK            = ClientVersion.Create( 0, 0, 0, 0199 ); // released 2/6/2004


        //
        // XBOX 1 XDK Released Clients    
        //  This data is pulled from http://teams/sites/xsoft/Release%20and%20Status/Archive/XDKReleaseHistory.xls
        //
        public static ulong DEC_2003_3_XDK     = ClientVersion.Create( 0, 0, 6, 5849 );   // released 5/19/2004
        public static ulong DEC_2003_2_XDK     = ClientVersion.Create( 0, 0, 4, 5849 );   // released 4/22/2004
        public static ulong DEC_2003_XDK       = ClientVersion.Create( 0, 0, 0, 5849 );   // released 12/19/2003
        public static ulong NOV_2003_2_XDK     = ClientVersion.Create( 0, 0, 2, 5788 );   // released 11/20/2003
        public static ulong NOV_2003_XDK       = ClientVersion.Create( 0, 0, 0, 5788 );   // released 11/12/2003
        public static ulong AUG_2003_4_XDK     = ClientVersion.Create( 0, 0, 5, 5659 );   // released 11/20/2003
        public static ulong AUG_2003_3_XDK     = ClientVersion.Create( 0, 0, 4, 5659 );   // released 10/3/2003
        public static ulong AUG_2003_2_XDK     = ClientVersion.Create( 0, 0, 2, 5659 );   // released 9/30/2003
        public static ulong AUG_2003_XDK       = ClientVersion.Create( 0, 0, 0, 5659 );   // released 7/30/2003
        public static ulong JUNE_2003_3_XDK    = ClientVersion.Create( 0, 0, 4, 5558 );   // released 10/3/2003
        public static ulong JUNE_2003_2_XDK    = ClientVersion.Create( 0, 0, 2, 5558 );   // released 6/20/2003
        public static ulong JUNE_2003_XDK      = ClientVersion.Create( 0, 0, 0, 5558 );   // released 5/30/2003
        public static ulong APRIL_2003_2_XDK   = ClientVersion.Create( 0, 0, 2, 5455 );   // released 4/18/2003
        public static ulong APRIL_2003_XDK     = ClientVersion.Create( 0, 0, 0, 5455 );   // released 4/4/2003
        public static ulong FEB_2003_4_XDK     = ClientVersion.Create( 0, 0, 4, 5344 );   // released 4/9/2003
        public static ulong FEB_2003_3_XDK     = ClientVersion.Create( 0, 0, 3, 5344 );   // released 3/18/2003
        public static ulong FEB_2003_2_XDK     = ClientVersion.Create( 0, 0, 2, 5344 );   // released 2/17/2003
        public static ulong FEB_2003_XDK       = ClientVersion.Create( 0, 0, 0, 5344 );   // released 2/4/2003
        public static ulong DEC_2002_4_XDK     = ClientVersion.Create( 0, 0, 5, 5233 );   // released 4/9/2003
        public static ulong DEC_2002_3_XDK     = ClientVersion.Create( 0, 0, 4, 5233 );   // released 3/18/2003
        public static ulong DEC_2002_2_XDK     = ClientVersion.Create( 0, 0, 3, 5233 );   // released 2/17/2003
        public static ulong DEC_2002_XDK       = ClientVersion.Create( 0, 0, 0, 5233 );   // released 12/12/2002
        public static ulong NOV_2002_3_XDK     = ClientVersion.Create( 0, 0, 4, 5120 );   // released 4/9/2003
        public static ulong NOV_2002_2_XDK     = ClientVersion.Create( 0, 0, 3, 5120 );   // released 3/18/2003
        public static ulong NOV_2002_XDK       = ClientVersion.Create( 0, 0, 0, 5120 );   // released 10/31/2002
        public static ulong OCT_2002_3_XDK     = ClientVersion.Create( 0, 0, 4, 5028 );   // released 3/18/2003
        public static ulong OCT_2002_2_XDK     = ClientVersion.Create( 0, 0, 3, 5028 );   // released 10/18/2003
        public static ulong OCT_2002_XDK       = ClientVersion.Create( 0, 0, 0, 5028 );   // released 10/4/2002
        public static ulong SEPT_2002_5_XDK    = ClientVersion.Create( 0, 0, 7, 4928 );   // released 3/18/2003
        public static ulong SEPT_2002_4_XDK    = ClientVersion.Create( 0, 0, 4, 4928 );   // released 10/18/2003
        public static ulong SEPT_2002_3_XDK    = ClientVersion.Create( 0, 0, 3, 4928 );   // released 10/3/2003
        public static ulong SEPT_2002_2_XDK    = ClientVersion.Create( 0, 0, 2, 4928 );   // released 9/12/2002
        public static ulong SEPT_2002_XDK      = ClientVersion.Create( 0, 0, 0, 4928 );   // released 8/28/2002
        public static ulong AUG_2002_5_XDK     = ClientVersion.Create( 0, 0, 9, 4831 );   // released 10/18/2003
        public static ulong AUG_2002_4_XDK     = ClientVersion.Create( 0, 0, 8, 4831 );   // released 9/12/2003
        public static ulong AUG_2002_3_XDK     = ClientVersion.Create( 0, 0, 6, 4831 );   // released 8/29/2003
        public static ulong AUG_2002_2_XDK     = ClientVersion.Create( 0, 0, 5, 4831 );   // released 8/23/2002
        public static ulong AUG_2002_XDK       = ClientVersion.Create( 0, 0, 0, 4831 );   // released 7/31/2002
        public static ulong JULY_2002_XDK      = ClientVersion.Create( 0, 0, 0, 4721 );   // released 6/26/2002
        public static ulong JUNE_2002_XDK      = ClientVersion.Create( 0, 0, 0, 4627 );   // released 6/5/2002
        public static ulong MAY_2002_XDK       = ClientVersion.Create( 0, 0, 0, 4531 );   // released 4/28/2002
        public static ulong APRIL_2002_XDK     = ClientVersion.Create( 0, 0, 0, 4432 );   // released 3/29/2002
        public static ulong MAR_2002_2_XDK     = ClientVersion.Create( 0, 0, 2, 4361 );   // released 3/15/2002
        public static ulong MAR_2002_XDK       = ClientVersion.Create( 0, 0, 0, 4361 );   // released 2/28/2002
        public static ulong FEB_2002_2_XDK     = ClientVersion.Create( 0, 0, 2, 4242 );   // released 3/15/2002
        public static ulong FEB_2002_XDK       = ClientVersion.Create( 0, 0, 0, 4242 );   // released 1/30/2002
        public static ulong DEC_2001_4_XDK     = ClientVersion.Create( 0, 0, 7, 4134 );   // released 3/19/2002
        public static ulong DEC_2001_3_XDK     = ClientVersion.Create( 0, 0, 6, 4134 );   // released 1/29/2002
        public static ulong DEC_2001_2_XDK     = ClientVersion.Create( 0, 0, 2, 4134 );   // released 1/3/2002
        public static ulong DEC_2001_XDK       = ClientVersion.Create( 0, 0, 0, 4134 );   // released 12/11/2001
        public static ulong NOV_2001_4_XDK     = ClientVersion.Create( 0, 0, 5, 4039 );   // released 3/19/2002
        public static ulong NOV_2001_3_XDK     = ClientVersion.Create( 0, 0, 4, 4039 );   // released 1/29/2002
        public static ulong NOV_2001_2_XDK     = ClientVersion.Create( 0, 0, 2, 4039 );   // released 11/9/2001
        public static ulong NOV_2001_XDK       = ClientVersion.Create( 0, 0, 0, 4039 );   // released 10/30/2001
        public static ulong AUG_2001_4_XDK     = ClientVersion.Create( 0, 0, 0, 3950 );   // released 1/29/2002
        public static ulong AUG_2001_3_XDK     = ClientVersion.Create( 0, 0, 0, 3948 );   // released 11/9/2001
        public static ulong AUG_2001_2_XDK     = ClientVersion.Create( 0, 0, 0, 3941 );   // released 9/18/2001
        public static ulong AUG_2001_XDK       = ClientVersion.Create( 0, 0, 0, 3911 );   // released 8/13/2001
    }


} // namespace xonline.common.protocol
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\cronprot.cs ===
/*==========================================================================
 *
 *  cronwire.cs -- This module defines the wire protocol for cron service apis
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using xonline.common.service;

namespace xonline.common.protocol 
{
    public class AddJobRequest : XRLObject2
    {
        public uint nameLen;             
        [WireInfo(SizeParam="nameLen")]        
        public string name;
        
        public uint titleId;
        
        public uint assemblyLen;
        [WireInfo(SizeParam="assemblyLen")]        
        public string assembly;
        
        public uint classLen;    
        [WireInfo(SizeParam="classLen")]        
        public string className;
    
        public uint argsLen;
        [WireInfo(SizeParam="argsLen")]        
        public string argsXml;
    
        public DateTime nextExec;
        public uint intervalSecs;
        public uint execCount;
        public uint timeoutSecs;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/cron/addjob.ashx";
            }
        }
    }

    public class AddJobResponse : XRLObject2
    {
        public int jobId;
    }

    
    public class RemoveJobRequest : XRLObject2
    {
        public int jobId;
        public uint titleId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/cron/removejob.ashx";
            }
        }
    }

    public class CronJobWire : XRLObject2
    {
        public int jobId;
        
        public uint nameLen;        
        [WireInfo(SizeParam="nameLen")]        
        public string name;
        
        public uint titleId;
        
        public uint assemblyLen;        
        [WireInfo(SizeParam="assemblyLen")]        
        public string assembly;
        
        public uint classLen;
        [WireInfo(SizeParam="classLen")]        
        public string className;
    
        public uint argsLen;        
        [WireInfo(SizeParam="argsLen")]        
        public string argsXml;
    
        public DateTime nextExec;
        public uint intervalSecs;
        public uint execCount;
        public uint timeoutSecs;
    
        public uint frontDoorLen;        
        [WireInfo(SizeParam="frontDoorLen")]        
        public string frontDoor;
    
    }

    public class GetJobRequest : XRLObject2
    {
        public int jobId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/cron/getjob.ashx";
            }
        }
    }
    
    
    public class GetJobResponse : CronJobWire
    {
    }

    public class FindJobsRequest : XRLObject2
    {
        public uint searchLen;
        
        [WireInfo(SizeParam="searchLen")]        
        public string search;
        

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/cron/findjobs.ashx";
            }
        }
    }
    
    
    public class FindJobsResponse : XRLObject2
    {
        public int jobCount;
                
        [WireInfo(SizeParam="jobCount")]        
        public CronJobWire[] jobs;
    }
    
    
    public class CronTimeWarpRequest : XRLObject2
    {
        public long offsetSeconds;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/cron/timewarp.ashx";
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\passport\PassportRpsUtil.cs ===
//
// PassportRpsUtil.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//

using System;
using System.Reflection;

using xonline.common.mgmt;
using xonline.common.service;

using Microsoft.Passport.RPS;

namespace xonline.common.passport
{

    // -----------------------------------------------------------------------------------
    // PassportRpsWrapper
    //
    // Provides an instance of RPS with some helper functions, including static helpers
    // for dealing with instances of RPSTicket.
    //
    // It is recommended that you use this class and store an instance of it in the HTTP
    // Application object. At least, that's what the RPS docs do:
    //
    // /* within Application_Start method */
    // PassportRpsWrapper rps;
    // rps = new PassportRpsWrapper();
    // Application["globalRPS"] = rps;
    // rps.Initialize(null);
    //
    // /* in your application */
    // rpsSession = Application["globalRPS"];
    //
    // -----------------------------------------------------------------------------------
    public class PassportRpsWrapper
    {
        private RPS             _rps = null;
        private RPSApplicationAuth _rpsAppAuth = null;
        private AssemblyName    _AssemblyName = null;
        public string Version
        {
            get { return _AssemblyName.Version.ToString(); }
        }

        // We can expose more assembly properties as needed...

        public PassportRpsWrapper()
        {
            _rps = new RPS();
            _rps.Initialize(null);
            _rpsAppAuth = new RPSApplicationAuth(_rps);

            // Get version RPS that we are using
            _AssemblyName = _rps.GetType().Assembly.GetName();
        }

        // ---------------------------------------------------------------------------
        // GetRpsTicketFromToken - Retrieves an RPSTicket from the token string of the
        // form "t=<base64 encoded ticket>".
        //
        // - siteName : name of your site, e.g. test.xboxlive.com
        // - ticketToken : the base64 encoded ticket
        // - authPolicy : specifies authentication policy, e.g. "LBI", "MBI", "HBI". Null
        // is OK and will use the default in the config xml file.
        //
        // ---------------------------------------------------------------------------
        public RPSTicket GetRpsTicketFromToken(
            string siteName,
            string ticketToken,
            string authPolicy)
        {
            const uint  ticketType = 2; // compact tickets
            bool        validated  = false;
            RPSTicket   rpsTicket = null;

            using (RPSAuth rpsAuth = (RPSAuth) _rps.GetObject("rps.auth"))
            {
                using (RPSPropBag rpsPropBag = (RPSPropBag) _rps.GetObject("rps.property.bag"))
                {
                    try
                    {
                        // Step 1/2: authenticate
                        rpsTicket = rpsAuth.Authenticate(siteName, ticketToken, ticketType, rpsPropBag);

                        // Add optional required auth policy. If null, rps will use the 
                        // default policy in the config xml file.
                        if (authPolicy != null)
                        {
                            rpsPropBag["AuthPolicy"] = authPolicy;
                        }
                        
                        // Step 2/2: validate
                        validated = rpsTicket.Validate(rpsPropBag);

                        object reasonHrObj = rpsPropBag["ReasonHR"];
                        HResult reasonHr = reasonHrObj == null ? HResult.S_OK : ((uint)((int) reasonHrObj));

                        if ( !validated || reasonHr.IsFailure())
                        {
                            HandleError(reasonHr, null);
                        }
                    }
                    catch (System.Runtime.InteropServices.COMException e)
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_HIGH, "GetRpsTicketFromToken: caught COMException: hr = " + ((HResult)(uint)e.ErrorCode) + ", Exception:\r\n" + e);

                        HandleError((uint)e.ErrorCode, e);
                    }
                }
            }

            return rpsTicket;
        }

        // ---------------------------------------------------------------------------
        // GetRpsTicketFromDelegationToken - Retrieves an RPSTicket from the 
        // delegation consent token 
        //
        // - siteName : name of your site, e.g. test.xboxlive.com
        // - ticketToken : the base64 encoded ticket
        // - authPolicy : specifies authentication policy, e.g. "LBI", "MBI", "HBI". Null
        // is OK and will use the default in the config xml file.
        //
        // ---------------------------------------------------------------------------
        public RPSTicket GetRpsTicketFromDelegationToken(
            string siteName,
            string delegationToken,
            string[] offerActions)
        {
            bool[] consents;
            RPSTicket rpsTicket = null;

            rpsTicket = GetRpsTicketFromDelegationToken(siteName, delegationToken, offerActions, out consents);

            foreach (bool consent in consents)
            {
                if (!consent)
                {
                    HandleError(HResult.XONLINE_E_PP_E_RPS_NOT_ALL_OFFER_ACTIONS_CONSENTED, null);
                }
            }

            return rpsTicket;
        }

        // ---------------------------------------------------------------------------
        // GetRpsTicketFromDelegationToken - Retrieves an RPSTicket from the 
        // delegation consent token 
        //
        // - siteName : name of your site, e.g. test.xboxlive.com
        // - ticketToken : the base64 encoded ticket
        // - authPolicy : specifies authentication policy, e.g. "LBI", "MBI", "HBI". Null
        // is OK and will use the default in the config xml file.
        //
        // ---------------------------------------------------------------------------
        public RPSTicket GetRpsTicketFromDelegationToken
            ( string siteName
            , string delegationToken
            , string[] offerActions
            , out bool[] consents
            )
        {
            bool[] isGranular;
            string[] contexts;
            RPSTicket rpsTicket = null;

            consents = null;

            try
            {
                _rpsAppAuth.ValidateConsent(siteName, delegationToken, offerActions, out isGranular, out contexts, out consents, out rpsTicket);
            }
            catch (System.Runtime.InteropServices.COMException e)
            {
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_HIGH, "GetRpsTicketFromDelegationToken: caught COMException: hr = " + ((HResult)(uint)e.ErrorCode) + ", Exception:\r\n" + e);

                HandleError((uint)e.ErrorCode, e);
            }

            return rpsTicket;
        }

        // ---------------------------------------------------------------------------
        // GetAppIdFromTicket - given an RPSTicket, retrieve the AppId.
        // ---------------------------------------------------------------------------
        public static ulong GetAppIdFromTicket(RPSTicket rpsTicket)
        {
            uint highWord = (uint)rpsTicket.Property["AppIdHigh"];
            uint lowWord = (uint)rpsTicket.Property["AppIdLow"];

            return (ulong)Int64Convert.FromUintPair(highWord, lowWord);
        }

        // ---------------------------------------------------------------------------
        // GetCIdFromTicket - given an RPSTicket, retrieve the CId.
        // ---------------------------------------------------------------------------
        public static ulong GetCIdFromTicket(RPSTicket rpsTicket)
        {
            uint cidHigh = (uint) rpsTicket.Property["CIdHigh"];
            uint cidLow = (uint) rpsTicket.Property["CIdLow"];

            return (ulong) Int64Convert.FromUintPair(cidHigh, cidLow);
        }

        // ---------------------------------------------------------------------------
        // GetHexCIdFromTicket - given an RPSTicket, retrieve the HexCId.
        // ---------------------------------------------------------------------------
        public static ulong GetHexCIdFromTicket(RPSTicket rpsTicket)
        {
            return ulong.Parse(rpsTicket.Property["HexCId"].ToString(), System.Globalization.NumberStyles.HexNumber);
        }

        // ---------------------------------------------------------------------------
        // GetPuidFromTicket - given an RPSTicket, retrieve the Passport puid.
        // ---------------------------------------------------------------------------
        public static ulong GetPuidFromTicket(RPSTicket rpsTicket)
        {
            uint puidHigh = (uint) rpsTicket.Property["MemberIdHigh"];
            uint puidLow = (uint) rpsTicket.Property["MemberIdLow"];

            return (ulong) Int64Convert.FromUintPair(puidHigh, puidLow);
        }

        // FYI there is also AuthInstant, but I don't think we will find that of use
        
        // ---------------------------------------------------------------------------
        // GetNotAfterFromTicket - given an RPSTicket, retrieve the NotAfter as a DateTime.
        // ---------------------------------------------------------------------------
        public static DateTime GetIssueInstantDateTimeFromTicket(RPSTicket rpsTicket)
        {
            DateTime date19700101  = new DateTime(1970, 1, 1);

            return date19700101.AddSeconds((UInt32) rpsTicket.Property[ "IssueInstant" ]);
        }

        // ---------------------------------------------------------------------------
        // GetNotAfterDateFromTicket - given an RPSTicket, retrieve the NotAfter as a DateTime.
        // ---------------------------------------------------------------------------
        public static DateTime GetNotAfterDateTimeFromTicket(RPSTicket rpsTicket)
        {
            DateTime date19700101  = new DateTime(1970, 1, 1);

            return date19700101.AddSeconds((UInt32) rpsTicket.Property[ "NotAfter" ]);
        }

        // ---------------------------------------------------------------------------
        // GetExpiryTimeDateTimeFromTicket - given an RPSTicket, retrieve the ExpiryTime as a DateTime.
        // ---------------------------------------------------------------------------
        public static DateTime GetExpiryTimeDateTimeFromTicket(RPSTicket rpsTicket)
        {
            DateTime date19700101 = new DateTime(1970, 1, 1);

            return date19700101.AddSeconds((UInt32)rpsTicket.Property["ExpiryTime"]);
        }

        // ---------------------------------------------------------------------------
        // GetSessionKey - given an RPSTicket, retrieve the SessionKey
        // ---------------------------------------------------------------------------
        public static byte[] GetSessionKey(RPSTicket rpsTicket)
        {
            if (rpsTicket.Property["SessionKey"] != null)
            {
                // Do not under any circumstance use a System.Text.Encoder here.
                // The reason is that the underlying c++ RPS implementation will
                // create the sessionKey by simplying copying the array of bytes
                // into the BSTR buffer.
                // 
                // This means that there are potentially some characters in
                // the string that will decode to different values. EG:
                // 0x6A, 0xDE will decode to 0xFF, 0xFD.

                string sessionKeyString = (string) rpsTicket.Property["SessionKey"];
                Byte[] sessionKey       = new Byte[ sessionKeyString.Length * 2];

                for (int i = 0; i < sessionKeyString.Length; ++i)
                {
                    Int16 entry = (Int16) sessionKeyString[i];

                    sessionKey[(i*2) + 1] = (byte) (entry >>    8);
                    sessionKey[(i*2)    ] = (byte) (entry  & 0xFF);
                }
                return sessionKey;

            }
            return null;
        }

        // ---------------------------------------------------------------------------
        // HandleError - throw a friendly XRLException
        // ---------------------------------------------------------------------------
        private static void HandleError(HResult hrPassport, Exception innerEx)
        {
            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_INFO, "HandleError: hrPassport = " + hrPassport + ", innerEx: " + (innerEx == null ? "" : innerEx.ToString()) );

            HResult xonlineHr = RpsToXonlineHResult(hrPassport);
            string rpsErr = RpsToErrorString(hrPassport);

            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_INFO, "HandleError: hrPassport = " + hrPassport + " -> xonlineHr = " + xonlineHr + ", rpsErr=" + rpsErr);
            
            if (innerEx == null)
            {
                throw new XRLException(
                    xonlineHr,
                    XEvent.Id.COMMON_CODE_146,
                    "PassportRpsWrapper: RPSTicket.Validate failed with error {0}, Passport hr=0x{1:X}",
                    rpsErr,
                    hrPassport);
            }
            else
            {
                throw new XRLException(
                    xonlineHr,
                    XEvent.Id.COMMON_CODE_146,
                    innerEx,
                    "PassportRpsWrapper: RPSTicket.Validate failed with error {0}, Passport hr=0x{1:X}",
                    rpsErr,
                    hrPassport);
            }
        }

        // {{{ RPS error codes
        public static HResult RpsToXonlineHResult(uint rpsHr)
        {
            switch (rpsHr)
            {
            case PP_E_RPS_NOT_INITIALIZED: return HResult.XONLINE_E_RPS_NOT_INITIALIZED;
            case PP_E_RPS_FAILED_TO_CREATE_DOM: return HResult.XONLINE_E_RPS_FAILED_TO_CREATE_DOM;
            case PP_E_RPS_INTERNAL_ERROR: return HResult.XONLINE_E_RPS_INTERNAL_ERROR;
            case PP_E_RPS_INVALID_OBJECT_ID: return HResult.XONLINE_E_RPS_INVALID_OBJECT_ID;
            case PP_E_RPS_OBJECT_ID_CANNOT_OVERWRITE: return HResult.XONLINE_E_RPS_OBJECT_ID_CANNOT_OVERWRITE;
            case PP_E_RPS_FAILED_TO_TLS: return HResult.XONLINE_E_RPS_FAILED_TO_TLS;
            case PP_E_RPS_XML_FILE_ERROR: return HResult.XONLINE_E_RPS_XML_FILE_ERROR;
            case PP_E_RPS_READ_ONLY: return HResult.XONLINE_E_RPS_READ_ONLY;
            case PP_E_RPS_SERVER_CONFIG_ALREADY_INITTED: return HResult.XONLINE_E_RPS_SERVER_CONFIG_ALREADY_INITTED;
            case PP_E_RPS_INVALIDCONFIG: return HResult.XONLINE_E_RPS_INVALIDCONFIG;
            case PP_E_RPS_CERT_NOT_FOUND: return HResult.XONLINE_E_RPS_CERT_NOT_FOUND;
            case PP_E_RPS_SKIBUFFER_TOO_SMALL: return HResult.XONLINE_E_RPS_SKIBUFFER_TOO_SMALL;
            case PP_E_RPS_FILE_TOO_LARGE: return HResult.XONLINE_E_RPS_FILE_TOO_LARGE;
            case PP_E_RPS_INVALID_DATATYPE: return HResult.XONLINE_E_RPS_INVALID_DATATYPE;
            case PP_E_RPS_MORE_DATA: return HResult.XONLINE_E_RPS_MORE_DATA;
            case PP_E_RPS_INVALID_SIGNATURE: return HResult.XONLINE_E_RPS_INVALID_SIGNATURE;
            case PP_E_RPS_ENCRYPTEDKEY_TOO_LARGE: return HResult.XONLINE_E_RPS_ENCRYPTEDKEY_TOO_LARGE;
            case PP_E_RPS_DATA_INTEGRITY_CHECK_FAILED: return HResult.XONLINE_E_RPS_DATA_INTEGRITY_CHECK_FAILED;
            case PP_E_RPS_CERT_WITHOUT_PRIVATE_KEY: return HResult.XONLINE_E_RPS_CERT_WITHOUT_PRIVATE_KEY;
            case PP_E_RPS_NET_CONFIG_CACHE_ALREADY_INITTED: return HResult.XONLINE_E_RPS_NET_CONFIG_CACHE_ALREADY_INITTED;
            case PP_E_RPS_DOMAIN_ATTRIBUTE_NOT_FOUND: return HResult.XONLINE_E_RPS_DOMAIN_ATTRIBUTE_NOT_FOUND;
            case PP_E_RPS_INVALIDDATA: return HResult.XONLINE_E_RPS_INVALIDDATA;
            case PP_E_RPS_TICKET_NOT_INITIALIZED: return HResult.XONLINE_E_RPS_TICKET_NOT_INITIALIZED;
            case PP_E_RPS_TICKET_CANNOT_BE_INITIALIZED_MORE_THAN_ONCE: return HResult.XONLINE_E_RPS_TICKET_CANNOT_BE_INITIALIZED_MORE_THAN_ONCE;
            case PP_E_RPS_SAML_ASSERTION_MISSINGDATA: return HResult.XONLINE_E_RPS_SAML_ASSERTION_MISSINGDATA;
            case PP_E_RPS_INVALID_TIMEWINDOW: return HResult.XONLINE_E_RPS_INVALID_TIMEWINDOW;
            case PP_E_RPS_HTTP_BODY_REQUIRED: return HResult.XONLINE_E_RPS_HTTP_BODY_REQUIRED;
            case PP_E_RPS_INVALID_TICKET_TYPE: return HResult.XONLINE_E_RPS_INVALID_TICKET_TYPE;
            case PP_E_RPS_INVALID_SLIDINGWINDOW: return HResult.XONLINE_E_RPS_INVALID_SLIDINGWINDOW;
            case PP_E_RPS_REASON_INVALID_AUTHMETHOD: return HResult.XONLINE_E_RPS_REASON_INVALID_AUTHMETHOD;
            case PP_E_RPS_NO_SUCH_PROFILE_ATTRIBUTE: return HResult.XONLINE_E_RPS_NO_SUCH_PROFILE_ATTRIBUTE;
            case PP_E_RPS_INVALID_PROFILESCHEMA_TYPE: return HResult.XONLINE_E_RPS_INVALID_PROFILESCHEMA_TYPE;
            case PP_E_RPS_FAILED_DOWNLOAD: return HResult.XONLINE_E_RPS_FAILED_DOWNLOAD;
            case PP_E_RPS_INVALID_SITEID: return HResult.XONLINE_E_RPS_INVALID_SITEID;
            case PP_E_RPS_BASE64DECODE_FAILED: return HResult.XONLINE_E_RPS_BASE64DECODE_FAILED;
            case PP_E_RPS_REASON_TIMEWINDOW_EXPIRED: return HResult.XONLINE_E_RPS_REASON_TIMEWINDOW_EXPIRED;
            case PP_E_RPS_REASON_SLIDINGWINDOW_EXPIRED: return HResult.XONLINE_E_RPS_REASON_SLIDINGWINDOW_EXPIRED;
            case PP_E_RPS_CERT_INVALID_KEY_SPEC: return HResult.XONLINE_E_RPS_CERT_INVALID_KEY_SPEC;
            case PP_E_RPS_INTERNAL_ERROR_CODE_UNSET_IN_EXCEPTION: return HResult.XONLINE_E_RPS_INTERNAL_ERROR_CODE_UNSET_IN_EXCEPTION;
            case PP_E_RPS_REASON_INVALID_AUTHINSTANT_DATATYPE: return HResult.XONLINE_E_RPS_REASON_INVALID_AUTHINSTANT_DATATYPE;
            case PP_E_RPS_REASON_HTTPS_OR_ENCRYPTED_TICKET_NEEDED: return HResult.XONLINE_E_RPS_REASON_HTTPS_OR_ENCRYPTED_TICKET_NEEDED;
            case PP_E_RPS_REASON_INCORRECT_IV_BYTES: return HResult.XONLINE_E_RPS_REASON_INCORRECT_IV_BYTES;
            case PP_E_RPS_REASON_PASSPORT_F_ERROR_ENCOUNTERED: return HResult.XONLINE_E_RPS_REASON_PASSPORT_F_ERROR_ENCOUNTERED;
            case PP_E_RPS_NO_SESSION_KEY: return HResult.XONLINE_E_RPS_NO_SESSION_KEY;
            case PP_E_RPS_INVALID_COOKIE_NAME: return HResult.XONLINE_E_RPS_INVALID_COOKIE_NAME;
            case PP_E_RPS_INVALID_AUTHPOLICY: return HResult.XONLINE_E_RPS_INVALID_AUTHPOLICY;
            case PP_E_RPS_INVALID_ENCRYPT_ALGID: return HResult.XONLINE_E_RPS_INVALID_ENCRYPT_ALGID;
            case PP_E_RPS_REASON_POST_TICKET_TIMEWINDOW_EXPIRED: return HResult.XONLINE_E_RPS_REASON_POST_TICKET_TIMEWINDOW_EXPIRED;
            case PP_E_RPS_TICKET_HAS_NO_SESSIONKEY: return HResult.XONLINE_E_RPS_TICKET_HAS_NO_SESSIONKEY;
            case PP_E_RPSDATA_DATA_TOO_LARGE: return HResult.XONLINE_E_RPSDATA_DATA_TOO_LARGE;
            case PP_E_RPSDATA_INVALID_DATATYPE: return HResult.XONLINE_E_RPSDATA_INVALID_DATATYPE;
            case PP_E_RPSDATA_MORE_DATA: return HResult.XONLINE_E_RPSDATA_MORE_DATA;
            case PP_E_RPSDATA_INVALID_DATAOFFSET: return HResult.XONLINE_E_RPSDATA_INVALID_DATAOFFSET;
            case PP_E_RPSDATA_INVALIDDATA: return HResult.XONLINE_E_RPSDATA_INVALIDDATA;
            case PP_E_RPS_TICKET_HAS_NO_OFFERACTIONS: return HResult.XONLINE_E_PP_E_RPS_TICKET_HAS_NO_OFFERACTIONS;
            case PP_E_RPS_REASON_INVALID_OFFERACTIONS_DATATYPE: return HResult.XONLINE_E_PP_E_RPS_REASON_INVALID_OFFERACTIONS_DATATYPE;
            case PP_E_RPS_REASON_OFFERACTIONS_INVALID: return HResult.XONLINE_E_PP_E_RPS_REASON_OFFERACTIONS_INVALID;
            case PP_E_RPS_NO_OFFERACTIONS: return HResult.XONLINE_E_PP_E_RPS_NO_OFFERACTIONS;
            case PP_E_RPS_REASON_INVALID_ISSUEINSTANT_DATATYPE: return HResult.XONLINE_E_PP_E_RPS_REASON_INVALID_ISSUEINSTANT_DATATYPE;
            case PP_E_RPS_REASON_INVALID_EXPIRYTIME_DATATYPE: return HResult.XONLINE_E_PP_E_RPS_REASON_INVALID_EXPIRYTIME_DATATYPE;
            default: return HResult.XONLINE_E_PASSPORT_ERROR;
            }
        }

        public static string RpsToErrorString(uint rpsHr)
        {
            switch (rpsHr)
            {
            case PP_E_RPS_NOT_INITIALIZED: return "PP_E_RPS_NOT_INITIALIZED";
            case PP_E_RPS_FAILED_TO_CREATE_DOM: return "PP_E_RPS_FAILED_TO_CREATE_DOM";
            case PP_E_RPS_INTERNAL_ERROR: return "PP_E_RPS_INTERNAL_ERROR";
            case PP_E_RPS_INVALID_OBJECT_ID: return "PP_E_RPS_INVALID_OBJECT_ID";
            case PP_E_RPS_OBJECT_ID_CANNOT_OVERWRITE: return "PP_E_RPS_OBJECT_ID_CANNOT_OVERWRITE";
            case PP_E_RPS_FAILED_TO_TLS: return "PP_E_RPS_FAILED_TO_TLS";
            case PP_E_RPS_XML_FILE_ERROR: return "PP_E_RPS_XML_FILE_ERROR";
            case PP_E_RPS_READ_ONLY: return "PP_E_RPS_READ_ONLY";
            case PP_E_RPS_SERVER_CONFIG_ALREADY_INITTED: return "PP_E_RPS_SERVER_CONFIG_ALREADY_INITTED";
            case PP_E_RPS_INVALIDCONFIG: return "PP_E_RPS_INVALIDCONFIG";
            case PP_E_RPS_CERT_NOT_FOUND: return "PP_E_RPS_CERT_NOT_FOUND";
            case PP_E_RPS_SKIBUFFER_TOO_SMALL: return "PP_E_RPS_SKIBUFFER_TOO_SMALL";
            case PP_E_RPS_FILE_TOO_LARGE: return "PP_E_RPS_FILE_TOO_LARGE";
            case PP_E_RPS_INVALID_DATATYPE: return "PP_E_RPS_INVALID_DATATYPE";
            case PP_E_RPS_MORE_DATA: return "PP_E_RPS_MORE_DATA";
            case PP_E_RPS_INVALID_SIGNATURE: return "PP_E_RPS_INVALID_SIGNATURE";
            case PP_E_RPS_ENCRYPTEDKEY_TOO_LARGE: return "PP_E_RPS_ENCRYPTEDKEY_TOO_LARGE";
            case PP_E_RPS_DATA_INTEGRITY_CHECK_FAILED: return "PP_E_RPS_DATA_INTEGRITY_CHECK_FAILED";
            case PP_E_RPS_CERT_WITHOUT_PRIVATE_KEY: return "PP_E_RPS_CERT_WITHOUT_PRIVATE_KEY";
            case PP_E_RPS_NET_CONFIG_CACHE_ALREADY_INITTED: return "PP_E_RPS_NET_CONFIG_CACHE_ALREADY_INITTED";
            case PP_E_RPS_DOMAIN_ATTRIBUTE_NOT_FOUND: return "PP_E_RPS_DOMAIN_ATTRIBUTE_NOT_FOUND";
            case PP_E_RPS_INVALIDDATA: return "PP_E_RPS_INVALIDDATA";
            case PP_E_RPS_TICKET_NOT_INITIALIZED: return "PP_E_RPS_TICKET_NOT_INITIALIZED";
            case PP_E_RPS_TICKET_CANNOT_BE_INITIALIZED_MORE_THAN_ONCE: return "PP_E_RPS_TICKET_CANNOT_BE_INITIALIZED_MORE_THAN_ONCE";
            case PP_E_RPS_SAML_ASSERTION_MISSINGDATA: return "PP_E_RPS_SAML_ASSERTION_MISSINGDATA";
            case PP_E_RPS_INVALID_TIMEWINDOW: return "PP_E_RPS_INVALID_TIMEWINDOW";
            case PP_E_RPS_HTTP_BODY_REQUIRED: return "PP_E_RPS_HTTP_BODY_REQUIRED";
            case PP_E_RPS_INVALID_TICKET_TYPE: return "PP_E_RPS_INVALID_TICKET_TYPE";
            case PP_E_RPS_INVALID_SLIDINGWINDOW: return "PP_E_RPS_INVALID_SLIDINGWINDOW";
            case PP_E_RPS_REASON_INVALID_AUTHMETHOD: return "PP_E_RPS_REASON_INVALID_AUTHMETHOD";
            case PP_E_RPS_NO_SUCH_PROFILE_ATTRIBUTE: return "PP_E_RPS_NO_SUCH_PROFILE_ATTRIBUTE";
            case PP_E_RPS_INVALID_PROFILESCHEMA_TYPE: return "PP_E_RPS_INVALID_PROFILESCHEMA_TYPE";
            case PP_E_RPS_FAILED_DOWNLOAD: return "PP_E_RPS_FAILED_DOWNLOAD";
            case PP_E_RPS_INVALID_SITEID: return "PP_E_RPS_INVALID_SITEID";
            case PP_E_RPS_BASE64DECODE_FAILED: return "PP_E_RPS_BASE64DECODE_FAILED";
            case PP_E_RPS_REASON_TIMEWINDOW_EXPIRED: return "PP_E_RPS_REASON_TIMEWINDOW_EXPIRED";
            case PP_E_RPS_REASON_SLIDINGWINDOW_EXPIRED: return "PP_E_RPS_REASON_SLIDINGWINDOW_EXPIRED";
            case PP_E_RPS_CERT_INVALID_KEY_SPEC: return "PP_E_RPS_CERT_INVALID_KEY_SPEC";
            case PP_E_RPS_INTERNAL_ERROR_CODE_UNSET_IN_EXCEPTION: return "PP_E_RPS_INTERNAL_ERROR_CODE_UNSET_IN_EXCEPTION";
            case PP_E_RPS_REASON_INVALID_AUTHINSTANT_DATATYPE: return "PP_E_RPS_REASON_INVALID_AUTHINSTANT_DATATYPE";
            case PP_E_RPS_REASON_HTTPS_OR_ENCRYPTED_TICKET_NEEDED: return "PP_E_RPS_REASON_HTTPS_OR_ENCRYPTED_TICKET_NEEDED";
            case PP_E_RPS_REASON_INCORRECT_IV_BYTES: return "PP_E_RPS_REASON_INCORRECT_IV_BYTES";
            case PP_E_RPS_REASON_PASSPORT_F_ERROR_ENCOUNTERED: return "PP_E_RPS_REASON_PASSPORT_F_ERROR_ENCOUNTERED";
            case PP_E_RPS_NO_SESSION_KEY: return "PP_E_RPS_NO_SESSION_KEY";
            case PP_E_RPS_INVALID_COOKIE_NAME: return "PP_E_RPS_INVALID_COOKIE_NAME";
            case PP_E_RPS_INVALID_AUTHPOLICY: return "PP_E_RPS_INVALID_AUTHPOLICY";
            case PP_E_RPS_INVALID_ENCRYPT_ALGID: return "PP_E_RPS_INVALID_ENCRYPT_ALGID";
            case PP_E_RPS_REASON_POST_TICKET_TIMEWINDOW_EXPIRED: return "PP_E_RPS_REASON_POST_TICKET_TIMEWINDOW_EXPIRED";
            case PP_E_RPS_TICKET_HAS_NO_SESSIONKEY: return "PP_E_RPS_TICKET_HAS_NO_SESSIONKEY";
            case PP_E_RPSDATA_DATA_TOO_LARGE: return "PP_E_RPSDATA_DATA_TOO_LARGE";
            case PP_E_RPSDATA_INVALID_DATATYPE: return "PP_E_RPSDATA_INVALID_DATATYPE";
            case PP_E_RPSDATA_MORE_DATA: return "PP_E_RPSDATA_MORE_DATA";
            case PP_E_RPSDATA_INVALID_DATAOFFSET: return "PP_E_RPSDATA_INVALID_DATAOFFSET";
            case PP_E_RPSDATA_INVALIDDATA: return "PP_E_RPSDATA_INVALIDDATA";
            case PP_E_RPS_TICKET_HAS_NO_OFFERACTIONS: return "PP_E_RPS_TICKET_HAS_NO_OFFERACTIONS";
            case PP_E_RPS_REASON_INVALID_OFFERACTIONS_DATATYPE: return "PP_E_RPS_REASON_INVALID_OFFERACTIONS_DATATYPE";
            case PP_E_RPS_REASON_OFFERACTIONS_INVALID: return "PP_E_RPS_REASON_OFFERACTIONS_INVALID";
            case PP_E_RPS_NO_OFFERACTIONS: return "PP_E_RPS_NO_OFFERACTIONS";
            case PP_E_RPS_REASON_INVALID_ISSUEINSTANT_DATATYPE: return "PP_E_RPS_REASON_INVALID_ISSUEINSTANT_DATATYPE";
            case PP_E_RPS_REASON_INVALID_EXPIRYTIME_DATATYPE: return "PP_E_RPS_REASON_INVALID_EXPIRYTIME_DATATYPE";
            default: return "<Unknown error>";
            }
        }

        public static bool IsPassportError(HResult hr)
        {
            return (hr >= PP_E_RPS_NOT_INITIALIZED &&
                    hr <= PP_E_RPSDATA_INVALIDDATA);
        }

        public const uint PP_E_RPS_NOT_INITIALIZED                              = 0x80049200;
        public const uint PP_E_RPS_FAILED_TO_CREATE_DOM                         = 0x80049201;
        public const uint PP_E_RPS_INTERNAL_ERROR                               = 0x80049202;
        public const uint PP_E_RPS_INVALID_OBJECT_ID                            = 0x80049203;
        public const uint PP_E_RPS_OBJECT_ID_CANNOT_OVERWRITE                   = 0x80049204;
        public const uint PP_E_RPS_FAILED_TO_TLS                                = 0x80049205;
        public const uint PP_E_RPS_XML_FILE_ERROR                               = 0x80049206;
        public const uint PP_E_RPS_READ_ONLY                                    = 0x80049207;
        public const uint PP_E_RPS_SERVER_CONFIG_ALREADY_INITTED                = 0x80049208;
        public const uint PP_E_RPS_INVALIDCONFIG                                = 0x80049209;
        public const uint PP_E_RPS_CERT_NOT_FOUND                               = 0x8004920a;
        public const uint PP_E_RPS_SKIBUFFER_TOO_SMALL                          = 0x8004920b;
        public const uint PP_E_RPS_FILE_TOO_LARGE                               = 0x8004920c;
        public const uint PP_E_RPS_INVALID_DATATYPE                             = 0x8004920d;
        public const uint PP_E_RPS_MORE_DATA                                    = 0x8004920e;
        public const uint PP_E_RPS_INVALID_SIGNATURE                            = 0x8004920f;
        public const uint PP_E_RPS_ENCRYPTEDKEY_TOO_LARGE                       = 0x80049211;
        public const uint PP_E_RPS_DATA_INTEGRITY_CHECK_FAILED                  = 0x80049212;
        public const uint PP_E_RPS_CERT_WITHOUT_PRIVATE_KEY                     = 0x80049214;
        public const uint PP_E_RPS_NET_CONFIG_CACHE_ALREADY_INITTED             = 0x80049215;
        public const uint PP_E_RPS_DOMAIN_ATTRIBUTE_NOT_FOUND                   = 0x80049216;
        public const uint PP_E_RPS_INVALIDDATA                                  = 0x80049217;
        public const uint PP_E_RPS_TICKET_NOT_INITIALIZED                       = 0x80049218;
        public const uint PP_E_RPS_TICKET_CANNOT_BE_INITIALIZED_MORE_THAN_ONCE  = 0x80049219;
        public const uint PP_E_RPS_SAML_ASSERTION_MISSINGDATA                   = 0x8004921a;
        public const uint PP_E_RPS_INVALID_TIMEWINDOW                           = 0x8004921b;
        public const uint PP_E_RPS_HTTP_BODY_REQUIRED                           = 0x8004921d;
        public const uint PP_E_RPS_INVALID_TICKET_TYPE                          = 0x8004921e;
        public const uint PP_E_RPS_INVALID_SLIDINGWINDOW                        = 0x8004921f;
        public const uint PP_E_RPS_REASON_INVALID_AUTHMETHOD                    = 0x80049220;
        public const uint PP_E_RPS_NO_SUCH_PROFILE_ATTRIBUTE                    = 0x80049222;
        public const uint PP_E_RPS_INVALID_PROFILESCHEMA_TYPE                   = 0x80049223;
        public const uint PP_E_RPS_FAILED_DOWNLOAD                              = 0x80049224;
        public const uint PP_E_RPS_INVALID_SITEID                               = 0x80049226;
        public const uint PP_E_RPS_BASE64DECODE_FAILED                          = 0x80049227;
        public const uint PP_E_RPS_REASON_TIMEWINDOW_EXPIRED                    = 0x80049228;
        public const uint PP_E_RPS_REASON_SLIDINGWINDOW_EXPIRED                 = 0x80049229;
        public const uint PP_E_RPS_CERT_INVALID_KEY_SPEC                        = 0x8004922a;
        public const uint PP_E_RPS_INTERNAL_ERROR_CODE_UNSET_IN_EXCEPTION       = 0x8004922b;
        public const uint PP_E_RPS_REASON_INVALID_AUTHINSTANT_DATATYPE          = 0x8004922c;
        public const uint PP_E_RPS_REASON_HTTPS_OR_ENCRYPTED_TICKET_NEEDED      = 0x8004922d;
        public const uint PP_E_RPS_REASON_INCORRECT_IV_BYTES                    = 0x8004922e;
        public const uint PP_E_RPS_REASON_PASSPORT_F_ERROR_ENCOUNTERED          = 0x8004922f;
        public const uint PP_E_RPS_NO_SESSION_KEY                               = 0x80049230;
        public const uint PP_E_RPS_INVALID_COOKIE_NAME                          = 0x80049231;
        public const uint PP_E_RPS_INVALID_AUTHPOLICY                           = 0x80049232;
        public const uint PP_E_RPS_INVALID_ENCRYPT_ALGID                        = 0x80049233;
        public const uint PP_E_RPS_REASON_POST_TICKET_TIMEWINDOW_EXPIRED        = 0x80049234;
        public const uint PP_E_RPS_TICKET_HAS_NO_SESSIONKEY                     = 0x80049235;
        public const uint PP_E_RPS_TICKET_HAS_NO_OFFERACTIONS                   = 0x80049245;
        public const uint PP_E_RPS_REASON_INVALID_OFFERACTIONS_DATATYPE         = 0x80049246;
        public const uint PP_E_RPS_REASON_OFFERACTIONS_INVALID                  = 0x80049247;
        public const uint PP_E_RPS_NO_OFFERACTIONS                              = 0x80049248;
        public const uint PP_E_RPS_REASON_INVALID_ISSUEINSTANT_DATATYPE         = 0x80049250;
        public const uint PP_E_RPS_REASON_INVALID_EXPIRYTIME_DATATYPE           = 0x80049251;
        public const uint PP_E_RPSDATA_DATA_TOO_LARGE                           = 0x80049400;
        public const uint PP_E_RPSDATA_INVALID_DATATYPE                         = 0x80049401;
        public const uint PP_E_RPSDATA_MORE_DATA                                = 0x80049402;
        public const uint PP_E_RPSDATA_INVALID_DATAOFFSET                       = 0x80049403;
        public const uint PP_E_RPSDATA_INVALIDDATA                              = 0x80049404;


        // }}}

    }


    // -----------------------------------------------------------------------------------
    // PassportRpsUtil
    //
    // This is the static version of the PassportRpsWrapper. If you don't want to cache an
    // instance of PassportRpsWrapper in the application, or for whatever reason don't
    // want to use it, then this all-static class could be useful. It will keep a copy of
    // RPS around in a static.
    //
    // -----------------------------------------------------------------------------------
    public static class PassportRpsUtil
    {
        private static PassportRpsWrapper globalRps = null;

        static PassportRpsUtil()
        {
            globalRps = new PassportRpsWrapper();
        }

        public static RPSTicket GetRpsTicketFromToken(string siteName, string ticketToken)
        {
            return globalRps.GetRpsTicketFromToken(siteName, ticketToken, null);
        }

        public static ulong GetPuidFromTicket(RPSTicket rpsTicket)
        {
            ulong passportPuid = PassportRpsWrapper.GetPuidFromTicket(rpsTicket);

            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportRpsUtil.GetPuidFromTicket: passportPuid: 0x" + passportPuid.ToString("X"));

            return passportPuid;
        }

        public static ulong GetPuidFromRpsTicketToken(string siteAddress, string ticketToken)
        {
            RPSTicket rpsTicket = GetRpsTicketFromToken(siteAddress, ticketToken);

            ulong puid = GetPuidFromTicket(rpsTicket);

            return puid;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\DownloadQueueProtocol.cs ===
using System;

using xonline.common.service;


namespace xonline.common.protocol
{
    public class CreateDownloadQueueRequest : XRLObject2
    {
        public ulong userPuid;
        public byte nameLength;
        public ushort xmlLength;

        [WireInfo( SizeParam = "nameLength" )]
        public string name;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlProperties;

        public override string Xrl
        {
            get { return "/Lists/CreateDownloadQueue.ashx"; }
        }
    }


    public class CreateDownloadQueueResponse : XRLObject2
    {
        public int queueId;
        public DateTime lastModified;

        public CreateDownloadQueueResponse( CreateListReply reply )
        {
            queueId = reply.listId;
            lastModified = reply.lastModified;
        }
    }


    public class ModifyDownloadQueueRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public DateTime lastModified;
        public ushort xmlLength;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlProperties;

        public override string Xrl
        {
            get { return "/Lists/ModifyDownloadQueue.ashx"; }
        }
    }


    public class ModifyDownloadQueueResponse : XRLObject2
    {
        public DateTime lastModified;

        public ModifyDownloadQueueResponse( ModifyListReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class QueryDownloadQueuesRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId; // int.MinValue is wildcard
        public DateTime lastModified;
        public int pageSize;
        public int pageNum;
        public int orderDir;

        public override string Xrl
        {
            get { return "/Lists/QueryDownloadQueues.ashx"; }
        }
    }


    public class QueryDownloadQueuesResponse : XRLObject2
    {
        public ushort totalQueues = 0;
        public ushort numQueues = 0;

        [WireInfo( SizeParam = "numQueues" )]
        public ListInfo[] resultQueues = null;

        public QueryDownloadQueuesResponse( QueryListsReply reply )
        {
            totalQueues = reply.totalLists;
            resultQueues = reply.resultLists;
            if( resultQueues != null ) {
                numQueues = (ushort) resultQueues.Length;
            }
        }
    }


    public class GrantDownloadQueueAccessRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public ulong machinePuid;

        public override string Xrl
        {
            get { return "/Lists/GrantDownloadQueueAccess.ashx"; }  
        }
    }


/*
    public class GrantDownloadQueueAccessResponse : XRLObject2
    {
        public GrantDownloadQueueAccessResponse( GrantListAccessReply reply )
        {
        }
    }
*/


    public class RevokeDownloadQueueAccessRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public ulong machinePuid; // 0 is wildcard

        public override string Xrl
        {
            get { return "/Lists/RevokeDownloadQueueAccess.ashx"; }
        }
    }


/*
    public class RevokeDownloadQueueAccessResponse : XRLObject2
    {
        public RevokeDownloadQueueAccessResponse( RevokeListAccessReply reply )
        {
        }
    }
*/


    public class InsertDownloadItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public DateTime lastModified;
        public ushort numItems;

        [WireInfo( SizeParam = "numItems" )]
        public ListItem[] items;

        public override string Xrl
        {
            get { return "/Lists/InsertDownloadItems.ashx"; }
        }
    }


    public class InsertDownloadItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public InsertDownloadItemsResponse( InsertItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class DeleteDownloadItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public DateTime lastModified;
        public ushort numIds;

        [WireInfo( SizeParam = "numIds" )]
        public Guid[] itemIds;

        public override string Xrl
        {
            get { return "/Lists/DeleteDownloadItems.ashx"; }
        }
    }


    public class DeleteDownloadItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public DeleteDownloadItemsResponse( DeleteItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class ModifyDownloadItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public DateTime lastModified;
        public ushort numItems;

        [WireInfo( SizeParam = "numItems" )]
        public ListItemMod[] items;

        public override string Xrl
        {
            get { return "/Lists/ModifyDownloadItems.ashx"; }
        }
    }


    public class ModifyDownloadItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public ModifyDownloadItemsResponse( ModifyItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class QueryDownloadItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public int pageSize;
        public int pageNum;
        public int orderDir;
        public ushort numIds;

        [WireInfo( SizeParam = "numIds" )]
        public Guid[] itemIds; // empty array is wildcard

        public override string Xrl
        {
            get { return "/Lists/QueryDownloadItems.ashx"; }
        }
    }


    public class QueryDownloadItemsResponse : XRLObject2
    {
        public ushort totalItems = 0;
        public DateTime lastModified = DateTime.MinValue;
        public ushort numItems = 0;

        [WireInfo( SizeParam = "numItems" )]
        public ListItem[] resultItems = null;

        public QueryDownloadItemsResponse( QueryItemsReply reply )
        {
            totalItems = reply.totalItems;
            lastModified = reply.lastModified;
            resultItems = reply.resultItems;
            if( resultItems != null ) {
                numItems = (ushort) resultItems.Length;
            }
        }
    }


    public class MoveDownloadItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public DateTime lastModified;
        public ushort numIndices;

        [WireInfo( SizeParam = "numIndices" )]
        public ListItemIndex[] itemIndices;

        public override string Xrl
        {
            get { return "/Lists/MoveDownloadItems.ashx"; }
        }
    }


    public class MoveDownloadItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public MoveDownloadItemsResponse( MoveItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\Domain.cs ===
/*
 * Copyright (c) 2003 Microsoft Corporation
 *
 * Storage Front-Door (stfd)
 *
 * StorageDomain.cs
 *
 * Domain policy and properties
 *
 * */

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml.Serialization;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

// trace area for StorageDomain code
[assembly: XomAreaDefinition(XomAreaName.domTrace)]

namespace xonline.common.protocol
{
    public class StorageDomainConstants
    {
        // domain id constants for the current storage domains
        public const uint _MIN = 0;
        public const uint STATS = 0;
        public const uint TITLE = 1;
        public const uint TUSER = 2;
        public const uint TTEAM = 3;
        public const uint MSG   = 4;
        public const uint XESTATS = 5;
        public const uint GLOBAL = 6;
        public const uint PICS  = 7;
        public const uint VID   = 8;
        public const uint ZPIC  = 9;
        public const uint AVATAR  = 10;
        public const uint _MAX = 10;
    }
    

    public class StorageDomain
    {

        public uint _id;
        public string _name;
        public string _description;
        public string _webstoreApp;

        public StorageDomainPolicy _policy = new StorageDomainPolicy();

        public StorageDomainPolicy Policy
        {
            get { return _policy; }
        }

        public string Name
        {
            get { return _name; }
        }
        public uint Id
        {
            get { return _id; }
        }
        public string WebstoreApp
        {
            get { return _webstoreApp; }
        }

    }

    
    public class StorageDomainList
    {
        private static Hashtable _domainHash = null;                
        public static Hashtable DomainHash
        {
          get 
          { 
                if ( _domainHash == null )
                {
                    LoadFromDb();
                }
              return StorageDomainList._domainHash; 
          }
        }

        private static StorageDomain[] _domainList = null;

        public static StorageDomain GetDomain(string name)
        {
            return (StorageDomain) DomainHash[name];
        }

        public static StorageDomain GetDomain(uint domainId)
        {
            if ( _domainList == null )
            {
                LoadFromDb();
            }

            return (StorageDomain) _domainList[(int)domainId];
        }

       

        protected static void LoadFromDb()
        {
            SqlConnection conn = null;
            SqlCommand cmd = null;
            SqlDataReader rdr = null;

            Hashtable h = new Hashtable();
            string connString = null;

            try
            {
                connString = ConfigUtil.NpdbConnectionString;
                Xom.Trace(XomAreaName.domTrace, LogLevel.L_NORMAL, "Domain.LoadFromDb: NPDB connection string='" + connString + "'");
            }
            catch (Exception e)
            {
                throw new ExceptionWithEventId(
                    XEvent.Id.COMMON_CONFIG_270,
                    "Domain.LoadFromDb: Failed to retrieve NPDB config data.",
                    e);
            }

            try
            {
                conn = new SqlConnection(connString);
                conn.Open();
                Xom.Trace(XomAreaName.domTrace, LogLevel.L_NORMAL, "Domain.LoadFromDb: opened connection.");
            }
            catch (Exception e)
            {
                throw new XRLException(
                    HResult.XONLINE_E_DATABASE_ERROR,
                    XEvent.Id.COMMON_CODE_41,
                    "Domain.LoadFromDb: failed to connect to NPDB SQL server: " + ConfigUtil.NpdbConnectionString,
                    e);
            }

            try
            {
                Xom.Trace(XomAreaName.domTrace, LogLevel.L_NORMAL, "Domain.LoadFromDb: calling CreateCommand");
                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_storage_get_domains";

                Xom.Trace(XomAreaName.domTrace, LogLevel.L_NORMAL, "Domain.LoadFromDb: executing dbo.p_storage_get_domains");
                rdr = cmd.ExecuteReader();
                Xom.Trace(XomAreaName.domTrace, LogLevel.L_NORMAL, "Domain.LoadFromDb: executed dbo.p_storage_get_domains");

                while ( rdr.Read() )
                {
                    StorageDomain d = new StorageDomain();
                    d._id = (uint) rdr.GetInt32(0);
                    d._name = rdr.GetString(1);
                    d._description = rdr.GetString(2);
                    d._webstoreApp = rdr.GetString(3);
                    d._policy._maxFileSize = (ulong) rdr.GetInt64(4);
                    d._policy._cacheReadFiles = (rdr.GetByte(5) != 0);
                    d._policy._readFileCacheTimeSeconds = rdr.GetInt32(6);
                    d._policy._cacheEnumFiles = (rdr.GetByte(7) != 0);
                    d._policy._enumFileCacheTimeSeconds = rdr.GetInt32(8);
                    d._policy._quotaEnabled = (rdr.GetByte(9) != 0);
                    d._policy._allowOverwrites = (rdr.GetByte(10) != 0);
                    d._policy._allowCrossTitle = (rdr.GetByte(11) != 0);
                    d._policy._allowPreviewVersioning = (rdr.GetByte(12) != 0);
                    d._policy._pathValidationString = rdr.GetString(13);
                    //d._policy._defaultExpiryInDays = rdr.GetInt32(14);
                    if (!rdr.GetSqlInt32(14).IsNull )
                    {
                        d._policy._defaultExpiryInDays = rdr.GetInt32(14);
                    } else 
                    {
                         d._policy._defaultExpiryInDays = Int32.MaxValue;
                    }

                    if ( d._policy._pathValidationString != null && d._policy._pathValidationString.Length > 0 )
                    {
                        d._policy._pathValidationRegex = new Regex(d._policy._pathValidationString, RegexOptions.IgnoreCase|RegexOptions.Compiled);
                    }

                    h.Add(d._name, d);

                    Xom.Trace(XomAreaName.domTrace, LogLevel.L_NORMAL,
                        "StorageDomainList: loaded domain id=" + d._id +
                             ", name=" + d._name +
                             ", webstore app=" + d._webstoreApp +
                             ", description=" + d._description + "\r\n" +
                         "StorageDomainList: Policy for domain " + d._name + "\r\n" +
                             d._policy.ToString());
                }

                rdr.Close();
                rdr = null;

                if ( h.Count == 0)
                {
                    throw new ExceptionWithEventId(XEvent.Id.STFD_MISSING_OR_BAD_CONFIG,
                        "Calling 'p_storage_get_domains' in NPDB returned 0 rows.  Check to ensure the t_storage_domains table is populated correctly." );
                }

                uint maxDomainId = 0;
                foreach (string name in h.Keys)
                {
                    StorageDomain d = (StorageDomain) h[name];
                    if ( d._id > maxDomainId )
                    {
                        maxDomainId = d._id;
                    }
                }

                StorageDomain[] domainList = new StorageDomain[maxDomainId+1];

                foreach (string name in h.Keys)
                {
                    StorageDomain d = (StorageDomain) h[name];
                    domainList[d._id] = d;
                }

                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_storage_get_domain_permissions";

                rdr = cmd.ExecuteReader();

                while ( rdr.Read() )
                {
                    uint domainId = (uint) rdr.GetInt32(0);
                    uint operation = (uint) rdr.GetInt32(1);
                    uint allowed = (uint) rdr.GetInt32(2);


                    StorageDomain d = domainList[domainId];
                    if ( d == null )
                    {
                        throw new ExceptionWithEventId(
                            XEvent.Id.COMMON_CONFIG_272,
                            "Calling 'p_storage_get_domain_permissions' in NPDB returned domain id=" + domainId + " which was not found in domain list.  Check to ensure the t_storage_domains and t_storage_domain_permissions tables are populated correctly." );
                    }

                    d._policy._permissions[operation] = allowed;

                    Xom.Trace(XomAreaName.domTrace, LogLevel.L_NORMAL, "StorageDomainList: loaded domain id=" + domainId + ", operation=" + operation + ", allowed=" + allowed);
                }

                rdr.Close();
                rdr = null;

                if ( h.Count == 0)
                {
                    throw new ExceptionWithEventId(XEvent.Id.STFD_MISSING_OR_BAD_CONFIG_1,
                        "Calling 'p_storage_get_domains' in NPDB returned 0 rows.  Check to ensure the t_storage_domains table is populated correctly." );
                }

                _domainHash = h;
                _domainList = domainList;
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.domTrace, LogLevel.L_ERROR, "Domain.LoadFromDb: caught exception: " + e);
                throw;
            }
            finally
            {
                if ( rdr != null )
                {
                    rdr.Close();
                    rdr = null;
                }

                if ( conn != null )
                {
                    conn.Close();
                    conn = null;
                }
            }
        }

        public static void ReloadFromDb()
        {
            _domainHash = null;
            _domainList = null;
        }

        
 
    }


    public class StorageDomainPolicy
    {
        public StorageDomainPolicy()
        {
            _permissions = new uint[ProtocolConstants.maxStorageOperations];
        }

        public ulong  _maxFileSize;
        public bool   _cacheReadFiles;
        public int    _readFileCacheTimeSeconds;
        public bool   _cacheEnumFiles;
        public int    _enumFileCacheTimeSeconds;
        public bool   _quotaEnabled;
        public bool   _allowOverwrites;
        public bool   _allowCrossTitle;
        public bool   _allowPreviewVersioning;
        public string _pathValidationString;
        public Regex  _pathValidationRegex;
        public int    _defaultExpiryInDays;


        [XmlIgnore]
        public uint[] _permissions;

        public ulong MaxFileSize
        {
            get { return _maxFileSize; }
        }
        public bool CacheReadFiles
        {
            get { return _cacheReadFiles; }
        }
        public int ReadFileCacheTimeSeconds
        {
            get { return _readFileCacheTimeSeconds; }
        }
        public bool CacheEnumFiles
        {
            get { return _cacheEnumFiles; }
        }
        public int EnumFileCacheTimeSeconds
        {
            get { return _enumFileCacheTimeSeconds; }
        }
        public bool QuotaEnabled
        {
            get { return _quotaEnabled; }
        }
        public bool AllowOverwrites
        {
            get { return _allowOverwrites; }
        }
        public bool AllowCrossTitle
        {
            get { return _allowCrossTitle; }
        }
        public bool AllowPreviewVersioning
        {
            get { return _allowPreviewVersioning; }
        }
        public string PathValidationString
        {
            get { return _pathValidationString; }
        }
        public Regex PathValidationRegex
        {
            get { return _pathValidationRegex; }
        }
        public int DefaultExpiryInDays
        {
          get { return _defaultExpiryInDays; }
        }

        [XmlIgnore]
        public uint[] Permissions {
            get { return _permissions; }
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            sb.Append("_maxFileSize: " + _maxFileSize + "\n");
            sb.Append("_cacheReadFiles: " + _cacheReadFiles + "\n");
            sb.Append("_readFileCacheTimeSeconds: " + _readFileCacheTimeSeconds + "\n");
            sb.Append("_cacheEnumFiles: " + _cacheEnumFiles + "\n");
            sb.Append("_enumFileCacheTimeSeconds: " + _enumFileCacheTimeSeconds + "\n");
            sb.Append("_quotaEnabled: " + _quotaEnabled + "\n");
            sb.Append("_allowOverwrites: " + _allowOverwrites + "\n");
            sb.Append("_allowCrossTitle: " + _allowCrossTitle + "\n");
            sb.Append("_allowPreviewVersioning: " + _allowPreviewVersioning + "\n");
            sb.Append("_pathValidationString: " + _pathValidationString + "\n");
            sb.Append("_defaultExpiryInDays: " + _defaultExpiryInDays.ToString() + "\n");

            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\feedbackprot.cs ===
// 
// FeedbackProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Feedback Service Integration
// Xbox Online Service
// 
// Author: masonb
//

using System;
using xonline.common.service;
using xonline.common.mgmt;


[assembly: XomAreaDefinition(XomAreaName.FeedbackProxy)]


namespace xonline.common.protocol 
{    
    //
    // Feedback definitions
    //
    public class FeedbackDefs
    {
        // Header name for redirecting presence requests for stress testing. 
        public const string AlternatePresenceDestinationHeaderName = "AlternatePresenceDestination";
        
        // 
        // Enumeration of feedback types
        //  Maps to XONLINE_FEEDBACK_TYPE in xonline.x
        //
        public enum FeedbackType : byte
        {
            NegNickname = 0,
            NegGameplay = 1,
            NegScreaming = 2,
            NegHarassment = 3,
            NegLewdness = 4,
            PosAttitude = 5,
            PosSession = 6,
            PosStatsAttachment = 7,
            NegStatsAttachment = 8,
            NegStatsAttachmentCheating = 9,
            NegMessageInappropriate = 10,
            NegMessageSpam = 11,
            NegTeamName = 12,
            NegTeamMotto = 13,
            NegTeamContent = 14,
            NegTeamDescription = 15,
            NegTeamURL = 16,
            NegCompetitionName = 17,
            NegCompetitionMotto = 18,
            NegCompetitionContent = 19,

            // Add new public types here
  
            NumTypes,

            MinServiceType = 254,

            // Add new private service types here and decrement MinServiceType

            ServiceDataMachine = 255,

        }

        // 
        // Enumeration of player review types
        //  Maps to ??? in xonline.x
        //
        public enum PlayerReview : uint
        {
            Prefer = 0,
            AvoidTrashTalk = 1,
            AvoidLanguage = 2,
            AvoidDisruptive = 3,
            AvoidAggressive = 4,
            AvoidUnsporting = 5,
            AvoidDisconnect = 6,
            AvoidUnskilled = 7,
            AvoidTooGood = 8,
            AvoidUnfamiliar = 9,


            // Add new review types here
        }
        
        // 
        // Enumeration of player review types
        //  Maps to ??? in xonline.x
        //
        public enum ComplaintType : uint
        {
            OffensiveGamertag = 0,
            OffensiveMotto = 1,
            OffensiveTextMessage = 2,
            OffensiveVoiceMail = 3,
            OffensiveVoiceChat = 4,
            OffensiveInGame = 5,
            TamperingFeedback = 6,
            TamperingSystem = 7,
            TamperingCheating = 8,
            OffensiveUserContent = 9,
            OffensiveVideoMessage = 10,
            OffensiveVideoChat = 11,
            OffensiveGamerPicture = 12,
            OffensiveInGameVideo = 13,
            OffensivePhotoMessage  = 14,
            OffensiveUrl = 15,
            ChildAbuse = 16,
            
            // Add new complaint types here
  
        }
        
    } // end definitions

    //
    // Structure Representing a Feedback request.
    //  Maps to XONFEEDBACK_SEND_REQUEST in xonline.x
    //  
    public class FeedbackRequest : XRLObject2
    {
        public ulong   ulSendPUID;
        public ulong   ulTargetPUID;
        public uint    uiTitleID;
        public byte    bFeedbackType;
        public byte    bTextSize;

        [WireInfo(SizeParam="bTextSize")]
        public string  szText;

        public override string Xrl
        {
            get
            {
                return "/fbserver/fbserver.ashx";
            }
        }
    }

    //
    // Structure Representing a Player Review request.
    //  Maps to ??? in xonline.x
    //  
    public class SubmitReviewRequest : XRLObject2
    {
        public ulong   senderPUID;
        public ulong   targetPUID;
        public uint    titleID;
        public uint    type;
        public ulong   context;

        public override string Xrl
        {
            get
            {
                return "/fbserver/submitreview.ashx";
            }
        }
    }


    //
    // Structure Representing an enumeration of Player Reviews sent by a particular user.
    //  Maps to ??? in xonline.x
    //  
    public class EnumerateSentReviewsRequest : XRLObject2
    {
        public ulong   senderPUID;
        public uint    page;
        public uint    resultsPerPage;

        public override string Xrl
        {
            get
            {
                return "/fbserver/enumsentreview.ashx";
            }
        }
    }

    //
    // Structure Representing an enumeration of Player Reviews received by a particular user.
    //  Maps to ??? in xonline.x
    //  
    public class EnumerateRecdReviewsRequest : XRLObject2
    {
        public ulong   targetPUID;
        public uint    page;
        public uint    resultsPerPage;

        public override string Xrl
        {
            get
            {
                return "/fbserver/enumrecdreview.ashx";
            }
        }

    }

    //
    // A single PlayerReview result
    //  
    public class PlayerReview : WireData
    {
        public ulong       senderPUID;
        public ulong       targetPUID;
        public uint        titleID;
        public uint        type;
        public ulong       context;
        public DateTime    dtSubmitted;
    }

    //
    // A reply to either a EnumerateSentReviewsRequest or EnumerateRecdReviewsRequest message
    //  
    public class EnumerateReviewsReply : XRLObject2
    {
        public HResult     hr;
        public uint        cReviews;

        [WireInfo(SizeParam="cReviews")]
        public PlayerReview [] reviews;
    }


    //
    // Structure Representing an request to retrieve a users aggregated Player Reviews data.
    //  Maps to ??? in xonline.x
    //  
    public class GetAggregateReviewsRequest : XRLObject2
    {
        public ulong   targetPUID;

        public override string Xrl
        {
            get
            {
                return "/fbserver/getaggreview.ashx";
            }
        }
    }

    //
    // A single AggregateReview result
    //  
    public class AggregateReview : WireData
    {
        public ulong       targetPUID;
        public uint        count;
        public uint        type;
    }

    //
    // A reply to a GetAggregateReviewsRequest message
    //  
    public class GetAggregateReviewsReply : XRLObject2
    {
        public HResult     hr;
        public uint        cReviews;

        [WireInfo(SizeParam="cReviews")]
        public AggregateReview [] aggReviews;
    }

    //
    // Structure Representing an request to retrieve a users aggregated Player Reviews data.
    //  Maps to ??? in xonline.x
    //  
    public class SubmitComplaintRequest : XRLObject2
    {
        public ulong   senderPUID;
        public ulong   targetPUID;
        public uint    titleID;
        public uint    type;
        public ulong   context;
	
        public override string Xrl
        {
            get
            {
                return "/fbserver/submitcomplaint.ashx";
            }
        }
    }

    //
    // Structures for the XeSchemaUnitTest component.
    //

    public class XeSchemaUnitTestComplexType : XRLObject2
    {
        [WireInfo(MinSchemaVersion="3.0")]        
        public ushort  v3_ushort_field = '\0';
        [WireInfo(MinSchemaVersion="4.0")]        
        public int     v4_int_field = 0;
    }
    
    public class XeSchemaUnitTestRequest : XRLObject2
    {
        public uint                         v1_uint_field = 0;
        [WireInfo(MaxSchemaVersion="3.0")]
        public ulong                        v1_ulong_field = 0;
        
        [WireInfo(MinSchemaVersion="2.0")]        
        public uint                         v2_string_field_length = 7;
        [WireInfo(SizeParam="v2_string_field_length", MinSchemaVersion="2.0")]
        public string                       v2_string_field = "default";

        [WireInfo(MinSchemaVersion="3.0")]
        public XeSchemaUnitTestComplexType  v3_4_complex_field;

        public override string Xrl
        {
            get
            {
                return "/fbserver/XeSchemaUnitTest.ashx";
            }
        }
    }

    public class XeSchemaUnitTestResponse : XRLObject2
    {
        public uint                         v1_uint_field = 0;
        [WireInfo(MaxSchemaVersion="3.0")]
        public ulong                        v1_ulong_field = 0;
        
        [WireInfo(MinSchemaVersion="2.0")]        
        public uint                         v2_string_field_length = 7;
        [WireInfo(SizeParam="v2_string_field_length", MinSchemaVersion="2.0")]
        public string                       v2_string_field = "default";

        [WireInfo(MinSchemaVersion="3.0")]
        public XeSchemaUnitTestComplexType  v3_4_complex_field = new XeSchemaUnitTestComplexType();
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\HTTPUtils.cs ===
namespace xonline.common.protocol
{



    public class HTTPHeaders
    {
        //See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html

        public const string IfModifiedSince = "If-Modified-Since";
        public const string CacheControl = "Cache-Control";
        public const string LastModified = "Last-Modified";
        public const string ContentType = "Content-Type";
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\ListsProtocol.cs ===
using System;

using xonline.common.service;


//--------------------------------------------------------------------------------
// NOTE:  changes to the WireData objects or to the Reply objects will impact classes in DownloadQueueProtocol.cs
//--------------------------------------------------------------------------------

namespace xonline.common.protocol
{
    public class ListInfo : WireData
    {
        public int listType;
        public int listId;
        public DateTime lastModified;
        public int totalItems;
        public byte nameLength;
        public ushort xmlLength;

        [WireInfo( SizeParam = "nameLength" )]
        public string name;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlProperties;
    }


    public class ListItem : WireData
    {
        public Guid itemId;
        public short priority;
        public ushort xmlLength;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlItem;
    }


    public class ListItemMod : WireData
    {
        public Guid itemId;
        public ushort xmlLength;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlItem;
    }


    public class ListItemIndex : WireData
    {
        public Guid itemId;
        public short priority;
        public int index;
    }


    public class CreateListRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public byte nameLength;
        public ushort xmlLength;

        [WireInfo( SizeParam = "nameLength" )]
        public string name;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlProperties;

        public override string Xrl
        {
            get
            {
                return "/Lists/CreateList.ashx";
            }
        }
    }


    public class CreateListResponse : XRLObject2
    {
        public int listId;
        public DateTime lastModified;

        public CreateListResponse( CreateListReply reply )
        {
            listId = reply.listId;
            lastModified = reply.lastModified;
        }
    }


    public class CreateListReply
    {
        public uint status = HResult.S_OK;
        public int listId = int.MinValue;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
    }


    public class DeleteListRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;

        public override string Xrl
        {
            get
            {
                return "/Lists/DeleteList.ashx";
            }
        }
    }


/*
    public class DeleteListResponse : XRLObject2
    {
        public DeleteListResponse( DeleteListReply reply )
        {
        }
    }
*/


    public class DeleteListReply
    {
        public uint status = HResult.S_OK;
    }


    public class ModifyListRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public DateTime lastModified;
        public ushort xmlLength;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlProperties;

        public override string Xrl
        {
            get
            {
                return "/Lists/ModifyList.ashx";
            }
        }
    }


    public class ModifyListResponse : XRLObject2
    {
        public DateTime lastModified;

        public ModifyListResponse( ModifyListReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class ModifyListReply
    {
        public uint status = HResult.S_OK;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
    }


    public class QueryListsRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType; // int.MinValue is wildcard
        public int listId; // int.MinValue is wildcard
        public DateTime lastModified;
        public int pageSize;
        public int pageNum;
        public int orderDir;

        public override string Xrl
        {
            get
            {
                return "/Lists/QueryLists.ashx";
            }
        }
    }


    public class QueryListsResponse : XRLObject2
    {
        public ushort totalLists = 0;
        public ushort numLists = 0;

        [WireInfo( SizeParam = "numLists" )]
        public ListInfo[] resultLists = null;

        public QueryListsResponse( QueryListsReply reply )
        {
            totalLists = reply.totalLists;
            resultLists = reply.resultLists;
            if( resultLists != null ) {
                numLists = (ushort) resultLists.Length;
            }
        }
    }


    public class QueryListsReply
    {
        public uint status = HResult.S_OK;
        public ushort totalLists = 0;
        public ListInfo[] resultLists = null;
    }


    public class GrantListAccessRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public ulong machinePuid;

        public override string Xrl
        {
            get
            {
                return "/Lists/GrantListAccess.ashx";
            }
        }
    }


/*
    public class GrantListAccessResponse : XRLObject2
    {
        public GrantListAccessResponse( GrantListAccessReply reply )
        {
        }
    }
*/


    public class GrantListAccessReply
    {
        public uint status = HResult.S_OK;
    }


    public class RevokeListAccessRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public ulong machinePuid; // 0 is wildcard

        public override string Xrl
        {
            get
            {
                return "/Lists/RevokeListAccess.ashx";
            }
        }
    }


/*
    public class RevokeListAccessResponse : XRLObject2
    {
        public RevokeListAccessResponse( RevokeListAccessReply reply )
        {
        }
    }
*/


    public class RevokeListAccessReply
    {
        public uint status = HResult.S_OK;
    }


    public class InsertItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public DateTime lastModified;
        public ushort numItems;

        [WireInfo( SizeParam = "numItems" )]
        public ListItem[] items;

        public override string Xrl
        {
            get
            {
                return "/Lists/InsertItems.ashx";
            }
        }
    }


    public class InsertItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public InsertItemsResponse( InsertItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class InsertItemsReply
    {
        public uint status = HResult.S_OK;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
    }


    public class DeleteItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public DateTime lastModified;
        public ushort numIds;

        [WireInfo( SizeParam = "numIds" )]
        public Guid[] itemIds;

        public override string Xrl
        {
            get
            {
                return "/Lists/DeleteItems.ashx";
            }
        }
    }


    public class DeleteItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public DeleteItemsResponse( DeleteItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class DeleteItemsReply
    {
        public uint status = HResult.S_OK;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
    }


    public class ModifyItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public DateTime lastModified;
        public ushort numItems;

        [WireInfo( SizeParam = "numItems" )]
        public ListItemMod[] items;

        public override string Xrl
        {
            get
            {
                return "/Lists/ModifyItems.ashx";
            }
        }
    }


    public class ModifyItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public ModifyItemsResponse( ModifyItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class ModifyItemsReply
    {
        public uint status = HResult.S_OK;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
    }


    public class QueryItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public int pageSize;
        public int pageNum;
        public int orderDir;
        public ushort numIds;

        [WireInfo( SizeParam = "numIds" )]
        public Guid[] itemIds; // empty array is wildcard

        public override string Xrl
        {
            get
            {
                return "/Lists/QueryItems.ashx";
            }
        }
    }


    public class QueryItemsResponse : XRLObject2
    {
        public ushort totalItems = 0;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
        public ushort numItems = 0;

        [WireInfo( SizeParam = "numItems" )]
        public ListItem[] resultItems = null;

        public QueryItemsResponse( QueryItemsReply reply )
        {
            totalItems = reply.totalItems;
            lastModified = reply.lastModified;
            resultItems = reply.resultItems;
            if( resultItems != null ) {
                numItems = (ushort) resultItems.Length;
            }
        }
    }


    public class QueryItemsReply
    {
        public uint status = HResult.S_OK;
        public ushort totalItems = 0;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
        public ListItem[] resultItems = null;
    }


    public class MoveItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int listType;
        public int listId;
        public DateTime lastModified;
        public ushort numIndices;

        [WireInfo( SizeParam = "numIndices" )]
        public ListItemIndex[] itemIndices;

        public override string Xrl
        {
            get
            {
                return "/Lists/MoveItems.ashx";
            }
        }
    }


    public class MoveItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public MoveItemsResponse( MoveItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }

    
    public class MoveItemsReply
    {
        public uint status = HResult.S_OK;
        public DateTime lastModified = new DateTime( 1601, 1, 1, 0, 0, 0, DateTimeKind.Utc );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\giprot.cs ===
// 
// GIProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Game Instrumentation Service Integration
// Xbox Online Service
// 

using System;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.service;


namespace xonline.common.protocol 
{
    public class GITypes
    {
        public const uint XONLINE_STAT_DATATYPE_MASK     = 0xF0000000;
        
        public const uint XONLINE_STAT_NULL              = 0x00000000;
        public const uint XONLINE_STAT_LONG              = 0x10000000;
        public const uint XONLINE_STAT_LONGLONG          = 0x20000000;
        public const uint XONLINE_STAT_DOUBLE            = 0x30000000;
        public const uint XONLINE_STAT_LPCWSTR           = 0x40000000;
        public const uint XONLINE_STAT_FLOAT             = 0x50000000;
        public const uint XONLINE_STAT_BINARY            = 0x60000000;
        public const uint XONLINE_STAT_DATETIME          = 0x70000000;
    }

    public class GIDefs
    {
        public const uint X_CONTEXT_PRESENCE            = 0x00008001;
        public const uint X_CONTEXT_GAME_TYPE           = 0x0000800A;
        public const uint X_CONTEXT_GAME_MODE           = 0x0000800B;
    }
    
    //
    // Basic Context name value pair. The value always corresponds to a localized label for display purposes
    //
    public class GIContext : WireData
    {
        public uint           Id;
        public uint           Value;

        public GIContext() { }
        public GIContext(uint id)
        {
            Id = id;
        }    
        public GIContext(uint id, uint value)
        {
            Id = id;
            Value = value;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                Id = binaryReader.ReadUInt32();
                Value = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_8, 
                    "Reached end of stream trying to read GIContext", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(Id);
            binaryWriter.Write(Value);
        }

    }


    //
    // Property data for Game Instrumentation. This is the meat of how data is represented via instrumentation
    //
    public class GIProperty: WireData
    {
        public GIProperty() { }
        public GIProperty(uint id)
        {
            Id = id;

            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                fValue = (float)0.0;
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                dtValue = (DateTime)DateTime.UtcNow;
                break;
                
            case GITypes.XONLINE_STAT_DOUBLE:
                dValue = (double)0.0;
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                nValue = (int)0;
                break;
            
            case GITypes.XONLINE_STAT_LONGLONG:
                lValue = (long)0;
                break;
            
            case GITypes.XONLINE_STAT_LPCWSTR:
                strValue = "";
                break;
            }            
        }    
        
        public GIProperty(uint id, float f)
        {
            Id = id;
            fValue = f;
            
            if ( (id & GITypes.XONLINE_STAT_FLOAT) != GITypes.XONLINE_STAT_FLOAT)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, DateTime dt)
        {
            Id = id;
            dtValue = dt;
            
            if ((id & GITypes.XONLINE_STAT_DATETIME) != GITypes.XONLINE_STAT_DATETIME)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, double d)
        {
            Id = id;
            dValue = d;

            if ( (id & GITypes.XONLINE_STAT_DOUBLE) != GITypes.XONLINE_STAT_DOUBLE)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, int n)
        {
            Id = id;
            nValue = n;

            if ( (id & GITypes.XONLINE_STAT_LONG) != GITypes.XONLINE_STAT_LONG)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, long l)
        {
            Id = id;
            lValue = l;

            if ( (id & GITypes.XONLINE_STAT_LONGLONG) != GITypes.XONLINE_STAT_LONGLONG)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, string str)
        {
            Id = id;
            strValue = str;

            if ( (id & GITypes.XONLINE_STAT_LPCWSTR) != GITypes.XONLINE_STAT_LPCWSTR)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }    
        public GIProperty(uint id, byte[] bin)
        {
            Id = id;
            binValue = bin;

            if ( (id & GITypes.XONLINE_STAT_BINARY) != GITypes.XONLINE_STAT_BINARY)
            {
                throw new ArgumentException("Property created with incorrect type mask specified");
            }
        }            
        
        
        //
        // Data exposed to SOAP for web services
        //
        [XmlAttribute]
        public uint Id;

        public object Value
        {
            get { return _value; }
            set { _value = value; } 
        }       


        //
        // Strongly typed accessors (these aren't serialized)
        //
        [XmlIgnore]
        public float fValue
        {
            get { return (float)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public DateTime dtValue
        {
            get { return (DateTime)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public double dValue
        {
            get { return (double)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public int nValue
        {
            get { return (int)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public long lValue
        {
            get { return (long)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public string strValue
        {
            get { return (string)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public byte[] binValue
        {
            get { return (byte[])_value; }
            set { _value = value; } 
        }
        

        //
        // Private data
        //
        protected object _value;
        

        //
        // Override default implementations of WireData methods for this class
        //
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            int     len;
            
            Id = (uint)binaryReader.ReadInt32();          
            
            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                fValue = binaryReader.ReadSingle();
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                dtValue = DateTime.FromFileTimeUtc(binaryReader.ReadInt64());
                break;

            case GITypes.XONLINE_STAT_DOUBLE:
                dValue = binaryReader.ReadDouble();
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                nValue = binaryReader.ReadInt32();
                break;
            
            case GITypes.XONLINE_STAT_LONGLONG:
                lValue = binaryReader.ReadInt64();
                break;
            
            case GITypes.XONLINE_STAT_LPCWSTR:
                len = binaryReader.ReadUInt16();
                strValue = Encoding.Unicode.GetString(binaryReader.ReadBytes(len));
                break;
                
            case GITypes.XONLINE_STAT_BINARY:
                len = binaryReader.ReadUInt16();
                binValue = binaryReader.ReadBytes(len);
                break;
            
            default:
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.COMMON_CODE_42, 
                    "Unrecgonized datatype: 0x" + (Id & GITypes.XONLINE_STAT_DATATYPE_MASK).ToString("x") + "! property id: " + Id);
            }

			return this;                                
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {            
            binaryWriter.Write(Id);
                
            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                binaryWriter.Write(fValue);
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                binaryWriter.Write(Convert.ToDateTime(dtValue).ToFileTimeUtc());
                break;
            
            case GITypes.XONLINE_STAT_DOUBLE:
                binaryWriter.Write(dValue);
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                binaryWriter.Write(nValue);
                break;
                
            case GITypes.XONLINE_STAT_LONGLONG:
                binaryWriter.Write(lValue);
                break;
                
            case GITypes.XONLINE_STAT_LPCWSTR:
                {
                byte[] buf;
                
                buf = Encoding.Unicode.GetBytes(strValue);
                binaryWriter.Write((ushort)buf.Length);
                binaryWriter.Write(buf);
                }
                break;
                
            case GITypes.XONLINE_STAT_BINARY:
                binaryWriter.Write((ushort)binValue.Length);
                binaryWriter.Write(binValue);
                break;
            
            default:
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.COMMON_CODE_43, 
                    "Unexpected datatype: 0x" + (Id & GITypes.XONLINE_STAT_DATATYPE_MASK).ToString("x") + "! property id: " + Id);
            }
        }

        // 
        // Provide a formatted ToString method so that we can get good debug output in exceptions/events/logs
        //
        public override string ToString(int indent)
        {
            StringBuilder str = new StringBuilder();
            
            str.Append("\n" + "".PadLeft(indent) + "Id" + "=0x" + Id.ToString("x8"));                
            str.Append("\n" + "".PadLeft(indent) + "Value" + "=");
                
            switch(Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
            {
            case GITypes.XONLINE_STAT_FLOAT:
                str.Append(fValue);
                break;
            
            case GITypes.XONLINE_STAT_DATETIME:
                str.Append(dtValue);
                break;
            
            case GITypes.XONLINE_STAT_DOUBLE:
                str.Append(dValue);
                break;
            
            case GITypes.XONLINE_STAT_LONG:
                str.Append(nValue);
                break;
                
            case GITypes.XONLINE_STAT_LONGLONG:
                str.Append(lValue);
                break;
                
            case GITypes.XONLINE_STAT_LPCWSTR:
                str.Append(strValue);
                break;
                
            case GITypes.XONLINE_STAT_BINARY:
                str.Append(ByteConvert.ToString(binValue));                    
                break;

            default:
                str.Append("null");
                break;
            }
            
            return str.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\AccountsProtocol.cs ===
using System;
using System.IO;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.core.wiredata;

[assembly: XomAreaDefinition(XomAreaName.passportTrace)]

namespace xonline.common.protocol
{
    public enum ServiceTypeEnum : uint
    {
        Unknown     = 0,
        XboxLive    = 1,
        Zune        = 2,
    }

    public enum UserAgeGroupEnum : uint
    {
        Child = 0,
        Teen = 1,
        Adult = 2,
    }

    public enum ClientTypeEnum : uint
    {
        Unknown     = 0,
        Xbox1       = 1,
        Xenon       = 2,
        Panorama    = 4,
        Web         = 8,
        ZuneDorado  = 16,
        WindowsPhone = 32,

        // Xuacs.GetSupportedCountries uses this value to retreive a static list of countries for Windows Phone
        // versions Mango and below. It is not intended for use anywhere else.
        WindowsPhoneMango = 64,
    }

    public enum KeyId : int
    {
        Ctp = 1
    }

    public class AddressInfoData : WireData
    {
        public ushort street1Length = 0;

        [WireInfo(SizeParam="street1Length")]
        public string street1 = "";

        public ushort street2Length = 0;

        [WireInfo(SizeParam="street2Length")]
        public string street2 = "";

        public ushort cityLength = 0;

        [WireInfo(SizeParam="cityLength")]
        public string city = "";

        public ushort districtLength = 0;

        [WireInfo(SizeParam="districtLength")]
        public string district = "";

        public ushort stateLength = 0;

        [WireInfo(SizeParam="stateLength")]
        public string state = "";

        public ushort postalCodeLength = 0;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode = "";
    }

    public class PhoneInfoData : WireData
    {
        [WireInfo(Min=0, Max=XOn.MAX_PHONE_PREFIX_SIZE)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix = "";

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_NUMBER_SIZE)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber = "";

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension = "";
    }

    public class CreditCardInfoData : WireData
    {
        public byte     cardType;

        public ushort   accountHolderNameLength = 0;

        [WireInfo(SizeParam="accountHolderNameLength")]
        public string   accountHolderName = "";

        [WireInfo(Min=0, Max=XOn.MAX_CC_NUMBER_SIZE*XOn.UTF8_MULT)]
        public ushort   accountNumberLength = 0;

        [WireInfo(SizeParam="accountNumberLength", MaskString=true)]
        public string   accountNumber = "";

        public ushort   ccvNumberLength = 0;

        [WireInfo(SizeParam="ccvNumberLength", MaskString=true)]
        public string   ccvNumber = "";

        [WireInfo(MaskString=true)]
        public DateTime expirationDate = new DateTime(2001,11,15);
    }

    public class CreditCardInfoDataEx : WireData
    {
        public byte cardType;

        public ushort accountHolderNameLength = 0;

        [WireInfo(SizeParam = "accountHolderNameLength")]
        public string accountHolderName = "";

        public ushort accountNumberLength = 0;

        [WireInfo(SizeParam = "accountNumberLength", MaskString = true)]
        public string encryptedAccountNumber = "";

        public ushort lastFourAccountNumberLength = 0;

        [WireInfo(SizeParam = "lastFourAccountNumberLength", MaskString = true)]
        public string lastFourAccountNumber = "";

        public ushort ccvNumberLength = 0;

        [WireInfo(SizeParam = "ccvNumberLength", MaskString = true)]
        public string encryptedCcvNumber = "";

        [WireInfo(MaskString = true)]
        public DateTime expirationDate = new DateTime(2001, 11, 15);
    }

    public class DirectDebitInfoData : WireData
    {
        public ushort   accountHolderNameLength = 0;

        [WireInfo(SizeParam="accountHolderNameLength")]
        public string   accountHolderName = "";

        public ushort   accountNumberLength = 0;

        [WireInfo(SizeParam="accountNumberLength", MaskString=true)]
        public string   accountNumber = "";

        [WireInfo(Min=0, Max=XOn.MAX_BANK_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort bankCodeLength;

        [WireInfo(SizeParam="bankCodeLength")]
        public string bankCode = "";

        [WireInfo(Min=0, Max=XOn.MAX_BRANCH_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort branchCodeLength;

        [WireInfo(SizeParam="branchCodeLength")]
        public string branchCode = "";

        [WireInfo(Min=0, Max=XOn.MAX_CHECK_DIGITS_SIZE)]
        public ushort checkDigitsLength;

        [WireInfo(SizeParam="checkDigitsLength")]
        public string checkDigits = "";
    }

    public class DirectDebitInfoDataEx : WireData
    {
        public ushort accountHolderNameLength = 0;

        [WireInfo(SizeParam = "accountHolderNameLength")]
        public string accountHolderName = "";

        public ushort accountNumberLength = 0;

        [WireInfo(SizeParam = "accountNumberLength", MaskString = true)]
        public string encryptedAccountNumber = "";

        public ushort lastFourAccountNumberLength = 0;

        [WireInfo(SizeParam = "lastFourAccountNumberLength", MaskString = true)]
        public string lastFourAccountNumber = "";

        [WireInfo(Min = 0, Max = XOn.MAX_BANK_CODE_SIZE * XOn.UTF8_MULT)]
        public ushort bankCodeLength;

        [WireInfo(SizeParam = "bankCodeLength")]
        public string bankCode = "";

        [WireInfo(Min = 0, Max = XOn.MAX_BRANCH_CODE_SIZE * XOn.UTF8_MULT)]
        public ushort branchCodeLength;

        [WireInfo(SizeParam = "branchCodeLength")]
        public string branchCode = "";

        [WireInfo(Min = 0, Max = XOn.MAX_CHECK_DIGITS_SIZE)]
        public ushort checkDigitsLength;

        [WireInfo(SizeParam = "checkDigitsLength")]
        public string checkDigits = "";
    }

    public class WholesaleInfoData : WireData
    {
        public ushort accountHolderNameLength = 0;

        [WireInfo(SizeParam = "accountHolderNameLength")]
        public string accountHolderName = "";

        public ushort externalReferenceIdLength = 0;

        [WireInfo(SizeParam = "externalReferenceIdLength", MaskString = true)]
        public string externalReferenceId = "";

        public ushort wholesalePartnerLength = 0;

        [WireInfo(SizeParam = "wholesalePartnerLength", MaskString = true)]
        public string wholesalePartner = "";

        public ushort encryptedPasswordLength = 0;

        [WireInfo(SizeParam = "encryptedPasswordLength", MaskString = true)]
        public string encryptedPassword = "";
    }

    public class BillingAgreementDetails  : WireData
    {
        public ushort payerEmailLength;

        [WireInfo(SizeParam = "payerEmailLength")]
        public string payerEmail;

        public ushort billingAgreementIdLength;

        [WireInfo(SizeParam = "billingAgreementIdLength")]
        public string billingAgreementId;

        public ushort firstNameLength;

        [WireInfo(SizeParam = "firstNameLength")]
        public string firstName;

        public ushort lastNameLength;

        [WireInfo(SizeParam = "lastNameLength")]
        public string lastName;

        public ushort middleNameLength;

        [WireInfo(SizeParam = "middleNameLength")]
        public string middleName;

        public ushort payerBusinessLength;

        [WireInfo(SizeParam = "payerBusinessLength")]
        public string payerBusiness;

        public ushort payerCountryLength;

        [WireInfo(SizeParam = "payerCountryLength")]
        public string payerCountry;

        public ushort billingAgreementDescriptionLength;

        [WireInfo(SizeParam = "billingAgreementDescriptionLength")]
        public string billingAgreementDescription;
    }

    public class PayPalPayinInfoData : WireData
    {
        public PayPalPayinInfoData()
        {
            billingAgreementDetails = new BillingAgreementDetails();
        }

        public BillingAgreementDetails billingAgreementDetails;
    }

    public class InicisPayinInfoData : WireData
    {
        public ushort billKeyLength;

        [WireInfo( SizeParam = "billKeyLength" )]
        public string billKey;

        public ushort buyerEmailLength;

        [WireInfo( SizeParam = "buyerEmailLength" )]
        public string buyerEmail;

        public ushort firstNameLength;

        [WireInfo( SizeParam = "firstNameLength" )]
        public string firstName;

        public ushort identifierLength;

        [WireInfo( SizeParam = "identifierLength" )]
        public string identifier;

        public ushort lastNameLength;

        [WireInfo( SizeParam = "lastNameLength" )]
        public string lastName;

        public ushort subTypeLength;

        [WireInfo( SizeParam = "subTypeLength" )]
        public string subType;
    }

    public class PassportCredentialInfoData : WireData
    {
        [WireInfo(HexString=true)]
        public Puid PassportPuid;

        public ushort PassportMemberNameLength = 0;
    
        [WireInfo(SizeParam="PassportMemberNameLength")]
        public string PassportMemberName;

        public bool IsActive;	
    }



    


    // requests that contain account creation information should
    // implement this so the common utilities can be created
    public interface ICreateAccountRequest
    {
        string FirstName { get; }
        string LastName { get; }
        string Gamertag { get; }
        string Email { get; }
        PhoneInfoData PhoneInfo { get; }
        AddressInfoData AddressInfo { get; }
        byte PaymentInstrumentType { get; }
        CreditCardInfoData CreditCardInfo { get ; }
        DirectDebitInfoData DirectDebitInfo { get; }
        WholesaleInfoData WholesaleInfo { get; }
        byte CountryId { get; }
        ushort LanguageId { get; }
        string CountryCode { get; }
        DateTime BirthDate { get; }
        ulong MachinePuid { get; }
        byte MsftOptIn { get; }
        byte PartnerOptIn { get; }
    }

    public interface ICreateAccountRequestEx
    {
        string FirstName { get; }
        string LastName { get; }
        string Gamertag { get; }
        string Email { get; }
        PhoneInfoData PhoneInfo { get; }
        AddressInfoData AddressInfo { get; }
        byte PaymentInstrumentType { get; }
        CreditCardInfoDataEx CreditCardInfo { get; }
        DirectDebitInfoDataEx DirectDebitInfo { get; }
        WholesaleInfoData WholesaleInfo { get; }
        byte CountryId { get; }
        ushort LanguageId { get; }
        string CountryCode { get; }
        DateTime BirthDate { get; }
        ulong MachinePuid { get; }
        byte MsftOptIn { get; }
        byte PartnerOptIn { get; }
    }

    public abstract class CreateUserResponse : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid = 0;
    }

    public interface ITrustedCreateAccountRequest : ICreateAccountRequest
    {
        ulong UserPassportPuid { get; }
        ulong OwnerPassportPuid { get; }
    }


    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class CreateLiveAccountRequest : XRLObject2, ICreateAccountRequest
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString=true)]
        public ulong offlineXuid = 0;

        [WireInfo(HexString=true)]
        public uint titleId = 0;

        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName = "";

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName = "";

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag = "";

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOwnerPassportPuid;

        [WireInfo(HexString=true)]
        public ulong offerId = 0;

        public ushort billingTokenLength = 0;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken = "";

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public int parentalControlGroupId = 0;

        public byte msftOptIn;

        public byte partnerOptIn;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        public ushort reservedBytesLength = 0;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;

        [WireInfo(Serialize=false)]
        public string countryCode;

        public override string Xrl
        {
            get { return "/xuacs/XeCreateLiveAccount.ashx"; }
        }

        // ICreateAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get { return phoneInfo; }
        }
        public AddressInfoData AddressInfo
        {
            get { return addressInfo; }
        }
        public byte PaymentInstrumentType
        {
            get { return paymentInstrumentType; }
        }
        public CreditCardInfoData CreditCardInfo
        {
            get { return creditCardInfo; }
        }
        public DirectDebitInfoData DirectDebitInfo
        {
            get { return directDebitInfo; }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return new WholesaleInfoData(); }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return xonline.common.utilities.CountryDictionary.CountryCode(countryId); }
        }

        public DateTime BirthDate
        {
            get { return birthdate; }
        }
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }
        public byte MsftOptIn
        {
            get { return msftOptIn; }
        }
        public byte PartnerOptIn
        {
            get { return partnerOptIn; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class CreateLiveAccountRequestEx : XRLObject2, ICreateAccountRequestEx
    {
        [WireInfo(HexString = true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString = true)]
        public ulong offlineXuid = 0;

        [WireInfo(HexString = true)]
        public uint titleId = 0;

        [WireInfo(Min = 0, Max = XOn.MAX_FIRSTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam = "firstNameLength")]
        public string firstName = "";

        [WireInfo(Min = 0, Max = XOn.MAX_LASTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam = "lastNameLength")]
        public string lastName = "";

        [WireInfo(Min = 1, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam = "gamertagLength")]
        public string gamertag = "";

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOwnerPassportPuid;

        [WireInfo(HexString = true)]
        public ulong offerId = 0;

        public ushort billingTokenLength = 0;

        [WireInfo(SizeParam = "billingTokenLength")]
        public string billingToken = "";

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam = "emailLength")]
        public string email;

        [WireInfo(Min = 1, Max = XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public int parentalControlGroupId = 0;

        public byte msftOptIn;

        public byte partnerOptIn;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoDataEx creditCardInfo;

        public DirectDebitInfoDataEx directDebitInfo;

        public ushort reservedBytesLength = 0;

        [WireInfo(SizeParam = "reservedBytesLength")]
        public byte[] reservedBytes;

        [WireInfo(Serialize = false)]
        public string countryCode;

        public override string Xrl
        {
            get { return "/xuacs/XeCreateLiveAccountEx.ashx"; }
        }

        // ICreateAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get { return phoneInfo; }
        }
        public AddressInfoData AddressInfo
        {
            get { return addressInfo; }
        }
        public byte PaymentInstrumentType
        {
            get { return paymentInstrumentType; }
        }
        public CreditCardInfoDataEx CreditCardInfo
        {
            get { return creditCardInfo; }
        }
        public DirectDebitInfoDataEx DirectDebitInfo
        {
            get { return directDebitInfo; }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return new WholesaleInfoData(); }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return xonline.common.utilities.CountryDictionary.CountryCode(countryId); }
        }

        public DateTime BirthDate
        {
            get { return birthdate; }
        }
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }
        public byte MsftOptIn
        {
            get { return msftOptIn; }
        }
        public byte PartnerOptIn
        {
            get { return partnerOptIn; }
        }
    }

    public class CreateLiveAccountResponse : CreateUserResponse
    {
        [WireInfo(ArraySize = (int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xboxKey;

        [WireInfo(ArraySize = (int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;
    }

    public class CreateLiveAccountExtra : XRLObject2
    {
        public bool createArgoProfile;
    }

    public class CreateLiveAccountEntryPoint : XRLObject2
    {
        public uint serviceType;
        public uint clientType;
    }


    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class CreateWholesaleAccountRequest : XRLObject2, ICreateAccountRequest {

        [WireInfo(HexString = true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString = true)]
        public ulong offlineXuid = 0;

        [WireInfo(HexString = true)]
        public uint wholesalePartnerId = 0;

        [WireInfo(Min = 1, Max = XOn.MAX_FIRSTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam = "firstNameLength")]
        public string firstName = "";

        [WireInfo(Min = 1, Max = XOn.MAX_LASTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam = "lastNameLength")]
        public string lastName = "";

        [WireInfo(Min = 1, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam = "gamertagLength")]
        public string gamertag = "";

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOwnerPassportPuid;

        [WireInfo(HexString = true)]
        public ulong offerId = 0;

        public DateTime birthdate;

        [WireInfo(Min = 1, Max = XOn.MAX_EMAIL_SIZE * XOn.UTF8_MULT)]
        public ushort emailLength;

        [WireInfo(SizeParam = "emailLength")]
        public string email;

        [WireInfo(Min = 1, Max = XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public int parentalControlGroupId = 0;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public WholesaleInfoData wholesaleInfo;

        public ushort reservedBytesLength = 0;

        [WireInfo(SizeParam = "reservedBytesLength")]
        public byte[] reservedBytes;

        [WireInfo(Serialize = false)]
        public string countryCode;

        [WireInfo(MinSchemaVersion = "6.1")]
        public byte msftOptIn;

        [WireInfo(MinSchemaVersion = "6.1")]
        public byte partnerOptIn;

        public override string Xrl
        {
            get { return "/xuacs/CreateWholesaleAccount.ashx"; }
        }

        // ICreateWholesaleAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get { return phoneInfo; }
        }
        public AddressInfoData AddressInfo
        {
            get { return addressInfo; }
        }
        public byte PaymentInstrumentType
        {
            get { return paymentInstrumentType; }
        }
        public CreditCardInfoData CreditCardInfo
        {
            get { return new CreditCardInfoData(); }
        }
        public DirectDebitInfoData DirectDebitInfo
        {
            get { return new DirectDebitInfoData(); }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return wholesaleInfo; }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return xonline.common.utilities.CountryDictionary.CountryCode(countryId); }
        }
        public DateTime BirthDate
        {
            get { return birthdate; }
        }
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }
        public byte MsftOptIn
        {
            get { return msftOptIn; }
        }
        public byte PartnerOptIn
        {
            get { return partnerOptIn; }
        }
    }

    public class CreateWholesaleAccountResponse : CreateUserResponse
    {
        [WireInfo(ArraySize = (int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xboxKey;

        [WireInfo(ArraySize = (int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;
    }


    public class GetPaymentInstrumentsRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public ushort maxResults;

        [WireInfo(MinSchemaVersion="5.4")]
        public bool includePayPalPayin = false;

        [WireInfo(MinSchemaVersion="5.4")]
        public bool includeExpiredCreditCards = true;

        [WireInfo(MinSchemaVersion="7.1")]
        public bool includeInicisPayin = false;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetPaymentInstruments.ashx"; }
        }
    }

    public class PaymentInstrumentInfo : XRLObject2
    {
        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        public byte paymentInstrumentType = 0;

        public byte creditCardType = 0;

        public ushort accountNumberLastFourLength = 0;

        [WireInfo(SizeParam="accountNumberLastFourLength")]
        public string accountNumberLastFour;
    }

    public class PaymentInstrumentInfoEx : XRLObject2
    {
        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        public byte paymentInstrumentType = 0;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        [WireInfo(MinSchemaVersion = "3.3")]
        public WholesaleInfoData wholesaleInfo;

        [WireInfo(MinSchemaVersion = "5.4")]
        public PayPalPayinInfoData paypalPayinInfo;

        [WireInfo( MinSchemaVersion = "7.1" )]
        public InicisPayinInfoData inicisPayinInfo;
    }

    public class GetPaymentInstrumentsResponse : XRLObject2
    {
        public ushort count;

        [WireInfo(SizeParam="count")]
        public PaymentInstrumentInfoEx[] paymentInstrumentInfo;
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class CreateXboxComAccountRequest : XRLObject2, ITrustedCreateAccountRequest
    {
        [WireInfo(Min=1, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=1, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString=true)]
        public ulong userPassportPuid = 0;

        [WireInfo(HexString=true)]
        public ulong ownerPassportPuid = 0;

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte parentalControlGroupId = 0;

        public byte msftOptIn;

        public byte partnerOptIn;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        [WireInfo(Serialize=false)]
        public string countryCode;

        public override string Xrl
        {
            get { return "/xuacs/XeCreateXboxComAccount.ashx"; }
        }

        // ICreateAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get { return phoneInfo; }
        }
        public AddressInfoData AddressInfo
        {
            get { return addressInfo; }
        }
        public byte PaymentInstrumentType
        {
            get { return paymentInstrumentType; }
        }
        public CreditCardInfoData CreditCardInfo
        {
            get { return creditCardInfo; }
        }
        public DirectDebitInfoData DirectDebitInfo
        {
            get { return directDebitInfo; }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return new WholesaleInfoData(); }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return xonline.common.utilities.CountryDictionary.CountryCode(countryId); }
        }
        public DateTime BirthDate
        {
            get { return birthdate; }
        }
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }
        public ulong UserPassportPuid
        {
            get { return userPassportPuid; }
        }
        public ulong OwnerPassportPuid
        {
            get { return ownerPassportPuid; }
        }
        public byte MsftOptIn
        {
            get { return msftOptIn; }
        }
        public byte PartnerOptIn
        {
            get { return partnerOptIn; }
        }
    }

    public class CreateXboxComAccountResponse : CreateUserResponse
    {
    }

    [WireDataEncryption(AsOfSchemaVersion = "6.1")]
    public class CreateWindowsMobileAccountRequest : XRLObject2, ITrustedCreateAccountRequest
    {
        [WireInfo(Min = 1, Max = XOn.MAX_FIRSTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam = "firstNameLength")]
        public string firstName = "";

        [WireInfo(Min = 1, Max = XOn.MAX_LASTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam = "lastNameLength")]
        public string lastName = "";

        [WireInfo(Min = 1, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam = "gamertagLength")]
        public string gamertag = "";

        [WireInfo(HexString = true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString = true)]
        public ulong userPassportPuid = 0;

        [WireInfo(HexString = true)]
        public ulong ownerPassportPuid = 0;

        public DateTime birthdate;

        public ushort emailLength = 0;

        [WireInfo(SizeParam = "emailLength")]
        public string email = "";

        [WireInfo(Min = 1, Max = XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte parentalControlGroupId = 0;

        public byte msftOptIn;

        public byte partnerOptIn;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        [WireInfo(Serialize = false)]
        public string countryCode;

        // ICreateAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get { return phoneInfo; }
        }
        public AddressInfoData AddressInfo
        {
            get { return addressInfo; }
        }
        public byte PaymentInstrumentType
        {
            get { return paymentInstrumentType; }
        }
        public CreditCardInfoData CreditCardInfo
        {
            get { return creditCardInfo; }
        }
        public DirectDebitInfoData DirectDebitInfo
        {
            get { return directDebitInfo; }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return new WholesaleInfoData(); }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return xonline.common.utilities.CountryDictionary.CountryCode(countryId); }
        }
        public DateTime BirthDate
        {
            get { return birthdate; }
        }
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }
        public ulong UserPassportPuid
        {
            get { return userPassportPuid; }
        }
        public ulong OwnerPassportPuid
        {
            get { return ownerPassportPuid; }
        }
        public byte MsftOptIn
        {
            get { return msftOptIn; }
        }
        public byte PartnerOptIn
        {
            get { return partnerOptIn; }
        }
        public int ParentalControlGroupId
        {
            get { return parentalControlGroupId; }
        }
    }

    public class CreateWindowsMobileAccountResponse : CreateUserResponse
    {
    }

    public class GenerateGamertagRequest : XRLObject2
    {
        [WireInfo(Min = 0, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort seedLength = 0;

        [WireInfo(SizeParam = "seedLength")]
        public string seed;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public int gamertagSuggestionType;

        public byte countryId = 103;

        public override string Xrl
        {
            get { return "/xuacs/GenerateGamertag.ashx"; }
        }
    }

    public class GenerateGamertagResponse : XRLObject2
    {
        [WireInfo(Min = 1, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam = "gamertagLength")]
        public string gamertag = "";
    }

    public class PassportGetUserDataRequest : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] sessionToken;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetUserData.ashx"; }
        }
    }

    public class PassportGetUserDataResponse : XRLObject2
    {
        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public DateTime birthdate;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte countryId;

        [WireInfo(Min=0, Max=XOn.MAX_EMAIL_SIZE*XOn.UTF8_MULT)]
        public ushort emailLength = 0;

        [WireInfo(SizeParam="emailLength")]
        public string email;
    }

    public class XePassportGetMemberNameRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetMemberName.ashx"; }
        }
    }

    public class XePassportGetMemberNameResponse : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort userPmnLength = 0;

        [WireInfo(SizeParam="userPmnLength")]
        public string userPmn;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort parentPmnLength = 0;

        [WireInfo(SizeParam="parentPmnLength")]
        public string parentPmn;

        [WireInfo(Min=0, Max=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN, MinSchemaVersion="3.1")]
        public ushort cidLength = 0;

        [WireInfo(SizeParam="cidLength", MinSchemaVersion="3.1")]
        public string userCid;
    }

    public class XePassportGetFriendMemberNameRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;


        [WireInfo(HexString=true)]
        public ulong friendPuid;


        public override string Xrl
        {
            get { return "/xuacs/XePassportGetFriendMemberName.ashx"; }
        }
    }

    public class XePassportGetFriendMemberNameResponse : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort friendPmnLength = 0;

        [WireInfo(SizeParam="friendPmnLength")]
        public string friendPmn;
    }

    public class XePassportGetBuddyGamertagRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort buddyPmnLength = 0;

        [WireInfo(SizeParam="buddyPmnLength")]
        public string buddyPmn;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetBuddyGamertag.ashx"; }
        }
    }

    public class XePassportGetBuddyGamertagResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong buddyPuid;

        [WireInfo(Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort buddyGamertagLength = 0;

        [WireInfo(SizeParam="buddyGamertagLength")]
        public string buddyGamertag;
    }

    public class XeABCHGetContactlistGamertagsRequest : XRLObject2WithFlags
    {
        static ushort QueryAtSignupForUsersInABCHandXBL         = 0x0001;
        static ushort QueryAtLoginForUsersInABCHandXBL          = 0x0002;

        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ushort requestFlags;

        public override string Xrl
        {
            get { return "/xuacs/XeABCHGetContactlistGamertags.ashx"; }
        }

        public bool queryAtSignupForUsersInABCHandXBL
        {
            get
            {
                return IsFlagSet(QueryAtSignupForUsersInABCHandXBL, requestFlags);
            }
            set
            {
                SetFlag(QueryAtSignupForUsersInABCHandXBL, value, ref requestFlags);
            }
        }

        public bool queryAtLoginForUsersInABCHandXBL
        {
            get
            {
                return IsFlagSet(QueryAtLoginForUsersInABCHandXBL, requestFlags);
            }
            set
            {
                SetFlag(QueryAtLoginForUsersInABCHandXBL, value, ref requestFlags);
            }
        }
    }

    public class XeABCHGetContactlistGamertagsResponse : XRLObject2
    {
        public ushort ABCHGetContactlistItemCount;

        [WireInfo(SizeParam="ABCHGetContactlistItemCount")]
        public ABCHGetContactlistItem [] items;
    }

    public class ABCHGetContactlistItem : XRLObject2WithFlags
    {
        static ushort UserInABCH            = 0x0001;
        static ushort UserInXBL             = 0x0002;

        public ABCHGetContactlistItem()
        {
            responseFlags = 0;
        }

        [WireInfo(HexString=true)]
        public ulong puid;

        [WireInfo(Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort pmnLength = 0;

        [WireInfo(SizeParam="pmnLength")]
        public string pmn;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort displayNameLength = 0;

        [WireInfo(SizeParam="displayNameLength")]
        public string displayName;

        public ushort responseFlags;

        public bool userInABCH
        {
            get
            {
                return IsFlagSet(UserInABCH, responseFlags);
            }
            set
            {
                SetFlag(UserInABCH, value, ref responseFlags);
            }
        }

        public bool userInXBL
        {
            get
            {
                return IsFlagSet(UserInXBL, responseFlags);
            }
            set
            {
                SetFlag(UserInXBL, value, ref responseFlags);
            }
        }
    }

    public class XeUserGetAgeRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid;

        [WireInfo(HexString = true)]
        public ulong machinePuid;

        [WireInfo(HexString = true)]
        public uint titleId;

        public override string Xrl
        {
            get { return "/xuacs/XeUserGetAge.ashx"; }
        }
    }

    public class XeUserGetAgeResponse : XRLObject2
    {
        public byte userAge;
    }

    public class XeUserGetAgeGroupRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid;

        [WireInfo(HexString = true)]
        public ulong machinePuid;

        [WireInfo(HexString = true)]
        public uint titleId;

        public override string Xrl
        {
            get { return "/xuacs/XeUserGetAgeGroup.ashx"; }
        }
    }

    public class XeUserGetAgeGroupResponse : XRLObject2
    {
        public uint userAgeGroup;
    }

    public class XeUpsGetProfileRequest : XRLObject2
    {
        public ulong  puid;

        public ushort attributesLength = 0;

        [WireInfo(SizeParam="attributesLength")]
        public string attributes;

        public override string Xrl
        {
            get { return "/xuacs/XeUpsGetProfile.ashx"; }
        }
    }

    public class XeUpsGetProfileResponse : XRLObject2
    {
        public ushort profileLength = 0;

        [WireInfo(SizeParam="profileLength")]
        public string profile;
    }

    public class XeUpsUpdateProfileRequest : XRLObject2
    {
        public ushort profileLength = 0;

        [WireInfo(SizeParam="profileLength")]
        public string profile;

        public override string Xrl
        {
            get { return "/xuacs/XeUpsUpdateProfile.ashx"; }
        }
    }

    public class ReadProfileSettingsRequest : XRLObject2
    {
        public override string Xrl
        {
            get { return "/xuacs/XeReadProfileSettings.ashx"; }
        }
    }

    public class ReadProfileSettingsResponse : XRLObject2
    {
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class AddPaymentInstrumentRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        public override string Xrl
        {
            get { return "/xuacs/XeAddPaymentInstrument.ashx"; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class AddPaymentInstrumentRequestEx : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid;

        [WireInfo(HexString = true)]
        public ulong machinePuid;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoDataEx creditCardInfo;

        public DirectDebitInfoDataEx directDebitInfo;

        public override string Xrl
        {
            get { return "/xuacs/XeAddPaymentInstrumentEx.ashx"; }
        }
    }

    public class AddPaymentInstrumentResponse : XRLObject2
    {
        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;
    }

    public class RemovePaymentInstrumentRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        public override string Xrl
        {
            get { return "/xuacs/XeRemovePaymentInstrument.ashx"; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class UpdatePaymentInstrumentRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        public override string Xrl
        {
            get { return "/xuacs/XeUpdatePaymentInstrument.ashx"; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class UpdatePaymentInstrumentRequestEx : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid;

        [WireInfo(HexString = true)]
        public ulong machinePuid;

        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam = "paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public CreditCardInfoDataEx creditCardInfo;

        public DirectDebitInfoDataEx directDebitInfo;

        public override string Xrl
        {
            get { return "/xuacs/XeUpdatePaymentInstrumentEx.ashx"; }
        }
    }

    public class GetUserInfoRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        public override string Xrl
        {
            get { return "/xuacs/XeGetUserInfo.ashx"; }
        }
    }

    public class GetUserInfoResponse : XRLObject2
    {
        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public AddressInfoData addressInfo;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte msftOptIn;

        public byte partnerOptIn;

        public byte age;
    }

    public class GetLinkedGamertagRequest : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        public override string Xrl
        {
            get { return "/xuacs/XeGetLinkedGamertag.ashx"; }
        }
    }

    public class GetLinkedGamertagResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class LinkXbox1AccountRequest : XRLObject2, IRecoveryRequest
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId = 0;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOwnerPassportPuid;

        public PhoneInfoData phoneInfo;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;


        // IRecoveryRequest properties
        public string PostalCode
        {
            get { return postalCode; }
        }
        public string PhonePrefix
        {
            get { return phoneInfo == null ? "" : phoneInfo.phonePrefix; }
        }
        public string PhoneNumber
        {
            get { return phoneInfo == null ? "" : phoneInfo.phoneNumber; }
        }
        public string PhoneExtension
        {
            get { return phoneInfo == null ? "" : phoneInfo.phoneExtension; }
        }
        public string CardHolder
        {
            get { return cardHolder; }
        }
        public string CardNumber
        {
            get { return cardNumber; }
        }

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeLinkXbox1Account.ashx"; }
        }
    }

    public class XePassportGetEncryptedProxyParametersRequest : XRLObject2
    {
        [WireInfo(MinSchemaVersion="3.0")]
        public int serviceId = 0;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetEncryptedProxyParameters.ashx"; }
        }
    }

    public class XePassportGetEncryptedProxyParametersResponse : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_LOGIN_TOKEN_REQUEST_MAX_LEN)]
        public ushort loginTokenRequestLength = 0;

        [WireInfo(SizeParam="loginTokenRequestLength")]
        public string loginTokenRequest;

        public uint publicKeyPublicExponent;

        [WireInfo(Min=XOn.XONLINE_PASSPORT_PUBLIC_KEY_MODULUS_MAX_LEN, Max=XOn.XONLINE_PASSPORT_PUBLIC_KEY_MODULUS_MAX_LEN)]
        public ushort publicKeyModulusLength;

        [WireInfo(SizeParam="publicKeyModulusLength")]
        public byte[] publicKeyModulus;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_PUBLIC_KEY_DIGEST_LEN)]
        public byte[] publicKeyDigest;
    }

    public class XePassportCreateRequest : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort passportMemberNameLength = 0;

        [WireInfo(SizeParam="passportMemberNameLength")]
        public string passportMemberName;

        [WireInfo(Min=XOn.XONLINE_PASSPORT_SECRET_QUESTION_MIN_LEN, Max=XOn.XONLINE_PASSPORT_SECRET_QUESTION_MAX_LEN)]
        public ushort secretQuestionLength = 0;

        [WireInfo(SizeParam="secretQuestionLength")]
        public string secretQuestion;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_ENCRYPTED_PASSWORD_MAX_LEN)]
        public ushort encryptedPasswordLength = 0;

        [WireInfo(SizeParam="encryptedPasswordLength")]
        public byte[] encryptedPassword;

        [WireInfo(MinSchemaVersion = "4.0")]
        public byte countryId = 0;

        [WireInfo(MinSchemaVersion = "4.0")]
        public DateTime birthdate = DateTime.FromFileTimeUtc(0);

        // Max = 1 specifies that the data is optional, no other way to declare that in wiredata
        [WireInfo(MinSchemaVersion = "7.1", Max = 1)]
        public ushort accountProofLength;

        [WireInfo(MinSchemaVersion = "7.1", SizeParam = "accountProofLength")]
        public ProofData[] accountProof;

        public override string Xrl
        {
            get { return "/xuacs/XePassportCreate.ashx"; }
        }
    }

    public class GetDependentSignedPuidRequest : XRLObject2
    {
        public PassportToken ownerSessionToken;

        public Puid targetXuid;

        public override string Xrl
        {
            get { return "/xuacs/GetDependentSignedPuid.ashx"; }
        }
    }

    public class GetDependentSignedPuidResponse : XRLObject2
    {
        public PassportToken sessionToken;
    }

    public class XePassportCreateResponse : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] sessionToken;
    }

    public class XePassportLoginRequest : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort passportMemberNameLength = 0;

        [WireInfo(SizeParam="passportMemberNameLength")]
        public string passportMemberName;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_ENCRYPTED_SESSION_KEY_MAX_LEN)]
        public ushort encryptedSessionKeyLength = 0;

        [WireInfo(SizeParam="encryptedSessionKeyLength")]
        public byte[] encryptedSessionKey;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_ENCRYPTED_PASSWORD_MAX_LEN)]
        public ushort encryptedPasswordLength = 0;

        [WireInfo(SizeParam="encryptedPasswordLength")]
        public byte[] encryptedPassword;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_LOGIN_TOKEN_REQUEST_MAX_LEN)]
        public ushort encryptedTokenRequestLength = 0;

        [WireInfo(SizeParam="encryptedTokenRequestLength")]
        public byte[] encryptedTokenRequest;

        [WireInfo(MinSchemaVersion="3.0")]
        public int serviceId = 0;

        public override string Xrl
        {
            get { return "/xuacs/XePassportLogin.ashx"; }
        }
    }

    public class XePassportLoginResponse : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] sessionToken;

        [WireInfo(Min=XOn.XONLINE_PASSPORT_LOGIN_NONCE_MIN_LEN, Max=XOn.XONLINE_PASSPORT_LOGIN_NONCE_MAX_LEN, MinSchemaVersion="3.0")]
        public ushort nonceLength;

        [WireInfo(SizeParam="nonceLength", MinSchemaVersion="3.0")]
        public byte[] nonce;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_LOGIN_CIPHER_VALUE_MAX_LEN, MinSchemaVersion="3.0")]
        public ushort cipherValueLength;

        [WireInfo(SizeParam="cipherValueLength", MinSchemaVersion="3.0")]
        public byte[] cipherValue;
    }

    public class XePassportChangePasswordRequest : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] sessionToken;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort passportMemberNameLength = 0;

        [WireInfo(SizeParam="passportMemberNameLength")]
        public string passportMemberName;

        public ushort encryptedPasswordLength = 0;

        [WireInfo(SizeParam="encryptedPasswordLength")]
        public byte[] encryptedPassword;

        public override string Xrl
        {
            get { return "/xuacs/XePassportChangePassword.ashx"; }
        }
    }

    public class XePassportGetSecretQuestionsRequest : XRLObject2
    {
        public ushort countryId;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetSecretQuestions.ashx"; }
        }
    }

    public class PassportSecretQuestion : XRLObject2
    {
        [WireInfo(Min=XOn.XONLINE_PASSPORT_SECRET_QUESTION_MIN_LEN, Max=XOn.XONLINE_PASSPORT_SECRET_QUESTION_MAX_LEN)]
        public ushort secretQuestionLength;

        [WireInfo(SizeParam="secretQuestionLength")]
        public string secretQuestion;
    }

    public class XePassportGetSecretQuestionsResponse : XRLObject2
    {
        [WireInfo(Min=1, Max=XOn.XONLINE_PASSPORT_SECRET_QUESTION_MAX_COUNT)]
        public ushort secretQuestionsCount;

        [WireInfo(SizeParam="secretQuestionsCount")]
        public PassportSecretQuestion[] secretQuestions;
    }

    public class XeRecoverAccountRequest : XRLObject2
    {
        [WireInfo(MinSchemaVersion = "6.1")]
        public byte visitorSigninAccountFlag;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPuid;

        public override string Xrl
        {
            get { return "/xuacs/XeRecoverAccount.ashx"; }
        }
    }

    public class XeRecoverAccountResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong offlineXuid;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] key;

        [WireInfo(Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Max=XOn.XONLINE_USERDOMAIN_SIZE)]
        public ushort domainLength;

        [WireInfo(SizeParam="domainLength")]
        public string domain;

        [WireInfo(Max=XOn.XONLINE_REALM_NAME_SIZE)]
        public ushort realmLength;

        [WireInfo(SizeParam="realmLength")]
        public string realm;
    }

    public class MigrateXbox1UserRequest : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedParentPassportPuid;

        [WireInfo(HexString=true)]
        public ulong offlineXuid;

        public ushort userPassportMemberNameLength;

        [WireInfo(SizeParam="userPassportMemberNameLength")]
        public string userPassportMemberName;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public ushort reservedBytesLength = 0;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;

        public override string Xrl
        {
            get { return "/xuacs/XeMigrateXbox1User.ashx"; }
        }
    }

    public class MigrateXbox1UserResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;

        [WireInfo(Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public ushort domainLength;
        [WireInfo(SizeParam="domainLength", Max=XOn.XONLINE_USERDOMAIN_SIZE)]
        public string domain;

        public ushort realmLength;
        [WireInfo(SizeParam="realmLength", Max=XOn.XONLINE_REALM_NAME_SIZE)]
        public string realm;

        public int parentalControlGroupId;

        public int cultureId;
    }

    public class XeSetAccountInfoRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong  userPuid;

        [WireInfo(HexString=true)]
        public ulong  machinePuid;

        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte msftOptIn;

        public byte partnerOptIn;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeSetAccountInfo.ashx"; }
        }
    }

    public class XeGetAccountInfoRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong  userPuid;

        [WireInfo(HexString=true)]
        public ulong  machinePuid;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetAccountInfo.ashx"; }
        }
    }

    public class XeGetAccountInfoResponse : XRLObject2
    {
        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte msftOptIn;

        public byte partnerOptIn;

        [WireInfo(MinSchemaVersion = "3.2")]
        public byte isLightweight;
    }

    public class XeUserGetAccountInfoRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public Puid userPuid;

        [WireInfo(HexString=true)]
        public Puid machinePuid;

        [WireInfo(HexString=true)]
        public TitleId titleId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeUserGetAccountInfo.ashx"; }
        }
    }

    public class XeUserGetAccountInfoResponse : XRLObject2
    {
        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public AddressInfoData addressInfo;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte age;
    }


    public class GetUserTenureRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public Puid    userPuid;

        [WireInfo(HexString=true)]
        public TitleId titleId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/GetUserTenure.ashx"; }
        }
    }

    public class GetUserTenureResponse : XRLObject2
    {
        public int      tenureLevel;

        public int      tenureMilestone;

        public DateTime nextMilestoneDate;
    }

    public class XeGetAccountInfoFromPassportRequest : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        [WireInfo(HexString=true)]
        public ulong  machinePuid;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetAccountInfoFromPassport.ashx"; }
        }
    }

    public class XeGetUserTypeRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetUserType.ashx"; }
        }
    }

    public class XeGetUserTypeResponse : XRLObject2
    {
        public byte userType;

        // the UserType property is a value within the range of the UserTypeEnum
        public byte UserType
        {
            get { return (byte)(userType & 0x7f); }
        }

        // the HasGamerProfile property is true if the high bit is set
        public bool HasGamerProfile
        {
            get { return (userType & 0x80) == 0x80; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class MigrateXboxComUserRequest : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        [WireInfo(HexString=true)]
        public ulong offlineXuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public byte countryId;

        public ushort languageId;

        [WireInfo(HexString=true)]
        public ulong offerId = 0;

        public ushort billingTokenLength = 0;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken = "";

        [WireInfo(Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        [WireInfo(Serialize=false)]
        public string countryCode;

        public override string Xrl
        {
            get { return "/xuacs/XeMigrateXboxComUser.ashx"; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class MigrateXboxComUserRequestEx : XRLObject2
    {
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        [WireInfo(HexString = true)]
        public ulong offlineXuid;

        [WireInfo(HexString = true)]
        public uint titleId;

        [WireInfo(HexString = true)]
        public ulong machinePuid;

        public byte countryId;

        public ushort languageId;

        [WireInfo(HexString = true)]
        public ulong offerId = 0;

        public ushort billingTokenLength = 0;

        [WireInfo(SizeParam = "billingTokenLength")]
        public string billingToken = "";

        [WireInfo(Max = XOn.MAX_FIRSTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam = "firstNameLength")]
        public string firstName;

        [WireInfo(Max = XOn.MAX_LASTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam = "lastNameLength")]
        public string lastName;

        public ushort emailLength;

        [WireInfo(SizeParam = "emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoDataEx creditCardInfo;

        public DirectDebitInfoDataEx directDebitInfo;

        [WireInfo(Serialize = false)]
        public string countryCode;

        public override string Xrl
        {
            get { return "/xuacs/XeMigrateXboxComUserEx.ashx"; }
        }
    }

    public class MigrateXboxComUserResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;

        [WireInfo(Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public ushort domainLength;
        [WireInfo(SizeParam="domainLength", Max=XOn.XONLINE_USERDOMAIN_SIZE)]
        public string domain;

        public ushort realmLength;
        [WireInfo(SizeParam="realmLength", Max=XOn.XONLINE_REALM_NAME_SIZE)]
        public string realm;

        public int parentalControlGroupId;

        public int cultureId;
    }

    public class ChangeSubscriptionPaymentInstrumentRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public ushort serviceInstanceIdLength = 0;

        [WireInfo(SizeParam="serviceInstanceIdLength")]
        public string serviceInstanceId;

        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeChangeSubscriptionPaymentInstrument.ashx"; }
        }
    }

    public class VerifyBillingInfoRequest : XRLObject2, IRecoveryRequest
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_PREFIX_SIZE)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_NUMBER_SIZE)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;


        // IRecoveryRequest properties
        public string PostalCode
        {
            get { return postalCode; }
        }
        public string PhonePrefix
        {
            get { return phonePrefix; }
        }
        public string PhoneNumber
        {
            get { return phoneNumber; }
        }
        public string PhoneExtension
        {
            get { return phoneExtension; }
        }
        public string CardHolder
        {
            get { return cardHolder; }
        }
        public string CardNumber
        {
            get { return cardNumber; }
        }

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeVerifyBillingInfo.ashx"; }
        }
    }

    public class VerifyBillingInfoResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte msftOptIn;

        public byte partnerOptIn;
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class VerifyParentCreditCardRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString=true)]
        public uint titleId = 0;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedParentPassportPuid;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort parentPassportMemberNameLength = 0;

        [WireInfo(SizeParam="parentPassportMemberNameLength")]
        public string parentPassportMemberName;

        [WireInfo(Min=0, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        [WireInfo(Min=1, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName = "";

        [WireInfo(Min=1, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName = "";

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public CreditCardInfoData creditCardInfo;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeVerifyParentCreditCard.ashx"; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class VerifyParentCreditCardRequestEx : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString = true)]
        public uint titleId = 0;

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedParentPassportPuid;

        [WireInfo(Max = XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort parentPassportMemberNameLength = 0;

        [WireInfo(SizeParam = "parentPassportMemberNameLength")]
        public string parentPassportMemberName;

        [WireInfo(Min = 0, Max = XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        [WireInfo(Min = 1, Max = XOn.MAX_FIRSTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam = "firstNameLength")]
        public string firstName = "";

        [WireInfo(Min = 1, Max = XOn.MAX_LASTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam = "lastNameLength")]
        public string lastName = "";

        public ushort emailLength;

        [WireInfo(SizeParam = "emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public CreditCardInfoDataEx creditCardInfo;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeVerifyParentCreditCardEx.ashx"; }
        }
    }

    public class XeGetUserWebInfoRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public uint serviceType = (uint) ServiceTypeEnum.XboxLive;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetUserWebInfo.ashx"; }
        }
    }

    public class XeGetUserWebInfoResponse : XRLObject2
    {
        [WireInfo(Serialize=false)]
        public static DateTime dummyMinDate = new DateTime(1900, 1, 1);

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[] userPrivileges;

        public uint tier;

        public DateTime lastWebActivity;

        public int parentalControlGroupId;

        [WireInfo(MinSchemaVersion="2.0")]
        public byte userType;

        [WireInfo(MinSchemaVersion="4.0")]
        public bool billingUnavailable;

        [WireInfo(MinSchemaVersion="4.0")]
        public bool isLightweight;

        [WireInfo(MinSchemaVersion="5.5")]
        public ushort billingAccountIdLength;

        [WireInfo(MinSchemaVersion="5.5", SizeParam="billingAccountIdLength")]
        public string billingAccountId;

        [WireInfo(MinSchemaVersion="6.1")]
        public bool isFreeGamertagChangeEligible;

        [WireInfo(MinSchemaVersion="6.6")]
        public DateTime lastMigratedDate;   

        [WireInfo(MinSchemaVersion="6.6")]
        public DateTime migrationEligibilityDate;    

        [WireInfo(MinSchemaVersion="6.6")]
        public bool isMigrationEligible;    

        [WireInfo(MinSchemaVersion="6.8")]
        public bool isParentallyControlled;    

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( dummyMinDate == lastWebActivity )
            {
                lastWebActivity = DateTime.FromFileTimeUtc(0);
            }

            if( dummyMinDate == lastMigratedDate)
            {
                lastMigratedDate = DateTime.FromFileTimeUtc(0);
            }

            if( dummyMinDate == migrationEligibilityDate)
            {
                migrationEligibilityDate = DateTime.FromFileTimeUtc(0);
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            if( DateTime.MinValue == lastWebActivity )
            {
                lastWebActivity = dummyMinDate;
            }

            if( DateTime.MinValue == lastMigratedDate)
            {
                lastMigratedDate= dummyMinDate;
            }

            if( DateTime.MinValue == migrationEligibilityDate)
            {
                migrationEligibilityDate = dummyMinDate;
            }

            base.WriteStream( binaryWriter );
        }
    }

    public class XeUpdateXboxComActivityRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public uint serviceType = (uint) ServiceTypeEnum.XboxLive;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeUpdateXboxComActivity.ashx"; }
        }
    }

    public class XeReserveGamertagRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public byte countryId;

        [WireInfo(Max=64)]
        public ushort maxSuggestedNames;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength  = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public override string Xrl
        {
            get { return "/xuacs/XeReserveGamertag.ashx"; }
        }
    }

    public class XeReserveGamertagSuggestedName : XRLObject2
    {
        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort nameLength;

        [WireInfo(SizeParam="nameLength")]
        public string name;
    }

    public class XeReserveGamertagResponse : XRLObject2
    {
        public HResult hr;

        [WireInfo(Max=64)]
        public ushort nameCount;

        [WireInfo(SizeParam="nameCount")]
        public XeReserveGamertagSuggestedName[] names;
    }

    public class XeGetGamertagSuggestionsRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong machinePuid;

        public byte countryId;

        [WireInfo(Max = 64)]
        public ushort maxSuggestedNames;

        [WireInfo(Min = 0, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort seedLength = 0;

        [WireInfo(SizeParam = "seedLength")]
        public string seed;

        public override string Xrl
        {
            get { return "/xuacs/XeGetGamertagSuggestions.ashx"; }
        }
    }

    public class XeGetGamertagSuggestionsSuggestedName : WireData
    {
        [WireInfo(Min = 1, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort nameLength;

        [WireInfo(SizeParam = "nameLength")]
        public string name;
    }

    public class XeGetGamertagSuggestionsResponse : XRLObject2
    {
        [WireInfo(Max = 64)]
        public ushort nameCount;

        [WireInfo(SizeParam = "nameCount")]
        public XeGetGamertagSuggestionsSuggestedName[] names;
    }

    public class XeTroubleshootAccountRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(Max=1024)]
        public ushort reservedBytesLength;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;

        public override string Xrl
        {
            get { return "/xuacs/XeTroubleshootAccount.ashx"; }
        }
    }

    public class XeTroubleshootAccountResponse : XRLObject2
    {
        public int newTOS;

        public int nameChangeRequired;

        public int downgraded;

        public DateTime suspendedUntil = DateTime.UtcNow;

        public ushort totalDaysSuspended;

        public DateTime voiceBannedUntil = DateTime.UtcNow;

        public ushort totalDaysVoiceBanned;

        public HResult billingHR;

        [WireInfo(MinSchemaVersion = "5.1")]
        public int userPassportInvalid;

        [WireInfo(MinSchemaVersion = "5.1")]
        public int ownerPassportInvalid;

        [WireInfo(MinSchemaVersion = "9.0")]
        public int gamertagRecycled;

        [WireInfo(Max=1024)]
        public ushort reservedBytesLength;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;
    }

    public class XeAcknowledgeDowngradeRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userId;

        public override string Xrl
        {
            get { return "/xuacs/XeAcknowledgeDowngrade.ashx"; }
        }
    }

    public class XeAccountQueryRequest : XRLObject2
    {
        public uint requestType;

        [WireInfo(Max=2048)]
        public ushort requestBytesLength;

        [WireInfo(SizeParam="requestBytesLength")]
        public byte[] requestBytes;

        public override string Xrl
        {
            get { return "/xuacs/XeAccountQuery.ashx"; }
        }
    }

    public class XeAccountQueryResponse : XRLObject2
    {
        [WireInfo(Max=2048)]
        public ushort responseBytesLength;

        [WireInfo(SizeParam="responseBytesLength")]
        public byte[] responseBytes;
    }

    public class DisableSubscriptionRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ushort serviceInstanceIdLength = 0;

        [WireInfo(SizeParam="serviceInstanceIdLength")]
        public string serviceInstanceId;

        public int subscriptionStatusId;

        public bool addViolation;

        public override string Xrl
        {
            get { return "/xuacs/DisableSubscription.ashx"; }
        }
    }

    public class GetNoAgeOutRequest : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        public override string Xrl
        {
            get { return "/xuacs/GetNoAgeOut.ashx"; }
        }
    }

    public class GetNoAgeOutResponse : XRLObject2
    {
        public bool noAgeOut;
    }

    public class ArgoAuthenticateAccountResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong offerId;

        public int subscriptionStatusId;

        public DateTime purchaseDate;

        public DateTime endDate;

        public bool hasViolations;

        [WireInfo(HexString=true)]
        public ulong renewalOfferId;

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH*4)]
        public byte[] userPrivileges;

        [WireInfo(Min=0, Max=32)]
        public ushort clientDataLength;

        [WireInfo(SizeParam="clientDataLength")]
        public byte[] clientData;
    }

    public class ArgoAuthenticateAccountRequest : XRLObject2
    {
        public ushort passportTicketLength = 0;

        [WireInfo(SizeParam="passportTicketLength")]
        public string passportTicket;

        public override string Xrl
        {
            get { return "/xuacs/ArgoAuthenticateAccount.ashx"; }
        }
    }

    public class ArgoGetAccountStatusResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public uint userBillingAccountStatus;

        [WireInfo(HexString=true)]
        public ulong offerId = 0;

        public ushort serviceInstanceIdLength = 0;

        [WireInfo(SizeParam="serviceInstanceIdLength")]
        public string serviceInstanceId;

        public int subscriptionStatusId;

        public DateTime purchaseDate;

        public DateTime endDate;

        public bool hasViolations;

        [WireInfo(HexString=true)]
        public ulong renewalOfferId = 0;
    }

    public class ArgoGetAccountStatusRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public override string Xrl
        {
            get { return "/xuacs/ArgoGetAccountStatus.ashx"; }
        }
    }

    public class ArgoTestCreateAccountResponse : XRLObject2
    {
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(HexString=true)]
        public ulong xboxLivePuid;

        [WireInfo(HexString=true)]
        public ulong passportPuid;

        public ushort passportMemberNameLength;

        [WireInfo(SizeParam="passportMemberNameLength")]
        public string passportMemberName;

        public ushort passportPasswordLength;

        [WireInfo(SizeParam="passportPasswordLength")]
        public string passportPassword;

        public uint pointsBalance;
    }

    public class ArgoTestCreateAccountRequest : XRLObject2
    {
        public bool addPoints;

        public bool addSubscription;

        public override string Xrl
        {
            get { return "/xuacs/ArgoTestCreateAccount.ashx"; }
        }
    }

    public class ArgoTestCreateAccountExRequest : XRLObject2
    {
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public byte countryId;

        public bool isChildAccount;

        public bool hasPurchaseContentPrivilege;

        public bool hasExplicitContentPrivilege;

        public bool addPoints;

        public bool addSubscription;

        public override string Xrl
        {
            get { return "/xuacs/ArgoTestCreateAccount.ashx"; }
        }
    }

    public class ArgoSignInSubscriptionInfo : XRLObject2
    {
        public ulong offerId;

        public ushort billingInstanceIdLength;

        [WireInfo(SizeParam="billingInstanceIdLength")]
        public string billingInstanceId;

        public ushort subscriptionStatusLength;

        [WireInfo(SizeParam="subscriptionStatusLength")]
        public string subscriptionStatus;

        public bool hasViolations;

        public bool hasPendingCancel;

        public ushort musicNetSkuLength;

        [WireInfo(SizeParam="musicNetSkuLength")]
        public string musicNetSku;

        public DateTime startDate;

        public DateTime endDate;
    }

    public class ArgoSignInResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public bool nameChangeRequired;

        public bool acceptedTermsOfService;

        public bool accountSuspended;

        public bool subscriptionLapsed;

        public bool billingUnavailable;

        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public byte countryId;

        public ushort geoCountryCodeLength;

        [WireInfo(SizeParam="geoCountryCodeLength")]
        public string geoCountryCode;

        public bool parentallyControlled;

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH*4)]
        public byte[] userPrivileges;

        public uint pointsBalance;

        public ArgoSignInSubscriptionInfo subInfo;
    }

    public class ArgoSignInRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ushort clientVersionLength = 0;

        [WireInfo(SizeParam="clientVersionLength")]
        public string clientVersion;

        public override string Xrl
        {
            get { return "/xuacs/ArgoSignIn.ashx"; }
        }
    }

    public class AcceptTermsOfServiceRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid = 0;

        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        public uint titleId = 0;

        public uint serviceType = 0;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/AcceptTermsOfService.ashx"; }
        }
    }

    public class SwitchUserPassportRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid = 0;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOldUserPassportPuid;

        public ushort oldUserPassportMemberNameLength;

        [WireInfo(SizeParam="oldUserPassportMemberNameLength")]
        public string oldUserPassportMemberName;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedNewUserPassportPuid;

        public ushort newUserPassportMemberNameLength;

        [WireInfo(SizeParam="newUserPassportMemberNameLength")]
        public string newUserPassportMemberName;

        public bool transferBalance;

        public ushort reservedBytesLength = 0;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;

        public override string Xrl
        {
            get { return "/xuacs/XeSwitchUserPassport.ashx"; }
        }
    }

    public class XeReplaceOwnerPassportRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid = 0;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedNewOwnerPassportPuid;

        public override string Xrl
        {
            get { return "/xuacs/XeReplaceOwnerPassport.ashx"; }
        }
    }

    public class SwitchOwnerPassportRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public Puid userPuid;

        [WireInfo(HexString = true)]
        public Puid machinePuid;

        [WireInfo(HexString = true)]
        public uint titleId;

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOldOwnerPassportPuid;

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedNewOwnerPassportPuid;

        public override string Xrl
        {
            get { return "/xuacs/SwitchOwnerPassport.ashx"; }
        }
    }

    public class SwitchUserCountryRequest : XRLObject2
    {
        public Guid trackingGuid;

        [WireInfo(HexString = true)]
        public Puid userPuid;

        public AddressInfoData addressInfo;

        public byte countryId;

        public int cultureId;

        public override string Xrl
        {
            get { return "/xuacs/SwitchUserCountry.ashx"; }
        }
    }

    public class SwitchUserDateOfBirthRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public Puid userPuid;

        public DateTime newDateOfBirth;

        public override string Xrl
        {
            get { return "/xuacs/SwitchUserDateOfBirth.ashx"; }
        }
    }

    public class XeReplaceUserPassportRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid = 0;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedNewUserPassportPuid;

        public ushort newUserPassportMemberNameLength;

        [WireInfo(SizeParam="newUserPassportMemberNameLength")]
        public string newUserPassportMemberName;

        public bool transferBalance;

        public override string Xrl
        {
            get { return "/xuacs/XeReplaceUserPassport.ashx"; }
        }
    }

    public class XePassportGetPuidFromMemberNameRequest : XRLObject2
    {
        public ushort memberNameLength;

        [WireInfo(SizeParam="memberNameLength")]
        public string memberName;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetPuidFromMemberName.ashx"; }
        }
    }

    public class XePassportGetPuidFromMemberNameResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong passportPuid;
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class GraduateUserRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString = true)]
        public ulong userPuid;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class GraduateUserRequestEx : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString = true)]
        public ulong userPuid;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoDataEx creditCardInfo;

        public DirectDebitInfoDataEx directDebitInfo;
    }

    [WireDataEncryption(AsOfSchemaVersion="6.2")]
    public class CreateUserRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString=true)]
        public ulong offlineXuid = 0;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag = "";

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOwnerPassportPuid;

        public DateTime birthdate;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public bool msftOptIn;

        public bool partnerOptIn;
    }

    [WireDataEncryption(AsOfSchemaVersion = "6.8")]
    public class CreateBulkUserRequest : CreateUserRequest
    {
        public ushort emailLength;

        [WireInfo(SizeParam = "emailLength")]
        public string email;

        public bool isFreeGamertagChangeEligible = false;

        public override string Xrl
        {
            get { return "/xuacs/CreateBulkUser.ashx"; }
        }
    }

    public class CreateBulkUserResponse : CreateUserResponse
    {
        [WireInfo(ArraySize = (int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;
    }

    [WireDataEncryption(AsOfSchemaVersion="6.2")]
    public class CreateUserAndBillableAccountRequest : CreateUserRequest
    {
        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public bool isFreeGamertagChangeEligible = false;

        [WireInfo(MinSchemaVersion = "6.7")]
        public ushort notificationFlags = 0;

        public override string Xrl
        {
            get { return "/xuacs/CreateUserAndBillableAccount.ashx"; }
        }
    }

    public class CreateUserAndBillableAccountResponse : CreateUserResponse
    {
        [WireInfo(ArraySize = (int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;
    }

    [WireDataEncryption(AsOfSchemaVersion="6.2")]
    public class PassportCreateGeneratedRequest : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_ENCRYPTED_SESSION_KEY_MAX_LEN)]
        public ushort sessionKeyLength = 0;

        [WireInfo(SizeParam="sessionKeyLength")]
        public byte[] sessionKey;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_ENCRYPTED_SESSION_KEY_MAX_LEN)]
        public ushort sessionIVLength = 0;

        [WireInfo(SizeParam="sessionIVLength")]
        public byte[] sessionIV;

        [WireInfo(HexString = true)]
        public Puid machinePuid = 0;

        [WireInfo(Min=0, Max=XOn.XONLINE_NAME_MAX_SIZE, MinSchemaVersion = "6.7")]
        public ushort seedLength = 0;

        [WireInfo(SizeParam="seedLength", MinSchemaVersion = "6.7")]
        public string seed = "";

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN, MinSchemaVersion="6.7")]
        public ushort ownerPassportMemberNameLength = 0;

        [WireInfo(SizeParam="ownerPassportMemberNameLength", MinSchemaVersion="6.7")]
        public string ownerPassportMemberName;

        public DateTime birthdate;

        public byte countryId;

        public override string Xrl
        {
            get { return "/xuacs/PassportCreateGenerated.ashx"; }
        }
    }

    public class PassportCreateGeneratedResponse : XRLObject2
    {
        [WireInfo(Min = 1, Max = XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort memberNameLength = 0;

        [WireInfo(SizeParam = "memberNameLength")]
        public string memberName = "";

        [WireInfo(Max=XOn.XONLINE_PASSPORT_ENCRYPTED_PASSWORD_MAX_LEN)]
        public ushort encryptedPasswordLength = 0;

        [WireInfo(SizeParam="encryptedPasswordLength")]
        public byte[] encryptedPassword;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] sessionToken;
    }


    public class XeGetPassportCredentialListByNameRequest : XRLObject2
    {
        public ushort memberNameLength;

        [WireInfo(SizeParam="memberNameLength")]
        public string memberName;
    
        public override string Xrl
        {
            get { return "/xuacs/XeGetPassportCredentialListByName.ashx"; }
        }
    }



    public class XeGetPassportCredentialListByNameResponse : XRLObject2
    {
        public ushort passportCredentialCount;
    
        [WireInfo(SizeParam="passportCredentialCount")]
        public PassportCredentialInfoData [] credentials;                    

    }

    public class GetKeyRequest : XRLObject2
    {
        public ushort keyId = 0;

        public override string Xrl
        {
            get { return "/xuacs/GetKey.ashx"; }
        }
    }

    public class GetKeyResponse : XRLObject2
    {
        public ushort publicKeyLength = 0;

        [WireInfo(SizeParam = "publicKeyLength")]
        public string publicKey;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\LiveInfo.cs ===
/*
 * Copyright (c) 2008 Microsoft Corporation
 *
 * protocol\LiveInfo.cs
 *
 * Protocol Definition for LiveInfo
 *
 */

using xonline.common.service;
using System;

namespace xonline.common.protocol
{
    // GetLiveConfigRequest
    // GetLiveConfig request packet
    public class GetLiveConfigRequest : XRLObject2
    {
        [WireInfoAttribute(Min=1, Max=XOn.XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH)]
        public ushort confignameLen;

        [WireInfoAttribute(SizeParam="confignameLen", Min=1, Max=XOn.XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH)]
        public string configname;

        public override string Xrl
        {
            get { return "/liveinfo/getliveconfig.ashx"; }
        }
    }

    // GetLiveConfigResponse
    public class GetLiveConfigResponse: XRLObject2
    {
        public const int CONFIG_BLOCK_MAX_COUNT = 10;

        [WireInfo(Max=CONFIG_BLOCK_MAX_COUNT * XeGenericBlock.BLOCK_MAX_LEN)]
        public uint configLen;

        [WireInfo(Max=CONFIG_BLOCK_MAX_COUNT)]
        public ushort configBlockCount;

        [WireInfo(SizeParam="configBlockCount")]
        public XeGenericBlock[] configBlocks;

        [WireInfo(Serialize=false)]
        public string config;
    }

    // GetLiveConfigIntRequest
    // This is a request to get the live config for an internal call, where we're not coming
    // from a user or have SG Info.  This is used by the liveinfoclient class for the cross
    // datacenter call.
    public class GetLiveConfigIntRequest : XRLObject2
    {
        [WireInfoAttribute(Min=1, Max=XOn.XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH)]
        public ushort confignameLen;

        [WireInfoAttribute(SizeParam="confignameLen", Min=1, Max=XOn.XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH)]
        public string configname;

        public override string Xrl
        {
            get { return "/liveinfo/getliveconfigint.ashx"; }
        }
    }

    // GetLiveConfigResponse
    public class GetLiveConfigIntResponse : XRLObject2
    {
        public uint settingCount;

        [WireInfo(SizeParam="settingCount")]
        public LiveConfigSetting[] settings;
    }

    public class LiveConfigSetting : WireData
    {
        [WireInfoAttribute(Min=1, Max=XOn.XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH)]
        public ushort confignameLen;

        [WireInfoAttribute(SizeParam="confignameLen", Min=1, Max=XOn.XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH)]
        public string configname;

        [WireInfoAttribute(Min=1)]
        public ushort nameLen;

        [WireInfoAttribute(SizeParam="nameLen")]
        public string name;

        public ushort valueLen;

        [WireInfoAttribute(SizeParam="valueLen")]
        public string value;
    }

    // GetNetworkAuthorizationListRequest
    // GetNetworkAuthorizationList request packet
    public class GetNetworkAuthorizationListRequest : XRLObject2
    {
        public override string Xrl
        {
            get { return "/liveinfo/getnetworkauthorizationlist.ashx"; }
        }
    }

    public class NetworkAuthorizationListItem : WireData
    {
        public ushort protocol;

        public ushort port; // can be 0, optional.

        public ushort serverLen;

        [WireInfoAttribute(SizeParam="serverLen")]
        public string server;

        // Path is optional.  Could just be a hostname or IP address.
        public ushort pathLen;

        [WireInfoAttribute(SizeParam="pathLen")]
        public string path;

        // IP Address range.  Optional.  0 if not used.
        // If it's one address, from = to.  If multiple, it's all the addresses
        // in between.
        public uint fromIP;

        public uint toIP;

        // Applies To is optional.
        public ushort appliesToLen;

        [WireInfoAttribute(SizeParam="appliesToLen")]
        public string appliesTo; // URI that it applies to?

    }

    // GetNetworkAuthorizationListResponse
    public class GetNetworkAuthorizationListResponse: XRLObject2
    {
        public ushort authorizationListCount;

        [WireInfo(SizeParam="authorizationListCount")]
        public NetworkAuthorizationListItem[] authorizationList;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\lspprot.cs ===
//
// lspprot.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Lsp protocol
//
    
using System;
using xonline.common.service;

namespace xonline.common.protocol 
{
    public class LspProtocolConstants
    {
        public const uint XONLINE_LSP_MAX_USER_DATA_LEN         = 200;
        public const uint XONLINE_LSP_MAX_LSP_INFO              = 1000;
        public const uint XONLINE_LSP_XNKID_LEN                 = 8;
        public const uint XONLINE_LSP_XNKEY_LEN                 = 16;
        public const uint XONLINE_LSP_MAX_EXPIRATION_SECONDS    = 100000;
        public const uint XONLINE_LSP_DEFAULT_DATASET           = 0xAAAA;
        public const uint XONLINE_LSP_ATTR_TSADDR               = 0x80200001;
        public const uint XONLINE_LSP_ATTR_XNKID                = 0x80200002;
        public const uint XONLINE_LSP_ATTR_KEK                  = 0x80200003;
        public const uint XONLINE_LSP_ATTR_USER                 = 0x80100004;
        public const uint XONLINE_LSP_ATTR_PARAM_USER           = 0x02100004;
    }

    public class LspAdvertiseRequest : XRLObject2
    {
        // Advertise to this titleId
        [WireInfo(Min=1, Max=UInt32.MaxValue)]
        public UInt32       titleId;
        
        // You can find me at this IP (Network byte order)
        [WireInfo(Min=1, Max=UInt32.MaxValue)]
        public UInt32       ipSgLsp;
        
        // Expire after this many seconds
        [WireInfo(Min=10, Max=LspProtocolConstants.XONLINE_LSP_MAX_EXPIRATION_SECONDS)]
        public UInt32       ttlInSeconds;

        // Reserved. Zero for now.
        [WireInfo(Min=0, Max=UInt32.MaxValue)]
        public UInt32       flags;

        // XNKID for backwards compatibility with old clients
        [WireInfo(ArraySize=(int)LspProtocolConstants.XONLINE_LSP_XNKID_LEN)]
        public byte[]       xnkid;

        // XNKEY for backwards compatibility with old clients
        [WireInfo(ArraySize=(int)LspProtocolConstants.XONLINE_LSP_XNKEY_LEN)]
        public byte[]       xnkey;

        // Length in bytes for user data (it's UTF8 encoded)
        [WireInfo(Min=0, Max=LspProtocolConstants.XONLINE_LSP_MAX_USER_DATA_LEN)]
        public ushort       userDataLength;

        // User data.
        [WireInfo(SizeParam="userDataLength")]
        public string       userData;

        public override string Xrl
        {
            get { return "/lsp/advertise.ashx"; }
        }
    }

    public class LspEnumerateRequest : XRLObject2
    {
        // Title-id
        [WireInfo(Min=1, Max=UInt32.MaxValue)]
        public UInt32       titleId;
        
        // Length of user data
        [WireInfo(Min=0, Max=LspProtocolConstants.XONLINE_LSP_MAX_USER_DATA_LEN)]
        public UInt16       userDataLength;

        // If specified (not empty, userDataLength > 0), only entries with 
        // matching userData will be enumerated. If not specified 
        // (userDataLength == 0), all entries will be enumerated
        [WireInfo(SizeParam="userDataLength")]
        public string       userData;

        // Return 'resultCount' results starting at 'resultIndex'. Zero is the 
        // first entry. One is the second and so on...
        [WireInfo(Min=0, Max=UInt32.MaxValue)]
        public UInt32       resultIndex;

        // Maximum number of results to be returned
        [WireInfo(Min=1, Max=LspProtocolConstants.XONLINE_LSP_MAX_LSP_INFO)]
        public UInt32       resultCount;

        public override string Xrl
        {
            get { return "/lsp/enumerate.ashx"; }
        }
    }

    public class LspEnumerateReply : WireData
    {
        // Number of LspInfos returned in 'lspInfo'
        [WireInfo(Min=0, Max=LspProtocolConstants.XONLINE_LSP_MAX_LSP_INFO)]
        public UInt32       lspInfoCount;
        
        // Array with information on Lsp Servers
        [WireInfo(SizeParam="lspInfoCount")]
        public LspEnumerateServerInfo[] lspInfo;
    }

    public class LspEnumerateServerInfo : WireData
    {
        // Ip of the SGLSP (Network byte order)
        [WireInfo(Min=1, Max=UInt32.MaxValue)]
        public UInt32       ipSgLsp;

        // Reserved. Zero for now.
        public UInt32       flags;

        // Length of user data
        [WireInfo(Min=0, Max=LspProtocolConstants.XONLINE_LSP_MAX_USER_DATA_LEN)]
        public UInt32       userDataLength;

        // User data - the same user data that the server passed in 
        // LspAdvertiseRequest
        [WireInfo(SizeParam="userDataLength")]
        public string       userData;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\PathInfo.cs ===
using System;
using System.Text.RegularExpressions;

using xonline.common.service;
using xonline.common.mgmt;


// trace area for PathInfo code
[assembly: XomAreaDefinition(XomAreaName.pathTrace)]

namespace xonline.common.protocol 
{
    public class PathInfo
    {
        public string _ipAddress;
        public string _domainQualifiers;
        public StorageDomain _domain;
        public IdType _keyType;
        public ulong  _keyValue;
        public string _pathName;
        public string _unparsedPathName;
        public string _partitionInfo;
        
        // Parse
        // Parse pathname info into its distinct components
        public static PathInfo Parse(string name)
        {
            // don't bother with null or empty strings
            if ( name == null || name == "" )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_163,
                    "PathInfo.Parse: null or empty pathName");
            }
            
            Match pathMatch = _filePathRegex.Match(name);
            
            if ( pathMatch.Success )
            {
                string value;

                PathInfo pi = new PathInfo();

                pi._ipAddress = pathMatch.Groups["ipaddr"].Value.ToLower();
                Xom.Trace(XomAreaName.pathTrace, LogLevel.L_LOW, "PathInfo._ipAddress: " + pi._ipAddress);

                value = pathMatch.Groups["domain"].Value.ToLower();
                try
                {
                    pi._domain = StorageDomainList.GetDomain(value);
                }
                catch (Exception e)
                {
                    XRLException se = e as XRLException;
                    if ( se == null )
                    {
                        se = new XRLException(
                            HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_164,
                            "Parse: invalid domain; found: " + value,
                            e);
                    }
                    if ( se != e )
                    {
                        throw se;
                    }
                    else
                    {
                        throw;
                    }
                }
                Xom.Trace(XomAreaName.pathTrace, LogLevel.L_LOW, "PathInfo._domain: " + pi._domain._name);

                pi._domainQualifiers = pathMatch.Groups["qualifiers"].Value.ToLower();
                Xom.Trace(XomAreaName.pathTrace, LogLevel.L_LOW, "PathInfo._domainQualifiers: " + pi._domainQualifiers);

                value = pathMatch.Groups["keytype"].Value.ToLower();
                pi._keyType = GetKeyType(value);

                Xom.Trace(XomAreaName.pathTrace, LogLevel.L_LOW, String.Format("PathInfo._keyType: {0} ({1})", value, pi._keyType));
                
                if ( pi._keyType == IdType.Undefined )  
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_165, 
                            "PathInfo.Parse: key type: " + value + 
                            " is not a valid identifier type.");
                }
                

                try
                {
                    pi._keyValue = Convert.ToUInt64(pathMatch.Groups["keyval"].Value.ToLower(), 16);
                    Xom.Trace(XomAreaName.pathTrace, LogLevel.L_LOW, "PathInfo._keyValue: " + pi._keyValue);
                }
                catch (Exception e)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_166, 
                            "PathInfo.Parse: key value: " + pathMatch.Groups["keyval"].Value.ToLower() + 
                            " is not a valid hex key value (caught exception: " + e + 
                            ").");
                }

                pi._pathName = pathMatch.Groups["path"].Value;
                Xom.Trace(XomAreaName.pathTrace, LogLevel.L_LOW, "PathInfo._pathName: " + pi._pathName);
                
                pi._unparsedPathName = name;

                // expose just the partition portion of the path component
                pi._partitionInfo =
                    "/" + pi._ipAddress +
                    "/" + pi._domain._name + pi._domainQualifiers +
                    "/" + pathMatch.Groups["keytype"].Value.ToLower() + ":" + pathMatch.Groups["keyval"].Value.ToLower();

                return pi;
            }
            else
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_167,
                    "PathInfo.Parse: malformed pathName: " + name);
            }
        }

        private static IdType GetKeyType(string value)
        {
            IdType id;
            switch ( value )
            {
                case "u":
                    id = IdType.UserId;
                    break;
                case "t":
                    id = IdType.TitleId;
                    break;
                default:
                    id = IdType.Undefined;
                    break;
            }

            return id;
        }

        public void Validate()
        {
            Validate(true);
        }
    
        public void Validate(bool checkPathRegex)
        {
            if ( ( _domain._name.Length + _domainQualifiers.Length ) > ProtocolConstants.maxSizeDomain )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_168,
                    "Validate: domain component too large: " + _domain._name + _domainQualifiers);
            }
            
            if ( _keyType >= IdType.Invalid )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_169,
                    "Validate: invalid key type: " + _keyType);
            }
            
            if ( _pathName == null || _pathName.Length == 0 )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_170,
                    "Validate: invalid empty pathName: " + _pathName);
            }

            // the following checks are applied the to last portion of the path, since
            // the xbox client code will use that in a Win32 CreateFile call

            int lastSlash = _pathName.LastIndexOf('/');
            string fileNameLower = _pathName.Substring(lastSlash + 1).ToLower();

            // these characters are not allowed anywhere in a filename
            char [] invalidCharacters = { '<', '>', ':', '"', '\\', '|' };
            if ( fileNameLower.LastIndexOfAny(invalidCharacters) != -1)
                throw new XRLException(HResult.XONLINE_E_STORAGE_INVALID_STORAGE_PATH, XEvent.Id.COMMON_CODE_171,
                    "Validate: invalid character in pathName: " + _pathName);

            // these are device names and cannot be used as a filename
            string [] invalidFileNames = {
                "con", "prn", "aux", "clock$", "nul", "com1", "com2", "com3", "com4", "com5", "com6", 
                "com7", "com8", "com9", "lpt1", "lpt2", "lpt3", "lpt4", "lpt5", "lpt6", "lpt7", "lpt8", "lpt9"
            };
            for (int i = 0; i < invalidFileNames.Length; i++)
            {
                if ( string.CompareOrdinal(fileNameLower, invalidFileNames[i]) == 0)
                    throw new XRLException(HResult.XONLINE_E_STORAGE_INVALID_STORAGE_PATH, XEvent.Id.COMMON_CODE_172,
                        "Validate: invalid pathName, contains a reserved file name: " + _pathName);
            }
            
            if ( checkPathRegex && _domain.Policy.PathValidationRegex != null )
            {
                Match m = _domain.Policy.PathValidationRegex.Match( _pathName );
                if ( !m.Success )
                {
                    throw new XRLException(
                        HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_173,
                        "Validate: invalid nonconforming pathName: " + _pathName);
                }
            }
        }
    
        public void Validate(IStorageRequest req, bool checkPathRegex)
        {
            Validate(checkPathRegex);
        }

        public void Validate(IStorageRequest req)
        {
            Validate(true);
        }

        public string IpAddress
        {
            get { return _ipAddress; }
        }
    
        public string DomainQualifiers
        {
            get { return _domainQualifiers; }
        }
    
        public StorageDomain Domain
        {
            get { return _domain; }
        }

        public IdType KeyType
        {
            get { return _keyType; }
        }
    
        public ulong KeyValue
        {
            get { return _keyValue; }
        }
    
        public string PathName
        {
            get { return _pathName; }
        }

        public string UnparsedPathName
        {
            get { return _unparsedPathName; }
        }

        public string PartitionInfo
        {
            get { return _partitionInfo; }
        }
    
        // regular expression to parse filepaths
        // [^\p{Cc}] means any character not in the Unicode Control category
        //    so embedded nul characters and other control characters are not
        //    allowed
        private const string filePathRegexSpec =
                @"^/(?<ipaddr>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})?" // optional IP address
            +   @"/(?<domain>\w+)"                                  // storage domain
            +   @"(?<qualifiers>(?:\.\w+)*)"                        // optional domain qualifiers
            +   @"/(?:"
            +        @"(?<keytype>[u]):(?<keyval>[0-9a-z]{1,16})|"  // key type and key value
            +        @"(?<keytype>[t]):(?<keyval>[0-9a-f]{1,8})"    // key type and key value
            +   @")"
            +   @"(?<path>/[^\p{Cc}]+)$";                           // pathname (with leading /)
            
        private static Regex _filePathRegex = new Regex(filePathRegexSpec, RegexOptions.IgnoreCase|RegexOptions.Compiled);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\messageprot.cs ===
// 
// MessageProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Messaging Service Integration
// Xbox Online Service
// 
// Author: phansen, masonb
//

using System;
using System.IO;
using xonline.common.service;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.MessageProxy)]


namespace xonline.common.protocol 
{    
    //
    // Messaging definitions
    //
    public class MsgDefs
    {
        public const uint XONLINE_MAX_TRANSIENT_MESSAGES              = 25;
        public const uint XONLINE_MAX_PERSISTENT_MESSAGES             = 100;
        public const uint XONLINE_MAX_NUM_MESSAGES                    = (XONLINE_MAX_TRANSIENT_MESSAGES + XONLINE_MAX_PERSISTENT_MESSAGES);
        public const uint XONLINE_MAX_MESSAGE_RECIPIENTS              = 100;
        public const uint XONLINE_MAX_MESSAGE_DETAILS                 = 4096;
        public const uint XONLINE_MAX_SYSTEM_MSGS                     = 100; // max that QMSG_ENUM_SYSTEM_MESSAGES will return

        //
        // Message Flags
        //
        public const uint XONLINE_MSG_FLAG_REQUIRED                   = 0x00000001; // The user is required to read this message
        public const uint XONLINE_MSG_FLAG_RECOMMENDED                = 0x00000002; // The user has a system recommended message
        public const uint XONLINE_MSG_FLAG_HAS_VOICE                  = 0x00000004; // This message contains a voice attachment
        public const uint XONLINE_MSG_FLAG_HAS_TEXT                   = 0x00000008; // This message contains a text body
        public const uint XONLINE_MSG_FLAG_READ                       = 0x00000010; // This message has been read
        public const uint XONLINE_MSG_FLAG_NON_EXPORTABLE             = 0x00000020; // This message should only be displayed on Xbox consoles, not the web
        public const uint XONLINE_MSG_FLAG_TEAM_CONTEXT               = 0x00000040; // This message's sender context refers to a team ID
        public const uint XONLINE_MSG_FLAG_COMP_CONTEXT               = 0x00000080; // This message's sender context refers to a competition event ID
        public const uint XONLINE_MSG_FLAG_ALTERNATE_TITLE            = 0x00000100; // This message is from an alternate Title of the currently logged on title (only available on Xbox consoles)
        public const uint XONLINE_MSG_FLAG_MARKETING                  = 0x00000200; // Used on title-wide messages to indicate the message is marketing related and opt-in settings should be checked
        public const uint XONLINE_MSG_FLAG_MS_MARKETING               = 0x00000400; // Used on title-wide messages to indicate the message is Microsoft marketing related and ms opt-in settings should be checked
        public const uint XONLINE_MSG_FLAG_HAS_PHOTO                  = 0x00000800; // This message has a photo attachment
        public const uint XONLINE_MSG_FLAG_XENON_COMPATIBLE           = 0x00001000; // This message is xenon only
        public const uint XONLINE_MSG_FLAGS_TITLE_RESERVED            = 0xFF000000; // Flags reserved for title custom messages
        public const uint XONLINE_MSG_FLAG_SENDER_IS_FRIEND           = 0x00800000; // Used by Notification to detect invites that should go to V1 clients
        public const uint XONLINE_MSG_FLAG_RECV_DETAILS_NEEDED        = 0x00200000; // Used by the client on received summaries to indicate that the title has requested downloading details
        public const uint XONLINE_MSG_FLAG_SEND_MSG_OWNED             = 0x00200000; // Used by the client on message sends to indicate that the message handle is owned by the Send operation
        public const uint XONLINE_MSG_FLAGS_RESERVED                  = 0x005FF000; // Flags reserved for future use
        public const uint XONLINE_MSG_FLAGS_VALID_SEND_MASK           = ( XONLINE_MSG_FLAGS_TITLE_RESERVED | 
                                                                          XONLINE_MSG_FLAG_NON_EXPORTABLE |
                                                                          XONLINE_MSG_FLAG_REQUIRED |
                                                                          XONLINE_MSG_FLAG_RECOMMENDED |
                                                                          XONLINE_MSG_FLAG_HAS_VOICE |
                                                                          XONLINE_MSG_FLAG_HAS_TEXT |
                                                                          XONLINE_MSG_FLAG_TEAM_CONTEXT |
                                                                          XONLINE_MSG_FLAG_COMP_CONTEXT |
                                                                          XONLINE_MSG_FLAG_MARKETING |
                                                                          XONLINE_MSG_FLAG_MS_MARKETING |
                                                                          XONLINE_MSG_FLAG_HAS_PHOTO | 
                                                                          XONLINE_MSG_FLAG_XENON_COMPATIBLE); // Flags valid in a call to send a message
        public const uint XONLINE_MSG_FLAGS_TITLE_SETABLE             = ( XONLINE_MSG_FLAG_READ |
                                                                          XONLINE_MSG_FLAGS_TITLE_RESERVED ); // Flags a title is allowed to set on an already sent message
        public const uint XONLINE_MSG_FLAGS_TITLE_CLEARABLE           = ( XONLINE_MSG_FLAGS_TITLE_RESERVED ); // Flags a title is allowed to clear on an already sent message

        //
        // Message Property Types
        //
        public const byte XONLINE_MSG_PROP_TYPE_NULL                  = 1;   // The property contains no data
        public 