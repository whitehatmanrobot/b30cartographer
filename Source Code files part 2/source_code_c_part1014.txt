 tuple code-
      off the pc-card. If the end of chain is reached on the
      current tuple chain, any links are followed to obtain
      the next tuple.

Arguments:

   TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

   STATUS_SUCCESS if tuple was retrieved
   STATUS_NO_MORE_ENTRIES - if no tuples were found

--*/
{

   NTSTATUS status;

   if (!NT_SUCCESS((status = NextTupleInChain(TuplePacket)))) {
      /* End of this CIS. Follow a link if it exists */
      if (status == STATUS_DEVICE_NOT_READY) {
         return status;
      }
      if ((status = FollowLink(TuplePacket)) != STATUS_SUCCESS) {
         return status;
      }
   }
   TuplePacket->TupleCode = GetCISChar(TuplePacket, 0);
   TuplePacket->TupleLink = GetCISChar(TuplePacket, 1);
   return (ProcessLinkTuple(TuplePacket));
}



NTSTATUS
FollowLink(
   IN PTUPLE_PACKET TuplePacket
   )
/*++

Routine Description:

   Called when the end of tuple chain is encountered:
   this follows links, if any are present

Arguments:

   TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

   STATUS_SUCCESS if a link is present
   STATUS_NO_MORE_ENTRIES - if not

--*/
{
   if (NextLink(TuplePacket) == STATUS_SUCCESS) {
      return STATUS_SUCCESS;
   }

   // There is no implied or explicit link to follow.  If an indirect link
   // has been specified, indirect attribute memory is processed with an
   // implied link to common memory.

   if ((TuplePacket->Flags & TPLF_IND_LINK) && !(TuplePacket->Flags & TPLF_INDIRECT)) {

       // Link to indirect attribute memory at offset 0.

       TuplePacket->Flags &= ~(TPLF_COMMON | TPLF_IND_LINK | TPLF_LINK_MASK);
       TuplePacket->Flags |= TPLF_INDIRECT;
       TuplePacket->CISOffset = 0;

       if (CheckLinkTarget(TuplePacket)) {
           return STATUS_SUCCESS;
       }
       return(NextLink(TuplePacket));
   }
   return STATUS_NO_MORE_ENTRIES;
}


BOOLEAN
CheckLinkTarget(
   IN PTUPLE_PACKET TuplePacket
   )
/*++

Routine Description:

   Ensures that the target of a link has the signature
   'CIS' which indicates it is a valid target,
   as documented in the PC-Card standard

Arguments:

   TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

   STATUS_SUCCESS           if valid target
   STATUS_NO_MORE_ENTRIES - if not

--*/
{
   return (GetCISChar(TuplePacket, 0) == CISTPL_LINKTARGET &&
           GetCISChar(TuplePacket, 1) >= 3 &&
           GetCISChar(TuplePacket, 2) == 'C' &&
           GetCISChar(TuplePacket, 3) == 'I' &&
           GetCISChar(TuplePacket, 4) == 'S');

}


NTSTATUS
NextLink(
   IN PTUPLE_PACKET TuplePacket
   )
/*++

Routine Description:

      Fetches the next link off the pc-card tuple chain
      if any are present

Arguments:

   TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

   STATUS_SUCCESS if a link was present
   STATUS_NO_MORE_ENTRIES - if no links

--*/
{
   switch (TuplePacket->Flags & TPLF_LINK_MASK) {
   case TPLF_IMPLIED_LINK:
   case TPLF_LINK_TO_C:  {
         TuplePacket->Flags |= TPLF_COMMON;
         TuplePacket->CISOffset = TuplePacket->LinkOffset;
         break;
      }
   case TPLF_LINK_TO_A:{
         TuplePacket->Flags &= ~TPLF_COMMON;
         TuplePacket->CISOffset = TuplePacket->LinkOffset;
         break;
      }
   case TPLF_LINK_TO_CB: {
         //
         // Needs work! We have to switch to the appropriate
         // address space (BARs/Expansion Rom/Config space)
         // depending on the link offset
         //
         TuplePacket->Flags &= ~TPLF_ASI;
         TuplePacket->Flags |= (TuplePacket->LinkOffset & 7) << TPLF_ASI_SHIFT;
         TuplePacket->CISOffset = TuplePacket->LinkOffset & ~7 ;
         break;
      }
   case TPLF_NO_LINK:
      default: {
         return STATUS_NO_MORE_ENTRIES;
      }

   }
   // Validate the link target
   if (!CheckLinkTarget (TuplePacket)) {
      if (TuplePacket->Flags & (TPLF_COMMON | TPLF_INDIRECT)) {
          return(STATUS_NO_MORE_ENTRIES);
      }

      // The R2 PCMCIA spec was not clear on how the link off
      // memory was defined.  As a result the offset is often
      // by 2 as defined in the later specs.  Therefore if th
      // not found at the proper offset, the offset is divide
      // proper link target is checked for at that offset.

      TuplePacket->CISOffset >>= 1;       // Divide by 2
      if (!CheckLinkTarget(TuplePacket)) {
          return(STATUS_NO_MORE_ENTRIES);
      }
      return STATUS_NO_MORE_ENTRIES;
   }

   TuplePacket->Flags &= ~TPLF_LINK_MASK;
   return STATUS_SUCCESS;
}


NTSTATUS
ProcessLinkTuple(
   IN PTUPLE_PACKET TuplePacket
   )
/*++

Routine Description:

  Processes an encountered link while traversing the tuple chain
  by storing it for future use - when the link has to be followed
  after end of chain is encountered

Arguments:

   TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

   STATUS_SUCCESS

--*/
{
   ULONG k;

   switch (TuplePacket->TupleCode) {
   case CISTPL_LONGLINK_CB: {
         // needs to be filled in
         if (TuplePacket->TupleLink < 4) {
            return (STATUS_NO_MORE_ENTRIES);
         }
         TuplePacket->Flags = (TuplePacket->Flags & ~TPLF_LINK_MASK) | TPLF_LINK_TO_CB;
         TuplePacket->LinkOffset =  GetCISChar(TuplePacket, TPLL_ADDR) +
                                    (GetCISChar(TuplePacket, TPLL_ADDR + 1)<<8) +
                                    (GetCISChar(TuplePacket, TPLL_ADDR + 2)<<16) +
                                    (GetCISChar(TuplePacket, TPLL_ADDR + 3)<<24);

         break;
      }

   case CISTPL_INDIRECT: {
         TuplePacket->Flags |= TPLF_IND_LINK;
         TuplePacket->LinkOffset = 0;     // Don't set link offset for indirect
         SetPdoFlag(TuplePacket->SocketData->PdoExtension, PCMCIA_PDO_INDIRECT_CIS);
        break;
      }

   case CISTPL_LONGLINK_A:
   case CISTPL_LONGLINK_C: {
         if (TuplePacket->TupleLink < 4) {
            return STATUS_NO_MORE_ENTRIES;
         }
         TuplePacket->Flags = ((TuplePacket->Flags & ~TPLF_LINK_MASK) |
                               (TuplePacket->TupleCode == CISTPL_LONGLINK_A ?
                                TPLF_LINK_TO_A: TPLF_LINK_TO_C));
         TuplePacket->LinkOffset =  GetCISChar(TuplePacket, TPLL_ADDR) +
                                    (GetCISChar(TuplePacket, TPLL_ADDR+1) << 8)  +
                                    (GetCISChar(TuplePacket, TPLL_ADDR+2) << 16) +
                                    (GetCISChar(TuplePacket, TPLL_ADDR+3) << 24) ;

         break;
      }
   case CISTPL_LONGLINK_MFC:{
         k = TPLMFC_NUM;
         TuplePacket->Socket->NumberOfFunctions = GetCISChar(TuplePacket, TPLMFC_NUM);

         if ((TuplePacket->TupleLink < (TuplePacket->Function*5 + 6)) ||
             (GetCISChar(TuplePacket, k) <= TuplePacket->Function)) {
            return STATUS_NO_MORE_ENTRIES;
         }
         k += TuplePacket->Function*5 + 1;
         TuplePacket->Flags = (TuplePacket->Flags & ~TPLF_LINK_MASK) |
                              (GetCISChar(TuplePacket, k) == 0?TPLF_LINK_TO_A:
                               TPLF_LINK_TO_C);
         k++;
         TuplePacket->LinkOffset =  GetCISChar(TuplePacket, k) +
                                    (GetCISChar(TuplePacket, k+1) << 8) +
                                    (GetCISChar(TuplePacket, k+2) << 16) +
                                    (GetCISChar(TuplePacket, k+3) << 24);
         break;
      }
   case CISTPL_NO_LINK:{
         TuplePacket->Flags = (TuplePacket->Flags & ~TPLF_LINK_MASK) | TPLF_NO_LINK;
         break;
      }
   }
   return STATUS_SUCCESS;
}



NTSTATUS
GetTupleData(
   IN PTUPLE_PACKET TuplePacket
   )
/*++

Routine Description:

   Retrieves the tuple body for the currently requested
   tuple.
   NOTE: This function assumes that the caller provided
   a big enough buffer in the TuplePacket to hold the tuple
   data. No attempt is made to trap exceptions etc.

Arguments:

   TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

   STATUS_SUCCESS if tuple data was retrieved
   STATUS_NO_MORE_ENTRIES - otherwise

--*/
{
   PUCHAR bufferPointer;
   USHORT xferLength;
   USHORT tupleOffset;

   TuplePacket->TupleDataIndex = 0;
   xferLength = TuplePacket->TupleDataLength = GetCISChar(TuplePacket, 1);
   if ((tupleOffset = TuplePacket->TupleOffset) > xferLength) {
      return STATUS_NO_MORE_ENTRIES;
   }
   xferLength = MIN((xferLength - tupleOffset), TuplePacket->TupleDataMaxLength);
   for (bufferPointer = TuplePacket->TupleData; xferLength;
       tupleOffset++, bufferPointer++, xferLength--) {
      *bufferPointer = GetCISChar(TuplePacket, tupleOffset + 2);
   }
   return STATUS_SUCCESS;
}


UCHAR
GetTupleChar(
   IN PTUPLE_PACKET TuplePacket
   )
/*++

Routine Description:

    Returns the next byte in the current set of tuple data.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    tuple data byte

--*/
{
   UCHAR tupleChar = 0;

   if (TuplePacket->TupleDataIndex < TuplePacket->TupleDataMaxLength) {
      tupleChar = TuplePacket->TupleData[TuplePacket->TupleDataIndex++];
   }
   return tupleChar;
}



/*------------- End of Tuple API -----------------------*/


USHORT
GetCRC(
   IN PSOCKET_DATA SocketData
   )

/*++

Routine Description:

    Using the same algorithm as Windows 95, calculate the CRC value
    to be appended with the manufacturer name and device name to
    obtain the unique identifier for the PCCARD.

Arguments:

    Socket         - Pointer to the socket which contains the device
    Function       - function number of device

Return Value:

    A USHORT CRC value.

--*/

{
   PSOCKET Socket = SocketData->Socket;
   TUPLE_PACKET tuplePacket;
   PUCHAR  tupleData;
   PUCHAR  cp;
   PUCHAR  cpEnd;
   PUCHAR  tplBuffer;
   NTSTATUS     status;
   USHORT  crc = 0;
   USHORT  index;
   USHORT  length;
   UCHAR   tupleCode;
   UCHAR   tmp;

   RtlZeroMemory(&tuplePacket, sizeof(TUPLE_PACKET));

   tuplePacket.DesiredTuple = 0xFF;
   tuplePacket.TupleData = ExAllocatePool(NonPagedPool, MAX_TUPLE_DATA_LENGTH);
   if (tuplePacket.TupleData == NULL) {
      return 0;
   }

   tuplePacket.Socket             = Socket;
   tuplePacket.SocketData         = SocketData;
   tuplePacket.TupleDataMaxLength = MAX_TUPLE_DATA_LENGTH;
   tuplePacket.TupleOffset        = 0;
   tuplePacket.Function           = SocketData->Function;

   try{

      status = GetFirstTuple(&tuplePacket);

      //
      // Calculate CRC
      //
      while (NT_SUCCESS(status)) {

         tupleCode = tuplePacket.TupleCode;

         for (index = 0; TplList[index] != CISTPL_END; index++) {

            if (tupleCode == TplList[index]) {

               status = GetTupleData(&tuplePacket);
               if (!NT_SUCCESS(status)) {
                  //
                  // Bail...
                  //
                  crc = 0;
                  leave;
               };
               tupleData = tuplePacket.TupleData;
               length = tuplePacket.TupleDataLength;

               //
               // This one is included in the CRC calculation
               //

               if (tupleCode == CISTPL_VERS_1) {
                  cp = tupleData + 2;
                  cpEnd = tupleData + MAX_TUPLE_DATA_LENGTH;

                  //
                  // Include all of the manufacturer name.
                  //

                  while ((cp < cpEnd) && *cp) {
                     cp++;
                  }

                  //
                  // Include the product string
                  //

                  cp++;
                  while ((cp < cpEnd) && *cp) {
                     cp++;
                  }
                  cp++;

                  length = (USHORT)(cp - tupleData);
               }

               if (length >= MAX_TUPLE_DATA_LENGTH) {
                  crc = 0;
                  leave;
               }

               for (cp = tupleData; length; length--, cp++) {

                  tmp = *cp ^ (UCHAR)crc;
                  crc = (crc >> 8) ^ crc16a[tmp & 0x0f] ^ crc16b[tmp >> 4];
               }
               break;
            }
         }
         status = GetNextTuple(&tuplePacket);
      }

   } finally {

      if (tuplePacket.TupleData) {
         ExFreePool(tuplePacket.TupleData);
      }
   }

   DebugPrint((PCMCIA_DEBUG_TUPLES, "Checksum=%x\n", crc));
   return crc;
}



NTSTATUS
PcmciaParseFunctionData(
   IN PSOCKET Socket,
   IN PSOCKET_DATA SocketData
   )
/*++

Routine Description

   Parses the tuple data for the supplied function
   (SocketPtr->Function)

Arguments:

   Socket         - Pointer to the socket which contains the device
   SocketData - Pointer to the socket data structure for the function
                which will be filled with the parsed information

Return Value:

   Status
--*/

{
   PCONFIG_ENTRY configEntry, prevEntry = NULL;
   TUPLE_PACKET  tuplePacket;
   NTSTATUS      status;

   if (SocketData->Function >= Socket->NumberOfFunctions) {
      return STATUS_NO_MORE_ENTRIES;
   }

   if (Is16BitCardInSocket(Socket)) {
      //
      // Get the CIS checksum
      //
      SocketData->CisCrc = GetCRC(SocketData);
   }

   RtlZeroMemory(&tuplePacket, sizeof(TUPLE_PACKET));

   tuplePacket.DesiredTuple = 0xFF;
   tuplePacket.TupleData = ExAllocatePool(PagedPool, MAX_TUPLE_DATA_LENGTH);
   if (tuplePacket.TupleData == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }
   tuplePacket.Socket             = Socket;
   tuplePacket.SocketData         = SocketData;
   tuplePacket.TupleDataMaxLength = MAX_TUPLE_DATA_LENGTH;
   tuplePacket.TupleOffset        = 0;
   tuplePacket.Function           = SocketData->Function;

   status = GetFirstTuple(&tuplePacket);

   if (!NT_SUCCESS(status) || (tuplePacket.TupleCode == CISTPL_END)) {

      if (IsCardBusCardInSocket(Socket)) {
         //
         // Couldn't get CIS of cardbus card, no big deal
         //
         status = STATUS_SUCCESS;

      } else if (status != STATUS_DEVICE_NOT_READY) {
         //
         // No CIS, munge it to look like a memory card
         //
         status = PcmciaMemoryCardHack(Socket, SocketData);
      }

     if (tuplePacket.TupleData) {
        ExFreePool(tuplePacket.TupleData);
     }
     return status;
   }

   while (NT_SUCCESS(status)) {

      status = GetTupleData(&tuplePacket);
      ASSERT (NT_SUCCESS(status));

      DebugPrint((PCMCIA_DEBUG_TUPLES, "%04x TUPLE %02x %s\n", tuplePacket.CISOffset,
                       tuplePacket.TupleCode, TUPLE_STRING(tuplePacket.TupleCode)));

      switch (tuplePacket.TupleCode) {

      case CISTPL_VERS_1: {
            ULONG         byteCount;
            PUCHAR        pStart, pCurrent;

            //
            // Extract manufacturer name and card name.
            //

            pStart = pCurrent = tuplePacket.TupleData+2;   // To string fields
            byteCount = 0;

            while ((*pCurrent != '\0') && (*pCurrent != (UCHAR)0xff)) {

               if ((byteCount >= MAX_MANFID_LENGTH-1) || (byteCount >= MAX_TUPLE_DATA_LENGTH)) {
                  status = STATUS_DEVICE_NOT_READY;
                  break;
               }

               byteCount++;
               pCurrent++;
            }

            if (!NT_SUCCESS(status)) {
               break;
            }

            RtlCopyMemory((PUCHAR)SocketData->Mfg, pStart, byteCount);
            //
            // Null terminate
            SocketData->Mfg[byteCount] = '\0';
            DebugPrint((PCMCIA_DEBUG_TUPLES, "Manufacturer: %s\n", SocketData->Mfg));

            PcmciaSubstituteUnderscore(SocketData->Mfg);

            pCurrent++;
            pStart = pCurrent;

            byteCount = 0;
            while ((*pCurrent != '\0') && (*pCurrent != (UCHAR)0xff)) {

               if ((byteCount >= MAX_IDENT_LENGTH-1) || (byteCount >= MAX_TUPLE_DATA_LENGTH)) {
                  status = STATUS_DEVICE_NOT_READY;
                  break;
               }

               byteCount++;
               pCurrent++;
            }

            if (!NT_SUCCESS(status)) {
               break;
            }

            RtlCopyMemory((PUCHAR)SocketData->Ident, pStart, byteCount);
            //
            // Null terminate
            SocketData->Ident[byteCount] = '\0';
            DebugPrint((PCMCIA_DEBUG_TUPLES, "Identifier: %s\n", SocketData->Ident));

            PcmciaSubstituteUnderscore(SocketData->Ident);
            break;
         }
         //
         // get the device configuration base
         //

      case CISTPL_CONFIG: {
            ProcessConfig(&tuplePacket);
            break;
         }

      case CISTPL_CONFIG_CB: {
            ProcessConfigCB(&tuplePacket);
            break;
         }

      case CISTPL_CFTABLE_ENTRY_CB:
      case CISTPL_CFTABLE_ENTRY:  {
            //
            // construct a possible configuration entry for this device
            //
            configEntry = PcmciaProcessConfigTable(&tuplePacket);
            if (configEntry) {

               //
               // Link configurations at the end of the list.
               //

               configEntry->NextEntry = NULL;
               if (prevEntry) {
                  prevEntry->NextEntry = configEntry;
               } else {
                  SocketData->ConfigEntryChain = configEntry;
               }
               prevEntry = configEntry;

            }
            break;
         }
      case CISTPL_FUNCID: {
            //  Mark device type..
            SocketData->DeviceType = * (tuplePacket.TupleData);
            DebugPrint((PCMCIA_DEBUG_TUPLES, "DeviceType: %x\n", SocketData->DeviceType));
            break;
         }
      case CISTPL_MANFID: {
            //
            PUCHAR localBufferPointer = tuplePacket.TupleData;

            SocketData->ManufacturerCode = *(localBufferPointer+1) << 8 | *localBufferPointer;
            SocketData->ManufacturerInfo = *(localBufferPointer+3)<<8 | *(localBufferPointer+2);
            DebugPrint((PCMCIA_DEBUG_TUPLES, "Code: %x, Info: %x\n", SocketData->ManufacturerCode,
                                                                     SocketData->ManufacturerInfo));
            break;
         }

      }  // end switch on Tuple code
      //
      // Skip to the next tuple
      //
      status = GetNextTuple(&tuplePacket);
   }

   if (tuplePacket.TupleData) {
      ExFreePool(tuplePacket.TupleData);
   }
   if (status == STATUS_DEVICE_NOT_READY) {
      return status;
   }

   //
   // Serial/modem/ATA devices recognized and appropriate
   // fixes for tuples applied here
   //

   PcmciaCheckForRecognizedDevice(Socket,SocketData);
   DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x ParseFunctionData: Final PcCard type %x\n",
               Socket, SocketData->DeviceType));
   return STATUS_SUCCESS;
}


NTSTATUS
PcmciaParseFunctionDataForID(
   IN PSOCKET_DATA SocketData
   )
/*++

Routine Description

   Parses the tuple data for the supplied function
   (SocketPtr->Function)

Arguments:

   Socket         - Pointer to the socket which contains the device
   SocketData - Pointer to the socket data structure for the function
                which will be filled with the parsed information

Return Value:

   Status
--*/

{
   PSOCKET Socket = SocketData->Socket;
   TUPLE_PACKET  tuplePacket;
   PUCHAR        localBufferPointer;
   NTSTATUS      status;
   USHORT        ManufacturerCode = 0;
   USHORT        ManufacturerInfo = 0;
   USHORT        CisCrc;

   DebugPrint((PCMCIA_DEBUG_TUPLES, "Parsing function %d for ID...\n", SocketData->Function));


   RtlZeroMemory(&tuplePacket, sizeof(TUPLE_PACKET));

   tuplePacket.DesiredTuple = 0xFF;
   tuplePacket.TupleData = ExAllocatePool(NonPagedPool, MAX_TUPLE_DATA_LENGTH);
   if (tuplePacket.TupleData == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }
   tuplePacket.Socket             = Socket;
   tuplePacket.SocketData         = SocketData;
   tuplePacket.TupleDataMaxLength = MAX_TUPLE_DATA_LENGTH;
   tuplePacket.TupleOffset        = 0;
   tuplePacket.Function           = SocketData->Function;

   status = GetFirstTuple(&tuplePacket);

   if (!NT_SUCCESS(status) ||
       (tuplePacket.TupleCode == CISTPL_END)) {

      if (status != STATUS_DEVICE_NOT_READY) {
         if (IsSocketFlagSet(Socket, SOCKET_CARD_MEMORY)) {
            status = STATUS_SUCCESS;
         }
         status = STATUS_NO_MORE_ENTRIES;
      }

      if (tuplePacket.TupleData) {
         ExFreePool(tuplePacket.TupleData);
      }
      return status;
   }

   while (NT_SUCCESS(status)) {

      status = GetTupleData(&tuplePacket);
      ASSERT (NT_SUCCESS(status));

      switch (tuplePacket.TupleCode) {

      case CISTPL_MANFID: {

            localBufferPointer = tuplePacket.TupleData;
            ManufacturerCode = *(localBufferPointer+1) << 8 | *localBufferPointer;
            ManufacturerInfo = *(localBufferPointer+3)<<8 | *(localBufferPointer+2);
            break;
         }

      }  // end switch on Tuple code
      //
      // Skip to the next tuple
      //
      status = GetNextTuple(&tuplePacket);
   }

   if (tuplePacket.TupleData) {
      ExFreePool(tuplePacket.TupleData);
   }

   if (SocketData->ManufacturerCode != ManufacturerCode) {
      DebugPrint((PCMCIA_DEBUG_TUPLES, "Verify failed on Manf. Code: %x %x\n", SocketData->ManufacturerCode, ManufacturerCode));
      return STATUS_UNSUCCESSFUL;
   }

   if (SocketData->ManufacturerInfo != ManufacturerInfo) {
      DebugPrint((PCMCIA_DEBUG_TUPLES, "Verify failed on Manf. Info: %x %x\n", SocketData->ManufacturerInfo, ManufacturerInfo));
      return STATUS_UNSUCCESSFUL;
   }

   //
   // Get the CIS checksum
   //
   CisCrc = GetCRC(SocketData);

   if (SocketData->CisCrc != CisCrc) {
      DebugPrint((PCMCIA_DEBUG_TUPLES, "Verify failed on CRC: %x %x\n", SocketData->CisCrc, CisCrc));
      return STATUS_UNSUCCESSFUL;
   }

   DebugPrint((PCMCIA_DEBUG_INFO, "skt %08x R2 CardId verified %x-%x-%x\n", Socket,
                                         ManufacturerCode,
                                         ManufacturerInfo,
                                         CisCrc
                                         ));
   return STATUS_SUCCESS;
}



VOID
PcmciaCheckForRecognizedDevice(
   IN PSOCKET  Socket,
   IN OUT PSOCKET_DATA SocketData
   )

/*++

Routine Description:

    Look at the configuration options on the PCCARD to determine if
    it is a serial port / modem / ATA device card.

Arguments:

    Socket         - Pointer to the socket which contains the device
    SocketData - the configuration information on the current PCCARD.

Return Value:

    None - Modifications are made to the socket data structure.

--*/

{
   ULONG         modemPorts[4] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8};
   ULONG         ataPorts0[2]  = { 0x1f0, 0x170};
   BOOLEAN       found = FALSE;
   UCHAR         dataByte;
   UCHAR         link;
   ULONG         index;
   PUCHAR        localBufferPointer;
   TUPLE_PACKET  tuplePacket;
   PUCHAR        tupleData;
   PCONFIG_ENTRY configEntry;
   NTSTATUS      status;

   //
   // This piece of code searches the config data for I/O ranges that start at
   // some known industry standard, and updates the devicetype accordingly.
   //
   // This is such an ugly hack, I'm really skeptical that we should be doing
   // this anymore. I assume there must have been some broken hardware that needed
   // it, but that information is now lost. At some point, this whole for loop
   // should just be removed.
   //
   for (configEntry = SocketData->ConfigEntryChain; configEntry; configEntry = configEntry->NextEntry) {
      for (index = 0; index < 4; index++) {
         if (modemPorts[index] == configEntry->IoPortBase[0]) {

            SocketData->DeviceType = PCCARD_TYPE_SERIAL;
            found = TRUE;
            break;
         }

         if (index < 2) {
            if (ataPorts0[index] == configEntry->IoPortBase[0]) {
               if (configEntry->IoPortBase[1] == 0x376 ||
                   configEntry->IoPortBase[1] == 0x3f6 ) {
                  SocketData->DeviceType = PCCARD_TYPE_ATA;
                  found = TRUE;
                  break;
               }
            }
         }
      }
   }

   switch(SocketData->DeviceType) {

   case PCCARD_TYPE_ATA:
      //
      // More smudges follow here for ATA cards to rub out buggy tuples
      //
      // Search for configurations which are not viable for ATA devices
      // and mark them invalid so they would not be reported to the I/O subsystem.
      // Also fix buggy tuples on ATA cards
      for (configEntry = SocketData->ConfigEntryChain;
          configEntry != NULL; configEntry = configEntry->NextEntry) {
         //
         // Adjust the IO resource requirement: ATA cards
         // typically have an incorrect length here
         // (+1)
         //
         if (configEntry->IoPortLength[1] > 0) {
            configEntry->IoPortLength[1]=0;
         }

         //
         // This next hack is to work around a problem with Viking SmartCard adapters.
         // This adapter doesn't like I/O ranges that are based at 0x70 or 0xf0,
         // so we bump up the alignment to 0x20 on unrestricted I/O ranges.
         //

         if ((SocketData->ManufacturerCode == 0x1df) && (configEntry->NumberOfIoPortRanges == 1) &&
             (configEntry->IoPortBase[0] == 0) && (configEntry->IoPortLength[0] == 0xf) &&
             (configEntry->IoPortAlignment[0] == 0x10)) {
             // alter alignment
             configEntry->IoPortAlignment[0] = 0x20;
         }

         if (configEntry->NumberOfMemoryRanges) {
            //
            // Don't use this configuration
            //
            configEntry->Flags |=  PCMCIA_INVALID_CONFIGURATION;
         }
      }
      break;

   case PCCARD_TYPE_PARALLEL:
      // Search for configurations which are not viable for Parallel devices
      for (configEntry = SocketData->ConfigEntryChain;
          configEntry != NULL; configEntry = configEntry->NextEntry) {

         if (configEntry->NumberOfMemoryRanges) {
            //
            // Don't use this configuration
            //
            configEntry->Flags |=  PCMCIA_INVALID_CONFIGURATION;
         }
      }
      break;

   case PCCARD_TYPE_SERIAL: {
      //
      // If card type is serial , check if it's actually a modem...
      //

      UCHAR  tupleDataBuffer[MAX_TUPLE_DATA_LENGTH];
      PUCHAR str, pChar;

      RtlZeroMemory(&tuplePacket, sizeof(TUPLE_PACKET));

      tuplePacket.DesiredTuple = CISTPL_FUNCE;
      tuplePacket.TupleData = tupleDataBuffer;

      tuplePacket.Socket             = Socket;
      tuplePacket.SocketData         = SocketData;
      tuplePacket.TupleDataMaxLength =  MAX_TUPLE_DATA_LENGTH;
      tuplePacket.TupleOffset        =  0;
      tuplePacket.Function           = SocketData->Function;
      status = GetFirstTuple(&tuplePacket);

      while (NT_SUCCESS(status)) {
         status = GetTupleData(&tuplePacket);
         if (!NT_SUCCESS(status) || (tuplePacket.TupleDataLength == 0)) {
            // something bad happened
            break;
         }

         if (tuplePacket.TupleData[0] >=1 &&
             tuplePacket.TupleData[0] <=3) {
            SocketData->DeviceType = PCCARD_TYPE_MODEM;
            return;
         }
         status = GetNextTuple(&tuplePacket);
      }

      if (status == STATUS_DEVICE_NOT_READY) {
         return;
      }

      tuplePacket.DesiredTuple = CISTPL_VERS_1;
      status = GetFirstTuple(&tuplePacket);

      if (!NT_SUCCESS(status)) {
         return;
      }
      status = GetTupleData(&tuplePacket);
      if (!NT_SUCCESS(status) || (tuplePacket.TupleDataLength < 3)) {
         // something bad happened
         return;
      }
      str = tuplePacket.TupleData+2;

      for (;;) {
         if ( *str == 0xFF ) {
            //
            // End of strings
            //
            break;
         }
         //
         // Convert to upper case
         //
         for (pChar = str; *pChar ; pChar++) {
            *pChar = (UCHAR)toupper(*pChar);
         }
         if (strstr(str, "MODEM") ||
             strstr(str, "FAX")) {
            SocketData->DeviceType = PCCARD_TYPE_MODEM;
            break;
         }
         //
         // Move onto next string..
         //
         str = str + strlen(str)+1;
         //
         // Just in case...
         //
         if (str >= (tuplePacket.TupleData + tuplePacket.TupleDataLength)) {
            break;
         }
      }
      break;
   }
   }


   // Search for configurations which are not viable - because
   // the resources requested are not supported by the controller
   // or the OS - and mark them invalid so they would not be requested

   for (configEntry = SocketData->ConfigEntryChain;
       configEntry != NULL; configEntry = configEntry->NextEntry) {

      if ((configEntry->IrqMask == 0) &&
          (configEntry->NumberOfIoPortRanges == 0) &&
          (configEntry->NumberOfMemoryRanges == 0)) {
         //
         // This configuration doesn't need any resources!!
         // Obviously bogus. (IBM Etherjet-3FE2 has one of these)
         //
         configEntry->Flags |= PCMCIA_INVALID_CONFIGURATION;
      }

   }
}


BOOLEAN
PcmciaQuickVerifyTupleChain(
   IN PUCHAR Buffer,
   IN ULONG Length
   )

/*++

Routine description:

   This routine is provided as a quick low-level check of the attribute
   data in the passed buffer. The tuples aren't interpreted in context,
   rather the tuple links are followed to see if the chain isn't total
   garbage.

   Note that none of the normal tuple handling functions are called, this
   is to avoid recursion, since this may be called from within normal
   tuple processing.


Arguments:
   Buffer, Length - defines the buffer that contains attribute data

Return Value:
   TRUE if the data in this buffer looks like a reasonable tuple chain,
   FALSE otherwise

--*/
{

   ULONG TupleCount = 0;
   UCHAR code, link;
   ULONG Offset = 0;
   BOOLEAN retval = TRUE;

   if (Length < 2) {
      return FALSE;
   }

   code = *(PUCHAR)((ULONG_PTR)(Buffer));
   link = *(PUCHAR)((ULONG_PTR)(Buffer)+1);

   while(code != CISTPL_END) {

      if (link == 0xff) {
         break;
      }

      if (code == CISTPL_NULL) {
         Offset += 1;
      } else if (code == CISTPL_NO_LINK) {
         Offset += 2;
      } else {
         Offset += (ULONG)link+2;
      }

      if (Offset >= (Length-1)) {
         retval = FALSE;
         break;
      }

      TupleCount++;

      code = *(PUCHAR)((ULONG_PTR)(Buffer)+Offset);
      link = *(PUCHAR)((ULONG_PTR)(Buffer)+Offset+1);
   }

   if (!TupleCount) {
      retval = FALSE;
   }

   return retval;
}



NTSTATUS
PcmciaMemoryCardHack(
   IN  PSOCKET Socket,
   IN PSOCKET_DATA SocketData
   )
/*++

Routine Description:

   This routine is called whenever we do not find a CIS of the card.
   We  probe the card to determine if it is sram or not.

Arguments

   SocketPtr   - Point to the socket in which this card was found
   SocketData  - Pointer to  a pointer to the data structure which normally contains
                 parsed tuple data. This will be filled in by this routine


Return Value

   STATUS_SUCCESS

--*/
{

#define JEDEC_SRAM 0x0000               // JEDEC ID for SRAM cards
#define JEDEC_ROM  0x0002               // JEDEC ID for ROM cards
#define READ_ID_CMD      0x9090

   PPDO_EXTENSION pdoExtension = SocketData->PdoExtension;
   USHORT OrigValue;
   USHORT ChkValue;
   USHORT ReadIdCmd = READ_ID_CMD;

   PAGED_CODE();

   SetSocketFlag(Socket, SOCKET_CARD_MEMORY);

   SocketData->DeviceType = PCCARD_TYPE_MEMORY;
   SocketData->Flags = SDF_JEDEC_ID;
   SocketData->JedecId = JEDEC_ROM;

   //
   // Like win9x, we probe the card's common memory with a write to offset zero to see if
   // it looks like sram
   //

   if (((*(Socket->SocketFnPtr->PCBReadCardMemory)) (pdoExtension, PCCARD_COMMON_MEMORY, 0, (PUCHAR)&OrigValue, 2) == 2) &&
       ((*(Socket->SocketFnPtr->PCBWriteCardMemory))(pdoExtension, PCCARD_COMMON_MEMORY, 0, (PUCHAR)&ReadIdCmd, 2) == 2) &&
       ((*(Socket->SocketFnPtr->PCBReadCardMemory)) (pdoExtension, PCCARD_COMMON_MEMORY, 0, (PUCHAR)&ChkValue, 2)  == 2) &&
       ((*(Socket->SocketFnPtr->PCBWriteCardMemory))(pdoExtension, PCCARD_COMMON_MEMORY, 0, (PUCHAR)&OrigValue, 2) == 2)) {

      if (ChkValue == ReadIdCmd) {
         SocketData->JedecId = JEDEC_SRAM;
      }
   }

   if (pcmciaReportMTD0002AsError && (SocketData->JedecId == JEDEC_ROM)) {
      return STATUS_DEVICE_NOT_READY;
   }

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\utils.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains utility functions for the pcmcia driver

Authors:

    Bob Rinne (BobRi) 3-Aug-1994
    Jeff McLeman 12-Apr-1994
    Ravisankar Pudipeddi (ravisp) 1-Nov-96
    Neil Sandlin (neilsa) June 1 1999

Environment:

    Kernel mode

Revision History :
    6-Apr-95
        Modified for databook support - John Keys Databook
    1-Nov-96
        Total overhaul to make this a bus enumerator - Ravisankar Pudipeddi (ravisp)
    30-Mar-99
        Turn this module into really just utility routines

--*/

#include "pch.h"


#pragma alloc_text(PAGE, PcmciaReportControllerError)

//
// Internal References
//

NTSTATUS
PcmciaAdapterIoCompletion(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp,
   IN PKEVENT pdoIoCompletedEvent
   );
   
VOID
PcmciaPlayTone(
   IN ULONG Frequency,
   IN ULONG Duration
   );

//
//
//



NTSTATUS
PcmciaIoCallDriverSynchronous(
   PDEVICE_OBJECT deviceObject,
   PIRP Irp
   )
/*++

Routine Description

Arguments

Return Value

--*/   
{
   NTSTATUS status;
   KEVENT event;

   KeInitializeEvent(&event, NotificationEvent, FALSE);
   
   IoCopyCurrentIrpStackLocationToNext(Irp);
   IoSetCompletionRoutine(
                         Irp,
                         PcmciaAdapterIoCompletion,
                         &event,
                         TRUE,
                         TRUE,
                         TRUE
                         );

   status = IoCallDriver(deviceObject, Irp);   

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
      status = Irp->IoStatus.Status;
   }

   return status;   
}



NTSTATUS
PcmciaAdapterIoCompletion(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp,
   IN PKEVENT pdoIoCompletedEvent
   )
/*++

Routine Description:

    Generic completion routine used by the driver

Arguments:

    DeviceObject
    Irp
    pdoIoCompletedEvent - this event will be signalled before return of this routine

Return value:

    Status

--*/
{
   KeSetEvent(pdoIoCompletedEvent, IO_NO_INCREMENT, FALSE);
   return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
PcmciaWait(
   IN ULONG MicroSeconds
   )

/*++
Routine Description

    Waits for the specified interval before returning,
    by yielding execution.

Arguments

    MicroSeconds -  Amount of time to delay in microseconds

Return Value

    None. Must succeed.

--*/
{
   LARGE_INTEGER  dueTime;
   NTSTATUS status;


   if ((KeGetCurrentIrql() < DISPATCH_LEVEL) && (MicroSeconds > 50)) {
      //
      // Convert delay to 100-nanosecond intervals
      //
      dueTime.QuadPart = -((LONG) MicroSeconds*10);
     
      //
      // We wait for an event that'll never be set.
      //
      status = KeWaitForSingleObject(&PcmciaDelayTimerEvent,
                                     Executive,
                                     KernelMode,
                                     FALSE,
                                     &dueTime);
                                     
      ASSERT(status == STATUS_TIMEOUT);
   } else {
      KeStallExecutionProcessor(MicroSeconds);
   }
}



ULONG
PcmciaCountOnes(
   IN ULONG Data
   )
/*++

Routine Description:

   Counts the number of 1's in the binary representation of the supplied argument

Arguments:

   Data - supplied argument for which 1's need to be counted

Return value:

   Number of 1's in binary rep. of Data

--*/
{
   ULONG count=0;
   while (Data) {
      Data &= (Data-1);
      count++;
   }
   return count;
}


VOID
PcmciaLogError(
   IN PFDO_EXTENSION DeviceExtension,
   IN ULONG ErrorCode,
   IN ULONG UniqueId,
   IN ULONG Argument
   )

/*++

Routine Description:

    This function logs an error.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.
    ErrorCode - Supplies the error code for this error.
    UniqueId - Supplies the UniqueId for this error.

Return Value:

    None.

--*/

{
   PIO_ERROR_LOG_PACKET packet;

   packet = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                                           sizeof(IO_ERROR_LOG_PACKET) + sizeof(ULONG));

   if (packet) {
      packet->ErrorCode = ErrorCode;
      packet->SequenceNumber = DeviceExtension->SequenceNumber++;
      packet->MajorFunctionCode = 0;
      packet->RetryCount = (UCHAR) 0;
      packet->UniqueErrorValue = UniqueId;
      packet->FinalStatus = STATUS_SUCCESS;
      packet->DumpDataSize = sizeof(ULONG);
      packet->DumpData[0] = Argument;

      IoWriteErrorLogEntry(packet);
   }
}


VOID
PcmciaLogErrorWithStrings(
   IN PFDO_EXTENSION DeviceExtension,
   IN ULONG             ErrorCode,
   IN ULONG             UniqueId,
   IN PUNICODE_STRING   String1,
   IN PUNICODE_STRING   String2
   )

/*++

Routine Description

    This function logs an error and includes the strings provided.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.
    ErrorCode - Supplies the error code for this error.
    UniqueId - Supplies the UniqueId for this error.
    String1 - The first string to be inserted.
    String2 - The second string to be inserted.

Return Value:

    None.

--*/

{
   ULONG                length;
   PCHAR                dumpData;
   PIO_ERROR_LOG_PACKET packet;

   length = String1->Length + sizeof(IO_ERROR_LOG_PACKET) + 4;

   if (String2) {
      length += String2->Length;
   }

   if (length > ERROR_LOG_MAXIMUM_SIZE) {

      //
      // Don't have code to truncate strings so don't log this.
      //

      return;
   }

   packet = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                                           (UCHAR) length);
   if (packet) {
      packet->ErrorCode = ErrorCode;
      packet->SequenceNumber = DeviceExtension->SequenceNumber++;
      packet->MajorFunctionCode = 0;
      packet->RetryCount = (UCHAR) 0;
      packet->UniqueErrorValue = UniqueId;
      packet->FinalStatus = STATUS_SUCCESS;
      packet->NumberOfStrings = 1;
      packet->StringOffset = (USHORT) ((PUCHAR)&packet->DumpData[0] - (PUCHAR)packet);
      packet->DumpDataSize = (USHORT) (length - sizeof(IO_ERROR_LOG_PACKET));
      packet->DumpDataSize /= sizeof(ULONG);
      dumpData = (PUCHAR) &packet->DumpData[0];

      RtlCopyMemory(dumpData, String1->Buffer, String1->Length);

      dumpData += String1->Length;
      if (String2) {
         *dumpData++ = '\\';
         *dumpData++ = '\0';

         RtlCopyMemory(dumpData, String2->Buffer, String2->Length);
         dumpData += String2->Length;
      }
      *dumpData++ = '\0';
      *dumpData++ = '\0';

      IoWriteErrorLogEntry(packet);
   }

   return;
}



BOOLEAN
PcmciaReportControllerError(
   IN PFDO_EXTENSION FdoExtension,
   NTSTATUS ErrorCode
   )
/*++
Routine Description

    Causes a pop-up dialog to appear indicating an error that 
    we should tell the user about. The device description of the
    controller is also included in the text of the pop-up.

Arguments

    FdoExtension - Pointer to device extension for pcmcia controller
    ErrorCode    - the ntstatus code for the error

Return Value

    TRUE    -   If a an error was queued
    FALSE   -   If it failed for some reason

--*/
{
    UNICODE_STRING unicodeString;
    PWSTR   deviceDesc = NULL;
    NTSTATUS status;
    ULONG   length = 0;
    BOOLEAN retVal;

    PAGED_CODE();

    //
    // Obtain the device description for the PCMCIA controller
    // that is used in the error pop-up. If one cannot be obtained,
    // still pop-up the error dialog, indicating the controller as unknown
    //

    // First, find out the length of the buffer required to obtain
    // device description for this pcmcia controller
    //
    status = IoGetDeviceProperty(FdoExtension->Pdo,
                                 DevicePropertyDeviceDescription,
                                 0,
                                 NULL,
                                 &length
                                );
    ASSERT(!NT_SUCCESS(status));

    if (status == STATUS_BUFFER_TOO_SMALL) {
         deviceDesc = ExAllocatePool(PagedPool, length);
         if (deviceDesc != NULL) {
            status = IoGetDeviceProperty(FdoExtension->Pdo,
                                         DevicePropertyDeviceDescription,
                                         length,
                                         deviceDesc,
                                         &length);
            if (!NT_SUCCESS(status)) {
                ExFreePool(deviceDesc);
            }
         } else {
           status = STATUS_INSUFFICIENT_RESOURCES;
         }
    }

    if (!NT_SUCCESS(status)) {
        deviceDesc = L"[unknown]";
    }

    RtlInitUnicodeString(&unicodeString, deviceDesc);

    retVal =  IoRaiseInformationalHardError(
                                ErrorCode,
                                &unicodeString,
                                NULL);

    //
    // Note: successful status here indicates success of
    // IoGetDeviceProperty above. This would mean we still have an
    // allocated buffer.
    //
    if (NT_SUCCESS(status)) {
        ExFreePool(deviceDesc);
    }

    return retVal;
}



VOID
PcmciaPlaySound(
   IN PCMCIA_SOUND_TYPE SoundType
   )
/*++

Routine Description:

    Plays the sound corresponding the supplied event,
    if sounds are enabled

Arguments:

    SoundType - specifies the event the sound denotes

Return Value:

    None
--*/
{

   if (!(PcmciaGlobalFlags & PCMCIA_GLOBAL_SOUNDS_ENABLED)) {
      return;
   }

   switch (SoundType) {

   case CARD_INSERTED_SOUND: {
         PcmciaPlayTone(660, 150);
         PcmciaPlayTone(880, 150);
         break;
      }

   case CARD_REMOVED_SOUND: {
         PcmciaPlayTone(880, 150);
         PcmciaPlayTone(660, 150);
         break;
      }

   case ERROR_SOUND: {
         PcmciaPlayTone(220, 350);
         break;
      }
   }
}



VOID
PcmciaPlayTone(
   IN ULONG Frequency,
   IN ULONG Duration
   )

/*++

Routine Description:

    Plays the note of the specified frequency &
    duration on the computer's internal speaker.

Arguments:

    Frequency - frequency of the note
    Duration -  duration, in milliseconds, of the note

Return Value:
    None

--*/
{
   KIRQL OldIrql;
   PPCMCIA_SOUND_EVENT soundEvent = ExAllocatePool(NonPagedPool, sizeof(PCMCIA_SOUND_EVENT));
   
   if (!soundEvent) {
      return;
   }         
   soundEvent->NextEvent = NULL;
   soundEvent->Frequency = Frequency;
   soundEvent->Duration = Duration;

   //
   // Synchronize access to prevent two beeps from starting at once
   //
   KeAcquireSpinLock(&PcmciaToneLock, &OldIrql);

   if (PcmciaToneList != NULL) {
      PPCMCIA_SOUND_EVENT curEvent, prevEvent;
      //
      // List isn't empty, tack this new event on the end of the list
      //
      curEvent = PcmciaToneList;
      while(curEvent) {
         prevEvent = curEvent;
         curEvent = curEvent->NextEvent;
      }
      prevEvent->NextEvent = soundEvent;
      
   } else {      
      LARGE_INTEGER  dueTime;
      //
      // Nothing playing right now, start it up
      //
      PcmciaToneList = soundEvent;
      
#if !defined(_WIN64)
      HalMakeBeep(soundEvent->Frequency);
#endif
      dueTime.QuadPart = -((LONG) soundEvent->Duration*1000*10);
      KeSetTimer(&PcmciaToneTimer, dueTime, &PcmciaToneDpc);      
   }

   KeReleaseSpinLock(&PcmciaToneLock, OldIrql);
}


VOID
PcmciaPlayToneCompletion(
   IN PKDPC Dpc,
   IN PVOID Context,
   IN PVOID SystemArgument1,
   IN PVOID SystemArgument2
   )
/*++
Routine Description

   This routine turns off the beep at the end of the duration, and
   starts a new one, if one is queued.

Arguments


Return Value

   none

--*/   
{
   KIRQL OldIrql;
   PPCMCIA_SOUND_EVENT oldEvent, soundEvent;

   //
   // turn off previous sound
   //
#if !defined(_WIN64)
   HalMakeBeep(0);
#endif

   KeAcquireSpinLock(&PcmciaToneLock, &OldIrql);
   //
   // dequeue the previous sound
   //   
   oldEvent = PcmciaToneList;
   ASSERT(oldEvent != NULL);
   PcmciaToneList = soundEvent = oldEvent->NextEvent;
   
   KeReleaseSpinLock(&PcmciaToneLock, OldIrql);
   ExFreePool(oldEvent);
   
   if (soundEvent) {
      LARGE_INTEGER  dueTime;
      //
      // turn on next sound, and reschedule timer
      //
#if !defined(_WIN64)
      HalMakeBeep(soundEvent->Frequency);
#endif
      dueTime.QuadPart = -((LONG) soundEvent->Duration*1000*10);
      KeSetTimer(&PcmciaToneTimer, dueTime, &PcmciaToneDpc);      

   } 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\ar_busno.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    ar_busno.c

Abstract:

    This module implements the PCI Bus Number Arbiter.

Author:

    Andy Thornton (andrewth) 04/17/97

Revision History:

--*/

#include "pcip.h"

#define ARBUSNO_VERSION 0

//
// Prototypes for routines exposed only through the "interface"
// mechanism.
//

NTSTATUS
arbusno_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

VOID
arbusno_Reference(
    IN PVOID Context
    );

VOID
arbusno_Dereference(
    IN PVOID Context
    );

NTSTATUS
arbusno_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

PCI_INTERFACE ArbiterInterfaceBusNumber = {
    &GUID_ARBITER_INTERFACE_STANDARD,       // InterfaceType
    sizeof(ARBITER_INTERFACE),              // MinSize
    ARBUSNO_VERSION,                        // MinVersion
    ARBUSNO_VERSION,                        // MaxVersion
    PCIIF_FDO,                              // Flags
    0,                                      // ReferenceCount
    PciArb_BusNumber,                       // Signature
    arbusno_Constructor,                    // Constructor
    arbusno_Initializer                     // Instance Initializer
};

//
// Arbiter helper functions.
//

NTSTATUS
arbusno_UnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );
    
NTSTATUS
arbusno_PackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
arbusno_UnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );

LONG
arbusno_ScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, arbusno_Constructor)
#pragma alloc_text(PAGE, arbusno_Dereference)
#pragma alloc_text(PAGE, arbusno_Initializer)
#pragma alloc_text(PAGE, arbusno_Reference)
#pragma alloc_text(PAGE, arbusno_UnpackRequirement)
#pragma alloc_text(PAGE, arbusno_PackResource)
#pragma alloc_text(PAGE, arbusno_UnpackResource)
#pragma alloc_text(PAGE, arbusno_ScoreRequirement)
#endif

NTSTATUS
arbusno_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Check the InterfaceSpecificData to see if this is the correct
    arbiter (we already know the required interface is an arbiter
    from the GUID) and if so, allocate (and reference) a context
    for this interface.

Arguments:

    PciInterface    Pointer to the PciInterface record for this 
                    interface type.
    InterfaceSpecificData
                    A ULONG containing the resource type for which
                    arbitration is required.
    InterfaceReturn

Return Value:

    TRUE is this device is not known to cause problems, FALSE
    if the device should be skipped altogether.

--*/

{
    PARBITER_INTERFACE arbiterInterface;
    NTSTATUS status;

    //
    // This arbiter handles bus numbers, is that what they want?
    //

    if ((ULONG_PTR)InterfaceSpecificData != CmResourceTypeBusNumber) {

        //
        // No, it's not us then.
        //

        return STATUS_INVALID_PARAMETER_5;
    }

    //
    // Have already verified that the InterfaceReturn variable
    // points to an area in memory large enough to contain an
    // ARBITER_INTERFACE.  Fill it in for the caller.
    //

    arbiterInterface = (PARBITER_INTERFACE)InterfaceReturn;

    arbiterInterface->Size                 = sizeof(ARBITER_INTERFACE);
    arbiterInterface->Version              = ARBUSNO_VERSION;
    arbiterInterface->InterfaceReference   = PciReferenceArbiter;
    arbiterInterface->InterfaceDereference = PciDereferenceArbiter;
    arbiterInterface->ArbiterHandler       = ArbArbiterHandler;
    arbiterInterface->Flags                = 0;

    status = PciArbiterInitializeInterface(DeviceExtension,
                                           PciArb_BusNumber,
                                           arbiterInterface);

    return status;
}

NTSTATUS
arbusno_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )

/*++

Routine Description:

    This routine is called once per instantiation of an arbiter.
    Performs initialization of this instantiation's context.

Arguments:

    Instance        Pointer to the arbiter context.

Return Value:

    Returns the status of this operation.

--*/

{
    RtlZeroMemory(&Instance->CommonInstance, sizeof(ARBITER_INSTANCE));
    
    //
    // Set the Action Handler entry points.
    //

    Instance->CommonInstance.UnpackRequirement = arbusno_UnpackRequirement;
    Instance->CommonInstance.PackResource      = arbusno_PackResource;
    Instance->CommonInstance.UnpackResource    = arbusno_UnpackResource;
    Instance->CommonInstance.ScoreRequirement  = arbusno_ScoreRequirement;
    
    //
    // Initialize the rest of the common instance
    //
    
    return ArbInitializeArbiterInstance(&Instance->CommonInstance,
                                        Instance->BusFdoExtension->FunctionalDeviceObject,
                                        CmResourceTypeBusNumber,
                                        Instance->InstanceName,
                                        L"Pci",
                                        NULL    // no translation of bus numbers
                                        );

}

NTSTATUS
arbusno_UnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

Routine Description:

    This routine unpacks an resource requirement descriptor.
    
Arguments:

    Descriptor - The descriptor describing the requirement to unpack.
    
    Minimum - Pointer to where the minimum acceptable start value should be 
        unpacked to.
    
    Maximum - Pointer to where the maximum acceptable end value should be 
        unpacked to.
    
    Length - Pointer to where the required length should be unpacked to.
    
    Minimum - Pointer to where the required alignment should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeBusNumber);

    *Minimum = (ULONGLONG)Descriptor->u.BusNumber.MinBusNumber;
    *Maximum = (ULONGLONG)Descriptor->u.BusNumber.MaxBusNumber;
    *Length = Descriptor->u.BusNumber.Length;
    *Alignment = 1;

    return STATUS_SUCCESS;
}

NTSTATUS
arbusno_PackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs an resource descriptor.
    
Arguments:

    Requirement - The requirement from which this resource was chosen.
    
    Start - The start value of the resource.
    
    Descriptor - Pointer to the descriptor to pack into.
    
Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Requirement);
    ASSERT(Requirement->Type == CmResourceTypeBusNumber);
    ASSERT(Start < MAXULONG);

    Descriptor->Type = CmResourceTypeBusNumber;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->u.BusNumber.Start = (ULONG) Start;
    Descriptor->u.BusNumber.Length = Requirement->u.BusNumber.Length;
    
    return STATUS_SUCCESS;
}

NTSTATUS
arbusno_UnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks an resource descriptor.
    
Arguments:

    Descriptor - The descriptor describing the resource to unpack.
    
    Start - Pointer to where the start value should be unpacked to.
    
    Length - Pointer to where the Length value should be unpacked to.
    
Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Start);
    ASSERT(Length);
    ASSERT(Descriptor->Type == CmResourceTypeBusNumber);

    *Start = (ULONGLONG) Descriptor->u.BusNumber.Start;
    *Length = Descriptor->u.BusNumber.Length;
    
    return STATUS_SUCCESS;
}

LONG
arbusno_ScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine scores a requirement based on how flexible it is.  The least
    flexible devices are scored the least and so when the arbitration list is
    sorted we try to allocate their resources first.
    
Arguments:

    Descriptor - The descriptor describing the requirement to score.
    

Return Value:

    The score.

--*/

{
    LONG score;
    
    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeBusNumber);

    score = (Descriptor->u.BusNumber.MaxBusNumber - 
                Descriptor->u.BusNumber.MinBusNumber) / 
                Descriptor->u.BusNumber.Length;

    PciDebugPrint(
        PciDbgObnoxious,
        "Scoring BusNumber resource %p => %i\n",
        Descriptor,
        score
        );

    return score;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\arb_comn.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    arb_comn.c

Abstract:

    This module contains arbitration generic "utility" routines
    for the PCI driver.

Author:

    Peter Johnston (peterj)     1-Apr-1997
    Andrew Thornton (andrewth)  15-May-1997


Revision History:

--*/

#include "pcip.h"

#define PCI_CONTEXT_TO_INSTANCE(context) \
    CONTAINING_RECORD(context, PCI_ARBITER_INSTANCE, CommonInstance)

//
// Plain text (short) description of each arbiter type.
// (For debug).
//
// N.B. Order corresponds to PCI Signature enumeration.
//

PUCHAR PciArbiterNames[] = {
    "I/O Port",
    "Memory",
    "Interrupt",
    "Bus Number"
};
VOID
PciArbiterDestructor(
    IN PVOID Extension
    )

/*++

Routine Description:

    This routine is called when a PCI Secondary Extension that
    contains an arbiter instance is being torn down.   Its function
    is to do any arbiter specific teardown.

Arguments:

    Extension   Address of PCI secondary extension containing
                the arbiter.

Return Value:

    None.

--*/

{
    PPCI_ARBITER_INSTANCE instance;
    PARBITER_INSTANCE arbiter;
    PARBITER_MEMORY_EXTENSION extension;

    instance = (PPCI_ARBITER_INSTANCE)Extension;
    arbiter = &instance->CommonInstance;

    ASSERT(!arbiter->ReferenceCount);
    ASSERT(!arbiter->TransactionInProgress);

    //
    // NTRAID #54671 - 04/03/2000 - andrewth
    // This is rather gross but it fixes the leak from the memory
    // arbiter.  
    //

    if (arbiter->ResourceType == CmResourceTypeMemory) {

        extension = arbiter->Extension;

        ASSERT(extension);

        ArbFreeOrderingList(&extension->PrefetchableOrdering);
        ArbFreeOrderingList(&extension->NonprefetchableOrdering);
        ArbFreeOrderingList(&extension->OriginalOrdering);

        //
        // Arbiter->OrderingList is one of the above three lists we just freed -
        // don't free it again
        //

        RtlZeroMemory(&arbiter->OrderingList, sizeof(ARBITER_ORDERING_LIST));
    }

    ArbDeleteArbiterInstance(arbiter);
}

NTSTATUS
PciArbiterInitializeInterface(
    IN  PVOID DeviceExtension,
    IN  PCI_SIGNATURE DesiredInterface,
    IN OUT PARBITER_INTERFACE ArbiterInterface
    )
{
    PPCI_ARBITER_INSTANCE instance;
    PPCI_FDO_EXTENSION fdoExtension = (PPCI_FDO_EXTENSION)DeviceExtension;

    //
    // Find the arbiter instance (context) for this resource type
    // on this FDO.
    //

    instance = PciFindSecondaryExtension(fdoExtension, DesiredInterface);
    if (instance == NULL) {

#if DBG

        //
        // Check if this bridge is doing subtractive decoding in
        // which case there will be no arbiter for IO or Memory.
        //
        // N.B. Only relevant to debug, either way the call will
        // fail but we don't want to actually assert if this is
        // the case.
        //

        if (!PCI_IS_ROOT_FDO(fdoExtension)) {

            PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)
                fdoExtension->PhysicalDeviceObject->DeviceExtension;

            ASSERT_PCI_PDO_EXTENSION(pdoExtension);

            if (pdoExtension->Dependent.type1.SubtractiveDecode) {

                //
                // Subtractive, no arbiters.
                //

                return STATUS_INVALID_PARAMETER_2;
            }

        }

        ASSERTMSG("couldn't locate arbiter for resource.", instance);

#endif
        return STATUS_INVALID_PARAMETER_5;
    }

    //
    // Fill in the rest of the caller's arbiter interface structure.
    //

    ArbiterInterface->Context = &instance->CommonInstance;

    PciDebugPrint(
        PciDbgObnoxious,
        "PCI - %S Arbiter Interface Initialized.\n",
        instance->CommonInstance.Name
        );

    return STATUS_SUCCESS;
}

NTSTATUS
PciInitializeArbiters(
    IN  PVOID DeviceExtension
    )
{
    NTSTATUS status;
    PPCI_INTERFACE *interfaceEntry;
    PCI_SIGNATURE arbiterType;
    PPCI_ARBITER_INSTANCE instance;
    PPCI_FDO_EXTENSION fdoExtension = (PPCI_FDO_EXTENSION)DeviceExtension;
    PRTL_RANGE_LIST *range;
    ULONG i;

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    //
    // For each resource type for which we do arbitration, initialize
    // a context.
    //

    for (arbiterType =  PciArb_Io;
         arbiterType <= PciArb_BusNumber;
         arbiterType++) {

        //
        // If this bridge provides this resource via subtractive
        // decode, get the system to fall thru to the parent
        // arbiter by not creating an arbiter at this level.
        //

        if (!PCI_IS_ROOT_FDO(fdoExtension)) {

            PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)
                fdoExtension->PhysicalDeviceObject->DeviceExtension;

            ASSERT_PCI_PDO_EXTENSION(pdoExtension);

            if (pdoExtension->Dependent.type1.SubtractiveDecode) {

                //
                // Skip creation of this arbiter.
                //

                PciDebugPrint(
                    PciDbgVerbose,
                    "PCI Not creating arbiters for subtractive bus %d\n",
                    pdoExtension->Dependent.type1.SecondaryBus
                    );

                continue;
            }
        }

        //
        // Find this entry in the interface table (if not found, skip
        // it).
        //

        for (interfaceEntry = PciInterfaces;
             *interfaceEntry;
             interfaceEntry++) {

            if ((*interfaceEntry)->Signature == arbiterType) {
                break;
            }
        }

        if (*interfaceEntry == NULL) {

            //
            // Did not find an interface entry.  This means we don't
            // actually implement this arbiter type.
            //

            PciDebugPrint(
                PciDbgObnoxious,
                "PCI - FDO ext 0x%08x no %s arbiter.\n",
                DeviceExtension,
                PciArbiterNames[arbiterType - PciArb_Io]
                );

            continue;
        }

        instance = ExAllocatePool(
                       PagedPool | POOL_COLD_ALLOCATION,
                       sizeof(PCI_ARBITER_INSTANCE)
                       );

        if (instance == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Initialize PCI specific fields
        //

        instance->BusFdoExtension = fdoExtension;
        instance->Interface = *interfaceEntry;

        swprintf(
            instance->InstanceName,
            L"PCI %S (b=%02x)",
            PciArbiterNames[arbiterType - PciArb_Io],
            fdoExtension->BaseBus
            );

        //
        // Allow this arbiter to do any of it's own first time
        // initialization.
        //

        status = (*interfaceEntry)->Initializer(instance);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Push this arbiter onto the FDO's list of extensions.
        //

        PciLinkSecondaryExtension(fdoExtension,
                                  instance,
                                  arbiterType,
                                  PciArbiterDestructor);

        PciDebugPrint(
            PciDbgObnoxious,
            "PCI - FDO ext 0x%08x %S arbiter initialized (context 0x%08x).\n",
            DeviceExtension,
            instance->CommonInstance.Name,
            instance
            );
    }
    return STATUS_SUCCESS;
}

NTSTATUS
PciInitializeArbiterRanges(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PCM_RESOURCE_LIST ResourceList
    )
{
    NTSTATUS status;
    PCI_SIGNATURE arbiterType;
    CM_RESOURCE_TYPE resourceType;
    PPCI_ARBITER_INSTANCE instance;

    //
    // NTRAID #95564 - 04/03/2000 - andrewth
    // This routine needs to be reworked, in the case where
    // this FDO is processing a second or subsequent START_DEVICE
    // IRP, the arbiter's ranges may need to be adjusted according
    // to the incoming resource list.    Until this is done, avoid
    // causing problems by processing it again.
    //

    if (FdoExtension->ArbitersInitialized) {
        PciDebugPrint(
            PciDbgInformative,
            "PCI Warning hot start FDOx %08x, resource ranges not checked.\n",
            FdoExtension
            );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Check if this bridge is doing subtractive decoding in
    // which case there will be no arbiters
    //

    if (!PCI_IS_ROOT_FDO(FdoExtension)) {
        PPCI_PDO_EXTENSION pdoExtension;

        pdoExtension = (PPCI_PDO_EXTENSION)
            FdoExtension->PhysicalDeviceObject->DeviceExtension;

        ASSERT_PCI_PDO_EXTENSION(pdoExtension);

        if (pdoExtension->Dependent.type1.SubtractiveDecode) {

            //
            // Subtractive decode no arbiters.
            //
            PciDebugPrint(
                PciDbgInformative,
                "PCI Skipping arbiter initialization for subtractive bridge FDOX %p\n",
                FdoExtension
                );

            return STATUS_SUCCESS;
        }
    }


    //
    // For each resource type for which we do arbitration, initialize
    // a context.
    //

    for (arbiterType =  PciArb_Io;
         arbiterType <= PciArb_Memory;
         arbiterType++) {

        //
        // Currently this is only supported for Memory and IO.
        //

        switch (arbiterType) {

            //
            // Go ahead and process these ones.
            //

        case PciArb_Io:
            resourceType = CmResourceTypePort;
            break;

        case PciArb_Memory:
            resourceType = CmResourceTypeMemory;
            break;

        default:

            //
            // Skip anything else.
            //

            continue;
        }

        //
        // Find this arbiter instance.
        //

        instance = PciFindSecondaryExtension(FdoExtension, arbiterType);
        if (instance == NULL) {

            //
            // Did not find an interface entry.  This means we don't
            // actually implement this arbiter type.
            //

            PciDebugPrint(
                PciDbgAlways,
                "PCI - FDO ext 0x%08x %s arbiter (REQUIRED) is missing.\n",
                FdoExtension,
                PciArbiterNames[arbiterType - PciArb_Io]
                );

            continue;
        }

        //
        // The incoming ResourceList gives the ranges this bus supports.
        // Convert this to an inverted range so we can exclude everything
        // we don't cover.
        //

        status = PciRangeListFromResourceList(
                     FdoExtension,
                     ResourceList,
                     resourceType,
                     TRUE,
                     instance->CommonInstance.Allocation
                     );
        if (!NT_SUCCESS(status)) {

            //
            // Nothing we can do here.   Additional debug stuff was
            // in the lower level.  Skip this puppy.
            //

            continue;
        }

        //
        // NTRAID #95564 - 04/03/2000 - andrewth
        //
        // When ArbStartArbiter is complete it will replace
        // the call to PciRangeListFromResourceList.
        //

        ASSERT(instance->CommonInstance.StartArbiter);

        status = instance->CommonInstance.StartArbiter(&instance->CommonInstance,
                                                       ResourceList
                                                       );

        if (!NT_SUCCESS(status)) {

            //
            // Bail initializing this arbiter and fail the start.  The arbiters
            // will be cleaned up when we get the REMOVE_DEVICE
            //

            return status;
        }
    }

    return STATUS_SUCCESS;
}

VOID
PciReferenceArbiter(
    IN PVOID Context
    )
{
    PPCI_ARBITER_INSTANCE instance = PCI_CONTEXT_TO_INSTANCE(Context);
    InterlockedIncrement(&instance->CommonInstance.ReferenceCount);
}

VOID
PciDereferenceArbiter(
    IN PVOID Context
    )
{
    PPCI_ARBITER_INSTANCE instance = PCI_CONTEXT_TO_INSTANCE(Context);
    InterlockedDecrement(&instance->CommonInstance.ReferenceCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\busno.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    busno.c

Abstract:

    This module implements routines pertaining to PCI bus numbers.

Author:

    Andy Thornton (andrewth) 9/5/98

Revision History:

--*/

#include "pcip.h"

VOID
PciSpreadBridges(
    IN PPCI_FDO_EXTENSION Parent,
    IN UCHAR BridgeCount
    );

UCHAR
PciFindBridgeNumberLimit(
    IN PPCI_FDO_EXTENSION BridgeParent,
    IN UCHAR Base
    );

VOID
PciFitBridge(
    IN PPCI_FDO_EXTENSION ParentFdoExtension,
    IN PPCI_PDO_EXTENSION BridgePdoExtension
    );

VOID
PciSetBusNumbers(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN UCHAR Primary,
    IN UCHAR Secondary,
    IN UCHAR Subordinate
    );

VOID
PciUpdateAncestorSubordinateBuses(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN UCHAR Subordinate
    );

VOID
PciDisableBridge(
    IN PPCI_PDO_EXTENSION Bridge
    );

UCHAR
PciFindBridgeNumberLimitWorker(
    IN PPCI_FDO_EXTENSION BridgeParent,
    IN PPCI_FDO_EXTENSION CurrentParent,
    IN UCHAR Base,
    OUT PBOOLEAN RootConstrained
    );


#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, PciConfigureBusNumbers)
#pragma alloc_text(PAGE, PciAreBusNumbersConfigured)
#pragma alloc_text(PAGE, PciSpreadBridges)
#pragma alloc_text(PAGE, PciFindBridgeNumberLimit)
#pragma alloc_text(PAGE, PciFitBridge)
#pragma alloc_text(PAGE, PciSetBusNumbers)
#pragma alloc_text(PAGE, PciUpdateAncestorSubordinateBuses)
#pragma alloc_text(PAGE, PciDisableBridge)
#pragma alloc_text(PAGE, PciFindBridgeNumberLimitWorker)

#endif


VOID
PciConfigureBusNumbers(
    PPCI_FDO_EXTENSION Parent
    )

/*++

Routine Description:

    This routine is called after scanning a PCI bus (root or bridge) and
    configures the bus numbers for any newly encountered bridges if possible.

    Any unconfigurable bridges will be set to Primary = Secondary = Subordinate = 0
    and their IO, Memory and BusMaster bits will be disabled.  When PCI is later
    asked to Add to them it will fail.

    The Parent->Mutex lock should be held before calling this function

Arguments:

    Parent - The bridge we have just enumerated.

Return Value:

    Status.

--*/

{
    PPCI_PDO_EXTENSION current, parentPdo = NULL;
    UCHAR bridgeCount = 0, configuredBridgeCount = 0;

    PAGED_CODE();

    if (!PCI_IS_ROOT_FDO(Parent)) {
        parentPdo = (PPCI_PDO_EXTENSION)Parent->PhysicalDeviceObject->DeviceExtension;
    }

    //
    // Walk the list of child PDO's for this bus and count the number of
    // bridges and configured bridges
    //
    ExAcquireFastMutex(&Parent->ChildListMutex);

    for (current = Parent->ChildBridgePdoList;
         current;
         current = current->NextBridge) {

        if (current->NotPresent) {
            PciDebugPrint(PciDbgBusNumbers,
                          "Skipping not present bridge PDOX @ %p\n",
                          current
                         );
            continue;
        }

        bridgeCount++;

        //
        // If we configured the parent then all the children are considered
        // to be unconfigured.  Root buses are always configured
        //

        if ((parentPdo &&
             parentPdo->Dependent.type1.WeChangedBusNumbers &&
             (current->DeviceState == PciNotStarted))
             || (!PciAreBusNumbersConfigured(current))) {

            //
            // Disable this bridge and we will fix it later
            //
            PciDisableBridge(current);

        } else {

            //
            // The bios must have configured this bridge and it looks valid so
            // leave it alone!
            //

            configuredBridgeCount++;
        }
    }

    ExReleaseFastMutex(&Parent->ChildListMutex);

    //
    // Now there are four posibilities...
    //

    if (bridgeCount == 0) {

        //
        // There are no bridges so not a lot to do...
        //

        PciDebugPrint(PciDbgBusNumbers,
                      "PCI - No bridges found on bus 0x%x\n",
                      Parent->BaseBus
                     );


    } else if (bridgeCount == configuredBridgeCount) {

        //
        // All the bridges are configured - still not a lot to do...
        //

        PciDebugPrint(PciDbgBusNumbers,
              "PCI - 0x%x bridges found on bus 0x%x - all already configured\n",
             bridgeCount,
             Parent->BaseBus
             );


    } else if (configuredBridgeCount == 0) {

        PciDebugPrint(PciDbgBusNumbers,
              "PCI - 0x%x bridges found on bus 0x%x - all need configuration\n",
             bridgeCount,
             Parent->BaseBus
             );

        //
        // All the bridges require configuration so we should use a spreading
        // out algorithm
        //

        PciSpreadBridges(Parent, bridgeCount);

    } else {

        //
        // Some of the bridges are configured and some are not - we should try
        // to fit the unconfigured ones into the holes left by the configured
        // ones
        //

        ASSERT(configuredBridgeCount < bridgeCount);

        PciDebugPrint(PciDbgBusNumbers,
              "PCI - 0x%x bridges found on bus 0x%x - 0x%x need configuration\n",
             bridgeCount,
             Parent->BaseBus,
             bridgeCount - configuredBridgeCount
             );


        //
        // Walk the list of PDO's again and configure each one seperatly
        //

        for (current = Parent->ChildBridgePdoList;
             current;
             current = current->NextBridge) {

            if (current->NotPresent) {
                PciDebugPrint(PciDbgBusNumbers,
                              "Skipping not present bridge PDOX @ %p\n",
                              current
                             );
                continue;
            }

            //
            // Fit the bridge if we disabled it.
            //

            if ((parentPdo &&
                 parentPdo->Dependent.type1.WeChangedBusNumbers &&
                 (current->DeviceState == PciNotStarted))
                 || (!PciAreBusNumbersConfigured(current))) {

                ASSERT(current->Dependent.type1.PrimaryBus == 0
                       && current->Dependent.type1.SecondaryBus == 0
                       && current->Dependent.type1.SubordinateBus == 0
                       );

                PciFitBridge(Parent, current);
            }
        }
    }
}



BOOLEAN
PciAreBusNumbersConfigured(
    IN PPCI_PDO_EXTENSION Bridge
    )
/*++

Routine Description:

    This checks if the bus numbers assigned to the bridge are valid

Arguments:

    Bridge - the bridge to check

Return Value:

    TRUE if numbers are valid FALSE otherwise.

--*/

{
    PAGED_CODE();

    //
    // Check this bridge is configured to run on the bus we found it.
    //

    if (Bridge->Dependent.type1.PrimaryBus != Bridge->ParentFdoExtension->BaseBus) {
        return FALSE;
    }

    //
    // Ensure the child bus number is greater than the parent bus.
    // (HP Omnibooks actually break this rule when not plugged into
    // their docking stations).
    //

    if (Bridge->Dependent.type1.SecondaryBus <= Bridge->Dependent.type1.PrimaryBus) {
        return FALSE;
    }

    //
    // And finally, make sure the secondary bus is in the range
    // of busses the bridge is programmed for.  Paranoia.
    //

    if (Bridge->Dependent.type1.SubordinateBus < Bridge->Dependent.type1.SecondaryBus) {
        return FALSE;
    }

    return TRUE;
}



VOID
PciSpreadBridges(
    IN PPCI_FDO_EXTENSION Parent,
    IN UCHAR BridgeCount
    )

/*++

Routine Description:

    This routine attemps to spread out the available bus numbers between the
    unconfigured bridges.  It is only called if ALL the bridges on a particular
    bus are not configured - eg we just hot docked!

    If a particular brigde can not be configured it is disabled (Decodes OFF and
    bus number 0->0-0) and the subsequent AddDevice will fail.

Arguments:

    Parent - The FDO extension for the bridge we are enumerating.

    BridgeCount - The number of bridges at this level

Return Value:

    None

--*/

{
    UCHAR base, limit, numberCount, currentNumber, spread, maxAssigned = 0;
    PPCI_PDO_EXTENSION current;
    BOOLEAN outOfNumbers = FALSE;

    PAGED_CODE();

    ASSERT(Parent->BaseBus < PCI_MAX_BRIDGE_NUMBER);

    //
    // Seeing as we only get here if all the bridges arn't configured the base
    // is the lowest bus out parent passes
    //

    base = (UCHAR)Parent->BaseBus;

    //
    // The limit is constrained by the siblings of the parent bridge or in the
    // case that there are none, by the siblings of the parent's parent and so on
    // until we find a sibling or run out of buses in which case the constraint
    // is the maximum bus number passed by this root.
    //

    limit = PciFindBridgeNumberLimit(Parent, base);

    if (limit < base) {
        //
        // This normally means the BIOS or HAL messed up and got the subordinate
        // bus number for the root bus wrong.  There's not much we can do..
        //

        ASSERT(limit >= base);

        return;
    }

    //
    // Now see if we have enough numbers available to number all the busses
    //

    numberCount = limit - base;

    if (numberCount == 0) {
        //
        // We don't have any bus numbers available - bail now
        //
        return;

    } else if (BridgeCount >= numberCount) {
        //
        // We have just/not enough - don't spread things out!
        //
        spread = 1;

    } else {

        //
        // Try and spread things out a bit so we can accomodate subordinate
        // bridges of the one we are configuring.  Also leave some space on the
        // parent bus for any bridges that appear here (the + 1).  As we have no idea
        // what is behind each bridge treat them equally...
        //

        spread = numberCount / (BridgeCount + 1);
    }

    //
    // Now assign the bus numbers - we have already disabled all the unconfigured
    // bridges
    //
    currentNumber = base + 1;

    for (current = Parent->ChildBridgePdoList;
         current;
         current = current->NextBridge) {

        if (current->NotPresent) {
            PciDebugPrint(PciDbgBusNumbers,
                          "Skipping not present bridge PDOX @ %p\n",
                          current
                         );
            continue;
        }


        //
        // Now go and write it out to the hardware
        //

        ASSERT(!PciAreBusNumbersConfigured(current));

        //
        // Primary is the bus we are on, secondary is our bus number.
        // We don't know if there are any bridges there - we have left space
        // just in case - therefore we don't pass any bus numbers.  If we
        // need to, the subordinate number can be updated later.
        //

        PciSetBusNumbers(current,
                         base,
                         currentNumber,
                         currentNumber
                         );

        //
        // Remember the max number we assigned
        //

        maxAssigned = currentNumber;

        //
        // Check if we have run out of numbers
        //

        if ((currentNumber + spread) < currentNumber // wrapped
        ||  (currentNumber + spread) > limit) {

            break;

        } else {
            //
            // Move onto the next number
            //
            currentNumber += spread;

        }
    }

    //
    // Now we have programmed the bridges - we need to go back and update the
    // subordinate bus numbers for all ancestor bridges.
    //

    ASSERT(maxAssigned > 0);

    PciUpdateAncestorSubordinateBuses(Parent, maxAssigned);

}

UCHAR
PciFindBridgeNumberLimitWorker(
    IN PPCI_FDO_EXTENSION BridgeParent,
    IN PPCI_FDO_EXTENSION CurrentParent,
    IN UCHAR Base,
    OUT PBOOLEAN RootConstrained
    )

/*++

Routine Description:

    This determines the subordinate bus number a bridge on the bus BridgeParent
    with secondary number Base can have given the constraints of the configured
    busses in the system.

Arguments:

    BridgeParent - The bus on which the bridge resides

    CurrentParent - The current bridge we are looking at (used for synchronization)

    Base - The primary bus number of this bridge (ie the parent's secondary bus number)

    Constraint - The number of the bus that constrains us

    RootConstrained - Set to TRUE if we were constrained by a root appeture, FALSE
        if constrained by another bridge

Return Value:

    None

--*/
{
    PPCI_PDO_EXTENSION current;
    UCHAR currentNumber, closest = 0;

    PAGED_CODE();

    if (BridgeParent != CurrentParent) {

        //
        // We're going to mess with the child pdo list - lock the state...
        //
        ExAcquireFastMutex(&CurrentParent->ChildListMutex);
    }

    //
    // Look for any bridge that will constrain us
    //

    for (current = CurrentParent->ChildBridgePdoList;
         current;
         current = current->NextBridge) {

        if (current->NotPresent) {
            PciDebugPrint(PciDbgBusNumbers,
                          "Skipping not present bridge PDOX @ %p\n",
                          current
                         );
            continue;
        }

        //
        // Unconfigured bridges can't constrain us
        //

        if (!PciAreBusNumbersConfigured(current)) {
            continue;
        }

        currentNumber = current->Dependent.type1.SecondaryBus;

        if (currentNumber > Base
        && (currentNumber < closest || closest == 0)) {
            closest = currentNumber;
        }
    }


    //
    // If we haven't found a closest bridge then move up one level - yes this
    // is recursive but is bounded by the depth of the pci tree is the best way
    // of dealing with the hierarchial locking.
    //
    if (closest == 0) {

        if (CurrentParent->ParentFdoExtension == NULL) {

            //
            // We have reached the root without finding a sibling
            //

            *RootConstrained = TRUE;
            closest = CurrentParent->MaxSubordinateBus;

        } else {

            closest = PciFindBridgeNumberLimitWorker(BridgeParent,
                                                     CurrentParent->ParentFdoExtension,
                                                     Base,
                                                     RootConstrained
                                                     );
        }

    } else {

        //
        // We are constrained by a bridge so by definition not by a root.
        //

        *RootConstrained = FALSE;
    }

    if (BridgeParent != CurrentParent) {

        ExReleaseFastMutex(&CurrentParent->ChildListMutex);
    }

    return closest;

}

UCHAR
PciFindBridgeNumberLimit(
    IN PPCI_FDO_EXTENSION Bridge,
    IN UCHAR Base
    )

/*++

Routine Description:

    This determines the subordinate bus number a bridge on the bus BridgeParent
    with secondary number Base can have given the constraints of the configured
    busses in the system.

Arguments:

    BridgeParent - The bus on which the bridge resides

    Base - The primary bus number of this bridge (ie the parent's secondary bus number)

Return Value:

    The max subordinate value.

--*/
{

    BOOLEAN rootConstrained;
    UCHAR constraint;

    PAGED_CODE();

    constraint = PciFindBridgeNumberLimitWorker(Bridge,
                                                Bridge,
                                                Base,
                                                &rootConstrained
                                                );



    if (rootConstrained) {

        //
        // We are constrained by the maximum bus number that this root bus passes
        // - this is therefore the max subordinate bus.
        //

        return constraint;

    } else {

        //
        // If we are not constrained by a root bus we must be constrained by a
        // bridge and thus the max subordinate value we can assign to the bus is
        // one less that the bridge that constrained us. (A bridge must have a
        // bus number greater that 1 so we can't wrap)
        //

        ASSERT(constraint > 0);
        return constraint - 1;
    }
}

VOID
PciFitBridge(
    IN PPCI_FDO_EXTENSION Parent,
    IN PPCI_PDO_EXTENSION Bridge
    )
/*++

Routine Description:

    This routine attemps to find a range of bus numbers for Bridge given the
    constraints of the already configured bridges.

    If a particular brigde can not be configured it is disabled (Decodes OFF and
    bus number 0->0-0) and the subsequent AddDevice will fail.

Arguments:

    Parent - The FDO extension for the bridge we are enumerating.

    Bridge - The brige we want to configure

Return Value:

    None

--*/

{
    PPCI_PDO_EXTENSION current;
    UCHAR base, limit, gap, bestBase = 0, biggestGap = 0, lowest = 0xFF;

    PAGED_CODE();

    for (current = Parent->ChildBridgePdoList;
         current;
         current = current->NextBridge) {

        if (current->NotPresent) {
            PciDebugPrint(PciDbgBusNumbers,
                          "Skipping not present bridge PDOX @ %p\n",
                          current
                         );
            continue;
        }


        //
        // Only look at configured bridges - buses we disabled have
        // bus numbers 0->0-0 which is helpfully invalid
        //

        if (PciAreBusNumbersConfigured(current)) {

            //
            // Get the base and limit for each bridge and calculate which bridge
            // has the biggest gap.
            //

            base = (UCHAR) current->Dependent.type1.SubordinateBus;
            limit = PciFindBridgeNumberLimit(Parent, base);

            //
            // This ASSERT might fail if a BIOS or HAL misreported the limits
            // of a root bridge. For example, an ACPI BIOS might have a _CRS
            // for the root bridge that specifies bus-numbers 0 to 0 (length 1)
            // are passed down, even though the real range is 0 to 255.
            //

            ASSERT(limit >= base);

            gap = limit - base;

            if (gap > biggestGap) {

                ASSERT(gap > 0);

                biggestGap = gap;
                bestBase = base + 1;
            }

            if (current->Dependent.type1.SecondaryBus < lowest) {
                lowest = current->Dependent.type1.SecondaryBus;
            }
        }
    }

    //
    // Now make sure the gap between the bus we are on and the first bridge
    // is not the biggest - lowest must always be greater that the parents bus
    // number or it is miss configured and would have failed the
    // BusNumbersConfigured test above.
    //

    ASSERT(lowest > Parent->BaseBus);

    gap = lowest - (Parent->BaseBus + 1);

    if (gap > biggestGap) {

        ASSERT(gap > 0);

        biggestGap = gap;
        bestBase = Parent->BaseBus + 1;
    }

    //
    // Did we find anywhere to put the bridge?
    //

    if (biggestGap >= 1) {

        //
        // Ok - we have some space to play with so we can configure out bridge
        // right in the middle of the gap, if the bestGap is 1 (ie the bridge
        // just fits) then this still works.
        //

        base = bestBase + (biggestGap / 2);

        //
        // Set subordinate equal to secondary as we are just leaving room for
        // any bridges.
        //

        PciSetBusNumbers(Bridge, Parent->BaseBus, base, base);

        //
        // Update the ancestor subordinates if we configured the bridge
        //

        PciUpdateAncestorSubordinateBuses(Parent,
                                          Bridge->Dependent.type1.SecondaryBus
                                          );

    }
}

VOID
PciSetBusNumbers(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN UCHAR Primary,
    IN UCHAR Secondary,
    IN UCHAR Subordinate
    )
/*++

Routine Description:

    This routine sets the bus numbers for a bridge and tracks if we have changed
    bus numbers.

Arguments:

    PdoExtension - The PDO for the bridge

    Primary - The primary bus number to assign

    Secondary - The secondary bus number to assign

    Subordinate - The subordinate bus number to assign


Return Value:

    None

--*/

{
    PCI_COMMON_HEADER commonHeader;
    PPCI_COMMON_CONFIG commonConfig = (PPCI_COMMON_CONFIG)&commonHeader;

    PAGED_CODE();

    ASSERT(Primary < Secondary || (Primary == 0 && Secondary == 0));
    ASSERT(Secondary <= Subordinate);

    //
    // Fill in in the config. Note that the Primary/Secondary/Subordinate bus
    // numbers are in the same place for type1 and type2 headers.
    //

    commonConfig->u.type1.PrimaryBus = Primary;
    commonConfig->u.type1.SecondaryBus = Secondary;
    commonConfig->u.type1.SubordinateBus = Subordinate;

    //
    // Grab the PCI Bus lock - this will let hwverifier reliably check the
    // config space against our extension.
    //

    ExAcquireFastMutex(&PciBusLock);

    //
    // Remember in the PDO
    //

    PdoExtension->Dependent.type1.PrimaryBus = Primary;
    PdoExtension->Dependent.type1.SecondaryBus = Secondary;
    PdoExtension->Dependent.type1.SubordinateBus = Subordinate;
    PdoExtension->Dependent.type1.WeChangedBusNumbers = TRUE;

    PciWriteDeviceConfig(
        PdoExtension,
        &commonConfig->u.type1.PrimaryBus,
        FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.PrimaryBus),
        sizeof(Primary) + sizeof(Secondary) + sizeof(Subordinate)
        );

    ExReleaseFastMutex(&PciBusLock);
}


VOID
PciUpdateAncestorSubordinateBuses(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN UCHAR Subordinate
    )
/*++

Routine Description:

    This routine walks the bridge hierarchy updating the subordinate bus numbers
    of each ancestor to ensure that numbers up to Subordinate are passed.

Arguments:

    FdoExtension - The Fdo for the parent of the bridge(s) we have just configured

    Subordinate - The maximum (subordinate) bus number to pass


Return Value:

    None

--*/

{
    PPCI_FDO_EXTENSION current;
    PPCI_PDO_EXTENSION currentPdo;

    PAGED_CODE();

    //
    // For all ancestors except the root update the subordinate bus number
    //

    for (current = FdoExtension;
         current->ParentFdoExtension;  // Root has no parent
         current = current->ParentFdoExtension) {

        currentPdo = (PPCI_PDO_EXTENSION)current->PhysicalDeviceObject->DeviceExtension;

        ASSERT(!currentPdo->NotPresent);

        if (currentPdo->Dependent.type1.SubordinateBus < Subordinate) {

            currentPdo->Dependent.type1.SubordinateBus = Subordinate;

            PciWriteDeviceConfig(currentPdo,
                                  &Subordinate,
                                  FIELD_OFFSET(PCI_COMMON_CONFIG,
                                               u.type1.SubordinateBus),
                                  sizeof(Subordinate)
                                  );

        }
    }

    //
    // Ok so now we're at the root - can't be too careful on a checked build
    // so lets make sure the subordinate value we came up with actually gets
    // down this root...
    //

    ASSERT(PCI_IS_ROOT_FDO(current));
    ASSERT(Subordinate <= current->MaxSubordinateBus);

}

VOID
PciDisableBridge(
    IN PPCI_PDO_EXTENSION Bridge
    )

/*++

Routine Description:

    This routine disables a bridge by turing of its decodes and zeroing its
    bus numbers.

Arguments:

    PdoExtension - The PDO for the bridge

Return Value:

    node
--*/


{
    PAGED_CODE();

    ASSERT(Bridge->DeviceState == PciNotStarted);

    //
    // Zero all the bus numbers so we shouldn't pass any config cycles
    //

    PciSetBusNumbers(Bridge, 0, 0, 0);

    // NTRAID #62594 - 04/03/2000 - andrewth
    // Close the windows in case this is the VGA bridge which we must
    // leave decoding...

    //
    // Turn off the decodes so we don't pass IO or Memory cycles and bus
    // master so we don't generate any
    //

    PciDecodeEnable(Bridge, FALSE, NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\ar_memio.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    ar_memio.c

Abstract:

    This module implements the PCI Memory and IO resource Arbiters.
    Most functionality for these two arbiters is common and distinguished
    by the "context".

Author:

    Andrew Thornton (andrewth)  21-May-1997

Revision History:

--*/

#include "pcip.h"

#define BUGFEST_HACKS

#define ARMEMIO_VERSION 0

//
// Flags for WorkSpace
//
#define PORT_ARBITER_PREPROCESSED               0x00000001
#define PORT_ARBITER_IMPROVISED_DECODE          0x00000002
#define PORT_ARBITER_ISA_BIT_SET                0x00000004
#define PORT_ARBITER_BRIDGE_WINDOW              0x00000008

//
// ALLOCATE_ALIASES - this turns on the allocation of 10 & 12 bit decoded
// aliases.
//

#define ALLOCATE_ALIASES                        1
#define IGNORE_PREFETCH_FOR_LEGACY_REPORTED     1
#define PASSIVE_DECODE_SUPPORTED                1
#define PREFETCHABLE_SUPPORTED                  1
#define ISA_BIT_SUPPORTED                       1

//
// Flags for range attributes
//

#define MEMORY_RANGE_ROM                        0x10


//
// Constants
//

#define PCI_BRIDGE_WINDOW_GRANULARITY   0x1000
#define PCI_BRIDGE_ISA_BIT_STRIDE       0x400
#define PCI_BRIDGE_ISA_BIT_WIDTH        0x100
#define PCI_BRIDGE_ISA_BIT_MAX          0xFFFF
            
//
// Static data
//

ARBITER_ORDERING PciBridgeOrderings[] = {
    { 0x10000, MAXULONGLONG },
    { 0,       0xFFFF }
};

ARBITER_ORDERING_LIST PciBridgeOrderingList = {
    sizeof(PciBridgeOrderings) / sizeof (ARBITER_ORDERING),
    sizeof(PciBridgeOrderings) / sizeof (ARBITER_ORDERING),
    PciBridgeOrderings
};

//
// Prototypes for routines exposed only thru the "interface"
// mechanism.
//

NTSTATUS
ario_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

NTSTATUS
ario_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

NTSTATUS
armem_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

NTSTATUS
armem_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

PCI_INTERFACE ArbiterInterfaceMemory = {
    &GUID_ARBITER_INTERFACE_STANDARD,       // InterfaceType
    sizeof(ARBITER_INTERFACE),              // MinSize
    ARMEMIO_VERSION,                        // MinVersion
    ARMEMIO_VERSION,                        // MaxVersion
    PCIIF_FDO,                              // Flags
    0,                                      // ReferenceCount
    PciArb_Memory,                          // Signature
    armem_Constructor,                      // Constructor
    armem_Initializer                       // Instance Initializer
};

PCI_INTERFACE ArbiterInterfaceIo = {
    &GUID_ARBITER_INTERFACE_STANDARD,       // InterfaceType
    sizeof(ARBITER_INTERFACE),              // MinSize
    ARMEMIO_VERSION,                        // MinVersion
    ARMEMIO_VERSION,                        // MaxVersion
    PCIIF_FDO,                              // Flags
    0,                                      // ReferenceCount
    PciArb_Io,                              // Signature
    ario_Constructor,                       // Constructor
    ario_Initializer                        // Instance Initializer
};

//
// Arbiter helper functions.
//

NTSTATUS
armemio_UnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
armemio_PackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
armemio_UnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );

NTSTATUS
armemio_ScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

VOID
ario_BacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );

BOOLEAN
ario_FindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
ario_GetNextAlias(
    ULONG IoDescriptorFlags,
    ULONGLONG LastAlias,
    PULONGLONG NextAlias
    );

BOOLEAN
ario_IsAliasedRangeAvailable(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

VOID
ario_AddAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
ario_OverrideConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
ario_PreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
armem_StartArbiter(
    IN PARBITER_INSTANCE Arbiter,
    IN PCM_RESOURCE_LIST StartResources
    );

NTSTATUS
armem_PreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
armem_GetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
ario_GetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
ario_StartArbiter(
    IN PARBITER_INSTANCE Arbiter,
    IN PCM_RESOURCE_LIST StartResources
    );

VOID
ario_AddOrBacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State,
     IN PARBITER_BACKTRACK_ALLOCATION Callback
     );

BOOLEAN
armem_FindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, ario_Constructor)
#pragma alloc_text(PAGE, armem_Constructor)
#pragma alloc_text(PAGE, ario_Initializer)
#pragma alloc_text(PAGE, armem_Initializer)
#pragma alloc_text(PAGE, armemio_UnpackRequirement)
#pragma alloc_text(PAGE, armemio_PackResource)
#pragma alloc_text(PAGE, armemio_UnpackResource)
#pragma alloc_text(PAGE, armemio_ScoreRequirement)
#pragma alloc_text(PAGE, ario_OverrideConflict)
#pragma alloc_text(PAGE, ario_BacktrackAllocation)
#pragma alloc_text(PAGE, ario_GetNextAlias)
#pragma alloc_text(PAGE, ario_FindSuitableRange)
#pragma alloc_text(PAGE, ario_GetNextAlias)
#pragma alloc_text(PAGE, ario_IsAliasedRangeAvailable)
#pragma alloc_text(PAGE, ario_AddAllocation)
#pragma alloc_text(PAGE, ario_PreprocessEntry)
#pragma alloc_text(PAGE, armem_StartArbiter)
#pragma alloc_text(PAGE, armem_PreprocessEntry)
#pragma alloc_text(PAGE, armem_GetNextAllocationRange)
#pragma alloc_text(PAGE, ario_AddOrBacktrackAllocation)
#pragma alloc_text(PAGE, armem_FindSuitableRange)

#endif

//
// Prefetchable memory support.
//
// Prefetchable memory is device memory that can be treated like normal memory
// in that reads have no side effects and we can combine writes.  The
// CM_RESOURCE_MEMORY_PREFETCHABLE flag means that the device would *like*
// prefetchable memory but normal memory is just fine as well.
//



NTSTATUS
ario_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Check the InterfaceSpecificData to see if this is the correct
    arbiter (we already know the required interface is an arbiter
    from the GUID) and if so, allocate (and reference) a context
    for this interface.

Arguments:

    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    InterfaceSpecificData
                    A ULONG containing the resource type for which
                    arbitration is required.
    InterfaceReturn

Return Value:

    TRUE is this device is not known to cause problems, FALSE
    if the device should be skipped altogether.

--*/

{
    PARBITER_INTERFACE arbiterInterface;
    NTSTATUS status;

    PAGED_CODE();

    //
    // This arbiter handles I/O ports, is that what they want?
    //

    if ((ULONG_PTR)InterfaceSpecificData != CmResourceTypePort) {

        //
        // No, it's not us then.
        //

        return STATUS_INVALID_PARAMETER_5;
    }

    //
    // Have already verified that the InterfaceReturn variable
    // points to an area in memory large enough to contain an
    // ARBITER_INTERFACE.  Fill it in for the caller.
    //

    arbiterInterface = (PARBITER_INTERFACE)InterfaceReturn;

    arbiterInterface->Size                 = sizeof(ARBITER_INTERFACE);
    arbiterInterface->Version              = ARMEMIO_VERSION;
    arbiterInterface->InterfaceReference   = PciReferenceArbiter;
    arbiterInterface->InterfaceDereference = PciDereferenceArbiter;
    arbiterInterface->ArbiterHandler       = ArbArbiterHandler;
    arbiterInterface->Flags                = 0;

    status = PciArbiterInitializeInterface(DeviceExtension,
                                           PciArb_Io,
                                           arbiterInterface);

    return status;
}

NTSTATUS
armem_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Check the InterfaceSpecificData to see if this is the correct
    arbiter (we already know the required interface is an arbiter
    from the GUID) and if so, allocate (and reference) a context
    for this interface.

Arguments:

    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    InterfaceSpecificData
                    A ULONG containing the resource type for which
                    arbitration is required.
    InterfaceReturn

Return Value:

    TRUE is this device is not known to cause problems, FALSE
    if the device should be skipped altogether.

--*/

{
    PARBITER_INTERFACE arbiterInterface;
    NTSTATUS status;

    PAGED_CODE();

    //
    // This arbiter handles memory, is that what they want?
    //

    if ((ULONG_PTR)InterfaceSpecificData != CmResourceTypeMemory) {

        //
        // No, it's not us then.
        //

        return STATUS_INVALID_PARAMETER_5;
    }

    //
    // Have already verified that the InterfaceReturn variable
    // points to an area in memory large enough to contain an
    // ARBITER_INTERFACE.  Fill it in for the caller.
    //

    arbiterInterface = (PARBITER_INTERFACE)InterfaceReturn;

    arbiterInterface->Size                 = sizeof(ARBITER_INTERFACE);
    arbiterInterface->Version              = ARMEMIO_VERSION;
    arbiterInterface->InterfaceReference   = PciReferenceArbiter;
    arbiterInterface->InterfaceDereference = PciDereferenceArbiter;
    arbiterInterface->ArbiterHandler       = ArbArbiterHandler;
    arbiterInterface->Flags                = 0;

    status = PciArbiterInitializeInterface(DeviceExtension,
                                           PciArb_Memory,
                                           arbiterInterface);

    return status;
}

NTSTATUS
armem_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )

/*++

Routine Description:

    This routine is called once per instantiation of an arbiter.
    Performs initialization of this instantiation's context.

Arguments:

    Instance        Pointer to the arbiter context.

Return Value:

    Returns the status of this operation.

--*/

{
    NTSTATUS status;

    RtlZeroMemory(&Instance->CommonInstance, sizeof(ARBITER_INSTANCE));

    PAGED_CODE();

    //
    // Set the Action Handler entry points.
    //

    Instance->CommonInstance.UnpackRequirement = armemio_UnpackRequirement;
    Instance->CommonInstance.PackResource      = armemio_PackResource;
    Instance->CommonInstance.UnpackResource    = armemio_UnpackResource;
    Instance->CommonInstance.ScoreRequirement  = armemio_ScoreRequirement;

    Instance->CommonInstance.FindSuitableRange = armem_FindSuitableRange;

#if PREFETCHABLE_SUPPORTED

    Instance->CommonInstance.PreprocessEntry   = armem_PreprocessEntry;
    Instance->CommonInstance.StartArbiter      = armem_StartArbiter;
    Instance->CommonInstance.GetNextAllocationRange
                                               = armem_GetNextAllocationRange;


    //
    // NTRAID #54671 - 2000/03/31 - andrewth
    // When reference counting is working we need to release this
    // extension when we dereference the arbiter to 0
    //

    //
    // Allocate and zero the arbiter extension, it is initialized in
    // armem_StartArbiter
    //

    Instance->CommonInstance.Extension
        = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, sizeof(ARBITER_MEMORY_EXTENSION));

    if (!Instance->CommonInstance.Extension) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(Instance->CommonInstance.Extension,
                  sizeof(ARBITER_MEMORY_EXTENSION)
                  );

#endif // PREFETCHABLE_SUPPORTED

    //
    // Initialize the rest of the common instance
    //

    return ArbInitializeArbiterInstance(&Instance->CommonInstance,
                                        Instance->BusFdoExtension->FunctionalDeviceObject,
                                        CmResourceTypeMemory,
                                        Instance->InstanceName,
                                        L"Pci",
                                        NULL
                                        );

}

NTSTATUS
ario_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )

/*++

Routine Description:

    This routine is called once per instantiation of an arbiter.
    Performs initialization of this instantiation's context.

Arguments:

    Instance        Pointer to the arbiter context.

Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();

    ASSERT(!(Instance->BusFdoExtension->BrokenVideoHackApplied));
    RtlZeroMemory(&Instance->CommonInstance, sizeof(ARBITER_INSTANCE));



    //
    // Set the Action Handler entry points.
    //

#if ALLOCATE_ALIASES

    Instance->CommonInstance.PreprocessEntry      = ario_PreprocessEntry;
    Instance->CommonInstance.FindSuitableRange    = ario_FindSuitableRange;
    Instance->CommonInstance.AddAllocation        = ario_AddAllocation;
    Instance->CommonInstance.BacktrackAllocation  = ario_BacktrackAllocation;

#endif

#if PASSIVE_DECODE_SUPPORTED

    Instance->CommonInstance.OverrideConflict     = ario_OverrideConflict;

#endif

#if ISA_BIT_SUPPORTED

    Instance->CommonInstance.GetNextAllocationRange = ario_GetNextAllocationRange;
    Instance->CommonInstance.StartArbiter           = ario_StartArbiter;
#endif

    Instance->CommonInstance.UnpackRequirement = armemio_UnpackRequirement;
    Instance->CommonInstance.PackResource      = armemio_PackResource;
    Instance->CommonInstance.UnpackResource    = armemio_UnpackResource;
    Instance->CommonInstance.ScoreRequirement  = armemio_ScoreRequirement;

    //
    // Initialize the rest of the common instance
    //

    return ArbInitializeArbiterInstance(&Instance->CommonInstance,
                                        Instance->BusFdoExtension->FunctionalDeviceObject,
                                        CmResourceTypePort,
                                        Instance->InstanceName,
                                        L"Pci",
                                        NULL
                                        );
}

NTSTATUS
armemio_UnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

Routine Description:

    This routine unpacks an resource requirement descriptor.

Arguments:

    Descriptor - The descriptor describing the requirement to unpack.

    Minimum - Pointer to where the minimum acceptable start value should be
        unpacked to.

    Maximum - Pointer to where the maximum acceptable end value should be
        unpacked to.

    Length - Pointer to where the required length should be unpacked to.

    Minimum - Pointer to where the required alignment should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    NTSTATUS    status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(Descriptor);
    ASSERT((Descriptor->Type == CmResourceTypePort) ||
           (Descriptor->Type == CmResourceTypeMemory));

    *Minimum = (ULONGLONG)Descriptor->u.Generic.MinimumAddress.QuadPart;
    *Maximum = (ULONGLONG)Descriptor->u.Generic.MaximumAddress.QuadPart;
    *Length = Descriptor->u.Generic.Length;
    *Alignment = Descriptor->u.Generic.Alignment;

    //
    // Fix the broken hardware that reports 0 alignment
    //

    if (*Alignment == 0) {
        *Alignment = 1;
    }

    //
    // Fix broken INF's that report they support 24bit memory > 0xFFFFFF
    //

    if (Descriptor->Type == CmResourceTypeMemory
    && Descriptor->Flags & CM_RESOURCE_MEMORY_24
    && Descriptor->u.Memory.MaximumAddress.QuadPart > 0xFFFFFF) {
        if (Descriptor->u.Memory.MinimumAddress.QuadPart > 0xFFFFFF) {
            PciDebugPrintf(0, "24 bit decode specified but both min and max are greater than 0xFFFFFF, most probably due to broken INF!\n");
            ASSERT(Descriptor->u.Memory.MinimumAddress.QuadPart <= 0xFFFFFF);
            status = STATUS_UNSUCCESSFUL;
        } else {
            *Maximum = 0xFFFFFF;
        }
    }

    return status;
}

NTSTATUS
armemio_PackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs an resource descriptor.

Arguments:

    Requirement - The requirement from which this resource was chosen.

    Start - The start value of the resource.

    Descriptor - Pointer to the descriptor to pack into.

Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();

    ASSERT(Descriptor);
    ASSERT(Requirement);
    ASSERT((Requirement->Type == CmResourceTypePort) ||
           (Requirement->Type == CmResourceTypeMemory));

    Descriptor->Type = Requirement->Type;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->u.Generic.Start.QuadPart = Start;
    Descriptor->u.Generic.Length = Requirement->u.Generic.Length;

    return STATUS_SUCCESS;
}

NTSTATUS
armemio_UnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks an resource descriptor.

Arguments:

    Descriptor - The descriptor describing the resource to unpack.

    Start - Pointer to where the start value should be unpacked to.

    End - Pointer to where the end value should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();

    ASSERT(Descriptor);
    ASSERT(Start);
    ASSERT(Length);
    ASSERT((Descriptor->Type == CmResourceTypePort) ||
           (Descriptor->Type == CmResourceTypeMemory));

    *Start = Descriptor->u.Generic.Start.QuadPart;
    *Length= Descriptor->u.Generic.Length;

    return STATUS_SUCCESS;
}

LONG
armemio_ScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine scores a requirement based on how flexible it is.  The least
    flexible devices are scored the least and so when the arbitration list is
    sorted we try to allocate their resources first.

Arguments:

    Descriptor - The descriptor describing the requirement to score.


Return Value:

    The score.

--*/

{
    LONG score;
    ULONGLONG start, end;
    ULONGLONG bigscore;
    ULONG alignment;

    PAGED_CODE();

    ASSERT(Descriptor);
    ASSERT((Descriptor->Type == CmResourceTypePort) ||
           (Descriptor->Type == CmResourceTypeMemory));

    alignment = Descriptor->u.Generic.Alignment;

    //
    // Fix the broken hardware that reports 0 alignment
    //
    if (alignment == 0) {
  
        //
        // Set this to 1 here, because we arbitrate ISA
        // devices in the context of PCI. If you don't understand
        // you don't want to. Trust me. (hint: subtractive decode)
        //
        // Any PCI device that has alignment 0 will also
        // have Length 0, which is horribly wrong to begin with.
        // and we deal with it elsewhere.
        //
        alignment = 1;
    }

    start = ALIGN_ADDRESS_UP(
                Descriptor->u.Generic.MinimumAddress.QuadPart,
                alignment
                );

    end = Descriptor->u.Generic.MaximumAddress.QuadPart;

    //
    // The score is the number of possible allocations that could be made
    // given the alignment and length constraints
    //

    bigscore = (((end - Descriptor->u.Generic.Length + 1) - start)
                    / alignment) + 1;

    //
    // Note, the scores for each possibility are added together.  To
    // avoid overflowing the total, we need to limit the range returned.
    //
    // Make it a sort of logarithmic score.  Find the highest byte
    // set, weight it (add 0x100) and use the log (I said "sort of").
    //
    // This puts the result in the range 0xff80 down to 0x0100.
    //

    for (score = sizeof(bigscore) - 1; score >= 0; score--) {

        UCHAR v = *(((PUCHAR)&bigscore) + score);
        if (v != 0) {
            score = (v + 0x100) << score;
            break;
        }
    }

    //
    // The resulting TOTAL from scoring all the alternatives is used
    // to sort the list.  The highest total is considered the easiest
    // to place,....  which is probably true,... What if we got some-
    // thing like a single fit preferred setting followed by a fits
    // anywhere setting?   We don't want that to score higher than
    // another device which only specified the fit anywhere setting,
    // the preferred setting is harder to achieve.
    //
    // And, are two alternatives, each half as good an a 'fit anywhere'
    // as good as the 'fit anywhere'.  Not really.
    //
    // So, we weight the result even further depending on what options
    // are set in this resource.
    //

    if (Descriptor->Option &
                    (IO_RESOURCE_PREFERRED | IO_RESOURCE_ALTERNATIVE)) {
        score -= 0x100;
    }

    ARB_PRINT(
        3,
        ("  %s resource %08x(0x%I64x-0x%I64x) => %i\n",
        Descriptor->Type == CmResourceTypeMemory ? "Memory" : "Io",
        Descriptor,
        Descriptor->u.Generic.MinimumAddress.QuadPart,
        end,
        score
        ));

    return score;
}
VOID
ario_BacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     )

/*++

Routine Description:

    This routine is called from AllocateEntry if the possible solution
    (State->Start - State->End) does not allow us to allocate resources to
    the rest of the devices being considered.  It deletes the ranges that were
    added to Arbiter->PossibleAllocation by AddAllocation including those
    associated with ISA aliases.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    None.

--*/


{

    PAGED_CODE();

    ario_AddOrBacktrackAllocation(Arbiter,
                                  State,
                                  ArbBacktrackAllocation
                                  );


}

VOID
ario_AddOrBacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State,
     IN PARBITER_BACKTRACK_ALLOCATION Callback
     )

/*++

Routine Description:

    This relies on the fact that PARBITER_BACKTRACK_ALLOCATION and
    PARBITER_ADD_ALLOCATION are of the same type

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

    Backtrack - TRUE for backtrack, false for ADD

Return Value:

    None.

--*/

{
    NTSTATUS status;
    ARBITER_ALLOCATION_STATE localState;

    PAGED_CODE();

    ASSERT(Arbiter);
    ASSERT(State);

    //
    // We are going to mess with the state so make our own local copy
    //

    RtlCopyMemory(&localState, State, sizeof(ARBITER_ALLOCATION_STATE));

#if ISA_BIT_SUPPORTED

    //
    // Check if this is a window for a bridge with the ISA bit set that is
    // in 16 bit IO space.  If so we need to do some special processing
    //

    if (State->WorkSpace & PORT_ARBITER_BRIDGE_WINDOW
    &&  State->WorkSpace & PORT_ARBITER_ISA_BIT_SET
    &&  State->Start < 0xFFFF) {

        //
        // We don't support IO windows that straddle the 16/32 bit boundry
        //

        ASSERT(State->End <= 0xFFFF);

        //
        // If the ISA bit is set on a bridge it means that the bridge only
        // decodes the first 0x100 ports for each 0x400 ports in 16 bit IO space.
        // Just remove these to the range list.
        //

        for (;
             localState.Start < State->End && localState.Start < 0xFFFF;
             localState.Start += 0x400) {

            localState.End = localState.Start + 0xFF;

            Callback(Arbiter, &localState);

        }

        return;
    }

#endif

    //
    // Process the base range
    //

    Callback(Arbiter, State);

    //
    // Process any aliases with the alias flag set
    //

    ARB_PRINT(2, ("Adding aliases\n"));

    //
    // Lets see if we are processing positively decoded alases - yes you read that
    // right - on a PCI-PCI or Cardbus brigde with the VGA bit set (and seeing
    // as our friends now like AGP cards this is rather common) we decode all
    // VGA ranges together with their 10bit aliases.  This means that the normal
    // rules of engagement with aliases don't apply so don't set the alias bit.
    //

    if (!(State->CurrentAlternative->Descriptor->Flags & CM_RESOURCE_PORT_POSITIVE_DECODE)) {

        //
        // We're processing aliases so set the alias flag
        //
        localState.RangeAttributes |= ARBITER_RANGE_ALIAS;
    }

    while (ario_GetNextAlias(State->CurrentAlternative->Descriptor->Flags,
                             localState.Start,
                             &localState.Start)) {

        localState.End = localState.Start + State->CurrentAlternative->Length - 1;

        Callback(Arbiter, &localState);

    }
}



NTSTATUS
ario_PreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine is called from AllocateEntry to allow preprocessing of
    entries

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    None.

--*/
{

    PARBITER_ALTERNATIVE current;
    ULONG defaultDecode;
    BOOLEAN improviseDecode = FALSE, windowDetected = FALSE;
    ULONGLONG greatestPort = 0;
    PCI_OBJECT_TYPE type;
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();


    if (State->WorkSpace & PORT_ARBITER_PREPROCESSED) {

        //
        // We have already proprocessed this entry so don't repeat the work
        //
        return STATUS_SUCCESS;

    } else {
        State->WorkSpace |= PORT_ARBITER_PREPROCESSED;
    }

    //
    // Scan the alternatives and check if we have set any of the decode flags
    // are set or if we have to improvise
    //

    FOR_ALL_IN_ARRAY(State->Alternatives,
                     State->AlternativeCount,
                     current) {

        ASSERT(current->Descriptor->Type == CmResourceTypePort);
        ASSERT(current->Descriptor->Flags == State->Alternatives->Descriptor->Flags);

        //
        // Remember the greatest value we come across
        //

        if (current->Maximum > greatestPort) {
            greatestPort = current->Maximum;
        }

        //
        // Remember if we ever encounter a bridge window
        //

        if (current->Descriptor->Flags & CM_RESOURCE_PORT_WINDOW_DECODE) {
            //
            // If the request is marked with the window flag all alternatives
            // should also be marked with the window flag
            //
#if DBG
            if (current != State->Alternatives) {
                //
                // This is an alternative - make sure we have already set the
                // window detected flag
                //
                ASSERT(windowDetected);
            }
#endif
            windowDetected = TRUE;
        }

        if (!(current->Descriptor->Flags &
              (CM_RESOURCE_PORT_10_BIT_DECODE
               | CM_RESOURCE_PORT_12_BIT_DECODE
               | CM_RESOURCE_PORT_16_BIT_DECODE
               | CM_RESOURCE_PORT_POSITIVE_DECODE))) {

            improviseDecode = TRUE;

            // ASSERT(LEGACY_REQUEST(State->Entry->Source)

            if (!LEGACY_REQUEST(State->Entry)) {

                ARB_PRINT(0,
                          ("Pnp device (%p) did not specify decodes for IO ports\n",
                           State->Entry->PhysicalDeviceObject
                          ));


            }
        }
    }

    if (improviseDecode) {

        //
        // Remember we improvised this
        //

        State->WorkSpace |= PORT_ARBITER_IMPROVISED_DECODE;

        ARB_PRINT(1, ("Improvising decode "));

        //
        // Work out the default
        //

        switch (State->Entry->InterfaceType) {
        case PNPISABus:
        case Isa:

            //
            // if machine is NEC98, default decode is 16 bit.
            //

            if(IsNEC_98) {
                defaultDecode = CM_RESOURCE_PORT_16_BIT_DECODE;
                ARB_PRINT(1, ("of 16bit for NEC98 Isa\n"));
            } else {

                //
                // If any of the ports is greater than can be decoded in 10 bits
                // assume a 16 bit decode
                //
                if (greatestPort >= (1<<10)) {
                    defaultDecode = CM_RESOURCE_PORT_16_BIT_DECODE;
                    ARB_PRINT(1, ("of 16bit for Isa with ports > 0x3FF\n"));
                } else {
                    defaultDecode = CM_RESOURCE_PORT_10_BIT_DECODE;
                    ARB_PRINT(1, ("of 10bit for Isa\n"));
                }
            }

            break;

        case Eisa:
        case MicroChannel:
        case PCMCIABus:
            ARB_PRINT(1, ("of 16bit for Eisa/MicroChannel/Pcmcia\n"));
            defaultDecode = CM_RESOURCE_PORT_16_BIT_DECODE;
            break;

        case PCIBus:
            ARB_PRINT(1, ("of positive for PCI\n"));
            defaultDecode = CM_RESOURCE_PORT_POSITIVE_DECODE;
            break;

        default:

            //
            // In NT < 5 we considered everything to be 16 bit decode so in the
            // absence of better information continue that tradition.
            //

            ARB_PRINT(1, ("of 16bit for unknown bus\n"));

            defaultDecode = CM_RESOURCE_PORT_16_BIT_DECODE;
            break;
        }

        //
        // Now set the flags
        //

        FOR_ALL_IN_ARRAY(State->Alternatives,
                         State->AlternativeCount,
                         current) {

                current->Descriptor->Flags |= defaultDecode;
        }

    } else {

        //
        // Even if we are not improvising decodes make sure that they didn't
        // report 10 bit decode for a range over 0x3FF - if so we assume 16 bit
        // decode - think EISA net cards that say they're ISA
        //

        FOR_ALL_IN_ARRAY(State->Alternatives,
                         State->AlternativeCount,
                         current) {

            if ((current->Descriptor->Flags & CM_RESOURCE_PORT_10_BIT_DECODE)
            &&  (greatestPort >= (1<<10) )) {

                current->Descriptor->Flags &= ~CM_RESOURCE_PORT_10_BIT_DECODE;
                current->Descriptor->Flags |= CM_RESOURCE_PORT_16_BIT_DECODE;
            }
        }
    }

    //
    // If we detected a bridge window then check if the ISA bit is set on the bridge
    //

    if (windowDetected) {

        //
        // Make sure its a PCI bridge...
        //

        if (State->Entry->PhysicalDeviceObject->DriverObject != PciDriverObject) {
            ASSERT(State->Entry->PhysicalDeviceObject->DriverObject == PciDriverObject);
            return STATUS_INVALID_PARAMETER;
        }

        pdoExtension = (PPCI_PDO_EXTENSION) State->Entry->PhysicalDeviceObject->DeviceExtension;

        if (pdoExtension->ExtensionType != PciPdoExtensionType) {
            ASSERT(pdoExtension->ExtensionType == PciPdoExtensionType);
            return STATUS_INVALID_PARAMETER;
        }

        type = PciClassifyDeviceType(pdoExtension);

        if (type != PciTypePciBridge && type != PciTypeCardbusBridge) {
            ASSERT(type == PciTypePciBridge || type == PciTypeCardbusBridge);
            return STATUS_INVALID_PARAMETER;
        }

        if (pdoExtension->Dependent.type1.IsaBitSet) {

            if (type == PciTypePciBridge) {
                State->WorkSpace |= PORT_ARBITER_ISA_BIT_SET;
            } else {
                ASSERT(type == PciTypePciBridge);
            }
        }

        State->WorkSpace |= PORT_ARBITER_BRIDGE_WINDOW;
    }

    //
    // If this device is positive decode then we want the range to be added to
    // the list with the positive decode flag set
    //

    if (State->Alternatives->Descriptor->Flags & CM_RESOURCE_PORT_POSITIVE_DECODE) {
        State->RangeAttributes |= ARBITER_RANGE_POSITIVE_DECODE;
    }

    return STATUS_SUCCESS;
}

BOOLEAN
ario_FindWindowWithIsaBit(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
{
    NTSTATUS status;
    ULONGLONG start, current;
    BOOLEAN available = FALSE;
    ULONG findRangeFlags = 0;

    //
    // We only support the ISA bit on Pci bridges
    //

    ASSERT_PCI_DEVICE_OBJECT(State->Entry->PhysicalDeviceObject);

    ASSERT(PciClassifyDeviceType(((PPCI_PDO_EXTENSION) State->Entry->PhysicalDeviceObject->DeviceExtension)
                                 ) == PciTypePciBridge);

    //
    // Bridges with windows perform positive decode and so can conflict with
    // aliases
    //

    ASSERT(State->CurrentAlternative->Descriptor->Flags & CM_RESOURCE_PORT_POSITIVE_DECODE);

    State->RangeAvailableAttributes |= ARBITER_RANGE_ALIAS;

    //
    // The request should be correctly aligned - we generated it!
    //

    ASSERT(State->CurrentAlternative->Length % State->CurrentAlternative->Alignment == 0);

    //
    // CurrentMinimum/CurrentMaximum should have been correctly aligned by
    // GetNextAllocationRange
    //

    ASSERT(State->CurrentMinimum % State->CurrentAlternative->Alignment == 0);
    ASSERT((State->CurrentMaximum + 1) % State->CurrentAlternative->Alignment == 0);

    //
    // Conflicts with NULL occur when our parents IO space is sparse, for
    // bridges that is if the ISA bit is set and so everything will line
    // up here.  If the root we are on is sparse then things arn't as easy.

    if (State->Flags & ARBITER_STATE_FLAG_NULL_CONFLICT_OK) {
        findRangeFlags |= RTL_RANGE_LIST_NULL_CONFLICT_OK;
    }

    //
    // ...or we are shareable...
    //

    if (State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED) {
        findRangeFlags |= RTL_RANGE_LIST_SHARED_OK;
    }

    //
    // Check the length is reasonable
    //
    
    if (State->CurrentMaximum < (State->CurrentAlternative->Length + 1)) {
        return FALSE;
    }
    
    //
    // Iterate through the possible window positions, top down like the rest of
    // arbitration.
    //

    start = State->CurrentMaximum - State->CurrentAlternative->Length + 1;


    while (!available) {

        //
        // Check the range is within the constraints specified
        //

        if (start < State->CurrentMinimum) {
            break;
        }

        //
        // Check if the ISA windows are available we don't care about the rest
        // of the ranges are we don't decode them.
        //

        for (current = start;
             (current < (start + State->CurrentAlternative->Length - 1)) && (current < PCI_BRIDGE_ISA_BIT_MAX);
             current += PCI_BRIDGE_ISA_BIT_STRIDE) {

            status = RtlIsRangeAvailable(
                         Arbiter->PossibleAllocation,
                         current,
                         current + PCI_BRIDGE_ISA_BIT_WIDTH - 1,
                         findRangeFlags,
                         State->RangeAvailableAttributes,
                         Arbiter->ConflictCallbackContext,
                         Arbiter->ConflictCallback,
                         &available
                         );

            ASSERT(NT_SUCCESS(status));

            if (!available) {
                break;
            }
        }
    
        //
        // Now available indicates if all the ISA windows were available 
        //

        if (available) {

            State->Start = start;
            State->End = start + State->CurrentAlternative->Length - 1;

            ASSERT(State->Start >= State->CurrentMinimum);
            ASSERT(State->End <= State->CurrentMaximum);
            
            break;

        } else {
    
            //
            // Move to next range if we can
            //
    
            if (start < PCI_BRIDGE_WINDOW_GRANULARITY) {
                break;
            }

            start -= PCI_BRIDGE_WINDOW_GRANULARITY;    // IO windows are 1000 byte aligned
            continue;
        }
    }

    return available;

}

BOOLEAN
ario_FindSuitableRange(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine is called from AllocateEntry once we have decided where we want
    to allocate from.  It tries to find a free range that matches the
    requirements in State while restricting its possible solutions to the range
    State->Start to State->CurrentMaximum.  On success State->Start and
    State->End represent this range.  Conflicts with ISA aliases are considered.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if we found a range, FALSE otherwise.

--*/
{
    NTSTATUS status;
    PPCI_PDO_EXTENSION parentPdo, childPdo;

    PAGED_CODE();

    //
    // Assume we won't be allowing null conflicts
    //

    State->Flags &= ~ARBITER_STATE_FLAG_NULL_CONFLICT_OK;

    //
    // Now check if we really wanted to allow them
    //

    if (State->WorkSpace & PORT_ARBITER_BRIDGE_WINDOW) {

        //
        // If this isn't a PCI PDO we already failed in PreprocessEntry but
        // paranoia reigns.
        //

        ASSERT_PCI_DEVICE_OBJECT(State->Entry->PhysicalDeviceObject);

        childPdo = (PPCI_PDO_EXTENSION) State->Entry->PhysicalDeviceObject->DeviceExtension;

        if (!PCI_PDO_ON_ROOT(childPdo)) {

            parentPdo = PCI_BRIDGE_PDO(PCI_PARENT_FDOX(childPdo));

            ASSERT(parentPdo);

        } else {

            parentPdo = NULL;
        }


        //
        // Check if this is a PCI-PCI bridge that the bios configured that
        // we have not moved or it is a root bus (which be definition was
        // bios configured ...
        //

        if ((parentPdo == NULL ||
             (parentPdo->HeaderType == PCI_BRIDGE_TYPE && !parentPdo->MovedDevice))
        &&  (State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_FIXED)) {

            //
            // The BIOS configured and we have not moved its parent (thus
            // invalidating the bioses configuration) then we will leave well
            // alone.  We then allow the null conflicts and only configure the
            // arbiter to give out ranges that make it to this bus.
            //

            State->Flags |= ARBITER_STATE_FLAG_NULL_CONFLICT_OK;

        } else {

            //
            // If the BIOS didn't configure it then we need to find somewhere to
            // put the bridge. This will involve trying to find a contiguous 1000
            // port window and then if one is not available, examining all locations
            // to find the one with the most IO.
            //

            //
            // NTRAID #62581 - 04/03/2000 - andrewth
            // We are punting on this for Win2K, if 1000 contiguous ports
            // arn't available then we are not going to configure the bridge. A fix
            // for this will be required for hot plug to work. Setting the ISA bit 
            // on the bridge will increase the chances of configuring this
            //

        }

        //
        // Check if this is a window for a bridge with the ISA bit set in 16 bit IO
        // space.  If so we need to do some special processing...
        //

        if (State->WorkSpace & PORT_ARBITER_ISA_BIT_SET
        && State->CurrentMaximum <= 0xFFFF) {

            return ario_FindWindowWithIsaBit(Arbiter, State);
        }
    }

    //
    // For legacy requests from IoAssignResources (directly or by way of
    // HalAssignSlotResources) or IoReportResourceUsage we consider preallocated
    // resources to be available for backward compatibility reasons.
    //
    // If we are allocating a devices boot config then we consider all other
    // boot configs to be available.
    //

    if (State->Entry->RequestSource == ArbiterRequestLegacyReported
        || State->Entry->RequestSource == ArbiterRequestLegacyAssigned
        || State->Entry->Flags & ARBITER_FLAG_BOOT_CONFIG) {

        State->RangeAvailableAttributes |= ARBITER_RANGE_BOOT_ALLOCATED;
    }

    //
    // This request is for a device which performs positive decode so all
    // aliased ranges should be considered available
    //

    if (State->CurrentAlternative->Descriptor->Flags & CM_RESOURCE_PORT_POSITIVE_DECODE) {

        State->RangeAvailableAttributes |= ARBITER_RANGE_ALIAS;

    }

    while (State->CurrentMaximum >= State->CurrentMinimum) {

        //
        // Try to satisfy the request
        //

        if (ArbFindSuitableRange(Arbiter, State)) {

            if (State->CurrentAlternative->Length == 0) {

                ARB_PRINT(2,
                    ("Zero length solution solution for %p = 0x%I64x-0x%I64x, %s\n",
                    State->Entry->PhysicalDeviceObject,
                    State->Start,
                    State->End,
                    State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED ?
                        "shared" : "non-shared"
                    ));

                //
                // Set the result in the arbiter appropriatley so that we
                // don't try and translate this zero requirement - it won't!
                //

                State->Entry->Result = ArbiterResultNullRequest;
                return TRUE;

            } else if (ario_IsAliasedRangeAvailable(Arbiter, State)) {

                //
                // We found a suitable range so return
                //

                return TRUE;

            } else {

                //
                // Check if we wrap on start - if so then we're finished.
                //

                if (State->Start - 1 > State->Start) {
                    break;
                }

                //
                // This range's aliases arn't available so reduce allocation
                // window to not include the range just returned and try again
                //

                State->CurrentMaximum = State->Start - 1;

                continue;
            }
        } else {

            //
            // We couldn't find a base range
            //

            break;
        }
    }

    return FALSE;
}

BOOLEAN
ario_GetNextAlias(
    ULONG IoDescriptorFlags,
    ULONGLONG LastAlias,
    PULONGLONG NextAlias
    )
/*++

Routine Description:

    This routine calculates the next alias of an IO port up to 0xFFFF.

Arguments:

    IoDescriptorFlags - The flags from the requirement descriptor indicating the
        type of alias if any.

    LastAlias - The alias previous to this one.

    NextAlias - Point to where the next alias should be returned

Return Value:

    TRUE if we found an alias, FALSE otherwise.

--*/

{
    ULONGLONG next;

    PAGED_CODE();

    if (IoDescriptorFlags & CM_RESOURCE_PORT_10_BIT_DECODE) {
        next = LastAlias + (1 << 10);
    } else if (IoDescriptorFlags & CM_RESOURCE_PORT_12_BIT_DECODE) {
        next = LastAlias + (1 << 12);
    } else if ((IoDescriptorFlags & CM_RESOURCE_PORT_POSITIVE_DECODE)
           ||  (IoDescriptorFlags & CM_RESOURCE_PORT_16_BIT_DECODE)) {
        //
        // Positive decode implies 16 bit decode unless 10 or 12 bit flags are set
        // There are no aliases as we decode all the bits... what a good idea
        //

        return FALSE;

    } else {
        //
        // None of the CM_RESOURCE_PORT_*_DECODE flags are set - we should never
        // get here as we should have set them in Preprocess
        //

        ASSERT(FALSE);
        return FALSE;

    }

    //
    // Check that we are below the maximum aliased port
    //

    if (next > 0xFFFF) {
        return FALSE;
    } else {
        *NextAlias = next;
        return TRUE;
    }
}

BOOLEAN
ario_IsAliasedRangeAvailable(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    )

/*++

Routine Description:

    This routine determines if the range (Start-(Length-1)) is available taking
    into account any aliases.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if the range is available, FALSE otherwise.

--*/

{
    NTSTATUS status;
    ULONGLONG alias = State->Start;
    BOOLEAN aliasAvailable;
    UCHAR userFlagsMask;

    PAGED_CODE();

    //
    // If we improvised the decode then add the aliases but don't care it they
    // conflict - more 4.0 compatibility.
    //

    if (State->WorkSpace & PORT_ARBITER_IMPROVISED_DECODE) {
        return TRUE;
    }

    //
    // Positive decode devices can conflict with aliases
    //
    userFlagsMask = ARBITER_RANGE_POSITIVE_DECODE;

    //
    // For legacy requests from IoAssignResources (directly or by way of
    // HalAssignSlotResources) or IoReportResourceUsage we consider preallocated
    // resources to be available for backward compatibility reasons.
    //
    if (State->Entry->RequestSource == ArbiterRequestLegacyReported
        || State->Entry->RequestSource == ArbiterRequestLegacyAssigned
        || State->Entry->Flags & ARBITER_FLAG_BOOT_CONFIG) {

        userFlagsMask |= ARBITER_RANGE_BOOT_ALLOCATED;
    }

    while (ario_GetNextAlias(State->CurrentAlternative->Descriptor->Flags,
                             alias,
                             &alias)) {

        status = RtlIsRangeAvailable(
                     Arbiter->PossibleAllocation,
                     alias,
                     alias + State->CurrentAlternative->Length - 1,
                     RTL_RANGE_LIST_NULL_CONFLICT_OK |
                        (State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED ?
                            RTL_RANGE_LIST_SHARED_OK : 0),
                     userFlagsMask,
                     Arbiter->ConflictCallbackContext,
                     Arbiter->ConflictCallback,
                     &aliasAvailable
                     );

        ASSERT(NT_SUCCESS(status));

        if (!aliasAvailable) {

            ARBITER_ALLOCATION_STATE tempState;

            //
            // Check if we allow this conflict by calling OverrideConflict -
            // we will need to falsify ourselves an allocation state first
            //
            // NTRAID #62583 - 04/03/2000 - andrewth
            // This works but relies on knowing what OverrideConflict
            // looks at.  A better fix invloves storing the aliases in another
            // list but this it too much of a change for Win2k
            //

            RtlCopyMemory(&tempState, State, sizeof(ARBITER_ALLOCATION_STATE));

            tempState.CurrentMinimum = alias;
            tempState.CurrentMaximum = alias + State->CurrentAlternative->Length - 1;

            if (Arbiter->OverrideConflict(Arbiter, &tempState)) {
                //
                // We decided this conflict was ok so contine checking the rest
                // of the aliases
                //

                continue;

            }

            //
            // An alias isn't available - get another possibility
            //

            ARB_PRINT(2,
                                ("\t\tAlias 0x%x-0x%x not available\n",
                                alias,
                                alias + State->CurrentAlternative->Length - 1
                                ));

            return FALSE;
        }
    }

    return TRUE;
}

VOID
ario_AddAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )

/*++

Routine Description:

    This routine is called from AllocateEntry once we have found a possible
    solution (State->Start - State->End).  It adds the ranges that will not be
    available if we commit to this solution to Arbiter->PossibleAllocation.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    None.

--*/

{

    PAGED_CODE();

    ario_AddOrBacktrackAllocation(Arbiter,
                                  State,
                                  ArbAddAllocation
                                  );

}

NTSTATUS
armem_PreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
{
    PARBITER_MEMORY_EXTENSION extension = Arbiter->Extension;
    BOOLEAN prefetchable;

    PAGED_CODE();
    ASSERT(extension);


    //
    // Check if this is a request for a ROM - it must be a fixed request with
    // only 1 alternative and the ROM bit set
    //

    if ((State->Alternatives[0].Descriptor->Flags & CM_RESOURCE_MEMORY_READ_ONLY) ||
        ((State->Alternatives[0].Flags & ARBITER_ALTERNATIVE_FLAG_FIXED) &&
          State->AlternativeCount == 1 &&
          State->Entry->RequestSource == ArbiterRequestLegacyReported)) {

        if (State->Alternatives[0].Descriptor->Flags & CM_RESOURCE_MEMORY_READ_ONLY) {

            ASSERT(State->Alternatives[0].Flags & ARBITER_ALTERNATIVE_FLAG_FIXED);
//            ASSERT(State->AlternativeCount == 1);

        }

        //
        // Consider other ROMS to be available
        //

        State->RangeAvailableAttributes |= MEMORY_RANGE_ROM;

        //
        // Mark this range as a ROM
        //

        State->RangeAttributes |= MEMORY_RANGE_ROM;

        //
        // Allow NULL conflicts
        //

        State->Flags |= ARBITER_STATE_FLAG_NULL_CONFLICT_OK;

    }

    //
    // Check if this is a request for prefetchable memory and select
    // the correct ordering list
    //

    if (extension->PrefetchablePresent) {

#if IGNORE_PREFETCH_FOR_LEGACY_REPORTED
        //
        // In NT < 5 IoReportResourceUsage had no notion of prefetchable memory
        // so in order to be backward compatible we hope the BIOS/firmware got
        // it right!
        //

        if (State->Entry->RequestSource == ArbiterRequestLegacyReported) {
            Arbiter->OrderingList = extension->OriginalOrdering;
            return STATUS_SUCCESS;
        }
#endif

        prefetchable =
            State->Alternatives[0].Descriptor->Flags
                & CM_RESOURCE_MEMORY_PREFETCHABLE;

        if (prefetchable) {

            Arbiter->OrderingList = extension->PrefetchableOrdering;

        } else {

            Arbiter->OrderingList = extension->NonprefetchableOrdering;
        }

#if DBG

        {
            PARBITER_ALTERNATIVE current;

            //
            // Make sure that all the alternatives are of the same type
            //

            FOR_ALL_IN_ARRAY(State->Alternatives,
                             State->AlternativeCount,
                             current) {

                ASSERT((current->Descriptor->Flags & CM_RESOURCE_MEMORY_PREFETCHABLE)
                            == prefetchable
                       );
            }
        }
#endif
    }

    return STATUS_SUCCESS;
}

BOOLEAN
armem_GetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
{
    PARBITER_MEMORY_EXTENSION extension = Arbiter->Extension;

    //
    // Call the default implementation
    //

    if (!ArbGetNextAllocationRange(Arbiter, State)) {
        return FALSE;
    }

    if (extension->PrefetchablePresent
    &&  State->Entry->RequestSource != ArbiterRequestLegacyReported) {

        //
        // We have already precalculated the reserved ranges into the ordering
        // so if we end up in the reserved ranges we're out of luck...
        //

        if (State->CurrentAlternative->Priority > ARBITER_PRIORITY_PREFERRED_RESERVED) {
            return FALSE;
        }

    }

    return TRUE;
}

NTSTATUS
armem_StartArbiter(
    IN PARBITER_INSTANCE Arbiter,
    IN PCM_RESOURCE_LIST StartResources
    )
/*++

   This is called after ArbInitializeArbiterInstance as it uses
   information initialized there.  The arbiter lock should be held.
   Seeing as this is only applicable to memory descriptors we maniulate
   the resource descriptors directlty as oppose to useing the pack/upack
   routines in the arbiter.

   Example:

    StartResources contain the prefetchable range 0xfff00000 - 0xfffeffff

    OriginalOrdering (from the registry) says:
        0x00100000 - 0xFFFFFFFF
        0x000F0000 - 0x000FFFFF
        0x00080000 - 0x000BFFFF
        0x00080000 - 0x000FFFFF
        0x00080000 - 0xFFBFFFFF

    ReservedList contains 0xfff0a000-0xfff0afff

    Then out ordering lists will be:

        PrefetchableOrdering            NonprefetchableOrdering

        0xFFF0B000 - 0xFFFEFFFF
        0xFFF00000 - 0xFFF09FFF
        0xFFFF0000 - 0xFFFFFFFF         0xFFF0b000 - 0xFFFFFFFF
        0x00100000 - 0xFFFEFFFF         0x00100000 - 0xFFF09FFF
        0x000F0000 - 0x000FFFFF         0x000F0000 - 0x000FFFFF
        0x00080000 - 0x000BFFFF         0x00080000 - 0x000BFFFF
        0x00080000 - 0x000FFFFF         0x00080000 - 0x000FFFFF

     This means that when following the prefetchable ordering we try to
     allocate in the prefetchable range and if we can't then we allocate
     none prefetchable memory.  In the Nonprefetchable ordering we avoid the
     prefetchable ranges. GetNextAllocationRange is changed so that it will not
     allow

--*/
{
    NTSTATUS status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR current;
    PARBITER_MEMORY_EXTENSION extension = Arbiter->Extension;
    PARBITER_ORDERING currentOrdering;
    ULONGLONG start, end;
#if PCIFLAG_IGNORE_PREFETCHABLE_MEMORY_AT_ROOT_HACK
    PPCI_FDO_EXTENSION fdoExtension;
#endif

    PAGED_CODE();

    //
    // If this is the first time we have initialized the extension do some one
    // only initialization
    //

    if (!extension->Initialized) {

        //
        // Copy the default memory ordering list from the arbiter
        //

        extension->OriginalOrdering = Arbiter->OrderingList;
        RtlZeroMemory(&Arbiter->OrderingList, sizeof(ARBITER_ORDERING_LIST));

    } else {

        //
        // We are reinitializing the arbiter
        //

        if (extension->PrefetchablePresent) {
            //
            // We had prefetchable memory before so free the orderings we
            // created last time.
            //

            ArbFreeOrderingList(&extension->PrefetchableOrdering);
            ArbFreeOrderingList(&extension->NonprefetchableOrdering);

        }

    }

    extension->PrefetchablePresent = FALSE;
    extension->PrefetchableCount = 0;

    if (StartResources != NULL) {

        ASSERT(StartResources->Count == 1);

        //
        // Check if we have any prefetchable memory - if not we're done
        //

            FOR_ALL_IN_ARRAY(StartResources->List[0].PartialResourceList.PartialDescriptors,
                        StartResources->List[0].PartialResourceList.Count,
                        current) {

                if ((current->Type == CmResourceTypeMemory)
            &&  (current->Flags & CM_RESOURCE_MEMORY_PREFETCHABLE)) {
                extension->PrefetchablePresent = TRUE;
                break;
            }
        }
    }

#if PCIFLAG_IGNORE_PREFETCHABLE_MEMORY_AT_ROOT_HACK

    if (PciSystemWideHackFlags&PCIFLAG_IGNORE_PREFETCHABLE_MEMORY_AT_ROOT_HACK) {

        fdoExtension = (PPCI_FDO_EXTENSION) Arbiter->BusDeviceObject->DeviceExtension;

        ASSERT_PCI_FDO_EXTENSION(fdoExtension);

        if (PCI_IS_ROOT_FDO(fdoExtension)) {

            extension->PrefetchablePresent = FALSE;
        }
    }
#endif

    if (!extension->PrefetchablePresent) {

        //
        // Restore the original ordering list
        //

        Arbiter->OrderingList = extension->OriginalOrdering;
        return STATUS_SUCCESS;
    }

    status = ArbInitializeOrderingList(&extension->PrefetchableOrdering);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = ArbInitializeOrderingList(&extension->NonprefetchableOrdering);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Copy of the original ordering into the new Nonprefetchable ordering
    //

    status = ArbCopyOrderingList(&extension->NonprefetchableOrdering,
                                 &extension->OriginalOrdering
                                 );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Add the range 0-MAXULONGLONG to the list so we will calculate the reserved
    // orderings in the list.  This will ensure that we don't give a half
    // prefetchable and half not range to a device.  Prefetchable devices should
    //  probably be able to deal with this but its asking for trouble!
    //
    status = ArbAddOrdering(&extension->NonprefetchableOrdering,
                            0,
                            MAXULONGLONG
                            );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // For each prefetchable range delete it from the nonprefetchabe ordering
    // and add it to the prefetchable one.
    //
    // NB - We take it "to be self evident that that all prefetchable memory is
    // created equal" and therefore initialize the ordering list in the order
    // the prefetchable memory desciptors are found in the resource list.
    //

    FOR_ALL_IN_ARRAY(StartResources->List[0].PartialResourceList.PartialDescriptors,
                     StartResources->List[0].PartialResourceList.Count,
                     current) {

        if ((current->Type == CmResourceTypeMemory)
        &&  (current->Flags & CM_RESOURCE_MEMORY_PREFETCHABLE)) {

            extension->PrefetchableCount++;

            start = current->u.Memory.Start.QuadPart,
            end = current->u.Memory.Start.QuadPart + current->u.Memory.Length - 1;

            //
            // Add to the prefetchable ordering
            //

            status = ArbAddOrdering(&extension->PrefetchableOrdering,
                                    start,
                                    end
                                    );

            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }

            //
            // And prune it from the Nonprefetchable ordering
            //

            status = ArbPruneOrdering(&extension->NonprefetchableOrdering, start, end);

            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }

            ARB_PRINT(1,("Processed prefetchable range 0x%I64x-0x%I64x\n",
                        start,
                        end
                      ));

        }
    }

    //
    // Now prune out any explicitly reserved ranges from our new prefetchable
    // ordering - these have already been precalculated into the Nonprefetchable
    // ordering
    //

    FOR_ALL_IN_ARRAY(Arbiter->ReservedList.Orderings,
                     Arbiter->ReservedList.Count,
                     currentOrdering) {

        status = ArbPruneOrdering(&extension->PrefetchableOrdering,
                                  currentOrdering->Start,
                                  currentOrdering->End
                                  );

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

    }

    //
    // Finally append the Nonprefetchable ordering onto the end of the prefetchable
    //

    FOR_ALL_IN_ARRAY(extension->NonprefetchableOrdering.Orderings,
                     extension->NonprefetchableOrdering.Count,
                     currentOrdering) {

        status = ArbAddOrdering(&extension->PrefetchableOrdering,
                                currentOrdering->Start,
                                currentOrdering->End
                               );

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

    }

    extension->Initialized = TRUE;

    return STATUS_SUCCESS;

cleanup:

    return status;

}

BOOLEAN
ario_IsBridge(
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    Determines if this device is a PCI enumberated PCI-PCI or Cardbus bridge

Arguments:

    Pdo - The Pdo representing the device in question

Return Value:

    TRUE if this Pdo is for a bridge

--*/


{
    PSINGLE_LIST_ENTRY nextEntry;
    PPCI_FDO_EXTENSION fdoExtension;
    PCI_OBJECT_TYPE type;

    PAGED_CODE();

    //
    // First of all see if this is a PCI FDO by walking the list of all our FDOs
    //

    for ( nextEntry = PciFdoExtensionListHead.Next;
          nextEntry != NULL;
          nextEntry = nextEntry->Next ) {

        fdoExtension = CONTAINING_RECORD(nextEntry,
                                         PCI_FDO_EXTENSION,
                                         List);

        if (fdoExtension->PhysicalDeviceObject == Pdo) {

            //
            // Ok this is our FDO so we can look at it and see if it is a
            // PCI-PCI or Cardbus bridge
            //

            type = PciClassifyDeviceType(Pdo->DeviceExtension);

            if (type == PciTypePciBridge || type == PciTypeCardbusBridge) {
                return TRUE;

            }
        }
    }

    return FALSE;
}

BOOLEAN
ario_OverrideConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )

/*++

Routine Description:

    This is the default implementation of override conflict which

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if the conflict is allowable, false otherwise

--*/

{

    PRTL_RANGE current;
    RTL_RANGE_LIST_ITERATOR iterator;
    BOOLEAN ok = FALSE;

    PAGED_CODE();

    if (!(State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_FIXED)) {
        return FALSE;
    }

    FOR_ALL_RANGES(Arbiter->PossibleAllocation, &iterator, current) {

        //
        // Only test the overlapping ones
        //

        if (INTERSECT(current->Start, current->End, State->CurrentMinimum, State->CurrentMaximum)) {

            if (current->Attributes & State->RangeAvailableAttributes) {

                //
                // We DON'T set ok to true because we are just ignoring the range,
                // as RtlFindRange would have and thus it can't be the cause of
                // RtlFindRange failing, so ignoring it can't fix the conflict.
                //

                continue;
            }

            //
            // Check if we are conflicting with ourselves and the conflicting
            // range is a fixed requirement
            //

            if (current->Owner == State->Entry->PhysicalDeviceObject
            &&  State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_FIXED) {

                ARB_PRINT(1,
                    ("PnP Warning: Device reported self-conflicting requirement\n"
                    ));

                State->Start=State->CurrentMinimum;
                State->End=State->CurrentMaximum;

                ok = TRUE;
                continue;
            }

            //
            // If the passive decode flag is set and we conflict with a bridge then
            // allow the conflict.  We also allow the conflict if the range never
            // makes it onto the bus (Owner == NULL)
            //
            // NTRAID #62584 - 04/03/2000 - andrewth
            // Once the PCI bridge code is in we need to ensure that we
            // don't put anything into the ranges that are being passively decoded
            //

            if (State->CurrentAlternative->Descriptor->Flags & CM_RESOURCE_PORT_PASSIVE_DECODE
            && (ario_IsBridge(current->Owner) || current->Owner == NULL)) {

                State->Start=State->CurrentMinimum;
                State->End=State->CurrentMaximum;

                ok = TRUE;
                continue;

            }
            //
            // The conflict is still valid
            //

            return FALSE;
        }
    }
    return ok;
}

VOID
ario_ApplyBrokenVideoHack(
    IN PPCI_FDO_EXTENSION FdoExtension
    )
{
    NTSTATUS status;
    PPCI_ARBITER_INSTANCE pciArbiter;
    PARBITER_INSTANCE arbiter;

    ASSERT(!FdoExtension->BrokenVideoHackApplied);
    ASSERT(PCI_IS_ROOT_FDO(FdoExtension));

    //
    // Find the arbiter - we should always have one for a root bus.
    //

    pciArbiter = PciFindSecondaryExtension(FdoExtension, PciArb_Io);

    ASSERT(pciArbiter);

    arbiter = &pciArbiter->CommonInstance;

    //
    // We are reinitializing the orderings free the old ones
    //

    ArbFreeOrderingList(&arbiter->OrderingList);
    ArbFreeOrderingList(&arbiter->ReservedList);

    //
    // Rebuild the ordering list reserving all the places these broken S3 and
    // ATI cards might want to live - this should not fail.
    //

    status = ArbBuildAssignmentOrdering(arbiter,
                                        L"Pci",
                                        L"BrokenVideo",
                                        NULL
                                        );

    ASSERT(NT_SUCCESS(status));

    FdoExtension->BrokenVideoHackApplied = TRUE;

}


BOOLEAN
ario_GetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
{
    BOOLEAN rangeFound, doIsaBit;
    ARBITER_ORDERING_LIST savedOrderingList;

    //
    // If this is a bridge with the ISA bit set use the bridge ordering list
    //

    doIsaBit = (State->WorkSpace & PORT_ARBITER_BRIDGE_WINDOW)
            && (State->WorkSpace & PORT_ARBITER_ISA_BIT_SET);


    if (doIsaBit) {
        savedOrderingList = Arbiter->OrderingList;
        Arbiter->OrderingList = PciBridgeOrderingList;
    }

    //
    // Call the base function
    //

    rangeFound = ArbGetNextAllocationRange(Arbiter, State);

    if (doIsaBit) {

        //
        // If we have reached preferred reserved priority then we fail as we
        // have already considered both the 16 and 32 bit IO cases and using
        // the reserved may allow us to stradle the boundry.
        //

        if (rangeFound
        && State->CurrentAlternative->Priority > ARBITER_PRIORITY_PREFERRED_RESERVED) {
            rangeFound = FALSE;
        }

        Arbiter->OrderingList = savedOrderingList;
    }

    return rangeFound;

}


NTSTATUS
ario_StartArbiter(
    IN PARBITER_INSTANCE Arbiter,
    IN PCM_RESOURCE_LIST StartResources
    )
{
    NTSTATUS status;
    PPCI_FDO_EXTENSION fdoExtension;
    PPCI_PDO_EXTENSION pdoExtension = NULL;
    PRTL_RANGE_LIST exclusionList = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;
    PPCI_FDO_EXTENSION rootFdo;
    PPCI_ARBITER_INSTANCE pciArbiter;
    BOOLEAN foundResource;
    ULONGLONG dummy;

    ArbAcquireArbiterLock(Arbiter);

    fdoExtension = (PPCI_FDO_EXTENSION) Arbiter->BusDeviceObject->DeviceExtension;

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    if (StartResources == NULL || PCI_IS_ROOT_FDO(fdoExtension)) {
        //
        // Root bridges don't have ISA bits - at least that we can see...
        // Bridges with no resources also arn't effected by the ISA bit
        //
        status = STATUS_SUCCESS;
        goto exit;
    }

    ASSERT(StartResources->Count == 1);

    pdoExtension = PCI_BRIDGE_PDO(fdoExtension);

    //
    // Select the appropriate exclusion list
    //

    if (pdoExtension->Dependent.type1.IsaBitSet) {
        if (pdoExtension->Dependent.type1.VgaBitSet) {
            exclusionList = &PciVgaAndIsaBitExclusionList;
        } else {
            exclusionList = &PciIsaBitExclusionList;
        }
    }

    //
    // Find the port window and process it if the ISA bit is set
    //

    foundResource = FALSE;

    FOR_ALL_IN_ARRAY(StartResources->List[0].PartialResourceList.PartialDescriptors,
                     StartResources->List[0].PartialResourceList.Count,
                     descriptor) {

        //
        // NTRAID #62585 - 04/03/2000 - andrewth
        // Again we don't deal with bridges with BARS - for now assume
        // that the first IO descriptor we encounter is for the window
        //

        if (descriptor->Type == CmResourceTypePort) {

            if (exclusionList) {
                status = PciExcludeRangesFromWindow(
                             descriptor->u.Port.Start.QuadPart,
                             descriptor->u.Port.Start.QuadPart
                                + descriptor->u.Port.Length - 1,
                             Arbiter->Allocation,
                             exclusionList
                             );

                if (!NT_SUCCESS(status)) {
                    return status;
                }
            }

            foundResource = TRUE;
            break;
        }
    }

    if (foundResource == FALSE) {

        //
        // There are no IO resourcres on this bus so don't try
        // to handle the sparse root case.
        //

        status = STATUS_SUCCESS;
        goto exit;
    }

    //
    // Now deal with sparse root busses
    //

    rootFdo = PCI_ROOT_FDOX(fdoExtension);

    //
    // Find the root FDO's arbiter
    //

    pciArbiter = PciFindSecondaryExtension(rootFdo, PciArb_Io);

    if (!pciArbiter) {
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Use it as the exclusion list for this arbiter
    //

    ArbAcquireArbiterLock(&pciArbiter->CommonInstance);

    status = PciExcludeRangesFromWindow(
                descriptor->u.Port.Start.QuadPart,
                descriptor->u.Port.Start.QuadPart
                   + descriptor->u.Port.Length - 1,
                Arbiter->Allocation,
                pciArbiter->CommonInstance.Allocation
                );

    ArbReleaseArbiterLock(&pciArbiter->CommonInstance);

    //
    // Sanity check this to make sure that at least one port is available - if
    // not then fail start.  You could argue that we should really have this
    // marked as insufficient resources (code 12) as oppose to failed start
    // (code 10) but that is much harder and this has the desired effect.
    // We check by seeing if we can find a range for the minimal PCI requirements
    // of 4 ports alignment 4.
    //

    status = RtlFindRange(Arbiter->Allocation,
                          0,
                          MAXULONGLONG,
                          4,
                          4,
                          0,     // Flags
                          0,     // AttribureAvailableMask
                          NULL,  // Context
                          NULL,  // Callback
                          &dummy
                          );

    if (!NT_SUCCESS(status)) {
        //
        // We can't start this bridge
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

exit:

    ArbReleaseArbiterLock(Arbiter);

    return status;
}

BOOLEAN
armem_FindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine is called from AllocateEntry once we have decided where we want
    to allocate from.  It tries to find a free range that matches the
    requirements in State while restricting its possible solutions to the range
    State->Start to State->CurrentMaximum.  On success State->Start and
    State->End represent this range.  Conflicts between boot configs are allowed

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if we found a range, FALSE otherwise.

--*/
{
    //
    // If this was a boot config then consider other boot configs to be
    // available
    //

    if (State->Entry->Flags & ARBITER_FLAG_BOOT_CONFIG) {
        State->RangeAvailableAttributes |= ARBITER_RANGE_BOOT_ALLOCATED;
    }

    //
    // Do the default thing
    //

    return ArbFindSuitableRange(Arbiter, State);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\busintrf.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    busintrf.c

Abstract:

    This module implements the "bus handler" interfaces supported
    by the PCI driver.

Author:

    Peter Johnston (peterj)  6-Jun-1997

Revision History:

--*/

#include "pcip.h"

#define BUSINTRF_VERSION 1

//
// Prototypes for routines exposed only thru the "interface"
// mechanism.
//

NTSTATUS
busintrf_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

VOID
busintrf_Reference(
    IN PVOID Context
    );

VOID
busintrf_Dereference(
    IN PVOID Context
    );

NTSTATUS
busintrf_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

BOOLEAN
PciPnpTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

struct _DMA_ADAPTER *
PciPnpGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

ULONG
PciPnpReadConfig(
    IN PVOID Context,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
PciPnpWriteConfig(
    IN PVOID Context,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

//
// Define the Bus Interface "Interface" structure.
//

PCI_INTERFACE BusHandlerInterface = {
    &GUID_BUS_INTERFACE_STANDARD,           // InterfaceType
    sizeof(BUS_INTERFACE_STANDARD),         // MinSize
    BUSINTRF_VERSION,                       // MinVersion
    BUSINTRF_VERSION,                       // MaxVersion
    PCIIF_PDO,                              // Flags
    0,                                      // ReferenceCount
    PciInterface_BusHandler,                // Signature
    busintrf_Constructor,                   // Constructor
    busintrf_Initializer                    // Instance Initializer
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, busintrf_Constructor)
#pragma alloc_text(PAGE, busintrf_Dereference)
#pragma alloc_text(PAGE, busintrf_Initializer)
#pragma alloc_text(PAGE, busintrf_Reference)
#pragma alloc_text(PAGE, PciPnpTranslateBusAddress)
#pragma alloc_text(PAGE, PciPnpGetDmaAdapter)
#endif

VOID
busintrf_Reference(
    IN PVOID Context
    )
{
    PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)Context;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    InterlockedIncrement(&pdoExtension->BusInterfaceReferenceCount);
}

VOID
busintrf_Dereference(
    IN PVOID Context
    )
{
    PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)Context;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    InterlockedDecrement(&pdoExtension->BusInterfaceReferenceCount);
}


NTSTATUS
busintrf_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Initialize the BUS_INTERFACE_STANDARD fields.

Arguments:

    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    InterfaceSpecificData
                    A ULONG containing the resource type for which
                    arbitration is required.
    InterfaceReturn

Return Value:

    TRUE is this device is not known to cause problems, FALSE
    if the device should be skipped altogether.

--*/

{
    PBUS_INTERFACE_STANDARD standard = (PBUS_INTERFACE_STANDARD)InterfaceReturn;

    standard->Size = sizeof( BUS_INTERFACE_STANDARD );
    standard->Version = BUSINTRF_VERSION;
    standard->Context = DeviceExtension;
    standard->InterfaceReference = busintrf_Reference;
    standard->InterfaceDereference = busintrf_Dereference;
    standard->TranslateBusAddress = PciPnpTranslateBusAddress;
    standard->GetDmaAdapter = PciPnpGetDmaAdapter;
    standard->SetBusData = PciPnpWriteConfig;
    standard->GetBusData = PciPnpReadConfig;

    return STATUS_SUCCESS;
}

NTSTATUS
busintrf_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )

/*++

Routine Description:

    For bus interface, does nothing, shouldn't actually be called.

Arguments:

    Instance        Pointer to the PDO extension.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERTMSG("PCI busintrf_Initializer, unexpected call.", 0);

    return STATUS_UNSUCCESSFUL;
}

BOOLEAN
PciPnpTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description:

    This function is used to translate bus addresses from legacy drivers.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

    BusAddress - Supplies the orginal address to be translated.

    Length - Supplies the length of the range to be translated.

    AddressSpace - Points to the location of of the address space type such as
        memory or I/O port.  This value is updated by the translation.

    TranslatedAddress - Returns the translated address.

Return Value:

    Returns a boolean indicating if the operations was a success.

--*/
{
    PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)Context;
    PPCI_FDO_EXTENSION fdoExtension;

    PAGED_CODE();

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    return HalTranslateBusAddress(PCIBus,
                                  PCI_PARENT_FDOX(pdoExtension)->BaseBus,
                                  BusAddress,
                                  AddressSpace,
                                  TranslatedAddress);
}

ULONG
PciPnpReadConfig(
    IN PVOID Context,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This function reads the PCI configuration space.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

    Buffer - Supplies a pointer to where the data should be placed.

    Offset - Indicates the offset into the data where the reading should begin.

    Length - Indicates the count of bytes which should be read.

Return Value:

    Returns the number of bytes read.

--*/
{
    PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)Context;
    ULONG lengthRead;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    PciReadDeviceSpace(pdoExtension,
                      WhichSpace,
                      Buffer,
                      Offset,
                      Length,
                      &lengthRead
                      );
    
    return lengthRead;
}

ULONG
PciPnpWriteConfig(
    IN PVOID Context,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This function writes the PCI configuration space.

Arguments:

    Context - Supplies a pointer  to the interface context.  This is actually
        the PDO for the root bus.

    Buffer - Supplies a pointer to where the data to be written is.

    Offset - Indicates the offset into the data where the writing should begin.

    Length - Indicates the count of bytes which should be written.

Return Value:

    Returns the number of bytes read.

--*/
{
    PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)Context;
    ULONG lengthWritten;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    PciWriteDeviceSpace(pdoExtension,
                        WhichSpace,
                        Buffer,
                        Offset,
                        Length,
                        &lengthWritten
                        );
    
    return lengthWritten;
}

PDMA_ADAPTER
PciPnpGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    This function writes the PCI configuration space.

Arguments:

    Context - Supplies a pointer  to the interface context.  This is actually
        the PDO for the root bus.

    DeviceDescriptor - Supplies the device descriptor used to allocate the dma
        adapter object.

    NubmerOfMapRegisters - Returns the maximum number of map registers a device
        can allocate at one time.

Return Value:

    Returns a DMA adapter or NULL.

--*/
{
    PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION)Context;

    PAGED_CODE();

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    //
    // If this is DMA on a PCI bus update the bus number, otherwise leave well
    // alone
    //

    if (DeviceDescriptor->InterfaceType == PCIBus) {
        DeviceDescriptor->BusNumber = PCI_PARENT_FDOX(pdoExtension)->BaseBus;
    }

    return IoGetDmaAdapter(
               pdoExtension->ParentFdoExtension->PhysicalDeviceObject,
               DeviceDescriptor,
               NumberOfMapRegisters);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\cardbus.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    cardbus.c

Abstract:

    This module contains functions associated with enumerating
    PCI to Cardbus bridges (PCI Header Type 2).

    This module also contain Cardbus/Pci Private interface functions.

Author:

    Peter Johnston (peterj) 09-Mar-1997

Revision History:

--*/

#include "pcip.h"

//
// Prototypes for routines exposed only thru the "interface"
// mechanism.
//

NTSTATUS
pcicbintrf_AddCardBus(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID * DeviceContext
    );

NTSTATUS
pcicbintrf_DeleteCardBus(
    IN PVOID DeviceContext
    );

NTSTATUS
pcicbintrf_DispatchPnp(
    IN PVOID DeviceContext,
    IN PIRP  Irp
    );

NTSTATUS
pcicbintrf_GetLocation(
    IN PDEVICE_OBJECT Pdo,
    OUT UCHAR *Bus,
    OUT UCHAR *DeviceNumber,
    OUT UCHAR *FunctionNumber,
    OUT BOOLEAN *OnDebugPath
    );

NTSTATUS
pcicbintrf_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

VOID
pcicbintrf_Reference(
    IN PVOID Context
    );

VOID
pcicbintrf_Dereference(
    IN PVOID Context
    );

NTSTATUS
pcicbintrf_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

//
// Define the PCI-Cardbus private interface.
//

PCI_INTERFACE PciCardbusPrivateInterface = {
    &GUID_PCI_CARDBUS_INTERFACE_PRIVATE,    // InterfaceType
    sizeof(PCI_CARDBUS_INTERFACE_PRIVATE),  // MinSize
    PCI_CB_INTRF_VERSION,                   // MinVersion
    PCI_CB_INTRF_VERSION,                   // MaxVersion
    PCIIF_PDO,                              // Flags
    0,                                      // ReferenceCount
    PciInterface_PciCb,                     // Signature
    pcicbintrf_Constructor,                 // Constructor
    pcicbintrf_Initializer                  // Instance Initializer
};
#ifdef ALLOC_PRAGMA

//
// Query Interface routines
//

#pragma alloc_text(PAGE, pcicbintrf_AddCardBus)
#pragma alloc_text(PAGE, pcicbintrf_DeleteCardBus)
#pragma alloc_text(PAGE, pcicbintrf_DispatchPnp)

#pragma alloc_text(PAGE, pcicbintrf_Constructor)
#pragma alloc_text(PAGE, pcicbintrf_Dereference)
#pragma alloc_text(PAGE, pcicbintrf_Initializer)
#pragma alloc_text(PAGE, pcicbintrf_Reference)

//
// Standard PCI enumeration routines
//

#pragma alloc_text(PAGE, Cardbus_MassageHeaderForLimitsDetermination)
#pragma alloc_text(PAGE, Cardbus_RestoreCurrent)
#pragma alloc_text(PAGE, Cardbus_SaveLimits)
#pragma alloc_text(PAGE, Cardbus_SaveCurrentSettings)
#pragma alloc_text(PAGE, Cardbus_GetAdditionalResourceDescriptors)

#endif


NTSTATUS
pcicbintrf_AddCardBus(
    IN      PDEVICE_OBJECT  ControllerPdo,
    IN OUT  PVOID          *DeviceContext
    )
{
    PPCI_PDO_EXTENSION controllerPdoExtension;
    PPCI_FDO_EXTENSION fdoExtension = NULL;
    PPCI_FDO_EXTENSION parent;
    NTSTATUS status;

    PciDebugPrint(
        PciDbgCardBus,
        "PCI - AddCardBus FDO for PDO %08x\n",
        ControllerPdo
        );

    //
    // DeviceObject is the PDO for this CardBus controller.   Ensure
    // the PCI driver created it and knows what it is.
    //

    controllerPdoExtension = (PPCI_PDO_EXTENSION)ControllerPdo->DeviceExtension;

    ASSERT_PCI_PDO_EXTENSION(controllerPdoExtension);

    if ((controllerPdoExtension->BaseClass != PCI_CLASS_BRIDGE_DEV) ||
        (controllerPdoExtension->SubClass  != PCI_SUBCLASS_BR_CARDBUS)) {

        ASSERT(controllerPdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV);
        ASSERT(controllerPdoExtension->SubClass  == PCI_SUBCLASS_BR_CARDBUS);
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto cleanup;
    }

    //
    // Sanity check.
    //

    parent = PCI_PARENT_FDOX(controllerPdoExtension);

    if (    (controllerPdoExtension->Dependent.type2.PrimaryBus !=
             parent->BaseBus)
        ||  (controllerPdoExtension->Dependent.type2.SecondaryBus <=
             parent->BaseBus)
        ||  (controllerPdoExtension->Dependent.type2.SubordinateBus <
             controllerPdoExtension->Dependent.type2.SecondaryBus)
       ) {

        PciDebugPrint(
            PciDbgAlways,
            "PCI Cardbus Bus Number configuration error (%02x>=%02x>%02x=%02x)\n",
            controllerPdoExtension->Dependent.type2.SubordinateBus,
            controllerPdoExtension->Dependent.type2.SecondaryBus,
            controllerPdoExtension->Dependent.type2.PrimaryBus,
            parent->BaseBus
            );

        ASSERT(controllerPdoExtension->Dependent.type2.PrimaryBus == parent->BaseBus);
        ASSERT(controllerPdoExtension->Dependent.type2.SecondaryBus > parent->BaseBus);
        ASSERT(controllerPdoExtension->Dependent.type2.SubordinateBus >=
               controllerPdoExtension->Dependent.type2.SecondaryBus);

        status = STATUS_INVALID_DEVICE_REQUEST;
        goto cleanup;
    }

    fdoExtension = ExAllocatePool(NonPagedPool, sizeof(PCI_FDO_EXTENSION));
    if (fdoExtension == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;

    }
    
    PciInitializeFdoExtensionCommonFields(
        fdoExtension,
        parent->FunctionalDeviceObject, // borrow parent's fdo
        ControllerPdo
        );

    //
    // We are probably only going to see QUERY_DEVICE_RELATIONS
    // Irps so initialize the FDO extension to a working state.
    //

    fdoExtension->PowerState.CurrentSystemState = PowerSystemWorking;
    fdoExtension->PowerState.CurrentDeviceState = PowerDeviceD0;
    fdoExtension->DeviceState = PciStarted;
    fdoExtension->TentativeNextState = PciStarted;
    fdoExtension->BaseBus = controllerPdoExtension->Dependent.type2.SecondaryBus;

    //
    // Copy the access methods from the root fdo and set
    // the root fdo back pointer.
    //

    fdoExtension->BusRootFdoExtension = parent->BusRootFdoExtension;

    //
    // Initialize arbiters for this FDO.
    //

    status = PciInitializeArbiters(fdoExtension);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Point the PDOextension to the new FDOextension (also indicates
    // the object is a bridge) and vice versa.
    //

    controllerPdoExtension->BridgeFdoExtension = fdoExtension;
    fdoExtension->ParentFdoExtension = parent;

    //
    // Flag that this FDO extension doesn't have a REAL FDO
    // associated with it.
    //

    fdoExtension->Fake = TRUE;

    //
    // Normaly we set the arbiter's ranges on a START_DEVICE IRP
    // but this has happened long before we get here so we must
    // regenerate the resource list.
    //

    {
        PCM_RESOURCE_LIST allocatedResources;

        status = PciQueryResources(
                     controllerPdoExtension,
                     &allocatedResources
                     );

        if (NT_SUCCESS(status)) {

            //
            // Note: there's really not much that can be done if
            // the above failed,...
            //
            // Note: Find the first memory range, it should be length
            // 0x1000, we really don't want the arbiter using this so
            // nullify it.
            //

            PCM_FULL_RESOURCE_DESCRIPTOR    full;
            PCM_PARTIAL_RESOURCE_LIST       partial;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;
            ULONG                           count;

            ASSERT(allocatedResources != NULL);
            ASSERT(allocatedResources->Count == 1);

            full = allocatedResources->List;            ASSERT(full);
            partial = &full->PartialResourceList;       ASSERT(partial);
            descriptor = partial->PartialDescriptors;   ASSERT(descriptor);
            count = partial->Count;                     ASSERT(count);

            while (count--) {
                if (descriptor->Type == CmResourceTypeMemory) {
                    ASSERT(descriptor->u.Generic.Length == 4096);
                    descriptor->Type = CmResourceTypeNull;
                    break;
                }
            }
            status = PciInitializeArbiterRanges(fdoExtension, allocatedResources);
            ASSERT(NT_SUCCESS(status));
            ExFreePool(allocatedResources);
        }
    }

    //
    // If the PDO has resource requirements squirreled away somewhere,
    // cause them to be reevaluated.
    //

    PciInvalidateResourceInfoCache(controllerPdoExtension);

    //
    // Insert this Fdo in the list of PCI parent Fdos.
    //

    PciInsertEntryAtTail(&PciFdoExtensionListHead,
                         &fdoExtension->List,
                         &PciGlobalLock);

    //
    // Return the device context (really a pointer to our fake
    // FDO extension) that will be used on all subsequent calls
    // for this device.
    //

    *DeviceContext = fdoExtension;
    return STATUS_SUCCESS;

cleanup:

    if (fdoExtension) {
        ExFreePool(fdoExtension);
    }

    return status;

}

NTSTATUS
pcicbintrf_DeleteCardBus(
    IN PVOID DeviceContext
    )
{
    PPCI_FDO_EXTENSION fdoExtension;
    PPCI_PDO_EXTENSION pdoExtension;

    fdoExtension = (PPCI_FDO_EXTENSION)DeviceContext;
    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    pdoExtension = fdoExtension->PhysicalDeviceObject->DeviceExtension;
    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    ASSERT(pdoExtension->BridgeFdoExtension == fdoExtension);
    pdoExtension->BridgeFdoExtension = NULL;

    PciDebugPrint(
        PciDbgCardBus,
        "PCI - DeleteCardBus (fake) FDO %08x for PDO %08x\n",
        fdoExtension,
        pdoExtension
        );

    //
    // Free the (fake) FDO extension we created to run this
    // bus with.
    //

    ASSERT(fdoExtension->ChildPdoList == NULL);

    
    PciRemoveEntryFromList(&PciFdoExtensionListHead,
                           &fdoExtension->List,
                           &PciGlobalLock);

    ExFreePool(fdoExtension);

    return STATUS_SUCCESS;
}
NTSTATUS
pcicbintrf_DispatchPnp(
    IN PVOID DeviceContext,
    IN PIRP  Irp
    )
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PPCI_FDO_EXTENSION fdoExtension;
    PVOID irpReturnVal;

    PAGED_CODE();

    fdoExtension = (PPCI_FDO_EXTENSION)DeviceContext;
    ASSERT_PCI_FDO_EXTENSION(fdoExtension);
    ASSERT(fdoExtension->Fake == TRUE);

    //
    // Get the stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(irpSp->MajorFunction == IRP_MJ_PNP);
#if DBG
    PciDebugPrint(
        PciDbgCardBus,
        "PCI CardBus Dispatch PNP: FDO(%x, bus 0x%02x)<-%s\n",
        fdoExtension,
        fdoExtension->BaseBus,
        PciDebugPnpIrpTypeToText(irpSp->MinorFunction)
        );
#endif
    return PciFdoIrpQueryDeviceRelations(
        Irp,
        irpSp,
        (PPCI_COMMON_EXTENSION) fdoExtension
        );
}


NTSTATUS
pcicbintrf_GetLocation(
    IN PDEVICE_OBJECT Pdo,
    OUT UCHAR *Bus,
    OUT UCHAR *DeviceNumber,
    OUT UCHAR *FunctionNumber,
    OUT BOOLEAN *OnDebugPath
    )
{
    PPCI_PDO_EXTENSION PdoExt = (PPCI_PDO_EXTENSION)Pdo->DeviceExtension;
    
    ASSERT(Bus);
    ASSERT(DeviceNumber);
    ASSERT(FunctionNumber);
    
    //
    // Verify that this PDO actually belongs to us.
    //
    if (!PdoExt) {
        return STATUS_NOT_FOUND;
    }

    //
    // Verify that it is actually a PDO.
    //
    if (PdoExt->ExtensionType != PciPdoExtensionType) {
        return STATUS_NOT_FOUND;
    }

    *Bus            = (UCHAR) PCI_PARENT_FDOX(PdoExt)->BaseBus;        
    *DeviceNumber   = (UCHAR) PdoExt->Slot.u.bits.DeviceNumber;
    *FunctionNumber = (UCHAR) PdoExt->Slot.u.bits.FunctionNumber;
    *OnDebugPath    = PdoExt->OnDebugPath;
    
    return STATUS_SUCCESS;
}    


VOID
pcicbintrf_Reference(
    IN PVOID Context
    )
{
}

VOID
pcicbintrf_Dereference(
    IN PVOID Context
    )
{
}

NTSTATUS
pcicbintrf_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Initialize the PCI_CARDBUS_INTERFACE_PRIVATE fields.

Arguments:

    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    InterfaceSpecificData
                    A ULONG containing the resource type for which
                    arbitration is required.
    InterfaceReturn

Return Value:

    Status of this operation.

--*/

{
    PPCI_CARDBUS_INTERFACE_PRIVATE interface;


    interface = (PPCI_CARDBUS_INTERFACE_PRIVATE)InterfaceReturn;

    //
    // Standard interface stuff
    //

    interface->Size = sizeof(PCI_CARDBUS_INTERFACE_PRIVATE);
    interface->Version = PCI_CB_INTRF_VERSION;
    interface->Context = DeviceExtension;
    interface->InterfaceReference = pcicbintrf_Reference;
    interface->InterfaceDereference = pcicbintrf_Dereference;

    //
    // PCI-CardBus private
    //

    interface->DriverObject = PciDriverObject;

    interface->AddCardBus    = pcicbintrf_AddCardBus;
    interface->DeleteCardBus = pcicbintrf_DeleteCardBus;
    interface->DispatchPnp   = pcicbintrf_DispatchPnp;
    interface->GetLocation   = pcicbintrf_GetLocation;

    return STATUS_SUCCESS;
}

NTSTATUS
pcicbintrf_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )

/*++

Routine Description:

    For pci-cardbus interface, does nothing, shouldn't actually be called.

Arguments:

    Instance        Pointer to the PDO extension.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERTMSG("PCI pcicbintrf_Initializer, unexpected call.", 0);

    return STATUS_UNSUCCESSFUL;
}

VOID
Cardbus_MassageHeaderForLimitsDetermination(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    The configuration header for a cardbus bridge has one BAR, the
    SocketRegistersBaseAddress (which is handled in the same way as
    a normal device BAR (see device.c)) and four range descriptions,
    two for I/O and two for memory.  Either or both of the memory
    ranges can be prefetchable.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    The Working configuration has been modified so that all range
    fields have been set to their maximum possible values.

    The Current configuration has been modified such that writing it
    to the hardware will restore the hardware to it's current (disabled)
    state.

--*/

{
    PPCI_COMMON_CONFIG working = This->Working;
    PPCI_COMMON_CONFIG current = This->Current;
    ULONG index;
    ULONG mask;

    working->u.type2.SocketRegistersBaseAddress = 0xffffffff;

    for (index = 0; index < (PCI_TYPE2_ADDRESSES-1); index++) {
        working->u.type2.Range[index].Base  = 0xffffffff;
        working->u.type2.Range[index].Limit = 0xffffffff;
    }

    This->PrivateData = This->Current->u.type2.SecondaryStatus;
    This->Current->u.type2.SecondaryStatus = 0;
    This->Working->u.type2.SecondaryStatus = 0;

    //
    // For cardbus, disregard whatever the BIOS set as resource
    // windows, PnP will assign new windows as appropriate.
    //

    if (!This->PdoExtension->OnDebugPath) {
        mask = 0xfffff000;
        for (index = 0; index < (PCI_TYPE2_ADDRESSES-1); index++) {
            current->u.type2.Range[index].Base  = mask;
            current->u.type2.Range[index].Limit = 0;
       
            if (index == 2) {
       
                //
                // Switch to IO (first two are memory).
                //
       
                mask = 0xfffffffc;
            }
        }
    }
}

VOID
Cardbus_RestoreCurrent(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Restore any type specific fields in the original copy of config
    space.   In the case of Cardbus bridges, the secondary status field.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    This->Current->u.type2.SecondaryStatus = (USHORT)(This->PrivateData);
}

VOID
Cardbus_SaveLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Fill in the Limit structure with a IO_RESOURCE_REQUIREMENT
    for each implemented BAR.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    BOOLEAN DbgChk64Bit;
    ULONG index;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PPCI_COMMON_CONFIG working = This->Working;
    ULONG endOffset;
    ULONG base;
    ULONG limit;
    TYPE2EXTRAS type2extras;
    ULONG tempLegacyModeBaseAddress;
    NTSTATUS status;

    descriptor = This->PdoExtension->Resources->Limit;

    DbgChk64Bit = PciCreateIoDescriptorFromBarLimit(
                      descriptor,
                      &working->u.type2.SocketRegistersBaseAddress,
                      FALSE);
    ASSERT(!DbgChk64Bit);

    descriptor++;

    for (index = 0;
         index < (PCI_TYPE2_ADDRESSES-1);
         index++, descriptor++) {

        if (index < 2) {

            //
            // First two are Memory
            //

            endOffset = 0xfff;

            descriptor->Type = CmResourceTypeMemory;
            descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;

        } else {

            //
            // Next two are IO
            //

            if ((working->u.type2.Range[index].Base & 0x3) == 0x0) {

                //
                // Only the lower 16 bits are implemented.
                //

                ASSERT((working->u.type2.Range[index].Limit & 0x3) == 0x0);

                working->u.type2.Range[index].Base  &= 0xffff;
                working->u.type2.Range[index].Limit &= 0xffff;
            }
            endOffset = 0x3;

            descriptor->Type = CmResourceTypePort;
            descriptor->Flags = CM_RESOURCE_PORT_IO
                              | CM_RESOURCE_PORT_POSITIVE_DECODE
                              | CM_RESOURCE_PORT_WINDOW_DECODE;
        }
        base  = working->u.type2.Range[index].Base  & ~endOffset;
        limit = working->u.type2.Range[index].Limit |  endOffset;

        //
        // Is this range in use?
        //

        if ((base != 0) && (base < limit)) {

            //
            // Yep.
            //

            descriptor->u.Generic.MinimumAddress.QuadPart = 0;
            descriptor->u.Generic.MaximumAddress.QuadPart = limit;
            descriptor->u.Generic.Alignment = endOffset + 1;

            //
            // Length is meaningless here, report zero.
            //

            descriptor->u.Generic.Length = 0;

        } else {

            //
            // Not in use, don't report it.
            //

            descriptor->Type = CmResourceTypeNull;
        }
    }

    //
    // Cardbus has an additional base address register in config
    // space beyond the common header.  Also there are the subsystem
    // ID and subsystem vendor ID so get those while we're there.
    //

    PciReadDeviceConfig(This->PdoExtension,
                        &type2extras,
                        FIELD_OFFSET(PCI_COMMON_CONFIG,
                                     DeviceSpecific),
                        sizeof(type2extras));

    This->PdoExtension->SubsystemVendorId = type2extras.SubVendorID;
    This->PdoExtension->SubsystemId       = type2extras.SubSystemID;

    //
    // CardBus always wants a 4K apperture in the first memory BAR.
    // Note that when saving the original settings we discarded
    // whatever was there already.
    //

    ASSERT(This->PdoExtension->Resources->Limit[1].u.Generic.Length == 0);

    This->PdoExtension->Resources->Limit[1].u.Generic.Length = 4096;
}

VOID
Cardbus_SaveCurrentSettings(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Fill in the Current array in the PDO extension with the current
    settings for each implemented BAR.

    Also, fill in the PDO Extension's Dependent structure.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    ULONG index;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor;
    PPCI_COMMON_CONFIG current = This->Current;
    ULONG endOffset;
    ULONG base;
    ULONG limit;

    partial = This->PdoExtension->Resources->Current;
    ioResourceDescriptor = This->PdoExtension->Resources->Limit;

    for (index = 0;
         index < PCI_TYPE2_RANGE_COUNT;
         index++, partial++, ioResourceDescriptor++) {

        partial->Type = ioResourceDescriptor->Type;

        if (partial->Type == CmResourceTypeNull) {

            //
            // This entry is not implemented (or permanently disabled)
            // no further processing required.
            //

            continue;
        }

        partial->Flags = ioResourceDescriptor->Flags;
        partial->ShareDisposition = ioResourceDescriptor->ShareDisposition;

        //
        // The first and last entries are in PCI Base Address Register
        // form.
        //

        if (index == 0) {

            partial->u.Generic.Length = ioResourceDescriptor->u.Generic.Length;
            base = current->u.type2.SocketRegistersBaseAddress;
            base &= ~(partial->u.Generic.Length - 1);
            partial->u.Generic.Start.QuadPart = base;
            continue;

        } else if (index == (PCI_TYPE2_RANGE_COUNT - 1)) {
            
            //
            // We don't use LegacyModeBaseAddress any more its always set to 0
            //
            continue;
        }

        //
        // Following entries are in the form of ranges.
        //

        base  = current->u.type2.Range[index-1].Base;
        limit = current->u.type2.Range[index-1].Limit;

        if (index < 3) {

            //
            // after the BAR come two memory ranges.
            //

            endOffset = 0xfff;

        } else {

            //
            // Next two are IO
            //

            if ((current->u.type2.Range[index].Base & 0x3) == 0x0) {

                //
                // Only the lower 16 bits are implemented.
                //

                base  &= 0xffff;
                limit &= 0xffff;
            }
            endOffset = 0x3;
        }
        base  &= ~endOffset;
        limit |=  endOffset;

        //
        // Is this range in use?
        //

        if (base && (base < limit)) {

            //
            // Yep.
            //

            partial->u.Generic.Start.QuadPart = base;
            partial->u.Generic.Length = limit - base + 1;

        } else {

            //
            // Not in use, don't report it.
            //

            partial->Type = CmResourceTypeNull;
        }
    }

    //
    // Always clear the ISA bit on a cardbus bridge
    //

    This->PdoExtension->Dependent.type2.IsaBitSet = FALSE;

    //
    // If any of the MEM0_PREFETCH, MEM1_PREFETCH or ISA bits are set in brigde
    // control register force us to update the hardware so we will clear them
    // in ChangeResourceSettings
    //

    if (current->u.type2.BridgeControl & (PCI_ENABLE_CARDBUS_MEM0_PREFETCH
                                          | PCI_ENABLE_CARDBUS_MEM1_PREFETCH
                                          | PCI_ENABLE_BRIDGE_ISA)) {

        This->PdoExtension->UpdateHardware = TRUE;
    }

    //
    // Save the bridge's PCI bus #'s
    //

    This->PdoExtension->Dependent.type2.PrimaryBus =
        current->u.type2.PrimaryBus;
    This->PdoExtension->Dependent.type2.SecondaryBus =
        current->u.type2.SecondaryBus;
    This->PdoExtension->Dependent.type2.SubordinateBus =
        current->u.type2.SubordinateBus;

}

VOID
Cardbus_ChangeResourceSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    )
{
    ULONG index;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor;
    ULONG lowPart;
    ULONG length;
    struct _type2_range {
        ULONG Base;
        ULONG Limit;
    } *range;

#if DBG

    PHYSICAL_ADDRESS upperBound;
    ULONG align;

#endif


    //
    // Close the bridge windows and only open them is appropriate resources
    // have been assigned
    //

    for (index = 0; index < PCI_TYPE2_ADDRESSES-1; index++) {
        CommonConfig->u.type2.Range[index].Base = 0xffffffff;
        CommonConfig->u.type2.Range[index].Limit = 0x0;
    }

    if (PdoExtension->Resources) {

        partial = PdoExtension->Resources->Current;
        ioResourceDescriptor = PdoExtension->Resources->Limit;

        for (index = 0;
             index < PCI_TYPE2_RANGE_COUNT;
             index++, partial++, ioResourceDescriptor++) {

            //
            // If this entry is not implemented, skip.
            //

            if (partial->Type == CmResourceTypeNull) {
                continue;
            }
            ASSERT(partial->Type == ioResourceDescriptor->Type);

            //
            // Cardbus supports 32 (or 16) bit addresses only.
            //

            lowPart = partial->u.Generic.Start.LowPart;

            ASSERT(partial->u.Generic.Start.HighPart == 0);

            //
            // Type 2 headers
            //
            // entry    cfg offset  size    what
            //
            //  0       10          4       CB Socket reg/EXCA BAR
            //  1       1c          8       Mem base/limit (32 bits each)
            //  2       24          8       ""  ""  2nd aperture
            //  3       2c          8(*)    IO base/limit
            //  4       34          8(*)    ""  ""  2nd aperture
            //  5       40          4(**)   16 bit PC card legacy mode BAR
            //
            // *  Optionally 16 or 32 bits.
            // ** Optional.  Not supported at present (Memphis says they don't
            // support it at all).  Peterj 11/5/97.
            //

            if (index == 0) {

                ASSERT(partial->Type == CmResourceTypeMemory);
                CommonConfig->u.type2.SocketRegistersBaseAddress = lowPart;
            } else if (index == (PCI_TYPE2_RANGE_COUNT-1)) {
                
                //
                // We don't use LegacyModeBaseAddress any more its always set to 0
                //
                ASSERT(partial->Type = CmResourceTypeNull);
                continue;

            } else {

                //
                // It's one of the range/limit pairs.
                //

                range =
                    (struct _type2_range *)&CommonConfig->u.type2.Range[index-1];
                length = partial->u.Generic.Length;

 #if DBG

                //
                // Verify type and upper bound.
                //

                upperBound.QuadPart = lowPart + (partial->u.Generic.Length - 1);
                ASSERT(upperBound.HighPart == 0);

                if (index < 3) {

                    //
                    // Memory ranges, 4KB alignment.
                    //

                    align = 0xfff;

                } else {

                    //
                    // IO ranges, verify type, 4 Byte alignment and
                    // upperbound if 16 bit only.
                    //

                    align = 0x3;

                    if ((range->Base & 0x3) == 0) {

                        //
                        // 16 bit
                        //

                        ASSERT((upperBound.LowPart & 0xffff0000) == 0);
                    }
                }
                ASSERT((lowPart & align) == 0);
                ASSERT(((length & align) == 0) && (length > align));

 #endif

                range->Base = lowPart;
                range->Limit = lowPart + (length - 1);
                continue;
            }
        }
    }

    //
    // Restore the bridge's PCI bus #'s
    //

    CommonConfig->u.type2.PrimaryBus = PdoExtension->Dependent.type2.PrimaryBus;
    CommonConfig->u.type2.SecondaryBus = PdoExtension->Dependent.type2.SecondaryBus;
    CommonConfig->u.type2.SubordinateBus = PdoExtension->Dependent.type2.SubordinateBus;

    //
    // Always clear the MEM0_PREFETCH, MEM1_PREFETCH and ISA enables
    // for a cardbus contoller as we don't support these.
    //

    ASSERT(!PdoExtension->Dependent.type2.IsaBitSet);

    CommonConfig->u.type2.BridgeControl &= ~(PCI_ENABLE_CARDBUS_MEM0_PREFETCH
                                             | PCI_ENABLE_CARDBUS_MEM1_PREFETCH
                                             | PCI_ENABLE_BRIDGE_ISA);

    //
    // Set the bridge control register bits we might have changes
    //

    if (PdoExtension->Dependent.type2.VgaBitSet) {
        CommonConfig->u.type2.BridgeControl |= PCI_ENABLE_BRIDGE_VGA;
    }


}

VOID
Cardbus_GetAdditionalResourceDescriptors(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig,
    IN PIO_RESOURCE_DESCRIPTOR Resource
    )
{
    //
    // For the moment, do nothing, need to add the same sort of
    // support as is in pci-pci bridges.
    //

    return;
}

NTSTATUS
Cardbus_ResetDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    )
{
    //
    // While you might logically expect to find code in this
    // function, RavisP assures me that the cardbus driver
    // handles resets correctly and the PCI driver doesn't
    // need to touch it.
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\devhere.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    devhere.c

Abstract:

    PCI_DEVICE_PRESENT_INTERFACE lives here

Author:

    Andy Thornton (andrewth) 15-July-1999

Revision History:

--*/

#include "pcip.h"

#define DEVPRESENT_MINSIZE     FIELD_OFFSET(PCI_DEVICE_PRESENT_INTERFACE, IsDevicePresentEx)



BOOLEAN
devpresent_IsDevicePresent(
    USHORT VendorID,
    USHORT DeviceID,
    UCHAR RevisionID,
    USHORT SubVendorID,
    USHORT SubSystemID,
    ULONG Flags
    );

BOOLEAN
devpresent_IsDevicePresentEx(
    IN PVOID Context,
    IN PPCI_DEVICE_PRESENCE_PARAMETERS Parameters
    );

NTSTATUS
devpresent_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

NTSTATUS
devpresent_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

VOID
PciRefDereferenceNoop(
    IN PVOID Context
    );

BOOLEAN
PcipDevicePresentOnBus(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_DEVICE_PRESENCE_PARAMETERS Parameters
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, devpresent_IsDevicePresent)
#pragma alloc_text(PAGE, devpresent_Initializer)
#pragma alloc_text(PAGE, devpresent_Constructor)
#pragma alloc_text(PAGE, PciRefDereferenceNoop)

#endif


PCI_INTERFACE PciDevicePresentInterface = {
    &GUID_PCI_DEVICE_PRESENT_INTERFACE,     // InterfaceType
    DEVPRESENT_MINSIZE,                     // MinSize
    PCI_DEVICE_PRESENT_INTERFACE_VERSION,   // MinVersion
    PCI_DEVICE_PRESENT_INTERFACE_VERSION,   // MaxVersion
    PCIIF_PDO,                              // Flags
    0,                                      // ReferenceCount
    PciInterface_DevicePresent,             // Signature
    devpresent_Constructor,                 // Constructor
    devpresent_Initializer                  // Instance Initializer
};


VOID
PciRefDereferenceNoop(
    IN PVOID Context
    )
{

    PAGED_CODE();
    return;
}

NTSTATUS
devpresent_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )
{
    PAGED_CODE();
    return STATUS_SUCCESS;
}

NTSTATUS
devpresent_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )
{


    PPCI_DEVICE_PRESENT_INTERFACE interface;

    PAGED_CODE();

     //
    // Have already verified that the InterfaceReturn variable
    // points to an area in memory large enough to contain a
    // PCI_DEVICE_PRESENT_INTERFACE.  Fill it in for the caller.
    //

    interface = (PPCI_DEVICE_PRESENT_INTERFACE) InterfaceReturn;

    interface->Version              = PCI_DEVICE_PRESENT_INTERFACE_VERSION;
    interface->InterfaceReference   = PciRefDereferenceNoop;
    interface->InterfaceDereference = PciRefDereferenceNoop;
    interface->Context              = DeviceExtension;
    interface->IsDevicePresent      = devpresent_IsDevicePresent;
        
    //
    // This interface has been extended from the base interface (what was
    // filled in above), to a larger interface.  If the buffer provided
    // is large enough to hold the whole thing, fill in the rest.  Otherwise
    // don't.
    //
    if (Size >= sizeof(PCI_DEVICE_PRESENT_INTERFACE)) {
        
        interface->IsDevicePresentEx = devpresent_IsDevicePresentEx;
        interface->Size = sizeof(PCI_DEVICE_PRESENT_INTERFACE);
    
    } else {

        interface->Size = DEVPRESENT_MINSIZE;
    }
    
    return STATUS_SUCCESS;
}


BOOLEAN
devpresent_IsDevicePresent(
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN UCHAR RevisionID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN ULONG Flags
    )
/*++

Routine Description:

    This routine searches the PCI device tree to see if the specific device
    is present in the system.  Not devices that are explicitly not enumerated
    (such as PIIX4 power management function) are considered absent.

Arguments:

    VendorID - Required VendorID of the device

    DeviceID - Required DeviceID of the device

    RevisionID - Optional Revision ID

    SubVendorID - Optional Subsystem Vendor ID

    SubSystemID - Optional Subsystem ID

    Flags - Bitfield which indicates if Revision and Sub* ID's should be used:

        PCI_USE_SUBSYSTEM_IDS, PCI_USE_REVISION_ID are valid all other bits
        should be 0


Return Value:

    TRUE if the device is present in the system, FALSE otherwise.

--*/

{
    PCI_DEVICE_PRESENCE_PARAMETERS parameters;

    parameters.Size = sizeof(PCI_DEVICE_PRESENCE_PARAMETERS);
    parameters.VendorID = VendorID;
    parameters.DeviceID = DeviceID;
    parameters.RevisionID = RevisionID;
    parameters.SubVendorID = SubVendorID;
    parameters.SubSystemID = SubSystemID;

    //
    // Clear out flags that this version of the interface didn't use,
    // 
    parameters.Flags = Flags & (PCI_USE_SUBSYSTEM_IDS | PCI_USE_REVISION);
    
    //
    // This original version of the interface required vendor/device ID
    // matching.  The new version doesn't, so set the flag indicating
    // that we do in fact want to do a vendor/device ID match.
    //
    parameters.Flags |= PCI_USE_VENDEV_IDS;
    
    return devpresent_IsDevicePresentEx(NULL,
                                        &parameters
                                        );
}

BOOLEAN
devpresent_IsDevicePresentEx(
    IN PVOID Context,
    IN PPCI_DEVICE_PRESENCE_PARAMETERS Parameters
    )
/*++

Routine Description:

    This routine searches the PCI device tree to see if the specific device
    is present in the system.  Note devices that are explicitly not enumerated
    (such as PIIX4 power management function) are considered absent.

Arguments:

    Context - The device extension of the device requesting the search.
    
    Parameters - Pointer to a structure containing the parameters of the device search,
                 including VendorID, SubSystemID and ClassCode, among others.                 

Return Value:

    TRUE if the device is present in the system, FALSE otherwise.

--*/
{
    PSINGLE_LIST_ENTRY nextEntry;
    PPCI_FDO_EXTENSION fdoExtension;
    PPCI_PDO_EXTENSION pdoExtension;
    BOOLEAN found = FALSE;
    ULONG flags;

    PAGED_CODE();

    //
    // Validate the parameters.
    //

    if (!ARGUMENT_PRESENT(Parameters)) {
        
        ASSERT(ARGUMENT_PRESENT(Parameters));
        return FALSE;
    }
    
    //
    // Validate the size of the structure passed in.
    //
    if (Parameters->Size < sizeof(PCI_DEVICE_PRESENCE_PARAMETERS)) {
        
        ASSERT(Parameters->Size >= sizeof(PCI_DEVICE_PRESENCE_PARAMETERS));
        return FALSE;
    }

    flags = Parameters->Flags;
    
    // 
    // We can either do a Vendor/Device ID match, or a Class/SubClass
    // match.  If neither of these flags are present, fail.
    //
    if (!(flags & (PCI_USE_VENDEV_IDS | PCI_USE_CLASS_SUBCLASS))) {
        
        ASSERT(flags & (PCI_USE_VENDEV_IDS | PCI_USE_CLASS_SUBCLASS));
        return FALSE;
    }

    //
    // RevisionID, SubVendorID and SubSystemID are more precise flags.
    // They are only valid if we're doing a Vendor/Device ID match.
    //
    if (flags & (PCI_USE_REVISION | PCI_USE_SUBSYSTEM_IDS)) {
        
        if (!(flags & PCI_USE_VENDEV_IDS)) {
            
            ASSERT(flags & PCI_USE_VENDEV_IDS);
            return FALSE;
        }
    }

    //
    // Programming Interface is also a more precise flag.
    // It is only valid if we're doing a class code match.
    //
    if (flags & PCI_USE_PROGIF) {
        
        if (!(flags & PCI_USE_CLASS_SUBCLASS)) {
            
            ASSERT(flags & PCI_USE_CLASS_SUBCLASS);
            return FALSE;
        }
    }

    //
    // Okay, validation complete.  Do the search.
    //
    ExAcquireFastMutex(&PciGlobalLock);

    pdoExtension = (PPCI_PDO_EXTENSION)Context;
    
    if (flags & (PCI_USE_LOCAL_BUS | PCI_USE_LOCAL_DEVICE)) {
        
        //
        // Limit the search to the same bus as the device that requested
        // the search.  This requires a pdoExtension representing the device
        // requesting the search.
        //
        if (pdoExtension == NULL) {
            
            ASSERT(pdoExtension != NULL);
            goto cleanup;
        }
        
        fdoExtension = pdoExtension->ParentFdoExtension;

        found = PcipDevicePresentOnBus(fdoExtension,
                                       pdoExtension,
                                       Parameters
                                       );   
    } else {

        //
        // We have not been told to limit the search to
        // the bus on which a particular device lives.
        // Do a global search, iterating over all the buses.
        //
        for ( nextEntry = PciFdoExtensionListHead.Next;
              nextEntry != NULL;
              nextEntry = nextEntry->Next ) {
    
            fdoExtension = CONTAINING_RECORD(nextEntry,
                                             PCI_FDO_EXTENSION,
                                             List
                                             );
            
            found = PcipDevicePresentOnBus(fdoExtension,
                                           NULL,
                                           Parameters
                                           );
            if (found) {
                break;
            }
    
        }
    }
    
cleanup:

    ExReleaseFastMutex(&PciGlobalLock);

    return found;

}

BOOLEAN
PcipDevicePresentOnBus(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_DEVICE_PRESENCE_PARAMETERS Parameters
    )
/*++

Routine Description:
    
    This routine searches the PCI device tree for a given device 
    on the bus represented by the given FdoExtension.  
    
Arguments:

    FdoExtension - A pointer to the device extension of a PCI FDO.
        This represents the bus to be searched for the given device.
        
    PdoExtension - A pointer to the device extension of the PCI PDO that requested
        the search.  Some device searches are limited to the same bus/device number
        as the requesting device, and this is used to get those numbers.
        
    Parameters - The parameters of the search.
    
    Flags - A bitfield indicating which fields of the Parameters structure to use for the search.
    
Return Value:

    TRUE if the requested device is found.
    FALSE if it is not.
    
--*/
{
    IN PPCI_PDO_EXTENSION currentPdo;
    BOOLEAN found = FALSE;
    ULONG flags = Parameters->Flags;

    ExAcquireFastMutex(&FdoExtension->ChildListMutex);

    for (currentPdo = FdoExtension->ChildPdoList;
         currentPdo;
         currentPdo = currentPdo->Next) {

        //
        // If we're limiting the search to devices with the same 
        // device number as the requesting device, make sure this
        // current PDO qualifies.
        //
        if (PdoExtension && (flags & PCI_USE_LOCAL_DEVICE)) {
            
            if (PdoExtension->Slot.u.bits.DeviceNumber != 
                currentPdo->Slot.u.bits.DeviceNumber) {
                
                continue;
            }
        }

        if (flags & PCI_USE_VENDEV_IDS) {
            
            if ((currentPdo->VendorId != Parameters->VendorID)
            ||  (currentPdo->DeviceId != Parameters->DeviceID)) {

                continue;
            }
            
            if ((flags & PCI_USE_SUBSYSTEM_IDS)
            &&  ((currentPdo->SubsystemVendorId != Parameters->SubVendorID) || 
                 (currentPdo->SubsystemId != Parameters->SubSystemID))) {

                continue;
            }

            if ((flags & PCI_USE_REVISION)
            &&  (currentPdo->RevisionId != Parameters->RevisionID)) {

                continue;
            }
        }

        if (flags & PCI_USE_CLASS_SUBCLASS) {
            
            if ((currentPdo->BaseClass != Parameters->BaseClass) ||
                (currentPdo->SubClass != Parameters->SubClass)) {
                
                continue;
            }

            if ((flags & PCI_USE_PROGIF) 
            &&  (currentPdo->ProgIf != Parameters->ProgIf)) {
                
                continue;
            }
        }

        found = TRUE;
        break;
    }

    ExReleaseFastMutex(&FdoExtension->ChildListMutex);

    return found;
}

#if DEVPRSNT_TESTING

NTSTATUS
PciRunDevicePresentInterfaceTest(
    IN PPCI_PDO_EXTENSION PdoExtension
    )
/*++

Routine Description:

    

Arguments:

    FdoExtension - this PCI bus's FDO extension

Return Value:

    STATUS_SUCCESS

Notes:

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PCI_DEVICE_PRESENT_INTERFACE interface;
    PDEVICE_OBJECT targetDevice = NULL;
    KEVENT irpCompleted;
    IO_STATUS_BLOCK statusBlock;
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpStack;
    USHORT interfaceSize;
    ULONG pass;
    PCI_DEVICE_PRESENCE_PARAMETERS parameters;
    BOOLEAN result;

    PAGED_CODE();
    
    targetDevice = IoGetAttachedDeviceReference(PdoExtension->PhysicalDeviceObject);

    for (pass = 0; pass < 2; pass++) {
        
        if (pass == 0) {
            
            //
            // First pass test the old version.
            //
            interfaceSize = FIELD_OFFSET(PCI_DEVICE_PRESENT_INTERFACE, IsDevicePresentEx);

        } else {

            //
            // Second pass test the full new version.
            //
            interfaceSize = sizeof(PCI_DEVICE_PRESENT_INTERFACE);
        }

        //
        // Get an IRP
        //
        //
    // Find out where we are sending the irp
    //

    
        KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);
    
        irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                           targetDevice,
                                           NULL,    // Buffer
                                           0,       // Length
                                           0,       // StartingOffset
                                           &irpCompleted,
                                           &statusBlock
                                           );
        if (!irp) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }
    
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        irp->IoStatus.Information = 0;
    
        //
        // Initialize the stack location
        //
    
        irpStack = IoGetNextIrpStackLocation(irp);
    
        PCI_ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);
    
        irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
    
        irpStack->Parameters.QueryInterface.InterfaceType = (PGUID) &GUID_PCI_DEVICE_PRESENT_INTERFACE;
        irpStack->Parameters.QueryInterface.Version = PCI_DEVICE_PRESENT_INTERFACE_VERSION;
        irpStack->Parameters.QueryInterface.Size = interfaceSize;
        irpStack->Parameters.QueryInterface.Interface = (PINTERFACE)&interface;
        irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;
    
        //
        // Call the driver and wait for completion
        //
    
        status = IoCallDriver(targetDevice, irp);
    
        if (status == STATUS_PENDING) {
    
            KeWaitForSingleObject(&irpCompleted, Executive, KernelMode, FALSE, NULL);
            status = statusBlock.Status;
        }
    
        if (!NT_SUCCESS(status)) {
    
            PciDebugPrintf("Couldn't successfully retrieve interface\n");
            goto cleanup;
        }
    
        PciDebugPrintf("Testing PCI Device Presence Interface\n");
        if (pass==0) {
            PciDebugPrintf("Original Version\n");
        } else {
            PciDebugPrintf("New Version\n");
        }

        PciDebugPrintf("Interface values:\n");
        PciDebugPrintf("\tSize=%d\n",interface.Size);
        PciDebugPrintf("\tVersion=%d\n",interface.Version);
        PciDebugPrintf("\tContext=%d\n",interface.Context);
        PciDebugPrintf("\tInterfaceReference=%d\n",interface.InterfaceReference);
        PciDebugPrintf("\tInterfaceDereference=%d\n",interface.InterfaceDereference);
        PciDebugPrintf("\tIsDevicePresent=%d\n",interface.IsDevicePresent);
        PciDebugPrintf("\tIsDevicePresentEx=%d\n",interface.IsDevicePresentEx);
    
        PciDebugPrintf("Testing IsDevicePresent function\n");
        PciDebugPrintf("\tTesting 8086:7190.03 0000:0000 No flags Should be TRUE, is ");
        result = interface.IsDevicePresent(0x8086,0x7190,3,0,0,0);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 8086:7190.03 0000:0000 PCI_USE_REVISION Should be TRUE, is ");
        result = interface.IsDevicePresent(0x8086,0x7190,3,0,0,PCI_USE_REVISION);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 8086:7190.01 0000:0000 PCI_USE_REVISION Should be FALSE, is ");
        result = interface.IsDevicePresent(0x8086,0x7190,1,0,0,PCI_USE_REVISION);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 8086:1229.05 8086:0009 PCI_USE_SUBSYSTEM_IDS Should be TRUE, is ");
        result = interface.IsDevicePresent(0x8086,0x1229,5,0x8086,9,PCI_USE_SUBSYSTEM_IDS);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 8086:1229.05 8086:0009 PCI_USE_SUBSYSTEM_IDS|PCI_USE_REVISION Should be TRUE, is ");
        result = interface.IsDevicePresent(0x8086,0x1229,5,0x8086,9,PCI_USE_SUBSYSTEM_IDS|PCI_USE_REVISION);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 8086:1229.05 8086:0004 PCI_USE_SUBSYSTEM_IDS Should be FALSE, is ");
        result = interface.IsDevicePresent(0x8086,0x1229,5,0x8086,4,PCI_USE_SUBSYSTEM_IDS);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 8086:1229.05 8084:0009 PCI_USE_SUBSYSTEM_IDS|PCI_USE_REVISION Should be FALSE, is ");
        result = interface.IsDevicePresent(0x8086,0x1229,5,0x8084,9,PCI_USE_SUBSYSTEM_IDS|PCI_USE_REVISION);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 0000:0000.00 0000:0000 No flags Should ASSERT and be FALSE, is ");
        result = interface.IsDevicePresent(0,0,0,0,0,0);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        PciDebugPrintf("\tTesting 0000:0000.00 0000:0000 PCI_USE_SUBSYSTEM_IDS Should ASSERT and be FALSE, is ");
        result = interface.IsDevicePresent(0,0,0,0,0,PCI_USE_SUBSYSTEM_IDS);
        if (result) {
            PciDebugPrintf("TRUE\n");
        } else {
            PciDebugPrintf("FALSE\n");
        }

        if (pass == 1) {
            
            PciDebugPrintf("Testing IsDevicePresentEx function\n");
            PciDebugPrintf("Running the same tests as IsDevicePresent, but using new function\n");
            
            PciDebugPrintf("\tTesting 8086:7190.03 0000:0000 PCI_USE_VENDEV_IDS Should be TRUE, is ");
            parameters.Size = sizeof(PCI_DEVICE_PRESENCE_PARAMETERS);
            parameters.Flags = PCI_USE_VENDEV_IDS;
            parameters.VendorID = 0x8086;
            parameters.DeviceID = 0x7190;
            parameters.RevisionID = 3;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }
    
            PciDebugPrintf("\tTesting 8086:7190.03 0000:0000 PCI_USE_REVISION Should be TRUE, is ");
            parameters.Flags |= PCI_USE_REVISION;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }
    
            PciDebugPrintf("\tTesting 8086:7190.01 0000:0000 PCI_USE_REVISION Should be FALSE, is ");
            parameters.RevisionID = 1;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }
    
            PciDebugPrintf("\tTesting 8086:1229.05 8086:0009 PCI_USE_SUBSYSTEM_IDS Should be TRUE, is ");
            parameters.DeviceID = 0x1229;
            parameters.RevisionID = 5;
            parameters.SubVendorID = 0x8086;
            parameters.SubSystemID = 9;
            parameters.Flags = PCI_USE_VENDEV_IDS | PCI_USE_SUBSYSTEM_IDS;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }
    
            PciDebugPrintf("\tTesting 8086:1229.05 8086:0009 PCI_USE_SUBSYSTEM_IDS|PCI_USE_REVISION Should be TRUE, is ");
            parameters.Flags |= PCI_USE_REVISION;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }
    
            PciDebugPrintf("\tTesting 8086:1229.05 8086:0004 PCI_USE_SUBSYSTEM_IDS Should be FALSE, is ");
            parameters.Flags &= ~PCI_USE_REVISION;
            parameters.SubSystemID = 4;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }
    
            PciDebugPrintf("\tTesting 8086:1229.05 8084:0009 PCI_USE_SUBSYSTEM_IDS|PCI_USE_REVISION Should be FALSE, is ");
            parameters.SubVendorID = 0x8084;
            parameters.SubSystemID = 9;
            parameters.Flags |= PCI_USE_SUBSYSTEM_IDS;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:1229.05 8084:0009 No flags Should ASSERT and be FALSE, is ");
            parameters.Flags = 0;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:1229.05 8084:0009 PCI_USE_VENDEV_IDS bad Size Should ASSERT and be FALSE, is ");
            parameters.SubVendorID = 0x8086;
            parameters.SubSystemID = 9;
            parameters.Flags = PCI_USE_VENDEV_IDS;
            parameters.Size = 3;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 0000:0000.00 0000:0000 No flags Should ASSERT and be FALSE, is ");
            RtlZeroMemory(&parameters, sizeof(PCI_DEVICE_PRESENCE_PARAMETERS));
            parameters.Size = sizeof(PCI_DEVICE_PRESENCE_PARAMETERS);
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("Running tests on new flags\n");
            PciDebugPrintf("\tTesting Class USB Controller PCI_USE_CLASS_SUBCLASS Should be TRUE, is ");
            parameters.Flags = PCI_USE_CLASS_SUBCLASS;
            parameters.BaseClass = PCI_CLASS_SERIAL_BUS_CTLR;
            parameters.SubClass = PCI_SUBCLASS_SB_USB;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting Class USB Controller (UHCI) PCI_USE_CLASS_SUBCLASS|PCI_USE_PROGIF Should be TRUE, is ");
            parameters.Flags = PCI_USE_CLASS_SUBCLASS|PCI_USE_PROGIF;
            parameters.ProgIf = 0;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting Class USB Controller (OHCI) PCI_USE_CLASS_SUBCLASS|PCI_USE_PROGIF Should be FALSE, is ");
            parameters.ProgIf = 0x10;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting Class Wireless RF PCI_USE_CLASS_SUBCLASS Should be FALSE, is ");
            parameters.BaseClass = PCI_CLASS_WIRELESS_CTLR;
            parameters.SubClass = PCI_SUBCLASS_WIRELESS_RF;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:7112 Class USB Controller PCI_USE_VENDEV|PCI_USE_CLASS_SUBCLASS Should be TRUE, is ");
            parameters.VendorID = 0x8086;
            parameters.DeviceID = 0x7112;
            parameters.BaseClass = PCI_CLASS_SERIAL_BUS_CTLR;
            parameters.SubClass = PCI_SUBCLASS_SB_USB;
            parameters.Flags = PCI_USE_VENDEV_IDS|PCI_USE_CLASS_SUBCLASS;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:7112 Class USB Controller PCI_USE_VENDEV|PCI_USE_CLASS_SUBCLASS|PCI_USE_LOCAL_BUS Should be TRUE, is ");
            parameters.VendorID = 0x8086;
            parameters.DeviceID = 0x7112;
            parameters.BaseClass = PCI_CLASS_SERIAL_BUS_CTLR;
            parameters.SubClass = PCI_SUBCLASS_SB_USB;
            parameters.Flags = PCI_USE_VENDEV_IDS|PCI_USE_CLASS_SUBCLASS|PCI_USE_LOCAL_BUS;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:7112 Class USB Controller PCI_USE_VENDEV|PCI_USE_CLASS_SUBCLASS|PCI_USE_LOCAL_DEVICE Should be ?, is ");
            parameters.VendorID = 0x8086;
            parameters.DeviceID = 0x7112;
            parameters.BaseClass = PCI_CLASS_SERIAL_BUS_CTLR;
            parameters.SubClass = PCI_SUBCLASS_SB_USB;
            parameters.Flags = PCI_USE_VENDEV_IDS|PCI_USE_CLASS_SUBCLASS|PCI_USE_LOCAL_DEVICE;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:7112 Class USB Controller PCI_USE_VENDEV|PCI_USE_CLASS_SUBCLASS|PCI_USE_LOCAL_BUS|PCI_USE_LOCAL_DEVICE Should be ?, is ");
            parameters.VendorID = 0x8086;
            parameters.DeviceID = 0x7112;
            parameters.BaseClass = PCI_CLASS_SERIAL_BUS_CTLR;
            parameters.SubClass = PCI_SUBCLASS_SB_USB;
            parameters.Flags = PCI_USE_VENDEV_IDS|PCI_USE_CLASS_SUBCLASS|PCI_USE_LOCAL_DEVICE|PCI_USE_LOCAL_BUS;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:7190 PCI_USE_VENDEV|PCI_USE_LOCAL_DEVICE Should be FALSE, is ");
            parameters.VendorID = 0x8086;
            parameters.DeviceID = 0x7190;
            parameters.Flags = PCI_USE_VENDEV_IDS|PCI_USE_LOCAL_DEVICE;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

            PciDebugPrintf("\tTesting 8086:7190 PCI_USE_VENDEV|PCI_USE_LOCAL_BUS Should be TRUE, is ");
            parameters.VendorID = 0x8086;
            parameters.DeviceID = 0x7190;
            parameters.Flags = PCI_USE_VENDEV_IDS|PCI_USE_LOCAL_BUS;
            result = interface.IsDevicePresentEx(interface.Context,&parameters);
            if (result) {
                PciDebugPrintf("TRUE\n");
            } else {
                PciDebugPrintf("FALSE\n");
            }

        }
    }
    
    //
    // Ok we're done with this stack
    //

    ObDereferenceObject(targetDevice);

    return status;

cleanup:

    if (targetDevice) {
        ObDereferenceObject(targetDevice);
    }

    return status;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\debug.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains debug functions for PCI.SYS.

Author:

    Peter Johnston (peterj)  12-Feb-1997

Revision History:

--*/

#include "pcip.h"

PUCHAR
PciDebugInterfaceTypeToText(
    ULONG InterfaceType
    );

PUCHAR
PciDebugCmResourceTypeToText(
    UCHAR Type
    );

#if DBG

#define PCI_DEBUG_BUFFER_SIZE 256

PCI_DEBUG_LEVEL PciDebug = PciDbgAlways;
ULONG PciDebugStop = 0;

UCHAR PciDebugBuffer[PCI_DEBUG_BUFFER_SIZE];

#endif

VOID
PciDebugPrintf(
    PCI_DEBUG_LEVEL DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for the PCI Bus Driver.

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.
    A bit mask corresponding to various debug items.

    Note: This used to be a level, for backward compatibility, 0 is
    treated as print always.



Return Value:

    None

--*/

{

#if DBG

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel & PciDebug) {

        _vsnprintf(PciDebugBuffer, sizeof(PciDebugBuffer), DebugMessage, ap);

        DbgPrint(PciDebugBuffer);
    }

    va_end(ap);

#endif

} // end PciDebugPrint()

VOID
PciDebugHit(
    ULONG StopOnBit
    )

/*++

Routine Description:

    Called from various places with various bits for arguments.
    If the bit(s) are a subset of the bits in the global PciDebugStop,
    call PciDebugBreak.

Arguments:

    Stop bit(s).

Return Value:

    None

--*/

{

#if DBG

    if (StopOnBit & PciDebugStop) {
        DbgBreakPoint();
    }

#endif

}
//++
//
// Miscellaneous Debug printing routines.
//
//--

#if DBG

static UCHAR PnpIrpUnknownText[] = "** UNKNOWN PNP IRP Minor Code **";
static UCHAR PoIrpUnknownText[]  = "** UNKNOWN PO IRP Minor Code **";

//
// The following really begin with "IRP_MN_"
//

static PUCHAR PnpIrpTypeStrings[] = {

    "START_DEVICE",                // 0x00
    "QUERY_REMOVE_DEVICE",         // 0x01
    "REMOVE_DEVICE",               // 0x02
    "CANCEL_REMOVE_DEVICE",        // 0x03
    "STOP_DEVICE",                 // 0x04
    "QUERY_STOP_DEVICE",           // 0x05
    "CANCEL_STOP_DEVICE",          // 0x06

    "QUERY_DEVICE_RELATIONS",      // 0x07
    "QUERY_INTERFACE",             // 0x08
    "QUERY_CAPABILITIES",          // 0x09
    "QUERY_RESOURCES",             // 0x0A
    "QUERY_RESOURCE_REQUIREMENTS", // 0x0B
    "QUERY_DEVICE_TEXT",           // 0x0C
    "FILTER_RESOURCE_REQUIREMENTS",// 0x0D
    PnpIrpUnknownText,             // 0x0E

    "READ_CONFIG",                 // 0x0F
    "WRITE_CONFIG",                // 0x10
    "EJECT",                       // 0x11
    "SET_LOCK",                    // 0x12
    "QUERY_ID",                    // 0x13
    "QUERY_PNP_DEVICE_STATE",      // 0x14
    "QUERY_BUS_INFORMATION",       // 0x15
    "DEVICE_USAGE_NOTIFICATION"    // 0x16

    };

static PUCHAR PoIrpTypeStrings[] = {

    "WAIT_WAKE",                   // 0x00
    "POWER_SEQUENCE",              // 0x01
    "SET_POWER",                   // 0x02
    "QUERY_POWER"                  // 0x03
    };

static PUCHAR SystemPowerStateStrings[] = {
    "Unspecified",
    "Working",
    "Sleeping1",
    "Sleeping2",
    "Sleeping3",
    "Hibernate",
    "Shutdown"
};

static PUCHAR DevicePowerStateStrings[] = {
    "Unspecified",
    "D0",
    "D1",
    "D2",
    "D3"
};

PUCHAR
PciDebugCmResourceTypeToText(
    UCHAR Type
    )
{
    switch (Type) {
    case CmResourceTypePort:
        return "CmResourceTypePort";
    case CmResourceTypeInterrupt:
        return "CmResourceTypeInterrupt";
    case CmResourceTypeMemory:
        return "CmResourceTypeMemory";
    case CmResourceTypeDma:
        return "CmResourceTypeDma";
    case CmResourceTypeDeviceSpecific:
        return "CmResourceTypeDeviceSpecific";
    case CmResourceTypeBusNumber:
        return "CmResourceTypeBusNumber";
    case CmResourceTypeConfigData:
        return "CmResourceTypeConfigData";
    case CmResourceTypeDevicePrivate:
        return "CmResourceTypeDevicePrivate";
    case CmResourceTypePcCardConfig:
        return "CmResourceTypePcCardConfig";
    default:
        return "*** INVALID RESOURCE TYPE ***";
    }
}

PUCHAR
PciDebugPnpIrpTypeToText(
    ULONG IrpMinorCode
    )
{
    if (IrpMinorCode < (sizeof(PnpIrpTypeStrings)/sizeof(PUCHAR))) {
        return PnpIrpTypeStrings[IrpMinorCode];
    }
    return PnpIrpUnknownText;
}

PUCHAR
PciDebugPoIrpTypeToText(
    ULONG IrpMinorCode
    )
{
    if (IrpMinorCode < (sizeof(PoIrpTypeStrings)/sizeof(PUCHAR))) {
        return PoIrpTypeStrings[IrpMinorCode];
    }
    return PoIrpUnknownText;
}

VOID
PciDebugDumpCommonConfig(
    IN PPCI_COMMON_CONFIG CommonConfig
    )

{
    PULONG dw;
    ULONG  i;

    if (PciDebug < PciDbgPrattling) {
        return;
    }

    dw = (PULONG)CommonConfig;

    for (i = 0; i < PCI_COMMON_HDR_LENGTH; i += sizeof(ULONG)) {
        DbgPrint("  %02x - %08x\n", i, *dw);
        dw++;
    }
}

VOID
PciDebugDumpQueryCapabilities(
    IN PDEVICE_CAPABILITIES C
    )
{
    //
    // Dump the DEVICE_CAPABILITIES structure pointed to by C.
    //

    SYSTEM_POWER_STATE sw = C->SystemWake;
    DEVICE_POWER_STATE dw = C->DeviceWake;
    ULONG i;

    DbgPrint(
        "Capabilities\n  Lock:%d, Eject:%d, Remove:%d, Dock:%d, UniqueId:%d\n",
        C->LockSupported,
        C->EjectSupported,
        C->Removable,
        C->DockDevice,
        C->UniqueID
        );
    DbgPrint(
        "  SilentInstall:%d, RawOk:%d, SurpriseOk:%d\n",
        C->SilentInstall,
        C->RawDeviceOK,
        C->SurpriseRemovalOK
        );
    DbgPrint(
        "  Address %08x, UINumber %08x, Latencies D1 %d, D2 %d, D3 %d\n",
        C->Address,
        C->UINumber,
        C->D1Latency,
        C->D2Latency,
        C->D3Latency
        );

    if (sw > PowerSystemMaximum) {
        sw = PowerSystemMaximum;
    }
    if (dw > PowerDeviceMaximum) {
        dw = PowerDeviceMaximum;
    }
    DbgPrint(
        "  System Wake: %s, Device Wake: %s\n  DeviceState[PowerState] [",
        SystemPowerStateStrings[sw],
        DevicePowerStateStrings[dw]
        );
    for (i = PowerSystemWorking;
         i < (sizeof(C->DeviceState) / sizeof(C->DeviceState[0]));
         i++) {
        dw = C->DeviceState[i];
        if (dw > PowerDeviceMaximum) {
            dw = PowerDeviceMaximum;
        }
        DbgPrint(" %s", DevicePowerStateStrings[dw]);
    }
    DbgPrint(" ]\n");
}


VOID
PciDebugPrintIoResource(
    IN PIO_RESOURCE_DESCRIPTOR D
    )
{
    ULONG  i;
    PUCHAR t;

    t = PciDebugCmResourceTypeToText(D->Type);
    DbgPrint("     IoResource Descriptor dump:  Descriptor @0x%x\n", D);
    DbgPrint("        Option           = 0x%x\n", D->Option);
    DbgPrint("        Type             = %d (%s)\n", D->Type, t);
    DbgPrint("        ShareDisposition = %d\n", D->ShareDisposition);
    DbgPrint("        Flags            = 0x%04X\n", D->Flags);

    for ( i = 0; i < 6; i+=3 ) {
        DbgPrint("        Data[%d] = %08x  %08x  %08x\n",
                 i,
                 D->u.DevicePrivate.Data[i],
                 D->u.DevicePrivate.Data[i+1],
                 D->u.DevicePrivate.Data[i+2]);
    }
}


VOID
PciDebugPrintIoResReqList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResReqList
    )
{
    ULONG                   numlists;
    PIO_RESOURCE_LIST       list;

    if ((PciDebug < PciDbgPrattling) || (IoResReqList == NULL)) {
        return;
    }

    numlists = IoResReqList->AlternativeLists;
    list     = IoResReqList->List;

    DbgPrint("  IO_RESOURCE_REQUIREMENTS_LIST (PCI Bus Driver)\n");
    DbgPrint("     InterfaceType        %d\n", IoResReqList->InterfaceType);
    DbgPrint("     BusNumber            0x%x\n", IoResReqList->BusNumber    );
    DbgPrint("     SlotNumber           %d (0x%x), (d/f = 0x%x/0x%x)\n",
             IoResReqList->SlotNumber,              // in decimal
             IoResReqList->SlotNumber,              // in hex
             IoResReqList->SlotNumber & 0x1f,       // device number
             (IoResReqList->SlotNumber >> 5) & 0x7  // function
            );
    DbgPrint("     AlternativeLists     %d\n", numlists                   );

    while (numlists--) {

        PIO_RESOURCE_DESCRIPTOR resource = list->Descriptors;
        ULONG                   count    = list->Count;

        DbgPrint("\n     List[%d].Count = %d\n", numlists, count);
        while (count--) {
            PciDebugPrintIoResource(resource++);
        }

        list = (PIO_RESOURCE_LIST)resource;
    }
    DbgPrint("\n");
}


VOID
PciDebugPrintPartialResource(
    PCI_DEBUG_LEVEL DebugPrintLevel,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR D
    )
{
    ULONG  i;
    PUCHAR t;

    if (!(PciDebug & DebugPrintLevel)) {
        return;
    }

    t = PciDebugCmResourceTypeToText(D->Type);
    DbgPrint("     Partial Resource Descriptor @0x%x\n", D);
    DbgPrint("        Type             = %d (%s)\n", D->Type, t);
    DbgPrint("        ShareDisposition = %d\n", D->ShareDisposition);
    DbgPrint("        Flags            = 0x%04X\n", D->Flags);

    for ( i = 0; i < 3; i+=3 ) {
        DbgPrint("        Data[%d] = %08x  %08x  %08x\n",
                 i,
                 D->u.DevicePrivate.Data[i],
                 D->u.DevicePrivate.Data[i+1],
                 D->u.DevicePrivate.Data[i+2]);
    }
}

VOID
PciDebugPrintCmResList(
    PCI_DEBUG_LEVEL DebugPrintLevel,
    IN PCM_RESOURCE_LIST ResourceList
    )
{
    ULONG                           numlists;
    PCM_FULL_RESOURCE_DESCRIPTOR    full;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;

    if (!ResourceList || !(PciDebug & DebugPrintLevel)) {
        return;
    }

    numlists = ResourceList->Count;
    full     = ResourceList->List;

    DbgPrint("  CM_RESOURCE_LIST (PCI Bus Driver) (List Count = %d)\n",
             numlists);

    while (numlists--) {
        PCM_PARTIAL_RESOURCE_LIST partial = &full->PartialResourceList;
        ULONG                     count   = partial->Count;

        DbgPrint("     InterfaceType        %d\n", full->InterfaceType);
        DbgPrint("     BusNumber            0x%x\n", full->BusNumber    );

        descriptor = partial->PartialDescriptors;
        while (count--) {
            PciDebugPrintPartialResource(DebugPrintLevel, descriptor);
            descriptor = PciNextPartialDescriptor(descriptor);
        }

        full = (PCM_FULL_RESOURCE_DESCRIPTOR)descriptor;
    }
    DbgPrint("\n");
}

static UCHAR InterfaceTypeUnknownText[]  = "** Unknown interface type **";

static PUCHAR InterfaceTypeText[] = {
    "InterfaceTypeUndefined",   // -1
    "Internal",                 // 0
    "Isa",                      // 1
    "Eisa",                     // 2
    "MicroChannel",             // 3
    "TurboChannel",             // 4
    "PCIBus",                   // 5
    "VMEBus",                   // 6
    "NuBus",                    // 7
    "PCMCIABus",                // 8
    "CBus",                     // 9
    "MPIBus",                   // 10
    "MPSABus",                  // 11
    "ProcessorInternal",        // 12
    "InternalPowerBus",         // 13
    "PNPISABus",                // 14
    "PNPBus"                    // 15
    };

PUCHAR
PciDebugInterfaceTypeToText(
    ULONG InterfaceType
    )
{
    if (InterfaceType < MaximumInterfaceType) {
        ASSERT(InterfaceType + 1 < sizeof(InterfaceTypeText) / sizeof(PUCHAR));
        return InterfaceTypeText[InterfaceType + 1];
    }
    return InterfaceTypeUnknownText;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\device.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    device.c

Abstract:

    This module contains functions associated with enumerating
    ordinary (PCI Header type 0) devices.

Author:

    Peter Johnston (peterj) 09-Mar-1997

Revision History:

--*/

#include "pcip.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, Device_MassageHeaderForLimitsDetermination)
#pragma alloc_text(PAGE, Device_RestoreCurrent)
#pragma alloc_text(PAGE, Device_SaveLimits)
#pragma alloc_text(PAGE, Device_SaveCurrentSettings)
#pragma alloc_text(PAGE, Device_GetAdditionalResourceDescriptors)

#endif

VOID
Device_MassageHeaderForLimitsDetermination(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    The limits for a device are determined by writing ones to the
    Base Address Registers (BARs) and examining what the hardware does
    to them.  For example, if a device requires 256 bytes of space,
    writing 0xffffffff to the BAR which configures this requirement
    tells the device to begin decoding its 256 bytes at that address.
    Clearly this is impossible, at most one byte can be configured
    at that address.  The hardware will lower the address by clearing
    the least significant bits until the range requirement can be met.
    In this case, we would get 0xffffff00 back from the register when
    it is next read.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    The Working configuration has been modified so that all range
    fields have been set to their maximum possible values.

    The Current configuration has been modified such that writing it
    to the hardware will restore the hardware to it's current (disabled)
    state.


--*/

{
    ULONG index;

    index = 0;

    //
    // PCI IDE controllers operating in legacy mode implement
    // the first 4 BARs but don't actually use them,... nor are
    // they initialized correctly, and sometimes, nothing will
    // change if we change them,... but we can't read them to determine
    // if they are implemented or not,... so,...
    //

    if (PCI_IS_LEGACY_IDE_CONTROLLER(This->PdoExtension)) {

        //
        // If both interfaces are in native mode and the BARs behave
        // normally.  If both are in legacy mode then we should skip
        // the first 4 BARs.  Any other combination is meaningless so
        // we skip the BARs and let PCIIDE take the system out when
        // its turn comes.
        //

        index = 4;
    }

    do {
        This->Working->u.type0.BaseAddresses[index] = 0xffffffff;
        index++;
    } while (index < PCI_TYPE0_ADDRESSES);

    //
    // Set the ROM to its maximum as well,... and disable it.
    //

    This->Working->u.type0.ROMBaseAddress =
        0xffffffff & PCI_ADDRESS_ROM_ADDRESS_MASK;

    return;
}

VOID
Device_RestoreCurrent(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Restore any type specific fields in the original copy of config
    space.   In the case of type 0 devices, there are none.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    return;
}

VOID
Device_SaveLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Fill in the Limit structure with a IO_RESOURCE_REQUIREMENT
    for each implemented BAR.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    ULONG index;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PULONG bar = This->Working->u.type0.BaseAddresses;

    //
    // PCI IDE controllers operating in legacy mode implement
    // the first 4 BARs but don't actually use them,... nor are
    // they initialized correctly, and sometimes, nothing will
    // change if we change them,... but we can't read them to determine
    // if they are implemented or not,... so,...
    //

    if (PCI_IS_LEGACY_IDE_CONTROLLER(This->PdoExtension)) {

        //
        // If both interfaces are in native mode and the BARs behave
        // normally.  If both are in legacy mode then we should skip
        // the first 4 BARs.  Any other combination is meaningless so
        // we skip the BARs and let PCIIDE take the system out when
        // its turn comes.
        //
        //
        // Set the limit to zero in the first 4 bars so we will
        // 'detect' the bars as unimplemented.
        //

        for (index = 0; index < 4; index++) {
            bar[index] = 0;
        }
    }

#if defined(PCI_S3_HACKS)

    //
    // Check for S3 868 and 968.  These cards report memory
    // requirements of 32MB but decode 64MB.   Gross huh?
    //

#if defined(PCIIDE_HACKS)

    //
    // Ok, it looks gross but turning the above and below into
    // an elseif seems marginally more efficient.  plj.
    //

    else

#endif

    if (This->PdoExtension->VendorId == 0x5333) {

        USHORT deviceId = This->PdoExtension->DeviceId;

        if ((deviceId == 0x88f0) || (deviceId == 0x8880)) {
            for (index = 0; index < PCI_TYPE0_ADDRESSES; index++) {

                //
                // Check for memory requirement of 32MB and
                // change it to 64MB.
                //

                if (bar[index] == 0xfe000000) {
                    bar[index] = 0xfc000000;

                    PciDebugPrint(
                        PciDbgObnoxious,
                        "PCI - Adjusted broken S3 requirement from 32MB to 64MB\n"
                        );
                }
            }
        }
    }

#endif

#if defined(PCI_CIRRUS_54XX_HACK)

    //
    // This device reports an IO requirement of 0x400 ports, in
    // the second BAR.   What it really wants is access to the VGA
    // registers (3b0 thru 3bb and 3c0 thru 3df).  It will actually
    // allow them to move but (a) the driver doesn't understand this
    // and the device no longer sees the VGA registers, ie vga.sys
    // won't work any more, (b) if the device is under a bridge and
    // the ISA bit is set, we can't satisfy the requirement,.......
    // however, if we left it where it was, it will work under the
    // bridge as long as the bridge has the VGA bit set.
    //
    // Basically, Cirrus tried to make the VGA registers moveable
    // which is a noble thing, unfortunately the implementation
    // requires a bunch of software knowledge that across all the
    // drivers involved, we just don't have.
    //
    // Solution?  Delete the requirement.
    //

    if ((This->PdoExtension->VendorId == 0x1013) &&
        (This->PdoExtension->DeviceId == 0x00a0)) {

        //
        // If the second requirement is IO for length 0x400,
        // currently unassigned, don't report it at all.
        //

        if ((bar[1] & 0xffff) == 0x0000fc01) {

            //
            // Only do this if the device does not have a valid
            // current setting in this BAR.
            //

            if (This->Current->u.type0.BaseAddresses[1] == 1) {

                bar[1] = 0;

#if DBG

                PciDebugPrint(
                    PciDbgObnoxious,
                    "PCI - Ignored Cirrus GD54xx broken IO requirement (400 ports)\n"
                    );

            } else {

                PciDebugPrint(
                    PciDbgInformative,
                    "PCI - Cirrus GD54xx 400 port IO requirement has a valid setting (%08x)\n",
                    This->Current->u.type0.BaseAddresses[1]
                    );
#endif

            }

#if DBG

        } else {

            //
            // The device doesn't look like we expected it to, complain.
            // (unless 0 in which case we assume cirrus already fixed it).
            //

            if (bar[1] != 0) {
                PciDebugPrint(
                    PciDbgInformative,
                    "PCI - Warning Cirrus Adapter 101300a0 has unexpected resource requirement (%08x)\n",
                    bar[1]
                    );
            }
#endif

        }
    }

#endif

    descriptor = This->PdoExtension->Resources->Limit;

    //
    // Create an IO_RESOURCE_DESCRIPTOR for each implemented
    // resource supported by this function.
    //

    for (index = 0; index < PCI_TYPE0_ADDRESSES; index++) {
        if (PciCreateIoDescriptorFromBarLimit(descriptor, bar, FALSE)) {

            //
            // This base address register is 64 bit, skip one.
            //

            ASSERT((index+1) < PCI_TYPE0_ADDRESSES);

            index++;
            bar++;

            //
            // Null descriptor in place holder.
            //

            descriptor++;
            descriptor->Type = CmResourceTypeNull;
        }
        descriptor++;
        bar++;
    }

    //
    // Do the same for the ROM
    //

    PciCreateIoDescriptorFromBarLimit(descriptor,
                                      &This->Working->u.type0.ROMBaseAddress,
                                      TRUE);
}

VOID
Device_SaveCurrentSettings(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Fill in the Current array in the PDO extension with the current
    settings for each implemented BAR.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    ULONG index;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor;
    PULONG baseAddress = This->Current->u.type0.BaseAddresses;
    ULONG bar;
    ULONG addressMask;
    BOOLEAN nonZeroBars = FALSE;

    partial = This->PdoExtension->Resources->Current;
    ioResourceDescriptor = This->PdoExtension->Resources->Limit;

    //
    // Create an CM_PARTIAL_RESOURCE_DESCRIPTOR for each implemented
    // resource supported by this function.
    //
    // Note: SaveLimits must have been called before SaveCurrentSettings
    // so we can tell which BARs are implemented.
    //
    // Note: The following loop runs one extra time to get the ROM.
    //

    for (index = 0;
         index <= PCI_TYPE0_ADDRESSES;
         index++, partial++, ioResourceDescriptor++) {

        partial->Type = ioResourceDescriptor->Type;
        bar = *baseAddress++;

        //
        // If this BAR is not implemented, no further processing for
        // this partial descriptor.
        //

        if (partial->Type == CmResourceTypeNull) {
            continue;
        }

        //
        // Copy the length from the limits descriptor, then we
        // actually need to do a little processing to figure out
        // the current limits.
        //

        partial->Flags = ioResourceDescriptor->Flags;
        partial->ShareDisposition = ioResourceDescriptor->ShareDisposition;
        partial->u.Generic.Length = ioResourceDescriptor->u.Generic.Length;
        partial->u.Generic.Start.HighPart = 0;

        if (index == PCI_TYPE0_ADDRESSES) {

            bar = This->Current->u.type0.ROMBaseAddress;
            addressMask = PCI_ADDRESS_ROM_ADDRESS_MASK;

            //
            // If the ROM Enabled bit is clear, don't record
            // a current setting for this ROM BAR.
            //

            if ((bar & PCI_ROMADDRESS_ENABLED) == 0) {
                partial->Type = CmResourceTypeNull;
                continue;
            }

        } else if (bar & PCI_ADDRESS_IO_SPACE) {

            ASSERT(partial->Type == CmResourceTypePort);
            addressMask = PCI_ADDRESS_IO_ADDRESS_MASK;

        } else {

            ASSERT(partial->Type == CmResourceTypeMemory);
            addressMask = PCI_ADDRESS_MEMORY_ADDRESS_MASK;

            if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_64BIT) {

                //
                // This is a 64 bit PCI device.  Get the high 32 bits
                // from the next BAR.
                //

                partial->u.Generic.Start.HighPart = *baseAddress;

            } else if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_20BIT) {

                //
                // This device must locate below 1MB, the BAR shouldn't
                // have any top bits set but this isn't clear from the
                // spec.  Enforce it by clearing the top bits.
                //

                addressMask &= 0x000fffff;

            }
        }
        partial->u.Generic.Start.LowPart = bar & addressMask;

        if (partial->u.Generic.Start.QuadPart == 0) {

            //
            // No current setting if the value is current setting
            // is 0.
            //

            partial->Type = CmResourceTypeNull;
            continue;
        }
        nonZeroBars = TRUE;
    }

    //
    // Save type 0 specific data in the PDO.
    //

    This->PdoExtension->SubsystemVendorId =
        This->Current->u.type0.SubVendorID;
    This->PdoExtension->SubsystemId =
        This->Current->u.type0.SubSystemID;
}

VOID
Device_ChangeResourceSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    )

/*++

Description:

    Reconfigure each BAR using the settings from the Current array
    in the PDO extension.   All we actually do here is write the new
    settings into the memory pointed to by CommonConfig, the actual
    write to the hardware is done elsewhere.

    Note:  Possibly not all BARs will be changed, at least one has
    changed or this routine would not have been called.

Arguments:

    PdoExtension    A pointer to the PDO extension for this device.
    CurrentConfig   A pointer to the current contents of PCI config
                    space.

Return Value:

    None.

--*/

{
    ULONG index;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    PULONG baseAddress;
    ULONG bar;
    ULONG lowPart;

    if (PdoExtension->Resources == NULL) {

        //
        // Nothing to play with.
        //
        return;
    }

    partial = PdoExtension->Resources->Current;
    baseAddress = CommonConfig->u.type0.BaseAddresses;

    for (index = 0;
         index <= PCI_TYPE0_ADDRESSES;
         index++, partial++, baseAddress++) {

        //
        // If this BAR is not implemented, no further processing for
        // this partial descriptor.
        //

        if (partial->Type == CmResourceTypeNull) {
            continue;
        }

        lowPart = partial->u.Generic.Start.LowPart;

        bar = *baseAddress;

        if (index == PCI_TYPE0_ADDRESSES) {

            ASSERT(partial->Type == CmResourceTypeMemory);

            bar = CommonConfig->u.type0.ROMBaseAddress;
            bar &= ~PCI_ADDRESS_ROM_ADDRESS_MASK;
            bar |= (lowPart & PCI_ADDRESS_ROM_ADDRESS_MASK);
            CommonConfig->u.type0.ROMBaseAddress = bar;

        } else if (bar & PCI_ADDRESS_IO_SPACE) {

            ASSERT(partial->Type == CmResourceTypePort);

            *baseAddress = lowPart;

        } else {

            ASSERT(partial->Type == CmResourceTypeMemory);

            *baseAddress = lowPart;

            if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_64BIT) {

                //
                // This is a 64 bit address.  Need to set the upper
                // 32 bits in the next BAR.
                //

                baseAddress++;
                *baseAddress = partial->u.Generic.Start.HighPart;

                //
                // We need to skip the next partial entry and descrement
                // the loop count because we consumed a BAR here.
                //

                index++;
                partial++;

#if DBG

            } else if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_20BIT) {

                //
                // This device must locate below 1MB, make sure we're
                // configuring it that way.
                //

                ASSERT((lowPart & 0xfff00000) == 0);

#endif

            }
        }
    }
}

VOID
Device_GetAdditionalResourceDescriptors(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig,
    IN PIO_RESOURCE_DESCRIPTOR Resource
    )
{
    //
    // Type 0 (devices) don't require resources not adequately
    // described in the BARs.
    //

    return;
}

NTSTATUS
Device_ResetDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    )
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\config.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    config.c

Abstract:

    Two kinds of config space access are allowed.  One for the config space
    associated with a specific PDO and one for a device specified in terms of
    a (RootFdo, BusNumber, Slot) tuple.

Author:

    Andrew Thornton (andrewth) 27-Aug-1998

Revision History:

--*/

#include "pcip.h"

#define INT_LINE_OFFSET ((ULONG)FIELD_OFFSET(PCI_COMMON_CONFIG,u.type0.InterruptLine))

//
// None of these functions are pageable as they are called to power manage
// devices at high IRQL
//

VOID
PciReadWriteConfigSpace(
    IN PPCI_FDO_EXTENSION ParentFdo,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    IN BOOLEAN Read
    )

/*++

Routine Description:

    This is the base routine through which all config space access from the
    pci driver go.

Arguments:

    ParentFdo - The FDO of the bus who's config space we want

    Slot - The Device/Function of the device on that bus we are interested in

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

    Read - TRUE to read from config space, FALSE to write

Return Value:

    None

Notes:

    If the underlying HAL or ACPI access mechanism failes we bugcheck with a
    PCI_CONFIG_SPACE_ACCESS_FAILURE

--*/

{

    NTSTATUS status;
    PciReadWriteConfig busHandlerReadWrite;
    PCI_READ_WRITE_CONFIG interfaceReadWrite;
    ULONG count;
    PPCI_BUS_INTERFACE_STANDARD busInterface;

    ASSERT(PCI_IS_ROOT_FDO(ParentFdo->BusRootFdoExtension));

    busInterface = ParentFdo->BusRootFdoExtension->PciBusInterface;

    if (busInterface) {

        //
        // If we have a PCI_BUS_INTERFACE use it to access config space
        //

        if (Read) {
            interfaceReadWrite = busInterface->ReadConfig;
        } else {
            interfaceReadWrite = busInterface->WriteConfig;
        }

        //
        // The interface access to config space is at the root of each PCI
        // domain
        //

        count = interfaceReadWrite(
                    busInterface->Context,
                    ParentFdo->BaseBus,
                    Slot.u.AsULONG,
                    Buffer,
                    Offset,
                    Length
                    );

        if (count != Length) {

            KeBugCheckEx(
                PCI_CONFIG_SPACE_ACCESS_FAILURE,
                (ULONG_PTR) ParentFdo->BaseBus, // Bus
                (ULONG_PTR) Slot.u.AsULONG,     // Slot
                (ULONG_PTR) Offset,             // Offset
                (ULONG_PTR) Read                // Read/Write
                );

        }

    } else {

        //
        // The BusHandler interface is at the parent level.
        //
        // NOTE: This means that if hot-plug of bridges (aka Docking) is to be
        // supported then the HAL must provide a PCI_BUS_INTERFACE_STANDARD
        // because it will not have a bus handler for the new bridge so we
        // won't be able to use this code path.
        //

        ASSERT(ParentFdo->BusHandler);

        //
        // We had better not think we can do hot plug
        //

        ASSERT(!PciAssignBusNumbers);

        if (Read) {
            busHandlerReadWrite =
                ((PPCIBUSDATA)ParentFdo->BusHandler->BusData)->ReadConfig;
        } else {
            busHandlerReadWrite =
                ((PPCIBUSDATA)ParentFdo->BusHandler->BusData)->WriteConfig;
        }


        busHandlerReadWrite(ParentFdo->BusHandler,
                            Slot,
                            Buffer,
                            Offset,
                            Length
                            );

    }

}

VOID
PciReadDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    Read the config space for a specific device

Arguments:

    Pdo - The PDO representing the device who's config space we want

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

Return Value:

    None

--*/

{
    PciReadWriteConfigSpace(PCI_PARENT_FDOX(Pdo),
                            Pdo->Slot,
                            Buffer,
                            Offset,
                            Length,
                            TRUE    // read
                            );

}


VOID
PciWriteDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    Write the config space for a specific device

Arguments:

    Pdo - The PDO representing the device who's config space we want

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

Return Value:

    None

--*/

{
#if 0

    //
    // Make sure we never change the interrupt line register
    //

    if ((Offset <= INT_LINE_OFFSET)
    &&  (Offset + Length > INT_LINE_OFFSET)) {

        PUCHAR interruptLine = (PUCHAR)Buffer + INT_LINE_OFFSET - Offset;

        ASSERT(*interruptLine == Pdo->RawInterruptLine);

    }

#endif

    PciReadWriteConfigSpace(PCI_PARENT_FDOX(Pdo),
                            Pdo->Slot,
                            Buffer,
                            Offset,
                            Length,
                            FALSE   // write
                            );

}

VOID
PciReadSlotConfig(
    IN PPCI_FDO_EXTENSION ParentFdo,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    Read config space for a specific bus/slot

Arguments:

    ParentFdo - The FDO of the bus who's config space we want

    Slot - The Device/Function of the device on that bus we are interested in

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

Return Value:

    None

--*/
{
    PciReadWriteConfigSpace(ParentFdo,
                            Slot,
                            Buffer,
                            Offset,
                            Length,
                            TRUE    // read
                            );
}

VOID
PciWriteSlotConfig(
    IN PPCI_FDO_EXTENSION ParentFdo,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    Read config space for a specific bus/slot

Arguments:

    ParentFdo - The FDO of the bus who's config space we want

    Slot - The Device/Function of the device on that bus we are interested in

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

Return Value:

    None

--*/
{
    PciReadWriteConfigSpace(ParentFdo,
                            Slot,
                            Buffer,
                            Offset,
                            Length,
                            FALSE    // write
                            );
}


UCHAR
PciGetAdjustedInterruptLine(
    IN PPCI_PDO_EXTENSION Pdo
    )

/*++

Routine Description:

   This updates the interrupt line the HAL would like the world to see - this
   may or may not be different than the raw pin.

Arguments:

    Pdo - The PDO representing the device who's config space we want

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

Return Value:

    None

--*/

{

    UCHAR adjustedInterruptLine = 0;
    ULONG lengthRead;

    //
    // Just in case anyone messes up the structures
    //

    ASSERT(INT_LINE_OFFSET
           == (ULONG)FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.InterruptLine));
    ASSERT(INT_LINE_OFFSET
           == (ULONG)FIELD_OFFSET(PCI_COMMON_CONFIG, u.type2.InterruptLine));

    if (Pdo->InterruptPin != 0) {

        //
        // Get the adjusted line the HAL wants us to see
        //

        lengthRead = HalGetBusDataByOffset(
                        PCIConfiguration,
                        PCI_PARENT_FDOX(Pdo)->BaseBus,
                        Pdo->Slot.u.AsULONG,
                        &adjustedInterruptLine,
                        INT_LINE_OFFSET,
                        sizeof(adjustedInterruptLine));

        if (lengthRead != sizeof(adjustedInterruptLine)) {

            adjustedInterruptLine = Pdo->RawInterruptLine;

        }
    }

    return adjustedInterruptLine;
}

NTSTATUS
PciQueryForPciBusInterface(
    IN PPCI_FDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    This routine sends an IRP to the parent PDO requesting
    handlers for PCI configuration reads and writes.

Arguments:

    FdoExtension - this PCI bus's FDO extension

Return Value:

    STATUS_SUCCESS, if the PDO provided handlers

Notes:

--*/
{
    NTSTATUS status;
    PPCI_BUS_INTERFACE_STANDARD interface;
    PDEVICE_OBJECT targetDevice = NULL;
    KEVENT irpCompleted;
    IO_STATUS_BLOCK statusBlock;
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    //
    // We only do this for root busses
    //

    ASSERT(PCI_IS_ROOT_FDO(FdoExtension));

    interface = ExAllocatePool(NonPagedPool, sizeof(PCI_BUS_INTERFACE_STANDARD));

    if (!interface) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Find out where we are sending the irp
    //

    targetDevice = IoGetAttachedDeviceReference(FdoExtension->PhysicalDeviceObject);

    //
    // Get an IRP
    //

    KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);

    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       targetDevice,
                                       NULL,    // Buffer
                                       0,       // Length
                                       0,       // StartingOffset
                                       &irpCompleted,
                                       &statusBlock
                                       );
    if (!irp) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    //
    // Initialize the stack location
    //

    irpStack = IoGetNextIrpStackLocation(irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    irpStack->Parameters.QueryInterface.InterfaceType = (PGUID) &GUID_PCI_BUS_INTERFACE_STANDARD;
    irpStack->Parameters.QueryInterface.Version = PCI_BUS_INTERFACE_STANDARD_VERSION;
    irpStack->Parameters.QueryInterface.Size = sizeof (PCI_BUS_INTERFACE_STANDARD);
    irpStack->Parameters.QueryInterface.Interface = (PINTERFACE) interface;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Call the driver and wait for completion
    //

    status = IoCallDriver(targetDevice, irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&irpCompleted, Executive, KernelMode, FALSE, NULL);
        status = statusBlock.Status;
    }

    if (NT_SUCCESS(status)) {

        FdoExtension->PciBusInterface = interface;

        //
        // The interface is already referenced when we get it so we don't need
        // to reference it again.
        //

    } else {

        //
        // We don't have an interface
        //

        FdoExtension->PciBusInterface = NULL;
        ExFreePool(interface);
    }

    //
    // Ok we're done with this stack
    //

    ObDereferenceObject(targetDevice);

    return status;

cleanup:

    if (targetDevice) {
        ObDereferenceObject(targetDevice);
    }

    if (interface) {
        ExFreePool(interface);
    }

    return status;

}


NTSTATUS
PciGetConfigHandlers(
    IN PPCI_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine attempts to get pnp style config handlers from the PCI busses
    enumerator and if they are not provided falls back on using the HAL bus
    handler method.

Arguments:

    FdoExtension - this PCI bus's FDO extension

Return Value:

    STATUS_SUCCESS, if the PDO provided handlers

Notes:

--*/

{
    NTSTATUS status;
    PPCIBUSDATA BusData;

    ASSERT(FdoExtension->BusHandler == NULL);

    //
    // Check if this is a root bus
    //

    if (PCI_IS_ROOT_FDO(FdoExtension)) {

        ASSERT(FdoExtension->PciBusInterface == NULL);

        //
        // Check to see if our parent is offering
        // functions for reading and writing config space.
        //


        status = PciQueryForPciBusInterface(FdoExtension);

        if (NT_SUCCESS(status)) {
            //
            // If we have an interface we support numbering of busses
            //

            PciAssignBusNumbers = TRUE;

        } else {

            //
            // We better not think we can number busses - we should only ever
            // get here if one root provides an interface and the other does not
            //

            ASSERT(!PciAssignBusNumbers);
        }

    } else {

        //
        // Check if our root has a PciBusInterface - which it got from above
        //

        if (FdoExtension->BusRootFdoExtension->PciBusInterface) {
            return STATUS_SUCCESS;
        } else {

            //
            // Set status so we get a bus handler for this bus
            //

            status = STATUS_NOT_SUPPORTED;
        }


    }

    if (!NT_SUCCESS(status)) {

        ASSERT(status == STATUS_NOT_SUPPORTED);

        //
        // Make sure we arn't trying to get a bus handler for a hot plug
        // capable machine
        //

        ASSERT(!PciAssignBusNumbers);

        //
        // We couldn't find config handlers the PnP way,
        // build them from the HAL bus handlers.
        //

        FdoExtension->BusHandler =
            HalReferenceHandlerForBus(PCIBus, FdoExtension->BaseBus);


        if (!FdoExtension->BusHandler) {

            //
            // This must be a bus that arrived hot.  We only support hot anything
            // on ACPI machines and they should have provided a PCI_BUS interface
            // at the root.  Fail the add for this new bus.
            //

            return STATUS_INVALID_DEVICE_REQUEST;   // better code?

        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
PciExternalReadDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    Called when agents outside the PCI driver want to access config space
    (either from a READ_CONFIG IRP or through BUS_INTERFACE_STANDARD).

    This function performs extra sanity checks and sanitization on the
    arguments and also double buffers the data as Buffer might be
    pageable and we access config space at high IRQL.

Arguments:

    Pdo - The PDO representing the device who's config space we want

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

Return Value:

    None

--*/

{
    PUCHAR interruptLine;
    UCHAR doubleBuffer[sizeof(PCI_COMMON_CONFIG)];

    //
    // Validate the request
    //

    if ((Length + Offset) > sizeof(PCI_COMMON_CONFIG)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Read the data into a buffer allocated on the stack with
    // is guaranteed to not be paged as we access config space
    // at > DISPATCH_LEVEL and the DDK says that the buffer
    // *should* be in paged pool.
    //

    PciReadDeviceConfig(Pdo, &doubleBuffer[Offset], Offset, Length);

    //
    // If we are reading the interrupt line register then adjust it.
    //

    if ((Pdo->InterruptPin != 0) &&
        (Offset <= INT_LINE_OFFSET) &&
        (Offset + Length > INT_LINE_OFFSET)) {

        doubleBuffer[INT_LINE_OFFSET] = Pdo->AdjustedInterruptLine;

    }

    RtlCopyMemory(Buffer, &doubleBuffer[Offset], Length);

    return STATUS_SUCCESS;
}


NTSTATUS
PciExternalWriteDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Called when agents outside the PCI driver want to access config space
    (either from a WRITE_CONFIG IRP or through BUS_INTERFACE_STANDARD).

    This function performs extra sanity checks and sanitization on the
    arguments and also double buffers the data as Buffer might be
    pageable and we access config space at high IRQL.

Arguments:

    Pdo - The PDO representing the device who's config space we want

    Buffer - A buffer where the data will be read or written

    Offset - The byte offset in config space where we should start to read/write

    Length - The number of bytes to read/write

Return Value:

    None

--*/

{
    PUCHAR interruptLine;
    UCHAR doubleBuffer[255];
    BOOLEAN illegalAccess = FALSE;
    PVERIFIER_DATA verifierData;

    //
    // Validate the request
    //

    if ((Length + Offset) > sizeof(PCI_COMMON_CONFIG)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Make sure they are not touching registers they should not be.  For
    // backward compatiblity we will just complain and let the request through.
    //

    switch (Pdo->HeaderType) {
    case PCI_DEVICE_TYPE:

        //
        // They should not be writing to their BARS including the ROM BAR
        //
        if (INTERSECT_CONFIG_FIELD(Offset, Length, u.type0.BaseAddresses)
        ||  INTERSECT_CONFIG_FIELD(Offset, Length, u.type0.ROMBaseAddress)) {
            illegalAccess = TRUE;
        }
        break;

    case PCI_BRIDGE_TYPE:
        //
        // For bridges they should not touch the bars, the base and limit registers,
        // the bus numbers or bridge control
        //
        if (INTERSECT_CONFIG_FIELD_RANGE(Offset, Length, u.type1.BaseAddresses, u.type1.SubordinateBus)
        ||  INTERSECT_CONFIG_FIELD_RANGE(Offset, Length, u.type1.IOBase, u.type1.IOLimit)
        ||  INTERSECT_CONFIG_FIELD_RANGE(Offset, Length, u.type1.MemoryBase, u.type1.IOLimitUpper16)
        ||  INTERSECT_CONFIG_FIELD(Offset, Length, u.type1.ROMBaseAddress)) {
            illegalAccess = TRUE;
        }
        break;

    case PCI_CARDBUS_BRIDGE_TYPE:

        //
        // For bridges they should not touch the bars, the base and limit registers
        // or the bus numbers.  Bridge control is modified by PCICIA to control cardbus
        // IRQ routing so must be ok.
        //
        if (INTERSECT_CONFIG_FIELD(Offset, Length, u.type2.SocketRegistersBaseAddress)
        ||  INTERSECT_CONFIG_FIELD_RANGE(Offset, Length, u.type2.PrimaryBus, u.type2.SubordinateBus)
        ||  INTERSECT_CONFIG_FIELD(Offset, Length, u.type2.Range)) {
            illegalAccess = TRUE;
        }
        break;
    }

    if (illegalAccess) {

        verifierData = PciVerifierRetrieveFailureData(
            PCI_VERIFIER_PROTECTED_CONFIGSPACE_ACCESS
            );

        ASSERT(verifierData);

        //
        // We fail the devnode instead of the driver because we don't actually
        // have an address to pass to the driver verifier.
        //
        VfFailDeviceNode(
            Pdo->PhysicalDeviceObject,
            PCI_VERIFIER_DETECTED_VIOLATION,
            PCI_VERIFIER_PROTECTED_CONFIGSPACE_ACCESS,
            verifierData->FailureClass,
            &verifierData->Flags,
            verifierData->FailureText,
            "%DevObj%Ulong%Ulong",
            Pdo->PhysicalDeviceObject,
            Offset,
            Length
            );
    }


    //
    // Copy the data into a buffer allocated on the stack with
    // is guaranteed to not be paged as we access config space
    // at > DISPATCH_LEVEL and the DDK says that the buffer
    // *should* be in paged pool.
    //

    RtlCopyMemory(doubleBuffer, Buffer, Length);

    //
    // If we are writing the interrupt line register then adjust it so we write
    // the raw value back again
    //

    if ((Pdo->InterruptPin != 0) &&
        (Offset <= INT_LINE_OFFSET) &&
        (Offset + Length > INT_LINE_OFFSET)) {

        interruptLine = (PUCHAR)doubleBuffer + INT_LINE_OFFSET - Offset;

        //
        // Adjust the interrupt line with what the HAL wants us to see
        //

        *interruptLine = Pdo->RawInterruptLine;

    }

    PciWriteDeviceConfig(Pdo, doubleBuffer, Offset, Length);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\dispatch.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains all of the data variables that are used for
    dispatching IRPs in the PCI Driver. The major Irp tables might
    be assigned as follows:

                                   +-- PCI Bus ---------IRP--+
                                   | FDO: PciFdoDispatchTable |
                                   | PDO:                     |
                                   +--------------------------+

                        +-- PCI Bus ---------IRP--+
                        | FDO: PciFdoDispatchTable |
                        | PDO: PciPdoDispatchTable |
                        +--------------------------+

 +-- PCI Device -----------IRP--+  +-- Cardbus Device -------IRP--+
 | FDO:                          |  | FDO:                          |
 | PDO: PciPdoDispatchTable      |  | PDO:                          |
 +-------------------------------+  +-------------------------------+


Author:

    Peter Johnston (peterj) 20-Nov-1996

Revision History:

Environment:

    NT Kernel Model Driver only

--*/

#include "pcip.h"

VOID
PciDispatchInvalidObject(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PUCHAR MajorString
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciDispatchInvalidObject)
#pragma alloc_text(PAGE, PciCallDownIrpStack)
#endif

#if DBG

BOOLEAN
PciDebugIrpDispatchDisplay(
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN ULONG                 MinorTableMax
    );

ULONG PciBreakOnPdoPnpIrp = 0;
ULONG PciBreakOnFdoPnpIrp = 0;
ULONG PciBreakOnPdoPowerIrp = 0;
ULONG PciBreakOnFdoPowerIrp = 0;

#endif


NTSTATUS
PciDispatchIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION        irpSp;
    PPCI_COMMON_EXTENSION     deviceExtension;
    PPCI_MJ_DISPATCH_TABLE    dispatchTable;
    PPCI_MN_DISPATCH_TABLE    minorTable;
    ULONG                     minorTableMax;
    PPCI_MN_DISPATCH_TABLE    irpDispatchTableEntry;
    PCI_MN_DISPATCH_FUNCTION  irpDispatchHandler;
    NTSTATUS                  status;
    PCI_DISPATCH_STYLE        irpDispatchStyle;
    BOOLEAN                   passDown;

    //
    // Get the Irp stack pointer
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // And our device extension
    //
    deviceExtension = ((PPCI_COMMON_EXTENSION)(DeviceObject->DeviceExtension));

    //
    // In checked, assert things aren't screwey.
    //
    ASSERT((deviceExtension->ExtensionType == PCI_EXTENSIONTYPE_PDO)||
           (deviceExtension->ExtensionType == PCI_EXTENSIONTYPE_FDO));

    if (deviceExtension->DeviceState == PciDeleted) {

        //
        // We should not be getting IRPs. Fail the invalid request.
        //
        status = STATUS_NO_SUCH_DEVICE;
        passDown = FALSE;
        goto FinishUpIrp;
    }

    //
    // Get the correct IRP handler.
    //
    dispatchTable = deviceExtension->IrpDispatchTable;

    switch(irpSp->MajorFunction) {

        case IRP_MJ_PNP:

            minorTable    = dispatchTable->PnpIrpDispatchTable;
            minorTableMax = dispatchTable->PnpIrpMaximumMinorFunction;
            break;

        case IRP_MJ_POWER:

            minorTable    = dispatchTable->PowerIrpDispatchTable;
            minorTableMax = dispatchTable->PowerIrpMaximumMinorFunction;
            break;

        case IRP_MJ_SYSTEM_CONTROL:
            
             irpDispatchHandler = dispatchTable->SystemControlIrpDispatchFunction;
             irpDispatchStyle = dispatchTable->SystemControlIrpDispatchStyle;
             minorTableMax = (ULONG) -1; // Always "handled"
             goto CallDispatchHandler;

        default:

            irpDispatchHandler = dispatchTable->OtherIrpDispatchFunction;
            irpDispatchStyle = dispatchTable->OtherIrpDispatchStyle;
            minorTableMax = (ULONG) -1; // Always "handled"
            goto CallDispatchHandler;
    }

    //
    // Grab the appropriate dispatch handler from the table. The last chance
    // handler is always at the end of the table so that the normal code path
    // is fast. Grab the dispatch style too.
    //
    irpDispatchTableEntry = (irpSp->MinorFunction <= minorTableMax) ?
        minorTable+irpSp->MinorFunction :
        minorTable+minorTableMax+1;

    irpDispatchStyle   = irpDispatchTableEntry->DispatchStyle;
    irpDispatchHandler = irpDispatchTableEntry->DispatchFunction;

CallDispatchHandler:

#if DBG
    if (PciDebugIrpDispatchDisplay(irpSp, deviceExtension, minorTableMax)) {
        DbgBreakPoint();
    }
#endif

    //
    // For now, if handlers want to see the IRP after completion, pass it down
    // synchronously. Later we can get more fancy.
    //
    if (irpDispatchStyle == IRP_UPWARD) {

        PciCallDownIrpStack(deviceExtension, Irp);
    }

    //
    // Call the handler
    //
    status = (irpDispatchHandler)(Irp, irpSp, deviceExtension);

    //
    // Post-op. Update IRP status and send Irp along it's way iff appropriate.
    //
    switch(irpDispatchStyle) {

        //
        // For this style, the IRP is being handled entirely our handler. Touch
        // nothing.
        //
        case IRP_DISPATCH:
            return status;

        //
        // For this style, the IRP status will be appropriately updated iff
        // status != STATUS_NOT_SUPPORTED. The IRP will be completed or
        // passed down appropriately.
        //
        case IRP_DOWNWARD:
            passDown = TRUE;
            break;

        //
        // For this style, the IRP will be completed and have it's status
        // appropriately updated iff status != STATUS_NOT_SUPPORTED
        //
        case IRP_COMPLETE:
            passDown = FALSE;
            break;

        //
        // For this style, the IRP status will be appropriately updated iff
        // status != STATUS_NOT_SUPPORTED. The IRP has already been sent down,
        // and must be completed.
        //
        case IRP_UPWARD:
            passDown = FALSE;
            break;

        default:
            ASSERT(0);
            passDown = FALSE;
            break;
    }

    //
    // STATUS_NOT_SUPPORTED is the only illegal failure code. So if one of our
    // table handlers returns this, it means the dispatch handler does not know
    // what to do with the IRP. In that case, we must leave the status
    // untouched, otherwise we update it. In both cases, return the correct
    // status value.
    //
    if (status == STATUS_PENDING) {

        return status;

    }

FinishUpIrp:

    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;
    }

    if (passDown && (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED))) {

        return PciPassIrpFromFdoToPdo(deviceExtension, Irp);
    }

    //
    // Read back status to return
    //
    status = Irp->IoStatus.Status;

    //
    // Power IRPs need just a little more help...
    //
    if (irpSp->MajorFunction == IRP_MJ_POWER) {

        //
        // Start the next power irp
        //
        PoStartNextPowerIrp(Irp);
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
PciSetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++

Routine Description:

    This routine is used as a completion routine when an IRP is passed
    down the stack but more processing must be done on the way back up.
    The effect of using this as a completion routine is that the IRP
    will not be destroyed in IoCompleteRequest as called by the lower
    level object.  The event which is a KEVENT is signaled to allow
    processing to continue

Arguments:

    DeviceObject - Supplies the device object

    Irp - The IRP we are processing

    Event - Supplies the event to be signaled

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    ASSERT(Event);

    //
    // This can be called at DISPATCH_LEVEL so must not be paged
    //

    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
PciPassIrpFromFdoToPdo(
    PPCI_COMMON_EXTENSION  DeviceExtension,
    PIRP                   Irp
    )

/*++

Description:

    Given an FDO, pass the IRP to the next device object in the
    device stack.  This is the PDO if there are no lower level
    filters.

    Note: This routine is used only if we do not expect to do
    any further processing on this IRP at this level.

    Note: For Power IRPs, the next power IRP is *not* started.

Arguments:

    DeviceObject - the Fdo
    Irp - the request

Return Value:

    Returns the result from calling the next level.

--*/

{
    PPCI_FDO_EXTENSION     fdoExtension;

#if DBG
    PciDebugPrint(PciDbgInformative, "Pci PassIrp ...\n");
#endif

    //
    // Get the pointer to the device extension.
    //

    fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

    //
    // Call the PDO driver with the request.
    //
    if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_POWER) {

        //
        // ADRIAO BUGBUG 10/22/98 - Power IRPs don't appear to be skipable.
        //                          Need to investigate in ntos\po\pocall,
        //                          who may be mistakenly checking the current
        //                          instead of the next IrpSp.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);

        //
        // Start the next power irp
        //
        PoStartNextPowerIrp(Irp);

        //
        // And now you know why this function isn't pageable...
        //
        return PoCallDriver(fdoExtension->AttachedDeviceObject, Irp);

    } else {

        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(fdoExtension->AttachedDeviceObject, Irp);
    }
}

NTSTATUS
PciCallDownIrpStack(
    PPCI_COMMON_EXTENSION  DeviceExtension,
    PIRP                   Irp
    )

/*++

Description:

    Pass the IRP to the next device object in the device stack.  This
    routine is used when more processing is required at this level on
    this IRP on the way back up.

Arguments:

    DeviceObject - the Fdo
    Irp - the request

Return Value:

    Returns the result from calling the next level.

--*/

{
    PPCI_FDO_EXTENSION     fdoExtension;
    NTSTATUS           status;
    KEVENT             event;

    PAGED_CODE();

#if DBG
    PciDebugPrint(PciDbgInformative, "PciCallDownIrpStack ...\n");
#endif

    fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;
    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Set our completion routine
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           PciSetEventCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    //
    // Pass down the driver stack
    status = IoCallDriver(fdoExtension->AttachedDeviceObject, Irp);

    //
    // If we did things asynchronously then wait on our event
    //

    if (status == STATUS_PENDING) {

        //
        // We do a KernelMode wait so that our stack where the event is
        // doesn't get paged out!
        //

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

        status = Irp->IoStatus.Status;
    }

    return status;
}

VOID
PciDispatchInvalidObject(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PUCHAR         MajorString
    )
{
    PciDebugPrint(
        PciDbgInformative,
        "PCI - %s IRP for unknown or corrupted Device Object.\n",
        MajorString
        );

    PciDebugPrint(
        PciDbgInformative,
        "      Device Object            0x%08x\n",
        DeviceObject
        );

    PciDebugPrint(
        PciDbgInformative,
        "      Device Object Extension  0x%08x\n",
        DeviceObject->DeviceExtension
        );

    PciDebugPrint(
        PciDbgInformative,
        "      Extension Signature      0x%08x\n",
        ((PPCI_PDO_EXTENSION)DeviceObject->DeviceExtension)->ExtensionType
        );
}

NTSTATUS
PciIrpNotSupported(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
PciIrpInvalidDeviceRequest(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    return STATUS_INVALID_DEVICE_REQUEST;
}

#if DBG
BOOLEAN
PciDebugIrpDispatchDisplay(
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN ULONG                 MinorTableMax
    )
{
    ULONG irpBreakMask;
    ULONG debugPrintMask;
    PUCHAR debugIrpText;

    //
    // Pick up the irpBreakMasks
    //
    switch(IrpSp->MajorFunction) {

        case IRP_MJ_PNP:

            irpBreakMask =
                (DeviceExtension->ExtensionType == PCI_EXTENSIONTYPE_PDO) ?
                PciBreakOnPdoPnpIrp :
                PciBreakOnFdoPnpIrp;

            debugIrpText = PciDebugPnpIrpTypeToText(IrpSp->MinorFunction);

            break;

        case IRP_MJ_POWER:

            irpBreakMask =
                (DeviceExtension->ExtensionType == PCI_EXTENSIONTYPE_PDO) ?
                PciBreakOnPdoPowerIrp :
                PciBreakOnFdoPowerIrp;

            debugIrpText = PciDebugPoIrpTypeToText(IrpSp->MinorFunction);

            break;

        default:

            debugIrpText = "";
            irpBreakMask = 0;
            break;
    }

    //
    // Print out stuff...
    //
    debugPrintMask = 0;
    if (DeviceExtension->ExtensionType == PCI_EXTENSIONTYPE_PDO) {

        switch(IrpSp->MajorFunction) {

            case IRP_MJ_POWER: debugPrintMask = PciDbgPoIrpsPdo;  break;
            case IRP_MJ_PNP:   debugPrintMask = PciDbgPnpIrpsPdo; break;
        }

    } else {

        switch(IrpSp->MajorFunction) {

            case IRP_MJ_POWER: debugPrintMask = PciDbgPoIrpsFdo;  break;
            case IRP_MJ_PNP:   debugPrintMask = PciDbgPnpIrpsFdo; break;
        }
    }

    if (DeviceExtension->ExtensionType == PCI_EXTENSIONTYPE_PDO) {

        PPCI_PDO_EXTENSION pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

        PciDebugPrint(
            debugPrintMask,
            "PDO(b=0x%x, d=0x%x, f=0x%x)<-%s\n",
            PCI_PARENT_FDOX(pdoExtension)->BaseBus,
            pdoExtension->Slot.u.bits.DeviceNumber,
            pdoExtension->Slot.u.bits.FunctionNumber,
            debugIrpText
            );

    } else {

        PPCI_FDO_EXTENSION fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

        PciDebugPrint(
            debugPrintMask,
            "FDO(%x)<-%s\n",
            fdoExtension,
            debugIrpText
            );
    }

    //
    // If it's an unknown minor IRP, squirt some text to the debugger...
    //
    if (IrpSp->MinorFunction > MinorTableMax) {

        PciDebugPrint(debugPrintMask | PciDbgInformative,
                      "Unknown IRP, minor = 0x%x\n",
                      IrpSp->MinorFunction);
    }

    return ((irpBreakMask & (1 << IrpSp->MinorFunction))!=0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\enum.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    enum.c

Abstract:

    This module contains functions associated with enumerating the
    PCI buses.

Author:

    Peter Johnston (peterj) 20-Nov-1996

Revision History:

   Elliot Shmukler (t-ellios) 7-15-1998      Added support for MSI-capable devices.

--*/

#include "pcip.h"

NTSTATUS
PciScanBus(
    IN PPCI_FDO_EXTENSION FdoExtension
    );

VOID
PciFreeIoRequirementsList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST List
    );

PCM_RESOURCE_LIST
PciAllocateCmResourceList(
    IN ULONG ResourceCount,
    IN ULONG BusNumber
    );


PCI_CONFIGURATOR PciConfigurators[] = {
    {
        Device_MassageHeaderForLimitsDetermination,
        Device_RestoreCurrent,
        Device_SaveLimits,
        Device_SaveCurrentSettings,
        Device_ChangeResourceSettings,
        Device_GetAdditionalResourceDescriptors,
        Device_ResetDevice
    },
    {
        PPBridge_MassageHeaderForLimitsDetermination,
        PPBridge_RestoreCurrent,
        PPBridge_SaveLimits,
        PPBridge_SaveCurrentSettings,
        PPBridge_ChangeResourceSettings,
        PPBridge_GetAdditionalResourceDescriptors,
        PPBridge_ResetDevice
    },
    {
        Cardbus_MassageHeaderForLimitsDetermination,
        Cardbus_RestoreCurrent,
        Cardbus_SaveLimits,
        Cardbus_SaveCurrentSettings,
        Cardbus_ChangeResourceSettings,
        Cardbus_GetAdditionalResourceDescriptors,
        Cardbus_ResetDevice
    },
};

//
// When dealing with devices whose configuration is totally
// unknown to us, we may want to emit the device but not its
// resources,... or, we may not want to see the device at all.
//

typedef enum {
    EnumHackConfigSpace,
    EnumBusScan,
    EnumResourceDetermination,
    EnumStartDevice
} ENUM_OPERATION_TYPE;

PIO_RESOURCE_REQUIREMENTS_LIST PciZeroIoResourceRequirements;

extern PULONG InitSafeBootMode;

//
// Prototypes for functions contained and only used in this module.
//


NTSTATUS
PciGetFunctionLimits(
    IN PPCI_PDO_EXTENSION     PdoExtension,
    IN PPCI_COMMON_CONFIG CurrentConfig,
    IN ULONGLONG          DeviceFlags
    );

NTSTATUS
PcipGetFunctionLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

BOOLEAN
PciSkipThisFunction(
    IN  PPCI_COMMON_CONFIG  Config,
    IN  PCI_SLOT_NUMBER     Slot,
    IN  ENUM_OPERATION_TYPE Operation,
    IN  ULONGLONG           DeviceFlags
    );

VOID
PciPrivateResourceInitialize(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    IN PCI_PRIVATE_RESOURCE_TYPES PrivateResourceType,
    IN ULONG Data
    );

VOID
PciGetInUseRanges(
    IN  PPCI_PDO_EXTENSION                  PdoExtension,
    IN  PPCI_COMMON_CONFIG              CurrentConfig,
    IN  PCM_PARTIAL_RESOURCE_DESCRIPTOR InUse
    );

VOID
PciWriteLimitsAndRestoreCurrent(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
PciGetEnhancedCapabilities(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG Config
    );

BOOLEAN
PcipIsSameDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

BOOLEAN
PciConfigureIdeController(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN OUT PPCI_COMMON_CONFIG Config,
    IN BOOLEAN TurnOffAllNative
    );
VOID
PciBuildGraduatedWindow(
    IN PIO_RESOURCE_DESCRIPTOR PrototypeDescriptor,
    IN ULONG WindowMax,
    IN ULONG WindowCount,
    OUT PIO_RESOURCE_DESCRIPTOR OutputDescriptor
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, PciAllocateCmResourceList)
#pragma alloc_text(PAGE, PciComputeNewCurrentSettings)
#pragma alloc_text(PAGE, PciFreeIoRequirementsList)
#pragma alloc_text(PAGE, PciGetInUseRanges)
#pragma alloc_text(PAGE, PciQueryDeviceRelations)
#pragma alloc_text(PAGE, PciQueryTargetDeviceRelations)
#pragma alloc_text(PAGE, PciQueryRequirements)
#pragma alloc_text(PAGE, PciQueryResources)
#pragma alloc_text(PAGE, PciScanBus)
#pragma alloc_text(PAGE, PciBuildRequirementsList)
#pragma alloc_text(PAGE, PciGetFunctionLimits)
#pragma alloc_text(PAGE, PcipGetFunctionLimits)
#pragma alloc_text(PAGE, PciPrivateResourceInitialize)
#pragma alloc_text(PAGE, PciWriteLimitsAndRestoreCurrent)
#pragma alloc_text(PAGE, PciGetEnhancedCapabilities)
#pragma alloc_text(PAGE, PciBuildGraduatedWindow)

#endif

BOOLEAN
PciSkipThisFunction(
    IN  PPCI_COMMON_CONFIG  Config,
    IN  PCI_SLOT_NUMBER     Slot,
    IN  ENUM_OPERATION_TYPE Operation,
    IN  ULONGLONG           RegistryFlags
    )

/*++

Routine Description:

    Check for known defective parts and return TRUE if this driver
    should do no further processing on this function.

Arguments:

    Config  Pointer to a copy of the common configuration header as
            read from the function's configuration space.

Return Value:

    TRUE is this function is not known to cause problems, FALSE
    if the function should be skipped altogether.

--*/

{
    ULONGLONG   flags = RegistryFlags;

#define SKIP_IF_FLAG(f, skip)   if (flags & (f)) goto skip
#define FLAG_SET(f)             (flags & (f))

    switch (Operation) {
    case EnumBusScan:

        //
        // Test the flags we care about during a bus scan.
        // Eg: the ones that say "pretend we never saw this device".
        //

        SKIP_IF_FLAG(PCI_HACK_NO_ENUM_AT_ALL, skipFunction);

        if (FLAG_SET(PCI_HACK_DOUBLE_DECKER) &&
            (Slot.u.bits.DeviceNumber >= 16)) {

            //
            // This device seems to look at only the lower 4 bits of
            // its DEVSEL lines, ie it is mirrored in the upper half
            // if the buss's device domain.
            //

            PciDebugPrint(
                PciDbgInformative,
                "    Device (Ven %04x Dev %04x (d=0x%x, f=0x%x)) is a ghost.\n",
                Config->VendorID,
                Config->DeviceID,
                Slot.u.bits.DeviceNumber,
                Slot.u.bits.FunctionNumber
                );
            goto skipFunction;
        }

        break;

    case EnumResourceDetermination:

        //
        // Limit the flags to those applicable to resource determination.
        //

        SKIP_IF_FLAG(PCI_HACK_ENUM_NO_RESOURCE, skipFunction);
        break;

    default:
        ASSERTMSG("PCI Skip Function - Operation type unknown.", 0);

        //
        // Don't know how to apply flags here.
        //
    }

    switch (Config->BaseClass) {
    case PCI_CLASS_NOT_DEFINED:

        //
        // Currently we get this from VendorID = 8086, DeviceID = 0008,
        // which reports a bunch of bogus resources.
        //
        // We have no idea what it really is either.
        //

        PciDebugPrint(
            PciDbgInformative,
            "    Vendor %04x, Device %04x has class code of PCI_CLASS_NOT_DEFINED\n",
            Config->VendorID,
            Config->DeviceID
            );

        // This case should be added to the registry.

        if ((Config->VendorID == 0x8086) &&
            (Config->DeviceID == 0x0008)) {
            goto skipFunction;
        }
        break;

    case PCI_CLASS_BRIDGE_DEV:

        switch (Config->SubClass) {
        case PCI_SUBCLASS_BR_HOST:

            //
            // It's a host bridge, emit the PDO in case there is
            // a (miniport) driver for it, but under no circumstances
            // should we attempt to figure out what resources it
            // consumes (we don't know the format of its configuration
            // space).
            //

        case PCI_SUBCLASS_BR_ISA:
        case PCI_SUBCLASS_BR_EISA:
        case PCI_SUBCLASS_BR_MCA:

            //
            // Microchannel bridges report their resource usage
            // like good citizens.   Unfortunately we really want
            // them to behave like ISA bridges and consume no
            // resources themselves.  Their children are subtractive
            // from the parent bus.   Enumerate the device but not
            // its resources.
            //

            if (Operation == EnumResourceDetermination) {
                goto skipFunction;
            }
            break;
        }
    }

    //
    // Verify we understand the header type.
    //

    if (PciGetConfigurationType(Config) > PCI_MAX_CONFIG_TYPE) {
        goto skipFunction;
    }

    //
    // Nothing interesting,
    //

    return FALSE;

skipFunction:

    PciDebugPrint(PciDbgPrattling, "   Device skipped (not enumerated).\n");
    return TRUE;
}

VOID
PciApplyHacks(
    IN  PPCI_FDO_EXTENSION      FdoExtension,
    IN  PPCI_COMMON_CONFIG  Config,
    IN  PCI_SLOT_NUMBER     Slot,
    IN  ENUM_OPERATION_TYPE Operation,
    IN  PPCI_PDO_EXTENSION      PdoExtension OPTIONAL
    )
{

    switch (Operation) {
    case EnumHackConfigSpace:

        ASSERT(PdoExtension == NULL);

        //
        // Some devices (e.g. pre-2.0 devices) do not report reasonable class
        // codes.  Update the class code for a given set of devices so that we
        // don't have to special-case these devices throughout the driver.
        //

        switch (Config->VendorID) {

        //
        // Intel
        //

        case 0x8086:

            switch (Config->DeviceID) {

            //
            // PCEB - PCI/EISA Bridge (pre 2.0)
            //

            case 0x0482:
                Config->BaseClass = PCI_CLASS_BRIDGE_DEV;
                Config->SubClass = PCI_SUBCLASS_BR_EISA;
#if DBG
                if (PdoExtension != NULL) {
                    PdoExtension->ExpectedWritebackFailure = TRUE;
                }
#endif
                break;

            //
            // SIO - PCI/ISA Bridge (pre 2.0)
            //

            case 0x0484:
                Config->BaseClass = PCI_CLASS_BRIDGE_DEV;
                Config->SubClass = PCI_SUBCLASS_BR_ISA;
#if DBG
                if (PdoExtension != NULL) {
                    PdoExtension->ExpectedWritebackFailure = TRUE;
                }
#endif
                break;

            }

            break;

        }

        break;



    case EnumBusScan:

        ASSERT(PdoExtension);

        if ((Config->VendorID == 0x1045) &&
            (Config->DeviceID == 0xc621)) {

            //
            // Bug 131482.   Force this device into legacy mode for
            // the purposes of detection anyway.
            //

            Config->ProgIf &= ~(PCI_IDE_PRIMARY_NATIVE_MODE
                                | PCI_IDE_SECONDARY_NATIVE_MODE);

#if DBG
            //
            // This field is not actually writeable so don't tell
            // people the writeback failed (we don't care).
            //

            PdoExtension->ExpectedWritebackFailure = TRUE;
#endif

        } else if (Config->BaseClass == PCI_CLASS_MASS_STORAGE_CTLR
        &&  Config->SubClass == PCI_SUBCLASS_MSC_IDE_CTLR) {

            //
            // Check with the BIOS to ensure that it can deal with the mode change
            // This is indicated by the *parent* of the device having a method
            // called NATA which returns a package of integers which are slots
            // in _ADR format that can be switched to native mode.
            //
            // Enabling native mode might expose BIOS bugs like interrupt routing problems
            // that could prevent the machine from booting, so don't do this for
            // safe mode, so that the user has some way to boot.
            //
            // For XP SP1, also check for a system wide hack flag that will not be set
            // by a service pack installed through update.exe.  This way we
            // know we will only be enabling this feature on slipstreamed builds.
            //
            if ((PciEnableNativeModeATA != 0) &&
                (*InitSafeBootMode == 0) &&
                PciIsSlotPresentInParentMethod(PdoExtension, (ULONG)'ATAN')) {
                
                PdoExtension->BIOSAllowsIDESwitchToNativeMode = TRUE;

            } else {

                PdoExtension->BIOSAllowsIDESwitchToNativeMode = FALSE;
            }
            
            //
            // Config is updated to reflect the results of the switch
            // if any.  Relied upon below.
            //

            PdoExtension->SwitchedIDEToNativeMode =
                PciConfigureIdeController(PdoExtension, Config, TRUE);
        }

        //
        // If the controller is (still) in legacy mode then it
        // consume 2 ISA interrupts whatever its interrupt pin says
        // force the driver to figure out interrupts on its own.
        //
        // Examine Base Class, Sub Class and Programming Interface,
        // if legacy mode, pretend PIN == 0.
        //

        if (PCI_IS_LEGACY_IDE_CONTROLLER(Config)) {

            //
            // Legacy mode.  Pretend there is no PCI interrupt.
            //

            Config->u.type0.InterruptPin = 0;
        }

        //
        // This hack doesn't change the config space for this device but enables
        // a hack in the PCI arbiters to reserve a large number IO ranges for
        // broken S3 and ATI cards.  These legacy cards don't function behind a
        // bridge so we only perform the check on a root bus and only perform it
        // once
        //

        if ((PdoExtension->HackFlags & PCI_HACK_VIDEO_LEGACY_DECODE)
        &&  PCI_IS_ROOT_FDO(FdoExtension)
        &&  !FdoExtension->BrokenVideoHackApplied) {

            ario_ApplyBrokenVideoHack(FdoExtension);

        }

        //
        // Check if this is the broken Compaq hot-plug controller that
        // is integrated into the Profusion chipset.  It only does a 32bit
        // decode in a 64bit address space... Does this seem familiar to anyone...
        // can you say ISA aliasing!
        //
        // The solution is to disable the memory decode.  But so that the user
        // gets to keep the hot-plug functionality we need to still enumerate
        // but prune out the memory requirement and rely on the fact that the
        // registers can be accessed through config space.  This is done later
        // in PciGetRequirements.
        //
        // Only do this on machines with PAE enabled as they can have > 4GB.
        // Note that this will only work on x86 machines but this is an x86 only
        // chipset.  Only revision 0x11 was broken.
        //

        if (Config->VendorID == 0x0e11
        &&  Config->DeviceID == 0xa0f7
        &&  Config->RevisionID == 0x11
        &&  ExIsProcessorFeaturePresent(PF_PAE_ENABLED)) {

            Config->Command &= ~(PCI_ENABLE_MEMORY_SPACE
                                 | PCI_ENABLE_BUS_MASTER
                                 | PCI_ENABLE_IO_SPACE);

            PciSetCommandRegister(PdoExtension, Config->Command);
            PdoExtension->CommandEnables &= ~(PCI_ENABLE_MEMORY_SPACE
                                                | PCI_ENABLE_BUS_MASTER
                                                | PCI_ENABLE_IO_SPACE);
            PdoExtension->HackFlags |= PCI_HACK_PRESERVE_COMMAND;
        }

        //
        // If this is a cardbus controller force it into Cardbus mode by writing 0
        // to the LegacyModeBaseAddressRegister.
        //

        if (PCI_CONFIGURATION_TYPE(Config) == PCI_CARDBUS_BRIDGE_TYPE) {

            ULONG zeroLMBA = 0;

            PciWriteDeviceConfig(PdoExtension,
                                 &zeroLMBA,
                                 CARDBUS_LMBA_OFFSET,
                                 sizeof(zeroLMBA)
                                 );
        }

        break;

    case EnumStartDevice:

        ASSERT(PdoExtension);

        //
        // IBM built a bridge (Kirin) that does both positive and subtractive decode
        // - we don't do that so set it to totally subtractive mode (info is from
        // NT bug 267076)
        //
        // NB - this relies on the fact that Kirin has a ProgIf of 1.
        //

        if (PdoExtension->VendorId == 0x1014 && PdoExtension->DeviceId == 0x0095) {

            UCHAR regE0;
            USHORT cmd;

            //
            // Turn off the hardware as we are going to mess with it
            //

            PciGetCommandRegister(PdoExtension, &cmd);
            PciDecodeEnable(PdoExtension, FALSE, &cmd);

            //
            // This is a Kirin
            //
            // Offset E0h - bit 0 : Subtractive Decode enable/disable
            //                  = 1 .. Enable
            //                  = 0 .. Disable
            //              bit 1 : Subtractive Decode Timing
            //                  = 0 : Subtractive Timing
            //                  = 1 : Slow Timing
            //

            PciReadDeviceConfig(PdoExtension, &regE0, 0xE0, 1);

            //
            // Set subtractive with subtractive timing.
            //

            regE0 |= 0x1;
            regE0 &= ~0x2;

            PciWriteDeviceConfig(PdoExtension, &regE0, 0xE0, 1);

            //
            // Put the command register back as we found it
            //

            PciSetCommandRegister(PdoExtension, cmd);

        }

        //
        // Subtractive decode bridges are not meant to have writeable window
        // register - some do so if this is a subtractive bridge then close
        // these windows by setting base > limit.
        //

        if (PdoExtension->HeaderType == PCI_BRIDGE_TYPE
        &&  PdoExtension->Dependent.type1.SubtractiveDecode
        &&  !PCI_IS_INTEL_ICH(PdoExtension)) {

            //
            // Now close all the windows on this bridge - if the registers are read only
            // this is a NOP.
            //

            Config->u.type1.IOBase = 0xFF;
            Config->u.type1.IOLimit = 0;
            Config->u.type1.MemoryBase = 0xFFFF;
            Config->u.type1.MemoryLimit = 0;
            Config->u.type1.PrefetchBase = 0xFFFF;
            Config->u.type1.PrefetchLimit = 0;
            Config->u.type1.PrefetchBaseUpper32 = 0;
            Config->u.type1.PrefetchLimitUpper32 = 0;
            Config->u.type1.IOBaseUpper16 = 0;
            Config->u.type1.IOLimitUpper16 = 0;

        }

        //
        // If this is a cardbus controller force it into Cardbus mode by writing 0
        // to the LegacyModeBaseAddressRegister.
        //

        if (Config->HeaderType ==  PCI_CARDBUS_BRIDGE_TYPE) {

            ULONG zeroLMBA = 0;

            PciWriteDeviceConfig(PdoExtension,
                                 &zeroLMBA,
                                 CARDBUS_LMBA_OFFSET,
                                 sizeof(zeroLMBA)
                                 );
        }

        break;
    }
}


PIO_RESOURCE_REQUIREMENTS_LIST
PciAllocateIoRequirementsList(
    IN ULONG ResourceCount,
    IN ULONG BusNumber,
    IN ULONG SlotNumber
    )
{
    PIO_RESOURCE_REQUIREMENTS_LIST list;
    ULONG                          size;

    //
    // Allocate space for (and zero) the resource requirements list.
    //

    size = ((ResourceCount - 1) * sizeof(IO_RESOURCE_DESCRIPTOR)) +
           sizeof(IO_RESOURCE_REQUIREMENTS_LIST);

    if (ResourceCount == 0) {

        //
        // We should not be called for a resource count of zero, except
        // once for the empty list.   In any case, it should work.
        //

        size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST);
    }

    list = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, size);

    if (list != NULL) {

        RtlZeroMemory(list, size);

        //
        // Initialize the list structure header.
        //
        // Driver constant-
        //

        list->InterfaceType = PCIBus;
        list->AlternativeLists = 1;
        list->List[0].Version = PCI_CM_RESOURCE_VERSION;
        list->List[0].Revision = PCI_CM_RESOURCE_REVISION;

        //
        // Call dependent.
        //

        list->BusNumber = BusNumber;
        list->SlotNumber = SlotNumber;
        list->ListSize = size;
        list->List[0].Count = ResourceCount;
    }
    return list;
}

VOID
PciFreeIoRequirementsList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST List
    )
{
    //
    // Don't free the empty list and don't free NULL which is
    // also allowed.
    //

    if ((List == NULL) || (List == PciZeroIoResourceRequirements)) {
        return;
    }

    ExFreePool(List);
}

PCM_RESOURCE_LIST
PciAllocateCmResourceList(
    IN ULONG ResourceCount,
    IN ULONG BusNumber
    )
{
    PCM_RESOURCE_LIST         list;
    ULONG                     size;
    PCM_PARTIAL_RESOURCE_LIST partial;

    //
    // CM_RESOURCE_LIST includes space for one descriptor.  If there's
    // more than one (in the resource list) increase the allocation by
    // that amount.
    //

    size = sizeof(CM_RESOURCE_LIST);

    if (ResourceCount > 1) {
        size += (ResourceCount - 1) * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
    }

    //
    // Get memory for the resource list.
    //

    list = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, size);
    if (list != NULL) {

        //
        // Initialize the resource list.
        //

        list->Count = 1;
        list->List[0].InterfaceType = PCIBus;
        list->List[0].BusNumber = BusNumber;

        partial = &list->List[0].PartialResourceList;

        partial->Version = PCI_CM_RESOURCE_VERSION;
        partial->Revision = PCI_CM_RESOURCE_REVISION;
        partial->Count = ResourceCount;

        RtlZeroMemory(
            partial->PartialDescriptors,
            size - ((ULONG_PTR)partial->PartialDescriptors - (ULONG_PTR)list)
            );
    }
    return list;
}

VOID
PciPrivateResourceInitialize(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    IN PCI_PRIVATE_RESOURCE_TYPES PrivateResourceType,
    IN ULONG Data
    )
{
    Descriptor->Type = CmResourceTypeDevicePrivate;
    Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    Descriptor->Option = 0;
    Descriptor->Flags  = 0;

    Descriptor->u.DevicePrivate.Data[0] = PrivateResourceType;
    Descriptor->u.DevicePrivate.Data[1] = Data;
}

VOID
PciGetInUseRanges(
    IN  PPCI_PDO_EXTENSION                  PdoExtension,
    IN  PPCI_COMMON_CONFIG              CurrentConfig,
    IN  PCM_PARTIAL_RESOURCE_DESCRIPTOR InUse
    )

/*++

Routine Description:

    Builds an array of CM Partial Resource descriptors containing
    valid entries only where the corresponding PCI address range
    is in use, NULL otherwise.

Arguments:

    PdoExtension   - Pointer to the Physical Device Object Extension for
                     the device whose requirements list is needed.
    CurrentConfig  - Existing contents of configuration space.
    Partial        - Pointer to an array of CM_PARTIAL_RESOURCE_DESCRIPTORs.

Return Value:

    None.

--*/

{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor;
    BOOLEAN enabledPciIo;
    BOOLEAN enabledPciMem;
    BOOLEAN passing = FALSE;
    ULONG index;

    partial = PdoExtension->Resources->Current;
    ioResourceDescriptor = PdoExtension->Resources->Limit;

    enabledPciIo  = BITS_SET(CurrentConfig->Command, PCI_ENABLE_IO_SPACE)
                    || BITS_SET(PdoExtension->InitialCommand, PCI_ENABLE_IO_SPACE);
    enabledPciMem = BITS_SET(CurrentConfig->Command, PCI_ENABLE_MEMORY_SPACE)
                    || BITS_SET(PdoExtension->InitialCommand, PCI_ENABLE_MEMORY_SPACE);

    for (index = 0;
         index < PCI_MAX_RANGE_COUNT;
         index++, InUse++, partial++, ioResourceDescriptor++) {

        //
        // Default to not in use.
        //

        InUse->Type = CmResourceTypeNull;

        //
        // If the resource type in the limits array is
        // CmResourceTypeNull, this resource is not implemented.
        //

        if (ioResourceDescriptor->Type != CmResourceTypeNull) {

            //
            // Not NULL, only options are Port or Memory, we will
            // consider this entry if the approptiate resource
            // (Port or Memory) is currently enabled.
            //

            if (((partial->Type == CmResourceTypePort) && enabledPciIo) ||
                ((partial->Type == CmResourceTypeMemory) && enabledPciMem)) {

                if (partial->u.Generic.Length != 0) {

                    //
                    // Length is non-zero, if base is also non-zero, OR
                    // if this is a bridge and the resource type is IO,
                    // allow it.
                    //

                    if ((partial->u.Generic.Start.QuadPart != 0) ||
                        ((PciGetConfigurationType(CurrentConfig) == PCI_BRIDGE_TYPE) &&
                         (partial->Type == CmResourceTypePort))) {

                        //
                        // This resource describes a valid range that is
                        // currently enabled by hardware.
                        //

                        *InUse = *partial;
                    }
                }
            }
        }
    }
}

VOID
PciBuildGraduatedWindow(
    IN PIO_RESOURCE_DESCRIPTOR PrototypeDescriptor,
    IN ULONG WindowMax,
    IN ULONG WindowCount,
    OUT PIO_RESOURCE_DESCRIPTOR OutputDescriptor
    )
/*++

Routine Description:

    Builds an array of IO Resource descriptors containing
    graduated requirements from WindowMax for WindowCount
    Descriptors dividing the length required in half each time.
    
    eg  If WindowMax is 64Mb and WindowCount is 7 we end up with
        the progression 64Mb, 32Mb, 16Mb, 8Mb, 4Mb, 2Mb, 1Mb
        
    This only works for IO and Memory descriptors.
    
Arguments:

    PrototypeDescriptor - this is used to initialize each
        requirement descriptor then the lenght is modified
        
    WindowMax - the maximum size of the window (where we build
        the progression from)
        
    WindowCount - the number of descriptors in the progression
    
    OutputDescriptor - pointer to the first of WindowCount
        descriptors to be populated by this function.

Return Value:

    None.

--*/


{
    ULONG window, count;
    PIO_RESOURCE_DESCRIPTOR current;
    
    PAGED_CODE();
    
    ASSERT(PrototypeDescriptor->Type == CmResourceTypePort 
           || PrototypeDescriptor->Type == CmResourceTypeMemory);


    window = WindowMax;
    current = OutputDescriptor;

    for (count = 0; count < WindowCount; count++) {

        RtlCopyMemory(current, PrototypeDescriptor, sizeof(IO_RESOURCE_DESCRIPTOR));
        //
        // Update the length
        //
        current->u.Generic.Length = window;
        //
        // If this is an alternative then mark it so
        //
        if (count > 0) {
            current->Option = IO_RESOURCE_ALTERNATIVE;
        }
        current++;

        //
        // Divide window and repeat
        //

        window /= 2;
        ASSERT(window > 1);
    }

    //
    // Return the number of descriptors filled in
    //

    ASSERT((current - OutputDescriptor) == WindowCount);
}

NTSTATUS
PciBuildRequirementsList(
    IN  PPCI_PDO_EXTENSION                 PdoExtension,
    IN  PPCI_COMMON_CONFIG             CurrentConfig,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *FinalReqList
    )

/*++

Routine Description:

    Build the IO_RESOURCE_REQUIREMENTS_LIST structure for this device.

    This structure contains the devices limits and requirements, for
    example, IO space in the range 0x100 to 0x1ff, Length 10.

Arguments:

    PdoExtension   - Pointer to the Physical Device Object Extension for
                     the device whose requirements list is needed.
    CurrentConfig  - Existing contents of configuration space.

Return Value:

    Returns a pointer to the IO_RESOURCE_REQUIREMENTS_LIST for this
    device/function if all went well.  NULL otherwise.

--*/

{
    //
    // Each base resource requires three extended resource descriptors.
    // the total RESOURCES_PER_BAR are
    //
    // 1. Base Resource Descriptor.  eg PCI Memory or I/O space.
    // 2. Ext Resource Descriptor, DevicePrivate.  This is used to
    //    keep track of which BAR this resource is derived from.

#define RESOURCES_PER_BAR   2
#define PCI_GRADUATED_WINDOW_COUNT 7 // 64, 32, 16, 8, 4, 2, 1
#define PCI_GRADUATED_WINDOW_MAX (64 * 1024 * 1024) // 64Mb

    ULONG index;
    ULONG baseResourceCount = 0;
    ULONG configType;
    ULONG interruptMin, interruptMax;
    ULONG iterationCount;
    BOOLEAN generatesInterrupt = FALSE;
    NTSTATUS status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR resource;
    PIO_RESOURCE_REQUIREMENTS_LIST reqList;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  inUse[PCI_MAX_RANGE_COUNT];
    PPCI_CONFIGURATOR configurator;

    PciDebugPrint(PciDbgInformative,
                  "PciBuildRequirementsList: Bus 0x%x, Dev 0x%x, Func 0x%x.\n",
                  PCI_PARENT_FDOX(PdoExtension)->BaseBus,
                  PdoExtension->Slot.u.bits.DeviceNumber,
                  PdoExtension->Slot.u.bits.FunctionNumber);

    if (PdoExtension->Resources == NULL) {

        //
        // If this function implements no BARs, we won't have a
        // resource structure for it.
        //

        iterationCount = 0;

    } else {

        iterationCount = PCI_MAX_RANGE_COUNT;
        partial = inUse;
        ioResourceDescriptor = PdoExtension->Resources->Limit;
        PciGetInUseRanges(PdoExtension, CurrentConfig, partial);
    }

    configurator =
        &PciConfigurators[PciGetConfigurationType(CurrentConfig)];

    //
    // First pass, figure out how large the resource requirements
    // list needs to be.
    //

    for (index = 0;
         index < iterationCount;
         index++, partial++, ioResourceDescriptor++) {

        //
        // If the resource type in the limits array is
        // CmResourceTypeNull, this resource is not implemented.
        //

        if (ioResourceDescriptor->Type != CmResourceTypeNull) {

            if (partial->Type != CmResourceTypeNull) {

                if ((ioResourceDescriptor->u.Generic.Length == 0) // bridge

#if PCI_BOOT_CONFIG_PREFERRED

                    || (1)                                        // always

#endif
                   )
                {

                    //
                    // Count one for the preferred setting.
                    //

                    baseResourceCount++;

                    PciDebugPrint(PciDbgObnoxious,
                        "    Index %d, Preferred = TRUE\n",
                        index
                        );
                }

            } else {

                //
                // This range is not being passed so we will not
                // generate a preferred setting for it.
                //
                // Bridges have variable length ranges so there is
                // no meaningful value that we could have stored in
                // the base descriptor other than 0.  We use this
                // fact to determine if it's a bridged range.
                //
                // If this range is a bridge range, we do not want
                // to generate a base descriptor for it either.
                //
                // Unless we are providing default minimum settings.
                // (Only do this for PCI-PCI bridges, CardBus gets
                // to figure out what it wants).
                //

                if (ioResourceDescriptor->u.Generic.Length == 0) {


                    //
                    // Generating prefered settings,... unless,...
                    // If the bridge IO is enabled and VGA is enabled,
                    // (and the IO range isn't programmed,... which is
                    // how we got here), then the VGA ranges are enough,
                    // don't try to add a range.
                    //

                    if ((ioResourceDescriptor->Type == CmResourceTypePort) &&
                        PdoExtension->Dependent.type1.VgaBitSet) {

                        continue;
                    }

                    //
                    // If this is a memory window then make space for a graduated
                    // requirement and a device private to follow it
                    //

                    if (ioResourceDescriptor->Type == CmResourceTypeMemory) {
                        baseResourceCount += PCI_GRADUATED_WINDOW_COUNT + 1;                      
                        continue;
                    }
                }

                //
                // If this resource is a ROM which is not currently
                // enabled, don't report it at all.
                //
                // Note: The ROM requirement exists in the io resource
                // descriptors so we know what to do if we get a read
                // config for the ROM.
                //

                if ((ioResourceDescriptor->Type == CmResourceTypeMemory) &&
                    (ioResourceDescriptor->Flags == CM_RESOURCE_MEMORY_READ_ONLY)) {
                    continue;
                }
            }

            //
            // Count one for the base resource, and any per resource
            // special ones (eg Device Private).
            //

            baseResourceCount += RESOURCES_PER_BAR;

            PciDebugPrint(PciDbgObnoxious,
                "    Index %d, Base Resource = TRUE\n",
                index
                );
        }
    }

    //
    // One base type for Interrupts if enabled.
    //

    status = PciGetInterruptAssignment(PdoExtension,
                                       &interruptMin,
                                       &interruptMax);

    if (NT_SUCCESS(status)) {
        generatesInterrupt = TRUE;
        baseResourceCount += RESOURCES_PER_BAR - 1;
    }

    //
    // If the header type dependent resource routines indicated
    // additional resources are required, add them in here.
    //

    baseResourceCount += PdoExtension->AdditionalResourceCount;

    PciDebugPrint(PciDbgPrattling,
                  "PCI - build resource reqs - baseResourceCount = %d\n",
                  baseResourceCount);

    if (baseResourceCount == 0) {

        //
        // This device consumes no resources.  Succeed the request but
        // return a pointer to our private empty list.  This will never
        // actually be given to anyone else but having an empty list
        // removes a bunch of special case code for handling a NULL
        // pointer.
        //

        if (PciZeroIoResourceRequirements == NULL) {
            PciZeroIoResourceRequirements = PciAllocateIoRequirementsList(
                0,  // resource count
                0,  // bus
                0   // slot
                );
        }
        *FinalReqList = PciZeroIoResourceRequirements;

        PciDebugPrint(PciDbgPrattling,
                      "PCI - build resource reqs - early out, 0 resources\n");

        return STATUS_SUCCESS;
    }

    //
    // Allocate and (bulk) initialize the IO resource requirements list.
    //

    reqList = PciAllocateIoRequirementsList(
                  baseResourceCount,
                  PCI_PARENT_FDOX(PdoExtension)->BaseBus,
                  PdoExtension->Slot.u.AsULONG);

    if (reqList == NULL) {

        //
        // Not much we can do about this, bail.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Second pass, build the resource list.
    //

    if (iterationCount != 0) {
        partial = inUse;
        ioResourceDescriptor = PdoExtension->Resources->Limit;
    }
    resource = reqList->List[0].Descriptors;

    for (index = 0;
         index < iterationCount;
         index++, partial++, ioResourceDescriptor++) {

        BOOLEAN passing;
        ULONG   genericLength;
        ULONG   genericAlignment;

        if (ioResourceDescriptor->Type == CmResourceTypeNull) {

            //
            // Nothing here.
            //

            continue;
        }

        //
        // Try to determine if the current setting for this resource
        // is (a) active (eg is's an IO resource and IO is enabled
        // for this device), and (b) valid.
        //

        passing = FALSE;
        genericLength = ioResourceDescriptor->u.Generic.Length;
        genericAlignment = ioResourceDescriptor->u.Generic.Alignment;

        if (partial->Type == CmResourceTypeNull) {

            //
            // Current setting is either not enabled or it's invalid
            // (h/w invalid ie the h/w will not see it as enabled).
            //
            // The base resource is for a bridged range, skip it
            // altogether.
            //

            if (genericLength == 0) {

                //
                // There is no boot setting for this bridge resource,
                // If the VGA bit is set, no need for a normal range.
                //

                if ((ioResourceDescriptor->Type == CmResourceTypeMemory) ||
                    ((ioResourceDescriptor->Type == CmResourceTypePort) &&
                      (PdoExtension->Dependent.type1.VgaBitSet == FALSE))) {

                    switch (PciClassifyDeviceType(PdoExtension)) {
                    case PciTypePciBridge:

                        if (ioResourceDescriptor->Type == CmResourceTypeMemory) {
                            PciBuildGraduatedWindow(ioResourceDescriptor,
                                                    PCI_GRADUATED_WINDOW_MAX,
                                                    PCI_GRADUATED_WINDOW_COUNT,
                                                    resource);

                            resource += PCI_GRADUATED_WINDOW_COUNT;
                            
                            PciPrivateResourceInitialize(resource,
                                                         PciPrivateBar,
                                                         index);

                            resource++;

                            continue;
                            
                        } else {
                            //
                            // Do the minium for IO space which is 4kb
                            // 
                            
                            genericLength = 0x1000;
                            genericAlignment = 0x1000;
                                
                        }
    
                        break;

                    case PciTypeCardbusBridge:

                        if (ioResourceDescriptor->Type == CmResourceTypeMemory) {
                            PciBuildGraduatedWindow(ioResourceDescriptor,
                                                    PCI_GRADUATED_WINDOW_MAX,
                                                    PCI_GRADUATED_WINDOW_COUNT,
                                                    resource);

                            resource += PCI_GRADUATED_WINDOW_COUNT;
                            
                            PciPrivateResourceInitialize(resource,
                                                         PciPrivateBar,
                                                         index);

                            resource++;
                            
                            continue;
                            
                        } else {
                            //
                            // Do the minium for IO space which is 256 bytes
                            // 

                            genericLength = 0x100;
                            genericAlignment = 0x100;
                        }
                        
                        break;
                    default:

                        //
                        // I don't know what this is.
                        // N.B. Can't actually get here.
                        //

                        continue;
                    }
                } else {
                
                    //
                    // Not IO or memory? - Skip it altogether.
                    //
    
                    continue;
                }

            } else {

                //
                // Could be that it's a ROM that we don't actually want
                // to report.
                //

                if ((ioResourceDescriptor->Type == CmResourceTypeMemory) &&
                    (ioResourceDescriptor->Flags == CM_RESOURCE_MEMORY_READ_ONLY)) {
                    continue;
                }
            }

        } else {

            //
            // Current setting IS being passed.   If it is a bridge,
            // we will provide the current setting as preferred
            // regardless.  This may change one day, if it does
            // we MUST get the length into the generic setting
            // before we pass it into IO in the resource descriptor.
            //

            if ((genericLength == 0) // bridge

#if PCI_BOOT_CONFIG_PREFERRED

                || (1)                                        // always

#endif
               )
            {
                passing = TRUE;
                genericLength = partial->u.Generic.Length;
            }
        }

        PciDebugPrint(PciDbgObnoxious,
            "    Index %d, Setting Base Resource,%s setting preferred.\n",
            index,
            passing ? "": " not"
            );

        ASSERT((resource + RESOURCES_PER_BAR + (passing ? 1 : 0) -
                reqList->List[0].Descriptors) <= (LONG)baseResourceCount);

        //
        // Fill in the base resource descriptor.
        //

        *resource = *ioResourceDescriptor;
        resource->ShareDisposition = CmResourceShareDeviceExclusive;
        resource->u.Generic.Length = genericLength;
        resource->u.Generic.Alignment = genericAlignment;

        //
        // Set the positive decode bit and 16 bit decode for all IO requirements
        //

        if (ioResourceDescriptor->Type == CmResourceTypePort) {
            resource->Flags |= (CM_RESOURCE_PORT_POSITIVE_DECODE
                                    | CM_RESOURCE_PORT_16_BIT_DECODE);
        }

        //
        // If this device is decoding IO or Memory, and this resource
        // is of that type, include the prefered settings in the list.
        //

        if (passing) {

            extern BOOLEAN PciLockDeviceResources;

            //
            // Copy the set of descriptors we just created.
            //

            PciDebugPrint(PciDbgVerbose, "  Duplicating for preferred locn.\n");

            *(resource + 1) = *resource;

            //
            // Change the original to indicate it is the preferred
            // setting and put the current settings into minimum
            // address field, current setting + length into the max.
            //

            resource->Option = IO_RESOURCE_PREFERRED;
            resource->u.Generic.MinimumAddress = partial->u.Generic.Start;
            resource->u.Generic.MaximumAddress.QuadPart =
                 resource->u.Generic.MinimumAddress.QuadPart +
                 (resource->u.Generic.Length - 1);

            //
            // The preferred setting is fixed (Start + Length - 1 == End) and
            // so alignment is not a restricting factor.
            //
            resource->u.Generic.Alignment = 1;

            if (PciLockDeviceResources == TRUE ||
                PdoExtension->LegacyDriver == TRUE ||
                PdoExtension->OnDebugPath ||
                (PCI_PARENT_FDOX(PdoExtension)->BusHackFlags & PCI_BUS_HACK_LOCK_RESOURCES) ||

                //
                // This is a work around for a pnp bug which affects Toshiba
                // Satellite machines.  We end up moving the PCI modem off its
                // boot config because it is reserved (on 2f8 or 3f8) and then
                // put a PCMCIA modem on top of it before it has been turned off.
                // Stops before Starts would fix this but the driver folks say
                // they can't deal with that so we need to fix this as part
                // of the rebalance cleanup in 5.1
                //

#if PCI_NO_MOVE_MODEM_IN_TOSHIBA
                (PdoExtension->VendorId == 0x11c1
                 && PdoExtension->DeviceId == 0x0441
                 && PdoExtension->SubsystemVendorId == 0x1179
                 && (PdoExtension->SubsystemId == 0x0001 || PdoExtension->SubsystemId == 0x0002))
#endif

            ) {


                //
                // Restrict the alternatives to the current settings.
                //

                *(resource + 1) = *resource;
            }

            (resource + 1)->Option = IO_RESOURCE_ALTERNATIVE;

            //
            // bump resource by one to allow for the one we just added.
            //

            resource++;
        }

        //
        // A devicePrivateResource is used to keep track of which
        // BAR this resource is derived from.  Record it now because
        // index may get bumped if this is a 64 bit memory BAR.
        //

        PciPrivateResourceInitialize(resource + 1,
                                     PciPrivateBar,
                                     index);

        resource += RESOURCES_PER_BAR;
    }

    //
    // Assign descriptors for interrupts.
    //

    if (generatesInterrupt) {

        PciDebugPrint(PciDbgVerbose, "  Assigning INT descriptor\n");

        //
        // Finally, fill in the base resource descriptor.
        //

        resource->Type = CmResourceTypeInterrupt;
        resource->ShareDisposition = CmResourceShareShared;
        resource->Option = 0;
        resource->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
        resource->u.Interrupt.MinimumVector = interruptMin;
        resource->u.Interrupt.MaximumVector = interruptMax;

        resource += (RESOURCES_PER_BAR - 1);
    }

    if (PdoExtension->AdditionalResourceCount != 0) {

        //
        // The header type dependent code indicated that it has
        // resources to add.  Call it back and allow it do add
        // them now.
        //

        configurator->GetAdditionalResourceDescriptors(
            PdoExtension,
            CurrentConfig,
            resource
            );

        resource += PdoExtension->AdditionalResourceCount;
    }

    //
    // Done.
    //

    ASSERT(reqList->ListSize == (ULONG_PTR)resource - (ULONG_PTR)reqList);

#if DBG

    PciDebugPrint(PciDbgPrattling,
                  "PCI build resource req - final resource count == %d\n",
                  resource - reqList->List[0].Descriptors);

    ASSERT((resource - reqList->List[0].Descriptors) != 0);

#endif

    //
    // Return the address of the resource list and a successful status
    // back to the caller.
    //

    *FinalReqList = reqList;

    return STATUS_SUCCESS;
}

VOID
PciWriteLimitsAndRestoreCurrent(
    IN PPCI_CONFIGURABLE_OBJECT This
    )
//
// Overwrite the device's configuration space with the adjusted
// version then read it back to see what the device did with it.
//
{
    
    if (This->PdoExtension->OnDebugPath) {

        //
        //  If our debugger is bus mastering then dont clear this bit as it
        //  will blow away the DMA engine on the card and we dont currently
        //  re-program the card when we call KdEnableDebugger.
        //
        if (This->Command & PCI_ENABLE_BUS_MASTER){

            This->Working->Command |= PCI_ENABLE_BUS_MASTER;
            This->Current->Command |= PCI_ENABLE_BUS_MASTER;
        }

        KdDisableDebugger();
    }
    
    //
    // Write out all those F's to work out which bits are sticky
    //

    PciSetConfigData(This->PdoExtension, This->Working);

    //
    // Read in which bits stuck
    //

    PciGetConfigData(This->PdoExtension, This->Working);

    //
    // Return the device to it's previous state by writing the
    // original values back into it.
    //
    // Note: Don't enable anything up front (ie, Command = 0)
    // because the Command register will get wriiten before
    // the BARs are updated which might enable translations
    // at undesirable locations.
    //

    PciSetConfigData(This->PdoExtension, This->Current);

    //
    // Now, return the command register to it's previous state.
    //

    This->Current->Command = This->Command;

    //
    // Only do the write if we are actually going to change the
    // value of the command field.
    //

    if (This->Command != 0) {

        PciSetCommandRegister(This->PdoExtension, This->Command);
    }

    //
    // Restore the status field in the caller's buffer.
    //

    This->Current->Status = This->Status;

    //
    // Restore any type specific fields.
    //

    This->Configurator->RestoreCurrent(This);

    if (This->PdoExtension->OnDebugPath) {
        KdEnableDebugger();
    }


#if DBG

    //
    // Check that what was written back stuck.
    //

    if (This->PdoExtension->ExpectedWritebackFailure == FALSE) {

        PPCI_COMMON_CONFIG verifyConfig;
        ULONG              len;

        verifyConfig = (PPCI_COMMON_CONFIG)
            ((ULONG_PTR)This->Working + PCI_COMMON_HDR_LENGTH);
        PciGetConfigData(This->PdoExtension, verifyConfig);

        if ((len = (ULONG)RtlCompareMemory(
                            verifyConfig,
                            This->Current,
                            PCI_COMMON_HDR_LENGTH)) != PCI_COMMON_HDR_LENGTH) {

            //
            // Compare failed.
            //

            PciDebugPrint(PciDbgInformative,
                  "PCI - CFG space write verify failed at offset 0x%x\n",
                  len);
            PciDebugDumpCommonConfig(verifyConfig);
        }
    }

#endif
}

NTSTATUS
PcipGetFunctionLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Determine the limits for the Base Address Registers (BARs) for a
    given Bus/Device/Function.

    This is done by writing all ones the the BARs, reading them
    back again.  The hardware will adjust the values to it's limits
    so we just store these new values away.

Arguments:

    This - Pointer to the configuration object.

Return Value:

    Returns status indicating the success or failure of this routine.

--*/

{
    ULONG                   configType;
    PPCI_COMMON_CONFIG      current = This->Current;
    PPCI_COMMON_CONFIG      working = This->Working;
    ULONG                   count;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor;

    PAGED_CODE();

    //
    // The first 16 bytes of configuration space are required by the
    // PCI specification to be of the following format.
    //
    //           3            2            1            0
    //    +------------+------------+------------+------------+
    //    |        Device ID        |        Vendor ID        |
    //    +------------+------------+------------+------------+
    //    |          Status         |         Command         |
    //    +------------+------------+------------+------------+
    //    | Base Class | Sub Class  | Progr. I/F | Revision ID|
    //    +------------+------------+------------+------------+
    //    |     BIST   | Header Type|   Latency  | Cache Ln Sz|
    //    +------------+------------+------------+------------+
    //
    // The status field in PCI Configuration space has its bits cleared
    // by writing a one to each bit to be cleared.  Zero the status
    // field in the image of the current configuration space so writing
    // to the hardware will not change it.
    //

    This->Status = current->Status;
    current->Status = 0;

    //
    // Disable the device while it's configuration is being messed
    // with.
    //

    This->Command = current->Command;
    current->Command &= ~(PCI_ENABLE_IO_SPACE |
                          PCI_ENABLE_MEMORY_SPACE |
                          PCI_ENABLE_BUS_MASTER);


    //
    // Make a copy of the configuration space that was handed in.
    // This copy will be modified and written to/read back from the
    // device's configuration space to allow us to determine the
    // limits for the device.
    //

    RtlCopyMemory(working, current, PCI_COMMON_HDR_LENGTH);

    //
    // Get the configuration type from the function's header.
    // NOTE: We have already checked that it is valid so no
    // further checking is needed here.
    //

    configType = PciGetConfigurationType(current);

    //
    // Set the configuration type dispatch table.
    //

    This->Configurator = &PciConfigurators[configType];

    //
    // Modify the "Working" copy of config space such that writing
    // it to the hardware and reading it back again will enable us
    // to determine the "limits" of this hardware's configurability.
    //

    This->Configurator->MassageHeaderForLimitsDetermination(This);

    //
    // Overwrite the device's configuration space with the adjusted
    // version then read it back to see what the device did with it.
    //

    PciWriteLimitsAndRestoreCurrent(This);

    //
    // Allocate memory for limits and current usage.
    //
    // Note: This should NOT have been done already.
    //

    ASSERT(This->PdoExtension->Resources == NULL);

    This->PdoExtension->Resources = ExAllocatePool(
                                        NonPagedPool,
                                        sizeof(PCI_FUNCTION_RESOURCES)
                                        );

    if (This->PdoExtension->Resources == NULL) {

        //
        // Couldn't get memory for this???
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Clear these structures.
    //
    // CmResourceTypeNull == 0, otherwise we need to init the Limits
    // and current settings structures seperately.
    //

    RtlZeroMemory(
        This->PdoExtension->Resources,
        sizeof(PCI_FUNCTION_RESOURCES)
        );

#if CmResourceTypeNull

    for (count = 0; count < PCI_MAX_RANGE_COUNT; count++) {
        This->PdoExtension->Resources->Limit[count].Type = CmResourceTypeNull;
        This->PdoExtension->Resources->Current[count].Type = CmResourceTypeNull;
    }

#endif

    //
    // Copy the limits and current settings into our device extension.
    //

    This->Configurator->SaveLimits(This);
    This->Configurator->SaveCurrentSettings(This);

    //
    // If SaveLimits didn't find any resources, we can free the
    // memory allocated to both limits and current settings. Note
    // that we still must call SaveCurrentSettings because that
    // routine is responsible for saving type specific data.
    //

    count = 0;
    ioResourceDescriptor = This->PdoExtension->Resources->Limit +
                           PCI_MAX_RANGE_COUNT;

    do {
        ioResourceDescriptor--;

        if (ioResourceDescriptor->Type != CmResourceTypeNull) {

            //
            // Some resource exists, get out.
            //

            count++;
            break;
        }
    } while (ioResourceDescriptor != This->PdoExtension->Resources->Limit);

    if (count == 0) {

        //
        // No resources.
        //

        ExFreePool(This->PdoExtension->Resources);
        This->PdoExtension->Resources = NULL;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
PciGetFunctionLimits(
    IN PPCI_PDO_EXTENSION     PdoExtension,
    IN PPCI_COMMON_CONFIG CurrentConfig,
    IN ULONGLONG              Flags
    )

/*++

Description:

    Determine the limits for the Base Address Registers (BARs) for a
    given Bus/Device/Function.

    The work is really done by PcipGetFunctionLimits.  This function is
    a wrapper to handle the allocation/deallocation of working memory.

Arguments:

    PdoExtension  - PDO Extension for the device object to obtain the
                    limits for.
    CurrentConfig - Existing contents of the PCI Common Configuration
                    Space for this function.

Return Value:

    Returns status indicating the success or failure of this routine.

--*/

{
    PPCI_COMMON_CONFIG      workingConfig;
    NTSTATUS                status;
    ULONG                   size;
    PCI_CONFIGURABLE_OBJECT this;

    PAGED_CODE();

    //
    // Check for anything the registry says we should not try
    // to figure out the resources on.  Examples are devices
    // that don't consume resources but return garbage in their
    // base address registers.
    //

    if (PciSkipThisFunction(CurrentConfig,
                            PdoExtension->Slot,
                            EnumResourceDetermination,
                            Flags) == TRUE) {
        return STATUS_SUCCESS;
    }

    size = PCI_COMMON_HDR_LENGTH;

#if DBG

    //
    // If a checked build, we will verify the writeback of the
    // orginal contents of configuration space.  Allow enough
    // space for a verification copy.
    //

    size *= 2;

#endif

    workingConfig = ExAllocatePool(NonPagedPool, size);

    if (workingConfig == NULL) {

        //
        // Failed to get memory to work with, bail.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    this.Current      = CurrentConfig;
    this.Working      = workingConfig;
    this.PdoExtension = PdoExtension;

    status = PcipGetFunctionLimits(&this);

    ExFreePool(workingConfig);

    return status;
}

VOID
PciProcessBus(
    IN PPCI_FDO_EXTENSION ParentFdo
)
/*++

Routine Description:

    Walk the child devices enumerated by PciScanBus and perform any processing
    the needs to be done once all the children have been enumerated

Arguments:

    ParentFdo - Our extension for the PCI bus functional device object.

Return Value:

    NT status.

--*/

{
    PPCI_PDO_EXTENSION current, vgaBridge = NULL, parentBridge = NULL;

    PAGED_CODE();

    if (!PCI_IS_ROOT_FDO(ParentFdo)) {
        parentBridge = PCI_BRIDGE_PDO(ParentFdo);
    }

    //
    // If our parent is a bridge with the ISA bit set, then set the ISA bit on
    // all child bridges unless they are subtractive in which case we set the 
    // IsaRequired bit
    //

    if (parentBridge
    && PciClassifyDeviceType(parentBridge) == PciTypePciBridge
    && (parentBridge->Dependent.type1.IsaBitSet || parentBridge->Dependent.type1.IsaBitRequired)) {

        for (current = ParentFdo->ChildBridgePdoList;
             current;
             current = current->NextBridge) {

            //
            // For now we only set the ISA bit on PCI-PCI bridges
            //

            if (PciClassifyDeviceType(current) == PciTypePciBridge) {
                if (current->Dependent.type1.SubtractiveDecode) {
                    current->Dependent.type1.IsaBitRequired = TRUE;
                } else {
                    current->Dependent.type1.IsaBitSet = TRUE;
                    current->UpdateHardware = TRUE;
                }
            }
        }

    } else {

        //
        // Scan the bridges enumerated to see if we need to set the ISA bit
        //

        for (current = ParentFdo->ChildBridgePdoList;
             current;
             current = current->NextBridge) {

            if (current->Dependent.type1.VgaBitSet) {
                vgaBridge = current;
                break;
            }
        }

        //
        // If we have a bridge with the VGA bit set - set the ISA bit on all other
        // bridges on this bus and force this to be written out to the hardware on
        // the start.
        //

        if (vgaBridge) {

            for (current = ParentFdo->ChildBridgePdoList;
                 current;
                 current = current->NextBridge) {

                if (current != vgaBridge
                && PciClassifyDeviceType(current) == PciTypePciBridge) {

                    //
                    // If this device is already started then we had better have already set the ISA bit
                    //

                    if (current->DeviceState == PciStarted) {
                        ASSERT(current->Dependent.type1.IsaBitRequired || current->Dependent.type1.IsaBitSet);
                    }

                    //
                    // If its a subtrative decode bridge remember we would have
                    // set the ISA bit so any children can inhereit it, otherwise
                    // set it and force it out to the hardware.
                    //

                    if (current->Dependent.type1.SubtractiveDecode) {
                        current->Dependent.type1.IsaBitRequired = TRUE;
                    } else {
                        current->Dependent.type1.IsaBitSet = TRUE;
                        current->UpdateHardware = TRUE;
                    }
                }
            }
        }
    }

    //
    // Check to see if there are any bridges in need of bus numbers and assign
    // them if we are running on a machine where this is a good idea.
    //
    if (PciAssignBusNumbers) {
        PciConfigureBusNumbers(ParentFdo);
    }
}




NTSTATUS
PciScanBus(
    IN PPCI_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    Scan the bus (detailed in FdoExtension) for any PCI devices/functions
    elligible for control via a WDM driver.

Arguments:

    FdoExtension - Our extension for the PCI bus functional device object.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    PCI_COMMON_HEADER commonHeader[2];
    PPCI_COMMON_CONFIG commonConfig = (PPCI_COMMON_CONFIG)&commonHeader[0];
    PPCI_COMMON_CONFIG biosConfig = (PPCI_COMMON_CONFIG)&commonHeader[1];
    PDEVICE_OBJECT physicalDeviceObject;
    PPCI_PDO_EXTENSION pdoExtension;
    PCI_SLOT_NUMBER slot;
    ULONG deviceNumber;
    ULONG functionNumber;
    ULONG pass;
    USHORT SubVendorID, SubSystemID;
    BOOLEAN isRoot;
    ULONGLONG hackFlags;
    ULONG maximumDevices;
    PIO_RESOURCE_REQUIREMENTS_LIST tempRequirementsList;
    BOOLEAN newDevices = FALSE;
    UCHAR secondary;

    PciDebugPrint(PciDbgPrattling,
                  "PCI Scan Bus: FDO Extension @ 0x%x, Base Bus = 0x%x\n",
                  FdoExtension,
                  FdoExtension->BaseBus);

    isRoot = PCI_IS_ROOT_FDO(FdoExtension);

    //
    // Examine each possible device on this bus.
    //

    maximumDevices = PCI_MAX_DEVICES;
    if (!isRoot) {

        //
        // Examine the PDO extension for the bridge device and see
        // if it's broken.
        //

        pdoExtension = (PPCI_PDO_EXTENSION)
                       FdoExtension->PhysicalDeviceObject->DeviceExtension;

        ASSERT_PCI_PDO_EXTENSION(pdoExtension);

        if (pdoExtension->HackFlags & PCI_HACK_ONE_CHILD) {
            maximumDevices = 1;
        }

        //
        // NEC program the bus number in their _DCK method, unfortunatley we have already
        // done it!  So detect someone else reprogramming the bus number and restore
        // the correct one!
        //

        PciReadDeviceConfig(pdoExtension,
                            &secondary,
                            FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.SecondaryBus),
                            sizeof(UCHAR)
                            );

        if (secondary != pdoExtension->Dependent.type1.SecondaryBus) {
            DbgPrint("PCI: Bus numbers have been changed!  Restoring originals.\n");
            PciSetBusNumbers(pdoExtension,
                             pdoExtension->Dependent.type1.PrimaryBus,
                             pdoExtension->Dependent.type1.SecondaryBus,
                             pdoExtension->Dependent.type1.SubordinateBus
                             );
        }

    }

    slot.u.AsULONG = 0;

    for (deviceNumber = 0;
         deviceNumber < maximumDevices;
         deviceNumber++) {

        slot.u.bits.DeviceNumber = deviceNumber;

        //
        // Examine each possible function on this device.
        // N.B. Early out if function 0 not present.
        //

        for (functionNumber = 0;
             functionNumber < PCI_MAX_FUNCTION;
             functionNumber++) {

#if defined(_AMD64_SIMULATOR_)
            if (deviceNumber == 7 && functionNumber == 2) {

                //
                // The simulator is reporting an IDE controller here, but
                // it's really a USB controller.  Ignore this one.
                //

                break;
            }
#endif

            slot.u.bits.FunctionNumber = functionNumber;

            PciReadSlotConfig(FdoExtension,
                              slot,
                              commonConfig,
                              0,
                              sizeof(commonConfig->VendorID)
                              );


            if (commonConfig->VendorID == 0xFFFF ||
                commonConfig->VendorID == 0) {

                if (functionNumber == 0) {

                    //
                    // Didn't get any data on function zero of this
                    // device, no point in checking other functions.
                    //

                    break;

                } else {

                    //
                    // Check next function.
                    //

                    continue;

                }
            }

            //
            // We have a device so get the rest of its config space
            //

            PciReadSlotConfig(FdoExtension,
                              slot,
                              &commonConfig->DeviceID,
                              FIELD_OFFSET(PCI_COMMON_CONFIG, DeviceID),
                              sizeof(PCI_COMMON_HEADER)
                                - sizeof(commonConfig->VendorID)
                              );

            //
            // Munge the config space if necessary
            //

            PciApplyHacks(FdoExtension,
                          commonConfig,
                          slot,
                          EnumHackConfigSpace,
                          NULL
                          );

#if DBG

            {
                ULONG i;
                PWSTR descr;

                i = 0x8000000 |
                    (FdoExtension->BaseBus << 16) |
                    (deviceNumber << 11) |
                    (functionNumber << 8);

                PciDebugPrint(PciDbgPrattling,
                              "Scan Found Device 0x%x (b=0x%x, d=0x%x, f=0x%x)\n",
                              i,
                              FdoExtension->BaseBus,
                              deviceNumber,
                              functionNumber);

                PciDebugDumpCommonConfig(commonConfig);

                descr = PciGetDeviceDescriptionMessage(
                            commonConfig->BaseClass,
                            commonConfig->SubClass);

                PciDebugPrint(PciDbgPrattling,
                              "Device Description \"%S\".\n",
                              descr ? descr : L"(NULL)");

                if (descr) {
                    ExFreePool(descr);
                }
            }

#endif

            if ((PciGetConfigurationType(commonConfig) == PCI_DEVICE_TYPE) &&
                (commonConfig->BaseClass != PCI_CLASS_BRIDGE_DEV)) {
                SubVendorID = commonConfig->u.type0.SubVendorID;
                SubSystemID = commonConfig->u.type0.SubSystemID;
            } else {
                SubVendorID = 0;
                SubSystemID = 0;
            }

            hackFlags = PciGetHackFlags(commonConfig->VendorID,
                                        commonConfig->DeviceID,
                                        SubVendorID,
                                        SubSystemID,
                                        commonConfig->RevisionID
                                        );

            if (PciSkipThisFunction(commonConfig,
                                    slot,
                                    EnumBusScan,
                                    hackFlags)) {
                //
                // Skip this function
                //

                continue;
            }


            //
            // In case we are rescanning the bus, check to see if
            // a PDO for this device already exists as a child of
            // the FDO.
            //

            pdoExtension = PciFindPdoByFunction(
                               FdoExtension,
                               slot,
                               commonConfig);

            if (pdoExtension == NULL) {

                //
                // Create a PDO for this new device.
                //

                newDevices = TRUE;

                status = PciPdoCreate(FdoExtension,
                                      slot,
                                      &physicalDeviceObject);

                if (!NT_SUCCESS(status)) {
                    ASSERT(NT_SUCCESS(status));
                    return status;
                }

                pdoExtension = (PPCI_PDO_EXTENSION)
                               physicalDeviceObject->DeviceExtension;

                if (hackFlags & PCI_HACK_FAKE_CLASS_CODE) {
                    commonConfig->BaseClass = PCI_CLASS_BASE_SYSTEM_DEV;
                    commonConfig->SubClass = PCI_SUBCLASS_SYS_OTHER;
#if DBG
                    pdoExtension->ExpectedWritebackFailure = TRUE;
#endif
                }

                //
                // Record device identification and type info.
                //

                pdoExtension->VendorId   = commonConfig->VendorID;
                pdoExtension->DeviceId   = commonConfig->DeviceID;
                pdoExtension->RevisionId = commonConfig->RevisionID;
                pdoExtension->ProgIf     = commonConfig->ProgIf;
                pdoExtension->SubClass   = commonConfig->SubClass;
                pdoExtension->BaseClass  = commonConfig->BaseClass;
                pdoExtension->HeaderType =
                    PciGetConfigurationType(commonConfig);

                //
                // If this is a bridge (PCI-PCI or Cardbus) then insert into
                // the list of child bridges for this bus
                //

                if (pdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV
                &&  (pdoExtension->SubClass == PCI_SUBCLASS_BR_PCI_TO_PCI
                  || pdoExtension->SubClass == PCI_SUBCLASS_BR_CARDBUS)) {

                    PPCI_PDO_EXTENSION *current;

                    //
                    // Insert at the end of the list
                    //

                    ExAcquireFastMutex(&FdoExtension->ChildListMutex);

                    current = &FdoExtension->ChildBridgePdoList;

                    while (*current) {
                        current = &((*current)->NextBridge);
                    }

                    *current = pdoExtension;
                    ASSERT(pdoExtension->NextBridge == NULL);

                    ExReleaseFastMutex(&FdoExtension->ChildListMutex);
                }


                //
                // See if we have already cached info for this device
                //

                status = PciGetBiosConfig(pdoExtension,
                                          biosConfig
                                          );

                if (NT_SUCCESS(status)) {

                    //
                    // Check if its the same device
                    //

                    if (PcipIsSameDevice(pdoExtension, biosConfig)) {

                        //
                        // Write the BiosConfig InterruptLine out to the hardware
                        // now and don't wait until start as many HALs will fail in
                        // PciGetAdjustedInterruptLine if we don't
                        //

                        if (biosConfig->u.type1.InterruptLine
                                != commonConfig->u.type1.InterruptLine) {

                            PciWriteDeviceConfig(pdoExtension,
                                                 &biosConfig->u.type1.InterruptLine,
                                                 FIELD_OFFSET(PCI_COMMON_CONFIG,
                                                              u.type1.InterruptLine),
                                                 sizeof(UCHAR)
                                                 );
                        }

                        pdoExtension->RawInterruptLine
                            = biosConfig->u.type0.InterruptLine;

                        pdoExtension->InitialCommand = biosConfig->Command;


                    } else {

                        //
                        // Its a different device so blow away the old bios
                        // config
                        //

                        status = STATUS_UNSUCCESSFUL;
                    }

                }

                if (!NT_SUCCESS(status)) {

                    //
                    // Write out the BiosConfig from the config space we just
                    // read from the hardware
                    //

                    status = PciSaveBiosConfig(pdoExtension,
                                               commonConfig
                                               );

                    ASSERT(NT_SUCCESS(status));

                    pdoExtension->RawInterruptLine
                        = commonConfig->u.type0.InterruptLine;

                    pdoExtension->InitialCommand = commonConfig->Command;

                }

                //
                // Save the command register so we can restore the appropriate bits
                //
                pdoExtension->CommandEnables = commonConfig->Command;

                //
                // Save the device flags so we don't need to go to
                // the registry all the time.
                //

                pdoExtension->HackFlags = hackFlags;

                //
                // See if we have any capabilities for this device
                //

                PciGetEnhancedCapabilities(pdoExtension, commonConfig);

                //
                // Before we calculate the Bar length, or get the capabilities
                // we may need to set the device to D0. N.B. This does *not*
                // update the power state stored in the pdoExtension.
                //
                PciSetPowerManagedDevicePowerState(
                    pdoExtension,
                    PowerDeviceD0,
                    FALSE
                    );

                //
                // Apply any hacks we know about for this device
                //

                PciApplyHacks(FdoExtension,
                              commonConfig,
                              slot,
                              EnumBusScan,
                              pdoExtension
                              );

                //
                // The interrupt number we report in the config data is obtained
                // from the HAL rather than the hardware's config space.
                //
                pdoExtension->InterruptPin = commonConfig->u.type0.InterruptPin;
                pdoExtension->AdjustedInterruptLine = PciGetAdjustedInterruptLine(pdoExtension);

                //
                // Work out if we are on the debug path
                //

                pdoExtension->OnDebugPath = PciIsDeviceOnDebugPath(pdoExtension);

                //
                // Get the IO and MEMORY limits for this device.  This
                // is a hardware thing and will never change so we keep
                // it in the PDO extension for future reference.
                //

                status = PciGetFunctionLimits(pdoExtension,
                                              commonConfig,
                                              hackFlags);


                //
                // NTRAID #62636 - 4/20/2000 - andrewth
                // We are going to expose a PDO. Why not just let the OS put
                // into whatever Dstate it feels?
                //
                PciSetPowerManagedDevicePowerState(
                    pdoExtension,
                    pdoExtension->PowerState.CurrentDeviceState,
                    FALSE
                    );

                //
                // Currently, this only returns errors on memory allocation.
                //
                if (!NT_SUCCESS(status)) {
                    ASSERT(NT_SUCCESS(status));
                    PciPdoDestroy(physicalDeviceObject);
                    return status;
                }

                //
                // If the device's SubSystem ID fields are not
                // guaranteed to be the same when we enumerate
                // the device after reapplying power to it (ie
                // they depend on the BIOS to initialize it),
                // then pretend it doesn't have a SubSystem ID
                // at all.
                //

                if (hackFlags & PCI_HACK_NO_SUBSYSTEM) {
                    pdoExtension->SubsystemVendorId = 0;
                    pdoExtension->SubsystemId       = 0;
                }

#if DBG
                //
                // Dump the capabilities list.
                //

                {
                    union _cap_buffer {
                        PCI_CAPABILITIES_HEADER header;
                        PCI_PM_CAPABILITY       pm;
                        PCI_AGP_CAPABILITY      agp;
                    } cap;

                    UCHAR   capOffset = pdoExtension->CapabilitiesPtr;
                    PUCHAR  capStr;
                    ULONG   nshort;
                    PUSHORT capData;

                    //
                    // Run the list.
                    //

                    while (capOffset != 0) {

                        UCHAR tmpOffset;
                        tmpOffset = PciReadDeviceCapability(
                                        pdoExtension,
                                        capOffset,
                                        0,          // match ANY ID
                                        &cap,
                                        sizeof(cap.header)
                                        );

                        if (tmpOffset != capOffset) {

                            //
                            // Sanity check only, this can't happen.
                            //

                            PciDebugPrint(
                                PciDbgAlways,
                                "PCI - Failed to read PCI capability at offset 0x%02x\n",
                                capOffset
                                );

                            ASSERT(tmpOffset == capOffset);
                            break;
                        }

                        //
                        // Depending on the Capability ID, the amount
                        // of data varies.
                        //

                        switch (cap.header.CapabilityID) {
                        case PCI_CAPABILITY_ID_POWER_MANAGEMENT:

                            capStr = "POWER";
                            nshort = 3;
                            tmpOffset = PciReadDeviceCapability(
                                            pdoExtension,
                                            capOffset,
                                            cap.header.CapabilityID,
                                            &cap,
                                            sizeof(cap.pm)
                                            );
                            break;

                        case PCI_CAPABILITY_ID_AGP:

                            capStr = "AGP";
                            nshort = 5;
                            tmpOffset = PciReadDeviceCapability(
                                            pdoExtension,
                                            capOffset,
                                            cap.header.CapabilityID,
                                            &cap,
                                            sizeof(cap.agp)
                                            );
                            break;

                        default:

                            capStr = "UNKNOWN CAPABILITY";
                            nshort = 0;
                            break;
                        }

                        PciDebugPrint(
                            PciDbgPrattling,
                            "CAP @%02x ID %02x (%s)",
                            capOffset,
                            cap.header.CapabilityID,
                            capStr
                            );

                        if (tmpOffset != capOffset) {

                            //
                            // Sanity check only, this can't happen.
                            //

                            PciDebugPrint(
                                PciDbgAlways,
                                "- Failed to read capability data. ***\n"
                                );

                            ASSERT(tmpOffset == capOffset);
                            break;
                        }

                        capData = ((PUSHORT)&cap) + 1;

                        while (nshort--) {

                            PciDebugPrint(
                                PciDbgPrattling,
                                "  %04x",
                                *capData++
                                );
                        }
                        PciDebugPrint(PciDbgPrattling, "\n");

                        //
                        // Advance to the next entry in the list.
                        //

                        capOffset = cap.header.Next;
                    }
                }

#endif

                //
                // Don't allow Power Down to legacy type busses (ISA/EISA/
                // MCA).  Who knows what sort of unenumerated devices
                // might be out there that the system is dependent on.
                //

#ifdef PCIIDE_HACKS

                //
                // NTRAID #103766 - 4/20/2000 - andrewth
                // This needs to be removed
                // Also, don't allow an IDE device to power itself off.
                //

                if (pdoExtension->BaseClass == PCI_CLASS_MASS_STORAGE_CTLR &&
                    pdoExtension->SubClass  == PCI_SUBCLASS_MSC_IDE_CTLR) {
                    pdoExtension->DisablePowerDown = TRUE;
                }
#endif

                if ((pdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV &&
                     (pdoExtension->SubClass == PCI_SUBCLASS_BR_ISA ||
                      pdoExtension->SubClass == PCI_SUBCLASS_BR_EISA ||
                      pdoExtension->SubClass == PCI_SUBCLASS_BR_MCA)) ||

                    (pdoExtension->VendorId == 0x8086 &&
                     pdoExtension->DeviceId == 0x0482)) {

                    pdoExtension->DisablePowerDown = TRUE;
                }

                //
                // Try to determine if this device looks like it was hot plugged
                // we assume that if IO, Mem and BusMaster bits are off and no
                // one has initialized either the latency timer or the cache line
                // size they should be initialized.
                //

                if (((pdoExtension->CommandEnables & (PCI_ENABLE_IO_SPACE
                                                      | PCI_ENABLE_MEMORY_SPACE
                                                      | PCI_ENABLE_BUS_MASTER)) == 0)
                &&  commonConfig->LatencyTimer == 0
                &&  commonConfig->CacheLineSize == 0) {

                    PciDebugPrint(
                        PciDbgConfigParam,
                        "PCI - ScanBus, PDOx %x found unconfigured\n",
                        pdoExtension
                        );

                    //
                    // Remember we need to configure this in PciSetResources
                    //

                    pdoExtension->NeedsHotPlugConfiguration = TRUE;
                }
                //
                // Save the Latency Timer and Cache Line Size
                // registers.   These were set by the BIOS on
                // power up but might need to be reset by the
                // OS if the device is powered down/up by the
                // OS without a reboot.
                //

                pdoExtension->SavedLatencyTimer =
                    commonConfig->LatencyTimer;
                pdoExtension->SavedCacheLineSize =
                    commonConfig->CacheLineSize;

                //
                // We are able to receive IRPs for this device now.
                //

                physicalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

            } else {

                //
                // A PDO already exists for this device.
                //

                pdoExtension->NotPresent = FALSE;
                ASSERT(pdoExtension->DeviceState != PciDeleted);
            }

            if ( (functionNumber == 0) &&
                !PCI_MULTIFUNCTION_DEVICE(commonConfig) ) {

                //
                // Not a multifunction adapter, skip other functions on
                // this device.
                //

                break;
            }
        }       // function loop
    }           // device loop

    //
    // Perform any post processing on the devices for this bridge if we found any
    // new devices
    //

    if (newDevices) {
        PciProcessBus(FdoExtension);
    }

    return STATUS_SUCCESS;

}

NTSTATUS
PciQueryRequirements(
    IN  PPCI_PDO_EXTENSION                  PdoExtension,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementsList
    )
/*++

Routine Description:

    Calculate the device's resource requirements from PCI Config space.

Arguments:

    PdoExtension     - Pdo Extension for the device (object) whose
                       requirements are needed.

    RequirementsList - Returns the address of the requirements list.

Return Value:

    NT status.

--*/
{
    NTSTATUS status;
    PCI_COMMON_HEADER commonHeader;
    PPCI_COMMON_CONFIG commonConfig = (PPCI_COMMON_CONFIG)&commonHeader;

    PAGED_CODE();

    //
    // Early out, if the device has no CM or IO resources and doesn't
    // use interrupts,... it doesn't have any resource requirements.
    //

    if ((PdoExtension->Resources == NULL) &&
        (PdoExtension->InterruptPin == 0)) {
        PciDebugPrint(
            PciDbgPrattling,
            "PciQueryRequirements returning NULL requirements list\n");
        *RequirementsList = NULL;
        return STATUS_SUCCESS;
    }

    //
    // Get the config space for the device (still needed to gen
    // a requirements list.   This should be changed so the PDOx
    // has enough info to do it without going to the h/w again).
    //

    PciGetConfigData(PdoExtension, commonConfig);

    status = PciBuildRequirementsList(PdoExtension,
                                      commonConfig,
                                      RequirementsList);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Check if this is the broken Compaq hot-plug controller that
    // is integrated into the Profusion chipset.  It only does a 32bit
    // decode in a 64bit address space... Does this seem familiar to anyone...
    // can you say ISA aliasing!
    //
    // The solution is to disable the memory decode.  This was done earlier in
    // PciApplyHacks from PciScan Bus.  But so that the user gets to keep the
    // hot-plug functionality we need to still enumerate but prune out the
    // memory requirement and rely on the fact that the registers can be
    // accessed through config space.
    //
    // Only do this on machines with PAE enabled as they can have > 4GB.
    // Note that this will only work on x86 machines but this is an x86 only
    // chipset.  Only revision 0x11 was broken.
    //


    if (commonConfig->VendorID == 0x0e11
    &&  commonConfig->DeviceID == 0xa0f7
    &&  commonConfig->RevisionID == 0x11
    &&  ExIsProcessorFeaturePresent(PF_PAE_ENABLED)) {

        PIO_RESOURCE_DESCRIPTOR current;

        //
        // Prune out the memory requirement
        //


        FOR_ALL_IN_ARRAY((*RequirementsList)->List[0].Descriptors,
                         (*RequirementsList)->List[0].Count,
                         current) {
            if (current->Type == CmResourceTypeMemory) {
                PIO_RESOURCE_DESCRIPTOR lookahead = current + 1;

                current->Type = CmResourceTypeNull;
                if (lookahead < ((*RequirementsList)->List[0].Descriptors +
                                 (*RequirementsList)->List[0].Count)) {
                    if (lookahead->Type == CmResourceTypeDevicePrivate) {
                        lookahead->Type = CmResourceTypeNull;
                        current++;
                    }
                }
            }
        }
    }

    if (*RequirementsList == PciZeroIoResourceRequirements) {

        //
        // This device (function) has no resources, return NULL
        // intead of our zero list.
        //

        *RequirementsList = NULL;

#if DBG

        PciDebugPrint(PciDbgPrattling, "Returning NULL requirements list\n");

    } else {

        PciDebugPrintIoResReqList(*RequirementsList);

#endif

    }
    return STATUS_SUCCESS;
}

NTSTATUS
PciQueryResources(
    IN  PPCI_PDO_EXTENSION     PdoExtension,
    OUT PCM_RESOURCE_LIST *ResourceList
    )
/*++

Routine Description:

    Given a pointer to a PCI PDO, this routine allocates and returns a pointer
    to the resource description of that PDO.

Arguments:

    PdoExtension - Our extension for the PCI-enumerated physical device object.

    ResourceList - Used to return a pointer to the resource list.

Return Value:

    NT status.

--*/
{
    ULONG    i;
    ULONG    resourceCount;
    ULONG    statusCommand;
    PCM_RESOURCE_LIST cmResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resource, lastResource;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR current;
    BOOLEAN enabledMemory;
    BOOLEAN enabledIo;
    BOOLEAN deviceIsABridge = FALSE;
    PCI_OBJECT_TYPE deviceType;
    USHORT command;

    PAGED_CODE();

    *ResourceList = NULL;

    //
    // Get a count of the resources.
    //

    if (PdoExtension->Resources == NULL) {

        //
        // This device has no resources, successfully return
        // a NULL resource list.
        //

        return STATUS_SUCCESS;
    }

    //
    // Seeing as other drivers (esp VideoPort for multimon) can change the
    // enables for this device re-read the hardware to ensure we are correct.
    //

    PciGetCommandRegister(PdoExtension, &command);

    enabledMemory = BITS_SET(command, PCI_ENABLE_MEMORY_SPACE);
    enabledIo = BITS_SET(command, PCI_ENABLE_IO_SPACE);

    resourceCount = 0;
    current = PdoExtension->Resources->Current;

    for (i = 0; i < PCI_MAX_RANGE_COUNT; i++, current++) {
        if ((enabledMemory && (current->Type == CmResourceTypeMemory))
        ||  (enabledIo && (current->Type == CmResourceTypePort))) {
            resourceCount++;
       }
    }

    if (PdoExtension->InterruptPin && (enabledMemory || enabledIo)) {

        if (PdoExtension->AdjustedInterruptLine != 0 && PdoExtension->AdjustedInterruptLine != 0xFF) {
            resourceCount += 1;
        }
    }




    if (resourceCount == 0) {

        //
        // Device has no resources currently enabled.
        //

        return STATUS_SUCCESS;
    }

    //
    // Allocate a CM Resource List large enough to handle this
    // device's resources.
    //

    cmResourceList = PciAllocateCmResourceList(
                         resourceCount,
                         PCI_PARENT_FDOX(PdoExtension)->BaseBus
                         );
    if (cmResourceList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    resource = PciFirstCmResource(cmResourceList);
    lastResource = resource + resourceCount;

    //
    // Copy the resources from the PDO's in-use resource table to
    // the output resource list - the ISA bit is set will be dealt with in
    // the arbiters - just as for resource requirements.
    //

    current = PdoExtension->Resources->Current;
    for (i = 0; i < PCI_MAX_RANGE_COUNT; i++, current++) {
        if (enabledMemory && (current->Type == CmResourceTypeMemory)) {
            *resource++ = *current;
        } else if (enabledIo && (current->Type == CmResourceTypePort)) {
            *resource++ = *current;
        }
    }

    if (PdoExtension->InterruptPin && (enabledMemory || enabledIo)) {

        if (PdoExtension->AdjustedInterruptLine != 0 && PdoExtension->AdjustedInterruptLine != 0xFF) {

            ASSERT(resource < lastResource);

            resource->Type = CmResourceTypeInterrupt;
            resource->ShareDisposition = CmResourceShareShared;
            resource->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;;
            resource->u.Interrupt.Level =
            resource->u.Interrupt.Vector = PdoExtension->AdjustedInterruptLine;
            resource->u.Interrupt.Affinity = (ULONG)-1;
        }
    }


    //
    // Return the list and indicate success.
    //

    *ResourceList = cmResourceList;
    return STATUS_SUCCESS;
}

NTSTATUS
PciQueryDeviceRelations(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN OUT PDEVICE_RELATIONS *PDeviceRelations
    )

/*++

Routine Description:

    This function builds a DEVICE_RELATIONS structure containing an array
    of pointers to physical device objects for the devices of the specified
    type on the bus indicated by FdoExtension.

Arguments:

    FdoExtension - Pointer to the FDO Extension for the bus itself.
    PDeviceRelations - Used to return the pointer to the allocated
                   device relations structure.

Return Value:

    Returns the status of the operation.

--*/

{
    ULONG pdoCount;
    PPCI_PDO_EXTENSION childPdo;
    PDEVICE_RELATIONS deviceRelations;
    PDEVICE_RELATIONS oldDeviceRelations;
    ULONG deviceRelationsSize;
    PDEVICE_OBJECT physicalDeviceObject;
    PDEVICE_OBJECT *object;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Check that it reasonable to perform this operation now.
    //

    if (FdoExtension->DeviceState != PciStarted) {

        ASSERT(FdoExtension->DeviceState == PciStarted);

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // We're going to mess with the child pdo list - lock the state...
    //
    status = PCI_ACQUIRE_STATE_LOCK(FdoExtension);
    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Run down the existing child list and flag each child as
    // not present.   This flag will be cleared by the bus
    // scan when (/if) the device is still present.   Any pdo
    // with the flag still present after the scan is no longer
    // in the system (could be powered off).
    //

    childPdo = FdoExtension->ChildPdoList;
    while (childPdo != NULL) {
        childPdo->NotPresent = TRUE;
        childPdo = childPdo->Next;
    }

    //
    // Enumerate the bus.
    //

    status = PciScanBus(FdoExtension);

    if (!NT_SUCCESS(status)) {

        ASSERT(NT_SUCCESS(status));
        goto cleanup;
    }

    //
    // First count the child PDOs
    //

    pdoCount = 0;
    childPdo = FdoExtension->ChildPdoList;
    while (childPdo != NULL) {
        if (childPdo->NotPresent == FALSE) {
            pdoCount++;

        } else {

            childPdo->ReportedMissing = TRUE;
#if DBG
            PciDebugPrint(
                PciDbgObnoxious,
                "PCI - Old device (pdox) %08x not found on rescan.\n",
                childPdo
                );
#endif

        }
        childPdo = childPdo->Next;
    }


    //
    // Calculate the amount of memory required to hold the DEVICE_RELATIONS
    // structure along with the array
    //

    deviceRelationsSize = FIELD_OFFSET(DEVICE_RELATIONS, Objects) +
                          pdoCount * sizeof(PDEVICE_OBJECT);

    //
    // We could be either (a) creating the DEVICE_RELATIONS structure
    // (list) here, or (b) adding our PDOs to an existing list.
    //

    oldDeviceRelations = *PDeviceRelations;

    if (oldDeviceRelations != NULL) {

        //
        // List already exists, allow enough space for both the old
        // and the new.
        //

        deviceRelationsSize += oldDeviceRelations->Count *
                               sizeof(PDEVICE_OBJECT);
    }

    deviceRelations = ExAllocatePool(NonPagedPool, deviceRelationsSize);

    if (deviceRelations == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    deviceRelations->Count = 0;

    if (oldDeviceRelations != NULL) {

        //
        // Copy and free the old list.
        //

        RtlCopyMemory(deviceRelations,
                      oldDeviceRelations,
                      FIELD_OFFSET(DEVICE_RELATIONS, Objects) +
                      oldDeviceRelations->Count * sizeof(PDEVICE_OBJECT));

        ExFreePool(oldDeviceRelations);
    }

    //
    // Set object to point at the DeviceRelations list entry being
    // added, walk our PDO list adding entries until we reach the
    // end of the list.
    //

    object = &deviceRelations->Objects[deviceRelations->Count];
    childPdo = FdoExtension->ChildPdoList;

    PciDebugPrint(
        PciDbgObnoxious,
        "PCI QueryDeviceRelations/BusRelations FDOx %08x (bus 0x%02x)\n",
        FdoExtension,
        FdoExtension->BaseBus
        );

    while (childPdo) {

        PciDebugPrint(
            PciDbgObnoxious,
            "  QDR PDO %08x (x %08x)%s\n",
            childPdo->PhysicalDeviceObject,
            childPdo,
            childPdo->NotPresent ? " <Omitted, device flaged not present>" : ""
            );

        if (childPdo->NotPresent == FALSE) {
            physicalDeviceObject = childPdo->PhysicalDeviceObject;
            ObReferenceObject(physicalDeviceObject);
            *object++ = physicalDeviceObject;
        }
        childPdo = childPdo->Next;
    }

    PciDebugPrint(
        PciDbgObnoxious,
        "  QDR Total PDO count = %d (%d already in list)\n",
        deviceRelations->Count + pdoCount,
        deviceRelations->Count
        );

    deviceRelations->Count += pdoCount;
    *PDeviceRelations = deviceRelations;

    status = STATUS_SUCCESS;

cleanup:

    //
    // Unlock
    //
    PCI_RELEASE_STATE_LOCK(FdoExtension);

    return status;
}

NTSTATUS
PciQueryTargetDeviceRelations(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN OUT PDEVICE_RELATIONS *PDeviceRelations
    )

/*++

Routine Description:

    This function builds a DEVICE_RELATIONS structure containing a
    one element array of pointers to the device object for which
    PdoExtension is the device extension.

Arguments:

    PdoExtension - Pointer to the PDO Extension for the device itself.
    PDeviceRelations - Used to return the pointer to the allocated
                   device relations structure.

Return Value:

    Returns the status of the operation.

--*/

{
    PDEVICE_RELATIONS deviceRelations;

    PAGED_CODE();

    if (*PDeviceRelations != NULL) {

        //
        // The caller kindly supplied a device relations structure,
        // it's either too small or exactly the right size.   Throw
        // it away.
        //

        ExFreePool(*PDeviceRelations);
    }

    deviceRelations = ExAllocatePool(NonPagedPool, sizeof(DEVICE_RELATIONS));

    if (deviceRelations == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    deviceRelations->Count = 1;
    deviceRelations->Objects[0] = PdoExtension->PhysicalDeviceObject;
    *PDeviceRelations = deviceRelations;

    ObReferenceObject(deviceRelations->Objects[0]);

    return STATUS_SUCCESS;
}

BOOLEAN
PcipIsSameDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    )
{
    //
    // Verify the data we got, was for the same device
    //

    if ((CommonConfig->VendorID != PdoExtension->VendorId) ||
        (CommonConfig->DeviceID != PdoExtension->DeviceId) ||
        (CommonConfig->RevisionID != PdoExtension->RevisionId)) {

        return FALSE;
    }

    //
    // If the device has a subsystem ID make sure that's the same too.
    //

    if ((PciGetConfigurationType(CommonConfig) == PCI_DEVICE_TYPE) &&
        (PdoExtension->BaseClass != PCI_CLASS_BRIDGE_DEV)          &&
        ((PdoExtension->HackFlags & PCI_HACK_NO_SUBSYSTEM) == 0)&&
        ((PdoExtension->HackFlags & PCI_HACK_NO_SUBSYSTEM_AFTER_D3) == 0)) {

        if ((PdoExtension->SubsystemVendorId !=
             CommonConfig->u.type0.SubVendorID) ||
            (PdoExtension->SubsystemId       !=
             CommonConfig->u.type0.SubSystemID)) {

            return FALSE;
        }
    }

    //
    // Done
    //

    return TRUE;
}

NTSTATUS
PciQueryEjectionRelations(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN OUT PDEVICE_RELATIONS *PDeviceRelations
    )

/*++

Routine Description:

    This function builds a DEVICE_RELATIONS structure containing an array
    of pointers to the device objects that would presumably leave if this
    device were ejected. This is constructed from all the functions of a device.

Arguments:

    PdoExtension - Pointer to the PDO Extension for the device itself.
    PDeviceRelations - Used to return the pointer to the allocated
                 device relations structure.

Return Value:

    Returns the status of the operation.

--*/
{
    PPCI_FDO_EXTENSION     fdoExtension;
    PPCI_PDO_EXTENSION     siblingExtension;
    PDEVICE_RELATIONS  ejectionRelations;
    ULONG              additionalNodes, relationCount;

    additionalNodes = 0;
    fdoExtension = PCI_PARENT_FDOX(PdoExtension);

    //
    // Search the child Pdo list.
    //

    ExAcquireFastMutex(&fdoExtension->ChildListMutex);
    for ( siblingExtension = fdoExtension->ChildPdoList;
          siblingExtension;
          siblingExtension = siblingExtension->Next ) {

        //
        // Is this someone who should be in the list?
        //

        if ((siblingExtension != PdoExtension) &&
            (!siblingExtension->NotPresent) &&
            (siblingExtension->Slot.u.bits.DeviceNumber ==
             PdoExtension->Slot.u.bits.DeviceNumber)) {

            additionalNodes++;
        }
    }

    if (!additionalNodes) {

        ExReleaseFastMutex(&fdoExtension->ChildListMutex);

        return STATUS_NOT_SUPPORTED;
    }

    relationCount = (*PDeviceRelations) ? (*PDeviceRelations)->Count : 0;

    ejectionRelations = (PDEVICE_RELATIONS) ExAllocatePool(
        NonPagedPool,
        sizeof(DEVICE_RELATIONS)+
            (relationCount+additionalNodes-1)*sizeof(PDEVICE_OBJECT)
        );

    if (ejectionRelations == NULL) {

        ExReleaseFastMutex(&fdoExtension->ChildListMutex);

        return STATUS_NOT_SUPPORTED;
    }

    if (*PDeviceRelations) {

        RtlCopyMemory(
            ejectionRelations,
            *PDeviceRelations,
            sizeof(DEVICE_RELATIONS)+
                (relationCount-1)*sizeof(PDEVICE_OBJECT)
            );

        ExFreePool(*PDeviceRelations);

    } else {

        ejectionRelations->Count = 0;
    }

    for ( siblingExtension = fdoExtension->ChildPdoList;
          siblingExtension;
          siblingExtension = siblingExtension->Next ) {

        //
        // Is this someone who should be in the list?
        //

        if ((siblingExtension != PdoExtension) &&
            (!siblingExtension->NotPresent) &&
            (siblingExtension->Slot.u.bits.DeviceNumber ==
             PdoExtension->Slot.u.bits.DeviceNumber)) {

            ObReferenceObject(siblingExtension->PhysicalDeviceObject);
            ejectionRelations->Objects[ejectionRelations->Count++] =
                siblingExtension->PhysicalDeviceObject;
        }
    }

    *PDeviceRelations = ejectionRelations;

    ExReleaseFastMutex(&fdoExtension->ChildListMutex);

    return STATUS_SUCCESS;
}

BOOLEAN
PciIsSameDevice(
    IN PPCI_PDO_EXTENSION PdoExtension
    )
{
    NTSTATUS                        status;
    PCI_COMMON_HEADER               commonHeader;

    //
    // Get the devices pci data
    //

    PciGetConfigData(PdoExtension, &commonHeader);

    return PcipIsSameDevice(PdoExtension, (PPCI_COMMON_CONFIG)&commonHeader);
}

BOOLEAN
PciComputeNewCurrentSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PCM_RESOURCE_LIST ResourceList
    )
/*++

Routine Description:

    Determine the new "device settings" based on the incoming
    resource list.

Arguments:

    PdoExtension    - Pointer to the PDO Extension for the PDO.
    ResourceList    - The set of resources the device is to be configured
                      to use.

Return Value:

    Returns TRUE if the devices new settings are not the same as
    the settings programmed into the device (FALSE otherwise).

--*/

{
    NTSTATUS                        status;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  newResources[PCI_MAX_RANGE_COUNT];
    PCM_FULL_RESOURCE_DESCRIPTOR    fullList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR oldPartial;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR nextPartial;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR interruptResource = NULL;
    BOOLEAN                         configurationChanged = FALSE;
    ULONG                           listCount;
    ULONG                           count;
    ULONG                           bar;

    PAGED_CODE();

    //
    // We should never get a Count of anything other that 1 but if so deal with 0 gracefully
    //

    ASSERT(ResourceList == NULL || ResourceList->Count == 1);

    if (ResourceList == NULL || ResourceList->Count == 0) {

        //
        // No incoming resource list,.. == no change unless we've previously
        // decided we must update the hardware.
        //

        return PdoExtension->UpdateHardware;
    }

#if DBG

    PciDebugPrintCmResList(PciDbgSetRes, ResourceList);

#endif

    //
    // Produce a new "Current Resources Array" based on the
    // incoming resource list and compare it to the devices
    // current resource list.  First init it to nothing.
    //

    for (count = 0; count < PCI_MAX_RANGE_COUNT; count++) {
        newResources[count].Type = CmResourceTypeNull;
    }

    listCount = ResourceList->Count;
    fullList  = ResourceList->List;

    //
    // In the CM Resource list, IO will have copied the device
    // private (extended) resource that we gave it in the
    // resource requirements list handed in earlier.
    //
    // Find that BAR number.   (Note: It's not there for interrupts).
    //

    while (listCount--) {
        PCM_PARTIAL_RESOURCE_LIST partialList = &fullList->PartialResourceList;
        ULONG                     drainPartial = 0;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR baseResource;
        CM_PARTIAL_RESOURCE_DESCRIPTOR tempResource;

#if DBG

        baseResource = NULL;

#endif

        count       = partialList->Count;
        nextPartial = partialList->PartialDescriptors;

        while (count--) {

            partial = nextPartial;
            nextPartial = PciNextPartialDescriptor(partial);

            if (drainPartial != 0) {

                //
                // We encountered a device private indicating
                // we should skip some number of descriptors.
                //

                drainPartial--;
                continue;
            }


            switch (partial->Type) {
            case CmResourceTypeInterrupt:

                ASSERT(interruptResource == NULL); // once only please
                ASSERT(partial->u.Interrupt.Level ==
                       partial->u.Interrupt.Vector);
                ASSERT((partial->u.Interrupt.Level & ~0xff) == 0);

                interruptResource = partial;
                PdoExtension->AdjustedInterruptLine =
                    (UCHAR)partial->u.Interrupt.Level;
                continue;

            case CmResourceTypeMemory:
            case CmResourceTypePort:

                //
                // Is this expected at this time?
                //

                ASSERT(baseResource == NULL);

                baseResource = partial;
                continue;

            case CmResourceTypeDevicePrivate:

                switch (partial->u.DevicePrivate.Data[0]) {
                case PciPrivateIsaBar:

                    ASSERT(baseResource != NULL);

                    //
                    // This private resource tells us which BAR
                    // is associated with this base resource AND
                    // modifies the length of the base resource.
                    // It is created in conjunction with the set
                    // of partial resources that make up a larger
                    // resource on a bridge when the bridge's ISA
                    // mode bit is set.
                    //
                    // What's really coming down the pipe is the
                    // set of descriptors that describe the ISA
                    // holes in the range.  These are 0x100 bytes
                    // every 0x400 bytes for the entire range.
                    //
                    // Make a copy of the base resource we have just
                    // seen.  Its starting address is the start of
                    // the entire range.  Adjust its length to the
                    // entire range.
                    //

                    tempResource = *baseResource;

                    //
                    // A little paranoia is sometimes a good thing.
                    // This can only happen on an IO resource which
                    // is the length of an ISA hole, ie 0x100 bytes.
                    //

                    ASSERT((tempResource.Type == CmResourceTypePort) &&
                           (tempResource.u.Generic.Length == 0x100)
                          );

                    //
                    // Excessive paranoia.
                    //

                    ASSERT((PdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV) &&
                           (PdoExtension->Dependent.type1.IsaBitSet == TRUE)
                          );

                    //
                    // Get the new length.
                    //

                    drainPartial = partial->u.DevicePrivate.Data[2];
                    tempResource.u.Generic.Length = drainPartial;

                    //
                    // Skip the remaining descriptors that make up this
                    // range.
                    //

                    drainPartial = (drainPartial / 0x400) - 1;

#if DBG

                    {
                        PCM_PARTIAL_RESOURCE_DESCRIPTOR lastOne;

                        lastOne = baseResource + drainPartial + 1;

                        ASSERT(lastOne->Type == CmResourceTypePort);
                        ASSERT(lastOne->u.Generic.Length == 0x100);
                        ASSERT(lastOne->u.Generic.Start.QuadPart ==
                                (tempResource.u.Generic.Start.QuadPart +
                                 tempResource.u.Generic.Length - 0x400)
                              );
                    }

#endif

                    //
                    // Finally, shift out pointer to our temp (adjusted)
                    // copy of the resource.
                    //

                    baseResource = &tempResource;

                    // fall thru.

                case PciPrivateBar:

                    ASSERT(baseResource != NULL);

                    //
                    // This private resource tells us which BAR
                    // to is associated with this resource.
                    //

                    bar = partial->u.DevicePrivate.Data[1];

                    //
                    // Copy this descriptor into the new array.
                    //

                    newResources[bar] = *baseResource;

#if DBG

                    baseResource = NULL;

#endif

                    continue;

                case PciPrivateSkipList:

                    ASSERT(baseResource == NULL);

                    //
                    // The remainder of this list is device
                    // specific stuff we can't change anyway.
                    //

                    drainPartial = partial->u.DevicePrivate.Data[1];
                    ASSERT(drainPartial); // sanity check
                    continue;
                }
            }
        }
        ASSERT(baseResource == NULL);

        //
        // Advance to next partial list.
        //

        fullList = (PCM_FULL_RESOURCE_DESCRIPTOR)partial;
    }

    //
    // If we have no I/O or memory resources, then there is no need to look
    // any further.
    //
    if (PdoExtension->Resources == NULL) {
        return FALSE;
    }

    //
    // Ok, we now have a new list of resources in the same order as
    // the "current" set.  See if anything changed.
    //

    partial = newResources;
    oldPartial = PdoExtension->Resources->Current;

#if DBG

    if (PciDebug & PciDbgSetResChange) {

        BOOLEAN dbgConfigurationChanged = FALSE;

        for (count = 0;
             count < PCI_MAX_RANGE_COUNT;
             count++, partial++, oldPartial++) {

            if ((partial->Type != oldPartial->Type) ||
                ((partial->Type != CmResourceTypeNull) &&
                 ((partial->u.Generic.Start.QuadPart !=
                   oldPartial->u.Generic.Start.QuadPart) ||
                  (partial->u.Generic.Length != oldPartial->u.Generic.Length)))) {

                //
                // Devices settings have changed.
                //

                dbgConfigurationChanged = TRUE;

                PciDebugPrint(
                    PciDbgAlways,
                    "PCI - PDO(b=0x%x, d=0x%x, f=0x%x) changing resource settings.\n",
                    PCI_PARENT_FDOX(PdoExtension)->BaseBus,
                    PdoExtension->Slot.u.bits.DeviceNumber,
                    PdoExtension->Slot.u.bits.FunctionNumber
                    );

                break;
            }
        }

        partial = newResources;
        oldPartial = PdoExtension->Resources->Current;

        if (dbgConfigurationChanged == TRUE) {
            PciDebugPrint(
                PciDbgAlways,
                "PCI - SetResources, old state, new state\n"
                );
            for (count = 0; count < PCI_MAX_RANGE_COUNT; count++) {
                PCM_PARTIAL_RESOURCE_DESCRIPTOR old = oldPartial + count;
                PCM_PARTIAL_RESOURCE_DESCRIPTOR new = partial + count;
                if ((old->Type == new->Type) &&
                    (new->Type == CmResourceTypeNull)) {
                    PciDebugPrint(
                        PciDbgAlways,
                        "00 <unused>\n"
                        );
                    continue;
                }
                PciDebugPrint(
                    PciDbgAlways,
                    "%02x %08x%08x %08x    ->    %02x %08x%08x %08x\n",
                    old->Type,
                    old->u.Generic.Start.HighPart,
                    old->u.Generic.Start.LowPart,
                    old->u.Generic.Length,
                    new->Type,
                    new->u.Generic.Start.HighPart,
                    new->u.Generic.Start.LowPart,
                    new->u.Generic.Length
                    );
                ASSERT((old->Type == new->Type) ||
                       (old->Type == CmResourceTypeNull) ||
                       (new->Type == CmResourceTypeNull));
            }
        }
    }

#endif

    for (count = 0;
         count < PCI_MAX_RANGE_COUNT;
         count++, partial++, oldPartial++) {

        //
        // If the resource type changed, OR, if any of the resources
        // settings changed (this latter only if type != NULL) ...
        //

        if ((partial->Type != oldPartial->Type) ||
            ((partial->Type != CmResourceTypeNull) &&
             ((partial->u.Generic.Start.QuadPart !=
               oldPartial->u.Generic.Start.QuadPart) ||
              (partial->u.Generic.Length != oldPartial->u.Generic.Length)))) {

            //
            // Devices settings have changed.
            //

            configurationChanged = TRUE;

#if DBG

            if (oldPartial->Type != CmResourceTypeNull) {
                PciDebugPrint(PciDbgSetResChange,
                              "      Old range-\n");
                PciDebugPrintPartialResource(PciDbgSetResChange, oldPartial);
            } else {
                PciDebugPrint(PciDbgSetResChange,
                              "      Previously unset range\n");
            }
            PciDebugPrint(PciDbgSetResChange,
                          "      changed to\n");
            PciDebugPrintPartialResource(PciDbgSetResChange, partial);

#endif

            //
            // Copy the new setting into the "current" settings
            // array.   This will then be written to the h/w.
            //

            oldPartial->Type = partial->Type;
            oldPartial->u.Generic = partial->u.Generic;
        }
    }

    return configurationChanged || PdoExtension->UpdateHardware;
}

NTSTATUS
PciSetResources(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN BOOLEAN        PowerOn,
    IN BOOLEAN        StartDeviceIrp
    )
/*++

Routine Description:

    Called to change a devices resource settings to those in the
    incoming list.

Arguments:

    PdoExtension    - Pointer to the PDO Extension for the PDO.
    Change          - TRUE is the resources are to be written.
    PowerOn         - TRUE if the device is having power restored
                      and extraneous config space registers should
                      be restored.  (PowerOn implies Change).
    StartDeviceIrp  - TRUE if this call is the result of a PNP START_DEVICE
                      IRP.

Return Value:

    Returns the status of the operation.

--*/

{
    PCI_COMMON_HEADER commonHeader;
    PPCI_COMMON_CONFIG commonConfig = (PPCI_COMMON_CONFIG)&commonHeader;
    PCI_MSI_CAPABILITY msiCapability;
    PPCI_FDO_EXTENSION fdoExtension = PCI_PARENT_FDOX(PdoExtension);
    ULONG configType;

    //
    // Get the common configuration data.
    //
    // N.B. This is done using RAW access to config space so that
    // (a) no pageable code is used, and
    // (b) the actual contents of the interrupt line register is
    //     returned/written.
    //

    PciGetConfigData(PdoExtension, commonConfig);

    if (!PcipIsSameDevice(PdoExtension, commonConfig)) {
        ASSERTMSG("PCI Set resources - not same device", 0);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // If this is a host bridge, bail.  We don't want to touch host bridge
    // config space.  This is a hack and should be fixed.
    //
    if (PdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV
    &&  PdoExtension->SubClass == PCI_SUBCLASS_BR_HOST) {

        return STATUS_SUCCESS;
    }

    if (PowerOn) {

        //
        // If this is an IDE controller then attempt to switch it to
        // native mode
        //

        if (PdoExtension->BaseClass == PCI_CLASS_MASS_STORAGE_CTLR
        &&  PdoExtension->SubClass == PCI_SUBCLASS_MSC_IDE_CTLR) {
            BOOLEAN switched;
        
            switched = PciConfigureIdeController(PdoExtension, commonConfig, FALSE);
            ASSERT(switched == PdoExtension->SwitchedIDEToNativeMode);
        }
    }

    //
    // Get part of the MSI capability structure for supported devices
    //

    //
    // NOTE: This code is UNTESTED due to the unavailability of MSI devices
    //
#if MSI_SUPPORTED

    if(PdoExtension->CapableMSI && PdoExtension->MsiInfo.MessageAddress) {

       //
       // Make sure we have an offset for the Capability structure
       //

       ASSERT(PdoExtension->MsiInfo.CapabilityOffset);

       //
       // We just need the message control register for configuration purposes
       //

        PciReadDeviceConfig(
            PdoExtension,
            &(msiCapability.MessageControl),
            PdoExtension->MsiInfo.CapabilityOffset +
               FIELD_OFFSET(PCI_MSI_CAPABILITY, MessageControl),
            sizeof(msiCapability.MessageControl)
        );

    }

#endif

    //
    // If this device is marked as needing hot plug configuration and we have a
    // clue of what to do...
    //

    if (PdoExtension->NeedsHotPlugConfiguration && fdoExtension->HotPlugParameters.Acquired) {

        UCHAR readCacheLineSize;
        USHORT newCmdBits = 0;

        //
        // Save away our new latency timer so it gets written out below
        //

        PdoExtension->SavedLatencyTimer = fdoExtension->HotPlugParameters.LatencyTimer;



        PciDebugPrint(
            PciDbgConfigParam,
            "PCI - SetResources, PDOx %x current CacheLineSize is %x, Want %x\n",
            PdoExtension,
            (ULONG)commonConfig->CacheLineSize,
            (ULONG)fdoExtension->HotPlugParameters.CacheLineSize
            );

        //
        // Write out out suggested cache line size
        //

        PciWriteDeviceConfig(
            PdoExtension,
            &fdoExtension->HotPlugParameters.CacheLineSize,
            FIELD_OFFSET(PCI_COMMON_CONFIG, CacheLineSize),
            sizeof(fdoExtension->HotPlugParameters.CacheLineSize)
            );

        //
        // Check if the cache line size stuck which means the hardware liked it
        //

        PciReadDeviceConfig(
            PdoExtension,
            &readCacheLineSize,
            FIELD_OFFSET(PCI_COMMON_CONFIG, CacheLineSize),
            sizeof(readCacheLineSize)
            );

        PciDebugPrint(
            PciDbgConfigParam,
            "PCI - SetResources, PDOx %x After write, CacheLineSize %x\n",
            PdoExtension,
            (ULONG)readCacheLineSize
            );

        if ((readCacheLineSize == fdoExtension->HotPlugParameters.CacheLineSize) &&
            (readCacheLineSize != 0)) {

            PciDebugPrint(
                PciDbgConfigParam,
                "PCI - SetResources, PDOx %x cache line size stuck, set MWI\n",
                PdoExtension
                );

            //
            // First stash this so that when we power manage the device we set
            // it back correctly and that we want to set MWI...
            //

            PdoExtension->SavedCacheLineSize = fdoExtension->HotPlugParameters.CacheLineSize;
            newCmdBits |= PCI_ENABLE_WRITE_AND_INVALIDATE;

            //
            // ISSUE-3/16/2000-andrewth
            // If we get our PDO blown away (ie removed parent) then we forget that we need to
            // set MWI...
            //

        } else {
            PciDebugPrint(
                PciDbgConfigParam,
                "PCI - SetResources, PDOx %x cache line size non-sticky\n",
                PdoExtension
                );
        }

        //
        // Now deal with SERR and PERR - abandon hope all ye who set these bits on
        // flaky PC hardware...
        //

        if (fdoExtension->HotPlugParameters.EnableSERR) {
            newCmdBits |= PCI_ENABLE_SERR;
        }

        if (fdoExtension->HotPlugParameters.EnablePERR) {
            newCmdBits |= PCI_ENABLE_PARITY;
        }

        //
        // Update the command enables so we write this out correctly after a PM op
        //

        PdoExtension->CommandEnables |= newCmdBits;

    }

    //
    // Write the resources out to the hardware...
    //

    configType = PciGetConfigurationType(commonConfig);

    PciInvalidateResourceInfoCache(PdoExtension);

    //
    // Call the device type dependent routine to set the new
    // configuration.
    //

    PciConfigurators[configType].ChangeResourceSettings(
        PdoExtension,
        commonConfig
        );

    //
    // If we explicitly wanted the hardware updated (UpdateHardware flag)
    // this its done now...
    //

    PdoExtension->UpdateHardware = FALSE;

    if (PowerOn) {

        PciConfigurators[configType].ResetDevice(
            PdoExtension,
            commonConfig
            );

        //
        // Restore InterruptLine register too. (InterruptLine is
        // at same offset for header type 0, 1 and 2).
        //

        commonConfig->u.type0.InterruptLine =
                PdoExtension->RawInterruptLine;
    }

    //
    // Restore Maximum Latency and Cache Line Size.
    //

#if DBG

    if (commonConfig->LatencyTimer != PdoExtension->SavedLatencyTimer) {
        PciDebugPrint(
            PciDbgConfigParam,
            "PCI (pdox %08x) changing latency from %02x to %02x.\n",
            PdoExtension,
            commonConfig->LatencyTimer,
            PdoExtension->SavedLatencyTimer
            );
    }

    if (commonConfig->CacheLineSize != PdoExtension->SavedCacheLineSize) {
        PciDebugPrint(
            PciDbgConfigParam,
            "PCI (pdox %08x) changing cache line size from %02x to %02x.\n",
            PdoExtension,
            commonConfig->CacheLineSize,
            PdoExtension->SavedCacheLineSize
            );
    }

#endif

    //
    // Restore random registers
    //

    commonConfig->LatencyTimer = PdoExtension->SavedLatencyTimer;
    commonConfig->CacheLineSize  = PdoExtension->SavedCacheLineSize;
    commonConfig->u.type0.InterruptLine = PdoExtension->RawInterruptLine;

    //
    // Restore the command register we remember in the power down case
    //

    commonConfig->Command = PdoExtension->CommandEnables;

    //
    // Disable the device while we write the rest of its config
    // space.  Also, don't write any non-zero value to it's status
    // register.
    //

    if ((PdoExtension->HackFlags & PCI_HACK_PRESERVE_COMMAND) == 0) {
        commonConfig->Command &= ~(PCI_ENABLE_IO_SPACE |
                                  PCI_ENABLE_MEMORY_SPACE |
                                  PCI_ENABLE_BUS_MASTER |
                                  PCI_ENABLE_WRITE_AND_INVALIDATE);
    }
    commonConfig->Status = 0;

    //
    // Call out and apply any hacks necessary
    //

    PciApplyHacks(
        PCI_PARENT_FDOX(PdoExtension),
        commonConfig,
        PdoExtension->Slot,
        EnumStartDevice,
        PdoExtension
        );

    //
    // Write it out to the hardware
    //

    PciSetConfigData(PdoExtension, commonConfig);

#if MSI_SUPPORTED

    //
    // Program MSI devices with their new message interrupt resources
    //
    // NOTE: This code is UNTESTED due to the unavailability of MSI devices
    //

    if (PdoExtension->CapableMSI && PdoExtension->MsiInfo.MessageAddress) {

        PciDebugPrint(
            PciDbgInformative,
            "PCI: Device %08x being reprogrammed for MSI.\n",
            PdoExtension->PhysicalDeviceObject
            );

        //
        // Set the proper resources in the MSI capability structure
        // and write them to Hardware.
        //
        // Message Address
        //

        ASSERT(PdoExtension->MsiInfo.MessageAddress);
        msiCapability.MessageAddress.Raw = PdoExtension->MsiInfo.MessageAddress;

        //
        // Must be DWORD aligned address
        //
        ASSERT(msiCapability.MessageAddress.Register.Reserved == 0);

        //
        // Write the Message Address register in Hardware.
        //

        PciWriteDeviceConfig(
            PdoExtension,
            &(msiCapability.MessageAddress),
            PdoExtension->MsiInfo.CapabilityOffset +
                FIELD_OFFSET(PCI_MSI_CAPABILITY,MessageAddress),
            sizeof(msiCapability.MessageAddress)
            );

        //
        // Message Upper Address
        //

       if(msiCapability.MessageControl.CapableOf64Bits) {

          // All the APICs we know live below 4GB so their upper address component
          // is always 0.
           msiCapability.Data.Bit64.MessageUpperAddress = 0;


            PciWriteDeviceConfig(
                PdoExtension,
                &(msiCapability.Data.Bit64.MessageUpperAddress),
                PdoExtension->MsiInfo.CapabilityOffset +
                  FIELD_OFFSET(PCI_MSI_CAPABILITY,Data.Bit64.MessageUpperAddress),
                sizeof(msiCapability.Data.Bit64.MessageUpperAddress)
                );

            //
            // Message Data
            //

            msiCapability.Data.Bit64.MessageData = PdoExtension->MsiInfo.MessageData;

            PciWriteDeviceConfig(
              PdoExtension,
              &(msiCapability.Data.Bit64.MessageData),
              PdoExtension->MsiInfo.CapabilityOffset +
                 FIELD_OFFSET(PCI_MSI_CAPABILITY,Data.Bit64.MessageData),
              sizeof(msiCapability.Data.Bit64.MessageData)
              );



       } else {

            //
            // Message Data
            //

            msiCapability.Data.Bit32.MessageData = PdoExtension->MsiInfo.MessageData;

            //
            // Write to hardware.
            //

          PciWriteDeviceConfig(
              PdoExtension,
              &(msiCapability.Data.Bit32.MessageData),
              PdoExtension->MsiInfo.CapabilityOffset +
                 FIELD_OFFSET(PCI_MSI_CAPABILITY,Data.Bit32.MessageData),
              sizeof(msiCapability.Data.Bit32.MessageData)
              );
        }

        // # of Messages granted
        //
        // We have the arbiter allocate only 1 interrupt for us, so we
        // are allocating just 1 message.
        //

        msiCapability.MessageControl.MultipleMessageEnable = 1;

        //
        // Enable bit
        //

        msiCapability.MessageControl.MSIEnable = 1;

        //
        // Write the message control register to Hardware
        //

       PciWriteDeviceConfig(
           PdoExtension,
           &(msiCapability.MessageControl),
           PdoExtension->MsiInfo.CapabilityOffset +
              FIELD_OFFSET(PCI_MSI_CAPABILITY,MessageControl),
           sizeof(msiCapability.MessageControl)
           );

    }

#endif // MSI_SUPPORTED





    //
    // Update our concept of the RawInterruptLine (either as read from
    // the h/w or restored by us).  Note: InterruptLine is at the same
    // offset for types 0, 1 and 2 PCI config space headers.
    //

    PdoExtension->RawInterruptLine = commonConfig->u.type0.InterruptLine;

    //
    // New values written to config space, now re-enable the
    // device (as indicated in the CommandEnables)
    //

    PciDecodeEnable(PdoExtension, TRUE, &PdoExtension->CommandEnables);

    //
    // If it needed configuration its done by now!
    //

    PdoExtension->NeedsHotPlugConfiguration = FALSE;

    return STATUS_SUCCESS;
}


VOID
PciGetEnhancedCapabilities(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG Config
)
/*++

Routine Description:

    This routine sets the appropriate fields in the Pdo extension relating
    to capabilities and power. If no power management registers are available
    the power state is based off of the decode fields. PCI bus reset code
    depends on this, and to prevent excessive resets this routine should only
    be called immediately after a new PDO is created.

    NOTE:
    We should rename this function to something with GetInitialState in the
    title and so it can't be confused with IRP_MN_QUERY_CAPABILITIES.

Arguments:

    PdoExtension    - Pointer to the PDO Extension for the PDO.
    Config          - Pointer to the common portion of the config space.

Return Value:

    None.

--*/
{
    ULONG configType;
    UCHAR capPtr = 0;
    PCI_MSI_CAPABILITY msi;
    UCHAR msicapptr;

    PAGED_CODE();

    //
    // If this function supports a capabilities list, record the
    // capabilities pointer.
    //

    PdoExtension->PowerState.DeviceWakeLevel = PowerDeviceUnspecified;

    if (!(Config->Status & PCI_STATUS_CAPABILITIES_LIST)) {

        //
        // If we don't have a capability bit we can't do MSI or Power management
        //

        PdoExtension->HackFlags |= PCI_HACK_NO_PM_CAPS;
        PdoExtension->CapabilitiesPtr = 0;
#if MSI_SUPPORTED
        PdoExtension->CapableMSI = FALSE;
#endif
        goto PciGetCapabilitiesExit;
    }

    switch (PciGetConfigurationType(Config)) {
    case PCI_DEVICE_TYPE:
        capPtr = Config->u.type0.CapabilitiesPtr;
        break;
    case PCI_BRIDGE_TYPE:
        capPtr = Config->u.type1.CapabilitiesPtr;
        break;
    case PCI_CARDBUS_BRIDGE_TYPE:
        capPtr = Config->u.type2.CapabilitiesPtr;
        break;
    }

    //
    // Capabilities pointers are a new feature so we verify a
    // little that the h/w folks built the right thing. Must
    // be a DWORD offset, must not point into common header.
    // (Zero is allowable, means not used).
    //

    if (capPtr) {
        if (((capPtr & 0x3) == 0) && (capPtr >= PCI_COMMON_HDR_LENGTH)) {
            PdoExtension->CapabilitiesPtr = capPtr;
        } else {
            ASSERT(((capPtr & 0x3) == 0) && (capPtr >= PCI_COMMON_HDR_LENGTH));
        }
    }

#if MSI_SUPPORTED

    //
    // Search for the MSI capability structure
    // Just get the structure header since we don't look at the structure here.
    //

    msicapptr = PciReadDeviceCapability(
                    PdoExtension,
                    PdoExtension->CapabilitiesPtr,
                    PCI_CAPABILITY_ID_MSI,
                    &msi,
                    sizeof(PCI_CAPABILITIES_HEADER)
                    );

    if (msicapptr != 0) {

        PciDebugPrint(PciDbgInformative,"PCI: MSI Capability Found for device %p\n",
                      PdoExtension->PhysicalDeviceObject);

        //
        // Cache the capability address in the PDO extension
        // and initialize MSI routing info.
        //

        PdoExtension->MsiInfo.CapabilityOffset = msicapptr;
        PdoExtension->MsiInfo.MessageAddress = 0;
        PdoExtension->MsiInfo.MessageData = 0;

        //
        // Mark this PDO as capable of MSI.
        //

        PdoExtension->CapableMSI = TRUE;
    }

#endif // MSI_SUPPORTED

    //
    // See if the device is Power Management capable.
    //

    if (!(PdoExtension->HackFlags & PCI_HACK_NO_PM_CAPS)) {

        PCI_PM_CAPABILITY pm;
        UCHAR pmcapptr;

        pmcapptr = PciReadDeviceCapability(
                        PdoExtension,
                        PdoExtension->CapabilitiesPtr,
                        PCI_CAPABILITY_ID_POWER_MANAGEMENT,
                        &pm,
                        sizeof(pm)
                        );

        if (pmcapptr != 0) {

            //
            // Found a PM capability structure.
            //
            // Select "most powered off state" this device can
            // issue a PME from.
            //

            DEVICE_POWER_STATE ds = PowerDeviceUnspecified;

            if (pm.PMC.Capabilities.Support.PMED0    ) ds = PowerDeviceD0;
            if (pm.PMC.Capabilities.Support.PMED1    ) ds = PowerDeviceD1;
            if (pm.PMC.Capabilities.Support.PMED2    ) ds = PowerDeviceD2;
            if (pm.PMC.Capabilities.Support.PMED3Hot ) ds = PowerDeviceD3;
            if (pm.PMC.Capabilities.Support.PMED3Cold) ds = PowerDeviceD3;

            PdoExtension->PowerState.DeviceWakeLevel = ds;

            //
            // Record the current power state.
            // Note: D0 = 0, thru D3 = 3, convert to
            // PowerDeviceD0 thru PowerDeviceD3.  It's
            // only a two bit field (in h/w) so no other
            // values are possible.
            //

            PdoExtension->PowerState.CurrentDeviceState =
                pm.PMCSR.ControlStatus.PowerState +
                PowerDeviceD0;

            //
            // Remember the power capabilities
            //

            PdoExtension->PowerCapabilities = pm.PMC.Capabilities;

        } else {

            //
            // Device has capabilities but not Power
            // Management capabilities.  Cheat a little
            // by pretending the registry flag is set
            // that says this.  (This speeds saves us
            // hunting through the h/w next time we
            // want to look at the PM caps).
            //

            PdoExtension->HackFlags |= PCI_HACK_NO_PM_CAPS;
        }
    }

PciGetCapabilitiesExit:
    if (PdoExtension->HackFlags & PCI_HACK_NO_PM_CAPS) {

        //
        // In this case we only support D0 and D3. D3 is defined as decodes
        // off.
        //
        if ((Config->Command & (PCI_ENABLE_IO_SPACE |
                                PCI_ENABLE_MEMORY_SPACE |
                                PCI_ENABLE_BUS_MASTER)) != 0) {

            PdoExtension->PowerState.CurrentDeviceState = PowerDeviceD0;

        } else {

            PdoExtension->PowerState.CurrentDeviceState = PowerDeviceD3;
        }
    }
}


NTSTATUS
PciScanHibernatedBus(
    IN PPCI_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    Scan the bus (detailed in FdoExtension) for any new PCI devices
    that were not there when we hibernated and turn them off if doing so seems
    like a good idea.

Arguments:

    FdoExtension - Our extension for the PCI bus functional device object.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    PCI_COMMON_HEADER commonHeader;
    PPCI_COMMON_CONFIG commonConfig = (PPCI_COMMON_CONFIG)&commonHeader;
    PDEVICE_OBJECT physicalDeviceObject;
    PPCI_PDO_EXTENSION pdoExtension;
    PCI_SLOT_NUMBER slot;
    ULONG deviceNumber;
    ULONG functionNumber;
    USHORT SubVendorID, SubSystemID;
    BOOLEAN isRoot;
    ULONGLONG hackFlags;
    ULONG maximumDevices;
    BOOLEAN newDevices = FALSE;

    PciDebugPrint(PciDbgPrattling,
                  "PCI Scan Bus: FDO Extension @ 0x%x, Base Bus = 0x%x\n",
                  FdoExtension,
                  FdoExtension->BaseBus);

    isRoot = PCI_IS_ROOT_FDO(FdoExtension);

    //
    // Examine each possible device on this bus.
    //

    maximumDevices = PCI_MAX_DEVICES;
    if (!isRoot) {

        //
        // Examine the PDO extension for the bridge device and see
        // if it's broken.
        //

        pdoExtension = (PPCI_PDO_EXTENSION)
                       FdoExtension->PhysicalDeviceObject->DeviceExtension;

        ASSERT_PCI_PDO_EXTENSION(pdoExtension);

        if (pdoExtension->HackFlags & PCI_HACK_ONE_CHILD) {
            maximumDevices = 1;
        }
    }

    slot.u.AsULONG = 0;

    for (deviceNumber = 0;
         deviceNumber < maximumDevices;
         deviceNumber++) {

        slot.u.bits.DeviceNumber = deviceNumber;

        //
        // Examine each possible function on this device.
        // N.B. Early out if function 0 not present.
        //

        for (functionNumber = 0;
             functionNumber < PCI_MAX_FUNCTION;
             functionNumber++) {

            slot.u.bits.FunctionNumber = functionNumber;

            PciReadSlotConfig(FdoExtension,
                              slot,
                              commonConfig,
                              0,
                              sizeof(commonConfig->VendorID)
                              );


            if (commonConfig->VendorID == 0xFFFF ||
                commonConfig->VendorID == 0) {

                if (functionNumber == 0) {

                    //
                    // Didn't get any data on function zero of this
                    // device, no point in checking other functions.
                    //

                    break;

                } else {

                    //
                    // Check next function.
                    //

                    continue;

                }
            }

            //
            // We have a device so get the rest of its config space
            //

            PciReadSlotConfig(FdoExtension,
                              slot,
                              &commonConfig->DeviceID,
                              FIELD_OFFSET(PCI_COMMON_CONFIG, DeviceID),
                              sizeof(PCI_COMMON_HEADER)
                                - sizeof(commonConfig->VendorID)
                              );

            //
            // Munge the config space if necessary
            //

            PciApplyHacks(FdoExtension,
                          commonConfig,
                          slot,
                          EnumHackConfigSpace,
                          NULL
                          );


            if ((PciGetConfigurationType(commonConfig) == PCI_DEVICE_TYPE) &&
                (commonConfig->BaseClass != PCI_CLASS_BRIDGE_DEV)) {
                SubVendorID = commonConfig->u.type0.SubVendorID;
                SubSystemID = commonConfig->u.type0.SubSystemID;
            } else {
                SubVendorID = 0;
                SubSystemID = 0;
            }

            hackFlags = PciGetHackFlags(commonConfig->VendorID,
                                        commonConfig->DeviceID,
                                        SubVendorID,
                                        SubSystemID,
                                        commonConfig->RevisionID
                                        );

            if (PciSkipThisFunction(commonConfig,
                                    slot,
                                    EnumBusScan,
                                    hackFlags)) {
                //
                // Skip this function
                //

                continue;
            }


            //
            // In case we are rescanning the bus, check to see if
            // a PDO for this device already exists as a child of
            // the FDO.
            //

            pdoExtension = PciFindPdoByFunction(
                               FdoExtension,
                               slot,
                               commonConfig);

            if (pdoExtension == NULL) {

                newDevices = TRUE;

                //
                // This is a new device disable it if we can
                //

                if (PciCanDisableDecodes(NULL, commonConfig, hackFlags, 0)) {

                    commonConfig->Command &= ~(PCI_ENABLE_IO_SPACE |
                                               PCI_ENABLE_MEMORY_SPACE |
                                               PCI_ENABLE_BUS_MASTER);

                    PciWriteSlotConfig(FdoExtension,
                                       slot,
                                       &commonConfig->Command,
                                       FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
                                       sizeof(commonConfig->Command)
                                       );
                }

            } else {

                //
                // We already know about this device so leave well alone!
                //

            }

            if ( (functionNumber == 0) &&
                !PCI_MULTIFUNCTION_DEVICE(commonConfig) ) {

                //
                // Not a multifunction adapter, skip other functions on
                // this device.
                //

                break;
            }
        }       // function loop
    }           // device loop

    //
    // Tell pnp we found some new devices
    //

    if (newDevices) {
        IoInvalidateDeviceRelations(FdoExtension->PhysicalDeviceObject, BusRelations);
    }

    return STATUS_SUCCESS;

}


BOOLEAN
PciConfigureIdeController(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN OUT PPCI_COMMON_CONFIG Config,
    IN BOOLEAN TurnOffAllNative
    )
/*++

Routine Description:

    If this is an IDE contoller that can be switched to native mode
    and its not already there, we change the programming interface
    (yes PCI 2.x does say its read only) and check if it sticks.

    Assuming all went well we update the Config to reflect the change.

Arguments:

    PdoExtension - PDO for the IDE controller to be switched

    Config - Config header for said device
    
    TurnOffAllNative - If TRUE indicates that we are calling this from 
                       the initial bus scan and so we should turn 
                       thid native capable IDE controllers.  If 
                       FALSE we should turn off only if the we have
                       accessed the PCI_NATIVE_IDE_INTERFACE.

Return Value:

    TRUE if we sucessfully switched, FALSE otherwise

Note:

    We support three styles of PCI IDE controller:
         - Compatible mode controllers that consume 2 ISA interrupts
           and decode fixed legacy resources, together with an optional
           relocateable bus master register
         - Native mode controller which uses all 5 bars and the PCI
           interrupt for both channels
         - Controllers which can be switched between modes.
    We do NOT support running one channel in native mode and one in
    compatible mode.

--*/


{

    BOOLEAN primaryChangeable, secondaryChangeable, primaryNative, secondaryNative, switched = FALSE;
    UCHAR progIf, tempProgIf;
    USHORT command;

    primaryChangeable = BITS_SET(Config->ProgIf, PCI_IDE_PRIMARY_MODE_CHANGEABLE);
    secondaryChangeable = BITS_SET(Config->ProgIf, PCI_IDE_SECONDARY_MODE_CHANGEABLE);
    primaryNative = BITS_SET(Config->ProgIf, PCI_IDE_PRIMARY_NATIVE_MODE);
    secondaryNative = BITS_SET(Config->ProgIf, PCI_IDE_SECONDARY_NATIVE_MODE);

    //
    // Don't touch controllers we don't support - leave ATAPI to deal with it!
    //

    if ((primaryNative != secondaryNative)
    ||  (primaryChangeable != secondaryChangeable)) {

        DbgPrint("PCI: Warning unsupported IDE controller configuration for VEN_%04x&DEV_%04x!",
                 PdoExtension->VendorId,
                 PdoExtension->DeviceId
                 );
        
        return FALSE;
    
    } else if (primaryNative && secondaryNative 
           && (TurnOffAllNative || PdoExtension->IoSpaceUnderNativeIdeControl)) {
    
        //
        // For a fully native mode controller turn off the IO decode.
        // In recent controllers MSFT has requested that this prevent
        // the PCI interrupt from being asserted to close a race condition
        // that can occur if an IDE device interrupts before the IDE driver
        // has been loaded on the PCI device.  This is not a issue for
        // compatible mode controllers because they use edge triggered 
        // interrupts that can be dismissed as spurious at the interrupt
        // controller, unlike the shared, level triggered,  PCI interrups
        // of native mode.
        //
        // Once loaded and having connected its interrupt the IDE driver
        // will renable IO space access.
        // 
        // We only do this during the initial bus scan or if the IDE driver
        // has requested it through the PCI_NATIVE_IDE_INTERFACE.  This is 
        // to avoid not enabling IoSpace for 3rd party native IDE controllers
        // with their own drivers.
        //
        
        PciGetCommandRegister(PdoExtension, &command);
        command &= ~PCI_ENABLE_IO_SPACE;
        PciSetCommandRegister(PdoExtension, command);
        Config->Command = command;

    } else if (primaryChangeable && secondaryChangeable
           &&  (PdoExtension->BIOSAllowsIDESwitchToNativeMode 
           &&  !(PdoExtension->HackFlags & PCI_HACK_BAD_NATIVE_IDE))) {
            
        //
        // If we aren't already in native mode, the controller can change modes
        // and the bios is ammenable then do so...
        //

        PciDecodeEnable(PdoExtension, FALSE, NULL);
        PciGetCommandRegister(PdoExtension, &Config->Command);

        progIf = Config->ProgIf | (PCI_IDE_PRIMARY_NATIVE_MODE 
                                   | PCI_IDE_SECONDARY_NATIVE_MODE);

        PciWriteDeviceConfig(PdoExtension, 
                             &progIf, 
                             FIELD_OFFSET(PCI_COMMON_CONFIG, ProgIf), 
                             sizeof(progIf)
                             );
        //
        // Check if it stuck
        //
        PciReadDeviceConfig(PdoExtension, 
                            &tempProgIf, 
                            FIELD_OFFSET(PCI_COMMON_CONFIG, ProgIf), 
                            sizeof(tempProgIf)
                            );

        if (tempProgIf == progIf) {
            //
            // If it stuck, remember we did this
            //
            Config->ProgIf = progIf;
            PdoExtension->ProgIf = progIf;
            switched = TRUE;
            
            //
            // Zero the first 4 bars in the config space because they might have
            // bogus values in them...
            //

            RtlZeroMemory(Config->u.type0.BaseAddresses, 
                          4 * sizeof(Config->u.type0.BaseAddresses[0]));

            PciWriteDeviceConfig(PdoExtension, 
                                 &Config->u.type0.BaseAddresses, 
                                 FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.BaseAddresses),
                                 4 * sizeof(Config->u.type0.BaseAddresses[0])
                                 );

            //
            // Read back what stuck into the config which we are going to generate 
            // requirements from
            //

            PciReadDeviceConfig(PdoExtension, 
                                &Config->u.type0.BaseAddresses, 
                                FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.BaseAddresses),
                                4 * sizeof(Config->u.type0.BaseAddresses[0])
                                );

            PciReadDeviceConfig(PdoExtension, 
                                &Config->u.type0.InterruptPin, 
                                FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.InterruptPin),
                                sizeof(Config->u.type0.InterruptPin)
                                );
        } else {
            
            DbgPrint("PCI: Warning failed switch to native mode for IDE controller VEN_%04x&DEV_%04x!",
                     Config->VendorID,
                     Config->DeviceID
                     );
        }
    }

    return switched;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\guid.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    guid.c

Abstract:

    This module instantiates the guids used by pci that are not part of 
    wdmguid.{h|lib}.
    
    It relies on the DEFINE_GUID macros being outside the #ifdef _FOO_H
    multiple inclusion fix.

Author:

    Peter Johnston (peterj)  20-Nov-1996

Revision History:

--*/

#include "pcip.h"
#include <initguid.h>
#include "pciintrf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\fdo.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    fdo.c

Abstract:

    This module handles IRPs for PCI FDO's.

Author:

    Adrian J. Oney (adriao) & Andrew Thornton (andrewth)  10-20-1998

Revision History:

--*/

#include "pcip.h"

NTSTATUS
PciFdoIrpStartDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpQueryRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpCancelRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpQueryStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpCancelStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpQueryCapabilities(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpQueryInterface(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpQueryLegacyBusInformation(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpDeviceUsageNotification(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoIrpSurpriseRemoval(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    );

VOID
PciGetHotPlugParameters(
    IN PPCI_FDO_EXTENSION Fdo
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciAddDevice)
#pragma alloc_text(PAGE, PciInitializeFdoExtensionCommonFields)
#pragma alloc_text(PAGE, PciFdoIrpStartDevice)
#pragma alloc_text(PAGE, PciFdoIrpQueryRemoveDevice)
#pragma alloc_text(PAGE, PciFdoIrpRemoveDevice)
#pragma alloc_text(PAGE, PciFdoIrpCancelRemoveDevice)
#pragma alloc_text(PAGE, PciFdoIrpQueryStopDevice)
#pragma alloc_text(PAGE, PciFdoIrpStopDevice)
#pragma alloc_text(PAGE, PciFdoIrpCancelStopDevice)
#pragma alloc_text(PAGE, PciFdoIrpQueryDeviceRelations)
#pragma alloc_text(PAGE, PciFdoIrpQueryInterface)
#pragma alloc_text(PAGE, PciFdoIrpQueryCapabilities)
#pragma alloc_text(PAGE, PciFdoIrpDeviceUsageNotification)
#pragma alloc_text(PAGE, PciFdoIrpSurpriseRemoval)
#pragma alloc_text(PAGE, PciFdoIrpQueryLegacyBusInformation)
#pragma alloc_text(PAGE, PciGetHotPlugParameters)
#endif

//
// The following is used to determine if we failed to get a
// reasonable configuration from the PDO (in AddDevice) more
// than once.  If only once, we try to guess, if twice, we're
// in big trouble.
//

static BOOLEAN HaveGuessedConfigOnceAlready = FALSE;

/*++

The majority of functions in this file are called based on their presence
in Pnp and Po dispatch tables.  In the interests of brevity the arguments
to all those functions will be described below:

NTSTATUS
PciXxxPdo(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpStack,
    IN PPCI_EXTENSION DeviceExtension
    )

Routine Description:

    This function handles the Xxx requests for a given PCI FDO or PDO.

Arguments:

    Irp - Points to the IRP associated with this request.

    IrpStack - Points to the current stack location for this request.

    DeviceExtension - Points to the device's extension.

Return Value:

    Status code that indicates whether or not the function was successful.

    STATUS_NOT_SUPPORTED indicates that the IRP should be completed without
    changing the Irp->IoStatus.Status field otherwise it is updated with this
    status.

--*/

#define PCI_MAX_MINOR_POWER_IRP  0x3
#define PCI_MAX_MINOR_PNP_IRP    0x18

PCI_MN_DISPATCH_TABLE PciFdoDispatchPowerTable[] = {
    { IRP_DISPATCH, PciFdoWaitWake                     }, // 0x00 - IRP_MN_WAIT_WAKE
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x01 - IRP_MN_POWER_SEQUENCE
    { IRP_DOWNWARD, PciFdoSetPowerState                }, // 0x02 - IRP_MN_SET_POWER
    { IRP_DOWNWARD, PciFdoIrpQueryPower                }, // 0x03 - IRP_MN_QUERY_POWER
    { IRP_DOWNWARD, PciIrpNotSupported                 }  //      - UNHANDLED Power IRP
};

PCI_MN_DISPATCH_TABLE PciFdoDispatchPnpTable[] = {
    { IRP_UPWARD,   PciFdoIrpStartDevice               }, // 0x00 - IRP_MN_START_DEVICE
    { IRP_DOWNWARD, PciFdoIrpQueryRemoveDevice         }, // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    { IRP_DISPATCH, PciFdoIrpRemoveDevice              }, // 0x02 - IRP_MN_REMOVE_DEVICE
    { IRP_DOWNWARD, PciFdoIrpCancelRemoveDevice        }, // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    { IRP_DOWNWARD, PciFdoIrpStopDevice                }, // 0x04 - IRP_MN_STOP_DEVICE
    { IRP_DOWNWARD, PciFdoIrpQueryStopDevice           }, // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    { IRP_DOWNWARD, PciFdoIrpCancelStopDevice          }, // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    { IRP_DOWNWARD, PciFdoIrpQueryDeviceRelations      }, // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    { IRP_DISPATCH, PciFdoIrpQueryInterface            }, // 0x08 - IRP_MN_QUERY_INTERFACE
    { IRP_UPWARD,   PciFdoIrpQueryCapabilities         }, // 0x09 - IRP_MN_QUERY_CAPABILITIES
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x0A - IRP_MN_QUERY_RESOURCES
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x0E - NOT USED
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x0F - IRP_MN_READ_CONFIG
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x10 - IRP_MN_WRITE_CONFIG
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x11 - IRP_MN_EJECT
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x12 - IRP_MN_SET_LOCK
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x13 - IRP_MN_QUERY_ID
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    { IRP_DOWNWARD, PciIrpNotSupported                 }, // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    { IRP_UPWARD,   PciFdoIrpDeviceUsageNotification   }, // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    { IRP_DOWNWARD, PciFdoIrpSurpriseRemoval           }, // 0x17 - IRP_MN_SURPRISE_REMOVAL
    { IRP_DOWNWARD, PciFdoIrpQueryLegacyBusInformation }, // 0x18 - IRP_MN_QUERY_LEGACY_BUS_INFORMATION
    { IRP_DOWNWARD, PciIrpNotSupported                 }  //      - UNHANDLED PNP IRP
};

//
// This is the major function dispatch table for Fdo's
//
PCI_MJ_DISPATCH_TABLE PciFdoDispatchTable = {
    PCI_MAX_MINOR_PNP_IRP,    PciFdoDispatchPnpTable,       // Pnp irps
    PCI_MAX_MINOR_POWER_IRP,  PciFdoDispatchPowerTable,     // Power irps
    IRP_DOWNWARD,             PciIrpNotSupported,           // SystemControl - just pass down!
    IRP_DOWNWARD,             PciIrpNotSupported            // DeviceControl - just pass down!
};

NTSTATUS
PciFdoIrpStartDevice(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Handler routine for start IRPs. This allows PDO filters to
    modify the allocated resources if they are filtering resource
    requirements. Called after completion.

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_START_DEVICE irp.

    FdoExtension - Supplies the FDO extension

Return Value:

    ERROR_SUCCESS if successful

    NTSTATUS error code otherwise

--*/
{
    NTSTATUS status;
    PPCI_FDO_EXTENSION fdoExtension;
    PPCI_PDO_EXTENSION pdoExtension;
    PCM_RESOURCE_LIST resources;
    UCHAR barType[PCI_TYPE1_ADDRESSES] = {0,0};
    ULONG index;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR currentResource;
    PIO_RESOURCE_DESCRIPTOR currentRequirement;
    

    PAGED_CODE();

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {

        return STATUS_NOT_SUPPORTED;
    }

    fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

    status = PciBeginStateTransition(DeviceExtension, PciStarted);

    if (!NT_SUCCESS(status)) {

        return status;
    }                                                                                       

    //
    // If this is a PCI-PCI bridge then check if it has any bars and if so exclude
    // them from the list used to initialize the arbiters.
    //
    
    resources = IrpSp->Parameters.StartDevice.AllocatedResources;

    if (resources && !PCI_IS_ROOT_FDO(fdoExtension)) {
        
        ASSERT(resources->Count == 1);
        
        pdoExtension = PCI_BRIDGE_PDO(fdoExtension);

        if (pdoExtension->Resources) {

            if (pdoExtension->HeaderType == PCI_BRIDGE_TYPE) {
            
                //
                // If there are any bars they are at the beginning of the list 
                // so "begin at the beginning which is a very good place to start".
                //
                
                currentResource = resources->List[0].PartialResourceList.PartialDescriptors;
                
                for (index = 0; index < PCI_TYPE1_ADDRESSES; index++) {
                    
                    //
                    // Extract the requirement we asked for to determine if this
                    // bridge implements any bars (index 0 and 1 in the Limits 
                    // array)
                    //
                    
                    currentRequirement = &pdoExtension->Resources->Limit[index]; 
                    
                    //
                    // CmResourceTypeNull indicates that we didn't request any 
                    // resources so the bar is not implemented and there is nothing
                    // to prune out.
                    //
                    
                    if (currentRequirement->Type != CmResourceTypeNull) {
                        
                        ASSERT(currentResource->Type == currentRequirement->Type);
    
                        //
                        // Save away the type so we can restore it later
                        //
    
                        barType[index] = currentResource->Type;
                        
                        //
                        // Null out the resource so we don't configure the arbiters to
                        // use it
                        //
                        
                        currentResource->Type = CmResourceTypeNull;
    
                        //
                        // Advance the pointer into the started resources by 2 
                        // descriptors to skip over the device private
                        //
    
                        ASSERT((currentResource+1)->Type == CmResourceTypeDevicePrivate);
                        
                        currentResource+=2;
                    }
                }
            }
        }
    }

    //
    // Initialize the arbiters
    //

    status = PciInitializeArbiterRanges(fdoExtension, resources);

    //
    // Restore the original resource list if we changed it
    //
    
    if (resources && !PCI_IS_ROOT_FDO(fdoExtension) && pdoExtension->Resources) {
        
        currentResource = resources->List[0].PartialResourceList.PartialDescriptors;
        
        for (index = 0; index < PCI_TYPE1_ADDRESSES; index++) {
            
            if (barType[index] != CmResourceTypeNull) {
                
                currentResource->Type = barType[index];
                
                //
                // Advance the pointer into the started resources by 2 
                // descriptors to skip over the device private
                //

                ASSERT((currentResource+1)->Type == CmResourceTypeDevicePrivate);

                currentResource+=2;
            }
        }
    }

    if (!NT_SUCCESS(status)) {
        PciCancelStateTransition(DeviceExtension, PciStarted);
        return status;
    }

    PciCommitStateTransition(DeviceExtension, PciStarted);
    return STATUS_SUCCESS;
}

NTSTATUS
PciFdoIrpQueryRemoveDevice(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

    return PciBeginStateTransition(DeviceExtension, PciDeleted);
}

NTSTATUS
PciFdoIrpRemoveDevice(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PPCI_FDO_EXTENSION fdoExtension;
    PPCI_PDO_EXTENSION pdox;
    PDEVICE_OBJECT attachedDevice;
    NTSTATUS       status;

    PAGED_CODE();

    fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

    ExAcquireFastMutex(&fdoExtension->ChildListMutex);

    while (fdoExtension->ChildPdoList) {

        pdox = (PPCI_PDO_EXTENSION) fdoExtension->ChildPdoList;
#if DBG

        PciDebugPrint(
            PciDbgVerbose,
            "PCI Killing PDO %p PDOx %p (b=%d, d=%d, f=%d)\n",
            pdox->PhysicalDeviceObject,
            pdox,
            PCI_PARENT_FDOX(pdox)->BaseBus,
            pdox->Slot.u.bits.DeviceNumber,
            pdox->Slot.u.bits.FunctionNumber
            );

        ASSERT(pdox->DeviceState == PciNotStarted);

#endif
        PciPdoDestroy(pdox->PhysicalDeviceObject);
    }

    ExReleaseFastMutex(&fdoExtension->ChildListMutex);

    //
    // Destroy any secondary extensions associated with
    // this FDO.
    //
    while (fdoExtension->SecondaryExtension.Next) {

        PcipDestroySecondaryExtension(
            &fdoExtension->SecondaryExtension,
            NULL,
            fdoExtension->SecondaryExtension.Next
            );
    }

    //
    // Destroy the FDO.
    //
    // The IRP needs to go down the device stack but we
    // need to remove the device from the stack so grab
    // the next object first, then detach, then pass it
    // down.
    //
    PciDebugPrint(
        PciDbgInformative,
        "PCI FDOx (%p) destroyed.",
        fdoExtension
        );

    //
    // Note that a filter above us may have failed Start. If this is so, we get
    // no query because the "devnode" has never been started...
    //
    if (!PciIsInTransitionToState(DeviceExtension, PciDeleted)) {

        status = PciBeginStateTransition(DeviceExtension, PciDeleted);
        ASSERT(NT_SUCCESS(status));
    }

    PciCommitStateTransition(DeviceExtension, PciDeleted);

    PciRemoveEntryFromList(&PciFdoExtensionListHead,
                           &fdoExtension->List,
                           &PciGlobalLock);

    attachedDevice = fdoExtension->AttachedDeviceObject;
    IoDetachDevice(attachedDevice);
    IoDeleteDevice(fdoExtension->FunctionalDeviceObject);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(attachedDevice, Irp);
}

NTSTATUS
PciFdoIrpCancelRemoveDevice(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

    PciCancelStateTransition(DeviceExtension, PciDeleted);
    return STATUS_SUCCESS;
}

NTSTATUS
PciFdoIrpStopDevice(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

    PciCommitStateTransition(DeviceExtension, PciStopped);
    return STATUS_SUCCESS;
}

NTSTATUS
PciFdoIrpQueryStopDevice(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

    PciBeginStateTransition(DeviceExtension, PciStopped);

    //
    // We don't support multilevel rebalance so we can't stop host bridges.
    //

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
PciFdoIrpCancelStopDevice(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

    PciCancelStateTransition(DeviceExtension, PciStopped);
    return STATUS_SUCCESS;
}

NTSTATUS
PciFdoIrpQueryDeviceRelations(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

    if (IrpSp->Parameters.QueryDeviceRelations.Type == BusRelations) {

        return PciQueryDeviceRelations(
            (PPCI_FDO_EXTENSION) DeviceExtension,
            (PDEVICE_RELATIONS *) &Irp->IoStatus.Information
            );
    }

    //
    // No other relation types need to be handled.
    //
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
PciFdoIrpQueryCapabilities(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    Snoops the results of a QUERY CAPABILITIES IRP that got sent
    downwards.   This saves us having to send our own for things
    like the device's power characteristics.

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_QUERY_CAPABILITIES irp.

    FdoExtension - Supplies the FDO extension

Return Value:

    STATUS_SUCCESS

--*/

{
    PDEVICE_CAPABILITIES capabilities;
    PPCI_FDO_EXTENSION fdoExtension;

    PAGED_CODE();

    fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    PciDebugPrint(
        PciDbgQueryCap,
        "PCI - FdoQueryCapabilitiesCompletion (fdox %08x) child status = %08x\n",
        fdoExtension,
        Irp->IoStatus.Status
        );

    //
    // Grab a pointer to the capablities for easy referencing
    //
    capabilities = IrpSp->Parameters.DeviceCapabilities.Capabilities;

    //
    // Remember what the system wake and device wake level are
    //
    fdoExtension->PowerState.SystemWakeLevel = capabilities->SystemWake;
    fdoExtension->PowerState.DeviceWakeLevel = capabilities->DeviceWake;

    //
    // Grab the S-state to D-State mapping
    //
    RtlCopyMemory(
        fdoExtension->PowerState.SystemStateMapping,
        capabilities->DeviceState,
        (PowerSystemShutdown + 1) * sizeof(DEVICE_POWER_STATE)
        );

#if DBG

    if (PciDebug & PciDbgQueryCap) {
        PciDebugDumpQueryCapabilities(capabilities);
    }

#endif

    return STATUS_SUCCESS;
}



NTSTATUS
PciFdoIrpQueryLegacyBusInformation(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

    return PciQueryLegacyBusInformation(
        (PPCI_FDO_EXTENSION) DeviceExtension,
        (PLEGACY_BUS_INFORMATION *) &Irp->IoStatus.Information
        );
}

NTSTATUS
PciFdoIrpDeviceUsageNotification(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
   PPCI_FDO_EXTENSION fdoExtension;

   PAGED_CODE();

   fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        return PciLocalDeviceUsage(&fdoExtension->PowerState, Irp);

    } else {

        return STATUS_NOT_SUPPORTED;
    }
}

NTSTATUS
PciFdoIrpQueryInterface(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
   PPCI_FDO_EXTENSION fdoExtension;
   NTSTATUS status;

   PAGED_CODE();

   fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

   ASSERT_PCI_FDO_EXTENSION(fdoExtension);


   // NTRAID #54671 - 4/20/2000 - andrewth
   //
   // We might want to do a synchronizing state
   // transition here so we don't attempt to get the interface during a
   // stop/remove sequence.
   //
   // We shouldn't hold interfaces when something isn't
   // started. But we won't boot unless we hack the below....
   //

   //if (fdoExtension->DeviceState != PciStarted) {
   if (fdoExtension->DeviceState == PciDeleted) {

       return PciPassIrpFromFdoToPdo(DeviceExtension, Irp);
   }

   status = PciQueryInterface(
                fdoExtension,
                IrpSp->Parameters.QueryInterface.InterfaceType,
                IrpSp->Parameters.QueryInterface.Size,
                IrpSp->Parameters.QueryInterface.Version,
                IrpSp->Parameters.QueryInterface.InterfaceSpecificData,
                IrpSp->Parameters.QueryInterface.Interface,
                FALSE
                );

   if (NT_SUCCESS(status)) {

       Irp->IoStatus.Status = status;
       return PciPassIrpFromFdoToPdo(DeviceExtension, Irp);

   } else if (status == STATUS_NOT_SUPPORTED) {

       //
       // Status == STATUS_NOT_SUPPORTED. Pass IRP down the stack
       // and see if anyone else is kind enough to provide this
       // interface.
       //
       status = PciCallDownIrpStack(DeviceExtension, Irp);

       if (status == STATUS_NOT_SUPPORTED) {

           //
           // If nobody provided the interface, try again at
           // this level.
           //
           status = PciQueryInterface(
               fdoExtension,
               IrpSp->Parameters.QueryInterface.InterfaceType,
               IrpSp->Parameters.QueryInterface.Size,
               IrpSp->Parameters.QueryInterface.Version,
               IrpSp->Parameters.QueryInterface.InterfaceSpecificData,
               IrpSp->Parameters.QueryInterface.Interface,
               TRUE
               );
       }
   }

   if (status != STATUS_NOT_SUPPORTED) {

       Irp->IoStatus.Status = status;
   } else {

       status = Irp->IoStatus.Status;
   }

   IoCompleteRequest(Irp, IO_NO_INCREMENT);
   return status;
}

NTSTATUS
PciFdoIrpSurpriseRemoval(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
   PPCI_FDO_EXTENSION fdoExtension;
   NTSTATUS status;

   PAGED_CODE();

   fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

   status = PciBeginStateTransition(DeviceExtension, PciSurpriseRemoved);
   ASSERT(NT_SUCCESS(status));
   if (NT_SUCCESS(status)) {

       PciCommitStateTransition(DeviceExtension, PciSurpriseRemoved);
       status = PciBeginStateTransition(DeviceExtension, PciDeleted);
   }
   return status;
}

NTSTATUS
PciAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    Given a physical device object, this routine creates a functional
    device object for it.

Arguments:

    DriverObject - Pointer to our driver's DRIVER_OBJECT structure.

    PhysicalDeviceObject - Pointer to the physical device object for which
                           we must create a functional device object.

Return Value:

    NT status.

--*/
{
    PDEVICE_OBJECT functionalDeviceObject = NULL;
    PDEVICE_OBJECT attachedTo = NULL;
    PPCI_FDO_EXTENSION fdoExtension = NULL;
    PPCI_FDO_EXTENSION pciParentFdoExtension;
    PPCI_PDO_EXTENSION pdoExtension;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;
    NTSTATUS       status;
    PSINGLE_LIST_ENTRY nextEntry;
    HANDLE deviceRegistryHandle;
    ULONG resultLength;
    UNICODE_STRING hackFlagsString;
    UCHAR infoBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG) - 1];
    PKEY_VALUE_PARTIAL_INFORMATION info = (PKEY_VALUE_PARTIAL_INFORMATION) infoBuffer;

    PAGED_CODE();

    PciDebugPrint(PciDbgAddDevice, "PCI - AddDevice (a new bus).\n");

    //
    // Find out if the PDO was created by the PCI driver.  That is,
    // if it is a child or a root bus.   Validate a few things before
    // going any further.
    //

    pciParentFdoExtension = PciFindParentPciFdoExtension(PhysicalDeviceObject,
                                                         &PciGlobalLock);
    if (pciParentFdoExtension) {

        //
        // The PDO was created by this driver, therefore we can look at
        // the extension.   Get it and verify it's ours.
        //

        pdoExtension = (PPCI_PDO_EXTENSION)PhysicalDeviceObject->DeviceExtension;
        ASSERT_PCI_PDO_EXTENSION(pdoExtension);

        //
        // The only thing we should get an add device that is a
        // child device is a PCI-PCI bridge.
        //

        if ((pdoExtension->BaseClass != PCI_CLASS_BRIDGE_DEV) ||
            (pdoExtension->SubClass  != PCI_SUBCLASS_BR_PCI_TO_PCI)) {
            PciDebugPrint(
                PciDbgAlways,
                "PCI - PciAddDevice for Non-Root/Non-PCI-PCI bridge,\n"
                "      Class %02x, SubClass %02x, will not add.\n",
                pdoExtension->BaseClass,
                pdoExtension->SubClass
                );
            ASSERT((pdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV) &&
                   (pdoExtension->SubClass  == PCI_SUBCLASS_BR_PCI_TO_PCI));

            status = STATUS_INVALID_DEVICE_REQUEST;
            goto cleanup;
        }

        PciDebugPrint(PciDbgAddDevice,
                      "PCI - AddDevice (new bus is child of bus 0x%x).\n",
                      pciParentFdoExtension->BaseBus
                      );

        if (!PciAreBusNumbersConfigured(pdoExtension)) {

            //
            // This bridge isn't configured and if we had been able to we would
            // already have done so
            //

            PciDebugPrint(
                PciDbgAddDevice | PciDbgInformative,
                "PCI - Bus numbers not configured for bridge (0x%x.0x%x.0x%x)\n",
                pciParentFdoExtension->BaseBus,
                pdoExtension->Slot.u.bits.DeviceNumber,
                pdoExtension->Slot.u.bits.FunctionNumber,
                pdoExtension->Dependent.type1.PrimaryBus
            );

            status = STATUS_INVALID_DEVICE_REQUEST;
            goto cleanup;

        }
    }

    //
    // We've been given the PhysicalDeviceObject for a PCI bus.  Create the
    // functionalDeviceObject.  Our FDO will be nameless.
    //

    status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof(PCI_FDO_EXTENSION),      // size of our extension
                NULL,                       // our name
                FILE_DEVICE_BUS_EXTENDER,   // device type
                0,                          // device characteristics
                FALSE,                      // not exclusive
                &functionalDeviceObject     // store new device object here
                );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    fdoExtension = (PPCI_FDO_EXTENSION)functionalDeviceObject->DeviceExtension;

    //
    // We have our functionalDeviceObject, initialize it.
    //

    PciInitializeFdoExtensionCommonFields(
        fdoExtension,
        functionalDeviceObject,
        PhysicalDeviceObject
        );

    //
    // Now attach to the PDO we were given.
    //

    attachedTo = IoAttachDeviceToDeviceStack(functionalDeviceObject,
                                             PhysicalDeviceObject);

    if (attachedTo == NULL) {

        ASSERT(attachedTo != NULL);
        status =  STATUS_NO_SUCH_DEVICE;
        goto cleanup;
    }

    fdoExtension->AttachedDeviceObject = attachedTo;

    //
    // Get the access registers and base bus number for this bus.
    // If this bus was discovered by this driver, then the PDO was
    // created by this driver and will be on one of the PDO lists
    // under one of the FDOs owned by this driver.  Otherwise it
    // is a new root,.... use magic.
    //

    if (pciParentFdoExtension) {

        //
        // This physical device was discovered by this driver.
        // Get the bus number from the PDO extension.
        //

        PSINGLE_LIST_ENTRY secondaryExtension;

        fdoExtension->BaseBus = pdoExtension->Dependent.type1.SecondaryBus;

        //
        // Copy the access methods from the root fdo and set
        // the root fdo back pointer.
        //

        fdoExtension->BusRootFdoExtension =
            pciParentFdoExtension->BusRootFdoExtension;

        //
        // Point the PDOextension to the new FDOextension (also indicates
        // the object is a bridge) and vice versa.
        //

        pdoExtension->BridgeFdoExtension = fdoExtension;
        fdoExtension->ParentFdoExtension = pciParentFdoExtension;

        //
        // Cause the requirements list to be reevaluated.
        //

        PciInvalidateResourceInfoCache(pdoExtension);

    } else {

        PVOID buffer;

        //
        // Get the boot configuration (CmResourceList) for
        // this PDO.  This gives us the bus number and the
        // ranges covered by this host bridge.
        //

        status = PciGetDeviceProperty(
                    PhysicalDeviceObject,
                    DevicePropertyBootConfiguration,
                    &buffer
                    );

        if (NT_SUCCESS(status)) {
#if DBG

            PciDebugPrint(PciDbgAddDeviceRes,
                         "PCI - CM RESOURCE LIST FROM ROOT PDO\n");
            PciDebugPrintCmResList(PciDbgAddDeviceRes,
                         buffer);

#endif

            descriptor = PciFindDescriptorInCmResourceList(
                            CmResourceTypeBusNumber,
                            buffer,
                            NULL
                            );
        } else {

            descriptor = NULL;
        }

        if (descriptor != NULL) {

            //
            // Sanity check, some servers are aproaching
            // 256 busses but as there is no way to deal with
            // numbering bridges under a bus > 256 and we don't
            // have raw and translated bus numbers yet - it had
            // better be < 0xFF!
            //

            ASSERT(descriptor->u.BusNumber.Start <= 0xFF);
            ASSERT(descriptor->u.BusNumber.Start + descriptor->u.BusNumber.Length - 1 <= 0xFF);

            fdoExtension->BaseBus =
                (UCHAR)descriptor->u.BusNumber.Start;
            fdoExtension->MaxSubordinateBus =
                (UCHAR)(descriptor->u.BusNumber.Start + descriptor->u.BusNumber.Length - 1);
            PciDebugPrint(PciDbgAddDevice,
                          "PCI - Root Bus # 0x%x->0x%x.\n",
                          fdoExtension->BaseBus,
                          fdoExtension->MaxSubordinateBus
                          );
        } else {

            //
            // HaveGuessedConfigOnceAlready is used to tell
            // if have multiple roots and no config info. If
            // this happens we end up gussing the bus number
            // as zero, doing this more than once is not good.
            //

            if (HaveGuessedConfigOnceAlready) {

                KeBugCheckEx(PCI_BUS_DRIVER_INTERNAL,
                             PCI_BUGCODE_TOO_MANY_CONFIG_GUESSES,
                             (ULONG_PTR)PhysicalDeviceObject,
                             0,
                             0);
            }
            PciDebugPrint(
                PciDbgAlways,
                "PCI   Will use default configuration.\n"
                );

            HaveGuessedConfigOnceAlready = TRUE;
            fdoExtension->BaseBus = 0;
        }

        fdoExtension->BusRootFdoExtension = fdoExtension;
    }

    //
    // Organise access to config space
    //

    status = PciGetConfigHandlers(fdoExtension);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Initialize arbiters for this FDO.
    //

    status = PciInitializeArbiters(fdoExtension);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Indicate this is a REAL FDO extension that is part of a REAL
    // FDO.   (Fake extensions exist to assist in the enumeration of
    // busses which PCI isn't the real controller for (eg CardBus).
    //

    fdoExtension->Fake = FALSE;

    //
    // Insert this Fdo in the list of PCI parent Fdos.
    //

    PciInsertEntryAtTail(&PciFdoExtensionListHead,
                         &fdoExtension->List,
                         &PciGlobalLock);


#if defined(_WIN64)

    //
    // Update the legacy hardware tree that would have been build by the ARC
    // firmware or NTDetect which don't exist here.
    //

    status = PciUpdateLegacyHardwareDescription(fdoExtension);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

#endif

    //
    // Check if there are any hacks to apply to this bus.
    // These are located under the device registry key in a value called HackFlags
    //

    status = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_ALL_ACCESS,
                                     &deviceRegistryHandle
                                     );



    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    PciConstStringToUnicodeString(&hackFlagsString, L"HackFlags");

    status = ZwQueryValueKey(deviceRegistryHandle,
                             &hackFlagsString,
                             KeyValuePartialInformation,
                             info,
                             sizeof(infoBuffer),
                             &resultLength
                             );
    
    ZwClose(deviceRegistryHandle);

    //
    // If we have valid data in the registry then remember it
    //

    if (NT_SUCCESS(status)
    && (info->Type == REG_DWORD)
    && (info->DataLength == sizeof(ULONG))) {
    
        fdoExtension->BusHackFlags = *((PULONG)(&info->Data));
    }

    //
    // We can receive IRPs now...
    //

    functionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;


    //
    // Get any hotplug parameters (we send IRPS for this so it must be after
    // DO_DEVICE_INITIALIZING is cleared so we can deal with them)
    //
    PciGetHotPlugParameters(fdoExtension);

    return STATUS_SUCCESS;

cleanup:

    ASSERT(!NT_SUCCESS(status));

    //
    // Destroy any secondary extensions associated with
    // this FDO.
    //
    if (fdoExtension) {

        while (fdoExtension->SecondaryExtension.Next) {

            PcipDestroySecondaryExtension(
                &fdoExtension->SecondaryExtension,
                NULL,
                fdoExtension->SecondaryExtension.Next
                );
        }
    }

    if (attachedTo) {
        IoDetachDevice(attachedTo);
    }

    if (functionalDeviceObject) {
        IoDeleteDevice(functionalDeviceObject);
    }

    return status;
}

VOID
PciInitializeFdoExtensionCommonFields(
    IN  PPCI_FDO_EXTENSION  FdoExtension,
    IN  PDEVICE_OBJECT  Fdo,
    IN  PDEVICE_OBJECT  Pdo
    )
{
    RtlZeroMemory(FdoExtension, sizeof(PCI_FDO_EXTENSION));

    FdoExtension->ExtensionType = PciFdoExtensionType;
    FdoExtension->PhysicalDeviceObject = Pdo;
    FdoExtension->FunctionalDeviceObject = Fdo;
    FdoExtension->PowerState.CurrentSystemState = PowerSystemWorking;
    FdoExtension->PowerState.CurrentDeviceState = PowerDeviceD0;
    FdoExtension->IrpDispatchTable = &PciFdoDispatchTable;
    ExInitializeFastMutex(&FdoExtension->SecondaryExtMutex);
    ExInitializeFastMutex(&FdoExtension->ChildListMutex);
    PciInitializeState((PPCI_COMMON_EXTENSION) FdoExtension);
}

VOID
PciGetHotPlugParameters(
    IN PPCI_FDO_EXTENSION Fdo
    )
/*++

Description:

    Runs the _HPP (described below) on the device and saves the parameters if available

    Method (_HPP, 0) {
        Return (Package(){
            0x00000008,     // CacheLineSize in DWORDS
            0x00000040,     // LatencyTimer in PCI clocks
            0x00000001,     // Enable SERR (Boolean)
            0x00000001      // Enable PERR (Boolean)
            })

Arguments:

    Fdo - The PDO extension for the bridge

Return Value:

    TRUE - if the parameters are available, FASLE otherwise

--*/
{
#ifndef HPPTESTING
    NTSTATUS status;
    ACPI_EVAL_INPUT_BUFFER input;
    PACPI_EVAL_OUTPUT_BUFFER output = NULL;
    ULONG count;
    PACPI_METHOD_ARGUMENT argument;
    ULONG outputSize = sizeof(ACPI_EVAL_OUTPUT_BUFFER) + sizeof(ACPI_METHOD_ARGUMENT) * PCI_HPP_PACKAGE_COUNT;

    PAGED_CODE();

    output = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, outputSize);

    if (!output) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    RtlZeroMemory(&input, sizeof(ACPI_EVAL_INPUT_BUFFER));
    RtlZeroMemory(output, outputSize);

    //
    // Send a IOCTL to ACPI to request it to run the _HPP method on this device
    // if the method it is present
    //

    input.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    input.MethodNameAsUlong = (ULONG)'PPH_';

    //
    // PciSendIoctl deals with sending this from the top of the stack.
    //

    status = PciSendIoctl(Fdo->PhysicalDeviceObject,
                          IOCTL_ACPI_EVAL_METHOD,
                          &input,
                          sizeof(ACPI_EVAL_INPUT_BUFFER),
                          output,
                          outputSize
                          );

    if (!NT_SUCCESS(status)) {
        //
        // Inherit them from my parent (If I have one)
        //

        if (!PCI_IS_ROOT_FDO(Fdo)) {
            RtlCopyMemory(&Fdo->HotPlugParameters,
                          &Fdo->ParentFdoExtension->HotPlugParameters,
                          sizeof(Fdo->HotPlugParameters)
                          );
        }
    
    } else {
    
        if (output->Count != PCI_HPP_PACKAGE_COUNT) {
            goto exit;
        }

        //
        // Check they are all integers and in the right bounds
        //

        for (count = 0; count < PCI_HPP_PACKAGE_COUNT; count++) {
            ULONG current;

            if (output->Argument[count].Type != ACPI_METHOD_ARGUMENT_INTEGER) {
                goto exit;
            }

            current = output->Argument[count].Argument;
            switch (count) {
            case PCI_HPP_CACHE_LINE_SIZE_INDEX:
            case PCI_HPP_LATENCY_TIMER_INDEX:
                //
                // These registers are only a UCHAR in length
                //
                if (current > 0xFF) {
                    goto exit;
                }
                break;
            case PCI_HPP_ENABLE_SERR_INDEX:
            case PCI_HPP_ENABLE_PERR_INDEX:
                //
                // These are booleans - 1 or 0
                //
                if (current > 1) {
                    goto exit;
                }
                break;
            }
        }
    
        //
        // Finally save them and remember we got them.
        //
    
        Fdo->HotPlugParameters.CacheLineSize = (UCHAR)output->Argument[PCI_HPP_CACHE_LINE_SIZE_INDEX].Argument;
        Fdo->HotPlugParameters.LatencyTimer = (UCHAR)output->Argument[PCI_HPP_LATENCY_TIMER_INDEX].Argument;
        Fdo->HotPlugParameters.EnableSERR = (BOOLEAN)output->Argument[PCI_HPP_ENABLE_SERR_INDEX].Argument;
        Fdo->HotPlugParameters.EnablePERR = (BOOLEAN)output->Argument[PCI_HPP_ENABLE_PERR_INDEX].Argument;
        Fdo->HotPlugParameters.Acquired = TRUE;
    }

exit:

    if (output) {
        ExFreePool(output);
    }

#else
    Fdo->HotPlugParameters.CacheLineSize = 0x8;
    Fdo->HotPlugParameters.LatencyTimer = 0x20;
    Fdo->HotPlugParameters.EnableSERR = 0;
    Fdo->HotPlugParameters.EnablePERR = 0;
    Fdo->HotPlugParameters.Acquired = TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\intrface.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    interface.c

Abstract:

    IRP_MN_QUERY_INTERFACE lives here.

Author:

    Peter Johnston (peterj)  31-Mar-1997

Revision History:

--*/

#include "pcip.h"


NTSTATUS
PciGetBusStandardInterface(
    IN PDEVICE_OBJECT Pdo,
    OUT PBUS_INTERFACE_STANDARD BusInterface
    );

extern PCI_INTERFACE ArbiterInterfaceBusNumber;
extern PCI_INTERFACE ArbiterInterfaceMemory;
extern PCI_INTERFACE ArbiterInterfaceIo;
extern PCI_INTERFACE TranslatorInterfaceInterrupt;
extern PCI_INTERFACE TranslatorInterfaceMemory;
extern PCI_INTERFACE TranslatorInterfaceIo;
extern PCI_INTERFACE BusHandlerInterface;
extern PCI_INTERFACE PciRoutingInterface;
extern PCI_INTERFACE PciCardbusPrivateInterface;
extern PCI_INTERFACE PciLegacyDeviceDetectionInterface;
extern PCI_INTERFACE PciPmeInterface;
extern PCI_INTERFACE PciDevicePresentInterface;
extern PCI_INTERFACE PciNativeIdeInterface;

PPCI_INTERFACE PciInterfaces[] = {
    &ArbiterInterfaceBusNumber,
    &ArbiterInterfaceMemory,
    &ArbiterInterfaceIo,
    &BusHandlerInterface,
    &PciRoutingInterface,
    &PciCardbusPrivateInterface,
    &PciLegacyDeviceDetectionInterface,
    &PciPmeInterface,
    &PciDevicePresentInterface,
    &PciNativeIdeInterface,
    NULL
};

//
// These are the interfaces we supply only if nobody underneath
// us (the HAL) does.
//
PPCI_INTERFACE PciInterfacesLastResort[] = {
    &TranslatorInterfaceInterrupt,
    NULL
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciQueryInterface)
#pragma alloc_text(PAGE, PciGetBusStandardInterface)
#endif

NTSTATUS
PciGetBusStandardInterface(
    IN PDEVICE_OBJECT Pdo,
    OUT PBUS_INTERFACE_STANDARD BusInterface
    )
/*++

Routine Description:

    This routine gets the bus iterface standard information from the PDO.

Arguments:

    Pdo - Physical device object to query for this information.

    BusInterface - Supplies a pointer for the retrived information.

Return Value:

    NT status.

--*/
{
    KEVENT event;
    NTSTATUS status;
    PIRP irp;
    IO_STATUS_BLOCK ioStatusBlock;
    PIO_STACK_LOCATION irpStack;

    PciDebugPrint(
        PciDbgObnoxious,
        "PCI - PciGetBusStandardInterface entered.\n"
        );

    KeInitializeEvent( &event, NotificationEvent, FALSE );

    irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                        Pdo,
                                        NULL,
                                        0,
                                        NULL,
                                        &event,
                                        &ioStatusBlock );

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation( irp );
    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpStack->Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_BUS_INTERFACE_STANDARD;
    irpStack->Parameters.QueryInterface.Size = sizeof( BUS_INTERFACE_STANDARD );
    irpStack->Parameters.QueryInterface.Version = 1;
    irpStack->Parameters.QueryInterface.Interface = (PINTERFACE) BusInterface;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Initialize the status to error in case the ACPI driver decides not to
    // set it correctly.
    //

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;


    status = IoCallDriver( Pdo, irp );

    if (!NT_SUCCESS( status)) {
        PciDebugPrint(
            PciDbgVerbose,
            "PCI - PciGetBusStandardInterface IoCallDriver returned %08x.\n",
            status
            );

        return status;
    }

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
    }

    PciDebugPrint(
        PciDbgVerbose,
        "PCI - PciGetBusStandardInterface returning status %08x.\n",
        ioStatusBlock.Status
        );

    return ioStatusBlock.Status;

}


NTSTATUS
PciQueryInterface(
    IN PVOID DeviceExtension,
    IN PGUID InterfaceType,
    IN USHORT Size,
    IN USHORT Version,
    IN PVOID InterfaceSpecificData,
    IN OUT PINTERFACE InterfaceReturn,
    IN BOOLEAN LastChance
    )
{
    PPCI_INTERFACE *interfaceEntry;
    PPCI_INTERFACE interface;
    PPCI_INTERFACE *interfaceTable;
    BOOLEAN isPdo;
    ULONG index;
    NTSTATUS status;

#if DBG

    UNICODE_STRING guidString;

    status = RtlStringFromGUID(InterfaceType, &guidString);

    if (NT_SUCCESS(status)) {
        PciDebugPrint(
            PciDbgVerbose,
            "PCI - PciQueryInterface TYPE = %wZ\n",
            &guidString
            );
        RtlFreeUnicodeString(&guidString);

        PciDebugPrint(
            PciDbgObnoxious,
            "      Size = %d, Version = %d, InterfaceData = %x, LastChance = %s\n",
            Size,
            Version,
            InterfaceSpecificData,
            LastChance ? "TRUE" : "FALSE"
            );
    }

#endif

    isPdo = ((PPCI_PDO_EXTENSION)DeviceExtension)->ExtensionType
                == PciPdoExtensionType;

    //
    // Try to locate the requested interface in the PCI driver's set
    // of exported interfaces.
    //
    // Note - we do not allow last chance interfaces (ie mock translators) for
    // machines where we assign bus numbers
    //
    if (LastChance) {

        interfaceTable = PciInterfacesLastResort;
    } else {
        interfaceTable = PciInterfaces;
    }

    for (interfaceEntry = interfaceTable; *interfaceEntry; interfaceEntry++) {

        interface = *interfaceEntry;

#if 0
        status = RtlStringFromGUID(interface->InterfaceType, &guidString);
        if (NT_SUCCESS(status)) {
            PciDebugPrint(
                PciDbgVerbose,
                "PCI - PciQueryInterface looking at guid = %wZ\n",
                &guidString
                );
            RtlFreeUnicodeString(&guidString);
        }
#endif

        //
        // Check if this interface is allowed to be used from this
        // device object type.
        //

        if (isPdo) {

            if ((interface->Flags & PCIIF_PDO) == 0) {

                //
                // This interface cannot be used from a PDO.
                //
#if DBG
                status = RtlStringFromGUID(interface->InterfaceType, &guidString);
                if (NT_SUCCESS(status)) {
                    PciDebugPrint(
                        PciDbgVerbose,
                        "PCI - PciQueryInterface: guid = %wZ only for PDOs\n",
                        &guidString
                        );
                    RtlFreeUnicodeString(&guidString);
                }
#endif
                continue;

            }

        } else {

            //
            // Allowable from FDO?
            //

            if ((interface->Flags & PCIIF_FDO) == 0) {

                //
                // No.
                //
#if DBG
                status = RtlStringFromGUID(interface->InterfaceType, &guidString);
                if (NT_SUCCESS(status)) {
                    PciDebugPrint(
                        PciDbgVerbose,
                        "PCI - PciQueryInterface: guid = %wZ only for FDOs\n",
                        &guidString
                        );
                    RtlFreeUnicodeString(&guidString);
                }

#endif
                continue;

            }
            //
            // Allowable only at root?
            //
            if (interface->Flags & PCIIF_ROOT) {

                PPCI_FDO_EXTENSION FdoExtension = (PPCI_FDO_EXTENSION)DeviceExtension;

                if (!PCI_IS_ROOT_FDO(FdoExtension)) {

#if DBG
                    status = RtlStringFromGUID(interface->InterfaceType, &guidString);
                    if (NT_SUCCESS(status)) {
                        PciDebugPrint(
                            PciDbgVerbose,
                            "PCI - PciQueryInterface: guid = %wZ only for ROOT\n",
                            &guidString
                            );
                        RtlFreeUnicodeString(&guidString);
                    }
#endif
                    continue;

                }

            }

        }

#if DBG
        status = RtlStringFromGUID(interface->InterfaceType, &guidString);
        if (NT_SUCCESS(status)) {
            PciDebugPrint(
                PciDbgVerbose,
                "PCI - PciQueryInterface looking at guid = %wZ\n",
                &guidString
                );
            RtlFreeUnicodeString(&guidString);
        }
#endif

        //
        // Check for the appropriate GUID then verify version numbers
        // and size.
        //

        if ((PciCompareGuid(InterfaceType, interface->InterfaceType)) &&
            (Version >= interface->MinVersion)                        &&
            (Version <= interface->MaxVersion)                        &&
            (Size    >= interface->MinSize)                           ) {

            //
            // We have a possible hit.  Check to see if the interface
            // itself agrees.
            //
            status = interface->Constructor(
                DeviceExtension,
                interface,
                InterfaceSpecificData,
                Version,
                Size,
                InterfaceReturn
                );
            if (NT_SUCCESS(status)) {

                //
                // We found and allocated an interface, reference it
                // and get out of the loop.
                //

                InterfaceReturn->InterfaceReference(InterfaceReturn->Context);

                PciDebugPrint(
                    PciDbgObnoxious,
                    "PCI - PciQueryInterface returning SUCCESS\n"
                    );
                return status;
#if DBG
            } else {

                PciDebugPrint(
                    PciDbgVerbose,
                    "PCI - PciQueryInterface - Contructor %08lx = %08lx\n",
                    interface->Constructor,
                    status
                    );

#endif
            }

        }

    }

    //
    // Failed to find the requested interface.
    //
    PciDebugPrint(
        PciDbgObnoxious,
        "PCI - PciQueryInterface FAILED TO FIND INTERFACE\n"
        );
    return STATUS_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\ideintrf.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    ideintrf.c

Abstract:

    This module implements the "Pci Native Ide" interfaces supported
    by the PCI driver.

Author:

    Andrew Thornton (andrewth) 1-26-2001

Revision History:

--*/

#include "pcip.h"

VOID
nativeIde_RefDereference(
    IN PVOID Context
    );

NTSTATUS
nativeIde_Constructor(
    IN PVOID DeviceExtension,
    IN PVOID PciInterface,
    IN PVOID InterfaceSpecificData,
    IN USHORT Version,
    IN USHORT Size,
    OUT PINTERFACE InterfaceReturn
    );

NTSTATUS
nativeIde_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

VOID
nativeIde_InterruptControl(
    IN PVOID Context,
    IN BOOLEAN Enable
    );


//
// Define the Pci Routing interface "Interface" structure.
//

PCI_INTERFACE PciNativeIdeInterface = {
    &GUID_PCI_NATIVE_IDE_INTERFACE,         // InterfaceType
    sizeof(PCI_NATIVE_IDE_INTERFACE),       // MinSize
    PCI_NATIVE_IDE_INTERFACE_VERSION,       // MinVersion
    PCI_NATIVE_IDE_INTERFACE_VERSION,       // MaxVersion
    PCIIF_PDO,                              // Flags
    0,                                      // ReferenceCount
    PciInterface_NativeIde,                 // Signature
    nativeIde_Constructor,                  // Constructor
    nativeIde_Initializer                   // Instance Initializer
};


VOID
nativeIde_RefDereference(
    IN PVOID Context
    )
{
    return;
}

NTSTATUS
nativeIde_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Initialize the PCI_NATIVE_IDE_INTERFACE fields.

Arguments:

    DeviceExtension - Extension of the device
    
    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    
    InterfaceSpecificData - from the QUERY_INTERFACE irp

    Version - Version of the interface requested
    
    Size - Size of the buffer 
    
    InterfaceReturn - Buffer to return the interface in

Return Value:

    Status

--*/

{
    PPCI_NATIVE_IDE_INTERFACE interface = (PPCI_NATIVE_IDE_INTERFACE)InterfaceReturn;
    PPCI_PDO_EXTENSION pdo = DeviceExtension;

    ASSERT_PCI_PDO_EXTENSION(pdo);

    if (!PCI_IS_NATIVE_CAPABLE_IDE_CONTROLLER(pdo)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    interface->Size = sizeof(PCI_NATIVE_IDE_INTERFACE);
    interface->Context = DeviceExtension;
    interface->Version = PCI_NATIVE_IDE_INTERFACE_VERSION;
    interface->InterfaceReference = nativeIde_RefDereference;
    interface->InterfaceDereference = nativeIde_RefDereference;

    interface->InterruptControl = nativeIde_InterruptControl;
    
    return STATUS_SUCCESS;
}

NTSTATUS
nativeIde_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )
/*++

Routine Description:

    For bus interface, does nothing, shouldn't actually be called.

Arguments:

    Instance        Pointer to the PDO extension.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERTMSG("PCI nativeide_Initializer, unexpected call.", 0);

    return STATUS_UNSUCCESSFUL;
}


VOID
nativeIde_InterruptControl(
    IN PVOID Context,
    IN BOOLEAN Enable
    )
/*++


Routine Description:

    Controls the enabling and disabling of native mode PCI IDE controllers
    IoSpaceEnable bits which on some controllers (currently Intel ICH3)
    will mask off interrupt generation and this prevent the system from 
    crashing...
    
Arguments:

    Context - Context from the PCI_NATIVE_IDE_INTERFACE
    
    Enable - If TRUE then set the IoSpaceEnable bit in the command register,
             otherwise disable it.


Return Value:

    None - if this operation fails we have aleady bugchecked in the PCI driver


    N.B. This function is called from with an ISR and this must be callable at
    DEVICE_LEVEL

--*/
{
    PPCI_PDO_EXTENSION pdo = Context;
    USHORT command;
    
    //
    // Remember we gave the IDE driver control of this
    //
    pdo->IoSpaceUnderNativeIdeControl = TRUE;

    PciReadDeviceConfig(pdo, 
                        &command, 
                        FIELD_OFFSET(PCI_COMMON_CONFIG, Command), 
                        sizeof(command)
                        );

    if (Enable) {
        command |= PCI_ENABLE_IO_SPACE;
        pdo->CommandEnables |= PCI_ENABLE_IO_SPACE;
    } else {
        command &= ~PCI_ENABLE_IO_SPACE;
        pdo->CommandEnables &= ~PCI_ENABLE_IO_SPACE; 
    }

    PciWriteDeviceConfig(pdo, 
                         &command, 
                         FIELD_OFFSET(PCI_COMMON_CONFIG, Command), 
                         sizeof(command)
                         );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\init.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the initialization code for PCI.SYS.

Author:

    Forrest Foltz (forrestf) 22-May-1996

Revision History:

--*/

#include "pcip.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
PciDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
PciBuildHackTable(
    IN HANDLE HackTableKey
    );

NTSTATUS
PciGetIrqRoutingTableFromRegistry(
    PPCI_IRQ_ROUTING_TABLE *RoutingTable
    );

NTSTATUS
PciGetDebugPorts(
    IN HANDLE ServiceHandle
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, PciBuildHackTable)
#pragma alloc_text(INIT, PciGetIrqRoutingTableFromRegistry)
#pragma alloc_text(INIT, PciGetDebugPorts)
#pragma alloc_text(PAGE, PciDriverUnload)
#endif

PDRIVER_OBJECT PciDriverObject;
BOOLEAN PciLockDeviceResources;
ULONG PciSystemWideHackFlags;
ULONG PciEnableNativeModeATA;

//
// List of FDOs created by this driver.
//

SINGLE_LIST_ENTRY PciFdoExtensionListHead;
LONG              PciRootBusCount;

//
// PciAssignBusNumbers - this flag indicates whether we should try to assign
// bus numbers to an unconfigured bridge.  It is set once we know if the enumerator
// of the PCI bus provides sufficient support.
//

BOOLEAN PciAssignBusNumbers = FALSE;

//
// This locks all PCI's global data structures
//

FAST_MUTEX        PciGlobalLock;

//
// This locks changes to bus numbers
//

FAST_MUTEX        PciBusLock;

//
// Table of hacks for broken hardware read from the registry at init.
// Protected by PciGlobalSpinLock and in none paged pool as it is needed at
// dispatch level
//

PPCI_HACK_TABLE_ENTRY PciHackTable = NULL;

// Will point to PCI IRQ Routing Table if one was found in the registry.
PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable = NULL;

//
// Debug ports we support
//
PCI_DEBUG_PORT PciDebugPorts[MAX_DEBUGGING_DEVICES_SUPPORTED];
ULONG PciDebugPortsCount;

#define PATH_CCS            L"\\Registry\\Machine\\System\\CurrentControlSet"

#define KEY_BIOS_INFO       L"Control\\BiosInfo\\PCI"
#define VALUE_PCI_LOCK      L"PCILock"

#define KEY_PNP_PCI         L"Control\\PnP\\PCI"
#define VALUE_PCI_HACKFLAGS L"HackFlags"
#define VALUE_ENABLE_NATA   L"EnableNativeModeATA"

#define KEY_CONTROL      L"Control"
#define VALUE_OSLOADOPT  L"SystemStartOptions"

#define KEY_MULTIFUNCTION L"\\Registry\\Machine\\HARDWARE\\DESCRIPTION\\System\\MultiFunctionAdapter"
#define KEY_IRQ_ROUTING_TABLE L"RealModeIrqRoutingTable\\0"
#define VALUE_IDENTIFIER L"Identifier"
#define VALUE_CONFIGURATION_DATA L"Configuration Data"
#define PCIIR_IDENTIFIER L"PCI BIOS"

#define HACKFMT_VENDORDEV         (sizeof(L"VVVVDDDD") - sizeof(UNICODE_NULL))
#define HACKFMT_VENDORDEVREVISION (sizeof(L"VVVVDDDDRR") - sizeof(UNICODE_NULL))
#define HACKFMT_SUBSYSTEM         (sizeof(L"VVVVDDDDSSSSssss") - sizeof(UNICODE_NULL))
#define HACKFMT_SUBSYSTEMREVISION (sizeof(L"VVVVDDDDSSSSssssRR") - sizeof(UNICODE_NULL))
#define HACKFMT_MAX_LENGTH        HACKFMT_SUBSYSTEMREVISION

#define HACKFMT_DEVICE_OFFSET     4
#define HACKFMT_SUBVENDOR_OFFSET  8
#define HACKFMT_SUBSYSTEM_OFFSET 12


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Entrypoint needed to initialize the PCI bus enumerator.

Arguments:

    DriverObject - Pointer to the driver object created by the system.
    RegistryPath - Pointer to the unicode registry service path.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    ULONG length;
    PWCHAR osLoadOptions;
    HANDLE ccsHandle = NULL, serviceKey = NULL, paramsKey = NULL, debugKey = NULL;
    PULONG registryValue;
    ULONG registryValueLength;
    OBJECT_ATTRIBUTES attributes;

    //
    // Fill in the driver object
    //

    DriverObject->MajorFunction[IRP_MJ_PNP]            = PciDispatchIrp;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = PciDispatchIrp;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PciDispatchIrp;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = PciDispatchIrp;

    DriverObject->DriverUnload                         = PciDriverUnload;
    DriverObject->DriverExtension->AddDevice           = PciAddDevice;

    PciDriverObject = DriverObject;

    //
    // Open our service key and retrieve the hack table
    //

    InitializeObjectAttributes(&attributes,
                               RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    status = ZwOpenKey(&serviceKey,
                       KEY_READ,
                       &attributes
                       );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get the Hack table from the registry
    //

    if (!PciOpenKey(L"Parameters", serviceKey, &paramsKey, &status)) {
        goto exit;
    }

    status = PciBuildHackTable(paramsKey);

    if (!NT_SUCCESS(status)) {
        goto exit;
    }

    //
    // Get any info about debugging ports from the registry so we don't perturb
    // them
    //

    if (PciOpenKey(L"Debug", serviceKey, &debugKey, &status)) {

        status = PciGetDebugPorts(debugKey);

        if (!NT_SUCCESS(status)) {
            goto exit;
        }

    }
    //
    // Initialize the list of FDO Extensions.
    //

    PciFdoExtensionListHead.Next = NULL;
    PciRootBusCount = 0;
    ExInitializeFastMutex(&PciGlobalLock);
    ExInitializeFastMutex(&PciBusLock);

    //
    // Need access to the CurrentControlSet for various
    // initialization chores.
    //

    if (!PciOpenKey(PATH_CCS, NULL, &ccsHandle, &status)) {
        goto exit;
    }

    //
    // Get OSLOADOPTIONS and see if PCILOCK was specified.
    // (Unless the driver is build to force PCILOCK).
    // (Note: Can't check for leading '/', it was stripped
    // before getting put in the registry).
    //

    PciLockDeviceResources = FALSE;

    if (NT_SUCCESS(PciGetRegistryValue(VALUE_OSLOADOPT,
                                       KEY_CONTROL,
                                       ccsHandle,
                                       &osLoadOptions,
                                       &length))) {

        //
        // Unfortunately, there isn't a wcsstrn (length limited
        // version of wcsstr).   If this is ever used more than
        // once, it should be moved to its own function in utils.c.
        //
        // Search for PCILOCK in the returned string.
        //

        ULONG  ln = length >> 1;
        PWCHAR cp = osLoadOptions;
        PWCHAR t = L"PCILOCK";
        PWCHAR s1, s2;
        ULONG  lt = wcslen(t);

        ASSERT(length < 0x10000);

        while (ln && *cp) {

            //
            // Can desired string exist in the remaining length?
            //

            if (ln < lt) {

                //
                // No, give up.
                //

                break;
            }

            s1 = cp;
            s2 = t;

            while (*s1 && *s2 && (*s1 == *s2)) {
                s1++, s2++;
            }

            if (!*s2) {

                //
                // Match!
                //

                PciLockDeviceResources = TRUE;
                break;
            }

            cp++, ln--;
        }

        ExFreePool(osLoadOptions);
    }

    if (!PciLockDeviceResources) {
        PULONG  pciLockValue;
        ULONG   pciLockLength;

        if (NT_SUCCESS(PciGetRegistryValue( VALUE_PCI_LOCK,
                                            KEY_BIOS_INFO,
                                            ccsHandle,
                                            &pciLockValue,
                                            &pciLockLength))) {

            if (pciLockLength == 4 && *pciLockValue == 1) {

                PciLockDeviceResources = TRUE;
            }

            ExFreePool(pciLockValue);
        }
    }

    PciSystemWideHackFlags = 0;

    if (NT_SUCCESS(PciGetRegistryValue( VALUE_PCI_HACKFLAGS,
                                        KEY_PNP_PCI,
                                        ccsHandle,
                                        &registryValue,
                                        &registryValueLength))) {

        if (registryValueLength == sizeof(ULONG)) {

            PciSystemWideHackFlags = *registryValue;
        }

        ExFreePool(registryValue);
    }

    PciEnableNativeModeATA = 0;

    if (NT_SUCCESS(PciGetRegistryValue( VALUE_ENABLE_NATA,
                                        KEY_PNP_PCI,
                                        ccsHandle,
                                        &registryValue,
                                        &registryValueLength))) {

        if (registryValueLength == sizeof(ULONG)) {

            PciEnableNativeModeATA = *registryValue;
        }

        ExFreePool(registryValue);
    }

    //
    // Build some global data structures
    //

    status = PciBuildDefaultExclusionLists();

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // If we don't find an IRQ routing table, no UI number information
    // will be returned for the PDOs using this mechanism.  ACPI may
    // still filter in UI numbers.
    //
    PciGetIrqRoutingTableFromRegistry(&PciIrqRoutingTable);

    //
    // Override the functions that used to be in the HAL but are now in the
    // PCI driver
    //

    PciHookHal();

    //
    // Enable the hardware verifier code if appropriate.
    //
    PciVerifierInit(DriverObject);

    status = STATUS_SUCCESS;

exit:

    if (ccsHandle) {
        ZwClose(ccsHandle);
    }

    if (serviceKey) {
        ZwClose(serviceKey);
    }

    if (paramsKey) {
        ZwClose(paramsKey);
    }

    if (debugKey) {
        ZwClose(debugKey);
    }

    return status;
}
VOID
PciDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Entrypoint used to unload the PCI driver.   Does nothing, the
    PCI driver is never unloaded.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

Return Value:

    None.

--*/

{
    //
    // Disable the hardware verifier code if appropriate.
    //
    PciVerifierUnload(DriverObject);

    //
    // Unallocate anything we can find.
    //

    RtlFreeRangeList(&PciIsaBitExclusionList);
    RtlFreeRangeList(&PciVgaAndIsaBitExclusionList);

    //
    // Free IRQ routing table if we have one
    //

    if (PciIrqRoutingTable != NULL) {
        ExFreePool(PciIrqRoutingTable);
    }

    //
    // Attempt to remove our hooks in case we actually get unloaded.
    //

    PciUnhookHal();
}


NTSTATUS
PciBuildHackTable(
    IN HANDLE HackTableKey
    )
{

    NTSTATUS status;
    PKEY_FULL_INFORMATION keyInfo = NULL;
    ULONG hackCount, size, index;
    USHORT temp;
    PPCI_HACK_TABLE_ENTRY entry;
    ULONGLONG data;
    PKEY_VALUE_FULL_INFORMATION valueInfo = NULL;
    ULONG valueInfoSize = sizeof(KEY_VALUE_FULL_INFORMATION)
                          + HACKFMT_MAX_LENGTH +
                          + sizeof(ULONGLONG);

    //
    // Get the key info so we know how many hack values there are.
    // This does not change during system initialization.
    //

    status = ZwQueryKey(HackTableKey,
                        KeyFullInformation,
                        NULL,
                        0,
                        &size
                        );

    if (status != STATUS_BUFFER_TOO_SMALL) {
        ASSERT(!NT_SUCCESS(status));
        goto cleanup;
    }

    ASSERT(size > 0);

    keyInfo = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, size);

    if (!keyInfo) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    status = ZwQueryKey(HackTableKey,
                        KeyFullInformation,
                        keyInfo,
                        size,
                        &size
                        );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    hackCount = keyInfo->Values;

    ExFreePool(keyInfo);
    keyInfo = NULL;

    //
    // Allocate and initialize the hack table
    //

    PciHackTable = ExAllocatePool(NonPagedPool,
                                  (hackCount + 1) * sizeof(PCI_HACK_TABLE_ENTRY)
                                  );

    if (!PciHackTable) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }


    //
    // Allocate a valueInfo buffer big enough for the biggest valid
    // format and a ULONGLONG worth of data.
    //

    valueInfo = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, valueInfoSize);

    if (!valueInfo) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    entry = PciHackTable;

    for (index = 0; index < hackCount; index++) {

        status = ZwEnumerateValueKey(HackTableKey,
                                     index,
                                     KeyValueFullInformation,
                                     valueInfo,
                                     valueInfoSize,
                                     &size
                                     );

        if (!NT_SUCCESS(status)) {
            if (status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL) {
                //
                // All out data is of fixed length and the buffer is big enough
                // so this can't be for us.
                //

                continue;
            } else {
                goto cleanup;
            }
        }

        //
        // Get pointer to the data if its of the right type
        //

        if ((valueInfo->Type == REG_BINARY) &&
            (valueInfo->DataLength == sizeof(ULONGLONG))) {
            data = *(ULONGLONG UNALIGNED *)(((PUCHAR)valueInfo) + valueInfo->DataOffset);
        } else {
            //
            // We only deal in ULONGLONGs
            //

            continue;
        }

        //
        // Now see if the name is formatted like we expect it to be:
        // VVVVDDDD
        // VVVVDDDDRR
        // VVVVDDDDSSSSssss
        // VVVVDDDDSSSSssssRR

        if ((valueInfo->NameLength != HACKFMT_VENDORDEV) &&
            (valueInfo->NameLength != HACKFMT_VENDORDEVREVISION) &&
            (valueInfo->NameLength != HACKFMT_SUBSYSTEM) &&
            (valueInfo->NameLength != HACKFMT_SUBSYSTEMREVISION)) {

            //
            // This isn't ours
            //

            PciDebugPrint(
                PciDbgInformative,
                "Skipping hack entry with invalid length name\n"
                );

            continue;
        }


        //
        // This looks plausable - try to parse it and fill in a hack table
        // entry
        //

        RtlZeroMemory(entry, sizeof(PCI_HACK_TABLE_ENTRY));

        //
        // Look for DeviceID and VendorID (VVVVDDDD)
        //

        if (!PciStringToUSHORT(valueInfo->Name, &entry->VendorID)) {
            continue;
        }

        if (!PciStringToUSHORT(valueInfo->Name + HACKFMT_DEVICE_OFFSET,
                               &entry->DeviceID)) {
            continue;
        }


        //
        // Look for SubsystemVendorID/SubSystemID (SSSSssss)
        //

        if ((valueInfo->NameLength == HACKFMT_SUBSYSTEM) ||
            (valueInfo->NameLength == HACKFMT_SUBSYSTEMREVISION)) {

            if (!PciStringToUSHORT(valueInfo->Name + HACKFMT_SUBVENDOR_OFFSET,
                                   &entry->SubVendorID)) {
                continue;
            }

            if (!PciStringToUSHORT(valueInfo->Name + HACKFMT_SUBSYSTEM_OFFSET,
                                   &entry->SubSystemID)) {
                continue;
            }

            entry->Flags |= PCI_HACK_FLAG_SUBSYSTEM;
        }

        //
        // Look for RevisionID (RR)
        //

        if ((valueInfo->NameLength == HACKFMT_VENDORDEVREVISION) ||
            (valueInfo->NameLength == HACKFMT_SUBSYSTEMREVISION)) {
            if (PciStringToUSHORT(valueInfo->Name +
                                   (valueInfo->NameLength/sizeof(WCHAR) - 4), &temp)) {
                entry->RevisionID = temp & 0xFF;
                entry->Flags |= PCI_HACK_FLAG_REVISION;
            } else {
                continue;
            }
        }

        ASSERT(entry->VendorID != 0xFFFF);

        //
        // Fill in the entry
        //

        entry->HackFlags = data;

        PciDebugPrint(
            PciDbgInformative,
            "Adding Hack entry for Vendor:0x%04x Device:0x%04x ",
            entry->VendorID, entry->DeviceID
            );

        if (entry->Flags & PCI_HACK_FLAG_SUBSYSTEM) {
            PciDebugPrint(
                PciDbgInformative,
                "SybSys:0x%04x SubVendor:0x%04x ",
                entry->SubSystemID, entry->SubVendorID
                );
        }

        if (entry->Flags & PCI_HACK_FLAG_REVISION) {
            PciDebugPrint(
                PciDbgInformative,
                "Revision:0x%02x",
                (ULONG) entry->RevisionID
                );
        }

        PciDebugPrint(
            PciDbgInformative,
            " = 0x%I64x\n",
            entry->HackFlags
            );

        entry++;
    }

    ASSERT(entry < (PciHackTable + hackCount + 1));

    //
    // Terminate the table with an invalid VendorID
    //

    entry->VendorID = 0xFFFF;

    ExFreePool(valueInfo);

    return STATUS_SUCCESS;

cleanup:

    ASSERT(!NT_SUCCESS(status));

    if (keyInfo) {
        ExFreePool(keyInfo);
    }

    if (valueInfo) {
        ExFreePool(valueInfo);
    }

    if (PciHackTable) {
        ExFreePool(PciHackTable);
        PciHackTable = NULL;
    }

    return status;

}

NTSTATUS
PciGetIrqRoutingTableFromRegistry(
    PPCI_IRQ_ROUTING_TABLE *RoutingTable
    )
/*++

Routine Description:

    Retrieve the IRQ routing table from the registry if present so it
    can be used to determine the UI Number (slot #) that will be used
    later when answering capabilities queries on the PDOs.

    Searches HKLM\Hardware\Description\System\MultiFunctionAdapter for
    a subkey with an "Identifier" value equal to "PCI BIOS".  It then looks at
    "RealModeIrqRoutingTable\0" from this subkey to find actual irq routing
    table value.  This value has a CM_FULL_RESOURCE_DESCRIPTOR in front of it.

    Hals that suppirt irq routing tables have a similar routine.

Arguments:

    RoutingTable - Pointer to a pointer to the routing table returned if any

Return Value:

    NTSTATUS - failure indicates inability to get irq routing table
    information from the registry.

--*/
{
    PUCHAR irqTable = NULL;
    PKEY_FULL_INFORMATION multiKeyInformation = NULL;
    PKEY_BASIC_INFORMATION keyInfo = NULL;
    PKEY_VALUE_PARTIAL_INFORMATION identifierValueInfo = NULL;
    UNICODE_STRING unicodeString;
    HANDLE keyMultifunction = NULL, keyTable = NULL;
    ULONG i, length, maxKeyLength, identifierValueLen;
    BOOLEAN result;
    NTSTATUS status;

    //
    // Open the multifunction key
    //
    result = PciOpenKey(KEY_MULTIFUNCTION,
                        NULL,
                        &keyMultifunction,
                        &status);
    if (!result) {
        goto Cleanup;
    }

    //
    // Do allocation of buffers up front
    //

    //
    // Determine maximum size of a keyname under the multifunction key
    //
    status = ZwQueryKey(keyMultifunction,
                        KeyFullInformation,
                        NULL,
                        sizeof(multiKeyInformation),
                        &length);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        goto Cleanup;
    }
    multiKeyInformation = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, length);
    if (multiKeyInformation == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    status = ZwQueryKey(keyMultifunction,
                        KeyFullInformation,
                        multiKeyInformation,
                        length,
                        &length);
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }
    // includes space for a terminating null that will be added later.
    maxKeyLength = multiKeyInformation->MaxNameLen +
        sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR);

    //
    // Allocate buffer used for storing subkeys that we are enumerated
    // under multifunction.
    //
    keyInfo = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, maxKeyLength);
    if (keyInfo == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Allocate buffer large enough to store a value containing REG_SZ
    // 'PCI BIOS'.  We hope to find such a value under one of the
    // multifunction subkeys
    //
    identifierValueLen = sizeof(PCIIR_IDENTIFIER) +
        sizeof(KEY_VALUE_PARTIAL_INFORMATION);
    identifierValueInfo = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, identifierValueLen);
    if (identifierValueInfo == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Enumerate subkeys of multifunction key looking for keys with an
    // Identifier value of "PCI BIOS".  If we find one, look for the
    // irq routing table in the tree below.
    //
    i = 0;
    do {
        status = ZwEnumerateKey(keyMultifunction,
                                i,
                                KeyBasicInformation,
                                keyInfo,
                                maxKeyLength,
                                &length);
        if (NT_SUCCESS(status)) {
            //
            // Found a key, now we need to open it and check the
            // 'Identifier' value to see if it is 'PCI BIOS'
            //
            keyInfo->Name[keyInfo->NameLength / sizeof(WCHAR)] = UNICODE_NULL;
            result = PciOpenKey(keyInfo->Name,
                                keyMultifunction,
                                &keyTable,
                                &status);
            if (result) {
                //
                // Checking 'Identifier' value to see if it contains 'PCI BIOS'
                //
                RtlInitUnicodeString(&unicodeString, VALUE_IDENTIFIER);
                status = ZwQueryValueKey(keyTable,
                                         &unicodeString,
                                         KeyValuePartialInformation,
                                         identifierValueInfo,
                                         identifierValueLen,
                                         &length);
                if (NT_SUCCESS(status) &&
                    RtlEqualMemory((PCHAR)identifierValueInfo->Data,
                                   PCIIR_IDENTIFIER,
                                   identifierValueInfo->DataLength))
                {
                    //
                    // This is the PCI BIOS key.  Try to get PCI IRQ
                    // routing table.  This is the key we were looking
                    // for so regardless of succss, break out.
                    //

                    status = PciGetRegistryValue(VALUE_CONFIGURATION_DATA,
                                                 KEY_IRQ_ROUTING_TABLE,
                                                 keyTable,
                                                 &irqTable,
                                                 &length);
                    ZwClose(keyTable);
                    break;
                }
                ZwClose(keyTable);
            }
        } else {
            //
            // If not NT_SUCCESS, only alowable value is
            // STATUS_NO_MORE_ENTRIES,... otherwise, someone
            // is playing with the keys as we enumerate
            //
            ASSERT(status == STATUS_NO_MORE_ENTRIES);
            break;
        }
        i++;
    }
    while (status != STATUS_NO_MORE_ENTRIES);

    if (NT_SUCCESS(status) && irqTable) {

        //
        // The routing table is stored as a resource and thus we need
        // to trim off the CM_FULL_RESOURCE_DESCRIPTOR that
        // lives in front of the actual table.
        //

        //
        // Perform sanity checks on the table.
        //

        if (length < (sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
                      sizeof(PCI_IRQ_ROUTING_TABLE))) {
            ExFreePool(irqTable);
            status = STATUS_UNSUCCESSFUL;
            goto Cleanup;
        }

        length -= sizeof(CM_FULL_RESOURCE_DESCRIPTOR);

        if (((PPCI_IRQ_ROUTING_TABLE) (irqTable + sizeof(CM_FULL_RESOURCE_DESCRIPTOR)))->TableSize > length) {
            ExFreePool(irqTable);
            status = STATUS_UNSUCCESSFUL;
            goto Cleanup;
        }

        //
        // Create a new table minus the header.
        //
        *RoutingTable = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, length);
        if (*RoutingTable) {

            RtlMoveMemory(*RoutingTable,
                          ((PUCHAR) irqTable) + sizeof(CM_FULL_RESOURCE_DESCRIPTOR),
                          length);
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
        ExFreePool(irqTable);
    }

 Cleanup:
    if (identifierValueInfo != NULL) {
        ExFreePool(identifierValueInfo);
    }

    if (keyInfo != NULL) {
        ExFreePool(keyInfo);
    }

    if (multiKeyInformation != NULL) {
        ExFreePool(multiKeyInformation);
    }

    if (keyMultifunction != NULL) {
        ZwClose(keyMultifunction);
    }

    return status;
}

NTSTATUS
PciGetDebugPorts(
    IN HANDLE ServiceHandle
    )
/*++

Routine Description:

    Looks in the PCI service key for debug port info and puts in into
    the PciDebugPorts global table.

Arguments:

    ServiceHandle - handle to the PCI service key passed into DriverEntry
Return Value:

    Status

--*/

{
    NTSTATUS status;
    ULONG index;
    WCHAR indexString[4];
    PULONG buffer = NULL;
    ULONG segment, bus, device, function, length;

    for (index = 0; index < MAX_DEBUGGING_DEVICES_SUPPORTED; index++) {

        _snwprintf(indexString, sizeof(indexString)/sizeof(WCHAR), L"%d", index);

        status = PciGetRegistryValue(L"Bus",
                                     indexString,
                                     ServiceHandle,
                                     &buffer,
                                     &length
                                     );

        if (!NT_SUCCESS(status)) {
            continue;
        }

        //
        // This is formatted as 31:8 Segment Number, 7:0 Bus Number
        //

        segment = (*buffer & 0xFFFFFF00) >> 8;
        bus = *buffer & 0x000000FF;

        ExFreePool(buffer);
        buffer = NULL;

        status = PciGetRegistryValue(L"Slot",
                                     indexString,
                                     ServiceHandle,
                                     &buffer,
                                     &length
                                     );


        if (!NT_SUCCESS(status)) {
            goto exit;
        }

        //
        // This is formatted as 7:5 Function Number, 4:0 Device Number
        //

        device = *buffer & 0x0000001F;
        function = (*buffer & 0x000000E0) >> 5;

        ExFreePool(buffer);
        buffer = NULL;


        PciDebugPrint(PciDbgInformative,
                      "Debug device @ Segment %x, %x.%x.%x\n",
                      segment,
                      bus,
                      device,
                      function
                      );
        //
        // We don't currently handle segment numbers for config space...
        //

        ASSERT(segment == 0);

        PciDebugPorts[index].Bus = bus;
        PciDebugPorts[index].Slot.u.bits.DeviceNumber = device;
        PciDebugPorts[index].Slot.u.bits.FunctionNumber = function;

        //
        // Remember we are using the debug port
        //
        PciDebugPortsCount++;

    }

    status = STATUS_SUCCESS;

exit:

    if (buffer) {
        ExFreePool(buffer);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\lddintrf.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    lddintrf.c

Abstract:

    This module implements the "legacy device detection" interface
    supported by the PCI driver.

Author:

    Dave Richards (daveri)  2-Oct-1998

Revision History:

--*/

#include "pcip.h"

#define LDDINTRF_VERSION 0

//
// Prototypes for routines exposed only through the "interface"
// mechanism.
//

NTSTATUS
lddintrf_Constructor(
    IN PVOID DeviceExtension,
    IN PVOID PciInterface,
    IN PVOID InterfaceSpecificData,
    IN USHORT Version,
    IN USHORT Size,
    IN PINTERFACE InterfaceReturn
    );

VOID
lddintrf_Reference(
    IN PVOID Context
    );

VOID
lddintrf_Dereference(
    IN PVOID Context
    );

NTSTATUS
lddintrf_Initializer(
    IN PVOID Instance
    );

NTSTATUS
PciLegacyDeviceDetection(
    IN PVOID Context,
    IN INTERFACE_TYPE LegacyBusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    OUT PDEVICE_OBJECT *PhysicalDeviceObject
    );

//
// Define the Legacy Device Detection "Interface" structure.
//

PCI_INTERFACE PciLegacyDeviceDetectionInterface = {
    &GUID_LEGACY_DEVICE_DETECTION_STANDARD, // InterfaceType
    sizeof(LEGACY_DEVICE_DETECTION_INTERFACE),
                                            // MinSize
    LDDINTRF_VERSION,                       // MinVersion
    LDDINTRF_VERSION,                       // MaxVersion
    PCIIF_FDO,                              // Flags
    0,                                      // ReferenceCount
    PciInterface_LegacyDeviceDetection,     // Signature
    lddintrf_Constructor,                   // Constructor
    lddintrf_Initializer                    // Instance Initializer
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, lddintrf_Constructor)
#pragma alloc_text(PAGE, lddintrf_Dereference)
#pragma alloc_text(PAGE, lddintrf_Initializer)
#pragma alloc_text(PAGE, lddintrf_Reference)
#pragma alloc_text(PAGE, PciLegacyDeviceDetection)
#endif

VOID
lddintrf_Reference(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine adds a reference to a legacy device detection interface.

Arguments:

    Instance - FDO extension pointer.

Return Value:

    None.

--*/
{
    PPCI_FDO_EXTENSION fdoExtension = (PPCI_FDO_EXTENSION)Context;

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);
}

VOID
lddintrf_Dereference(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine releases a reference to a legacy device detection interface.

Arguments:

    Instance - FDO extension pointer.

Return Value:

    None.

--*/
{
    PPCI_FDO_EXTENSION fdoExtension = (PPCI_FDO_EXTENSION)Context;

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);
}

NTSTATUS
lddintrf_Constructor(
    IN PVOID DeviceExtension,
    IN PVOID PciInterface,
    IN PVOID InterfaceSpecificData,
    IN USHORT Version,
    IN USHORT Size,
    IN PINTERFACE InterfaceReturn
    )
/*++

Routine Description:

    This routine constructs a LEGACY_DEVICE_DETECTION_INTERFACE.

Arguments:

    DeviceExtension - An FDO extenion pointer.

    PCIInterface - PciInterface_LegacyDeviceDetection.

    InterfaceSpecificData - Unused.

    Version - Interface version.

    Size - Size of the LEGACY_DEVICE_DETECTION interface object.

    InterfaceReturn - The interface object pointer.

Return Value:

    Returns NTSTATUS.

--*/
{
    PLEGACY_DEVICE_DETECTION_INTERFACE standard;

    standard = (PLEGACY_DEVICE_DETECTION_INTERFACE)InterfaceReturn;
    standard->Size = sizeof( LEGACY_DEVICE_DETECTION_INTERFACE );
    standard->Version = LDDINTRF_VERSION;
    standard->Context = DeviceExtension;
    standard->InterfaceReference = lddintrf_Reference;
    standard->InterfaceDereference = lddintrf_Dereference;
    standard->LegacyDeviceDetection = PciLegacyDeviceDetection;

    return STATUS_SUCCESS;
}

NTSTATUS
lddintrf_Initializer(
    IN PVOID Instance
    )
/*++

Routine Description:

    For legacy device detection does nothing, shouldn't actually be called.

Arguments:

    Instance - FDO extension pointer.

Return Value:

    Returns NTSTATUS.

--*/
{
    ASSERTMSG("PCI lddintrf_Initializer, unexpected call.", FALSE);

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
PciLegacyDeviceDetection(
    IN PVOID Context,
    IN INTERFACE_TYPE LegacyBusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    OUT PDEVICE_OBJECT *PhysicalDeviceObject
    )
/*++

Routine Description:

    This function searches for a legacy device, specified by LegacyBusType,
    BusNumber and SlotNumber, and returns a referenced physical device object
    as an output argument.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the FDO for the given bus.

    LegacyBusType - PCIBus.

    BusNumber - The legacy device's bus number.

    SlotNumber - The legacy device's slot number.

    PhysicalDeviceObject - The return argument i.e. a reference physical
        device object if the corresponding legacy device is found.

Return Value:

    Returns NTSTATUS.

--*/
{
    PCI_SLOT_NUMBER slotNumber;
    PPCI_FDO_EXTENSION fdoExtension;
    PPCI_PDO_EXTENSION pdoExtension;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    fdoExtension = (PPCI_FDO_EXTENSION)Context;

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    if (LegacyBusType != PCIBus) {
        return STATUS_UNSUCCESSFUL;
    }

    if (fdoExtension->BaseBus != BusNumber) {
        return STATUS_UNSUCCESSFUL;
    }

    slotNumber.u.AsULONG = SlotNumber;

    ExAcquireFastMutex(&fdoExtension->SecondaryExtMutex);

    for (pdoExtension = fdoExtension->ChildPdoList;
         pdoExtension != NULL;
         pdoExtension = pdoExtension->Next) {

        if (pdoExtension->Slot.u.bits.DeviceNumber == slotNumber.u.bits.DeviceNumber &&
            pdoExtension->Slot.u.bits.FunctionNumber == slotNumber.u.bits.FunctionNumber) {

            if (pdoExtension->DeviceState != PciNotStarted) {
                break;
            }

//          pdoExtension->DeviceState = PciLockedBecauseNotPnp;

            *PhysicalDeviceObject = pdoExtension->PhysicalDeviceObject;
            ObReferenceObject(pdoExtension->PhysicalDeviceObject);
            status = STATUS_SUCCESS;
            break;

        }

    }

    ExReleaseFastMutex(&fdoExtension->SecondaryExtMutex);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\hookhal.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    hookhal.c

Abstract:

    The module overrides the Hal functions that are now controlled by the
    PCI driver.

Author:

    Andrew Thornton (andrewth) 11-Sept-1998

Revision History:

--*/

#include "pcip.h"

pHalAssignSlotResources PcipSavedAssignSlotResources = NULL;
pHalTranslateBusAddress PcipSavedTranslateBusAddress = NULL;

BOOLEAN
PciTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

VOID
PciHookHal(
    VOID
    )
/*++

Routine Description:

    This is called when the PCI driver is loaded and it takes over the functions
    that have traditionally been in the HAL.

Arguments:

    None

Return Value:

    None

--*/

{

    ASSERT(PcipSavedAssignSlotResources == NULL);
    ASSERT(PcipSavedTranslateBusAddress == NULL);

    //
    // Override the handlers for AssignSlotResources and
    // TranslateBusAddress.  (But only modify the HAL dispatch
    // table once.)
    //

    PcipSavedAssignSlotResources = HALPDISPATCH->HalPciAssignSlotResources;
    HALPDISPATCH->HalPciAssignSlotResources = PciAssignSlotResources;
    PcipSavedTranslateBusAddress = HALPDISPATCH->HalPciTranslateBusAddress;
    HALPDISPATCH->HalPciTranslateBusAddress = PciTranslateBusAddress;
}

VOID
PciUnhookHal(
    VOID
    )

/*++

Routine Description:

    This reverses the changed made by PciHookHal.  It is called as part of
    unloading the PCI driver which seems like a really bad idea...

Arguments:

    None

Return Value:

    None

--*/

{

    ASSERT(PcipSavedAssignSlotResources != NULL);
    ASSERT(PcipSavedTranslateBusAddress != NULL);

    //
    // Override the handlers for AssignSlotResources and
    // TranslateBusAddress.  (But only modify the HAL dispatch
    // table once.)
    //

    HALPDISPATCH->HalPciAssignSlotResources = PcipSavedAssignSlotResources;
    HALPDISPATCH->HalPciTranslateBusAddress = PcipSavedTranslateBusAddress;

    PcipSavedAssignSlotResources = NULL;
    PcipSavedTranslateBusAddress = NULL;
}


PPCI_PDO_EXTENSION
PciFindPdoByLocation(
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER Slot
    )
/*++

Routine Description:


Arguments:

    BusNumber - the bus number of the bus the device is on
    Slot - the device/function of the device

Return Value:

    The PDO or NULL if one can not be found

--*/


{
    PSINGLE_LIST_ENTRY nextEntry;
    PPCI_FDO_EXTENSION fdoExtension;
    PPCI_PDO_EXTENSION pdoExtension = NULL;

    ExAcquireFastMutex(&PciGlobalLock);

    //
    // Find the bus FDO.
    //

    for ( nextEntry = PciFdoExtensionListHead.Next;
          nextEntry != NULL;
          nextEntry = nextEntry->Next ) {

        fdoExtension = CONTAINING_RECORD(nextEntry,
                                         PCI_FDO_EXTENSION,
                                         List);

        if (fdoExtension->BaseBus == BusNumber) {
            break;
        }
    }

    ExReleaseFastMutex(&PciGlobalLock);

    if (nextEntry == NULL) {

        //
        // This is bad.
        //

        PciDebugPrint(PciDbgAlways, "Pci: Could not find PCI bus FDO. Bus Number = 0x%x\n", BusNumber);
        goto cleanup;
    }

    //
    // Now find the pdo for the device in this slot
    //

    ExAcquireFastMutex(&fdoExtension->ChildListMutex);
    for (pdoExtension = fdoExtension->ChildPdoList;
         pdoExtension;
         pdoExtension = pdoExtension->Next) {

        //
        // People probably don't clear the unused bits in a PCI_SLOT_NUMBER so
        // ignore them in the main build but assert checked so we can get this
        // fixed
        //

        if (pdoExtension->Slot.u.bits.DeviceNumber == Slot.u.bits.DeviceNumber
        &&  pdoExtension->Slot.u.bits.FunctionNumber == Slot.u.bits.FunctionNumber) {

            ASSERT(pdoExtension->Slot.u.AsULONG == Slot.u.AsULONG);

            //
            // This is our guy!
            //

            break;
        }
    }
    ExReleaseFastMutex(&fdoExtension->ChildListMutex);

    if (pdoExtension == NULL) {

        //
        // This is bad.
        //

        PciDebugPrint(PciDbgAlways,
                      "Pci: Could not find PDO for device @ %x.%x.%x\n",
                      BusNumber,
                      Slot.u.bits.DeviceNumber,
                      Slot.u.bits.FunctionNumber
                      );

        goto cleanup;
    }

    return pdoExtension;

cleanup:

    return NULL;

}

NTSTATUS
PciAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    Slot,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    This subsumes the the functinality of HalAssignSlotResources for PCI devices.

    This function builds some bookkeeping information about legacy
    PCI device so that we know how to route interrupts for these
    PCI devices.  We build this here because this is the only place
    we see the legacy device object associated with proper bus, slot,
    function information.

Arguments:

    As HalAssignSlotResources

Return Value:

    STATUS_SUCCESS or error

--*/
{
    NTSTATUS status;
    PPCI_PDO_EXTENSION pdoExtension;
    PPCI_SLOT_NUMBER slotNumber = (PPCI_SLOT_NUMBER) &Slot;
    PCI_COMMON_HEADER buffer;
    PPCI_COMMON_CONFIG commonConfig = (PPCI_COMMON_CONFIG) &buffer;
    PIO_RESOURCE_REQUIREMENTS_LIST requirements = NULL;
    PCM_RESOURCE_LIST resources = NULL;
    ULONG readIndex, writeIndex;
    PCM_PARTIAL_RESOURCE_LIST partialList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptors;
    ULONG descriptorCount;
    PDEVICE_OBJECT  oldDO;

    PAGED_CODE();
    ASSERT(PcipSavedAssignSlotResources);
    ASSERT(BusType == PCIBus);

    *AllocatedResources = NULL;

    pdoExtension = PciFindPdoByLocation(BusNumber, *slotNumber);
    if (!pdoExtension) {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Grab the PciGlobalLock since we will modify the legacy cache.
    //

    ExAcquireFastMutex(&PciGlobalLock);

    //
    // Make sure that they didn't pass us in our PDO
    //

    ASSERT(DeviceObject != pdoExtension->PhysicalDeviceObject);

    PciReadDeviceConfig(
        pdoExtension,
        commonConfig,
        0,
        PCI_COMMON_HDR_LENGTH
        );

    //
    // Cache everything we have now learned about this
    // device object provided that they gave us one so that we can regurgitate
    // it when the IRQ arbiter needs to know.
    //
    //
    // NTRAID #62644 - 4/20/2000 - andrewth
    //
    // This should go away when we return the real PCI pdo
    // from IoReportDetectedDevice
    //

    status = PciCacheLegacyDeviceRouting(
            DeviceObject,
            BusNumber,
            Slot,
            commonConfig->u.type0.InterruptLine,
            commonConfig->u.type0.InterruptPin,
            commonConfig->BaseClass,
            commonConfig->SubClass,
            PCI_PARENT_FDOX(pdoExtension)->PhysicalDeviceObject,
            pdoExtension,
            &oldDO
            );
    if (!NT_SUCCESS(status)) {

        //
        // We failed to allocate memory while trying to cache this legacy DO.
        //

        goto ExitWithoutUpdatingCache;
    }

    //
    // Build a requirements list for this device
    //

    status = PciBuildRequirementsList(pdoExtension,
                                      commonConfig,
                                      &requirements
                                      );

    pdoExtension->LegacyDriver = TRUE;

    if (!NT_SUCCESS(status)) {
        goto ExitWithCacheRestoreOnFailure;
    }

    //
    // Call the legacy API to get the resources
    //

    status = IoAssignResources(RegistryPath,
                               DriverClassName,
                               DriverObject,
                               DeviceObject,
                               requirements,
                               &resources
                               );
    if (!NT_SUCCESS(status)) {
        ASSERT(resources == NULL);
        goto ExitWithCacheRestoreOnFailure;
    }

    //
    // Enable the decodes
    //

    pdoExtension->CommandEnables |= (PCI_ENABLE_IO_SPACE 
                                   | PCI_ENABLE_MEMORY_SPACE 
                                   | PCI_ENABLE_BUS_MASTER);

    //
    // Set up the extension
    //

    PciComputeNewCurrentSettings(pdoExtension,
                                 resources
                                 );
    //
    // Program the hardware
    //

    status = PciSetResources(pdoExtension,
                             TRUE, // power on
                             TRUE  // pretend its from a start irp
                             );

    if (!NT_SUCCESS(status)) {
        goto ExitWithCacheRestoreOnFailure;
    }

    //
    // Remove the device privates from the list - yes this means that we will
    // have allocated a little more pool than required.
    //

    ASSERT(resources->Count == 1);

    partialList = &resources->List[0].PartialResourceList;
    descriptorCount = resources->List[0].PartialResourceList.Count;
    descriptors = &resources->List[0].PartialResourceList.PartialDescriptors[0];

    readIndex = 0;
    writeIndex = 0;

    while (readIndex < descriptorCount) {
        if (descriptors[readIndex].Type != CmResourceTypeDevicePrivate) {

            if (writeIndex < readIndex) {

                //
                // Shuffle the descriptor up
                //

                RtlCopyMemory(&descriptors[writeIndex],
                              &descriptors[readIndex],
                              sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                              );
            }

            writeIndex++;

        } else {

            //
            // Skip the device private, don't increment writeCount so we will
            // overwrite it
            //

            ASSERT(partialList->Count > 0);
            partialList->Count--;

        }
        readIndex++;
    }

    ASSERT(partialList->Count > 0);

    *AllocatedResources = resources;
    resources = NULL;
    status = STATUS_SUCCESS;

ExitWithCacheRestoreOnFailure:
    //
    // On failure, restore the old legacy DO in our cache.
    //

    if (!NT_SUCCESS(status)) {

        PciCacheLegacyDeviceRouting(
        oldDO,
        BusNumber,
        Slot,
        commonConfig->u.type0.InterruptLine,
        commonConfig->u.type0.InterruptPin,
        commonConfig->BaseClass,
        commonConfig->SubClass,
        PCI_PARENT_FDOX(pdoExtension)->PhysicalDeviceObject,
        pdoExtension,
        NULL
        );

    }

ExitWithoutUpdatingCache:
    ExReleaseFastMutex(&PciGlobalLock);

    if (requirements) {
        ExFreePool(requirements);
    }

    if (resources) {
        ExFreePool(resources);
    }
    return status;

}


BOOLEAN
PciTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This subsumes the the functinality of HalTranslateBusAddress for PCI devices.

Arguments:

    As HalTranslateBusAddress

Return Value:

    TRUE if translation succeeded, FALSE otherwise.

--*/


{
    PPCI_FDO_EXTENSION fdoExtension;
    PSINGLE_LIST_ENTRY nextEntry;
    ULONG savedAddressSpace;
    PPCI_PDO_EXTENSION pdoExtension = NULL;
    BOOLEAN subtractive = FALSE, translatesOk = TRUE;
    PPCI_ARBITER_INSTANCE pciArbiter;
    PCI_SIGNATURE arbiterType;
    PARBITER_INSTANCE arbiter;
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE current;
    ULONGLONG address = (ULONGLONG) BusAddress.QuadPart;

    //
    // HalTranslateBusAddress can be called at high IRQL (the DDK says
    // <= DISPATCH_LEVEL) but crash dump seems to be at HIGH_LEVEL.  Either way
    // touching pageable data and code is a no no.  If we are calling at high
    // IRQL then just skip the validation that the range is on the bus as we are
    // crashing/hibernating at the time anyway...  We still need to call the
    // original hal function to perform the translation magic.
    //

    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {

        //
        // Find the FDO for this bus
        //

        ExAcquireFastMutex(&PciGlobalLock);

        for ( nextEntry = PciFdoExtensionListHead.Next;
              nextEntry != NULL;
              nextEntry = nextEntry->Next ) {

            fdoExtension = CONTAINING_RECORD(nextEntry,
                                             PCI_FDO_EXTENSION,
                                             List);

            if (fdoExtension->BaseBus == BusNumber) {
                break;
            }
        }

        if (nextEntry == NULL) {

            //
            // This is bad.
            //

            PciDebugPrint(PciDbgAlways, "Pci: Could not find PCI bus FDO. Bus Number = 0x%x\n", BusNumber);
            ExReleaseFastMutex(&PciGlobalLock);
            return FALSE;
        }


        for (;;) {

            if (!PCI_IS_ROOT_FDO(fdoExtension)) {

                pdoExtension = PCI_BRIDGE_PDO(fdoExtension);

                if (pdoExtension->Dependent.type1.SubtractiveDecode) {

                    //
                    // It is subtractive go up a level, rinse and repeat
                    //

                    fdoExtension = PCI_PARENT_FDOX(pdoExtension);
                    continue;
                }
            }
            break;
        }

        ExReleaseFastMutex(&PciGlobalLock);

        ASSERT(fdoExtension);

        //
        // Find the appropriate arbiter
        //

        switch (*AddressSpace) {
        case 0: // Memory space
        case 2: // UserMode view of memory space (Alpha)
        case 4: // Dense memory space (Alpha)
        case 6: // UserMode view of dense memory space (Alpha)
            arbiterType = PciArb_Memory;
            break;

        case 1: // Port space
        case 3: // UserMode view of port space (Alpha)
            arbiterType = PciArb_Io;
            break;

        default:

            ASSERT(FALSE);
            return FALSE;
        }

        pciArbiter = PciFindSecondaryExtension(fdoExtension,arbiterType);

        if (!pciArbiter) {
            ASSERT(FALSE);
            return FALSE;
        }

        arbiter = &pciArbiter->CommonInstance;

        //
        // Lock it
        //

        ArbAcquireArbiterLock(arbiter);

        //
        // If the range is not owned by NULL then it should translate
        //

        FOR_ALL_RANGES(arbiter->Allocation, &iterator, current) {

            if (address < current->Start) {
                //
                // We have passed all possible intersections
                //
                break;
            }

            if (INTERSECT(current->Start, current->End, address, address)
            &&  current->Owner == NULL) {

                //
                // This guy is not on our bus so he doesn't translate!
                //
                translatesOk = FALSE;
                break;
            }


        }

        ArbReleaseArbiterLock(arbiter);
    }

    //
    // Call the original HAL function to perform the translation magic
    //

    if (translatesOk) {

        savedAddressSpace = *AddressSpace;

        translatesOk = PcipSavedTranslateBusAddress(
                            InterfaceType,
                            BusNumber,
                            BusAddress,
                            AddressSpace,
                            TranslatedAddress
                            );

    }

#if defined(_X86_) && defined(PCI_NT50_BETA1_HACKS)

    if (!translatesOk) {

        //
        // HalTranslateBusAddress failed, figure out if we want to
        // pretend it succeeded.
        //

        //
        // GROSS HACK:  If we failed to translate in the range 0xa0000
        // thru 0xbffff on an X86 machine, just go ahead and allow it.
        // It is probably because the BIOS is buggy.
        //
        // Same for 0x400 thru 0x4ff
        //

        if (BusAddress.HighPart == 0) {

            ULONG lowPart = BusAddress.LowPart; // improve code generation

            if (((savedAddressSpace == ADDRESS_SPACE_MEMORY) &&
                    (((lowPart >= 0xa0000) &&     // HACK broken MPS BIOS
                      (lowPart <= 0xbffff)) ||    //
                     ((lowPart >= 0x400)   &&     // HACK MGA
                      (lowPart <= 0x4ff))   ||    //
                     (lowPart == 0x70)      )) || // HACK Trident
                 ((savedAddressSpace == ADDRESS_SPACE_PORT) &&
                     ((lowPart >= 0xcf8) &&       // HACK MGA
                      (lowPart <= 0xcff)))) {

                translatesOk = TRUE;
                *TranslatedAddress = BusAddress;
                *AddressSpace = savedAddressSpace;
            }
        }
    }

#endif

    return translatesOk;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\id.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    id.c

Abstract:

    This module contains functions used in the generation of responses
    to a IRP_MN_QUERY_ID IRP.

Author:

    Peter Johnston (peterj)  08-Mar-1997

Revision History:

--*/

#include "pcip.h"

//++
//
// PciQueryId returns UNICODE strings when the ID type is DeviceID
// or InstanceID.  For HardwareIDs and CompatibleIDs it returns a
// a zero terminated list of zero terminated UNICODE strings (MULTI_SZ).
//
// The normal process of converting a string to a unicode string involves
// taking it's length, allocating pool memory for the new string and
// calling RtlAnsiStringToUnicodeString to do the conversion.  The following
// is an attempt to be a little more efficient in terms of both size and
// speed by keeping track of the relevant string data as it goes past in
// the process of creating the set of strings.
//
//--

#define MAX_ANSI_STRINGS 8
#define MAX_ANSI_BUFFER  256

typedef struct _PCI_ID_BUFFER {
    ULONG       Count;                 // number of ansi strings
    ANSI_STRING AnsiStrings[MAX_ANSI_STRINGS];
    USHORT      UnicodeSZSize[MAX_ANSI_STRINGS];
    USHORT      UnicodeBufferSize;
    PUCHAR      NextFree;              // first unused byte in buffer
    UCHAR       Bytes[MAX_ANSI_BUFFER];// buffer start address
} PCI_ID_BUFFER, *PPCI_ID_BUFFER;

//
// All functins in this module are pageable.
//
// Define prototypes for module local functions.
//

VOID
PciIdPrintf(
    IN PPCI_ID_BUFFER IdBuffer,
    PCCHAR Format,
    ...
    );

VOID
PciIdPrintfAppend(
    IN PPCI_ID_BUFFER IdBuffer,
    PCCHAR Format,
    ...
    );

VOID
PciInitIdBuffer(
    IN PPCI_ID_BUFFER IdBuffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciGetDeviceDescriptionMessage)
#pragma alloc_text(PAGE, PciIdPrintf)
#pragma alloc_text(PAGE, PciIdPrintfAppend)
#pragma alloc_text(PAGE, PciInitIdBuffer)
#pragma alloc_text(PAGE, PciQueryId)
#pragma alloc_text(PAGE, PciQueryDeviceText)
#endif


VOID
PciInitIdBuffer(
    IN PPCI_ID_BUFFER IdBuffer
    )
{
    IdBuffer->NextFree          = IdBuffer->Bytes;
    IdBuffer->UnicodeBufferSize = 0;
    IdBuffer->Count             = 0;
}

VOID
PciIdPrintf(
    IN PPCI_ID_BUFFER IdBuffer,
    PCCHAR Format,
    ...
    )
{
    LONG         length;
    ULONG        index;
    PUCHAR       buffer;
    LONG         maxLength;
    va_list      ap;
    PANSI_STRING ansiString;

    ASSERT(IdBuffer->Count < MAX_ANSI_STRINGS);

    //
    // Make my life easier, keep repeated values in locals.
    //

    index      = IdBuffer->Count;
    buffer     = IdBuffer->NextFree;
    maxLength  = MAX_ANSI_BUFFER - (LONG)(buffer - IdBuffer->Bytes);
    ansiString = &IdBuffer->AnsiStrings[index];

    //
    // Pass the format string and subsequent data into (effectively)
    // sprintf.
    //

    va_start(ap, Format);

    length = _vsnprintf(buffer, maxLength, Format, ap);

    va_end(ap);

    ASSERT(length < maxLength);

    //
    // RtlInitAnsiString without the strlen.
    //

    ansiString->Buffer = buffer;
    ansiString->Length = (USHORT)length;
    ansiString->MaximumLength = (USHORT)length;

    //
    // Get the length of this string in a unicode world and record it
    // for later when the whole set of strings gets converted (keep
    // the total size also).
    //

    IdBuffer->UnicodeSZSize[index] =
                            (USHORT)RtlAnsiStringToUnicodeSize(ansiString);
    IdBuffer->UnicodeBufferSize += IdBuffer->UnicodeSZSize[index];

    //
    // Bump buffer pointer for next iteration and the count.
    //

    IdBuffer->NextFree += length + 1;
    IdBuffer->Count++;
}

VOID
PciIdPrintfAppend(
    IN PPCI_ID_BUFFER IdBuffer,
    PCCHAR Format,
    ...
    )
{
    LONG         length;
    ULONG        index;
    PUCHAR       buffer;
    LONG         maxLength;
    va_list      ap;
    PANSI_STRING ansiString;

    ASSERT(IdBuffer->Count);

    //
    // Make my life easier, keep repeated values in locals.
    //

    index      = IdBuffer->Count - 1;
    buffer     = IdBuffer->NextFree - 1;
    maxLength  = MAX_ANSI_BUFFER - (LONG)(buffer - IdBuffer->Bytes);
    ansiString = &IdBuffer->AnsiStrings[index];

    //
    // Pass the format string and subsequent data into (effectively)
    // sprintf.
    //

    va_start(ap, Format);

    length = _vsnprintf(buffer, maxLength, Format, ap);

    va_end(ap);

    ASSERT(length < maxLength);

    //
    // Increase the ansi string length by the length of the new
    // portion of the string.
    //

    ansiString->Length += (USHORT)length;
    ansiString->MaximumLength += (USHORT)length;

    //
    // Get the length of this string in a unicode world and record it
    // for later when the whole set of strings gets converted (keep
    // the total size also).
    //

    IdBuffer->UnicodeSZSize[index] =
                            (USHORT)RtlAnsiStringToUnicodeSize(ansiString);
    IdBuffer->UnicodeBufferSize += IdBuffer->UnicodeSZSize[index];

    //
    // Bump buffer pointer for next iteration.
    //

    IdBuffer->NextFree += length;
}

NTSTATUS
PciQueryId(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
{
    PCI_ID_BUFFER  idBuffer;
    UCHAR          venDevString[sizeof("PCI\\VEN_vvvv&DEV_dddd")];
    NTSTATUS       status;
    UNICODE_STRING unicodeId;
    PVOID          unicodeBuffer;
    ULONG          i;
    ULONG          subsystem;
    PPCI_PDO_EXTENSION current;

    PAGED_CODE();

    *BusQueryId = NULL;

    //
    // In all the following we want PCI\VEN_vvvv&DEV_dddd.
    //

    sprintf(venDevString,
            "PCI\\VEN_%04X&DEV_%04X",
            PdoExtension->VendorId,
            PdoExtension->DeviceId);

    PciInitIdBuffer(&idBuffer);

    subsystem = (PdoExtension->SubsystemId << 16) |
                 PdoExtension->SubsystemVendorId;

    switch (IdType) {
    case BusQueryInstanceID:

        //
        // Caller wants an instance ID for this device.  The PCI
        // driver reports that it does NOT generate unique IDs for
        // devices so PnP Manager will prepend bus information.
        //
        // The instance ID is of the form-
        //
        //  AABBCCDDEEFF...XXYYZZ
        //
        // Where AA is the slot number (device/function) of the device
        // on the bus, BB, CC,... XX, YY, ZZ are the slot number of the
        // PCI-to-PCI bridges on their parent busses all the way up to
        // the root.   A device on the root bus will have only one entry,
        // AA.
        //

        current = PdoExtension;

        //
        // Initialize empty buffer.
        //

        PciIdPrintf(&idBuffer,"");

        for (;;) {
            
            PciIdPrintfAppend(&idBuffer,
                              "%02X",
                              PCI_DEVFUNC(current)
                              );

            if (PCI_PDO_ON_ROOT(current)) {
                break;
            }
            current = PCI_PARENT_PDO(current)->DeviceExtension;
        }
        break;

    case BusQueryHardwareIDs:
    case BusQueryDeviceID:

        //
        // Hardware and Compatible IDs are generated as specified
        // in the ACPI spec (section 6.1.2 in version 0.9).
        //
        // Hardware IDs are a list of identifiers of the form
        //
        //  PCI\VEN_vvvv&DEV_dddd&SUBSYS_ssssssss&REV_rr
        //  PCI\VEN_vvvv&DEV_dddd&SUBSYS_ssssssss
        //  PCI\VEN_vvvv&DEV_dddd&REV_rr
        //  PCI\VEN_vvvv&DEV_dddd
        //
        // Where vvvv is the Vendor ID from config space,
        //       dddd is the Device ID,
        //       ssssssss is the Subsystem ID/Subsystem Vendor ID, and
        //       rr   is the Revision ID.
        //
        // Device ID is the same as the first Hardware ID (ie most
        // specific of all possible IDs).
        //

        PciIdPrintf(&idBuffer,
                    "%s&SUBSYS_%08X&REV_%02X",
                    venDevString,
                    subsystem,
                    PdoExtension->RevisionId);

        if (IdType == BusQueryDeviceID) {
            break;
        }

        PciIdPrintf(&idBuffer,
                    "%s&SUBSYS_%08X",
                    venDevString,
                    subsystem);

        //
        // Fall thru.
        //

    case BusQueryCompatibleIDs:

        //
        // If the subsystem is non-zero, the second two are compatible
        // IDs, otherwise they are hardware IDs.
        //

        if (((subsystem == 0) && (IdType == BusQueryHardwareIDs)) ||
            ((subsystem != 0) && (IdType == BusQueryCompatibleIDs))) {

            PciIdPrintf(&idBuffer,
                        "%s&REV_%02X",
                        venDevString,
                        PdoExtension->RevisionId);

            //
            // Device ID is PCI\VEN_vvvv&DEV_dddd
            //

            PciIdPrintf(&idBuffer,
                        "%s",
                        venDevString);
        }

        if (IdType == BusQueryHardwareIDs) {

            //
            // The comment in the Memphis code says "Add
            // special Intel entry".  Odd that these entries
            // are absent from the spec.  They are added for
            // PIIX4 which has the same vendor and device IDs
            // for two different sub class codes.
            //
            // These two entries are
            //
            //  PCI\VEN_vvvv&DEV_dddd&CC_ccsspp
            //  PCI\VEN_vvvv&DEV_dddd&CC_ccss
            //
            // (See below for cc, ss and pp explanaitions).
            //

            PciIdPrintf(&idBuffer,
                        "%s&CC_%02X%02X%02X",
                        venDevString,
                        PdoExtension->BaseClass,
                        PdoExtension->SubClass,
                        PdoExtension->ProgIf);

            PciIdPrintf(&idBuffer,
                        "%s&CC_%02X%02X",
                        venDevString,
                        PdoExtension->BaseClass,
                        PdoExtension->SubClass);
        }

        if (IdType == BusQueryCompatibleIDs) {

            //
            // The Compatible IDs list, consists of the above plus
            //
            //  PCI\VEN_vvvv&CC_ccsspp
            //  PCI\VEN_vvvv&CC_ccss
            //  PCI\VEN_vvvv
            //  PCI\CC_ccsspp
            //  PCI\CC_ccss
            //
            // Where cc is the Class Code from config space,
            //       ss is the Sub-Class Code, and
            //       pp is the programming interface.
            //
            // WARNING: Revise the size of the buffer if you increase
            //          the above list.
            //

            PciIdPrintf(&idBuffer,
                        "PCI\\VEN_%04X&CC_%02X%02X%02X",
                        PdoExtension->VendorId,
                        PdoExtension->BaseClass,
                        PdoExtension->SubClass,
                        PdoExtension->ProgIf);

            PciIdPrintf(&idBuffer,
                        "PCI\\VEN_%04X&CC_%02X%02X",
                        PdoExtension->VendorId,
                        PdoExtension->BaseClass,
                        PdoExtension->SubClass);

            PciIdPrintf(&idBuffer,
                        "PCI\\VEN_%04X",
                        PdoExtension->VendorId);

            PciIdPrintf(&idBuffer,
                        "PCI\\CC_%02X%02X%02X",
                        PdoExtension->BaseClass,
                        PdoExtension->SubClass,
                        PdoExtension->ProgIf);

            PciIdPrintf(&idBuffer,
                        "PCI\\CC_%02X%02X",
                        PdoExtension->BaseClass,
                        PdoExtension->SubClass);

        }

        //
        // HardwareIDs and CompatibleIDs are MULTI_SZ, add a
        // NULL list to terminate it all.
        //

        PciIdPrintf(&idBuffer, "");

        break;

    default:

        PciDebugPrint(PciDbgVerbose,
                      "PciQueryId expected ID type = %d\n",
                      IdType);

        //ASSERT(0 && "Unexpected BUS_QUERY_ID_TYPE");
        return STATUS_NOT_SUPPORTED;
    }

    ASSERT(idBuffer.Count > 0);

    //
    // What we have is a (bunch of) ansi strings.  What we need is a
    // (bunch of) unicode strings.
    //

    unicodeBuffer = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, idBuffer.UnicodeBufferSize);

    if (unicodeBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build the (possibly MULTI_SZ) unicode string(s).
    //

    PciDebugPrint(PciDbgPrattling,
                  "PciQueryId(%d)\n",
                  IdType);

    unicodeId.Buffer = unicodeBuffer;
    unicodeId.MaximumLength = idBuffer.UnicodeBufferSize;

    for (i = 0; i < idBuffer.Count; i++) {
        PciDebugPrint(PciDbgPrattling,
                      "    <- \"%s\"\n",
                      idBuffer.AnsiStrings[i].Buffer);

        status = RtlAnsiStringToUnicodeString(&unicodeId,
                                              &idBuffer.AnsiStrings[i],
                                              FALSE);
        if (!NT_SUCCESS(status)) {
            ASSERT(NT_SUCCESS(status));
            ExFreePool(unicodeBuffer);
            return status;
        }

        //
        // Bump the base pointer and decrement the max length for the
        // next trip thru the loop.
        //

        (ULONG_PTR)unicodeId.Buffer += idBuffer.UnicodeSZSize[i];
        unicodeId.MaximumLength -= idBuffer.UnicodeSZSize[i];
    }

    *BusQueryId = unicodeBuffer;
    return status;
}

PWSTR
PciGetDescriptionMessage(
    IN ULONG MessageNumber
    )
{
    PWSTR description = NULL;
    NTSTATUS status;
    PMESSAGE_RESOURCE_ENTRY messageEntry;

    status = RtlFindMessage(PciDriverObject->DriverStart,
                            11,             // <-- I wonder what this is.
                            LANG_NEUTRAL,
                            MessageNumber,
                            &messageEntry);

    if (NT_SUCCESS(status)) {

        if (messageEntry->Flags & MESSAGE_RESOURCE_UNICODE) {

            //
            // Our caller wants a copy they can free, also we need to
            // strip the trailing CR/LF.  The Length field of the
            // message structure includes both the header and the
            // actual text.
            //
            // Note: The message resource entry length will always be a
            // multiple of 4 bytes in length.  The 2 byte null terminator
            // could be in either the last or second last WCHAR position.
            //

            ULONG textLength;

            textLength = messageEntry->Length -
                         FIELD_OFFSET(MESSAGE_RESOURCE_ENTRY, Text) -
                         2 * sizeof(WCHAR);

            description = (PWSTR)(messageEntry->Text);
            if (description[textLength / sizeof(WCHAR)] == 0) {
                textLength -= sizeof(WCHAR);
            }

            ASSERT((LONG)textLength > 1);
            ASSERT(description[textLength / sizeof(WCHAR)] == 0x000a);

            description = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, textLength);

            if (description) {

                //
                // Copy the text except for the CR/LF/NULL
                //

                textLength -= sizeof(WCHAR);
                RtlCopyMemory(description, messageEntry->Text, textLength);

                //
                // New NULL terminator.
                //

                description[textLength / sizeof(WCHAR)] = 0;
            }

        } else {

            //
            // RtlFindMessage returns a string?   Wierd.
            //

            ANSI_STRING    ansiDescription;
            UNICODE_STRING unicodeDescription;

            RtlInitAnsiString(&ansiDescription, messageEntry->Text);

            //
            // Strip CR/LF off the end of the string.
            //

            ansiDescription.Length -= 2;

            //
            // Turn it all into a unicode string so we can grab the buffer
            // and return that to our caller.
            //

            status = RtlAnsiStringToUnicodeString(
                         &unicodeDescription,
                         &ansiDescription,
                         TRUE
                         );

            description = unicodeDescription.Buffer;
        }
    }

    return description;
}

PWSTR
PciGetDeviceDescriptionMessage(
    IN UCHAR BaseClass,
    IN UCHAR SubClass
    )
{
    PWSTR deviceDescription = NULL;
    ULONG messageNumber;

    messageNumber = (BaseClass << 8) | SubClass;

    deviceDescription = PciGetDescriptionMessage(messageNumber);

    if (!deviceDescription) {

#define TEMP_DESCRIPTION L"PCI Device"
        deviceDescription = ExAllocatePool(PagedPool, sizeof(TEMP_DESCRIPTION));
        if (deviceDescription) {
            RtlCopyMemory(deviceDescription,
                          TEMP_DESCRIPTION,
                          sizeof(TEMP_DESCRIPTION));
        }
    }

    return deviceDescription;
}

NTSTATUS
PciQueryDeviceText(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN DEVICE_TEXT_TYPE TextType,
    IN LCID LocaleId,
    IN OUT PWSTR *DeviceText
    )
{
    PWSTR locationFormat;
    ULONG textLength;

    PAGED_CODE();

    switch (TextType) {
    case DeviceTextDescription:

        *DeviceText = PciGetDeviceDescriptionMessage(PdoExtension->BaseClass,
                                                     PdoExtension->SubClass);
        if (*DeviceText) {
            return STATUS_SUCCESS;
        }
        return STATUS_NOT_SUPPORTED;

    case DeviceTextLocationInformation:

        locationFormat = PciGetDescriptionMessage(PCI_LOCATION_TEXT);

        if (locationFormat) {

            // Compute max size for location information string
            textLength = wcslen(locationFormat) + 2 + 2 + 2 + 1;
            *DeviceText = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION,
                                         textLength * sizeof(WCHAR));
            if (*DeviceText) {
                swprintf(*DeviceText, locationFormat,
                         (ULONG) PdoExtension->ParentFdoExtension->BaseBus,
                         (ULONG) PdoExtension->Slot.u.bits.DeviceNumber,
                         (ULONG) PdoExtension->Slot.u.bits.FunctionNumber);
            }
            ExFreePool(locationFormat);

            if (*DeviceText) {
                return STATUS_SUCCESS;
            } else {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        // fall thru if we couldn't get format string

    default:
        return STATUS_NOT_SUPPORTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\pcip.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    pcip.h

Abstract:

    This module contains local definitions for PCI.SYS.

Author:

    Andrew Thornton (andrewth) 25-Jan-2000

Revision History:

--*/

#if !defined(_PCIP_H)
#define _PCIP_H

#define _NTDRIVER_
#define _NTSRV_
#define _NTDDK_

#include "stdio.h"

#define InitSafeBootMode TempSafeBootMode
#include "ntos.h"
#undef InitSafeBootMode

#include "pci.h"
#include "wdmguid.h"
#include "zwapi.h"
#include "pciirqmp.h"
#include "arbiter.h"
#include "acpiioct.h"
#include "pciintrf.h"
#include "pcicodes.h"
#include "pciverifier.h"

//
// regstr.h uses things of type WORD, which isn't around in kernel mode.
//

#define _IN_KERNEL_

#include "regstr.h"

//
// It seems that anything to do with the definitions of GUIDs is
// bogus.
//

typedef const GUID * PGUID;

#define PciCompareGuid(a,b)                                         \
    (RtlEqualMemory((PVOID)(a), (PVOID)(b), sizeof(GUID)))

//
// Internal constants.
//

#define PCI_CM_RESOURCE_VERSION     1
#define PCI_CM_RESOURCE_REVISION    1
#define PCI_MAX_CONFIG_TYPE (PCI_CARDBUS_BRIDGE_TYPE)

//
// Internal bug codes.
//

#define PCI_BUGCODE_TOO_MANY_CONFIG_GUESSES     0xdead0010

//
// Internal Controls
//

#define PCI_BOOT_CONFIG_PREFERRED           1
#define PCIIDE_HACKS                        1
#define PCI_NT50_BETA1_HACKS                1
#define PCI_DISABLE_LAST_CHANCE_INTERFACES  1
#define MSI_SUPPORTED                       0
#define PCI_NO_MOVE_MODEM_IN_TOSHIBA        1

//
// Systemwide hack flags. These flags are a bitmask that can be set to zero so
// as to eliminate support for the hack.
//
#define PCIFLAG_IGNORE_PREFETCHABLE_MEMORY_AT_ROOT_HACK     0x00000001

//
// Video Hacks
//

#define PCI_S3_HACKS                        1
#define PCI_CIRRUS_54XX_HACK                1


#define PCI_IS_ATI_M1(_PdoExtension)                \
    ((_PdoExtension)->VendorId == 0x1002            \
        && ((_PdoExtension)->DeviceId == 0x4C42     \
         || (_PdoExtension)->DeviceId == 0x4C44     \
         || (_PdoExtension)->DeviceId == 0x4C49     \
         || (_PdoExtension)->DeviceId == 0x4C4D     \
         || (_PdoExtension)->DeviceId == 0x4C4E     \
         || (_PdoExtension)->DeviceId == 0x4C50     \
         || (_PdoExtension)->DeviceId == 0x4C51     \
         || (_PdoExtension)->DeviceId == 0x4C52     \
         || (_PdoExtension)->DeviceId == 0x4C53))

#define INTEL_ICH_HACKS                     1

#if INTEL_ICH_HACKS

#define PCI_IS_INTEL_ICH(_PdoExtension)             \
   ((_PdoExtension)->VendorId == 0x8086             \
       && ((_PdoExtension)->DeviceId == 0x2418      \
        || (_PdoExtension)->DeviceId == 0x2428      \
        || (_PdoExtension)->DeviceId == 0x244E      \
        || (_PdoExtension)->DeviceId == 0x2448))

#else

#define PCI_IS_INTEL_ICH(_PdoExtension)     FALSE

#endif

//
// Translatable resources
//

#define ADDRESS_SPACE_MEMORY                0x0
#define ADDRESS_SPACE_PORT                  0x1
#define ADDRESS_SPACE_USER_MEMORY           0x2
#define ADDRESS_SPACE_USER_PORT             0x3
#define ADDRESS_SPACE_DENSE_MEMORY          0x4
#define ADDRESS_SPACE_USER_DENSE_MEMORY     0x6

//
// Add our tag signature
//

#ifdef ExAllocatePool

#undef ExAllocatePool

#endif

#define ExAllocatePool( t, s ) ExAllocatePoolWithTag( (t), (s), 'BicP' )

//
// Lock and Unlock
//

typedef struct _PCI_LOCK {
    KSPIN_LOCK  Atom;
    KIRQL       OldIrql;

#if DBG

    PUCHAR      File;
    ULONG       Line;

#endif

} PCI_LOCK, *PPCI_LOCK;

#if DBG

#define PCI_LOCK_OBJECT(x)                                          \
    (x)->Lock.File = __FILE__,                                      \
    (x)->Lock.Line = __LINE__,                                      \
    KeAcquireSpinLock(&(x)->Lock.Atom, &(x)->Lock.OldIrql)

#else

#define PCI_LOCK_OBJECT(x)                                          \
    KeAcquireSpinLock(&(x)->Lock.Atom, &(x)->Lock.OldIrql)

#endif
#define PCI_UNLOCK_OBJECT(x)                                        \
    KeReleaseSpinLock(&(x)->Lock.Atom, (x)->Lock.OldIrql)



#define PciAcquireGlobalLock()                                      \
    ExAcquireFastMutex(&PciGlobalLock)

#define PciReleaseGlobalLock()                                      \
    ExReleaseFastMutex(&PciGlobalLock)


//
// PCM_PARTIAL_RESOURCE_DESCRIPTOR
// PciFirstCmResource(
//     PCM_RESOURCE_LIST List
//     )
//
// Routine Description:
//
//   Returns the address of the first CM PARTIAL RESOURCE DESCRIPTOR
//   in the given CM RESOURCE LIST.
//

#define PciFirstCmResource(x)                                           \
    (x)->List[0].PartialResourceList.PartialDescriptors


//
// ULONG
// PciGetConfigurationType(
//     PPCI_COMMON_CONFIG x
//     )
//
// Routine Description:
//
//   Returns the configuration type subfield from the HeaderType
//   field in PCI Configuration Space.
//

#define PciGetConfigurationType(x) PCI_CONFIGURATION_TYPE(x)

//
// PPCI_FDO_EXTENSION
// PCI_PARENT_FDO(
//     PPCI_PDO_EXTENSION x
//     )
//
// Routine Description:
//
//   Returns a pointer to the FDO extension that created PDO x as a result
//   of enumeration.  That is, the FDO extension of the bus that owns this
//   device.
//

#define PCI_PARENT_FDOX(x) ((x)->ParentFdoExtension)


//
// PPCI_FDO_EXTENSION
// PCI_ROOT_FDOX(
//     PPCI_PDO_EXTENSION x
//     )
//
// Routine Description:
//
//   Returns a pointer to the FDO extension for the root bus (CPU-PCI Bridge)
//   that this device is situated under.
//

#define PCI_ROOT_FDOX(x) ((x)->ParentFdoExtension->BusRootFdoExtension)


//
// PDEVICE_OBJECT
// PCI_PARENT_PDO(
//     PPCI_PDO_EXTENSION x
//     )
//
// Routine Description:
//
//   Returns a pointer to the PDO for the parent bus.
//

#define PCI_PARENT_PDO(x) ((x)->ParentFdoExtension->PhysicalDeviceObject)

//
// PPCI_PDO_EXTENSION
// PCI_BRIDGE_PDO(
//     PPCI_FDO_EXTENSION x
//     )
//
// Routine Description:
//
//   Returns a pointer to the PDO for the bridge given its FDO
//

#define PCI_BRIDGE_PDO(x) ((PPCI_PDO_EXTENSION)((x)->PhysicalDeviceObject->DeviceExtension))



//
// PPCI_FDO_EXTENSION
// PCI_BRIDGE_FDO(
//     PPCI_PDO_EXTENSION x
//     )
//
// Routine Description:
//
//   Returns a pointer to the FDO for the bridge given its PDO
//

#define PCI_BRIDGE_FDO(x) ((PPCI_FDO_EXTENSION)((x)->BridgeFdoExtension))

//
// BOOLEAN
// PCI_IS_ROOT_FDO(
//     PPCI_FDO_EXTENSION x
//     )
//
// Routine Description:
//
//   Returns TRUE if x is an FDO for a PCI ROOT bus.
//

#define PCI_IS_ROOT_FDO(x) ((x) == (x)->BusRootFdoExtension)

//
// BOOLEAN
// PCI_PDO_ON_ROOT(
//     PPCI_PDO_EXTENSION x
//     )
//
// Routine Description:
//

#define PCI_PDO_ON_ROOT(x)  PCI_IS_ROOT_FDO(PCI_PARENT_FDOX(x))

//
// UCHAR
// PCI_DEVFUNC(
//     PPCI_PDO_EXTENSION x
//     )
//
// Routine Description:
//
//   Returns the 5 bit device number and 3 bit function number for this
//   device as a single 8 bit quantity.
//

#define PCI_DEVFUNC(x)    (((x)->Slot.u.bits.DeviceNumber << 3) | \
                          (x)->Slot.u.bits.FunctionNumber)

//
//
// VOID
// PciConstStringToUnicodeString(
//     OUT PUNICODE_STRING u,
//     IN  PCWSTR p
//     )
//
//
#define PciConstStringToUnicodeString(u, p)                                     \
    (u)->Length = ((u)->MaximumLength = sizeof((p))) - sizeof(WCHAR);   \
    (u)->Buffer = (p)

//
// Name of the volative key under the DeviceParameters key where data that needs
// to be persistent accross removes, but NOT reboots is stored
//
#define BIOS_CONFIG_KEY_NAME L"BiosConfig"


//
// Assert this is a device object created by PCI
//

#define ASSERT_PCI_DEVICE_OBJECT(_DeviceObject) \
    ASSERT((_DeviceObject)->DriverObject == PciDriverObject)

#define ASSERT_MUTEX_HELD(x)

//
// IRPs can be handled the following ways
//
typedef enum _PCI_DISPATCH_STYLE {

    IRP_COMPLETE, // Complete IRP, adjust status as neccessary
    IRP_DOWNWARD, // Dispatch on the way down, adjust status as neccessary
    IRP_UPWARD,   // Dispatch on the way up, adjust status as neccessary
    IRP_DISPATCH  // Dispatch downward, don't touch afterwards
} PCI_DISPATCH_STYLE;

//
// The following routines are dispatched to depending on header type.
//

typedef
VOID
(*PMASSAGEHEADERFORLIMITSDETERMINATION)(
    IN struct _PCI_CONFIGURABLE_OBJECT *This
    );

typedef
VOID
(*PSAVELIMITS)(
    IN struct _PCI_CONFIGURABLE_OBJECT *This
    );

typedef
VOID
(*PSAVECURRENTSETTINGS)(
    IN struct _PCI_CONFIGURABLE_OBJECT *This
    );

typedef
VOID
(*PRESTORECURRENT)(
    IN struct _PCI_CONFIGURABLE_OBJECT *This
    );

typedef
VOID
(*PCHANGERESOURCESETTINGS)(
    IN struct _PCI_PDO_EXTENSION * PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

typedef
VOID
(*PGETADDITIONALRESOURCEDESCRIPTORS)(
    IN struct _PCI_PDO_EXTENSION * PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig,
    IN PIO_RESOURCE_DESCRIPTOR Resource
    );

typedef
NTSTATUS
(*PRESETDEVICE)(
    IN struct _PCI_PDO_EXTENSION * PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

typedef struct {
    PMASSAGEHEADERFORLIMITSDETERMINATION    MassageHeaderForLimitsDetermination;
    PRESTORECURRENT                         RestoreCurrent;
    PSAVELIMITS                             SaveLimits;
    PSAVECURRENTSETTINGS                    SaveCurrentSettings;
    PCHANGERESOURCESETTINGS                 ChangeResourceSettings;
    PGETADDITIONALRESOURCEDESCRIPTORS       GetAdditionalResourceDescriptors;
    PRESETDEVICE                            ResetDevice;
} PCI_CONFIGURATOR, *PPCI_CONFIGURATOR;

//
// Internal structure definitions follow
//


typedef enum {
    PciBridgeIo = 0x10,
    PciBridgeMem,
    PciBridgePrefetch,
    PciBridgeMaxPassThru
} PCI_BRIDGE_PASSTHRU;

typedef enum {

    //
    // Device Object Extension Types
    //

    PciPdoExtensionType = 'icP0',
    PciFdoExtensionType,

    //
    // Arbitration Types.  (These are also secondary extensions).
    //

    PciArb_Io,
    PciArb_Memory,
    PciArb_Interrupt,
    PciArb_BusNumber,

    //
    // Translation Types.  (These are also secondary extensions).
    //

    PciTrans_Interrupt,

    //
    // Other exposed interfaces.
    //

    PciInterface_BusHandler,
    PciInterface_IntRouteHandler,
    PciInterface_PciCb,
    PciInterface_LegacyDeviceDetection,
    PciInterface_PmeHandler,
    PciInterface_DevicePresent,
    PciInterface_NativeIde

} PCI_SIGNATURE;

#define PCI_EXTENSIONTYPE_FDO PciFdoExtensionType
#define PCI_EXTENSIONTYPE_PDO PciPdoExtensionType

typedef enum {
    PciTypeUnknown,
    PciTypeHostBridge,
    PciTypePciBridge,
    PciTypeCardbusBridge,
    PciTypeDevice
} PCI_OBJECT_TYPE;

typedef enum {
    PciPrivateUndefined,
    PciPrivateBar,
    PciPrivateIsaBar,
    PciPrivateSkipList
} PCI_PRIVATE_RESOURCE_TYPES;

typedef
VOID
(*PSECONDARYEXTENSIONDESTRUCTOR)(
    IN PVOID Extension
    );

typedef struct {
    SINGLE_LIST_ENTRY               List;
    PCI_SIGNATURE                   ExtensionType;
    PSECONDARYEXTENSIONDESTRUCTOR   Destructor;
} PCI_SECONDARY_EXTENSION, *PPCI_SECONDARY_EXTENSION;

//
// Define a structure to contain current and limit settings
// for any (currently defined) PCI header type.
//
// Currently type 0 defines the greatest number of possible
// resources but we shall do it programmatically anyway.
//
// Type 0 and type 1 also have a ROM base address, additionally,
// type 1 has three ranges that aren't included in its address
// count but should be.
//

#define PCI_TYPE0_RANGE_COUNT   ((PCI_TYPE0_ADDRESSES) + 1)
#define PCI_TYPE1_RANGE_COUNT   ((PCI_TYPE1_ADDRESSES) + 4)
#define PCI_TYPE2_RANGE_COUNT   ((PCI_TYPE2_ADDRESSES) + 1)

#if PCI_TYPE0_RANGE_COUNT > PCI_TYPE1_RANGE_COUNT

    #if PCI_TYPE0_RANGE_COUNT > PCI_TYPE2_RANGE_COUNT

        #define PCI_MAX_RANGE_COUNT PCI_TYPE0_RANGE_COUNT

    #else

        #define PCI_MAX_RANGE_COUNT PCI_TYPE2_RANGE_COUNT

    #endif

#else

    #if PCI_TYPE1_RANGE_COUNT > PCI_TYPE2_RANGE_COUNT

        #define PCI_MAX_RANGE_COUNT PCI_TYPE1_RANGE_COUNT

    #else

        #define PCI_MAX_RANGE_COUNT PCI_TYPE2_RANGE_COUNT

    #endif

#endif


typedef union {
    struct {
        UCHAR Spare[4];
    } type0;

    struct {
        UCHAR   PrimaryBus;
        UCHAR   SecondaryBus;
        UCHAR   SubordinateBus;
        BOOLEAN SubtractiveDecode:1;
        BOOLEAN IsaBitSet:1;
        BOOLEAN VgaBitSet:1;
        BOOLEAN WeChangedBusNumbers:1;
        BOOLEAN IsaBitRequired:1;
    } type1;

    struct {
        UCHAR   PrimaryBus;
        UCHAR   SecondaryBus;
        UCHAR   SubordinateBus;
        BOOLEAN SubtractiveDecode:1;
        BOOLEAN IsaBitSet:1;
        BOOLEAN VgaBitSet:1;
        BOOLEAN WeChangedBusNumbers:1;
        BOOLEAN IsaBitRequired:1;
    } type2;

} PCI_HEADER_TYPE_DEPENDENT;

typedef struct {
    IO_RESOURCE_DESCRIPTOR          Limit[PCI_MAX_RANGE_COUNT];
    CM_PARTIAL_RESOURCE_DESCRIPTOR  Current[PCI_MAX_RANGE_COUNT];
} PCI_FUNCTION_RESOURCES, *PPCI_FUNCTION_RESOURCES;

//
// Indices for the PCI_FUNCTION_RESOURCES arrays for different header types
//

#define PCI_DEVICE_BAR_0            0
#define PCI_DEVICE_BAR_1            1
#define PCI_DEVICE_BAR_2            2
#define PCI_DEVICE_BAR_3            3
#define PCI_DEVICE_BAR_4            4
#define PCI_DEVICE_BAR_5            5
#define PCI_DEVICE_BAR_ROM          6

#define PCI_BRIDGE_BAR_0            0
#define PCI_BRIDGE_BAR_1            1
#define PCI_BRIDGE_IO_WINDOW        2
#define PCI_BRIDGE_MEMORY_WINDOW    3
#define PCI_BRIDGE_PREFETCH_WINDOW  4
#define PCI_BRIDGE_BAR_ROM          5

#define PCI_CARDBUS_SOCKET_BAR      0
#define PCI_CARDBUS_MEMORY_WINDOW_0 1
#define PCI_CARDBUS_MEMORY_WINDOW_1 2
#define PCI_CARDBUS_IO_WINDOW_0     3
#define PCI_CARDBUS_IO_WINDOW_1     4
#define PCI_CARDBUS_LEGACY_BAR      5 // Not used



typedef struct {
    ULONGLONG   Total;
    ULONG       Alignment;
} PCI_RESOURCE_ACCUMULATOR, *PPCI_RESOURCE_ACCUMULATOR;

typedef struct {

    SYSTEM_POWER_STATE  CurrentSystemState;
    DEVICE_POWER_STATE  CurrentDeviceState;
    SYSTEM_POWER_STATE  SystemWakeLevel;
    DEVICE_POWER_STATE  DeviceWakeLevel;
    DEVICE_POWER_STATE  SystemStateMapping[PowerSystemMaximum];

    PIRP                WaitWakeIrp;
    PDRIVER_CANCEL      SavedCancelRoutine;

    // device usage...
    LONG                Paging;
    LONG                Hibernate;
    LONG                CrashDump;

} PCI_POWER_STATE, *PPCI_POWER_STATE;

typedef struct _PCI_PDO_EXTENSION          *PPCI_PDO_EXTENSION;
typedef struct _PCI_FDO_EXTENSION          *PPCI_FDO_EXTENSION;
typedef struct _PCI_COMMON_EXTENSION   *PPCI_COMMON_EXTENSION;


//
// This is an Irp Dispatch Handler for PCI
//
typedef NTSTATUS (*PCI_MN_DISPATCH_FUNCTION) (
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

typedef struct _PCI_MN_DISPATCH_TABLE {

    PCI_DISPATCH_STYLE        DispatchStyle;
    PCI_MN_DISPATCH_FUNCTION  DispatchFunction;

} PCI_MN_DISPATCH_TABLE, *PPCI_MN_DISPATCH_TABLE;

//
// This is a table that contains everything neccessary to handle Power, PnP,
// and other IRPs.
//
typedef struct _PCI_MJ_DISPATCH_TABLE {

    ULONG                     PnpIrpMaximumMinorFunction;
    PPCI_MN_DISPATCH_TABLE    PnpIrpDispatchTable;
    ULONG                     PowerIrpMaximumMinorFunction;
    PPCI_MN_DISPATCH_TABLE    PowerIrpDispatchTable;
    PCI_DISPATCH_STYLE        SystemControlIrpDispatchStyle;
    PCI_MN_DISPATCH_FUNCTION  SystemControlIrpDispatchFunction;
    PCI_DISPATCH_STYLE        OtherIrpDispatchStyle;
    PCI_MN_DISPATCH_FUNCTION  OtherIrpDispatchFunction;

} PCI_MJ_DISPATCH_TABLE, *PPCI_MJ_DISPATCH_TABLE;

//
// Structure used for storing MSI routing info
// in the PDO extention.
//

typedef struct _PCI_MSI_INFO {
   ULONG_PTR MessageAddress;
   UCHAR CapabilityOffset;
   USHORT MessageData;
} PCI_MSI_INFO, *PPCI_MSI_INFO;

//
// This much must be common to both the PDO and FDO extensions.
//
typedef struct _PCI_COMMON_EXTENSION {
    PVOID                           Next;
    PCI_SIGNATURE                   ExtensionType;
    PPCI_MJ_DISPATCH_TABLE          IrpDispatchTable;
    UCHAR                           DeviceState;
    UCHAR                           TentativeNextState;
    FAST_MUTEX                      SecondaryExtMutex;
} PCI_COMMON_EXTENSION;

typedef struct _PCI_PDO_EXTENSION{
    PPCI_PDO_EXTENSION                  Next;
    PCI_SIGNATURE                   ExtensionType;
    PPCI_MJ_DISPATCH_TABLE          IrpDispatchTable;
    UCHAR                           DeviceState;
    UCHAR                           TentativeNextState;
    FAST_MUTEX                      SecondaryExtMutex;
    PCI_SLOT_NUMBER                 Slot;
    PDEVICE_OBJECT                  PhysicalDeviceObject;
    PPCI_FDO_EXTENSION                  ParentFdoExtension;
    SINGLE_LIST_ENTRY               SecondaryExtension;
    ULONG                           BusInterfaceReferenceCount;
    USHORT                          VendorId;
    USHORT                          DeviceId;
    USHORT                          SubsystemVendorId;
    USHORT                          SubsystemId;
    UCHAR                           RevisionId;
    UCHAR                           ProgIf;
    UCHAR                           SubClass;
    UCHAR                           BaseClass;
    UCHAR                           AdditionalResourceCount;
    UCHAR                           AdjustedInterruptLine;
    UCHAR                           InterruptPin;
    UCHAR                           RawInterruptLine;
    UCHAR                           CapabilitiesPtr;
    UCHAR                           SavedLatencyTimer;
    UCHAR                           SavedCacheLineSize;
    UCHAR                           HeaderType;

    BOOLEAN                         NotPresent;
    BOOLEAN                         ReportedMissing;
    BOOLEAN                         ExpectedWritebackFailure;
    BOOLEAN                         NoTouchPmeEnable;
    BOOLEAN                         LegacyDriver;
    BOOLEAN                         UpdateHardware;
    BOOLEAN                         MovedDevice;
    BOOLEAN                         DisablePowerDown;
    BOOLEAN                         NeedsHotPlugConfiguration;
    BOOLEAN                         SwitchedIDEToNativeMode;
    BOOLEAN                         BIOSAllowsIDESwitchToNativeMode; // NIDE method said it was OK
    BOOLEAN                         IoSpaceUnderNativeIdeControl;
    BOOLEAN                         OnDebugPath;    // Includes headless port

#if MSI_SUPPORTED
    BOOLEAN                         CapableMSI;
    PCI_MSI_INFO                    MsiInfo;
#endif // MSI_SUPPORTED

    PCI_POWER_STATE                 PowerState;

    PCI_HEADER_TYPE_DEPENDENT       Dependent;
    ULONGLONG                       HackFlags;
    PPCI_FUNCTION_RESOURCES         Resources;
    PPCI_FDO_EXTENSION              BridgeFdoExtension;
    PPCI_PDO_EXTENSION              NextBridge;
    PPCI_PDO_EXTENSION              NextHashEntry;
    PCI_LOCK                        Lock;
    PCI_PMC                         PowerCapabilities;
    USHORT                          CommandEnables; // What we want to enable for this device
    USHORT                          InitialCommand; // How we found the command register
} PCI_PDO_EXTENSION;

#define ASSERT_PCI_PDO_EXTENSION(x)                                     \
    ASSERT((x)->ExtensionType == PciPdoExtensionType);

typedef struct _PCI_FDO_EXTENSION{
    SINGLE_LIST_ENTRY      List;                  // List of pci.sys's FDOs
    PCI_SIGNATURE          ExtensionType;         // PciFdoExtensionType
    PPCI_MJ_DISPATCH_TABLE IrpDispatchTable;      // Irp Dispatch Table to use.
    UCHAR                  DeviceState;
    UCHAR                  TentativeNextState;
    FAST_MUTEX             SecondaryExtMutex;
    PDEVICE_OBJECT         PhysicalDeviceObject;  // PDO passed into AddDevice()
    PDEVICE_OBJECT         FunctionalDeviceObject;// FDO that points here
    PDEVICE_OBJECT         AttachedDeviceObject;  // next DO in chain.
    FAST_MUTEX             ChildListMutex;
    PPCI_PDO_EXTENSION     ChildPdoList;
    PPCI_FDO_EXTENSION     BusRootFdoExtension;   // points to top of this tree
    PPCI_FDO_EXTENSION     ParentFdoExtension;    // points to the parent bridge
    PPCI_PDO_EXTENSION     ChildBridgePdoList;
    PPCI_BUS_INTERFACE_STANDARD PciBusInterface;  // Only for a root
    UCHAR                 MaxSubordinateBus;      // Only for a root
    PBUS_HANDLER          BusHandler;
    UCHAR                 BaseBus;                // Bus number for THIS bus
    BOOLEAN               Fake;                   // True if not a real FDOx
    BOOLEAN               Scanned;                // True is bus enumerated
    BOOLEAN               ArbitersInitialized;
    BOOLEAN               BrokenVideoHackApplied;
    BOOLEAN               Hibernated;
    PCI_POWER_STATE       PowerState;
    SINGLE_LIST_ENTRY     SecondaryExtension;
    ULONG                 ChildWaitWakeCount;
#if INTEL_ICH_HACKS
    PPCI_COMMON_CONFIG    IchHackConfig;
#endif
    PCI_LOCK              Lock;

    //
    // Information from ACPI _HPP to apply to hot plugged cards,
    // Acquired indicates the rest are valid.
    //
    struct {
        BOOLEAN               Acquired;
        UCHAR                 CacheLineSize;
        UCHAR                 LatencyTimer;
        BOOLEAN               EnablePERR;
        BOOLEAN               EnableSERR;
    } HotPlugParameters;

    ULONG                 BusHackFlags;            // see PCI_BUS_HACK_*
} PCI_FDO_EXTENSION;


#define ASSERT_PCI_FDO_EXTENSION(x)                                     \
    ASSERT((x)->ExtensionType == PciFdoExtensionType);

typedef struct _PCI_CONFIGURABLE_OBJECT {
    PPCI_PDO_EXTENSION      PdoExtension;
    PPCI_COMMON_CONFIG  Current;
    PPCI_COMMON_CONFIG  Working;
    PPCI_CONFIGURATOR   Configurator;
    ULONG               PrivateData;
    USHORT              Status;
    USHORT              Command;
} PCI_CONFIGURABLE_OBJECT, *PPCI_CONFIGURABLE_OBJECT;

typedef struct _PCI_ASSIGNED_RESOURCE_EXTENSION {
    ULONG   ResourceIdentifier;
} PCI_ASSIGNED_RESOURCE_EXTENSION, *PPCI_ASSIGNED_RESOURCE_EXTENSION;

//
// The PCI_COMMON_CONFIG includes the 192 bytes of device specific
// data.  The following structure is used to get only the first 64
// bytes which is all we care about most of the time anyway.  We cast
// to PCI_COMMON_CONFIG to get at the actual fields.
//

typedef struct {
    ULONG Reserved[PCI_COMMON_HDR_LENGTH/sizeof(ULONG)];
} PCI_COMMON_HEADER, *PPCI_COMMON_HEADER;

//
// In order to be able to arbitrate interrupts for device with
// legacy drivers, we have to do some bookkeeping.
//

typedef struct {
    SINGLE_LIST_ENTRY List;
    PDEVICE_OBJECT LegacyDeviceObject;
    ULONG          Bus;
    ULONG          PciSlot;
    UCHAR          InterruptLine;
    UCHAR          InterruptPin;
    UCHAR          ClassCode;
    UCHAR          SubClassCode;
    PDEVICE_OBJECT ParentPdo;
    ROUTING_TOKEN  RoutingToken;
    PPCI_PDO_EXTENSION PdoExtension;
} LEGACY_DEVICE, *PLEGACY_DEVICE;

extern PLEGACY_DEVICE PciLegacyDeviceHead;


#define PCI_HACK_FLAG_SUBSYSTEM 0x01
#define PCI_HACK_FLAG_REVISION  0x02

typedef struct _PCI_HACK_TABLE_ENTRY {
    USHORT VendorID;
    USHORT DeviceID;
    USHORT SubVendorID;
    USHORT SubSystemID;
    ULONGLONG HackFlags;
    UCHAR   RevisionID;
    UCHAR   Flags;
} PCI_HACK_TABLE_ENTRY, *PPCI_HACK_TABLE_ENTRY;

typedef struct _ARBITER_MEMORY_EXTENSION {

    //
    // Indicates that this arbiter will arbitrate prefetchable memory
    //
    BOOLEAN PrefetchablePresent;

    //
    // Indicates that this arbiter has been initialized
    //
    BOOLEAN Initialized;

    //
    // The number of prefetchable ranges
    //
    USHORT PrefetchableCount;

    //
    // The allocation ordering list to be used for prefetchable memory
    //
    ARBITER_ORDERING_LIST PrefetchableOrdering;

    //
    // The allocation ordering list to be used for standard memory
    //
    ARBITER_ORDERING_LIST NonprefetchableOrdering;

    //
    // The original memory allocation ordering (from the registry)
    //
    ARBITER_ORDERING_LIST OriginalOrdering;

} ARBITER_MEMORY_EXTENSION, *PARBITER_MEMORY_EXTENSION;



NTSTATUS
PciCacheLegacyDeviceRouting(
    IN PDEVICE_OBJECT       LegacyDO,
    IN ULONG                Bus,
    IN ULONG                PciSlot,
    IN UCHAR                InterruptLine,
    IN UCHAR                InterruptPin,
    IN UCHAR                ClassCode,
    IN UCHAR                SubClassCode,
    IN PDEVICE_OBJECT       ParentPdo,
    IN PPCI_PDO_EXTENSION   PdoExtension,
    OUT PDEVICE_OBJECT      *OldLegacyDO
    );


//
// Global data declarations follow
//

extern PDRIVER_OBJECT           PciDriverObject;
extern UNICODE_STRING           PciServiceRegistryPath;
extern SINGLE_LIST_ENTRY        PciFdoExtensionListHead;
extern FAST_MUTEX               PciGlobalLock;
extern FAST_MUTEX               PciBusLock;
extern LONG                     PciRootBusCount;
extern BOOLEAN                  PciAssignBusNumbers;
extern PPCI_FDO_EXTENSION       PciRootExtensions;
extern RTL_RANGE_LIST           PciIsaBitExclusionList;
extern RTL_RANGE_LIST           PciVgaAndIsaBitExclusionList;
extern ULONG                    PciSystemWideHackFlags;
extern ULONG                    PciEnableNativeModeATA;
extern PPCI_HACK_TABLE_ENTRY    PciHackTable;

// arb_comn.h

#define PciWstrToUnicodeString(u, p)                                    \
                                                                        \
    (u)->Length = ((u)->MaximumLength = sizeof((p))) - sizeof(WCHAR);   \
    (u)->Buffer = (p)

#define INSTANCE_NAME_LENGTH 24

typedef struct _PCI_ARBITER_INSTANCE {

    //
    // Standard secondary extension header
    //

    PCI_SECONDARY_EXTENSION     Header;

    //
    // Back pointer to the interface we are a context of
    //

    struct _PCI_INTERFACE      *Interface;

    //
    // Pointer to owning device object (extension).
    //

    PPCI_FDO_EXTENSION              BusFdoExtension;

    //
    // Arbiter description.
    //

    WCHAR                       InstanceName[INSTANCE_NAME_LENGTH];

    //
    // The common instance data
    //

    ARBITER_INSTANCE            CommonInstance;

} PCI_ARBITER_INSTANCE, *PPCI_ARBITER_INSTANCE;



NTSTATUS
PciArbiterInitializeInterface(
    IN  PVOID DeviceExtension,
    IN  PCI_SIGNATURE DesiredInterface,
    IN OUT PARBITER_INTERFACE ArbiterInterface
    );

NTSTATUS
PciInitializeArbiterRanges(
    IN  PPCI_FDO_EXTENSION FdoExtension,
    IN  PCM_RESOURCE_LIST ResourceList
    );

NTSTATUS
PciInitializeArbiters(
    IN  PVOID DeviceExtension
    );

VOID
PciReferenceArbiter(
    IN PVOID Context
    );

VOID
PciDereferenceArbiter(
    IN PVOID Context
    );

VOID
ario_ApplyBrokenVideoHack(
    IN PPCI_FDO_EXTENSION FdoExtension
    );


//    busno.h

BOOLEAN
PciAreBusNumbersConfigured(
    IN PPCI_PDO_EXTENSION Bridge
    );


VOID
PciConfigureBusNumbers(
    PPCI_FDO_EXTENSION Parent
    );

VOID
PciSetBusNumbers(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN UCHAR Primary,
    IN UCHAR Secondary,
    IN UCHAR Subordinate
    );

//    cardbus.h

VOID
Cardbus_MassageHeaderForLimitsDetermination(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Cardbus_RestoreCurrent(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Cardbus_SaveLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Cardbus_SaveCurrentSettings(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Cardbus_ChangeResourceSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

VOID
Cardbus_GetAdditionalResourceDescriptors(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig,
    IN PIO_RESOURCE_DESCRIPTOR Resource
    );

NTSTATUS
Cardbus_ResetDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

//    config.h

VOID
PciReadDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

VOID
PciWriteDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

VOID
PciReadSlotConfig(
    IN PPCI_FDO_EXTENSION ParentFdo,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

VOID
PciWriteSlotConfig(
    IN PPCI_FDO_EXTENSION ParentFdo,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

UCHAR
PciGetAdjustedInterruptLine(
    IN PPCI_PDO_EXTENSION Pdo
    );

NTSTATUS
PciExternalReadDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
PciExternalWriteDeviceConfig(
    IN PPCI_PDO_EXTENSION Pdo,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
PciGetConfigHandlers(
    IN PPCI_FDO_EXTENSION FdoExtension
    );

//
// Macros to access common registers in config space
//

//
// VOID
// PciGetCommandRegister(
//      PPCI_PDO_EXTENSION _PdoExt,
//      PUSHORT _Command
//  );
//
#define PciGetCommandRegister(_PdoExt, _Command)                    \
    PciReadDeviceConfig((_PdoExt),                                  \
                        (_Command),                                 \
                        FIELD_OFFSET(PCI_COMMON_CONFIG, Command),   \
                        sizeof(USHORT)                              \
                        );

//
// VOID
// PciSetCommandRegister(
//      PPCI_PDO_EXTENSION _PdoExt,
//      USHORT _Command
//  );
//
#define PciSetCommandRegister(_PdoExt, _Command)                    \
    PciWriteDeviceConfig((_PdoExt),                                 \
                        &(_Command),                                \
                        FIELD_OFFSET(PCI_COMMON_CONFIG, Command),   \
                        sizeof(USHORT)                              \
                        );

//  BOOLEAN
//  BITS_SET(
//      IN  USHORT C
//      IN  USHORT F
//      )
//
#define BITS_SET(C,F) (((C) & (F)) == (F))

//
//  VOID
//  PciGetConfigData(
//      IN PPCI_PDO_EXTENSION PdoExtension,
//      OUT PPCI_COMMON_CONFIG PciConfig
//      )
//

#define PciGetConfigData(_PdoExtension, _PciConfig) \
    PciReadDeviceConfig((_PdoExtension),            \
                        (_PciConfig),               \
                        0,                          \
                        PCI_COMMON_HDR_LENGTH       \
                        );
//
//  VOID
//  PciSetConfigData(
//      IN PPCI_PDO_EXTENSION PdoExtension,
//      OUT PPCI_COMMON_CONFIG PciConfig
//      )
//

#define PciSetConfigData(_PdoExtension, _PciConfig) \
    PciWriteDeviceConfig((_PdoExtension),           \
                         (_PciConfig),              \
                         0,                         \
                         PCI_COMMON_HDR_LENGTH      \
                         );

//    debug.c

typedef enum {
    PciDbgAlways        = 0x00000000,   // unconditionally
    PciDbgInformative   = 0x00000001,
    PciDbgVerbose       = 0x00000003,
    PciDbgPrattling     = 0x00000007,

    PciDbgPnpIrpsFdo    = 0x00000100,   // PnP IRPs at FDO
    PciDbgPnpIrpsPdo    = 0x00000200,   // PnP IRPs at PDO
    PciDbgPoIrpsFdo     = 0x00000400,   // PO  IRPs at FDO
    PciDbgPoIrpsPdo     = 0x00000800,   // PO  IRPs at PDO

    PciDbgAddDevice     = 0x00001000,   // AddDevice info
    PciDbgAddDeviceRes  = 0x00002000,   // bus initial resource info

    PciDbgWaitWake      = 0x00008000,   // noisy debug for wait wake
    PciDbgQueryCap      = 0x00010000,   // Dump QueryCapabilities
    PciDbgCardBus       = 0x00020000,   // CardBus FDOish behavior
    PciDbgROM           = 0x00040000,   // access to device ROM
    PciDbgConfigParam   = 0x00080000,   // Setting config parameters

    PciDbgBusNumbers    = 0x00100000,   // checking and assigning bus numbers

    PciDbgResReqList    = 0x01000000,   // generated resource requirements
    PciDbgCmResList     = 0x02000000,   // generated CM Resource lists
    PciDbgSetResChange  = 0x04000000,   // SetResources iff changing
    PciDbgSetRes        = 0x08000000,   // SetResources


    PciDbgObnoxious     = 0x7fffffff    // anything
} PCI_DEBUG_LEVEL;

#if DBG

extern PCI_DEBUG_LEVEL PciDebug;

#define PCI_DEBUG_BUFFER_SIZE 256

#define PciDebugPrint   PciDebugPrintf

#else

#define PciDebugPrint   if(0)

#endif

VOID
PciDebugDumpCommonConfig(
    IN PPCI_COMMON_CONFIG CommonConfig
    );

VOID
PciDebugDumpQueryCapabilities(
    IN PDEVICE_CAPABILITIES C
    );

VOID
PciDebugHit(
    ULONG StopOnBit
    );

PUCHAR
PciDebugPnpIrpTypeToText(
    ULONG IrpMinorCode
    );

PUCHAR
PciDebugPoIrpTypeToText(
    ULONG IrpMinorCode
    );

VOID
PciDebugPrintf(
    PCI_DEBUG_LEVEL DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

VOID
PciDebugPrintCmResList(
    PCI_DEBUG_LEVEL DebugPrintLevel,
    IN PCM_RESOURCE_LIST ResourceList
    );

VOID
PciDebugPrintIoResource(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

VOID
PciDebugPrintIoResReqList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST List
    );

VOID
PciDebugPrintPartialResource(
    PCI_DEBUG_LEVEL DebugPrintLevel,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR D
    );


//    device.h

VOID
Device_MassageHeaderForLimitsDetermination(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Device_RestoreCurrent(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Device_SaveLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Device_SaveCurrentSettings(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
Device_ChangeResourceSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

VOID
Device_GetAdditionalResourceDescriptors(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig,
    IN PIO_RESOURCE_DESCRIPTOR Resource
    );

NTSTATUS
Device_ResetDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );


//    dispatch.h

//
// This is the dispatch table for normal PDO's.
//
extern PCI_MJ_DISPATCH_TABLE PciPdoDispatchTable;

NTSTATUS
PciDispatchIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );


NTSTATUS
PciPassIrpFromFdoToPdo(
    PPCI_COMMON_EXTENSION  DeviceExtension,
    PIRP                   Irp
    );

NTSTATUS
PciCallDownIrpStack(
    PPCI_COMMON_EXTENSION  DeviceExtension,
    PIRP                   Irp
    );

NTSTATUS
PciIrpNotSupported(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciIrpInvalidDeviceRequest(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

//    enum.h

PIO_RESOURCE_REQUIREMENTS_LIST
PciAllocateIoRequirementsList(
    IN ULONG ResourceCount,
    IN ULONG BusNumber,
    IN ULONG SlotNumber
    );

BOOLEAN
PciComputeNewCurrentSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PCM_RESOURCE_LIST ResourceList
    );

NTSTATUS
PciQueryDeviceRelations(
    IN PPCI_FDO_EXTENSION FdoExtension,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );

NTSTATUS
PciQueryRequirements(
    IN  PPCI_PDO_EXTENSION                  PdoExtension,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementsList
    );

NTSTATUS
PciQueryResources(
    IN PPCI_PDO_EXTENSION PdoExtension,
    OUT PCM_RESOURCE_LIST *ResourceList
    );

NTSTATUS
PciQueryTargetDeviceRelations(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN OUT PDEVICE_RELATIONS *PDeviceRelations
    );

NTSTATUS
PciQueryEjectionRelations(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN OUT PDEVICE_RELATIONS *PDeviceRelations
    );

NTSTATUS
PciScanHibernatedBus(
    IN PPCI_FDO_EXTENSION FdoExtension
    );

NTSTATUS
PciSetResources(
    IN PPCI_PDO_EXTENSION    PdoExtension,
    IN BOOLEAN           PowerOn,
    IN BOOLEAN           StartDeviceIrp
    );

BOOLEAN
PciIsSameDevice(
    IN PPCI_PDO_EXTENSION PdoExtension
    );

NTSTATUS
PciBuildRequirementsList(
    IN  PPCI_PDO_EXTENSION                 PdoExtension,
    IN  PPCI_COMMON_CONFIG             CurrentConfig,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *FinalReqList
    );


//    fdo.h


NTSTATUS
PciFdoIrpQueryDeviceRelations(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

VOID
PciInitializeFdoExtensionCommonFields(
    IN PPCI_FDO_EXTENSION  FdoExtension,
    IN PDEVICE_OBJECT  Fdo,
    IN PDEVICE_OBJECT  Pdo
    );


// hookhal.c

VOID
PciHookHal(
    VOID
    );

VOID
PciUnhookHal(
    VOID
    );

//    id.h

PWSTR
PciGetDeviceDescriptionMessage(
    IN UCHAR BaseClass,
    IN UCHAR SubClass
    );

NTSTATUS
PciQueryId(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
PciQueryDeviceText(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN DEVICE_TEXT_TYPE TextType,
    IN LCID LocaleId,
    IN OUT PWSTR *DeviceText
    );

//    interface.h

#define PCIIF_PDO       0x01        // Interface can be used by a PDO
#define PCIIF_FDO       0x02        // Interface can be used by an FDO
#define PCIIF_ROOT      0x04        // Interface can be used only at by the root.

typedef
NTSTATUS
(*PPCI_INTERFACE_CONSTRUCTOR)(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

typedef
NTSTATUS
(*PPCI_INTERFACE_INITIALIZER)(
    PPCI_ARBITER_INSTANCE Instance
    );

typedef struct _PCI_INTERFACE {
    PGUID                      InterfaceType;
    USHORT                     MinSize;
    USHORT                     MinVersion;
    USHORT                     MaxVersion;
    USHORT                     Flags;
    LONG                       ReferenceCount;
    PCI_SIGNATURE              Signature;
    PPCI_INTERFACE_CONSTRUCTOR Constructor;
    PPCI_INTERFACE_INITIALIZER Initializer;
} PCI_INTERFACE, *PPCI_INTERFACE;

NTSTATUS
PciQueryInterface(
    IN PVOID DeviceExtension,
    IN PGUID InterfaceType,
    IN USHORT Size,
    IN USHORT Version,
    IN PVOID InterfaceSpecificData,
    IN OUT PINTERFACE Interface,
    IN BOOLEAN LastChance
    );


extern PPCI_INTERFACE PciInterfaces[];

//    pdo.h

NTSTATUS
PciPdoCreate(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PCI_SLOT_NUMBER Slot,
    OUT PDEVICE_OBJECT *PhysicalDeviceObject
    );

VOID
PciPdoDestroy(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );


//  pmeintf.h

VOID
PciPmeAdjustPmeEnable(
    IN  PPCI_PDO_EXTENSION  PdoExtension,
    IN  BOOLEAN         Enable,
    IN  BOOLEAN         ClearStatusOnly
    );

VOID
PciPmeGetInformation(
    IN  PDEVICE_OBJECT  Pdo,
    OUT PBOOLEAN        PmeCapable,
    OUT PBOOLEAN        PmeStatus,
    OUT PBOOLEAN        PmeEnable
    );



//  power.h

NTSTATUS
PciPdoIrpQueryPower(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoSetPowerState (
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpStack,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoWaitWake (
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );


VOID
PciPdoWaitWakeCancelRoutine(
    IN PDEVICE_OBJECT         DeviceObject,
    IN OUT PIRP               Irp
    );

NTSTATUS
PciFdoIrpQueryPower(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoSetPowerState(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciFdoWaitWake(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciSetPowerManagedDevicePowerState(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN DEVICE_POWER_STATE DeviceState,
    IN BOOLEAN RefreshConfigSpace
    );

// ppbridge.h

VOID
PPBridge_MassageHeaderForLimitsDetermination(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
PPBridge_RestoreCurrent(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
PPBridge_SaveLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
PPBridge_SaveCurrentSettings(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

VOID
PPBridge_ChangeResourceSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

VOID
PPBridge_GetAdditionalResourceDescriptors(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig,
    IN PIO_RESOURCE_DESCRIPTOR Resource
    );

NTSTATUS
PPBridge_ResetDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

//    romimage.h

NTSTATUS
PciReadRomImage(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN ULONG WhichSpace,
    OUT PVOID Buffer,
    IN ULONG Offset,
    IN OUT PULONG LENGTH
    );

//    state.h

//
// Note - State.c depends on the order of these.
//
typedef enum {
    PciNotStarted = 0,
    PciStarted,
    PciDeleted,
    PciStopped,
    PciSurpriseRemoved,
    PciSynchronizedOperation,
    PciMaxObjectState
} PCI_OBJECT_STATE;

VOID
PciInitializeState(
    IN PPCI_COMMON_EXTENSION DeviceExtension
    );

NTSTATUS
PciBeginStateTransition(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      NewState
    );

VOID
PciCommitStateTransition(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      NewState
    );

NTSTATUS
PciCancelStateTransition(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      StateNotEntered
    );

BOOLEAN
PciIsInTransitionToState(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      NextState
    );

/*
NTSTATUS
PciBeginStateTransitionIfNotBegun(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
     IN PCI_OBJECT_STATE      StateToEnter
    );
*/

#define PCI_ACQUIRE_STATE_LOCK(Extension) \
   PciBeginStateTransition((PPCI_COMMON_EXTENSION) (Extension), \
                           PciSynchronizedOperation)


#define PCI_RELEASE_STATE_LOCK(Extension) \
   PciCancelStateTransition((PPCI_COMMON_EXTENSION) (Extension), \
                           PciSynchronizedOperation)



//    tr_comn.h

typedef struct _PCI_TRANSLATOR_INSTANCE {
    PTRANSLATOR_INTERFACE Interface;
    ULONG ReferenceCount;
    PPCI_FDO_EXTENSION FdoExtension;
} PCI_TRANSLATOR_INSTANCE, *PPCI_TRANSLATOR_INSTANCE;

#define PCI_TRANSLATOR_INSTANCE_TO_CONTEXT(x)   ((PVOID)(x))
#define PCI_TRANSLATOR_CONTEXT_TO_INSTANCE(x)   ((PPCI_TRANSLATOR_INSTANCE)(x))

VOID
PciReferenceTranslator(
    IN PVOID Context
    );

VOID
PciDereferenceTranslator(
    IN PVOID Context
    );

//    usage.h

NTSTATUS
PciLocalDeviceUsage (
    IN PPCI_POWER_STATE     PowerState,
    IN PIRP                 Irp
    );

NTSTATUS
PciPdoDeviceUsage (
    IN PPCI_PDO_EXTENSION   pdoExtension,
    IN PIRP             Irp
    );

//  utils.h

NTSTATUS
PciAssignSlotResources(
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

PCI_OBJECT_TYPE
PciClassifyDeviceType(
    PPCI_PDO_EXTENSION PdoExtension
    );

// VOID
// PciCompleteRequest(
//     IN OUT PIRP Irp,
//     IN NTSTATUS Status
//     );

#define PciCompleteRequest(_Irp_,_Status_)                      \
    {                                                           \
        (_Irp_)->IoStatus.Status = (_Status_);                  \
        IoCompleteRequest((_Irp_), IO_NO_INCREMENT);            \
    }

BOOLEAN
PciCreateIoDescriptorFromBarLimit(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    IN PULONG BaseAddress,
    IN BOOLEAN Rom
    );

#define PCI_CAN_DISABLE_VIDEO_DECODES   0x00000001

BOOLEAN
PciCanDisableDecodes(
    IN PPCI_PDO_EXTENSION PdoExtension OPTIONAL,
    IN PPCI_COMMON_CONFIG Config OPTIONAL,
    IN ULONGLONG HackFlags,
    IN ULONG Flags
    );

VOID
PciDecodeEnable(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN BOOLEAN EnableOperation,
    IN PUSHORT ExistingCommand OPTIONAL
    );

PCM_PARTIAL_RESOURCE_DESCRIPTOR
PciFindDescriptorInCmResourceList(
    IN CM_RESOURCE_TYPE DescriptorType,
    IN PCM_RESOURCE_LIST ResourceList,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR PreviousHit
    );

PPCI_FDO_EXTENSION
PciFindParentPciFdoExtension(
    PDEVICE_OBJECT PhysicalDeviceObject,
    IN PFAST_MUTEX Mutex
    );

PPCI_PDO_EXTENSION
PciFindPdoByFunction(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PCI_SLOT_NUMBER Slot,
    IN PPCI_COMMON_CONFIG Config
    );

PVOID
PciFindNextSecondaryExtension(
    IN PSINGLE_LIST_ENTRY   ListEntry,
    IN PCI_SIGNATURE        DesiredType
    );

#define PciFindSecondaryExtension(X,TYPE) \
    PciFindNextSecondaryExtension((X)->SecondaryExtension.Next, TYPE)

VOID
PcipLinkSecondaryExtension(
    IN PSINGLE_LIST_ENTRY               ListHead,
    IN PFAST_MUTEX                      Mutex,
    IN PVOID                            NewExtension,
    IN PCI_SIGNATURE                    Type,
    IN PSECONDARYEXTENSIONDESTRUCTOR    Destructor
    );

#define PciLinkSecondaryExtension(X,X2,T,D)                 \
    PcipLinkSecondaryExtension(&(X)->SecondaryExtension,    \
                               &(X)->SecondaryExtMutex,     \
                               X2,                          \
                               T,                           \
                               D)

VOID
PcipDestroySecondaryExtension(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PFAST_MUTEX        Mutex,
    IN PVOID              Extension
    );

ULONGLONG
PciGetHackFlags(
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN UCHAR  RevisionID
    );

NTSTATUS
PciGetDeviceProperty(
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    IN  DEVICE_REGISTRY_PROPERTY DeviceProperty,
    OUT PVOID *PropertyBuffer
    );

NTSTATUS
PciGetInterruptAssignment(
    IN PPCI_PDO_EXTENSION PdoExtension,
    OUT ULONG *Minimum,
    OUT ULONG *Maximum
    );

ULONG
PciGetLengthFromBar(
    ULONG BaseAddressRegister
    );

NTSTATUS
PciGetRegistryValue(
    IN  PWSTR   ValueName,
    IN  PWSTR   KeyName,
    IN  HANDLE  ParentHandle,
    OUT PVOID   *Buffer,
    OUT ULONG   *Length
    );

VOID
PciInsertEntryAtTail(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY NewEntry,
    IN PFAST_MUTEX        Mutex
    );

VOID
PciInsertEntryAtHead(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY NewEntry,
    IN PFAST_MUTEX        Mutex
    );

VOID
PciInvalidateResourceInfoCache(
    IN PPCI_PDO_EXTENSION PdoExtension
    );

PCM_PARTIAL_RESOURCE_DESCRIPTOR
PciNextPartialDescriptor(
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

BOOLEAN
PciOpenKey(
    IN  PWSTR           KeyName,
    IN  HANDLE          ParentHandle,
    OUT PHANDLE         ChildHandle,
    OUT PNTSTATUS       Status
    );

NTSTATUS
PciQueryBusInformation(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPNP_BUS_INFORMATION *BusInformation
    );

NTSTATUS
PciQueryLegacyBusInformation(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PLEGACY_BUS_INFORMATION *BusInformation
    );

NTSTATUS
PciQueryCapabilities(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PDEVICE_CAPABILITIES Capabilities
    );

NTSTATUS
PciRangeListFromResourceList(
    IN  PPCI_FDO_EXTENSION    FdoExtension,
    IN  PCM_RESOURCE_LIST ResourceList,
    IN  CM_RESOURCE_TYPE  DesiredType,
    IN  BOOLEAN           Complement,
    IN  PRTL_RANGE_LIST   ResultRange
    );

UCHAR
PciReadDeviceCapability(
    IN     PPCI_PDO_EXTENSION PdoExtension,
    IN     UCHAR          Offset,
    IN     UCHAR          Id,
    IN OUT PVOID          Buffer,
    IN     ULONG          Length
    );

VOID
PciRemoveEntryFromList(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY OldEntry,
    IN PFAST_MUTEX        Mutex
    );

PPCI_PDO_EXTENSION
PciFindPdoByLocation(
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER Slot
    );

NTSTATUS
PciBuildDefaultExclusionLists(
    VOID
    );

NTSTATUS
PciExcludeRangesFromWindow(
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN PRTL_RANGE_LIST ArbiterRanges,
    IN PRTL_RANGE_LIST ExclusionRanges
    );

NTSTATUS
PciSaveBiosConfig(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG Config
    );

NTSTATUS
PciGetBiosConfig(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG Config
    );

BOOLEAN
PciStringToUSHORT(
    IN PWCHAR String,
    OUT PUSHORT Result
    );

NTSTATUS
PciSendIoctl(
    IN PDEVICE_OBJECT Device,
    IN ULONG IoctlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

BOOLEAN
PciIsOnVGAPath(
    IN PPCI_PDO_EXTENSION Pdo
    );

BOOLEAN
PciIsSlotPresentInParentMethod(
    IN PPCI_PDO_EXTENSION Pdo,
    IN ULONG Method
    );

NTSTATUS
PciUpdateLegacyHardwareDescription(
    IN PPCI_FDO_EXTENSION Fdo
    );

NTSTATUS
PciWriteDeviceSpace(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    OUT PULONG LengthWritten
    );

NTSTATUS
PciReadDeviceSpace(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    OUT PULONG LengthRead
    );

//
// Programming Interface encodings for PCI IDE Controllers
// BaseClass = 1, SubClass = 1
//


#define PCI_IDE_PRIMARY_NATIVE_MODE         0x01
#define PCI_IDE_PRIMARY_MODE_CHANGEABLE     0x02
#define PCI_IDE_SECONDARY_NATIVE_MODE       0x04
#define PCI_IDE_SECONDARY_MODE_CHANGEABLE   0x08

#define PCI_IS_LEGACY_IDE_CONTROLLER(_Config)                               \
        ((_Config)->BaseClass == PCI_CLASS_MASS_STORAGE_CTLR                \
        && (_Config)->SubClass == PCI_SUBCLASS_MSC_IDE_CTLR                 \
        && !BITS_SET((_Config)->ProgIf, (PCI_IDE_PRIMARY_NATIVE_MODE        \
                                        | PCI_IDE_SECONDARY_NATIVE_MODE)))

#define PCI_IS_NATIVE_IDE_CONTROLLER(_Config)                               \
        ((_Config)->BaseClass == PCI_CLASS_MASS_STORAGE_CTLR                \
        && (_Config)->SubClass == PCI_SUBCLASS_MSC_IDE_CTLR                 \
        && BITS_SET((_Config)->ProgIf, (PCI_IDE_PRIMARY_NATIVE_MODE         \
                                        | PCI_IDE_SECONDARY_NATIVE_MODE)))

#define PCI_IS_NATIVE_CAPABLE_IDE_CONTROLLER(_Config)                       \
        ((_Config)->BaseClass == PCI_CLASS_MASS_STORAGE_CTLR                \
        && (_Config)->SubClass == PCI_SUBCLASS_MSC_IDE_CTLR                 \
        && BITS_SET((_Config)->ProgIf, (PCI_IDE_PRIMARY_MODE_CHANGEABLE     \
                                        | PCI_IDE_SECONDARY_MODE_CHANGEABLE)))


//
// _HPP method for HotPlugParameters
//
//    Method (_HPP, 0) {
//        Return (Package(){
//            0x00000008,     // CacheLineSize in DWORDS
//            0x00000040,     // LatencyTimer in PCI clocks
//            0x00000001,     // Enable SERR (Boolean)
//            0x00000001      // Enable PERR (Boolean)
//         })
//

#define PCI_HPP_CACHE_LINE_SIZE_INDEX   0
#define PCI_HPP_LATENCY_TIMER_INDEX     1
#define PCI_HPP_ENABLE_SERR_INDEX       2
#define PCI_HPP_ENABLE_PERR_INDEX       3
#define PCI_HPP_PACKAGE_COUNT           4


//
// Support for kernel debugger and headless ports that can't be turned off
// This is retrieved from the registry in DriverEntry and thus the bus numbers
// are how the firmware configured the machine and not necessarily the current
// settings.  Luckily we saved away the BIOS config in the registry.
//

typedef struct _PCI_DEBUG_PORT {
    ULONG Bus;
    PCI_SLOT_NUMBER Slot;
} PCI_DEBUG_PORT, *PPCI_DEBUG_PORT;

extern PCI_DEBUG_PORT PciDebugPorts[];
extern ULONG PciDebugPortsCount;

BOOLEAN
PciIsDeviceOnDebugPath(
    IN PPCI_PDO_EXTENSION Pdo
    );

//
// Cardbus has extra configuration information beyond the common
// header.
//

typedef struct _TYPE2EXTRAS {
    USHORT  SubVendorID;
    USHORT  SubSystemID;
    ULONG   LegacyModeBaseAddress;
} TYPE2EXTRAS;

#define CARDBUS_LMBA_OFFSET                                     \
    (ULONG)(FIELD_OFFSET(PCI_COMMON_CONFIG, DeviceSpecific) +   \
            FIELD_OFFSET(TYPE2EXTRAS, LegacyModeBaseAddress))


//
// Hack flags for PCI devices (PDO)
//

#define PCI_HACK_NO_VIDEO_IRQ               0x0000000000000001L
#define PCI_HACK_PCMCIA_WANT_IRQ            0x0000000000000002L
#define PCI_HACK_DUAL_IDE                   0x0000000000000004L
#define PCI_HACK_NO_ENUM_AT_ALL             0x0000000000000008L
#define PCI_HACK_ENUM_NO_RESOURCE           0x0000000000000010L
#define PCI_HACK_NEED_DWORD_ACCESS          0x0000000000000020L
#define PCI_HACK_SINGLE_FUNCTION            0x0000000000000040L
#define PCI_HACK_ALWAYS_ENABLED             0x0000000000000080L
#define PCI_HACK_IS_IDE                     0x0000000000000100L
#define PCI_HACK_IS_VIDEO                   0x0000000000000200L
#define PCI_HACK_FAIL_START                 0x0000000000000400L
#define PCI_HACK_GHOST                      0x0000000000000800L
#define PCI_HACK_DOUBLE_DECKER              0x0000000000001000L
#define PCI_HACK_ONE_CHILD                  0x0000000000002000L
#define PCI_HACK_PRESERVE_COMMAND           0x0000000000004000L
#define PCI_HACK_IS_VGA                     0x0000000000008000L
#define PCI_HACK_CB_SHARE_CMD_BITS          0x0000000000010000L
#define PCI_HACK_STRAIGHT_IRQ_ROUTING       0x0000000000020000L
#define PCI_HACK_SUBTRACTIVE_DECODE         0x0000000000040000L
#define PCI_HACK_FDMA_ISA                   0x0000000000080000L
#define PCI_HACK_EXCLUSIVE                  0x0000000000100000L
#define PCI_HACK_EDGE                       0x0000000000200000L
#define PCI_HACK_NO_SUBSYSTEM               0x0000000000400000L
#define PCI_HACK_NO_WPE                     0x0000000000800000L
#define PCI_HACK_OLD_ID                     0x0000000001000000L
#define PCI_HACK_DONT_SHRINK_BRIDGE         0x0000000002000000L
#define PCI_HACK_TURN_OFF_PARITY            0x0000000004000000L
#define PCI_HACK_NO_NON_PCI_CHILD_BAR       0x0000000008000000L
#define PCI_HACK_NO_ENUM_WITH_DISABLE       0x0000000010000000L
#define PCI_HACK_NO_PM_CAPS                 0x0000000020000000L
#define PCI_HACK_NO_DISABLE_DECODES         0x0000000040000000L
#define PCI_HACK_NO_SUBSYSTEM_AFTER_D3      0x0000000080000000L
#define PCI_HACK_VIDEO_LEGACY_DECODE        0x0000000100000000L
#define PCI_HACK_FAKE_CLASS_CODE            0x0000000200000000L
#define PCI_HACK_RESET_BRIDGE_ON_POWERUP    0x0000000400000000L
#define PCI_HACK_BAD_NATIVE_IDE             0x0000000800000000L
#define PCI_HACK_FAIL_QUERY_REMOVE          0x0000001000000000L

//
// Hack flags for PCI busses (FDO)
// NB: These are not currently applied to cardbus bridges
//

//
// PCI_BUS_HACK_LOCK_RESOURCES - prevent devices on *this* bus from 
// being moved.  If a BAR are unconfigured it will still be assigned
// resources from what is available on the bus.  If the BAR is
// configured only those resources if available will be assigned, if
// not available the the device will fail CM_PROBLEM_RESOURCE_CONFLICT.
// 
// Putting /PCILOCK in boot.ini applies this to all devices in the system.
//
#define PCI_BUS_HACK_LOCK_RESOURCES         0x00000001

//
// Random useful macros
//

#ifndef FIELD_SIZE
#define FIELD_SIZE(type, field) (sizeof(((type *)0)->field))
#endif

//
// This macro computes if a range of bytes with configuration
// space from offset for length bytes will intersect with the
// any of the fields between field1 and field2 as defined in
// PCI_COMMON_CONFIG
//

#define INTERSECT_CONFIG_FIELD_RANGE(offset, length, field1, field2)    \
    INTERSECT((offset),                                                 \
              (offset) + (length) - 1,                                  \
              FIELD_OFFSET(PCI_COMMON_CONFIG, field1),                \
              FIELD_OFFSET(PCI_COMMON_CONFIG, field2)                 \
                + FIELD_SIZE(PCI_COMMON_CONFIG, field2) - 1           \
              )

//
// This macro computes if a range of bytes with configuration
// space from offset for length bytes will intersect with
// field as defined in PCI_COMMON_CONFIG
//

#define INTERSECT_CONFIG_FIELD(offset, length, field)                   \
    INTERSECT_CONFIG_FIELD_RANGE(offset, length, field, field)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\pdo.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    pdo.c

Abstract:

    This module handles IRPs for PCI PDO's.

Author:

    Adrian J. Oney (adriao) & Andrew Thornton (andrewth)  10-20-1998

Revision History:

--*/

#include "pcip.h"

NTSTATUS
PciPdoIrpStartDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpCancelRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpCancelStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryDeviceRelations(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryCapabilities(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryInterface(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryResources(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryResourceRequirements(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryDeviceText(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpReadConfig(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpWriteConfig(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryId(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryBusInformation(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpDeviceUsageNotification(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryLegacyBusInformation(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpSurpriseRemoval(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );

NTSTATUS
PciPdoIrpQueryDeviceState(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciPdoCreate)
#pragma alloc_text(PAGE, PciPdoDestroy)
#pragma alloc_text(PAGE, PciPdoIrpStartDevice)
#pragma alloc_text(PAGE, PciPdoIrpQueryRemoveDevice)
#pragma alloc_text(PAGE, PciPdoIrpRemoveDevice)
#pragma alloc_text(PAGE, PciPdoIrpCancelRemoveDevice)
#pragma alloc_text(PAGE, PciPdoIrpStopDevice)
#pragma alloc_text(PAGE, PciPdoIrpQueryStopDevice)
#pragma alloc_text(PAGE, PciPdoIrpCancelStopDevice)
#pragma alloc_text(PAGE, PciPdoIrpQueryDeviceRelations)
#pragma alloc_text(PAGE, PciPdoIrpQueryInterface)
#pragma alloc_text(PAGE, PciPdoIrpQueryCapabilities)
#pragma alloc_text(PAGE, PciPdoIrpQueryResources)
#pragma alloc_text(PAGE, PciPdoIrpQueryResourceRequirements)
#pragma alloc_text(PAGE, PciPdoIrpQueryDeviceText)
#pragma alloc_text(PAGE, PciPdoIrpReadConfig)
#pragma alloc_text(PAGE, PciPdoIrpWriteConfig)
#pragma alloc_text(PAGE, PciPdoIrpQueryId)
#pragma alloc_text(PAGE, PciPdoIrpQueryBusInformation)
#pragma alloc_text(PAGE, PciPdoIrpDeviceUsageNotification)
#pragma alloc_text(PAGE, PciPdoIrpQueryLegacyBusInformation)
#pragma alloc_text(PAGE, PciPdoIrpSurpriseRemoval)
#pragma alloc_text(PAGE, PciPdoIrpQueryDeviceState)
#endif

/*++

The majority of functions in this file are called based on their presence
in Pnp and Po dispatch tables.  In the interests of brevity the arguments
to all those functions will be described below:

NTSTATUS
PciXxxPdo(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpStack,
    IN PPCI_EXTENSION DeviceExtension
    )

Routine Description:

    This function handles the Xxx requests for a given PCI FDO or PDO.

Arguments:

    Irp - Points to the IRP associated with this request.

    IrpStack - Points to the current stack location for this request.

    DeviceExtension - Points to the device's extension.

Return Value:

    Status code that indicates whether or not the function was successful.

    STATUS_NOT_SUPPORTED indicates that the IRP should be completed without
    changing the Irp->IoStatus.Status field otherwise it is updated with this
    status.

--*/

#define PCI_MAX_MINOR_POWER_IRP  0x3
#define PCI_MAX_MINOR_PNP_IRP    0x18

PCI_MN_DISPATCH_TABLE PciPdoDispatchPowerTable[] = {
    { IRP_DISPATCH, PciPdoWaitWake                     }, // 0x00 - IRP_MN_WAIT_WAKE
    { IRP_COMPLETE, PciIrpNotSupported                 }, // 0x01 - IRP_MN_POWER_SEQUENCE
    { IRP_COMPLETE, PciPdoSetPowerState                }, // 0x02 - IRP_MN_SET_POWER
    { IRP_COMPLETE, PciPdoIrpQueryPower                }, // 0x03 - IRP_MN_QUERY_POWER
    { IRP_COMPLETE, PciIrpNotSupported                 }, //      - UNHANDLED Power IRP
};

PCI_MN_DISPATCH_TABLE PciPdoDispatchPnpTable[] = {
    { IRP_COMPLETE, PciPdoIrpStartDevice               }, // 0x00 - IRP_MN_START_DEVICE
    { IRP_COMPLETE, PciPdoIrpQueryRemoveDevice         }, // 0x01 - IRP_MN_QUERY_REMOVE_DEVICE
    { IRP_COMPLETE, PciPdoIrpRemoveDevice              }, // 0x02 - IRP_MN_REMOVE_DEVICE
    { IRP_COMPLETE, PciPdoIrpCancelRemoveDevice        }, // 0x03 - IRP_MN_CANCEL_REMOVE_DEVICE
    { IRP_COMPLETE, PciPdoIrpStopDevice                }, // 0x04 - IRP_MN_STOP_DEVICE
    { IRP_COMPLETE, PciPdoIrpQueryStopDevice           }, // 0x05 - IRP_MN_QUERY_STOP_DEVICE
    { IRP_COMPLETE, PciPdoIrpCancelStopDevice          }, // 0x06 - IRP_MN_CANCEL_STOP_DEVICE
    { IRP_COMPLETE, PciPdoIrpQueryDeviceRelations      }, // 0x07 - IRP_MN_QUERY_DEVICE_RELATIONS
    { IRP_COMPLETE, PciPdoIrpQueryInterface            }, // 0x08 - IRP_MN_QUERY_INTERFACE
    { IRP_COMPLETE, PciPdoIrpQueryCapabilities         }, // 0x09 - IRP_MN_QUERY_CAPABILITIES
    { IRP_COMPLETE, PciPdoIrpQueryResources            }, // 0x0A - IRP_MN_QUERY_RESOURCES
    { IRP_COMPLETE, PciPdoIrpQueryResourceRequirements }, // 0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    { IRP_COMPLETE, PciPdoIrpQueryDeviceText           }, // 0x0C - IRP_MN_QUERY_DEVICE_TEXT
    { IRP_COMPLETE, PciIrpNotSupported                 }, // 0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    { IRP_COMPLETE, PciIrpNotSupported                 }, // 0x0E - NOT USED
    { IRP_COMPLETE, PciPdoIrpReadConfig                }, // 0x0F - IRP_MN_READ_CONFIG
    { IRP_COMPLETE, PciPdoIrpWriteConfig               }, // 0x10 - IRP_MN_WRITE_CONFIG
    { IRP_COMPLETE, PciIrpNotSupported                 }, // 0x11 - IRP_MN_EJECT
    { IRP_COMPLETE, PciIrpNotSupported                 }, // 0x12 - IRP_MN_SET_LOCK
    { IRP_COMPLETE, PciPdoIrpQueryId                   }, // 0x13 - IRP_MN_QUERY_ID
    { IRP_COMPLETE, PciPdoIrpQueryDeviceState          }, // 0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE
    { IRP_COMPLETE, PciPdoIrpQueryBusInformation       }, // 0x15 - IRP_MN_QUERY_BUS_INFORMATION
    { IRP_COMPLETE, PciPdoIrpDeviceUsageNotification   }, // 0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION
    { IRP_COMPLETE, PciPdoIrpSurpriseRemoval           }, // 0x17 - IRP_MN_SURPRISE_REMOVAL
    { IRP_COMPLETE, PciPdoIrpQueryLegacyBusInformation }, // 0x18 - IRP_MN_QUERY_LEGACY_BUS_INFORMATION
    { IRP_COMPLETE, PciIrpNotSupported                 }  //      - UNHANDLED PNP IRP
};

//
// This is the major function dispatch table for Pdo's
//
PCI_MJ_DISPATCH_TABLE PciPdoDispatchTable = {
    PCI_MAX_MINOR_PNP_IRP,    PciPdoDispatchPnpTable,       // Pnp irps
    PCI_MAX_MINOR_POWER_IRP,  PciPdoDispatchPowerTable,     // Power irps
    IRP_COMPLETE,             PciIrpNotSupported,
    IRP_COMPLETE,             PciIrpInvalidDeviceRequest    // Other
};

//
// Data
//

BOOLEAN PciStopOnIllegalConfigAccess = FALSE;
ULONG   PciPdoSequenceNumber = (ULONG)-1;

NTSTATUS
PciPdoCreate(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PCI_SLOT_NUMBER Slot,
    OUT PDEVICE_OBJECT *PhysicalDeviceObject
    )
{
    NTSTATUS       status;
    PDRIVER_OBJECT driverObject;
    PDEVICE_OBJECT functionalDeviceObject;
    PDEVICE_OBJECT physicalDeviceObject;
    PPCI_PDO_EXTENSION pdoExtension;
    UNICODE_STRING unicodeDeviceString;
    WCHAR          deviceString[32];

    PAGED_CODE();

    //
    // We've been asked to create a new PDO for a PCI device.  First get
    // a pointer to our driver object.
    //

    functionalDeviceObject = FdoExtension->FunctionalDeviceObject;
    driverObject = functionalDeviceObject->DriverObject;

    //
    // Create the physical device object for this device.
    // In theory it doesn't need a name,...  It must have
    // a name.
    //
    // But what name?  For now we'll call it NTPNP_PCIxxxx,
    // where xxxx is the 0-based number of PCI devices we've
    // found.
    //

    _snwprintf(deviceString,
               sizeof(deviceString)/sizeof(WCHAR),
               L"\\Device\\NTPNP_PCI%04d",
               InterlockedIncrement(&PciPdoSequenceNumber));

    RtlInitUnicodeString(&unicodeDeviceString, deviceString);

    status = IoCreateDevice(
                driverObject,               // our driver object
                sizeof(PCI_PDO_EXTENSION),      // size of our extension,
                &unicodeDeviceString,       // our name
                FILE_DEVICE_UNKNOWN,        // device type
                0,                          // device characteristics
                FALSE,                      // not exclusive
                &physicalDeviceObject       // store new device object here
                );

    if (!NT_SUCCESS(status)) {
        ASSERT(NT_SUCCESS(status));
        return status;
    }

    pdoExtension = (PPCI_PDO_EXTENSION)physicalDeviceObject->DeviceExtension;

    PciDebugPrint(PciDbgVerbose,
                  "PCI: New PDO (b=0x%x, d=0x%x, f=0x%x) @ %p, ext @ %p\n",
                  FdoExtension->BaseBus,
                  Slot.u.bits.DeviceNumber,
                  Slot.u.bits.FunctionNumber,
                  physicalDeviceObject,
                  pdoExtension);

    //
    // We have our physical device object, initialize it.
    //
    // And yes, I would have zeroed the extension if I didn't know
    // for a fact that it was zeroed by IoCreateDevice().
    //
    pdoExtension->ExtensionType = PciPdoExtensionType;
    pdoExtension->IrpDispatchTable = &PciPdoDispatchTable;
    pdoExtension->PhysicalDeviceObject = physicalDeviceObject;
    pdoExtension->Slot = Slot;
    pdoExtension->PowerState.CurrentSystemState = PowerSystemWorking;
    pdoExtension->PowerState.CurrentDeviceState = PowerDeviceD0;
    pdoExtension->ParentFdoExtension = FdoExtension;
    
    ExInitializeFastMutex(&pdoExtension->SecondaryExtMutex);
    PciInitializeState((PPCI_COMMON_EXTENSION) pdoExtension);

    //
    // Insert it into the list of child PDOs hanging off of the FdoExtension.
    // We won't be re-entered enumerating the same bus, so we don't need to
    // protect the list.
    //

    pdoExtension->Next = NULL;

    PciInsertEntryAtTail(
        (PSINGLE_LIST_ENTRY)&FdoExtension->ChildPdoList,
        (PSINGLE_LIST_ENTRY)&pdoExtension->Next,
        &FdoExtension->ChildListMutex
        );

    *PhysicalDeviceObject = physicalDeviceObject;
    return STATUS_SUCCESS;
}

VOID
PciPdoDestroy(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
{
    PPCI_PDO_EXTENSION pdoExtension;
    PPCI_PDO_EXTENSION *previousBridge;
    PPCI_FDO_EXTENSION fdoExtension;

    PAGED_CODE();

    pdoExtension = (PPCI_PDO_EXTENSION)PhysicalDeviceObject->DeviceExtension;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    ASSERT(!pdoExtension->LegacyDriver);

    fdoExtension = PCI_PARENT_FDOX(pdoExtension);

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    PciDebugPrint(PciDbgVerbose,
                  "PCI: destroy PDO (b=0x%x, d=0x%x, f=0x%x)\n",
                  PCI_PARENT_FDOX(pdoExtension)->BaseBus,
                  pdoExtension->Slot.u.bits.DeviceNumber,
                  pdoExtension->Slot.u.bits.FunctionNumber);

    //
    // Remove this PDO from the Child Pdo List.
    //
    ASSERT_MUTEX_HELD(&fdoExtension->ChildListMutex);

    PciRemoveEntryFromList((PSINGLE_LIST_ENTRY)&fdoExtension->ChildPdoList,
                           (PSINGLE_LIST_ENTRY)pdoExtension,
                           NULL);

    for (previousBridge = &fdoExtension->ChildBridgePdoList;
         *previousBridge;
         previousBridge = &((*previousBridge)->NextBridge)) {

        if (*previousBridge == pdoExtension) {
            *previousBridge = pdoExtension->NextBridge;
            pdoExtension->NextBridge = NULL;
            break;
        }
    }

    pdoExtension->Next = NULL;

    //
    // Delete any secondary extensions this PDO may have.
    //

    while (pdoExtension->SecondaryExtension.Next) {

        PcipDestroySecondaryExtension(&pdoExtension->SecondaryExtension,
                                      NULL,
                                      pdoExtension->SecondaryExtension.Next);
    }

    //
    // Zap the extension type so we'll trip up if we try to resuse it.
    //

    pdoExtension->ExtensionType = 0xdead;
    
    //
    // If there are any resource lists etc associated with this puppy,
    // give them back to the system.
    //

    PciInvalidateResourceInfoCache(pdoExtension);

    if (pdoExtension->Resources) {
        ExFreePool(pdoExtension->Resources);
    }

    //
    // And finally,...
    //

    IoDeleteDevice(PhysicalDeviceObject);
}


NTSTATUS
PciPdoIrpStartDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    NTSTATUS status;
    BOOLEAN change, powerOn, isVideoController;
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();

    status = PciBeginStateTransition(DeviceExtension, PciStarted);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    //
    // If there is a motherboard video device and a plug in video
    // device, the BIOS will have disabled the motherboard one.  The
    // video drivers use this fact to determine if this device should
    // be disabled,... don't change its settings here.
    //
    isVideoController =
       ((pdoExtension->BaseClass == PCI_CLASS_PRE_20) &&
        (pdoExtension->SubClass  == PCI_SUBCLASS_PRE_20_VGA)) ||
       ((pdoExtension->BaseClass == PCI_CLASS_DISPLAY_CTLR) &&
        (pdoExtension->SubClass  == PCI_SUBCLASS_VID_VGA_CTLR));

    if ( !isVideoController ) {

        //
        // Non-VGA, unconditionally enable the IO and Memory for the device.
        //

        pdoExtension->CommandEnables |= (PCI_ENABLE_IO_SPACE 
                                       | PCI_ENABLE_MEMORY_SPACE);
    }

    //
    // Disable interrupt generation for IDE controllers until IDE is up and
    // running (See comment in PciConfigureIdeController)
    //
    if (pdoExtension->IoSpaceUnderNativeIdeControl) {
        pdoExtension->CommandEnables &= ~PCI_ENABLE_IO_SPACE;
    }

    //
    // Always enable the bus master bit - even for video controllers
    //
    pdoExtension->CommandEnables |= PCI_ENABLE_BUS_MASTER;

    //
    // Extract the PDO Resources (PCI driver internal style)
    // from the incoming resource list.
    //
    change = PciComputeNewCurrentSettings(
                 pdoExtension,
                 IrpSp->Parameters.StartDevice.AllocatedResources
                 );

    //
    // Remember if we ever move the device
    //

    if (change) {
        pdoExtension->MovedDevice = TRUE;
    }

#if DBG

    if (!change) {
        PciDebugPrint(
            PciDbgObnoxious,
            "PCI - START not changing resource settings.\n"
            );
    }

#endif

    //
    // The device should be powered up at this stage.
    //

    powerOn = FALSE;

    if (pdoExtension->PowerState.CurrentDeviceState != PowerDeviceD0) {

        POWER_STATE powerState;

        status = PciSetPowerManagedDevicePowerState(
                     pdoExtension,
                     PowerDeviceD0,
                     FALSE
                     );
        
        if (!NT_SUCCESS(status)) {
            PciCancelStateTransition(DeviceExtension, PciStarted);
            return STATUS_DEVICE_POWER_FAILURE;
        }

        powerState.DeviceState = PowerDeviceD0;

        PoSetPowerState(
            pdoExtension->PhysicalDeviceObject,
            DevicePowerState,
            powerState
            );

        //
        // Force PciSetResources to write the configuration
        // and other extraneous data to the device.
        //

        powerOn = TRUE;

        pdoExtension->PowerState.CurrentDeviceState = PowerDeviceD0;
    }

    //
    // Program the device with the resources allocated.
    //

    status = PciSetResources(
                 pdoExtension,
                 powerOn,
                 TRUE
                 );

    if (NT_SUCCESS(status)) {

        PciCommitStateTransition(DeviceExtension, PciStarted);
    } else {

        PciCancelStateTransition(DeviceExtension, PciStarted);
    }

    return status;
}

NTSTATUS
PciPdoIrpQueryRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();

    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    //
    // Don't allow the paging device (or a hibernate device) to
    // be removed or stopped
    //

    if (pdoExtension->PowerState.Hibernate ||
        pdoExtension->PowerState.Paging    ||
        pdoExtension->PowerState.CrashDump ||
        pdoExtension->OnDebugPath ||
        (pdoExtension->HackFlags & PCI_HACK_FAIL_QUERY_REMOVE)) {

        return STATUS_DEVICE_BUSY;
    }

    //
    // Don't allow devices with legacy drivers to be removed (even thought the
    // driver may be root enumerated)
    //

    if (pdoExtension->LegacyDriver) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (DeviceExtension->DeviceState == PciNotStarted) {

        return STATUS_SUCCESS;

    } else {

        return PciBeginStateTransition(DeviceExtension, PciNotStarted);
    }
}

NTSTATUS
PciPdoIrpRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    NTSTATUS status;
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();

    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    //
    // If this PDO is for a PCI-PCI bridge, it has a pointer
    // to the FDO that was attached to it.  That FDO was destroyed
    // as a result of the IRP coming down the stack.  Clear the
    // pointer.  (Unconditionally as it is only set for bridges).
    //

    pdoExtension->BridgeFdoExtension = NULL;

    if (!pdoExtension->NotPresent) {

        //
        // Turn the device off.   (Checks for whether or not
        // this is a good idea are in the PciDecodeEnable routine).
        // While you might think this should be done only if we were already
        // headed to PciNotStarted, we may in fact have a boot config that
        // needs to be disabled.
        //

        PciDecodeEnable(pdoExtension, FALSE, NULL);

        //
        // Power it down if we are allowed to disable its decodes - if not then
        // don't turn it off.  eg. Don't turn of the VGA card...
        //
        if (pdoExtension->PowerState.CurrentDeviceState != PowerDeviceD3
        &&  PciCanDisableDecodes(pdoExtension, NULL, 0, 0)) {

            POWER_STATE powerState;

            status = PciSetPowerManagedDevicePowerState(
                         pdoExtension,
                         PowerDeviceD3,
                         FALSE
                         );

            pdoExtension->PowerState.CurrentDeviceState = PowerDeviceD3;

            powerState.DeviceState = PowerDeviceD3;

            PoSetPowerState(
                pdoExtension->PhysicalDeviceObject,
                DevicePowerState,
                powerState
                );
        }
    }

    //
    // We can get a remove in one of three states:
    // 1) We have received a QueryRemove/SurpriseRemove in which case we are
    //    transitioning to PciNotStarted.
    // 2) We were never started, so we are already in PciNotStarted.
    // 3) We started the PDO, but the FDO failed start. We are in PciStarted in
    //    this case.
    //
    if (!PciIsInTransitionToState(DeviceExtension, PciNotStarted)&&
        (DeviceExtension->DeviceState == PciStarted)) {

        PciBeginStateTransition(DeviceExtension, PciNotStarted);
    }

    if (PciIsInTransitionToState(DeviceExtension, PciNotStarted)) {

        PciCommitStateTransition(DeviceExtension, PciNotStarted);
    }

    if (pdoExtension->ReportedMissing) {

        status = PciBeginStateTransition(DeviceExtension, PciDeleted);
        ASSERT(NT_SUCCESS(status));

        PciCommitStateTransition(DeviceExtension, PciDeleted);

        PciPdoDestroy(pdoExtension->PhysicalDeviceObject);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PciPdoIrpCancelRemoveDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();

    PciCancelStateTransition(DeviceExtension, PciNotStarted);
    return STATUS_SUCCESS;
}

NTSTATUS
PciPdoIrpStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Turn the device off.   (Checks for whether or not
    // this is a good idea are in the PciDecodeEnable routine).
    //
    PciDecodeEnable((PPCI_PDO_EXTENSION) DeviceExtension, FALSE, NULL);

    PciCommitStateTransition(DeviceExtension, PciStopped);

    return STATUS_SUCCESS;

}

NTSTATUS
PciPdoIrpQueryStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();

    //
    // Don't allow the paging device (or a hibernate device) to
    // be removed or stopped
    //
    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    if (pdoExtension->PowerState.Hibernate ||
        pdoExtension->PowerState.Paging    ||
        pdoExtension->PowerState.CrashDump ||
        pdoExtension->OnDebugPath) {

        return STATUS_DEVICE_BUSY;
    }

    //
    // Don't stop PCI->PCI and CardBus bridges
    //

    if (pdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV
        &&  (pdoExtension->SubClass == PCI_SUBCLASS_BR_PCI_TO_PCI
             || pdoExtension->SubClass == PCI_SUBCLASS_BR_CARDBUS)) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Don't allow devices with legacy drivers to be stopped (even thought the
    // driver may be root enumerated)
    //

    if (pdoExtension->LegacyDriver) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // If we cannot free the resources, do tell the OS.
    //
    if (!PciCanDisableDecodes(pdoExtension, NULL, 0, 0)) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    return PciBeginStateTransition(DeviceExtension, PciStopped);
}

NTSTATUS
PciPdoIrpCancelStopDevice(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();

    PciCancelStateTransition(DeviceExtension, PciStopped);
    return STATUS_SUCCESS;
}

NTSTATUS
PciPdoIrpQueryDeviceRelations(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    NTSTATUS status;
    PPCI_PDO_EXTENSION pdoExtension, childList;

    PAGED_CODE();

    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    switch(IrpSp->Parameters.QueryDeviceRelations.Type) {

        case EjectionRelations:
            status = PciQueryEjectionRelations(
                pdoExtension,
                (PDEVICE_RELATIONS*)&Irp->IoStatus.Information
                );
            break;

        case TargetDeviceRelation:
            status = PciQueryTargetDeviceRelations(
                pdoExtension,
                (PDEVICE_RELATIONS*)&Irp->IoStatus.Information
                );
            break;

        default:
            status = STATUS_NOT_SUPPORTED;
            break;
    }

    return status;
}

NTSTATUS
PciPdoIrpQueryInterface(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    NTSTATUS status;
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();

    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    status = PciQueryInterface(
                pdoExtension,
                IrpSp->Parameters.QueryInterface.InterfaceType,
                IrpSp->Parameters.QueryInterface.Size,
                IrpSp->Parameters.QueryInterface.Version,
                IrpSp->Parameters.QueryInterface.InterfaceSpecificData,
                IrpSp->Parameters.QueryInterface.Interface,
                FALSE
                );

    if (!NT_SUCCESS(status)) {

        //
        // KLUDGE:   If this pdo has a fake FDO attatched to
        // it (because it's a cardbus controller), we should
        // check to see if this interface could have been supplied
        // by the FDO and supply it if so.
        //
        // Yes, this is really gross and yes it breaks the filter
        // model.  The correct thing is for cardbus to pass the
        // IRP here via the "backdoor" while it has it at the FDO
        // level.
        //

        PPCI_FDO_EXTENSION fakeFdo;

        fakeFdo = pdoExtension->BridgeFdoExtension;

        if (fakeFdo && (fakeFdo->Fake == TRUE)) {

            ASSERT((pdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV) &&
                   (pdoExtension->SubClass  == PCI_SUBCLASS_BR_CARDBUS));

            status = PciQueryInterface(
                        fakeFdo,
                        IrpSp->Parameters.QueryInterface.InterfaceType,
                        IrpSp->Parameters.QueryInterface.Size,
                        IrpSp->Parameters.QueryInterface.Version,
                        IrpSp->Parameters.QueryInterface.InterfaceSpecificData,
                        IrpSp->Parameters.QueryInterface.Interface,
                        FALSE
                        );
        }
    }

    return status;
}

NTSTATUS
PciPdoIrpQueryCapabilities(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();

    return PciQueryCapabilities(
                (PPCI_PDO_EXTENSION) DeviceExtension,
                IrpSp->Parameters.DeviceCapabilities.Capabilities
                );
}

NTSTATUS
PciPdoIrpQueryId(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();

    //
    // Get a pointer to the query id structure and process.
    //
    return PciQueryId(
        (PPCI_PDO_EXTENSION) DeviceExtension,
        IrpSp->Parameters.QueryId.IdType,
        (PWSTR*)&Irp->IoStatus.Information
        );
}

NTSTATUS
PciPdoIrpQueryResources(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();

    return PciQueryResources(
        (PPCI_PDO_EXTENSION) DeviceExtension,
        (PCM_RESOURCE_LIST*)&Irp->IoStatus.Information
        );
}

NTSTATUS
PciPdoIrpQueryResourceRequirements(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();

    return PciQueryRequirements(
        (PPCI_PDO_EXTENSION) DeviceExtension,
        (PIO_RESOURCE_REQUIREMENTS_LIST*)&Irp->IoStatus.Information
        );
}

NTSTATUS
PciPdoIrpQueryDeviceText(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();

    return PciQueryDeviceText(
             (PPCI_PDO_EXTENSION) DeviceExtension,
             IrpSp->Parameters.QueryDeviceText.DeviceTextType,
             IrpSp->Parameters.QueryDeviceText.LocaleId,
             (PWSTR*)&Irp->IoStatus.Information
             );
}

NTSTATUS
PciPdoIrpReadConfig(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    NTSTATUS status;
    ULONG lengthRead;
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();
    
    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;
    
    status = PciReadDeviceSpace(pdoExtension,
                                IrpSp->Parameters.ReadWriteConfig.WhichSpace,
                                IrpSp->Parameters.ReadWriteConfig.Buffer,
                                IrpSp->Parameters.ReadWriteConfig.Offset,
                                IrpSp->Parameters.ReadWriteConfig.Length,
                                &lengthRead
                                );
    
    //
    // Update the information files with the number of bytes read
    //
    
    Irp->IoStatus.Information = lengthRead;

    return status;
}

NTSTATUS
PciPdoIrpWriteConfig(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    NTSTATUS status;
    ULONG lengthWritten;
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();
    
    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;
    
    status = PciWriteDeviceSpace(pdoExtension,
                                 IrpSp->Parameters.ReadWriteConfig.WhichSpace,
                                 IrpSp->Parameters.ReadWriteConfig.Buffer,
                                 IrpSp->Parameters.ReadWriteConfig.Offset,
                                 IrpSp->Parameters.ReadWriteConfig.Length,
                                 &lengthWritten
                                 );
    
    //
    // Update the information files with the number of bytes read
    //
    
    Irp->IoStatus.Information = lengthWritten;

    return status;
}

NTSTATUS
PciPdoIrpQueryBusInformation(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

    return PciQueryBusInformation(
        (PPCI_PDO_EXTENSION) DeviceExtension,
        (PPNP_BUS_INFORMATION *) &Irp->IoStatus.Information
        );
}

NTSTATUS
PciPdoIrpDeviceUsageNotification(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PAGED_CODE();

    return PciPdoDeviceUsage((PPCI_PDO_EXTENSION) DeviceExtension, Irp);
}

NTSTATUS
PciPdoIrpQueryLegacyBusInformation(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp,
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
    PPCI_PDO_EXTENSION PdoExtension;
    PLEGACY_BUS_INFORMATION information;

    PAGED_CODE();

    //
    // We're interested in IRP_MN_QUERY_LEGACY_BUS_INFORMATION on a
    // PDO if the PDO is for a CardBus bridge.  In this case, the
    // CardBus/PCMCIA FDO has passed the irp down so that we can
    // answer it correctly.
    //

    PdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    if (PciClassifyDeviceType(PdoExtension) != PciTypeCardbusBridge) {
        return STATUS_NOT_SUPPORTED;
    }

    information = ExAllocatePool(PagedPool, sizeof(LEGACY_BUS_INFORMATION));

    if (information == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(&information->BusTypeGuid, &GUID_BUS_TYPE_PCI, sizeof(GUID));
    information->LegacyBusType = PCIBus;
    information->BusNumber = PdoExtension->Dependent.type1.SecondaryBus;

    (PLEGACY_BUS_INFORMATION) Irp->IoStatus.Information = information;

    return STATUS_SUCCESS;
}

NTSTATUS
PciPdoIrpSurpriseRemoval(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    NTSTATUS status;
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();

    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    //
    // There are two kinds of surprise removals
    // - Surprise removals due to removal of our device
    // - Surprise removals due to failure of our device to start
    //

    if (!pdoExtension->NotPresent) {

        //
        // Turn the device off.   (Checks for whether or not
        // this is a good idea are in the PciDecodeEnable routine).
        // While you might think this should be done only if we were already
        // headed to PciNotStarted, we may in fact have a boot config that
        // needs to be disabled. Note that we may turn it off again in remove
        // device. No big deal.
        //

        PciDecodeEnable(pdoExtension, FALSE, NULL);

        //
        // Power it down if we are allowed to disable its decodes - if not then
        // don't turn it off.  eg. Don't turn of the VGA card...
        //
        if (pdoExtension->PowerState.CurrentDeviceState != PowerDeviceD3
        &&  PciCanDisableDecodes(pdoExtension, NULL, 0, 0)) {

            POWER_STATE powerState;
            
            //
            // Power it down - if it fails we don't care - the hardware may be 
            // gone!
            //

            PciSetPowerManagedDevicePowerState(
                         pdoExtension,
                         PowerDeviceD3,
                         FALSE
                         );
            
            pdoExtension->PowerState.CurrentDeviceState = PowerDeviceD3;

            powerState.DeviceState = PowerDeviceD3;

            PoSetPowerState(
                pdoExtension->PhysicalDeviceObject,
                DevicePowerState,
                powerState
                );
        }
    }

    if (!pdoExtension->ReportedMissing) {

        PciBeginStateTransition(DeviceExtension, PciNotStarted);
        
    } else {

        //
        // The device is physically gone, don't dare touch it!
        //
        PciBeginStateTransition(DeviceExtension, PciSurpriseRemoved);
        PciCommitStateTransition(DeviceExtension, PciSurpriseRemoved);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
PciPdoIrpQueryDeviceState(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    PPCI_PDO_EXTENSION pdoExtension;

    PAGED_CODE();

    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;
    //
    // Host brides cannot be disabled and the user should not be given a 
    // opportunity to do so.
    //
    if ((pdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV) &&
        (pdoExtension->SubClass  == PCI_SUBCLASS_BR_HOST)) {

        (PNP_DEVICE_STATE)Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\power.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    power.c

Abstract:

    This module contains power management code for PCI.SYS.

Author:

    Joe Dai (joedai) 11-Sept-1997
    Peter Johnston (peterj) 24-Oct-1997

Revision History:

--*/


#include "pcip.h"


NTSTATUS
PciFdoWaitWakeCompletion(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PIRP                   Irp,
    IN PPCI_FDO_EXTENSION     FdoExtension
    );

NTSTATUS
PciFdoWaitWakeCallBack(
    IN PDEVICE_OBJECT         DeviceObject,
    IN UCHAR                  MinorFunction,
    IN POWER_STATE            PowerState,
    IN PVOID                  Context,
    IN PIO_STATUS_BLOCK       IoStatus
    );

VOID
PciFdoWaitWakeCancel(
    IN PDEVICE_OBJECT         DeviceObject,
    IN OUT PIRP               Irp
    );

VOID
PciFdoSetPowerStateCompletion(
    IN PDEVICE_OBJECT         DeviceObject,
    IN UCHAR                  MinorFunction,
    IN POWER_STATE            PowerState,
    IN PVOID                  Context,
    IN PIO_STATUS_BLOCK       IoStatus
    );

NTSTATUS
PciPdoWaitWakeCallBack(
    IN PDEVICE_OBJECT         DeviceObject,
    IN UCHAR                  MinorFunction,
    IN POWER_STATE            PowerState,
    IN PVOID                  Context,
    IN PIO_STATUS_BLOCK       IoStatus
    );

VOID
PciPdoAdjustPmeEnable(
    IN PPCI_PDO_EXTENSION         PdoExtension,
    IN BOOLEAN                Enable
    );

VOID
PciPmeClearPmeStatus(
    IN  PDEVICE_OBJECT  Pdo
    );

//
// This table is taken from the PCI spec.  The units are microseconds.

LONG PciPowerDelayTable[4][4] = {
//  D0      D1      D2      D3(Hot)
    0,      0,      200,    10000,  // D0
    0,      0,      200,    10000,  // D1
    200,    200,    0,      10000,  // D2
    10000,  10000,  10000,  0       // D3(Hot)
};


VOID
PciPdoAdjustPmeEnable(
    IN  PPCI_PDO_EXTENSION  PdoExtension,
    IN  BOOLEAN         Enable
    )

/*++

Routine Description:

    Enable or Disable the PME Enable bit for a device(function).

    Note: The PDO Extension lock is held on entry and is not released
    by this routine.

Arguments:

    PdoExtension - Pointer to the PDO Extension for the device whose
                   PME Enable bit is to be altered.

    Enable - TRUE if PME Enable is to be set, FALSE if to be cleared.

Return Value:

    None.

--*/

{
    //
    // Is the device's PME management owned by someone else?
    //
    if (PdoExtension->NoTouchPmeEnable) {

        PciDebugPrint(
            PciDbgWaitWake,
            "AdjustPmeEnable on pdox %08x but PME not owned.\n",
            PdoExtension
            );
        return;

    }

    //
    // Really update the PME signal. Note that we always need to supply
    // the 3rd argument as FALSE --- we don't want to just clear the PME
    // Status bit
    //
    PciPmeAdjustPmeEnable( PdoExtension, Enable, FALSE );
}

NTSTATUS
PciPdoIrpQueryPower(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    //
    // pass 1, claim we can do it.
    //

    //
    // ADRIAO N.B. 08/29/1999 -
    //     For D-IRPs, we do *not* want to verify the requested D-state is
    // actually supported. See PciQueryPowerCapabilities for details.
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PciPdoSetPowerState (
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpStack,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
/*++

Routine Description:

    Handles SetPower Irps send to a PCI PDO

    If the irp is an S-Irp, then do nothing

    If the irp is an D-Irp, then put the device in the appropriate state.
        Exceptions: If the device is in the hibernate path, then don't
                        actually power down if we are hibernating

Arguments:

    Irp             - The request
    IrpStack        - The current stack location
    DeviceExtension - The device that is getting powered down

Return Value:

    NTSTATUS

--*/
{
    DEVICE_POWER_STATE  desiredDeviceState;
    NTSTATUS            status;
    PPCI_PDO_EXTENSION      pdoExtension;
    POWER_ACTION        powerAction;
    POWER_STATE         powerState;

    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    status   = STATUS_SUCCESS;

    switch (IrpStack->Parameters.Power.Type) {
    case DevicePowerState:
        desiredDeviceState = IrpStack->Parameters.Power.State.DeviceState;
        powerAction = IrpStack->Parameters.Power.ShutdownType;
        break;
    case SystemPowerState:
        return STATUS_SUCCESS;
    default:
        return STATUS_NOT_SUPPORTED;
    }

    if ((desiredDeviceState == PowerDeviceD0)
        && (pdoExtension->PowerState.CurrentDeviceState == PowerDeviceD0)) {
        return STATUS_SUCCESS;
    }

#if DBG

    if ((desiredDeviceState < PowerDeviceD0) ||
        (desiredDeviceState > PowerDeviceD3)) {

        //
        // Invalid power level.
        //

        return STATUS_INVALID_PARAMETER;
    }

#endif

    //
    // If the device is trying to power down perform some sanity checks
    //

    if (desiredDeviceState > PowerDeviceD0) {

        if (pdoExtension->OnDebugPath) {
            KdPowerTransition(desiredDeviceState);
        }
        //
        // If device is currently in D0 state, capture it's command
        // register settings in case the FDO changed them since we
        // looked at them.
        //
        if (pdoExtension->PowerState.CurrentDeviceState == PowerDeviceD0) {

            PciGetCommandRegister(pdoExtension,
                                  &pdoExtension->CommandEnables);

        }

        //
        // Prevent race conditions and remember that the device is off before
        // we actually turn it off
        //
        pdoExtension->PowerState.CurrentDeviceState = desiredDeviceState;

        if (pdoExtension->DisablePowerDown) {

            //
            // Powerdown of this device disabled (based on device type).
            //
            PciDebugPrint(
                PciDbgObnoxious,
                "PCI power down of PDOx %08x, disabled, ignored.\n",
                pdoExtension
                );
            return STATUS_SUCCESS;

        }


        //
        // Device driver should likely not be powering down any device
        // that's on the hibernate path or the crashdump path
        //
        if ( powerAction == PowerActionHibernate &&
             (pdoExtension->PowerState.Hibernate || pdoExtension->PowerState.CrashDump ) ) {

            //
            // Don't actually change the device, but new device state was
            // recorded above (as if we HAD done it) so we know to reset
            // resources as the system comes up again.
            //
            return STATUS_SUCCESS;
        }

        //
        // If we are a device on the VGA path then don't turn off for shutdown so we can
        // display the "Safe to turn off your machine" screen.  For hibernate we also
        // don't want to turn off so we can display the "Dumping stuff to your disk progress
        // bar" but this is accomplished by video putting device on the video path on the hibernate
        // path.
        //

        if (IrpStack->Parameters.Power.State.DeviceState == PowerDeviceD3
        &&  (IrpStack->Parameters.Power.ShutdownType == PowerActionShutdownReset ||
             IrpStack->Parameters.Power.ShutdownType == PowerActionShutdownOff ||
             IrpStack->Parameters.Power.ShutdownType == PowerActionShutdown)
        &&  PciIsOnVGAPath(pdoExtension)) {

            return STATUS_SUCCESS;
        }

        //
        // If this device is on the debug path then don't power it down so we
        // can report if this crashes the machine...
        //

        if (pdoExtension->OnDebugPath) {
            return STATUS_SUCCESS;
        }

    } else {

        //
        // Device is powering UP.
        //
        // Verify the device is still the same as before (and that someone
        // hasn't removed/replaced it with something else)
        //
        if (!PciIsSameDevice(pdoExtension)) {

            return STATUS_NO_SUCH_DEVICE;

        }
    }

    //
    // Place the device in the proper power state
    //
    status = PciSetPowerManagedDevicePowerState(
                 pdoExtension,
                 desiredDeviceState,
                 TRUE
                 );

    //
    // If the device is transitioning to the D0 state, reset the common
    // config information on the device and inform the system of the device
    // state change.
    //
    if (desiredDeviceState == PowerDeviceD0) {
        if (NT_SUCCESS(status)) {

            pdoExtension->PowerState.CurrentDeviceState = desiredDeviceState;
            PoSetPowerState (
                pdoExtension->PhysicalDeviceObject,
                DevicePowerState,
                IrpStack->Parameters.Power.State
                );

            if (pdoExtension->OnDebugPath) {
                KdPowerTransition(PowerDeviceD0);
            }
        }

    } else {

        //
        // The new device state is something other then D0.
        // notify the system before continuing
        //
        PoSetPowerState (
            pdoExtension->PhysicalDeviceObject,
            DevicePowerState,
            IrpStack->Parameters.Power.State
            );

        //
        // Turn off the device's IO and MEMory access.
        //
        PciDecodeEnable(pdoExtension, FALSE, NULL);
        status = STATUS_SUCCESS;

    }
    return status;
}

NTSTATUS
PciPdoWaitWake(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )

/*++

Routine Description:

    Handle IRP_MN_WAIT_WAKE for PCI PDOs.

    This operation is used to wait for the device to signal a wake event.
    By waiting for a wake signal from a device, its wake event is enabled
    so long as the System Power State is above the requested SystemWake
    state.   By not waiting for a wake signal from a device, its wake
    signal is not enabled.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

    STATUS_INVALID_DEVICE_STATE, if the device is in the PowerD0 state or
        a state below which can support waking or if the SystemWake state
        is below a state which can be supported.

        A pending IRP_MN_WAIT_WAKE will complete with this error if the
        device's state is changed to be incompatible with the wake request.

    STATUS_DEVICE_BUSY, if the device already has a WAIT_WAKE request
        outstanding.  To change the SystemWake level the outstanding
        IRP must be canceled.

    STATUS_INVALID_DEVICE_REQUEST, if the device is not capable of
        signaling a wakeup.   In theory we should have gotten out
        before getting this far because DeviceWake woud be unspecified.

    STATUS_SUCCESS.  The device has signaled a WAKE event.

    STATUS_PENDING.  This is the expected return, the IRP will not
        complete until the wait is complete or cancelled.

--*/

{
    BOOLEAN             pmeCapable;
    DEVICE_POWER_STATE  devPower;
    NTSTATUS            status;
    PPCI_FDO_EXTENSION      fdoExtension;
    PIO_STACK_LOCATION  irpStack;
    PIRP                irpToParent;
    POWER_STATE         powerState;
    PPCI_PDO_EXTENSION      pdoExtension;
    ULONG               waitCount;

    pdoExtension = (PPCI_PDO_EXTENSION) DeviceExtension;

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    PoStartNextPowerIrp(Irp);

    devPower = pdoExtension->PowerState.CurrentDeviceState;

    //
    // The docs say WAIT_WAKE is allowed only from a state < D0, and
    // only if current power state supports wakeup.
    //

    ASSERT(devPower < PowerDeviceMaximum);

    if ((devPower > pdoExtension->PowerState.DeviceWakeLevel) ||
        (pdoExtension->PowerState.DeviceWakeLevel == PowerDeviceUnspecified)) {

        //
        // NTRAID #62653 - 4/28/2000 - andrewth
        // Need to add system state to conditions here.
        //

        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake: pdox %08x current state (%d) not valid for waiting\n",
            pdoExtension,
            devPower
            );

        status = STATUS_INVALID_DEVICE_STATE;
        goto PciPdoWaitWakeFailIrp;

    }

    PCI_LOCK_OBJECT(pdoExtension);

    //
    // Only one WAIT_WAKE IRP allowed.   Set THIS IRP as the wait wake
    // irp in the pdo extension, if and only if, there is no other irp
    // there.
    //

    if (pdoExtension->PowerState.WaitWakeIrp != NULL) {

        //
        // A WAIT_WAKE IRP is already pending for this device.
        //

        PCI_UNLOCK_OBJECT(pdoExtension);
        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake: pdox %08x is already waiting\n",
            devPower
            );
        status = STATUS_DEVICE_BUSY;
        goto PciPdoWaitWakeFailIrp;

    }

    //
    // Does this device support Power Management?   That is, do we
    // know how to enable PME?
    //
    PciPmeGetInformation(
        pdoExtension->PhysicalDeviceObject,
        &pmeCapable,
        NULL,
        NULL
        );
    if (pmeCapable == FALSE) {

        //
        // This device does not support Power Management.
        // Don't allow a wait wake.   In theory we couldn't
        // have gotten here because our capabilities should
        // have stopped the caller from even trying this.
        //
        PCI_UNLOCK_OBJECT(pdoExtension);
        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake: pdox %08x does not support PM\n",
            devPower
            );
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto PciPdoWaitWakeFailIrp;

    }

    fdoExtension = PCI_PARENT_FDOX(pdoExtension);
    ASSERT_PCI_FDO_EXTENSION(fdoExtension);
    if (fdoExtension->Fake) {

        //
        // Parent is really PCMCIA.sys, his filter will take care
        // of sending the wait wake to the parent,... bail out.
        //
        PCI_UNLOCK_OBJECT(pdoExtension);
        return STATUS_PENDING;

    }

    //
    // We're going to do this.  Set the wait wake irp field in the
    // pdo extension and set cancel routine for this IRP.
    //
    PciDebugPrint(
        PciDbgWaitWake,
        "WaitWake: pdox %08x setting PMEEnable.\n",
        pdoExtension
        );

    pdoExtension->PowerState.WaitWakeIrp = Irp;

    IoMarkIrpPending(Irp);

    pdoExtension->PowerState.SavedCancelRoutine =
        IoSetCancelRoutine(Irp, PciPdoWaitWakeCancelRoutine);

    //
    // NTRAID #62653 - 4/28/2000 - andrewth
    // What is the correct behaviour if there are stacked
    // cancel routines?
    //
    ASSERT(!pdoExtension->PowerState.SavedCancelRoutine);

    //
    // Set the PME Enable bit.
    //
    PciPdoAdjustPmeEnable( pdoExtension, TRUE );

    //
    // Remember that the parent now has one more child that is armed
    // for wakeup
    //
    waitCount = InterlockedIncrement(&fdoExtension->ChildWaitWakeCount);

    //
    // Once we have a wait count reference, we can unlock the object
    //
    PCI_UNLOCK_OBJECT(pdoExtension);

    //
    // This PDO is now waiting.  If this is the first child of this
    // PDO's parent bus to enter this state, the parent bus should
    // also enter this state.
    //
    if (waitCount == 1) {

        //
        // Note that there are two values that can use here, the
        // SystemWakeLevel of the FDO itself or the SystemWakeLevel of
        // the PDO. Both are equally valid, but since we want to catch people
        // who fail to prevent the system from going into a deeper sleep state
        // than their device can support, we use the SystemWakeLevel from the
        // PDO, which conviniently enough, is stored in the irp..
        //
        powerState.SystemState = IrpSp->Parameters.WaitWake.PowerState;

        //
        // Request a power irp to go to our parent stack
        //
        PoRequestPowerIrp(
            fdoExtension->FunctionalDeviceObject,
            IRP_MN_WAIT_WAKE,
            powerState,
            PciPdoWaitWakeCallBack,
            fdoExtension,
            NULL
            );

    }

    //
    // If we get to this point, then we will return pending because we
    // have queue up the request
    //
    status = STATUS_PENDING;

PciPdoWaitWakeFailIrp:
    if (!NT_SUCCESS(status)) {

        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    } else {

        ASSERT( status == STATUS_PENDING );

    }
    return status;
}

NTSTATUS
PciPdoWaitWakeCallBack(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This is the callback routine that gets invoked when the W/W irp that was
    sent to the FDO by a PDO is finished. The purpose of this routine is to
    see if we need to re-arm the W/W on the FDO because we have more devices
    with W/W outstanding on them

Arguments:

    DeviceObject        - The FDO's device object
    MinorFunction       - IRP_MN_WAIT_WAKE
    PowerState          - The sleep state that was used to wake up the system
    Context             - The FDO Extension
    IoStatus            - The Status of the request

Return Value:

    NTSTATUS

--*/
{
    BOOLEAN         pmeStatus;
    PPCI_FDO_EXTENSION  fdoExtension = (PPCI_FDO_EXTENSION) Context;
    PIRP            finishedIrp;
    PPCI_PDO_EXTENSION  pdoExtension;

    //
    // Normally, the IRP (to the PDO) will have completed with
    // STATUS_SUCCESS.  In that case, just wake up the one device
    // which is signalling for wakeup.   If the IRP to the PDO
    // failed, wake up ALL devices that are dependent on this wake.
    //

    //
    // For each child
    //
    for (pdoExtension = fdoExtension->ChildPdoList;
         pdoExtension && fdoExtension->ChildWaitWakeCount;
         pdoExtension = pdoExtension->Next) {

        //
        // Does this device do power management and if so, does
        // it have an outstanding WaitWake IRP?
        //
        PCI_LOCK_OBJECT(pdoExtension);
        if (pdoExtension->PowerState.WaitWakeIrp != NULL) {

            PciPmeGetInformation(
                pdoExtension->PhysicalDeviceObject,
                NULL,
                &pmeStatus,
                NULL
                );

            //
            // Is this device signalling for a wakeup?  (Or, if we
            // are completing wake irps because our own wait_wake
            // failed).
            //
            if (pmeStatus || !NT_SUCCESS(IoStatus->Status)) {

                //
                // Yes.  Complete its outstanding wait wake IRP.
                //

#if DBG
                if (pmeStatus) {

                    PciDebugPrint(
                        PciDbgWaitWake,
                        "PCI - pdox %08x is signalling a PME\n",
                        pdoExtension
                        );

                } else {

                    PciDebugPrint(
                        PciDbgWaitWake,
                        "PCI - waking pdox %08x because fdo wait failed %0x.\n",
                        pdoExtension,
                        IoStatus->Status
                        );
                }
#endif

                //
                // Wait_wake irp being dequeued, disable the PME enable,
                // clear PMEStatus (if set) and EOI this device.
                //
                PciPdoAdjustPmeEnable( pdoExtension, FALSE );

                //
                // Make sure this IRP will not be completed again,
                // or, canceled.
                //
                finishedIrp = pdoExtension->PowerState.WaitWakeIrp;
                pdoExtension->PowerState.WaitWakeIrp = NULL;
                IoSetCancelRoutine(finishedIrp, NULL);

                PoStartNextPowerIrp( finishedIrp );
                PciCompleteRequest(
                    finishedIrp,    // send down parent status
                    IoStatus->Status
                    );

                //
                // Decrement the waiter count.
                //
                ASSERT(fdoExtension->ChildWaitWakeCount > 0);
                InterlockedDecrement( &(fdoExtension->ChildWaitWakeCount) );

            }

        }
        PCI_UNLOCK_OBJECT(pdoExtension);

    }

    //
    // Did we succeed this irp?
    //
    if (!NT_SUCCESS(IoStatus->Status)) {

        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake (fdox %08x) - WaitWake Irp Failed %08x\n",
            fdoExtension,
            IoStatus->Status
            );
        return IoStatus->Status;

    }

    //
    // Are there any children with outstanding WaitWakes on thems?
    //
    if (fdoExtension->ChildWaitWakeCount) {

        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake (fdox %08x) - WaitWake Irp restarted - count = %x\n",
            fdoExtension,
            fdoExtension->ChildWaitWakeCount
            );

        //
        // Loop
        //
        PoRequestPowerIrp(
            DeviceObject,
            MinorFunction,
            PowerState,
            PciPdoWaitWakeCallBack,
            Context,
            NULL
            );
#if DBG
    } else {

        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake (fdox %08x) - WaitWake Irp Finished\n",
            fdoExtension
            );

#endif

    }

    //
    // Done
    //
    return STATUS_SUCCESS;
}

VOID
PciPdoWaitWakeCancelRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN OUT PIRP         Irp
    )
/*++

Routine Description:

    Cancel an outstanding WAIT_WAKE IRP.

    Note: The Cancel Spin Lock is held on entry.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    None.

--*/
{
    PPCI_PDO_EXTENSION pdoExtension;
    PPCI_FDO_EXTENSION fdoExtension;

    KIRQL oldIrql;
    ULONG waitCount;

    pdoExtension = (PPCI_PDO_EXTENSION) DeviceObject->DeviceExtension;

    PciDebugPrint(
        PciDbgWaitWake,
        "WaitWake (pdox %08x) Cancel routine, Irp %08x.\n",
        pdoExtension,
        Irp
        );

    ASSERT_PCI_PDO_EXTENSION(pdoExtension);

    oldIrql = Irp->CancelIrql;
    IoReleaseCancelSpinLock(oldIrql);

    PCI_LOCK_OBJECT(pdoExtension);

    if (pdoExtension->PowerState.WaitWakeIrp == NULL) {

        //
        // The WaitWake IRP has already been dealt with.
        //

        PCI_UNLOCK_OBJECT(pdoExtension);
        return;
    }

    //
    // Clear WaitWake Irp in the PDO.
    //

    pdoExtension->PowerState.WaitWakeIrp = NULL;

    PciPdoAdjustPmeEnable(pdoExtension, FALSE);

    //
    // As this is a cancel, the wait wake count in the parent has not
    // been decremented.   Decrement it here and if decrementing to
    // zero waiters, cancel the IRP at the parent.
    //

    fdoExtension = PCI_PARENT_FDOX(pdoExtension);

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    waitCount = InterlockedDecrement(&fdoExtension->ChildWaitWakeCount);

    PCI_UNLOCK_OBJECT(pdoExtension);

    if (waitCount == 0) {

        //
        // Cancel the parent's wait wake also.
        //

        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake (pdox %08x) zero waiters remain on parent, cancelling parent wait.\n",
            pdoExtension
            );

        IoCancelIrp(fdoExtension->PowerState.WaitWakeIrp);
    }

    //
    // Complete the IRP.
    //

    Irp->IoStatus.Information = 0;
    PoStartNextPowerIrp(Irp);
    PciCompleteRequest(Irp, STATUS_CANCELLED);

    //
    // NTRAID #62653 - 4/28/2000 - andrewth
    // Need to cause the bus parent to decrement its outstanding
    // IRP counter,... how to make this happen?
    //

    return;
}

NTSTATUS
PciFdoIrpQueryPower(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
{
    //
    // pass 1, claim we can do it.
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PciFdoSetPowerState (
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )
/*++

Routine Description:

    Handle SET_POWER irps set to an FDO

    Basic Rules for handling this:
        - If this is a DEVICE power irp, we don't need to do anything since
          for root buses and bridges, all necessary programming is done by the
          PDO
        - If this is a SYSTEM power irp, then
            a) block all incoming IRP_MN_POWER requests (using a spinlock)
            b) use the capabilities table in the device extension to determine
               what the "highest" allowed DEVICE state that we should transition
               the device into
            c) look at all the children of this device and see if we can pick a
               "lower" DEVICE state.
            d) Consideration should be granted if a child is armed for wake
               or if this device is armed for wake (in general, both should be
               true, or both should be false)
            e) Remember the answer as the "Desired State"
            f) Release the spinlock and allow other IRP_MN_POWER requests in
            g) Use PoRequestPowerIrp() to request a power irp to put the device
               in the appropriate state
            h) return STATUS_PENDING
         - In another thread context (ie: in the context of the completion
           passed to PoRequestPowerIrp), complete the irp that was handed to
           us

Arguments:

    Irp             - The Power Irp
    IrpSp           - The current stack location in the irp
    DeviceExtension - The device whose power we want to set

--*/
{
    POWER_STATE         desiredState;
    PPCI_FDO_EXTENSION      fdoExtension;
    NTSTATUS            status;
    SYSTEM_POWER_STATE  systemState;

    fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    //
    // If this is a device power irp, remember that we say it go by, and
    // remember what D-state the bus/bridge is now in. If we needed to do more
    // here, then we should have to distinguish between power up and power down
    // requests. PowerDown requests we can add the code in-line. PowerUp
    // requests would force us to set a completion routine on the IRP and do
    // the work in the completion routine
    //
    if (IrpSp->Parameters.Power.Type == DevicePowerState) {

        fdoExtension->PowerState.CurrentDeviceState =
            IrpSp->Parameters.Power.State.DeviceState;
        return STATUS_SUCCESS;

    }

    //
    // If we aren't started, don't touch the power IRP.
    //
    if (fdoExtension->DeviceState != PciStarted) {

        return STATUS_NOT_SUPPORTED;

    }

    //
    // If this isn't a SystemPowerState irp, then we don't know what it is, and
    // so we will not support it
    //
    ASSERT( IrpSp->Parameters.Power.Type == SystemPowerState );
    if (IrpSp->Parameters.Power.Type != SystemPowerState) {

        return STATUS_NOT_SUPPORTED;

    }

    //
    // If this is a Shutdown so we can warm reboot don't take the bridges to D3 as
    // if the video or boot device is behind the bridge and the BIOS doesn't power
    // things up (most don't) then we don't reboot...
    //

    if (IrpSp->Parameters.Power.State.SystemState == PowerSystemShutdown
    &&  IrpSp->Parameters.Power.ShutdownType == PowerActionShutdownReset) {

        return STATUS_SUCCESS;
    }

    //
    // Grab the system state that we want to go to
    //
    systemState = IrpSp->Parameters.Power.State.SystemState;
    ASSERT( systemState > PowerSystemUnspecified && systemState < PowerSystemMaximum );

    //
    // At this point, we can assume that we will transition the Device into a
    // least the following D-state
    //
    desiredState.DeviceState = fdoExtension->PowerState.SystemStateMapping[ systemState ];

    //
    // Mark the irp as pending
    //
    IoMarkIrpPending( Irp );

    //
    // Send a request
    //
    PoRequestPowerIrp(
        fdoExtension->FunctionalDeviceObject,
        IRP_MN_SET_POWER,
        desiredState,
        PciFdoSetPowerStateCompletion,
        Irp,
        NULL
        );
    return STATUS_PENDING;
}

VOID
PciFdoSetPowerStateCompletion(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This routine is called when the D-Irp that was requested by the FDO
    has been completed.

    This routine needs to pass the S-Irp that initiated the D-Irp all the
    way down the stack

Arguments:

    DeviceObject    - The FDO device object
    MinorFunction   - IRP_MN_SET_POWER
    PowerState      - Whatever the requested power state was
    Context         - This is really the S-Irp that requested the D-Irp
    IoStatus        - The result of the D-Irp

Return Value:

    None

--*/
{
    PPCI_FDO_EXTENSION  fdoExtension;
    PIRP            irp = (PIRP) Context;
    PIO_STACK_LOCATION irpSp;

    UNREFERENCED_PARAMETER( MinorFunction );
    UNREFERENCED_PARAMETER( PowerState );

    ASSERT( IoStatus->Status == STATUS_SUCCESS );

    //
    // Grab a pointer to the FDO extension and make sure that it is valid
    fdoExtension = (PPCI_FDO_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    irpSp = IoGetCurrentIrpStackLocation(irp);

    //
    // Check if we are returning from a hibernate and powering on the bus
    //

    if (irpSp->Parameters.Power.State.SystemState == PowerSystemWorking
    &&  fdoExtension->Hibernated) {

        fdoExtension->Hibernated = FALSE;

            //
            // Scan the bus and turn off any new hardware
            //

            PciScanHibernatedBus(fdoExtension);
        }


    if (irpSp->Parameters.Power.ShutdownType == PowerActionHibernate
    &&  irpSp->Parameters.Power.State.SystemState > PowerSystemWorking) {

            //
            // We're powering down for a hibernate so remember
            //

            fdoExtension->Hibernated = TRUE;
    }

    //
    // Mark the current irp as having succeeded
    //
    irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Start the next power irp for this device
    //
    PoStartNextPowerIrp( irp );

    //
    // Get ready to pass the power irp down the stack
    //
    IoCopyCurrentIrpStackLocationToNext( irp );

    //
    // Pass the irp down the stack
    //
    PoCallDriver( fdoExtension->AttachedDeviceObject, irp );
}

NTSTATUS
PciFdoWaitWake(
    IN PIRP                   Irp,
    IN PIO_STACK_LOCATION     IrpSp,
    IN PPCI_COMMON_EXTENSION  DeviceExtension
    )

/*++

Routine Description:

    Handle IRP_MN_WAIT_WAKE for PCI FDOs.

    PCI FDOs receive a WAIT_WAKE IRP when the number of child PDOs
    with a pending WAIT_WAKE IRP transitions from 0 to 1.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/

{
    PIO_STACK_LOCATION irpStack;
    PPCI_FDO_EXTENSION fdoExtension;
    NTSTATUS status;

    fdoExtension = (PPCI_FDO_EXTENSION) DeviceExtension;

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    irpStack = IrpSp;

    PCI_LOCK_OBJECT(fdoExtension);

    //
    // Only one WAIT_WAKE IRP allowed.   Set THIS IRP as the wait wake
    // irp in the fdo extension, if and only if, there is no other irp
    // there.
    //
    // Note: The ChildWaitWakeCount field is incremented by the PCI
    // driver before sending this IRP down.  Only accept this IRP if
    // the ChildWaitWakeCount field is one (ie don't listen to ACPI).
    //
    if (!fdoExtension->ChildWaitWakeCount) {

        //
        // Didn't come from a PCI PDO, ignore it.
        //
        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake (fdox %08x) Unexpected WaitWake IRP IGNORED.\n",
            fdoExtension
            );
        status = STATUS_DEVICE_BUSY;
        goto Cleanup;

    }
    if (fdoExtension->PowerState.WaitWakeIrp != NULL) {

        //
        // A WAIT_WAKE IRP is already pending for this device.
        //
        PciDebugPrint(
            PciDbgWaitWake,
            "WaitWake: fdox %08x already waiting (%d waiters)\n",
            fdoExtension,
            fdoExtension->ChildWaitWakeCount
            );
        status = STATUS_DEVICE_BUSY;
        goto Cleanup;

    }

    fdoExtension->PowerState.WaitWakeIrp = Irp;

    //
    // This IRP will be passed down to the underlying PDO who
    // will pend it.   The completion routine does needs to check
    // that the bus is capable of checking its children and then
    // examining each child (that has a wait wake outstanding).
    //
    PciDebugPrint(
        PciDbgWaitWake,
        "WaitWake: fdox %08x is a now waiting for a wake event\n",
        fdoExtension
        );
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(
        Irp,
        PciFdoWaitWakeCompletion,
        fdoExtension,
        TRUE,
        TRUE,
        TRUE
        );
    Irp->IoStatus.Status = status = STATUS_SUCCESS;

Cleanup:

    PCI_UNLOCK_OBJECT(fdoExtension);
    //
    // Start the next power irp
    //
    PoStartNextPowerIrp(Irp);
    if (!NT_SUCCESS(status) ) {

        PciCompleteRequest(Irp, status);
        return status;

    }

    //
    // Pass the IRP down the stack.
    //
    return PoCallDriver(fdoExtension->AttachedDeviceObject ,Irp);
}

NTSTATUS
PciFdoWaitWakeCallBack(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    This routine is called when a device has transitioned back into the
    into the D-zero state

Arguments:

    DeviceObject    - Pointer to the FDO
    MinorFunction   - IRP_MN_SET_POWER
    PowerState      - D0
    Context         - The WaitWake irp that caused us to make this transition
    IoStatus        - The status of the request

Return Value:

    NTSTATUS

--*/
{
    PIRP    waitWakeIrp = (PIRP) Context;

    UNREFERENCED_PARAMETER( MinorFunction );
    UNREFERENCED_PARAMETER( PowerState );

    //
    // Complete the wait wake irp
    //
    PoStartNextPowerIrp( waitWakeIrp );
    PciCompleteRequest( waitWakeIrp, IoStatus->Status );

    //
    // Done
    //
    return IoStatus->Status;
}

VOID
PciFdoWaitWakeCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    Cancel an outstanding WAIT_WAKE IRP.

    Note: The Cancel Spin Lock is held on entry.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    None.

--*/

{
    PPCI_FDO_EXTENSION fdoExtension;
    NTSTATUS status;
    KIRQL oldIrql;

    fdoExtension = (PPCI_FDO_EXTENSION)DeviceObject->DeviceExtension;

    PciDebugPrint(
        PciDbgWaitWake,
        "WaitWake (fdox %08x) Cancel routine, Irp %08x.\n",
        fdoExtension,
        Irp
        );

    ASSERT_PCI_FDO_EXTENSION(fdoExtension);

    oldIrql = Irp->CancelIrql;

    IoReleaseCancelSpinLock(oldIrql);

    PCI_LOCK_OBJECT(fdoExtension);
    if (fdoExtension->PowerState.WaitWakeIrp == NULL) {

        //
        // The WaitWake IRP has already been dealt with.
        //
        PCI_UNLOCK_OBJECT(fdoExtension);
        return;

    }
    fdoExtension->PowerState.WaitWakeIrp = NULL;
    PCI_UNLOCK_OBJECT(fdoExtension);

    Irp->IoStatus.Information = 0;
    PoStartNextPowerIrp(Irp);
    PciCompleteRequest(Irp, STATUS_CANCELLED);

    return;
}

NTSTATUS
PciFdoWaitWakeCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PPCI_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    Handle IRP_MN_WAIT_WAKE completion for PCI FDOs.

    WAIT_WAKE completion at the FDO means some device (not necesarily
    a child of this FDO) is signalling wake.  This routine scans each
    child to see if that device is the one.   This is a recursive
    operation.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/

{
    POWER_STATE powerState;

    PciDebugPrint(
        PciDbgWaitWake,
        "WaitWake (fdox %08x) Completion routine, Irp %08x, IrpStatus = %08x.\n",
        FdoExtension,
        Irp,
        Irp->IoStatus.Status
        );

    ASSERT_PCI_FDO_EXTENSION(FdoExtension);

    //
    // We will need the device's lock for some of the following...
    //
    PCI_LOCK_OBJECT(FdoExtension);
    ASSERT (FdoExtension->PowerState.WaitWakeIrp);

    //
    // We no longer have a WaitWake irp in the the FDO...
    //
    FdoExtension->PowerState.WaitWakeIrp = NULL;

    //
    // Check the bus is at a power level at which the config space
    // of its children can be examined.
    //
    // NTRAID #62653 - 4/28/2000 - andrewth
    //
    // Question: Should we depend on PO to take care of this requirement?
    // can we use PO to do the needed power state changes?
    //
    // Assumption: The parent of this bus is powered at this moment.
    //
    if (FdoExtension->PowerState.CurrentDeviceState != PowerDeviceD0) {

        powerState.SystemState = PowerDeviceD0;

        //
        // Power up the bus.
        //
        PoRequestPowerIrp(
            DeviceObject,
            IRP_MN_SET_POWER,
            powerState,
            PciFdoWaitWakeCallBack,
            Irp,
            NULL
            );
        PCI_UNLOCK_OBJECT(FdoExtension);
        return STATUS_MORE_PROCESSING_REQUIRED;

    }

    //
    // Done with lock
    //
    PCI_UNLOCK_OBJECT(FdoExtension);
    return STATUS_SUCCESS;
}

NTSTATUS
PciStallForPowerChange(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN DEVICE_POWER_STATE PowerState,
    IN UCHAR PowerCapabilityPointer
    )
{
    NTSTATUS status = STATUS_DEVICE_PROTOCOL_ERROR;
    PVERIFIER_DATA verifierData;
    LONG delay;
    ULONG retries = 100;
    KIRQL irql;
    PCI_PMCSR pmcsr;

    ASSERT(PdoExtension->PowerState.CurrentDeviceState >= PowerDeviceD0
           && PdoExtension->PowerState.CurrentDeviceState <= PowerDeviceD3);
    ASSERT(PowerState >= PowerDeviceD0 && PowerState <= PowerDeviceD3);
    ASSERT(!(PdoExtension->HackFlags & PCI_HACK_NO_PM_CAPS));

    //
    // Lookup the delay we are meant to do as in the PCI spec
    //

    delay = PciPowerDelayTable[PdoExtension->PowerState.CurrentDeviceState-1][PowerState-1];

    //
    // Stall in a polite fashion if IRQL allows
    //

    irql = KeGetCurrentIrql();

    while (retries--) {

        if (delay > 0) {

            if (irql < DISPATCH_LEVEL) {

                //
                // Get off the processor.
                //
                // timeoutPeriod is in units of 100ns, negative means
                // relative.
                //

                LARGE_INTEGER timeoutPeriod;

                timeoutPeriod.QuadPart = -10 * delay;
                timeoutPeriod.QuadPart -= (KeQueryTimeIncrement() - 1);

                KeDelayExecutionThread(KernelMode,
                                       FALSE,
                                       &timeoutPeriod
                                        );
            } else {

                //
                // Spin, units are microseconds
                //

                KeStallExecutionProcessor((ULONG)delay);
            }
        }

        //
        // Reread the status and control register.  The assumption here is that
        // some cards don't get their act together fast enough and the fact that
        // they arn't ready yet is reflected by them not updating the power control
        // register with what we just wrote to it.  This is not in the PCI spec
        // but is how some of these broken cards work and it can't hurt...
        //

        PciReadDeviceConfig(
            PdoExtension,
            &pmcsr,
            PowerCapabilityPointer + FIELD_OFFSET(PCI_PM_CAPABILITY,PMCSR),
            sizeof(PCI_PMCSR)
            );


        //
        // Pci power states are 0-3 where as NT power states are 1-4
        //

        if (pmcsr.PowerState == PowerState-1) {

            //
            // Device is ready, we're done.
            //
            return STATUS_SUCCESS;
        }

        //
        // Subsequent iterations, delay 1ms.
        //

        delay = 1000;

    }

    //
    // So how nasty can this sort of problem be?
    //
    // If this is an ATI M1 (mobile video) and on some machines under some
    // circumstances (and no ATI doesn't know which ones) they disable the
    // operation of the PMCSR.  It would have been nice if they had just
    // removed the PM capability from the list so we would have never
    // attempted to power manage this chip but they would have failed
    // WHQL.  Unfortunately it is not possible to just add these to the
    // list of devices that have bad PM because some BIOSes (read HP and
    // Dell) monitor this register to save extra state from the chip and
    // thus if we don't change it we spin in AML forever.
    //
    // Yes this is a gross hack.
    //
    verifierData = PciVerifierRetrieveFailureData(
        PCI_VERIFIER_PMCSR_TIMEOUT
        );

    ASSERT(verifierData);

    VfFailDeviceNode(
        PdoExtension->PhysicalDeviceObject,
        PCI_VERIFIER_DETECTED_VIOLATION,
        PCI_VERIFIER_PMCSR_TIMEOUT,
        verifierData->FailureClass,
        &verifierData->Flags,
        verifierData->FailureText,
        "%DevObj%Ulong",
        PdoExtension->PhysicalDeviceObject,
        PowerState-1
        );

    return status;
}


NTSTATUS
PciSetPowerManagedDevicePowerState(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN DEVICE_POWER_STATE DeviceState,
    IN BOOLEAN RefreshConfigSpace
    )

/*++

Routine Description:

    If the PCI device supports the PCI Power Management extensions,
    set the device to the desired state.   Otherwise, this routine
    does (can do) nothing.

Arguments:

    PdoExtension    Pointer to the PDO device extension for the device
                    being programmed. The current power state stored
                    in the extension is *not* updated by this function.

    DeviceState     Power state the device is to be set to.

Return Value:

    None.

--*/

{
    PCI_PM_CAPABILITY   pmCap;
    UCHAR               pmCapPtr = 0;
    NTSTATUS            status = STATUS_SUCCESS;

    //
    // If we are standing by then we want to power down the video to preseve the batteries,
    // we have already (in PdoPdoSetPoweState) decided to leave the video on for the hibernate
    // and shutdown cases.
    //

    if ((!PciCanDisableDecodes(PdoExtension, NULL, 0, PCI_CAN_DISABLE_VIDEO_DECODES)) &&
        (DeviceState != PowerDeviceD0)) {

        //
        // Here is a device we unfortunately can't turn off. We do not however
        // convert this to D0 - the virtual state of the device will represent
        // a powered down device, and only when a real D0 is requested will we
        // restore all the various state.
        //
        return STATUS_SUCCESS;
    }

    if (!(PdoExtension->HackFlags & PCI_HACK_NO_PM_CAPS) ) {

        pmCapPtr = PciReadDeviceCapability(
           PdoExtension,
           PdoExtension->CapabilitiesPtr,
           PCI_CAPABILITY_ID_POWER_MANAGEMENT,
           &pmCap,
           sizeof(pmCap)
           );

        if (pmCapPtr == 0) {
            //
            // We don't have a power management capability - how did we get here?
            //
            ASSERT(pmCapPtr);
            return STATUS_INVALID_DEVICE_REQUEST;

        }

        //
        // Set the device into its new D state
        //
        switch (DeviceState) {
        case PowerDeviceD0:
            pmCap.PMCSR.ControlStatus.PowerState = 0;

            //
            // PCI Power Management Specification. Table-7. Page 25
            //
            if (pmCap.PMC.Capabilities.Support.PMED3Cold) {

                pmCap.PMCSR.ControlStatus.PMEStatus = 1;

            }
            break;
        case PowerDeviceUnspecified:
            ASSERT( DeviceState != PowerDeviceUnspecified);
            pmCapPtr = 0;
            break;
        default:
            pmCap.PMCSR.ControlStatus.PowerState = (DeviceState - 1);
            break;
        }

        if (pmCapPtr) {

            PciWriteDeviceConfig(
                PdoExtension,
                &pmCap.PMCSR.ControlStatus,
                pmCapPtr + FIELD_OFFSET(PCI_PM_CAPABILITY,PMCSR.ControlStatus),
                sizeof(pmCap.PMCSR.ControlStatus)
                );

        } else {

            //
            // Debug only. ControlFlags should have been set so this
            // can't happen.
            //
            ASSERT(pmCapPtr);

        }

        //
        // Stall for the appropriate time
        //

        status = PciStallForPowerChange(PdoExtension, DeviceState, pmCapPtr);
    }

    //
    // Only update the config space if:
    //      - The device is happy and in the correct power state
    //      - We have been asked to refresh the config space
    //      - We have powered up the device
    //

    if (NT_SUCCESS(status)
    &&  RefreshConfigSpace
    &&  DeviceState < PdoExtension->PowerState.CurrentDeviceState) {
        status = PciSetResources(PdoExtension, TRUE, FALSE);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\pciverifier.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    pciverifier.c

Abstract:

    This module implements routines used to catch BIOS, hardware, and driver
    bugs.

Author:

    Adrian J. Oney (AdriaO) 02/20/2001

Revision History:

--*/

#include "pcip.h"
#include <initguid.h>
#include <wdmguid.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,     PciVerifierInit)
#pragma alloc_text(PAGE,     PciVerifierUnload)
//#pragma alloc_text(PAGEVRFY, PciVerifierProfileChangeCallback)
//#pragma alloc_text(PAGEVRFY, PciVerifierEnsureTreeConsistancy)
//#pragma alloc_text(PAGEVRFY, PciVerifierRetrieveFailureData)
#endif

BOOLEAN PciVerifierRegistered = FALSE;

#ifdef ALLOC_DATA_PRAGMA
//#pragma data_seg("PAGEVRFD")
#endif

PVOID PciVerifierNotificationHandle = NULL;

//
// This is the table of PCI verifier failures
//
VERIFIER_DATA PciVerifierFailureTable[] = {

    { PCI_VERIFIER_BRIDGE_REPROGRAMMED, VFFAILURE_FAIL_LOGO,
      0,
      "The BIOS has reprogrammed the bus numbers of an active PCI device "
      "(!devstack %DevObj) during a dock or undock!" },

    { PCI_VERIFIER_PMCSR_TIMEOUT, VFFAILURE_FAIL_LOGO,
      0,
      "A device in the system did not update it's PMCSR register in the spec "
      "mandated time (!devstack %DevObj, Power state D%Ulong)" },

    { PCI_VERIFIER_PROTECTED_CONFIGSPACE_ACCESS, VFFAILURE_FAIL_LOGO,
      0,
      "A driver controlling a PCI device has tried to access OS controlled "
      "configuration space registers (!devstack %DevObj, Offset 0x%Ulong1, "
      "Length 0x%Ulong2)" },
    
    { PCI_VERIFIER_INVALID_WHICHSPACE, VFFAILURE_FAIL_UNDER_DEBUGGER,
      0,
      "A driver controlling a PCI device has tried to read or write from "
      "an invalid space using IRP_MN_READ/WRITE_CONFIG or via BUS_INTERFACE_STANDARD.  "
      "NB: These functions take WhichSpace parameters of the form PCI_WHICHSPACE_* "
      "and not a BUS_DATA_TYPE (!devstack %DevObj, WhichSpace 0x%Ulong1)" }

};


VOID
PciVerifierInit(
    IN  PDRIVER_OBJECT  DriverObject
    )
/*++

Routine Description:

    This routine initializes the hardware verification support, enabling
    consistancy hooks and state checks where appropriate.

Arguments:

    DriverObject - Pointer to our driver object.

Return Value:

    None.

--*/
{
    NTSTATUS status;

    if (!VfIsVerificationEnabled(VFOBJTYPE_SYSTEM_BIOS, NULL)) {

        return;
    }

    status = IoRegisterPlugPlayNotification(
        EventCategoryHardwareProfileChange,
        0,
        NULL,
        DriverObject,
        PciVerifierProfileChangeCallback,
        (PVOID) NULL,
        &PciVerifierNotificationHandle
        );

    if (NT_SUCCESS(status)) {

        PciVerifierRegistered = TRUE;
    }
}


VOID
PciVerifierUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
/*++

Routine Description:

    This routine uninitializes the hardware verification support.

Arguments:

    DriverObject - Pointer to our driver object.

Return Value:

    None.

--*/
{
    NTSTATUS status;

    UNREFERENCED_PARAMETER(DriverObject);

    if (!PciVerifierRegistered) {

        return;
    }

    ASSERT(PciVerifierNotificationHandle);

    status = IoUnregisterPlugPlayNotification(PciVerifierNotificationHandle);

    ASSERT(NT_SUCCESS(status));

    PciVerifierRegistered = FALSE;
}


NTSTATUS
PciVerifierProfileChangeCallback(
    IN  PHWPROFILE_CHANGE_NOTIFICATION  NotificationStructure,
    IN  PVOID                           NotUsed
    )
/*++

Routine Description:

    This routine gets called back during hardware profile change events if
    hardware verification is enabled.

Arguments:

    NotificationStructure - Describes the hardware profile event that occured.

    NotUsed - Not used

Return Value:

    NTSTATUS.

--*/
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(NotUsed);

    if (IsEqualGUID((LPGUID) &NotificationStructure->Event,
                    (LPGUID) &GUID_HWPROFILE_CHANGE_COMPLETE)) {

        //
        // This is a HW profile change complete message. Do some tests to
        // ensure our hardware hasn't been reprogrammed behind our back.
        //
        PciVerifierEnsureTreeConsistancy();
    }

    return STATUS_SUCCESS;
}


VOID
PciVerifierEnsureTreeConsistancy(
    VOID
    )
/*++

Routine Description:

    This routine checks the device tree and ensures it's physical state matches
    the virtual state described by our structures. A deviation may mean someone
    has reprogrammed the hardware behind our back.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PSINGLE_LIST_ENTRY  nextEntry;
    PPCI_FDO_EXTENSION  fdoExtension;
    PPCI_PDO_EXTENSION  pdoExtension;
    PCI_COMMON_CONFIG   commonConfig;
    PVERIFIER_DATA      verifierData;

    //
    // Walk the list of FDO extensions and verifier the physical hardware
    // matches our virtual state. Owning the PciGlobalLock ensures the list
    // is locked.
    //

    ExAcquireFastMutex(&PciGlobalLock);

    //
    // Grab the bus renumbering lock. Note that this lock can be held when
    // child list locks are held.
    //

    ExAcquireFastMutex(&PciBusLock);

    for ( nextEntry = PciFdoExtensionListHead.Next;
          nextEntry != NULL;
          nextEntry = nextEntry->Next ) {

        fdoExtension = CONTAINING_RECORD(nextEntry, PCI_FDO_EXTENSION, List);

        if (PCI_IS_ROOT_FDO(fdoExtension)) {

            //
            // It's a root FDO, ignore it.
            //
            continue;
        }

        pdoExtension = PCI_BRIDGE_PDO(fdoExtension);

        if (pdoExtension->NotPresent ||
            (pdoExtension->PowerState.CurrentDeviceState == PowerDeviceD3)) {

            //
            // Don't touch.
            //
            continue;
        }

        if ((pdoExtension->HeaderType != PCI_BRIDGE_TYPE) &&
            (pdoExtension->HeaderType != PCI_CARDBUS_BRIDGE_TYPE)) {

            //
            // Nothing to verify - in fact, why are here, this is a bridge list!
            //
            ASSERT(0);
            continue;
        }

        //
        // Read in the common config (that should be enough)
        //
        PciReadDeviceConfig(
            pdoExtension,
            &commonConfig,
            0,
            sizeof(PCI_COMMON_CONFIG)
            );

        //
        // Ensure bus numbers haven't changed. Note that P2P and Cardbus
        // bridges have their Primary, Secondary & Subordinate fields in the
        // same place.
        //
        if ((commonConfig.u.type1.PrimaryBus !=
             pdoExtension->Dependent.type1.PrimaryBus) ||
            (commonConfig.u.type1.SecondaryBus !=
             pdoExtension->Dependent.type1.SecondaryBus) ||
            (commonConfig.u.type1.SubordinateBus !=
             pdoExtension->Dependent.type1.SubordinateBus)) {

            verifierData = PciVerifierRetrieveFailureData(
                PCI_VERIFIER_BRIDGE_REPROGRAMMED
                );

            ASSERT(verifierData);

            VfFailSystemBIOS(
                PCI_VERIFIER_DETECTED_VIOLATION,
                PCI_VERIFIER_BRIDGE_REPROGRAMMED,
                verifierData->FailureClass,
                &verifierData->Flags,
                verifierData->FailureText,
                "%DevObj",
                pdoExtension->PhysicalDeviceObject
                );
        }
    }

    ExReleaseFastMutex(&PciBusLock);

    ExReleaseFastMutex(&PciGlobalLock);
}


PVERIFIER_DATA
PciVerifierRetrieveFailureData(
    IN  PCI_VFFAILURE   VerifierFailure
    )
/*++

Routine Description:

    This routine retrieves the failure data corresponding to a particular PCI
    verifier failure event.

Arguments:

    PCI Failure.

Return Value:

    Verifier data corresponding to the failure.

--*/
{
    PVERIFIER_DATA verifierData;
    ULONG i;

    for(i=0;
        i<(sizeof(PciVerifierFailureTable)/sizeof(PciVerifierFailureTable[0]));
        i++) {

        verifierData = PciVerifierFailureTable + i;

        if (verifierData->VerifierFailure == VerifierFailure) {

            return verifierData;
        }
    }

    ASSERT(0);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\pciverifier.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    pciverifier.h

Abstract:

    This header contains prototypes for hardware state verification.

Author:

    Adrian J. Oney (AdriaO) 02/20/2001

--*/

//
// The following definitions are external to pciverifier.c
//
VOID
PciVerifierInit(
    IN  PDRIVER_OBJECT  DriverObject
    );

VOID
PciVerifierUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

//
// This is the list of PCI verifier failures.
//
typedef enum {

    PCI_VERIFIER_BRIDGE_REPROGRAMMED = 1,
    PCI_VERIFIER_PMCSR_TIMEOUT,
    PCI_VERIFIER_PROTECTED_CONFIGSPACE_ACCESS,
    PCI_VERIFIER_INVALID_WHICHSPACE

} PCI_VFFAILURE, *PPCI_VFFAILURE;

//
// This structure specifies table elements used when failing hardware, bioses,
// or drivers.
//
typedef struct {

    PCI_VFFAILURE       VerifierFailure;
    VF_FAILURE_CLASS    FailureClass;
    ULONG               Flags;
    PSTR                FailureText;

} VERIFIER_DATA, *PVERIFIER_DATA;

PVERIFIER_DATA
PciVerifierRetrieveFailureData(
    IN  PCI_VFFAILURE   VerifierFailure
    );

//
// These definitions are *internal* to pciverifier.c
//
NTSTATUS
PciVerifierProfileChangeCallback(
    IN  PHWPROFILE_CHANGE_NOTIFICATION  NotificationStructure,
    IN  PVOID                           NotUsed
    );

VOID
PciVerifierEnsureTreeConsistancy(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\ppbridge.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    ppbridge.c

Abstract:

    This module contains functions associated with enumerating
    PCI to PCI bridges.

Author:

    Peter Johnston (peterj) 12-Feb-1997

Revision History:

--*/

#include "pcip.h"

BOOLEAN
PciBridgeIsPositiveDecode(
    IN PPCI_PDO_EXTENSION Pdo
    );

BOOLEAN
PciBridgeIsSubtractiveDecode(
    IN PPCI_CONFIGURABLE_OBJECT This
    );

ULONG
PciBridgeIoBase(
    IN  PPCI_COMMON_CONFIG  Config
    );

ULONG
PciBridgeIoLimit(
    IN  PPCI_COMMON_CONFIG  Config
    );

ULONG
PciBridgeMemoryBase(
    IN  PPCI_COMMON_CONFIG  Config
    );

ULONG
PciBridgeMemoryLimit(
    IN  PPCI_COMMON_CONFIG  Config
    );

PHYSICAL_ADDRESS
PciBridgePrefetchMemoryBase(
    IN  PPCI_COMMON_CONFIG  Config
    );

PHYSICAL_ADDRESS
PciBridgePrefetchMemoryLimit(
    IN  PPCI_COMMON_CONFIG  Config
    );


#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, PciBridgeIoBase)
#pragma alloc_text(PAGE, PciBridgeIoLimit)
#pragma alloc_text(PAGE, PciBridgeMemoryBase)
#pragma alloc_text(PAGE, PciBridgeMemoryLimit)
#pragma alloc_text(PAGE, PciBridgePrefetchMemoryBase)
#pragma alloc_text(PAGE, PciBridgePrefetchMemoryLimit)
#pragma alloc_text(PAGE, PPBridge_MassageHeaderForLimitsDetermination)
#pragma alloc_text(PAGE, PPBridge_RestoreCurrent)
#pragma alloc_text(PAGE, PPBridge_SaveLimits)
#pragma alloc_text(PAGE, PPBridge_SaveCurrentSettings)
#pragma alloc_text(PAGE, PPBridge_GetAdditionalResourceDescriptors)
#pragma alloc_text(PAGE, PciBridgeIsPositiveDecode)

#endif

ULONG
PciBridgeIoBase(
    IN  PPCI_COMMON_CONFIG  Config
    )

/*++

Routine Description:

    Compute the 32 bit base IO address being passed by the bridge
    whose config space is at Config.

    The IO base address is always 4KB aligned.  If only 64KB IO
    address space is supported, this is represented in the upper
    nibble of Config->u.type1.IOBase giving the range 0 to 0xf000
    for the base address.  The low nibble of Config->u.type1.IOBase
    contains flags.  If the least significant bit is set, then the
    bridge supports IO addressing to 4GB and Config->u.type1.IOBaseUpper16
    contains the upper 16 bits of the base address.

Arguments:

    Config - Pointer to a buffer containing the device's common (type1)
    configuration header.

Return Value:

    ULONG containing the IO Base address.

--*/

{
    BOOLEAN io32Bit = (Config->u.type1.IOBase & 0x0f) == 1;
    ULONG   base    = (Config->u.type1.IOBase & 0xf0) << 8;

    ASSERT(PciGetConfigurationType(Config) == PCI_BRIDGE_TYPE);

    if (io32Bit) {
        base |= Config->u.type1.IOBaseUpper16 << 16;

        //
        // Check h/w (base and limit must be the same bit width).
        //

        ASSERT(Config->u.type1.IOLimit & 0x1);
    }
    return base;
}

ULONG
PciBridgeIoLimit(
    IN  PPCI_COMMON_CONFIG  Config
    )

/*++

Routine Description:

    Compute the 32 bit IO address limit being passed by the bridge
    whose config space is at Config.

    The range of IO addresses being passed is always a multiple of 4KB
    therefore the least significant 12 bits of the address limit are
    always 0xfff.  The upper nibble of Config->u.type1.IOLimit provides
    the next significant 4 bits.  The lower nibble of this byte contains
    flags.  If the least significant bit is set, the bridge is capable of
    passing 32 bit IO addresses and the next 16 significant bits are
    obtained from Config->u.type1.IOLimitUpper16.

Arguments:

    Config - Pointer to a buffer containing the device's common (type1)
    configuration header.

Return Value:

    ULONG containing the IO address limit.

--*/

{
    BOOLEAN io32Bit = (Config->u.type1.IOLimit & 0x0f) == 1;
    ULONG   limit   = (Config->u.type1.IOLimit & 0xf0) << 8;

    ASSERT(PciGetConfigurationType(Config) == PCI_BRIDGE_TYPE);

    if (io32Bit) {
        limit |= Config->u.type1.IOLimitUpper16 << 16;

        //
        // Check h/w (base and limit must be the same bit width).
        //

        ASSERT(Config->u.type1.IOBase & 0x1);
    }
    return limit | 0xfff;
}

ULONG
PciBridgeMemoryBase(
    IN  PPCI_COMMON_CONFIG  Config
    )

/*++

Routine Description:

    Compute the 32 bit base Memory address being passed by the bridge
    whose config space is at Config.

    The Memory base address is always 1MB aligned.

Arguments:

    Config - Pointer to a buffer containing the device's common (type1)
    configuration header.

Return Value:

    ULONG containing the Memory Base address.

--*/

{
    ASSERT(PciGetConfigurationType(Config) == PCI_BRIDGE_TYPE);

    //
    // The upper 12 bits of the memory base address are contained in
    // the upper 12 bits of the USHORT Config->u.type1.MemoryBase.
    //

    return Config->u.type1.MemoryBase << 16;
}

ULONG
PciBridgeMemoryLimit(
    IN  PPCI_COMMON_CONFIG  Config
    )

/*++

Routine Description:

    Compute the 32 bit Memory address limit being passed by the bridge
    whose config space is at Config.

    The memory limit is always at the byte preceeding a 1MB boundary.
    The upper 12 bits of the limit address are contained in the upper
    12 bits of Config->u.type1.MemoryLimit, the lower 20 bits are all
    ones.

Arguments:

    Config - Pointer to a buffer containing the device's common (type1)
    configuration header.

Return Value:

    ULONG containing the Memory limit.

--*/

{
    ASSERT(PciGetConfigurationType(Config) == PCI_BRIDGE_TYPE);

    return (Config->u.type1.MemoryLimit << 16) | 0xfffff;
}

PHYSICAL_ADDRESS
PciBridgePrefetchMemoryBase(
    IN  PPCI_COMMON_CONFIG  Config
    )

/*++

Routine Description:

    Compute the 64 bit base Prefetchable Memory address being passed
    by the bridge whose config space is at Config.

    The Prefetchable Memory base address is always 1MB aligned.

Arguments:

    Config - Pointer to a buffer containing the device's common (type1)
    configuration header.

Return Value:

    PHYSICAL_ADDRESS containing the Prefetchable Memory Base address.

--*/

{
    BOOLEAN          prefetch64Bit;
    PHYSICAL_ADDRESS base;

    ASSERT(PciGetConfigurationType(Config) == PCI_BRIDGE_TYPE);

    prefetch64Bit = (Config->u.type1.PrefetchBase & 0x000f) == 1;

    base.QuadPart = 0;

    base.LowPart = (Config->u.type1.PrefetchBase & 0xfff0) << 16;

    if (prefetch64Bit) {
        base.HighPart = Config->u.type1.PrefetchBaseUpper32;
    }

    return base;
}

PHYSICAL_ADDRESS
PciBridgePrefetchMemoryLimit(
    IN  PPCI_COMMON_CONFIG  Config
    )

/*++

Routine Description:

    Compute the 64 bit Prefetchable Memory address limit being passed
    by the bridge whose config space is at Config.

    The prefetchable memory limit is always at the byte preceeding a
    1MB boundary, that is, the least significant 20 bits are all ones.
    The next 12 bits are obtained from the upper 12 bits of
    Config->u.type1.PrefetchLimit.  The botton 4 bits of that field
    provide a flag indicating whether the upper 32 bits should be obtained
    from Config->u.type1.PrefetchLimitUpper32 or should be 0.

Arguments:

    Config - Pointer to a buffer containing the device's common (type1)
    configuration header.

Return Value:

    PHYSICAL_ADDRESS containing the prefetchable memory limit.

--*/

{
    BOOLEAN          prefetch64Bit;
    PHYSICAL_ADDRESS limit;

    ASSERT(PciGetConfigurationType(Config) == PCI_BRIDGE_TYPE);

    prefetch64Bit = (Config->u.type1.PrefetchLimit & 0x000f) == 1;

    limit.LowPart = (Config->u.type1.PrefetchLimit & 0xfff0) << 16;
    limit.LowPart |= 0xfffff;

    if (prefetch64Bit) {
        limit.HighPart = Config->u.type1.PrefetchLimitUpper32;
    } else {
        limit.HighPart = 0;
    }

    return limit;
}

ULONG
PciBridgeMemoryWorstCaseAlignment(
    IN ULONG Length
    )
/*

Description:

    This function calculates the maximum alignment a device can have if it is
    behind a bridge with a memory window of Length.  This turns out to be finding
    the top bit set in the length.

Arguments:

    Length - the size of the memory window

Return Value:

    The alignment

*/
{
    ULONG alignment = 0x80000000;

    if (Length == 0) {
        ASSERT(Length != 0);
        return 0;
    }

    while (!(Length & alignment)) {
        alignment >>= 1;
    }

    return alignment;
}

VOID
PPBridge_MassageHeaderForLimitsDetermination(
    IN IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    The configuration header for a PCI to PCI bridge has two BARs
    and three range descriptors (IO, Memory and Prefetchable Memory).

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    Returns status indicating the success or failure of this routine.

    The Working configuration has been modified so that all range
    fields have been set to their maximum possible values.

    The Current configuration has been modified such that writing it
    to the hardware will restore the hardware to it's current (disabled)
    state.

--*/

{
    PUCHAR fStart;
    ULONG  fLength;

    //
    // Set BARs and ranges to all ones in the working copy.  Note
    // that the method used will overwrite some other values that
    // need to be restored before going any further.
    //

    fStart = (PUCHAR)&This->Working->u.type1.BaseAddresses;
    fLength  = FIELD_OFFSET(PCI_COMMON_CONFIG,u.type1.CapabilitiesPtr) -
               FIELD_OFFSET(PCI_COMMON_CONFIG,u.type1.BaseAddresses[0]);

    RtlFillMemory(fStart, fLength, 0xff);

    //
    // Restore Primary/Secondary/Subordinate bus numbers and
    // Secondary Latency from the "Current" copy.  (All four
    // are byte fields in the same ULONG so cheat).
    //

    *(PULONG)&This->Working->u.type1.PrimaryBus =
        *(PULONG)&This->Current->u.type1.PrimaryBus;

    //
    // Set the ROM to its maximum as well,... and disable it.
    //

    This->Working->u.type0.ROMBaseAddress =
        0xffffffff & ~PCI_ROMADDRESS_ENABLED;

    This->PrivateData = This->Current->u.type1.SecondaryStatus;
    This->Current->u.type1.SecondaryStatus = 0;
    This->Working->u.type1.SecondaryStatus = 0;

    return;
}

VOID
PPBridge_RestoreCurrent(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Restore any type specific fields in the original copy of config
    space.   In the case of PCI-PCI bridges, the secondary status field.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    This->Current->u.type1.SecondaryStatus = (USHORT)(This->PrivateData);
}

VOID
PPBridge_SaveLimits(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Fill in the Limit structure with a IO_RESOURCE_REQUIREMENT
    for each implemented BAR.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    ULONG index;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PPCI_COMMON_CONFIG working = This->Working;
    PULONG bar = working->u.type1.BaseAddresses;
    PHYSICAL_ADDRESS limit;

    descriptor = This->PdoExtension->Resources->Limit;

    //
    // Create an IO_RESOURCE_DESCRIPTOR for each implemented
    // resource supported by this function.
    //

    for (index = 0; index < PCI_TYPE1_ADDRESSES; index++) {
        if (PciCreateIoDescriptorFromBarLimit(descriptor, bar, FALSE)) {

            //
            // This base address register is 64 bit, skip one.
            //

            ASSERT((index+1) < PCI_TYPE1_ADDRESSES);

            index++;
            bar++;

            //
            // Null descriptor in place holder.
            //

            descriptor++;
            descriptor->Type = CmResourceTypeNull;
        }
        descriptor++;
        bar++;
    }

    //
    // Check if we support subtractive decode (if we do then clear the VGA and
    // ISA bits as they don't mean anything for subtractive bridges)
    //

    if (PciBridgeIsSubtractiveDecode(This)) {
        This->PdoExtension->Dependent.type1.SubtractiveDecode = TRUE;
        This->PdoExtension->Dependent.type1.VgaBitSet = FALSE;
        This->PdoExtension->Dependent.type1.IsaBitSet = FALSE;
    }

    //
    // Skip the bridge windows for a subtractive bridge
    //

    if (!This->PdoExtension->Dependent.type1.SubtractiveDecode) {

        for (index = PciBridgeIo;
             index < PciBridgeMaxPassThru;
             index++, descriptor++) {

            limit.HighPart = 0;
            descriptor->u.Generic.MinimumAddress.QuadPart = 0;

            switch (index) {
            case PciBridgeIo:

                //
                // Get I/O Limit.
                //
                //

                ASSERT(working->u.type1.IOLimit != 0);

                //
                // IO Space is implemented by the bridge, calculate
                // the real limit.
                //
                // The IOLimit field is one byte, the upper nibble of
                // which represents the 4096 byte block number of the
                // highest 4096 byte block that can be addressed by
                // this bridge.  The highest addressable byte is 4095
                // bytes higher.
                //

                limit.LowPart = PciBridgeIoLimit(working);

                //
                // The lower nibble is a flag.  The least significant bit
                // indicates that this bridge supports I/O ranges up to
                // 4GB and the other bits are currently reserved.
                //

                ASSERT((working->u.type1.IOLimit & 0x0e) == 0);

                descriptor->Type = CmResourceTypePort;
                descriptor->Flags = CM_RESOURCE_PORT_IO
                                  | CM_RESOURCE_PORT_POSITIVE_DECODE
                                  | CM_RESOURCE_PORT_WINDOW_DECODE;
                descriptor->u.Generic.Alignment = 0x1000;

                break;

            case PciBridgeMem:

                //
                // Get Memory Limit.  Memory limit is not optional on a bridge.
                // It is a 16 bit field in which only the upper 12 bits are
                // implemented, the lower 4 bits MUST be zero.
                //

                limit.LowPart = PciBridgeMemoryLimit(working);

                ASSERT((working->u.type1.MemoryLimit & 0xf) == 0);

                descriptor->Type = CmResourceTypeMemory;
                descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
                descriptor->u.Generic.Alignment = 0x100000;

                break;

            case PciBridgePrefetch:

                //
                // Get Prefetchable memory limit.
                //

                if (working->u.type1.PrefetchLimit != 0) {

                    //
                    // Prefetchable memory is implemented by this bridge.
                    //

                    limit = PciBridgePrefetchMemoryLimit(working);

                } else {

                    //
                    // prefetchable memory not implemented on this bridge.
                    //

                    descriptor->Type = CmResourceTypeNull;
                    continue;
                }
                descriptor->Type = CmResourceTypeMemory;
                descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE |
                                    CM_RESOURCE_MEMORY_PREFETCHABLE;;
                descriptor->u.Generic.Alignment = 0x100000;

                break;

            }
            descriptor->u.Generic.MinimumAddress.QuadPart = 0;
            descriptor->u.Generic.MaximumAddress = limit;

            //
            // Length is meaningless here.
            //

            descriptor->u.Generic.Length = 0;
        }
    }

    //
    // Do the BAR thing for the ROM if its active
    //

    if (!(This->Current->u.type1.ROMBaseAddress & PCI_ROMADDRESS_ENABLED)) {
        return;
    }

    PciCreateIoDescriptorFromBarLimit(descriptor,
                                      &working->u.type1.ROMBaseAddress,
                                      TRUE);
}

VOID
PPBridge_SaveCurrentSettings(
    IN PPCI_CONFIGURABLE_OBJECT This
    )

/*++

Description:

    Fill in the Resource array in the PDO extension with the current
    settings for each implemented BAR.

    Also, fill in the PDO Extension's Dependent structure.

Arguments:

    This    - Pointer to a PCI driver "configurable" object.  This
              object contains configuration data for the function
              currently being configured.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    ULONG index;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor;
    PPCI_COMMON_CONFIG current;
    ULONG bar;
    PHYSICAL_ADDRESS base;
    PHYSICAL_ADDRESS limit;
    PHYSICAL_ADDRESS length;
    BOOLEAN zeroBaseOk;
    BOOLEAN updateAlignment;
    PCI_COMMON_HEADER biosConfigBuffer;
    PPCI_COMMON_CONFIG biosConfig = (PPCI_COMMON_CONFIG) &biosConfigBuffer;

    partial = This->PdoExtension->Resources->Current;
    ioResourceDescriptor = This->PdoExtension->Resources->Limit;

    //
    // Check if the device has either IO or Memory enabled
    //

    if (This->Command & (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE)) {

        //
        // It does so use the real current settings
        //

        current = This->Current;

    } else {

        //
        // Check if we have a bios config
        //

        status = PciGetBiosConfig(This->PdoExtension, biosConfig);

        if (NT_SUCCESS(status)) {

            //
            // Ok - this is a bit gross but until multi level/multi arbiter
            // rebalance working this will have to do.  We use the initial bios
            // configuration config space to record the current settings.  The
            // current settings is used for responding to the QUERY_RESOURCES
            // and the QUERY_RESOURCE_REQUIREMENTS.  We want to have the original
            // requirements be reported as the preferred location for this
            // bridge and, more importantly, for the original window sizes to
            // be used. We do not however want to report this as the resources
            // currently being decoded as they arn't but we have already checked
            // that the decodes of the device are off so PciQueryResources will
            // not report these.
            //

            current = biosConfig;

        } else {

            //
            // This is a bridge disabled by the BIOS (or one it didn't see) so
            // minimal requirements are likely...
            //

            current = This->Current;

        }

    }


    //
    // Create an IO_RESOURCE_DESCRIPTOR for each implemented
    // resource supported by this function.
    //

    for (index = 0;
         index < PCI_TYPE1_RANGE_COUNT;
         index++, partial++, ioResourceDescriptor++) {

        partial->Type = ioResourceDescriptor->Type;

        //
        // If this entry is not implemented, no further processing for
        // this partial descriptor.
        //

        if (partial->Type == CmResourceTypeNull) {
            continue;
        }

        partial->Flags = ioResourceDescriptor->Flags;
        partial->ShareDisposition = ioResourceDescriptor->ShareDisposition;
        base.HighPart = 0;

        //
        // Depending on where we are in the 'set' we have to look
        // at the data differently.
        //
        // In a header type 1, there are two BARs, I/O limit and
        // base, Memory limit and base, prefetchable limit and base
        // and a ROM BAR.
        //

        if ((index < PCI_TYPE1_ADDRESSES) ||
            (index == (PCI_TYPE1_RANGE_COUNT-1))) {

            ULONG addressMask;

            //
            // Handle BARs
            //

            if (index < PCI_TYPE1_ADDRESSES) {
                bar = current->u.type1.BaseAddresses[index];

                if ((bar & PCI_ADDRESS_IO_SPACE) != 0) {
                    addressMask = PCI_ADDRESS_IO_ADDRESS_MASK;
                } else {
                    addressMask = PCI_ADDRESS_MEMORY_ADDRESS_MASK;
                    if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_64BIT) {
                        //
                        // 64 bit address, consume next BAR.
                        //

                        base.HighPart = current->u.type1.BaseAddresses[index+1];
                    }
                }
            } else {
                bar = current->u.type1.ROMBaseAddress;
                addressMask = PCI_ADDRESS_ROM_ADDRESS_MASK;
            }
            base.LowPart = bar & addressMask;

            //
            // Copy the length from the limits descriptor.
            //

            partial->u.Generic.Length = ioResourceDescriptor->u.Generic.Length;

        } else {

            //
            // It's one of the base/limit pairs (each a different format).
            //

            limit.HighPart = 0;
            zeroBaseOk = FALSE;
            updateAlignment = FALSE;

            switch (index - PCI_TYPE1_ADDRESSES + PciBridgeIo) {
            case PciBridgeIo:

                //
                // Get I/O range.
                //
                //

                base.LowPart  = PciBridgeIoBase(current);
                limit.LowPart = PciBridgeIoLimit(current);

                if (base.LowPart == 0) {
                    if (This->Working->u.type1.IOLimit != 0) {

                        //
                        // The bridge's IO IObase and IOlimit are both
                        // zero but the maximum setting of IOlimit is
                        // non-zero.   This means the bridge is decoding
                        // IO addresses 0 thru 0xfff.
                        //

                        zeroBaseOk = TRUE;
                    }
                }
                break;

            case PciBridgeMem:

                //
                // Get Memory range.
                //

                base.LowPart  = PciBridgeMemoryBase(current);
                limit.LowPart = PciBridgeMemoryLimit(current);
                updateAlignment = TRUE;

                break;

            case PciBridgePrefetch:


                ASSERT(partial->Flags & CM_RESOURCE_MEMORY_PREFETCHABLE);

                //
                // Get Prefetchable memory range.
                //

                base  = PciBridgePrefetchMemoryBase(current);
                limit = PciBridgePrefetchMemoryLimit(current);
                updateAlignment = TRUE;

                break;
            }

            if ((ULONGLONG)base.QuadPart > (ULONGLONG)limit.QuadPart) {

                //
                // This resource is disabled - remove the current setting AND
                // the requirement
                //
                partial->Type = CmResourceTypeNull;
                ioResourceDescriptor->Type = CmResourceTypeNull;
                continue;

            } else if (((base.QuadPart == 0) && (!zeroBaseOk))) {

                //
                // This resource is not currently being bridged.
                //

                partial->Type = CmResourceTypeNull;
                continue;
            }

            length.QuadPart = limit.QuadPart - base.QuadPart + 1;
            ASSERT(length.HighPart == 0);
            partial->u.Generic.Length = length.LowPart;

            if (updateAlignment) {

                //
                // We don't know what the alignment requirements for the bridge
                // are because that is dependent on the requirements of the
                // childen of the bridge which we haven't enumerated yet, so
                // we use the maximal alignment that a child could have based
                // on the size of the bridge window.  We don't need to do this
                // for IO requirements because the alignment requirements of
                // the bridge are greater than or equal to any child.
                //

                ASSERT(partial->u.Generic.Length > 0);
                ioResourceDescriptor->u.Generic.Alignment =
                    PciBridgeMemoryWorstCaseAlignment(partial->u.Generic.Length);

            }
        }
        partial->u.Generic.Start = base;
    }

    //
    // Up until this point we might have been using the bios config but we need
    // to know the real current settings for thr bus number registers and the
    // bridge control register so undo the falsification here
    //

    current = This->Current;

    //
    // Save the header specific data in the PDO.
    //

    This->PdoExtension->Dependent.type1.PrimaryBus =
        current->u.type1.PrimaryBus;
    This->PdoExtension->Dependent.type1.SecondaryBus =
        current->u.type1.SecondaryBus;
    This->PdoExtension->Dependent.type1.SubordinateBus =
        current->u.type1.SubordinateBus;


    if (!This->PdoExtension->Dependent.type1.SubtractiveDecode) {

        //
        // If the VGA bit is set in the bridge control register, we
        // will be passing an additional memory range and a bunch of
        // IO ranges, possibly in conflict with the normal ranges.
        //
        // If this is going to be the case, BuildRequirementsList needs
        // to know to allocate a bunch of additional resources.
        //
        // How many?  One Memory range 0xa0000 thru 0xbffff plus IO
        // ranges 3b0 thru 3bb and 3c0 thru 3df AND every 10 bit alias
        // to these in the possible 16 bit IO space.
        //
        // However, it turns out there's this neat flag so we can
        // tell IO that this resource uses 10 bit decode so we only
        // need to build the two IO port resources.
        //

        if (current->u.type1.BridgeControl & PCI_ENABLE_BRIDGE_VGA) {

            This->PdoExtension->AdditionalResourceCount =
                1 + // Device Private
                1 + // Memory
                2;  // Io
            This->PdoExtension->Dependent.type1.VgaBitSet = TRUE;
        }

        This->PdoExtension->Dependent.type1.IsaBitSet =
            (current->u.type1.BridgeControl & PCI_ENABLE_BRIDGE_ISA) != 0;

    } else {

        ASSERT(!This->PdoExtension->Dependent.type1.VgaBitSet);
        ASSERT(!This->PdoExtension->Dependent.type1.IsaBitSet);
    }

#if INTEL_ICH_HACKS

    if (PCI_IS_INTEL_ICH(This->PdoExtension)) {
    
        PPCI_FDO_EXTENSION fdo;

        fdo = PCI_PARENT_FDOX(This->PdoExtension);

        fdo->IchHackConfig = ExAllocatePool(NonPagedPool, PCI_COMMON_HDR_LENGTH);
        if (!fdo->IchHackConfig) {
            //
            // Um - we're screwed
            //
            return;
        }

        RtlCopyMemory(fdo->IchHackConfig, This->Current, PCI_COMMON_HDR_LENGTH);

    }

#endif

}

VOID
PPBridge_ChangeResourceSettings(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    )
{
    ULONG index;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    ULONG bar;
    ULONG lowPart;
    ULONG limit;
    PHYSICAL_ADDRESS bigLimit;
#if DBG
    BOOLEAN has32BitIo = ((CommonConfig->u.type1.IOBase & 0xf) == 1);
#endif


    if (PCI_IS_INTEL_ICH(PdoExtension)) {
        
        //
        // If this is an ICH then copy back how it was configured before. 
        // Yes this is a vile hack.
        //

        PPCI_FDO_EXTENSION fdo = PCI_PARENT_FDOX(PdoExtension);
        
        ASSERT(!PdoExtension->Resources);

        CommonConfig->u.type1.IOBase = fdo->IchHackConfig->u.type1.IOBase;
        CommonConfig->u.type1.IOLimit = fdo->IchHackConfig->u.type1.IOLimit;
        CommonConfig->u.type1.MemoryBase = fdo->IchHackConfig->u.type1.MemoryBase;
        CommonConfig->u.type1.MemoryLimit = fdo->IchHackConfig->u.type1.MemoryLimit;
        CommonConfig->u.type1.PrefetchBase = fdo->IchHackConfig->u.type1.PrefetchBase;
        CommonConfig->u.type1.PrefetchLimit = fdo->IchHackConfig->u.type1.PrefetchLimit;
        CommonConfig->u.type1.PrefetchBaseUpper32 = fdo->IchHackConfig->u.type1.PrefetchBaseUpper32;
        CommonConfig->u.type1.PrefetchLimitUpper32 = fdo->IchHackConfig->u.type1.PrefetchLimitUpper32;
        CommonConfig->u.type1.IOBaseUpper16 = fdo->IchHackConfig->u.type1.IOBaseUpper16;
        CommonConfig->u.type1.IOLimitUpper16 = fdo->IchHackConfig->u.type1.IOLimitUpper16;
    
    } else {

        //
        // Close the bridge windows and only open them is appropriate resources
        // have been assigned
        //
    
        CommonConfig->u.type1.IOBase = 0xff;
        CommonConfig->u.type1.IOLimit = 0x0;
        CommonConfig->u.type1.MemoryBase = 0xffff;
        CommonConfig->u.type1.MemoryLimit = 0x0;
        CommonConfig->u.type1.PrefetchBase = 0xffff;
        CommonConfig->u.type1.PrefetchLimit = 0x0;
        CommonConfig->u.type1.PrefetchBaseUpper32 = 0;
        CommonConfig->u.type1.PrefetchLimitUpper32 = 0;
        CommonConfig->u.type1.IOBaseUpper16 = 0;
        CommonConfig->u.type1.IOLimitUpper16 = 0;

    }

    if (PdoExtension->Resources) {

        partial = PdoExtension->Resources->Current;

        for (index = 0;
             index < PCI_TYPE1_RANGE_COUNT;
             index++, partial++) {

            //
            // If this entry is not implemented, no further processing for
            // this partial descriptor.
            //

            if (partial->Type == CmResourceTypeNull) {
                continue;
            }

            lowPart = partial->u.Generic.Start.LowPart;

            //
            // Depending on where we are in the 'set' we have to look
            // at the data differently.
            //
            // In a header type 1, there are two BARs, I/O limit and
            // base, Memory limit and base, prefetchable limit and base
            // and a ROM BAR.
            //

            if ((index < PCI_TYPE1_ADDRESSES) ||
                (index == (PCI_TYPE1_RANGE_COUNT-1))) {

                //
                // Handle BARs
                //
                if (index < PCI_TYPE1_ADDRESSES) {
                    bar = CommonConfig->u.type1.BaseAddresses[index];

                    if (partial->Type == CmResourceTypeMemory){
                    
                        if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_64BIT) {

                            //
                            // 64 bit address, set upper 32 bits in next bar.
                            //
                            ASSERT(index == 0);
                            ASSERT((partial+1)->Type == CmResourceTypeNull);
    
                            CommonConfig->u.type1.BaseAddresses[1] =
                                partial->u.Generic.Start.HighPart;
#if DBG

                        } else if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_20BIT) {

                            //
                            // This device must locate below 1MB, make sure we're
                            // configuring it that way.
                            //
    
                            ASSERT((lowPart & 0xfff00000) == 0);
#endif
                        }
                        
                    }

                    CommonConfig->u.type1.BaseAddresses[index] = lowPart;

                } else {

                    ASSERT(partial->Type == CmResourceTypeMemory);

                    bar = CommonConfig->u.type1.ROMBaseAddress;
                    bar &= ~PCI_ADDRESS_ROM_ADDRESS_MASK;
                    bar |= (lowPart & PCI_ADDRESS_ROM_ADDRESS_MASK);
                    CommonConfig->u.type0.ROMBaseAddress = bar;
                }

            } else {

                //
                // It's one of the base/limit pairs (each a different format).
                //

                limit = lowPart - 1 + partial->u.Generic.Length;

                switch (index - PCI_TYPE1_ADDRESSES + PciBridgeIo) {
                case PciBridgeIo:

                    //
                    // Set I/O range.
                    //
                    //

#if DBG

                    ASSERT(((lowPart & 0xfff) == 0) && ((limit & 0xfff) == 0xfff));

                    if (!has32BitIo) {
                        ASSERT(((lowPart | limit) & 0xffff0000) == 0);
                    }

#endif

                    CommonConfig->u.type1.IOBaseUpper16  = (USHORT)(lowPart >> 16);
                    CommonConfig->u.type1.IOLimitUpper16 = (USHORT)(limit   >> 16);

                    CommonConfig->u.type1.IOBase  = (UCHAR)((lowPart >> 8) & 0xf0);
                    CommonConfig->u.type1.IOLimit = (UCHAR)((limit   >> 8) & 0xf0);
                    break;

                case PciBridgeMem:

                    //
                    // Set Memory range.
                    //

                    ASSERT(((lowPart & 0xfffff) == 0) &&
                           ((limit & 0xfffff) == 0xfffff));

                    CommonConfig->u.type1.MemoryBase = (USHORT)(lowPart >> 16);
                    CommonConfig->u.type1.MemoryLimit =
                        (USHORT)((limit >> 16) & 0xfff0);
                    break;

                case PciBridgePrefetch:

                    //
                    // Set Prefetchable memory range.
                    //

                    bigLimit.QuadPart = partial->u.Generic.Start.QuadPart - 1 +
                                        partial->u.Generic.Length;

                    ASSERT(((lowPart & 0xfffff) == 0) &&
                            (bigLimit.LowPart & 0xfffff) == 0xfffff);

                    CommonConfig->u.type1.PrefetchBase = (USHORT)(lowPart >> 16);
                    CommonConfig->u.type1.PrefetchLimit =
                        (USHORT)((bigLimit.LowPart >> 16) & 0xfff0);

                    CommonConfig->u.type1.PrefetchBaseUpper32 =
                        partial->u.Generic.Start.HighPart;

                    CommonConfig->u.type1.PrefetchLimitUpper32 = bigLimit.HighPart;
                    break;
                }
            }
        }
    }

    //
    // Restore the bridge's PCI bus #'s
    //

    CommonConfig->u.type1.PrimaryBus =
        PdoExtension->Dependent.type1.PrimaryBus;
    CommonConfig->u.type1.SecondaryBus =
        PdoExtension->Dependent.type1.SecondaryBus;
    CommonConfig->u.type1.SubordinateBus =
        PdoExtension->Dependent.type1.SubordinateBus;

    //
    // Set the bridge control register bits we might have changes
    //

    if (PdoExtension->Dependent.type1.IsaBitSet) {
        CommonConfig->u.type1.BridgeControl |= PCI_ENABLE_BRIDGE_ISA;
    }

    if (PdoExtension->Dependent.type1.VgaBitSet) {
        CommonConfig->u.type1.BridgeControl |= PCI_ENABLE_BRIDGE_VGA;
    }

}

VOID
PPBridge_GetAdditionalResourceDescriptors(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig,
    IN PIO_RESOURCE_DESCRIPTOR Resource
    )
{
    //
    // If this bridge is has the ISA or VGA bits set in its Bridge
    // Control Register, or is doing subtractive decoding, now would
    // be a good time to add the descriptors.
    //

#define SET_RESOURCE(type, minimum, maximum, flags)             \
                                                                \
        Resource->Type = type;                                  \
        Resource->Flags = flags;                                \
        Resource->u.Generic.Length = (maximum) - (minimum) + 1; \
        Resource->u.Generic.Alignment = 1;                      \
        Resource->u.Generic.MinimumAddress.QuadPart = minimum;  \
        Resource->u.Generic.MaximumAddress.QuadPart = maximum;  \
        Resource++;

    if (CommonConfig->u.type1.BridgeControl & PCI_ENABLE_BRIDGE_VGA) {

        //
        // Add VGA ranges.
        //
        // These are memory from 0xA0000 thru 0xBFFFF, and IO ranges
        // 3b0 thru 3bb and 3c0 thru 3df.   These will be passed
        // regardless of the memory and IO range settings but IS
        // controlled by the Memory and IO command register bits.
        //
        // Note: It's also going to do any 10 bit alias to the two
        // IO ranges.
        //
        // First, indicate that the rest of the list is not for
        // generic processing.
        //

        Resource->Type = CmResourceTypeDevicePrivate;
        Resource->u.DevicePrivate.Data[0] = PciPrivateSkipList;
        Resource->u.DevicePrivate.Data[1] = 3; // count to skip
        Resource++;

        //
        // Set the memory descriptor.
        //

        SET_RESOURCE(CmResourceTypeMemory, 0xa0000, 0xbffff, 0);

        //
        // Do the two IO ranges AND their aliases positive decode.
        //

        SET_RESOURCE(CmResourceTypePort,
                     0x3b0,
                     0x3bb,
                     CM_RESOURCE_PORT_10_BIT_DECODE | CM_RESOURCE_PORT_POSITIVE_DECODE);
        SET_RESOURCE(CmResourceTypePort,
                     0x3c0,
                     0x3df,
                     CM_RESOURCE_PORT_10_BIT_DECODE | CM_RESOURCE_PORT_POSITIVE_DECODE);
    }
    return;

#undef SET_RESOURCE

}

NTSTATUS
PPBridge_ResetDevice(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG CommonConfig
    )
{
    USHORT  bridgeControl;

    //
    // Only reset if device is not enabled and a reset is necessary
    //

    if (CommonConfig->Command == 0 && (PdoExtension->HackFlags & PCI_HACK_RESET_BRIDGE_ON_POWERUP)) {

        //
        // We should never have powered down a device on the debug path so we should
        // never have to reset it on the way back up... but you never know!
        //

        ASSERT(!PdoExtension->OnDebugPath);

        PciReadDeviceConfig(
            PdoExtension,
            &bridgeControl,
            FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.BridgeControl),
            sizeof(bridgeControl)
            );

        bridgeControl |= PCI_ASSERT_BRIDGE_RESET;

        PciWriteDeviceConfig(
            PdoExtension,
            &bridgeControl,
            FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.BridgeControl),
            sizeof(bridgeControl)
            );

        //
        // Per PCI 2.1, reset must remain asserted for a minimum
        // of 100 us.
        //

        KeStallExecutionProcessor(100);

        bridgeControl &= ~PCI_ASSERT_BRIDGE_RESET;

        PciWriteDeviceConfig(
            PdoExtension,
            &bridgeControl,
            FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.BridgeControl),
            sizeof(bridgeControl)
            );
    }

    return STATUS_SUCCESS;
}

BOOLEAN
PciBridgeIsSubtractiveDecode(
    IN PPCI_CONFIGURABLE_OBJECT This
    )
{

    ASSERT(This->Current->BaseClass == 0x6 && This->Current->SubClass == 0x4);

    //
    // Bridges are subtractive if their programming interface of 0x1 or we
    // have the appropriate hack flag set.
    //
    // They are also subtractive if the IO Limit register isn't sticky (we tried
    // to write 0xFF to it (see MassageHeader) but the top nibble which is meant
    // to be sticky did't stick).
    //
    // By tradition (NT4/Win9x) this means that the bridge performs subtractive
    // decode of both memory and IO.Unfortunatly the PCI spec says that IO in
    // bridges is optional and so if anyone builds a bridge that doesn't do IO
    // then we will think they have subtractive IO.  One might think that the
    // non-optional memory limit register would have been a better choice but
    // seeing as this is how it works so lets be consistent.
    //

    if (!((This->PdoExtension->HackFlags & PCI_HACK_SUBTRACTIVE_DECODE)
           || (This->Current->ProgIf == 0x1)
           || ((This->Working->u.type1.IOLimit & 0xf0) != 0xf0))) {

        //
        // This is a positive decode bridge
        //
        return FALSE;
    }

    //
    // Intel built a device that claims to be a PCI-PCI bridge - it is actually
    // a hublink-PCI bridge.  It operates like a PCI-PCI bridge only that it
    // subtractively decodes all unclaimed cycles not in the bridge window.
    // Yes so it is positive and subtractive at the same time - we can support
    // this in a later release using partial arbitration but its too late for
    // that now.  It would be nice is we could detect such bridges - perhaps
    // with a Programming Interface of 2.
    //
    // We are giving the OEM a choice - they can have a positive window and
    // operate just like a normal PCI-PCI bridge (and thus can use peer-peer
    // trafic) OR they cah operate like a subtractive PCI-PCI bridge (so ISA
    // like devices (eg PCMCIA, PCI Sound Cards) work but peer-peer doesn't)).
    //
    // Given that most machines will want the subtractive mode, we default to
    // that using the hack table (and this code relies on the correct entries
    // being in said table).  If the OEM wants to enfore positive decode
    // they add an ACPI control method under the parent of the bridge.  This
    // method is a package that enumerates to a list of _ADR style slot numbers
    // for each the bridge we should treat as a vanila PCI-PCI bridge.
    //
    // Note this is only tried for the hublink bridges we know about.
    //

    if (This->PdoExtension->VendorId == 0x8086
    &&  (This->PdoExtension->DeviceId == 0x2418
        || This->PdoExtension->DeviceId == 0x2428
        || This->PdoExtension->DeviceId == 0x244E
        || This->PdoExtension->DeviceId == 0x2448)
        ) {

        //
        // Run the PDEC method if its present
        //

        if (PciBridgeIsPositiveDecode(This->PdoExtension)) {

            PciDebugPrint(
                PciDbgInformative,
                "Putting bridge in positive decode because of PDEC\n"
            );

            return FALSE;

        }
    }

    PciDebugPrint(
        PciDbgInformative,
        "PCI : Subtractive decode on Bus 0x%x\n",
        This->Current->u.type1.SecondaryBus
        );

    //
    // Force us to update the hardware and thus close the windows if necessary.
    //

    This->PdoExtension->UpdateHardware = TRUE;

    return TRUE;

}

BOOLEAN
PciBridgeIsPositiveDecode(
    IN PPCI_PDO_EXTENSION Pdo
    )
/*++

Description:

    Determines if a PCI-PCI bridge device performs positive decode even though
    it says subtractive (either ProfIf=1 or from a hack flag).  This is currently
    only the Intel ICH.

Arguments:

    Pdo - The PDO extension for the bridge

Return Value:

    TRUE - the bridge performs positive decode, FASLE it does not

--*/
{
    return PciIsSlotPresentInParentMethod(Pdo, (ULONG)'CEDP');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\pmeintf.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    gpeintf.c

Abstract:

    This module implements the "PME" interfaces supported
    by the PCI driver.

Author:

    Stephane Plante (splante) Feb-1-1999

Revision History:

--*/

#include "pcip.h"

NTSTATUS
PciPmeInterfaceConstructor(
    PVOID       DeviceExtension,
    PVOID       PciInterface,
    PVOID       InterfaceSpecificData,
    USHORT      Version,
    USHORT      Size,
    PINTERFACE  InterfaceReturn
    );

VOID
PciPmeInterfaceDereference(
    IN PVOID Context
    );

NTSTATUS
PciPmeInterfaceInitializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

VOID
PciPmeInterfaceReference(
    IN PVOID Context
    );

VOID
PciPmeUpdateEnable(
    IN  PDEVICE_OBJECT   Pdo,
    IN  BOOLEAN          PmeEnable
    );

//
// Define the Pci PME interface "interface" structure
//
PCI_INTERFACE PciPmeInterface = {
    &GUID_PCI_PME_INTERFACE,        // Interface Type
    sizeof(PCI_PME_INTERFACE),      // Mininum Size
    PCI_PME_INTRF_STANDARD_VER,     // Minimum Version
    PCI_PME_INTRF_STANDARD_VER,     // Maximum Version
    PCIIF_FDO | PCIIF_ROOT,         // Flags
    0,                              // ReferenceCount
    PciInterface_PmeHandler,        // Signature
    PciPmeInterfaceConstructor,     // Constructor
    PciPmeInterfaceInitializer      // Instance Initializer
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciPmeInterfaceConstructor)
#pragma alloc_text(PAGE, PciPmeInterfaceDereference)
#pragma alloc_text(PAGE, PciPmeInterfaceInitializer)
#pragma alloc_text(PAGE, PciPmeInterfaceReference)
#endif


VOID
PciPmeAdjustPmeEnable(
    IN  PPCI_PDO_EXTENSION  PdoExtension,
    IN  BOOLEAN         Enable,
    IN  BOOLEAN         ClearStatusOnly
    )
/*++

Routine Description:

    This is the only routine in the the PCI driver that is allowed to set
    the PME Enable pin for a device.

Arguments:

    PdoExtension    - The device that wants to have the PME enable set
    Enable          - Turn on the PME pin or not
    ClearStatusOnly - Only clear the status --- ignore the Enable bit

Return Value:

    VOID

--*/
{
    PCI_PM_CAPABILITY   pmCap;
    UCHAR               pmCapPtr     = 0;

    //
    // Are there any pm capabilities?
    //
    if (!(PdoExtension->HackFlags & PCI_HACK_NO_PM_CAPS) ) {

        pmCapPtr = PciReadDeviceCapability(
            PdoExtension,
            PdoExtension->CapabilitiesPtr,
            PCI_CAPABILITY_ID_POWER_MANAGEMENT,
            &pmCap,
            sizeof(pmCap)
            );

    }
    if (pmCapPtr == 0) {

        return;

    }

    //
    // Set or clear the PMEEnable bit depending on the value of Enable
    //
    if (!ClearStatusOnly) {

        pmCap.PMCSR.ControlStatus.PMEEnable = (Enable != 0);

    }

    //
    // Write back what we read to clear the PME Status.
    //
    PciWriteDeviceConfig(
        PdoExtension,
        &(pmCap.PMCSR.ControlStatus),
        pmCapPtr + FIELD_OFFSET(PCI_PM_CAPABILITY, PMCSR.ControlStatus),
        sizeof(pmCap.PMCSR.ControlStatus)
        );
}

VOID
PciPmeClearPmeStatus(
    IN  PDEVICE_OBJECT  Pdo
    )
/*++

Routine Description:

    This routine explicitly clears the PME status bit from a device

Arguments:

    Pdo - The device whose pin we are to clear

Return Value:

    VOID

--*/
{
    PPCI_PDO_EXTENSION  pdoExtension = (PPCI_PDO_EXTENSION) Pdo->DeviceExtension;

    ASSERT_PCI_PDO_EXTENSION( pdoExtension );

    //
    // Call the Adjust function to do the actual work. Note that passing
    // in the 3rd argument as TRUE means that the 2nd argument is ignored
    //
    PciPmeAdjustPmeEnable( pdoExtension, FALSE, TRUE );
}

VOID
PciPmeGetInformation(
    IN  PDEVICE_OBJECT  Pdo,
    OUT PBOOLEAN    PmeCapable,
    OUT PBOOLEAN    PmeStatus,
    OUT PBOOLEAN    PmeEnable
    )
/*++

Routine Description:

    Supplies the information regarding a PDO's PME capabilities

Arguments:

    Pdo         - The device object whose capabilities we care about
    PmeCapable  - Can the device generate a PME?
    PmeStatus   - Is the PME status for the device on?
    PmeEnable   - Is the PME enable for the device on?

Return Value:

    None

--*/
{
    BOOLEAN             pmeCapable   = FALSE;
    BOOLEAN             pmeEnable    = FALSE;
    BOOLEAN             pmeStatus    = FALSE;
    NTSTATUS            status;
    PCI_PM_CAPABILITY   pmCap;
    PPCI_PDO_EXTENSION      pdoExtension = (PPCI_PDO_EXTENSION) Pdo->DeviceExtension;
    UCHAR               pmCapPtr     = 0;

    ASSERT_PCI_PDO_EXTENSION( pdoExtension );

    //
    // Get the current power management capabilities from the device
    //
    if (!(pdoExtension->HackFlags & PCI_HACK_NO_PM_CAPS) ) {

        pmCapPtr = PciReadDeviceCapability(
            pdoExtension,
            pdoExtension->CapabilitiesPtr,
            PCI_CAPABILITY_ID_POWER_MANAGEMENT,
            &pmCap,
            sizeof(pmCap)
            );

    }

    if (pmCapPtr == 0) {

        //
        // No Pdo capabilities
        //
        goto PciPmeGetInformationExit;

    }

    //
    // At this point, we are found to be PME capable
    //
    pmeCapable = TRUE;

    //
    // Are enabled for PME?
    //
    if (pmCap.PMCSR.ControlStatus.PMEEnable == 1) {

        pmeEnable = TRUE;

    }

    //
    // Is the PME Status pin set?
    //
    if (pmCap.PMCSR.ControlStatus.PMEStatus == 1) {

        pmeStatus = TRUE;

    }

PciPmeGetInformationExit:

    if (PmeCapable != NULL) {

        *PmeCapable = pmeCapable;

    }
    if (PmeStatus != NULL) {

        *PmeStatus = pmeStatus;

    }
    if (PmeEnable != NULL) {

        *PmeEnable = pmeEnable;

    }
    return;

}

NTSTATUS
PciPmeInterfaceConstructor(
    PVOID       DeviceExtension,
    PVOID       PciInterface,
    PVOID       InterfaceSpecificData,
    USHORT      Version,
    USHORT      Size,
    PINTERFACE  InterfaceReturn
    )
/*++

Routine Description:

    Initialize the PCI_PME_INTERFACE fields.

Arguments:

    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    InterfaceSpecificData

    InterfaceReturn

Return Value:

    Status

--*/

{
    PPCI_PME_INTERFACE   standard   = (PPCI_PME_INTERFACE) InterfaceReturn;

    switch(Version) {
    case PCI_PME_INTRF_STANDARD_VER:
        standard->GetPmeInformation  = PciPmeGetInformation;
        standard->ClearPmeStatus     = PciPmeClearPmeStatus;
        standard->UpdateEnable       = PciPmeUpdateEnable;
        break;
    default:
        return STATUS_NOINTERFACE;
    }

    standard->Size                  = sizeof( PCI_PME_INTERFACE );
    standard->Version               = Version;
    standard->Context               = DeviceExtension;
    standard->InterfaceReference    = PciPmeInterfaceReference;
    standard->InterfaceDereference  = PciPmeInterfaceDereference;
    return STATUS_SUCCESS;
}

VOID
PciPmeInterfaceDereference(
    IN PVOID Context
    )
{
    return;
}

NTSTATUS
PciPmeInterfaceInitializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )
/*++

Routine Description:

    For bus interface, does nothing, shouldn't actually be called.

Arguments:

    Instance        Pointer to the PDO extension.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERTMSG("PCI PciPmeInterfaceInitializer, unexpected call.", 0);
    return STATUS_UNSUCCESSFUL;
}

VOID
PciPmeInterfaceReference(
    IN PVOID Context
    )
{
    return;
}

VOID
PciPmeUpdateEnable(
    IN  PDEVICE_OBJECT   Pdo,
    IN  BOOLEAN          PmeEnable
    )
/*++

Routine Description:

    This routine sets or clears the PME Enable bit on the specified
    device object

Arguments:

    Pdo         - The device object whose PME enable we care about
    PmeEnable   - Wether or not we should enable PME on the device

Return Value:

    None

--*/
{
    PPCI_PDO_EXTENSION  pdoExtension    = (PPCI_PDO_EXTENSION) Pdo->DeviceExtension;

    ASSERT_PCI_PDO_EXTENSION( pdoExtension );

    //
    // Mark the device as not having its PME managed by PCI any more...
    //
    pdoExtension->NoTouchPmeEnable = 1;

    //
    // Call the interface that does the real work. Note that we always need
    // to supply the 3rd argument as FALSE --- we don't to just clear the
    // PME Status bit
    //
    PciPmeAdjustPmeEnable( pdoExtension, PmeEnable, FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\romimage.c ===
/*++
Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    romimage.c

Abstract:

    This module contains the code required to obtain a copy of a
    device's ROM (Read Only Memory).

    The PCI spec allows a device to share address decoding logic
    between the ROM BAR (Base Address Registers) and other BARs.
    Effectively, this means the ROM cannot be accessed at the same
    time as the device is otherwise operating.

    The ROM is accesible when both the ROM enabled bit is set and
    memory decoding is enabled.

Author:

    Peter Johnston  (peterj)    15-Apr-1998

Revision History:

--*/


#include "pcip.h"

extern pHalTranslateBusAddress PcipSavedTranslateBusAddress;

typedef struct _PCI_ROM_HEADER {
    USHORT  Signature;
    UCHAR   RsvdArchitectureUnique[0x16];
    USHORT  DataStructureOffset;
} PCI_ROM_HEADER, *PPCI_ROM_HEADER;

typedef struct _PCI_DATA_STRUCTURE {
    ULONG   Signature;
    USHORT  VendorId;
    USHORT  DeviceId;
    USHORT  VitalProductDataOffset;
    USHORT  DataStructureLength;
    UCHAR   DataStructureRevision;
    UCHAR   ClassCode[3];
    USHORT  ImageLength;
    USHORT  ImageRevision;
    UCHAR   CodeType;
    UCHAR   Indicator;
    USHORT  Reserved;
} PCI_DATA_STRUCTURE, *PPCI_DATA_STRUCTURE;

#define PCI_ROM_HEADER_SIGNATURE            0xaa55
#define PCI_ROM_DATA_STRUCTURE_SIGNATURE    'RICP'  // LE PCIR

//
// Prototypes for local routines.
//

NTSTATUS
PciRomTestWriteAccessToBuffer(
    IN PUCHAR Buffer,
    IN ULONG  Length
    );

VOID
PciTransferRomData(
    IN PVOID    RomAddress,
    IN PVOID    Buffer,
    IN ULONG    Length
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, PciReadRomImage)
#pragma alloc_text(PAGE, PciRomTestWriteAccessToBuffer)
#pragma alloc_text(PAGE, PciTransferRomData)

#endif

VOID
PciTransferRomData(
    IN PVOID    RomAddress,
    IN PVOID    Buffer,
    IN ULONG    Length
    )

/*++

Routine Description:

    Simple abstraction of READ_REGISTER_BUFFER_Uxxxx()

    Copies from ROM to an in memory buffer.   Deals with alignment
    and tries to use the most efficient means.

Arguments:

    RomAddress  Mapped/Translated address to copy from.
    Buffer      Memory address to copy to.
    Length      Number of BYTEs to copy.

Return Value:

    None.

--*/

{
    #define BLKSIZE sizeof(ULONG)
    #define BLKMASK (BLKSIZE - 1)

    ULONG temp;

    if (Length > BLKSIZE) {

        //
        // Optimize for aligned case (typically, both will be perfectly
        // aligned) and a multiple of DWORDs.
        //

        temp = (ULONG)((ULONG_PTR)RomAddress & BLKMASK);
        if (temp == ((ULONG_PTR)Buffer & BLKMASK)) {

            //
            // Same alignment, (note: if not same alignment, we
            // transfer byte by byte).
            //
            // Walk off any leading bytes...
            //

            if (temp != 0) {

                //
                // temp is offset from a dword boundary, get number of
                // bytes to copy.
                //

                temp = BLKSIZE - temp;

                READ_REGISTER_BUFFER_UCHAR(RomAddress, Buffer, temp);

                Length -= temp;
                Buffer = (PVOID)((PUCHAR)Buffer + temp);
                RomAddress = (PVOID)((PUCHAR)RomAddress + temp);
            }

            if (Length > BLKSIZE) {

                //
                // Get as much as possible using DWORDS
                //

                temp = Length / BLKSIZE;

                READ_REGISTER_BUFFER_ULONG(RomAddress, Buffer, temp);

                temp = temp * BLKSIZE;
                Length -= temp;
                Buffer = (PVOID)((PUCHAR)Buffer + temp);
                RomAddress = (PVOID)((PUCHAR)RomAddress + temp);
            }
        }
    }

    //
    // Finish any remaining bytes.
    //

    if (Length) {
        READ_REGISTER_BUFFER_UCHAR(RomAddress, Buffer, Length);
    }

    #undef BLKMASK
    #undef BLKSIZE
}

NTSTATUS
PciRomTestWriteAccessToBuffer(
    IN PUCHAR Buffer,
    IN ULONG  Length
    )

/*++

Routine Description:

    Complete Paranoia.  Make sure we can write every page in the
    caller's buffer (assumes 4096 bytes per page) by writing to
    every page.

    We do this in a try block to avoid killing the system.  The
    hope is to avoid anything that might bugcheck the system while
    we have changed the operating characteristics of the device.

Arguments:

    Buffer      Address of start of buffer.
    Length      Number of bytes in buffer.

Return Value:

    Status.

--*/

{
    PUCHAR endAddress = Buffer + Length - 1;

    try {

        while (Buffer <= endAddress) {
            *Buffer = 0;
            Buffer += 0x1000;
        }
        *endAddress = 0;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }
    return STATUS_SUCCESS;
}

NTSTATUS
PciReadRomImage(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN ULONG WhichSpace,
    OUT PVOID Buffer,
    IN ULONG Offset,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    Copy the device ROM to the caller's Buffer.

Arguments:

    PdoExtension    Device Extension of the device in question.
    WhichSpace      Indicates which part of the ROM image is required.
                    (Currently only the x86 BIOS image is supported,
                    can be expanded to pass back the Open FW image if
                    needed).
    Buffer          Address of the caller's data area.
    Offset          Offset from the start of the ROM image data should
                    be returned from.   Currently not used, can be used
                    in the future to stage data.
    Length          Pointer to a ULONG containing the length of the
                    Buffer (requested length).   The value is modified
                    to the actual data length.


Return Value:

    Status of this operation.

--*/

{
    PIO_RESOURCE_DESCRIPTOR         requirement;
    PIO_RESOURCE_DESCRIPTOR         movedRequirement = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resource;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  tempResource;
    BOOLEAN                         acquiredResources = TRUE;
    BOOLEAN                         movedResource = FALSE;
    BOOLEAN                         translated;
    ULONG                           oldStatusCommand;
    ULONG                           newStatusCommand;
    ULONG                           oldRom;
    ULONG                           newRom;
    ULONG                           maximumLength;
    NTSTATUS                        status;
    PHYSICAL_ADDRESS                translatedAddress;
    ULONG                           addressIsIoSpace = 0;
    PVOID                           mapped = NULL;
    PVOID                           romBase;
    PUCHAR                          imageBase;
    ULONG                           imageLength;
    PCI_ROM_HEADER                  header;
    PCI_DATA_STRUCTURE              dataStructure;
    PPCI_ARBITER_INSTANCE           pciArbiter;
    PARBITER_INSTANCE               arbiter;
    PHYSICAL_ADDRESS                movedAddress;
    ULONG                           movedIndex;
    ULONGLONG                       tempResourceStart;

    PAGED_CODE();

    PciDebugPrint(
        PciDbgROM,
        "PCI ROM entered for pdox %08x (buffer @ %08x %08x bytes)\n",
        PdoExtension,
        Buffer,
        *Length
        );

    //
    // Currently not very flexible, assert we can do what the
    // caller wants.
    //

    ASSERT(Offset == 0);
    ASSERT(WhichSpace == PCI_WHICHSPACE_ROM);

    //
    // Capture the length and set the returned length to 0.  This
    // will be set to the correct value any data is successfully
    // returned.
    //

    maximumLength = *Length;
    *Length = 0;

    //
    // Only do this for header type 0 (ie devices, not bridges,
    // bridges actually can have ROMs,.... I don't know why and
    // currently have no plan to support it).
    //

    if (PdoExtension->HeaderType != PCI_DEVICE_TYPE) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // It's a device, does it use a ROM?
    //

    requirement = &PdoExtension->Resources->Limit[PCI_TYPE0_ADDRESSES];

    if ((PdoExtension->Resources == NULL) ||
        (requirement->Type == CmResourceTypeNull)) {

        return STATUS_SUCCESS;
    }

    //
    // Special case.  If Length == 0 on entry, caller wants to know
    // what the length should be.
    //

    ASSERT((requirement->u.Generic.Length & 0x1ff) == 0);

    if (maximumLength == 0) {
        *Length = requirement->u.Generic.Length;
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Trim length to device maximum.
    //

    if (requirement->u.Generic.Length < maximumLength) {
        maximumLength = requirement->u.Generic.Length;
    }

    //
    // Paranoia1:  This device is probably video.  If the system
    // bugchecks while we have the device' memory access in limbo,
    // the system will appear to hung.  Reduce the possibility of
    // bugcheck by ensuring we have (write) access to the caller's
    // buffer.
    //

    status = PciRomTestWriteAccessToBuffer(Buffer, maximumLength);

    if (!NT_SUCCESS(status)) {
        ASSERT(NT_SUCCESS(status));
        return status;
    }

    ASSERT(requirement->Type == CmResourceTypeMemory);
    ASSERT(requirement->Flags == CM_RESOURCE_MEMORY_READ_ONLY);

    //
    // Get current settings for the command register and the ROM BAR.
    //

    PciReadDeviceConfig(
        PdoExtension,
        &oldStatusCommand,
        FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
        sizeof(ULONG)
        );

    PciReadDeviceConfig(
        PdoExtension,
        &oldRom,
        FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.ROMBaseAddress),
        sizeof(ULONG)
        );

    //
    // Zero the upper 16 bits of the Status/Command variable so the
    // Status field in h/w is unchanged in subsequent writes.  (Bits
    // in the Status field are cleared by writing ones to them).
    //

    oldStatusCommand &= 0xffff;

    newStatusCommand = oldStatusCommand;
    newRom = oldRom;

    //
    // If access to the ROM is already enabled, and memory is
    // currently enabled, we already have access to the image.
    // (I've never actually seen that condition.  plj).
    // Otherwise, we need to get PnP to allocate the range.
    //


    if (PdoExtension->Resources->Current[PCI_TYPE0_ADDRESSES].Type ==
        CmResourceTypeMemory) {

        ASSERT(oldRom & PCI_ROMADDRESS_ENABLED);

        if (oldStatusCommand & PCI_ENABLE_MEMORY_SPACE) {

            //
            // No need to acquire resources.
            //

            acquiredResources = FALSE;
        }
    } else {
        ASSERT(PdoExtension->Resources->Current[PCI_TYPE0_ADDRESSES].Type ==
               CmResourceTypeNull);
    }

    //
    // Allocate a memory resource to access the ROM with.
    //

    if (acquiredResources == TRUE) {

        ULONGLONG rangeMin, rangeMax;
        PPCI_PDO_EXTENSION currentPdo, bridgePdo = NULL;



        //
        // Acquire the Arbiter lock for the parent FDO (ie the
        // bridge this device lives under).
        //
        // Attempt to acquire the range needed.   If that fails,
        // attempt to find a memory range the device already has
        // and move it to an invalid range then give the ROM the
        // memory that used to be assigned to that memory window.
        //

        currentPdo = PdoExtension;
        do {

            //
            // Find the PDO of the bridge - NULL for a root bus
            //

            if (PCI_PDO_ON_ROOT(currentPdo)) {

                bridgePdo = NULL;

            } else {

                bridgePdo = PCI_BRIDGE_PDO(PCI_PARENT_FDOX(currentPdo));

            }

            pciArbiter = PciFindSecondaryExtension(PCI_PARENT_FDOX(currentPdo),
                                                   PciArb_Memory);

            if (!pciArbiter) {

                //
                // If this device is on a root bus and the root doesn't have an
                // arbiter something bad happened...
                //

                if (!bridgePdo) {
                    ASSERT(pciArbiter);
                    return STATUS_UNSUCCESSFUL;
                };

                //
                // We didn't find an arbiter - probably because this is a
                // subtractive decode bridge.
                //


                if (bridgePdo->Dependent.type1.SubtractiveDecode) {

                    //
                    // This is subtractive so we want to find the guy who
                    // arbitrates our resources (so we move on up the tree)
                    //

                    currentPdo = bridgePdo;

                } else {

                    //
                    // We have a non-subtractive bridge without an arbiter -
                    // something is wrong...
                    //

                    ASSERT(pciArbiter);
                    return STATUS_UNSUCCESSFUL;
                }
            }

        } while (!pciArbiter);


        arbiter = &pciArbiter->CommonInstance;

        ArbAcquireArbiterLock(arbiter);

        //
        // Attempt to get this resource as an additional resource
        // within the ranges supported by this bridge.
        //

        rangeMin = requirement->u.Memory.MinimumAddress.QuadPart;
        rangeMax = requirement->u.Memory.MaximumAddress.QuadPart;

        //
        // If this is a PCI-PCI bridge then restrict this to the
        // non-prefetchable memory.  Currently we don't enable
        // prefetchable memory cardbus so there is nothing to
        // do there.
        //
        // Note: ROM BARs are 32 bit only so limit to low 4GB).
        // Note: Is is not clear that we really need to limit to
        // non-prefetchable memory.
        //

        if (bridgePdo) {

            if (bridgePdo->HeaderType == PCI_BRIDGE_TYPE) {

                //
                // The 3 below is the index of the non-prefetchable
                // memory bar for a PCI-PCI bridge within it's resources
                // current settings.
                //

                resource = &bridgePdo->Resources->Current[3];
                if (resource->Type == CmResourceTypeNull) {

                    //
                    // Bridge isn't passing memory,.... so reading
                    // ROMs isn't really an option.
                    //

                    PciDebugPrint(
                        PciDbgROM,
                        "PCI ROM pdo %p parent %p has no memory aperture.\n",
                        PdoExtension,
                        bridgePdo
                        );
                    ArbReleaseArbiterLock(arbiter);
                    return STATUS_UNSUCCESSFUL;
                }
                ASSERT(resource->Type == CmResourceTypeMemory);
                rangeMin = resource->u.Memory.Start.QuadPart;
                rangeMax = rangeMin + (resource->u.Memory.Length - 1);
            }
        }

        status = RtlFindRange(
                     arbiter->Allocation,
                     rangeMin,
                     rangeMax,
                     requirement->u.Memory.Length,
                     requirement->u.Memory.Alignment,
                     0,
                     0,
                     NULL,
                     NULL,
                     &tempResourceStart);

        tempResource.u.Memory.Start.QuadPart = tempResourceStart;

        if (!NT_SUCCESS(status)) {

            ULONG i;

            //
            // If this is a cardbus controller then game over as stealing BARS
            // is not something we encourage and is not fatal if we fail.
            //

            if (bridgePdo && bridgePdo->HeaderType == PCI_CARDBUS_BRIDGE_TYPE) {
                ArbReleaseArbiterLock(arbiter);
                return STATUS_UNSUCCESSFUL;
            }

            //
            // We were unable to get enough space on this bus
            // given the existing ranges and resources being
            // consumed.  Run down the list of memory resources
            // already assigned to this device and try to find
            // one which is large enough to cover the ROM and
            // appropriate aligned.   (Note: look for the smallest
            // one meeting these requirements).
            //
            // Note: ROM BARs are only 32 bits so we cannot steal
            // a 64 bit BAR that has been assigned an address > 4GB-1.
            // We could allow the replacement range to be > 4GB-1 if
            // the BAR supports it but I'm not doing this on the first
            // pass. (plj).
            //


            for (i = 0; i < PCI_TYPE0_ADDRESSES; i++) {

                PIO_RESOURCE_DESCRIPTOR l = &PdoExtension->Resources->Limit[i];

                if ((l->Type == CmResourceTypeMemory) &&
                    (l->u.Memory.Length >= requirement->u.Memory.Length) &&
                    (PdoExtension->Resources->Current[i].u.Memory.Start.HighPart == 0)) {
                    if ((!movedRequirement) ||
                        (movedRequirement->u.Memory.Length >
                                    l->u.Memory.Length)) {
                            movedRequirement = l;
                    }
                }
            }

            if (!movedRequirement) {
                PciDebugPrint(
                    PciDbgROM,
                    "PCI ROM pdo %p could not get MEM resource len 0x%x.\n",
                    PdoExtension,
                    requirement->u.Memory.Length
                    );
                ArbReleaseArbiterLock(arbiter);
                return STATUS_UNSUCCESSFUL;
            }

            //
            // Ok, we found a suitable candidate to move.   Let's see
            // if we can find somewhere to put it that's out of the
            // way.   We do this by allowing a conflict with ranges
            // not owned by this bus.  We know the driver isn't
            // using this range at this instant so we can put it
            // somewhere where there's no way to use it then use
            // the space it occupied for the ROM.
            //

            status = RtlFindRange(arbiter->Allocation,
                                  0,
                                  0xffffffff,
                                  movedRequirement->u.Memory.Length,
                                  movedRequirement->u.Memory.Alignment,
                                  RTL_RANGE_LIST_NULL_CONFLICT_OK,
                                  0,
                                  NULL,
                                  NULL,
                                  &movedAddress.QuadPart);
            
            if (!NT_SUCCESS(status)) {

                //
                // We were unable to find somewhere to move the
                // memory aperture to even allowing conflicts with
                // ranges not on this bus.   This can't happen
                // unless the requirement is just plain bogus.
                //

                PciDebugPrint(
                    PciDbgROM,
                    "PCI ROM could find range to disable %x memory window.\n",
                    movedRequirement->u.Memory.Length
                    );
                ArbReleaseArbiterLock(arbiter);
                return STATUS_UNSUCCESSFUL;
            }
            movedIndex = (ULONG)(movedRequirement - PdoExtension->Resources->Limit);
            tempResource = PdoExtension->Resources->Current[movedIndex];
            PciDebugPrint(
                PciDbgROM,
                "PCI ROM Moving existing memory resource from %p to %p\n",
                tempResource.u.Memory.Start.LowPart,
                movedAddress.LowPart);
        }
    } else {

        //
        // The ROM is currently enabled on this device, translate and
        // map the current setting.
        //

        tempResource.u.Generic.Start.LowPart =
            oldRom & PCI_ADDRESS_ROM_ADDRESS_MASK;
    }

    tempResource.Type = CmResourceTypeMemory;
    tempResource.u.Memory.Start.HighPart = 0;
    tempResource.u.Memory.Length = requirement->u.Memory.Length;
    resource = &tempResource;

    //
    // The following need to be done regardless of whether
    // or not we had to go acquire resources.
    //
    // HalTranslateBusAddress
    // MmMapIoSpace
    //
    // Note: HalTranslateBusAddress has been hooked to call back
    // into the PCI driver which will then attempt to acquire the
    // arbiter lock on this bus.  We can't release the lock as we
    // haven't really acquired this resource we're about to use.
    // We could trick PciTranslateBusAddress into not acquiring
    // the lock by calling it at dispatch level, or, we could
    // just call the saved (prehook) HAL function which is what
    // that routine ends up doing anyway.
    //

    ASSERT(PcipSavedTranslateBusAddress);

    translated = PcipSavedTranslateBusAddress(
                     PCIBus,
                     PCI_PARENT_FDOX(PdoExtension)->BaseBus,
                     resource->u.Generic.Start,
                     &addressIsIoSpace,
                     &translatedAddress
                     );

    //
    // NTRAID #62658 - 3/30/2001 - andrewth
    // If the resource won't translate it may be because the HAL doesn't
    // know about this bus.  Try the translation of the root bus this is 
    // under instead
    //

    if (!translated) {
        
        translated = PcipSavedTranslateBusAddress(
                     PCIBus,
                     PCI_PARENT_FDOX(PdoExtension)->BusRootFdoExtension->BaseBus,
                     resource->u.Generic.Start,
                     &addressIsIoSpace,
                     &translatedAddress
                     );

    }
    
    if (!translated) {
        PciDebugPrint(PciDbgROM,
                      "PCI ROM range at %p FAILED to translate\n",
                      resource->u.Generic.Start.LowPart);
        ASSERT(translated);
        status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }

    PciDebugPrint(PciDbgROM,
                  "PCI ROM range at %p translated to %p\n",
                  resource->u.Generic.Start.LowPart,
                  translatedAddress.LowPart);

    if (!addressIsIoSpace) {

        //
        // Translated to memory, map it.
        //

        mapped = MmMapIoSpace(translatedAddress,
                              requirement->u.Generic.Length,
                              MmNonCached);

        if (!mapped) {

            //
            // Failed to get mapping.
            //

            ASSERT(mapped);
            status = STATUS_UNSUCCESSFUL;
            goto cleanup;
        }

        romBase = mapped;

        PciDebugPrint(
            PciDbgROM,
            "PCI ROM mapped b %08x t %08x to %p length %x bytes\n",
            resource->u.Generic.Start.LowPart,
            translatedAddress.LowPart,
            mapped,
            requirement->u.Generic.Length
            );

    } else {

        romBase = (PVOID)translatedAddress.QuadPart;

        //
        // NOTE - on alpha even if things are translated into ports from memory
        // you still access them using HAL_READ_MEMORY_* routines - YUCK!
        //

        PciDebugPrint(
            PciDbgROM,
            "PCI ROM b %08x t %08x IO length %x bytes\n",
            resource->u.Generic.Start.LowPart,
            translatedAddress.LowPart,
            requirement->u.Generic.Length
            );

    }

    if (acquiredResources == TRUE) {

        newRom = tempResource.u.Memory.Start.LowPart | PCI_ROMADDRESS_ENABLED;

        //
        // Disable IO, MEMory and DMA while we enable the rom h/w.
        //

        newStatusCommand &= ~(PCI_ENABLE_IO_SPACE |
                              PCI_ENABLE_MEMORY_SPACE |
                              PCI_ENABLE_BUS_MASTER);

        PciWriteDeviceConfig(
            PdoExtension,
            &newStatusCommand,
            FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
            sizeof(ULONG)
            );

        //
        // WARNING:  While in this state, the device cannot operate
        // normally.
        //
        // If we have to move a memory aperture to access the ROM
        // do so now.
        //

        if (movedRequirement) {

            PciWriteDeviceConfig(
                PdoExtension,
                &movedAddress.LowPart,
                FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.BaseAddresses) +
                movedIndex * sizeof(ULONG),
                sizeof(ULONG)
                );
        }

        //
        // Set the ROM address (+enable).
        //

        PciWriteDeviceConfig(
            PdoExtension,
            &newRom,
            FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.ROMBaseAddress),
            sizeof(ULONG)
            );

        //
        // Enable MEMory access to this device.
        //

        newStatusCommand |= PCI_ENABLE_MEMORY_SPACE;

        PciWriteDeviceConfig(
            PdoExtension,
            &newStatusCommand,
            FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
            sizeof(ULONG)
            );
    }

    //
    // Copy the ROM to the caller's buffer.   Any failure prior to
    // this step will cause us to skip this step.
    //

    imageBase = (PUCHAR)romBase;

    do {

        //
        // Get the header, check signature.
        //

        PciTransferRomData(imageBase, &header, sizeof(header));

        if (header.Signature != PCI_ROM_HEADER_SIGNATURE) {

            //
            // Not a valid ROM image, don't transfer anything.
            //

            PciDebugPrint(
                PciDbgROM,
                "PCI ROM invalid signature, offset %x, expected %04x, got %04x\n",
                imageBase - (PUCHAR)romBase,
                PCI_ROM_HEADER_SIGNATURE,
                header.Signature
                );

            break;
        }

        //
        // Get image data structure, check its signature and
        // get actual length.
        //

        PciTransferRomData(imageBase + header.DataStructureOffset,
                           &dataStructure,
                           sizeof(dataStructure));

        if (dataStructure.Signature != PCI_ROM_DATA_STRUCTURE_SIGNATURE) {

            //
            // Invalid data structure, bail.
            //

            PciDebugPrint(
                PciDbgROM,
                "PCI ROM invalid signature, offset %x, expected %08x, got %08x\n",
                imageBase - (PUCHAR)romBase + header.DataStructureOffset,
                PCI_ROM_DATA_STRUCTURE_SIGNATURE,
                dataStructure.Signature
                );

            break;
        }

        //
        // Image length is in units of 512 bytes.   We presume
        // it's from the start of this image, ie imageBase, not
        // from the start of the code,... 'coz that wouldn't make
        // any sense.
        //

        imageLength = dataStructure.ImageLength * 512;

        if (imageLength > maximumLength) {

            //
            // Truncate to available buffer space.
            //

            imageLength = maximumLength;
        }

        //
        // Transfer this image to the caller's buffer.
        //

        PciTransferRomData(imageBase, Buffer, imageLength);

        //
        // Update pointers etc
        //

        Buffer = (PVOID)((PUCHAR)Buffer + imageLength);
        *Length += imageLength;
        imageBase += imageLength;
        maximumLength -= imageLength;

        if (dataStructure.Indicator & 0x80) {

            //
            // Indicator bit 7 == 1 means this was the last image.
            //

            break;
        }
    } while (maximumLength);

cleanup:

    if (acquiredResources == TRUE) {

        NTSTATUS tmpSta;

        //
        // Disable memory decoding and disable ROM access.
        //

        if (newRom != oldRom) {

            newStatusCommand &= ~PCI_ENABLE_MEMORY_SPACE;

            //
            // Not much we can do if this fails.
            //

            PciWriteDeviceConfig(
                PdoExtension,
                &newStatusCommand,
                FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
                sizeof(ULONG)
                );

            PciWriteDeviceConfig(
                PdoExtension,
                &oldRom,
                FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.ROMBaseAddress),
                sizeof(ULONG)
                );
        }

        //
        // If we moved someone to make room for the ROM, put them
        // back where they started off.
        //

        if (movedRequirement) {

            PciWriteDeviceConfig(
                PdoExtension,
                &PdoExtension->Resources->Current[movedIndex].u.Memory.Start.LowPart,
                FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.BaseAddresses) +
                movedIndex * sizeof(ULONG),
                sizeof(ULONG)
                );
        }

        //
        // Restore the command register to its original state.
        //

        if (newStatusCommand != oldStatusCommand) {

            PciWriteDeviceConfig(
                PdoExtension,
                &oldStatusCommand,
                FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
                sizeof(ULONG)
                );
        }

        //
        // Release the arbiter lock (we're no longer using extraneous
        // resources so it should be safe to let someone else allocate
        // them.
        //

        ArbReleaseArbiterLock(arbiter);
    }
    if (mapped) {
        MmUnmapIoSpace(mapped, requirement->u.Generic.Length);
    }
    PciDebugPrint(
        PciDbgROM,
        "PCI ROM leaving pdox %08x (buffer @ %08x %08x bytes, status %08x)\n",
        PdoExtension,
        (PUCHAR)Buffer - *Length,
        *Length,
        status
        );
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\tr_comn.c ===
/*++                                       

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    tr_comn.c

Abstract:

    This module provides the routines which are common to all the translators
    
Author:

    Andrew Thornton (andrewth)  21-May-1997

Revision History:

--*/


#include "pcip.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, PciReferenceTranslator)
#pragma alloc_text(PAGE, PciDereferenceTranslator)

#endif

VOID
PciReferenceTranslator(
    IN PVOID Context
    )
{
    PAGED_CODE();
}

VOID
PciDereferenceTranslator(
    IN PVOID Context
    )
{
    PAGED_CODE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\state.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    state.c

Abstract:

    This module the state manipulation engine for PCI

Author:

    Adrian J. Oney (AdriaO) 20-Oct-1998

Revision History:

Environment:

    NT Kernel Model Driver only

--*/

#include "pcip.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciBeginStateTransition)
#pragma alloc_text(PAGE, PciCommitStateTransition)
#pragma alloc_text(PAGE, PciCancelStateTransition)
#pragma alloc_text(PAGE, PciIsInTransitionToState)
#endif

//
// This array marks Allowed, Disallowed, and Illegal state transitions.
//
// The horizontal axis represents the current state.
// The vertical axis represents the state we are being asked to transition into.
//
//    There are four values in the table:
//       STATUS_SUCCESS                - State transition is possible
//       STATUS_INVALID_DEVICE_STATE   - We legally cannot do the state transition
//       STATUS_INVALID_DEVICE_REQUEST - Illegal transition, but known OS bug.
//       STATUS_FAIL_CHECK             - Consistancy problem. We should ASSERT!
//
// Count is PciMaxObjectState of
//
// PciNotStarted, PciStarted, PciDeleted, PciStopped, PciSurpriseRemoved, and
// PciSynchronizedOperation
//
// The final state is used to initiate operations that synchronously with
// respect to it and other state transitions. Commiting PciSynchronizedOperation
// is strictly illegal, and we are never strickly "in" that state.
//

//
// We will use the following visually shorter notation (State Transition foo)
// for the table:
//
#define ST_OK     STATUS_SUCCESS
#define ST_NOTOK  STATUS_INVALID_DEVICE_STATE
#define ST_ERROR  STATUS_FAIL_CHECK
#define ST_NTBUG  STATUS_INVALID_DEVICE_REQUEST
#define ST_OSBUG  STATUS_INVALID_DEVICE_REQUEST
#define ST_9XBUG  STATUS_FAIL_CHECK           // Change to STATUS_SUCCESS for 9x

NTSTATUS PnpStateTransitionArray[PciMaxObjectState][PciMaxObjectState] = {
// at NotStarted, Started, Deleted, Stopped, SurpriseRemoved, SynchronizedOperation
   { ST_ERROR, ST_OK,    ST_ERROR, ST_OK,    ST_ERROR, ST_ERROR }, // entering PciNotStarted
   { ST_OK,    ST_ERROR, ST_ERROR, ST_OK,    ST_ERROR, ST_ERROR }, // entering PciStarted
   { ST_OK,    ST_OK,    ST_ERROR, ST_ERROR, ST_OK,    ST_ERROR }, // entering PciDeleted
   { ST_OSBUG, ST_OK,    ST_ERROR, ST_ERROR, ST_ERROR, ST_ERROR }, // entering PciStopped
   { ST_NTBUG, ST_OK,    ST_ERROR, ST_OK,    ST_ERROR, ST_ERROR }, // entering PciSurpriseRemoved
   { ST_OK,    ST_OK,    ST_NOTOK, ST_OK,    ST_NOTOK, ST_ERROR }  // entering PciSynchronizedOperation
};

//
// This array is used in debug to restrict which state transitions can be
// spuriously cancelled. We restrict this to Stops and Removes, which come
// through all the time due to the inability of PnP to differentiate which
// device in a stack failed a query.
//
#if DBG
// Cancelling NotStarted, Started, Removed, Stopped, SurpriseRemoved, SynchronizedOperation
NTSTATUS PnpStateCancelArray[PciMaxObjectState] =
   { ST_NTBUG, ST_ERROR, ST_NOTOK, ST_NOTOK, ST_ERROR, ST_ERROR };

//
// While here, declare the text we use for debug squirties...
//

PUCHAR PciTransitionText[] = {
   "PciNotStarted",
   "PciStarted",
   "PciDeleted",
   "PciStopped",
   "PciSurpriseRemoved",
   "PciSynchronizedOperation",
   "PciMaxObjectState"
};
#endif


VOID
PciInitializeState(
    IN PPCI_COMMON_EXTENSION DeviceExtension
    )
{
   DeviceExtension->DeviceState        = PciNotStarted;
   DeviceExtension->TentativeNextState = PciNotStarted;
}

NTSTATUS
PciBeginStateTransition(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      NewState
    )
{
    NTSTATUS status;
    PCI_OBJECT_STATE currentState;

#if DBG
    PciDebugPrint(
        PciDbgInformative,
        "PCI Request to begin transition of Extension %p to %s ->",
        DeviceExtension,
        PciTransitionText[NewState]
        );
#endif

    //
    // Our "next" device state should be the same as our current device state.
    //
    ASSERT(DeviceExtension->TentativeNextState == DeviceExtension->DeviceState);
    currentState = DeviceExtension->DeviceState;

    //
    // One of three returns will wind their way out of this code:
    // STATUS_SUCCESS              - State transition is possible
    // STATUS_INVALID_DEVICE_STATE - We legally cannot do the state transition
    // STATUS_FAIL_CHECK           - Consistancy problem. We should ASSERT!
    //
    ASSERT(currentState < PciMaxObjectState);
    ASSERT(NewState     < PciMaxObjectState);

    //
    // Get plausibility and legality of requested state change.
    //
    status = PnpStateTransitionArray[NewState][currentState];

#if DBG
    //
    // State bug in PnP or driver. Investigation required.
    //
    if (status == STATUS_FAIL_CHECK) {

        PciDebugPrintf(
            PciDbgAlways,
            "ERROR\nPCI: Error trying to enter state \"%s\" from state \"%s\"\n",
            PciTransitionText[NewState],
            PciTransitionText[currentState]
            );

        DbgBreakPoint();

    } else if (status == STATUS_INVALID_DEVICE_REQUEST) {

        PciDebugPrintf(
            PciDbgInformative,
            "ERROR\nPCI: Illegal request to try to enter state \"%s\" from state \"%s\", rejecting",
            PciTransitionText[NewState],
            PciTransitionText[currentState]
            );
    }
#endif

    //
    // Someone tried to transition from A to A. We must fail the attemtpt
    // (ie STATUS_INVALID_DEVICE_STATE). There is no known case where we
    // should return success yet do nothing.
    //
    ASSERT((NewState!=DeviceExtension->DeviceState) || (!NT_SUCCESS(status)));

    if (NT_SUCCESS(status)) {
        DeviceExtension->TentativeNextState = (UCHAR)NewState;
    }

    PciDebugPrint(PciDbgInformative, "->%x\n", status);
    return status;
}

VOID
PciCommitStateTransition(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      NewState
    )
{
#if DBG
    PciDebugPrint(
        PciDbgInformative,
        "PCI Commit transition of Extension %p to %s\n",
        DeviceExtension,
        PciTransitionText[NewState]
        );
#endif

    //
    // This state is illegal.
    //
    ASSERT(NewState != PciSynchronizedOperation);

    //
    // verify commit properly pairs with previous PciBeginStateTransition.
    //
    ASSERT(DeviceExtension->TentativeNextState == NewState);

    DeviceExtension->DeviceState = (UCHAR)NewState;
}

NTSTATUS
PciCancelStateTransition(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      StateNotEntered
    )
{
#if DBG
    PciDebugPrint(
        PciDbgInformative,
        "PCI Request to cancel transition of Extension %p to %s ->",
        DeviceExtension,
        PciTransitionText[StateNotEntered]
        );
#endif

    //
    // Spurious Cancel's are allowed in specific states. This is allowed
    // because PnP can't help but send them.
    //
    if (DeviceExtension->TentativeNextState == DeviceExtension->DeviceState) {

        PciDebugPrint(PciDbgInformative, "%x\n", STATUS_INVALID_DEVICE_STATE);
        ASSERT(StateNotEntered < PciMaxObjectState);
        ASSERT(PnpStateCancelArray[StateNotEntered] != STATUS_FAIL_CHECK);
        return STATUS_INVALID_DEVICE_STATE;
    }

    //
    // verify cancel properly pairs with previous PciBeginStateTransition.
    //
    ASSERT(DeviceExtension->TentativeNextState == StateNotEntered);

    //
    // OK, our tests say we are in a transition. Verify the mutex.
    //

    DeviceExtension->TentativeNextState = DeviceExtension->DeviceState;

    PciDebugPrint(PciDbgInformative, "%x\n", STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

BOOLEAN
PciIsInTransitionToState(
    IN PPCI_COMMON_EXTENSION DeviceExtension,
    IN PCI_OBJECT_STATE      NextState
    )
{
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    ASSERT(NextState < PciMaxObjectState);

    //
    // Are we in a state transition?
    //
    if (DeviceExtension->TentativeNextState == DeviceExtension->DeviceState) {

        return FALSE;
    }

    //
    // OK, our tests say we are in a transition. Verify the mutex.
    //
    ASSERT_MUTEX_HELD(&DeviceExtension->StateMutex);

    return (DeviceExtension->TentativeNextState == NextState);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\routintf.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    routintf.c

Abstract:

    This module implements the "Pci Interrupt Routing" interfaces supported
    by the PCI driver.

Author:

    Jake Oshins (jakeo)  19-Jul-1997

Revision History:

   Elliot Shmukler (t-ellios) 7-15-1998   Modified the PCI routing interface to support
                                          MSI capable devices.

--*/

#include "pcip.h"

#define MSI_SIMULATE 0

//
// Prototypes for routines exposed only thru the "interface"
// mechanism.
//

NTSTATUS
routeintrf_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

NTSTATUS
routeintrf_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

VOID
routeintrf_Reference(
    IN PVOID Context
    );

VOID
routeintrf_Dereference(
    IN PVOID Context
    );

NTSTATUS
PciGetInterruptRoutingInfoEx(
    IN  PDEVICE_OBJECT  Pdo,
    OUT ULONG           *Bus,
    OUT ULONG           *PciSlot,
    OUT UCHAR           *InterruptLine,
    OUT UCHAR           *InterruptPin,
    OUT UCHAR           *ClassCode,
    OUT UCHAR           *SubClassCode,
    OUT PDEVICE_OBJECT  *ParentPdo,
    OUT ROUTING_TOKEN   *RoutingToken,
    OUT UCHAR           *Flags
    );

NTSTATUS
PciSetRoutingToken(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PROUTING_TOKEN  RoutingToken
    );

NTSTATUS
PciSetRoutingTokenEx(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PROUTING_TOKEN  RoutingToken
    );

VOID
PciUpdateInterruptLine(
    IN PDEVICE_OBJECT Pdo,
    IN UCHAR Line
    );

NTSTATUS 
PciGetInterruptRoutingInfo(
    IN  PDEVICE_OBJECT  Pdo,
    OUT ULONG           *Bus,
    OUT ULONG           *PciSlot,
    OUT UCHAR           *InterruptLine,
    OUT UCHAR           *InterruptPin,
    OUT UCHAR           *ClassCode,
    OUT UCHAR           *SubClassCode,
    OUT PDEVICE_OBJECT  *ParentPdo,
    OUT ROUTING_TOKEN   *RoutingToken
    );

NTSTATUS
PciSetLegacyDeviceToken(
    IN PDEVICE_OBJECT LegacyDO,
    IN PROUTING_TOKEN RoutingToken
    );

NTSTATUS
PciFindLegacyDevice(
    IN PDEVICE_OBJECT LegacyDO,
    OUT ULONG           *Bus,
    OUT ULONG           *PciSlot,
    OUT UCHAR           *InterruptLine,
    OUT UCHAR           *InterruptPin,
    OUT UCHAR           *ClassCode,
    OUT UCHAR           *SubClassCode,
    OUT PDEVICE_OBJECT  *ParentPdo,
    OUT ROUTING_TOKEN   *RoutingToken
    );

typedef struct {
    PCI_SECONDARY_EXTENSION ExtensionHeader;
    ROUTING_TOKEN RoutingToken;
} ROUTING_EXTENSION, *PROUTING_EXTENSION;

//
// Define the Pci Routing interface "Interface" structure.
//

PCI_INTERFACE PciRoutingInterface = {
    &GUID_INT_ROUTE_INTERFACE_STANDARD,     // InterfaceType
    sizeof(INT_ROUTE_INTERFACE_STANDARD),   // MinSize
    PCI_INT_ROUTE_INTRF_STANDARD_VER,                // MinVersion
    PCI_INT_ROUTE_INTRF_STANDARD_VER,                // MaxVersion
    PCIIF_FDO,                              // Flags
    0,                                      // ReferenceCount
    PciInterface_IntRouteHandler,           // Signature
    routeintrf_Constructor,                 // Constructor
    routeintrf_Initializer                  // Instance Initializer
};

PLEGACY_DEVICE PciLegacyDeviceHead = NULL;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, routeintrf_Constructor)
#pragma alloc_text(PAGE, routeintrf_Initializer)
#pragma alloc_text(PAGE, routeintrf_Reference)
#pragma alloc_text(PAGE, PciGetInterruptRoutingInfo)
#pragma alloc_text(PAGE, PciGetInterruptRoutingInfoEx)
#pragma alloc_text(PAGE, PciSetRoutingToken)
#pragma alloc_text(PAGE, PciSetRoutingTokenEx)
#pragma alloc_text(PAGE, PciFindLegacyDevice)
#pragma alloc_text(PAGE, PciCacheLegacyDeviceRouting)
#pragma alloc_text(PAGE, PciUpdateInterruptLine)
#endif

VOID
routeintrf_Reference(
    IN PVOID Context
    )
{
    return;
}

NTSTATUS
routeintrf_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Initialize the BUS_INTERFACE_STANDARD fields.

Arguments:

    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    InterfaceSpecificData

    InterfaceReturn

Return Value:

    Status

--*/

{
    PINT_ROUTE_INTERFACE_STANDARD standard = (PINT_ROUTE_INTERFACE_STANDARD)InterfaceReturn;

    switch(Version)
    {
    case PCI_INT_ROUTE_INTRF_STANDARD_VER:
       standard->GetInterruptRouting = PciGetInterruptRoutingInfoEx;
       standard->SetInterruptRoutingToken = PciSetRoutingTokenEx;
       standard->UpdateInterruptLine = PciUpdateInterruptLine;
       break;
    default:
       return STATUS_NOINTERFACE;

    }

    standard->Size = sizeof( INT_ROUTE_INTERFACE_STANDARD );
    standard->Version = Version;
    standard->Context = DeviceExtension;
    standard->InterfaceReference = routeintrf_Reference;
    standard->InterfaceDereference = routeintrf_Reference;


    return STATUS_SUCCESS;
}

NTSTATUS
routeintrf_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )
/*++

Routine Description:

    For bus interface, does nothing, shouldn't actually be called.

Arguments:

    Instance        Pointer to the PDO extension.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERTMSG("PCI routeintrf_Initializer, unexpected call.", 0);

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
PciGetInterruptRoutingInfo(
    IN  PDEVICE_OBJECT  Pdo,
    OUT ULONG           *Bus,
    OUT ULONG           *PciSlot,
    OUT UCHAR           *InterruptLine,
    OUT UCHAR           *InterruptPin,
    OUT UCHAR           *ClassCode,
    OUT UCHAR           *SubClassCode,
    OUT PDEVICE_OBJECT  *ParentPdo,
    OUT ROUTING_TOKEN   *RoutingToken
)
/*++

Routine Description:

    Each PCI device in the system is connected to some
    interrupt pin.  And in order to figure out which interrupt
    that device may trigger, an IRQ arbiter must have this
    information.  This interface gathers all such information
    for the arbiter.

Arguments:

    Pdo           - Device object that the arbiter needs to inquire about
    Bus           - Number of the PCI bus in question
    PciSlot       - Slot/Function that corresponds to this device
    InterruptLine - Contents of the device's interrupt line register
    InterruptPin  - Contents of the device's interrupt pin register
    ClassCode     - type of device
    SubClassCode  - sub-type of device
    ParentPdo     - PDO of parent PCI bus
    RoutingToken  - blob of data

Return Value:

    STATUS_SUCCESS   - this is a PCI device and all the fields have been filled
    STATUS_NOT_FOUND - to the knowledge of the PCI driver, this is not a PCI device

--*/
{
    PROUTING_EXTENSION RoutingExtension;
    PPCI_PDO_EXTENSION PdoExt = (PPCI_PDO_EXTENSION)Pdo->DeviceExtension;
    NTSTATUS status;

    ASSERT(Bus);
    ASSERT(PciSlot);
    ASSERT(InterruptLine);
    ASSERT(InterruptPin);
    ASSERT(ClassCode);
    ASSERT(SubClassCode);
    ASSERT(ParentPdo);
    ASSERT(RoutingToken);

    //
    // Check to see if this is a legacy PCI device that
    // we are tracking.
    //

    status = PciFindLegacyDevice(Pdo,
                                 Bus,
                                 PciSlot,
                                 InterruptLine,
                                 InterruptPin,
                                 ClassCode,
                                 SubClassCode,
                                 ParentPdo,
                                 RoutingToken);

    if (NT_SUCCESS(status)) {
        //
        // If so, the fields have been filled in already.
        //
        return status;
    }

    //
    // Verify that this PDO actually belongs to us.
    //
    if (!PdoExt) {
        return STATUS_NOT_FOUND;
    }

    //
    // Verify that it is actually a PDO.
    //
    if (PdoExt->ExtensionType != PciPdoExtensionType) {
        return STATUS_NOT_FOUND;
    }

    *Bus            = PCI_PARENT_FDOX(PdoExt)->BaseBus;
    *PciSlot        = PdoExt->Slot.u.AsULONG;
    *InterruptLine  = PdoExt->RawInterruptLine;
    *InterruptPin   = PdoExt->InterruptPin;
    *ClassCode      = PdoExt->BaseClass;
    *SubClassCode   = PdoExt->SubClass;
    *ParentPdo      = PCI_PARENT_PDO(PdoExt);

    RoutingExtension = PciFindSecondaryExtension(PdoExt,
                                                 PciInterface_IntRouteHandler);

    if (RoutingExtension) {

        *RoutingToken = RoutingExtension->RoutingToken;

    } else {

        RoutingToken->LinkNode = 0;
        RoutingToken->StaticVector = 0;
        RoutingToken->Flags = 0;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PciGetInterruptRoutingInfoEx(
    IN  PDEVICE_OBJECT  Pdo,
    OUT ULONG           *Bus,
    OUT ULONG           *PciSlot,
    OUT UCHAR           *InterruptLine,
    OUT UCHAR           *InterruptPin,
    OUT UCHAR           *ClassCode,
    OUT UCHAR           *SubClassCode,
    OUT PDEVICE_OBJECT  *ParentPdo,
    OUT ROUTING_TOKEN   *RoutingToken,
    OUT UCHAR           *Flags
    )
/*++

Routine Description:

    Wrapper for PciGetInterruptroutingInfo that sets
    the Flags parameter to indicate MSI-capable PCI devices.

Arguments:

    Mostly, same as PciGetInterruptRoutingInfo.

    Flags receives device-specific flags such as whether the device
    supports MSI.

Return Value:

    Same as PciGetInterruptRoutingInfo.

--*/

{
   NTSTATUS status;
   PPCI_PDO_EXTENSION PdoExt = (PPCI_PDO_EXTENSION)Pdo->DeviceExtension;

   // Call the real function

   status = PciGetInterruptRoutingInfo(Pdo,
                                       Bus,
                                       PciSlot,
                                       InterruptLine,
                                       InterruptPin,
                                       ClassCode,
                                       SubClassCode,
                                       ParentPdo,
                                       RoutingToken);

   *Flags = 0;


#if MSI_SUPPORTED

   if (NT_SUCCESS(status)

#if !MSI_SIMULATE
       && PdoExt->CapableMSI
#endif
        ) {


      // MSI device?
      *Flags = PCI_MSI_ROUTING;

   }

#endif // MSI_SUPPORTED

   return status;
}



NTSTATUS
PciSetRoutingToken(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PROUTING_TOKEN  RoutingToken
    )
/*++

Routine Description:

    This routine stores a blob of data associated with this
    PCI device.  This job is foisted off on the PCI driver because
    the PCI driver has a one-to-one correspondence between useful
    data structures and PCI devices.

Arguments:

    Pdo          - Device object that the IRQ arbiter is working with

    RoutingToken - Blob of data that the IRQ arbiter wants to associate with
                   the PCI device.

Return Value:

    Returns the status of this operation.

--*/
{
    PROUTING_EXTENSION RoutingExtension;
    PPCI_PDO_EXTENSION PdoExt = (PPCI_PDO_EXTENSION)Pdo->DeviceExtension;
    NTSTATUS status;

    //
    // Check first to see if this is a legacy PCI device.
    //

    status = PciSetLegacyDeviceToken(Pdo, RoutingToken);

    if (NT_SUCCESS(status)) {
        return STATUS_SUCCESS;
    }

    //
    // This isn't in our list of legacy devices.  So it must be
    // a PCI PDO.
    //

#if DBG
    RoutingExtension = PciFindSecondaryExtension(PdoExt,
                                                 PciInterface_IntRouteHandler);

    if (RoutingExtension != NULL) {
        DbgPrint("PCI:  *** redundant PCI routing extesion being created ***\n");
    }
    ASSERT(RoutingExtension == NULL);
#endif

    RoutingExtension = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION,
                                      sizeof(ROUTING_EXTENSION));

    if (!RoutingExtension) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RoutingExtension->RoutingToken = *RoutingToken;

    PciLinkSecondaryExtension(PdoExt,
                              RoutingExtension,
                              PciInterface_IntRouteHandler,
                              NULL);

    return STATUS_SUCCESS;
}

NTSTATUS
PciSetRoutingTokenEx(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PROUTING_TOKEN  RoutingToken
    )
/*++

Routine Description:

    MSI-aware wrapper for PciSetRoutingToken.

    This function will intercept MSI routing tokens (as indicated by
    the PCI_MSI_ROUTING flag) and store the MSI routing information
    in the PDO extension without caching the token in a secondary extension.

    Non-MSI routing tokens will be passed to PciSetRoutingToken.

Arguments:

    Same as PciSetRoutingToken.


Return Value:

    Same as PciSetRoutingToken.

--*/
{
    PPCI_PDO_EXTENSION PdoExt = (PPCI_PDO_EXTENSION)Pdo->DeviceExtension;
    NTSTATUS status = STATUS_SUCCESS;


#if MSI_SUPPORTED

    if(

#if !MSI_SIMULATE
        PdoExt->CapableMSI &&
#endif

       (RoutingToken->Flags & PCI_MSI_ROUTING))
    {

       // MSI token

       PciDebugPrint(PciDbgInformative,"PCI: MSI Resources Received for Device %08x\n", Pdo);

#ifdef DBG

       // have we received a new resource assignment?

       if ((PdoExt->MsiInfo.MessageAddress != (ULONG_PTR)RoutingToken->LinkNode)
          || (PdoExt->MsiInfo.MessageData != (USHORT)RoutingToken->StaticVector)) {

          PciDebugPrint(PciDbgPrattling,"PCI: Device %08x will be reprogrammed with Message = %ld @%p\n",
                   Pdo, RoutingToken->StaticVector, RoutingToken->LinkNode);

       }

#endif

       // Store MSI info in PdoExt.

       PdoExt->MsiInfo.MessageAddress = (ULONG_PTR)RoutingToken->LinkNode;
       PdoExt->MsiInfo.MessageData = (USHORT)RoutingToken->StaticVector;
    }
    else

#endif // MSI_SUPPORTED

    {
       // Call the original function on non-MSI tokens.

       status = PciSetRoutingToken(Pdo, RoutingToken);
    }

    return status;
}


//
//  NT 5.0 has to support non-PnP 4.0-style device drivers.  And
//  this driver doesn't create the device objects associated with
//  a PCI device when its driver is 4.0-style.  It does, however
//  get a chance to look at those objects when the driver calls
//  HalAssignSlotResources.  This collection of functions tracks
//  these foreign device objects.
//

NTSTATUS
PciFindLegacyDevice(
    IN PDEVICE_OBJECT LegacyDO,
    OUT ULONG           *Bus,
    OUT ULONG           *PciSlot,
    OUT UCHAR           *InterruptLine,
    OUT UCHAR           *InterruptPin,
    OUT UCHAR           *ClassCode,
    OUT UCHAR           *SubClassCode,
    OUT PDEVICE_OBJECT  *ParentPdo,
    OUT ROUTING_TOKEN   *RoutingToken
    )
/*++

Routine Description:

    This function returns all the routing data for a legacy
    device object.

Arguments:

Return Value:

    Returns the status of this operation.

--*/
{
    PLEGACY_DEVICE  legacyDev = PciLegacyDeviceHead;
    NTSTATUS        status = STATUS_NOT_FOUND;

    PAGED_CODE();

    while (legacyDev) {

        if (legacyDev->LegacyDeviceObject == LegacyDO) {
            
            break;

        } else if (legacyDev->Bus == *Bus && legacyDev->PciSlot == *PciSlot) {
            
            if (legacyDev->LegacyDeviceObject == NULL) {
                
                //
                // Cache the LegacyDO in case we matched on the bus and slot info.
                //

                legacyDev->LegacyDeviceObject = LegacyDO;
                break;

            } else {
                
                PciDebugPrint(PciDbgAlways, "Two PDOs (Legacy = %08x, Pnp = %08x) for device on bus %08x, slot %08x\n", legacyDev->LegacyDeviceObject, LegacyDO, *Bus, *PciSlot);
                ASSERT(legacyDev->LegacyDeviceObject != NULL);
                legacyDev = NULL;
                break;

            }
        }

        legacyDev = (PLEGACY_DEVICE)legacyDev->List.Next;
    }

    if (legacyDev) {
        
        *Bus            = legacyDev->Bus;
        *PciSlot        = legacyDev->PciSlot;
        *InterruptLine  = legacyDev->InterruptLine;
        *InterruptPin   = legacyDev->InterruptPin;
        *ClassCode      = legacyDev->ClassCode;
        *SubClassCode   = legacyDev->SubClassCode;
        *ParentPdo      = legacyDev->ParentPdo;
        *RoutingToken   = legacyDev->RoutingToken;

        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
PciCacheLegacyDeviceRouting(
    IN PDEVICE_OBJECT LegacyDO,
    IN ULONG          Bus,
    IN ULONG          PciSlot,
    IN UCHAR          InterruptLine,
    IN UCHAR          InterruptPin,
    IN UCHAR          ClassCode,
    IN UCHAR          SubClassCode,
    IN PDEVICE_OBJECT ParentPdo,
    IN PPCI_PDO_EXTENSION PdoExtension,
    OUT PDEVICE_OBJECT      *OldLegacyDO
    )
/*++

Routine Description:

    This function stores all the routing data for a legacy
    device object, except the RoutingToken. Caller needs to acquire 
    PciGlobalLock before calling this function.

Arguments:

Return Value:

    Returns the status of this operation.

--*/
{
    PLEGACY_DEVICE  legacyDev = PciLegacyDeviceHead;

    PAGED_CODE();

    while (legacyDev) {

        if (Bus == legacyDev->Bus && PciSlot == legacyDev->PciSlot) {
            if (legacyDev->LegacyDeviceObject == LegacyDO) {

                //
                // This device is already in the list.
                //

                if (OldLegacyDO) {

                    *OldLegacyDO = LegacyDO;
                }

                return STATUS_SUCCESS;
            } else {

                PDEVICE_OBJECT oldDO;

                //
                // We are overwriting an existing entry.
                //

                oldDO = legacyDev->LegacyDeviceObject;
                legacyDev->LegacyDeviceObject = LegacyDO;

                if (OldLegacyDO) {

                    *OldLegacyDO = oldDO;
                }

                return STATUS_SUCCESS;
            }
        }
        legacyDev = (PLEGACY_DEVICE)legacyDev->List.Next;
    }

    legacyDev = ExAllocatePool(PagedPool,
                               sizeof(LEGACY_DEVICE));

    if (!legacyDev) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(legacyDev, sizeof(LEGACY_DEVICE));

    legacyDev->LegacyDeviceObject   = LegacyDO;
    legacyDev->Bus                  = Bus;
    legacyDev->PciSlot              = PciSlot;
    legacyDev->InterruptLine        = InterruptLine;
    legacyDev->InterruptPin         = InterruptPin;
    legacyDev->ClassCode            = ClassCode;
    legacyDev->SubClassCode         = SubClassCode;
    legacyDev->ParentPdo            = ParentPdo;
    legacyDev->PdoExtension         = PdoExtension;

    //
    // Push this one onto the list.
    //

    legacyDev->List.Next = (PSINGLE_LIST_ENTRY)PciLegacyDeviceHead;
    PciLegacyDeviceHead = legacyDev;

    if (OldLegacyDO) {

        *OldLegacyDO = LegacyDO;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PciSetLegacyDeviceToken(
    IN PDEVICE_OBJECT LegacyDO,
    IN PROUTING_TOKEN RoutingToken
    )
/*++

Routine Description:

    This function stores the RoutingToken.

Arguments:

Return Value:

    Returns the status of this operation.

--*/
{
    PLEGACY_DEVICE  legacyDev = PciLegacyDeviceHead;

    PAGED_CODE();

    while (legacyDev) {

        if (legacyDev->LegacyDeviceObject == LegacyDO) {

            //
            // Found it.  Copy the token into the structure.
            //

            legacyDev->RoutingToken = *RoutingToken;

            return STATUS_SUCCESS;
        }

        legacyDev = (PLEGACY_DEVICE)legacyDev->List.Next;
    }

    return STATUS_NOT_FOUND;
}

VOID
PciUpdateInterruptLine(
    IN PDEVICE_OBJECT Pdo,
    IN UCHAR Line
    )
{
    NTSTATUS status;
    PPCI_PDO_EXTENSION pdoExt;
    PLEGACY_DEVICE legacyDev = PciLegacyDeviceHead;
    PCI_COMMON_HEADER header;
    PPCI_COMMON_CONFIG biosConfig = (PPCI_COMMON_CONFIG) &header;

    PAGED_CODE();

    //
    // Work out if this is a legacy PDO or not
    //

    while (legacyDev) {

        if (legacyDev->LegacyDeviceObject == Pdo) {

            //
            // Found it.
            //

            pdoExt = legacyDev->PdoExtension;
            break;
        }

        legacyDev = (PLEGACY_DEVICE)legacyDev->List.Next;
    }


    if (legacyDev == NULL) {

        //
        // Oh well it must be a PCI pdo
        //

        pdoExt = Pdo->DeviceExtension;
    }

    ASSERT_PCI_PDO_EXTENSION(pdoExt);

    //
    // Now we can update the hardware and our internal state!
    //

    pdoExt->RawInterruptLine = pdoExt->AdjustedInterruptLine = Line;

    PciWriteDeviceConfig(pdoExt,
                         &Line,
                         FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.InterruptLine),
                         sizeof(Line)
                         );

    //
    // Finally refresh the config space stored in the registry
    //

    status = PciGetBiosConfig(pdoExt, biosConfig);

    ASSERT(NT_SUCCESS(status));

    if (NT_SUCCESS(status)
    &&  biosConfig->u.type0.InterruptLine != Line) {

        biosConfig->u.type0.InterruptLine = Line;

        status = PciSaveBiosConfig(pdoExt, biosConfig);

        ASSERT(NT_SUCCESS(status));

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\usage.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains dispatch code for PCI.SYS.

Author:

    Ken Reneris (kenr) 4-Dec-1997

Revision History:

--*/

#include "pcip.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciLocalDeviceUsage)
#pragma alloc_text(PAGE, PciPdoDeviceUsage)
#endif


NTSTATUS
PciLocalDeviceUsage (
    IN PPCI_POWER_STATE     PowerState,
    IN PIRP                 Irp
    )
{
    PIO_STACK_LOCATION  irpSp;
    PLONG               Addend;
    LONG                Increment;
    LONG                Junk;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    Increment = irpSp->Parameters.UsageNotification.InPath  ? 1 : -1;
    switch (irpSp->Parameters.UsageNotification.Type) {
        case DeviceUsageTypePaging:         Addend = &PowerState->Paging;      break;
        case DeviceUsageTypeHibernation:    Addend = &PowerState->Hibernate;   break;
        case DeviceUsageTypeDumpFile:       Addend = &PowerState->CrashDump;   break;
        default:
            return STATUS_NOT_SUPPORTED;
    }

    Junk = InterlockedExchangeAdd (Addend, Increment);

#if DBG

    if (Increment == -1) {
        ASSERT(Junk > 0);
    }

#endif

    return STATUS_SUCCESS;
}

NTSTATUS
PciPdoDeviceUsage (
    IN PPCI_PDO_EXTENSION   pdoExtension,
    IN PIRP             Irp
    )
{
    PDEVICE_OBJECT      ParentFdo;
    PIO_STACK_LOCATION  IrpSp;
    PIO_STACK_LOCATION  NewIrpSp;
    PIRP                NewIrp;
    KEVENT              Event;
    NTSTATUS            Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK     LocalIoStatus;

    PAGED_CODE();

    //
    // Do we have a parent that we must notify?
    //
    if (pdoExtension->ParentFdoExtension != NULL &&
        pdoExtension->ParentFdoExtension->PhysicalDeviceObject != NULL) {

        //
        // Get a referenced object to the parent
        //
        ParentFdo = IoGetAttachedDeviceReference(
            pdoExtension->ParentFdoExtension->PhysicalDeviceObject
            );
        if (ParentFdo == NULL) {

            Status = STATUS_NO_SUCH_DEVICE;
            goto PciPdoDeviceUsageExit;

        }

        //
        // Initialize the event to wait on
        //
        KeInitializeEvent( &Event, SynchronizationEvent, FALSE );

        //
        // Build an Irp
        //
        NewIrp = IoBuildSynchronousFsdRequest(
            IRP_MJ_PNP,
            ParentFdo,
            NULL,
            0,
            NULL,
            &Event,
            &LocalIoStatus
            );
        if (NewIrp == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            ObDereferenceObject( ParentFdo );
            goto PciPdoDeviceUsageExit;

        }

        //
        // Get the top of the stacks
        //
        NewIrpSp = IoGetNextIrpStackLocation( NewIrp );
        IrpSp = IoGetCurrentIrpStackLocation(Irp);

        //
        // Set the top of stack
        //
        *NewIrpSp = *IrpSp;

        //
        // Clear any completion routines from the new stack
        //
        IoSetCompletionRoutine(
            NewIrp,
            NULL,
            NULL,
            FALSE,
            FALSE,
            FALSE
            );

        NewIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        //
        // Send the request down
        //
        Status = IoCallDriver( ParentFdo, NewIrp );
        if (Status == STATUS_PENDING) {

            //
            // Wait for the request to be done
            //
            KeWaitForSingleObject(
                &Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );
            Status = LocalIoStatus.Status;

        }

        //
        // Deference the target
        //
        ObDereferenceObject( ParentFdo );

    }


PciPdoDeviceUsageExit:

    //
    // If we succeeded, then apply the usages locally
    //
    if (NT_SUCCESS(Status)) {

        //
        // Apply the usage locally
        //

        Status = PciLocalDeviceUsage(&pdoExtension->PowerState, Irp);

    }

    //
    // Done
    //
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\tr_irq.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    tr_irq.c

Abstract:

    This module implements the PCI Interrupt translator.  It should eventually
    go away when all the HALs provide translators.

Author:

    Andrew Thornton (andrewth)  21-May-1997

Revision History:

--*/


#include "pcip.h"

#define TRANIRQ_VERSION     0

//
// Irq translator
//

NTSTATUS
tranirq_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    );

NTSTATUS
tranirq_Constructor(
    PVOID DeviceExtension,
    PVOID PciInterface,
    PVOID InterfaceSpecificData,
    USHORT Version,
    USHORT Size,
    PINTERFACE InterfaceReturn
    );

NTSTATUS
tranirq_TranslateResource(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
tranirq_TranslateResourceRequirement(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
tranirq_TranslateInterrupt(
    IN PDEVICE_OBJECT Pdo,
    IN PPCI_TRANSLATOR_INSTANCE Translator,
    IN ULONG Vector,
    OUT PULONG TranslatedVector,
    OUT PULONG TranslatedLevel,
    OUT PULONG TranslatedAffinity,
    OUT PULONG UntranslatedVector
    );

#define TR_IRQ_INVALID_VECTOR 0xffffffff

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, tranirq_Initializer)
#pragma alloc_text(PAGE, tranirq_Constructor)
#endif


PCI_INTERFACE TranslatorInterfaceInterrupt = {
    &GUID_TRANSLATOR_INTERFACE_STANDARD,    // InterfaceType
    sizeof(TRANSLATOR_INTERFACE),           // MinSize
    TRANIRQ_VERSION,                        // MinVersion
    TRANIRQ_VERSION,                        // MaxVersion
    PCIIF_FDO,                              // Flags
    0,                                      // ReferenceCount
    PciTrans_Interrupt,                     // Signature
    tranirq_Constructor,                    // Constructor
    tranirq_Initializer                     // Instance Initializer
};

NTSTATUS
tranirq_Initializer(
    IN PPCI_ARBITER_INSTANCE Instance
    )
{
    return STATUS_SUCCESS;
}

NTSTATUS
tranirq_Constructor(
    IN PVOID DeviceExtension,
    IN PVOID PciInterface,
    IN PVOID InterfaceSpecificData,
    IN USHORT Version,
    IN USHORT Size,
    IN PINTERFACE InterfaceReturn
    )

/*++

Routine Description:

    Check the InterfaceSpecificData to see if this is the correct
    translator (we already know the required interface is a translator
    from the GUID) and if so, allocate (and reference) a context
    for this interface.

Arguments:

    PciInterface    Pointer to the PciInterface record for this
                    interface type.
    InterfaceSpecificData
                    A ULONG containing the resource type for which
                    arbitration is required.
    InterfaceReturn

Return Value:

    TRUE is this device is not known to cause problems, FALSE
    if the device should be skipped altogether.

--*/

{
    PTRANSLATOR_INTERFACE interface;
    PPCI_TRANSLATOR_INSTANCE instance;
    ULONG secondaryBusNumber, parentBusNumber;
    INTERFACE_TYPE parentInterface;
    PPCI_FDO_EXTENSION fdoExt = (PPCI_FDO_EXTENSION)DeviceExtension;
    PPCI_PDO_EXTENSION pdoExt;

    //
    // This translator handles interrupts, is that what they want?
    //

    if ((CM_RESOURCE_TYPE)(ULONG_PTR)InterfaceSpecificData != CmResourceTypeInterrupt) {

        PciDebugPrint(
            PciDbgVerbose,
            "PCI - IRQ trans constructor doesn't like %x in InterfaceSpecificData\n",
            InterfaceSpecificData);
        
        //
        // No, it's not us then.
        //

        return STATUS_INVALID_PARAMETER_3;
    }

    ASSERT(fdoExt->ExtensionType == PciFdoExtensionType);

    //
    // Give the HAL a shot at providing this translator.
    //
    
    if (PCI_IS_ROOT_FDO(fdoExt)) {

        parentInterface = Internal;
        secondaryBusNumber = fdoExt->BaseBus;
        parentBusNumber = 0;

        PciDebugPrint(PciDbgObnoxious, "      Is root FDO\n");

    } else {

        parentInterface = PCIBus;
        secondaryBusNumber = fdoExt->BaseBus;
        
        pdoExt = (PPCI_PDO_EXTENSION)fdoExt->PhysicalDeviceObject->DeviceExtension;
        parentBusNumber = PCI_PARENT_FDOX(pdoExt)->BaseBus;
        
        PciDebugPrint(PciDbgObnoxious, 
                      "      Is bridge FDO, parent bus %x, secondary bus %x\n",
                      parentBusNumber,
                      secondaryBusNumber);

    }
    
    return HalGetInterruptTranslator(parentInterface,
                                     parentBusNumber,
                                     PCIBus,
                                     sizeof(TRANSLATOR_INTERFACE),
                                     TRANIRQ_VERSION,
                                     (PTRANSLATOR_INTERFACE)InterfaceReturn,
                                     &secondaryBusNumber);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pci\utils.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains assorted utility functions for PCI.SYS.

Author:

    Peter Johnston (peterj)  20-Nov-1996

Revision History:

--*/

#include "pcip.h"

typedef struct _LIST_CONTEXT {
    PCM_PARTIAL_RESOURCE_LIST       List;
    CM_RESOURCE_TYPE                DesiredType;
    ULONG                           Remaining;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Next;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  Alias;
} LIST_CONTEXT, *PLIST_CONTEXT;

extern PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable;

VOID
PcipInitializePartialListContext(
    IN PLIST_CONTEXT             ListContext,
    IN PCM_PARTIAL_RESOURCE_LIST PartialList,
    IN CM_RESOURCE_TYPE          DesiredType
    );

PCM_PARTIAL_RESOURCE_DESCRIPTOR
PcipGetNextRangeFromList(
    PLIST_CONTEXT ListContext
    );

NTSTATUS
PciGetDeviceCapabilities(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PcipDestroySecondaryExtension)
#pragma alloc_text(PAGE, PciFindDescriptorInCmResourceList)
#pragma alloc_text(PAGE, PciFindParentPciFdoExtension)
#pragma alloc_text(PAGE, PciGetDeviceCapabilities)
#pragma alloc_text(PAGE, PciGetDeviceProperty)
#pragma alloc_text(PAGE, PcipGetNextRangeFromList)
#pragma alloc_text(PAGE, PciGetRegistryValue)
#pragma alloc_text(PAGE, PcipInitializePartialListContext)
#pragma alloc_text(PAGE, PciInsertEntryAtHead)
#pragma alloc_text(PAGE, PciInsertEntryAtTail)
#pragma alloc_text(PAGE, PcipLinkSecondaryExtension)
#pragma alloc_text(PAGE, PciOpenKey)
#pragma alloc_text(PAGE, PciQueryBusInformation)
#pragma alloc_text(PAGE, PciQueryLegacyBusInformation)
#pragma alloc_text(PAGE, PciQueryCapabilities)
#pragma alloc_text(PAGE, PciRangeListFromResourceList)
#pragma alloc_text(PAGE, PciSaveBiosConfig)
#pragma alloc_text(PAGE, PciGetBiosConfig)
#pragma alloc_text(PAGE, PciStringToUSHORT)
#pragma alloc_text(PAGE, PciSendIoctl)
#pragma alloc_text(INIT, PciBuildDefaultExclusionLists)
#pragma alloc_text(PAGE, PciIsDeviceOnDebugPath)
#endif


//
// Range lists indicating the ranges excluded from decode when the ISA and/or
// VGA bits are set on a bridge.  Initialized by PciBuildDefaultExclusionLists
// from DriverEntry.
//
RTL_RANGE_LIST PciIsaBitExclusionList;
RTL_RANGE_LIST PciVgaAndIsaBitExclusionList;


PCM_PARTIAL_RESOURCE_DESCRIPTOR
PciFindDescriptorInCmResourceList(
    IN CM_RESOURCE_TYPE DescriptorType,
    IN PCM_RESOURCE_LIST ResourceList,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR PreviousHit
    )
{
    ULONG                           numlists;
    PCM_FULL_RESOURCE_DESCRIPTOR    full;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;

    if (ResourceList == NULL) {
        return NULL;
    }
    numlists = ResourceList->Count;
    full     = ResourceList->List;
    while (numlists--) {
        PCM_PARTIAL_RESOURCE_LIST partial = &full->PartialResourceList;
        ULONG                     count   = partial->Count;

        descriptor = partial->PartialDescriptors;
        while (count--) {

            if (descriptor->Type == DescriptorType) {

                //
                // We have a hit on the type.  If we we are doing a
                // find next, check to see if we're back where we got
                // to last time yet.
                //

                if (PreviousHit != NULL) {
                    if (PreviousHit == descriptor) {

                        //
                        // We found it again, now we can search for real.
                        //

                        PreviousHit = NULL;
                    }
                } else {

                    //
                    // It's the one.
                    //

                    return descriptor;
                }

            }
            descriptor = PciNextPartialDescriptor(descriptor);
        }

        full = (PCM_FULL_RESOURCE_DESCRIPTOR)descriptor;
    }
    return NULL;
}

PVOID
PciFindNextSecondaryExtension(
    IN PSINGLE_LIST_ENTRY   ListEntry,
    IN PCI_SIGNATURE        DesiredType
    )
{
    PPCI_SECONDARY_EXTENSION extension;

    while (ListEntry != NULL) {

        extension = CONTAINING_RECORD(ListEntry,
                                      PCI_SECONDARY_EXTENSION,
                                      List);
        if (extension->ExtensionType == DesiredType) {

            //
            // This extension is the right type, get out.
            //

            return extension;
        }
        ListEntry = extension->List.Next;
    }

    //
    // Didn't find it, fail.
    //
    return NULL;
}

VOID
PcipLinkSecondaryExtension(
    IN PSINGLE_LIST_ENTRY               ListHead,
    IN PFAST_MUTEX                      Mutex,
    IN PVOID                            NewExtension,
    IN PCI_SIGNATURE                    Type,
    IN PSECONDARYEXTENSIONDESTRUCTOR    Destructor
    )

/*++

Routine Description:

    Add a secondary extension to the secondary extension list for
    a PDO/FDO and fill in the header fields.

    NOTE: Use the macro PciLinkSecondaryExtension which takes a
    PDO extension or FDO extension instead of the list header and
    mutex fields.

Arguments:

    ListHead    &SecondaryExtension.Next from the FDO/PDO extension.
    Mutex       FDO/PDO Mutex.
    NewExtension    Extension being added to the list.
    Type            Member of the enum PCI_SIGNATURE.
    Destructor      Routine to call when this entry is being torn down.
                    (Optional).

Return Value:

    None.

--*/

{
    PPCI_SECONDARY_EXTENSION Header;

    PAGED_CODE();

    Header = (PPCI_SECONDARY_EXTENSION)NewExtension;

    Header->ExtensionType = Type;
    Header->Destructor    = Destructor;

    PciInsertEntryAtHead(ListHead, &Header->List, Mutex);
}

VOID
PcipDestroySecondaryExtension(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PFAST_MUTEX        Mutex,
    IN PVOID              Extension
    )

/*++

Routine Description:

    Remove this secondary extension from the list of secondary
    extensions, call its destructor routine and free the memory
    allocated to it.   The destructor is responsible for deleting
    any associated allocations.

    Failure is not an option.

    Note: Use the macro PciDestroySecondaryExtension instead of
    calling this routine directly.

Arguments:

    ListHead    Pointer to the list this extension is on.
    Mutex       Mutex for synchronization of list manipulation.
    Extension   The Secondary extension being destroyed.

Return Value:

    None.

--*/

{
    PPCI_SECONDARY_EXTENSION Header;

    PAGED_CODE();

    Header = (PPCI_SECONDARY_EXTENSION)Extension;

    PciRemoveEntryFromList(ListHead, &Header->List, Mutex);

    //
    // Call the extension's destructor if one was specified.
    //

    if (Header->Destructor != NULL) {
        Header->Destructor(Extension);
    }

    //
    // Free the memory allocated for this extension.
    //

    ExFreePool(Extension);
}

VOID
PciInsertEntryAtTail(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY NewEntry,
    IN PFAST_MUTEX        Mutex
    )
{
    PSINGLE_LIST_ENTRY Previous;

    PAGED_CODE();

    if (Mutex) {
        ExAcquireFastMutex(Mutex);
    }

    //
    // Find the end of the list.
    //

    Previous = ListHead;

    while (Previous->Next) {
        Previous = Previous->Next;
    }

    //
    // Append the entry.
    //

    Previous->Next = NewEntry;

    if (Mutex) {
        ExReleaseFastMutex(Mutex);
    }
}

VOID
PciInsertEntryAtHead(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY NewEntry,
    IN PFAST_MUTEX        Mutex
    )
{
    PAGED_CODE();

    if (Mutex) {
        ExAcquireFastMutex(Mutex);
    }

    NewEntry->Next = ListHead->Next;
    ListHead->Next = NewEntry;

    if (Mutex) {
        ExReleaseFastMutex(Mutex);
    }
}

VOID
PciRemoveEntryFromList(
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY OldEntry,
    IN PFAST_MUTEX        Mutex
    )

/*++

Routine Description:

    Remove an entry from a singly linked list.

    It is the caller's responsibility to have locked the list if
    there is danger of multiple updates.

Arguments:

    ListHead    - Address of the first entry in the list.
    OldEntry    - Address of the entry to be removed from the
                  list.

Return Value:

    None.

--*/

{
    PSINGLE_LIST_ENTRY Previous;

    //
    // Sanity check, the list head can't be removed.
    //

    ASSERT(ListHead != OldEntry);

    if (Mutex) {
        ExAcquireFastMutex(Mutex);
    }

    //
    // Locate the entry that points to this entry.
    //

    for (Previous = ListHead; Previous; Previous = Previous->Next) {
        if (Previous->Next == OldEntry) {
            break;
        }
    }

    //
    // The entry is not in the list - this is bad but fail gracefully...
    //

    if (!Previous) {
        ASSERT(Previous);
        goto exit;
    }

    //
    // Pull it off the list.
    //

    Previous->Next = OldEntry->Next;
    OldEntry->Next = NULL;

exit:

    if (Mutex) {
        ExReleaseFastMutex(Mutex);
    }

}

PCM_PARTIAL_RESOURCE_DESCRIPTOR
PciNextPartialDescriptor(
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    Given a pointer to a CmPartialResourceDescriptor, return a pointer
    to the next descriptor in the same list.

    This is only done in a routine (rather than a simple descriptor++)
    because if the variable length resource CmResourceTypeDeviceSpecific.

Arguments:

    Descriptor   - Pointer to the descriptor being advanced over.

Return Value:

    Pointer to the next descriptor in the same list (or byte beyond
    end of list).

--*/

{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR nextDescriptor;

    nextDescriptor = Descriptor + 1;

    if (Descriptor->Type == CmResourceTypeDeviceSpecific) {

        //
        // This (old) descriptor is followed by DataSize bytes
        // of device specific data, ie, not immediatelly by the
        // next descriptor.   Adjust nextDescriptor by this amount.
        //

        nextDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
            ((ULONG_PTR)nextDescriptor + Descriptor->u.DeviceSpecificData.DataSize);
    }
    return nextDescriptor;
}

VOID
PcipInitializePartialListContext(
    IN PLIST_CONTEXT             ListContext,
    IN PCM_PARTIAL_RESOURCE_LIST PartialList,
    IN CM_RESOURCE_TYPE          DesiredType
    )
{
    ASSERT(DesiredType != CmResourceTypeNull);

    ListContext->List = PartialList;
    ListContext->DesiredType = DesiredType;
    ListContext->Remaining = PartialList->Count;
    ListContext->Next = PartialList->PartialDescriptors;
    ListContext->Alias.Type = CmResourceTypeNull;
}

PCM_PARTIAL_RESOURCE_DESCRIPTOR
PcipGetNextRangeFromList(
    PLIST_CONTEXT ListContext
    )
{
    ULONG Addend;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR current;

    //
    // See if we should be generating an alias to the current
    // descriptor.
    //

    if (ListContext->Alias.Type == ListContext->DesiredType) {

        //
        // Yes, advance to alias by adding offset to next 10 bit or
        // 12 bit alias (only allowable values).
        //

        if (ListContext->Alias.Flags & CM_RESOURCE_PORT_10_BIT_DECODE) {
            Addend = 1 << 10;
        } else {
            Addend = 1 << 12;
        }
        Addend += ListContext->Alias.u.Generic.Start.LowPart;

        if (Addend < (1 << 16)) {

            //
            // This is a valid alias, return it.
            //

            ListContext->Alias.u.Generic.Start.LowPart = Addend;
            return &ListContext->Alias;
        }

        //
        // Out of aliases to this resource.
        //

        ListContext->Alias.Type = CmResourceTypeNull;
    }

    //
    // We get here if there are no aliases or it is time to advance
    // to the next descriptor of the desired type.
    //

    while (ListContext->Remaining != 0) {

        current = ListContext->Next;

        //
        // Advance context to next before examining and possibly
        // returning current.
        //

        ListContext->Next = PciNextPartialDescriptor(current);
        ListContext->Remaining--;

        //
        // Is this current descriptor a candidate?
        //

        if (current->Type == ListContext->DesiredType) {

            //
            // Return this one to caller.   If this descriptor has
            // aliases, setup so the next call will return an alias.
            //

            if (current->Flags & (CM_RESOURCE_PORT_10_BIT_DECODE |
                                  CM_RESOURCE_PORT_12_BIT_DECODE)) {
                ListContext->Alias = *current;
            }
            return current;
        }
    }

    //
    // No aliases and no new descriptors of the desired type.
    //

    return NULL;
}

NTSTATUS
PciQueryPowerCapabilities(
    IN  PPCI_PDO_EXTENSION          PdoExtension,
    IN  PDEVICE_CAPABILITIES    Capabilities
    )
/*++

Routine Description:

    determine a device's power capabilites by using its parent capabilities

    It should be noted that there two ways that the code calculates the system
    and device wake levels. The first method, which is preferred, biases toward
    the deepest possible system state, and the second, which gets used if the
    first fails to find something legal, is biased towards finding the deepest
    possible device wake state

Arguments:

    PdoExtension    - The PDO whose capabilities we will provide
    Capablities     - Where we will store the device capabilities

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    DEVICE_CAPABILITIES     parentCapabilities;
    DEVICE_POWER_STATE      deviceState;
    DEVICE_POWER_STATE      validDeviceWakeState       = PowerDeviceUnspecified;
    SYSTEM_POWER_STATE      index;
    SYSTEM_POWER_STATE      highestSupportedSleepState = PowerSystemUnspecified;
    SYSTEM_POWER_STATE      validSystemWakeState       = PowerSystemUnspecified;

    //
    // Get the device capabilities of the parent
    //
    status = PciGetDeviceCapabilities(
        PdoExtension->ParentFdoExtension->PhysicalDeviceObject,
        &parentCapabilities
        );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // Make sure that we have sane device capabilities to start with...
    //
    if (parentCapabilities.DeviceState[PowerSystemWorking] == PowerDeviceUnspecified) {

        parentCapabilities.DeviceState[PowerSystemWorking] = PowerDeviceD0;

    }
    if (parentCapabilities.DeviceState[PowerSystemShutdown] == PowerDeviceUnspecified) {

        parentCapabilities.DeviceState[PowerSystemShutdown] = PowerDeviceD3;

    }

    //
    // Does the device have any PCI power capabilities?
    //
    if ( (PdoExtension->HackFlags & PCI_HACK_NO_PM_CAPS)) {

        //
        // Use the parent's mapping as our own
        //
        RtlCopyMemory(
            Capabilities->DeviceState,
            parentCapabilities.DeviceState,
            (PowerSystemShutdown + 1) * sizeof(DEVICE_POWER_STATE)
            );

        //
        // As D1 and D2 are not supported here, round down to D3.
        //
        //     This code is not enabled so that a hack becomes available for
        // older PCI video cards. Basically, older video cards can do D3 hot
        // but not D3 cold (in which case they need reposting). ACPI supplies
        // a hack by which all PCI-to-PCI bridges are said to map S1->D1. The
        // code below lets the parent's D1 "appear" as a state the child
        // supports, regardless of it's real capabilities. Video drivers for
        // such cards fail D3 (which may be D3-cold), but succeed D1 (which is
        // really D3-hot).
        //
        // Also note that this is not targetted at video cards but rather is
        // targetted at any non-PCI power managed device. That means drivers
        // for older devices need to either map D1&D2 to D3 themselves, or
        // treat unexpected D1&D2 IRPs as if D3. Folklore says that there is
        // also a net card or two that also takes advantage of this hack.
        //
#if 0
        for (index = PowerSystemWorking; index < PowerSystemMaximum; index++) {

            //
            // This is the device state that the parent supports
            //
            deviceState = parentCapabilities.DeviceState[index];

            //
            // Round down if D1 or D2
            //
            if ((deviceState == PowerDeviceD1) || (deviceState == PowerDeviceD2)) {

                Capabilities->DeviceState[index] = PowerDeviceD3;
            }
        }
#endif

        //
        // The device has no wake capabilities
        //
        Capabilities->DeviceWake = PowerDeviceUnspecified;
        Capabilities->SystemWake = PowerSystemUnspecified;

        //
        // Set these bits explicitly
        //
        Capabilities->DeviceD1 = FALSE;
        Capabilities->DeviceD2 = FALSE;
        Capabilities->WakeFromD0 = FALSE;
        Capabilities->WakeFromD1 = FALSE;
        Capabilities->WakeFromD2 = FALSE;
        Capabilities->WakeFromD3 = FALSE;

        //
        // Done
        //
        return STATUS_SUCCESS;

    }

    //
    // Set all the capabilities bits
    //
    Capabilities->DeviceD1 = PdoExtension->PowerCapabilities.Support.D1;
    Capabilities->DeviceD2 = PdoExtension->PowerCapabilities.Support.D2;
    Capabilities->WakeFromD0 = PdoExtension->PowerCapabilities.Support.PMED0;
    Capabilities->WakeFromD1 = PdoExtension->PowerCapabilities.Support.PMED1;
    Capabilities->WakeFromD2 = PdoExtension->PowerCapabilities.Support.PMED2;
    if (parentCapabilities.DeviceWake == PowerDeviceD3) {

        //
        // If our parent can wake from the D3 state, than we must support
        // PM3 From D3 Cold. The (obvious) exception to this is if the
        // parent is a root bus...
        //
        if (PCI_PDO_ON_ROOT(PdoExtension)) {

            Capabilities->WakeFromD3 =
                PdoExtension->PowerCapabilities.Support.PMED3Hot;

        } else {

            Capabilities->WakeFromD3 =
                PdoExtension->PowerCapabilities.Support.PMED3Cold;

        }

    } else {

        //
        // If our parent cannot wake from the D3 state, then we support
        // the D3 state if we support PME3Hot
        //
        Capabilities->WakeFromD3 =
            PdoExtension->PowerCapabilities.Support.PMED3Hot;

    }

    //
    // First step is to make sure that all the S-states that we got from
    // out parent map to valid D-states for this device
    //
    // ADRIAO N.B. 08/18/1999 -
    //     This algorithm works but it's overly aggressive. It is in fact legal
    // for a bridge to be in D2 with a card behind it in D1.
    //
    for (index = PowerSystemWorking; index < PowerSystemMaximum; index++) {

        //
        // This is the device state that the parent supports
        //
        deviceState = parentCapabilities.DeviceState[index];

        //
        // If the device state is D1 and we don't support D1, then
        // consider D2 instead
        //
        if (deviceState == PowerDeviceD1 &&
            PdoExtension->PowerCapabilities.Support.D1 == FALSE) {

            deviceState++;

        }

        //
        // If the device state is D2 and we don't support D2, then
        // consider D3 instead
        //
        if (deviceState == PowerDeviceD2 &&
            PdoExtension->PowerCapabilities.Support.D2 == FALSE) {

            deviceState++;

        }

        //
        // We should be able to support this deviceState
        //
        Capabilities->DeviceState[index] = deviceState;

        //
        // If this S-state is less than PowerSystemHibernate, and the
        // S-State doesn't map to PowerDeviceUnspecified, then consider
        // this to be the highest supported SleepState
        //
        if (index < PowerSystemHibernate &&
            Capabilities->DeviceState[index] != PowerDeviceUnspecified) {

            highestSupportedSleepState = index;

        }

        //
        // Can we support this as a wake state?
        //
        if (index < parentCapabilities.SystemWake &&
            deviceState >= parentCapabilities.DeviceState[index] &&
            parentCapabilities.DeviceState[index] != PowerDeviceUnspecified) {

            //
            // Consider using this as a valid wake state
            //
            if ( (deviceState == PowerDeviceD0 && Capabilities->WakeFromD0) ||
                 (deviceState == PowerDeviceD1 && Capabilities->WakeFromD1) ||
                 (deviceState == PowerDeviceD2 && Capabilities->WakeFromD2) ) {

                validSystemWakeState = index;
                validDeviceWakeState = deviceState;

            } else if (deviceState == PowerDeviceD3 &&
                       PdoExtension->PowerCapabilities.Support.PMED3Hot) {

                //
                // This is a special case logic (which is why it is seperate from
                // the above logic
                //
                if (parentCapabilities.DeviceState[index] < PowerDeviceD3 ||
                    PdoExtension->PowerCapabilities.Support.PMED3Cold) {

                    validSystemWakeState = index;
                    validDeviceWakeState = deviceState;

                }

            }

        }

    }

    //
    // Does the parent device have power management capabilities?
    // Does the device have power management capabilities?
    // Can we wake up from the same D-states that our parent can? or better?
    //
    if (parentCapabilities.SystemWake == PowerSystemUnspecified ||
        parentCapabilities.DeviceWake == PowerDeviceUnspecified ||
        PdoExtension->PowerState.DeviceWakeLevel == PowerDeviceUnspecified ||
        PdoExtension->PowerState.DeviceWakeLevel < parentCapabilities.DeviceWake) {

        //
        // The device doesn't support any kind of wakeup (that we know about)
        // or the device doesn't support wakeup from supported D-states, so
        // set the latency and return
        //
        Capabilities->D1Latency  = 0;
        Capabilities->D2Latency  = 0;
        Capabilities->D3Latency  = 0;

        return STATUS_SUCCESS;

    }

    //
    // We should be able to wake the device from the same state
    // that our parent can wake from
    //
    Capabilities->SystemWake = parentCapabilities.SystemWake;
    Capabilities->DeviceWake = PdoExtension->PowerState.DeviceWakeLevel;

    //
    // Change our device wake level to include a state that we support
    //
    if (Capabilities->DeviceWake == PowerDeviceD0 && !Capabilities->WakeFromD0) {

        Capabilities->DeviceWake++;

    }
    if (Capabilities->DeviceWake == PowerDeviceD1 && !Capabilities->WakeFromD1) {

        Capabilities->DeviceWake++;

    }
    if (Capabilities->DeviceWake == PowerDeviceD2 && !Capabilities->WakeFromD2) {

        Capabilities->DeviceWake++;

    }
    if (Capabilities->DeviceWake == PowerDeviceD3 && !Capabilities->WakeFromD3) {

        Capabilities->DeviceWake = PowerDeviceUnspecified;
        Capabilities->SystemWake = PowerSystemUnspecified;

    }

    //
    // This is our fallback position. If we got here and there is no wake
    // capability using the above method of calcuation, then we should
    // check to see if we noticed a valid wake combination while scanning
    // the S to D mapping information
    //
    if ( (Capabilities->DeviceWake == PowerDeviceUnspecified  ||
          Capabilities->SystemWake == PowerSystemUnspecified) &&
         (validSystemWakeState != PowerSystemUnspecified &&
          validDeviceWakeState != PowerSystemUnspecified) ) {

        Capabilities->DeviceWake = validDeviceWakeState;
        Capabilities->SystemWake = validSystemWakeState;

        //
        // Note that in this case, we might have set DeviceWake to D3, without
        // having set the bit, so "correct" that situation.
        //
        if (validDeviceWakeState == PowerDeviceD3) {

            Capabilities->WakeFromD3 = TRUE;

        }

    }
    //
    // We shouldn't allow Wake From S4, S5, unless the supports the D3 state
    // Even then, we really shouldn't allow S4, S5 unless the device supports
    // the D3Cold PME state
    //
    if (Capabilities->SystemWake > PowerSystemSleeping3) {

        //
        // Does the device support wake from D3?
        //
        if (Capabilities->DeviceWake != PowerDeviceD3) {

            //
            // Reduce the systemwake level to something more realistic
            //
            Capabilities->SystemWake = highestSupportedSleepState;

        }

        //
        // This is in a seperate if statement so that the code can be easily
        // commented out
        //
        if (!PdoExtension->PowerCapabilities.Support.PMED3Cold) {

            //
            // Reduce the systemwake level to something more realistic
            //
            Capabilities->SystemWake = highestSupportedSleepState;

        }

    }

    //
    // From the PCI Power Management spec V1.0, table 18
    // "PCI Function State Transition Delays".
    //
    // D1 -> D0  0
    // D2 -> D0  200 us
    // D3 -> D0  10  ms
    //
    // The latency entries are in units of 100 us.
    //
    Capabilities->D1Latency  = 0;
    Capabilities->D2Latency  = 2;
    Capabilities->D3Latency  = 100;

    //
    // Make sure that S0 maps to D0
    //
    ASSERT( Capabilities->DeviceState[PowerSystemWorking] == PowerDeviceD0);

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
PciDetermineSlotNumber(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN OUT PULONG SlotNumber
    )

/*++

Description:

    Determine the slot number associated with a PCI device (if any)
    through use of the PCI IRQ routing table information we may have
    stored earlier.

    If the previous mechanism fails to retrieve a slot number, see if
    we can inherit our parent's slot number.

    This result may be filtered further by ACPI and other bus filters..

Arguments:

    PdoExtension - PDO extension of device in question.
    SlotNumber - Pointer to slot number to update

Return Value:

    STATUS_SUCCESS if slot # found

--*/

{
    PSLOT_INFO slotInfo, lastSlot;
    NTSTATUS status;
    ULONG length;

    if (PciIrqRoutingTable == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Don't return UI numbers if we don't have a parent to check for BaseBus
    //

    if (PCI_PARENT_FDOX(PdoExtension) == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    slotInfo = (PSLOT_INFO)((PUCHAR) PciIrqRoutingTable +
                            sizeof(PCI_IRQ_ROUTING_TABLE));
    lastSlot = (PSLOT_INFO)((PUCHAR) PciIrqRoutingTable +
                            PciIrqRoutingTable->TableSize);

    // Search for a entry in the routing table that matches this device

    while (slotInfo < lastSlot) {
        if ((PCI_PARENT_FDOX(PdoExtension)->BaseBus == slotInfo->BusNumber)  &&
            ((UCHAR)PdoExtension->Slot.u.bits.DeviceNumber == (slotInfo->DeviceNumber >> 3)) &&
            (slotInfo->SlotNumber != 0)) {
            *SlotNumber = slotInfo->SlotNumber;
            return STATUS_SUCCESS;
        }
        slotInfo++;
    }

    //
    // Maybe our parent has a UI Number that we could 'inherit'.
    // but only if we're not a PDO off a root bus otherwise we pick up
    // the UI number from the PNPA03 node (likely 0)
    //

    if (PCI_PDO_ON_ROOT(PdoExtension)) {
        return STATUS_UNSUCCESSFUL;
    }

    status = IoGetDeviceProperty(PCI_PARENT_PDO(PdoExtension),
                                 DevicePropertyUINumber,
                                 sizeof(*SlotNumber),
                                 SlotNumber,
                                 &length);
    return status;
}

NTSTATUS
PciQueryCapabilities(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PDEVICE_CAPABILITIES Capabilities
    )

/*++

Routine Description:

    return a subset of our parent's capabilities.

Arguments:

    Capabilities - pointer to a DEVICE_CAPABILITIES structured supplied
                   by the caller.

Return Value:

    Status.

--*/

{
    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       slot;

#ifndef HANDLE_BOGUS_CAPS
    if (Capabilities->Version < 1) {

        //
        // do not touch irp!
        //
        return STATUS_NOT_SUPPORTED;

    }
#endif

    //
    // For PCI devices, the Capabilities Address field contains
    // the Device Number in the upper 16 bits and the function
    // number in the lower.
    //
    Capabilities->Address =
        PdoExtension->Slot.u.bits.DeviceNumber << 16 |
        PdoExtension->Slot.u.bits.FunctionNumber;

    //
    // The PCI bus driver does not generate Unique IDs for its children.
    //
    Capabilities->UniqueID = FALSE;

    //
    // If this PDO is for a HOST BRIDGE, claim that it supports
    // being handled Raw.  This is so the device controller will
    // allow installation of the NULL device on this puppy.
    //

    if ((PdoExtension->BaseClass == PCI_CLASS_BRIDGE_DEV) &&
        (PdoExtension->SubClass  == PCI_SUBCLASS_BR_HOST)) {

        Capabilities->RawDeviceOK = TRUE;

    } else {

        Capabilities->RawDeviceOK = FALSE;

    }

    //
    // The following values should be fixed by filters or function
    // drivers that actually know the answer.
    //
    Capabilities->LockSupported = FALSE;
    Capabilities->EjectSupported = FALSE;
    Capabilities->Removable = FALSE;
    Capabilities->DockDevice = FALSE;

    PciDetermineSlotNumber(PdoExtension, &Capabilities->UINumber);

    //
    // Get the device power capabilities
    //
    status = PciQueryPowerCapabilities( PdoExtension, Capabilities );
    if (!NT_SUCCESS(status)) {

        return status;

    }

#if DBG
    if (PciDebug & PciDbgQueryCap) {

        PciDebugDumpQueryCapabilities(Capabilities);

    }
#endif

    //
    // Done
    //
    return status;
}

NTSTATUS
PciQueryBusInformation(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPNP_BUS_INFORMATION *BusInformation
    )

/*++

Routine Description:

    Tell PnP that it's talking to a PCI bus.

Arguments:

    BusInformation - Pointer to a PPNP_BUS_INFORMATION.  We create
                     a PNP_BUS_INFORMATION and pass its address
                     back thru here.

Return Value:

    Status.

--*/

{
    PPNP_BUS_INFORMATION information;

    information = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, sizeof(PNP_BUS_INFORMATION));

    if (information == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(&information->BusTypeGuid, &GUID_BUS_TYPE_PCI, sizeof(GUID));
    information->LegacyBusType = PCIBus;
    information->BusNumber = PCI_PARENT_FDOX(PdoExtension)->BaseBus;

    *BusInformation = information;

    return STATUS_SUCCESS;
}

NTSTATUS
PciQueryLegacyBusInformation(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PLEGACY_BUS_INFORMATION *BusInformation
    )

/*++

Routine Description:

    Tell PnP that it's talking to a PCI bus.

Arguments:

    BusInformation - Pointer to a PLEGACY_BUS_INFORMATION.  We create
                     a LEGACY_BUS_INFORMATION and pass its address
                     back thru here.

Return Value:

    Status.

--*/

{
    PLEGACY_BUS_INFORMATION information;

    information = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, sizeof(LEGACY_BUS_INFORMATION));

    if (information == NULL) {
        ASSERT(information != NULL);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(&information->BusTypeGuid, &GUID_BUS_TYPE_PCI, sizeof(GUID));
    information->LegacyBusType = PCIBus;
    information->BusNumber = FdoExtension->BaseBus;

    *BusInformation = information;

    return STATUS_SUCCESS;
}

NTSTATUS
PciGetInterruptAssignment(
    IN PPCI_PDO_EXTENSION PdoExtension,
    OUT ULONG *Minimum,
    OUT ULONG *Maximum
    )
{
    UCHAR pin       = PdoExtension->InterruptPin;
    UCHAR line;

    //
    // Using HAL for interrupts.
    //

    PIO_RESOURCE_REQUIREMENTS_LIST reqList;
    PIO_RESOURCE_DESCRIPTOR resource;
    PCI_SLOT_NUMBER  slot;
    NTSTATUS         status = STATUS_RESOURCE_TYPE_NOT_FOUND;

    if (pin != 0) {

        //
        // This hardware uses an interrupt.
        //
        // Depend on the HAL to understand how IRQ routing is
        // really done.
        //

        reqList = PciAllocateIoRequirementsList(
                      1,                            // number of resources
                      PCI_PARENT_FDOX(PdoExtension)->BaseBus,
                      PdoExtension->Slot.u.AsULONG
                      );

        if (reqList == NULL) {

            //
            // Out of system resources?  Bad things are happening.
            //

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        resource = reqList->List[0].Descriptors;
        resource->Type = CmResourceTypeInterrupt;
        resource->ShareDisposition = CmResourceShareShared;
        resource->Option = 0;
        resource->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
        resource->u.Interrupt.MinimumVector = 0x00;
        resource->u.Interrupt.MaximumVector = 0xff;

#if defined(NO_LEGACY_DRIVERS)
        *Minimum = 0;
        *Maximum = 0xFF;
        status = STATUS_SUCCESS;
#else
        status = HalAdjustResourceList(&reqList);

        //
        // If the HAL succeeded it will have reallocated the list.
        //
        resource = reqList->List[0].Descriptors;

        if (!NT_SUCCESS(status)) {

            PciDebugPrint(
                PciDbgInformative,
                "    PIN %02x, HAL FAILED Interrupt Assignment, status %08x\n",
                pin,
                status
                );

            status = STATUS_UNSUCCESSFUL;

        } else if (resource->u.Interrupt.MinimumVector >
                   resource->u.Interrupt.MaximumVector) {

            //
            // The HAL succeeded but returned an invalid range.  This
            // is the HALs way of telling us that, sorry, it doesn't
            // know either.
            //

            //
            // We have a bug in that we restore the interrupt line to
            // config space before we power up the device and thus if
            // the device is in D>0 and the interrupt line register
            // isn't sticky it doesn't stick.  It doesn't matter unless
            // we are on a machine that doesn't support interrupt
            // routing in which case we are toast.  The correct fix is
            // to move the restore code after we power managed the device
            // but that changes things too much for Whistler Beta2 and this
            // is totally rewritten for Blackcomb so, now that you know
            // the right way to fix this, the hack is if the HAL fails
            // the call use what we would have restored into the interrupt
            // line.
            //

            //
            // Get the current int line (this is in the same place for all header types)
            //

            PciReadDeviceConfig(PdoExtension,
                                &line,
                                FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.InterruptLine),
                                sizeof(line)
                                );

            //
            // If this is 0 and it was something when we first saw the device then use
            // what we first saw
            //

            if (line == 0 && PdoExtension->RawInterruptLine != 0) {
                *Minimum = *Maximum = (ULONG)PdoExtension->RawInterruptLine;

                status = STATUS_SUCCESS;

            } else {

                PciDebugPrint(
                    PciDbgInformative,
                    "    PIN %02x, HAL could not assign interrupt.\n",
                    pin
                    );

                status = STATUS_UNSUCCESSFUL;
            }

        } else {

            *Minimum = resource->u.Interrupt.MinimumVector;
            *Maximum = resource->u.Interrupt.MaximumVector;

            PciDebugPrint(
                PciDbgObnoxious,
                "    Interrupt assigned = 0x%x through 0x%x\n",
                *Minimum,
                *Maximum
                );

            status = STATUS_SUCCESS;
        }
        ExFreePool(reqList);

#endif // NO_LEGACY_DRIVERS

    } else {

#if MSI_SUPPORTED

        if (PdoExtension->CapableMSI) {

            //
            // MSI Only device - we need to return a success here so that
            // this device gets resource requests passed to a (hopefully)
            // MSI-aware arbiter. If the arbiter is not MSI aware, we will
            // simply get extraneous/unusable resources allocated for this
            // device - not to mention the fact that the device will not work.
            //
            // The below could be anything, they are only limited by message
            // size and the available APIC ranges which only the arbiter
            // knows about.
            //

            *Minimum = 0x00;
            *Maximum = 0xFF;

            status = STATUS_SUCCESS;
        }

#endif // MSI_SUPPORTED

    }
    return status;
}

PPCI_PDO_EXTENSION
PciFindPdoByFunction(
    IN PPCI_FDO_EXTENSION FdoExtension,
    IN PCI_SLOT_NUMBER Slot,
    IN PPCI_COMMON_CONFIG Config
    )
{
    PPCI_PDO_EXTENSION pdoExtension;
    KIRQL currentIrql;

    //
    // This can be called at >= DISPATCH_LEVEL when we scan the bus on returning
    // from hibernate.  Don't try to acquire the locks because (1) it'll crash
    // and (2) it is guaranteed to be single threaded
    //

    currentIrql = KeGetCurrentIrql();

    if (currentIrql < DISPATCH_LEVEL) {
        ExAcquireFastMutex(&FdoExtension->ChildListMutex);
    };

    //
    // Seach each PDO hanging off of the given FDO until we find a matching
    // PCI function or fall off the end of the list.
    //

    for (pdoExtension = FdoExtension->ChildPdoList;
         pdoExtension;
         pdoExtension = pdoExtension->Next) {

        if ((!pdoExtension->ReportedMissing) &&
            (pdoExtension->Slot.u.bits.DeviceNumber == Slot.u.bits.DeviceNumber)   &&
            (pdoExtension->Slot.u.bits.FunctionNumber == Slot.u.bits.FunctionNumber)) {

            //
            // Check that the device in this slot hasn't changed. (as best
            // we can).
            //

            if (   (pdoExtension->VendorId   == Config->VendorID)
                && (pdoExtension->DeviceId   == Config->DeviceID)
                && (pdoExtension->RevisionId == Config->RevisionID)
#if 0
                //
                // NTRAID #62668 - 4/25/2000
                //
                // These do not contribute towards the device ID itself, and
                // as they are unfortunately volatile on some cards (SubClass
                // changes on the ATIRage, Programming interface on IDE cards).
                // Therefore a change in these fields does not mean a change in
                // the presence of the card.
                //
                // What about the SSVID?
                //
                && (pdoExtension->ProgIf     == Config->ProgIf)
                && (pdoExtension->SubClass   == Config->SubClass)
                && (pdoExtension->BaseClass  == Config->BaseClass)
#endif
                ) {

                break;
            }
        }
    }

    if (currentIrql < DISPATCH_LEVEL) {
        ExReleaseFastMutex(&FdoExtension->ChildListMutex);
    }

    return pdoExtension;
}

PPCI_FDO_EXTENSION
PciFindParentPciFdoExtension(
    PDEVICE_OBJECT PhysicalDeviceObject,
    IN PFAST_MUTEX Mutex
    )

/*++

Routine Description:

    For each Parent PCI FDO, search the child Pdo lists for the supplied
    PhysicalDeviceObject.

Arguments:

    PhysicalDeviceObject    Pdo to find.
    Mutex                   Mutex list is protected by.

Return Value:

    If Pdo is found as a child, returns a pointer to the root Fdo's
    device extension, otherwise returns NULL.

--*/

{
    PPCI_FDO_EXTENSION     fdoExtension;
    PPCI_PDO_EXTENSION     pdoExtension;
    PPCI_PDO_EXTENSION     target;
    PSINGLE_LIST_ENTRY nextEntry;

    if (Mutex) {
        ExAcquireFastMutex(Mutex);
    }

    target = (PPCI_PDO_EXTENSION)PhysicalDeviceObject->DeviceExtension;

    //
    // For each root
    //

    for ( nextEntry = PciFdoExtensionListHead.Next;
          nextEntry != NULL;
          nextEntry = nextEntry->Next ) {

        fdoExtension = CONTAINING_RECORD(nextEntry,
                                         PCI_FDO_EXTENSION,
                                         List);

        //
        // Search the child Pdo list.
        //

        ExAcquireFastMutex(&fdoExtension->ChildListMutex);
        for ( pdoExtension = fdoExtension->ChildPdoList;
              pdoExtension;
              pdoExtension = pdoExtension->Next ) {

            //
            // Is this the one we're looking for?
            //

            if ( pdoExtension == target ) {

                ExReleaseFastMutex(&fdoExtension->ChildListMutex);

                //
                // Yes, return it.
                //

                if (Mutex) {
                     ExReleaseFastMutex(Mutex);
                }

                return fdoExtension;
            }
        }
        ExReleaseFastMutex(&fdoExtension->ChildListMutex);
    }

    //
    // Did not find match.
    //
    if (Mutex) {
         ExReleaseFastMutex(Mutex);
    }

    return NULL;
}

PCI_OBJECT_TYPE
PciClassifyDeviceType(
    PPCI_PDO_EXTENSION PdoExtension
    )

/*++

Routine Description:

    Examine the Configuration Header BaseClass and SubClass fields
    and classify the device into a simple enumerated type.

Arguments:

    PdoExtension    Pointer to the Physical Device Object extension
                    into which the above fields have been previously
                    been copied from PCI config space.

Return Value:

    Returns a device type from the PCI_OBJECT_TYPE enumeration.

--*/

{
    ASSERT_PCI_PDO_EXTENSION(PdoExtension);

    switch (PdoExtension->BaseClass) {

    case PCI_CLASS_BRIDGE_DEV:

        //
        // It's a bridge, subdivide it into the kind of bridge.
        //

        switch (PdoExtension->SubClass) {

        case PCI_SUBCLASS_BR_HOST:

            return PciTypeHostBridge;

        case PCI_SUBCLASS_BR_PCI_TO_PCI:

            return PciTypePciBridge;

        case PCI_SUBCLASS_BR_CARDBUS:

            return PciTypeCardbusBridge;

        default:

            //
            // Anything else is just a device.
            //

            break;
        }

    default:

        //
        // Anything else is just another device.
        //

        break;
    }
    return PciTypeDevice;
}

ULONG
PciGetLengthFromBar(
    ULONG BaseAddressRegister
    )

/*++

Routine Description:

    Given the contents of a PCI Base Address Register, after it
    has been written with all ones, this routine calculates the
    length (and alignment) requirement for this BAR.

    This method for determining requirements is described in
    section 6.2.5.1 of the PCI Specification (Rev 2.1).

    NTRAID #62631 - 4/25/2000 - andrewth
    The length is a power of two, given only a ULONG to
    contain it, we are restricted to a maximum resource size of
    2GB.

Arguments:

    BaseAddressRegister contains something.

Return Value:

    Returns the length of the resource requirement.  This will be a number
    in the range 0 thru 0x80000000.

--*/

{
    ULONG Length;

    //
    // A number of least significant bits should be ignored in the
    // determination of the length.  These are flag bits, the number
    // of bits is dependent on the type of the resource.
    //

    if (BaseAddressRegister & PCI_ADDRESS_IO_SPACE) {

        //
        // PCI IO space.
        //

        BaseAddressRegister &= PCI_ADDRESS_IO_ADDRESS_MASK;

    } else {

        //
        // PCI Memory space.
        //

        BaseAddressRegister &= PCI_ADDRESS_MEMORY_ADDRESS_MASK;
    }

    //
    // BaseAddressRegister now contains the maximum base address
    // this device can reside at and still exist below the top of
    // memory.
    //
    // The value 0xffffffff was written to the BAR.  The device will
    // have adjusted this value to the maximum it can really use.
    //
    // Length MUST be a power of 2.
    //
    // For most devices, h/w will simply have cleared bits from the
    // least significant bit positions so that the address 0xffffffff
    // is adjusted to accomodate the length.  eg: if the new value is
    // 0xffffff00, the device requires 256 bytes.
    //
    // The difference between the original and new values is the length (-1).
    //
    // For example, if the value fead back from the BAR is 0xffff0000,
    // the length of this resource is
    //
    //     0xffffffff - 0xffff0000 + 1
    //   = 0x0000ffff + 1
    //   = 0x00010000
    //
    //  ie 16KB.
    //
    // Some devices cannot reside at the top of PCI address space.  These
    // devices will have adjusted the value such that length bytes are
    // accomodated below the highest address.  For example, if a device
    // must reside below 1MB, and occupies 256 bytes, the value will now
    // be 0x000fff00.
    //
    // In the first case, length can be calculated as-
    //

    Length = (0xffffffff - BaseAddressRegister) + 1;

    if (((Length - 1) & Length) != 0) {

        //
        // We didn't end up with a power of two, must be the latter
        // case, we will have to scan for it.
        //

        Length = 4;     // start with minimum possible

        while ((Length | BaseAddressRegister) != BaseAddressRegister) {

            //
            // Length *= 2, note we will eventually drop out of this
            // loop for one of two reasons (a) because we found the
            // length, or (b) because Length left shifted off the end
            // and became 0.
            //

            Length <<= 1;
        }
    }

    //
    // Check that we got something - if this is a 64bit bar then nothing is ok as
    // we might be asking for a range >= 4GB (not that that's going to work any time soon)
    //

    if (!((BaseAddressRegister & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_64BIT)) {
        ASSERT(Length);
    }

    return Length;
}

BOOLEAN
PciCreateIoDescriptorFromBarLimit(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    IN PULONG BaseAddress,
    IN BOOLEAN Rom
    )

/*++

Description:

    Generate an IO resource descriptor to describe the settings
    a Base Address Register can take.

Arguments:

    Descriptor -
    BaseAddress - Pointer to the value read from a base address register
                  immediately after writing all ones to it.
    Rom         - If true, this is a base address register for ROM.

Return Value:

    Returns TRUE if this address register was a 64 bit address register,
    FALSE otherwise.

--*/

{
    ULONG bar = *BaseAddress;
    ULONG length;
    ULONG addressMask;
    BOOLEAN returnValue = FALSE;

    //
    // If the Base Address Register contains zero after being written
    // with all ones, it is not implemented.  Set the resource type to
    // NULL, no further processing is required.
    //
    // Note: We ignore the I/O bit in the BAR due to HARDWARE BUGS
    // in some people's hardware.
    //

    if ((bar & ~1) == 0) {
        Descriptor->Type = CmResourceTypeNull;
        return FALSE;
    }

    //
    // Default to ordinary (32 bit) memory.
    //

    Descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
    Descriptor->u.Memory.MaximumAddress.HighPart = 0;
    Descriptor->u.Memory.MinimumAddress.QuadPart = 0;

    if (Rom == TRUE) {

        //
        // Mask out unused bits and indicate in the descriptor that
        // this entry describes ROM.
        //

        bar &= PCI_ADDRESS_ROM_ADDRESS_MASK;
        Descriptor->Flags = CM_RESOURCE_MEMORY_READ_ONLY;
    }

    //
    // Ranges described by PCI Base Address Registers must be a
    // power of 2 in length and naturally aligned.  Get the length
    // and set the length and alignment in the descriptor.
    //

    length = PciGetLengthFromBar(bar);
    Descriptor->u.Generic.Length = length;
    Descriptor->u.Generic.Alignment = length;

    if ((bar & PCI_ADDRESS_IO_SPACE) != 0) {

        //
        // This BAR describes I/O space.
        //

        addressMask = PCI_ADDRESS_IO_ADDRESS_MASK;
        Descriptor->Type = CmResourceTypePort;
        Descriptor->Flags = CM_RESOURCE_PORT_IO;

    } else {

        //
        // This BAR describes PCI memory space.
        //

        addressMask = PCI_ADDRESS_MEMORY_ADDRESS_MASK;
        Descriptor->Type = CmResourceTypeMemory;

        if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_64BIT) {

            //
            // This is a 64 bit PCI device.  Get the high 32 bits
            // from the next BAR.
            //

            Descriptor->u.Memory.MaximumAddress.HighPart = *(BaseAddress+1);
            returnValue = TRUE;

        } else if ((bar & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_20BIT) {

            //
            // This device must locate below 1MB, the BAR shouldn't
            // have any top bits set but this isn't clear from the
            // spec.  Enforce it by clearing the top bits.
            //

            addressMask &= 0x000fffff;
        }

        if (bar & PCI_ADDRESS_MEMORY_PREFETCHABLE) {
            Descriptor->Flags |= CM_RESOURCE_MEMORY_PREFETCHABLE;
        }
    }
    Descriptor->u.Generic.MaximumAddress.LowPart = bar & addressMask;
    Descriptor->u.Generic.MaximumAddress.QuadPart += (length - 1);

    return returnValue;
}

VOID
PciInvalidateResourceInfoCache(
    IN PPCI_PDO_EXTENSION PdoExtension
    )

/*++

Description:

    Delete any cached resource information as it is (potentially)
    no longer valid.

    Currently this doesn't actually have anything to do.

Arguments:

    PdoExtension    PDO cached info may be associated with.

Return Value:

    None.

--*/

{
}

BOOLEAN
PciOpenKey(
    IN  PWSTR   KeyName,
    IN  HANDLE  ParentHandle,
    OUT PHANDLE Handle,
    OUT PNTSTATUS Status
    )

/*++

Description:

    Open a registry key.

Arguments:

    KeyName      Name of the key to be opened.
    ParentHandle Pointer to the parent handle (OPTIONAL)
    Handle       Pointer to a handle to recieve the opened key.

Return Value:

    TRUE is key successfully opened, FALSE otherwise.

--*/

{
    UNICODE_STRING    nameString;
    OBJECT_ATTRIBUTES nameAttributes;
    NTSTATUS localStatus;

    PAGED_CODE();

    RtlInitUnicodeString(&nameString, KeyName);

    InitializeObjectAttributes(&nameAttributes,
                               &nameString,
                               OBJ_CASE_INSENSITIVE,
                               ParentHandle,
                               (PSECURITY_DESCRIPTOR)NULL
                               );
    localStatus = ZwOpenKey(Handle,
                            KEY_READ,
                            &nameAttributes
                            );

    if (Status != NULL) {

        //
        // Caller wants underlying status.
        //

        *Status = localStatus;
    }

    //
    // Return status converted to a boolean, TRUE if
    // successful.
    //

    return NT_SUCCESS(localStatus);
}

NTSTATUS
PciGetRegistryValue(
    IN  PWSTR   ValueName,
    IN  PWSTR   KeyName,
    IN  HANDLE  ParentHandle,
    OUT PVOID   *Buffer,
    OUT ULONG   *Length
    )
{
    NTSTATUS status;
    HANDLE keyHandle;
    ULONG neededLength;
    ULONG actualLength;
    UNICODE_STRING unicodeValueName;
    PKEY_VALUE_PARTIAL_INFORMATION info;

    if (!PciOpenKey(KeyName, ParentHandle, &keyHandle, &status)) {
        return status;
    }

    unicodeValueName.Buffer = ValueName;
    unicodeValueName.MaximumLength = (wcslen(ValueName) + 1) * sizeof(WCHAR);
    unicodeValueName.Length = unicodeValueName.MaximumLength - sizeof(WCHAR);

    //
    // Find out how much memory we need for this.
    //

    status = ZwQueryValueKey(
                 keyHandle,
                 &unicodeValueName,
                 KeyValuePartialInformation,
                 NULL,
                 0,
                 &neededLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        ASSERT(neededLength != 0);

        //
        // Get memory to return the data in.  Note this includes
        // a header that we really don't want.
        //

        info = ExAllocatePool(
                   PagedPool | POOL_COLD_ALLOCATION,
                   neededLength);
        if (info == NULL) {
            ZwClose(keyHandle);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Get the data.
        //

        status = ZwQueryValueKey(
                 keyHandle,
                 &unicodeValueName,
                 KeyValuePartialInformation,
                 info,
                 neededLength,
                 &actualLength
                 );
        if (!NT_SUCCESS(status)) {

            ASSERT(NT_SUCCESS(status));
            ExFreePool(info);
            ZwClose(keyHandle);
            return status;
        }

        ASSERT(neededLength == actualLength);

        //
        // Subtract out the header size and get memory for just
        // the data we want.
        //

        neededLength -= FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);

        *Buffer = ExAllocatePool(
                      PagedPool | POOL_COLD_ALLOCATION,
                      neededLength
                      );
        if (*Buffer == NULL) {
            ExFreePool(info);
            ZwClose(keyHandle);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Copy data sans header.
        //

        RtlCopyMemory(*Buffer, info->Data, neededLength);
        ExFreePool(info);

        if (Length) {
            *Length = neededLength;
        }

    } else {

#if DBG

        PciDebugPrint(
            PciDbgInformative,
            "PCI - Unexpected status %08x from ZwQueryValueKey, expected\n",
            status
            );
        PciDebugPrint(
            PciDbgInformative,
            "      STATUS_BUFFER_TOO_SMALL (%08x).\n",
            STATUS_BUFFER_TOO_SMALL
            );

#endif

        if (NT_SUCCESS(status)) {

            //
            // We don't want to report success when this happens.
            //

            status = STATUS_UNSUCCESSFUL;
        }
    }
    ZwClose(keyHandle);
    return status;
}

NTSTATUS
PciGetDeviceCapabilities(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    )
/*++

Routine Description:

    This routine sends the get capabilities irp to the given stack

Arguments:

    DeviceObject        A device object in the stack whose capabilities we want
    DeviceCapabilites   Where to store the answer

Return Value:

    NTSTATUS

--*/
{
    IO_STATUS_BLOCK     ioStatus;
    KEVENT              pnpEvent;
    NTSTATUS            status;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpStack;
    PIRP                pnpIrp;

    PAGED_CODE();

    //
    // Initialize the capabilities that we will send down
    //
    RtlZeroMemory( DeviceCapabilities, sizeof(DEVICE_CAPABILITIES) );
    DeviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
    DeviceCapabilities->Version = 1;
    DeviceCapabilities->Address = -1;
    DeviceCapabilities->UINumber = -1;

    //
    // Initialize the event
    //
    KeInitializeEvent( &pnpEvent, SynchronizationEvent, FALSE );

    //
    // Get the irp that we will send the request to
    //
    targetObject = IoGetAttachedDeviceReference( DeviceObject );

    //
    // Build an Irp
    //
    pnpIrp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        targetObject,
        NULL,
        0,
        NULL,
        &pnpEvent,
        &ioStatus
        );
    if (pnpIrp == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto PciGetDeviceCapabilitiesExit;

    }

    //
    // Pnp Irps all begin life as STATUS_NOT_SUPPORTED;
    //
    pnpIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    pnpIrp->IoStatus.Information = 0;

    //
    // Get the top of stack
    //
    irpStack = IoGetNextIrpStackLocation( pnpIrp );
    if (irpStack == NULL) {

        status = STATUS_INVALID_PARAMETER;
        goto PciGetDeviceCapabilitiesExit;

    }

    //
    // Set the top of stack
    //
    RtlZeroMemory( irpStack, sizeof(IO_STACK_LOCATION ) );
    irpStack->MajorFunction = IRP_MJ_PNP;
    irpStack->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
    irpStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    //
    // Make sure that there are no completion routines set
    //
    IoSetCompletionRoutine(
        pnpIrp,
        NULL,
        NULL,
        FALSE,
        FALSE,
        FALSE
        );

    //
    // Call the driver
    //
    status = IoCallDriver( targetObject, pnpIrp );
    if (status == STATUS_PENDING) {

        //
        // Block until the irp comes back
        //
        KeWaitForSingleObject(
            &pnpEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = ioStatus.Status;

    }

PciGetDeviceCapabilitiesExit:
    //
    // Done with reference
    //
    ObDereferenceObject( targetObject );

    //
    // Done
    //
    return status;

}

ULONGLONG
PciGetHackFlags(
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN UCHAR  RevisionID
    )

/*++

Description:

    Look in the registry for any flags for this VendorId/DeviceId.

Arguments:

    VendorId      PCI Vendor ID (16 bits) of the manufacturer of the
                  device.

    DeviceId      PCI Device ID (16 bits) of the device.

    SubVendorID   PCI SubVendorID representing the manufacturer of the
                  subsystem

    SubSystemID   PCI SubSystemID representing subsystem

    RevisionID    PCI Revision denoting the revision of the device

Return Value:

    64 bit flags value or 0 if not found.

--*/

{
    PPCI_HACK_TABLE_ENTRY current;
    ULONGLONG hackFlags = 0;
    ULONG match, bestMatch = 0;
    ASSERT(PciHackTable);

    //
    // We want to do a best-case match:
    // VVVVDDDDSSSSssssRR
    // VVVVDDDDSSSSssss
    // VVVVDDDDRR
    // VVVVDDDD
    //
    // List is currently unsorted, so keep updating current best match.
    //

    for (current = PciHackTable; current->VendorID != 0xFFFF; current++) {
        match = 0;

        //
        // Must at least match vendor/dev
        //

        if ((current->DeviceID != DeviceID) ||
            (current->VendorID != VendorID)) {
            continue;
        }

        match = 1;

        //
        // If this entry specifies a revision, check that it is consistent.
        //

        if (current->Flags & PCI_HACK_FLAG_REVISION) {
            if (current->RevisionID == RevisionID) {
                match += 2;
            } else {
                continue;
            }
        }

        //
        // If this entry specifies subsystems, check that they are consistent
        //

        if (current->Flags & PCI_HACK_FLAG_SUBSYSTEM) {
            if (current->SubVendorID == SubVendorID &&
                current->SubSystemID == SubSystemID) {
                match += 4;
            } else {
                continue;
            }
        }

        if (match > bestMatch) {
            bestMatch = match;
            hackFlags = current->HackFlags;
        }
    }

    return hackFlags;
}

NTSTATUS
PciGetDeviceProperty(
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    IN  DEVICE_REGISTRY_PROPERTY DeviceProperty,
    OUT PVOID *PropertyBuffer
    )
{
    NTSTATUS status;
    NTSTATUS expected;
    ULONG length;
    ULONG length2;
    PVOID buffer;

    //
    // Two passes, first pass, find out what size buffer
    // is needed.
    //

    status = IoGetDeviceProperty(
                 PhysicalDeviceObject,
                 DeviceProperty,
                 0,
                 NULL,
                 &length
                 );

    expected = STATUS_BUFFER_TOO_SMALL;

    if (status == expected) {

        //
        // Good, now get a buffer.
        //

        buffer = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, length);

        if (buffer == NULL) {

            PciDebugPrint(
                PciDbgAlways,
                "PCI - Failed to allocate DeviceProperty buffer (%d bytes).\n",
                length
                );

            status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            //
            // This time, do it for real.
            //

            status = IoGetDeviceProperty(
                         PhysicalDeviceObject,
                         DeviceProperty,
                         length,
                         buffer,
                         &length2
                         );

            if (NT_SUCCESS(status)) {
                ASSERT(length == length2);

                //
                // Return the buffer containing the requested device
                // property to the caller.
                //

                *PropertyBuffer = buffer;
                return STATUS_SUCCESS;
            }
            expected = STATUS_SUCCESS;
        }
    }

    PciDebugPrint(
        PciDbgAlways,
        "PCI - Unexpected status from GetDeviceProperty, saw %08X, expected %08X.\n",
        status,
        expected
        );

    //
    // Clear the caller's buffer pointer, and, if the unexpected status
    // is success (from the first call to IoGetDeviceProperty) change it
    // to STATUS_UNSUCCESSFUL (N.B. This is if course impossible).
    //

    *PropertyBuffer = NULL;

    if (status == STATUS_SUCCESS) {
        ASSERTMSG("PCI Successfully did the impossible!", 0);
        status = STATUS_UNSUCCESSFUL;
    }
    return status;
}

NTSTATUS
PciRangeListFromResourceList(
    IN  PPCI_FDO_EXTENSION    FdoExtension,
    IN  PCM_RESOURCE_LIST ResourceList,
    IN  CM_RESOURCE_TYPE  DesiredType,
    IN  BOOLEAN           Complement,
    IN  PRTL_RANGE_LIST   ResultRange
    )

/*++

Description:

    Generates a range list for the resources of a given type
    from a resource list.

    Note: This routine supports only Memory or Io resources.

    Overlapping ranges in the incoming list will be combined.

Arguments:

    FdoExtension    Bus particulars.  NOTE: This is only needed for the
                    gross X86 hack for A0000 due to buggy MPS BIOS
                    implementations.  Otherwise this routine is more
                    generalized.
    ResourceList    Incoming CM Resource List.
    DesiredType     Type of resource to be included in the range list.
    Complement      Specifies wether or not the range list should be
                    the "complement" of the incoming data.
    ResultRange     Output range list.

Return Value:

    TRUE is key successfully opened, FALSE otherwise.

--*/

{

#define EXIT_IF_ERROR(status)                           \
    if (!NT_SUCCESS(status)) {                          \
        ASSERT(NT_SUCCESS(status));                     \
        goto exitPoint;                                 \
    }

#if DBG

#define ADD_RANGE(range, start, end, status)                       \
        PciDebugPrint(                                             \
        PciDbgObnoxious,                                           \
        "    Adding to RtlRange  %I64x thru %I64x\n",              \
        (ULONGLONG)start,                                          \
        (ULONGLONG)end                                             \
        );                                                         \
        status = RtlAddRange(range, start, end, 0, 0, NULL, NULL); \
        if (!NT_SUCCESS(status)) {                                 \
            ASSERT(NT_SUCCESS(status));                            \
            goto exitPoint;                                        \
        }

#else

#define ADD_RANGE(range, start, end, status)                       \
        status = RtlAddRange(range, start, end, 0, 0, NULL, NULL); \
        if (!NT_SUCCESS(status)) {                                 \
            ASSERT(NT_SUCCESS(status));                            \
            goto exitPoint;                                        \
        }

#endif

    NTSTATUS                        status;
    ULONG                           elementCount;
    ULONG                           count;
    ULONG                           numlists;
    PCM_FULL_RESOURCE_DESCRIPTOR    full;
    PCM_PARTIAL_RESOURCE_LIST       partial;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;

    typedef struct {
        LIST_ENTRY list;
        ULONGLONG  start;
        ULONGLONG  end;
        BOOLEAN    valid;
    } PCI_RANGE_LIST_ELEMENT, *PPCI_RANGE_LIST_ELEMENT;

    PPCI_RANGE_LIST_ELEMENT         elementBuffer;
    PPCI_RANGE_LIST_ELEMENT         upper;
    PPCI_RANGE_LIST_ELEMENT         lower;
    PPCI_RANGE_LIST_ELEMENT         current;
    ULONG                           allocatedElement;
    ULONGLONG                       start;
    ULONGLONG                       end;

#if defined(_X86_) && defined(PCI_NT50_BETA1_HACKS)

    //
    // BETA1_HACKS - Remove this when the problem is fixed.
    //
    // HACK HACK some MPS BIOS implementations don't report the
    // memory range 0xA0000 thru 0xBFFFF.  They should.  HACK
    // them into the memory list.  Gross.
    // Even grosser, assume this applies only to bus 0.
    //
    // The 400 hack is because some cards (Matrox MGA) want access
    // to the SYSTEM BIOS DATA area which is in memory at address
    // 0x400 thru 0x4ff.  It's not on the BUS so why are we making
    // it appear here?
    //
    // Note, there is TWO hacks here but we do both under the
    // exact same condition so we have only one boolean.  If the
    // two are seperated (or one removed) this needs to be split.
    //

    BOOLEAN doA0000Hack = (DesiredType == CmResourceTypeMemory) &&
                          (FdoExtension && (FdoExtension->BaseBus == 0));

#endif

    PAGED_CODE();

    ASSERT((DesiredType == CmResourceTypeMemory) ||
           (DesiredType == CmResourceTypePort));

    //
    // First, get a count of the number of resources of the desired
    // type in the list.   This gives us the maximum number of entries
    // in the resulting list.
    //
    // Plus 1 in case we're complementing it.  2 actually, we start
    // with a beginning and end entry.
    //

    elementCount = 2;

    numlists = 0;
    if (ResourceList != NULL) {
        numlists = ResourceList->Count;
        full = ResourceList->List;
    }

    while (numlists--) {
        partial = &full->PartialResourceList;
        count   = partial->Count;
        descriptor = partial->PartialDescriptors;
        while (count--) {
            if (descriptor->Type == DesiredType) {
                if (DesiredType == CmResourceTypePort) {
                    if (descriptor->Flags & CM_RESOURCE_PORT_10_BIT_DECODE) {
                        elementCount += ((1 << 16) / (1 << 10)) - 1;
                    } else if (descriptor->Flags & CM_RESOURCE_PORT_12_BIT_DECODE) {
                        elementCount += ((1 << 16) / (1 << 12)) - 1;
                    }
                }
                elementCount++;
            }
            descriptor = PciNextPartialDescriptor(descriptor);
        }
        full = (PCM_FULL_RESOURCE_DESCRIPTOR)descriptor;
    }

    PciDebugPrint(
        PciDbgObnoxious,
        "PCI - PciRangeListFromResourceList processing %d elements.\n",
        elementCount - 2
        );

#if defined(_X86_) && defined(PCI_NT50_BETA1_HACKS)

    if (doA0000Hack) {
        elementCount += 3;  // one for A0000 hack, one for 400 hack. + 1 for 70
    }

#endif

    //
    // Allocate list entries and initialize the list.
    //

    elementBuffer = ExAllocatePool(
                        PagedPool | POOL_COLD_ALLOCATION,
                        elementCount * sizeof(PCI_RANGE_LIST_ELEMENT)
                        );

    if (elementBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Take the first two entries and set them to the absolute minimum
    // and absolute maximum possible values.   Everything else will
    // either end up between these or be combined with them.
    //
    // Setting the terminators this way should avoid us having to check
    // for end conditions.
    //

    allocatedElement = 2;
    current = &elementBuffer[1];

    // first element (list min terminator)

    elementBuffer[1].start = elementBuffer[1].end = 0;
    elementBuffer[1].list.Flink = &elementBuffer[0].list;
    elementBuffer[1].list.Blink = &elementBuffer[0].list;
    elementBuffer[1].valid = FALSE;

    // last element (list max terminator)

    elementBuffer[0].start = elementBuffer[0].end = ~0;
    elementBuffer[0].list.Flink = &elementBuffer[1].list;
    elementBuffer[0].list.Blink = &elementBuffer[1].list;
    elementBuffer[0].valid = FALSE;

#if defined(_X86_) && defined(PCI_NT50_BETA1_HACKS)

    if (doA0000Hack) {

        //
        // Hack in A0000 thru FFFFF by just adding an entry for it
        // to the otherwise empty list.
        //
        // Hack in 400 thru 4ff too.
        //

        PLIST_ENTRY minEntry = &elementBuffer[1].list;
        PLIST_ENTRY maxEntry = &elementBuffer[0].list;
        PPCI_RANGE_LIST_ELEMENT tempElement;

        allocatedElement = 5;

        elementBuffer[2].start = 0x70;      // HACK Trident
        elementBuffer[2].end   = 0x70;
        elementBuffer[2].valid = TRUE;

        elementBuffer[3].start = 0x400;     // HACK Matrox MGA
        elementBuffer[3].end   = 0x4FF;
        elementBuffer[3].valid = TRUE;

        elementBuffer[4].start = 0xA0000;   // HACK broken MPS BIOS
        elementBuffer[4].end   = 0xBFFFF;
        elementBuffer[4].valid = TRUE;

        // set the flinks

        minEntry->Flink = &elementBuffer[2].list;
        elementBuffer[2].list.Flink = &elementBuffer[3].list;
        elementBuffer[3].list.Flink = &elementBuffer[4].list;
        elementBuffer[4].list.Flink = maxEntry;

        // set the blinks

        elementBuffer[2].list.Blink = minEntry;
        elementBuffer[3].list.Blink = &elementBuffer[2].list;
        elementBuffer[4].list.Blink = &elementBuffer[3].list;
        maxEntry->Blink = &elementBuffer[4].list;

#if DBG

        tempElement = CONTAINING_RECORD(
                          minEntry,
                          PCI_RANGE_LIST_ELEMENT,
                          list
                          );

        PciDebugPrint(
            PciDbgObnoxious,
            "    === PCI added default initial ranges ===\n"
            );

        do {

            //
            // Print this entry if it is valid.
            //

            if (tempElement->valid == TRUE) {
                PciDebugPrint(
                    PciDbgObnoxious,
                    "    %I64x .. %I64x\n",
                    tempElement->start,
                    tempElement->end
                    );
            }

            //
            // Next entry.
            //

            if (tempElement->list.Flink == minEntry) {
                break;
            }
            tempElement = CONTAINING_RECORD(
                              tempElement->list.Flink,
                              PCI_RANGE_LIST_ELEMENT,
                              list
                              );
        } while (TRUE);

        PciDebugPrint(
            PciDbgObnoxious,
            "    === end added default initial ranges ===\n"
            );

#endif

    }

#endif

    //
    // Starting again at the beginning of the resource list, extract
    // the desired resources and insert them in our new list.
    //

    numlists = 0;
    if (ResourceList != NULL) {
        full = ResourceList->List;
        numlists = ResourceList->Count;
    }

    while (numlists--) {

        LIST_CONTEXT listContext;

        PcipInitializePartialListContext(
            &listContext,
            &full->PartialResourceList,
            DesiredType
            );

        while ((descriptor = PcipGetNextRangeFromList(&listContext)) != NULL) {


            ASSERT(descriptor->Type == DesiredType);

            //
            // insert this element into the list.
            //

            start = (ULONGLONG)descriptor->u.Generic.Start.QuadPart;
            end   = start - 1 + descriptor->u.Generic.Length;

            //
            // First find the element to the left of this one
            // (below it).
            //

            lower = current;

            //
            // Just in case we actually need to go right,...
            //

            while (start > lower->end) {

                lower = CONTAINING_RECORD(
                            lower->list.Flink,
                            PCI_RANGE_LIST_ELEMENT,
                            list
                            );
            }

            //
            // Search left.
            //

            while (start <= lower->end) {
                if (start >= lower->start) {
                    break;
                }

                //
                // Go left.
                //

                lower = CONTAINING_RECORD(
                            lower->list.Blink,
                            PCI_RANGE_LIST_ELEMENT,
                            list
                            );
            }

            //
            // Early out if the lower entry completely
            // covers the new entry.
            //

            if ((start >= lower->start) && (end <= lower->end)) {

                //
                // It does, just skip it.
                //

                PciDebugPrint(
                    PciDbgObnoxious,
                    "    -- (%I64x .. %I64x) swallows (%I64x .. %I64x)\n",
                    lower->start,
                    lower->end,
                    start,
                    end
                );

                current = lower;
                current->valid = TRUE;
                continue;
            }


            //
            // Then, the one above it.
            //

            upper = lower;

            while (end > upper->start) {
                if (end <= upper->end) {
                    break;
                }

                //
                // Go right.
                //

                upper = CONTAINING_RECORD(
                            upper->list.Flink,
                            PCI_RANGE_LIST_ELEMENT,
                            list
                            );
            }
            current = &elementBuffer[allocatedElement++];
            current->start = start;
            current->end   = end;
            current->valid = TRUE;

            PciDebugPrint(
                PciDbgObnoxious,
                "    (%I64x .. %I64x) <= (%I64x .. %I64x) <= (%I64x .. %I64x)\n",
                lower->start,
                lower->end,
                start,
                end,
                upper->start,
                upper->end
                );

            //
            // We now have, the element below this one, possibly
            // overlapping, the element above this one, possibly
            // overlapping, and a new one.
            //
            // The easiest way to deal with this is to create
            // the new entry, link it in, then unlink the overlaps
            // if they exist.
            //
            //
            // Note: The new entry may overlap several entries,
            // these are orphaned.
            //
            // Link it in.
            //

            current->list.Flink = &upper->list;
            current->list.Blink = &lower->list;
            upper->list.Blink = &current->list;
            lower->list.Flink = &current->list;

            //
            // Check for lower overlap.
            //

            if ((lower->valid == TRUE) && (start > 0)) {
                start--;
            }

            if (lower->end >= start) {

                //
                // Overlaps from below,...
                //
                // Merge lower into current.
                //

                current->start = lower->start;
                current->list.Blink = lower->list.Blink;

                //
                //
                // lower is being orphaned, reuse it to get to
                // our new lower neighbor.
                //

                lower = CONTAINING_RECORD(
                            lower->list.Blink,
                            PCI_RANGE_LIST_ELEMENT,
                            list
                            );
                lower->list.Flink = &current->list;

                PciDebugPrint(
                    PciDbgObnoxious,
                    "    -- Overlaps lower, merged to (%I64x .. %I64x)\n",
                    current->start,
                    current->end
                    );
            }

            //
            // Check for upper overlap.
            //

            if ((upper->valid == TRUE) && (end < ~0)) {
                end++;
            }
            if ((end >= upper->start) && (current != upper)) {

                //
                // Overlaps above,... merge upper into current.
                //

                current->end = upper->end;
                current->list.Flink = upper->list.Flink;

                //
                // upper is being orphaned, reuse it to get to
                // our new upper neighbor.
                //

                upper = CONTAINING_RECORD(
                            upper->list.Flink,
                            PCI_RANGE_LIST_ELEMENT,
                            list
                            );
                upper->list.Blink = &current->list;

                PciDebugPrint(
                    PciDbgObnoxious,
                    "    -- Overlaps upper, merged to (%I64x .. %I64x)\n",
                    current->start,
                    current->end
                    );
            }
        }
        full = (PCM_FULL_RESOURCE_DESCRIPTOR)listContext.Next;
    }

    //
    // Find the lowest value.
    //

    while (current->valid == TRUE) {

        lower = CONTAINING_RECORD(
                    current->list.Blink,
                    PCI_RANGE_LIST_ELEMENT,
                    list
                    );
        if ((lower->valid == FALSE) ||
            (lower->start > current->start)) {
            break;
        }
        current = lower;
    }

#if DBG

    lower = current;

    if (current->valid == FALSE) {
        PciDebugPrint(
            PciDbgObnoxious,
            "    ==== No ranges in results list. ====\n"
            );
    } else {

        PciDebugPrint(
            PciDbgObnoxious,
            "    === ranges ===\n"
            );

        do {
            if (current->valid == TRUE) {
                PciDebugPrint(
                    PciDbgObnoxious,
                    "    %I64x .. %I64x\n",
                    current->start,
                    current->end
                    );
            }

            //
            // Next entry.
            //
            current = CONTAINING_RECORD(
                          current->list.Flink,
                          PCI_RANGE_LIST_ELEMENT,
                          list
                          );

        } while (current != lower);
    }

#endif

    if (Complement == TRUE) {

        //
        // Invert the list.
        //
        // The generation of the list always results in the orphaning
        // of elementBuffer[1] (which was the original start point),
        // we can use that one for the first element of the new
        // inverted list.
        //

        if (current->valid == FALSE) {

            //
            // Empty list, complement it you get everything.
            //

            ADD_RANGE(ResultRange, 0, ~0, status);
        } else {

            //
            // If the original range doesn't start at zero we must
            // generate an entry from 0 to the start of that range.
            //

            if (current->start != 0) {
                ADD_RANGE(ResultRange, 0, current->start - 1, status);
            }

            //
            // Run the list greating range list entries for the
            // gaps between entries in this list.
            //

            do {
                PPCI_RANGE_LIST_ELEMENT next = CONTAINING_RECORD(
                                                   current->list.Flink,
                                                   PCI_RANGE_LIST_ELEMENT,
                                                   list
                                                   );
                if (current->valid == TRUE) {
                    start = current->end + 1;
                    end = next->start - 1;

                    if ((end < start) || (next == elementBuffer)) {
                        end = ~0;
                    }
                    ADD_RANGE(ResultRange, start, end, status);
                }

                //
                // Next entry.
                //
                current = next;

            } while (current != lower);
        }
    } else {

        //
        // Not complementing,... add a range for each member of the
        // list.
        //

        if (current->valid == TRUE) {
            do {
                ADD_RANGE(ResultRange, current->start, current->end, status);

                //
                // Next entry.
                //
                current = CONTAINING_RECORD(
                              current->list.Flink,
                              PCI_RANGE_LIST_ELEMENT,
                              list
                              );

            } while (current != lower);
        }
    }
    status = STATUS_SUCCESS;

exitPoint:

    ExFreePool(elementBuffer);
    return status;

#undef EXIT_IF_ERROR
}


UCHAR
PciReadDeviceCapability(
    IN     PPCI_PDO_EXTENSION PdoExtension,
    IN     UCHAR          Offset,
    IN     UCHAR          Id,
    IN OUT PVOID          Buffer,
    IN     ULONG          Length
    )

/*++

Description:

    Searches configuration space for the PCI Capabilities structure
    identified by Id.  Begins at offset Offset in PCI config space.

Arguments:

    PdoExtension    Pointer to the PDO Extension for this device.
    Offset          Offset into PCI config space to begin traversing
                    the capabilities list.
    Id              Capabilities ID.  (0 if want to match any).
    Buffer          Pointer to the buffer where the capabilities
                    structure is to be returned (includes capabilities
                    header).
    Length          Number of bytes wanted (must be at least large
                    enough to contain the header).

Return Value:

    Returns the Offset in PCI config space at which the capability
    was found or 0 if not found.

--*/

{
    NTSTATUS    status;
    PPCI_CAPABILITIES_HEADER capHeader;
    UCHAR       loopCount = 0;

    capHeader = (PPCI_CAPABILITIES_HEADER)Buffer;

    //
    // In case the caller is running the list, check if we got
    // handed the list end.
    //

    if (Offset == 0) {
        return 0;
    }

    ASSERT_PCI_PDO_EXTENSION(PdoExtension);

    ASSERT(PdoExtension->CapabilitiesPtr != 0);

    ASSERT(Buffer);

    ASSERT(Length >= sizeof(PCI_CAPABILITIES_HEADER));

    do {

        //
        // Catch case where the device has been powered off.   (Reads
        // from a powered off device return FF,... allowing also for
        // the case where the device is just broken).
        //

        if ((Offset < PCI_COMMON_HDR_LENGTH) ||
            ((Offset & 0x3) != 0)) {
            ASSERT((Offset >= PCI_COMMON_HDR_LENGTH) && ((Offset & 0x3) == 0));

            return 0;
        }

        PciReadDeviceConfig(
            PdoExtension,
            Buffer,
            Offset,
            sizeof(PCI_CAPABILITIES_HEADER)
            );

        //
        // Check if this capability is the one we want (or if we want
        // ALL capability structures).
        //
        // NOTE: Intel 21554 non-transparent P2P bridge has a VPD
        // capability that has the Chassis capability id.  Needs to be
        // handled here in the future. Maybe fixed in later revisions.
        //

        if ((capHeader->CapabilityID == Id) || (Id == 0)) {
            break;
        }

        Offset = capHeader->Next;

        //
        // One more check for broken h/w.   Make sure we're not
        // traversing a circular list.   A Capabilities header
        // cannot be in the common header and must be DWORD aligned
        // in config space so there can only be (256-64)/4 of them.
        //

        if (++loopCount > ((256-64)/4)) {

            PciDebugPrint(
                PciDbgAlways,
                "PCI device %p capabilities list is broken.\n",
                PdoExtension
                );
            return 0;
        }

    } while (Offset != 0);

    //
    // If we found a match and we haven't read all the data, get the
    // remainder.
    //

    if ((Offset != 0) && (Length > sizeof(PCI_CAPABILITIES_HEADER))) {

        if (Length > (sizeof(PCI_COMMON_CONFIG) - Offset)) {

            //
            // If we are too close to the end of config space to
            // return the amount of data the caller requested,
            // truncate.
            //
            // Worst case truncation will be to 4 bytes so no need
            // to check we have data to read (again).
            //

            ASSERT(Length <= (sizeof(PCI_COMMON_CONFIG) - Offset));

            Length = sizeof(PCI_COMMON_CONFIG) - Offset;
        }

        //
        // Read remainder.
        //

        Length -= sizeof(PCI_CAPABILITIES_HEADER);

        PciReadDeviceConfig(
            PdoExtension,
            capHeader + 1,
            Offset + sizeof(PCI_CAPABILITIES_HEADER),
            Length
            );
    }
    return Offset;
}

BOOLEAN
PciCanDisableDecodes(
    IN PPCI_PDO_EXTENSION PdoExtension OPTIONAL,
    IN PPCI_COMMON_CONFIG Config OPTIONAL,
    IN ULONGLONG HackFlags,
    IN ULONG Flags
    )
// N.B. - not paged so we can power down at dispatch level
{
    UCHAR baseClass;
    UCHAR subClass;
    BOOLEAN canDisableVideoDecodes;

    canDisableVideoDecodes = (Flags & PCI_CAN_DISABLE_VIDEO_DECODES) == PCI_CAN_DISABLE_VIDEO_DECODES;

    if (ARGUMENT_PRESENT(PdoExtension)) {
        ASSERT(HackFlags == 0);
        HackFlags = PdoExtension->HackFlags;
        baseClass = PdoExtension->BaseClass;
        subClass = PdoExtension->SubClass;
    } else {
        ASSERT(ARGUMENT_PRESENT(Config));
        baseClass = Config->BaseClass;
        subClass = Config->SubClass;
    }

    if (HackFlags & PCI_HACK_PRESERVE_COMMAND) {

        //
        // Bad things happen if we touch this device's command
        // register, leave it alone.
        //

        return FALSE;
    }

    if (HackFlags & PCI_HACK_CB_SHARE_CMD_BITS) {

        //
        // This is a multifunction cardbus controller with a shared
        // command register.  Never turn of any of the functions because it has
        // the unfortunate side effect of turning of all of them!
        //
        // NTRAID #62672 - 4/25/2000 - andrewth
        // We should probably ensure that the windows for all functions
        // are closed on all functions before enabling any of them...
        //
        //

        return FALSE;
    }

    if (HackFlags & PCI_HACK_NO_DISABLE_DECODES) {

        //
        // If we disable the decodes on this device bad things happen
        //

        return FALSE;

    }

    //
    // If this is a video device then don't allow the decodes to be disabled unless
    // we are allowed to...
    //

    if ((baseClass == PCI_CLASS_DISPLAY_CTLR && subClass == PCI_SUBCLASS_VID_VGA_CTLR)
    ||  (baseClass == PCI_CLASS_PRE_20 && subClass == PCI_SUBCLASS_PRE_20_VGA)) {

        return canDisableVideoDecodes;

    }

    //
    // There are various things in the world we shouldn't turn off.
    // The system is quite possibly unable to recover if we do, so
    // don't (just pretend).
    //
    switch (baseClass) {
    case PCI_CLASS_BRIDGE_DEV:

        //
        // Bad things happen if we turn off the HOST bridge (the
        // system doesn't understand that this device, which is
        // on a PCI bus, is actually the parent of that PCI bus),
        // or ISA/EISA/MCA bridges under which are devices we still
        // need to have working but are legacy detected so not in
        // the heirachy in any way we understand.
        //

        if ((subClass == PCI_SUBCLASS_BR_ISA )  ||
            (subClass == PCI_SUBCLASS_BR_EISA)  ||
            (subClass == PCI_SUBCLASS_BR_MCA)   ||
            (subClass == PCI_SUBCLASS_BR_HOST)  ||
            (subClass == PCI_SUBCLASS_BR_OTHER)) {

            return FALSE;
        }

        //
        // We don't want to turn off bridges that might have the VGA card behind
        // then otherwise video stops working.  Seeing as we can't actually tell
        // where the VGA card is use the hint that if the bridge is passing VGA
        // ranges the video card is probably somewhere down there.
        //

        if (subClass == PCI_SUBCLASS_BR_PCI_TO_PCI
        ||  subClass == PCI_SUBCLASS_BR_CARDBUS) {

            BOOLEAN vgaBitSet;

            if (ARGUMENT_PRESENT(PdoExtension)) {
                vgaBitSet = PdoExtension->Dependent.type1.VgaBitSet;
            } else {
                vgaBitSet = (Config->u.type1.BridgeControl & PCI_ENABLE_BRIDGE_VGA) != 0;
            }

            if (vgaBitSet) {
                //
                // We can disable the video path if we are powering down the machine
                //
                return canDisableVideoDecodes;
            }
        }

        break;

    case PCI_CLASS_DISPLAY_CTLR:

        //
        // If a video driver fails to start, the device reverts back to being
        // VGA if it is the VGA device.   Don't disable the decodes on VGA
        // devices.
        //

        if (subClass == PCI_SUBCLASS_VID_VGA_CTLR) {
            //
            // We can disable the video path if we are powering down the machine
            //
            return canDisableVideoDecodes;
        }
        break;

    case PCI_CLASS_PRE_20:

        //
        // Same as above.
        //

        if (subClass == PCI_SUBCLASS_PRE_20_VGA) {
            //
            // We can disable the video path if we are powering down the machine
            //
            return canDisableVideoDecodes;
        }
        break;
    }
    return TRUE;
}

VOID
PciDecodeEnable(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN BOOLEAN Enable,
    IN PUSHORT ExistingCommand OPTIONAL
    )
/*++

Description:

    Either sets the decodes to match the extension (misnomered Enable) or zeros
    the decodes entirely.

    N.B. - not paged so we can power down at dispatch level

Arguments:

    PdoExtension    Pointer to the PDO Extension for this device.
    Enable          If TRUE, decodes are set to match the extension (on or off).
                    If FALSE, decodes are disabled.
    ExistingCommand Optional saved command to prevent a reread of the config
                    space command field.

Return Value:

    Nothing.

--*/
{
    USHORT cmd;
    ULONG length = sizeof(cmd);

    //
    // Can we disable it if so ordered?
    //
    if (!Enable && !PciCanDisableDecodes(PdoExtension, NULL, 0, 0)) {
        return;
    }

    if (PdoExtension->HackFlags & PCI_HACK_PRESERVE_COMMAND) {

        //
        // Bad things happen if we touch this device's command
        // register, leave it alone.
        //

        return;
    }

    if (ARGUMENT_PRESENT(ExistingCommand)) {

        //
        // The caller has supplied the current contents of the
        // device's config space.
        //

        cmd = *ExistingCommand;
    } else {

        //
        // Get the current command register from the device.
        //

        PciGetCommandRegister(PdoExtension, &cmd);
    }

    cmd &= ~(PCI_ENABLE_IO_SPACE |
             PCI_ENABLE_MEMORY_SPACE |
             PCI_ENABLE_BUS_MASTER);

    if (Enable) {

        //
        // Set enables
        //

        cmd |= PdoExtension->CommandEnables & (PCI_ENABLE_IO_SPACE
                                             | PCI_ENABLE_MEMORY_SPACE
                                             | PCI_ENABLE_BUS_MASTER);
    }

    //
    // Set the new command register into the device.
    //

    PciSetCommandRegister(PdoExtension, cmd);
}

NTSTATUS
PciExcludeRangesFromWindow(
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN PRTL_RANGE_LIST ArbiterRanges,
    IN PRTL_RANGE_LIST ExclusionRanges
    )
{

    NTSTATUS status;
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE current;

    FOR_ALL_RANGES(ExclusionRanges, &iterator, current) {

        if (current->Owner == NULL
        &&  INTERSECT(current->Start, current->End, Start, End)) {

            status = RtlAddRange(ArbiterRanges,
                                 current->Start,
                                 current->End,
                                 0,
                                 RTL_RANGE_LIST_ADD_IF_CONFLICT,
                                 NULL,
                                 NULL // this range is not on the bus
                                 );

            if (!NT_SUCCESS(status)) {
                ASSERT(NT_SUCCESS(status));
                return status;
            }
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PciBuildDefaultExclusionLists(
    VOID
    )
{
    NTSTATUS status;
    ULONG windowBase;

    ASSERT(PciIsaBitExclusionList.Count == 0);
    ASSERT(PciVgaAndIsaBitExclusionList.Count == 0);

    RtlInitializeRangeList(&PciIsaBitExclusionList);
    RtlInitializeRangeList(&PciVgaAndIsaBitExclusionList);


    for (windowBase = 0; windowBase <= 0xFFFF; windowBase += 0x400) {

        //
        // Add the x100-x3ff range to the ISA list
        //

        status = RtlAddRange(&PciIsaBitExclusionList,
                             windowBase + 0x100,
                             windowBase + 0x3FF,
                             0,
                             RTL_RANGE_LIST_ADD_IF_CONFLICT,
                             NULL,
                             NULL // this range is not on the bus
                             );

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        //
        // Add the x100-x3af, x3bc-x3bf and x3e0-x3ff ranges to the VGA/ISA list
        //

        status = RtlAddRange(&PciVgaAndIsaBitExclusionList,
                             windowBase + 0x100,
                             windowBase + 0x3AF,
                             0,
                             RTL_RANGE_LIST_ADD_IF_CONFLICT,
                             NULL,
                             NULL // this range is not on the bus
                             );

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }


        status = RtlAddRange(&PciVgaAndIsaBitExclusionList,
                             windowBase + 0x3BC,
                             windowBase + 0x3BF,
                             0,
                             RTL_RANGE_LIST_ADD_IF_CONFLICT,
                             NULL,
                             NULL // this range is not on the bus
                             );

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        status = RtlAddRange(&PciVgaAndIsaBitExclusionList,
                             windowBase + 0x3E0,
                             windowBase + 0x3FF,
                             0,
                             RTL_RANGE_LIST_ADD_IF_CONFLICT,
                             NULL,
                             NULL // this range is not on the bus
                             );

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

    }

    return STATUS_SUCCESS;

cleanup:

    RtlFreeRangeList(&PciIsaBitExclusionList);
    RtlFreeRangeList(&PciVgaAndIsaBitExclusionList);

    return status;
}

NTSTATUS
PciSaveBiosConfig(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG Config
    )
/*++

Description:

    This saves the original configuration of a device in the registry

Arguments:

    PdoExtension    Pointer to the PDO Extension for this device.

    Config          The config space as the BIOS initialized it

Return Value:

    Status

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING unicodeString;
    HANDLE deviceHandle, configHandle;
    WCHAR buffer[sizeof(L"DEV_xx&FUN_xx")];

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(PCI_PARENT_PDO(PdoExtension),
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_ALL_ACCESS,
                                     &deviceHandle
                                     );



    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    PciConstStringToUnicodeString(&unicodeString, BIOS_CONFIG_KEY_NAME);

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_KERNEL_HANDLE,
                               deviceHandle,
                               NULL
                               );

    status = ZwCreateKey(&configHandle,
                         KEY_ALL_ACCESS,
                         &attributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE,
                         NULL
                         );

    ZwClose(deviceHandle);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    unicodeString.Length =
        (USHORT)_snwprintf(buffer,
                           sizeof(buffer)/sizeof(WCHAR),
                           L"DEV_%02x&FUN_%02x",
                           PdoExtension->Slot.u.bits.DeviceNumber,
                           PdoExtension->Slot.u.bits.FunctionNumber
                          );
    unicodeString.Length *= sizeof(WCHAR); // Length is in bytes
    unicodeString.MaximumLength = unicodeString.Length;
    unicodeString.Buffer = buffer;

    status = ZwSetValueKey(configHandle,
                           &unicodeString,
                           0,
                           REG_BINARY,
                           Config,
                           PCI_COMMON_HDR_LENGTH
                           );

    ZwClose(configHandle);

    return status;

cleanup:

    return status;
}

NTSTATUS
PciGetBiosConfig(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN PPCI_COMMON_CONFIG Config
    )
/*++

Description:

    This retrieves the original configuration of a device from the registry

Arguments:

    PdoExtension    Pointer to the PDO Extension for this device.

    Config          The config space as the BIOS initialized it

Return Value:

    Status

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING unicodeString;
    HANDLE deviceHandle, configHandle;
    WCHAR buffer[sizeof(L"DEV_xx&FUN_xx")];
    CHAR returnBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + PCI_COMMON_HDR_LENGTH - 1];
    PKEY_VALUE_PARTIAL_INFORMATION info;
    ULONG resultLength;

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(PCI_PARENT_PDO(PdoExtension),
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ | KEY_WRITE,
                                     &deviceHandle
                                     );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    PciConstStringToUnicodeString(&unicodeString, BIOS_CONFIG_KEY_NAME);

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_KERNEL_HANDLE,
                               deviceHandle,
                               NULL
                               );

    status = ZwOpenKey(&configHandle,
                         KEY_READ,
                         &attributes
                         );

    ZwClose(deviceHandle);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    unicodeString.Length =
        (USHORT)_snwprintf(buffer,
                           sizeof(buffer)/sizeof(WCHAR),
                           L"DEV_%02x&FUN_%02x",
                           PdoExtension->Slot.u.bits.DeviceNumber,
                           PdoExtension->Slot.u.bits.FunctionNumber
                          );
    unicodeString.Length *= sizeof(WCHAR); // Length is in bytes
    unicodeString.MaximumLength = unicodeString.Length;
    unicodeString.Buffer = buffer;

    status = ZwQueryValueKey(configHandle,
                             &unicodeString,
                             KeyValuePartialInformation,
                             &returnBuffer,
                             sizeof(returnBuffer),
                             &resultLength
                             );

    ZwClose(configHandle);

    if (NT_SUCCESS(status)) {

        info = (PKEY_VALUE_PARTIAL_INFORMATION) returnBuffer;

        ASSERT(info->DataLength == PCI_COMMON_HDR_LENGTH);

        RtlCopyMemory(Config, info->Data, PCI_COMMON_HDR_LENGTH);
    }

    return status;

cleanup:

    return status;
}

#if 0
BOOLEAN
PciPresenceCheck(
    IN PPCI_PDO_EXTENSION PdoExtension
    )
{
    UCHAR configSpaceBuffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG cardConfig = (PPCI_COMMON_CONFIG) configSpaceBuffer;

    PAGED_CODE();

    //
    // If the card is already missing, don't bother reexamining it.
    //
    if (PdoExtension->NotPresent) {

        return FALSE;
    }

    if (PciIsSameDevice(PdoExtension)) {

        //
        // Still here.
        //
        return TRUE;
    }

    //
    // Mark it not present, then tell the OS it's gone.
    //
    PdoExtension->NotPresent = 1;

    IoInvalidateDeviceState(PdoExtension->PhysicalDeviceObject);
    return FALSE;
}
#endif

BOOLEAN
PciStringToUSHORT(
    IN PWCHAR String,
    OUT PUSHORT Result
    )
/*++

Description:

    Takes a 4 character hexidecimal sting and converts it into a USHORT.

Arguments:

    String - the string

    Result - the USHORT

Return Value:

    TRUE is success, FASLE otherwise

--*/

{
    ULONG count;
    USHORT number = 0;
    PWCHAR current;

    current = String;

    for (count = 0; count < 4; count++) {

        number <<= 4;

        if (*current >= L'0' && *current <= L'9') {
            number |= *current - L'0';
        } else if (*current >= L'A' && *current <= L'F') {
            number |= *current + 10 - L'A';
        } else if (*current >= L'a' && *current <= L'f') {
            number |= *current + 10 - L'a';
        } else {
            return FALSE;
        }

        current++;
    }

    *Result = number;
    return TRUE;
}


NTSTATUS
PciSendIoctl(
    IN PDEVICE_OBJECT Device,
    IN ULONG IoctlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )
/*++

Description:

    Builds and send an IOCTL to a device and return the results

Arguments:

    Device - a device on the device stack to receive the IOCTL - the
             irp is always sent to the top of the stack

    IoctlCode - the IOCTL to run

    InputBuffer - arguments to the IOCTL

    InputBufferLength - length in bytes of the InputBuffer

    OutputBuffer - data returned by the IOCTL

    OnputBufferLength - the size in bytes of the OutputBuffer

Return Value:

    Status

--*/
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    PIRP irp;
    PDEVICE_OBJECT targetDevice = NULL;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Get the top of the stack to send the IRP to
    //

    targetDevice = IoGetAttachedDeviceReference(Device);

    if (!targetDevice) {
        status = STATUS_INVALID_PARAMETER;
    goto exit;
    }

    //
    // Get Io to build the IRP for us
    //

    irp = IoBuildDeviceIoControlRequest(IoctlCode,
                                        targetDevice,
                                        InputBuffer,
                                        InputBufferLength,
                                        OutputBuffer,
                                        OutputBufferLength,
                                        FALSE, // InternalDeviceIoControl
                                        &event,
                                        &ioStatus
                                        );


    if (!irp) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Send the IRP and wait for it to complete
    //

    status = IoCallDriver(targetDevice, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

exit:

    if (targetDevice) {
        ObDereferenceObject(targetDevice);
    }

    return status;

}

BOOLEAN
PciIsOnVGAPath(
    IN PPCI_PDO_EXTENSION Pdo
    )

/*++

Description:

    Guesses if we are on the VGA path or not!

Arguments:

    Pdo - The PDO for the device in question

Return Value:

    TRUE if we are on the VGA path, TRUE otherwise

--*/

{
    switch (Pdo->BaseClass) {

    case PCI_CLASS_BRIDGE_DEV:
        //
        // We don't want to turn off bridges that might have the VGA card behind
        // then otherwise video stops working.  Seeing as we can't actually tell
        // where the VGA card is use the hint that if the bridge is passing VGA
        // ranges the video card is probably somewhere down there.
        //

        if (Pdo->SubClass == PCI_SUBCLASS_BR_PCI_TO_PCI
        ||  Pdo->SubClass == PCI_SUBCLASS_BR_CARDBUS) {

            if (Pdo->Dependent.type1.VgaBitSet) {
                return TRUE;
            }
        }

        break;

    case PCI_CLASS_DISPLAY_CTLR:

        if (Pdo->SubClass == PCI_SUBCLASS_VID_VGA_CTLR) {
            return TRUE;
        }
        break;

    case PCI_CLASS_PRE_20:

        if (Pdo->SubClass == PCI_SUBCLASS_PRE_20_VGA) {
            return TRUE;
        }
        break;
    }

    return FALSE;
}

BOOLEAN
PciIsSlotPresentInParentMethod(
    IN PPCI_PDO_EXTENSION Pdo,
    IN ULONG Method
    )
/*++

Description:

    This function checks if the slot this device is in is present in a
    Method named package on the parent of this device.

Arguments:

    Pdo - The PDO extension for the device

    Method - The Parents method to examine

Return Value:

    TRUE if present, FALSE otherwise

--*/
{
    NTSTATUS status;
    ACPI_EVAL_INPUT_BUFFER input;
    PACPI_EVAL_OUTPUT_BUFFER output = NULL;
    ULONG count, adr;
    PACPI_METHOD_ARGUMENT argument;
    BOOLEAN result = FALSE;
    //
    // Allocate a buffer big enough for all possible slots
    //
    ULONG outputSize = sizeof(ACPI_EVAL_OUTPUT_BUFFER) + sizeof(ACPI_METHOD_ARGUMENT) * (PCI_MAX_DEVICES * PCI_MAX_FUNCTION);

    PAGED_CODE();

    output = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, outputSize);

    if (!output) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    RtlZeroMemory(&input, sizeof(ACPI_EVAL_INPUT_BUFFER));
    RtlZeroMemory(output, outputSize);

    //
    // Send a IOCTL to ACPI to request it to run the method on this device's
    // parent if the method it is present
    //

    input.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    input.MethodNameAsUlong = Method;

    status = PciSendIoctl(PCI_PARENT_FDOX(Pdo)->PhysicalDeviceObject,
                          IOCTL_ACPI_EVAL_METHOD,
                          &input,
                          sizeof(ACPI_EVAL_INPUT_BUFFER),
                          output,
                          outputSize
                          );

    if (!NT_SUCCESS(status)) {
        goto exit;
    }

    //
    // Format my slot number as an _ADR style integer
    //

    adr = (Pdo->Slot.u.bits.DeviceNumber << 16) | Pdo->Slot.u.bits.FunctionNumber;

    for (count = 0; count < output->Count; count++) {

        //
        // Walking the arguments works like this because we are a package of
        // integers
        //

        argument = &output->Argument[count];

        if (argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {
            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }

        if (argument->Argument == adr) {
            //
            // Jackpot!
            //

            result = TRUE;
            break;
        }
    }

exit:

    if (output) {
        ExFreePool(output);
    }

    return result;

}

BOOLEAN
PciIsDeviceOnDebugPath(
    IN PPCI_PDO_EXTENSION Pdo
    )
/*++

Description:

    This function checks if device is on the path to the debugging device

    NOTE: PDO is only partially initialized at this point. Take care to insure
          that fields touched here are valid.

Arguments:

    Pdo - The PDO extension for the device

Return Value:

    TRUE if on the debug path, FALSE otherwise

--*/

{
    NTSTATUS status;
    PPCI_DEBUG_PORT current;
    PCI_COMMON_HEADER header;
    PPCI_COMMON_CONFIG config = (PPCI_COMMON_CONFIG) &header;

    PAGED_CODE();

    ASSERT(PciDebugPortsCount <= MAX_DEBUGGING_DEVICES_SUPPORTED);

    //
    // We can't be on the debug path if we aren't using a PCI debug port!
    //
    if (PciDebugPortsCount == 0) {
        return FALSE;
    }

    RtlZeroMemory(&header, sizeof(header));

    //
    // If its a bridge check if one of its subordinate buses has the debugger
    // port on it
    //

    if (Pdo->HeaderType == PCI_BRIDGE_TYPE
    ||  Pdo->HeaderType == PCI_CARDBUS_BRIDGE_TYPE) {

        //
        // Use the configuration that the firmware left the device in
        //

        status = PciGetBiosConfig(Pdo, config);

        ASSERT(NT_SUCCESS(status));

        FOR_ALL_IN_ARRAY(PciDebugPorts, PciDebugPortsCount, current) {

            if (current->Bus >= config->u.type1.SecondaryBus
            &&  current->Bus <= config->u.type1.SubordinateBus
            &&  config->u.type1.SecondaryBus != 0
            &&  config->u.type1.SubordinateBus != 0) {
                return TRUE;
            }
        }

    } else {

        UCHAR parentBus;

        if (PCI_PDO_ON_ROOT(Pdo)) {

            parentBus = PCI_PARENT_FDOX(Pdo)->BaseBus;

        } else {

            //
            // Get the BIOS config of the parent so we can get its initial bus
            // number
            //

            status = PciGetBiosConfig(PCI_BRIDGE_PDO(PCI_PARENT_FDOX(Pdo)),
                                      config
                                      );

            ASSERT(NT_SUCCESS(status));

            if (config->u.type1.SecondaryBus == 0
            ||  config->u.type1.SubordinateBus == 0) {
                //
                // This is a bridge that wasn't configured by the firmware so this
                // child can't be on the debug path.
                //
                return FALSE;

            } else {

                parentBus = config->u.type1.SecondaryBus;
            }

        }

        //
        // Check if we are the device on the correct bus in the correct slot
        //

        FOR_ALL_IN_ARRAY(PciDebugPorts, PciDebugPortsCount, current) {


            if (current->Bus == parentBus
            &&  current->Slot.u.AsULONG == Pdo->Slot.u.AsULONG) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

NTSTATUS
PciUpdateLegacyHardwareDescription(
    IN PPCI_FDO_EXTENSION Fdo
    )
{
    NTSTATUS status;
    HANDLE multifunctionHandle = NULL, indexHandle = NULL;
    WCHAR indexStringBuffer[10];
    UNICODE_STRING indexString, tempString;
    OBJECT_ATTRIBUTES attributes;
    UCHAR infoBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 50];
    PKEY_VALUE_PARTIAL_INFORMATION info = (PKEY_VALUE_PARTIAL_INFORMATION) infoBuffer;
    ULONG infoLength;
    ULONG disposition;
    CM_FULL_RESOURCE_DESCRIPTOR descriptor;
    PCM_FULL_RESOURCE_DESCRIPTOR full;
    CONFIGURATION_COMPONENT component;
    ULONG index;
    BOOLEAN createdNewKey = FALSE;

    if (!PciOpenKey(L"\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION\\System\\MultifunctionAdapter",
                    NULL,
                    &multifunctionHandle,
                    &status)) {

        goto exit;
    }

    //
    // HKML\Hardware\Description\System\MultifunctionAdapter is structured as
    // a set of 0 base consecutive numbered keys.
    // Run through all the subkeys and check that we haven't already reported
    // this bus
    //

    indexString.Buffer = indexStringBuffer;
    indexString.MaximumLength = sizeof(indexStringBuffer);
    indexString.Length = 0;

    for (index = 0;;index++) {

        status = RtlIntegerToUnicodeString(index, 10, &indexString);

        if (!NT_SUCCESS(status)) {
            goto exit;
        }

        InitializeObjectAttributes(&attributes,
                                   &indexString,
                                   OBJ_CASE_INSENSITIVE,
                                   multifunctionHandle,
                                   NULL
                                   );

        status = ZwCreateKey(&indexHandle,
                             KEY_ALL_ACCESS,
                             &attributes,
                             0,
                             NULL,
                             REG_OPTION_VOLATILE,
                             &disposition
                             );

        if (!NT_SUCCESS(status)) {
            goto exit;
        }

        //
        // As the keys are all consecutive then if we created this key we have
        // enumerated then all and we can get on with registering out data
        //

        if (disposition == REG_CREATED_NEW_KEY) {
            createdNewKey = TRUE;
            break;
        }

        PciConstStringToUnicodeString(&tempString, L"Identifier");

        status = ZwQueryValueKey(indexHandle,
                                 &tempString,
                                 KeyValuePartialInformation,
                                 info,
                                 sizeof(infoBuffer),
                                 &infoLength
                                 );

        if (NT_SUCCESS(status)) {

            if (info->Type == REG_SZ &&
               (wcscmp(L"PCI", (PWSTR)&info->Data) == 0)) {
                //
                // This is a PCI bus, now check if its our bus number
                //

                PciConstStringToUnicodeString(&tempString, L"Configuration Data");

                status = ZwQueryValueKey(indexHandle,
                                         &tempString,
                                         KeyValuePartialInformation,
                                         info,
                                         sizeof(infoBuffer),
                                         &infoLength
                                         );

                if (NT_SUCCESS(status)) {
                    if (info->Type == REG_FULL_RESOURCE_DESCRIPTOR) {

                        full = (PCM_FULL_RESOURCE_DESCRIPTOR) &info->Data;

                        ASSERT(full->InterfaceType == PCIBus);

                        if (full->BusNumber == Fdo->BaseBus) {

                            //
                            // We're already reported this so we don't need to
                            // do anything.
                            //

                            status = STATUS_SUCCESS;

                            //
                            // indexHandle will be closed by the exit path.
                            //
                            goto exit;

                        }
                    }
                }
            }
        }

        ZwClose(indexHandle);
        indexHandle = NULL;
    }

    //
    // if we created a new key then indexHandle is it
    //

    if (createdNewKey) {

        //
        // Fill in the Identifier entry.  This is a PCI bus.
        //

        PciConstStringToUnicodeString(&tempString, L"Identifier");

        status = ZwSetValueKey(indexHandle,
                               &tempString,
                               0,
                               REG_SZ,
                               L"PCI",
                               sizeof(L"PCI")
                               );

        if (!NT_SUCCESS(status)) {
            goto exit;
        }

        //
        // Fill in the Configuration Data entry.
        //
        // Note that the complete descriptor is not written to the registry just
        // enough data to indicate that this is an empty list (the first 16 bytes).
        // This is a bit gross but it is what happens on x86 machines today and
        // after all we're only doing this for backward compatibility.
        //

        RtlZeroMemory(&descriptor, sizeof(CM_FULL_RESOURCE_DESCRIPTOR));

        descriptor.InterfaceType = PCIBus;
        descriptor.BusNumber = Fdo->BaseBus;

        PciConstStringToUnicodeString(&tempString, L"Configuration Data");

        status = ZwSetValueKey(indexHandle,
                               &tempString,
                               0,
                               REG_FULL_RESOURCE_DESCRIPTOR,
                               &descriptor,
                               16
                               );

        if (!NT_SUCCESS(status)) {
            goto exit;
        }


        //
        // Fill in the Component Information entry.  This is the Flags, Revision, Version,
        // Key and AffinityMask members from the CONFIGURATION_COMPONENT structure.
        //
        // For PCI buses the affinity is set to all processors (0xFFFFFFFF) and
        // everything else is 0.
        //

        RtlZeroMemory(&component, sizeof(CONFIGURATION_COMPONENT));

        component.AffinityMask = 0xFFFFFFFF;

        PciConstStringToUnicodeString(&tempString, L"Component Information");

        status = ZwSetValueKey(indexHandle,
                               &tempString,
                               0,
                               REG_BINARY,
                               &component.Flags,
                               FIELD_OFFSET(CONFIGURATION_COMPONENT, ConfigurationDataLength) -
                                   FIELD_OFFSET(CONFIGURATION_COMPONENT, Flags)
                               );

        if (!NT_SUCCESS(status)) {
            goto exit;
        }

    }

    status = STATUS_SUCCESS;

exit:

    if (indexHandle) {

        //
        // If we are failing attempt to cleanup by deleting the key we tried
        // to create.
        //
        if (!NT_SUCCESS(status) && createdNewKey) {
            ZwDeleteKey(indexHandle);
        }

        ZwClose(indexHandle);
    }


    if (multifunctionHandle) {
        ZwClose(multifunctionHandle);
    }


    return status;

}

NTSTATUS
PciReadDeviceSpace(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    OUT PULONG LengthRead
    )

/*++

Routine Description:

    This function handles reading from PCI device spaces and is called for both 
    the IRP_MN_READ_CONFIG and the BUS_INTERFACE_STANDARD.GetBusData cases.

Arguments:

    PdoExtension - the PDO for the device we want to read from
    
    WhichSpace - what type of space we want to read - of the form PCI_WHICHSPACE_*

    Buffer - Supplies a pointer to where the data is to be returned

    Offset - Indicates the offset into the space where the reading should begin.

    Length - Indicates the count of bytes which should be read.
    
    LengthRead - Indicates the count of bytes which was actually read.

Return Value:

    Status

--*/

{
    // NOT PAGED
    
    NTSTATUS status;
    PVERIFIER_DATA verifierData;

    *LengthRead = 0;

    switch (WhichSpace) {

    default:
                               
        //
        // Many people hand in the wrong WhichSpace parameters slap them around if we are verifing...
        //

        verifierData = PciVerifierRetrieveFailureData(PCI_VERIFIER_INVALID_WHICHSPACE);
    
        ASSERT(verifierData);

        VfFailDeviceNode(
            PdoExtension->PhysicalDeviceObject,
            PCI_VERIFIER_DETECTED_VIOLATION,
            PCI_VERIFIER_INVALID_WHICHSPACE,
            verifierData->FailureClass,
            &verifierData->Flags,
            verifierData->FailureText,
            "%DevObj%Ulong",
            PdoExtension->PhysicalDeviceObject,
            WhichSpace
            );

        // fall through 

    case PCI_WHICHSPACE_CONFIG:

        status = PciExternalReadDeviceConfig(
                    PdoExtension,
                    Buffer,
                    Offset,
                    Length
                    );
        
        if(NT_SUCCESS(status)){
            *LengthRead = Length;
        }

        break;

    case PCI_WHICHSPACE_ROM:

        //
        // Read ROM.
        //

        *LengthRead = Length;

        status = PciReadRomImage(
                     PdoExtension,
                     WhichSpace,
                     Buffer,
                     Offset,
                     LengthRead
                     );
        break;
    }

    return status;
}


NTSTATUS
PciWriteDeviceSpace(
    IN PPCI_PDO_EXTENSION PdoExtension,
    IN ULONG WhichSpace,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    OUT PULONG LengthWritten
    )

/*++

Routine Description:

    This function handles reading from PCI device spaces and is called for both 
    the IRP_MN_WRITE_CONFIG and the BUS_INTERFACE_STANDARD.SetBusData cases.

Arguments:

    PdoExtension - the PDO for the device we want to write to
    
    WhichSpace - what type of space we want to write - of the form PCI_WHICHSPACE_*

    Buffer - Supplies a pointer to where the data is to be written resides

    Offset - Indicates the offset into the space where the writing should begin.

    Length - Indicates the count of bytes which should be written.
    
    LengthWritten - Indicates the count of bytes which was actually written.

Return Value:

    Status

--*/

{
    NTSTATUS status;
    PVERIFIER_DATA verifierData;

    *LengthWritten = 0;

    //
    // Any config space write could mean the resource requirements
    // list or resource list we have cached are no longer valid.
    //

    PciInvalidateResourceInfoCache(PdoExtension);

    switch (WhichSpace) {

    default:
                               
        //
        // Many people hand in the wrong WhichSpace parameters slap them around if we are verifing...
        //

        verifierData = PciVerifierRetrieveFailureData(PCI_VERIFIER_INVALID_WHICHSPACE);
    
        ASSERT(verifierData);

        VfFailDeviceNode(
            PdoExtension->PhysicalDeviceObject,
            PCI_VERIFIER_DETECTED_VIOLATION,
            PCI_VERIFIER_INVALID_WHICHSPACE,
            verifierData->FailureClass,
            &verifierData->Flags,
            verifierData->FailureText,
            "%DevObj%Ulong",
            PdoExtension->PhysicalDeviceObject,
            WhichSpace
            );
    
        // fall through 

    case PCI_WHICHSPACE_CONFIG:

        status = PciExternalWriteDeviceConfig(
                    PdoExtension,
                    Buffer,
                    Offset,
                    Length
                    );
        
        if( NT_SUCCESS(status)){
            *LengthWritten = Length;
        }

        break;

    case PCI_WHICHSPACE_ROM:

        //
        // You can't write ROM
        //

        PciDebugPrint(
            PciDbgAlways,
            "PCI (%08x) WRITE_CONFIG IRP for ROM, failing.\n",
            PdoExtension
            );
        
        status = STATUS_INVALID_DEVICE_REQUEST;
        *LengthWritten = 0;

        break;

    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pcidump\pcidump.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    pcienum.c

Abstract:

    Enumerates the PCI bus and puts all the found PCI information
    into the registery.

    This is done for debugging & support reasons.

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#include "ntddk.h"

WCHAR rgzMultiFunctionAdapter[] = L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter";
WCHAR rgzConfigurationData[] = L"Configuration Data";
WCHAR rgzIdentifier[] = L"Identifier";
WCHAR rgzPCIIndetifier[] = L"PCI";
WCHAR rgzPCIDump[] = L"PCI configuration space dump";
WCHAR rgzPCIConfigData[] = L"PCIConfigSpaceData";


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


BOOLEAN
FindRegisterLocation (
    PHANDLE     RegHandle
    )
{
    UNICODE_STRING      unicodeString, ConfigName, IdentName;
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              hMFunc, hBus;
    NTSTATUS            status;
    ULONG               i, junk, disposition;
    WCHAR               wstr[8];
    PKEY_VALUE_FULL_INFORMATION         ValueInfo;
    UCHAR               buffer [200];
    PWSTR               p;

    //
    // Search the hardware description looking for any reported
    // PCI bus.  The first ARC entry for a PCI bus will contain
    // the PCI_REGISTRY_INFO.
    //

    RtlInitUnicodeString (&unicodeString, rgzMultiFunctionAdapter);
    InitializeObjectAttributes (
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL);


    status = ZwOpenKey (&hMFunc, KEY_READ | KEY_WRITE, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    unicodeString.Buffer = wstr;
    unicodeString.MaximumLength = sizeof (wstr);

    RtlInitUnicodeString (&ConfigName, rgzConfigurationData);
    RtlInitUnicodeString (&IdentName,  rgzIdentifier);

    ValueInfo = (PKEY_VALUE_FULL_INFORMATION) buffer;

    for (i=0; TRUE; i++) {
        RtlIntegerToUnicodeString (i, 10, &unicodeString);
        InitializeObjectAttributes (
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            hMFunc,
            NULL);

        status = ZwOpenKey (&hBus, KEY_READ | KEY_WRITE, &objectAttributes);
        if (!NT_SUCCESS(status)) {
            //
            // Out of Multifunction adapter entries...
            //

            ZwClose (hMFunc);
            return FALSE;
        }

        //
        // Check the Indentifier to see if this is a PCI entry
        //

        status = ZwQueryValueKey (
                    hBus,
                    &IdentName,
                    KeyValueFullInformation,
                    ValueInfo,
                    sizeof (buffer),
                    &junk
                    );

        if (!NT_SUCCESS (status)) {
            ZwClose (hBus);
            continue;
        }

        p = (PWSTR) ((PUCHAR) ValueInfo + ValueInfo->DataOffset);
        if (p[0] != L'P' || p[1] != L'C' || p[2] != L'I' || p[3] != 0) {
            ZwClose (hBus);
            continue;
        }

        // found it...
        break;

    }

    //
    // Initialize the object for the key.
    //

    RtlInitUnicodeString (&unicodeString, rgzPCIDump);

    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        hBus,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = ZwCreateKey (
                RegHandle,
                KEY_READ | KEY_WRITE,
                &objectAttributes,
                0,
                NULL,
                REG_OPTION_VOLATILE,
                &disposition
                );

    return NT_SUCCESS(status);
}



VOID
DumpPciConfigSpaceIntoRegistry (
    HANDLE  RegHandle
    )
{

    PCI_SLOT_NUMBER     SlotNumber;
    ULONG               BusNo, DeviceNo, FunctionNo, BytesRead;
    BOOLEAN             ScanFlag;
    PCI_COMMON_CONFIG   PciData;
    HANDLE              HBus, HDevice;
    UNICODE_STRING      unicodeString;
    OBJECT_ATTRIBUTES   objectAttributes;
    NTSTATUS            status;
    ULONG               len, disposition;
    WCHAR               wstr[80];

    SlotNumber.u.bits.Reserved = 0;
    BusNo = 0;
    ScanFlag = TRUE;

    while (ScanFlag) {
        for (DeviceNo=0; ScanFlag && DeviceNo < PCI_MAX_DEVICES; DeviceNo++) {
            SlotNumber.u.bits.DeviceNumber = DeviceNo;

            for (FunctionNo = 0; FunctionNo < PCI_MAX_FUNCTION; FunctionNo++) {
                SlotNumber.u.bits.FunctionNumber = FunctionNo;

                BytesRead = HalGetBusData (
                                PCIConfiguration,
                                BusNo,
                                SlotNumber.u.AsULONG,
                                &PciData,
                                PCI_COMMON_HDR_LENGTH
                                );

                //
                // If end-of-scan
                //

                if (BytesRead == 0) {
                    ScanFlag = FALSE;
                    break;
                }

                //
                // If not present, next device
                //

                if (PciData.VendorID ==  PCI_INVALID_VENDORID) {
                    break;
                }

                //
                // If Intel Device ID, then read complete state
                //

                if (PciData.VendorID == 0x8086) {
                    if (PciData.DeviceID == 0x04A3 ||
                        PciData.DeviceID == 0x0482 ||
                        PciData.DeviceID == 0x0484) {

                        BytesRead = HalGetBusData (
                                        PCIConfiguration,
                                        BusNo,
                                        SlotNumber.u.AsULONG,
                                        &PciData,
                                        sizeof (PciData)
                                        );
                    }
                }

                //
                // Open/Create bus entry in registry
                //

                swprintf (wstr, L"PCI bus%d", BusNo);
                RtlInitUnicodeString (&unicodeString, wstr);

                InitializeObjectAttributes(
                    &objectAttributes,
                    &unicodeString,
                    OBJ_CASE_INSENSITIVE,
                    RegHandle,
                    (PSECURITY_DESCRIPTOR) NULL
                    );

                status = ZwCreateKey (
                            &HBus,
                            KEY_READ | KEY_WRITE,
                            &objectAttributes,
                            0,
                            NULL,
                            REG_OPTION_VOLATILE,
                            &disposition
                            );


                if (!NT_SUCCESS(status)) {
                    continue;
                }

                //
                // Open/Create device function key
                //

                swprintf (wstr, L"Device %02d  Function %d", DeviceNo, FunctionNo);
                RtlInitUnicodeString (&unicodeString, wstr);

                InitializeObjectAttributes(
                    &objectAttributes,
                    &unicodeString,
                    OBJ_CASE_INSENSITIVE,
                    HBus,
                    (PSECURITY_DESCRIPTOR) NULL
                    );

                status = ZwCreateKey (
                            &HDevice,
                            KEY_READ | KEY_WRITE,
                            &objectAttributes,
                            0,
                            NULL,
                            REG_OPTION_VOLATILE,
                            &disposition
                            );


                ZwClose (HBus);
                if (!NT_SUCCESS(status)) {
                    continue;
                }

                //
                // Write PCI config information to registry
                //

                len = swprintf (wstr, L"%04x-%04x rev %x",
                    PciData.VendorID,
                    PciData.DeviceID,
                    PciData.RevisionID
                    );

                RtlInitUnicodeString (&unicodeString, L"Device ID");
                ZwSetValueKey (
                    HDevice,
                    &unicodeString,
                    0L,
                    REG_SZ,
                    wstr,
                    sizeof (WCHAR) * len
                    );


                RtlInitUnicodeString (&unicodeString, L"RawData");
                ZwSetValueKey (
                    HDevice,
                    &unicodeString,
                    0L,
                    REG_BINARY,
                    &PciData,
                    BytesRead
                    );

                ZwClose (HDevice);
            }

        }

        BusNo += 1;
    }
}



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:


Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    BOOLEAN     flag;
    HANDLE      RegHandle;

    flag = FindRegisterLocation (&RegHandle);
    if (flag) {
        DumpPciConfigSpaceIntoRegistry (RegHandle);
        ZwClose (RegHandle);
    }

    // never load
    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This is the cluster-wide sources include file. All cluster sources files
    include this.

Author:

    Steve Wood (stevewo) 12-Apr-1990

    C. Brent Thomas (a-brentt) 23-Mar-1998

	Eliminated the use of the ALT_PROJECT_TARGET macro with the result
	that the symbol files will be placed in the ??? directory.

!ENDIF

MAJORCOMP=cluster
BINPLACE_PLACEFILE=$(PROJECT_ROOT)\cluster\placefil.txt
MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=$(C_DEFINES) -DCLUSTER_BETA=0 -DSTARTUP_FAILURE_RESTART=1

LEAKSLIB=$(PROJECT_ROOT)\cluster\clusexts\leaks\$(O)\leaks.lib

!IF !DEFINED(NO_SPECIAL_DEBUG)
!IF DEFINED(USE_DEBUG_CRTS)
DEBUG_CRTS=1
!ENDIF
!IF !$(FREEBUILD)
RCOPTIONS=$(RCOPTIONS) -D_DEBUG
!ENDIF
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\app.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      App.cpp
//
//  Abstract:
//      Implementation of the CApp class.
//
//  Author:
//      David Potter (davidp)   December 1, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "App.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CApp
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
_CrtMemState CApp::s_msStart = { 0 };
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CApp::Init
//
//  Routine Description:
//      Initialize the module.
//
//  Arguments:
//      p           COM Object map.
//      h           Instance handle.
//      pszAppName  Application name.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CApp::Init( _ATL_OBJMAP_ENTRY * p, HINSTANCE h, LPCWSTR pszAppName )
{
    ASSERT( pszAppName != NULL );

#ifdef _DEBUG
    _CrtMemCheckpoint( &s_msStart );
#endif // _DEBUG

    CComModule::Init( p, h );

    // Deallocate the buffer if it was allocated previously
    // since we don't have any way of knowing if it is big
    // enough for the new app name.
    if ( m_pszAppName != NULL )
    {
        delete [] m_pszAppName;
        m_pszAppName = NULL;
    } // if: allocated previously

    // Allocate an app name buffer and copy the app name to it.
    m_pszAppName = new TCHAR[ lstrlen( pszAppName ) + 1 ];
    ASSERT( m_pszAppName != NULL );
    if ( m_pszAppName != NULL )
    {
        lstrcpy( m_pszAppName, pszAppName );
    } // if: memory for app name allocated successfully

} //*** CApp::Init( pszAppName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CApp::Init
//
//  Routine Description:
//      Initialize the module.
//
//  Arguments:
//      p           COM Object map.
//      h           Instance handle.
//      idsAppName  Resource ID for the application name.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CApp::Init( _ATL_OBJMAP_ENTRY * p, HINSTANCE h, UINT idsAppName )
{
    ASSERT( idsAppName != 0 );

#ifdef _DEBUG
    _CrtMemCheckpoint( &s_msStart );
#endif // _DEBUG

    CComModule::Init( p, h );

    //
    // Save the application name.
    //
    {
        CString strAppName;
        strAppName.LoadString( idsAppName );

        // Deallocate the buffer if it was allocated previously
        // since we don't have any way of knowing if it is big
        // enough for the new app name.
        if ( m_pszAppName != NULL )
        {
            delete [] m_pszAppName;
            m_pszAppName = NULL;
        } // if: allocated previously

        // Allocate an app name buffer and copy the app name to it.
        m_pszAppName = new TCHAR[ strAppName.GetLength() + 1 ];
        ASSERT( m_pszAppName != NULL );
        if ( m_pszAppName != NULL )
        {
            lstrcpy( m_pszAppName, strAppName );
        } // if: memory for app name allocated successfully
    } // Save the application name

} //*** CApp::Init( idsAppName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CApp::GetProfileString
//
//  Routine Description:
//      Read a value from the profile.
//
//  Arguments:
//      lpszSection [IN] Name of subkey below HKEY_CURRENT_USER to read from.
//      lpszEntry   [IN] Name of value to read.
//      lpszDefault [IN] Default if no value found.
//
//  Return Value:
//      CString value.
//
//--
/////////////////////////////////////////////////////////////////////////////
CString CApp::GetProfileString(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszDefault // = NULL
    )
{
    CRegKey key;
    CString strKey;
    CString strValue;
    LPTSTR  pszValue;
    DWORD   cbValue;
    DWORD   sc;

    ASSERT( m_pszAppName != NULL );
    if ( m_pszAppName == NULL )
    {
        return _T( "" );
    } // if: app name buffer not allocated

    // Open the key.
    strKey.Format( _T("Software\\%s\\%s"), m_pszAppName, lpszSection );
    sc = key.Open( HKEY_CURRENT_USER, strKey, KEY_READ );
    if ( sc != ERROR_SUCCESS )
    {
        return lpszDefault;
    } // if:  error opening the key

    // Read the value.
    cbValue = 256;
    pszValue = strValue.GetBuffer( cbValue / sizeof( TCHAR ) );
    sc = key.QueryValue( pszValue, lpszEntry, &cbValue );
    if ( sc != ERROR_SUCCESS )
    {
        return lpszDefault;
    } // if:  error querying the value

    // Return the buffer to the caller.
    strValue.ReleaseBuffer();
    return strValue;

} //*** CApp::GetProfileString()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CApp::PszHelpFilePath
//
//  Routine Description:
//      Return the help file path.
//
//  Arguments:
//      None.
//
//  Return Value:
//      LPCTSTR
//
//--
/////////////////////////////////////////////////////////////////////////////
LPCTSTR CApp::PszHelpFilePath( void )
{
    static TCHAR    s_szHelpFilePath[ _MAX_PATH ] = { 0 };
    TCHAR           szPath[ _MAX_PATH ];
    TCHAR           szDrive[ _MAX_PATH ];
    TCHAR           szDir[ _MAX_DIR ];
    int             cchPath;

    //
    // Generate the help file path.  The help file is located in
    // %SystemRoot%\Help.
    //
    if ( s_szHelpFilePath[ 0 ] == _T('\0') )
    {
        ::GetSystemWindowsDirectory( szPath, _MAX_PATH );
        cchPath = lstrlen( szPath );
        if ( szPath[ cchPath - 1 ] != _T('\\') )
        {
            szPath[ cchPath++ ] = _T('\\');
            szPath[ cchPath ] = _T('\0');
        } // if: no backslash on the end of the path

        lstrcpy( &szPath[ cchPath ], _T("Help\\") );
        _tsplitpath( szPath, szDrive, szDir, NULL, NULL );
        _tmakepath( s_szHelpFilePath, szDrive, szDir, _T("cluadmin"), _T(".hlp") );
    } // if: help file name hasn't been constructed yet

    return s_szHelpFilePath;

} //*** CApp::PszHelpFilePath()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\app.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		App.h
//
//	Abstract:
//		Definition of the CApp class.
//
//	Implementation File:
//		App.cpp
//
//	Author:
//		David Potter (davidp)	December 1, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __APP_H_
#define __APP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CApp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

namespace ATL
{
	class CString;
}

/////////////////////////////////////////////////////////////////////////////
// External Declarations
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
_CRTIMP void __cdecl _CrtMemCheckpoint(_CrtMemState * state);
_CRTIMP int __cdecl _CrtMemDifference(
		_CrtMemState * state,
		const _CrtMemState * oldState,
		const _CrtMemState * newState
		);
_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(const _CrtMemState * state);
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEAPP_H_
#include <AtlBaseApp.h>
#endif

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////

const LPTSTR g_pszHelpFileName = { _T( "CluAdmin.hlp" ) };

/////////////////////////////////////////////////////////////////////////////
// class CApp
/////////////////////////////////////////////////////////////////////////////

class CApp : public CBaseApp
{
protected:
	LPWSTR m_pszAppName;

#ifdef _DEBUG
	static _CrtMemState CApp::s_msStart;
#endif // _DEBUG

public:
	// Default constructor
	CApp(void)
	{
		m_pszAppName = NULL;
	}

	// Destructor
	~CApp(void)
	{
		delete [] m_pszAppName;
	}

	// Initialize the application object
	void Init(_ATL_OBJMAP_ENTRY * p, HINSTANCE h, LPCWSTR pszAppName);

	// Initialize the application object
	void Init(_ATL_OBJMAP_ENTRY * p, HINSTANCE h, UINT idsAppName);

	void Term(void)
	{
		delete [] m_pszAppName;
		m_pszAppName = NULL;
		CComModule::Term();
#ifdef _DEBUG
		_CrtMemState msNow;
		_CrtMemState msDiff;
		_CrtMemCheckpoint(&msNow);
		if (_CrtMemDifference(&msDiff, &s_msStart, &msNow))
		{
			ATLTRACE(_T("Possible memory leaks detected in CLADMWIZ!\n"));
            _CrtMemDumpAllObjectsSince(&s_msStart);
		} // if:  memory leak detected
#endif // _DEBUG

	} //*** Term()

	// Returns the name of the application.
	LPCTSTR PszAppName(void)
	{
		return m_pszAppName;
	}

	// Display a message box as a child of the console
	int MessageBox(
		HWND hwndParent,
		LPCWSTR lpszText,
		UINT fuStyle = MB_OK
		);

	// Display a message box as a child of the console
	int MessageBox(
		HWND hwndParent,
		UINT nID,
		UINT fuStyle = MB_OK
		);

	// Read a value from the profile
	CString GetProfileString(
		LPCTSTR lpszSection,
		LPCTSTR lpszEntry,
		LPCTSTR lpszDefault = NULL
		);

	virtual LPCTSTR PszHelpFilePath( void );

}; // class CApp

/////////////////////////////////////////////////////////////////////////////

#endif // __APP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\app.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		App.inl
//
//	Abstract:
//		Inline method implementations for the CApp class.
//
//	Author:
//		David Potter (davidp)	December 1, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __APP_INL_
#define __APP_INL_

/////////////////////////////////////////////////////////////////////////////
// class CApp
/////////////////////////////////////////////////////////////////////////////

// Display a message box
inline int CApp::MessageBox(
	HWND hwndParent,
	LPCWSTR lpszText,
	UINT fuStyle
	)
{
	return ::MessageBox(
			hwndParent,
			lpszText,
			m_pszAppName,
			fuStyle
			);

} //*** CApp::MessageBox(lpszText)

// Display a message box
inline int CApp::MessageBox(
	HWND hwndParent,
	UINT nID,
	UINT fuStyle
	)
{
	CString strMsg;

	strMsg.LoadString(nID);
	return MessageBox(hwndParent, strMsg, fuStyle);

} //*** CApp::MessageBox(nID)

/////////////////////////////////////////////////////////////////////////////
// Helper Functions
/////////////////////////////////////////////////////////////////////////////

// Get a pointer to the application object
inline CApp * GetApp(void)
{
	return &_Module;
}

// Display an application message box
inline int AppMessageBox(HWND hwndParent, LPCWSTR lpszText, UINT fuStyle)
{
	return GetApp()->MessageBox(hwndParent, lpszText, fuStyle);

} // AppMessageBox()

// Display an application message box
inline int AppMessageBox(HWND hwndParent, UINT nID, UINT fuStyle)
{
	return GetApp()->MessageBox(hwndParent, nID, fuStyle);

} // MessageBox()

/////////////////////////////////////////////////////////////////////////////
// Provide TRACE support
/////////////////////////////////////////////////////////////////////////////

// Get a pointer to the application object
inline CApp * TRACE_GetApp(void)
{
	return GetApp();
}

inline int TRACE_AppMessageBox(LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0)
{
	return AppMessageBox(NULL, lpszText, nType);
}

inline int TRACE_AppMessageBox(UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1)
{
	return AppMessageBox(NULL, nIDPrompt, nType);
}

/////////////////////////////////////////////////////////////////////////////

#endif // __APP_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\arcreate.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		ARCreate.cpp
//
//	Abstract:
//		Implementation of the CWizPageARCreate class.
//
//	Author:
//		David Potter (davidp)	December 8, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ARCreate.h"
#include "ClusAppWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageARCreate
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageARCreate )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARC_CREATE_RES )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARC_DONT_CREATE_RES )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARCreate::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARCreate::OnInitDialog( void )
{
	//
	// Attach the controls to control member variables.
	//
	AttachControl( m_rbCreateAppRes, IDC_ARC_CREATE_RES );
	AttachControl( m_rbDontCreateAppRes, IDC_ARC_DONT_CREATE_RES );

	return TRUE;

} //*** CWizPageARCreate::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARCreate::OnSetActive
//
//	Routine Description:
//		Handler for PSN_SETACTIVE.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Page activated successfully.
//		FALSE		Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARCreate::OnSetActive( void )
{
	//
	// Get info from the sheet.
	//
	m_bCreatingAppResource = PwizThis()->BCreatingAppResource();


	//
	// Call the base class and return.
	//
	return baseClass::OnSetActive();

} //*** CWizPageARCreate::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARCreate::UpdateData
//
//	Routine Description:
//		Update data on or from the page.
//
//	Arguments:
//		bSaveAndValidate	[IN] TRUE if need to read data from the page.
//								FALSE if need to set data to the page.
//
//	Return Value:
//		TRUE		The data was updated successfully.
//		FALSE		An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARCreate::UpdateData( BOOL bSaveAndValidate )
{
	BOOL	bSuccess = TRUE;

	if ( bSaveAndValidate )
	{
		BOOL bChecked = (m_rbCreateAppRes.GetCheck() == BST_CHECKED);
		m_bCreatingAppResource = bChecked;
	} // if: saving data from the page
	else
	{
		if ( m_bCreatingAppResource )
		{
			//
			// Default the radio button selection.
			//
			m_rbCreateAppRes.SetCheck( BST_CHECKED );
			m_rbDontCreateAppRes.SetCheck( BST_UNCHECKED );

		} // if:  creating application resource
		else
		{
			//
			// Default the radio button selection.
			//
			m_rbCreateAppRes.SetCheck( BST_UNCHECKED );
			m_rbDontCreateAppRes.SetCheck( BST_CHECKED );

		} // else:  not creating application resource

	} // else:  setting data to the page

	return bSuccess;

} //*** CWizPageARCreate::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARCreate::BApplyChanges
//
//	Routine Description:
//		Apply changes made on this page to the sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		The data was applied successfully.
//		FALSE		An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARCreate::BApplyChanges( void )
{
	if ( ! PwizThis()->BSetCreatingAppResource( m_bCreatingAppResource ) )
	{
		return FALSE;
	} // if:  error applying the change to the wizard

	if ( ! m_bCreatingAppResource )
	{
		SetNextPage( IDD_COMPLETION );
		PwizThis()->RemoveExtensionPages();
	} // if: not creating applicaton resource

	return TRUE;

} //*** CWizPageARCreate::BApplyChanges()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\arcreated.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ARCreated.h
//
//	Abstract:
//		Definition of the CWizPageARCreated class.
//
//	Implementation File:
//		ARCreated.cpp
//
//	Author:
//		David Potter (davidp)	December 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ARCREATED_H_
#define __ARCREATED_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageARCreated;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageARCreated
/////////////////////////////////////////////////////////////////////////////

class CWizPageARCreated : public CClusterAppStaticWizardPage< CWizPageARCreated >
{
	typedef CClusterAppStaticWizardPage< CWizPageARCreated > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageARCreated( void )
	{
	} //*** CWizPageARCreated()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_ARCD )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_ARCD )

	enum { IDD = IDD_APP_RESOURCE_CREATED };

public:
	//
	// CWizardPageWindow public methods.
	//

public:
	//
	// CBasePage public methods.
	//

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CWizPageARCreated )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

// Implementation
protected:

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_APP_RESOURCE_CREATED; }

}; //*** class CWizPageARCreated

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageARCreated )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////

#endif // __ARCREATED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\arname.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		ARName.cpp
//
//	Abstract:
//		Implementation of the CWizPageARNameDesc class.
//
//	Author:
//		David Potter (davidp)	December 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ARName.h"
#include "ClusAppWiz.h"
#include "ResAdv.h"			// for CGeneralResourceAdvancedSheet

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageARNameDesc
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageARNameDesc )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_RES_NAME_TITLE )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_RES_NAME_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_RES_NAME )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_RES_DESC_TITLE )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_RES_DESC_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_RES_DESC )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_ADVANCED_PROPS_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_ADVANCED_PROPS )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_CLICK_NEXT )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARNameDesc::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		psht		[IN] Property sheet object to which this page belongs.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Error initializing the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARNameDesc::BInit( IN CBaseSheetWindow * psht )
{
	//
	// Call the base class method.
	//
	return baseClass::BInit( psht );

} //*** CWizPageARNameDesc::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARNameDesc::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARNameDesc::OnInitDialog( void )
{
	//
	// Make a local copy of the dependency list and the possible owners
	// list. This is needed to find out the changes made to these lists.
	//
	CClusResInfo *	_priAppResInfoPtr = PwizThis()->PriApplication();

	m_lpriOldDependencies = *(_priAppResInfoPtr->PlpriDependencies());
	m_lpniOldPossibleOwners = *(_priAppResInfoPtr->PlpniPossibleOwners());

	//
	// Attach the controls to control member variables.
	//
	AttachControl( m_editResName, IDC_ARND_RES_NAME );
	AttachControl( m_editResDesc, IDC_ARND_RES_DESC );

	return TRUE;

} //*** CWizPageARNameDesc::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARNameDesc::UpdateData
//
//	Routine Description:
//		Update data on or from the page.
//
//	Arguments:
//		bSaveAndValidate	[IN] TRUE if need to read data from the page.
//								FALSE if need to set data to the page.
//
//	Return Value:
//		TRUE		The data was updated successfully.
//		FALSE		An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARNameDesc::UpdateData( BOOL bSaveAndValidate )
{
	BOOL			_bSuccess = TRUE;
	CClusResInfo *	_priAppResInfoPtr = PwizThis()->PriApplication();

	if ( bSaveAndValidate )
	{
		DDX_GetText( m_hWnd, IDC_ARND_RES_NAME, m_strResName );
		DDX_GetText( m_hWnd, IDC_ARND_RES_DESC, m_strResDesc );

		if ( ! BBackPressed() && ( m_bAdvancedButtonPressed == FALSE ) )
		{
			if ( ! DDV_RequiredText( m_hWnd, IDC_ARND_RES_NAME, IDC_ARND_RES_NAME_LABEL, m_strResName ) )
			{
				return FALSE;
			} // if: required text not specified
		} // if:  Back button not presssed

		//
		// Check if the resource name has changed. If so update the data in
		// the wizard and set a flag.
		//
		if ( _priAppResInfoPtr->RstrName().CompareNoCase( m_strResName ) != 0 )
		{
			_priAppResInfoPtr->SetName( m_strResName );
			m_bNameChanged = TRUE;
		} // if: resource name changed

		//
		// Check if the resource description has changed. If so update the data in
		// the wizard and set a flag.
		//
		if ( _priAppResInfoPtr->RstrDescription().CompareNoCase( m_strResDesc ) != 0 )
		{
			_priAppResInfoPtr->SetDescription( m_strResDesc );
			PwizThis()->SetAppDataChanged();
		} // if: description changed
	} // if: saving data from the page
	else
	{
		m_strResName = _priAppResInfoPtr->RstrName();
		m_strResDesc = _priAppResInfoPtr->RstrDescription();
		m_editResName.SetWindowText( m_strResName );
		m_editResDesc.SetWindowText( m_strResDesc );
	} // else:  setting data to the page

	return _bSuccess;

} //*** CWizPageARNameDesc::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARNameDesc::OnWizardBack
//
//	Routine Description:
//		Handler for PSN_WIZBACK.
//
//	Arguments:
//		None.
//
//	Return Value:
//		0				Move to previous page.
//		-1				Don't move to previous page.
//		anything else	Move to specified page.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CWizPageARNameDesc::OnWizardBack( void )
{
	int _nResult;

	//
	// Call the base class.  This causes our UpdateData() method to get
	// called.  If it succeeds, save our values.
	//
	_nResult = baseClass::OnWizardBack();

	return _nResult;

} //*** CWizPageARNameDesc::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARNameDesc::BApplyChanges
//
//	Routine Description:
//		Apply changes made on this page to the sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		The data was applied successfully.
//		FALSE		An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARNameDesc::BApplyChanges( void )
{
	BOOL	_bSuccess = FALSE;

	// Loop to avoid goto's.
	do
	{
		CClusResInfo *	priAppResInfoPtr = &PwizThis()->RriApplication();

		if ( BResourceNameInUse() )
		{
			CString _strMsg;
			_strMsg.FormatMessage( IDS_ERROR_RESOURCE_NAME_IN_USE, m_strResName );
			AppMessageBox( m_hWnd, _strMsg, MB_OK | MB_ICONEXCLAMATION );
			break;
		} // if:  resource name is already in use


		//
		// Create the resource if the if the resource does not exist.
		//
		if ( PwizThis()->PriApplication()->BCreated() == FALSE )
		{
			//
			// Delete the resource if it already exists.
			//
			_bSuccess = PwizThis()->BDeleteAppResource();
			if ( _bSuccess == FALSE )
			{
				break;
			} // if:	resource deletion failed.

			//
			//
			// Ensure all required dependencies are present.
			//
			_bSuccess = PwizThis()->BRequiredDependenciesPresent( &PwizThis()->RriApplication() );
			if ( _bSuccess == FALSE )
			{
				break;
			} // if:  all required dependencies not present

			//
			// Create the resource.
			//
			_bSuccess = PwizThis()->BCreateAppResource();
			if ( _bSuccess == FALSE )
			{
				break;
			} // if:	resource creation failed.

			//
			// Copy the list of dependencies and possible owners.
			// This is required to update only the changes to these lists.
			//
			m_lpriOldDependencies = *(priAppResInfoPtr->PlpriDependencies());
			m_lpniOldPossibleOwners = *(priAppResInfoPtr->PlpniPossibleOwners());

			m_bNameChanged = FALSE;
			//
			// Add extension pages.
			//
			Pwiz()->AddExtensionPages( NULL /*hfont*/, PwizThis()->HiconRes() );

		} // if:  the application has not been created
		else
		{
			CClusResInfo *	_priAppResInfoPtr = &PwizThis()->RriApplication();

			//
			// The name of the resource has changed. We cannot set it with the
			// rest of the properties since it is a read only property. So, use
			// the SetClusterResourceName API.
			//
			if ( m_bNameChanged != FALSE )
			{
				if ( SetClusterResourceName(
							_priAppResInfoPtr->Hresource(), 
							_priAppResInfoPtr->RstrName()
							)
					!= ERROR_SUCCESS 
					)
				{
					_bSuccess = FALSE;
					break;
				} // if: the name of the resource could not be set

				m_bNameChanged = FALSE;
			} // if: the name of the resource has changed

			// 
			// If the app data has changed, update the data.
			//
			if ( PwizThis()->BAppDataChanged() )
			{
				_bSuccess = PwizThis()->BSetAppResAttributes( &m_lpriOldDependencies, &m_lpniOldPossibleOwners );
				if ( _bSuccess )
				{
					//
					// Copy the list of dependencies and possible owners.
					// This is required to update only the changes to these lists.
					//
					m_lpriOldDependencies = *(_priAppResInfoPtr->PlpriDependencies());
					m_lpniOldPossibleOwners = *(_priAppResInfoPtr->PlpniPossibleOwners());
				} // if: set attributes successfully
			} // if:  application data changed
			else
			{
				_bSuccess = TRUE;
			} // else:  application data has not changed.
		} // else:	the application has been created

	} while ( 0 );

	return _bSuccess;

} //*** CWizPageARNameDesc::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARNameDesc::OnAdvancedProps
//
//	Routine Description:
//		Handler for the BN_CLICKED command notification on IDC_ARA_ADVANCED_PROPS.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Ignored.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CWizPageARNameDesc::OnAdvancedProps(
	WORD /*wNotifyCode*/,
	WORD /*idCtrl*/,
	HWND /*hwndCtrl*/,
	BOOL & /*bHandled*/
	)
{
	CWaitCursor		_wc;
	CClusResInfo *	_priAppResInfoPtr = PwizThis()->PriApplication();
	BOOL			_bAppDataChanged = PwizThis()->BAppDataChanged();


	m_bAdvancedButtonPressed = TRUE;

	UpdateData( TRUE );

	CGeneralResourceAdvancedSheet _sht( IDS_ADV_RESOURCE_PROP_TITLE, PwizThis() );
	if ( _sht.BInit( *_priAppResInfoPtr, _bAppDataChanged ) )
	{
		//
		// Display the property sheet.  If any properties were changed,
		// update the display of the resource name and description.
		//
		_sht.DoModal();

		PwizThis()->SetAppDataChanged( _bAppDataChanged );
		UpdateData( FALSE );
	} // if:  sheet successfully initialized

	m_bAdvancedButtonPressed = FALSE;

	return 0;

} //*** CWizPageARNameDesc::OnAdvancedProps()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\arname.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		ARName.h
//
//	Abstract:
//		Definition of the CWizPageARNameDesc class.
//
//	Implementation File:
//		ARName.cpp
//
//	Author:
//		David Potter (davidp)	December 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ARNAME_H_
#define __ARNAME_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageARNameDesc;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __CLUSAPPWIZ_H_
#include "ClusAppWiz.h"		// for using CClusterAppWizard
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageARNameDesc
/////////////////////////////////////////////////////////////////////////////

class CWizPageARNameDesc : public CClusterAppStaticWizardPage< CWizPageARNameDesc >
{
	typedef CClusterAppStaticWizardPage< CWizPageARNameDesc > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageARNameDesc( void ) 
		: m_bAdvancedButtonPressed( FALSE )
		, m_bNameChanged( FALSE )
	{
	} //*** CCWizPageARNameDesc()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_ARND )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_ARND )

	enum { IDD = IDD_APP_RESOURCE_NAME_DESC };

public:
	//
	// CWizardPageWindow public methods.
	//

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

public:
	//
	// CWizardPageImpl required methods.
	//

	// Initialize the page
	BOOL BInit( IN CBaseSheetWindow * psht );

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( BOOL bSaveAndValidate );

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( CWizPageARNameDesc )
		COMMAND_HANDLER( IDC_ARND_RES_NAME, EN_CHANGE, OnResNameChanged )
		COMMAND_HANDLER( IDC_ARND_ADVANCED_PROPS, BN_CLICKED, OnAdvancedProps )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	// Handler for the EN_CHANGE command notification on IDC_ARND_RES_NAME
	LRESULT OnResNameChanged(
		WORD /*wNotifyCode*/,
		WORD /*idCtrl*/,
		HWND /*hwndCtrl*/,
		BOOL & /*bHandled*/
		)
	{
		BOOL bEnable = (m_editResName.GetWindowTextLength() > 0);
		EnableNext( bEnable );
		return 0;

	} //*** OnResNameChanged()

	// Handler for the BN_CLICKED command notification on IDC_ARA_ADVANCE_PROPS
	LRESULT OnAdvancedProps(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		);

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

	// Handler for PSN_WIZBACK
	int OnWizardBack( void );

// Implementation
protected:
	//
	// Controls.
	//
	CEdit		m_editResName;
	CEdit		m_editResDesc;

	//
	// Page state.
	//
	CString				m_strResName;
	CString				m_strResDesc;
	BOOL				m_bAdvancedButtonPressed;
	BOOL				m_bNameChanged;
	CClusResPtrList		m_lpriOldDependencies;
	CClusNodePtrList	m_lpniOldPossibleOwners;

	//
	// Utility methods.
	//

	// Determine if the resource name is already in use
	BOOL BResourceNameInUse( void )
	{
		return ( PwizThis()->PriFindResourceNoCase( m_strResName ) != NULL );

	} //*** BResourceNameInUse()

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_APP_RESOURCE_NAME_DESC; }

}; //*** class CWizPageARNameDesc

/////////////////////////////////////////////////////////////////////////////

#endif // __ARNAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\arcreate.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ARCreate.h
//
//	Abstract:
//		Definition of the CWizPageARCreate class.
//
//	Implementation File:
//		ARCreate.cpp
//
//	Author:
//		David Potter (davidp)	December 8, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ARCREATE_H_
#define __ARCREATE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageARCreate;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageARCreate
/////////////////////////////////////////////////////////////////////////////

class CWizPageARCreate : public CClusterAppStaticWizardPage< CWizPageARCreate >
{
	typedef CClusterAppStaticWizardPage< CWizPageARCreate > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageARCreate( void ) : m_bCreatingAppResource( TRUE )
	{
	} //*** CWizPageARCreate()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_ARC )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_ARC )

	enum { IDD = IDD_APP_RESOURCE_CREATE };

public:
	//
	// CWizardPageWindow public methods.
	//

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( BOOL bSaveAndValidate );

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CWizPageARCreate )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void );

// Implementation
protected:
	//
	// Controls.
	//
	CButton		m_rbCreateAppRes;
	CButton		m_rbDontCreateAppRes;

	//
	// Page state.
	//
	BOOL		m_bCreatingAppResource;

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_APP_RESOURCE_CREATE; }

}; //*** class CWizPageARCreate

/////////////////////////////////////////////////////////////////////////////

#endif // __ARCREATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\atlbasepropsheets.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlBasePropSheetS.cpp
//
//	Abstract:
//		Stub for implementation of base property sheet classes.
//
//	Author:
//		David Potter (davidp)	April 20, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "AtlBasePropSheet.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\artype.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ARType.h
//
//	Abstract:
//		Definition of the CWizPageARType class.
//
//	Implementation File:
//		ARType.cpp
//
//	Author:
//		David Potter (davidp)	December 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ARTYPE_H_
#define __ARTYPE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageARType;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusResTypeInfo;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageARType
/////////////////////////////////////////////////////////////////////////////

class CWizPageARType : public CClusterAppStaticWizardPage< CWizPageARType >
{
	typedef CClusterAppStaticWizardPage< CWizPageARType > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageARType( void )
		: m_prti( NULL )
	{
	} //*** CWizPageARType()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_ART )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_ART )

	enum { IDD = IDD_APP_RESOURCE_TYPE };

public:
	//
	// CWizardPageWindow public methods.
	//

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

public:
	//
	// CWizardPageImpl required methods.
	//

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( BOOL bSaveAndValidate );

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CWizPageARType )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void );

	// Handler for PSN_WIZBACK
	int OnWizardBack( void );


// Implementation
protected:
	//
	// Controls.
	//
	CComboBox	m_cboxResTypes;

	//
	// Page state.
	//
	CString				m_strResType;
	CClusResTypeInfo *	m_prti;

	// Fill the combobox with a list of resource types
	void FillComboBox( void );

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_APP_RESOURCE_TYPE; }

}; //*** class CWizPageARType

/////////////////////////////////////////////////////////////////////////////

#endif // __ARTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\atlbasesheets.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlBaseSheetS.cpp
//
//	Abstract:
//		Stub for implementation of base property sheet classes.
//
//	Author:
//		David Potter (davidp)	April 20, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "AtlBaseSheet.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\atlbasewizs.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlBaseWizS.cpp
//
//	Abstract:
//		Stub for implementation of base wizard classes.
//
//	Author:
//		David Potter (davidp)	April 20, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "AtlBaseWiz.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\artype.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		ARType.cpp
//
//	Abstract:
//		Implementation of the CWizPageARType class.
//
//	Author:
//		David Potter (davidp)	December 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ARType.h"
#include "ClusAppWiz.h"
#include "WizThread.h"	// for CWizardThread

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageARType
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageARType )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ART_RESTYPES_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ART_RESTYPES )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARType::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARType::OnInitDialog( void )
{
	//
	// Attach the controls to control member variables.
	//
	AttachControl( m_cboxResTypes, IDC_ART_RESTYPES );

	return TRUE;

} //*** CWizPageARType::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARType::OnSetActive
//
//	Routine Description:
//		Handler for PSN_SETACTIVE.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Page activated successfully.
//		FALSE		Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARType::OnSetActive( void )
{
	//
	// Get info from the sheet.
	//
	m_prti = PwizThis()->RriApplication().Prti();

	//
	// Fill the list of resource types.
	//
	FillComboBox();

	//
	// Call the base class and return.
	//
	return baseClass::OnSetActive();

} //*** CWizPageARType::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARType::UpdateData
//
//	Routine Description:
//		Update data on or from the page.
//
//	Arguments:
//		bSaveAndValidate	[IN] TRUE if need to read data from the page.
//								FALSE if need to set data to the page.
//
//	Return Value:
//		TRUE		The data was updated successfully.
//		FALSE		An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARType::UpdateData( BOOL bSaveAndValidate )
{
	BOOL	bSuccess = TRUE;

	if ( bSaveAndValidate )
	{
		//
		// Save the combobox selection.
		//
		DDX_GetText( m_hWnd, IDC_ART_RESTYPES, m_strResType );

		if ( ! BBackPressed() )
		{
			if ( ! DDV_RequiredText( m_hWnd, IDC_ART_RESTYPES, IDC_ART_RESTYPES_LABEL, m_strResType ) )
			{
				return FALSE;
			} // if:  required text isn't present
		} // if:  Back button not presssed

		//
		// Get the pointer to the currently selected resource type.
		//
		int idx = m_cboxResTypes.GetCurSel();
		if ( idx != CB_ERR )
		{
			m_prti = reinterpret_cast< CClusResTypeInfo * >( m_cboxResTypes.GetItemDataPtr( idx ) );
		} // if:  item is selected
	} // if: saving data from the page
	else
	{
		//
		// Set the combobox selection.
		//
		ASSERT( m_prti != NULL );
		DDX_SetComboBoxText( m_hWnd, IDC_ART_RESTYPES, m_prti->RstrName() );

	} // else:  setting data to the page

	return bSuccess;

} //*** CWizPageARType::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARType::OnWizardBack
//
//	Routine Description:
//		Handler for PSN_WIZBACK.
//
//	Arguments:
//		None.
//
//	Return Value:
//		0				Move to previous page.
//		-1				Don't move to previous page.
//		anything else	Move to specified page.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CWizPageARType::OnWizardBack( void )
{
	int nResult;

	//
	// Call the base class.  This causes our UpdateData() method to get
	// called.  If it succeeds, save our values.
	//
	nResult = baseClass::OnWizardBack();
	if ( nResult != -1 )
	{
		if ( ! BApplyChanges() )
		{
			nResult = -1;
		} // if:  error applying changes
	} // if:  base class called successfully

	return nResult;

} //*** CWizPageARType::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARType::BApplyChanges
//
//	Routine Description:
//		Apply changes made on this page to the sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		The data was applied successfully.
//		FALSE		An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARType::BApplyChanges( void )
{
	BOOL	bSuccess = FALSE;

	// Loop to avoid goto's.
	do
	{
		if ( PwizThis()->RriApplication().BSetResourceType( m_prti ) )
		{
			//
			// If the resource has already been created, delete it.
			//
			if ( PwizThis()->BAppResourceCreated() )
			{
				if ( ! PwizThis()->BDeleteAppResource() )
				{
					break;
				} // if:  failed to delete the resource
			} // if:  resource previously created

			PwizThis()->SetAppDataChanged();
		} // if:  resource type changed

		bSuccess = TRUE;

	} while ( 0 );

	return bSuccess;

} //*** CWizPageARType::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARType::FillComboBox
//
//	Routine Description:
//		Fill the combobox with a list of resource types.
//		NOTE: THIS SHOULD ONLY BE CALLED FROM ONINITDIALOG!!!
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizPageARType::FillComboBox( void )
{
	int		idx;
	LPCWSTR	pszDefaultTypeName;
	LPCWSTR	pszDefaultTypeDisplayName = NULL;
	CString strGenAppString;

	//
	// Set the default resource type name.
	//
	if ( (PcawData() != NULL) && (PcawData()->pszAppResourceType != NULL) )
	{
		pszDefaultTypeName = PcawData()->pszAppResourceType;
	} // if:  default type name specified
	else
	{
		strGenAppString.LoadString(IDS_RESTYPE_GENERIC_APPLICATION);
		pszDefaultTypeName = strGenAppString;
	} // else:  no default type name specified

	// Loop to avoid goto's.
	do
	{
		HDC 			hCboxDC;
		HFONT			hfontOldFont;
		HFONT			hfontCBFont;
		int 			nCboxHorizExtent = 0;
		SIZE			cboxTextSize;
		TEXTMETRIC		tm;

		tm.tmAveCharWidth = 0;

		//
		// Refer to Knowledge base article Q66370 for details on how to
		// set the horizontal extent of a list box (or drop list).
		//
		hCboxDC = m_cboxResTypes.GetDC();					// Get the device context (DC) from the combo box.
		hfontCBFont = m_cboxResTypes.GetFont();				// Get the combo box font.
		hfontOldFont = (HFONT) SelectObject( hCboxDC, hfontCBFont);	// Select this font into the DC. Save the old font.
		GetTextMetrics(hCboxDC, &tm);						// Get the text metrics of this DC.

		//
		// Collect the list of resource types.
		//
		if ( ! PwizThis()->BCollectResourceTypes( GetParent() ) )
		{
			break;
		} // if:  error collecting resource types

		//
		// Clear the combobox first.
		//
		m_cboxResTypes.ResetContent();

		//
		// Add each resource type in the list to the combobox.
		//
		CClusResTypePtrList::iterator itrestype;
		for ( itrestype = PwizThis()->PlprtiResourceTypes()->begin()
			; itrestype != PwizThis()->PlprtiResourceTypes()->end()
			; itrestype++ )
		{
			//
			// Add the resource types to the combobox.
			//
			CClusResTypeInfo * prti = *itrestype;

			// Compute the horizontal extent of this string.
			::GetTextExtentPoint( 
					hCboxDC, 
					prti->RstrDisplayName(),
					prti->RstrDisplayName().GetLength(),
					&cboxTextSize);

			if (cboxTextSize.cx > nCboxHorizExtent)
			{
				nCboxHorizExtent = cboxTextSize.cx;
			}

			idx = m_cboxResTypes.AddString( prti->RstrDisplayName() );
			if ( prti->RstrName() == pszDefaultTypeName )
			{
				pszDefaultTypeDisplayName = prti->RstrDisplayName();
			} // if:  found the default resource type
			m_cboxResTypes.SetItemDataPtr( idx, prti );
		} // for:  each entry in the list

		SelectObject(hCboxDC, hfontOldFont);				// Reset the original font in the DC
		m_cboxResTypes.ReleaseDC(hCboxDC);					// Release the DC
		m_cboxResTypes.SetHorizontalExtent(nCboxHorizExtent + tm.tmAveCharWidth);

		//
		// Select the currently saved entry, or the one specified by
		// the caller of the wizard, or the first one if none are
		// currently saved or specified.
		//
		if ( m_strResType.GetLength() == 0 )
		{
			idx = m_cboxResTypes.FindString( -1, pszDefaultTypeDisplayName );
			if ( idx == CB_ERR )
			{
				idx = 0;
			} // if:  default value not found
			m_cboxResTypes.SetCurSel( idx );
			m_prti = reinterpret_cast< CClusResTypeInfo * >( m_cboxResTypes.GetItemDataPtr( idx ) );
		} // if:  nothing specified yet
		else
		{
			int idx = m_cboxResTypes.FindStringExact( -1, m_strResType );
			ASSERT( idx != CB_ERR );
			if ( idx != CB_ERR )
			{
				m_cboxResTypes.SetCurSel( idx );
			} // if:  string found in list
		} // else:  resource type saved
	} while ( 0 );

} //*** CWizPageARType::FillComboBox()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\atlextdlls.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlExtDllS.cpp
//
//	Abstract:
//		Stub for implementation of the Cluster Administrator extension classes.
//
//	Author:
//		David Potter (davidp)	May 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AtlExtDll.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\atlbasewizpages.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlBaseWizPageS.cpp
//
//	Abstract:
//		Stub for implementation of wizard page classes.
//
//	Author:
//		David Potter (davidp)	May 26, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AtlBaseWizPage.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\atldbgwins.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlDbgWinS.cpp
//
//	Abstract:
//		Stub for implementation of the ATL window debugging functions.
//
//	Author:
//		David Potter (davidp)	June 2, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AtlDbgWin.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\atlutils.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlUtilS.cpp
//
//	Abstract:
//		Stub for implementation of ATL utility functions.
//
//	Author:
//		David Potter (davidp)	December 11, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "AtlUtil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\barfclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BarfClus.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Implementation File:
//		BarfClus.cpp
//
//	Author:
//		David Potter (davidp)	May 30, 1997
//
//	Revision History:
//
//	Notes:
//		Dummy file for not implementing BARF.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __BARFCLUS_H_
#define __BARFCLUS_H_

/////////////////////////////////////////////////////////////////////////////

#endif // __BARFCLUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\clusappwiz.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ClusAppWiz.cpp
//
//  Abstract:
//      Implementation of the CClusterAppWizard class.
//
//  Author:
//      David Potter (davidp)   December 2, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClusAppWiz.h"

#include "ExcOper.h"    // for CNTException
#include "WizThread.h"  // for CWizardThread

#include "Welcome.h"    // for CWizPageWelcome
#include "VSCreate.h"   // for CWizPageVSCreate
#include "VSGroup.h"    // for CWizPageVSGroup
#include "VSGrpName.h"  // for CWizPageVSGroupName
#include "VSAccess.h"   // for CWizPageVSAccessInfo
#include "VSAdv.h"      // for CWizPageVSAdvanced
#include "ARCreate.h"   // for CWizPageARCreate
#include "ARType.h"     // for CWizPageARType
#include "ARName.h"     // for CWizPageARNameDesc
#include "Complete.h"   // for CWizPageCompletion

#include "App.h"
#include "App.inl"

#include "StlUtils.h"   // for STL utility functions

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CClusterAppWizard
/////////////////////////////////////////////////////////////////////////////

DEFINE_CLASS_NAME( CClusterAppWizard )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::CClusterAppWizard
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterAppWizard::CClusterAppWizard( void )
    : CWizardImpl< CClusterAppWizard >( IDS_CLASS_DISPLAY_NAME )
    , m_hwndParent( NULL )
    , m_hCluster( NULL )
    , m_pcawData( NULL )
    , m_pnte( NULL )
    , m_bCanceled( FALSE )
    , m_pThread( NULL )

    , m_bCollectedGroups( FALSE )
    , m_bCollectedResources( FALSE )
    , m_bCollectedResourceTypes( FALSE )
    , m_bCollectedNetworks( FALSE )
    , m_bCollectedNodes( FALSE )

    , m_bClusterUpdated( FALSE )
    , m_bVSDataChanged( FALSE )
    , m_bAppDataChanged( FALSE )
    , m_bNetNameChanged( FALSE )
    , m_bIPAddressChanged( FALSE )
    , m_bNetworkChanged( FALSE )
    , m_bCreatingNewVirtualServer( TRUE )
    , m_bCreatingNewGroup( TRUE )
    , m_bCreatingAppResource( TRUE )
    , m_bNewGroupCreated( FALSE )
    , m_bExistingGroupRenamed( FALSE )

    , m_pgiExistingVirtualServer( NULL )
    , m_pgiExistingGroup( NULL )
    , m_giCurrent( &m_ci )
    , m_riIPAddress( &m_ci )
    , m_riNetworkName( &m_ci )
    , m_riApplication( &m_ci )

    , m_bEnableNetBIOS( TRUE )

    , m_hiconRes( NULL )
{
    m_psh.dwFlags &= ~PSH_WIZARD;
    m_psh.dwFlags |= PSH_WIZARD97
        | PSH_WATERMARK
        | PSH_HEADER
        | PSH_WIZARDCONTEXTHELP
        ;
    m_psh.pszbmWatermark = MAKEINTRESOURCE( IDB_WELCOME );
    m_psh.pszbmHeader = MAKEINTRESOURCE( IDB_HEADER );

} //*** CClusterAppWizard::CClusterAppWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::~CClusterAppWizard
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterAppWizard::~CClusterAppWizard( void )
{
    ASSERT( ! BCanceled() ); // Cancel state should already have been handled by now

    //
    // Cleanup the worker thread.
    //
    if ( m_pThread != NULL )
    {
        //
        // Terminate the thread and then wait for it to exit.
        //
        PThread()->QuitThread( HwndParent() );
        PThread()->WaitForThreadToExit( HwndParent() );

        //
        // Cleanup the thread object.
        //
        delete m_pThread;
        m_pThread = NULL;
    } // if:  thread created

    //
    // Delete the lists.
    //
    DeleteListItems< CClusGroupPtrList,   CClusGroupInfo >( PlpgiGroups() );
    DeleteListItems< CClusResPtrList,     CClusResInfo >( PlpriResources() );
    DeleteListItems< CClusResTypePtrList, CClusResTypeInfo >( PlprtiResourceTypes() );
    DeleteListItems< CClusNetworkPtrList, CClusNetworkInfo >( PlpniNetworks() );
    DeleteListItems< CClusNodePtrList,    CClusNodeInfo >( PlpniNodes() );

} //*** CClusterAppWizard::~CClusterAppWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BInit
//
//  Routine Description:
//      Initialize the wizard.
//
//  Arguments:
//      hwndParent  [IN] Handle to parent window.
//      hCluster    [IN] Handle to cluster.
//      pcawData    [IN] Default data for the wizard.
//      pnte        [IN OUT] Exception object to fill if an error occurs.
//
//  Return Value:
//      TRUE        Wizard initialized successfully.
//      FALSE       Error initializing the wizard.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BInit(
    IN HWND                     hwndParent,
    IN HCLUSTER                 hCluster,
    IN CLUSAPPWIZDATA const *   pcawData,
    IN OUT CNTException *       pnte
    )
{
    ASSERT( hCluster != NULL );
    ASSERT( m_pnte == NULL );

    BOOL bSuccess = FALSE;

    m_hwndParent = hwndParent;
    m_hCluster = hCluster;
    m_pcawData = pcawData;
    m_pnte = pnte;
    m_ci.SetClusterHandle( hCluster );
    m_bCanceled = FALSE;

    m_strIPAddressResNameSuffix.LoadString( IDS_IP_ADDRESS_SUFFIX );
    m_strNetworkNameResNameSuffix.LoadString( IDS_NETWORK_NAME_SUFFIX );

    //
    // Set defaults from the data passed in.
    //
    if ( pcawData != NULL )
    {
        m_bCreatingNewVirtualServer = pcawData->bCreateNewVirtualServer;
        m_bCreatingNewGroup = pcawData->bCreateNewGroup;
        m_bCreatingAppResource = pcawData->bCreateAppResource;
        if ( pcawData->pszIPAddress != NULL )
        {
            m_strIPAddress = pcawData->pszIPAddress;
        } // if:  IP Address was specified
        if ( pcawData->pszNetwork != NULL )
        {
            m_strNetwork = pcawData->pszNetwork;
        } // if:  network was specified;
        if ( pcawData->pszAppResourceName != NULL )
        {
            m_riApplication.SetName( pcawData->pszAppResourceName );
        } // if:  application resource name specified
    } // if:  default data was passed in

    //
    // Add the standard resource types that we must have to operate.
    // We will be able to tell if they don't actually exist if they
    // continue to return FALSE from BQueried().
    //
    {
        CClusResTypeInfo * prti;

        //
        // Make sure these don't exist already.
        //
        ASSERT( PobjFromName( PlprtiResourceTypes(), CLUS_RESTYPE_NAME_IPADDR ) == NULL );
        ASSERT( PobjFromName( PlprtiResourceTypes(), CLUS_RESTYPE_NAME_NETNAME ) == NULL );
        ASSERT( PobjFromName( PlprtiResourceTypes(), CLUS_RESTYPE_NAME_GENAPP ) == NULL );

        //
        // Add the IP Address resource type.
        prti = new CClusResTypeInfo( Pci(), CLUS_RESTYPE_NAME_IPADDR );
        if ( prti == NULL )
        {
            goto MemoryError;
        } // if: error allocating memory
        PlprtiResourceTypes()->insert( PlprtiResourceTypes()->end(), prti );
        m_riIPAddress.BSetResourceType( prti );
        prti = NULL;

        //
        // Add the Network Name resource type.
        prti = new CClusResTypeInfo( Pci(), CLUS_RESTYPE_NAME_NETNAME );
        if ( prti == NULL )
        {
            goto MemoryError;
        } // if: error allocating memory
        PlprtiResourceTypes()->insert( PlprtiResourceTypes()->end(), prti );
        m_riNetworkName.BSetResourceType( prti );
        prti = NULL;

        //
        // Add the Generic Application resource type.
        prti = new CClusResTypeInfo( Pci(), CLUS_RESTYPE_NAME_GENAPP );
        if ( prti == NULL )
        {
            goto MemoryError;
        } // if: error allocating memory
        PlprtiResourceTypes()->insert( PlprtiResourceTypes()->end(), prti );
        m_riApplication.BSetResourceType( prti );
        prti = NULL;

    } // Add standard resource types to list

    //
    // Fill the page array.
    //
    if ( ! BAddAllPages() )
    {
        goto Cleanup;
    } // if: error adding all pages

    //
    // Call the base class.
    //
    if ( ! baseClass::BInit() )
    {
        goto Cleanup;
    } // if: error initializing the base class

    //
    // Create welcome and completion page title font.
    //
    if ( ! BCreateFont(
                m_fontExteriorTitle,
                IDS_EXTERIOR_TITLE_FONT_SIZE,
                IDS_EXTERIOR_TITLE_FONT_NAME,
                TRUE // bBold
                ) )
    {
        goto WinError;
    } // if: error creating the font

    //
    // Create bold font.
    //
    if ( ! BCreateFont(
                m_fontBoldText,
                8,
                _T("MS Shell Dlg"),
                TRUE // bBold
                ) )
    {
        goto WinError;
    } // if: error creating the font

    //
    // Load the resource icon.
    //
    m_hiconRes = LoadIcon( _Module.m_hInst, MAKEINTRESOURCE( IDB_RES_32 ) );
    if ( m_hiconRes == NULL )
    {
        goto WinError;
    } // if: error loading the font

    //
    // Initialize the worker thread.
    //
    if ( ! BInitWorkerThread() )
    {
        goto Cleanup;
    } // if:  error initializing the worker thread

    //
    // Read cluster information, such as the cluster name.
    //
    if ( ! BReadClusterInfo() )
    {
        goto Cleanup;
    } // if:  error reading cluster information

    //
    // Initialize group pointers, dependency lists, and resource lists.
    //
    RriNetworkName().PlpriDependencies()->insert( RriNetworkName().PlpriDependencies()->end(), PriIPAddress() );
    RriNetworkName().SetGroup( &RgiCurrent() );
    RriIPAddress().SetGroup( &RgiCurrent() );
    RriApplication().SetGroup( &RgiCurrent() );
    RgiCurrent().PlpriResources()->insert( RgiCurrent().PlpriResources()->end(), &RriIPAddress() );
    RgiCurrent().PlpriResources()->insert( RgiCurrent().PlpriResources()->end(), &RriNetworkName() );

    //
    // Specify the object to be extended.  The object to extend is the
    // application resource object for which pages will be added to the
    // wizard.
    //
    SetObjectToExtend( &RriApplication() );
    bSuccess = TRUE;

Cleanup:
    return bSuccess;

MemoryError:
    m_pnte->SetOperation( E_OUTOFMEMORY, (UINT) 0 );
    goto Cleanup;

WinError:
    {
        DWORD   sc = GetLastError();
        m_pnte->SetOperation( HRESULT_FROM_WIN32( sc ), (UINT) 0 );
    }
    goto Cleanup;

} //*** CClusterAppWizard::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BAddAllPages
//
//  Routine Description:
//      Initialize the wizard page array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Pages added successfully.
//      FALSE   Error adding pages.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BAddAllPages( void )
{
    ASSERT( m_pnte != NULL );

    BOOL                bSuccess    = FALSE;
    CWizardPageWindow * pwpw        = NULL;

    //
    // Add static pages.
    //

    pwpw = new CWizPageWelcome;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageVSCreate;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageVSGroup;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageVSGroupName;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageVSAccessInfo;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageVSAdvanced;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageARCreate;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageARType;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageARNameDesc;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = NULL;

    //
    // Add dynamic pages, which includes the Completion page.
    //
    if ( ! BAddDynamicPages() )
    {
        goto Cleanup;
    } // if:  error adding the completion page

    //
    // Enable the first page.
    //
    pwpw = *PlwpPages()->begin();
    ASSERT( pwpw != NULL );
    pwpw->EnablePage();

    bSuccess = TRUE;
    pwpw = NULL;

Cleanup:
    delete pwpw;
    return bSuccess;

MemoryError:
    m_pnte->SetOperation( E_OUTOFMEMORY, (UINT) 0 );
    goto Cleanup;

} //*** CClusterAppWizard::BAddAllPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BAddDynamicPages
//
//  Routine Description:
//      Add dynamic pages to the wizard, which includes the Completion page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Pages added successfully.
//      FALSE   Error adding pages.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BAddDynamicPages( void )
{
    ASSERT( m_pnte != NULL );

    DWORD                   sc;
    BOOL                    bSuccess    = FALSE;
    CWizPageCompletion *    pwp         = NULL;

    //
    // Allocate the Completion page.
    //
    pwp = new CWizPageCompletion;
    if ( pwp == NULL )
    {
        goto MemoryError;
    } // if:  error allocating the Completion page

    //
    // Initialize the page.
    //
    if ( ! pwp->BInit( this ) )
    {
        goto Cleanup;
    } // if:  error initializing the page

    //
    // Enable the page.  This is done because this page
    // will always reside after extension pages and must be
    // enabled or the user won't be able to finish.
    //
    pwp->EnablePage();

    //
    // Create the page.
    //
    sc = pwp->ScCreatePage();
    if ( sc != ERROR_SUCCESS )
    {
        m_pnte->SetOperation( HRESULT_FROM_WIN32( sc ), IDS_ERROR_CREATE_WIZ_PROPERTY_PAGE );
        goto Cleanup;
    } // if:  error creating the page

    //
    // Add the page.
    //
    if ( ! BAddPage( pwp ) )
    {
        goto Cleanup;
    } // if:  error adding the page

    pwp = NULL;
    bSuccess = TRUE;

Cleanup:
    delete pwp;
    return bSuccess;

MemoryError:
    m_pnte->SetOperation( E_OUTOFMEMORY, (UINT) 0 );
    goto Cleanup;

} //*** CClusterAppWizard::HrAddDynamicPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BInitWorkerThread
//
//  Routine Description:
//      Get a worker thread.  If one isn't available and we haven't reached
//      the maximum number of threads, create a new thread.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Thread initialized successfully.
//      FALSE       Error initializing the thread.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BInitWorkerThread( void )
{
    ASSERT( m_pThread == NULL );
    ASSERT( m_pnte != NULL );

    BOOL            bSuccess    = FALSE;
    DWORD           sc          = ERROR_SUCCESS;
    CWizardThread * pThread     = NULL;

    //
    // Take out the thread critical section so we can make changes to
    // the thread pool.
    //
    m_csThread.Lock();

    {
        CWaitCursor     wc;

        //
        // Allocate a new worker thread class instance.
        //
        pThread = new CWizardThread( this );
        if ( pThread == NULL )
        {
            m_pnte->SetOperation( E_OUTOFMEMORY, (ULONG) 0 );
            goto Cleanup;
        } // if:  error allocation the thread

        //
        // Create the worker thread.
        //
        sc = pThread->CreateThread();
        if ( sc != ERROR_SUCCESS )
        {
            m_pnte->SetOperation( HRESULT_FROM_WIN32( sc ), IDS_ERROR_CREATING_THREAD );
            goto Cleanup;
        } // if:  error creating the thread

        //
        // Save the pointer to the thread we just created.
        //
        m_pThread = pThread;
        pThread = NULL;
        bSuccess = TRUE;
    }

Cleanup:
    //
    // Release the thread critical section.
    //
    m_csThread.Unlock();

    return bSuccess;

} //*** CClusterAppWizard::BInitWorkerThread()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BReadClusterInfo
//
//  Routine Description:
//      Read cluster information, such as the cluster name.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BReadClusterInfo( void )
{
    BOOL    bSuccess;
    HWND    hWnd;

    hWnd = HwndOrParent( NULL );

    bSuccess = PThread()->BReadClusterInfo( hWnd );
    if ( ! bSuccess )
    {
        PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
    } // if:  error collecting groups

    return bSuccess;

} //*** CClusterAppWizard::BReadClusterInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCollectGroups
//
//  Routine Description:
//      Collect a list of groups from the cluster.
//
//  Arguments:
//      hWnd        [IN] Parent window.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCollectGroups( IN HWND hWnd /* = NULL */ )
{
    BOOL bSuccess;

    if ( ! BCollectedGroups() )
    {
        hWnd = HwndOrParent( hWnd );

        bSuccess = PThread()->BCollectGroups( hWnd );
        if ( ! bSuccess )
        {
            PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
        } // if:  error collecting groups
    } // if:  groups not collected yet
    else
    {
        bSuccess = TRUE;
    } // else:  groups already collected

    return bSuccess;

} //*** CClusterAppWizard::BCollectGroups()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCollectResources
//
//  Routine Description:
//      Collect a list of resources from the cluster.
//
//  Arguments:
//      hWnd        [IN] Parent window.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCollectResources( IN HWND hWnd /* = NULL */ )
{
    BOOL bSuccess;

    if ( ! BCollectedResources() )
    {
        hWnd = HwndOrParent( hWnd );

        bSuccess = PThread()->BCollectResources( hWnd );
        if ( ! bSuccess )
        {
            PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
        } // if:  error collecting resources
    } // if:  resources not collected yet
    else
    {
        bSuccess = TRUE;
    } // else:  resources already collected

    return bSuccess;

} //*** CClusterAppWizard::BCollectResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCollectResourceTypes
//
//  Routine Description:
//      Collect a list of resource types from the cluster.
//
//  Arguments:
//      hWnd        [IN] Parent window.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCollectResourceTypes( IN HWND hWnd /* = NULL */ )
{
    BOOL bSuccess;

    if ( ! BCollectedResourceTypes() )
    {
        hWnd = HwndOrParent( hWnd );

        bSuccess = PThread()->BCollectResourceTypes( hWnd );
        if ( ! bSuccess )
        {
            PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
        } // if:  error collecting resource types
    } // if:  resource types not collected yet
    else
    {
        bSuccess = TRUE;
    } // else:  resource types already collected

    return bSuccess;

} //*** CClusterAppWizard::BCollectResourceTypes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCollectNetworks
//
//  Routine Description:
//      Collect a list of networks from the cluster.
//
//  Arguments:
//      hWnd        [IN] Parent window.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCollectNetworks( IN HWND hWnd /* = NULL */ )
{
    BOOL bSuccess;

    if ( ! BCollectedNetworks() )
    {
        hWnd = HwndOrParent( hWnd );

        bSuccess = PThread()->BCollectNetworks( hWnd );
        if ( ! bSuccess )
        {
            PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
        } // if:  error collecting networks
    } // if:  networks not collected yet
    else
    {
        bSuccess = TRUE;
    } // else:  networks already collected

    return bSuccess;

} //*** CClusterAppWizard::BCollectNetworks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCollectNodes
//
//  Routine Description:
//      Collect a list of nodes from the cluster.
//
//  Arguments:
//      hWnd        [IN] Parent window.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCollectNodes( IN HWND hWnd /* = NULL */ )
{
    BOOL bSuccess;

    if ( ! BCollectedNodes() )
    {
        hWnd = HwndOrParent( hWnd );

        bSuccess = PThread()->BCollectNodes( hWnd );
        if ( ! bSuccess )
        {
            PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
        } // if:  error collecting nodes
    } // if:  nodes not collected yet
    else
    {
        bSuccess = TRUE;
    } // else:  nodes already collected

    return bSuccess;

} //*** CClusterAppWizard::BCollectNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCopyGroupInfo
//
//  Routine Description:
//      Copy one group info object to another.
//
//  Arguments:
//      rgiDst      [OUT] Destination group.
//      rgiSrc      [IN] Source group.
//      hWnd        [IN] Parent window.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCopyGroupInfo(
    OUT CClusGroupInfo &    rgiDst,
    IN CClusGroupInfo &     rgiSrc,
    IN HWND                 hWnd // = NULL
    )
{
    BOOL                bSuccess;
    CClusGroupInfo *    rgGroups[ 2 ] = { &rgiDst, &rgiSrc };

    hWnd = HwndOrParent( hWnd );

    bSuccess = PThread()->BCopyGroupInfo( hWnd, rgGroups );
    if ( ! bSuccess )
    {
        PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
    } // if:  error copying the group

    return bSuccess;

} //*** CClusterAppWizard::BCopyGroupInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCollectDependencies
//
//  Routine Description:
//      Collect dependencies for a resource.
//
//  Arguments:
//      pri         [IN OUT] Resource to collect dependencies for.
//      hWnd        [IN] Parent window.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCollectDependencies(
    IN OUT CClusResInfo *   pri,
    IN HWND                 hWnd /* = NULL */
    )
{
    ASSERT( pri != NULL );

    BOOL bSuccess;

    if ( ! pri->BCollectedDependencies() )
    {
        hWnd = HwndOrParent( hWnd );

        bSuccess = PThread()->BCollectDependencies( hWnd, pri );
        if ( ! bSuccess )
        {
            PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
        } // if:  error collecting groups
    } // if:  dependencies not collected yet
    else
    {
        bSuccess = TRUE;
    } // else:  dependencies already collected

    return bSuccess;

} //*** CClusterAppWizard::BCollectDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BIsVirtualServer
//
//  Routine Description:
//      Determine if the group is a virtual server or not.
//
//  Arguments:
//      pwszName    Name of the group.
//
//  Return Value:
//      TRUE        Group is a virtual server.
//      FALSE       Group is not a virtual server, or an error occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BIsVirtualServer( IN LPCWSTR pwszName )
{
    ASSERT( pwszName != NULL );
    ASSERT( BCollectedGroups() );

    //
    // Find the group name in the map.  If found and the group has been
    // queried already, just return the result of the previous query.
    //
    CClusGroupPtrList::iterator itgrp;
    for ( itgrp = PlpgiGroups()->begin() ; itgrp != PlpgiGroups()->end() ; itgrp++ )
    {
        if ( (*itgrp)->RstrName() == pwszName )
        {
            break;
        } // if:  match found
    } // for:  each item in the list
    if ( itgrp == PlpgiGroups()->end() )
    {
        return FALSE;
    } // if:  no match found
    ASSERT( (*itgrp)->BQueried() );
    return (*itgrp)->BIsVirtualServer();

} //*** CClusterAppWizard::BIsVirtualServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCreateVirtualServer
//
//  Routine Description:
//      Create the virtual server.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Virtual server created successfully.
//      FALSE       Error creating the virtual server.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCreateVirtualServer( void )
{
    ASSERT( BCreatingNewVirtualServer() );
    ASSERT( Hcluster() != NULL );

    BOOL    bSuccess;
    HWND    hWnd;

    hWnd = HwndOrParent( NULL );

    bSuccess = PThread()->BCreateVirtualServer( hWnd );
    if ( ! bSuccess )
    {
        PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
    } // if:  error creating the virtual server

    return bSuccess;

} //*** CClusterAppWizard::BCreateVirtualServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCreateAppResource
//
//  Routine Description:
//      Create the application resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Resource created successfully.
//      FALSE       Error creating the resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCreateAppResource( void )
{
    ASSERT( BCreatingAppResource() );
    ASSERT( Hcluster() != NULL );

    BOOL    bSuccess;
    HWND    hWnd;

    hWnd = HwndOrParent( NULL );

    bSuccess = PThread()->BCreateAppResource( hWnd );
    if ( ! bSuccess )
    {
        PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
    } // if:  error creating the resource

    return bSuccess;

} //*** CClusterAppWizard::BCreateAppResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BDeleteAppResource
//
//  Routine Description:
//      Delete the application resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Resource deleted successfully.
//      FALSE       Error deleted the resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BDeleteAppResource( void )
{
    ASSERT( Hcluster() != NULL );

    BOOL    bSuccess;
    HWND    hWnd;

    hWnd = HwndOrParent( NULL );

    bSuccess = PThread()->BDeleteAppResource( hWnd );
    if ( ! bSuccess )
    {
        PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
    } // if:  error deleting the resource

    return bSuccess;

} //*** CClusterAppWizard::BDeleteAppResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BResetCluster
//
//  Routine Description:
//      Reset the cluster back to the state it was in before we started.
//
//  Arguments:
//      pwszName    Name of the group.
//
//  Return Value:
//      TRUE        Cluster reset successfully.
//      FALSE       Error resetting the cluster.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BResetCluster( void )
{
    ASSERT( Hcluster() != NULL );

    BOOL    bSuccess;
    HWND    hWnd;

    hWnd = HwndOrParent( NULL );

    bSuccess = PThread()->BResetCluster( hWnd );
    if ( ! bSuccess )
    {
        PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
    } // if:  error resetting the cluster

    return bSuccess;

} //*** CClusterAppWizard::BResetCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BSetAppResAttributes
//
//  Routine Description:
//      Set the properties, dependency list and preferred owner list of the
//      application resource. Assumes that the application resource has 
//      already been created.
//
//  Arguments:
//      plpriOldDependencies    [IN] Pointer to the old resource dependency list
//      plpniOldPossibleOwners  [IN] Pointer to the old list of possible owner nodes
//
//  Return Value:
//      TRUE        Successfully set the attributes.
//      FALSE       Error setting the attributes.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BSetAppResAttributes( 
    IN CClusResPtrList *    plpriOldDependencies,   // = NULL
    IN CClusNodePtrList *   plpniOldPossibleOwners  // = NULL
    )
{
    ASSERT( Hcluster() != NULL );

    BOOL    bSuccess;
    HWND    hWnd;

    hWnd = HwndOrParent( NULL );

    bSuccess = PThread()->BSetAppResAttributes( hWnd, plpriOldDependencies, plpniOldPossibleOwners );
    if ( ! bSuccess )
    {
        PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
    } // if:  error resetting the cluster

    return bSuccess;

} //*** CClusterAppWizard::BResetCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::ConstructNetworkName
//
//  Routine Description:
//      Construct the network name from a string by converting to all
//      uppercase and removing invalid characters.  For now that means
//      removing spaces, although there are probably other characters we
//      should look at as well.
//
//  Arguments:
//      pszName     String to construct the network name from.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAppWizard::ConstructNetworkName( IN LPCTSTR pszName )
{
    CString str;
    LPTSTR  pszSrcStart;
    LPTSTR  pszSrcBegin;
    LPTSTR  pszSrcEnd;
    LPTSTR  pszDst;
    int     cchCopy;

#define INVALID_CHARS _T(" ")

    //
    // Convert the string to all uppercase characters.well.
    //
    m_strNetName = pszName;
    m_strNetName.MakeUpper();

    //
    // Prepare the buffer for parsing.
    //
    pszSrcStart = pszSrcEnd = m_strNetName.GetBuffer( 0 );

    //
    // Skip to the first invalid character.
    //
    cchCopy = _tcscspn( pszSrcEnd, INVALID_CHARS );
    pszSrcEnd += cchCopy;
    pszDst = pszSrcEnd;

    //
    // Loop through the buffer moving valid characters up in the buffer
    // over invalid characters.
    //
    while ( *pszSrcEnd != _T('\0') )
    {
        ASSERT( _tcsspn( pszSrcEnd, INVALID_CHARS ) != 0 );

        //
        // Find the first valid character.
        //
        pszSrcBegin = pszSrcEnd + _tcsspn( pszSrcEnd, INVALID_CHARS );
        if ( *pszSrcBegin == _T('\0') )
        {
            break;
        } // if:  no vald characters found

        //
        // Find the next invalid character.
        //
        cchCopy = _tcscspn( pszSrcBegin, INVALID_CHARS );
        pszSrcEnd = pszSrcBegin + cchCopy;

        //
        // Copy the string to the destination.
        //
        _tcsncpy(pszDst, pszSrcBegin, cchCopy);
        pszDst += cchCopy;
    } // while:  more characters in the string

    //
    // Make sure the buffer isn't too long.
    //
    if ( lstrlen( pszSrcStart ) > MAX_COMPUTERNAME_LENGTH )
    {
        pszSrcStart[ MAX_COMPUTERNAME_LENGTH ] = _T('\0');
    } // if:  string is too long

    //
    // Release the buffer back to the CString class.
    //
    *pszDst = _T('\0');
    m_strNetName.ReleaseBuffer();

    SetVSDataChanged();
    SetNetNameChanged();

} //*** CClusterAppWizard::ConstructNetworkName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BRequiredDependenciesPresent
//
//  Routine Description:
//      Determine if all required dependencies are present on a resource
//
//  Arguments:
//      pri         [IN] Resource to check against.
//      plpri       [IN] List of resources considered dependencies.
//                      Defaults to specified resource's dependencies.
//
//  Return Value:
//      TRUE        All required dependencies are present.
//      FALSE       At least one required dependency is not present.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BRequiredDependenciesPresent(
    IN CClusResInfo *           pri,
    IN CClusResPtrList const *  plpri   // = NULL
    )
{
    ASSERT( pri != NULL );

    BOOL    bFound;
    CString strMissing;
    CString strMsg;
    BOOL    bMissingTypeName;

    bFound = pri->BRequiredDependenciesPresent(
                    plpri,
                    strMissing,
                    bMissingTypeName
                    );
    if ( ! bFound )
    {
        //
        // If missing a resource type name, translate it to
        // the resource type display name, if possible.
        //
        if ( bMissingTypeName )
        {
            CClusResTypeInfo * prti = PrtiFindResourceTypeNoCase( strMissing );
            if ( prti != NULL )
            {
                strMissing = prti->RstrDisplayName();
            } // if:  found resource type in our list
        } // if:  missing a type name

        //
        // Display an error message.
        //
        strMsg.FormatMessage( IDS_ERROR_REQUIRED_DEPENDENCY_NOT_FOUND, strMissing );
        AppMessageBox( GetActiveWindow(), strMsg, MB_OK | MB_ICONSTOP );
    } // if:  all required dependencies not present

    return bFound;

} //*** CClusterAppWizard::BRequiredDependenciesPresent()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BSetCreatingNewVirtualServer
//
//  Routine Description:
//      Indicate whether a new virtual server should be created or if an
//      existing group should be used.  If this state changes and changes
//      have already been made to the cluster (such as if the user backed
//      up in the wizard), undo those changes first.
//
//  Arguments:
//      bCreate     [IN] New value of this state.
//      pgi         [IN] Group info if using existing virtual server.
//
//  Return Value:
//      TRUE        State changed successfully.
//      FALSE       Error occurred changing state.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BSetCreatingNewVirtualServer(
    IN BOOL             bCreate,    // = TRUE
    IN CClusGroupInfo * pgi         // = NULL
    )
{
    BOOL bSuccess = TRUE;

    // Loop to avoid goto's.
    do
    {
        //
        // If the state changed or the group changed, save the new state.
        //
        if (   bCreate != BCreatingNewVirtualServer()
            || (! bCreate && (pgi != PgiExistingVirtualServer())) )
        {
            //
            // If the cluster has been updated, reset it back to its original state.
            //
            if ( BClusterUpdated() )
            {
                if ( ! BResetCluster() )
                {
                    bSuccess = FALSE;
                    break;
                } // if:  error resetting the cluster
            } // if:  cluster was updated

            //
            // Save the new state.
            //
            m_bCreatingNewVirtualServer = bCreate;
            if ( bCreate )
            {
                RgiCurrent().Reset( Pci() );
                ClearExistingVirtualServer();
            } // if:  creating new virtual server
            else
            {
                ASSERT( pgi != NULL );
                bSuccess = BCopyGroupInfo( RgiCurrent(), *pgi );
                if ( bSuccess )
                {
                    SetExistingVirtualServer( pgi );
                } // if:  group copied successfully
            } // else:  using existing virtual server
            SetVSDataChanged();
        } // if:  state changed
    } while ( 0 );

    return bSuccess;

} //*** CClusterAppWizard::BSetCreatingNewVirtualServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BSetCreatingNewGroup
//
//  Routine Description:
//      Indicate whether a new group should be created or if an existing group
//      should be used.  If this state changes and changes have already been
//      made to the cluster (such as if the user backed up in the wizard),
//      undo those changes first.
//
//  Arguments:
//      bCreate     [IN] New value of this state.
//      pgi         [IN] Group info if using existing group.
//
//  Return Value:
//      TRUE        State changed successfully.
//      FALSE       Error occurred changing state.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BSetCreatingNewGroup(
    IN BOOL             bCreate,    // = TRUE
    IN CClusGroupInfo * pgi         // = NULL
    )
{
    BOOL    bSuccess = TRUE;
    DWORD   sc;

    // Loop to avoid goto's.
    do
    {
        //
        // If the state changed or the group changed, save the new state.
        //
        if (   bCreate != BCreatingNewGroup()
            || (! bCreate && (pgi != PgiExistingGroup())) )
        {
            //
            // If the cluster has been updated, reset it back to its original state.
            //
            if ( BClusterUpdated() && ! BResetCluster() )
            {
                bSuccess = FALSE;
                break;
            } // if:  error resetting the cluster

            //
            // Save the new state.
            //
            if ( bCreate )
            {
                RgiCurrent().Reset( Pci() );
                ClearExistingGroup();
            } // if:  creating new group
            else
            {
                ASSERT( pgi != NULL );

                if ( ! BSetGroupName( pgi->RstrName() ) )
                {
                    bSuccess = FALSE;
                    break;
                } // if:  error setting the group name

                sc = RgiCurrent().ScCopy( *pgi );

                //
                // Copy destroys original list of resources in the group.
                // Re-add the IP address and NetName resources to the list
                // of resources in this group.
                //
                RgiCurrent().PlpriResources()->insert( RgiCurrent().PlpriResources()->end(), &RriIPAddress() );
                RgiCurrent().PlpriResources()->insert( RgiCurrent().PlpriResources()->end(), &RriNetworkName() );

                if ( sc != ERROR_SUCCESS )
                {
                    m_pnte->SetOperation( HRESULT_FROM_WIN32( sc ), IDS_ERROR_OPEN_GROUP );
                    bSuccess = FALSE;
                } // if: error copying the group
                SetExistingGroup( pgi );
            } // else:  using existing group
            m_bCreatingNewGroup = bCreate;
            SetVSDataChanged();
        } // if:  state changed
    } while ( 0 );

    return bSuccess;

} //*** CClusterAppWizard::BSetCreatingNewGroup()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\cladmwiz.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-2001 Microsoft Corporation
//
//	Module Name:
//		ClApdmWiz.cpp
//
//	Description:
//		Implementation of the DLL exports
//
//	Maintained By:
//		David Potter (davidp)	November 24, 1997
//
//	Notes:
//
//		Proxy/Stub Information
//
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also 
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for ClAdmWiz.idl by adding the following 
//		files to the Outputs.
//			ClAdmWiz_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL, 
//		run nmake -f ClAdmWizps.mk in the project directory.
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#define __RESOURCE_H_
#include "initguid.h"
#include "dlldatax.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "WizObject.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CApp _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_ClusAppWiz, CClusAppWizardObject)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllMain
//
//	Routine Description:
//		DLL Entry Point.
//
//	Arguments:
//		hInstance		Handle to this DLL.
//		dwReason		Reason this function was called.
//							Can be Process/Thread Attach/Detach.
//		lpReserved		Reserved.
//
//	Return Value:
//		TRUE			No error.
//		FALSE			Error occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
extern "C"
BOOL WINAPI DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved )
{
	lpReserved;
#ifdef _MERGE_PROXYSTUB
	if ( ! PrxDllMain( hInstance, dwReason, lpReserved ) )
		return FALSE;
#endif
	if ( dwReason == DLL_PROCESS_ATTACH )
	{
#ifdef _DEBUG
		_CrtSetDbgFlag( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
		_CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_DEBUG );
#endif
		_Module.Init( ObjectMap, hInstance, IDS_CLASS_DISPLAY_NAME );
		DisableThreadLibraryCalls( hInstance );

        //
        // Initialize Fusion.
        //
        // The value of IDR_MANIFEST in the call to
        // SHFusionInitializeFromModuleID() must match the value specified in the
        // sources file for SXS_MANIFEST_RESOURCE_ID.
        //
        if ( ! SHFusionInitializeFromModuleID( hInstance, IDR_MANIFEST ) )
        {
            DWORD   sc = GetLastError();
        }

    } // if: DLL_PROCESS_ATTACH
	else if ( dwReason == DLL_PROCESS_DETACH )
    {
        SHFusionUninitialize();
		_Module.Term();
    } // else if: DLL_PROCESS_DETACH
	return TRUE;    // ok

} //*** DllMain()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllCanUnloadNow
//
//	Routine Description:
//		Used to determine whether the DLL can be unloaded by OLE.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK		DLL can be unloaded.
//		S_FALSE		DLL can not be unloaded.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

} //*** DllCanUnloadNow()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllGetClassObject
//
//	Routine Description:
//		Returns a class factory to create an object of the requested type.
//
//	Arguments:
//		rclsid		CLSID of class desired.
//		riid		IID of interface on class factory desired.
//		ppv			Filled with interface pointer to class factory.
//
//	Return Value:
//		S_OK		Class object returned successfully.
//		Any status codes returned from _Module.GetClassObject().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif
	return _Module.GetClassObject(rclsid, riid, ppv);

} //*** DllGetClassObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllRegisterServer
//
//	Routine Description:
//		Registers the interfaces and objects that this DLL supports in the
//		system registry.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK		DLL registered successfully.
//		Any status codes returned from _Module.RegisterServer().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer( FALSE /*bRegTypeLib*/ );

} //*** DllRegisterServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllRegisterServer
//
//	Routine Description:
//		Unregisters the interfaces and objects that this DLL supports in the
//		system registry.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK		DLL unregistered successfully.
//		Any status codes returned from _Module.UnregisterServer().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif
	_Module.UnregisterServer();
	return S_OK;

} //*** DllUnregisterServer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\clusappwiz.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ClusAppWiz.h
//
//  Abstract:
//      Definition of the CClusterAppWizard class.
//
//  Implementation File:
//      ClusAppWiz.cpp
//
//  Author:
//      David Potter (davidp)   December 2, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLUSAPPWIZ_H_
#define __CLUSAPPWIZ_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterAppWizard;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizardThread;
class CWizPageCompletion;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLDBGWIN_H_
#include "AtlDbgWin.h"  // for DECLARE_CLASS_NAME
#endif

#ifndef __ATLBASEWIZ_H_
#include "AtlBaseWiz.h" // for CWizardImpl
#endif

#ifndef __CRITSEC_H_
#include "CritSec.h"    // for CCritSec
#endif

#ifndef __CLUSOBJ_H_
#include "ClusObj.h"    // for CClusterObject, etc.
#endif

#ifndef __EXCOPER_H_
#include "ExcOper.h"    // for CNTException
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CClusterAppWizard
/////////////////////////////////////////////////////////////////////////////

class CClusterAppWizard : public CWizardImpl< CClusterAppWizard >
{
    typedef CWizardImpl< CClusterAppWizard > baseClass;

public:
    //
    // Construction
    //

    // Default constructor
    CClusterAppWizard( void );

    // Destructor
    ~CClusterAppWizard( void );

    // Initialize the sheet
    BOOL BInit(
        IN HWND                     hwndParent,
        IN HCLUSTER                 hCluster,
        IN CLUSAPPWIZDATA const *   pcawData,
        IN OUT CNTException *       pnte
        );

    // Add all pages to the page array
    BOOL BAddAllPages( void );

    // Handle a reset from one of the pages
    void OnReset( void )
    {
        m_bCanceled = TRUE;

    } //*** OnReset()

public:
    //
    // CClusterAppWizard public methods.
    //

    // Wait for group data collection to be completed
    void WaitForGroupsToBeCollected( void )
    {
    } //*** WaitForGroupsToBeCollected()

    // Determine if the group is a virtual server or not
    BOOL BIsVirtualServer( IN LPCWSTR pwszName );

    // Create a virtual server
    BOOL BCreateVirtualServer( void );

    // Create an application resource
    BOOL BCreateAppResource( void );

    // Delete the application resource
    BOOL BDeleteAppResource( void );

    // Reset the cluster
    BOOL BResetCluster( void );

    // Set the properties, dependency list and preferred owner list of the
    // application resource
    BOOL CClusterAppWizard::BSetAppResAttributes(
        IN CClusResPtrList *    plpriOldDependencies    = NULL,
        IN CClusNodePtrList *   plpniOldPossibleOwners  = NULL
        );

    // Set the group name and update any other names that are calculated from it
    BOOL BSetGroupName( IN LPCTSTR pszGroupName )
    {
        if ( RgiCurrent().RstrName() != pszGroupName )
        {
            if ( BClusterUpdated() && ! BResetCluster() )
            {
                return FALSE;
            } // if:  error resetting the cluster

            RriNetworkName().SetName( pszGroupName + m_strNetworkNameResNameSuffix );
            RriIPAddress().SetName( pszGroupName + m_strIPAddressResNameSuffix );
            RgiCurrent().SetName( pszGroupName );
            ConstructNetworkName( pszGroupName );
            SetVSDataChanged();
        } // if:  group name changed

        return TRUE;

    } //*** BSetGroupName()

    // Find an object in a list
    template < class ObjT >
    ObjT PobjFind( IN std::list< ObjT > * pList, IN LPCTSTR pszName )
    {
        ASSERT( pszName != NULL );

        ObjT pobj = NULL;

        //
        // Find the name in the list.
        //
        std::list< ObjT >::iterator itpobj;
        for ( itpobj = pList->begin()
            ; itpobj != pList->end()
            ; itpobj++ )
        {
            if ( (*itpobj)->RstrName() == pszName )
            {
                pobj = *itpobj;
                break;
            } // if:  match found
        } // for:  each item in the list

        return pobj;

    } //*** PobjFind()

    // Find an object in a list, ignoring case
    template < class ObjT >
    ObjT PobjFindNoCase( IN std::list< ObjT > * pList, IN LPCTSTR pszName )
    {
        ASSERT( pszName != NULL );

        ObjT pobj = NULL;

        //
        // Find the name in the list.
        //
        std::list< ObjT >::iterator itpobj;
        for ( itpobj = pList->begin()
            ; itpobj != pList->end()
            ; itpobj++ )
        {
            if ( (*itpobj)->RstrName().CompareNoCase( pszName ) == 0 )
            {
                pobj = *itpobj;
                break;
            } // if:  match found
        } // for:  each item in the list

        return pobj;

    } //*** PobjFindNoCase()

    // Find a node in our list
    CClusNodeInfo * PniFindNode( IN LPCTSTR pszName )
    {
        return PobjFind( PlpniNodes(), pszName );

    } //*** PniFindNode()

    // Find a node in our list, ignoring case
    CClusNodeInfo * PniFindNodeNoCase( IN LPCTSTR pszName )
    {
        return PobjFindNoCase( PlpniNodes(), pszName );

    } //*** PniFindNodeNoCase()

    // Find a group in our list
    CClusGroupInfo * PgiFindGroup( IN LPCTSTR pszName )
    {
        return PobjFind( PlpgiGroups(), pszName );

    } //*** PgiFindGroups()

    // Find a group in our list, ignoring case
    CClusGroupInfo * PgiFindGroupNoCase( IN LPCTSTR pszName )
    {
        return PobjFindNoCase( PlpgiGroups(), pszName );

    } //*** PgiFindGroupsNoCase()

    // Find a resource in our list
    CClusResInfo * PriFindResource( IN LPCTSTR pszName )
    {
        return PobjFind( PlpriResources(), pszName );

    } //*** PriFindResource()

    // Find a resource in our list, ignoring case
    CClusResInfo * PriFindResourceNoCase( IN LPCTSTR pszName )
    {
        return PobjFindNoCase( PlpriResources(), pszName );

    } //*** PriFindResourceNoCase()

    // Find a resource type in our list
    CClusResTypeInfo * PrtiFindResourceType( IN LPCTSTR pszName )
    {
        return PobjFind( PlprtiResourceTypes(), pszName );

    } //*** PrtiFindResourceType()

    // Find a resource type in our list, ignoring case
    CClusResTypeInfo * PrtiFindResourceTypeNoCase( IN LPCTSTR pszName )
    {
        return PobjFindNoCase( PlprtiResourceTypes(), pszName );

    } //*** PrtiFindResourceTypeNoCase()

    // Find a network in our list
    CClusNetworkInfo * PniFindNetwork( IN LPCTSTR pszName )
    {
        return PobjFind( PlpniNetworks(), pszName );

    } //*** PniFindNetwork()

    // Find a network in our list, ignoring case
    CClusNetworkInfo * PniFindNetworkNoCase( IN LPCTSTR pszName )
    {
        return PobjFindNoCase( PlpniNetworks(), pszName );

    } //*** PniFindNetworkNoCase()

    // Determine if all required dependencies are present on a resource
    BOOL BRequiredDependenciesPresent(
        IN CClusResInfo *           pri,
        IN CClusResPtrList const *  plpri = NULL
        );

public:
    //
    // Multithreading support.
    //

    // Initialize the worker thread
    BOOL BInitWorkerThread( void );

    // Return the thread.
    CWizardThread * PThread( void )
    {
        ASSERT( m_pThread != NULL );
        return m_pThread;

    } //*** PThread( void )

protected:
    CCritSec        m_csThread; // Critical section for initializing thread.
    CWizardThread * m_pThread;  // Worker thread pointer.

public:
    //
    // Message map.
    //
//  BEGIN_MSG_MAP( CClusterAppWizard )
//      CHAIN_MSG_MAP( baseClass )
//  END_MSG_MAP()

    DECLARE_CLASS_NAME()

    //
    // Message override functions.
    //

    // Handler for the final message after WM_DESTROY
    void OnFinalMessage( HWND hWnd )
    {
        //
        // If the user canceled the wizard, reset the cluster back to
        // the state it was in before we ran.
        //
        if ( BCanceled() )
        {
            BResetCluster();
            m_bCanceled = FALSE;
        } // if:  wizard was canceled

    } //*** OnFinalMessage()

// Implementation
protected:
    HWND                    m_hwndParent;
    HCLUSTER                m_hCluster;
    CLUSAPPWIZDATA const *  m_pcawData;
    CNTException *          m_pnte;
    CClusterInfo            m_ci;
    BOOL                    m_bCanceled;

    // Construct a network name
    void ConstructNetworkName( IN LPCTSTR psz );

    //
    // Fonts
    //
    CFont           m_fontExteriorTitle;
    CFont           m_fontBoldText;

    //
    // Icons
    //
    HICON           m_hiconRes;

    //
    // Object lists.
    //
    CClusNodePtrList    m_lpniNodes;
    CClusGroupPtrList   m_lpgiGroups;
    CClusResPtrList     m_lpriResources;
    CClusResTypePtrList m_lprtiResourceTypes;
    CClusNetworkPtrList m_lpniNetworks;

    BOOL    m_bCollectedGroups;
    BOOL    m_bCollectedResources;
    BOOL    m_bCollectedResourceTypes;
    BOOL    m_bCollectedNetworks;
    BOOL    m_bCollectedNodes;

    //
    // Helper Methods
    //
protected:
    HWND HwndOrParent( IN HWND hWnd )
    {
        if ( hWnd == NULL )
        {
            hWnd = m_hWnd;
            if ( hWnd == NULL )
            {
                hWnd = HwndParent();
            } // if:  no wizard window yet
        } // if:  no window specified

        return hWnd;

    } //*** HwndOrParent()

public:
    // Remove the Completion page so extension pages can be added
    void RemoveCompletionPage( void );

    // Add dynamic pages to the end of the wizard, including the Completion page
    BOOL BAddDynamicPages( void );

    // Remove all extension pages.
    void RemoveExtensionPages( void )   { baseClass::RemoveAllExtensionPages(); }

    CFont & RfontExteriorTitle( void )  { return m_fontExteriorTitle; }
    CFont & RfontBoldText( void )       { return m_fontBoldText; }

    HWND                    HwndParent( void ) const    { return m_hwndParent; }
    HCLUSTER                Hcluster( void ) const      { return m_hCluster; }
    CLUSAPPWIZDATA const *  PcawData( void ) const      { return m_pcawData; }
    CClusterInfo *          Pci( void )                 { return &m_ci; }
    BOOL                    BCanceled( void ) const     { return m_bCanceled; }
    HICON                   HiconRes( void ) const      { return m_hiconRes; }

    CClusNodePtrList *      PlpniNodes( void )          { return &m_lpniNodes; }
    CClusGroupPtrList *     PlpgiGroups( void )         { return &m_lpgiGroups; }
    CClusResPtrList *       PlpriResources( void )      { return &m_lpriResources; }
    CClusResTypePtrList *   PlprtiResourceTypes( void ) { return &m_lprtiResourceTypes; }
    CClusNetworkPtrList *   PlpniNetworks( void )       { return &m_lpniNetworks; }

    // Read cluster information, such as the cluster name
    BOOL BReadClusterInfo( void );

    // Collect a list of groups from the cluster
    BOOL BCollectGroups( IN HWND hWnd = NULL );

    // Collect a list of resources from the cluster
    BOOL BCollectResources( IN HWND hWnd = NULL );

    // Collect a list of resource types from the cluster
    BOOL BCollectResourceTypes( IN HWND hWnd = NULL );

    // Collect a list of networks from the cluster
    BOOL BCollectNetworks( IN HWND hWnd = NULL );

    // Collect a list of nodes from the cluster
    BOOL BCollectNodes( IN HWND hWnd = NULL );

    // Copy one group info object to another
    BOOL BCopyGroupInfo(
        OUT CClusGroupInfo &    rgiDst,
        IN CClusGroupInfo &     rgiSrc,
        IN HWND                 hWnd = NULL
        );

    // Collect dependencies for a resource
    BOOL BCollectDependencies( IN OUT CClusResInfo * pri, IN HWND hWnd = NULL );

    BOOL BCollectedGroups( void ) const         { return m_bCollectedGroups; }
    BOOL BCollectedResources( void ) const      { return m_bCollectedResources; }
    BOOL BCollectedResourceTypes( void ) const  { return m_bCollectedResourceTypes; }
    BOOL BCollectedNetworks( void ) const       { return m_bCollectedNetworks; }
    BOOL BCollectedNodes( void ) const          { return m_bCollectedNodes; }

    void SetCollectedGroups( void )             { ASSERT( ! m_bCollectedGroups ); m_bCollectedGroups = TRUE; }
    void SetCollectedResources( void )          { ASSERT( ! m_bCollectedResources ); m_bCollectedResources = TRUE; }
    void SetCollectedResourceTypes( void )      { ASSERT( ! m_bCollectedResourceTypes ); m_bCollectedResourceTypes = TRUE; }
    void SetCollectedNetworks( void )           { ASSERT( ! m_bCollectedNetworks ); m_bCollectedNetworks = TRUE; }
    void SetCollectedNodes( void )              { ASSERT( ! m_bCollectedNodes ); m_bCollectedNodes = TRUE; }

protected:
    //
    // Page data.
    //

    // State information.
    BOOL m_bClusterUpdated;
    BOOL m_bVSDataChanged;
    BOOL m_bAppDataChanged;
    BOOL m_bNetNameChanged;
    BOOL m_bIPAddressChanged;
    BOOL m_bSubnetMaskChanged;
    BOOL m_bNetworkChanged;
    BOOL m_bCreatingNewVirtualServer;
    BOOL m_bCreatingNewGroup;
    BOOL m_bCreatingAppResource;
    BOOL m_bNewGroupCreated;
    BOOL m_bExistingGroupRenamed;

    // Common properties.
    CClusGroupInfo *    m_pgiExistingVirtualServer;
    CClusGroupInfo *    m_pgiExistingGroup;
    CClusGroupInfo      m_giCurrent;
    CClusResInfo        m_riIPAddress;
    CClusResInfo        m_riNetworkName;
    CClusResInfo        m_riApplication;

    // Private properties.
    CString         m_strIPAddress;
    CString         m_strSubnetMask;
    CString         m_strNetwork;
    CString         m_strNetName;
    BOOL            m_bEnableNetBIOS;

    // Names used to create/rename objects so we can undo it.
    CString         m_strGroupName;

    // Strings for constructing resource names.
    CString         m_strIPAddressResNameSuffix;
    CString         m_strNetworkNameResNameSuffix;

    // Set pointer to existing virtual server to create app in
    void SetExistingVirtualServer( IN CClusGroupInfo * pgi )    
    {
        ASSERT( pgi != NULL );

        if ( m_pgiExistingVirtualServer != pgi )
        {
            m_pgiExistingVirtualServer = pgi;
            SetVSDataChanged();
        } // if:  new virtual server selected

    } //*** SetExistingVirtualServer()

    // Set pointer to existing group to use for virtual server
    void SetExistingGroup( IN CClusGroupInfo * pgi )
    {
        ASSERT( pgi != NULL );

        if ( m_pgiExistingGroup != pgi )
        {
            m_pgiExistingGroup = pgi;
            SetVSDataChanged();
        } // if:  new group selected

    } //*** SetExistingGroup()

public:
    //
    // Access methods.
    //

    // State information -- READ.
    BOOL BClusterUpdated( void ) const              { return m_bClusterUpdated; }
    BOOL BVSDataChanged( void ) const               { return m_bVSDataChanged; }
    BOOL BAppDataChanged( void ) const              { return m_bAppDataChanged; }
    BOOL BNetNameChanged( void ) const              { return m_bNetNameChanged; }
    BOOL BIPAddressChanged( void ) const            { return m_bIPAddressChanged; }
    BOOL BSubnetMaskChanged( void ) const           { return m_bSubnetMaskChanged; }
    BOOL BNetworkChanged( void ) const              { return m_bNetworkChanged; }
    BOOL BCreatingNewVirtualServer( void ) const    { return m_bCreatingNewVirtualServer; }
    BOOL BCreatingNewGroup( void ) const            { return m_bCreatingNewGroup; }
    BOOL BCreatingAppResource( void ) const         { return m_bCreatingAppResource; }
    BOOL BNewGroupCreated( void ) const             { return m_bNewGroupCreated; }
    BOOL BExistingGroupRenamed( void ) const        { return m_bExistingGroupRenamed; }
    BOOL BIPAddressCreated( void ) const            { return m_riIPAddress.BCreated(); }
    BOOL BNetworkNameCreated( void ) const          { return m_riNetworkName.BCreated(); }
    BOOL BAppResourceCreated( void ) const          { return m_riApplication.BCreated(); }

    // State information -- WRITE.

    // TRUE = cluster has been changed by this wizard
    void SetClusterUpdated( IN BOOL bUpdated = TRUE )
    {
        m_bClusterUpdated = bUpdated;

    } //*** SetClusterUpdated()

    // TRUE = delete virtual server before creating new one, FALSE = ??
    void SetVSDataChanged( IN BOOL bChanged = TRUE )
    {
        m_bVSDataChanged = bChanged;
    
    } //*** SetVSDataChanged()

    // TRUE = delete application resource before creating new one, FALSE = ??
    void SetAppDataChanged( IN BOOL bChanged = TRUE )
    {
        m_bAppDataChanged = bChanged;

    } //*** SetAppDataChanged()

    // TRUE = refresh net name on page, FALSE = ??
    void SetNetNameChanged( IN BOOL bChanged = TRUE )
    {
        m_bNetNameChanged = bChanged;
        SetVSDataChanged( bChanged );

    } //*** SetNetNameChanged()

    // TRUE = refresh IP Address on page, FALSE = ??
    void SetIPAddressChanged( IN BOOL bChanged = TRUE )
    {
        m_bIPAddressChanged = bChanged;
        SetVSDataChanged( bChanged );

    } //*** SetIPAddressChanged()

    // TRUE = refresh subnet mask on page, FALSE = ??
    void SetSubnetMaskChanged( IN BOOL bChanged = TRUE )
    {
        m_bSubnetMaskChanged = bChanged;
        SetVSDataChanged( bChanged );

    } //*** SetSubnetMaskChanged()

    // TRUE = refresh network on page, FALSE = ??
    void SetNetworkChanged( IN BOOL bChanged = TRUE )
    {
        m_bNetworkChanged = bChanged;
        SetVSDataChanged( bChanged );

    } //*** SetNetworkChanged()

    // TRUE = create a new virtual server, FALSE = use existing
    BOOL BSetCreatingNewVirtualServer( IN BOOL bCreate = TRUE, IN CClusGroupInfo * pgi = NULL );

    // TRUE = creating new group for VS, FALSE = use existing group
    BOOL BSetCreatingNewGroup( IN BOOL bCreate = TRUE, IN CClusGroupInfo * pgi = NULL );

    // TRUE = creating application resource, FALSE = skip
    BOOL BSetCreatingAppResource( IN BOOL bCreate = TRUE )
    {
        if ( bCreate != m_bCreatingAppResource )
        {
            if ( BAppResourceCreated() && ! BDeleteAppResource() )
            {
                return FALSE;
            } // if:  error deleting the application resource
            m_bCreatingAppResource = bCreate;
            SetAppDataChanged();
        } // if:  state changed

        return TRUE;
    
    } //*** BSetCreateAppResource()

    // TRUE = new group was created
    void SetNewGroupCreated( IN BOOL bCreated = TRUE )
    {
        m_bNewGroupCreated = bCreated;
    
    } //*** SetNewGroupCreated()

    // TRUE = existing group was renamed
    void SetExistingGroupRenamed( IN BOOL bRenamed = TRUE )
    {
        m_bExistingGroupRenamed = bRenamed;
    
    } //*** SetExistingGroupRenamed()

    // Common properties.
    CClusGroupInfo *    PgiExistingVirtualServer( void ) const  { return m_pgiExistingVirtualServer; }
    CClusGroupInfo *    PgiExistingGroup( void ) const          { return m_pgiExistingGroup; }
    CClusGroupInfo &    RgiCurrent( void )                      { return m_giCurrent; }
    CClusResInfo &      RriIPAddress( void )                    { return m_riIPAddress; }
    CClusResInfo &      RriNetworkName( void )                  { return m_riNetworkName; }
    CClusResInfo &      RriApplication( void )                  { return m_riApplication; }
    CClusResInfo *      PriIPAddress( void )                    { return &m_riIPAddress; }
    CClusResInfo *      PriNetworkName( void )                  { return &m_riNetworkName; }
    CClusResInfo *      PriApplication( void )                  { return &m_riApplication; }

    void ClearExistingVirtualServer( void ) { m_pgiExistingVirtualServer = NULL; }
    void ClearExistingGroup( void )         { m_pgiExistingGroup = NULL; }

    // Private properties.
    const CString &     RstrIPAddress( void ) const     { return m_strIPAddress; }
    const CString &     RstrSubnetMask( void ) const    { return m_strSubnetMask; }
    const CString &     RstrNetwork( void ) const       { return m_strNetwork; }
    const CString &     RstrNetName( void ) const       { return m_strNetName; }
    BOOL                BEnableNetBIOS( void ) const    { return m_bEnableNetBIOS; }

    // Set the IP Address private property
    BOOL BSetIPAddress( IN LPCTSTR psz )
    {
        if ( m_strIPAddress != psz )
        {
            if ( BClusterUpdated() && ! BResetCluster() )
            {
                return FALSE;
            } // if:  error resetting the cluster
            m_strIPAddress = psz;
            SetIPAddressChanged();
        } // if:  string changed

        return TRUE;

    } //*** BSetIPAddress()

    // Set the subnet mask private property
    BOOL BSetSubnetMask( IN LPCTSTR psz )
    {
        if ( m_strSubnetMask != psz )
        {
            if ( BClusterUpdated() && ! BResetCluster() )
            {
                return FALSE;
            } // if:  error resetting the cluster
            m_strSubnetMask = psz;
            SetSubnetMaskChanged();
        } // if:  string changed

        return TRUE;

    } //*** BSetSubnetMask()

    // Set the Network private property
    BOOL BSetNetwork( IN LPCTSTR psz )
    {
        if ( m_strNetwork != psz )
        {
            if ( BClusterUpdated() && ! BResetCluster() )
            {
                return FALSE;
            } // if:  error resetting the cluster
            m_strNetwork = psz;
            SetNetworkChanged();
        } // if:  string changed

        return TRUE;

    } //*** BSetNetwork()

    // Set the network name private property
    BOOL BSetNetName( IN LPCTSTR psz )
    {
        if ( m_strNetName != psz )
        {
            if ( BClusterUpdated() && ! BResetCluster() )
            {
                return FALSE;
            } // if:  error resetting the cluster
            m_strNetName = psz;
            SetNetNameChanged();
        } // if:  string changed

        return TRUE;

    } //*** BSetNetName()

    // Set the EnableNetBIOS property for the IP Address resource
    BOOL BSetEnableNetBIOS( IN BOOL bEnable )
    {
        if ( m_bEnableNetBIOS != bEnable )
        {
            if ( BClusterUpdated() && ! BResetCluster() )
            {
                return FALSE;
            } // if:  error resetting the cluster
            m_bEnableNetBIOS = bEnable;
            SetNetNameChanged();
        } // if:  state changed

        return TRUE;

    } //*** BSetEnableNetBIOS()

    // Names used to create/rename objects so we can undo it.
    const CString & RstrIPAddressResName( void )                { return RriIPAddress().RstrName(); }
    const CString & RstrNetworkNameResName( void )              { return RriNetworkName().RstrName(); }

    // Strings for constructing resource names.
    const CString const & RstrIPAddressResNameSuffix( void ) const      { return m_strIPAddressResNameSuffix; }
    const CString const & RstrNetworkNameResNameSuffix( void ) const    { return m_strNetworkNameResNameSuffix; }

}; //*** class CClusterAppWizard

/////////////////////////////////////////////////////////////////////////////

#endif // __CLUSAPPWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\clusappwizpage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ClusAppWizPage.h
//
//	Abstract:
//		Definitions of the CClusterAppWizardPage classes.
//
//	Implementation File:
//		None.
//
//	Author:
//		David Potter (davidp)	December 6, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLUSAPPWIZPAGE_H_
#define __CLUSAPPWIZPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

template < class TBase > class CClusterAppWizardPage;
template < class T > class CClusterAppStaticWizardPage;
template < class T > class CClusterAppDynamicWizardPage;
template < class T > class CClusterAppExtensionWizardPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterAppWizard;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEWIZPAGE_H_
#include "AtlBaseWizPage.h"	// for CBaseWizardPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CClusterAppWizardPage
/////////////////////////////////////////////////////////////////////////////

template < class TBase >
class CClusterAppWizardPage : public TBase
{
public:
	//
	// Construction
	//

	// Standard constructor
	CClusterAppWizardPage(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: TBase( lpszTitle )
	{
	} //*** CClusterAppWizardPage()

	// Constructor taking a resource ID for the title
	CClusterAppWizardPage(
		IN UINT nIDTitle
		)
		: TBase( nIDTitle )
	{
	} //*** CClusterAppWizardPage()

public:
	//
	// CClusterAppWizardPage public methods.
	//

public:
	//
	// Message handler functions.
	//

// Implementation
protected:
	CClusterAppWizard *		PwizThis( void ) const	{ return (CClusterAppWizard *) Pwiz(); }
	CLUSAPPWIZDATA const *	PcawData( void ) const	{ return PwizThis()->PcawData(); }

}; //*** class CClusterAppWizardPage

/////////////////////////////////////////////////////////////////////////////
// class CClusterAppStaticWizardPage
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CClusterAppStaticWizardPage : public CClusterAppWizardPage< CStaticWizardPageImpl< T > >
{
public:
	//
	// Construction
	//

	// Standard constructor
	CClusterAppStaticWizardPage(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: CClusterAppWizardPage< CStaticWizardPageImpl< T > >( lpszTitle )
	{
	} //*** CClusterAppStaticWizardPage()

	// Constructor taking a resource ID for the title
	CClusterAppStaticWizardPage(
		IN UINT nIDTitle
		)
		: CClusterAppWizardPage< CStaticWizardPageImpl< T > >( nIDTitle )
	{
	} //*** CClusterAppStaticWizardPage()

	// Handler for PSN_WIZFINISH
	BOOL OnWizardFinish( void )
	{
		return CBasePageWindow::OnWizardFinish();

	} //*** OnWizardFinish()

}; //*** class CClusterAppStaticWizardPage

/////////////////////////////////////////////////////////////////////////////
// class CClusterAppDynamicWizardPage
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CClusterAppDynamicWizardPage : public CClusterAppWizardPage< CDynamicWizardPageImpl< T > >
{
public:
	//
	// Construction
	//

	// Standard constructor
	CClusterAppDynamicWizardPage(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: CClusterAppWizardPage< CDynamicWizardPageImpl< T > >( lpszTitle )
	{
	} //*** CClusterAppDynamicWizardPage()

	// Constructor taking a resource ID for the title
	CClusterAppDynamicWizardPage(
		IN UINT nIDTitle
		)
		: CClusterAppWizardPage< CDynamicWizardPageImpl< T > >( nIDTitle )
	{
	} //*** CClusterAppDynamicWizardPage()

}; //*** class CClusterAppDynamicWizardPage

/////////////////////////////////////////////////////////////////////////////
// class CClusterAppExtensionWizardPage
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CClusterAppExtensionWizardPage : public CClusterAppWizardPage< CExtensionWizardPageImpl< T > >
{
public:
	//
	// Construction
	//

	// Standard constructor
	CClusterAppExtensionWizardPage(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: CClusterAppWizardPage< CDynamicWizardPageImpl< T > >( lpszTitle )
	{
	} //*** CClusterAppExtensionWizardPage()

	// Constructor taking a resource ID for the title
	CClusterAppExtensionWizardPage(
		IN UINT nIDTitle
		)
		: CClusterAppWizardPage< CDynamicWizardPageImpl< T > >( nIDTitle )
	{
	} //*** CClusterAppExtensionWizardPage()

}; //*** class CClusterAppExtensionWizardPage

/////////////////////////////////////////////////////////////////////////////

#endif // __CLUSAPPWIZPAGE_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "ClAdmWiz_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\clusobjs.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ClusObjS.cpp
//
//	Abstract:
//		Stub for implementation of the CClusterObject classes.
//
//	Author:
//		David Potter (davidp)	September 15, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClusObj.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\complete.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		Complete.cpp
//
//	Abstract:
//		Implementation of the CWizPageCompletion class.
//
//	Author:
//		David Potter (davidp)	December 5, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Complete.h"
#include "ClusAppWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageCompletion
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageCompletion )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_TITLE )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_LISTBOX )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageCompletion::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None..
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageCompletion::OnInitDialog( void )
{
	//
	// Attach controls to control member variables.
	//
	AttachControl( m_staticTitle, IDC_WIZARD_TITLE );
	AttachControl( m_lvcProperties, IDC_WIZARD_LISTBOX );

	//
	// Set the font of the title control.
	//
	m_staticTitle.SetFont( PwizThis()->RfontExteriorTitle() );

	//
	// Initialize and add columns to the list view control.
	//
	{
		DWORD	_dwExtendedStyle;
		CString	_strWidth;
		int		_nWidth;

		//
		// Change list view control extended styles.
		//
		_dwExtendedStyle = m_lvcProperties.GetExtendedListViewStyle();
		m_lvcProperties.SetExtendedListViewStyle( 
			LVS_EX_FULLROWSELECT,
			LVS_EX_FULLROWSELECT
			);

		//
		// Insert the property name column.
		//
		_strWidth.LoadString( IDS_COMPLETED_PROP_NAME_WIDTH );
		_nWidth = _tcstoul( _strWidth, NULL, 10 );
		m_lvcProperties.InsertColumn( 0, _T(""), LVCFMT_LEFT, _nWidth, -1 );

		//
		// Insert the property value column.
		//
		_strWidth.LoadString( IDS_COMPLETED_PROP_VALUE_WIDTH );
		_nWidth = _tcstoul( _strWidth, NULL, 10 );
		m_lvcProperties.InsertColumn( 1, _T(""), LVCFMT_LEFT, _nWidth, -1 );

	} // Add columns

	return TRUE;

} //*** CWizPageCompletion::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageCompletion::OnSetActive
//
//	Routine Description:
//		Handler for PSN_SETACTIVE.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Page activated successfully.
//		FALSE		Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageCompletion::OnSetActive( void )
{
	int		_idxCurrent = 0;
	int		_idxActual;
	CString	_strPropName;
	CString	_strVirtualServer;
	CString	_strNetworkName;
	CString	_strIPAddress;
	CString	_strNetwork;
	CString	_strAppName;
	CString	_strResType;

	//
	// FILL THE LIST VIEW CONTROL WITH THE PROPERTIES THE USER SPECIFIED.
	//

	//
	// Remove all items from the list view control to begin with.
	//
	m_lvcProperties.DeleteAllItems();

	//
	// Collect the data.
	//
	if ( PwizThis()->BCreatingNewVirtualServer() )
	{
		_strVirtualServer = PwizThis()->RgiCurrent().RstrName();
		_strNetworkName = PwizThis()->RgiCurrent().RstrNetworkName();
		_strIPAddress = PwizThis()->RgiCurrent().RstrIPAddress();
		_strNetwork = PwizThis()->RgiCurrent().RstrNetwork();
	} // if:  created new virtual server
	else
	{
		_strVirtualServer = PwizThis()->PgiExistingVirtualServer()->RstrName();
		_strNetworkName = PwizThis()->PgiExistingVirtualServer()->RstrNetworkName();
		_strIPAddress = PwizThis()->PgiExistingVirtualServer()->RstrIPAddress();
		_strNetwork = PwizThis()->PgiExistingVirtualServer()->RstrNetwork();
	} // else:  used existing virtual server

	if ( PwizThis()->BCreatingAppResource() )
	{
		_strAppName = PwizThis()->RriApplication().RstrName();
		_strResType = PwizThis()->RriApplication().Prti()->RstrDisplayName();
	} // if:  created application resource

	//
	// Set the virtual server name.
	//
	_strPropName.LoadString( IDS_COMPLETED_VIRTUAL_SERVER );
	_idxActual = m_lvcProperties.InsertItem( _idxCurrent++, _strPropName );
	m_lvcProperties.SetItemText( _idxActual, 1, _strVirtualServer );

	//
	// Set the Network Name.
	//
	_strPropName.LoadString( IDS_COMPLETED_NETWORK_NAME );
	_idxActual = m_lvcProperties.InsertItem( _idxCurrent++, _strPropName );
	m_lvcProperties.SetItemText( _idxActual, 1, _strNetworkName );

	//
	// Set the IP Address.
	//
	_strPropName.LoadString( IDS_COMPLETED_IP_ADDRESS );
	_idxActual = m_lvcProperties.InsertItem( _idxCurrent++, _strPropName );
	m_lvcProperties.SetItemText( _idxActual, 1, _strIPAddress );

	//
	// Set the Network.
	//
	_strPropName.LoadString( IDS_COMPLETED_NETWORK );
	_idxActual = m_lvcProperties.InsertItem( _idxCurrent++, _strPropName );
	m_lvcProperties.SetItemText( _idxActual, 1, _strNetwork );

	//
	// If we created an application resource, add properties
	// for it as well.
	//
	if ( PwizThis()->BCreatingAppResource() )
	{
		//
		// Set the application resource name.
		//
		_strPropName.LoadString( IDS_COMPLETED_APP_RESOURCE );
		_idxActual = m_lvcProperties.InsertItem( _idxCurrent++, _strPropName );
		m_lvcProperties.SetItemText( _idxActual, 1, _strAppName );

		//
		// Set the application resource type.
		//
		_strPropName.LoadString( IDS_COMPLETED_APP_RESOURCE_TYPE );
		_idxActual = m_lvcProperties.InsertItem( _idxCurrent++, _strPropName );
		m_lvcProperties.SetItemText( _idxActual, 1, _strResType );
	} // if:  created application resource

	//
	// Call the base class and return.
	//
	return baseClass::OnSetActive();

} //*** CWizPageCompletion::OnSetActive()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\complete.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		Complete.h
//
//	Abstract:
//		Definition of the CWizPageCompletion class.
//
//	Implementation File:
//		Complete.cpp
//
//	Author:
//		David Potter (davidp)	December 2, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __COMPLETE_H_
#define __COMPLETE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageCompletion;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAG_H_
#include "ClusAppWizPage.h"	// for CClusterAppDynamicWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageCompletion
/////////////////////////////////////////////////////////////////////////////

class CWizPageCompletion : public CClusterAppDynamicWizardPage< CWizPageCompletion >
{
	typedef CClusterAppDynamicWizardPage< CWizPageCompletion > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageCompletion( void )
	{
	} //*** CWizPageCompletion()

	WIZARDPAGE_HEADERTITLEID( 0 )
	WIZARDPAGE_HEADERSUBTITLEID( 0 )

	enum { IDD = IDD_COMPLETION };

public:
	//
	// CWizardPageWindow public methods.
	//

public:
	//
	// CBasePage public methods.
	//

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CWizPageCompletion )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void );

// Implementation
protected:
	//
	// Controls.
	//
	CStatic			m_staticTitle;
	CListViewCtrl	m_lvcProperties;

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_COMPLETION; }

}; //*** class CWizPageCompletion

/////////////////////////////////////////////////////////////////////////////

#endif // __COMPLETE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\excopers.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ExcOperS.cpp
//
//	Abstract:
//		Stub for implementation of exception classes.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

inline int EXC_AppMessageBox(LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0)
{
	return AppMessageBox(NULL, lpszText, nType);
}

inline int EXC_AppMessageBox(UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1)
{
	return AppMessageBox(NULL, nIDPrompt, nType);
}

inline int EXC_AppMessageBox(HWND hwndParent, LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0)
{
	return AppMessageBox(hwndParent, lpszText, nType);
}

inline int EXC_AppMessageBox(HWND hwndParent, UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1)
{
	return AppMessageBox(hwndParent, nIDPrompt, nType);
}

inline HINSTANCE EXC_GetResourceInstance(void)
{
	return _Module.GetResourceInstance();
}

#include "ExcOper.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__CC7C59FA_64F2_11D1_9AA7_00C04FB93A80__INCLUDED_)
#define AFX_DLLDATAX_H__CC7C59FA_64F2_11D1_9AA7_00C04FB93A80__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__CC7C59FA_64F2_11D1_9AA7_00C04FB93A80__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\helpdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		HelpData.cpp
//
//	Abstract:
//		Data required for implementing help.
//
//	Author:
//		Galen Barbee (galenb)	May 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "AdmCommonRes.h"

// Define help IDs.
#include "HelpIDs.h"

// Declare arrays.  If we don't do this the arrays don't get instantiated
// in the executable image.
#include "HelpArr.h"

// Define the arrays.
#define INITHELPARRAYS
#include "HelpArr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\entersubnet.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		EnterSubnet.h
//
//	Abstract:
//		Definition of the CEnterSubnetMaskDlg class.
//
//	Implementation File:
//		EnterSubnet.cpp
//
//	Author:
//		David Potter (davidp)	February 9, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ENTERSUBNET_H_
#define __ENTERSUBNET_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CEnterSubnetMaskDlg;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __ATLBASEDLG_H_
#include "AtlBaseDlg.h"	// for CBaseDlg
#endif

#ifndef __CLUSAPPWIZ_H_
#include "ClusAppWiz.h"
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CEnterSubnetMaskDlg
/////////////////////////////////////////////////////////////////////////////

class CEnterSubnetMaskDlg : public CBaseDlg< CEnterSubnetMaskDlg >
{
public:
	//
	// Construction
	//

	// Default constructor
	CEnterSubnetMaskDlg(
		LPCTSTR pszIPAddress,
		LPCTSTR pszSubnetMask,
		LPCTSTR pszNetwork,
		CClusterAppWizard * pwiz
		)
		: m_strIPAddress( pszIPAddress )
		, m_strSubnetMask( pszSubnetMask )
		, m_strNetwork( pszNetwork )
		, m_pwiz( pwiz )
	{
		ASSERT( pszIPAddress != NULL );
		ASSERT( pszSubnetMask != NULL );
		ASSERT( pszNetwork != NULL );
		ASSERT( pwiz != NULL );

	} //*** CEnterSubnetMaskDlg()

	enum { IDD = IDD_ENTER_SUBNET_MASK };

public:
	//
	// CEnterSubnetMaskDlg public methods.
	//

public:
	//
	// CBaseDlg public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( BOOL bSaveAndValidate );

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( CEnterSubnetMaskDlg )
		COMMAND_HANDLER( IDC_ESM_SUBNET_MASK, EN_CHANGE, OnChangedSubnetMask )
		COMMAND_HANDLER( IDC_ESM_NETWORKS, CBN_SELCHANGE, OnChangedNetwork )
		COMMAND_HANDLER( IDOK, BN_CLICKED, OnOK )
		COMMAND_HANDLER( IDCANCEL, BN_CLICKED, OnCancel )
		CHAIN_MSG_MAP( CBaseDlg< CEnterSubnetMaskDlg > )
	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	// Handler for the EN_CHANGE command notification on IDC_ESM_SUBNET_MASK
	LRESULT OnChangedSubnetMask(
		WORD /*wNotifyCode*/,
		WORD /*idCtrl*/,
		HWND /*hwndCtrl*/,
		BOOL & /*bHandled*/
		)
	{
		CheckForRequiredFields();
		return 0;

	} //*** OnChangedSubnetMask()

	// Handler for the EN_CHANGE command notification on IDC_ESM_NETWORK
	LRESULT OnChangedNetwork(
		WORD /*wNotifyCode*/,
		WORD /*idCtrl*/,
		HWND /*hwndCtrl*/,
		BOOL & /*bHandled*/
		)
	{
		CheckForRequiredFields();
		return 0;

	} //*** OnChangedNetwork()

	// Handler for the BN_CLICKED command notification on IDOK
	LRESULT OnOK(
		WORD /*wNotifyCode*/,
		WORD /*idCtrl*/,
		HWND /*hwndCtrl*/,
		BOOL & /*bHandled*/
		)
	{
		if ( UpdateData(TRUE /*bSaveAndValidate*/ ) )
		{
			EndDialog( IDOK );
		} // if:  data updated successfully

		return 0;

	} //*** OnOK()

	// Handler for the BN_CLICKED command notification on IDCANCEL
	LRESULT OnCancel(
		WORD /*wNotifyCode*/,
		WORD /*idCtrl*/,
		HWND /*hwndCtrl*/,
		BOOL & /*bHandled*/
		)
	{
		EndDialog( IDCANCEL );
		return 0;

	} //*** OnCancel()

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog(void);


// Implementation
protected:
	//
	// Controls.
	//
	CIPAddressCtrl		m_ipaIPAddress;
	CIPAddressCtrl		m_ipaSubnetMask;
	CComboBox			m_cboxNetworks;
	CButton				m_pbOK;

	//
	// Page state.
	//
	CString				m_strIPAddress;
	CString				m_strSubnetMask;
	CString				m_strNetwork;

	CClusterAppWizard *	m_pwiz;

	// Check for required fields and enable/disable Next button
	void CheckForRequiredFields( void )
	{
		BOOL bIsSubnetMaskBlank = m_ipaSubnetMask.IsBlank();
		BOOL bIsNetworkBlank = m_cboxNetworks.GetWindowTextLength() == 0;
		BOOL bEnable = ! bIsSubnetMaskBlank && ! bIsNetworkBlank;
		m_pbOK.EnableWindow( bEnable );

	} //*** CheckForRequiredFields()

	// Fill the combobox with a list of networks that are accessible by clients
	void FillComboBox( void );

public:
	//
	// Data access.
	//
	const CString RstrSubnetMask( void ) const	{ return m_strSubnetMask; }
	const CString RstrNetwork( void ) const		{ return m_strNetwork; }
	CClusterAppWizard * Pwiz( void )			{ return m_pwiz; }

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_ENTER_SUBNET_MASK; }

}; //*** class CEnterSubnetMaskDlg

/////////////////////////////////////////////////////////////////////////////

#endif // __ENTERSUBNET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\entersubnet.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		EnterSubnet.cpp
//
//	Abstract:
//		Implementation of the CEnterSubnetMaskDlg class.
//
//	Author:
//		David Potter (davidp)	February 10, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "EnterSubnet.h"
#include "AdmNetUtils.h"	// for BIsValidxxx network functions
#include "AtlUtil.h"		// for DDX/DDV

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CEnterSubnetMaskDlg
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CEnterSubnetMaskDlg )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ESM_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ESM_IP_ADDRESS_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ESM_IP_ADDRESS )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ESM_SUBNET_MASK_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ESM_SUBNET_MASK )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ESM_NETWORKS_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ESM_NETWORKS )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDOK )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDCANCEL )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CEnterSubnetMaskDlg::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CEnterSubnetMaskDlg::OnInitDialog( void )
{
	//
	// Attach the controls to control member variables.
	//
	AttachControl( m_ipaIPAddress, IDC_ESM_IP_ADDRESS );
	AttachControl( m_ipaSubnetMask, IDC_ESM_SUBNET_MASK );
	AttachControl( m_cboxNetworks, IDC_ESM_NETWORKS );
	AttachControl( m_pbOK, IDOK );

	//
	// Initialize the data in the controls.
	//
	UpdateData( FALSE /*bSaveAndValidate*/ );

	//
	// Set the IP Address control to be read only.
	//
	SetDlgItemReadOnly( m_ipaIPAddress.m_hWnd );

	//
	// Fill the networks combobox.
	//
	FillComboBox();

	//
	// Set the focus on the subnet mask control.
	//
	m_ipaSubnetMask.SetFocus( 0 );

	return FALSE;

} //*** CEnterSubnetMaskDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CEnterSubnetMaskDlg::UpdateData
//
//	Routine Description:
//		Update data on or from the page.
//
//	Arguments:
//		bSaveAndValidate	[IN] TRUE if need to read data from the page.
//								FALSE if need to set data to the page.
//
//	Return Value:
//		TRUE		The data was updated successfully.
//		FALSE		An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CEnterSubnetMaskDlg::UpdateData( BOOL bSaveAndValidate )
{
	BOOL	bSuccess = TRUE;

	if ( bSaveAndValidate )
	{
		DDX_GetText( m_hWnd, IDC_ESM_SUBNET_MASK, m_strSubnetMask );
		DDX_GetText( m_hWnd, IDC_ESM_NETWORKS, m_strNetwork );

		if (	! DDV_RequiredText( m_hWnd, IDC_ESM_SUBNET_MASK, IDC_ESM_SUBNET_MASK_LABEL, m_strSubnetMask )
			||	! DDV_RequiredText( m_hWnd, IDC_ESM_NETWORKS, IDC_ESM_NETWORKS_LABEL, m_strNetwork )
			)
		{
			return FALSE;
		} // if: required text not present

		//
		// Validate the subnet mask.
		//
		if ( ! BIsValidSubnetMask( m_strSubnetMask ) )
		{
			CString strMsg;
			strMsg.FormatMessage( IDS_ERROR_INVALID_SUBNET_MASK, m_strSubnetMask );
			AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
			return FALSE;
		}  // if: invalid subnet mask
		if ( ! BIsValidIpAddressAndSubnetMask( m_strIPAddress, m_strSubnetMask ) )
		{
			CString strMsg;
			strMsg.FormatMessage( IDS_ERROR_INVALID_ADDRESS_AND_SUBNET_MASK, m_strIPAddress, m_strSubnetMask );
			AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
			return FALSE;
		}  // if: invalid subnet mask
	} // if: saving data from the page
	else
	{
		DDX_SetText( m_hWnd, IDC_ESM_IP_ADDRESS, m_strIPAddress );
		DDX_SetText( m_hWnd, IDC_ESM_SUBNET_MASK, m_strSubnetMask );
		DDX_SetComboBoxText( m_hWnd, IDC_ESM_NETWORKS, m_strNetwork );
	} // else: setting data to the page

	return bSuccess;

} //*** CEnterSubnetMaskDlg::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CEnterSubnetMaskDlg::FillComboBox
//
//	Routine Description:
//		Fill the combobox with a list of networks that are accessible by clients.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CEnterSubnetMaskDlg::FillComboBox( void )
{
	// Loop to avoid goto's.
	do
	{
		//
		// Clear the combobox first.
		//
		m_cboxNetworks.ResetContent();

		//
		// Add each network in the list to the combobox.
		//
		CClusNetworkPtrList::iterator itnet;
		int idx;
		for ( itnet = Pwiz()->PlpniNetworks()->begin()
			; itnet != Pwiz()->PlpniNetworks()->end()
			; itnet++ )
		{
			//
			// Add the network to the combobox.
			//
			CClusNetworkInfo * pni = *itnet;
			if ( pni->BIsClientNetwork() )
			{
				idx = m_cboxNetworks.AddString( pni->RstrName() );
				ASSERT( idx != CB_ERR );
				m_cboxNetworks.SetItemDataPtr( idx, (void *) pni );
			} // if:  client network
		} // for:  each entry in the list

		//
		// Select the currently saved entry, or the first one if none are
		// currently saved.
		//
		if ( m_strNetwork.GetLength() == 0 )
		{
			m_cboxNetworks.SetCurSel( 0 );
		} // if:  empty string
		else
		{
			int idx = m_cboxNetworks.FindStringExact( -1, m_strNetwork );
			if ( idx != CB_ERR )
			{
				m_cboxNetworks.SetCurSel( idx );
			} // if:  saved selection found in the combobox
			else
			{
				m_cboxNetworks.SetCurSel( 0 );
			} // else:  saved selection not found in the combobox
		} // else:  network saved
	} while ( 0 );

} //*** CEnterSubnetMaskDlg::FillComboBox()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\grpadv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		GrpAdv.h
//
//	Abstract:
//		Definition of the advanced group page classes.
//
//	Implementation File:
//		GrpAdv.cpp
//
//	Author:
//		David Potter (davidp)	February 25, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __GRPADV_H_
#define __GRPADV_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGroupAdvancedSheet;
class CGroupGeneralPage;
class CGroupFailoverPage;
class CGroupFailbackPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusGroupInfo;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __ATLBASEPROPSHEET_H_
#include "AtlBasePropSheet.h"	// for CBasePropertySheetImpl
#endif

#ifndef __ATLBASEPROPPAGE_H_
#include "AtlBasePropPage.h"	// for CBasePropertyPageImpl
#endif

#ifndef __CLUSAPPWIZ_H_
#include "ClusAppWiz.h"			// for CClusterAppWizard
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"			// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CGroupAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

class CGroupAdvancedSheet : public CBasePropertySheetImpl< CGroupAdvancedSheet >
{
	typedef CBasePropertySheetImpl< CGroupAdvancedSheet > baseClass;

public:
	//
	// Construction
	//

	// Default constructor
	CGroupAdvancedSheet( IN UINT nIDCaption )
		: CBasePropertySheetImpl< CGroupAdvancedSheet >( nIDCaption )
		, m_pgi( NULL )
		, m_pbChanged( NULL )
	{
	} //*** CGroupAdvancedSheet()

	// Initialize the sheet
	BOOL BInit(
		IN OUT CClusGroupInfo &	rgi,
		IN CClusterAppWizard *	pwiz,
		IN OUT BOOL &			rbChanged
		);

	// Add all pages to the page array
	BOOL BAddAllPages( void );

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CGroupAdvancedSheet )
//	END_MSG_MAP()
	DECLARE_EMPTY_MSG_MAP()
	DECLARE_CLASS_NAME()

	//
	// Message handler functions.
	//

// Implementation
protected:
	CClusGroupInfo *	m_pgi;
	CClusterAppWizard *	m_pwiz;
	BOOL *				m_pbChanged;

public:
	CClusGroupInfo *	Pgi( void ) const	{ return m_pgi; }
	CClusterAppWizard *	Pwiz( void ) const	{ return m_pwiz; }
	void				SetGroupInfoChanged( void ) { ASSERT( m_pbChanged != NULL ); *m_pbChanged = TRUE; }

}; //*** class CGroupAdvancedSheet

/////////////////////////////////////////////////////////////////////////////
// class CGroupGeneralPage
/////////////////////////////////////////////////////////////////////////////

class CGroupGeneralPage : public CStaticPropertyPageImpl< CGroupGeneralPage >
{
	typedef CStaticPropertyPageImpl< CGroupGeneralPage > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CGroupGeneralPage( void )
		: m_bPreferredOwnersChanged( FALSE )
	{
	} //*** CGroupGeneralPage()

	enum { IDD = IDD_GRPADV_GENERAL };

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( CGroupGeneralPage )
		COMMAND_HANDLER( IDC_GAG_PREF_OWNERS_MODIFY, BN_CLICKED, OnModifyPrefOwners )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	// Handler for BN_CLICKED on the Modify button
	LRESULT OnModifyPrefOwners(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		);

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( IN BOOL bSaveAndValidate );

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

// Implementation
protected:
	//
	// Controls.
	//
	CListBox	m_lbPreferredOwners;

	//
	// Page state.
	//
	CString	m_strName;
	CString	m_strDesc;

	CClusNodePtrList m_lpniPreferredOwners;

	BOOL m_bPreferredOwnersChanged;

protected:
	CGroupAdvancedSheet *	PshtThis( void ) const		{ return (CGroupAdvancedSheet *) Psht(); }
	CClusGroupInfo *		Pgi( void ) const			{ return PshtThis()->Pgi(); }
	CClusterAppWizard *		Pwiz( void ) const			{ return PshtThis()->Pwiz(); }
	void					SetGroupInfoChanged( void )	{ PshtThis()->SetGroupInfoChanged(); }

	// Save the group name
	BOOL BSaveName( void )
	{
		if ( Pgi()->RstrName() != m_strName )
		{
			Pgi()->SetName( m_strName );
			return TRUE;
		} // if:  value changed

		return FALSE;

	} //*** BSaveName()

	// Save the group description
	BOOL BSaveDescription( void )
	{
		if ( Pgi()->RstrDescription() != m_strDesc )
		{
			Pgi()->SetDescription( m_strDesc );
			return TRUE;
		} // if:  value changed

		return FALSE;

	} //*** BSaveDescription()

	// Save preferred owners
	BOOL BSavePreferredOwners( void )
	{
		if ( m_bPreferredOwnersChanged )
		{
			*Pgi()->PlpniPreferredOwners() = m_lpniPreferredOwners;
			return TRUE;
		} // if:  preferred owners changed

		return FALSE;

	} //*** BSavePreferredOwners()

	// Fill the list of preferred owners
	void FillPreferredOwnersList( void );

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_GRPADV_GENERAL; }

}; //*** class CGroupGeneralPage

/////////////////////////////////////////////////////////////////////////////
// class CGroupFailoverPage
/////////////////////////////////////////////////////////////////////////////

class CGroupFailoverPage : public CStaticPropertyPageImpl< CGroupFailoverPage >
{
	typedef CStaticPropertyPageImpl< CGroupFailoverPage > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CGroupFailoverPage( void )
		: m_nFailoverThreshold( CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD )
		, m_nFailoverPeriod( CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD )
	{
	} //*** CGroupFailoverPage()

	enum { IDD = IDD_GRPADV_FAILOVER };

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( CGroupFailoverPage )
		COMMAND_HANDLER( IDC_GAFO_FAILOVER_THRESH, EN_CHANGE, OnChanged )
		COMMAND_HANDLER( IDC_GAFO_FAILOVER_PERIOD, EN_CHANGE, OnChanged )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	// Handler for the EN_CHANGE command notification on edit fields
	LRESULT OnChanged(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		SetModified( TRUE );
		return 0;

	} // OnChanged()

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( IN BOOL bSaveAndValidate );

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

// Implementation
protected:
	//
	// Controls.
	//
	CUpDownCtrl	m_spinThreshold;
	CUpDownCtrl	m_spinPeriod;

	//
	// Page state.
	//
	ULONG		m_nFailoverThreshold;
	ULONG		m_nFailoverPeriod;

protected:
	CGroupAdvancedSheet *	PshtThis( void ) const		{ return (CGroupAdvancedSheet *) Psht(); }
	CClusGroupInfo *		Pgi( void ) const			{ return PshtThis()->Pgi(); }
	CClusterAppWizard *		Pwiz( void ) const			{ return PshtThis()->Pwiz(); }
	void					SetGroupInfoChanged( void )	{ PshtThis()->SetGroupInfoChanged(); }

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_GRPADV_FAILOVER; }

}; //*** class CGroupFailoverPage

/////////////////////////////////////////////////////////////////////////////
// class CGroupFailbackPage
/////////////////////////////////////////////////////////////////////////////

class CGroupFailbackPage : public CStaticPropertyPageImpl< CGroupFailbackPage >
{
	typedef CStaticPropertyPageImpl< CGroupFailbackPage > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CGroupFailbackPage( void )
		: m_cgaft( ClusterGroupPreventFailback )
		, m_bNoFailbackWindow( TRUE )
		, m_nStart( CLUSTER_GROUP_FAILBACK_WINDOW_NONE )
		, m_nEnd( CLUSTER_GROUP_FAILBACK_WINDOW_NONE )
	{
	} //*** CGroupFailoverPage()

	enum { IDD = IDD_GRPADV_FAILBACK };

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( CGroupFailbackPage )
		COMMAND_HANDLER( IDC_GAFB_PREVENT_FAILBACK, BN_CLICKED, OnClickedPreventFailback )
		COMMAND_HANDLER( IDC_GAFB_ALLOW_FAILBACK, BN_CLICKED, OnClickedAllowFailback )
		COMMAND_HANDLER( IDC_GAFB_FAILBACK_IMMED, BN_CLICKED, OnClickedFailbackImmediate )
		COMMAND_HANDLER( IDC_GAFB_FAILBACK_WINDOW, BN_CLICKED, OnClickedFailbackInWindow )
		COMMAND_HANDLER( IDC_GAFB_FBWIN_START, EN_CHANGE, OnChanged )
		COMMAND_HANDLER( IDC_GAFB_FBWIN_END, EN_CHANGE, OnChanged )

		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	// Handler for the BN_CLICKED command notification on the PREVENT radio button
	LRESULT OnClickedPreventFailback(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		);

	// Handler for the BN_CLICKED command notification on the ALLOW radio button
	LRESULT OnClickedAllowFailback(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		);

	// Handler for the BN_CLICKED command notification on the IMMEDIATE radio button
	LRESULT OnClickedFailbackImmediate(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		);

	// Handler for the BN_CLICKED command notification on the IN WINDOW radio button
	LRESULT OnClickedFailbackInWindow(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		);

	// Handler for the EN_CHANGE command notification on edit fields
	LRESULT OnChanged(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		SetModified( TRUE );
		return 0;

	} // OnChanged()

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( IN BOOL bSaveAndValidate );

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

// Implementation
protected:
	//
	// Controls.
	//
	CButton		m_rbPreventFailback;
	CButton		m_rbAllowFailback;
	CStatic		m_staticFailbackWhenDesc;
	CButton		m_rbFBImmed;
	CButton		m_rbFBWindow;
	CEdit		m_editStart;
	CUpDownCtrl	m_spinStart;
	CStatic		m_staticWindowAnd;
	CEdit		m_editEnd;
	CUpDownCtrl	m_spinEnd;
	CStatic		m_staticWindowUnits;

	//
	// Page state.
	//
	CGAFT	m_cgaft;
	BOOL	m_bNoFailbackWindow;
	DWORD	m_nStart;
	DWORD	m_nEnd;

protected:
	CGroupAdvancedSheet *	PshtThis( void ) const		{ return (CGroupAdvancedSheet *) Psht(); }
	CClusGroupInfo *		Pgi( void ) const			{ return PshtThis()->Pgi(); }
	CClusterAppWizard *		Pwiz( void ) const			{ return PshtThis()->Pwiz(); }
	void					SetGroupInfoChanged( void )	{ PshtThis()->SetGroupInfoChanged(); }

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_GRPADV_FAILBACK; }

}; //*** class CGroupFailbackPage

/////////////////////////////////////////////////////////////////////////////

#endif // __GRPADV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\helparr.h ===
//disable instructional text and icons
#define IDH_DISABLEHELP	((DWORD)-1)

#ifdef INITHELPARRAYS


const DWORD g_aHelpIDs_IDD_APP_RESOURCE_CREATE[]=
{
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_ARC_DONT_CREATE_RES, IDH_ARC_DONT_CREATE_RES,
	IDC_ARC_CREATE_RES, IDH_ARC_CREATE_RES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_APP_RESOURCE_NAME_DESC[]=
{
	IDC_ARND_RES_NAME_TITLE, IDH_DISABLEHELP,
	IDC_ARND_RES_NAME_LABEL, IDH_ARND_RES_NAME,
	IDC_ARND_RES_NAME, IDH_ARND_RES_NAME,
	IDC_ARND_RES_DESC_LABEL, IDH_ARND_RES_DESC, 
	IDC_ARND_RES_DESC, IDH_ARND_RES_DESC,
	IDC_ARND_ADVANCED_PROPS_LABEL, IDH_ARND_ADVANCED_PROPS,
	IDC_ARND_ADVANCED_PROPS, IDH_ARND_ADVANCED_PROPS,
	IDC_WIZARD_CLICK_NEXT, IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_APP_RESOURCE_TYPE[]=
{
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_ART_RESTYPES_LABEL, IDH_ART_RESTYPES,
	IDC_ART_RESTYPES, IDH_ART_RESTYPES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_COMPLETION[]=
{
	IDC_WIZARD_TITLE, IDH_DISABLEHELP,
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_WIZARD_LISTBOX, IDH_WIZARD_LISTBOX,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ENTER_SUBNET_MASK[]=
{
	IDC_ESM_DESCRIPTION, IDH_DISABLEHELP,
	IDC_ESM_IP_ADDRESS_LABEL, IDH_ESM_IP_ADDRESS,
	IDC_ESM_IP_ADDRESS, IDH_ESM_IP_ADDRESS,
	IDC_ESM_SUBNET_MASK_LABEL, IDH_ESM_SUBNET_MASK,
	IDC_ESM_SUBNET_MASK, IDH_ESM_SUBNET_MASK,
	IDC_ESM_NETWORKS_LABEL, IDH_ESM_NETWORKS,
	IDC_ESM_NETWORKS, IDH_ESM_NETWORKS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_GRPADV_FAILBACK[]=
{
	IDC_GAFB_FAILBACK_DESCRIPTION, IDH_DISABLEHELP, 
	IDC_GAFB_PREVENT_FAILBACK, IDH_PP_GROUP_AUTOFB_PREVENT,
	IDC_GAFB_ALLOW_FAILBACK, IDH_PP_GROUP_AUTOFB_ALLOW,
	IDC_GAFB_ALLOW_FAILBACK_GROUP, IDH_PP_GROUP_AUTOFB_ALLOW,
	IDC_GAFB_FAILBACK_WHEN_DESCRIPTION, IDH_PP_GROUP_AUTOFB_ALLOW,
	IDC_GAFB_FAILBACK_IMMED, IDH_PP_GROUP_FB_IMMED,
	IDC_GAFB_FAILBACK_WINDOW, IDH_PP_GROUP_FB_WINDOW,
	IDC_GAFB_FBWIN_START, IDH_PP_GROUP_FBWIN_START,
	IDC_GAFB_FB_WINDOW_LABEL1, IDH_PP_GROUP_FBWIN_START,
	IDC_GAFB_FBWIN_END, IDH_PP_GROUP_FBWIN_END,
	IDC_GAFB_FB_WINDOW_LABEL2, IDH_PP_GROUP_FBWIN_END,
	0, 0
};

const DWORD g_aHelpIDs_IDD_GRPADV_FAILOVER[]=
{
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_GAFO_FAILOVER_DESCRIPTION, IDH_DISABLEHELP,
	IDC_GAFO_FAILOVER_THRESH_LABEL, IDH_PP_GROUP_FAILOVER_THRESH,
	IDC_GAFO_FAILOVER_THRESH, IDH_PP_GROUP_FAILOVER_THRESH,
	IDC_GAFO_FAILOVER_PERIOD_LABEL, IDH_PP_GROUP_FAILOVER_PERIOD,
	IDC_GAFO_FAILOVER_PERIOD, IDH_PP_GROUP_FAILOVER_PERIOD,
	IDC_GAFO_FAILOVER_PERIOD_LABEL2, IDH_PP_GROUP_FAILOVER_PERIOD,
	0, 0
};

const DWORD g_aHelpIDs_IDD_GRPADV_GENERAL[]=
{
	IDC_GAG_NAME_LABEL, IDH_GAG_NAME,
	IDC_GAG_NAME, IDH_GAG_NAME,
	IDC_GAG_DESC_LABEL, IDH_PP_GROUP_DESC,
	IDC_GAG_DESC, IDH_PP_GROUP_DESC,
	IDC_GAFB_PREFERRED_OWNERS_DESCRIPTION, IDH_DISABLEHELP,
	IDC_GAG_PREF_OWNERS_LABEL, IDH_PP_GROUP_PREF_OWNERS,
	IDC_GAG_PREF_OWNERS, IDH_PP_GROUP_PREF_OWNERS,
	IDC_GAG_PREF_OWNERS_MODIFY, IDH_GAG_MODIFY,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MODIFY_DEPENDENCIES[]=
{
	ADMC_IDC_LCP_LEFT_LABEL, IDH_LCP_LEFT_LIST,
	ADMC_IDC_LCP_LEFT_LIST, IDH_LCP_LEFT_LIST,
	ADMC_IDC_LCP_ADD, IDH_LCP_ADD,
	ADMC_IDC_LCP_REMOVE, IDH_LCP_REMOVE,
	ADMC_IDC_LCP_RIGHT_LABEL, IDH_LCP_RIGHT_LIST,
	ADMC_IDC_LCP_RIGHT_LIST, IDH_LCP_RIGHT_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MODIFY_POSSIBLE_OWNERS[]=
{
	ADMC_IDC_LCP_LEFT_LABEL, IDH_POSSIBLE_LCP_LEFT_LIST,
	ADMC_IDC_LCP_LEFT_LIST, IDH_POSSIBLE_LCP_LEFT_LIST,
	ADMC_IDC_LCP_ADD, IDH_POSSIBLE_LCP_ADD,
	ADMC_IDC_LCP_REMOVE, IDH_POSIBLE_LCP_REMOVE,
	ADMC_IDC_LCP_RIGHT_LABEL, IDH_POSSIBLE_LCP_RIGHT_LIST,
	ADMC_IDC_LCP_RIGHT_LIST, IDH_POSSIBLE_LCP_RIGHT_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MODIFY_PREFERRED_OWNERS[]=
{
	ADMC_IDC_LCP_LEFT_LABEL, IDH_PREF_LCP_LEFT_LIST,
	ADMC_IDC_LCP_LEFT_LIST, IDH_PREF_LCP_LEFT_LIST,
	ADMC_IDC_LCP_ADD, IDH_POSSIBLE_LCP_ADD,
	ADMC_IDC_LCP_REMOVE, IDH_POSIBLE_LCP_REMOVE,
	ADMC_IDC_LCP_RIGHT_LABEL, IDH_PREF_LCP_RIGHT_LIST,
	ADMC_IDC_LCP_RIGHT_LIST, IDH_PREF_LCP_RIGHT_LIST,
	ADMC_IDC_LCP_MOVE_UP, IDH_LCP_MOVE_UP,
	ADMC_IDC_LCP_MOVE_DOWN, IDH_LCP_MOVE_DOWN,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RES_ADVANCED[]=
{
	IDC_RES_DONT_RESTART, IDH_PP_RES_DONT_RESTART,
	IDC_RES_RESTART, IDH_PP_RES_RESTART,
	IDC_RES_RESTART_GROUP, IDH_PP_RES_RESTART,
	IDC_RES_AFFECT_THE_GROUP, IDH_PP_RES_AFFECT_THE_GROUP,
	IDC_RES_RESTART_THRESH_LABEL, IDH_PP_RES_RESTART_THRESHOLD,
	IDC_RES_RESTART_THRESHOLD, IDH_PP_RES_RESTART_THRESHOLD,
	IDC_RES_RESTART_PERIOD_LABEL, IDH_PP_RES_RESTART_PERIOD,
	IDC_RES_RESTART_PERIOD, IDH_PP_RES_RESTART_PERIOD,
	IDC_RES_RESTART_PERIOD_LABEL2, IDH_PP_RES_RESTART_PERIOD,
	IDC_RES_LOOKS_ALIVE_GROUP, IDH_PP_RES_LOOKS_ALIVE_GROUP,
	IDC_RES_DEFAULT_LOOKS_ALIVE, IDH_PP_RES_DEFAULT_LOOKS_ALIVE,
	IDC_RES_SPECIFY_LOOKS_ALIVE, IDH_PP_RES_SPECIFY_LOOKS_ALIVE,
	IDC_RES_LOOKS_ALIVE, IDH_PP_RES_LOOKS_ALIVE,
	IDC_RES_SPECIFY_LOOKS_ALIVE_LABEL, IDH_PP_RES_LOOKS_ALIVE,
	IDC_RES_IS_ALIVE_GROUP, IDH_PP_RES_IS_ALIVE_GROUP,
	IDC_RES_DEFAULT_IS_ALIVE, IDH_PP_RES_DEFAULT_IS_ALIVE,
	IDC_RES_SPECIFY_IS_ALIVE, IDH_PP_RES_SPECIFY_IS_ALIVE,
	IDC_RES_IS_ALIVE, IDH_PP_RES_IS_ALIVE,
	IDC_RES_IS_ALIVE_LABEL, IDH_PP_RES_IS_ALIVE,
	IDC_RES_PENDING_TIMEOUT_LABEL, IDH_PP_RES_PENDING_TIMEOUT,
	IDC_RES_PENDING_TIMEOUT, IDH_PP_RES_PENDING_TIMEOUT,
	IDC_RES_PENDING_TIMEOUT_LABEL2, IDH_PP_RES_PENDING_TIMEOUT,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RES_DEPENDENCIES[]=
{
	IDC_RES_NOTE, IDH_DISABLEHELP,
	IDC_RES_DEPENDS_LIST_LABEL, IDH_PP_RES_DEPENDS_LIST,
	IDC_RES_DEPENDS_LIST, IDH_PP_RES_DEPENDS_LIST,
	IDC_RES_DEPENDS_MODIFY, IDH_PP_RES_MODIFY,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RES_GENERAL[]=
{
	IDC_RES_NAME_LABEL, IDH_PP_RES_NAME,
	IDC_RES_NAME, IDH_PP_RES_NAME,
	IDC_RES_DESC_LABEL, IDH_PP_RES_DESC,
	IDC_RES_DESC, IDH_PP_RES_DESC,
	IDC_RES_POSSIBLE_OWNERS_LABEL, IDH_PP_RES_POSSIBLE_OWNERS,
	IDC_RES_POSSIBLE_OWNERS, IDH_PP_RES_POSSIBLE_OWNERS,
	IDC_RES_SEPARATE_MONITOR, IDH_PP_RES_SEPARATE_MONITOR,
	IDC_RES_POSSIBLE_OWNERS_MODIFY, IDH_RES_POSSIBLE_OWNERS_MODIFY,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RES_IP_PARAMS[]=
{
	IDC_IPADDR_PARAMS_ADDRESS_LABEL, IDH_PP_IPADDR_PARAMS_ADDRESS,
	IDC_IPADDR_PARAMS_ADDRESS, IDH_PP_IPADDR_PARAMS_ADDRESS,
	IDC_IPADDR_PARAMS_SUBNET_MASK_LABEL, IDH_PP_IPADDR_PARAMS_SUBNET_MASK,
	IDC_IPADDR_PARAMS_SUBNET_MASK, IDH_PP_IPADDR_PARAMS_SUBNET_MASK,
	IDC_IPADDR_PARAMS_NETWORK_LABEL, IDH_PP_IPADDR_PARAMS_NETWORK,
	IDC_IPADDR_PARAMS_NETWORK, IDH_PP_IPADDR_PARAMS_NETWORK,
	IDC_IPADDR_PARAMS_ENABLE_NETBIOS, IDH_PP_IPADDR_PARAMS_ENABLE_NETBIOS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RES_NETNAME_PARAMS[]=
{
	IDC_NETNAME_PARAMS_NAME_LABEL, IDH_NETNAME_PARAMS_NAME,
	IDC_NETNAME_PARAMS_NAME, IDH_RES_NETNAME_NAME,
	0, 0
};

const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_ACCESS_INFO[]=
{
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_VSAI_NETWORK_NAME_LABEL, IDH_VSAI_NETWORK_NAME,
	IDC_VSAI_NETWORK_NAME, IDH_VSAI_NETWORK_NAME,
	IDC_VSAI_IP_ADDRESS_LABEL, IDH_VSAI_IP_ADDRESS,
	IDC_VSAI_IP_ADDRESS, IDH_VSAI_IP_ADDRESS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_ADVANCED[]=
{
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_VSA_CATEGORIES_LABEL, IDH_VSA_CATEGORIES,
	IDC_VSA_CATEGORIES, IDH_VSA_CATEGORIES,
	IDC_VSA_ADVANCED_PROPS, IDH_VSA_ADVANCED_PROPS,
	IDC_WIZARD_CLICK_NEXT, IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_CREATE[]=
{
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_VSC_CREATE_NEW, IDH_VSC_CREATE_NEW,
	IDC_VSC_USE_EXISTING, IDH_VSC_USE_EXISTING,
	IDC_VSC_VIRTUAL_SERVERS_LABEL, IDH_VSC_VIRTUAL_SERVERS,
	IDC_VSC_VIRTUAL_SERVERS, IDH_VSC_VIRTUAL_SERVERS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_GROUP[]=
{
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_VSG_CREATE_NEW, IDH_VSG_CREATE_NEW,
	IDC_VSG_USE_EXISTING, IDH_VSG_USE_EXISTING,
	IDC_VSG_GROUPS_LABEL, IDH_VSG_GROUPS,
	IDC_VSG_GROUPS, IDH_VSG_GROUPS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_GROUP_NAME[]=
{
	IDC_VSGN_GROUP_NAME_TITLE, IDH_DISABLEHELP,
	IDC_VSGN_GROUP_NAME_LABEL, IDH_VSGN_GROUP_NAME,
	IDC_VSGN_GROUP_NAME, IDH_VSGN_GROUP_NAME,
	IDC_VSGN_GROUP_DESC_LABEL, IDH_VSGN_GROUP_DESC,
	IDC_VSGN_GROUP_DESC, IDH_VSGN_GROUP_DESC,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WELCOME[]=
{
	IDC_WIZARD_TITLE, IDH_DISABLEHELP,
	IDC_WIZARD_SUBTITLE_1, IDH_DISABLEHELP,
	IDC_WIZARD_SUBTITLE_2, IDH_DISABLEHELP,
	IDC_WIZARD_CLICK_NEXT, IDH_DISABLEHELP,
	0, 0
};

#else

extern const DWORD g_aHelpIDs_IDD_WELCOME[];
extern const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_CREATE[];
extern const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_GROUP[];
extern const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_GROUP_NAME[];
extern const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_ACCESS_INFO[];
extern const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_ADVANCED[];
extern const DWORD g_aHelpIDs_IDD_APP_RESOURCE_CREATE[];
extern const DWORD g_aHelpIDs_IDD_APP_RESOURCE_TYPE[];
extern const DWORD g_aHelpIDs_IDD_APP_RESOURCE_NAME_DESC[];
extern const DWORD g_aHelpIDs_IDD_APP_RESOURCE_ADVANCED[];
extern const DWORD g_aHelpIDs_IDD_COMPLETION[];
extern const DWORD g_aHelpIDs_IDD_ENTER_SUBNET_MASK[];
extern const DWORD g_aHelpIDs_IDD_MODIFY_PREFERRED_OWNERS[];
extern const DWORD g_aHelpIDs_IDD_MODIFY_POSSIBLE_OWNERS[];
extern const DWORD g_aHelpIDs_IDD_MODIFY_DEPENDENCIES[];
extern const DWORD g_aHelpIDs_IDD_GRPADV_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_GRPADV_FAILOVER[];
extern const DWORD g_aHelpIDs_IDD_GRPADV_FAILBACK[];
extern const DWORD g_aHelpIDs_IDD_RES_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_RES_DEPENDENCIES[];
extern const DWORD g_aHelpIDs_IDD_RES_ADVANCED[];
extern const DWORD g_aHelpIDs_IDD_RES_IP_PARAMS[];
extern const DWORD g_aHelpIDs_IDD_RES_NETNAME_PARAMS[];

#endif // INITHELPARRAYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\grpadv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		GrpAdv.cpp
//
//	Abstract:
//		Implementation of the class that implement the advanced group
//		property sheet.
//
//	Author:
//		David Potter (davidp)	February 26, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AtlBaseWiz.h"
#include "GrpAdv.h"
#include "LCPair.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CGroupAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

DEFINE_CLASS_NAME( CGroupAdvancedSheet )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupAdvancedSheet::BInit
//
//	Routine Description:
//		Initialize the wizard.
//
//	Arguments:
//		rgi			[IN OUT] The group info object.
//		pwiz		[IN] Wizard containing common info.
//		rbChanged	[IN OUT] TRUE = group info was changed by property sheet.
//
//	Return Value:
//		TRUE		Sheet initialized successfully.
//		FALSE		Error initializing sheet.  Error already displayed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupAdvancedSheet::BInit(
	IN OUT CClusGroupInfo &	rgi,
	IN CClusterAppWizard *	pwiz,
	IN OUT BOOL &			rbChanged
	)
{
	ASSERT( pwiz != NULL );

	BOOL bSuccess = FALSE;

	m_pgi = &rgi;
	m_pwiz = pwiz;
	m_pbChanged = &rbChanged;

	// Loop to avoid goto's.
	do
	{
		//
		// Fill the page array.
		//
		if ( ! BAddAllPages() )
		{
			break;
		} // if:  error adding pages

		//
		// Call the base class method.
		//
		if ( ! baseClass::BInit() )
		{
			break;
		} // if:  error initializing the base class

		bSuccess = TRUE;

	} while ( 0 );

	return bSuccess;

} //*** CGroupAdvancedSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupAdvancedSheet::BAddAllPages
//
//	Routine Description:
//		Add all pages to the page array.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Pages added successfully.
//		FALSE	Error adding pages.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupAdvancedSheet::BAddAllPages( void )
{
	BOOL bSuccess = FALSE;

	// Loop to avoid goto's.
	do
	{
		//
		// Add static pages.
		//
		if (   ! BAddPage( new CGroupGeneralPage )
			|| ! BAddPage( new CGroupFailoverPage )
			|| ! BAddPage( new CGroupFailbackPage )
			)
		{
			break;
		} // if:  error adding a page

		bSuccess = TRUE;

	} while ( 0 );

	return bSuccess;

} //*** CGroupAdvancedSheet::BAddAllPages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CGroupGeneralPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CGroupGeneralPage )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAG_NAME_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAG_NAME )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAG_DESC_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAG_DESC )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAG_PREF_OWNERS_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAG_PREF_OWNERS )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAG_PREF_OWNERS_MODIFY )
END_CTRL_NAME_MAP()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupGeneralPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupGeneralPage::OnInitDialog( void )
{
	//
	// Attach the controls to control member variables.
	//
	AttachControl( m_lbPreferredOwners, IDC_GAG_PREF_OWNERS );

	//
	// Get data from the sheet.
	//
	m_strName = Pgi()->RstrName();
	m_strDesc = Pgi()->RstrDescription();

	//
	// Copy the preferred owners list.
	//
	m_lpniPreferredOwners = *Pgi()->PlpniPreferredOwners();

	//
	// Fill the preferred owners list.
	//
	FillPreferredOwnersList();

	return TRUE;

} //*** CGroupGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupGeneralPage::UpdateData
//
//	Routine Description:
//		Update data on or from the page.
//
//	Arguments:
//		bSaveAndValidate	[IN] TRUE if need to read data from the page.
//								FALSE if need to set data to the page.
//
//	Return Value:
//		TRUE		The data was updated successfully.
//		FALSE		An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupGeneralPage::UpdateData( IN BOOL bSaveAndValidate )
{
	BOOL	bSuccess = TRUE;

	if ( bSaveAndValidate )
	{
		DDX_GetText( m_hWnd, IDC_GAG_NAME, m_strName );
		DDX_GetText( m_hWnd, IDC_GAG_DESC, m_strDesc );
		if ( ! DDV_RequiredText(
					m_hWnd,
					IDC_GAG_NAME,
					IDC_GAG_NAME_LABEL,
					m_strName
					) )
		{
			return FALSE;
		} // if:  error getting number
	} // if: saving data from the page
	else
	{
		DDX_SetText( m_hWnd, IDC_GAG_NAME, m_strName );
		DDX_SetText( m_hWnd, IDC_GAG_DESC, m_strDesc );
	} // else:  setting data to the page

	return bSuccess;

} //*** CGroupGeneralPage::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupGeneralPage::BApplyChanges
//
//	Routine Description:
//		Apply changes made on this page to the sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		The data was applied successfully.
//		FALSE		An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupGeneralPage::BApplyChanges( void )
{
	if (   BSaveName()
		|| BSaveDescription()
		|| BSavePreferredOwners() )
	{
		SetGroupInfoChanged();
	} // if:  user changed info

	return TRUE;

} //*** CGroupGeneralPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupGeneralPage::OnModifyPrefOwners
//
//	Routine Description:
//		Handler for the BN_CLICKED command notification on the Modify push
//		button.  Display a dialog that allows the user to modify the list of
//		preferred owners.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CGroupGeneralPage::OnModifyPrefOwners(
	WORD wNotifyCode,
	WORD idCtrl,
	HWND hwndCtrl,
	BOOL & bHandled
	)
{
	CModifyPreferredOwners dlg( Pwiz(), Pgi(), &m_lpniPreferredOwners, Pwiz()->PlpniNodes() );

	int id = dlg.DoModal( m_hWnd );
	if ( id == IDOK )
	{
		SetModified();
		m_bPreferredOwnersChanged = TRUE;
		FillPreferredOwnersList();
	} // if:  user accepted changes

	return 0;

} //*** CGroupGeneralPage::OnModifyPrefOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupGeneralPage::FillPreferredOwnersList
//
//	Routine Description:
//		Fill the list of preferred owners.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupGeneralPage::FillPreferredOwnersList( void )
{
	CWaitCursor wc;

	//
	// Make sure nodes have been collected.
	//
	if ( ! Pwiz()->BCollectNodes() )
	{
		return;
	} // if:  error collecting nodes

	//
	// Remove all items to begin with.
	//
	m_lbPreferredOwners.ResetContent();

	//
	// Add each preferred owner to the list.
	//
	CClusNodePtrList::iterator itnode;
	for ( itnode = m_lpniPreferredOwners.begin()
		; itnode != m_lpniPreferredOwners.end()
		; itnode++ )
	{
		//
		// Add the string to the list box.
		//
		m_lbPreferredOwners.AddString( (*itnode)->RstrName() );
	} // for:  each entry in the list

} //*** CGroupGeneralPage::FillPreferredOwnersList()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CGroupFailoverPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CGroupFailoverPage )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFO_FAILOVER_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFO_FAILOVER_THRESH_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFO_FAILOVER_THRESH )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFO_FAILOVER_PERIOD_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFO_FAILOVER_PERIOD )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFO_FAILOVER_PERIOD_LABEL2 )
END_CTRL_NAME_MAP()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailoverPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailoverPage::OnInitDialog( void )
{
	//
	// Attach the controls to control member variables.
	//

	//
	// Get data from the sheet.
	//
	m_nFailoverThreshold = Pgi()->NFailoverThreshold();
	m_nFailoverPeriod = Pgi()->NFailoverPeriod();

	return TRUE;

} //*** CGroupFailoverPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailoverPage::UpdateData
//
//	Routine Description:
//		Update data on or from the page.
//
//	Arguments:
//		bSaveAndValidate	[IN] TRUE if need to read data from the page.
//								FALSE if need to set data to the page.
//
//	Return Value:
//		TRUE		The data was updated successfully.
//		FALSE		An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailoverPage::UpdateData( IN BOOL bSaveAndValidate )
{
	BOOL	bSuccess = TRUE;

	if ( bSaveAndValidate )
	{
		if ( ! DDX_GetNumber(
					m_hWnd,
					IDC_GAFO_FAILOVER_THRESH,
					m_nFailoverThreshold,
					CLUSTER_GROUP_MINIMUM_FAILOVER_THRESHOLD,
					CLUSTER_GROUP_MAXIMUM_FAILOVER_THRESHOLD,
					FALSE		// bSigned
					) )
		{
			return FALSE;
		} // if:  error getting number
		if ( ! DDX_GetNumber(
					m_hWnd,
					IDC_GAFO_FAILOVER_PERIOD,
					m_nFailoverPeriod,
					CLUSTER_GROUP_MINIMUM_FAILOVER_PERIOD,
					CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD,
					FALSE		// bSigned
					) )
		{
			return FALSE;
		} // if:  error getting number
	} // if: saving data from the page
	else
	{
		DDX_SetNumber(
			m_hWnd,
			IDC_GAFO_FAILOVER_THRESH,
			m_nFailoverThreshold,
			CLUSTER_GROUP_MINIMUM_FAILOVER_THRESHOLD,
			CLUSTER_GROUP_MAXIMUM_FAILOVER_THRESHOLD,
			FALSE		// bSigned
			);
		DDX_SetNumber(
			m_hWnd,
			IDC_GAFO_FAILOVER_PERIOD,
			m_nFailoverPeriod,
			CLUSTER_GROUP_MINIMUM_FAILOVER_PERIOD,
			CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD,
			FALSE		// bSigned
			);
	} // else:  setting data to the page

	return bSuccess;

} //*** CGroupFailoverPage::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailoverPage::BApplyChanges
//
//	Routine Description:
//		Apply changes made on this page to the sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		The data was applied successfully.
//		FALSE		An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailoverPage::BApplyChanges( void )
{
	if ( Pgi()->BSetFailoverProperties( m_nFailoverThreshold, m_nFailoverPeriod ) )
	{
		SetGroupInfoChanged();
	} // if:  user changed info

	return TRUE;

} //*** CGroupFailoverPage::BApplyChanges()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CGroupFailbackPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CGroupFailbackPage )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FAILBACK_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_PREVENT_FAILBACK )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_ALLOW_FAILBACK_GROUP )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_ALLOW_FAILBACK )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FAILBACK_WHEN_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FAILBACK_IMMED )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FAILBACK_WINDOW )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FBWIN_START )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FBWIN_START_SPIN )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FB_WINDOW_LABEL1 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FBWIN_END )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FBWIN_END_SPIN )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FB_WINDOW_LABEL2 )
END_CTRL_NAME_MAP()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailbackPage::OnInitDialog( void )
{
	//
	// Attach the controls to control member variables.
	//
	AttachControl( m_rbPreventFailback,			IDC_GAFB_PREVENT_FAILBACK );
	AttachControl( m_rbAllowFailback,			IDC_GAFB_ALLOW_FAILBACK );
	AttachControl( m_staticFailbackWhenDesc,	IDC_GAFB_FAILBACK_WHEN_DESCRIPTION );
	AttachControl( m_rbFBImmed,					IDC_GAFB_FAILBACK_IMMED );
	AttachControl( m_rbFBWindow,				IDC_GAFB_FAILBACK_WINDOW );
	AttachControl( m_editStart,					IDC_GAFB_FBWIN_START );
	AttachControl( m_spinStart,					IDC_GAFB_FBWIN_START_SPIN );
	AttachControl( m_staticWindowAnd,			IDC_GAFB_FB_WINDOW_LABEL1 );
	AttachControl( m_editEnd,					IDC_GAFB_FBWIN_END );
	AttachControl( m_spinEnd,					IDC_GAFB_FBWIN_END_SPIN );
	AttachControl( m_staticWindowUnits,			IDC_GAFB_FB_WINDOW_LABEL2 );

	//
	// Get data from the sheet.
	//
	m_cgaft = Pgi()->CgaftAutoFailbackType();
	m_nStart = Pgi()->NFailbackWindowStart();
	m_nEnd = Pgi()->NFailbackWindowEnd();
	m_bNoFailbackWindow = (    (m_cgaft == ClusterGroupPreventFailback)
							|| (m_nStart == CLUSTER_GROUP_FAILBACK_WINDOW_NONE)
							|| (m_nEnd == CLUSTER_GROUP_FAILBACK_WINDOW_NONE) );

	return TRUE;

} //*** CGroupFailbackPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::UpdateData
//
//	Routine Description:
//		Update data on or from the page.
//
//	Arguments:
//		bSaveAndValidate	[IN] TRUE if need to read data from the page.
//								FALSE if need to set data to the page.
//
//	Return Value:
//		TRUE		The data was updated successfully.
//		FALSE		An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailbackPage::UpdateData( IN BOOL bSaveAndValidate )
{
	BOOL	bSuccess = TRUE;

	if ( bSaveAndValidate )
	{
		//
		// If failback is allowed, make sure there is a preferred owner
		// and validate the failback window.
		//
		if ( m_cgaft == ClusterGroupAllowFailback )
		{
			//
			// Make sure there is a preferred owner.
			//

			//
			// If there is a failback window, validate it.
			//
			if ( ! m_bNoFailbackWindow )
			{
				if ( ! DDX_GetNumber(
							m_hWnd,
							IDC_GAFB_FBWIN_START,
							m_nStart,
							0,		// nMin
							CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START,
							TRUE	// bSigned
							) )
				{
					return FALSE;
				} // if:  error getting number
				if ( ! DDX_GetNumber(
							m_hWnd,
							IDC_GAFB_FBWIN_END,
							m_nEnd,
							0,		// nMin
							CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END,
							TRUE	// bSigned
							) )
				{
					return FALSE;
				} // if:  error getting number
				if ( m_nStart == m_nEnd )
				{
					AppMessageBox( m_hWnd, IDS_ERROR_SAME_START_AND_END, MB_OK | MB_ICONEXCLAMATION );
					m_editStart.SetFocus();
					m_editStart.SetSel( 0, -1, FALSE );
					return FALSE;
				}  // if:  values are the same
			} // if:  there is a failback window
		} // if:  failback is allowed
	} // if: saving data from the page
	else
	{
		BOOL bHandled;
		if ( m_cgaft == ClusterGroupPreventFailback )
		{
			m_rbPreventFailback.SetCheck( BST_CHECKED );
			m_rbAllowFailback.SetCheck( BST_UNCHECKED );
			OnClickedPreventFailback( 0, 0, 0, bHandled );
		}  // if:  failbacks are not allowed
		else
		{
			m_rbPreventFailback.SetCheck( BST_UNCHECKED );
			m_rbAllowFailback.SetCheck( BST_CHECKED );
			OnClickedAllowFailback( 0, 0, 0, bHandled );
		}  // else:  failbacks are allowed
		m_rbFBImmed.SetCheck( m_bNoFailbackWindow ? BST_CHECKED : BST_UNCHECKED );
		m_rbFBWindow.SetCheck( m_bNoFailbackWindow ? BST_UNCHECKED : BST_CHECKED );

		// Set up the Start and End window controls.
		DDX_SetNumber(
			m_hWnd,
			IDC_GAFB_FBWIN_START,
			m_nStart,
			0,		// nMin
			CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START,
			FALSE	// bSigned
			);
		DDX_SetNumber(
			m_hWnd,
			IDC_GAFB_FBWIN_END,
			m_nEnd,
			0,		// nMin
			CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END,
			FALSE	// bSigned
			);
		m_spinStart.SetRange( 0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START );
		m_spinEnd.SetRange( 0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END );
		if ( m_nStart == CLUSTER_GROUP_FAILBACK_WINDOW_NONE )
		{
			m_editStart.SetWindowText( _T("") );
		} // if:  no start window
		if ( m_nEnd == CLUSTER_GROUP_FAILBACK_WINDOW_NONE )
		{
			m_editEnd.SetWindowText( _T("") );
		} // if:  no end window
	} // else:  setting data to the page

	return bSuccess;

} //*** CGroupFailbackPage::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::BApplyChanges
//
//	Routine Description:
//		Apply changes made on this page to the sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		The data was applied successfully.
//		FALSE		An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailbackPage::BApplyChanges( void )
{
	if ( m_bNoFailbackWindow )
	{
		m_nStart = CLUSTER_GROUP_FAILBACK_WINDOW_NONE;
		m_nEnd = CLUSTER_GROUP_FAILBACK_WINDOW_NONE;
	}  // if:  no failback window

	if ( Pgi()->BSetFailbackProperties( m_cgaft, m_nStart, m_nEnd ) )
	{
		SetGroupInfoChanged();
	} // if:  user changed info

	return TRUE;

} //*** CGroupFailbackPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::OnClickedPreventFailback
//
//	Routine Description:
//		Handler for the BN_CLICKED command notification on the PREVENT radio
//		button.  Disable controls in the ALLOW group.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CGroupFailbackPage::OnClickedPreventFailback(
	WORD wNotifyCode,
	WORD idCtrl,
	HWND hwndCtrl,
	BOOL & bHandled
	)
{
	BOOL bHandledX;

	m_staticFailbackWhenDesc.EnableWindow( FALSE );
	m_rbFBImmed.EnableWindow( FALSE );
	m_rbFBWindow.EnableWindow( FALSE );

	OnClickedFailbackImmediate( 0, 0, 0, bHandledX );

	m_editStart.EnableWindow( FALSE );
	m_spinStart.EnableWindow( FALSE );
	m_staticWindowAnd.EnableWindow( FALSE );
	m_editEnd.EnableWindow( FALSE );
	m_spinEnd.EnableWindow( FALSE );
	m_staticWindowUnits.EnableWindow( FALSE );

	if ( m_cgaft != ClusterGroupPreventFailback ) 
	{
		m_cgaft = ClusterGroupPreventFailback;
		SetModified( TRUE );
	} // if:  value changed

	return 0;

} //*** CGroupFailbackPage::OnClickedPreventFailback()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::OnClickedAllowFailback
//
//	Routine Description:
//		Handler for the BN_CLICKED command notification on the ALLOW radio
//		button.  Enable controls in the ALLOW group.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CGroupFailbackPage::OnClickedAllowFailback(
	WORD wNotifyCode,
	WORD idCtrl,
	HWND hwndCtrl,
	BOOL & bHandled
	)
{
	BOOL bHandledX;

	m_staticFailbackWhenDesc.EnableWindow( TRUE );
	m_rbFBImmed.EnableWindow( TRUE );
	m_rbFBWindow.EnableWindow( TRUE );

	if ( m_bNoFailbackWindow )
	{
		OnClickedFailbackImmediate( 0, 0, 0, bHandledX );
	} // if:  no failback window
	else
	{
		OnClickedFailbackInWindow( 0, 0, 0, bHandledX );
	} // else:  failback window specified


	if ( m_cgaft != ClusterGroupAllowFailback )
	{
		m_cgaft = ClusterGroupAllowFailback;
		SetModified( TRUE );
	} // if:  value changed

	return 0;

} //*** CGroupFailbackPage::OnClickedAllowFailback()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::OnClickedFailbackImmediate
//
//	Routine Description:
//		Handler for the BN_CLICKED command notification on the IMMEDIATE radio
//		button.  Disable the 'failback in time window' controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CGroupFailbackPage::OnClickedFailbackImmediate(
	WORD wNotifyCode,
	WORD idCtrl,
	HWND hwndCtrl,
	BOOL & bHandled
	)
{
	m_editStart.EnableWindow( FALSE );
	m_spinStart.EnableWindow( FALSE );
	m_staticWindowAnd.EnableWindow( FALSE );
	m_editEnd.EnableWindow( FALSE );
	m_spinEnd.EnableWindow( FALSE );
	m_staticWindowUnits.EnableWindow( FALSE );

	if ( ! m_bNoFailbackWindow )
	{
		m_bNoFailbackWindow = TRUE;
		SetModified( TRUE );
	} // if:  value changed

	return 0;

} //*** CGroupFailbackPage::OnClickedFailbackImmediate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::OnClickedFailbackInWindow
//
//	Routine Description:
//		Handler for the BN_CLICKED command notification on the IN WINDOW radio
//		button.  Enable the 'failback in time window' controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CGroupFailbackPage::OnClickedFailbackInWindow(
	WORD wNotifyCode,
	WORD idCtrl,
	HWND hwndCtrl,
	BOOL & bHandled
	)
{
	m_editStart.EnableWindow( TRUE );
	m_spinStart.EnableWindow( TRUE );
	m_staticWindowAnd.EnableWindow( TRUE );
	m_editEnd.EnableWindow( TRUE );
	m_spinEnd.EnableWindow( TRUE );
	m_staticWindowUnits.EnableWindow( TRUE );

	if ( m_bNoFailbackWindow )
	{
		// Set the values of the edit controls.
		if ( m_nStart == CLUSTER_GROUP_FAILBACK_WINDOW_NONE )
		{
			SetDlgItemInt( IDC_GAFB_FBWIN_START, 0, FALSE );
		} // if:  no failback window
		if ( m_nEnd == CLUSTER_GROUP_FAILBACK_WINDOW_NONE )
		{
			SetDlgItemInt( IDC_GAFB_FBWIN_END, 0, FALSE );
		} // if:  no failback window

		m_bNoFailbackWindow = FALSE;
		SetModified( TRUE );
	} // if:  value changed

	return 0;

} //*** CGroupFailbackPage::OnClickedFailbackInWindow()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\proplists.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		PropListS.cpp
//
//	Abstract:
//		Stub for implementation of property list classes.
//
//	Author:
//		David Potter (davidp)	February 24, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "PropList.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\helpids.h ===
// This file is used by CLADMWIZ.RC
//
// Created in Dev. Studio by Melissa Simmons, 4/7/99

//text unique to this wizard
#define IDH_ARC_CREATE_RES 700003000
#define IDH_ARC_DONT_CREATE_RES 700003001
#define IDH_ARND_ADVANCED_PROPS 700003027
#define IDH_ARND_RES_DESC 700003026
#define IDH_ARND_RES_NAME 700003025
#define IDH_ART_RESTYPES 700003050
#define IDH_ESM_IP_ADDRESS 700003100
#define IDH_ESM_SUBNET_MASK 700003101
#define IDH_RES_POSSIBLE_OWNERS_MODIFY 700003328
#define IDH_VSA_ADVANCED_PROPS 700003426
#define IDH_VSA_CATEGORIES 700003425
#define IDH_VSAI_IP_ADDRESS 700003401
#define IDH_VSAI_NETWORK_NAME 700003400
#define IDH_ESM_NETWORKS 700003402
#define IDH_VSC_CREATE_NEW 700003450
#define IDH_VSC_USE_EXISTING 700003451
#define IDH_VSC_VIRTUAL_SERVERS 700003452
#define IDH_VSG_CREATE_NEW 700003475
#define IDH_VSG_GROUPS 700003477
#define IDH_VSG_USE_EXISTING 700003476
#define IDH_VSGN_GROUP_DESC 700003501
#define IDH_VSGN_GROUP_NAME 700003500
#define IDH_WIZARD_LISTBOX 700003075
#define IDH_GAG_MODIFY 700003080
#define IDH_RES_NETNAME_NAME 700003090
#define IDH_GAG_NAME 700003175
#define IDH_NETNAME_PARAMS_NAME 700003375
//borrowed text
#define	IDH_PP_GROUP_AUTOFB_ALLOW	700001276
#define	IDH_PP_GROUP_AUTOFB_PREVENT	700001275
#define	IDH_PP_GROUP_FB_IMMED	700001277
#define	IDH_PP_GROUP_FB_WINDOW	700001278
#define	IDH_PP_GROUP_FBWIN_END	700001280
#define	IDH_PP_GROUP_FBWIN_START	700001279
//borrowed text
#define	IDH_PP_GROUP_FAILOVER_PERIOD	700001301
#define	IDH_PP_GROUP_FAILOVER_THRESH	700001300
//borrowed text
#define	IDH_PP_GROUP_DESC	700001326
#define	IDH_PP_GROUP_PREF_OWNERS	700001327
#define	IDH_PP_GROUP_PREF_OWNERS_MODIFY	700001328
//borrowed text
#define	IDH_LCP_ADD	700001076
#define	IDH_LCP_LEFT_LIST	700001075
#define	IDH_LCP_REMOVE	700001077
#define	IDH_LCP_RIGHT_LIST	700001078
//borrowed text
#define	IDH_POSIBLE_LCP_REMOVE	700001102
#define	IDH_POSSIBLE_LCP_ADD	700001101
#define	IDH_POSSIBLE_LCP_LEFT_LIST	700001100
#define	IDH_POSSIBLE_LCP_RIGHT_LIST	700001103
//borrowed text
#define	IDH_PREF_LCP_LEFT_LIST	700001125
#define	IDH_PREF_LCP_RIGHT_LIST	700001128
#define	IDH_LCP_MOVE_DOWN	700001130
#define	IDH_LCP_MOVE_UP	700001129
//borrowed text
#define	IDH_PP_RES_AFFECT_THE_GROUP	700001437
#define	IDH_PP_RES_DONT_RESTART	700001435
#define	IDH_PP_RES_RESTART	700001436
#define	IDH_PP_RES_RESTART_THRESHOLD	70000143
#define	IDH_PP_RES_RESTART_PERIOD	700001425
#define	IDH_PP_RES_LOOKS_ALIVE_GROUP	700001426
#define	IDH_PP_RES_DEFAULT_LOOKS_ALIVE	700001427
#define	IDH_PP_RES_SPECIFY_LOOKS_ALIVE	700001428
#define	IDH_PP_RES_LOOKS_ALIVE	700001429
#define	IDH_PP_RES_IS_ALIVE_GROUP	700001430
#define	IDH_PP_RES_DEFAULT_IS_ALIVE	700001431
#define	IDH_PP_RES_SPECIFY_IS_ALIVE	700001432
#define	IDH_PP_RES_IS_ALIVE	700001433
#define	IDH_PP_RES_PENDING_TIMEOUT	700001434
//borrowed text
#define	IDH_PP_RES_DEPENDS_LIST	700001450
#define	IDH_PP_RES_MODIFY	700001451
//borrowed text
#define	IDH_PP_RES_NAME	700001475
#define	IDH_PP_RES_DESC	700001476
#define	IDH_PP_RES_POSSIBLE_OWNERS	700001477
#define	IDH_PP_RES_SEPARATE_MONITOR	700001479
//borrowed text
#define	IDH_PP_IPADDR_PARAMS_ADDRESS	700000200
#define	IDH_PP_IPADDR_PARAMS_ENABLE_NETBIOS	700000203
#define	IDH_PP_IPADDR_PARAMS_NETWORK	700000202
#define	IDH_PP_IPADDR_PARAMS_SUBNET_MASK	700000201
//borrowed text
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\helpdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		HelpData.h
//
//	Abstract:
//		Definitions for data required for implementing help.
//
//	Author:
//		Galen Barbee (galenb)	May 19, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __HELPDATA_H_
#define __HELPDATA_H_

#include "HelpArr.h"

/////////////////////////////////////////////////////////////////////////////

#endif // __HELPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\resadv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1999 Microsoft Corporation
//
//  Module Name:
//      ResAdv.cpp
//
//  Abstract:
//      Implementation of the advanced resource property sheet classes.
//
//  Author:
//      David Potter (davidp)   March 6, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ResAdv.h"
#include "AdmNetUtils.h"    // for BIsValidxxx network functions
#include "AtlUtil.h"        // for DDX/DDV routines
#include "LCPair.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

DEFINE_CLASS_NAME( CGeneralResourceAdvancedSheet )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGeneralResourceAdvancedSheet::BAddAllPages
//
//  Routine Description:
//      Add all pages to the page array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Pages added successfully.
//      FALSE   Error adding pages.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGeneralResourceAdvancedSheet::BAddAllPages( void )
{
    BOOL bSuccess = FALSE;

    // Loop to avoid goto's.
    do
    {
        //
        // Add static pages.
        //
        if (   ! BAddPage( new CGeneralResourceGeneralPage )
            || ! BAddPage( new CGeneralResourceDependenciesPage )
            || ! BAddPage( new CGeneralResourceAdvancedPage )
            )
        {
            break;
        } // if:  error adding a page

        bSuccess = TRUE;

    } while ( 0 );

    return bSuccess;

} //*** CGeneralResourceAdvancedSheet::BAddAllPages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CIPAddrAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

DEFINE_CLASS_NAME( CIPAddrAdvancedSheet )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrAdvancedSheet::BAddAllPages
//
//  Routine Description:
//      Add all pages to the page array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Pages added successfully.
//      FALSE   Error adding pages.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIPAddrAdvancedSheet::BAddAllPages( void )
{
    BOOL bSuccess = FALSE;

    // Loop to avoid goto's.
    do
    {
        //
        // Add static pages.
        //
        if (   ! BAddPage( new CGeneralResourceGeneralPage )
            || ! BAddPage( new CGeneralResourceDependenciesPage )
            || ! BAddPage( new CGeneralResourceAdvancedPage )
            || ! BAddPage( new CIPAddrParametersPage )
            )
        {
            break;
        } // if:  error adding a page

        bSuccess = TRUE;

    } while ( 0 );

    return bSuccess;

} //*** CIPAddrAdvancedSheet::BAddAllPages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CNetNameAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

DEFINE_CLASS_NAME( CNetNameAdvancedSheet )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetNameAdvancedSheet::BAddAllPages
//
//  Routine Description:
//      Add all pages to the page array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Pages added successfully.
//      FALSE   Error adding pages.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetNameAdvancedSheet::BAddAllPages( void )
{
    BOOL bSuccess = FALSE;

    // Loop to avoid goto's.
    do
    {
        //
        // Add static pages.
        //
        if (   ! BAddPage( new CGeneralResourceGeneralPage )
            || ! BAddPage( new CGeneralResourceDependenciesPage )
            || ! BAddPage( new CGeneralResourceAdvancedPage )
            || ! BAddPage( new CNetNameParametersPage )
            )
        {
            break;
        } // if:  error adding a page

        bSuccess = TRUE;

    } while ( 0 );

    return bSuccess;

} //*** CNetNameAdvancedSheet::BAddAllPages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CResourceGeneralPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceGeneralPage< T, TSht >::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_lbPossibleOwners,          IDC_RES_POSSIBLE_OWNERS );
    AttachControl( m_pbModifyPossibleOwners,    IDC_RES_POSSIBLE_OWNERS_MODIFY );

    //
    // Get data from the sheet.
    //
    m_strName = Pri()->RstrName();
    m_strDesc = Pri()->RstrDescription();
    m_bSeparateMonitor = Pri()->BSeparateMonitor();

    //
    // Copy the possible owners list.
    //
    m_lpniPossibleOwners = *Pri()->PlpniPossibleOwners();

    //
    // Fill the possible owners list.
    //
    FillPossibleOwnersList();

    return TRUE;

} //*** CResourceGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceGeneralPage< T, TSht >::UpdateData( IN BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    if ( bSaveAndValidate )
    {
        DDX_GetText( m_hWnd, IDC_RES_NAME, m_strName );
        DDX_GetText( m_hWnd, IDC_RES_DESC, m_strDesc );
        DDX_GetCheck( m_hWnd, IDC_RES_SEPARATE_MONITOR, m_bSeparateMonitor );
        if ( ! DDV_RequiredText(
                    m_hWnd,
                    IDC_RES_NAME,
                    IDC_RES_NAME_LABEL,
                    m_strName
                    ) )
        {
            return FALSE;
        } // if:  error getting number
    } // if: saving data from the page
    else
    {
        DDX_SetText( m_hWnd, IDC_RES_NAME, m_strName );
        DDX_SetText( m_hWnd, IDC_RES_DESC, m_strDesc );
        DDX_SetCheck( m_hWnd, IDC_RES_SEPARATE_MONITOR, m_bSeparateMonitor );
    } // else:  setting data to the page

    return bSuccess;

} //*** CResourceGeneralPage::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceGeneralPage< T, TSht >::BApplyChanges( void )
{
    if (   BSaveName()
        || BSaveDescription()
        || BSaveSeparateMonitor()
        || BSavePossibleOwners() )
    {
        SetResInfoChanged();
    } // if:  data changed

    return TRUE;

} //*** CResourceGeneralPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnModify
//
//  Routine Description:
//      Handler for BN_CLICKED on the MODIFY push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Ignored.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
LRESULT CResourceGeneralPage< T, TSht >::OnModify(
    WORD /*wNotifyCode*/,
    WORD /*idCtrl*/,
    HWND /*hwndCtrl*/,
    BOOL & /*bHandled*/
    )
{
    CModifyPossibleOwners dlg( Pwiz(), Pri(), &m_lpniPossibleOwners, Pwiz()->PlpniNodes() );

    int id = dlg.DoModal( m_hWnd );
    if ( id == IDOK )
    {
        SetModified();
        m_bPossibleOwnersChanged = TRUE;
        FillPossibleOwnersList();
    } // if:  user accepted changes

    return 0;

} //*** CResourceGeneralPage::OnModify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::FillPossibleOwnersList
//
//  Routine Description:
//      Fill the list of possible owners.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
void CResourceGeneralPage< T, TSht >::FillPossibleOwnersList( void )
{
    CWaitCursor wc;

    //
    // Make sure nodes have been collected.
    //
    if ( ! Pwiz()->BCollectNodes() )
    {
        return;
    } // if:  error collecting nodes

    //
    // Remove all items to begin with.
    //
    m_lbPossibleOwners.ResetContent();

    //
    // Add each possible owner to the list.
    //
    CClusNodePtrList::iterator itnode;
    for ( itnode = m_lpniPossibleOwners.begin()
        ; itnode != m_lpniPossibleOwners.end()
        ; itnode++ )
    {
        //
        // Add the string to the list box.
        //
        m_lbPossibleOwners.AddString( (*itnode)->RstrName() );
    } // for:  each entry in the list

} //*** CResourceGeneralPage::FillPossibleOwnersList()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceGeneralPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CGeneralResourceGeneralPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_NAME_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_NAME )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DESC_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DESC )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_POSSIBLE_OWNERS )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_POSSIBLE_OWNERS_MODIFY )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SEPARATE_MONITOR )
END_CTRL_NAME_MAP()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CIPAddrResourceGeneralPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CIPAddrResourceGeneralPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_NAME_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_NAME )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DESC_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DESC )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_POSSIBLE_OWNERS )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_POSSIBLE_OWNERS_MODIFY )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SEPARATE_MONITOR )
END_CTRL_NAME_MAP()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CResourceDependenciesPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependenciesPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceDependenciesPage< T, TSht >::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_lvcDependencies, IDC_RES_DEPENDS_LIST );

    //
    // Copy the dependencies list.
    //
    m_lpriDependencies = *Pri()->PlpriDependencies();

    //
    // Copy the list of resources in the group and remove our entry.
    //
    {
        m_lpriResourcesInGroup = *Pri()->Pgi()->PlpriResources();
        CClusResPtrList::iterator itCurrent = m_lpriResourcesInGroup.begin();
        CClusResPtrList::iterator itLast = m_lpriResourcesInGroup.end();
        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            CClusResInfo * pri = *itCurrent;
            if ( pri->RstrName().CompareNoCase( Pri()->RstrName() ) == 0 )
            {
                m_lpriResourcesInGroup.erase( itCurrent );
                break;
            } // if:  found this resource in the list
        } // for:  each entry in the list
    } // Copy the list of resources in the group and remove our entry

    //
    // Initialize and add columns to the dependencies list view control.
    //
    {
        DWORD       dwExtendedStyle;
        CString     strColText;

        //
        // Change list view control extended styles.
        //
        dwExtendedStyle = m_lvcDependencies.GetExtendedListViewStyle();
        m_lvcDependencies.SetExtendedListViewStyle(
            LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP,
            LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP
            );

        //
        // Insert the Resource Name column.
        //
        strColText.LoadString( IDS_COLTEXT_RESOURCE_NAME );
        m_lvcDependencies.InsertColumn( 0, strColText, LVCFMT_LEFT, 125 * 3 / 2, -1 );

        //
        // Insert the Resource Type column.
        //
        strColText.LoadString( IDS_COLTEXT_RESOURCE_TYPE );
        m_lvcDependencies.InsertColumn( 1, strColText, LVCFMT_LEFT, 100 * 3 / 2, -1 );

    } // Add columns

    //
    // Fill the dependencies list.
    //
    FillDependenciesList();

    return TRUE;

} //*** CResourceDependenciesPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependenciesPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceDependenciesPage< T, TSht >::BApplyChanges( void )
{
    if ( BSaveDependencies() )
    {
        SetResInfoChanged();
    } // if:  dependencies changed

    return TRUE;

} //*** CResourceDependenciesPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependenciesPage::OnModify
//
//  Routine Description:
//      Handler for BN_CLICKED on the MODIFY push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Ignored.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
LRESULT CResourceDependenciesPage< T, TSht >::OnModify(
    WORD /*wNotifyCode*/,
    WORD /*idCtrl*/,
    HWND /*hwndCtrl*/,
    BOOL & /*bHandled*/
    )
{
    CModifyDependencies dlg( Pwiz(), Pri(), &m_lpriDependencies, &m_lpriResourcesInGroup );

    int id = dlg.DoModal( m_hWnd );
    if ( id == IDOK )
    {
        SetModified();
        m_bDependenciesChanged = TRUE;
        FillDependenciesList();
    } // if:  user accepted changes

    return 0;

} //*** CResourceDependenciesPage::OnModify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependenciesPage::FillDependenciesList
//
//  Routine Description:
//      Fill the list of possible owners.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
void CResourceDependenciesPage< T, TSht >::FillDependenciesList( void )
{
    CWaitCursor wc;
    int         idx;

    //
    // Remove all items to begin with.
    //
    m_lvcDependencies.DeleteAllItems();

    //
    // Add each dependency to the list.
    //
    CClusResPtrList::iterator itCurrent = m_lpriDependencies.begin();
    CClusResPtrList::iterator itLast = m_lpriDependencies.end();
    for ( ; itCurrent  != itLast ; itCurrent++ )
    {
        //
        // Add the string to the list control.
        //
        CClusResInfo * pri = *itCurrent;
        ASSERT( pri->Prti() != NULL );
        idx = m_lvcDependencies.InsertItem( 0, pri->RstrName() );
        m_lvcDependencies.SetItemText( idx, 1, pri->Prti()->RstrName() );

        m_lvcDependencies.SetItemData( idx, (DWORD_PTR)pri );

    } // for:  each entry in the list

} //*** CResourceDependenciesPage::FillDependenciesList()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceDependenciesPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CGeneralResourceDependenciesPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_NOTE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEPENDS_LIST_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEPENDS_LIST )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEPENDS_MODIFY )
END_CTRL_NAME_MAP()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CIPAddrResourceDependenciesPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CIPAddrResourceDependenciesPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_NOTE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEPENDS_LIST_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEPENDS_LIST )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEPENDS_MODIFY )
END_CTRL_NAME_MAP()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CResourceAdvancedPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceAdvancedPage< T, TSht >::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_rbDontRestart,         IDC_RES_DONT_RESTART );
    AttachControl( m_rbRestart,             IDC_RES_RESTART );
    AttachControl( m_editThreshold,         IDC_RES_RESTART_THRESHOLD );
    AttachControl( m_editPeriod,            IDC_RES_RESTART_PERIOD );
    AttachControl( m_ckbAffectTheGroup,     IDC_RES_AFFECT_THE_GROUP );
    AttachControl( m_rbDefaultLooksAlive,   IDC_RES_DEFAULT_LOOKS_ALIVE );
    AttachControl( m_rbSpecifyLooksAlive,   IDC_RES_SPECIFY_LOOKS_ALIVE );
    AttachControl( m_editLooksAlive,        IDC_RES_LOOKS_ALIVE );
    AttachControl( m_rbDefaultIsAlive,      IDC_RES_DEFAULT_IS_ALIVE );
    AttachControl( m_rbSpecifyIsAlive,      IDC_RES_SPECIFY_IS_ALIVE );
    AttachControl( m_editIsAlive,           IDC_RES_IS_ALIVE );
    AttachControl( m_editPendingTimeout,    IDC_RES_PENDING_TIMEOUT );

    //
    // Get data from the sheet.
    //
    m_crraRestartAction = Pri()->CrraRestartAction();
    m_nThreshold = Pri()->NRestartThreshold();
    m_nPeriod = Pri()->NRestartPeriod() / 1000; // display units are seconds, stored units are milliseconds
    m_nLooksAlive = Pri()->NLooksAlive();
    m_nIsAlive = Pri()->NIsAlive();
    m_nPendingTimeout = Pri()->NPendingTimeout() / 1000; // display units are seconds, stored units are milliseconds

    switch ( m_crraRestartAction )
    {
        case ClusterResourceDontRestart:
            m_nRestart = 0;
            break;
        case ClusterResourceRestartNoNotify:
            m_nRestart = 1;
            break;
        case ClusterResourceRestartNotify:
            m_nRestart = 1;
            m_bAffectTheGroup = TRUE;
            break;
    } // switch:  restart action

    return TRUE;

} //*** CResourceAdvancedPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceAdvancedPage< T, TSht >::UpdateData( IN BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    if ( bSaveAndValidate )
    {
        DDX_GetRadio( m_hWnd, IDC_RES_DONT_RESTART, m_nRestart );
        DDX_GetCheck( m_hWnd, IDC_RES_AFFECT_THE_GROUP, m_bAffectTheGroup );

        //if (!BReadOnly())
        //{
            if ( m_nRestart == 1 )
            {
                DDX_GetNumber(
                    m_hWnd,
                    IDC_RES_RESTART_THRESHOLD,
                    m_nThreshold,
                    CLUSTER_RESOURCE_MINIMUM_RESTART_THRESHOLD,
                    CLUSTER_RESOURCE_MAXIMUM_RESTART_THRESHOLD,
                    FALSE /*bSigned*/
                    );
                DDX_GetNumber(
                    m_hWnd,
                    IDC_RES_RESTART_PERIOD,
                    m_nPeriod,
                    CLUSTER_RESOURCE_MINIMUM_RESTART_PERIOD,
                    CLUSTER_RESOURCE_MAXIMUM_RESTART_PERIOD / 1000, // display units are seconds, stored units are milliseconds
                    FALSE /*bSigned*/
                    );
            }  // if:  restart is enabled

            if ( m_rbDefaultLooksAlive.GetCheck() == BST_CHECKED )
            {
                m_nLooksAlive = CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL;
            } // if:  Default Looks Alive checkbox checked
            else
            {
                DDX_GetNumber(
                    m_hWnd,
                    IDC_RES_LOOKS_ALIVE,
                    m_nLooksAlive,
                    CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE,
                    CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE_UI,
                    FALSE /*bSigned*/
                    );
            } // else:  Specify Looks Alive checkbox checked

            if ( m_rbDefaultIsAlive.GetCheck() == BST_CHECKED )
            {
                m_nIsAlive = CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL;
            } // if:  Default Is Alive checkbox checked
            else
            {
                DDX_GetNumber(
                    m_hWnd,
                    IDC_RES_IS_ALIVE,
                    m_nIsAlive,
                    CLUSTER_RESOURCE_MINIMUM_IS_ALIVE,
                    CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE_UI,
                    FALSE /*bSigned*/
                    );
            } // else:  Specify Is Alive checkbox checked

            DDX_GetNumber(
                m_hWnd,
                IDC_RES_PENDING_TIMEOUT,
                m_nPendingTimeout,
                CLUSTER_RESOURCE_MINIMUM_PENDING_TIMEOUT,
                CLUSTER_RESOURCE_MAXIMUM_PENDING_TIMEOUT / 1000, // display units are seconds, stored units are milliseconds
                FALSE /*bSigned*/
                );
        //}  // if:  not read only
    } // if: saving data from the page
    else
    {
        int     nDefault;
        int     nSpecify;
        BOOL    bReadOnly;

        DDX_SetNumber(
            m_hWnd,
            IDC_RES_RESTART_THRESHOLD,
            m_nThreshold,
            CLUSTER_RESOURCE_MINIMUM_RESTART_THRESHOLD,
            CLUSTER_RESOURCE_MAXIMUM_RESTART_THRESHOLD,
            FALSE /*bSigned*/
            );
        DDX_SetNumber(
            m_hWnd,
            IDC_RES_RESTART_PERIOD,
            m_nPeriod,
            CLUSTER_RESOURCE_MINIMUM_RESTART_PERIOD,
            CLUSTER_RESOURCE_MAXIMUM_RESTART_PERIOD / 1000, // display units are seconds, stored units are milliseconds
            FALSE /*bSigned*/
            );
        DDX_SetNumber(
            m_hWnd,
            IDC_RES_PENDING_TIMEOUT,
            m_nPendingTimeout,
            CLUSTER_RESOURCE_MINIMUM_PENDING_TIMEOUT,
            CLUSTER_RESOURCE_MAXIMUM_PENDING_TIMEOUT / 1000, // display units are seconds, stored units are milliseconds
            FALSE /*bSigned*/
            );

        if ( m_nRestart == 0 )
        {
            m_rbDontRestart.SetCheck( BST_CHECKED );
            m_rbRestart.SetCheck( BST_UNCHECKED );
            OnClickedDontRestart();
        }  // if:  Don't Restart selected
        else
        {
            m_rbDontRestart.SetCheck( BST_UNCHECKED );
            m_rbRestart.SetCheck( BST_CHECKED );
            OnClickedRestart();
            if ( m_bAffectTheGroup )
            {
                m_ckbAffectTheGroup.SetCheck( BST_CHECKED );
            } // if: restart and notify
            else
            {
                m_ckbAffectTheGroup.SetCheck( BST_UNCHECKED );
            } // else: restart and don't notify
        }  // else:  Restart selected

        DWORD nLooksAlive = m_nLooksAlive;
        if ( m_nLooksAlive == (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL )
        {
            nLooksAlive = Prti()->NLooksAlive();
            nDefault = BST_CHECKED;
            nSpecify = BST_UNCHECKED;
            bReadOnly = TRUE;
        }  // if:  using default
        else
        {
            nDefault = BST_UNCHECKED;
            nSpecify = BST_CHECKED;
            bReadOnly = FALSE;
        }  // if:  not using default
        DDX_SetNumber(
            m_hWnd,
            IDC_RES_LOOKS_ALIVE,
            nLooksAlive,
            CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE,
            CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE_UI,
            FALSE /*bSigned*/
            );
        m_editLooksAlive.SetReadOnly( bReadOnly );
        m_rbDefaultLooksAlive.SetCheck( nDefault );
        m_rbSpecifyLooksAlive.SetCheck( nSpecify );

        DWORD nIsAlive = m_nIsAlive;
        if ( m_nIsAlive == (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL )
        {
            nIsAlive = Prti()->NIsAlive();
            nDefault = BST_CHECKED;
            nSpecify = BST_UNCHECKED;
            bReadOnly = TRUE;
        }  // if:  using default
        else
        {
            nDefault = BST_UNCHECKED;
            nSpecify = BST_CHECKED;
            bReadOnly = TRUE;
        }  // if:  not using default
        DDX_SetNumber(
            m_hWnd,
            IDC_RES_IS_ALIVE,
            nIsAlive,
            CLUSTER_RESOURCE_MINIMUM_IS_ALIVE,
            CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE_UI,
            FALSE /*bSigned*/
            );
        m_editIsAlive.SetReadOnly( bReadOnly );
        m_rbDefaultIsAlive.SetCheck( nDefault );
        m_rbSpecifyIsAlive.SetCheck( nSpecify );
    } // else:  setting data to the page

    return bSuccess;

} //*** CResourceAdvancedPage::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceAdvancedPage< T, TSht >::BApplyChanges( void )
{
    //
    // Calculate the restart action value.
    //
    if ( m_nRestart == 0 )
    {
        m_crraRestartAction = ClusterResourceDontRestart;
    } // if:  Don't Restart selected
    else if ( m_bAffectTheGroup )
    {
        m_crraRestartAction = ClusterResourceRestartNotify;
    } // else if:  Restart and Affects Group selected
    else
    {
        m_crraRestartAction = ClusterResourceRestartNoNotify;
    } // else:  Restart but not Affects Group selected

    //
    // Save all changed data.
    //
    if ( Pri()->BSetAdvancedProperties(
                m_crraRestartAction,
                m_nThreshold,
                m_nPeriod * 1000, // display units are seconds, stored units are milliseconds
                m_nLooksAlive,
                m_nIsAlive,
                m_nPendingTimeout * 1000 // display units are seconds, stored units are milliseconds
                ) )
    {
        SetResInfoChanged();
    } // if:  data changed

    return TRUE;

} //*** CResourceAdvancedPage::BApplyChanges()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceAdvancedPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CGeneralResourceAdvancedPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DONT_RESTART )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_AFFECT_THE_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_THRESH_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_THRESHOLD )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_PERIOD_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_PERIOD )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_PERIOD_LABEL2 )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_LOOKS_ALIVE_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEFAULT_LOOKS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SPECIFY_LOOKS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_LOOKS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SPECIFY_LOOKS_ALIVE_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_IS_ALIVE_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEFAULT_IS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SPECIFY_IS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_IS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_IS_ALIVE_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_PENDING_TIMEOUT_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_PENDING_TIMEOUT )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_PENDING_TIMEOUT_LABEL2 )
END_CTRL_NAME_MAP()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CIPAddrResourceAdvancedPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CIPAddrResourceAdvancedPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DONT_RESTART )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_AFFECT_THE_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_THRESH_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_THRESHOLD )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_PERIOD_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_PERIOD )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_PERIOD_LABEL2 )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_LOOKS_ALIVE_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEFAULT_LOOKS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SPECIFY_LOOKS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_LOOKS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SPECIFY_LOOKS_ALIVE_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_IS_ALIVE_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEFAULT_IS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SPECIFY_IS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_IS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_IS_ALIVE_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_PENDING_TIMEOUT_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_PENDING_TIMEOUT )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_PENDING_TIMEOUT_LABEL2 )
END_CTRL_NAME_MAP()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CIPAddrParametersPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CIPAddrParametersPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_IPADDR_PARAMS_ADDRESS_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_IPADDR_PARAMS_ADDRESS )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_IPADDR_PARAMS_SUBNET_MASK_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_IPADDR_PARAMS_SUBNET_MASK )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_IPADDR_PARAMS_NETWORK_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_IPADDR_PARAMS_NETWORK )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_IPADDR_PARAMS_ENABLE_NETBIOS )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrParametersPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIPAddrParametersPage::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_ipaIPAddress,  IDC_IPADDR_PARAMS_ADDRESS );
    AttachControl( m_ipaSubnetMask, IDC_IPADDR_PARAMS_SUBNET_MASK );
    AttachControl( m_cboxNetworks,  IDC_IPADDR_PARAMS_NETWORK );
    AttachControl( m_chkEnableNetBIOS, IDC_IPADDR_PARAMS_ENABLE_NETBIOS );

    //
    // Get data from the sheet.
    //
    m_strIPAddress = PshtThis()->m_strIPAddress;
    m_strSubnetMask = PshtThis()->m_strSubnetMask;
    m_strNetwork = PshtThis()->m_strNetwork;
    m_bEnableNetBIOS = PshtThis()->m_bEnableNetBIOS;

    //
    // Fill the networks combobox.
    //
    FillNetworksList();

    //
    // Default the subnet mask if not set.
    //

    return TRUE;

} //*** CIPAddrParametersPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrParametersPage::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIPAddrParametersPage::UpdateData( IN BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    // Loop to avoid goto's.
    do
    {
        if ( bSaveAndValidate )
        {
            DDX_GetText( m_hWnd, IDC_IPADDR_PARAMS_ADDRESS, m_strIPAddress );
            DDX_GetText( m_hWnd, IDC_IPADDR_PARAMS_SUBNET_MASK, m_strSubnetMask );
            DDX_GetText( m_hWnd, IDC_IPADDR_PARAMS_NETWORK, m_strNetwork );
            DDX_GetCheck( m_hWnd, IDC_IPADDR_PARAMS_ENABLE_NETBIOS, m_bEnableNetBIOS );

            if (   ! DDV_RequiredText( m_hWnd, IDC_IPADDR_PARAMS_ADDRESS, IDC_IPADDR_PARAMS_ADDRESS_LABEL, m_strIPAddress )
                || ! DDV_RequiredText( m_hWnd, IDC_IPADDR_PARAMS_SUBNET_MASK, IDC_IPADDR_PARAMS_SUBNET_MASK_LABEL, m_strSubnetMask )
                || ! DDV_RequiredText( m_hWnd, IDC_IPADDR_PARAMS_NETWORK, IDC_IPADDR_PARAMS_NETWORK_LABEL, m_strNetwork )
                )
            {
                bSuccess = FALSE;
                break;
            } // if:  required text not specified

            //
            // Validate the IP address.
            //
            if ( ! BIsValidIpAddress( m_strIPAddress ) )
            {
                CString strMsg;
                strMsg.FormatMessage( IDS_ERROR_INVALID_IP_ADDRESS, m_strIPAddress );
                AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
                m_ipaIPAddress.SetFocus( 0 /*nField*/ );
                bSuccess = FALSE;
                break;
            }  // if:  invalid IP address

            //
            // Make sure we process the IP address.
            // If we don't call it here, and the user pressed a tab button
            // while sitting in the IP address field, the EN_KILLFOCUS
            // message won't get processed until after this method returns.
            //
            if (   (m_strSubnetMask.GetLength() == 0)
                || (m_ipaSubnetMask.IsBlank()) )
            {
                BOOL bHandled = TRUE;
                OnKillFocusIPAddr( EN_KILLFOCUS, IDC_IPADDR_PARAMS_ADDRESS, m_ipaIPAddress.m_hWnd, bHandled );
            } // if:  subnet mask not specified

            //
            // Validate the subnet mask.
            //
            if ( ! BIsValidSubnetMask( m_strSubnetMask ) )
            {
                CString strMsg;
                strMsg.FormatMessage( IDS_ERROR_INVALID_SUBNET_MASK, m_strSubnetMask );
                AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
                m_ipaSubnetMask.SetFocus( 0 /*nField*/ );
                bSuccess = FALSE;
                break;
            }  // if:  invalid subnet mask

            //
            // Validate the IP address and the subnet mask together.
            //
            if ( ! BIsValidIpAddressAndSubnetMask( m_strIPAddress, m_strSubnetMask ) )
            {
                CString strMsg;
                strMsg.FormatMessage( IDS_ERROR_INVALID_ADDRESS_AND_SUBNET_MASK, m_strIPAddress, m_strSubnetMask );
                AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
                m_ipaIPAddress.SetFocus( 0 /*nField*/ );
                bSuccess = FALSE;
                break;
            }  // if:  invalid IP address with subnet mask
        } // if: saving data from the page
        else
        {
            m_ipaIPAddress.SetWindowText( m_strIPAddress );
            m_ipaSubnetMask.SetWindowText( m_strSubnetMask );
            DDX_SetComboBoxText( m_hWnd, IDC_IPADDR_PARAMS_NETWORK, m_strNetwork );
            DDX_SetCheck( m_hWnd, IDC_IPADDR_PARAMS_ENABLE_NETBIOS, m_bEnableNetBIOS );
        } // else:  setting data to the page
    } while ( 0 );

    return bSuccess;

} //*** CIPAddrParametersPage::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrParametersPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIPAddrParametersPage::BApplyChanges( void )
{
    if (   BSaveIPAddress()
        || BSaveSubnetMask()
        || BSaveNetwork()
        || BSaveEnableNetBIOS() )
    {
        SetResInfoChanged();
    } // if:  data changed

    return TRUE;

} //*** CIPAddrParametersPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrParametersPage::OnKillFocusIPAddr
//
//  Routine Description:
//      Handler for the EN_KILLFOCUS command notification on IDC_IPADDR_PARAMS_ADDRESS.
//
//  Arguments:
//      bHandled    [IN OUT] TRUE = we handled message (default).
//
//  Return Value:
//      TRUE        Page activated successfully.
//      FALSE       Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CIPAddrParametersPage::OnKillFocusIPAddr(
    WORD /*wNotifyCode*/,
    WORD /*idCtrl*/,
    HWND /*hwndCtrl*/,
    BOOL & bHandled
    )
{
    CString             strAddress;
    CString             strMsg;
    CClusNetworkInfo *  pni;

    BSTR bstr = NULL;
    m_ipaIPAddress.GetWindowText( bstr );
    strAddress = bstr;
    SysFreeString( bstr );
    bstr = NULL;

    if ( strAddress.GetLength() == 0 )
    {
        ((CEdit &)m_ipaIPAddress).SetSel( 0, 0, FALSE );
    } // if:  empty string
    else if ( !BIsValidIpAddress( strAddress ) )
    {
    } // else if:  invalid address
    else
    {
        pni = PniFromIpAddress( strAddress );
        if ( pni != NULL )
        {
            SelectNetwork( pni );
        } // if:  network found
        else
        {
            //m_strSubnetMask = _T("");
        } // else:  network not found
    } // else:  valid address

    bHandled = FALSE;
    return 0;

} //*** CIPAddrParametersPage::OnIPAddrChanged()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrParametersPage::FillNetworksList
//
//  Routine Description:
//      Fill the list of possible owners.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIPAddrParametersPage::FillNetworksList( void )
{
    CWaitCursor wc;

    // Loop to avoid goto's.
    do
    {
        //
        // Add each network in the list to the combobox.
        //
        CClusNetworkPtrList::iterator itnet;
        int idx;
        for ( itnet = PshtThis()->PlpniNetworks()->begin()
            ; itnet != PshtThis()->PlpniNetworks()->end()
            ; itnet++ )
        {
            //
            // Add the network to the combobox.
            //
            CClusNetworkInfo * pni = *itnet;
            if ( pni->BIsClientNetwork() )
            {
                idx = m_cboxNetworks.AddString( pni->RstrName() );
                ASSERT( idx != CB_ERR );
                m_cboxNetworks.SetItemDataPtr( idx, (void *) pni );
            } // if:  client network
        } // for:  each entry in the list

        //
        // Select the currently saved entry, or the first one if none are
        // currently saved.
        //
        if ( m_strNetwork.GetLength() == 0 )
        {
            m_cboxNetworks.SetCurSel( 0 );
        } // if:  empty string
        else
        {
            int idx = m_cboxNetworks.FindStringExact( -1, m_strNetwork );
            ASSERT( idx != CB_ERR );
            if ( idx != CB_ERR )
            {
                m_cboxNetworks.SetCurSel( idx );
            } // if:  saved selection found in the combobox
        } // else:  network saved
    } while ( 0 );

} //*** CIPAddrParametersPage::FillNetworksList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrParametersPage::PniFromIpAddress
//
//  Routine Description:
//      Find the network for the specified IP address.
//
//  Arguments:
//      pszAddress      [IN] IP address to match.
//
//  Return Value:
//      NULL            No matching network found.
//      pni             Network that supports the specfied IP address.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetworkInfo * CIPAddrParametersPage::PniFromIpAddress( IN LPCWSTR pszAddress )
{
    DWORD               dwStatus;
    DWORD               nAddress;
    CClusNetworkInfo *  pni;

    //
    // Convert the address to a number.
    //
    dwStatus = ClRtlTcpipStringToAddress( pszAddress, &nAddress );
    if ( dwStatus != ERROR_SUCCESS )
    {
        return NULL;
    } // if:  error converting the address to a number

    //
    // Search the list for a matching address.
    //
    CClusNetworkPtrList::iterator itnet;
    for ( itnet = PshtThis()->PlpniNetworks()->begin()
        ; itnet != PshtThis()->PlpniNetworks()->end()
        ; itnet++ )
    {
        pni = *itnet;
        if ( ClRtlAreTcpipAddressesOnSameSubnet( nAddress, pni->NAddress(), pni->NAddressMask() ) )
        {
            return pni;
        } // if:  IP address is on this network
    }  // while:  more items in the list

    return NULL;

}  //*** CIPAddrParametersPage::PniFromIpAddress()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrParametersPage::SelectNetwork
//
//  Routine Description:
//      Select the specified network in the network combobox, and set the
//      subnet mask.
//
//  Arguments:
//      pni         [IN OUT] Network info object for network to select.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIPAddrParametersPage::SelectNetwork( IN OUT CClusNetworkInfo * pni )
{
    ASSERT( pni != NULL );

    int     inet;
    CString strSubnetMask;
    BSTR    bstrSubnetMask = NULL;

    // Find the proper item in the checkbox.
    inet = m_cboxNetworks.FindStringExact( -1, pni->RstrName() );
    if ( inet != CB_ERR )
    {
        m_cboxNetworks.SetCurSel( inet );
        m_ipaSubnetMask.GetWindowText( bstrSubnetMask );
        strSubnetMask = bstrSubnetMask;
        SysFreeString( bstrSubnetMask );
        if ( strSubnetMask != pni->RstrAddressMask() )
            m_ipaSubnetMask.SetWindowText( pni->RstrAddressMask() );
        m_strNetwork = pni->RstrName();
        m_strSubnetMask = pni->RstrAddressMask();
    }  // if:  match found

}  //*** CIPAddrParametersPage::SelectNetwork()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CNetNameParametersPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CNetNameParametersPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_NETNAME_PARAMS_NAME_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_NETNAME_PARAMS_NAME )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetNameParametersPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetNameParametersPage::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_editNetName, IDC_NETNAME_PARAMS_NAME );

    //
    // Set limits on edit controls.
    //
    m_editNetName.SetLimitText( MAX_CLUSTERNAME_LENGTH );

    //
    // Get data from the sheet.
    //
    m_strNetName = PshtThis()->m_strNetName;

    return TRUE;

} //*** CIPAddrParametersPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetNameParametersPage::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetNameParametersPage::UpdateData( IN BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    // Loop to avoid goto's.
    do
    {
        if ( bSaveAndValidate )
        {
            CString strNetName;

            DDX_GetText( m_hWnd, IDC_NETNAME_PARAMS_NAME, strNetName );

            if ( ! DDV_RequiredText( m_hWnd, IDC_NETNAME_PARAMS_NAME, IDC_NETNAME_PARAMS_NAME_LABEL, strNetName ) )
            {
                bSuccess = FALSE;
                break;
            } // if:  required text not specified

            //
            // Validate the network name if the data on the page is different
            //
            if ( m_strNetName != strNetName )
            {
                CLRTL_NAME_STATUS cnStatus;

                if ( ! ClRtlIsNetNameValid( strNetName, &cnStatus, FALSE /*CheckIfExists*/) )
                {
                    CString     strMsg;
                    UINT        idsError;

                    switch ( cnStatus )
                    {
                        case NetNameTooLong:
                            idsError = IDS_ERROR_INVALID_NETWORK_NAME_TOO_LONG;
                            break;
                        case NetNameInvalidChars:
                            idsError = IDS_ERROR_INVALID_NETWORK_NAME_INVALID_CHARS;
                            break;
                        case NetNameInUse:
                            idsError = IDS_ERROR_INVALID_NETWORK_NAME_IN_USE;
                            break;
                        case NetNameDNSNonRFCChars:
                            idsError = IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS;
                            break;
                        case NetNameSystemError:
                        {
                            DWORD scError = GetLastError();
                            CNTException nte( scError, IDS_ERROR_VALIDATING_NETWORK_NAME, (LPCWSTR) strNetName );
                            nte.ReportError();
                            break;
                        }
                        default:
                            idsError = IDS_ERROR_INVALID_NETWORK_NAME;
                            break;
                    }  // switch:  cnStatus

                    if ( cnStatus != NetNameSystemError )
                    {
                        strMsg.LoadString( idsError );

                        if ( idsError == IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS )
                        {
                            int id = AppMessageBox( m_hWnd, strMsg, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION );

                            if ( id == IDNO )
                            {
                                bSuccess = FALSE;
                            }
                        }
                        else
                        {
                            AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
                            bSuccess = FALSE;
                        }

                        if ( ! bSuccess )
                        {
                            break;
                        }
                    } // if:  popup not displayed yet
                }  // if:  invalid network name

                m_strNetName = strNetName;
            } // if: the network name has changed
        } // if: saving data from the page
        else
        {
            m_editNetName.SetWindowText( m_strNetName );
        } // else:  setting data to the page
    } while ( 0 );

    return bSuccess;

} //*** CNetNameParametersPage::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetNameParametersPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetNameParametersPage::BApplyChanges( void )
{
    if ( BSaveNetName() )
    {
        SetResInfoChanged();
    } // if:  data changed

    return TRUE;

} //*** CNetNameParametersPage::BApplyChanges()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\lcpair.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		LCPair.h
//
//	Abstract:
//		Definition of the CModifyNodesDlg and CModifyResourcesDlg dialogs.
//
//	Implementation File:
//		LCPair.cpp
//
//	Author:
//		David Potter (davidp)	April 16, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __LCPAIR_H_
#define __LCPAIR_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

template < class T, class BaseT > class CModifyNodesDlg;
template < class T, class BaseT > class CModifyResourcesDlg;
class CModifyPreferredOwners;
class CModifyPossibleOwners;
class CModifyDependencies;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusGroupInfo;
class CClusResInfo;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLUSOBJ_H_
#include "ClusObj.h"	// for CClusterObject, CClusObjPtrList
#endif

#ifndef __ATLLCPAIR_H_
#include "AtlLCPair.h"	// for CListCtrlPair
#endif

#ifndef __ATLBASEDLG_H_
#include "AtlBaseDlg.h"	// for CBaseDlg
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"	// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CModifyNodesDlg
/////////////////////////////////////////////////////////////////////////////

template < class T, class BaseT >
class CModifyNodesDlg : public CListCtrlPair< T, CClusNodeInfo, BaseT >
{
	typedef CModifyNodesDlg< T, BaseT >	thisClass;
	typedef CListCtrlPair< T, CClusNodeInfo, BaseT > baseClass;

public:
	//
	// Construction
	//

	// Constructor taking a string pointer for the title
	CModifyNodesDlg(
		IN CClusterAppWizard *	pwiz,
		IN DWORD				dwStyle,
		IN LPCTSTR				pszTitle = NULL
		)
		: baseClass(
				dwStyle | /*LCPS_PROPERTIES_BUTTON | */(dwStyle & LCPS_ORDERED ? LCPS_CAN_BE_ORDERED : 0),
				pszTitle
				)
	{
		ASSERT( pwiz != NULL );

		m_pwiz = pwiz;

	} //*** CModifyNodesDlg()

	// Constructor taking a resource ID for the title
	CModifyNodesDlg(
		IN CClusterAppWizard *	pwiz,
		IN DWORD				dwStyle,
		IN UINT					nIDCaption
		)
		: baseClass(
				dwStyle | /*LCPS_PROPERTIES_BUTTON | */(dwStyle & LCPS_ORDERED ? LCPS_CAN_BE_ORDERED : 0),
				nIDCaption
				)
	{
		ASSERT( pwiz != NULL );

		m_pwiz = pwiz;

	} //*** CModifyNodesDlg()

protected:
	CClusterAppWizard * m_pwiz;

public:
	CClusterAppWizard * Pwiz( void ) const { return m_pwiz; }

public:
	//
	// Functions that are required to be implemented by CListCtrlPair.
	//

	// Get column text and image
	void GetColumnInfo(
		IN OUT CClusNodeInfo *	pobj,
		IN int					iItem,
		IN int					icol,
		OUT CString &			rstr,
		OUT int *				piimg
		)
	{
		switch ( icol )
		{
			case 0:
				rstr = pobj->RstrName();
				break;
			default:
				ASSERT( 0 );
				break;
		} // switch: icol

	} //*** GetColumnInfo()

	// Display an application-wide message box
	virtual int AppMessageBox( LPCWSTR lpszText, UINT fuStyle )
	{
		return ::AppMessageBox( m_hWnd, lpszText, fuStyle );

	} //*** AppMessageBox()

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( thisClass )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void )
	{
		//
		// Add columns.
		//
		AddColumn( IDS_COLTEXT_NODE_NAME, 125 /* nWidth */);

		//
		// Call the base class.
		//
		return baseClass::OnInitDialog();

	} //*** OnInitDialog()

	//static const DWORD * PidHelpMap( void ) { return g_; };

};  //*** class CModifyNodesDlg

/////////////////////////////////////////////////////////////////////////////
// class CModifyResourcesDlg
/////////////////////////////////////////////////////////////////////////////

template < class T, class BaseT >
class CModifyResourcesDlg : public CListCtrlPair< T, CClusResInfo, BaseT >
{
	typedef CModifyResourcesDlg< T, BaseT >	thisClass;
	typedef CListCtrlPair< T, CClusResInfo, BaseT > baseClass;

public:
	//
	// Construction
	//

	// Constructor taking a string pointer for the title
	CModifyResourcesDlg(
		IN CClusterAppWizard *	pwiz,
		IN DWORD				dwStyle,
		IN LPCTSTR				pszTitle = NULL
		)
		: baseClass(
				dwStyle | /*LCPS_PROPERTIES_BUTTON | */(dwStyle & LCPS_ORDERED ? LCPS_CAN_BE_ORDERED : 0),
				pszTitle
				)
		, m_pwiz( pwiz )
	{
		ASSERT( pwiz != NULL);

	} //*** CModifyResourcesDlg()

	// Constructor taking a resource ID for the title
	CModifyResourcesDlg(
		IN CClusterAppWizard *	pwiz,
		IN DWORD				dwStyle,
		IN UINT					nIDCaption
		)
		: baseClass(
				dwStyle | /*LCPS_PROPERTIES_BUTTON | */(dwStyle & LCPS_ORDERED ? LCPS_CAN_BE_ORDERED : 0),
				nIDCaption
				)
		, m_pwiz( pwiz )
	{
		ASSERTE( pwiz != NULL );

	} //*** CModifyResourcesDlg()

protected:
	CClusterAppWizard * m_pwiz;

public:
	CClusterAppWizard * Pwiz( void ) const { return m_pwiz; }

public:
	//
	// Functions that are required to be implemented by CListCtrlPair.
	//

	// Get column text and image
	void GetColumnInfo(
		IN OUT CClusResInfo *	pobj,
		IN int					iItem,
		IN int					icol,
		OUT CString &			rstr,
		OUT int *				piimg
		)
	{
		switch ( icol )
		{
			case 0:
				rstr = pobj->RstrName();
				break;
			case 1:
				rstr = pobj->Prti()->RstrDisplayName();
				break;
			default:
				ASSERT( 0 );
				break;
		} // switch:  icol

	} //*** GetColumnInfo()

	// Display an application-wide message box
	virtual int AppMessageBox( LPCWSTR lpszText, UINT fuStyle )
	{
		return ::AppMessageBox( m_hWnd, lpszText, fuStyle );

	} //*** AppMessageBox()

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( thisClass )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void )
	{
		//
		// Add columns.
		//
		AddColumn( IDS_COLTEXT_RESOURCE_NAME, 125 /* nWidth */);
		AddColumn( IDS_COLTEXT_RESOURCE_TYPE, 100 /* nWidth */);

		//
		// Call the base class.
		//
		return baseClass::OnInitDialog();

	} //*** OnInitDialog()

	//static const DWORD * PidHelpMap( void ) { return g_; };

};  //*** class CModifyResourcesDlg

/////////////////////////////////////////////////////////////////////////////
// class CModifyPreferredOwners
/////////////////////////////////////////////////////////////////////////////

class CModifyPreferredOwners : public CModifyNodesDlg< CModifyPreferredOwners, CBaseDlg< CModifyPreferredOwners > >
{
	typedef CModifyNodesDlg< CModifyPreferredOwners, CBaseDlg< CModifyPreferredOwners > > baseClass;

public:
	// Constructor
	CModifyPreferredOwners(
		IN CClusterAppWizard *		pwiz,
		IN CClusGroupInfo *			pgi,
		IN OUT CClusNodePtrList *	plpniRight,
		IN CClusNodePtrList *		plpniLeft
		)
		: baseClass( pwiz, LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY | LCPS_CAN_BE_ORDERED | LCPS_ORDERED )
		, m_pgi( pgi )
		, m_plpniRight( plpniRight )
		, m_plpniLeft( plpniLeft )
	{
		ASSERT( pgi != NULL );
		ASSERT( plpniRight != NULL );
		ASSERT( plpniLeft != NULL );

	} //*** CModifyPreferredOwners()

	enum { IDD = IDD_MODIFY_PREFERRED_OWNERS };

	DECLARE_CTRL_NAME_MAP()

protected:
	CClusGroupInfo *	m_pgi;
	CClusNodePtrList *	m_plpniRight;
	CClusNodePtrList *	m_plpniLeft;

public:
	//
	// Functions that are required to be implemented by CListCtrlPair.
	//

	// Return list of objects for right list control
	CClusNodePtrList * PlpobjRight( void ) const
	{
		return m_plpniRight;

	} //*** PlpobjRight()

	// Return list of objects for left list control
	CClusNodePtrList * PlpobjLeft( void ) const
	{
		return m_plpniLeft;

	} //*** PlpobjRight()

	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_MODIFY_PREFERRED_OWNERS; };

}; //*** class CModifyPreferredOwners

/////////////////////////////////////////////////////////////////////////////
// class CModifyPossibleOwners
/////////////////////////////////////////////////////////////////////////////

class CModifyPossibleOwners : public CModifyNodesDlg< CModifyPossibleOwners, CBaseDlg< CModifyPossibleOwners > >
{
	typedef CModifyNodesDlg< CModifyPossibleOwners, CBaseDlg< CModifyPossibleOwners > > baseClass;

public:
	// Constructor
	CModifyPossibleOwners(
		IN CClusterAppWizard *		pwiz,
		IN CClusResInfo *			pri,
		IN OUT CClusNodePtrList *	plpniRight,
		IN CClusNodePtrList *		plpniLeft
		)
		: baseClass( pwiz, LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY )
		, m_pri( pri )
		, m_plpniRight( plpniRight )
		, m_plpniLeft( plpniLeft )
	{
		ASSERT( pri != NULL );
		ASSERT( plpniRight != NULL );
		ASSERT( plpniLeft != NULL );

	} //*** CModifyPossibleOwners()

	enum { IDD = IDD_MODIFY_POSSIBLE_OWNERS };

	DECLARE_CTRL_NAME_MAP()

protected:
	CClusResInfo *		m_pri;
	CClusNodePtrList *	m_plpniRight;
	CClusNodePtrList *	m_plpniLeft;

public:
	//
	// Functions that are required to be implemented by CListCtrlPair.
	//

	// Return list of objects for right list control
	CClusNodePtrList * PlpobjRight( void ) const
	{
		return m_plpniRight;

	} //*** PlpobjRight()

	// Return list of objects for left list control
	CClusNodePtrList * PlpobjLeft( void ) const
	{
		return m_plpniLeft;

	} //*** PlpobjRight()

	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_MODIFY_POSSIBLE_OWNERS; };

}; //*** class CModifyPossibleOwners

/////////////////////////////////////////////////////////////////////////////
// class CModifyDependencies
/////////////////////////////////////////////////////////////////////////////

class CModifyDependencies
	: public CModifyResourcesDlg< CModifyDependencies, CBaseDlg< CModifyDependencies > >
{
	typedef CModifyResourcesDlg< CModifyDependencies, CBaseDlg< CModifyDependencies > > baseClass;

public:
	// Constructor
	CModifyDependencies(
		IN CClusterAppWizard *		pwiz,
		IN CClusResInfo *			pri,
		IN OUT CClusResPtrList *	plpriRight,
		IN CClusResPtrList *		plpriLeft
		)
		: baseClass( pwiz, LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY )
		, m_pri( pri )
		, m_plpriRight( plpriRight )
		, m_plpriLeft( plpriLeft )
	{
		ASSERT( pri != NULL );
		ASSERT( plpriRight != NULL );
		ASSERT( plpriLeft != NULL );

	} //*** CModifyDependencies()

	enum { IDD = IDD_MODIFY_DEPENDENCIES };

	DECLARE_CTRL_NAME_MAP()

protected:
	CClusResInfo * m_pri;
	CClusResPtrList * m_plpriRight;
	CClusResPtrList * m_plpriLeft;

public:
	//
	// Functions that are required to be implemented by CListCtrlPair.
	//

	// Return list of objects for right list control
	CClusResPtrList * PlpobjRight( void ) const
	{
		return m_plpriRight;

	} //*** PlpobjRight()

	// Return list of objects for left list control
	CClusResPtrList * PlpobjLeft( void ) const
	{
		return m_plpriLeft;

	} //*** PlpobjRight()

	// Update data on or from the dialog
	BOOL UpdateData( IN BOOL bSaveAndValidate )
	{
		BOOL	bSuccess = TRUE;

		bSuccess = baseClass::UpdateData( bSaveAndValidate );
		if ( bSuccess )
		{
			if ( bSaveAndValidate )
			{
				//
				// Ensure all required dependencies are present.
				//
				if ( ! Pwiz()->BRequiredDependenciesPresent( m_pri, &LpobjRight() ) )
				{
					bSuccess = FALSE;
				} // if:  all required dependencies not present
			} // if:  saving data from the dialog
		} // if:  base class was successful

		return bSuccess;

	} //*** UpdateData()

	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_MODIFY_DEPENDENCIES; };

}; //*** class CModifyDependencies

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CModifyPreferredOwners Control Name Map

BEGIN_CTRL_NAME_MAP( CModifyPreferredOwners )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_LEFT_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_LEFT_LIST )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_ADD )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_REMOVE )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_RIGHT_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_RIGHT_LIST )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_MOVE_UP )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_MOVE_DOWN )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDOK )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDCANCEL )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
// CModifyPossibleOwners Control Name Map

BEGIN_CTRL_NAME_MAP( CModifyPossibleOwners )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_LEFT_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_LEFT_LIST )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_ADD )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_REMOVE )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_RIGHT_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_RIGHT_LIST )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDOK )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDCANCEL )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
// CModifyDependencies Control Name Map

BEGIN_CTRL_NAME_MAP( CModifyDependencies )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_LEFT_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_LEFT_LIST )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_ADD )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_REMOVE )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_RIGHT_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_RIGHT_LIST )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDOK )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDCANCEL )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////

#endif // __LCPAIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\resadv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ResAdv.h
//
//	Abstract:
//		Definition of the advanced resource property sheet classes.
//
//	Implementation File:
//		ResAdv.cpp
//
//	Author:
//		David Potter (davidp)	March 5, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESADV_H_
#define __RESADV_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

template < class T > class CResourceAdvancedSheet;
class CGeneralResourceAdvancedSheet;
class CIPAddrAdvancedSheet;
template < class T, class TSht > class CResourceAdvancedBasePage;
template < class T, class TSht > class CResourceGeneralPage;
template < class T, class TSht > class CResourceDependenciesPage;
template < class T, class TSht > class CResourceAdvancedPage;
class CIPAddrParametersPage;
class CNetNameParametersPage;
class CGeneralResourceGeneralPage;
class CGeneralResourceDependenciesPage;
class CGeneralResourceAdvancedPage;
class CIPAddrResourceGeneralPage;
class CIPAddrResourceDependenciesPage;
class CIPAddrResourceAdvancedPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __ATLBASEPROPSHEET_H_
#include "AtlBasePropSheet.h"	// for CBasePropertySheetImpl
#endif

#ifndef __ATLBASEPROPPAGE_H_
#include "AtlBasePropPage.h"	// for CBasePropertyPageImpl
#endif

#ifndef __CLUSAPPWIZ_H_
#include "ClusAppWiz.h"			// for CClusterAppWizard
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"			// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CResourceAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CResourceAdvancedSheet : public CBasePropertySheetImpl< T >
{
	typedef CResourceAdvancedSheet< T > thisClass;
	typedef CBasePropertySheetImpl< T > baseClass;

public:
	//
	// Construction
	//

	// Default constructor
	CResourceAdvancedSheet(
		IN UINT					nIDCaption,
		IN CClusterAppWizard *	pwiz
		)
		: baseClass( nIDCaption )
		, m_pwiz( pwiz )
		, m_prti( NULL )
		, m_pri( NULL )
		, m_pbChanged( NULL )
	{
		ASSERT( pwiz != NULL );

	} //*** CResourceAdvancedSheet()

	// Initialize the sheet
	BOOL BInit( IN OUT CClusResInfo & rri, IN OUT BOOL & rbChanged );

	// Add all pages to the page array
	virtual BOOL BAddAllPages( void ) = 0;

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CResourceAdvancedSheet )
//	END_MSG_MAP()
//	DECLARE_EMPTY_MSG_MAP()

	//
	// Message handler functions.
	//

// Implementation
protected:
	CClusterAppWizard *	m_pwiz;
	CClusResInfo *		m_pri;
	CClusResTypeInfo *	m_prti;
	BOOL *				m_pbChanged;

public:
	CClusterAppWizard *	Pwiz( void ) const			{ return m_pwiz; }
	CClusResInfo *		Pri( void ) const			{ return m_pri; }
	CClusResTypeInfo *	Prti( void ) const			{ return m_prti; }
	void				SetResInfoChanged( void )	{ ASSERT( m_pbChanged != NULL ); *m_pbChanged = TRUE; }

	// Return the help ID map
	//static const DWORD * PidHelpMap( void ) { return g_; }

}; //*** class CResourceAdvancedSheet

/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

class CGeneralResourceAdvancedSheet : public CResourceAdvancedSheet< CGeneralResourceAdvancedSheet >
{
	typedef CResourceAdvancedSheet< CGeneralResourceAdvancedSheet > baseClass;

public:
	//
	// Construction
	//

	// Default constructor
	CGeneralResourceAdvancedSheet( IN UINT nIDCaption, IN CClusterAppWizard * pwiz )
		: baseClass( nIDCaption, pwiz )
	{
	} //*** CGeneralResourceAdvancedSheet()

	// Destructor
	~CGeneralResourceAdvancedSheet( void )
	{
	} //*** ~CGeneralResourceAdvancedSheet()

	// Add all pages to the page array
	virtual BOOL BAddAllPages( void );

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CGeneralResourceAdvancedSheet )
//	END_MSG_MAP()
	DECLARE_EMPTY_MSG_MAP()
	DECLARE_CLASS_NAME()

	//
	// Message handler functions.
	//

// Implementation
protected:

public:

	// Return the help ID map
	//static const DWORD * PidHelpMap( void ) { return g_; }

}; //*** class CGeneralResourceAdvancedSheet

/////////////////////////////////////////////////////////////////////////////
// class CIPAddrAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

class CIPAddrAdvancedSheet : public CResourceAdvancedSheet< CIPAddrAdvancedSheet >
{
	typedef CResourceAdvancedSheet< CIPAddrAdvancedSheet > baseClass;

public:
	//
	// Construction
	//

	// Default constructor
	CIPAddrAdvancedSheet( IN UINT nIDCaption, IN CClusterAppWizard * pwiz )
		: baseClass( nIDCaption, pwiz )
	{
	} //*** CIPAddrAdvancedSheet()

	// Destructor
	~CIPAddrAdvancedSheet( void )
	{
	} //*** ~CIPAddrAdvancedSheet()

	// Add all pages to the page array
	virtual BOOL BAddAllPages( void );

	// Initialize IP Address-specific data
	void InitPrivateData(
		IN const CString &		strIPAddress,
		IN const CString &		strSubnetMask,
		IN const CString &		strNetwork,
		IN BOOL					bEnableNetBIOS,
		CClusNetworkPtrList *	plpniNetworks
		)
	{
		ASSERT( plpniNetworks != NULL );

		m_strIPAddress = strIPAddress;
		m_strSubnetMask = strSubnetMask;
		m_strNetwork = strNetwork;
		m_bEnableNetBIOS = bEnableNetBIOS;
		m_plpniNetworks = plpniNetworks;

	} //*** InitPrivateData()

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CIPAddrAdvancedSheet )
//	END_MSG_MAP()
	DECLARE_EMPTY_MSG_MAP()
	DECLARE_CLASS_NAME()

	//
	// Message handler functions.
	//

// Implementation
protected:
	CClusNetworkPtrList * m_plpniNetworks;

public:
	CString		m_strIPAddress;
	CString		m_strSubnetMask;
	CString		m_strNetwork;
	BOOL		m_bEnableNetBIOS;

	CClusNetworkPtrList * PlpniNetworks( void ) { return m_plpniNetworks; }

	// Return the help ID map
	//static const DWORD * PidHelpMap( void ) { return g_; }

}; //*** class CIPAddrAdvancedSheet

/////////////////////////////////////////////////////////////////////////////
// class CNetNameAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

class CNetNameAdvancedSheet : public CResourceAdvancedSheet< CNetNameAdvancedSheet >
{
	typedef CResourceAdvancedSheet< CNetNameAdvancedSheet > baseClass;

public:
	//
	// Construction
	//

	// Default constructor
	CNetNameAdvancedSheet( IN UINT nIDCaption, IN CClusterAppWizard * pwiz )
		: baseClass( nIDCaption, pwiz )
	{
	} //*** CNetNameAdvancedSheet()

	// Destructor
	~CNetNameAdvancedSheet( void )
	{
	} //*** ~CNetNameAdvancedSheet()

	// Add all pages to the page array
	virtual BOOL BAddAllPages( void );

	// Initialize Network Name-specific data
	void InitPrivateData( IN const CString & strNetName )
	{
		m_strNetName = strNetName;

	} //*** InitPrivateData()

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CNetNameAdvancedSheet )
//	END_MSG_MAP()
	DECLARE_EMPTY_MSG_MAP()
	DECLARE_CLASS_NAME()

	//
	// Message handler functions.
	//

// Implementation
protected:

public:
	CString		m_strNetName;

	// Return the help ID map
	//static const DWORD * PidHelpMap( void ) { return g_; }

}; //*** class CNetNameAdvancedSheet

/////////////////////////////////////////////////////////////////////////////
// class CResourceAdvancedBasePage
/////////////////////////////////////////////////////////////////////////////

template < class T, class TSht >
class CResourceAdvancedBasePage : public CStaticPropertyPageImpl< T >
{
	typedef CResourceAdvancedBasePage< T, TSht > thisClass;
	typedef CStaticPropertyPageImpl< T > baseClass;

public:
	//
	// Construction
	//

	// Default constructor
	CResourceAdvancedBasePage( void )
	{
	} //*** CGroupFailoverPage()

public:
	//
	// Message map.
	//
	//
	// Message handler functions.
	//

	// Handler for changed fields
	LRESULT OnChanged(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		SetModified( TRUE );
		return 0;

	} // OnChanged()

// Implementation
protected:
	//
	// Controls.
	//

	//
	// Page state.
	//

protected:
	CResourceAdvancedSheet< TSht > *	PshtThis( void ) const		{ return (CResourceAdvancedSheet< TSht > *) Psht(); }
	CClusResInfo *						Pri( void ) const			{ return PshtThis()->Pri(); }
	CClusResTypeInfo *					Prti( void ) const			{ return PshtThis()->Prti(); }
	CClusterAppWizard *					Pwiz( void ) const			{ return PshtThis()->Pwiz(); }
	void								SetResInfoChanged( void )	{ PshtThis()->SetResInfoChanged(); }

public:

}; //*** class CResourceAdvancedBasePage

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResourceAdvancedSheet::BInit
//
//	Routine Description:
//		Initialize the wizard.
//
//	Arguments:
//		rgi			[IN OUT] The resource info object.
//		rbChanged	[IN OUT] TRUE = resource info was changed by property sheet.
//
//	Return Value:
//		TRUE		Sheet initialized successfully.
//		FALSE		Error initializing sheet.  Error already displayed.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T >
BOOL CResourceAdvancedSheet< T >::BInit(
	IN OUT CClusResInfo &	rri,
	IN OUT BOOL &			rbChanged
	)
{
	BOOL bSuccess = FALSE;

	m_pri = &rri;
	m_pbChanged = &rbChanged;

	// Loop to avoid goto's
	do
	{
		//
		// Collect resource types.
		//
		if ( ! Pwiz()->BCollectResourceTypes( m_hWnd ) )
		{
			break;
		} // if:  error collecting resource types

		//
		// Find the resource type of this resource
		//
		ASSERT( rri.Prti() != NULL );
		m_prti = Pwiz()->PrtiFindResourceTypeNoCase( rri.Prti()->RstrName() );
		if ( m_prti == NULL )
		{
			AppMessageBox( m_hWnd, IDS_RESOURCE_TYPE_NOT_FOUND, MB_OK | MB_ICONEXCLAMATION );
			break;
		} // if:  error finding resource type

		//
		// Fill the page array.
		//
		if ( ! BAddAllPages() )
		{
			break;
		} // if:  error adding pages

		//
		// Call the base class.
		//
		if ( ! baseClass::BInit() )
		{
			break;
		} // if:  error initializing the base class

		bSuccess = TRUE;

	} while ( 0 );

	return bSuccess;

} //*** CResourceAdvancedSheet< class T >::BInit()

/////////////////////////////////////////////////////////////////////////////
// class CResourceGeneralPage
/////////////////////////////////////////////////////////////////////////////

template < class T, class TSht >
class CResourceGeneralPage : public CResourceAdvancedBasePage< T, TSht >
{
	typedef CResourceGeneralPage< T, TSht > thisClass;
	typedef CResourceAdvancedBasePage< T, TSht > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CResourceGeneralPage( void )
		: m_bSeparateMonitor( FALSE )
		, m_bPossibleOwnersChanged( FALSE )
	{
	} //*** CGroupFailoverPage()

	enum { IDD = IDD_RES_GENERAL };

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( thisClass )
		COMMAND_HANDLER( IDC_RES_NAME, EN_CHANGE, OnChanged )
		COMMAND_HANDLER( IDC_RES_DESC, EN_CHANGE, OnChanged )
		COMMAND_HANDLER( IDC_RES_POSSIBLE_OWNERS_MODIFY, BN_CLICKED, OnModify )
		COMMAND_HANDLER( IDC_RES_SEPARATE_MONITOR, BN_CLICKED, OnChanged )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	//
	// Message handler functions.
	//

	// Handler for BN_CLICKED on the MODIFY push button
	LRESULT OnModify(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		);

	//
	// Message handler overrides.
	//

	// Handler for WM_INITDIALOG
	BOOL OnInitDialog( void );

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( IN BOOL bSaveAndValidate );

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

// Implementation
protected:
	//
	// Controls.
	//
	CListBox	m_lbPossibleOwners;
	CButton		m_pbModifyPossibleOwners;

	//
	// Page state.
	//
	CString	m_strName;
	CString	m_strDesc;
	BOOL	m_bSeparateMonitor;

	CClusNodePtrList m_lpniPossibleOwners;

	BOOL m_bPossibleOwnersChanged;

protected:
	// Fill in the list of possible owners
	void FillPossibleOwnersList( void );

	// Save the resource name
	BOOL BSaveName( void )
	{
		if ( Pri()->RstrName() != m_strName )
		{
			Pri()->SetName( m_strName );
			return TRUE;
		} // if:  value changed

		return FALSE;

	} //*** BSaveName()

	// Save the group description
	BOOL BSaveDescription( void )
	{
		if ( Pri()->RstrDescription() != m_strDesc )
		{
			Pri()->SetDescription( m_strDesc );
			return TRUE;
		} // if:  value changed

		return FALSE;

	} //*** BSaveDescription()

	// Save the SeparateMonitor flag
	BOOL BSaveSeparateMonitor( void )
	{
		return Pri()->BSetSeparateMonitor( m_bSeparateMonitor );

	} //*** BSaveSeparateMonitor()

	// Save possible owners
	BOOL BSavePossibleOwners( void )
	{
		if ( m_bPossibleOwnersChanged )
		{
			*Pri()->PlpniPossibleOwners() = m_lpniPossibleOwners;
			return TRUE;
		} // if:  possible owners changed

		return FALSE;

	} //*** BSavePossibleOwners()

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_RES_GENERAL; }

}; //*** class CResourceGeneralPage

/////////////////////////////////////////////////////////////////////////////
// class CResourceDependenciesPage
/////////////////////////////////////////////////////////////////////////////

template < class T, class TSht >
class CResourceDependenciesPage : public CResourceAdvancedBasePage< T, TSht >
{
	typedef CResourceDependenciesPage< T, TSht > thisClass;
	typedef CResourceAdvancedBasePage< T, TSht > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CResourceDependenciesPage( void )
		: m_bDependenciesChanged( FALSE )
	{
	} //*** CResourceDependenciesPage()

	enum { IDD = IDD_RES_DEPENDENCIES };

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( thisClass )
		COMMAND_HANDLER( IDC_RES_DEPENDS_MODIFY, BN_CLICKED, OnModify )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	//
	// Message handler functions.
	//

	// Handler for BN_CLICKED on the MODIFY push button
	LRESULT OnModify(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		);

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

public:
	//
	// CBasePage public methods.
	//

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

// Implementation
protected:
	//
	// Controls.
	//
	CListViewCtrl	m_lvcDependencies;

	//
	// Page state.
	//
	CClusResPtrList m_lpriDependencies;
	CClusResPtrList m_lpriResourcesInGroup;

	BOOL m_bDependenciesChanged;

protected:
	// Fill in the list of dependencies
	void FillDependenciesList( void );

	// Returns whether dependencies list has changed
	BOOL BDependenciesChanged( void ) const { return m_bDependenciesChanged; }

	// Save dependencies
	BOOL BSaveDependencies( void )
	{
		if ( m_bDependenciesChanged )
		{
			*Pri()->PlpriDependencies() = m_lpriDependencies;
			return TRUE;
		} // if:  dependencies changed

		return FALSE;

	} //*** BSaveDependencies()

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_RES_DEPENDENCIES; }

}; //*** class CResourceDependenciesPage

/////////////////////////////////////////////////////////////////////////////
// class CResourceAdvancedPage
/////////////////////////////////////////////////////////////////////////////

template < class T, class TSht >
class CResourceAdvancedPage : public CResourceAdvancedBasePage< T, TSht >
{
	typedef CResourceAdvancedPage< T, TSht > thisClass;
	typedef CResourceAdvancedBasePage< T, TSht > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CResourceAdvancedPage( void )
		: m_bAffectTheGroup( FALSE )
		, m_nRestart( -1 )
		, m_crraRestartAction( CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION )
		, m_nThreshold( CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD )
		, m_nPeriod( CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD )
		, m_nLooksAlive( CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE )
		, m_nIsAlive( CLUSTER_RESOURCE_DEFAULT_IS_ALIVE )
		, m_nPendingTimeout( CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT )
	{
	} //*** CResourceAdvancedPage()

	enum { IDD = IDD_RES_ADVANCED };

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( thisClass )
		COMMAND_HANDLER( IDC_RES_DONT_RESTART, BN_CLICKED, OnClickedDontRestart )
		COMMAND_HANDLER( IDC_RES_RESTART, BN_CLICKED, OnClickedRestart )
		COMMAND_HANDLER( IDC_RES_AFFECT_THE_GROUP, BN_CLICKED, OnChanged )
		COMMAND_HANDLER( IDC_RES_RESTART_THRESHOLD, EN_CHANGE, OnChanged )
		COMMAND_HANDLER( IDC_RES_RESTART_PERIOD, EN_CHANGE, OnChanged )
		COMMAND_HANDLER( IDC_RES_DEFAULT_LOOKS_ALIVE, BN_CLICKED, OnClickedDefaultLooksAlive )
		COMMAND_HANDLER( IDC_RES_SPECIFY_LOOKS_ALIVE, BN_CLICKED, OnClickedSpecifyLooksAlive )
		COMMAND_HANDLER( IDC_RES_LOOKS_ALIVE, EN_CHANGE, OnChangeLooksAlive )
		COMMAND_HANDLER( IDC_RES_DEFAULT_IS_ALIVE, BN_CLICKED, OnClickedDefaultIsAlive )
		COMMAND_HANDLER( IDC_RES_SPECIFY_IS_ALIVE, BN_CLICKED, OnClickedSpecifyIsAlive )
		COMMAND_HANDLER( IDC_RES_IS_ALIVE, EN_CHANGE, OnChangeIsAlive )
		COMMAND_HANDLER( IDC_RES_PENDING_TIMEOUT, EN_CHANGE, OnChanged )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	//
	// Message handler functions.
	//

	// Handler for BN_CLICKED on IDC_RES_DONT_RESTART
	LRESULT OnClickedDontRestart(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		//
		// Disable the restart parameter controls.
		//
		m_ckbAffectTheGroup.EnableWindow( FALSE );
		m_editThreshold.EnableWindow( FALSE );
		m_editPeriod.EnableWindow( FALSE );

		//
		// Set the page as modified if the state changed
		//
		if ( m_nRestart != 0 )
		{
			SetModified( TRUE );
		}  // if:  state changed

		return 0;

	} //*** OnClickedDontRestart()

	// Handler for BN_CLICKED on IDC_RES_RESTART
	LRESULT OnClickedRestart(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		//
		// Enable the restart parameter controls.
		//
		m_ckbAffectTheGroup.EnableWindow( TRUE );
		m_editThreshold.EnableWindow( TRUE );
		m_editPeriod.EnableWindow( TRUE );

		//
		// Set the page as modified if the state changed.
		//
		if ( m_nRestart != 1 )
		{
			SetModified( TRUE );
		}  // if:  state changed

		return 0;

	} //*** OnClickedRestart()

	// Default handler for clicking IDC_RES_DONT_RESTART
	void OnClickedDontRestart( void )
	{
		BOOL bHandled = TRUE;
		OnClickedDontRestart( 0, 0, 0, bHandled );

	} //*** OnClickedDontRestart()

	// Default handler for clicking IDC_RES_RESTART
	void OnClickedRestart( void )
	{
		BOOL bHandled = TRUE;
		OnClickedRestart( 0, 0, 0, bHandled );

	} //*** OnClickedRestart()

	// Handler for BN_CLICKED on IDC_RES_DEFAULT_LOOKS_ALIVE
	LRESULT OnClickedDefaultLooksAlive(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		m_editLooksAlive.SetReadOnly();

		if ( m_nLooksAlive != (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL )
		{
			CString	str;

			str.Format( _T("%d"), Pri()->NLooksAlive() );
			m_editLooksAlive.SetWindowText( str );

			m_rbDefaultLooksAlive.SetCheck( BST_CHECKED );
			m_rbSpecifyLooksAlive.SetCheck( BST_UNCHECKED );

			SetModified( TRUE );
		}  // if:  value changed

		return 0;

	} //*** OnClickedDefaultLooksAlive()

	// Handler for BN_CLICKED on IDC_RES_SPECIFY_LOOKS_ALIVE
	LRESULT OnClickedSpecifyLooksAlive(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		m_editLooksAlive.SetReadOnly( FALSE );

		if ( m_nLooksAlive == (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL )
		{
			SetModified( TRUE );
		} // if:  state changed

		return 0;

	} //*** OnClickedSpecifyLooksAlive()

	// Handler for EN_CHANGE on IDC_RES_LOOKS_ALIVE
	LRESULT OnChangeLooksAlive(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		m_rbDefaultLooksAlive.SetCheck( BST_UNCHECKED );
		m_rbSpecifyLooksAlive.SetCheck( BST_CHECKED );

		SetModified( TRUE );
		return 0;

	} //*** OnChangeLooksAlive()

	// Handler for BN_CLICKED on IDC_RES_DEFAULT_IS_ALIVE
	LRESULT OnClickedDefaultIsAlive(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		m_editIsAlive.SetReadOnly();

		if ( m_nIsAlive != (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL )
		{
			CString	str;

			str.Format( _T("%d"), Pri()->NIsAlive() );
			m_editIsAlive.SetWindowText( str );

			m_rbDefaultIsAlive.SetCheck( BST_CHECKED );
			m_rbSpecifyIsAlive.SetCheck( BST_UNCHECKED );

			SetModified( TRUE );
		}  // if:  value changed

		return 0;

	} //*** OnClickedDefaultIsAlive()

	// Handler for BN_CLICKED on IDC_RES_SPECIFY_IS_ALIVE
	LRESULT OnClickedSpecifyIsAlive(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		m_editIsAlive.SetReadOnly( FALSE );

		if ( m_nIsAlive == (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL )
		{
			SetModified( TRUE );
		} // if:  state changed

		return 0;

	} //*** OnClickedSpecifyIsAlive()

	// Handler for EN_CHANGE on IDC_RES_IS_ALIVE
	LRESULT OnChangeIsAlive(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		m_rbDefaultIsAlive.SetCheck( BST_UNCHECKED );
		m_rbSpecifyIsAlive.SetCheck( BST_CHECKED );

		SetModified( TRUE );
		return 0;

	} //*** OnChangeIsAlive()

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( BOOL bSaveAndValidate );

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

// Implementation
protected:
	//
	// Controls.
	//
	CButton	m_rbDontRestart;
	CButton	m_rbRestart;
	CEdit	m_editThreshold;
	CEdit	m_editPeriod;
	CButton	m_ckbAffectTheGroup;
	CButton	m_rbDefaultLooksAlive;
	CButton	m_rbSpecifyLooksAlive;
	CEdit	m_editLooksAlive;
	CButton	m_rbDefaultIsAlive;
	CButton	m_rbSpecifyIsAlive;
	CEdit	m_editIsAlive;
	CEdit	m_editPendingTimeout;

	//
	// Page state.
	//
	BOOL	m_bAffectTheGroup;
	int		m_nRestart;
	CRRA	m_crraRestartAction;
	DWORD	m_nThreshold;
	DWORD	m_nPeriod;
	DWORD	m_nLooksAlive;
	DWORD	m_nIsAlive;
	DWORD	m_nPendingTimeout;

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_RES_ADVANCED; }

}; //*** class CResourceAdvancedPage

/////////////////////////////////////////////////////////////////////////////
// class CIPAddrParametersPage
/////////////////////////////////////////////////////////////////////////////

class CIPAddrParametersPage
	: public CResourceAdvancedBasePage< CIPAddrParametersPage, CIPAddrAdvancedSheet >
{
	typedef CResourceAdvancedBasePage< CIPAddrParametersPage, CIPAddrAdvancedSheet > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CIPAddrParametersPage( void )
	{
	} //*** CIPAddrParametersPage()

	enum { IDD = IDD_RES_IP_PARAMS };

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( CIPAddrParametersPage )
		COMMAND_HANDLER( IDC_IPADDR_PARAMS_ADDRESS, EN_KILLFOCUS, OnKillFocusIPAddr )
		COMMAND_HANDLER( IDC_IPADDR_PARAMS_ADDRESS, EN_CHANGE, OnChanged )
		COMMAND_HANDLER( IDC_IPADDR_PARAMS_SUBNET_MASK, EN_CHANGE, OnChanged )
		COMMAND_HANDLER( IDC_IPADDR_PARAMS_NETWORK, CBN_SELCHANGE, OnChanged )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	// Handler for the EN_KILLFOCUS command notification on IDC_IPADDR_PARAMS_ADDRESS
	LRESULT OnKillFocusIPAddr(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		);

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( BOOL bSaveAndValidate );

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

// Implementation
protected:
	//
	// Controls.
	//
	CIPAddressCtrl	m_ipaIPAddress;
	CIPAddressCtrl	m_ipaSubnetMask;
	CComboBox		m_cboxNetworks;
	CButton			m_chkEnableNetBIOS;

	//
	// Page state.
	//
	CString			m_strIPAddress;
	CString			m_strSubnetMask;
	CString			m_strNetwork;
	BOOL			m_bEnableNetBIOS;

protected:
	CIPAddrAdvancedSheet * PshtThis( void ) const	{ return reinterpret_cast< CIPAddrAdvancedSheet * >( Psht() ); }

	// Fill the list of networks
	void FillNetworksList( void );

	// Get a network info object from an IP address
	CClusNetworkInfo * PniFromIpAddress( IN LPCWSTR pszAddress );

	// Select a network based on a network info object
	void SelectNetwork(IN OUT CClusNetworkInfo * pni);

	BOOL BSaveIPAddress( void )
	{
		if ( PshtThis()->m_strIPAddress != m_strIPAddress )
		{
			PshtThis()->m_strIPAddress = m_strIPAddress;
			return TRUE;
		} // if:  user changed info

		return FALSE;

	} //*** BSaveIPAddress()

	BOOL BSaveSubnetMask( void )
	{
		if ( PshtThis()->m_strSubnetMask != m_strSubnetMask )
		{
			PshtThis()->m_strSubnetMask = m_strSubnetMask;
			return TRUE;
		} // if:  user changed info

		return FALSE;

	} //*** BSaveSubnetMask()

	BOOL BSaveNetwork( void )
	{
		if ( PshtThis()->m_strNetwork != m_strNetwork )
		{
			PshtThis()->m_strNetwork = m_strNetwork;
			return TRUE;
		} // if:  user changed info

		return FALSE;

	} //*** BSaveNetwork()

	BOOL BSaveEnableNetBIOS( void )
	{
		if ( PshtThis()->m_bEnableNetBIOS != m_bEnableNetBIOS )
		{
			PshtThis()->m_bEnableNetBIOS = m_bEnableNetBIOS;
			return TRUE;
		} // if:  user changed info

		return FALSE;

	} //*** BSaveEnableNetBIOS()

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_RES_IP_PARAMS; }

}; //*** class CIPAddrParametersPage

/////////////////////////////////////////////////////////////////////////////
// class CNetNameParametersPage
/////////////////////////////////////////////////////////////////////////////

class CNetNameParametersPage
	: public CResourceAdvancedBasePage< CNetNameParametersPage, CNetNameAdvancedSheet >
{
	typedef CResourceAdvancedBasePage< CNetNameParametersPage, CNetNameAdvancedSheet > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CNetNameParametersPage( void )
	{
	} //*** CNetNameParametersPage()

	enum { IDD = IDD_RES_NETNAME_PARAMS };

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( CNetNameParametersPage )
		COMMAND_HANDLER( IDC_NETNAME_PARAMS_NAME, EN_CHANGE, OnChanged )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( BOOL bSaveAndValidate );

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

// Implementation
protected:
	//
	// Controls.
	//
	CEdit	m_editNetName;

	//
	// Page state.
	//
	CString		m_strNetName;

protected:
	CNetNameAdvancedSheet * PshtThis( void ) const	{ return reinterpret_cast< CNetNameAdvancedSheet * >( Psht() ); }

	BOOL BSaveNetName( void )
	{
		if ( PshtThis()->m_strNetName != m_strNetName )
		{
			PshtThis()->m_strNetName = m_strNetName;
			return TRUE;
		} // if:  user changed info

		return FALSE;

	} //*** BSaveNetName()

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_RES_NETNAME_PARAMS; }

}; //*** class CNetNameParametersPage

/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceGeneralPage
/////////////////////////////////////////////////////////////////////////////

class CGeneralResourceGeneralPage
	: public CResourceGeneralPage< CGeneralResourceGeneralPage, CGeneralResourceAdvancedSheet >
{
public:
	DECLARE_CTRL_NAME_MAP()

}; //*** class CGeneralResourceGeneralPage

/////////////////////////////////////////////////////////////////////////////
// class CIPAddrResourceGeneralPage
/////////////////////////////////////////////////////////////////////////////

class CIPAddrResourceGeneralPage
	: public CResourceGeneralPage< CIPAddrResourceGeneralPage , CIPAddrAdvancedSheet >
{
public:
	DECLARE_CTRL_NAME_MAP()

}; //*** class CIPAddrResourceGeneralPage

/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceDependenciesPage
/////////////////////////////////////////////////////////////////////////////

class CGeneralResourceDependenciesPage
	: public CResourceDependenciesPage< CGeneralResourceDependenciesPage, CGeneralResourceAdvancedSheet >
{
public:
	DECLARE_CTRL_NAME_MAP()

}; //*** class CGeneralResourceDependenciesPage

/////////////////////////////////////////////////////////////////////////////
// class CIPAddrResourceDependenciesPage
/////////////////////////////////////////////////////////////////////////////

class CIPAddrResourceDependenciesPage
	: public CResourceDependenciesPage< CIPAddrResourceDependenciesPage, CIPAddrAdvancedSheet >
{
public:
	DECLARE_CTRL_NAME_MAP()

}; //*** class CIPAddrResourceDependenciesPage

/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceAdvancedPage
/////////////////////////////////////////////////////////////////////////////

class CGeneralResourceAdvancedPage
	: public CResourceAdvancedPage< CGeneralResourceAdvancedPage, CGeneralResourceAdvancedSheet >
{
public:
	DECLARE_CTRL_NAME_MAP()

}; //*** class CGeneralResourceAdvancedPage

/////////////////////////////////////////////////////////////////////////////
// class CIPAddrResourceAdvancedPage
/////////////////////////////////////////////////////////////////////////////

class CIPAddrResourceAdvancedPage
	: public CResourceAdvancedPage< CIPAddrResourceAdvancedPage, CIPAddrAdvancedSheet >
{
public:
	DECLARE_CTRL_NAME_MAP()

}; //*** class CIPAddrResourceAdvancedPage

/////////////////////////////////////////////////////////////////////////////

#endif // __RESADV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin21.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ClAdmWiz.rc
//
#define IDS_PROJNAME                    100
#define IDS_CLASS_DISPLAY_NAME          101
#define IDR_CLUSAPPWIZ                  102
#define IDB_WELCOME                     120
#define IDB_HEADER                      121
#define IDB_RES_32                      122
#define IDD_WELCOME                     200
#define IDD_VIRTUAL_SERVER_CREATE       201
#define IDD_VIRTUAL_SERVER_GROUP        202
#define IDD_VIRTUAL_SERVER_GROUP_NAME   203
#define IDD_VIRTUAL_SERVER_ACCESS_INFO  204
#define IDD_VIRTUAL_SERVER_ADVANCED     205
#define IDD_APP_RESOURCE_CREATE         206
#define IDD_APP_RESOURCE_TYPE           207
#define IDD_APP_RESOURCE_NAME_DESC      208
#define IDD_COMPLETION                  210
#define IDD_ENTER_SUBNET_MASK           250
#define IDD_MODIFY_PREFERRED_OWNERS     251
#define IDD_MODIFY_POSSIBLE_OWNERS      252
#define IDD_MODIFY_DEPENDENCIES         253
#define IDD_GRPADV_GENERAL              260
#define IDD_GRPADV_FAILOVER             261
#define IDD_GRPADV_FAILBACK             262
#define IDD_RES_GENERAL                 265
#define IDD_RES_DEPENDENCIES            266
#define IDD_RES_ADVANCED                267
#define IDD_RES_IP_PARAMS               270
#define IDD_RES_NETNAME_PARAMS          271
#define IDR_MANIFEST                    700
#define IDC_WIZARD_BACKGROUND           1000
#define IDC_WIZARD_TITLE                1001
#define IDC_WIZARD_SUBTITLE_1           1002
#define IDC_WIZARD_SUBTITLE_2           1003
#define IDC_WIZARD_HORIZ_LINE           1004
#define IDC_WIZARD_PAGE_DESCRIPTION     1005
#define IDC_WIZARD_CLICK_NEXT           1006
#define IDC_WIZARD_LISTBOX              1010
#define IDC_VSC_CREATE_NEW              1020
#define IDC_VSC_USE_EXISTING            1021
#define IDC_VSC_VIRTUAL_SERVERS_LABEL   1022
#define IDC_VSC_VIRTUAL_SERVERS         1023
#define IDC_VSG_CREATE_NEW              1030
#define IDC_VSG_USE_EXISTING            1031
#define IDC_VSG_GROUPS_LABEL            1032
#define IDC_VSG_GROUPS                  1033
#define IDC_VSGN_GROUP_NAME_TITLE       1040
#define IDC_VSGN_GROUP_NAME_LABEL       1041
#define IDC_VSGN_GROUP_NAME             1042
#define IDC_VSGN_GROUP_DESC_TITLE       1043
#define IDC_VSGN_GROUP_DESC_LABEL       1044
#define IDC_VSGN_GROUP_DESC             1045
#define IDC_VSAI_NETWORK_NAME_LABEL     1050
#define IDC_VSAI_NETWORK_NAME           1051
#define IDC_VSAI_IP_ADDRESS_LABEL       1052
#define IDC_VSAI_IP_ADDRESS             1053
#define IDC_VSA_CATEGORIES_LABEL        1060
#define IDC_VSA_CATEGORIES              1061
#define IDC_VSA_ADVANCED_PROPS          1062
#define IDC_ARC_CREATE_RES              1070
#define IDC_ARC_DONT_CREATE_RES         1071
#define IDC_ART_RESTYPES_LABEL          1080
#define IDC_ART_RESTYPES                1081
#define IDC_ARND_RES_NAME_TITLE         1090
#define IDC_ARND_RES_NAME_LABEL         1091
#define IDC_ARND_RES_NAME               1092
#define IDC_ARND_RES_DESC_TITLE         1093
#define IDC_ARND_RES_DESC_LABEL         1094
#define IDC_ARND_RES_DESC               1095
#define IDC_ARND_ADVANCED_PROPS_LABEL   1096
#define IDC_ARND_ADVANCED_PROPS         1097
#define IDC_ESM_DESCRIPTION             1501
#define IDC_ESM_IP_ADDRESS_LABEL        1502
#define IDC_ESM_IP_ADDRESS              1503
#define IDC_ESM_SUBNET_MASK_LABEL       1504
#define IDC_ESM_SUBNET_MASK             1505
#define IDC_ESM_NETWORKS_LABEL          1506
#define IDC_ESM_NETWORKS                1507
#define IDC_GAG_NAME_LABEL              1510
#define IDC_GAG_NAME                    1511
#define IDC_GAG_DESC_LABEL              1512
#define IDC_GAG_DESC                    1513
#define IDC_GAG_PREF_OWNERS_LABEL       1514
#define IDC_GAG_PREF_OWNERS             1515
#define IDC_GAG_PREF_OWNERS_MODIFY      1516
#define IDC_GAFO_FAILOVER_DESCRIPTION   1520
#define IDC_GAFO_FAILOVER_THRESH_LABEL  1521
#define IDC_GAFO_FAILOVER_THRESH        1522
#define IDC_GAFO_FAILOVER_THRESH_SPIN   1523
#define IDC_GAFO_FAILOVER_PERIOD_LABEL  1524
#define IDC_GAFO_FAILOVER_PERIOD        1525
#define IDC_GAFO_FAILOVER_PERIOD_SPIN   1526
#define IDC_GAFO_FAILOVER_PERIOD_LABEL2 1527
#define IDC_GAFB_FAILBACK_DESCRIPTION   1530
#define IDC_GAFB_PREVENT_FAILBACK       1531
#define IDC_GAFB_ALLOW_FAILBACK_GROUP   1532
#define IDC_GAFB_ALLOW_FAILBACK         1533
#define IDC_GAFB_PREFERRED_OWNERS_DESCRIPTION 1534
#define IDC_GAFB_PREF_OWNERS_LABEL      1535
#define IDC_GAFB_PREF_OWNERS            1536
#define IDC_GAFB_PREF_OWNERS_MODIFY     1537
#define IDC_GAFB_FAILBACK_WHEN_DESCRIPTION 1538
#define IDC_GAFB_FAILBACK_IMMED         1539
#define IDC_GAFB_FAILBACK_WINDOW        1540
#define IDC_GAFB_FBWIN_START            1541
#define IDC_GAFB_FBWIN_START_SPIN       1542
#define IDC_GAFB_FB_WINDOW_LABEL1       1543
#define IDC_GAFB_FBWIN_END              1544
#define IDC_GAFB_FBWIN_END_SPIN         1545
#define IDC_GAFB_FB_WINDOW_LABEL2       1546
#define IDC_RES_NAME_LABEL              1550
#define IDC_RES_NAME                    1551
#define IDC_RES_DESC_LABEL              1552
#define IDC_RES_DESC                    1553
#define IDC_RES_POSSIBLE_OWNERS_LABEL   1554
#define IDC_RES_POSSIBLE_OWNERS         1555
#define IDC_RES_POSSIBLE_OWNERS_MODIFY  1556
#define IDC_RES_SEPARATE_MONITOR        1557
#define IDC_RES_NOTE                    1560
#define IDC_RES_DEPENDS_LIST_LABEL      1561
#define IDC_RES_DEPENDS_LIST            1562
#define IDC_RES_DEPENDS_MODIFY          1563
#define IDC_RES_PROPERTIES              1564
#define IDC_RES_DONT_RESTART            1570
#define IDC_RES_RESTART_GROUP           1571
#define IDC_RES_RESTART                 1572
#define IDC_RES_AFFECT_THE_GROUP        1573
#define IDC_RES_RESTART_THRESH_LABEL    1574
#define IDC_RES_RESTART_THRESHOLD       1575
#define IDC_RES_RESTART_PERIOD_LABEL    1576
#define IDC_RES_RESTART_PERIOD          1577
#define IDC_RES_RESTART_PERIOD_LABEL2   1578
#define IDC_RES_LOOKS_ALIVE_GROUP       1579
#define IDC_RES_DEFAULT_LOOKS_ALIVE     1580
#define IDC_RES_SPECIFY_LOOKS_ALIVE     1581
#define IDC_RES_LOOKS_ALIVE             1582
#define IDC_RES_SPECIFY_LOOKS_ALIVE_LABEL 1583
#define IDC_RES_IS_ALIVE_GROUP          1584
#define IDC_RES_DEFAULT_IS_ALIVE        1585
#define IDC_RES_SPECIFY_IS_ALIVE        1586
#define IDC_RES_IS_ALIVE                1587
#define IDC_RES_IS_ALIVE_LABEL          1588
#define IDC_RES_PENDING_TIMEOUT_LABEL   1589
#define IDC_RES_PENDING_TIMEOUT         1590
#define IDC_RES_PENDING_TIMEOUT_LABEL2  1591
#define IDC_IPADDR_PARAMS_ADDRESS_LABEL 1600
#define IDC_IPADDR_PARAMS_ADDRESS       1601
#define IDC_IPADDR_PARAMS_SUBNET_MASK_LABEL 1602
#define IDC_IPADDR_PARAMS_SUBNET_MASK   1603
#define IDC_IPADDR_PARAMS_NETWORK_LABEL 1604
#define IDC_IPADDR_PARAMS_NETWORK       1605
#define IDC_IPADDR_PARAMS_ENABLE_NETBIOS 1606
#define IDC_NETNAME_PARAMS_NAME_LABEL   1610
#define IDC_NETNAME_PARAMS_NAME         1611
#define IDS_EXTERIOR_TITLE_FONT_SIZE    20000
#define IDS_EXTERIOR_TITLE_FONT_NAME    20001
#define IDS_HDR_TITLE_VSD               20010
#define IDS_HDR_SUBTITLE_VSD            20011
#define IDS_HDR_TITLE_VSC               20012
#define IDS_HDR_SUBTITLE_VSC            20013
#define IDS_HDR_TITLE_VSG               20014
#define IDS_HDR_SUBTITLE_VSG            20015
#define IDS_HDR_TITLE_VSGN              20016
#define IDS_HDR_SUBTITLE_VSGN           20017
#define IDS_HDR_TITLE_VSAI              20018
#define IDS_HDR_SUBTITLE_VSAI           20019
#define IDS_HDR_TITLE_VSA               20020
#define IDS_HDR_SUBTITLE_VSA            20021
#define IDS_HDR_TITLE_VSCD              20022
#define IDS_HDR_SUBTITLE_VSCD           20023
#define IDS_HDR_TITLE_IRT               20024
#define IDS_HDR_SUBTITLE_IRT            20025
#define IDS_HDR_TITLE_ARC               20026
#define IDS_HDR_SUBTITLE_ARC            20027
#define IDS_HDR_TITLE_ART               20028
#define IDS_HDR_SUBTITLE_ART            20029
#define IDS_HDR_TITLE_ARND              20030
#define IDS_HDR_SUBTITLE_ARND           20031
#define IDS_HDR_TITLE_ARA               20032
#define IDS_HDR_SUBTITLE_ARA            20033
#define IDS_HDR_TITLE_ARCD              20034
#define IDS_HDR_SUBTITLE_ARCD           20035
#define IDS_RESTYPE_GENERIC_APPLICATION 20036
#define IDS_VSA_CAT_RES_GROUP_PROPS     20100
#define IDS_VSA_CAT_IP_ADDRESS_PROPS    20101
#define IDS_VSA_CAT_NET_NAME_PROPS      20102
#define IDS_IP_ADDRESS_SUFFIX           20110
#define IDS_NETWORK_NAME_SUFFIX         20111
#define IDS_ADV_GRP_PROP_TITLE          20200
#define IDS_ADV_IPADDR_PROP_TITLE       20201
#define IDS_ADV_NETNAME_PROP_TITLE      20202
#define IDS_ADV_RESOURCE_PROP_TITLE     20203
#define IDS_COLTEXT_RESOURCE_NAME       21000
#define IDS_COLTEXT_RESOURCE_TYPE       21001
#define IDS_COLTEXT_NODE_NAME           21002
#define IDS_COMPLETED_VIRTUAL_SERVER    21010
#define IDS_COMPLETED_NETWORK_NAME      21011
#define IDS_COMPLETED_IP_ADDRESS        21012
#define IDS_COMPLETED_NETWORK           21013
#define IDS_COMPLETED_APP_RESOURCE      21015
#define IDS_COMPLETED_APP_RESOURCE_TYPE 21016
#define IDS_COMPLETED_PROP_NAME_WIDTH   21020
#define IDS_COMPLETED_PROP_VALUE_WIDTH  21021
#define IDS_ERROR_MSG_ID                40600
#define IDS_REQUIRED_FIELD_EMPTY        40601
#define IDS_ERROR_OPEN_CLUSTER_ENUM     41000
#define IDS_ERROR_ENUM_CLUSTER          41001
#define IDS_ERROR_OPEN_GROUP            41002
#define IDS_ERROR_OPEN_GROUP_ENUM       41003
#define IDS_ERROR_ENUM_GROUP            41004
#define IDS_ERROR_CREATE_GROUP          41005
#define IDS_ERROR_RENAME_GROUP          41006
#define IDS_ERROR_DELETE_GROUP          41007
#define IDS_ERROR_GET_GROUP_PROPERTIES  41008
#define IDS_ERROR_SET_COMMON_GROUP_PROPS 41009
#define IDS_ERROR_GROUP_NAME_IN_USE     41010
#define IDS_ERROR_SET_PREFERRED_OWNERS  41011
#define IDS_ERROR_OPEN_NETWORK          41012
#define IDS_ERROR_GET_NETWORK_PROPERTIES 41013
#define IDS_ERROR_OPEN_RESOURCE         41014
#define IDS_ERROR_CREATE_RESOURCE       41015
#define IDS_ERROR_DELETE_RESOURCE       41016
#define IDS_ERROR_OPEN_RESOURCE_ENUM    41017
#define IDS_ERROR_ENUM_RESOURCE         41018
#define IDS_ERROR_ADD_DEPENDENCY        41019
#define IDS_ERROR_REMOVE_RESOURCE_OWNER 41020
#define IDS_ERROR_GET_RESOURCE_TYPE     41021
#define IDS_ERROR_GET_RESOURCE_PROPERTIES 41022
#define IDS_ERROR_GET_RESOURCE_TYPE_PROPERTIES 41023
#define IDS_ERROR_RESOURCE_NAME_IN_USE  41024
#define IDS_ERROR_SET_COMMON_RES_PROPS  41025
#define IDS_ERROR_SET_PRIVATE_RES_PROPS 41026
#define IDS_ERROR_OPEN_NODE             41027
#define IDS_ERROR_GET_NODE_PROPERTIES   41028
#define IDS_ERROR_CREATE_WIZ_PROPERTY_PAGE 41029
#define IDS_ERROR_REMOVE_DEPENDENCY     41030
#define IDS_ERROR_ADD_RESOURCE_OWNER    41031
#define IDS_ERROR_INVALID_IP_ADDRESS    41100
#define IDS_ERROR_INVALID_SUBNET_MASK   41101
#define IDS_ERROR_INVALID_ADDRESS_AND_SUBNET_MASK 41102
#define IDS_ERROR_SAME_START_AND_END    41103
#define IDS_ERROR_GET_CLUSTER_INFO      41104
#define IDS_ERROR_GET_CLUSTER_KEY       41105
#define IDS_ERROR_OPEN_CLUSTER_KEY      41106
#define IDS_ERROR_QUERY_VALUE           41107
#define IDS_ERROR_INVALID_NETWORK_NAME  41108
#define IDS_ERROR_INVALID_NETWORK_NAME_TOO_LONG 41109
#define IDS_ERROR_INVALID_NETWORK_NAME_INVALID_CHARS 41110
#define IDS_ERROR_INVALID_NETWORK_NAME_IN_USE 41111
#define IDS_ERROR_GET_RESTYPE_REQUIRED_DEPENDENCIES 41112
#define IDS_ERROR_REQUIRED_DEPENDENCY_NOT_FOUND 41113
#define IDS_ERROR_VALIDATING_NETWORK_NAME 41114
#define IDS_ERROR_CREATING_THREAD       41115
#define IDS_RESOURCE_TYPE_NOT_FOUND     41116
#define IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS 41117
#define IDP_NO_ERROR_AVAILABLE          61472
#define IDP_PARSE_INT_RANGE             61714
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        251
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         1515
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(__STDAFX_H_)
#define __STDAFX_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

//#define _DBG_MSG_NOTIFY
//#define _DBG_MSG_COMMAND

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define THIS_FILE __FILE__
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#define _CRTDBG_MAP_ALLOC
#endif // _DEBUG

//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>

// Disable some benign warnings.
#pragma warning(disable : 4100) // unreferenced formal parameter
#pragma warning(disable : 4505) // unreferenced local function has been removed
//#pragma warning(disable : 4245) // signed/unsigned mismatch

// Enable some warnings.
#pragma warning(error : 4706)  // assignment within conditional expression

//
// Enable cluster debug reporting
//
#if DBG
#define CLRTL_INCLUDE_DEBUG_REPORTING
#endif // DBG
#include "ClRtlDbg.h"
#define ASSERT _CLRTL_ASSERTE
#define ATLASSERT ASSERT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
#include "App.h"
extern CApp _Module;
#include <atlcom.h>

// atlwin.h needs this for the definition of DragAcceptFiles
#include <shellapi.h>

// atlwin.h needs this for the definition of psh1
#ifndef _DLGSH_INCLUDED_
#include <dlgs.h>
#endif

#if (_ATL_VER < 0x0300)
#include <atlwin21.h>
#endif //(_ATL_VER < 0x0300)

#ifndef _ASSERTE
#define _ASSERTE _CLRTL_ASSERTE
#endif

#include <atltmp.h>
#include <atlctrls.h>
#include <atlgdi.h>
#include <atlapp.h>
#include <atldlgs.h>

#include <shfusion.h>

#include <clusapi.h>
#include "clusudef.h"
#include "clusrtl.h"

#include "WaitCrsr.h"
#include "ExcOper.h"
#include "AtlUtil.h"
#include "TraceTag.h"
#include "App.inl"
#include "ClAdmWiz.h"

#if DBG
#include <crtdbg.h>
#endif // DBG

// Include parts of STL
#pragma warning(disable : 4244) // possible loss of data (for STL)
#pragma warning(disable : 4663) // C++ language change for explicit specialization (for STL)
#include <list>
#include <vector>
#include <algorithm>

typedef std::list< CString > cstringlist;

//#ifndef ASSERT
//#define ASSERT _ASSERTE
//#endif

#ifndef MAX_DWORD
#define MAX_DWORD ((DWORD)-1)
#endif // MAX_DWORD

#ifdef _DEBUG
//void * __cdecl operator new(size_t nSize, LPCSTR lpszFileName, int nLine);
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(__STDAFX_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\tracetag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		TraceTag.h
//
//	Abstract:
//		Definition of the CTraceTag class.
//
//	Implementation File:
//		TraceTag.cpp
//
//	Author:
//		David Potter (davidp)	May 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __TRACETAG_H_
#define __TRACETAG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

#if DBG || defined( _DEBUG )
class CTraceTag;
#endif // DBG || defined( _DEBUG )

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#define TRACE_TAG_REG_SECTION		TEXT("Debug")
#define TRACE_TAG_REG_SECTION_FMT	TRACE_TAG_REG_SECTION TEXT("\\%s")
#define TRACE_TAG_REG_FILE			TEXT("Trace File")

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	CTraceTag
//
//	Purpose:
//		Object containing a specific set of trace settings allowing trace
//		output to go to multiple outputs.
//
/////////////////////////////////////////////////////////////////////////////

#if DBG || defined( _DEBUG )
class CTraceTag : public CString
{
	friend class CTraceDialog;
	friend void InitAllTraceTags( void );
	friend void CleanupAllTraceTags( void );

public:
	CTraceTag( IN LPCTSTR pszSubsystem, IN LPCTSTR pszName, IN UINT uiFlagsDefault = NULL );
	~CTraceTag( void );

	enum TraceFlags
	{
		tfCom2		= 1,
		tfFile		= 2,
		tfDebug		= 4,
		tfBreak		= 8
	};

// Attributes
protected:
	UINT		m_uiFlags;
	UINT		m_uiFlagsDialog;
	UINT		m_uiFlagsDefault;
	UINT		m_uiFlagsDialogStart;	// of Selection...

	LPCTSTR		m_pszSubsystem;
	LPCTSTR		m_pszName;

	LPCTSTR		PszSubsystem( void )				{ return m_pszSubsystem; }
	LPCTSTR		PszName( void )						{ return m_pszName; }

	void		ConstructRegState( OUT CString & rstr );

	void		SetFlags( IN UINT tf, IN BOOL bEnable );
	void		SetFlagsDialog( IN UINT tf, IN BOOL bEnable );

	void		SetBCom2( IN BOOL bEnable )			{ SetFlags( tfCom2, bEnable ); }
	void		SetBCom2Dialog( IN BOOL bEnable )	{ SetFlagsDialog( tfCom2, bEnable ); }
	BOOL		BCom2Dialog( void ) const			{ return m_uiFlagsDialog & tfCom2 ? TRUE : FALSE; }

	void		SetBFile( IN BOOL bEnable )			{ SetFlags( tfFile, bEnable ); }
	void		SetBFileDialog( IN BOOL bEnable )	{ SetFlagsDialog( tfFile, bEnable ); }
	BOOL		BFileDialog( void ) const			{ return m_uiFlagsDialog & tfFile ? TRUE : FALSE; }

	void		SetBDebug( IN BOOL bEnable )		{ SetFlags( tfDebug, bEnable ); }
	void		SetBDebugDialog( IN BOOL bEnable )	{ SetFlagsDialog( tfDebug, bEnable ); }
	BOOL		BDebugDialog( void ) const			{ return m_uiFlagsDialog & tfDebug ? TRUE : FALSE; }

	void		SetBBreak( IN BOOL bEnable )		{ SetFlags( tfBreak, bEnable ); }
	void		SetBBreakDialog( IN BOOL bEnable )	{ SetFlagsDialog( tfBreak, bEnable ); }
	BOOL		BBreakDialog( void ) const			{ return m_uiFlagsDialog & tfBreak ? TRUE : FALSE; }

public:
	BOOL		BCom2( void ) const					{ return m_uiFlags & tfCom2 ? TRUE : FALSE; }
	BOOL		BFile( void ) const					{ return m_uiFlags & tfFile ? TRUE : FALSE; }
	BOOL		BDebug( void ) const				{ return m_uiFlags & tfDebug ? TRUE : FALSE; }
	BOOL		BBreak( void ) const				{ return m_uiFlags & tfBreak ? TRUE : FALSE; }
	BOOL		BAny( void ) const					{ return m_uiFlags != 0; }

// Operations
public:

// Implementation
public:
	void				TraceV( IN LPCTSTR pszFormat, va_list );

protected:
	void				Init( void );

	static LPCTSTR		s_pszCom2;
	static LPCTSTR		s_pszFile;
	static LPCTSTR		s_pszDebug;
	static LPCTSTR		s_pszBreak;

	static LPCTSTR		PszFile( void );

	static CTraceTag *	s_ptagFirst;
	static CTraceTag *	s_ptagLast;
	CTraceTag *			m_ptagNext;
//	static HANDLE			s_hfileCom2;

	static CRITICAL_SECTION	s_critsec;
	static BOOL				s_bCritSecValid;

	static BOOL				BCritSecValid( void ) { return s_bCritSecValid; }

};  //*** class CTraceTag

#endif // DBG || defined( _DEBUG )

/////////////////////////////////////////////////////////////////////////////
// Global Functions and Data
/////////////////////////////////////////////////////////////////////////////

#if DBG || defined( _DEBUG )

 extern		CTraceTag				g_tagAlways;
 extern		CTraceTag				g_tagError;
 void		Trace( IN OUT CTraceTag & rtag, IN LPCTSTR pszFormat, ... );
 void		TraceError( IN OUT CException & rexcept );
 void		TraceError( IN LPCTSTR pszModule, IN SC sc );
 void		InitAllTraceTags( void );
 void		CleanupAllTraceTags( void );
 void		TraceMenu( IN OUT CTraceTag & rtag, IN const CMenu * pmenu, IN LPCTSTR pszPrefix );

// extern		LPTSTR		g_pszTraceIniFile;
 extern		CString		g_strTraceFile;
 extern		BOOL		g_bBarfDebug;

#else // _DEBUG

 //			Expand to ";", <tab>, one "/" followed by another "/"
 //			(which is //).
 //			NOTE: This means the Trace statements have to be on ONE line.
 //			If you need multiple line Trace statements, enclose them in
 //			a #ifdef _DEBUG block.
 #define	Trace					;	/##/
 inline void TraceError( IN OUT CException & rexcept )		{ }
 inline void TraceError( IN LPCTSTR pszModule, IN SC sc )	{ }
 #define TraceMenu( _rtag, _pmenu, _pszPrefix )
 inline void InitAllTraceTags( void )						{ }
 inline void CleanupAllTraceTags( void )					{ }

#endif // DBG || defined( _DEBUG )

/////////////////////////////////////////////////////////////////////////////

#endif // __TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\tracetag.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		TraceTag.cpp
//
//	Abstract:
//		Implementation of the CTraceTag class.
//
//	Author:
//		David Potter (davidp)	May 28, 1996
//
//	Revision History:
//
//	Notes:
//
//		TRACE_GetApp() must be defined to return a pointer to an object
//		that defines the GetProfileString() method.
//
//		TRACE_AppMessageBox must be defined and implemented.
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <winnls.h>
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#if DBG || defined( _DEBUG )

#ifndef CP_ANSI
#define CP_ANSI 1252
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

CTraceTag	g_tagAlways( _T("Debug"), _T("Always"), CTraceTag::tfDebug );
CTraceTag	g_tagError( _T("Debug"), _T("Error"), CTraceTag::tfDebug );

// g_pszTraceIniFile must be an LPTSTR so it exists before "{" of WinMain.
// If we make it a CString, it may not be constructed when some of the
// tags are constructed, so we won't restore their value.
//LPTSTR		g_pszTraceIniFile		= _T("Trace.INI");
CString		g_strTraceFile;
BOOL		g_bBarfDebug			= TRUE;

CRITICAL_SECTION	CTraceTag::s_critsec;
BOOL				CTraceTag::s_bCritSecValid = FALSE;

#endif // DBG || defined( _DEBUG )

/////////////////////////////////////////////////////////////////////////////
// CTraceTag
/////////////////////////////////////////////////////////////////////////////

#if DBG || defined( _DEBUG )

//	Static Variables...

CTraceTag *		CTraceTag::s_ptagFirst	= NULL;
CTraceTag *		CTraceTag::s_ptagLast	= NULL;
//HANDLE			CTraceTag::s_hfileCom2	= NULL;
LPCTSTR			CTraceTag::s_pszCom2	= _T(" com2 ");
LPCTSTR			CTraceTag::s_pszFile	= _T(" file ");
LPCTSTR			CTraceTag::s_pszDebug	= _T(" debug ");
LPCTSTR			CTraceTag::s_pszBreak	= _T(" break ");

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::CTraceTag
//
//	Routine Description:
//		Constructor.  "Initializes" the tag by giving it its name, giving
//		it a startup value (from the registry if possible), and adding it
//		to the list of current tags.
//
//	Arguments:
//		pszSubsystem	[IN] 8 char string to say to what the tag applies
//		pszName			[IN] Description of the tag (~30 chars)
//		uiFlagsDefault	[IN] Default value.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTraceTag::CTraceTag(
	IN LPCTSTR	pszSubsystem,
	IN LPCTSTR	pszName,
	IN UINT		uiFlagsDefault
	)
{
	//	Store the calling parameters
	m_pszSubsystem = pszSubsystem;
	m_pszName = pszName;
	m_uiFlagsDefault = uiFlagsDefault;
	m_uiFlags = uiFlagsDefault;

	//	Add the tag to the list of tags
	if ( s_ptagLast != NULL )
	{
		s_ptagLast->m_ptagNext = this;
	} // if:  tag list not empty
	else
	{
		s_ptagFirst = this;
	} // else:  tag list is empty

	s_ptagLast = this;
	m_ptagNext = NULL;

	m_uiFlags = 0;

} //*** CTraceTag::CTraceTag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::~CTraceTag
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTraceTag::~CTraceTag( void )
{
#ifdef NEVER
	if ( s_hfileCom2 && (s_hfileCom2 != INVALID_HANDLE_VALUE) )
	{
		::CloseHandle( s_hfileCom2 );
		s_hfileCom2 = NULL;
	} // if:  tracing to COM port and valid COM port handle
#endif

} //*** CTraceTag::~CTraceTag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::Init
//
//	Routine Description:
//		Initializes the tag by giving it its name and giving it a startup value
//		(from the registry if possible).
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::Init( void )
{
	CString		strSection;
	CString		strValue;

	//	Get the value from the Registry.
	strSection.Format( TRACE_TAG_REG_SECTION_FMT, m_pszSubsystem );
	strValue = TRACE_GetApp()->GetProfileString( strSection, m_pszName );
	strValue.MakeLower();
	if ( strValue.Find( s_pszCom2 ) != -1 )
	{
		m_uiFlags |= tfCom2;
	} // if:  logging to COM port
	if ( strValue.Find( s_pszFile ) != -1 )
	{
		m_uiFlags |= tfFile;
	} // if:  logging to file
	if ( strValue.Find( s_pszDebug ) != -1 )
	{
		m_uiFlags |= tfDebug;
	} // if:  logging to debugger
	if ( strValue.Find( s_pszBreak ) != -1 )
	{
		m_uiFlags |= tfBreak;
	} // if:  breaking into debugger

} //*** CTraceTag::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::ConstructRegState
//
//	Routine Description:
//		Constructs the registry state string.
//
//	Arguments:
//		rstr		[OUT] String in which to return the state string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::ConstructRegState( OUT CString & rstr )
{
	rstr = _T("");
	if ( BDebug() )
	{
		rstr += s_pszDebug;
	} // if:  logging to debugger
	if ( BBreak() )
	{
		rstr += s_pszBreak;
	} // if:  breaking into debugger
	if ( BCom2() )
	{
		rstr += s_pszCom2;
	} // if:  logging to COM port
	if ( BFile() )
	{
		rstr += s_pszFile;
	} // if:  logging to file

} //*** CTraceTag::ConstructRegState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::SetFlags
//
//	Routine Description:
//		Sets/Resets TraceFlags.
//
//	Arguments:
//		tf			[IN] Flags to set.
//		bEnable		[IN] TRUE = set the flags, FALSE = clear the flags.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::SetFlags( IN UINT tf, IN BOOL bEnable )
{
	if ( bEnable )
	{
		m_uiFlags |= tf;
	} // if:  enabling flag
	else
	{
		m_uiFlags &= ~tf;
	} // else:  disabling flag

} //*** CTraceTag::SetFlags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::SetFlagsDialog
//
//	Routine Description:
//		Sets/Resets the "Dialog Settings"  version of the TraceFlags.
//
//	Arguments:
//		tf			[IN] Flags to set.
//		bEnable		[IN] TRUE = set the flags, FALSE = clear the flags.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::SetFlagsDialog( IN UINT tf, IN BOOL bEnable )
{
	if ( bEnable )
	{
		m_uiFlagsDialog |= tf;
	} // if:  enabling flag
	else
	{
		m_uiFlagsDialog &= ~tf;
	} // else:  disabling flag

} //*** CTraceTag::SetFlagsDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::PszFile
//
//	Routine Description:
//		Returns the name of the file where to write the trace output.
//		The filename is read from the registry if it is unknown.
//
//	Arguments:
//		None.
//
//	Return Value:
//		psz		Name of the file.
//
//--
/////////////////////////////////////////////////////////////////////////////
LPCTSTR CTraceTag::PszFile( void )
{
	static	BOOL	bInitialized	= FALSE;

	if ( ! bInitialized )
	{
		g_strTraceFile = TRACE_GetApp()->GetProfileString(
										TRACE_TAG_REG_SECTION,
										TRACE_TAG_REG_FILE,
										_T("C:\\Trace.out")
										);
		bInitialized = TRUE;
	} // if:  not initialized

	return g_strTraceFile;

} //*** CTraceTag::PszFile()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTraceTag::TraceV
//
//	Routine Description:
//		Processes a Trace statement based on the flags of the tag.
//
//	Arguments:
//		pszFormat	[IN] printf-style format string.
//		va_list		[IN] Argument block for the format string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::TraceV( IN LPCTSTR pszFormat, va_list marker )
{
	CString		strTraceMsg;
	LPSTR		psz;
	int			cb;
	int			cbActual;
	
	//
	// Get out quick with any formats if we're not turned on.
	//
	if ( ! m_pszName || ! BAny() )
	{
		return;
	} // if:  nothing to do

	if ( BCritSecValid() )
	{
		EnterCriticalSection( &s_critsec );
	} // if:  critical section has been initialized

	FormatV( pszFormat, marker );
	strTraceMsg.Format( _T("%s: %s\x0D\x0A"), m_pszName, m_pchData );

	//
	// Send trace output to the debug window.
	//
	if ( BDebug() )
	{
		OutputDebugString( strTraceMsg );
	} // if:  logging to debugger

	if ( BCom2() || BFile() )
	{
#ifdef _UNICODE
		// Not much point in sending UNICODE output to COMM or file at the moment,
		// so convert to ANSI
		CHAR	aszTraceMsg[256];
		cb = ::WideCharToMultiByte(
					CP_ANSI,
					NULL,
					strTraceMsg,
					strTraceMsg.GetLength(),
					aszTraceMsg,
					sizeof( aszTraceMsg ),
					NULL,
					NULL
					);
		psz = aszTraceMsg;
#else
		cb = strTraceMsg.GetLength();
		psz = (LPSTR) (LPCSTR) strTraceMsg;
#endif // _UNICODE

		// Send trace output to COM2.
		if ( BCom2() )
		{
			HANDLE			hfile			= INVALID_HANDLE_VALUE;
			static	BOOL	bOpenFailed		= FALSE;

			if ( ! bOpenFailed )
			{
				hfile = ::CreateFile(
								_T("COM2:"),
								GENERIC_WRITE,
								0,
								NULL,
								OPEN_EXISTING,
								FILE_FLAG_WRITE_THROUGH,
								NULL
								);
			} // if:  not currently in a 'COM2 failed to open' state
			
			if ( hfile != INVALID_HANDLE_VALUE )
			{
				ASSERT (::WriteFile( hfile, psz, cb, (LPDWORD) &cbActual, NULL ) );
//				ASSERT( ::FlushFileBuffers( hfile ) );
				ASSERT( ::CloseHandle( hfile ) );
			} // if:  COM2 opened successfully
			else
			{
				if ( ! bOpenFailed )
				{
					bOpenFailed = TRUE;		// Do this first, so the str.Format
											// do not cause problems with their trace statement.

					TRACE_AppMessageBox( _T("COM2 could not be opened."), MB_OK | MB_ICONINFORMATION );
				} // if:  open file didn't fail
			} // else:  file not opened successfully
		} // if:  sending trace output to COM2

		// Send trace output to a file.
		if ( BFile() )
		{
			HANDLE			hfile			= INVALID_HANDLE_VALUE;
			static	BOOL	bOpenFailed		= FALSE;

			if ( ! bOpenFailed )
			{
				hfile = ::CreateFile(
								PszFile(),
								GENERIC_WRITE,
								FILE_SHARE_WRITE,
								NULL,
								OPEN_ALWAYS,
								FILE_FLAG_WRITE_THROUGH,
								NULL
								);
			} // if:  not currently in a 'file failed to open' state

			if ( hfile != INVALID_HANDLE_VALUE )
			{
				// Fail these calls silently to avoid recursive failing calls.
				::SetFilePointer( hfile, NULL, NULL, FILE_END );
				::WriteFile( hfile, psz, cb, (LPDWORD) &cbActual, NULL );
				::CloseHandle( hfile );
			} // if:  file opened successfully
			else
			{
				if ( ! bOpenFailed )
				{
					CString		strMsg;

					bOpenFailed = TRUE;		// Do this first, so the str.Format
											// do not cause problems with their trace statement.

					strMsg.Format( _T("The DEBUG ONLY trace log file '%s' could not be opened"), PszFile() );
					TRACE_AppMessageBox( strMsg, MB_OK | MB_ICONINFORMATION );
				} // if:  open file didn't fail
			} // else:  file not opened successfully
		} // if:  sending trace output to a file
	} // if:  tracing to com and/or file

	// Do a DebugBreak on the trace.
	if ( BBreak() )
	{
		DebugBreak();
	} // if:  breaking into the debugger

	if ( BCritSecValid() )
	{
		LeaveCriticalSection( &s_critsec );
	} // if:  critical section has been initialized

} //*** CTraceTag::TraceFn()

#endif // DBG || defined( _DEBUG )


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

#if DBG || defined( _DEBUG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Trace
//
//	Routine Description:
//		Maps the Trace statement to the proper method call.  This is needed
//		(instead of doing directly ptag->Trace()) to guarantee that no code
//		is added in the retail build.
//
//	Arguments:
//		rtag		[IN OUT] Tag controlling the debug output
//		pszFormat	[IN] printf style formatting string.
//		...			[IN] printf style parameters, depends on pszFormat
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void Trace( IN OUT CTraceTag & rtag, IN LPCTSTR pszFormat, ... )
{
	va_list		marker;

	va_start( marker, pszFormat );
	rtag.TraceV( pszFormat, marker );
	va_end( marker );

} //*** Trace()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	TraceError
//
//	Routine Description:
//		Formats a standard error string and outputs it to all trace outputs.
//
//	Arguments:
//		rexcept		[IN OUT] Exception from which to obtain the message.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceError( IN OUT CException & rexcept )
{
	TCHAR			szMessage[1024];

	rexcept.GetErrorMessage( szMessage, sizeof( szMessage ) / sizeof( TCHAR ) );

	Trace(
		g_tagError,
		_T("EXCEPTION: %s"),
		szMessage
		);

} //*** TraceError(CException&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	TraceError
//
//	Routine Description:
//		Formats a standard error string and outputs it to all trace outputs.
//
//	Arguments:
//		pszModule	[IN] Name of module in which error occurred.
//		sc			[IN] NT status code.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceError( IN LPCTSTR pszModule, IN SC sc )
{
	TCHAR			szMessage[1024];
	CNTException	nte( sc );

	nte.GetErrorMessage( szMessage, sizeof( szMessage ) / sizeof( TCHAR ) );

	Trace(
		g_tagError,
		_T("Module %s, SC = %#08lX = %d (10)\r\n = '%s'"),
		pszModule,
		sc,
		sc,
		szMessage
		);

} //*** TraceError(pszModule, sc)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	InitAllTraceTags
//
//	Routine Description:
//		Initializes all trace tags in the tag list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void InitAllTraceTags( void )
{
	CTraceTag *	ptag;

	// Loop through the tag list.
	for ( ptag = CTraceTag::s_ptagFirst ; ptag != NULL ; ptag = ptag->m_ptagNext )
	{
		ptag->Init();
	} // for:  each trace tag

	InitializeCriticalSection( &CTraceTag::s_critsec );
	CTraceTag::s_bCritSecValid = TRUE;

} //*** InitAllTraceTags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CleanupAllTraceTags
//
//	Routine Description:
//		Cleanup after the trace tags.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CleanupAllTraceTags(void)
{
	if ( CTraceTag::BCritSecValid() )
	{
		DeleteCriticalSection( &CTraceTag::s_critsec );
		CTraceTag::s_bCritSecValid = FALSE;
	} // if:  critical section is valid

} //*** CleanupAllTraceTags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	TraceMenu
//
//	Routine Description:
//		Display information about menus.
//
//	Arguments:
//		rtag		[IN OUT] Trace tag to use to display information.
//		pmenu		[IN] Menu to traverse.
//		pszPrefix	[IN] Prefix string to display.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceMenu(
	IN OUT CTraceTag &	rtag,
	IN const CMenu *	pmenu,
	IN LPCTSTR			pszPrefix
	)
{
	if ( rtag.BAny() )
	{
		UINT	cItems;
		UINT	iItem;
		UINT	nState;
		CString	strMenu;
#ifndef __AFXWIN_H__
		BSTR	bstrMenu;
#endif
		CString	strPrefix(pszPrefix);
		
		strPrefix += _T("->");

		cItems = pmenu->GetMenuItemCount();
		for ( iItem = 0 ; iItem < cItems ; iItem++ )
		{
#ifdef __AFXWIN_H__
			pmenu->GetMenuString( iItem, strMenu, MF_BYPOSITION );
#else // __ATLGDI_H__ must be defined
			pmenu->GetMenuString( iItem, bstrMenu, MF_BYPOSITION );
			strMenu = bstrMenu;
			SysFreeString( bstrMenu );
#endif
			nState = pmenu->GetMenuState( iItem, MF_BYPOSITION );
			if ( nState & MF_SEPARATOR )
			{
				strMenu += _T("SEPARATOR");
			} // if:  menu item is a separate
			if ( nState & MF_CHECKED )
			{
				strMenu += _T(" (checked)");
			} // if:  menu item is checked
			if ( nState & MF_DISABLED )
			{
				strMenu += _T(" (disabled)");
			} // if:  menu item is disabled
			if ( nState & MF_GRAYED )
			{
				strMenu += _T(" (grayed)");
			} // if:  menu item is grayed
			if ( nState & MF_MENUBARBREAK )
			{
				strMenu += _T(" (MenuBarBreak)");
			} // if:  menu item is a menu bar break
			if ( nState & MF_MENUBREAK )
			{
				strMenu += _T(" (MenuBreak)");
			} // if:  menu item is a menu break
			if ( nState & MF_POPUP )
			{
				strMenu += _T(" (popup)");
			} // if:  menu item is a popup menu

			Trace( rtag, _T("(0x%08.8x) %s%s"), pszPrefix, pmenu->m_hMenu, strMenu );

			if ( nState & MF_POPUP )
			{
#ifdef __AFXWIN_H__
				TraceMenu( rtag, pmenu->GetSubMenu( iItem ), strPrefix );
#else // __ATLGDI_H__ must be defined
				CMenu submenu( pmenu->GetSubMenu( iItem ) );
				TraceMenu( rtag, &submenu, strPrefix );
			} // if:  popup menu
#endif // __AFXWIN_H__
		} // for:  each item in the menu
	} // if:  any output is enabled

} //*** TraceMenu()

struct AFX_MAP_MESSAGE
{
	UINT    nMsg;
	LPCSTR  lpszMsg;
};

#include "dde.h"
#define DEFINE_MESSAGE(wm)  { wm, #wm }

static const AFX_MAP_MESSAGE allMessages[] =
{
	DEFINE_MESSAGE( WM_CREATE ),
	DEFINE_MESSAGE( WM_DESTROY ),
	DEFINE_MESSAGE( WM_MOVE ),
	DEFINE_MESSAGE( WM_SIZE ),
	DEFINE_MESSAGE( WM_ACTIVATE ),
	DEFINE_MESSAGE( WM_SETFOCUS ),
	DEFINE_MESSAGE( WM_KILLFOCUS ),
	DEFINE_MESSAGE( WM_ENABLE ),
	DEFINE_MESSAGE( WM_SETREDRAW ),
	DEFINE_MESSAGE( WM_SETTEXT ),
	DEFINE_MESSAGE( WM_GETTEXT ),
	DEFINE_MESSAGE( WM_GETTEXTLENGTH ),
	DEFINE_MESSAGE( WM_PAINT ),
	DEFINE_MESSAGE( WM_CLOSE ),
	DEFINE_MESSAGE( WM_QUERYENDSESSION ),
	DEFINE_MESSAGE( WM_QUIT ),
	DEFINE_MESSAGE( WM_QUERYOPEN ),
	DEFINE_MESSAGE( WM_ERASEBKGND ),
	DEFINE_MESSAGE( WM_SYSCOLORCHANGE ),
	DEFINE_MESSAGE( WM_ENDSESSION ),
	DEFINE_MESSAGE( WM_SHOWWINDOW ),
	DEFINE_MESSAGE( WM_CTLCOLORMSGBOX ),
	DEFINE_MESSAGE( WM_CTLCOLOREDIT ),
	DEFINE_MESSAGE( WM_CTLCOLORLISTBOX ),
	DEFINE_MESSAGE( WM_CTLCOLORBTN ),
	DEFINE_MESSAGE( WM_CTLCOLORDLG ),
	DEFINE_MESSAGE( WM_CTLCOLORSCROLLBAR ),
	DEFINE_MESSAGE( WM_CTLCOLORSTATIC ),
	DEFINE_MESSAGE( WM_WININICHANGE ),
	DEFINE_MESSAGE( WM_DEVMODECHANGE ),
	DEFINE_MESSAGE( WM_ACTIVATEAPP ),
	DEFINE_MESSAGE( WM_FONTCHANGE ),
	DEFINE_MESSAGE( WM_TIMECHANGE ),
	DEFINE_MESSAGE( WM_CANCELMODE ),
	DEFINE_MESSAGE( WM_SETCURSOR ),
	DEFINE_MESSAGE( WM_MOUSEACTIVATE ),
	DEFINE_MESSAGE( WM_CHILDACTIVATE ),
	DEFINE_MESSAGE( WM_QUEUESYNC ),
	DEFINE_MESSAGE( WM_GETMINMAXINFO ),
	DEFINE_MESSAGE( WM_ICONERASEBKGND ),
	DEFINE_MESSAGE( WM_NEXTDLGCTL ),
	DEFINE_MESSAGE( WM_SPOOLERSTATUS ),
	DEFINE_MESSAGE( WM_DRAWITEM ),
	DEFINE_MESSAGE( WM_MEASUREITEM ),
	DEFINE_MESSAGE( WM_DELETEITEM ),
	DEFINE_MESSAGE( WM_VKEYTOITEM ),
	DEFINE_MESSAGE( WM_CHARTOITEM ),
	DEFINE_MESSAGE( WM_SETFONT ),
	DEFINE_MESSAGE( WM_GETFONT ),
	DEFINE_MESSAGE( WM_QUERYDRAGICON ),
	DEFINE_MESSAGE( WM_COMPAREITEM ),
	DEFINE_MESSAGE( WM_COMPACTING ),
	DEFINE_MESSAGE( WM_NCCREATE ),
	DEFINE_MESSAGE( WM_NCDESTROY ),
	DEFINE_MESSAGE( WM_NCCALCSIZE ),
	DEFINE_MESSAGE( WM_NCHITTEST ),
	DEFINE_MESSAGE( WM_NCPAINT ),
	DEFINE_MESSAGE( WM_NCACTIVATE ),
	DEFINE_MESSAGE( WM_GETDLGCODE ),
	DEFINE_MESSAGE( WM_NCMOUSEMOVE ),
	DEFINE_MESSAGE( WM_NCLBUTTONDOWN ),
	DEFINE_MESSAGE( WM_NCLBUTTONUP ),
	DEFINE_MESSAGE( WM_NCLBUTTONDBLCLK ),
	DEFINE_MESSAGE( WM_NCRBUTTONDOWN ),
	DEFINE_MESSAGE( WM_NCRBUTTONUP ),
	DEFINE_MESSAGE( WM_NCRBUTTONDBLCLK ),
	DEFINE_MESSAGE( WM_NCMBUTTONDOWN ),
	DEFINE_MESSAGE( WM_NCMBUTTONUP ),
	DEFINE_MESSAGE( WM_NCMBUTTONDBLCLK ),
	DEFINE_MESSAGE( WM_KEYDOWN ),
	DEFINE_MESSAGE( WM_KEYUP ),
	DEFINE_MESSAGE( WM_CHAR ),
	DEFINE_MESSAGE( WM_DEADCHAR ),
	DEFINE_MESSAGE( WM_SYSKEYDOWN ),
	DEFINE_MESSAGE( WM_SYSKEYUP ),
	DEFINE_MESSAGE( WM_SYSCHAR ),
	DEFINE_MESSAGE( WM_SYSDEADCHAR ),
	DEFINE_MESSAGE( WM_KEYLAST ),
	DEFINE_MESSAGE( WM_INITDIALOG ),
	DEFINE_MESSAGE( WM_COMMAND ),
	DEFINE_MESSAGE( WM_SYSCOMMAND ),
	DEFINE_MESSAGE( WM_TIMER ),
	DEFINE_MESSAGE( WM_HSCROLL ),
	DEFINE_MESSAGE( WM_VSCROLL ),
	DEFINE_MESSAGE( WM_INITMENU ),
	DEFINE_MESSAGE( WM_INITMENUPOPUP ),
	DEFINE_MESSAGE( WM_MENUSELECT ),
	DEFINE_MESSAGE( WM_MENUCHAR ),
	DEFINE_MESSAGE( WM_ENTERIDLE ),
	DEFINE_MESSAGE( WM_MOUSEMOVE ),
	DEFINE_MESSAGE( WM_LBUTTONDOWN ),
	DEFINE_MESSAGE( WM_LBUTTONUP ),
	DEFINE_MESSAGE( WM_LBUTTONDBLCLK ),
	DEFINE_MESSAGE( WM_RBUTTONDOWN ),
	DEFINE_MESSAGE( WM_RBUTTONUP ),
	DEFINE_MESSAGE( WM_RBUTTONDBLCLK ),
	DEFINE_MESSAGE( WM_MBUTTONDOWN ),
	DEFINE_MESSAGE( WM_MBUTTONUP ),
	DEFINE_MESSAGE( WM_MBUTTONDBLCLK ),
	DEFINE_MESSAGE( WM_PARENTNOTIFY ),
	DEFINE_MESSAGE( WM_MDICREATE ),
	DEFINE_MESSAGE( WM_MDIDESTROY ),
	DEFINE_MESSAGE( WM_MDIACTIVATE ),
	DEFINE_MESSAGE( WM_MDIRESTORE ),
	DEFINE_MESSAGE( WM_MDINEXT ),
	DEFINE_MESSAGE( WM_MDIMAXIMIZE ),
	DEFINE_MESSAGE( WM_MDITILE ),
	DEFINE_MESSAGE( WM_MDICASCADE ),
	DEFINE_MESSAGE( WM_MDIICONARRANGE ),
	DEFINE_MESSAGE( WM_MDIGETACTIVE ),
	DEFINE_MESSAGE( WM_MDISETMENU ),
	DEFINE_MESSAGE( WM_CUT ),
	DEFINE_MESSAGE( WM_COPY ),
	DEFINE_MESSAGE( WM_PASTE ),
	DEFINE_MESSAGE( WM_CLEAR ),
	DEFINE_MESSAGE( WM_UNDO ),
	DEFINE_MESSAGE( WM_RENDERFORMAT ),
	DEFINE_MESSAGE( WM_RENDERALLFORMATS ),
	DEFINE_MESSAGE( WM_DESTROYCLIPBOARD ),
	DEFINE_MESSAGE( WM_DRAWCLIPBOARD ),
	DEFINE_MESSAGE( WM_PAINTCLIPBOARD ),
	DEFINE_MESSAGE( WM_VSCROLLCLIPBOARD ),
	DEFINE_MESSAGE( WM_SIZECLIPBOARD ),
	DEFINE_MESSAGE( WM_ASKCBFORMATNAME ),
	DEFINE_MESSAGE( WM_CHANGECBCHAIN ),
	DEFINE_MESSAGE( WM_HSCROLLCLIPBOARD ),
	DEFINE_MESSAGE( WM_QUERYNEWPALETTE ),
	DEFINE_MESSAGE( WM_PALETTEISCHANGING ),
	DEFINE_MESSAGE( WM_PALETTECHANGED ),
	DEFINE_MESSAGE( WM_DDE_INITIATE ),
	DEFINE_MESSAGE( WM_DDE_TERMINATE ),
	DEFINE_MESSAGE( WM_DDE_ADVISE ),
	DEFINE_MESSAGE( WM_DDE_UNADVISE ),
	DEFINE_MESSAGE( WM_DDE_ACK ),
	DEFINE_MESSAGE( WM_DDE_DATA ),
	DEFINE_MESSAGE( WM_DDE_REQUEST ),
	DEFINE_MESSAGE( WM_DDE_POKE ),
	DEFINE_MESSAGE( WM_DDE_EXECUTE ),
	DEFINE_MESSAGE( WM_DROPFILES ),
	DEFINE_MESSAGE( WM_POWER ),
	DEFINE_MESSAGE( WM_WINDOWPOSCHANGED ),
	DEFINE_MESSAGE( WM_WINDOWPOSCHANGING ),
#ifdef __AFXWIN_H__
// MFC specific messages
	DEFINE_MESSAGE( WM_SIZEPARENT ),
	DEFINE_MESSAGE( WM_SETMESSAGESTRING ),
	DEFINE_MESSAGE( WM_IDLEUPDATECMDUI ),
	DEFINE_MESSAGE( WM_INITIALUPDATE ),
	DEFINE_MESSAGE( WM_COMMANDHELP ),
	DEFINE_MESSAGE( WM_HELPHITTEST ),
	DEFINE_MESSAGE( WM_EXITHELPMODE ),
#endif // __AFXWIN_H__
	DEFINE_MESSAGE( WM_HELP ),
	DEFINE_MESSAGE( WM_NOTIFY ),
	DEFINE_MESSAGE( WM_CONTEXTMENU ),
	DEFINE_MESSAGE( WM_TCARD ),
	DEFINE_MESSAGE( WM_MDIREFRESHMENU ),
	DEFINE_MESSAGE( WM_MOVING ),
	DEFINE_MESSAGE( WM_STYLECHANGED ),
	DEFINE_MESSAGE( WM_STYLECHANGING ),
	DEFINE_MESSAGE( WM_SIZING ),
	DEFINE_MESSAGE( WM_SETHOTKEY ),
	DEFINE_MESSAGE( WM_PRINT ),
	DEFINE_MESSAGE( WM_PRINTCLIENT ),
	DEFINE_MESSAGE( WM_POWERBROADCAST ),
	DEFINE_MESSAGE( WM_HOTKEY ),
	DEFINE_MESSAGE( WM_GETICON ),
	DEFINE_MESSAGE( WM_EXITMENULOOP ),
	DEFINE_MESSAGE( WM_ENTERMENULOOP ),
	DEFINE_MESSAGE( WM_DISPLAYCHANGE ),
	DEFINE_MESSAGE( WM_STYLECHANGED ),
	DEFINE_MESSAGE( WM_STYLECHANGING ),
	DEFINE_MESSAGE( WM_GETICON ),
	DEFINE_MESSAGE( WM_SETICON ),
	DEFINE_MESSAGE( WM_SIZING ),
	DEFINE_MESSAGE( WM_MOVING ),
	DEFINE_MESSAGE( WM_CAPTURECHANGED ),
	DEFINE_MESSAGE( WM_DEVICECHANGE ),
	DEFINE_MESSAGE( WM_PRINT ),
	DEFINE_MESSAGE( WM_PRINTCLIENT ),
// MFC private messages
#ifdef __AFXWIN_H__
	DEFINE_MESSAGE( WM_QUERYAFXWNDPROC ),
	DEFINE_MESSAGE( WM_RECALCPARENT ),
	DEFINE_MESSAGE( WM_SIZECHILD ),
	DEFINE_MESSAGE( WM_KICKIDLE ),
	DEFINE_MESSAGE( WM_QUERYCENTERWND ),
	DEFINE_MESSAGE( WM_DISABLEMODAL ),
	DEFINE_MESSAGE( WM_FLOATSTATUS ),
	DEFINE_MESSAGE( WM_ACTIVATETOPLEVEL ),
	DEFINE_MESSAGE( WM_QUERY3DCONTROLS ),
	DEFINE_MESSAGE( WM_RESERVED_0370 ),
	DEFINE_MESSAGE( WM_RESERVED_0371 ),
	DEFINE_MESSAGE( WM_RESERVED_0372 ),
	DEFINE_MESSAGE( WM_SOCKET_NOTIFY ),
	DEFINE_MESSAGE( WM_SOCKET_DEAD ),
	DEFINE_MESSAGE( WM_POPMESSAGESTRING ),
	DEFINE_MESSAGE( WM_OCC_LOADFROMSTREAM ),
	DEFINE_MESSAGE( WM_OCC_LOADFROMSTORAGE ),
	DEFINE_MESSAGE( WM_OCC_INITNEW ),
	DEFINE_MESSAGE( WM_OCC_LOADFROMSTREAM_EX ),
	DEFINE_MESSAGE( WM_OCC_LOADFROMSTORAGE_EX ),
	DEFINE_MESSAGE( WM_QUEUE_SENTINEL ),
	DEFINE_MESSAGE( WM_RESERVED_037C ),
	DEFINE_MESSAGE( WM_RESERVED_037D ),
	DEFINE_MESSAGE( WM_RESERVED_037E ),
	DEFINE_MESSAGE( WM_RESERVED_037F ),
#endif // __AFXWIN_H_
	{ 0, NULL, }   // end of message list
};

#undef DEFINE_MESSAGE
#define _countof( array ) (sizeof( array )/sizeof( array[0] ))

void TraceMsg( LPCTSTR lpszPrefix, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam )
{
	ASSERT( lpszPrefix != NULL );

	if (   (message == WM_MOUSEMOVE) || (message == WM_NCMOUSEMOVE)
		|| (message == WM_NCHITTEST)
		|| (message == WM_SETCURSOR)
		|| (message == WM_CTLCOLORBTN)
		|| (message == WM_CTLCOLORDLG)
		|| (message == WM_CTLCOLOREDIT)
		|| (message == WM_CTLCOLORLISTBOX)
		|| (message == WM_CTLCOLORMSGBOX)
		|| (message == WM_CTLCOLORSCROLLBAR)
		|| (message == WM_CTLCOLORSTATIC)
		|| (message == WM_ENTERIDLE)
		|| (message == WM_CANCELMODE)
		|| (message == 0x0118)    // WM_SYSTIMER (caret blink)
		)
	{
		// don't report very frequently sent messages
		return;
	} // if:  frequently sent message

	LPCSTR lpszMsgName = NULL;
	char szBuf[80];

	// find message name
	if ( message >= 0xC000 )
	{
		// Window message registered with 'RegisterWindowMessage'
		//  (actually a USER atom)
		if ( ::GetClipboardFormatNameA( message, szBuf, _countof( szBuf ) ) )
		{
			lpszMsgName = szBuf;
		} // if:  registered message
	}
	else if ( message >= WM_USER )
	{
		// User message
		wsprintfA( szBuf, "WM_USER+0x%04X", message - WM_USER );
		lpszMsgName = szBuf;
	} // else if:  WM_USER message
	else
	{
		// a system windows message
		const AFX_MAP_MESSAGE * pMapMsg = allMessages;
		for ( /*null*/; pMapMsg->lpszMsg != NULL; pMapMsg++ )
		{
			if ( pMapMsg->nMsg == message )
			{
				lpszMsgName = pMapMsg->lpszMsg;
				break;
			} // if:  found a match
		} // for:  each message in the table
	} // else:  other message

	if ( lpszMsgName != NULL )
	{
		AtlTrace(
			_T("%s: hwnd=0x%p, msg = %hs (0x%04X, 0x%08lX)\n"),
			lpszPrefix,
			hwnd,
			lpszMsgName,
			wParam,
			lParam
			);
	} // if:  message found
	else
	{
		AtlTrace(
			_T("%s: hwnd=0x%p, msg = 0x%04X (0x%04X, 0x%08lX)\n"),
			lpszPrefix,
			hwnd,
			message,
			wParam,
			lParam
			);
	} // else:  unknown message

//#ifndef _MAC
//	if ( message >= WM_DDE_FIRST && message <= WM_DDE_LAST )
//		TraceDDE( lpszPrefix, pMsg );
//#endif

} //*** TraceMsg()

#endif // DBG || defined( _DEBUG )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\vsaccess.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		VSAccess.h
//
//	Abstract:
//		Definition of the CWizPageVSAccessInfo class.
//
//	Implementation File:
//		VSAccess.cpp
//
//	Author:
//		David Potter (davidp)	December 9, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VSACCESS_H_
#define __VSACCESS_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSAccessInfo;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusNetworkInfo;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSAccessInfo
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSAccessInfo : public CClusterAppStaticWizardPage< CWizPageVSAccessInfo >
{
	typedef CClusterAppStaticWizardPage< CWizPageVSAccessInfo > baseClass;

public:
	//
	// Construction
	//

	// Default constructor
	CWizPageVSAccessInfo( void )
	{
	} //*** CCWizPageVSAccessInfo()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_VSAI )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_VSAI )

	enum { IDD = IDD_VIRTUAL_SERVER_ACCESS_INFO };

public:
	//
	// CWizardPageWindow public methods.
	//

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( IN BOOL bSaveAndValidate );

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( CWizPageVSAccessInfo )
		COMMAND_HANDLER( IDC_VSAI_NETWORK_NAME, EN_CHANGE, OnChangedNetName )
		COMMAND_HANDLER( IDC_VSAI_IP_ADDRESS, EN_CHANGE, OnChangedIPAddr )
		COMMAND_HANDLER( IDC_VSAI_IP_ADDRESS, EN_KILLFOCUS, OnKillFocusIPAddr )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	// Handler for the EN_CHANGE command notification on IDC_VSAI_NETWORK_NAME
	LRESULT OnChangedNetName(
		WORD /*wNotifyCode*/,
		WORD /*idCtrl*/,
		HWND /*hwndCtrl*/,
		BOOL & /*bHandled*/
		)
	{
		CheckForRequiredFields();
		return 0;

	} //*** OnChangedNetName()

	// Handler for the EN_CHANGE command notification on IDC_VSAI_IP_ADDRESS
	LRESULT OnChangedIPAddr(
		WORD /*wNotifyCode*/,
		WORD /*idCtrl*/,
		HWND /*hwndCtrl*/,
		BOOL & /*bHandled*/
		)
	{
		CheckForRequiredFields();
		return 0;

	} //*** OnChangedIPAddr()

	// Handler for the EN_KILLFOCUS command notification on IDC_VSAI_IP_ADDRESS
	LRESULT OnKillFocusIPAddr(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		);

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

// Implementation
protected:
	//
	// Controls.
	//
	CEdit			m_editNetName;
	CIPAddressCtrl	m_ipaIPAddress;
	CComboBox		m_cboxNetworks;

	//
	// Page state.
	//
	CString			m_strNetName;
	CString			m_strIPAddress;
	CString			m_strSubnetMask;
	CString			m_strNetwork;

	// Check for required fields and enable/disable Next button
	void CheckForRequiredFields( void )
	{
		int cchNetName = m_editNetName.GetWindowTextLength();
		BOOL bIsIPAddrBlank = m_ipaIPAddress.IsBlank();
		BOOL bEnable = (cchNetName > 0) && ! bIsIPAddrBlank;
		EnableNext( bEnable );

	} //*** CheckForRequiredFields()

	// Get a network info object from an IP address
	CClusNetworkInfo * PniFromIpAddress( IN LPCWSTR pszAddress );

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_VIRTUAL_SERVER_ACCESS_INFO; }

}; //*** class CWizPageVSAccessInfo

/////////////////////////////////////////////////////////////////////////////

#endif // __VSACCESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\vsaccess.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1999 Microsoft Corporation
//
//  Module Name:
//      VSAccess.cpp
//
//  Abstract:
//      Implementation of the CWizPageVSAccessInfo class.
//
//  Author:
//      David Potter (davidp)   December 9, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VSAccess.h"
#include "ClusAppWiz.h"
#include "AdmNetUtils.h"    // for BIsValidxxx network functions
#include "WizThread.h"      // for CWizardThread
#include "EnterSubnet.h"    // for CEnterSubnetMaskDlg

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSAccessInfo
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageVSAccessInfo )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSAI_NETWORK_NAME_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSAI_NETWORK_NAME )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSAI_IP_ADDRESS_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSAI_IP_ADDRESS )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAccessInfo::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSAccessInfo::OnInitDialog(void)
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_editNetName, IDC_VSAI_NETWORK_NAME );
    AttachControl( m_ipaIPAddress, IDC_VSAI_IP_ADDRESS );

    //
    // Set limits on edit controls.
    //
    m_editNetName.SetLimitText( MAX_CLUSTERNAME_LENGTH );

    PwizThis()->BCollectNetworks( GetParent() );

    return TRUE;

} //*** CWizPageVSAccessInfo::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAccessInfo::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSAccessInfo::UpdateData( IN BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    // Loop to avoid goto's.
    do
    {
        if ( bSaveAndValidate )
        {
            if ( ! BBackPressed() )
            {
                CString     strTempNetName;
                CString     strTempIPAddress;

                DDX_GetText( m_hWnd, IDC_VSAI_NETWORK_NAME, strTempNetName );
                DDX_GetText( m_hWnd, IDC_VSAI_IP_ADDRESS, strTempIPAddress );

                if (    ! DDV_RequiredText( m_hWnd, IDC_VSAI_NETWORK_NAME, IDC_VSAI_NETWORK_NAME_LABEL, strTempNetName )
                    ||  ! DDV_RequiredText( m_hWnd, IDC_VSAI_IP_ADDRESS, IDC_VSAI_IP_ADDRESS_LABEL, strTempIPAddress )
                    )
                {
                    bSuccess = FALSE;
                    break;
                } // if:  required text not specified

                //
                // If the IP address has changed, validate it.
                //
                if ( strTempIPAddress != PwizThis()->RstrIPAddress() )
                {
                    BOOL bHandled = TRUE;

                    if ( ! BIsValidIpAddress( strTempIPAddress ) )
                    {
                        CString strMsg;
                        strMsg.FormatMessage( IDS_ERROR_INVALID_IP_ADDRESS, strTempIPAddress );
                        AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
                        bSuccess = FALSE;
                        break;
                    }  // if:  invalid IP address

                    // The IP address has changed - recompute the subnet mask and network.
                    m_strSubnetMask.Empty();
                    m_strNetwork.Empty();

                    //
                    // Make sure we process the IP address.
                    // If we don't call it here, and the user pressed Next
                    // while sitting in the IP address field, the EN_KILLFOCUS
                    // message won't get processed until after this method returns.
                    //
                    OnKillFocusIPAddr( EN_KILLFOCUS, IDC_VSAI_IP_ADDRESS, m_ipaIPAddress.m_hWnd, bHandled );

                    //
                    // If no subnet mask has been specified yet, make the
                    // user enter it manually.
                    //
                    if (    ( m_strSubnetMask.GetLength() == 0 )
                        ||  ( m_strNetwork.GetLength() == 0 )
                        )
                    {
                        CEnterSubnetMaskDlg dlg( strTempIPAddress, m_strSubnetMask, m_strNetwork, PwizThis() );
                        if ( dlg.DoModal() == IDOK )
                        {
                            m_strSubnetMask = dlg.RstrSubnetMask();
                            m_strNetwork = dlg.RstrNetwork();
                        } // if:  user accepted subnet mask
                        else
                        {
                            bSuccess = FALSE;
                            break;
                        } // else:  user cancelled subnet mask.
                    } // if:  no subnet mask specified yet
                } // if:  the IP address has changed

                //
                // If the network name has changed, validate it.
                //
                if ( strTempNetName != PwizThis()->RstrNetName() )
                {
                    CLRTL_NAME_STATUS cnStatus;

                    if ( ! ClRtlIsNetNameValid( strTempNetName, &cnStatus, FALSE /*CheckIfExists*/) )
                    {
                        CString     strMsg;
                        UINT        idsError;

                        switch ( cnStatus )
                        {
                            case NetNameTooLong:
                                idsError = IDS_ERROR_INVALID_NETWORK_NAME_TOO_LONG;
                                break;
                            case NetNameInvalidChars:
                                idsError = IDS_ERROR_INVALID_NETWORK_NAME_INVALID_CHARS;
                                break;
                            case NetNameInUse:
                                idsError = IDS_ERROR_INVALID_NETWORK_NAME_IN_USE;
                                break;
                            case NetNameDNSNonRFCChars:
                                idsError = IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS;
                                break;
                            case NetNameSystemError:
                            {
                                DWORD scError = GetLastError();
                                CNTException nte( scError, IDS_ERROR_VALIDATING_NETWORK_NAME, (LPCWSTR) strTempNetName );
                                nte.ReportError();
                                break;
                            }
                            default:
                                idsError = IDS_ERROR_INVALID_NETWORK_NAME;
                                break;
                        }  // switch:  cnStatus

                        if ( cnStatus != NetNameSystemError )
                        {
                            strMsg.LoadString( idsError );

                            if ( idsError == IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS ) {
                                int id = AppMessageBox( m_hWnd, strMsg, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION );

                                if ( id == IDNO )
                                {
                                    bSuccess = FALSE;
                                }
                            }
                            else
                            {
                                AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
                                bSuccess = FALSE;
                            }
                        } // if:  popup not displayed yet

                        if ( ! bSuccess )
                        {
                            break;
                        }
                    }  // if:  invalid network name
                }  // if:  the network name has changed

                //
                // These two variables contain the net name and the IP address that will be
                // the sheet when we leave this page.
                //
                m_strNetName = strTempNetName;
                m_strIPAddress = strTempIPAddress;
            } // if:  Back button not presssed
            else
            {
                //
                // These two variables contain the net name and the IP address that will be
                // the sheet when we leave this page. This is needed to compare against the 
                // sheet data the next time we enter this page. If the sheet data is different
                // from this data, it means that the user has changed the data elsewhere and
                // the sheet data is reloaded into the UI. If the data has not changed in the
                // sheet then what is in the UI is the latest data and so it left unchanged.
                //
                m_strNetName = PwizThis()->RstrNetName();
                m_strIPAddress = PwizThis()->RstrIPAddress();
            } // if:  Back button has been pressed
        } // if:  saving data from the page
        else
        {
            //
            // If the copy of the data stored in this sheet is different from
            // the copy of the data in the sheet, then the user has changed the
            // data elsewhere in the wizard. So, reload it.
            // If not, we should not change the UI since it may contain unvalidated
            // user input.
            //
            if ( m_strNetName != PwizThis()->RstrNetName() )
            {
                m_editNetName.SetWindowText( PwizThis()->RstrNetName() );
            } // if:  the page copy of the net name is different from the sheet copy

            if ( m_strIPAddress != PwizThis()->RstrIPAddress() )
            {
                m_ipaIPAddress.SetWindowText( PwizThis()->RstrIPAddress() );
            } // if:  the page copy of the IP address is different from the sheet copy
        } // else:  setting data to the page
    } while ( 0 );

    return bSuccess;

} //*** CWizPageVSAccessInfo::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAccessInfo::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSAccessInfo::BApplyChanges( void )
{
    if (    ! PwizThis()->BSetNetName( m_strNetName )
        ||  ! PwizThis()->BSetIPAddress( m_strIPAddress )
        ||  ! PwizThis()->BSetSubnetMask( m_strSubnetMask )
        ||  ! PwizThis()->BSetNetwork( m_strNetwork ) )
    {
        return FALSE;
    } // if:  error setting data in the wizard

    return TRUE;

} //*** CWizPageVSAccessInfo::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAccessInfo::OnKillFocusIPAddr
//
//  Routine Description:
//      Handler for the EN_KILLFOCUS command notification on IDC_VSAI_IP_ADDRESS.
//
//  Arguments:
//      bHandled    [IN OUT] TRUE = we handled message (default).
//
//  Return Value:
//      TRUE        Page activated successfully.
//      FALSE       Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CWizPageVSAccessInfo::OnKillFocusIPAddr(
    WORD /*wNotifyCode*/,
    WORD /*idCtrl*/,
    HWND /*hwndCtrl*/,
    BOOL & bHandled
    )
{
    CString             strAddress;
    CString             strMsg;
    CClusNetworkInfo *  pni;

    BSTR bstr = NULL;
    m_ipaIPAddress.GetWindowText( bstr );
    strAddress = bstr;
    SysFreeString( bstr );
    bstr = NULL;

    if ( strAddress.GetLength() == 0 )
    {
        ((CEdit &) m_ipaIPAddress).SetSel( 0, 0, FALSE );
    } // if:  empty string
    else if ( ! BIsValidIpAddress( strAddress ) )
    {
    } // else if:  invalid address
    else
    {
        pni = PniFromIpAddress( strAddress );
        if ( pni != NULL )
        {
            m_strNetwork = pni->RstrName();
            m_strSubnetMask = pni->RstrAddressMask();
        } // if:  network found
        else
        {
            //m_strSubnetMask = _T("");
        } // else:  network not found
    } // else:  valid address

    bHandled = FALSE;
    return 0;

} //*** CWizPageVSAccessInfo::OnKillFocusIPAddr()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAccessInfo::PniFromIpAddress
//
//  Routine Description:
//      Find the network for the specified IP address.
//
//  Arguments:
//      pszAddress      [IN] IP address to match.
//
//  Return Value:
//      NULL            No matching network found.
//      pni             Network that supports the specfied IP address.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetworkInfo * CWizPageVSAccessInfo::PniFromIpAddress( IN LPCWSTR pszAddress )
{
    DWORD               dwStatus;
    DWORD               nAddress;
    CClusNetworkInfo *  pni;

    //
    // Convert the address to a number.
    //
    dwStatus = ClRtlTcpipStringToAddress( pszAddress, &nAddress );
    if ( dwStatus != ERROR_SUCCESS )
    {
        return NULL;
    } // if:  error converting the address to a number

    //
    // Search the list for a matching address.
    //
    CClusNetworkPtrList::iterator itnet;
    for ( itnet = PwizThis()->PlpniNetworks()->begin()
        ; itnet != PwizThis()->PlpniNetworks()->end()
        ; itnet++ )
    {
        pni = *itnet;
        if ( ClRtlAreTcpipAddressesOnSameSubnet( nAddress, pni->NAddress(), pni->NAddressMask() ) )
        {
            return pni;
        } // if:  IP address is on this network
    }  // while:  more items in the list

    return NULL;

}  //*** CWizPageVSAccessInfo::PniFromIpAddress()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\vsadv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		VSAdv.cpp
//
//	Abstract:
//		Implementation of the CWizPageVSAdvanced class.
//
//	Author:
//		David Potter (davidp)	December 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VSAdv.h"
#include "ClusAppWiz.h"
#include "GrpAdv.h"			// for CGroupAdvancedSheet
#include "ResAdv.h"			// for CResourceAdvancedSheet

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSAdvanced
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageVSAdvanced )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSA_DESCRIPTION_1 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSA_DESCRIPTION_2 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSA_CATEGORIES_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSA_CATEGORIES )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSA_ADVANCED_PROPS )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_CLICK_NEXT )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSAdvanced::OnInitDialog
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		psht		[IN] Property sheet object to which this page belongs.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Error initializing the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSAdvanced::BInit( IN CBaseSheetWindow * psht )
{
	//
	// Call the base class method.
	//
	if ( ! baseClass::BInit( psht ) )
	{
		return FALSE;
	} // if:  error calling base class method

	return TRUE;

} //*** CWizPageVSAdvanced::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSAdvanced::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSAdvanced::OnInitDialog( void )
{
	//
	// Attach the controls to control member variables.
	//
	AttachControl( m_lbCategories, IDC_VSA_CATEGORIES );

	//
	// Get info from the sheet.
	//

	//
	// Fill the list of categories.
	//
	FillListBox();

	return TRUE;

} //*** CWizPageVSAdvanced::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSAdvanced::OnSetActive
//
//	Routine Description:
//		Handler for PSN_SETACTIVE.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Page activated successfully.
//		FALSE		Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSAdvanced::OnSetActive( void )
{
	//
	// Get info from the sheet.
	//

	//
	// Call the base class and return.
	//
	return baseClass::OnSetActive();

} //*** CWizPageVSAdvanced::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSAdvanced::OnWizardBack
//
//	Routine Description:
//		Handler for PSN_WIZBACK.
//
//	Arguments:
//		None.
//
//	Return Value:
//		0				Move to previous page.
//		-1				Don't move to previous page.
//		anything else	Move to specified page.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CWizPageVSAdvanced::OnWizardBack( void )
{
	int _nResult;

	//
	// Call the base class.  This causes our UpdateData() method to get
	// called.  If it succeeds, save our values.
	//
	_nResult = baseClass::OnWizardBack();
	if ( _nResult != -1 )
	{
		if ( ! BApplyChanges() ) 
		{
			_nResult = -1;
		} // if:  applying changes failed
	} // if:  base class called successfully

	return _nResult;

} //*** CWizPageVSAdvanced::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSAdvanced::BApplyChanges
//
//	Routine Description:
//		Apply changes made on this page to the sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		The data was applied successfully.
//		FALSE		An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSAdvanced::BApplyChanges( void )
{
	BOOL	_bSuccess = TRUE;

	if ( BAnythingChanged() )
	{
		//
		// If the cluster has been updated, reset the cluster.
		//
		if ( PwizThis()->BClusterUpdated() )
		{
			if ( ! PwizThis()->BResetCluster() )
			{
				return FALSE;
			} // if:  failed to reset the cluster
		} // if:  cluster was updated
		PwizThis()->SetVSDataChanged();
	} // if: anything changed

	//
	// Create the group and resources as appropriate.
	//
	if ( PwizThis()->BVSDataChanged() && ! BBackPressed() )
	{
		_bSuccess = PwizThis()->BCreateVirtualServer();
		if ( _bSuccess )
		{
			m_bGroupChanged = FALSE;
			m_bIPAddressChanged = FALSE;
			m_bNetworkNameChanged = FALSE;
		} // if: virtual server created successfully
	} // if:  virtual server data changed

	return _bSuccess;

} //*** CWizPageVSAdvanced::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSAdvanced::OnAdvancedProps
//
//	Routine Description:
//		Command handler to display advanced properties.  This is the handler
//		for the BN_CLICKED command notification on IDC_VSA_ADVANCED_PROPS, and
//		for the LBN_DBLCLK command notification on IDC_VSA_CATEGORIES.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Ignored.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CWizPageVSAdvanced::OnAdvancedProps(
	WORD /*wNotifyCode*/,
	WORD /*idCtrl*/,
	HWND /*hwndCtrl*/,
	BOOL & /*bHandled*/
	)
{
	CWaitCursor		_wc;
	int				_idx;

	//
	// Make sure nodes have been collected already.
	//
	if ( ! PwizThis()->BCollectedNodes() )
	{
		//
		// Collect the nodes in the cluster.
		//
		if ( PwizThis()->BCollectNodes( GetParent() ) )
		{
		} // if:  nodes collected successfully
	} // if:  nodes haven't been collected yet

	//
	// Get the current selection in the list box.
	//
	_idx = m_lbCategories.GetCurSel();
	ASSERT( _idx != LB_ERR );
	ASSERT( 0 <= _idx && _idx <= 2 );

	//
	// Display a property sheet based on which item is selected.
	//
	switch ( _idx )
	{
		case 0:
			{
				CGroupAdvancedSheet _sht( IDS_ADV_GRP_PROP_TITLE );

				if ( _sht.BInit( PwizThis()->RgiCurrent(), PwizThis(), m_bGroupChanged ) )
				{
					_sht.DoModal( m_hWnd );
				} // if:  sheet successfully initialized
			}
			break;
		case 1:
			{
				CIPAddrAdvancedSheet _sht( IDS_ADV_IPADDR_PROP_TITLE, PwizThis() );

				if ( _sht.BInit( PwizThis()->RriIPAddress(), m_bIPAddressChanged ) )
				{
					int _idReturn;

					_sht.InitPrivateData(
						PwizThis()->RstrIPAddress(),
						PwizThis()->RstrSubnetMask(),
						PwizThis()->RstrNetwork(),
						PwizThis()->BEnableNetBIOS(),
						PwizThis()->PlpniNetworks()
						);
					_idReturn = _sht.DoModal( m_hWnd );
					if ( _idReturn != IDCANCEL )
					{
						PwizThis()->BSetIPAddress( _sht.m_strIPAddress );
						PwizThis()->BSetSubnetMask( _sht.m_strSubnetMask );
						PwizThis()->BSetNetwork( _sht.m_strNetwork );
						PwizThis()->BSetEnableNetBIOS( _sht.m_bEnableNetBIOS );
					} // if:  sheet not canceled
				} // if:  sheet successfully initialized
			}
			break;
		case 2:
			{
				CNetNameAdvancedSheet _sht( IDS_ADV_NETNAME_PROP_TITLE, PwizThis() );

				if ( _sht.BInit( PwizThis()->RriNetworkName(), m_bNetworkNameChanged ) )
				{
					int _idReturn;

					_sht.InitPrivateData( PwizThis()->RstrNetName() );
					_idReturn = _sht.DoModal( m_hWnd );
					if ( _idReturn != IDCANCEL )
					{
						PwizThis()->BSetNetName( _sht.m_strNetName );
					} // if:  sheet not canceled
				} // if:  sheet successfully initialized
			}
			break;
		default:
			_ASSERT( 0 );
	} // switch:  idx

	return 0;

} //*** CWizPageVSAdvanced::OnAdvancedProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSAdvanced::FillListBox
//
//	Routine Description:
//		Fill the list control with a list of advanced property categories.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizPageVSAdvanced::FillListBox( void )
{
	CWaitCursor	_wc;
	CString		_strType;

	//
	// Add each property type to the list.
	//

	_strType.LoadString( IDS_VSA_CAT_RES_GROUP_PROPS );
	m_lbCategories.InsertString( 0, _strType );

	_strType.LoadString( IDS_VSA_CAT_IP_ADDRESS_PROPS );
	m_lbCategories.InsertString( 1, _strType );

	_strType.LoadString( IDS_VSA_CAT_NET_NAME_PROPS );
	m_lbCategories.InsertString( 2, _strType );

	//
	// Set the current selection.
	//
	m_lbCategories.SetCurSel( 0 );

} //*** CWizPageVSAdvanced::FillListBox()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\vscreate.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSCreate.cpp
//
//	Abstract:
//		Implementation of the CWizPageVSCreate class.
//
//	Author:
//		David Potter (davidp)	December 5, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VSCreate.h"
#include "ClusAppWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSCreate
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageVSCreate )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSC_CREATE_NEW )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSC_USE_EXISTING )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSC_VIRTUAL_SERVERS_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSC_VIRTUAL_SERVERS )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSCreate::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSCreate::OnInitDialog( void )
{
	//
	// Attach the controls to control member variables.
	//
	AttachControl( m_rbCreateNew, IDC_VSC_CREATE_NEW );
	AttachControl( m_rbUseExisting, IDC_VSC_USE_EXISTING );
	AttachControl( m_cboxVirtualServers, IDC_VSC_VIRTUAL_SERVERS );

	//
	// Get info from the sheet.
	//
	m_bCreateNew = PwizThis()->BCreatingNewVirtualServer();

	//
	// Stuff below here requires the groups to have been fully collected
	// so we can know which are virtual servers and which are not.
	//
	PwizThis()->WaitForGroupsToBeCollected();

	//
	// If there is no virtual server group yet, check to see if there is a
	// default virtual server name specified.  If not, clear the virtual server
	// name.  Otherwise, get the virtual name from the virtual server group.
	// This is only needed if the caller of the wizard passed in a
	// virtual server name.
	//
	if ( PwizThis()->PgiExistingVirtualServer() == NULL )
	{
		if (   (PcawData() != NULL )
			&& ! PcawData()->bCreateNewVirtualServer
			&& (PcawData()->pszVirtualServerName != NULL) )
		{
			m_strVirtualServer = PcawData()->pszVirtualServerName;
		} // if:  default data was specified
		else
		{
			m_strVirtualServer.Empty();
		} // else:  no default data specified
	} // if:  no existing virtual server yet
	else
	{
		m_strVirtualServer = PwizThis()->PgiExistingVirtualServer()->RstrName();
	} // else:  existing virtual server already specified

	//
	// Fill the list of virtual servers.
	//
	FillComboBox();

	return TRUE;

} //*** CWizPageVSCreate::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSCreate::UpdateData
//
//	Routine Description:
//		Update data on or from the page.
//
//	Arguments:
//		bSaveAndValidate	[IN] TRUE if need to read data from the page.
//								FALSE if need to set data to the page.
//
//	Return Value:
//		TRUE		The data was updated successfully.
//		FALSE		An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSCreate::UpdateData( IN BOOL bSaveAndValidate )
{
	BOOL	bSuccess = TRUE;

	if ( bSaveAndValidate )
	{
		BOOL bChecked = (m_rbCreateNew.GetCheck() == BST_CHECKED);
		m_bCreateNew = bChecked;
		if ( ! bChecked )
		{
			//
			// Save the combobox selection.
			//
			DDX_GetText( m_hWnd, IDC_VSC_VIRTUAL_SERVERS, m_strVirtualServer );

			if ( ! BBackPressed() )
			{
				if ( ! DDV_RequiredText( m_hWnd, IDC_VSC_VIRTUAL_SERVERS, IDC_VSC_VIRTUAL_SERVERS_LABEL, m_strVirtualServer ) )
				{
					return FALSE;
				} // if:  virtual server not specified
			} // if:  Back button not presssed

			//
			// Save the group info pointer.
			//
			int idx = m_cboxVirtualServers.GetCurSel();
			ASSERT( idx != CB_ERR );
			m_pgi = (CClusGroupInfo *) m_cboxVirtualServers.GetItemDataPtr( idx );
		} // if:  using an existing virtual server
	} // if: saving data from the page
	else
	{
		if ( m_bCreateNew )
		{
			//
			// Default the radio button selection.
			//
			m_rbCreateNew.SetCheck( BST_CHECKED );
			m_rbUseExisting.SetCheck( BST_UNCHECKED );

		} // if:  creating new virtual server
		else
		{
			//
			// Default the radio button selection.
			//
			m_rbCreateNew.SetCheck( BST_UNCHECKED );
			m_rbUseExisting.SetCheck( BST_CHECKED );

			//
			// Set the combobox selection.
			//
//			DDX_SetComboBoxText( m_hWnd, IDC_VSC_VIRTUAL_SERVERS, m_strVirtualServer, TRUE /*bRequired*/ );
		} // else:  using existing virtual server

		//
		// Enable/disable the combobox.
		//
		m_cboxVirtualServers.EnableWindow( ! m_bCreateNew /*bEnable*/ );

	} // else:  setting data to the page

	return bSuccess;

} //*** CWizPageVSCreate::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSCreate::BApplyChanges
//
//	Routine Description:
//		Apply changes made on this page to the sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		The data was applied successfully.
//		FALSE		An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSCreate::BApplyChanges( void )
{
	//
	// Save the current state.
	//
	if ( ! PwizThis()->BSetCreatingNewVirtualServer( m_bCreateNew, m_pgi ) )
	{
		return FALSE;
	} // if:  error setting new state

	//
	// If using an existing server, skip all the virtual server pages and
	// move right to the create resource pages.
	//
	if ( ! m_bCreateNew )
	{
		SetNextPage( IDD_APP_RESOURCE_CREATE );
	} // if:  using existing virtual server

	return TRUE;

} //*** CWizPageVSCreate::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSCreate::FillComboBox
//
//	Routine Description:
//		Fill the combobox with a list of existing virtual servers.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizPageVSCreate::FillComboBox( void )
{
	// Loop to avoid goto's.
	do
	{
		//
		// Collect the list of groups.
		//
		if ( ! PwizThis()->BCollectGroups( GetParent() ) )
		{
			break;
		} // if:  error collecting groups

		//
		// For each group in the cluster, find out if it is a virtual server
		// or not.  If so then add it to the combobox.
		//

		CClusGroupPtrList::iterator itgrp;
		int idx;
		for ( itgrp = PwizThis()->PlpgiGroups()->begin()
			; itgrp != PwizThis()->PlpgiGroups()->end()
			; itgrp++ )
		{
			//
			// If this is a virtual server, add it to the list.
			// Save a pointer to the group info object with the string
			// so we can retrieve it with the selection later.
			//
			CClusGroupInfo * pgi = *itgrp;
			if ( pgi->BIsVirtualServer() )
			{
				idx = m_cboxVirtualServers.AddString( pgi->RstrName() );
				ASSERT( idx != CB_ERR );
				m_cboxVirtualServers.SetItemDataPtr( idx, (void *) pgi );
			} // if:  group is a virtual server
		} // for:  each entry in the list

		//
		// Select the currently saved entry, or the first one if none are
		// currently saved.
		//
		if ( m_strVirtualServer.GetLength() == 0 )
		{
			m_cboxVirtualServers.SetCurSel( 0 );
		} // if:  no virtual server yet
		else
		{
			int idx = m_cboxVirtualServers.FindStringExact( -1, m_strVirtualServer );
			ASSERT( idx != CB_ERR );
			if ( idx != CB_ERR )
			{
				m_cboxVirtualServers.SetCurSel( idx );
			} // if:  virtual server found in list
		} // else:  virtual server saved
	} while ( 0 );

} //*** CWizPageVSCreate::FillComboBox()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\vscreate.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSCreate.h
//
//	Abstract:
//		Definition of the CWizPageVSCreate class.
//
//	Implementation File:
//		VSCreate.cpp
//
//	Author:
//		David Potter (davidp)	December 5, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VSCREATE_H_
#define __VSCREATE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSCreate;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusGroupInfo;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSCreate
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSCreate : public CClusterAppStaticWizardPage< CWizPageVSCreate >
{
	typedef CClusterAppStaticWizardPage< CWizPageVSCreate > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageVSCreate( void )
		: m_bCreateNew( TRUE )
		, m_pgi( NULL )
	{
	} //*** CWizPageVSCreate()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_VSC )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_VSC )

	enum { IDD = IDD_VIRTUAL_SERVER_CREATE };

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( IN BOOL bSaveAndValidate );

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( CWizPageVSCreate )
		COMMAND_HANDLER( IDC_VSC_CREATE_NEW, BN_CLICKED, OnRadioButtonsChanged )
		COMMAND_HANDLER( IDC_VSC_USE_EXISTING, BN_CLICKED, OnRadioButtonsChanged )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	// Handler for the BN_CLICKED command notification on IDC_VSG_CREATE_NEW and IDC_VSG_USE_EXISTING
	LRESULT OnRadioButtonsChanged(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		BOOL bEnable = (m_rbCreateNew.GetCheck() != BST_CHECKED);
		m_cboxVirtualServers.EnableWindow( bEnable );
		return 0;

	} //*** OnRadioButtonsChanged()

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

// Implementation
protected:
	//
	// Controls.
	//
	CButton			m_rbCreateNew;
	CButton			m_rbUseExisting;
	CComboBox		m_cboxVirtualServers;

	//
	// Page state.
	//
	BOOL				m_bCreateNew;
	CString				m_strVirtualServer;
	CClusGroupInfo *	m_pgi;

	// Fill the combobox with a list of existing virtual servers
	void FillComboBox( void );

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_VIRTUAL_SERVER_CREATE; }

}; //*** class CWizPageVSCreate

/////////////////////////////////////////////////////////////////////////////

#endif // __VSCREATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\vscreated.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSCreated.h
//
//	Abstract:
//		Definition of the CWizPageVSCreated class.
//
//	Implementation File:
//		VSCreated.cpp
//
//	Author:
//		David Potter (davidp)	December 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VSCREATED_H_
#define __VSCREATED_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSCreated;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSCreated
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSCreated : public CClusterAppStaticWizardPage< CWizPageVSCreated >
{
	typedef CClusterAppStaticWizardPage< CWizPageVSCreated > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageVSCreated( void )
	{
	} //*** CWizPageVSCreated()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_VSCD )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_VSCD )

	enum { IDD = IDD_VIRTUAL_SERVER_CREATED };

public:
	//
	// CWizardPageWindow public methods.
	//

public:
	//
	// CBasePage public methods.
	//

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CWizPageVSCreated )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

// Implementation
protected:
	//
	// Controls.
	//
	CStatic		m_staticStep2;

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_VIRTUAL_SERVER_CREATED; }

}; //*** class CWizPageVSCreated

/////////////////////////////////////////////////////////////////////////////

#endif // __VSCREATED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\vsadv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSAdv.h
//
//	Abstract:
//		Definition of the CWizPageVSAdvanced class.
//
//	Implementation File:
//		VSAdv.cpp
//
//	Author:
//		David Potter (davidp)	December 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VSADV_H_
#define __VSADV_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSAdvanced;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __CLUSOBJ_H_
#include "ClusObj.h"		// for CClusGroupInfo, CClusResInfo
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSAdvanced
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSAdvanced : public CClusterAppStaticWizardPage< CWizPageVSAdvanced >
{
	typedef CClusterAppStaticWizardPage< CWizPageVSAdvanced > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageVSAdvanced( void )
		: m_bGroupChanged( FALSE )
		, m_bIPAddressChanged( FALSE )
		, m_bNetworkNameChanged( FALSE )
	{
	} //*** CWizPageVSAdvanced()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_VSA )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_VSA )

	enum { IDD = IDD_VIRTUAL_SERVER_ADVANCED };

public:
	//
	// CWizardPageWindow public methods.
	//

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

public:
	//
	// CWizardPageImpl required methods.
	//

	// Initialize the page
	BOOL BInit( IN CBaseSheetWindow * psht );

public:
	//
	// CBasePage public methods.
	//

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( CWizPageVSAdvanced )
		COMMAND_HANDLER( IDC_VSA_CATEGORIES, LBN_DBLCLK, OnAdvancedProps )
		COMMAND_HANDLER( IDC_VSA_ADVANCED_PROPS, BN_CLICKED, OnAdvancedProps )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	// Command handler to display advanced properties
	LRESULT OnAdvancedProps(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		);

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void );

	// Handler for PSN_WIZBACK
	int OnWizardBack( void );

// Implementation
protected:
	//
	// Controls.
	//
	CListBox		m_lbCategories;

	//
	// Page state.
	//
	BOOL			m_bGroupChanged;
	BOOL			m_bIPAddressChanged;
	BOOL			m_bNetworkNameChanged;

	// Quick check if anything changed on the page
	BOOL BAnythingChanged( void ) const
	{
		return ( m_bGroupChanged || m_bIPAddressChanged || m_bNetworkNameChanged );

	} //*** BAnythingChanged()

	// Fill the list control with a list of advanced property categories
	void FillListBox( void );

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_VIRTUAL_SERVER_ADVANCED; }

}; //*** class CWizPageVSAdvanced

/////////////////////////////////////////////////////////////////////////////

#endif // __VSADV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\vsgroup.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSGroup.cpp
//
//	Abstract:
//		Implementation of the CWizPageVSGroup class.
//
//	Author:
//		David Potter (davidp)	December 5, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VSGroup.h"
#include "ClusAppWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSGroup
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageVSGroup )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSG_CREATE_NEW )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSG_USE_EXISTING )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSG_GROUPS_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSG_GROUPS )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroup::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroup::OnInitDialog( void )
{
	//
	// Attach the controls to control member variables.
	//
	AttachControl( m_rbCreateNew, IDC_VSG_CREATE_NEW );
	AttachControl( m_rbUseExisting, IDC_VSG_USE_EXISTING );
	AttachControl( m_cboxGroups, IDC_VSG_GROUPS );

	//
	// Get info from the sheet in OnSetActive because we might be skipped
	// the first time through, and then the user could change his mind,
	// which would mean the information we retrieve here would be out of date.
	//

	return TRUE;

} //*** CWizPageVSGroup::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroup::OnSetActive
//
//	Routine Description:
//		Handler for PSN_SETACTIVE.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Page activated successfully.
//		FALSE		Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroup::OnSetActive( void )
{
	//
	// Get info from the sheet.
	//

	m_bCreateNew = PwizThis()->BCreatingNewGroup();

	//
	// Save the current group name, if any, so that we have a local copy.
	// Get the existing group name first since that will be the name in the
	// list, not the current group name.  If we just get the current group
	// name, the user could have changed that by moving to the next page,
	// changing the current group name, then moving back.  The new name
	// entered would not be found in the list.
	//
	// NOTE:  This is only needed for the case where the caller of the wizard
	// passed in a group name.
	//
	if ( PwizThis()->PgiExistingGroup() != NULL )
	{
		m_strGroupName = PwizThis()->PgiExistingGroup()->RstrName();
	} // if:  an existing group has previously been selected
	else
	{
		m_strGroupName = PwizThis()->RgiCurrent().RstrName();
	} // else:  no existing group selected yet

	//
	// If no new group name is found, use the default value.
	//
	if ( m_strGroupName.GetLength() == 0 )
	{
		if (   (PcawData() != NULL)
			&& (PcawData()->pszVirtualServerName != NULL) )
		{
			m_strGroupName = PcawData()->pszVirtualServerName;
		} // if: default data and value specified
	} // if:  group name is still empty

	//
	// Fill the list of groups.
	//
	FillComboBox();

	//
	// Call the base class and return.
	//
	return baseClass::OnSetActive();

} //*** CWizPageVSGroup::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroup::UpdateData
//
//	Routine Description:
//		Update data on or from the page.
//
//	Arguments:
//		bSaveAndValidate	[IN] TRUE if need to read data from the page.
//								FALSE if need to set data to the page.
//
//	Return Value:
//		TRUE		The data was updated successfully.
//		FALSE		An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroup::UpdateData( IN BOOL bSaveAndValidate )
{
	BOOL	bSuccess = TRUE;

	if ( bSaveAndValidate )
	{
		BOOL bChecked = (m_rbCreateNew.GetCheck() == BST_CHECKED);
		m_bCreateNew = bChecked;
		if ( ! bChecked )
		{
			//
			// Save the combobox selection.
			//
			DDX_GetText( m_hWnd, IDC_VSG_GROUPS, m_strGroupName );

			if ( ! BBackPressed() )
			{
				if ( ! DDV_RequiredText( m_hWnd, IDC_VSG_GROUPS, IDC_VSG_GROUPS_LABEL, m_strGroupName ) )
				{
					return FALSE;
				} // if:  no group specified
			} // if:  Back button not presssed

			//
			// Get the group object for the selected group.
			//
			int idx = m_cboxGroups.GetCurSel();
			ASSERT( idx != CB_ERR );
			m_pgi = reinterpret_cast< CClusGroupInfo * >( m_cboxGroups.GetItemDataPtr( idx ) );
		} // if:  using an existing group
	} // if: saving data from the page
	else
	{
		if ( m_bCreateNew )
		{
			//
			// Default the radio button selection.
			//
			m_rbCreateNew.SetCheck( BST_CHECKED );
			m_rbUseExisting.SetCheck( BST_UNCHECKED );

		} // if:  creating new group
		else
		{
			//
			// Default the radio button selection.
			//
			m_rbCreateNew.SetCheck( BST_UNCHECKED );
			m_rbUseExisting.SetCheck( BST_CHECKED );
		} // else:  using existing group

		//
		// Set the combobox selection.  If the selection is not
		// found, select the first entry.
		//
		if (   (m_strGroupName.GetLength() == 0)
			|| ! DDX_SetComboBoxText( m_hWnd, IDC_VSG_GROUPS, m_strGroupName, FALSE /*bRequired*/ ) )
		{
			m_cboxGroups.SetCurSel( 0 );
		} // if:  combobox selection not set

		//
		// Enable/disable the combobox.
		//
		m_cboxGroups.EnableWindow( ! m_bCreateNew /*bEnable*/ );

	} // else:  setting data to the page

	return bSuccess;

} //*** CWizPageVSGroup::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroup::BApplyChanges
//
//	Routine Description:
//		Apply changes made on this page to the sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		The data was applied successfully.
//		FALSE		An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroup::BApplyChanges( void )
{
	//
	// Save the current state.
	//
	if ( ! PwizThis()->BSetCreatingNewGroup( m_bCreateNew, m_pgi ) )
	{
		return FALSE;
	} // if:  error setting new state

	return TRUE;

} //*** CWizPageVSGroup::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroup::FillComboBox
//
//	Routine Description:
//		Fill the combobox with a list of groups that are not virtual servers.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizPageVSGroup::FillComboBox( void )
{
	CWaitCursor wc;

	//
	// Clear the combobox first.
	//
	m_cboxGroups.ResetContent();

	//
	// For each group in the cluster, find out if it is a virtual server
	// or not.  If not then add it to the combobox.
	//

	CClusGroupPtrList::iterator itgrp;
	int idx;
	for ( itgrp = PwizThis()->PlpgiGroups()->begin()
		; itgrp != PwizThis()->PlpgiGroups()->end()
		; itgrp++ )
	{
		//
		// If this is not a virtual server, add it to the list.
		// Save a pointer to the group info object with the string
		// so we can retrieve it with the selection later.
		//
		CClusGroupInfo * pgi = *itgrp;
		ASSERT( pgi->BQueried() );
		if ( ! pgi->BIsVirtualServer() )
		{
			idx = m_cboxGroups.AddString( pgi->RstrName() );
			ASSERT( idx != CB_ERR );
			m_cboxGroups.SetItemDataPtr( idx, (void *) pgi );
		} // if:  not virtual server
	} // for:  each entry in the list

	//
	// Select the currently saved entry, or the first one if none are
	// currently saved.
	//
//	UpdateData( FALSE /*bSaveAndValidate*/ );

//	if ( m_strGroupName.GetLength() == 0 )
//	{
//		m_cboxGroups.SetCurSel( 0 );
//	} // if:  no group name specified
//	else
//	{
//		int idx = m_cboxGroups.FindStringExact( -1, m_strGroupName );
//		ASSERT( idx != CB_ERR );
//		if ( idx != CB_ERR )
//		{
//			m_cboxGroups.SetCurSel( idx );
//		} // if:  group found in list
//	} // else:  virtual server saved

} //*** CWizPageVSGroup::FillComboBox()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\vscreated.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSCreated.cpp
//
//	Abstract:
//		Implementation of the CWizPageVSCreated class.
//
//	Author:
//		David Potter (davidp)	February 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VSCreated.h"
#include "ClusAppWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSCreated
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageVSCreated )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP1 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2A )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2B )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2C )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSCreated::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None..
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSCreated::OnInitDialog( void )
{
	//
	// Attach controls to control member variables.
	//
	AttachControl( m_staticStep2, IDC_WIZARD_STEP2 );

	//
	// Set the font of the control.
	//
	m_staticStep2.SetFont( PwizThis()->RfontBoldText() );

	return TRUE;

} //*** CWizPageVSCreated::OnInitDialog()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\vsdesc.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSDesc.h
//
//	Abstract:
//		Definition of the CWizPageVSDesc class.
//
//	Implementation File:
//		VSDesc.cpp
//
//	Author:
//		David Potter (davidp)	December 3, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VSDESC_H_
#define __VSDESC_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSDesc;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSDesc
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSDesc : public CClusterAppStaticWizardPage< CWizPageVSDesc >
{
	typedef CClusterAppStaticWizardPage< CWizPageVSDesc > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageVSDesc( void )
	{
	} //*** CWizPageVSDesc()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_VSD )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_VSD )

	enum { IDD = IDD_VIRTUAL_SERVER_DESCRIPTION };

public:
	//
	// CWizardPageWindow public methods.
	//

public:
	//
	// CBasePage public methods.
	//

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CWizPageVSDesc )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

// Implementation
protected:

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_VIRTUAL_SERVER_DESCRIPTION; }

}; //*** class CWizPageVSDesc

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageVSDesc )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_LIST_DOT_1 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSD_COMPONENT1 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_LIST_DOT_2 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSD_COMPONENT2 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_LIST_DOT_3 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSD_COMPONENT3 )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////

#endif // __VSDESC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\welcome.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		Welcome.cpp
//
//	Abstract:
//		Implementation of the CWizPageWelcome class.
//
//	Author:
//		David Potter (davidp)	December 4, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Welcome.h"
#include "ClusAppWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageWelcome
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageWelcome )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_TITLE )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_SUBTITLE )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP1 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2A )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2B )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2C )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageWelcome::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageWelcome::OnInitDialog( void )
{
	// Set the system menu so the context help "?" can be seen
	DWORD dwStyle = ::GetWindowLongPtr( GetParent( ), GWL_STYLE );
	dwStyle |= WS_SYSMENU;
	::SetWindowLongPtr( GetParent( ), GWL_STYLE, dwStyle );

	//
	// Attach controls to control member variables.
	//
	AttachControl( m_staticTitle, IDC_WIZARD_TITLE );

	//
	// Set the font of the control.
	//
	m_staticTitle.SetFont( PwizThis()->RfontExteriorTitle() );

	return TRUE;

} //*** CWizPageWelcome::OnInitDialog()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\welcome.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		Welcome.h
//
//	Abstract:
//		Definition of the CWizPageWelcome class.
//
//	Implementation File:
//		Welcome.cpp
//
//	Author:
//		David Potter (davidp)	December 2, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __WELCOME_H_
#define __WELCOME_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageWelcome;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageWelcome
/////////////////////////////////////////////////////////////////////////////

class CWizPageWelcome : public CClusterAppStaticWizardPage< CWizPageWelcome >
{
	typedef CClusterAppStaticWizardPage< CWizPageWelcome > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageWelcome(void)
	{
	} //*** CWizPageWelcome()

	WIZARDPAGE_HEADERTITLEID( 0 )
	WIZARDPAGE_HEADERSUBTITLEID( 0 )

	enum { IDD = IDD_WELCOME };

public:
	//
	// CWizardPageWindow public methods.
	//

public:
	//
	// CBasePage public methods.
	//

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CWizPageWelcome )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

// Implementation
protected:
	//
	// Controls.
	//
	CStatic		m_staticTitle;

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_WELCOME; }

}; //*** class CWizPageWelcome

/////////////////////////////////////////////////////////////////////////////

#endif // __WELCOME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\vsgrpname.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSGrpName.h
//
//	Abstract:
//		Definition of the CWizPageVSGroupName class.
//
//	Implementation File:
//		VSGrpName.cpp
//
//	Author:
//		David Potter (davidp)	December 9, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VSGRPNAME_H_
#define __VSGRPNAME_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSGroupName;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __CLUSAPPWIZ_H_
#include "ClusAppWiz.h"		// for using CClusterAppWizard
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSGroupName
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSGroupName : public CClusterAppStaticWizardPage< CWizPageVSGroupName >
{
	typedef CClusterAppStaticWizardPage< CWizPageVSGroupName > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageVSGroupName( void )
	{
	} //*** CCWizPageVSGroupName()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_VSGN )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_VSGN )

	enum { IDD = IDD_VIRTUAL_SERVER_GROUP_NAME };

public:
	//
	// CWizardPageWindow public methods.
	//

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( IN BOOL bSaveAndValidate );

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( CWizPageVSGroupName )
		COMMAND_HANDLER( IDC_VSGN_GROUP_NAME, EN_CHANGE, OnGroupNameChanged )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	// Handler for the EN_CHANGE command notification on IDC_VSGN_GROUP_NAME
	LRESULT OnGroupNameChanged(
		WORD /*wNotifyCode*/,
		WORD /*idCtrl*/,
		HWND /*hwndCtrl*/,
		BOOL & /*bHandled*/
		)
	{
		BOOL bEnable = ( m_editGroupName.GetWindowTextLength() > 0 );
		EnableNext( bEnable );
		return 0;

	} //*** OnGroupNameChanged()

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void );

	// Handler for PSN_WIZBACK
	int OnWizardBack( void );

// Implementation
protected:
	//
	// Controls.
	//
	CEdit		m_editGroupName;
	CEdit		m_editGroupDesc;

	//
	// Page state.
	//
	CString		m_strGroupName;
	CString		m_strGroupDesc;

protected:
	//
	// Utility methods.
	//

	// Determine if the group name is already in use
	BOOL BGroupNameInUse( void )
	{
		return ( PwizThis()->PgiFindGroupNoCase( m_strGroupName ) != NULL );

	} //*** BGroupNameInUse()

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_VIRTUAL_SERVER_GROUP_NAME; }

}; //*** class CWizPageVSGroupName

/////////////////////////////////////////////////////////////////////////////

#endif // __VSGRPNAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\vsgrpname.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSGrpName.cpp
//
//	Abstract:
//		Implementation of the CWizPageVSGroupName class.
//
//	Author:
//		David Potter (davidp)	December 9, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VSGrpName.h"
#include "ClusAppWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSGroupName
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageVSGroupName )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSGN_GROUP_NAME_TITLE )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSGN_GROUP_NAME_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSGN_GROUP_NAME )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSGN_GROUP_DESC_TITLE )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSGN_GROUP_DESC_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSGN_GROUP_DESC )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroupName::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroupName::OnInitDialog( void )
{
	//
	// Attach the controls to control member variables.
	//
	AttachControl( m_editGroupName, IDC_VSGN_GROUP_NAME );
	AttachControl( m_editGroupDesc, IDC_VSGN_GROUP_DESC );

	return TRUE;

} //*** CWizPageVSGroupName::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroupName::OnSetActive
//
//	Routine Description:
//		Handler for PSN_SETACTIVE.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Page activated successfully.
//		FALSE		Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroupName::OnSetActive( void )
{
	//
	// Get info from the sheet.
	// This is done here because it is also affected by pages displayed
	// before this one, and the user could press the Back button to change it.
	//
	m_strGroupName = PwizThis()->RgiCurrent().RstrName();
	m_strGroupDesc = PwizThis()->RgiCurrent().RstrDescription();

	if ( m_strGroupName.GetLength() == 0 )
	{
		if (   (PcawData() != NULL)
			&& (PcawData()->pszVirtualServerName != NULL) )
		{
			m_strGroupName = PcawData()->pszVirtualServerName;
		} // if: default data and value specified
	} // if:  no group name specified

	//
	// Call the base class and return.
	//
	return baseClass::OnSetActive();

} //*** CWizPageVSGroupName::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroupName::UpdateData
//
//	Routine Description:
//		Update data on or from the page.
//
//	Arguments:
//		bSaveAndValidate	[IN] TRUE if need to read data from the page.
//								FALSE if need to set data to the page.
//
//	Return Value:
//		TRUE		The data was updated successfully.
//		FALSE		An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroupName::UpdateData( IN BOOL bSaveAndValidate )
{
	BOOL	bSuccess = TRUE;

	if ( bSaveAndValidate )
	{
		DDX_GetText( m_hWnd, IDC_VSGN_GROUP_NAME, m_strGroupName );
		DDX_GetText( m_hWnd, IDC_VSGN_GROUP_DESC, m_strGroupDesc );

		if ( ! BBackPressed() )
		{
			if ( ! DDV_RequiredText( m_hWnd, IDC_VSGN_GROUP_NAME, IDC_VSGN_GROUP_NAME_LABEL, m_strGroupName ) )
			{
				return FALSE;
			} // if:  group name not specified
		} // if:  Back button not presssed
	} // if: saving data from the page
	else
	{
		m_editGroupName.SetWindowText( m_strGroupName );
		m_editGroupDesc.SetWindowText( m_strGroupDesc );
	} // else:  setting data to the page

	return bSuccess;

} //*** CWizPageVSGroupName::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroupName::OnWizardBack
//
//	Routine Description:
//		Handler for PSN_WIZBACK.
//
//	Arguments:
//		None.
//
//	Return Value:
//		0				Move to previous page.
//		-1				Don't move to previous page.
//		anything else	Move to specified page.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CWizPageVSGroupName::OnWizardBack( void )
{
	int nResult;

	//
	// Call the base class.  This causes our UpdateData() method to get
	// called.  If it succeeds, save our values.
	//
	nResult = baseClass::OnWizardBack();
	if ( nResult != -1 ) // -1 means failure
	{
		if ( ! PwizThis()->BSetGroupName( m_strGroupName ) )
		{
			return FALSE;
		} // if:  error setting the group name
		if ( m_strGroupDesc != PwizThis()->RgiCurrent().RstrDescription() )
		{
			if ( PwizThis()->BClusterUpdated() && ! PwizThis()->BResetCluster() )
			{
				return FALSE;
			} // if:  error resetting the cluster
			PwizThis()->RgiCurrent().SetDescription( m_strGroupDesc );
			PwizThis()->SetVSDataChanged();
		} // if:  group description changed
	} // if:  base class called successfully

	return nResult;

} //*** CWizPageVSGroupName::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroupName::BApplyChanges
//
//	Routine Description:
//		Apply changes made on this page to the sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		The data was applied successfully.
//		FALSE		An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroupName::BApplyChanges( void )
{
	//
	// If creating a new group or giving a new name to an existing group,
	// make sure this group name isn't already in use.
	//
	if (   PwizThis()->BCreatingNewGroup()
		|| (m_strGroupName != PwizThis()->PgiExistingGroup()->RstrName()) )
	{
		if ( BGroupNameInUse() )
		{
			CString strMsg;
			strMsg.FormatMessage( IDS_ERROR_GROUP_NAME_IN_USE, m_strGroupName );
			AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
			return FALSE;
		} // if:  group name is already in use
	} // if:  creating new group or changing name of existing group


	//
	// Save the info in the wizard object.
	//
	if ( m_strGroupName != PwizThis()->RgiCurrent().RstrName() )
	{
		if ( PwizThis()->BClusterUpdated() && ! PwizThis()->BResetCluster() )
		{
			return FALSE;
		} // if:  error resetting the cluster

		if ( ! PwizThis()->BSetGroupName( m_strGroupName ) )
		{
			return FALSE;
		} // if:  error setting the group name
	} // if: name changed

	if ( m_strGroupDesc != PwizThis()->RgiCurrent().RstrDescription() )
	{
		if ( PwizThis()->BClusterUpdated() && ! PwizThis()->BResetCluster() )
		{
			return FALSE;
		} // if:  error resetting the cluster

		PwizThis()->RgiCurrent().SetDescription( m_strGroupDesc );
		PwizThis()->SetVSDataChanged();
	} // if:  description changed

	return TRUE;

} //*** CWizPageVSGroupName::BApplyChanges()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\wizobject.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      WizObject.cpp
//
//  Abstract:
//      Implementation of the CClusAppWizardObject class.
//
//  Author:
//      David Potter (davidp)   November 26, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "WizObject.h"
#include "ClusAppWiz.h"
#include "AdmCommonRes.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

static BOOL g_bInitializedCommonControls = FALSE;
static INITCOMMONCONTROLSEX g_icce =
{
    sizeof( g_icce ),
    ICC_WIN95_CLASSES | ICC_INTERNET_CLASSES
};

/////////////////////////////////////////////////////////////////////////////
// class CClusAppWizardObject
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusAppWizardObject::UpdateRegistry
//
//  Routine Description:
//      Update the registry for this object.
//
//  Arguments:
//      bRegister   TRUE = register, FALSE = unregister.
//
//  Return Value:
//      Any return values from _Module.UpdateRegistryFromResource.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CClusAppWizardObject::UpdateRegistry( BOOL bRegister )
{
    static WCHAR oszClassDisplayName[1024] = { 0 };
    static _ATL_REGMAP_ENTRY rgRegMap[] =
    {
        { OLESTR("ClassDisplayName"), oszClassDisplayName },
        { NULL, NULL }
    };

    //
    // Load replacement values.
    //
    if ( oszClassDisplayName[0] == OLESTR('\0') )
    {
        CString str;

        str.LoadString( IDS_CLASS_DISPLAY_NAME );
        lstrcpyW( oszClassDisplayName, str );
    } // if:  replacement values not loaded yet

    return _Module.UpdateRegistryFromResource( IDR_CLUSAPPWIZ, bRegister, rgRegMap );

} //*** CClusAppWizardObject::UpdateRegistry()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusAppWizardObject::DoModalWizard [IClusterApplicationWizard]
//
//  Routine Description:
//      Display a modal wizard.
//
//  Arguments:
//      hwndParent      [IN] Parent window.
//      hCluster        [IN] Cluster in which to configure the application.
//      pDefaultData    [IN] Default data for the wizard.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusAppWizardObject::DoModalWizard(
    HWND                    IN hwndParent,
    ULONG_PTR  /*HCLUSTER*/ IN hCluster,
    CLUSAPPWIZDATA const *  IN pcawData
    )
{
    HRESULT             hr = S_FALSE;
    BOOL                bSuccess;
    int                 id;
    CClusterAppWizard   wiz;
    CNTException        nte(
                            ERROR_SUCCESS,  // sc
                            0,              // idsOperation
                            NULL,           // pszOperArg1
                            NULL,           // pszOperArg2
                            FALSE           // bAutoDelete
                            );

    //
    // Cluster handle must be valid.
    //
    ASSERT( hCluster != NULL );
    ASSERT( (pcawData == NULL) || (pcawData->nStructSize == sizeof(CLUSAPPWIZDATA)) );
    if (   (hCluster == NULL )
        || ((pcawData != NULL) && (pcawData->nStructSize != sizeof(CLUSAPPWIZDATA))) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    } // if:  no cluster handle specified or data not the right size

    //
    // Prepare the wizard.
    //
    bSuccess = wiz.BInit(
                    hwndParent,
                    reinterpret_cast< HCLUSTER >( hCluster ),
                    pcawData,
                    &nte
                    );
    if ( ! bSuccess )
    {
        goto Cleanup;
    } // if:  error initializing the wizard

    //
    // Initialize common controls.
    //
    if ( ! g_bInitializedCommonControls )
    {
        BOOL bSuccess = InitCommonControlsEx( &g_icce );
        ASSERT( bSuccess );
        g_bInitializedCommonControls = TRUE;
    } // if:  common controls not initialized yet

    //
    // Display the wizard.
    //
    id = wiz.DoModal( hwndParent );
    if ( id != ID_WIZFINISH )
    {
    }

    hr = S_OK;

Cleanup:
    if ( nte.Sc() != ERROR_SUCCESS )
    {
        nte.ReportError( hwndParent, MB_OK | MB_ICONEXCLAMATION );
    } // if: error occurred
    nte.Delete();
    return hr;

} //*** CClusAppWizardObject::DoModalWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusAppWizardObject::DoModlessWizard [IClusterApplicationWizard]
//
//  Routine Description:
//      Display a modless wizard.
//
//  Arguments:
//      hwndParent  [IN] Parent window.
//      hCluster    [IN] Cluster in which to configure the application.
//      pcawData    [IN] Default data for the wizard.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusAppWizardObject::DoModelessWizard(
    HWND                    IN hwndParent,
    ULONG_PTR /*HCLUSTER*/  IN hCluster,
    CLUSAPPWIZDATA const *  IN pcawData
    )
{
    HRESULT             hr = S_FALSE;
    BOOL                bSuccess;
    CClusterAppWizard   wiz;
    CNTException        nte(
                            ERROR_SUCCESS,  // sc
                            0,              // idsOperation
                            NULL,           // pszOperArg1
                            NULL,           // pszOperArg2
                            FALSE           // bAutoDelete
                            );

    return E_NOTIMPL;

    //
    // Cluster handle must be valid.
    //
    ASSERT( hCluster != NULL );
    ASSERT( (pcawData == NULL) || (pcawData->nStructSize == sizeof(CLUSAPPWIZDATA)) );
    if (   (hCluster == NULL )
        || ((pcawData != NULL) && (pcawData->nStructSize != sizeof(CLUSAPPWIZDATA))) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    } // if:  no cluster handle specified or data not the right size

    //
    // Prepare the wizard.
    //
    bSuccess = wiz.BInit(
                    hwndParent,
                    reinterpret_cast< HCLUSTER >( hCluster ),
                    pcawData,
                    &nte
                    );
    if ( ! bSuccess )
    {
        goto Cleanup;
    } // if:  error initializing the wizard

    //
    // Initialize common controls.
    //
    if ( ! g_bInitializedCommonControls )
    {
        BOOL bSuccess = InitCommonControlsEx( &g_icce );
        ASSERT( bSuccess );
        g_bInitializedCommonControls = TRUE;
    } // if:  common controls not initialized yet

    hr = S_FALSE; // TODO:  Need to implement this still

Cleanup:
    return hr;

} //*** CClusAppWizardObject::DoModlessWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusAppWizardObject::InterfaceSupportsErrorInfo [ISupportsErrorInfo]
//
//  Routine Description:
//      Indicates whether the interface identified by riid supports the
//      IErrorInfo interface.
//
//  Arguments:
//      riid        [IN] Interface to check.
//
//  Return Value:
//      S_OK        Specified interface supports the IErrorInfo interface.
//      S_FALSE     Specified interface does not support the IErrorInfo interface.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusAppWizardObject::InterfaceSupportsErrorInfo( REFIID riid )
{
    static const IID * arr[] = 
    {
        &IID_IClusterApplicationWizard,
    };
    for ( int idx = 0 ; idx < sizeof( arr ) / sizeof( arr[0] ) ; idx++ )
    {
        if ( InlineIsEqualGUID( *arr[idx], riid ) )
        {
            return S_OK;
        } // if:  found the GUID
    } // for:  each IID

    return S_FALSE;

}  //*** CClusAppWizardObject::InterfaceSupportsErrorInfo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\wizobject.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		WizObject.h
//
//	Abstract:
//		Definition of the CClusAppWizardObject class.
//
//	Implementation File:
//		WizObject.cpp
//
//	Author:
//		David Potter (davidp)	November 26, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __WIZOBJECT_H_
#define __WIZOBJECT_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusAppWizardObject;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"       // main symbols
#define __RESOURCE_H_
#endif

/////////////////////////////////////////////////////////////////////////////
// class CClusAppWizardObject
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusAppWizardObject : 
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusAppWizardObject, &CLSID_ClusAppWiz >,
	public ISupportErrorInfo,
	public IClusterApplicationWizard
{
public:
	//
	// Object construction and destruction.
	//

	CClusAppWizardObject( void )
	{
	}

	DECLARE_NOT_AGGREGATABLE( CClusAppWizardObject )

	//
	// Map interfaces to this class.
	//
	BEGIN_COM_MAP( CClusAppWizardObject )
		COM_INTERFACE_ENTRY( IClusterApplicationWizard )
		COM_INTERFACE_ENTRY( ISupportErrorInfo )
	END_COM_MAP()

	// Update the registry for object registration
	static HRESULT WINAPI UpdateRegistry( BOOL bRegister );

public:
	//
	// IClusterApplicationWizard methods.
	//

	// Display a modal wizard
	STDMETHOD( DoModalWizard )(
		HWND					IN hwndParent,
		ULONG_PTR  /*HCLUSTER*/	IN hCluster,
		CLUSAPPWIZDATA const *	IN pcawData
		);

	// Display a modeless wizard
	STDMETHOD( DoModelessWizard )(
		HWND					IN hwndParent,
		ULONG_PTR  /*HCLUSTER*/	IN hCluster,
		CLUSAPPWIZDATA const *	IN pcawData
		);

public:
	//
	// ISupportsErrorInfo methods.
	//

	// Determine if interface supports IErrorInfo
	STDMETHOD( InterfaceSupportsErrorInfo )( REFIID riid );

}; //*** class CClusAppWizardObject

/////////////////////////////////////////////////////////////////////////////

#endif //__ACWIZOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\vsgroup.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSGroup.h
//
//	Abstract:
//		Definition of the CWizPageVSGroup class.
//
//	Implementation File:
//		VSGroup.cpp
//
//	Author:
//		David Potter (davidp)	December 5, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VSGROUP_H_
#define __VSGROUP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSGroup;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusGroupInfo;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSGroup
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSGroup : public CClusterAppStaticWizardPage< CWizPageVSGroup >
{
	typedef CClusterAppStaticWizardPage< CWizPageVSGroup > baseClass;
public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageVSGroup( void )
		: m_bCreateNew( TRUE )
		, m_pgi( NULL )
	{
	} //*** CCWizPageVSGroup()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_VSG )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_VSG )

	enum { IDD = IDD_VIRTUAL_SERVER_GROUP };

public:
	//
	// CWizardPageWindow public methods.
	//

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( IN BOOL bSaveAndValidate );

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( CWizPageVSGroup )
		COMMAND_HANDLER( IDC_VSG_CREATE_NEW, BN_CLICKED, OnRadioButtonsChanged )
		COMMAND_HANDLER( IDC_VSG_USE_EXISTING, BN_CLICKED, OnRadioButtonsChanged )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	// Handler for the BN_CLICKED command notification on IDC_VSG_CREATE_NEW and IDC_VSG_USE_EXISTING
	LRESULT OnRadioButtonsChanged(
		WORD /*wNotifyCode*/,
		WORD /*idCtrl*/,
		HWND /*hwndCtrl*/,
		BOOL & /*bHandled*/
		)
	{
		BOOL bEnable = (m_rbCreateNew.GetCheck() != BST_CHECKED);
		m_cboxGroups.EnableWindow( bEnable );
		return 0;

	} //*** OnRadioButtonsChanged()

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void );

// Implementation
protected:
	//
	// Controls.
	//
	CButton			m_rbCreateNew;
	CButton			m_rbUseExisting;
	CComboBox		m_cboxGroups;

	//
	// Page state.
	//
	BOOL				m_bCreateNew;
	CString				m_strGroupName;
	CClusGroupInfo *	m_pgi;

	// Fill the combobox with a list of groups that are not virtual servers
	void FillComboBox( void );

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_VIRTUAL_SERVER_GROUP; }

}; //*** class CWizPageVSGroup

/////////////////////////////////////////////////////////////////////////////

#endif // __VSGROUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\wizthread.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      WizThread.cpp
//
//  Abstract:
//      Implementation of the CWizardThread class.
//
//  Author:
//      David Potter (davidp)   December 16, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "WizThread.h"
#include <ResApi.h>         // for ResUtilxxx routine prototypes
#include "PropList.h"       // for CClusPropList
#include "ClusAppWiz.h"     // for CClusterAppWizard
#include "ClusObj.h"        // for CClusterObject, etc.
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

inline DWORD ScReallocString( LPWSTR & rpwsz, DWORD & rcchmac, DWORD & rcch )
{
    delete [] rpwsz;
    rpwsz = NULL;
    rcchmac = rcch + 1;
    rpwsz = new WCHAR[ rcchmac ];
    if ( rpwsz == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    } // if: error allocating memory

    rcch = rcchmac;
    return ERROR_SUCCESS;

} //*** ScReallocString()

/////////////////////////////////////////////////////////////////////////////
// class CWizardThread
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::ThreadFunctionHandler
//
//  Routine Description:
//      Thread function handler.  Processes thread function requests.
//
//  Arguments:
//      nFunction   [IN] Function code.
//      pvParam1    [IN OUT] Parameter 1 with function-specific data.
//      pvParam2    [IN OUT] Parameter 2 with function-specific data.
//
//  Return Value:
//      Status returned to the calling function.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CWizardThread::ThreadFunctionHandler(
    LONG    nFunction,
    PVOID   pvParam1,
    PVOID   pvParam2
    )
{
    DWORD sc = ERROR_SUCCESS;

    switch ( nFunction )
    {
        case WZTF_READ_CLUSTER_INFO:
            sc = _BReadClusterInfo();
            break;
        case WZTF_COLLECT_GROUPS:
            sc = _BCollectGroups();
            break;
        case WZTF_COLLECT_RESOURCES:
            sc = _BCollectResources();
            break;
        case WZTF_COLLECT_RESOURCE_TYPES:
            sc = _BCollectResourceTypes();
            break;
        case WZTF_COLLECT_NETWORKS:
            sc = _BCollectNetworks();
            break;
        case WZTF_COLLECT_NODES:
            sc = _BCollectNodes();
            break;
        case WZTF_COPY_GROUP_INFO:
            sc = _BCopyGroupInfo( (CClusGroupInfo **) pvParam1 );
            break;
        case WZTF_COLLECT_DEPENDENCIES:
            sc = _BCollectDependencies( (CClusResInfo *) pvParam1 );
            break;
        case WZTF_CREATE_VIRTUAL_SERVER:
            sc = _BCreateVirtualServer();
            break;
        case WZTF_CREATE_APP_RESOURCE:
            sc = _BCreateAppResource();
            break;
        case WZTF_DELETE_APP_RESOURCE:
            sc = _BDeleteAppResource();
            break;
        case WZTF_RESET_CLUSTER:
            sc = _BResetCluster();
            break;
        case WZTF_SET_APPRES_ATTRIBUTES:
            sc = _BSetAppResAttributes( 
                    (CClusResPtrList *) pvParam1, 
                    (CClusNodePtrList *) pvParam2
                    );
            break;
        default:
            ASSERT( 0 );
    } // switch:  nFunction

    return sc;

} //*** CWizardThread::ThreadFunctionHandler()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BReadClusterInfo
//
//  Routine Description:
//      (WZTF_READ_CLUSTER_INFO) Read cluster information, such as the
//      cluster name.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BReadClusterInfo( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->Hcluster() != NULL );

    DWORD               sc;
    BOOL                bSuccess = TRUE;
    CLUSTERVERSIONINFO  cvi;
    LPWSTR              pwszName = NULL;
    DWORD               cchmacName = 128;
    DWORD               cchName;

    // Loop to avoid goto's.
    do
    {
        //
        // Allocate an initial buffer for the object name.  In most cases the
        // name will probably fit into this buffer, so doing this avoids an
        // additional call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_GET_CLUSTER_INFO );
            break;
        } // if: error allocating object name buffer

        //
        // Get cluster information.
        //
        ATLTRACE( _T("CWizardThread::_BReadClusterInfo() - Calling GetClusterInformation()\n") );
        cchName = cchmacName;
        cvi.dwVersionInfoSize = sizeof( CLUSTERVERSIONINFO );
        sc = GetClusterInformation( Pwiz()->Hcluster(), pwszName, &cchName, &cvi );
        if ( sc == ERROR_MORE_DATA )
        {
            cchName++;
            ATLTRACE( _T("CWizardThread::_BReadClusterInfo() - Name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
            sc = ScReallocString( pwszName, cchmacName, cchName );
            if ( sc == ERROR_SUCCESS )
            {
                sc = GetClusterInformation( Pwiz()->Hcluster(), pwszName, &cchName, &cvi );
            } // if: name buffer reallocated successfully
        } // if:  buffer is too small
        if ( sc != ERROR_SUCCESS )
        {
            ATLTRACE( _T("CWizardThread::_BReadClusterInfo() - Error %08.8x from GetClusterInformation()\n"), sc );
            m_nte.SetOperation( sc, IDS_ERROR_GET_CLUSTER_INFO );
            bSuccess = FALSE;
            break;
        } // else if:  error reading from the enumerator

        //
        // Copy the information into the wizard's cluster object.
        //
        Pwiz()->Pci()->SetName( pwszName );

        //
        // Get admin extensions.
        //
        bSuccess = _BReadAdminExtensions( NULL, Pwiz()->Pci()->m_lstrClusterAdminExtensions );
        if ( bSuccess )
        {
            bSuccess = _BReadAdminExtensions( L"ResourceTypes", Pwiz()->Pci()->m_lstrResTypesAdminExtensions );
        } // if: read cluster extensions successfully

    } while ( 0 );

    //
    // Cleanup.
    //
    delete [] pwszName;

    return bSuccess;

} //*** CWizardThread::_BReadClusterInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCollectGroups
//
//  Routine Description:
//      (WZTF_COLLECT_GROUPS) Collect groups in the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCollectGroups( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( ! Pwiz()->BCollectedGroups() );

    DWORD       sc;
    BOOL        bSuccess = TRUE;
    HCLUSENUM   hclusenum = NULL;
    LPWSTR      pwszName = NULL;
    DWORD       cchmacName = 128;
    DWORD       cchName;
    int         ienum;
    ULONG       ceType;

    // Loop to avoid goto's.
    do
    {
        //
        // Make sure resources have been collected.
        //
        if ( ! Pwiz()->BCollectedResources() )
        {
            bSuccess = _BCollectResources();
            if ( ! bSuccess )
            {
                break;
            } // if:  error collecting resources
        } // if:  resources not collected yet

        //
        // Collect nodes now as well.  This is done because copies of the
        // objects are stored in individual pages, and if we wait for the
        // page to be initialized or displayed before collecting the data,
        // the node information won't be stored on the copies.
        //
        if ( ! Pwiz()->BCollectedNodes() )
        {
            bSuccess = _BCollectNodes();
            if ( ! bSuccess )
            {
                break;
            } // if:  error collecting nodes
        } // if:  nodes not collected yet

        //
        // Open the enumerator.
        //
        ATLTRACE( _T("CWizardThread::_BCollectGroups() - Calling ClusterOpenEnum()\n") );
        hclusenum = ClusterOpenEnum( Pwiz()->Hcluster(), CLUSTER_ENUM_GROUP );
        if ( hclusenum == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_CLUSTER_ENUM );
            bSuccess = FALSE;
            break;
        } // if:  error opening the enumerator

        //
        // Allocate an initial buffer for the object name.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // Loop through the enumeration and add each item to our internal list.
        //
        for ( ienum = 0 ; ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA)
            {
                ATLTRACE( _T("CWizardThread::_BCollectGroups() - name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_CLUSTER );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Allocate the group info structure.
            //
            CClusGroupInfo * pgi = new CClusGroupInfo( Pwiz()->Pci(), pwszName );
            if ( pgi == NULL )
            {
                sc = GetLastError();
                m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
                break;
            } // if: error allocating group info structure

            //
            // Initialize the group info structure.
            //
            ATLTRACE( _T("CWizardThread::_BCollectGroups() - Querying group info about '%s'\n"), pwszName );
            bSuccess = _BQueryGroup( pgi );
            if ( ! bSuccess )
            {
                delete pgi;
                break;
            } // if:  error getting properties

            //
            // Add this group to the list.
            //
            Pwiz()->PlpgiGroups()->insert( Pwiz()->PlpgiGroups()->end(), pgi );
        } // for:  each group in the enumeration
    } while ( 0 );

    //
    // Cleanup.
    //
    delete [] pwszName;
    if ( hclusenum != NULL )
    {
        ClusterCloseEnum( hclusenum );
    } // if:  enumeration still open

    if ( bSuccess )
    {
        Pwiz()->SetCollectedGroups();
    } // if:  groups collected successfully

    return bSuccess;

} //*** CWizardThread::_BCollectGroups()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCollectResources
//
//  Routine Description:
//      (WZTF_COLLECT_GROUPS) Collect resources in the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCollectResources( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( ! Pwiz()->BCollectedResources() );

    DWORD       sc;
    BOOL        bSuccess = TRUE;
    HCLUSENUM   hclusenum = NULL;
    LPWSTR      pwszName = NULL;
    DWORD       cchmacName = 128;
    DWORD       cchName;
    int         ienum;
    ULONG       ceType;

    // Loop to avoid goto's.
    do
    {
        //
        // Make sure resource types have been collected.
        //
        if ( ! Pwiz()->BCollectedResourceTypes() )
        {
            bSuccess = _BCollectResourceTypes();
            if ( ! bSuccess )
            {
                break;
            } // if:  error collecting resource types
        } // if:  resource types not collected yet

        //
        // Open the enumerator.
        //
        ATLTRACE( _T("CWizardThread::_BCollectResources() - Calling ClusterOpenEnum()\n") );
        hclusenum = ClusterOpenEnum( Pwiz()->Hcluster(), CLUSTER_ENUM_RESOURCE );
        if ( hclusenum == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_CLUSTER_ENUM );
            bSuccess = FALSE;
            break;
        } // if:  error opening the enumerator

        //
        // Allocate an initial buffer for the object name.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // Loop through the enumeration and add each item to our internal list.
        //
        for ( ienum = 0 ; ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BCollectResources() - name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_CLUSTER );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Allocate the resource info structure.
            //
            CClusResInfo * pri = new CClusResInfo( Pwiz()->Pci(), pwszName );
            if ( pri == NULL )
            {
                sc = GetLastError();
                m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
                break;
            } // if: error allocating resource info structure

            //
            // Initialize the resource info structure.
            //
            ATLTRACE( _T("CWizardThread::_BCollectResources() - Querying resource info about '%s'\n"), pwszName );
            bSuccess = _BQueryResource( pri );
            if ( ! bSuccess )
            {
                delete pri;
                break;
            } // if:  error getting properties

            //
            // Add this resource to the list.
            //
            Pwiz()->PlpriResources()->insert( Pwiz()->PlpriResources()->end(), pri );
        } // for:  each resource in the enumeration
    } while ( 0 );

    //
    // Cleanup.
    //
    delete [] pwszName;
    if ( hclusenum != NULL )
    {
        ClusterCloseEnum( hclusenum );
    } // if:  enumeration still open

    if ( bSuccess )
    {
        Pwiz()->SetCollectedResources();
    } // if:  resources collected successfully

    return bSuccess;

} //*** CWizardThread::_BCollectResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCollectResourceTypes
//
//  Routine Description:
//      (WZTF_COLLECT_RESOURCE_TYPES) Collect resource types in the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCollectResourceTypes( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( ! Pwiz()->BCollectedResourceTypes() );

    DWORD       sc;
    BOOL        bAllocated;
    BOOL        bSuccess = TRUE;
    HCLUSENUM   hclusenum = NULL;
    LPWSTR      pwszName = NULL;
    DWORD       cchmacName = 128;
    DWORD       cchName;
    int         ienum;
    ULONG       ceType;

    // Loop to avoid goto's.
    do
    {
        //
        // Open the enumerator.
        //
        ATLTRACE( _T("CWizardThread::_BCollectResourceTypes() - Calling ClusterOpenEnum()\n") );
        hclusenum = ClusterOpenEnum( Pwiz()->Hcluster(), CLUSTER_ENUM_RESTYPE );
        if ( hclusenum == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_CLUSTER_ENUM );
            bSuccess = FALSE;
            break;
        } // if:  error opening the enumerator

        //
        // Allocate an initial buffer for the object name.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // Loop through the enumeration and add each item to our internal list.
        //
        for ( ienum = 0 ; ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BCollectResourceTypes() - name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_CLUSTER );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // If the resource type doesn't exist yet, allocate a new one.
            //
            CClusResTypeInfo * prti = PobjFromName( Pwiz()->PlprtiResourceTypes(), pwszName );
            if ( prti == NULL )
            {
                //
                // Allocate the resource type info structure.
                //
                prti = new CClusResTypeInfo( Pwiz()->Pci(), pwszName );
                if ( prti == NULL )
                {
                    sc = GetLastError();
                    m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
                    break;
                } // if: error allocating resource type info structure
                bAllocated = TRUE;
            } // if:  resource type doesn't exist yet
            else
            {
                bAllocated = FALSE;
            } // else:  resource type already exists

            //
            // Initialize the resource type info structure.
            //
            ATLTRACE( _T("CWizardThread::_BCollectResourceTypes() - Querying resource type info about '%s'\n"), pwszName );
            bSuccess = _BQueryResourceType( prti );
            if ( ! bSuccess )
            {
                if ( bAllocated )
                {
                    delete prti;
                } // if:  we allocated the resource type info structure

                // Set bSuccess to TRUE because the inability to query one resource type
                // should not abort the whole process of collecting resource types.
                bSuccess = TRUE;
            } // if:  error getting properties
            else
            {
                //
                // Add this resource type to the list.
                //
                if ( bAllocated )
                {
                    Pwiz()->PlprtiResourceTypes()->insert( Pwiz()->PlprtiResourceTypes()->end(), prti );
                } // if:  we allocated the resource type info structure
            } // else:  else: no errors getting properties
        } // for:  each group in the enumeration
    } while ( 0 );

    //
    // Cleanup.
    //
    delete [] pwszName;
    if ( hclusenum != NULL )
    {
        ClusterCloseEnum( hclusenum );
    } // if:  enumeration still open

    if ( bSuccess )
    {
        Pwiz()->SetCollectedResourceTypes();
    } // if:  resource types collected successfully

    return bSuccess;

} //*** CWizardThread::_BCollectResourceTypes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCollectNetworks
//
//  Routine Description:
//      (WZTF_COLLECT_NETWORKS) Collect networks in the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCollectNetworks( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( ! Pwiz()->BCollectedNetworks() );

    DWORD       sc;
    BOOL        bSuccess = TRUE;
    HCLUSENUM   hclusenum = NULL;
    LPWSTR      pwszName = NULL;
    DWORD       cchmacName = 128;
    DWORD       cchName;
    int         ienum;
    ULONG       ceType;

    // Loop to avoid goto's.
    do
    {
        //
        // Open the enumerator.
        //
        ATLTRACE( _T("CWizardThread::_BCollectNetworks() - Calling ClusterOpenEnum()\n") );
        hclusenum = ClusterOpenEnum( Pwiz()->Hcluster(), CLUSTER_ENUM_NETWORK );
        if ( hclusenum == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_CLUSTER_ENUM );
            bSuccess = FALSE;
            break;
        } // if:  error opening the enumerator

        //
        // Allocate an initial buffer for the object name.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // Loop through the enumeration and add each item to our internal list.
        //
        for ( ienum = 0 ; ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BCollectNetworks() - name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_CLUSTER );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Allocate the network info structure.
            //
            CClusNetworkInfo * pni = new CClusNetworkInfo( Pwiz()->Pci(), pwszName );
            if ( pni == NULL )
            {
                sc = GetLastError();
                m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
                break;
            } // if: error allocating network info structure

            //
            // Initialize the network info structure.
            //
            ATLTRACE( _T("CWizardThread::_BCollectNetworks() - Querying network info about '%s'\n"), pwszName );
            bSuccess = _BQueryNetwork( pni );
            if ( ! bSuccess )
            {
                delete pni;
                break;
            } // if:  error querying for network properties

            //
            // Add this network to the list.
            //
            Pwiz()->PlpniNetworks()->insert( Pwiz()->PlpniNetworks()->end(), pni );
        } // for:  each network in the enumeration
    } while ( 0 );

    //
    // Cleanup.
    //
    delete [] pwszName;
    if ( hclusenum != NULL )
    {
        ClusterCloseEnum( hclusenum );
    } // if:  enumeration still open

    if ( bSuccess )
    {
        Pwiz()->SetCollectedNetworks();
    } // if:  networks collected successfully

    return bSuccess;

} //*** CWizardThread::_BCollectNetworks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCollectNodes
//
//  Routine Description:
//      (WZTF_COLLECT_NODES) Collect nodes in the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCollectNodes( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( ! Pwiz()->BCollectedNodes() );

    DWORD       sc;
    BOOL        bSuccess = TRUE;
    HCLUSENUM   hclusenum = NULL;
    LPWSTR      pwszName = NULL;
    DWORD       cchmacName = 128;
    DWORD       cchName;
    int         ienum;
    ULONG       ceType;

    // Loop to avoid goto's.
    do
    {
        //
        // Open the enumerator.
        //
        ATLTRACE( _T("CWizardThread::_BCollectNodes() - Calling ClusterOpenEnum()\n") );
        hclusenum = ClusterOpenEnum( Pwiz()->Hcluster(), CLUSTER_ENUM_NODE );
        if ( hclusenum == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_CLUSTER_ENUM );
            bSuccess = FALSE;
            break;
        } // if:  error opening the enumerator

        //
        // Allocate an initial buffer for the object name.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // Loop through the enumeration and add each item to our internal list.
        //
        for ( ienum = 0 ; ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BCollectNodes() - name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_CLUSTER );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Allocate the node info structure.
            //
            CClusNodeInfo * pni = new CClusNodeInfo( Pwiz()->Pci(), pwszName );
            if ( pni == NULL )
            {
                sc = GetLastError();
                m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
                break;
            } // if: error allocating node info structure

            //
            // Initialize the node info structure.
            //
            ATLTRACE( _T("CWizardThread::_BCollectNodes() - Querying network info about '%s'\n"), pwszName );
            bSuccess = _BQueryNode( pni );
            if ( ! bSuccess )
            {
                delete pni;
                break;
            } // if:  error querying for node properties

            //
            // Add this node to the list.
            //
            Pwiz()->PlpniNodes()->insert( Pwiz()->PlpniNodes()->end(), pni );

            //
            // Add this node to each of the resources we care about.
            //
            Pwiz()->PriIPAddress()->m_lpniPossibleOwners.insert( Pwiz()->PriIPAddress()->m_lpniPossibleOwners.end(), pni );
            Pwiz()->PriNetworkName()->m_lpniPossibleOwners.insert( Pwiz()->PriNetworkName()->m_lpniPossibleOwners.end(), pni );
            Pwiz()->PriApplication()->m_lpniPossibleOwners.insert( Pwiz()->PriApplication()->m_lpniPossibleOwners.end(), pni );
        } // for:  each node in the enumeration

        if ( m_nte.Sc() != ERROR_SUCCESS )
        {
            break;
        } // if: error occurred in the for loop

        //
        // Indicate that nodes have now been collected.
        //
        Pwiz()->SetCollectedNodes();

        //
        // Collect preferred owners for groups.
        //
        CClusGroupPtrList::iterator itgrp;
        for ( itgrp = Pwiz()->PlpgiGroups()->begin()
            ; itgrp != Pwiz()->PlpgiGroups()->end()
            ; itgrp++ )
        {
            //
            // Collect preferred owners.  Ignore errors as since error
            // collecting groups for one group may not affect other groups.
            //
            CClusGroupInfo * pgi = *itgrp;
            _BGetPreferredOwners( pgi );
        } // for:  each group already collected

        //
        // Collect possible owners for resources.
        //
        CClusResPtrList::iterator itres;
        for ( itres = Pwiz()->PlpriResources()->begin()
            ; itres != Pwiz()->PlpriResources()->end()
            ; itres++ )
        {
            //
            // Collect possible owners.  Ignore errors as an error collecting
            // groups for one resource may not affect other resources.
            //
            CClusResInfo * pri = *itres;
            _BGetPossibleOwners( pri );
        } // for:  each resource already collected
    } while ( 0 );

    //
    // Cleanup.
    //
    delete [] pwszName;
    if ( hclusenum != NULL )
    {
        ClusterCloseEnum( hclusenum );
    } // if:  enumeration still open

    return bSuccess;

} //*** CWizardThread::_BCollectNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCopyGroupInfo
//
//  Routine Description:
//      (WZTF_COPY_GROUP_INFO) Copy one group info object to another.
//
//  Arguments:
//      ppgi        [IN OUT] Array of two CGroupInfo pointers.
//                      [0] = Destination group info object pointer.
//                      [1] = Source group info object pointer.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCopyGroupInfo( IN OUT CClusGroupInfo ** ppgi )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( ppgi != NULL );
    ASSERT( ppgi[ 0 ] != NULL );
    ASSERT( ppgi[ 1 ] != NULL );

    DWORD   sc;
    BOOL    bSuccess = TRUE;

    // Loop to avoid goto's.
    do
    {
        //
        // Copy the group.
        //
        sc = ppgi[ 0 ]->ScCopy( *ppgi[ 1 ] );
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_OPEN_GROUP, ppgi[ 1 ]->m_strName );
            bSuccess = FALSE;
            break;
        } // if:  error copying the group
    } while ( 0 );

    return bSuccess;

} //*** CWizardThread::_BCopyGroupInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCollectDependencies
//
//  Routine Description:
//      (WZTF_COLLECT_DEPENDENCIES) Collect dependencies for a resource in
//      the cluster.
//
//  Arguments:
//      pri         [IN OUT] Resource to collect dependencies for.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCollectDependencies( IN OUT CClusResInfo * pri )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( pri != NULL );
    ASSERT( ! pri->m_bCollectedDependencies );

    BOOL    bSuccess = TRUE;
    DWORD   sc;

    // Loop to avoid goto's.
    do
    {
        //
        // Open the resource if not open yet.
        //
        if ( pri->Hresource() == NULL )
        {
            sc = pri->ScOpen();
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_OPEN_RESOURCE, pri->RstrName() );
                bSuccess = FALSE;
                break;
            } // if:  error opening the enumerator
        } // if:  resource not open yet

        //
        // Collect dependencies for the resource.
        //
        bSuccess = _BGetDependencies( pri );
    } while ( 0 );

    return bSuccess;

} //*** CWizardThread::_BCollectDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCreateVirtualServer
//
//  Routine Description:
//      (WZTF_CREATE_VIRTUAL_SERVER) Create a virtual server.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCreateVirtualServer( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->BCreatingNewVirtualServer() );
    ASSERT( ! Pwiz()->BNewGroupCreated() );
    ASSERT( ! Pwiz()->BExistingGroupRenamed() );
    ASSERT( ! Pwiz()->BIPAddressCreated() );
    ASSERT( ! Pwiz()->BNetworkNameCreated() );

    DWORD               sc = ERROR_SUCCESS;
    BOOL                bSuccess = FALSE;
    CClusGroupInfo *    pgiExisting = Pwiz()->PgiExistingGroup();
    CClusGroupInfo *    pgiNew = &Pwiz()->RgiCurrent();
    CClusResInfo *      priIPAddr = &Pwiz()->RriIPAddress();
    CClusResInfo *      priNetName = &Pwiz()->RriNetworkName();

    // Loop to avoid goto's
    do
    {
        //
        // If creating a new group, do it now.
        // Otherwise rename the existing group.
        //
        if ( Pwiz()->BCreatingNewGroup() )
        {
            //
            // Create the group.
            //
            sc = pgiNew->ScCreate();
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_CREATE_GROUP, pgiNew->RstrName() );
                break;
            } // if:  error creating the group

            //
            // Indicate we created the group.
            //
            Pwiz()->SetNewGroupCreated();
        } // if:  creating a new group
        else
        {
            //
            // Open the group.
            //
            ASSERT( pgiExisting != NULL );
            if ( pgiExisting->Hgroup() == NULL )
            {
                sc = pgiExisting->ScOpen();
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_OPEN_GROUP, pgiExisting->RstrName() );
                    break;
                } // if:  error opening the group
            } // if:  group not open yet

            //
            // Rename the group.
            //
            if ( pgiExisting->RstrName() != pgiNew->RstrName() )
            {
                sc = SetClusterGroupName( pgiExisting->Hgroup(), pgiNew->RstrName() );
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_RENAME_GROUP, pgiExisting->RstrName(), pgiNew->RstrName() );
                    break;
                } // if:  error renaming the group
            } // if:  group name changed

            //
            // Open the other group object.
            //
            if ( pgiNew->Hgroup() == NULL )
            {
                sc = pgiNew->ScOpen();
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_OPEN_GROUP, pgiNew->RstrName() );
                    break;
                } // if:  error opening the other group
            } // if:  new group object not open yet

            //
            // Indicate we renamed the group.
            //
            Pwiz()->SetExistingGroupRenamed();
        } // else:  using an existing group

        //
        // Set common group properties.
        //
        if ( ! _BSetGroupProperties( pgiNew, pgiExisting ) )
        {
            break;
        } // if:  error setting group properties

        //
        // Create the IP Address resource.
        //
        if ( ! _BCreateResource( *priIPAddr, pgiNew->Hgroup() ) )
        {
            break;
        } // if:  error creating IP Address resource

        //
        // Set private properties on the IP Address resource.
        //
        {
            CClusPropList   props;
            DWORD           cbProps;

            props.ScAddProp( CLUSREG_NAME_IPADDR_ADDRESS, Pwiz()->RstrIPAddress() );
            props.ScAddProp( CLUSREG_NAME_IPADDR_SUBNET_MASK, Pwiz()->RstrSubnetMask() );
            props.ScAddProp( CLUSREG_NAME_IPADDR_NETWORK, Pwiz()->RstrNetwork() );
            if ( props.Cprops() > 0 )
            {
                sc = ClusterResourceControl(
                                priIPAddr->Hresource(),
                                NULL,   // hNode
                                CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                                props.PbPropList(),
                                props.CbPropList(),
                                NULL,   // lpOutBuffer
                                0,      // nOutBufferSize
                                &cbProps
                                );
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_SET_PRIVATE_RES_PROPS, priIPAddr->RstrName() );
                    break;
                } // if:  error setting private resource properties
            } // if:  any props were added

        } // Set private properties on the IP Address resource

        //
        // Create the Network Name resource.
        //
        if ( ! _BCreateResource( *priNetName, pgiNew->Hgroup() ) )
        {
            break;
        } // if:  error creating Network Name resource

        //
        // Add a dependency for the Network name resource on the IP Address resource.
        //
        if ( 0 )
        {
            sc = AddClusterResourceDependency( priNetName->Hresource(), priIPAddr->Hresource() );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_ADD_DEPENDENCY, priNetName->RstrName(), priIPAddr->RstrName() );
                break;
            } // if:  error adding the dependency
        } // Add a dependency for the Network name resource on the IP Address resource

        //
        // Set private properties on the Network Name resource.
        //
        {
            CClusPropList   props;
            DWORD           cbProps;

            props.ScAddProp( CLUSREG_NAME_NETNAME_NAME, Pwiz()->RstrNetName() );
            if ( props.Cprops() > 0 )
            {
                sc = ClusterResourceControl(
                                priNetName->Hresource(),
                                NULL,   // hNode
                                CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                                props.PbPropList(),
                                props.CbPropList(),
                                NULL,   // lpOutBuffer
                                0,      // nOutBufferSize
                                &cbProps
                                );
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_SET_PRIVATE_RES_PROPS, priNetName->RstrName() );
                    break;
                } // if:  error setting private resource properties
            } // if:  any props were added

        } // Set private properties on the Network Name resource

        //
        // Update the virtual server properties on the group.
        //
        pgiNew->SetVirtualServerProperties( Pwiz()->RstrNetName(), Pwiz()->RstrIPAddress(), Pwiz()->RstrNetwork() );

        //
        // If we made it to here, the operation was successful.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Construct the error info if an error occurred.
    //
    if ( ! bSuccess )
    {
        if ( Pwiz()->BNetworkNameCreated() && (priNetName->Hresource() != NULL) )
        {
            priNetName->ScDelete();
        } // if:  created Network Name resource
        if ( Pwiz()->BIPAddressCreated() && (priIPAddr->Hresource() != NULL) )
        {
            priIPAddr->ScDelete();
        } // if:  created IP Address resource
        if ( Pwiz()->BNewGroupCreated() && (pgiNew->Hgroup() != NULL) )
        {
            pgiNew->ScDelete();
            Pwiz()->SetNewGroupCreated( FALSE );
        } // if:  created group
        else if ( Pwiz()->BExistingGroupRenamed() && (pgiExisting->Hgroup() != NULL) )
        {
            sc = SetClusterGroupName( pgiExisting->Hgroup(), pgiExisting->RstrName() );
            Pwiz()->SetExistingGroupRenamed( FALSE );
        } // else if:  renamed group
    } // if:  error occurred
    else
    {
        Pwiz()->SetClusterUpdated();
        Pwiz()->SetVSDataChanged( FALSE );
    } // else:  cluster updated successfully

    return bSuccess;

} //*** CWizardThread::_BCreateVirtualServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCreateAppResource
//
//  Routine Description:
//      (WZTF_CREATE_APP_RESOURCE) Create an application resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCreateAppResource( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->BCreatingAppResource() );
    ASSERT( ! Pwiz()->BAppResourceCreated() );

    DWORD   sc = ERROR_SUCCESS;
    BOOL    bSuccess = FALSE;

    // Loop to avoid goto's
    do
    {
        //
        // Open the group.
        //
        if ( Pwiz()->RgiCurrent().Hgroup() == NULL )
        {
            sc = Pwiz()->RgiCurrent().ScOpen();
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperationIfEmpty(
                    sc,
                    IDS_ERROR_OPEN_GROUP,
                    Pwiz()->RgiCurrent().RstrName()
                    );
                break;
            } // if:  error opening the group
        } // if:  group not open yet

        //
        // Create the application resource.
        //
        if ( ! _BCreateResource( Pwiz()->RriApplication(), Pwiz()->RgiCurrent().Hgroup() ) )
        {
            break;
        } // if:  error creating IP Address resource

        //
        // If we made it to here, the operation was successful.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Construct the error info if an error occurred.
    //
    if ( ! bSuccess )
    {
        if ( Pwiz()->BAppResourceCreated() && (Pwiz()->RriApplication().Hresource() != NULL) )
        {
            Pwiz()->RriApplication().ScDelete();
        } // if:  created application resource
    } // if:  error occurred
    else
    {
        Pwiz()->SetClusterUpdated();
        Pwiz()->SetAppDataChanged( FALSE );
    } // else:  cluster updated successfully

    return bSuccess;

} //*** CWizardThread::_BCreateAppResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BDeleteAppResource
//
//  Routine Description:
//      (WZTF_DELETE_APP_RESOURCE) Delete the application resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BDeleteAppResource( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );

    BOOL bSuccess = FALSE;

    //
    // Delete the application resource if we created it.
    //
    bSuccess = _BDeleteResource( Pwiz()->RriApplication() );
    if ( bSuccess )
    {
        Pwiz()->SetAppDataChanged( FALSE );
    } // if:  resource deleted successfully


    return bSuccess;

} //*** CWizardThread::_BDeleteAppResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BResetCluster
//
//  Routine Description:
//      (WZTF_RESET_CLUSTER) Reset the cluster.
//      Delete the resources we created and delete or rename the group.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BResetCluster( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );

    BOOL bSuccess = FALSE;

    //
    // Delete the application resource if we created it.
    //
    bSuccess = _BDeleteResource( Pwiz()->RriApplication() );

    //
    // Delete the Network Name resource if we created it.
    //
    if ( bSuccess )
    {
        bSuccess = _BDeleteResource( Pwiz()->RriNetworkName() );
    } // if:  successful up to here

    //
    // Delete the IP Address resource if we created it.
    //
    if ( bSuccess )
    {
        bSuccess = _BDeleteResource( Pwiz()->RriIPAddress() );
    } // if:  successful up to here

    //
    // Delete or rename the group if we created or renamed it.
    //
    if ( bSuccess )
    {
        bSuccess = _BResetGroup();
    } // if:  successful up to here

    //
    // If we are successful to this point, indicate that the cluster no longer
    // needs to be cleaned up.
    //
    if ( bSuccess )
    {
        Pwiz()->SetClusterUpdated( FALSE );
        Pwiz()->SetVSDataChanged( FALSE );
        Pwiz()->SetAppDataChanged( FALSE );
    } // if:  cluster reset successfully

    return bSuccess;

} //*** CWizardThread::_BResetCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BSetAppResAttributes
//
//  Routine Description:
//      (WZTF_SET_APPRES_ATTRIBUTES) Set properties, dependencies, owners of 
//      the application resource.
//
//  Arguments:
//      plpriOldDependencies    [IN] Pointer to the old resource dependency list
//      plpniOldPossibleOwners  [IN] Pointer to the old list of possible owner nodes
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BSetAppResAttributes(
        IN CClusResPtrList *    plpriOldDependencies,
        IN CClusNodePtrList *   plpniOldPossibleOwners
        )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    BOOL bSuccess;

    bSuccess = _BSetResourceAttributes( 
                    Pwiz()->RriApplication(),
                    plpriOldDependencies,
                    plpniOldPossibleOwners
                    );
    if ( bSuccess )
    {
        Pwiz()->SetAppDataChanged( FALSE );
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BQueryResource
//
//  Routine Description:
//      Query for information about a resource (thread).
//
//  Arguments:
//      pri         [IN OUT] Resource info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BQueryResource( IN OUT CClusResInfo * pri )
{
    ASSERT( pri != NULL );

    BOOL    bSuccess = TRUE;
    DWORD   sc;

    // Loop to avoid goto's
    do
    {
        //
        // Indicate that we've now queried the resource.
        //
        pri->BSetQueried();

        //
        // Open the resource.
        //
        sc = pri->ScOpen();
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_OPEN_RESOURCE, pri->RstrName() );
            bSuccess = FALSE;
            break;
        } // if:  error opening the resource

        //
        // Get resource properties.
        //
        bSuccess = _BGetResourceProps( pri );
        if ( ! bSuccess )
        {
            break;
        } // if:  error getting properties

        //
        // Collect the possible owners.
        //
        bSuccess = _BGetPossibleOwners( pri );
        if ( ! bSuccess )
        {
            break;
        } // if:  error getting possible owners

    } while ( 0 );

    return bSuccess;

} //*** CWizardThread::_BQueryResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetResourceProps
//
//  Routine Description:
//      Get resource properties (thread).
//
//  Arguments:
//      pri         [IN OUT] Resource info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetResourceProps( IN OUT CClusResInfo * pri )
{
    ASSERT( pri != NULL );
    ASSERT( pri->Hresource() != NULL );

    DWORD           sc;
    BOOL            bSuccess = FALSE;
    CClusPropList   cpl;
    LPWSTR          pwsz = NULL;

    RESUTIL_PROPERTY_ITEM ptable[] =
    { { CLUSREG_NAME_RES_SEPARATE_MONITOR,  NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET( CClusResInfo, m_bSeparateMonitor ) }
    , { CLUSREG_NAME_RES_PERSISTENT_STATE,  NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_PERSISTENT_STATE,  CLUSTER_RESOURCE_MINIMUM_PERSISTENT_STATE,  CLUSTER_RESOURCE_MAXIMUM_PERSISTENT_STATE, RESUTIL_PROPITEM_SIGNED, FIELD_OFFSET( CClusResInfo, m_nPersistentState ) }
    , { CLUSREG_NAME_RES_LOOKS_ALIVE,       NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE,       CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE,       CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE, 0, FIELD_OFFSET( CClusResInfo, m_nLooksAlive ) }
    , { CLUSREG_NAME_RES_IS_ALIVE,          NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_IS_ALIVE,          CLUSTER_RESOURCE_MINIMUM_IS_ALIVE,          CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE, 0, FIELD_OFFSET( CClusResInfo, m_nIsAlive ) }
    , { CLUSREG_NAME_RES_RESTART_ACTION,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION,    0,                                          CLUSTER_RESOURCE_MAXIMUM_RESTART_ACTION, 0, FIELD_OFFSET( CClusResInfo, m_crraRestartAction ) }
    , { CLUSREG_NAME_RES_RESTART_THRESHOLD, NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD, CLUSTER_RESOURCE_MINIMUM_RESTART_THRESHOLD, CLUSTER_RESOURCE_MAXIMUM_RESTART_THRESHOLD, 0, FIELD_OFFSET( CClusResInfo, m_nRestartThreshold ) }
    , { CLUSREG_NAME_RES_RESTART_PERIOD,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD,    CLUSTER_RESOURCE_MINIMUM_RESTART_PERIOD,    CLUSTER_RESOURCE_MAXIMUM_RESTART_PERIOD, 0, FIELD_OFFSET( CClusResInfo, m_nRestartPeriod ) }
    , { CLUSREG_NAME_RES_PENDING_TIMEOUT,   NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT,   CLUSTER_RESOURCE_MINIMUM_PENDING_TIMEOUT,   CLUSTER_RESOURCE_MAXIMUM_PENDING_TIMEOUT, 0, FIELD_OFFSET( CClusResInfo, m_nPendingTimeout ) }
    , { 0 }
    };

    // Loop to avoid goto's
    do
    {
        //
        // Get resource common properties.
        //
        sc = cpl.ScGetResourceProperties( pri->Hresource(), CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error getting properties

        //
        // Parse the properties.
        //
        sc = ResUtilVerifyPropertyTable(
                        ptable,
                        NULL,
                        TRUE, // AllowUnknownProperties
                        cpl.PbPropList(),
                        cpl.CbPropList(),
                        (PBYTE) pri
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error parsing properties

        //
        // Find the Type property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        cpl.CbPropList(),
                        CLUSREG_NAME_RES_TYPE,
                        &pwsz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        CClusResTypeInfo * prti = PobjFromName( Pwiz()->PlprtiResourceTypes(), pwsz );
        pri->BSetResourceType( prti );
        LocalFree( pwsz );
        pwsz = NULL;

        //
        // Find the Description property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        cpl.CbPropList(),
                        CLUSREG_NAME_RES_DESC,
                        &pwsz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        pri->m_strDescription = pwsz;
        LocalFree( pwsz );
        pwsz = NULL;

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Check for errors getting properties.
    //
    if ( sc != ERROR_SUCCESS )
    {
        m_nte.SetOperation( sc, IDS_ERROR_GET_RESOURCE_PROPERTIES, pri->RstrName() );
    } // if:  error occurred getting properties

    if ( pwsz != NULL )
    {
        LocalFree( pwsz );
    } // if:  memory still allocated

    return bSuccess;

} //*** CWizardThread::_BGetResourceProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetPossibleOwners
//
//  Routine Description:
//      Collect the list of possible owners for a resource (thread).
//
//  Arguments:
//      pri         [IN OUT] Resource info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetPossibleOwners( IN OUT CClusResInfo * pri )
{
    ASSERT( pri != NULL );
    ASSERT( pri->Hresource() != NULL );

    DWORD           sc;
    BOOL            bSuccess = TRUE;
    HRESENUM        hre = NULL;
    LPWSTR          pwszName = NULL;
    DWORD           cchmacName = 128;
    DWORD           cchName;
    int             ienum;
    ULONG           reType;
    CClusNodeInfo * pniOwner;

    //
    // Only do this if nodes have been already been collected
    // and we haven't collected owners yet.
    //
    if ( ! Pwiz()->BCollectedNodes() || pri->m_bCollectedOwners )
    {
        return TRUE;
    } // if:  nodes not collected yet

    // Loop to avoid goto's
    do
    {
        //
        // Open an enumeration for the resource.
        //
        hre = ClusterResourceOpenEnum( pri->Hresource(), CLUSTER_RESOURCE_ENUM_NODES );
        if ( hre == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_RESOURCE_ENUM, pri->RstrName() );
            bSuccess = FALSE;
            break;
        } // if:  error opening the resource enumerator

        //
        // Allocate an initial buffer for the object names.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // For each owner, add it to the list.
        //
        for ( ienum = 0 ; 1 ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterResourceEnum( hre, ienum, &reType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BGetPossibleOwners() - owner name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterResourceEnum( hre, ienum, &reType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_RESOURCE );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Find the node in our list and insert it into the list.
            //
            pniOwner = Pwiz()->PniFindNodeNoCase( pwszName );
            if ( pniOwner != NULL )
            {
                pri->m_lpniPossibleOwners.insert( pri->m_lpniPossibleOwners.end(), pniOwner );
            } // if:  node exists in the list
        } // for:  each owner in the enumeration

        //
        // Indicate owners have been collected.
        //
        pri->m_bCollectedOwners = TRUE;
    } while ( 0 );

    //
    // Cleanup.
    //
    if ( hre != NULL )
    {
        ClusterResourceCloseEnum( hre );
    } // if:  enumeration still open
    delete [] pwszName;

    return bSuccess;

} //*** CWizardThread::_BGetPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetDependencies
//
//  Routine Description:
//      Collect the list of dependencies for a resource (thread).
//
//  Arguments:
//      pri         [IN OUT] Resource info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetDependencies( IN OUT CClusResInfo * pri )
{
    ASSERT( pri != NULL );
    ASSERT( pri->Hresource() != NULL );

    DWORD           sc;
    BOOL            bSuccess = TRUE;
    HRESENUM        hre = NULL;
    LPWSTR          pwszName = NULL;
    DWORD           cchmacName = 128;
    DWORD           cchName;
    int             ienum;
    ULONG           reType;
    CClusResInfo *  priDependency;

    //
    // Only do this if we haven't collected dependencies yet.
    //
    if ( pri->m_bCollectedDependencies )
    {
        return TRUE;
    } // if:  dependencies collected already

    // Loop to avoid goto's
    do
    {
        //
        // Open an enumeration for the resource.
        //
        hre = ClusterResourceOpenEnum( pri->Hresource(), CLUSTER_RESOURCE_ENUM_DEPENDS );
        if ( hre == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_RESOURCE_ENUM, pri->RstrName() );
            bSuccess = FALSE;
            break;
        } // if:  error opening the resource enumerator

        //
        // Allocate an initial buffer for the object names.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // For each dependency, add it to the list.
        //
        for ( ienum = 0 ; 1 ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterResourceEnum( hre, ienum, &reType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BGetDependencies() - dependency name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterResourceEnum( hre, ienum, &reType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_RESOURCE );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Find the resource in our list and insert it into the list.
            //
            priDependency = Pwiz()->PriFindResourceNoCase( pwszName );
            if ( priDependency != NULL )
            {
                pri->m_lpriDependencies.insert( pri->m_lpriDependencies.end(), priDependency );
            } // if:  resource exists in the list
        } // for:  each owner in the enumeration

        //
        // Indicate dependencies have been collected.
        //
        pri->m_bCollectedDependencies = TRUE;
    } while ( 0 );

    //
    // Cleanup.
    //
    if ( hre != NULL )
    {
        ClusterResourceCloseEnum( hre );
    } // if:  enumeration still open
    delete [] pwszName;

    return bSuccess;

} //*** CWizardThread::_BGetDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BQueryGroup
//
//  Routine Description:
//      Query for information about a group (thread).
//
//  Arguments:
//      pgi         [IN OUT] Group info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BQueryGroup( IN OUT CClusGroupInfo * pgi )
{
    ASSERT( pgi != NULL );

    DWORD           sc;
    BOOL            bSuccess = TRUE;

    // Loop to avoid goto's
    do
    {
        //
        // Open the group.
        //
        sc = pgi->ScOpen();
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_OPEN_GROUP, pgi->RstrName() );
            bSuccess = FALSE;
            break;
        } // if:  error opening the group

        //
        // Get group properties.
        //
        bSuccess = _BGetGroupProps( pgi );
        if ( ! bSuccess )
        {
            pgi->Close();
            break;
        } // if:  error getting properties

        //
        // Collect the list of resources in the group.
        //
        bSuccess = _BGetResourcesInGroup( pgi );
        if ( ! bSuccess )
        {
            pgi->Close();
            break;
        } // if:  error getting resources in the group

        //
        // Collect the preferred owners.
        //
        bSuccess = _BGetPreferredOwners( pgi );
        if ( ! bSuccess )
        {
            pgi->PlpriResources()->erase( pgi->PlpriResources()->begin(), pgi->PlpriResources()->end() );
            pgi->Close();
            break;
        } // if:  error getting preferred owners

        //
        // Indicate that we've now queried the group.
        //
        pgi->BSetQueried();

    } while ( 0 );

    return bSuccess;

} //*** CWizardThread::_BQueryGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetGroupProps
//
//  Routine Description:
//      Get group properties (thread).
//
//  Arguments:
//      pgi         [IN OUT] Group info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetGroupProps(
    IN OUT CClusGroupInfo * pgi
    )
{
    ASSERT( pgi != NULL );
    ASSERT( pgi->Hgroup() != NULL );

    DWORD           sc;
    BOOL            bSuccess = FALSE;
    CClusPropList   cpl;
    LPWSTR          pwsz = NULL;

    RESUTIL_PROPERTY_ITEM ptable[] =
    { { CLUSREG_NAME_GRP_PERSISTENT_STATE,      NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET( CClusGroupInfo, m_nPersistentState ) }
    , { CLUSREG_NAME_GRP_FAILOVER_THRESHOLD,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD,    CLUSTER_GROUP_MINIMUM_FAILOVER_THRESHOLD, CLUSTER_GROUP_MAXIMUM_FAILOVER_THRESHOLD, 0, FIELD_OFFSET( CClusGroupInfo, m_nFailoverThreshold ) }
    , { CLUSREG_NAME_GRP_FAILOVER_PERIOD,       NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD,       CLUSTER_GROUP_MINIMUM_FAILOVER_PERIOD, CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD, 0, FIELD_OFFSET( CClusGroupInfo, m_nFailoverPeriod ) }
    , { CLUSREG_NAME_GRP_FAILBACK_TYPE,         NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_AUTO_FAILBACK_TYPE,    0, CLUSTER_GROUP_MAXIMUM_AUTO_FAILBACK_TYPE, 0, FIELD_OFFSET( CClusGroupInfo, m_cgaftAutoFailbackType ) }
    , { CLUSREG_NAME_GRP_FAILBACK_WIN_START,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_START, CLUSTER_GROUP_MINIMUM_FAILBACK_WINDOW_START, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START, RESUTIL_PROPITEM_SIGNED, FIELD_OFFSET( CClusGroupInfo, m_nFailbackWindowStart ) }
    , { CLUSREG_NAME_GRP_FAILBACK_WIN_END,      NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_END,   CLUSTER_GROUP_MINIMUM_FAILBACK_WINDOW_END,   CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END,   RESUTIL_PROPITEM_SIGNED, FIELD_OFFSET( CClusGroupInfo, m_nFailbackWindowEnd ) }
    , { 0 }
    };

    // Loop to avoid goto's
    do
    {
        //
        // Get group common properties.
        //
        sc = cpl.ScGetGroupProperties( pgi->Hgroup(), CLUSCTL_GROUP_GET_COMMON_PROPERTIES );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error getting properties

        //
        // Parse the properties.
        //
        sc = ResUtilVerifyPropertyTable(
                        ptable,
                        NULL,
                        TRUE, // AllowUnknownProperties
                        cpl.PbPropList(),
                        cpl.CbPropList(),
                        (PBYTE) pgi
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error parsing properties

        //
        // Find the Description property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        cpl.CbPropList(),
                        CLUSREG_NAME_GRP_DESC,
                        &pwsz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        pgi->m_strDescription = pwsz;
        LocalFree( pwsz );
        pwsz = NULL;

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Check for errors getting properties.
    //
    if ( sc != ERROR_SUCCESS )
    {
        m_nte.SetOperation( sc, IDS_ERROR_GET_GROUP_PROPERTIES, pgi->RstrName() );
    } // if:  error occurred

    if ( pwsz != NULL )
    {
        LocalFree( pwsz );
    } // if:  memory still allocated

    return bSuccess;

} //*** CWizardThread::_BGetGroupProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetResourcesInGroup
//
//  Routine Description:
//      Collect the list of resources contained in a group (thread).
//
//  Arguments:
//      pgi         [IN OUT] Group info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetResourcesInGroup( IN OUT CClusGroupInfo * pgi )
{
    ASSERT( pgi != NULL );
    ASSERT( pgi->Hgroup() != NULL );

    DWORD           sc;
    BOOL            bSuccess = TRUE;
    HGROUPENUM      hge = NULL;
    LPWSTR          pwszName = NULL;
    DWORD           cchmacName = 128;
    DWORD           cchName;
    int             ienum;
    ULONG           geType;
    CClusResInfo *  pri;

    //
    // Only do this if resources have been already been collected
    // and we haven't collected resources in this group yet.
    //
    if ( ! Pwiz()->BCollectedResources() || pgi->m_bCollectedResources )
    {
        return TRUE;
    } // if:  nodes not collected yet

    // Loop to avoid goto's
    do
    {
        //
        // Open an enumeration for the group.
        //
        hge = ClusterGroupOpenEnum( pgi->Hgroup(), CLUSTER_GROUP_ENUM_CONTAINS );
        if ( hge == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_GROUP_ENUM, pgi->RstrName() );
            bSuccess = FALSE;
            break;
        } // if:  error opening the group enumerator

        //
        // Allocate an initial buffer for the object names.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // For each resource, add it to the list.
        //
        for ( ienum = 0 ; 1 ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterGroupEnum( hge, ienum, &geType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BGetResourcesInGroup() - name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterGroupEnum( hge, ienum, &geType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_GROUP );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Find the node in our list and insert it into the list.
            //
            pri = Pwiz()->PriFindResourceNoCase( pwszName );
            if ( pri == NULL )
            {
                m_nte.SetOperation( ERROR_FILE_NOT_FOUND, 0 );
                bSuccess = FALSE;
                break;
            } // if:  didn't find the resource
            pgi->m_lpriResources.insert( pgi->m_lpriResources.end(), pri );

            //
            // Check to see if it is an IP Address resource or a Network Name
            // resource and store the result in the list entry.
            //
            ASSERT( pri->Prti() != NULL );
            if ( pri->Prti()->RstrName().CompareNoCase( CLUS_RESTYPE_NAME_IPADDR ) == 0 )
            {
                if ( ! pgi->BHasIPAddress() )
                {
                    pgi->m_bHasIPAddress = TRUE;

                    //
                    // Read IP Address private properties.
                    //
                    bSuccess = _BGetIPAddressPrivatePropsForGroup( pgi, pri );
                    if ( ! bSuccess )
                    {
                        break;
                    } // if:  error getting props
                } // if:  first IP Address resource in group
            } // if:  this is an IP Address resource
            else if ( pri->Prti()->RstrName().CompareNoCase( CLUS_RESTYPE_NAME_NETNAME ) == 0 )
            {
                if ( ! pgi->BHasNetName() )
                {
                    pgi->m_bHasNetName = TRUE;

                    //
                    // Read Network Name private properties.
                    //
                    bSuccess = _BGetNetworkNamePrivatePropsForGroup( pgi, pri );
                    if ( ! bSuccess )
                    {
                        break;
                    } // if:  error getting props
                } // if:  first Network Name resource in group
            } // else if:  this is a Network Name resource
        } // for:  each owner in the enumeration

        //
        // Indicate owners have been collected.
        //
        pgi->m_bCollectedResources = TRUE;
    } while ( 0 );

    //
    // Cleanup.
    //
    if ( hge != NULL )
    {
        ClusterGroupCloseEnum( hge );
    } // if:  enumeration still open
    delete [] pwszName;

    return bSuccess;

} //*** CWizardThread::_BGetResourcesInGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetPreferredOwners
//
//  Routine Description:
//      Collect the list of preferred owners for a group (thread).
//
//  Arguments:
//      pgi         [IN OUT] Group info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetPreferredOwners( IN OUT CClusGroupInfo * pgi )
{
    ASSERT( pgi != NULL );
    ASSERT( pgi->Hgroup() != NULL );

    DWORD           sc;
    BOOL            bSuccess = TRUE;
    HGROUPENUM      hge = NULL;
    LPWSTR          pwszName = NULL;
    DWORD           cchmacName = 128;
    DWORD           cchName;
    int             ienum;
    ULONG           geType;
    CClusNodeInfo * pniOwner;

    //
    // Only do this if nodes have been already been collected
    // and we haven't collected owners yet.
    //
    if ( ! Pwiz()->BCollectedNodes() || pgi->m_bCollectedOwners )
    {
        return TRUE;
    } // if:  nodes not collected yet

    // Loop to avoid goto's
    do
    {
        //
        // Open an enumeration for the group.
        //
        hge = ClusterGroupOpenEnum( pgi->Hgroup(), CLUSTER_GROUP_ENUM_NODES );
        if ( hge == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_GROUP_ENUM, pgi->RstrName() );
            bSuccess = FALSE;
            break;
        } // if:  error opening the group enumerator

        //
        // Allocate an initial buffer for the object names.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // For each owner, add it to the list.
        //
        for ( ienum = 0 ; 1 ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterGroupEnum( hge, ienum, &geType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BGetPreferredOwners() - owner name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterGroupEnum( hge, ienum, &geType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_GROUP );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Find the node in our list and insert it into the list.
            //
            pniOwner = Pwiz()->PniFindNodeNoCase( pwszName );
            if ( pniOwner != NULL )
            {
                pgi->m_lpniPreferredOwners.insert( pgi->m_lpniPreferredOwners.end(), pniOwner );
            } // if:  node exists in the list
        } // for:  each owner in the enumeration

        //
        // Indicate owners have been collected.
        //
        pgi->m_bCollectedOwners = TRUE;
    } while ( 0 );

    //
    // Cleanup.
    //
    if ( hge != NULL )
    {
        ClusterGroupCloseEnum( hge );
    } // if:  enumeration still open
    delete [] pwszName;

    return bSuccess;

} //*** CWizardThread::_BGetPreferredOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetIPAddressPrivatePropsForGroup
//
//  Routine Description:
//      Collect the private properties of the IP Address resource in the
//      group and save the IP Address and Network properties in the group
//      object.
//
//  Arguments:
//      pgi         [IN OUT] Group info.
//      pri         [IN OUT] Resource info for an IP Address resource.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetIPAddressPrivatePropsForGroup(
    IN OUT CClusGroupInfo * pgi,
    IN OUT CClusResInfo *   pri
    )
{
    ASSERT( pgi != NULL );
    ASSERT( pgi->Hgroup() != NULL );
    ASSERT( pri != NULL );
    ASSERT( pri->Hresource() != NULL );
    ASSERT( pri->Prti()->RstrName().CompareNoCase( CLUS_RESTYPE_NAME_IPADDR ) == 0 );

    DWORD           sc;
    BOOL            bSuccess = TRUE;
    CClusPropList   cpl;
    LPWSTR          pwsz = NULL;

    // Loop to avoid goto's
    do
    {
        //
        // Get resource private properties.
        //
        sc = cpl.ScGetResourceProperties( pri->Hresource(), CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error getting properties

        //
        // Find the IP Address property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        cpl.CbPropList(),
                        CLUSREG_NAME_IPADDR_ADDRESS,
                        &pwsz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        pgi->m_strIPAddress = pwsz;
        LocalFree( pwsz );
        pwsz = NULL;

        //
        // Find the Network property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        cpl.CbPropList(),
                        CLUSREG_NAME_IPADDR_NETWORK,
                        &pwsz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        pgi->m_strNetwork = pwsz;
        LocalFree( pwsz );
        pwsz = NULL;

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Check for errors getting properties.
    //
    if ( sc != ERROR_SUCCESS )
    {
        m_nte.SetOperation( sc, IDS_ERROR_GET_RESOURCE_PROPERTIES, pri->RstrName() );
    } // if:  error occurred getting properties

    if ( pwsz != NULL )
    {
        LocalFree( pwsz );
    } // if:  memory still allocated

    return bSuccess;

} //*** CWizardThread::_BGetIPAddressPrivatePropsForGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetNetworkNamePrivatePropsForGroup
//
//  Routine Description:
//      Collect the private properties of the Network Name resource in the
//      group and save the Network Name property in the group object.
//
//  Arguments:
//      pgi         [IN OUT] Group info.
//      pri         [IN OUT] Resource info for an Network Name resource.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetNetworkNamePrivatePropsForGroup(
    IN OUT CClusGroupInfo * pgi,
    IN OUT CClusResInfo *   pri
    )
{
    ASSERT( pgi != NULL );
    ASSERT( pgi->Hgroup() != NULL );
    ASSERT( pri != NULL );
    ASSERT( pri->Hresource() != NULL );
    ASSERT( pri->Prti()->RstrName().CompareNoCase( CLUS_RESTYPE_NAME_NETNAME ) == 0 );

    DWORD           sc;
    BOOL            bSuccess = TRUE;
    CClusPropList   cpl;
    LPWSTR          pwsz = NULL;

    // Loop to avoid goto's
    do
    {
        //
        // Get resource private properties.
        //
        sc = cpl.ScGetResourceProperties( pri->Hresource(), CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error getting properties

        //
        // Find the Name property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        cpl.CbPropList(),
                        CLUSREG_NAME_NETNAME_NAME,
                        &pwsz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        pgi->m_strNetworkName = pwsz;
        LocalFree( pwsz );
        pwsz = NULL;

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Check for errors getting properties.
    //
    if ( sc != ERROR_SUCCESS )
    {
        m_nte.SetOperation( sc, IDS_ERROR_GET_RESOURCE_PROPERTIES, pri->RstrName() );
    } // if:  error occurred getting properties

    if ( pwsz != NULL )
    {
        LocalFree( pwsz );
    } // if:  memory still allocated

    return bSuccess;

} //*** CWizardThread::_BGetNetworkNamePrivatePropsForGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BQueryResourceType
//
//  Routine Description:
//      Query for information about a resource type (thread).
//
//  Arguments:
//      prti        [IN OUT] Resource type info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BQueryResourceType( IN OUT CClusResTypeInfo * prti )
{
    ASSERT( prti != NULL );
    ASSERT( Pwiz()->Hcluster() != NULL );

    BOOL bSuccess = TRUE;

    // Loop to avoid goto's
    do
    {
        //
        // Indicate that we've now queried the resource type.
        //
        prti->BSetQueried();

        //
        // Get resource type properties.
        //
        bSuccess = _BGetResourceTypeProps( prti );
        if ( ! bSuccess )
        {
            break;
        } // if:  error getting properties

        //
        // Get resource type class info.
        //
        {
            DWORD   cbReturned;
            DWORD   sc;

            sc = ClusterResourceTypeControl(
                            Pwiz()->Hcluster(),
                            prti->RstrName(),
                            NULL,
                            CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO,
                            NULL,
                            NULL,
                            &prti->m_rciResClassInfo,
                            sizeof( prti->m_rciResClassInfo ),
                            &cbReturned
                            );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_GET_RESOURCE_TYPE_PROPERTIES, prti->RstrName() );
                bSuccess = FALSE;
                break;
            } // if:  error getting class info
            else
            {
                ASSERT( cbReturned == sizeof( prti->m_rciResClassInfo ) );
            }  // else:  data retrieved successfully
        } // Get resource type class info

        //
        // Get required dependencies.
        //
        bSuccess = _BGetRequiredDependencies( prti );
        if ( ! bSuccess )
        {
            break;
        } // if:  error getting resource type class info

    } while ( 0 );

    return bSuccess;

} //*** CWizardThread::_BQueryResourceType()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetResourceTypeProps
//
//  Routine Description:
//      Get resource type properties (thread).
//
//  Arguments:
//      prti        [IN OUT] Resource type info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetResourceTypeProps( IN OUT CClusResTypeInfo * prti )
{
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( prti != NULL );

    DWORD           sc;
    BOOL            bSuccess = FALSE;
    CClusPropList   cpl;
    LPWSTR          psz = NULL;
    DWORD           cbValue;

    RESUTIL_PROPERTY_ITEM ptable[] =
    { { CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,   NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE, 0, MAX_DWORD, 0, FIELD_OFFSET( CClusResTypeInfo, m_nLooksAlive ) }
    , { CLUSREG_NAME_RESTYPE_IS_ALIVE,      NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESTYPE_DEFAULT_IS_ALIVE,    0, MAX_DWORD, 0, FIELD_OFFSET( CClusResTypeInfo, m_nIsAlive ) }
    , { 0 }
    };

    // Loop to avoid goto's
    do
    {
        //
        // Get resource type common properties.
        //
        sc = cpl.ScGetResourceTypeProperties(
                        Pwiz()->Hcluster(),
                        prti->RstrName(),
                        CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error getting properties

        //
        // Parse the properties.
        //
        sc = ResUtilVerifyPropertyTable(
                        ptable,
                        NULL,
                        TRUE, // AllowUnknownProperties
                        cpl.PbPropList(),
                        cpl.CbPropList(),
                        (PBYTE) prti
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error parsing properties

        //
        // Find the DLL Name property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        cpl.CbPropList(),
                        CLUSREG_NAME_RESTYPE_NAME,
                        &psz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        prti->m_strDisplayName = psz;
        LocalFree( psz );
        psz = NULL;

        //
        // Find the Description property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        cpl.CbPropList(),
                        CLUSREG_NAME_RESTYPE_DESC,
                        &psz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        prti->m_strDescription = psz;
        LocalFree( psz );
        psz = NULL;

        //
        // Find the AdminExtensions property.
        //
        sc = ResUtilFindMultiSzProperty(
                        cpl.PbPropList(),
                        cpl.CbPropList(),
                        CLUSREG_NAME_ADMIN_EXT,
                        &psz,
                        &cbValue
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property

        //
        // Loop through each value in the property and add it to the list
        // of admin extension strings.
        //
        {
            //
            // Start with a fresh list.
            //
            prti->m_lstrAdminExtensions.erase(
                prti->m_lstrAdminExtensions.begin(),
                prti->m_lstrAdminExtensions.end()
                );

            LPWSTR pszCurrent = psz;
            while ( *pszCurrent != L'\0' )
            {
                prti->m_lstrAdminExtensions.insert(
                    prti->m_lstrAdminExtensions.end(),
                    pszCurrent
                    );
                pszCurrent += lstrlenW( pszCurrent ) + 1;
            } // while:  more strings in the array
        } // add strings to the list
        LocalFree( psz );
        psz = NULL;

        //
        // Get resource type common read-only properties.
        //
        sc = cpl.ScGetResourceTypeProperties(
                        Pwiz()->Hcluster(),
                        prti->RstrName(),
                        CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error getting properties

        //
        // Find the DLL Name property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        cpl.CbPropList(),
                        CLUSREG_NAME_RESTYPE_DLL_NAME,
                        &psz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        prti->m_strResDLLName = psz;
        LocalFree( psz );
        psz = NULL;

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Check for errors getting properties.
    //
    if ( sc != ERROR_SUCCESS )
    {
        m_nte.SetOperation( sc, IDS_ERROR_GET_RESOURCE_TYPE_PROPERTIES, prti->RstrName() );
    } // if:  error occurred

    return bSuccess;

} //*** CWizardThread::_BGetResourceTypeProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetRequiredDependencies
//
//  Routine Description:
//      Get resource type required dependencies (thread).
//
//  Arguments:
//      prti        [IN OUT] Resource type info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetRequiredDependencies( IN OUT CClusResTypeInfo * prti )
{
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( prti != NULL );
    ASSERT( prti->m_pcrd == NULL );

    DWORD                   sc;
    BOOL                    bSuccess = FALSE;
    DWORD                   cbOutBuf = 512;
    CLUSPROP_BUFFER_HELPER  buf;

    buf.pb = NULL;

    // Loop to avoid goto's
    do
    {
        //
        // Allocate the initial buffer.
        //
        buf.pb = new BYTE[ cbOutBuf ];
        if ( buf.pb == NULL )
        {
            sc = ERROR_NOT_ENOUGH_MEMORY;
            break;
        } // if:  error allocating memory

        //
        // Get required dependencies.
        //
        sc = ClusterResourceTypeControl(
                        Pwiz()->Hcluster(),
                        prti->RstrName(),
                        NULL,
                        CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES,
                        NULL,
                        0,
                        buf.pb,
                        cbOutBuf,
                        &cbOutBuf
                        );
        if ( sc == ERROR_MORE_DATA )
        {
            delete [] buf.pb;
            buf.pb = new BYTE[ cbOutBuf ];
            if ( buf.pb == NULL )
            {
                sc = ERROR_NOT_ENOUGH_MEMORY;
                break;
            } // if:  error allocating memory
            sc = ClusterResourceTypeControl(
                            Pwiz()->Hcluster(),
                            prti->RstrName(),
                            NULL,
                            CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES,
                            NULL,
                            0,
                            buf.pb,
                            cbOutBuf,
                            &cbOutBuf
                            );
        } // if:  buffer too small
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error getting properties

        //
        // Save the required dependencies in the resource type if any exist.
        //
        if ( cbOutBuf > 0 )
        {
            prti->m_pcrd = buf.pRequiredDependencyValue;
            buf.pb = NULL;
        } // if:  resource type has required dependencies

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Check for errors getting properties.
    //
    if ( sc != ERROR_SUCCESS )
    {
        m_nte.SetOperation( sc, IDS_ERROR_GET_RESTYPE_REQUIRED_DEPENDENCIES, prti->RstrName() );
    } // if:  error occurred

    delete [] buf.pb;
    return bSuccess;

} //*** CWizardThread::_BGetRequiredDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BQueryNetwork
//
//  Routine Description:
//      Query for information about a network (thread).
//
//  Arguments:
//      pni         [IN OUT] Network info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BQueryNetwork( IN OUT CClusNetworkInfo * pni )
{
    ASSERT( pni != NULL );

    DWORD           sc = ERROR_SUCCESS;
    BOOL            bSuccess = FALSE;
    CClusPropList   cpl;
    LPWSTR          pwsz = NULL;

    // Loop to avoid goto's
    do
    {
        //
        // Indicate that we've now queried the network.
        //
        pni->BSetQueried();

        //
        // Open the network.
        //
        sc = pni->ScOpen();
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_OPEN_NETWORK, pni->RstrName() );
            break;
        } // if:  error opening the network

        // Loop to avoid goto's
        do
        {
            //
            // Get network common properties.
            //
            sc = cpl.ScGetNetworkProperties( pni->Hnetwork(), CLUSCTL_NETWORK_GET_COMMON_PROPERTIES );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error getting properties

            //
            // Find the Description property.
            //
            sc = ResUtilFindSzProperty(
                            cpl.PbPropList(),
                            cpl.CbPropList(),
                            CLUSREG_NAME_NET_DESC,
                            &pwsz
                            );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error finding the description
            pni->m_strDescription = pwsz;
            LocalFree( pwsz );
            pwsz = NULL;

            //
            // Find the Role property.
            //
            sc = ResUtilFindDwordProperty(
                            cpl.PbPropList(),
                            cpl.CbPropList(),
                            CLUSREG_NAME_NET_ROLE,
                            (DWORD *) &pni->m_nRole
                            );
            ASSERT( sc == ERROR_SUCCESS );

            //
            // Get network common read-only properties.
            //
            sc = cpl.ScGetNetworkProperties( pni->Hnetwork(), CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error getting properties

            //
            // Find the Address property.
            //
            sc = ResUtilFindSzProperty(
                            cpl.PbPropList(),
                            cpl.CbPropList(),
                            CLUSREG_NAME_NET_ADDRESS,
                            &pwsz
                            );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error finding the property
            pni->m_strAddress = pwsz;
            LocalFree( pwsz );
            pwsz = NULL;

            //
            // Find the Address Mask property.
            //
            sc = ResUtilFindSzProperty(
                            cpl.PbPropList(),
                            cpl.CbPropList(),
                            CLUSREG_NAME_NET_ADDRESS_MASK,
                            &pwsz
                            );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error finding the property
            pni->m_strAddressMask = pwsz;
            LocalFree( pwsz );
            pwsz = NULL;

            //
            // Convert the address and address mask to numbers.
            //
            sc = ClRtlTcpipStringToAddress( pni->RstrAddress(), &pni->m_nAddress );
            if ( sc == ERROR_SUCCESS )
            {
                sc = ClRtlTcpipStringToAddress( pni->RstrAddressMask(), &pni->m_nAddressMask );
            } // if:  successfully converted address to number
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error converting address or address mask to a number
        } while ( 0 );

        //
        // Check for errors getting properties.
        //
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_GET_NETWORK_PROPERTIES, pni->RstrName() );
            break;
        } // if:  error getting properties

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Cleanup.
    //
    if ( pwsz != NULL )
    {
        LocalFree( pwsz );
    } // if:  memory still allocated

    return bSuccess;

} //*** CWizardThread::_BQueryNetwork()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BQueryNode
//
//  Routine Description:
//      Query for information about a node (thread).
//
//  Arguments:
//      pni         [IN OUT] Node info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BQueryNode( IN OUT CClusNodeInfo * pni )
{
    ASSERT( pni != NULL );

    DWORD           sc = ERROR_SUCCESS;
    BOOL            bSuccess = FALSE;
    CClusPropList   cpl;
    LPWSTR          pwsz = NULL;

    // Loop to avoid goto's
    do
    {
        //
        // Indicate that we've now queried the node.
        //
        pni->BSetQueried();

        //
        // Open the node.
        //
        sc = pni->ScOpen();
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_OPEN_NODE, pni->RstrName() );
            break;
        } // if:  error opening the node

        // Loop to avoid goto's
        do
        {
            //
            // Get node common properties.
            //
            sc = cpl.ScGetNodeProperties( pni->Hnode(), CLUSCTL_NODE_GET_COMMON_PROPERTIES );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error getting properties

            //
            // Find the Description property.
            //
            sc = ResUtilFindSzProperty(
                            cpl.PbPropList(),
                            cpl.CbPropList(),
                            CLUSREG_NAME_NODE_DESC,
                            &pwsz
                            );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error finding the description
            pni->m_strDescription = pwsz;
            LocalFree( pwsz );
            pwsz = NULL;

        } while ( 0 );

        //
        // Check for errors getting properties.
        //
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_GET_NODE_PROPERTIES, pni->RstrName() );
            break;
        } // if:  error getting properties

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Cleanup.
    //
    if ( pwsz != NULL )
    {
        LocalFree( pwsz );
    } // if:  memory still allocated

    return bSuccess;

} //*** CWizardThread::_BQueryNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BResetGroup
//
//  Routine Description:
//      Reset the group to its original state. (thread)
//      This entails deleting the group if we created it or renaming it
//      if it was an existing group.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BResetGroup( void )
{
    BOOL        bSuccess = FALSE;
    DWORD       sc = ERROR_SUCCESS;
    DWORD       idsError;

    // Loop to avoid goto's.
    do
    {
        //
        // Delete or rename the group if we created or renamed it.
        //
        if ( Pwiz()->BNewGroupCreated() || Pwiz()->BExistingGroupRenamed() )
        {
            ASSERT( Pwiz()->Hcluster() != NULL );

            if ( Pwiz()->BNewGroupCreated() )
            {
                idsError = IDS_ERROR_DELETE_GROUP;
            } // if:  created the group
            else
            {
                idsError = IDS_ERROR_RENAME_GROUP;
            } // else:  renamed the group

            //
            // Open the group.
            //
            if ( Pwiz()->RgiCurrent().Hgroup() == NULL )
            {
                sc = Pwiz()->RgiCurrent().ScOpen();
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperationIfEmpty(
                        sc,
                        idsError,
                        Pwiz()->RgiCurrent().RstrName()
                        );
                    break;
                } // if:  error opening the group
            } // if:  group not open yet

            //
            // Delete or rename the group.
            //
            if ( Pwiz()->BNewGroupCreated() )
            {
                sc = Pwiz()->RgiCurrent().ScDelete();
            } // if:  created the group
            else
            {
                ASSERT( Pwiz()->PgiExistingGroup() != NULL );
                if ( Pwiz()->PgiExistingGroup()->RstrName() != Pwiz()->RgiCurrent().RstrName() )
                {
                    sc = SetClusterGroupName( Pwiz()->RgiCurrent().Hgroup(), Pwiz()->PgiExistingGroup()->RstrName() );
                } // if:  name changed
                if ( sc == ERROR_SUCCESS )
                {
                    bSuccess = _BSetGroupProperties( Pwiz()->PgiExistingGroup(), &Pwiz()->RgiCurrent() );
                    if ( ! bSuccess )
                    {
                        break;
                    } // if:  error setting group properties
                } // if:  cluster group name changed successfully
            } // if:  renamed the group
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperationIfEmpty(
                    sc,
                    idsError,
                    Pwiz()->RgiCurrent().RstrName(),
                    Pwiz()->PgiExistingGroup()->RstrName()
                    );
                break;
            } // if:  error deleting or renaming the group

            //
            // Indicate group was deleted or renamed back.
            //
            Pwiz()->SetNewGroupCreated( FALSE );
            Pwiz()->SetExistingGroupRenamed( FALSE );

        } // else:  group opened successfully

        //
        // If we made it to here, the operation was successful.
        //
        bSuccess = TRUE;

    } while ( 0 );

    return bSuccess;

} //*** CWizardThread::_BResetGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BSetGroupProperties
//
//  Routine Description:
//      Set properties on a group (thread)
//
//  Arguments:
//      pgi         [IN OUT] Group info.
//      pgiPrev     [IN] Previous group info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BSetGroupProperties(
    IN OUT CClusGroupInfo *     pgi,
    IN const CClusGroupInfo *   pgiPrev
    )
{
    ASSERT( pgi != NULL );

    BOOL            bSuccess = FALSE;
    DWORD           sc;
    CClusPropList   props;
    DWORD           cbProps;
    CClusGroupInfo  giDefault( pgi->Pci() );

    // Loop to avoid goto's.
    do
    {
        //
        // If there is no previous group info, point to a default
        // one so that group properties can be written if they
        // have changed.
        //
        if ( pgiPrev == NULL )
        {
            pgiPrev = &giDefault;
        } // if:  no previous group info

        //
        // Add changed properties to the property list.
        //
        props.ScAddProp( CLUSREG_NAME_GRP_DESC, pgi->RstrDescription(), pgiPrev->RstrDescription() );
        props.ScAddProp( CLUSREG_NAME_GRP_FAILOVER_THRESHOLD, pgi->NFailoverThreshold(), pgiPrev->NFailoverThreshold() );
        props.ScAddProp( CLUSREG_NAME_GRP_FAILOVER_PERIOD, pgi->NFailoverPeriod(), pgiPrev->NFailoverPeriod() );
        props.ScAddProp( CLUSREG_NAME_GRP_FAILBACK_TYPE, (DWORD) pgi->CgaftAutoFailbackType(), pgiPrev->CgaftAutoFailbackType() );
        props.ScAddProp( CLUSREG_NAME_GRP_FAILBACK_WIN_START, pgi->NFailbackWindowStart(), pgiPrev->NFailbackWindowStart() );
        props.ScAddProp( CLUSREG_NAME_GRP_FAILBACK_WIN_END, pgi->NFailbackWindowEnd(), pgiPrev->NFailbackWindowEnd() );

        //
        // Send the property list to the cluster.
        //
        if ( props.Cprops() > 0 )
        {
            sc = ClusterGroupControl(
                            pgi->Hgroup(),
                            NULL,   // hNode
                            CLUSCTL_GROUP_SET_COMMON_PROPERTIES,
                            props.PbPropList(),
                            props.CbPropList(),
                            NULL,   // lpOutBuffer
                            0,      // nOutBufferSize
                            &cbProps
                            );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_SET_COMMON_GROUP_PROPS, pgi->RstrName() );
                break;
            } // if:  error setting common group properties
        } // if:  any props were added

        //
        // Set the preferred owners on the group.
        //
        {
            HNODE * phnodes = NULL;

            //
            // Allocate node handle array.
            //
            phnodes = new HNODE[ pgi->PlpniPreferredOwners()->size() ];
            if ( phnodes == NULL )
            {
                m_nte.SetOperation( ERROR_NOT_ENOUGH_MEMORY, IDS_ERROR_SET_PREFERRED_OWNERS, pgi->RstrName() );
                break;
            } // if:  error allocating node handle array

            //
            // Copy the handle of all the nodes in the node list
            // to the handle array.
            //
            CClusNodePtrList::iterator  itCurrent = pgi->PlpniPreferredOwners()->begin();
            CClusNodePtrList::iterator  itLast = pgi->PlpniPreferredOwners()->end();
            CClusNodeInfo *             pni;
            int                         idxHnode;

            for ( idxHnode = 0 ; itCurrent != itLast ; itCurrent++, idxHnode++ )
            {
                pni = *itCurrent;
                phnodes[ idxHnode ] = pni->Hnode();
            } // for:  each node in the list

            //
            // Set the preferred owners.
            //
            sc = SetClusterGroupNodeList( pgi->Hgroup(), idxHnode, phnodes );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_SET_PREFERRED_OWNERS, pgi->RstrName() );
                delete [] phnodes;
                break;
            } // if:  error setting the preferred owners

            delete [] phnodes;
        } // Set the preferred owners on the group

        //
        // If we get here, we must be successful.
        //
        bSuccess = TRUE;

    } while ( 0 );

    return bSuccess;

} //*** CWizardThread::_BSetGroupProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCreateResource
//
//  Routine Description:
//      Create a resource and set common properties (thread)
//      Caller is responsible for closing the resource handle.
//
//  Arguments:
//      rri         [IN] Resource info.
//      hGroup      [IN] Handle to group to create resource in.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCreateResource(
    IN CClusResInfo &   rri,
    IN HGROUP           hGroup
    )
{
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( hGroup != NULL );
    ASSERT( rri.RstrName().GetLength() > 0 );
    ASSERT( rri.Prti() != NULL );
    ASSERT( rri.Prti()->RstrName().GetLength() > 0 );
    ASSERT( ! rri.BCreated() );
    ASSERT( rri.Hresource() == NULL );

    BOOL    bSuccess = FALSE;
    DWORD   sc = ERROR_SUCCESS;
    DWORD   dwFlags;

    //
    // Create the resource.
    //
    if ( rri.BSeparateMonitor() )
    {
        dwFlags = CLUSTER_RESOURCE_SEPARATE_MONITOR;
    } // if:  bring resource online in a separate resource monitor
    else
    {
        dwFlags = 0;
    } // if:  bring resource online in the common resource monitor

    do  // do-while: dummy loop to avoid gotos
    {
        CClusNodePtrList *  plpniPossibleOwnersList = &rri.m_lpniPossibleOwners;

        sc = rri.ScCreate( hGroup, dwFlags );
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_CREATE_RESOURCE, rri.RstrName() );
            break;
        } // if:  error creating resource

        //
        // Indicate we created the resource.
        //
        rri.BSetCreated();

        //
        // Get the possible owner list of the newly created resource.
        //
        
        // First clear the list.
        plpniPossibleOwnersList->erase( plpniPossibleOwnersList->begin(), plpniPossibleOwnersList->end() );

        // Then get it.
        bSuccess = _BGetPossibleOwners( &rri );
        if ( bSuccess == FALSE )
        {
            break;
        }

        //
        // Set the resource properties, dependencies and owner list.
        // There is no need to get the dependency list beforehand because it is empty.
        //
        bSuccess = _BSetResourceAttributes( rri, NULL, plpniPossibleOwnersList );
    }
    while ( FALSE ); // do-while: dummy loop to avoid gotos

    //
    // If an error occurred, delete the resource.
    //
    if ( bSuccess == FALSE )
    {
        if ( rri.BCreated() && (rri.Hresource() != NULL) )
        {
            rri.ScDelete();
        } // if:  created resource and opened successfully
    } // if:  error creating the resource

    return bSuccess;

} //*** CWizardThread::_BCreateResource()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BSetResourceAttributes
//
//  Routine Description:
//      Set the properties, the dependency and possible owner list of a 
//      resource. Assumes that the resource has already been created 
//      successfully.
//
//  Arguments:
//      rri                     [IN] Resource info.
//      plpriOldDependencies    [IN] Pointer to the old resource dependency list
//      plpniOldPossibleOwners  [IN] Pointer to the old list of possible owner nodes
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BSetResourceAttributes(
    IN CClusResInfo &       rri,
    IN CClusResPtrList *    plpriOldDependencies,   // = NULL
    IN CClusNodePtrList *   plpniOldPossibleOwners  // = NULL
    )
{
    // Make sure that the resource is created and is valid.
    ASSERT( rri.BCreated() && (rri.Hresource() != NULL) );

    BOOL bSuccess = FALSE;
    DWORD   sc = ERROR_SUCCESS;

    // Loop to avoid goto's.
    do
    {
        //
        // Set common properties on the resource.
        //
        {
            CClusPropList   props;
            DWORD           cbProps;

            props.ScAddProp( CLUSREG_NAME_RES_DESC, rri.RstrDescription() );
            props.ScAddProp( CLUSREG_NAME_RES_SEPARATE_MONITOR, (DWORD) rri.BSeparateMonitor(), FALSE );
            props.ScAddProp( CLUSREG_NAME_RES_LOOKS_ALIVE, rri.NLooksAlive(), CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE );
            props.ScAddProp( CLUSREG_NAME_RES_IS_ALIVE, rri.NIsAlive(), CLUSTER_RESOURCE_DEFAULT_IS_ALIVE );
            props.ScAddProp( CLUSREG_NAME_RES_RESTART_ACTION, (DWORD) rri.CrraRestartAction(), CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION );
            props.ScAddProp( CLUSREG_NAME_RES_RESTART_THRESHOLD, rri.NRestartThreshold(), CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD );
            props.ScAddProp( CLUSREG_NAME_RES_RESTART_PERIOD, rri.NRestartPeriod(), CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD );
            props.ScAddProp( CLUSREG_NAME_RES_PENDING_TIMEOUT, rri.NPendingTimeout(), CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT );
            if ( props.Cprops() > 0 )
            {
                sc = ClusterResourceControl(
                                rri.Hresource(),
                                NULL,   // hNode
                                CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES,
                                props.PbPropList(),
                                props.CbPropList(),
                                NULL,   // lpOutBuffer
                                0,      // nOutBufferSize
                                &cbProps
                                );
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_SET_COMMON_RES_PROPS, rri.RstrName() );
                    break;
                } // if:  error setting common resource properties
            } // if:  any props were added

        } // Set common properties on the resource


        sc = _BSetResourceDependencies( rri, plpriOldDependencies );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        }

        sc = _BSetPossibleOwners( rri, plpniOldPossibleOwners );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        }

        bSuccess = ( sc == ERROR_SUCCESS );
    }
    while ( FALSE ); // Loop to avoid goto's.

    return bSuccess;

}  //*** CWizardThread::_BSetResourceAttributes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BSetResourceDependencies
//
//  Routine Description:
//      Set the dependency list of a resource. Assumes that the resource has 
//      already been created successfully.
//
//  Arguments:
//      rri                     [IN] Resource info.
//      plpriOldDependencies    [IN] Pointer to the old resource dependency list
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CWizardThread::_BSetResourceDependencies(
    IN CClusResInfo &       rri,
    IN CClusResPtrList *    plpriOldDependencies    // = NULL
    )
{
    DWORD   sc = ERROR_SUCCESS;
    CClusResPtrList *           plpriDependencies   = &rri.m_lpriDependencies;

    //
    // If the old list is the same as the new list, do nothing.
    // This is a dummy while to do this check and to avoid gotos.
    //
    while ( plpriDependencies != plpriOldDependencies )
    {

        CClusResInfo *              priDep;
        CClusResPtrList::iterator   itNewDepCurrent;
        CClusResPtrList::iterator   itNewDepLast;
        CClusResPtrList::iterator   itOldDepCurrent;
        CClusResPtrList::iterator   itOldDepLast;

        //
        // Commit only the changes in the dependency list.
        // Delete those dependencies that are in old list but not in the new list.
        // Add those dependencies that are in new list but not in the old list.
        //

        // If the pointer to the old list of dependencies is NULL,
        // point it to a temporary dummy list to make code to follow simpler.
        //
        CClusResPtrList             lpriTempList;
        if ( plpriOldDependencies == NULL )
        {
            plpriOldDependencies = &lpriTempList;
        }
        else
        {
            plpriOldDependencies->sort();
        }

        //
        // The two lists need to be sorted. We do not care what order they are
        // sorted in as long as they are in a consistent order.
        // Note: Sorting invadidates the iterators
        //
        plpriDependencies->sort();

        itNewDepCurrent     = plpriDependencies->begin();
        itNewDepLast        = plpriDependencies->end();
        itOldDepCurrent     = plpriOldDependencies->begin();
        itOldDepLast        = plpriOldDependencies->end();

        while ( ( itNewDepCurrent != itNewDepLast ) &&
                ( itOldDepCurrent != itOldDepLast ) 
              )
        {
            BOOL                        bDeleteDependency;
            DWORD                       dwErrorCode;

            //
            // If the current elements in both the lists are equal, this element
            // is is both the lists. Do nothing.
            if ( *itNewDepCurrent == *itOldDepCurrent )
            {
                ++itNewDepCurrent;
                ++itOldDepCurrent;
                continue;
            }

            if ( *itNewDepCurrent > *itOldDepCurrent )
            {
                //
                // The current resource has been deleted from the old list.
                //
                priDep = *itOldDepCurrent;
                bDeleteDependency = TRUE;
                ++itOldDepCurrent;
            } // if:  the new dependency pointer is greater than the old pointer
            else
            {
                //
                // The current resource has been added to the new list.
                //
                priDep = *itNewDepCurrent;
                bDeleteDependency = FALSE;
                ++itNewDepCurrent;
            } // if:  the new dependency pointer is less than the old pointer

            //
            // Open the resource.
            //
            if ( priDep->Hresource() == NULL )
            {
                sc = priDep->ScOpen();
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_OPEN_RESOURCE, priDep->RstrName() );
                    break;
                } // if:  error opening the resource
            } // if:  resource not open yet


            if ( bDeleteDependency == FALSE )
            {
                sc = AddClusterResourceDependency( rri.Hresource(), priDep->Hresource() );
                dwErrorCode = IDS_ERROR_ADD_DEPENDENCY;
            }
            else
            {
                sc = RemoveClusterResourceDependency( rri.Hresource(), priDep->Hresource() );
                dwErrorCode = IDS_ERROR_REMOVE_DEPENDENCY;
            }

            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, dwErrorCode, rri.RstrName(), priDep->RstrName() );
                break;
            } // if:  error setting dependency.
        } // while:  we have not reached the end of either list.

        if ( sc != ERROR_SUCCESS )
        {
            break;
        }

        //
        // If there are any more resources in the old list, remove them
        // all from the dependency list.
        //
        while ( itOldDepCurrent != itOldDepLast )
        {
            priDep = *itOldDepCurrent;
            ++itOldDepCurrent;
            //
            // Open the resource.
            //
            if ( priDep->Hresource() == NULL )
            {
                sc = priDep->ScOpen();
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_OPEN_RESOURCE, priDep->RstrName() );
                    break;
                } // if:  error opening the resource
            } // if:  resource not open yet

            sc = RemoveClusterResourceDependency( rri.Hresource(), priDep->Hresource() );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_REMOVE_DEPENDENCY, rri.RstrName(), priDep->RstrName() );
                break;
            } // if:  error setting dependency.
        } // while:  we are not at the end of the old list

        if ( sc != ERROR_SUCCESS )
        {
            break;
        }

        //
        // If there are any more resources in the new list, add them
        // all to the dependency list.
        //
        while ( itNewDepCurrent != itNewDepLast )
        {
            priDep = *itNewDepCurrent;
            ++itNewDepCurrent;
            //
            // Open the resource.
            //
            if ( priDep->Hresource() == NULL )
            {
                sc = priDep->ScOpen();
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_OPEN_RESOURCE, priDep->RstrName() );
                    break;
                } // if:  error opening the resource
            } // if:  resource not open yet

            sc = AddClusterResourceDependency( rri.Hresource(), priDep->Hresource() );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_ADD_DEPENDENCY, rri.RstrName(), priDep->RstrName() );
                break;
            } // if:  error setting dependency.
        } // while:  we are not at the end of the new list

        break;
    } // while: dummy while to avoid gotos

    return sc;

} //*** CWizardThread::_BSetResourceDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BSetPossibleOwners
//
//  Routine Description:
//      Set the possible owner list of a resource. Assumes that the resource has 
//      already been created successfully.
//
//  Arguments:
//      rri                     [IN] Resource info.
//      plpniOldPossibleOwners  [IN] Pointer to the old list of possible owner nodes
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CWizardThread::_BSetPossibleOwners(
    IN CClusResInfo &       rri,
    IN CClusNodePtrList *   plpniOldPossibleOwners  // = NULL
    )
{
    DWORD   sc = ERROR_SUCCESS;
    CClusNodePtrList *          plpniNewPossibleOwners  = &rri.m_lpniPossibleOwners;

    //
    // If the old list is the same as the new list, do nothing.
    // This is a dummy while to do this check and to avoid gotos.
    //
    while ( plpniNewPossibleOwners != plpniOldPossibleOwners )
    {
        CClusNodeInfo *             pniOwnerNodeInfo;
        CClusNodePtrList::iterator  itNewOwnersCurrent;
        CClusNodePtrList::iterator  itNewOwnersLast;
        CClusNodePtrList::iterator  itOldOwnersCurrent;
        CClusNodePtrList::iterator  itOldOwnersLast;

        //
        // Commit only the changes in the owners list.
        // Delete those owners that are in old list but not in the new list.
        // Add those owners that are in new list but not in the old list.
        //

        // If the pointer to the old list of owners is NULL,
        // point it to a temporary dummy list to make code to follow simpler.
        //
        CClusNodePtrList            lpniTempList;
        if ( plpniOldPossibleOwners == NULL )
        {
            plpniOldPossibleOwners = &lpniTempList;
        }
        else
        {
            plpniOldPossibleOwners->sort();
        }

        //
        // The two lists need to be sorted. We do not care what order they are
        // sorted in as long as they are in a consistent order.
        // Note: Sorting invadidates the iterators
        //
        plpniNewPossibleOwners->sort();

        itNewOwnersCurrent  = plpniNewPossibleOwners->begin();
        itNewOwnersLast     = plpniNewPossibleOwners->end();
        itOldOwnersCurrent  = plpniOldPossibleOwners->begin();
        itOldOwnersLast     = plpniOldPossibleOwners->end();

        while ( ( itNewOwnersCurrent != itNewOwnersLast ) &&
                ( itOldOwnersCurrent != itOldOwnersLast ) 
              )
        {
            BOOL                        bDeletePossibleOwner;
            DWORD                       dwErrorCode;

            //
            // If the current elements in both the lists are equal, this element
            // is is both the lists. Do nothing.
            if ( *itNewOwnersCurrent == *itOldOwnersCurrent )
            {
                ++itNewOwnersCurrent;
                ++itOldOwnersCurrent;
                continue;
            }

            if ( *itNewOwnersCurrent > *itOldOwnersCurrent )
            {
                //
                // The current resource has been deleted from the old list.
                //
                pniOwnerNodeInfo = *itOldOwnersCurrent;
                bDeletePossibleOwner = TRUE;
                ++itOldOwnersCurrent;
            } // if:  the new possible owner pointer is greater than the old pointer
            else
            {
                //
                // The current resource has been added to the new list.
                //
                pniOwnerNodeInfo = *itNewOwnersCurrent;
                bDeletePossibleOwner = FALSE;
                ++itNewOwnersCurrent;
            } // if:  the new possible owner pointer is less than the old pointer

            if ( bDeletePossibleOwner == FALSE )
            {
                sc = AddClusterResourceNode( rri.Hresource(), pniOwnerNodeInfo->Hnode() );
                dwErrorCode = IDS_ERROR_ADD_RESOURCE_OWNER;
            }
            else
            {
                sc = RemoveClusterResourceNode( rri.Hresource(), pniOwnerNodeInfo->Hnode() );
                dwErrorCode = IDS_ERROR_REMOVE_RESOURCE_OWNER;
            }

            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, dwErrorCode, pniOwnerNodeInfo->RstrName(), rri.RstrName() );
                break;
            } // if:  error setting dependency.
        } // while:  we have not reached the end of either list.

        if ( sc != ERROR_SUCCESS )
        {
            break;
        }

        //
        // If there are any more nodes in the old list, remove them
        // all from the possible owners list.
        //
        while ( itOldOwnersCurrent != itOldOwnersLast )
        {
            pniOwnerNodeInfo = *itOldOwnersCurrent;
            ++itOldOwnersCurrent;

            sc = RemoveClusterResourceNode( rri.Hresource(), pniOwnerNodeInfo->Hnode() );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_REMOVE_RESOURCE_OWNER, pniOwnerNodeInfo->RstrName(), rri.RstrName() );
                break;
            } // if:  error setting dependency.
        } // while:  we are not at the end of the old list

        if ( sc != ERROR_SUCCESS )
        {
            break;
        }

        //
        // If there are any more nodes in the new list, add them
        // all to the possible owners list.
        //
        while ( itNewOwnersCurrent != itNewOwnersLast )
        {
            pniOwnerNodeInfo = *itNewOwnersCurrent;
            ++itNewOwnersCurrent;

            sc = AddClusterResourceNode( rri.Hresource(), pniOwnerNodeInfo->Hnode() );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_ADD_RESOURCE_OWNER, pniOwnerNodeInfo->RstrName(), rri.RstrName() );
                break;
            } // if:  error setting dependency.
        } // while:  we are not at the end of the old list

        break;
    } // while: dummy while to avoid gotos

    return sc;
} //*** CWizardThread::_BSetPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BDeleteResource
//
//  Routine Description:
//      Delete a resource.
//
//  Arguments:
//      rri         [IN] Resource info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BDeleteResource(
    IN CClusResInfo & rri
    )
{
    BOOL        bSuccess = FALSE;
    DWORD       sc = ERROR_SUCCESS;

    if ( ! rri.BCreated() )
    {
        return TRUE;
    } // if:  resource not created

    // Loop to avoid goto's.
    do
    {
        //
        // Open the resource.
        //
        if ( rri.Hresource() == NULL )
        {
            sc = rri.ScOpen();
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error opening the resource
        } // if:  resource not open yet

        //
        // Delete the resource.
        //
        sc = rri.ScDelete();
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error deleting the resource

        //
        // If we made it to here, the operation was successful.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Handle errors.
    //
    if ( sc != ERROR_SUCCESS )
    {
        m_nte.SetOperationIfEmpty(
            sc,
            IDS_ERROR_DELETE_RESOURCE,
            rri.RstrName()
            );
    } // if:  error occurred

    return bSuccess;

} //*** CWizardThread::_BDeleteResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BReadAdminExtensions
//
//  Routine Description:
//      Read admin extensions directly from the cluster database.
//
//  Arguments:
//      pszKey      [IN] Key from which to read extensions.
//      rlstr       [OUT] List in which to return extension CLSIDs.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BReadAdminExtensions(
    IN LPCWSTR                  pszKey,
    OUT std::list< CString > &  rlstr
    )
{
    ASSERT( Pwiz()->Hcluster() != NULL );

    BOOL    bSuccess = FALSE;
    HKEY    hkeyCluster = NULL;
    HKEY    hkeySubKey = NULL;
    HKEY    hkey;
    DWORD   sc;
    DWORD   dwType;
    LPWSTR  pszData = NULL;
    DWORD   cbData;

    // Loop to avoid goto's.
    do
    {
        //
        // Get the cluster key.
        //
        hkeyCluster = GetClusterKey( Pwiz()->Hcluster(), KEY_READ );
        if ( hkeyCluster == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_GET_CLUSTER_KEY );
            break;
        } // if:  error getting the cluster key

        //
        // Open the subkey if specified.
        //
        if ( pszKey != NULL )
        {
            sc = ClusterRegOpenKey( hkeyCluster, pszKey, KEY_READ, &hkeySubKey );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_OPEN_CLUSTER_KEY, pszKey );
                break;
            } // if:  error opening the subkey
            hkey = hkeySubKey;
        } // if:  subkey specified
        else
        {
            hkey = hkeyCluster;
        } // else:  no subkey specified

        //
        // Get the length of the AdminExtensions value.
        //
        cbData = 0;
        sc = ClusterRegQueryValue( hkey, CLUSREG_NAME_ADMIN_EXT, &dwType, NULL, &cbData );
        if ( sc != ERROR_SUCCESS )
        {
            if ( sc == ERROR_FILE_NOT_FOUND )
            {
                bSuccess = TRUE;
            } // if:  value didn't exist
            else
            {
                m_nte.SetOperation( sc, IDS_ERROR_QUERY_VALUE, CLUSREG_NAME_ADMIN_EXT );
            } // else:  other error occurred
            break;
        } // if:  error reading extensions value

        //
        // Allocate a buffer for the value data.
        //
        pszData = new WCHAR[ cbData / sizeof( WCHAR ) ];
        if ( pszData == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_QUERY_VALUE, CLUSREG_NAME_ADMIN_EXT );
            break;
        } // if: error allocating the buffer

        //
        // Read the AdminExtensions value.
        //
        sc = ClusterRegQueryValue(
                        hkey,
                        CLUSREG_NAME_ADMIN_EXT,
                        &dwType,
                        reinterpret_cast< LPBYTE >( pszData ),
                        &cbData
                        );
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_QUERY_VALUE, CLUSREG_NAME_ADMIN_EXT );
            break;
        } // if:  error reading extensions value

        //
        // Add each extension to the list.
        //
        LPWSTR pszEntry = pszData;
        while ( *pszEntry != L'\0' )
        {
            rlstr.insert( rlstr.end(), pszEntry );
            pszEntry += lstrlenW( pszEntry ) + 1;
        } // while:  more entries in the list

        bSuccess = TRUE;
    } while ( 0 );

    //
    // Cleanup.
    //
    if ( hkeyCluster != NULL )
    {
        ClusterRegCloseKey( hkeyCluster );
    } // if:  cluster key is open
    if ( hkeySubKey != NULL )
    {
        ClusterRegCloseKey( hkeySubKey );
    } // if:  sub key is open
    if ( pszData != NULL )
    {
        delete [] pszData;
    } // if:  data was allocated

    return bSuccess;

} //*** CWizardThread::_BReadAdminExtensions()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\types\idl\makefile.inc ===
CopyTLB : CLADMWIZ_TLB

CLADMWIZ_TLB : $(O)\ClAdmWiz.tlb
    -mkdir ..\..\src\$(O)
    copy $** ..\..\src\$(O)\ClAdmWiz.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\workthreads.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		WorkThreadS.cpp
//
//	Abstract:
//		Stub for implementation of the CWorkerThread class.
//
//	Author:
//		David Potter (davidp)	December 16, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "WorkThrd.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\aclbase.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  Module Name:
//      AclBase.cpp
//
//  Description:
//      Implementation of the ISecurityInformation interface.  This interface
//      is the new common security UI in NT 5.0.
//
//  Author:
//      Galen Barbee    (galenb)    February 6, 1998
//          From \nt\private\admin\snapin\filemgmt\permpage.cpp
//          by JonN
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AclBase.h"
#include "AclUtils.h"
#include "resource.h"
#include <DsGetDC.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include "CluAdmx.h"

/////////////////////////////////////////////////////////////////////////////
// CSecurityInformation
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::CSecurityInformation
//
//  Routine Description:
//      ctor
//
//  Arguments:
//      none.
//
//  Return Value:
//      none.
//
//--
/////////////////////////////////////////////////////////////////////////////
CSecurityInformation::CSecurityInformation(
    void
    ) : m_pShareMap( NULL ), m_dwFlags( 0 ), m_nDefAccess( 0 ), m_psiAccess( NULL ), m_pObjectPicker( NULL ), m_cRef( 1 )
{
    m_nLocalSIDErrorMessageID = 0;

}  //*** CSecurityInformation::CSecurityInformation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::~CSecurityInformation
//
//  Routine Description:
//      dtor
//
//  Arguments:
//      none.
//
//  Return Value:
//      none.
//
//--
/////////////////////////////////////////////////////////////////////////////
CSecurityInformation::~CSecurityInformation(
    void
    )
{
    if ( m_pObjectPicker != NULL )
    {
        m_pObjectPicker->Release();
        m_pObjectPicker = NULL;
    } // if:

}  //*** CSecurityInformation::CSecurityInformation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::MapGeneric
//
//  Routine Description:
//      Maps specific rights to generic rights
//
//  Arguments:
//      pguidObjectType [IN]
//      pAceFlags       [IN]
//      pMask           [OUT]
//
//  Return Value:
//      S_OK
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSecurityInformation::MapGeneric(
    IN  const GUID *,   //pguidObjectType,
    IN  UCHAR *,        //pAceFlags,
    OUT ACCESS_MASK *pMask
   )
{
    ASSERT( pMask != NULL );
    ASSERT( m_pShareMap != NULL );
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    ::MapGenericMask( pMask, m_pShareMap );

    return S_OK;

}  //*** CSecurityInformation::MapGeneric()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::GetInheritTypes
//
//  Routine Description:
//
//
//  Arguments:
//      None.
//
//  Return Value:
//      E_NOTIMPL
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSecurityInformation::GetInheritTypes(
    PSI_INHERIT_TYPE    *,  //ppInheritTypes,
    ULONG               *   //pcInheritTypes
    )
{
    ASSERT( FALSE );
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    return E_NOTIMPL;

}  //*** CSecurityInformation::GetInheritTypes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::PropertySheetPageCallback
//
//  Routine Description:
//      This method is called by the ACL editor when something interesting
//      happens.
//
//  Arguments:
//      hwnd    [IN]    ACL editor window (currently NULL)
//      uMsg    [IN]    reason for call back
//      uPage   [IN]    kind of page we are dealing with
//
//  Return Value:
//      S_OK.   Want to keep everything movin' along
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSecurityInformation::PropertySheetPageCallback(
    IN  HWND            hwnd,
    IN  UINT            uMsg,
    IN  SI_PAGE_TYPE    uPage
    )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    return S_OK;

}  //*** CSecurityInformation::PropertySheetPageCallback()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::GetObjectInformation
//
//  Routine Description:
//
//
//  Arguments:
//    pObjectInfo   [IN OUT]
//
//  Return Value:
//      S_OK.   Want to keep everything movin' along
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSecurityInformation::GetObjectInformation(
    IN OUT PSI_OBJECT_INFO pObjectInfo
    )
{
    ASSERT( pObjectInfo != NULL && !IsBadWritePtr( pObjectInfo, sizeof( *pObjectInfo ) ) );
    ASSERT( !m_strServer.IsEmpty() );
    ASSERT( m_dwFlags != 0 );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    pObjectInfo->dwFlags = m_dwFlags;                   // SI_EDIT_PERMS | SI_NO_ACL_PROTECT;
    pObjectInfo->hInstance = AfxGetInstanceHandle();
    pObjectInfo->pszServerName = (LPTSTR)(LPCTSTR) m_strServer;
//  pObjectInfo->pszObjectName =
/*
    pObjectInfo->dwUgopServer =     UGOP_BUILTIN_GROUPS
                                //| UGOP_USERS
                                //| UGOP_COMPUTERS
                                //| UGOP_WELL_KNOWN_PRINCIPALS_USERS
                                //| UGOP_GLOBAL_GROUPS
                                //| UGOP_USER_WORLD
                                //| UGOP_USER_AUTHENTICATED_USER
                                //| UGOP_USER_ANONYMOUS
                                //| UGOP_USER_DIALUP
                                //| UGOP_USER_NETWORK
                                //| UGOP_USER_BATCH
                                //| UGOP_USER_INTERACTIVE
                                  | UGOP_USER_SERVICE
                                  | UGOP_USER_SYSTEM
                                  | UGOP_LOCAL_GROUPS
                                //| UGOP_UNIVERSAL_GROUPS
                                //| UGOP_UNIVERSAL_GROUPS_SE
                                //| UGOP_ACCOUNT_GROUPS
                                //| UGOP_ACCOUNT_GROUPS_SE
                                //| UGOP_RESOURCE_GROUPS
                                //| UGOP_RESOURCE_GROUPS_SE
                                ;

    pObjectInfo->dwUgopOther  = ( NT5_UGOP_FLAGS | NT4_UGOP_FLAGS ) &~ UGOP_COMPUTERS;
*/
    return S_OK;

}  //*** CSecurityInformation::GetObjectInformation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::SetSecurity
//
//  Routine Description:
//      ISecurityInformation is giving back the edited security descriptor
//      and we need to validate it.  A valid SD is one that doesn't contain
//      any local SIDs.
//
//  Arguments:
//      SecurityInformation [IN]
//      pSecurityDescriptor [IN OUT]
//
//  Return Value:
//      E_FAIL for error and S_OK for success and S_FALSE for SD no good.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSecurityInformation::SetSecurity(
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    ASSERT( m_nLocalSIDErrorMessageID != 0 );

    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    HRESULT hr = S_OK;
    BOOL    bFound = FALSE;

    hr = HrLocalAccountsInSD( pSecurityDescriptor, &bFound );
    if ( SUCCEEDED( hr ) )
    {
        if ( bFound )
        {
            CString strMsg;

            strMsg.LoadString( m_nLocalSIDErrorMessageID );
            AfxMessageBox( strMsg, MB_OK | MB_ICONSTOP );

            hr = S_FALSE;   // if there are local accounts then return S_FALSE to keep AclUi alive.
        }
    }
    else
    {
        CString strMsg;
        CString strMsgIdFmt;
        CString strMsgId;
        CString strErrorMsg;

        strMsg.LoadString( IDS_ERROR_VALIDATING_CLUSTER_SECURITY_DESCRIPTOR );

        FormatError( strErrorMsg, hr );

        strMsgIdFmt.LoadString( IDS_ERROR_MSG_ID );
        strMsgId.Format( strMsgIdFmt, hr, hr);

        strMsg.Format( _T("%s\n\n%s%s"), strMsg, strErrorMsg, strMsgId );

        AfxMessageBox( strMsg );
        hr = S_FALSE;   // return S_FALSE to keep AclUi alive.
    }

    return hr;

}  //*** CSecurityInformation::SetSecurity()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::GetAccessRights
//
//  Routine Description:
//      Return the access rights that you want the user to be able to set.
//
//  Arguments:
//      pguidObjectType [IN]
//      dwFlags         [IN]
//      ppAccess        [OUT]
//      pcAccesses      [OUT]
//      piDefaultAccess [OUT]
//
//  Return Value:
//      S_OK.   Want to keep everything movin' along
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSecurityInformation::GetAccessRights(
    IN  const GUID *    pguidObjectType,
    IN  DWORD           dwFlags,
    OUT PSI_ACCESS *    ppAccess,
    OUT ULONG *         pcAccesses,
    OUT ULONG *         piDefaultAccess
    )
{
    ASSERT( ppAccess != NULL );
    ASSERT( pcAccesses != NULL );
    ASSERT( piDefaultAccess != NULL );
    ASSERT( m_psiAccess != NULL );
    ASSERT( m_nAccessElems > 0 );
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    *ppAccess = m_psiAccess;
    *pcAccesses = m_nAccessElems;
    *piDefaultAccess = m_nDefAccess;

    return S_OK;

}  //*** CSecurityInformation::GetAccessRights()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::Initialize
//
//  Routine Description:
//      Initialize.
//
//  Arguments:
//      pInitInfo   [IN]    - Info to use for initialization.
//
//  Return Value:
//      S_OK if successful, or HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSecurityInformation::Initialize( IN PDSOP_INIT_INFO pInitInfo )
{
    HRESULT hr = S_OK;
    DSOP_INIT_INFO InitInfo;
    PDSOP_SCOPE_INIT_INFO pDSOPScopes = NULL;


    if ( m_pObjectPicker == NULL )
    {
        hr = CoCreateInstance( CLSID_DsObjectPicker,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IDsObjectPicker,
                               (LPVOID *) &m_pObjectPicker
                               );

    }

    if ( SUCCEEDED( hr ) )
    {
        //
        // Make a local copy of the InitInfo so we can modify it safely
        //
        CopyMemory( &InitInfo, pInitInfo, min( pInitInfo->cbSize, sizeof( InitInfo ) ) );

        //
        // Make a local copy of g_aDSOPScopes so we can modify it safely.
        // Note also that m_pObjectPicker->Initialize returns HRESULTs
        // in this buffer.
        //
        pDSOPScopes = (PDSOP_SCOPE_INIT_INFO) ::LocalAlloc( LPTR, sizeof( g_aDSOPScopes ) );
        if (pDSOPScopes != NULL )
        {
            CopyMemory( pDSOPScopes, g_aDSOPScopes, sizeof( g_aDSOPScopes ) );

            //
            // Override the ACLUI default scopes, but don't touch
            // the other stuff.
            //
            // pDSOPScopes->pwzDcName = m_strServer;
            InitInfo.cDsScopeInfos = ARRAYSIZE( g_aDSOPScopes );
            InitInfo.aDsScopeInfos = pDSOPScopes;
            InitInfo.pwzTargetComputer = m_strServer;

            hr = m_pObjectPicker->Initialize( &InitInfo );

            ::LocalFree( pDSOPScopes );
        }
        else
        {
            hr = HRESULT_FROM_WIN32( ::GetLastError() );
        } // else:
    }

    return hr;

} //*** CSecurityInformation::Initialize()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::InvokeDialog
//
//  Routine Description:
//      Forward the InvokeDialog call into the contained object.
//
//  Arguments:
//      hwndParent      [IN]
//      ppdoSelection   [IN]
//
//  Return Value:
//      E_POINTER if m_pObjectPicker is NULL, or the return from
//      m_pObjectPicker->InvokeDialog().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSecurityInformation::InvokeDialog(
    IN HWND             hwndParent,
    IN IDataObject **   ppdoSelection
    )
{
    HRESULT hr = E_POINTER;

    if ( m_pObjectPicker != NULL )
    {
        hr = m_pObjectPicker->InvokeDialog( hwndParent, ppdoSelection );
    } // if:

    return hr;

} //*** CSecurityInformation::InvokeDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::HrLocalAccountsInSD
//
//  Routine Description:
//  Determines if any ACEs for local accounts are in DACL stored in
//  Security Descriptor (pSD) after the ACL editor has been called
//
//  Arguments:
//      pSD     [IN] - Security Descriptor to be checked.
//      pbFound [OUT] - catches the "local account" found flag.
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 error.
//
//  NB:
//
//      I took this code verbatim from EditAcl.cpp and it really needs some
//      clean up and style upgrades!
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CSecurityInformation::HrLocalAccountsInSD(
    PSECURITY_DESCRIPTOR    pSD,
    PBOOL                   pbFound
    )
{
    ASSERT( !m_strNode.IsEmpty() );

    HRESULT hr = E_POINTER;

    if ( pbFound != NULL )
    {
        BOOL                        bLocalAccountInAcl  = FALSE;
        DWORD                       dwError = NO_ERROR;
        PSID                        pAdminSid = NULL;
        SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;

        if ( ::AllocateAndInitializeSid( &siaNtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &pAdminSid ) )
        {
            PSID    pSystemSid = NULL;

            if ( ::AllocateAndInitializeSid( &siaNtAuthority, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pSystemSid ) )
            {
                PSID    pServiceSid = NULL;

                if ( ::AllocateAndInitializeSid( &siaNtAuthority, 1, SECURITY_SERVICE_RID, 0, 0, 0, 0, 0, 0, 0, &pServiceSid ) )
                {
                    if ( ::IsValidSecurityDescriptor( pSD ) )
                    {
                         PACL    paclDACL = NULL;
                         BOOL    bHasDACL = FALSE;
                         BOOL    bDaclDefaulted = FALSE;

                         if ( ::GetSecurityDescriptorDacl( pSD, (LPBOOL) &bHasDACL, (PACL *) &paclDACL, (LPBOOL) &bDaclDefaulted ) )
                         {
                              if ( ::IsValidAcl( paclDACL ) )
                              {
                                   ACL_SIZE_INFORMATION    asiAclSize;
                                   DWORD                   dwBufLength;

                                   dwBufLength = sizeof( asiAclSize );

                                   if ( ::GetAclInformation( paclDACL, (LPVOID) &asiAclSize, (DWORD) dwBufLength, (ACL_INFORMATION_CLASS) AclSizeInformation ) )
                                   {
                                        PDOMAIN_CONTROLLER_INFO pdci = NULL;
                                        GUID                    guid;

                                        dwError = ::DsGetDcName( NULL, NULL, &guid, NULL, 0, &pdci );
                                        if ( dwError == ERROR_SUCCESS )
                                        {
                                             ACCESS_ALLOWED_ACE *    paaAllowedAce;
                                             DWORD                   dwACL_Index = 0L;
                                             WCHAR                   szUser [256];
                                             WCHAR                   szDomain [256];
                                             DWORD                   cchUser = sizeof( szUser ) / sizeof( szUser[0] );
                                             DWORD                   cchDomain = sizeof( szDomain ) / sizeof( szDomain [0] );
                                             SID_NAME_USE            snu;
                                             PSID                    psid = NULL;

                                             //
                                             // Search the ACL for local account ACEs
                                             //
                                             for ( dwACL_Index = 0; dwACL_Index < asiAclSize.AceCount; dwACL_Index++ )
                                             {
                                                  if ( ::GetAce( paclDACL, dwACL_Index, (LPVOID *) &paaAllowedAce ) )
                                                  {
                                                       //
                                                       // Get SID from ACE
                                                       //
                                                       psid = &paaAllowedAce->SidStart;

                                                       if ( ::EqualSid( psid, pAdminSid ) )
                                                       {
                                                            continue;                       // allowed
                                                       } // if: is this the local admin SID?
                                                       else if ( ::EqualSid( psid, pSystemSid ) )
                                                       {
                                                            continue;                       // allowed
                                                       } // else if: is this the local system SID?
                                                       else if ( ::EqualSid( psid, pServiceSid ) )
                                                       {
                                                            continue;                       // allowed
                                                       } // else if: is this the service SID?
                                                       else
                                                       {
                                                            if ( ::LookupAccountSidW( pdci->DomainControllerName, psid, szUser, &cchUser, szDomain, &cchDomain, &snu ) )
                                                            {
                                                                 if ( ( ::lstrcmpiW( szDomain, m_strNode ) == 0 ) && ( snu != SidTypeDomain ) )
                                                                 {
                                                                      bLocalAccountInAcl = TRUE;
                                                                      break;
                                                                 } // if: the domain name and the node name are the same and the SID_NAME_USE is not SidTypeDomain then it's a local SID
                                                            } // if:  LookupAccountSid() succeeded
                                                            else
                                                            {
                                                                 //if ( ::LookupAccountSidW( m_strNode, psid, szUser, &cchUser, szDomain, &cchDomain, &snu ) )
                                                                 //{
                                                                 PUCHAR  pnSubAuthorityCount = GetSidSubAuthorityCount( psid );

                                                                 if ( pnSubAuthorityCount != NULL )
                                                                 {
                                                                      PULONG  pnSubAuthority0 = GetSidSubAuthority( psid, 0 );

                                                                      if ( pnSubAuthority0 != NULL )
                                                                      {
                                                                           if ( ( *pnSubAuthorityCount == 2 ) && ( *pnSubAuthority0 == SECURITY_BUILTIN_DOMAIN_RID ) )
                                                                           {
                                                                                bLocalAccountInAcl = TRUE;
                                                                                break;
                                                                           } // if: this SID has 2 sub authorites and is from the built in domain it must be local
                                                                      } // if: got the first sub authority
                                                                      else
                                                                      {
                                                                           dwError = ::GetLastError();
                                                                           break;
                                                                      } // else: could not get the first sub authority
                                                                 } // if: got the sub authority count
                                                                 else
                                                                 {
                                                                      dwError = ::GetLastError();
                                                                      break;
                                                                 } // else: could not get the sub authority count
                                                                 //} // if: LookupAccountSid on the cluster machine failed
                                                                 //else
                                                                 //{
                                                                 //  dwError = ::GetLastError();
                                                                 //  break;
                                                                 //} // else: failed
                                                            } // else: LookupAccountSid() failed, could be a local SID
                                                       } // else: not local admin and not local system
                                                  } // if: GetAce() Succeeded
                                                  else
                                                  {
                                                       dwError = ::GetLastError();
                                                       break;
                                                  } // else: failed
                                             } // for:

                                             ::NetApiBufferFree( (LPVOID) pdci );
                                        } // if: DsGetDcName succeeded
                                   } // if: GetAclInformation() succeeded
                                   else
                                   {
                                        dwError = ::GetLastError();
                                   } // else: failed
                              } // if: IsValidAcl() succeeded
                              else
                              {
                                   dwError = ::GetLastError();
                              } // else: failed
                         } // if: GetSecurityDescriptorDacl() succeeded
                         else
                         {
                              dwError = ::GetLastError();
                         } // else: failed
                    } // if: Is ValidSecurityDescriptor() succeeded
                    else
                    {
                         dwError = ::GetLastError();
                    } // else: failed

                    ::FreeSid( pServiceSid );
                } // if: Create Service SID
                else
                {
                    dwError = ::GetLastError();
                } // else: failed

                ::FreeSid( pSystemSid );
            } // if: Create local system SID
            else
            {
                dwError = ::GetLastError();
            } // else: failed

            ::FreeSid( pAdminSid );
        } // if: Create local admin SID
        else
        {
            dwError = ::GetLastError();
        } // else: failed

        *pbFound = bLocalAccountInAcl;
        hr = HRESULT_FROM_WIN32( dwError );
    } // if: pbFound != NULL

    return hr;

}  //*** CSecurityInformation::HrLocalAccountsInSD()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\aclhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       helpids.h
//
//  Contents:   Help context identifiers
//
//  History:    13-Sep-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#define HC_OK                       1
#define HC_CANCEL                   2
#define HC_SHARE_SHARENAME          3
#define HC_SHARE_COMMENT            4
#define HC_SHARE_MAXIMUM            5
#define HC_SHARE_ALLOW              6
#define HC_SHARE_ALLOW_VALUE        7
#define HC_SHARE_PERMISSIONS        8
#define HC_SHARE_NOTSHARED          9
#define HC_SHARE_SHAREDAS           10
#define HC_SHARE_SHARENAME_COMBO    11
#define HC_SHARE_REMOVE             12
#define HC_SHARE_NEWSHARE           13
#define HC_SHARE_LIMIT              14

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// The following are help ids for the ACL editor

// stolen from \nt\private\net\ui\common\h\uihelp.h
#define HC_UI_BASE              7000
#define HC_UI_SHELL_BASE        (HC_UI_BASE+10000)

// stolen from \nt\private\net\ui\shellui\h\helpnums.h
#define HC_NTSHAREPERMS              11 // Main share perm dialog
// The following four have to be consecutive
#define HC_SHAREADDUSER              12 // Share perm add dlg
#define HC_SHAREADDUSER_LOCALGROUP   13 // Share perm add->Members
#define HC_SHAREADDUSER_GLOBALGROUP  14 // Share perm add->Members
#define HC_SHAREADDUSER_FINDUSER     15 // Share perm add->FindUser
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\aclutils.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		AclUtils.cpp
//
//	Abstract:
//		Various Access Control List (ACL) utilities.
//
//	Author:
//		Galen Barbee	(galenb)	February 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AclUtils.h"
#include "DllBase.h"
#include <lmerr.h>

class CAclUiDLL : public CDynamicLibraryBase
{
public:
	CAclUiDLL()
	{
		m_lpszLibraryName = _T( "aclui.dll" );
		m_lpszFunctionName = "CreateSecurityPage";
	}

	HPROPSHEETPAGE CreateSecurityPage( LPSECURITYINFO psi );

protected:
	typedef HPROPSHEETPAGE (*ACLUICREATESECURITYPAGEPROC) (LPSECURITYINFO);
};


HPROPSHEETPAGE CAclUiDLL::CreateSecurityPage(
	LPSECURITYINFO psi
	)
{
	ASSERT( m_hLibrary != NULL );
	ASSERT( m_pfFunction != NULL );

	return ( (ACLUICREATESECURITYPAGEPROC) m_pfFunction ) ( psi );
}

//////////////////////////////////////////////////////////////////////////
// static instances of the dynamically loaded DLL's

static CAclUiDLL g_AclUiDLL;

//+-------------------------------------------------------------------------
//
//	Function:	CreateClusterSecurityPage
//
//	Synopsis:	Create the common NT security hpage.
//
//	Arguments:	[psecinfo] - *psecinfo points to a security descriptor.
//				Caller is responsible for freeing it.
//
//	Returns:	Valid hpage or 0 for error.
//
//	History:
//		  GalenB   11-Feb-1998	Created.
//
//--------------------------------------------------------------------------
HPROPSHEETPAGE
CreateClusterSecurityPage(
	CSecurityInformation* psecinfo
	)
{
	ASSERT( NULL != psecinfo );

	HPROPSHEETPAGE	hPage = 0;

	if ( g_AclUiDLL.Load() )
	{
		psecinfo->AddRef();
		hPage = g_AclUiDLL.CreateSecurityPage( psecinfo );
		ASSERT( hPage != NULL );
		if ( hPage == NULL )
		{
			TRACE( _T( "CreateClusterSecurityPage() - Failed to create security page.\r" ) );
		}

		psecinfo->Release();
	}
	else
	{
		TRACE( _T( "CreateClusterSecurityPage() - Failed to load AclUi.dll.\r" ) );
	}

	return hPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cladmwiz\src\wizthread.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		WizThread.h
//
//	Abstract:
//		Definition of the CWizardThread class.
//
//	Implementation File:
//		WizThread.cpp
//
//	Author:
//		David Potter (davidp)	December 16, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __WIZTHREAD_H_
#define __WIZTHREAD_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterThread;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterAppWizard;
class CClusNodeInfo;
class CClusGroupInfo;
class CClusResInfo;
class CClusResTypeInfo;
class CClusNetworkInfo;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __WORKTHRD_H_
#include "WorkThrd.h"		// for CWorkerThread
#endif

#ifndef __CLUSOBJ_H_
#include "ClusObj.h"		// for CClusResPtrList, etc.
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

// Cluster thread function codes.
enum
{
	WZTF_READ_CLUSTER_INFO = WTF_USER,	// Read cluster information.
	WZTF_COLLECT_GROUPS,				// Collect groups in the cluster.
	WZTF_COLLECT_RESOURCES,				// Collect resources in the cluster.
	WZTF_COLLECT_RESOURCE_TYPES,		// Collect resource types in the cluster.
	WZTF_COLLECT_NETWORKS,				// Collect networks in the cluster.
	WZTF_COLLECT_NODES,					// Collect nodes in the cluster.
	WZTF_COPY_GROUP_INFO,				// Copy one group to another.
	WZTF_COLLECT_DEPENDENCIES,			// Collect dependencies for a resource.
	WZTF_CREATE_VIRTUAL_SERVER,			// Create a virtual server.
	WZTF_CREATE_APP_RESOURCE,			// Create the application resource.
	WZTF_DELETE_APP_RESOURCE,			// Delete the application resource.
	WZTF_RESET_CLUSTER,					// Reset the cluster.
	WZTF_SET_APPRES_ATTRIBUTES,			// Set properties, dependencies, owners of the application resource.

	WZTF_MAX
};

/////////////////////////////////////////////////////////////////////////////
// class CWizardThread
/////////////////////////////////////////////////////////////////////////////

class CWizardThread : public CWorkerThread
{
public:
	//
	// Construction and destruction.
	//

	// Default constructor
	CWizardThread( IN CClusterAppWizard * pwiz )
		: m_pwiz( pwiz )
	{
		ASSERT( pwiz != NULL );

	} //*** CWizardThread()

	// Destructor
	~CWizardThread( void )
	{
	} //*** ~CWizardThread()

	//
	// Accessor functions.
	//

protected:
	//
	// Properties.
	//

	CClusterAppWizard * m_pwiz;

	// Returns the wizard object
	CClusterAppWizard * Pwiz( void )
	{
		ASSERT( m_pwiz != NULL );
		return m_pwiz;

	} //*** Pwiz()

public:
	//
	// Function marshaler macros.
	//

#define WIZ_THREAD_FUNCTION_0( funcname, funccode ) \
	public: \
	BOOL funcname( HWND hwnd ) \
	{ \
		ASSERT( GetCurrentThreadId() != m_idThread ); \
		return CallThreadFunction( hwnd, funccode, NULL, NULL );\
	} \
	protected: \
    BOOL _##funcname( void );
#define WIZ_THREAD_FUNCTION_1( funcname, funccode, p1type, p1 ) \
	public: \
	BOOL funcname( HWND hwnd, p1type p1 ) \
	{ \
		ASSERT( GetCurrentThreadId() != m_idThread ); \
		ASSERT( p1 != NULL ); \
		return CallThreadFunction( hwnd, funccode, (PVOID) p1, NULL );\
	} \
	protected: \
    BOOL _##funcname( p1type p1 );
#define WIZ_THREAD_FUNCTION_2( funcname, funccode, p1type, p1, p2type, p2 ) \
	public: \
	BOOL funcname( HWND hwnd, p1type p1, p2type p2 ) \
	{ \
		ASSERT( GetCurrentThreadId() != m_idThread ); \
		ASSERT( p1 != NULL ); \
		ASSERT( p2 != NULL ); \
		return CallThreadFunction( hwnd, funccode, (PVOID) p1, (PVOID) p2 );\
	} \
	protected: \
    BOOL _##funcname( p1type p1, p2type p2 );

	//
	// Function marshaler functions.
	//
	WIZ_THREAD_FUNCTION_0( BReadClusterInfo,      WZTF_READ_CLUSTER_INFO )
	WIZ_THREAD_FUNCTION_0( BCollectResources,     WZTF_COLLECT_RESOURCES )
	WIZ_THREAD_FUNCTION_0( BCollectGroups,        WZTF_COLLECT_GROUPS )
	WIZ_THREAD_FUNCTION_0( BCollectResourceTypes, WZTF_COLLECT_RESOURCE_TYPES )
	WIZ_THREAD_FUNCTION_0( BCollectNetworks,      WZTF_COLLECT_NETWORKS )
	WIZ_THREAD_FUNCTION_0( BCollectNodes,         WZTF_COLLECT_NODES )
	WIZ_THREAD_FUNCTION_1( BCopyGroupInfo,        WZTF_COPY_GROUP_INFO,      CClusGroupInfo **, ppgi )
	WIZ_THREAD_FUNCTION_1( BCollectDependencies,  WZTF_COLLECT_DEPENDENCIES, CClusResInfo *, pri )
	WIZ_THREAD_FUNCTION_0( BCreateVirtualServer,  WZTF_CREATE_VIRTUAL_SERVER )
	WIZ_THREAD_FUNCTION_0( BCreateAppResource,    WZTF_CREATE_APP_RESOURCE )
	WIZ_THREAD_FUNCTION_0( BDeleteAppResource,    WZTF_DELETE_APP_RESOURCE )
	WIZ_THREAD_FUNCTION_0( BResetCluster,         WZTF_RESET_CLUSTER )
	WIZ_THREAD_FUNCTION_2( BSetAppResAttributes,  WZTF_SET_APPRES_ATTRIBUTES,
						   CClusResPtrList *,	  plpriOldDependencies,
						   CClusNodePtrList *,	  plpniOldPossibleOwners
						 )

protected:
	//
	// Thread worker functions.
	//

	// Thread function handler
	virtual DWORD ThreadFunctionHandler(
						LONG	nFunction,
						PVOID	pvParam1,
						PVOID	pvParam2
						);

	//
	// Helper functions.
	//

	// Cleanup objects
	virtual void Cleanup( void )
	{
		CWorkerThread::Cleanup();
	}

protected:
	//
	// Utility functions callable by thread function handlers.
	//

	// Query for information about a resource
	BOOL _BQueryResource( IN OUT CClusResInfo * pri );

	// Get resource properties
	BOOL _BGetResourceProps( IN OUT CClusResInfo * pri );

	// Get possible owners for a resource
	BOOL _BGetPossibleOwners( IN OUT CClusResInfo * pri );

	// Get dependencies for a resource
	BOOL _BGetDependencies( IN OUT CClusResInfo * pri );

	// Query for information about a group
	BOOL _BQueryGroup( IN OUT CClusGroupInfo * pgi );

	// Get group properties
	BOOL _BGetGroupProps( IN OUT CClusGroupInfo * pgi );

	// Get resources in a group
	BOOL _BGetResourcesInGroup( IN OUT CClusGroupInfo * pgi );

	// Get preferred owners for a group
	BOOL _BGetPreferredOwners( IN OUT CClusGroupInfo * pgi );

	// Get private props of IP Address resource for the group
	BOOL _BGetIPAddressPrivatePropsForGroup(
		IN OUT CClusGroupInfo *	pgi,
		IN OUT CClusResInfo *	pri
		);

	// Get private props of Network Name resource for the group
	BOOL _BGetNetworkNamePrivatePropsForGroup(
		IN OUT CClusGroupInfo *	pgi,
		IN OUT CClusResInfo *	pri
		);

	// Query for information about a resource type
	BOOL _BQueryResourceType( IN OUT CClusResTypeInfo * prti );

	// Get resource type properties
	BOOL _BGetResourceTypeProps( IN OUT CClusResTypeInfo * prti );

	// Get resource type required dependencies
	BOOL _BGetRequiredDependencies( IN OUT CClusResTypeInfo * prti );

	// Query for information about a network
	BOOL _BQueryNetwork( IN OUT CClusNetworkInfo * pni );

	// Query for information about a node
	BOOL _BQueryNode( IN OUT CClusNodeInfo * pni );

	// Set properties on a group
	BOOL _BSetGroupProperties(
		IN OUT CClusGroupInfo *		pgi,
		IN const CClusGroupInfo *	pgiPrev
		);

	// Create a resource and set common properties
	BOOL _BCreateResource(
		IN CClusResInfo &	rri,
		IN HGROUP			hGroup
		);

	// Set the properties, dependency list and possible owner list of a resource.
	BOOL _BSetResourceAttributes( 
		IN CClusResInfo	&		rri,
		IN CClusResPtrList *	plpriOldDependencies	= NULL,
		IN CClusNodePtrList *	plpniOldPossibleOwners	= NULL
		);

	// Set the dependency list of a resource.
	DWORD _BSetResourceDependencies(
		IN CClusResInfo	&		rri,
		IN CClusResPtrList *	plpriOldDependencies	= NULL
		);

	// Set the possible owner list of a resource.
	DWORD _BSetPossibleOwners(
		IN CClusResInfo	&		rri,
		IN CClusNodePtrList *	plpniOldPossibleOwners	= NULL
		);

	// Delete a resource
	BOOL _BDeleteResource( IN CClusResInfo & rri );

	// Reset the group to its original state (deleted or renamed)
	BOOL _BResetGroup( void );

	// Read admin extensions directly from the cluster database
	BOOL _BReadAdminExtensions( IN LPCWSTR pszKey, OUT std::list< CString > & rlstr );

}; // class CWizardThread

/////////////////////////////////////////////////////////////////////////////

#endif // __WIZTHREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\barfclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BarfClus.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Implementation File:
//		BarfClus.cpp
//
//	Author:
//		David Potter (davidp)	May 30, 1997
//
//	Revision History:
//
//	Notes:
//		Dummy file for not implementing BARF.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARFCLUS_H_
#define _BARFCLUS_H_

/////////////////////////////////////////////////////////////////////////////

#endif // _BARF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\aclbase.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-2001 Microsoft Corporation
//
//	Module Name:
//		AclBase.h
//
//	Description:
//		Implementation of the ISecurityInformation interface.  This interface
//		is the new common security UI in NT 5.0.
//
//	Implementation File:
//		AclBase.cpp
//
//	Author:
//		Galen Barbee	(galenb)	February 6, 1998
//			From \nt\private\admin\snapin\filemgmt\permpage.h
//			by JonN
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _ACLBASE_H
#define _ACLBASE_H

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _ACLUI_H_
#include <aclui.h>		// for ISecurityInformation
#endif // _ACLUI_H_

#include "CluAdmEx.h"

#include <ObjSel.h>
/*
#define NT5_UGOP_FLAGS      ( UGOP_USERS                        \
							| UGOP_ACCOUNT_GROUPS_SE            \
							| UGOP_UNIVERSAL_GROUPS_SE          \
							| UGOP_COMPUTERS                    \
							| UGOP_WELL_KNOWN_PRINCIPALS_USERS  \
							)

#define NT4_UGOP_FLAGS      ( UGOP_USERS                        \
							| UGOP_GLOBAL_GROUPS                \
							| UGOP_ALL_NT4_WELLKNOWN_SIDS       \
							)
*/

/* These are here to help document what the macro does...
typedef struct _DSOP_UPLEVEL_FILTER_FLAGS
{
    ULONG       flBothModes;					//b
    ULONG       flMixedModeOnly;				//m
    ULONG       flNativeModeOnly;				//n
} DSOP_UPLEVEL_FILTER_FLAGS;


typedef struct _DSOP_FILTER_FLAGS
{
    DSOP_UPLEVEL_FILTER_FLAGS   Uplevel;
    ULONG                       flDownlevel;	//d
} DSOP_FILTER_FLAGS;

typedef struct _DSOP_SCOPE_INIT_INFO
{
    ULONG               cbSize;
    ULONG               flType;					//t
    ULONG               flScope;				//f
    DSOP_FILTER_FLAGS   FilterFlags;
    PCWSTR              pwzDcName;
    PCWSTR              pwzADsPath;
    HRESULT             hr;
} DSOP_SCOPE_INIT_INFO, *PDSOP_SCOPE_INIT_INFO;
*/
#define DECLARE_SCOPE(t,f,b,m,n,d)  \
{ sizeof(DSOP_SCOPE_INIT_INFO), (t), (f), { { (b), (m), (n) }, (d) }, NULL, NULL, S_OK }

static const DSOP_SCOPE_INIT_INFO g_aDSOPScopes[] =
{
	// The domain to which the target computer is joined.
	DECLARE_SCOPE(DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,
					0,
					  DSOP_FILTER_USERS
					| DSOP_FILTER_UNIVERSAL_GROUPS_SE
					| DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
					| DSOP_FILTER_WELL_KNOWN_PRINCIPALS
                    | DSOP_FILTER_INCLUDE_ADVANCED_VIEW,
					0,
					0,
					0 ),

	// The external domain to which the target computer is joined.
	DECLARE_SCOPE(DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,
					0,
					  DSOP_FILTER_USERS
					| DSOP_FILTER_UNIVERSAL_GROUPS_SE
					| DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
					| DSOP_FILTER_WELL_KNOWN_PRINCIPALS
                    | DSOP_FILTER_INCLUDE_ADVANCED_VIEW,
					0,
					0,
					0 ),

	// The external domain to which the target computer is joined.
	DECLARE_SCOPE(DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN,
					0,
					  DSOP_FILTER_USERS
					| DSOP_FILTER_UNIVERSAL_GROUPS_SE
					| DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
					| DSOP_FILTER_WELL_KNOWN_PRINCIPALS
                    | DSOP_FILTER_INCLUDE_ADVANCED_VIEW,
					0,
					0,
					0 ),

	// The downlevel domain to which the target computer is joined.
	DECLARE_SCOPE(DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,
					0,
					0,
					0,
					0,
					  DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS
					| DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS
					| DSOP_DOWNLEVEL_FILTER_USERS,
					),

	// The downlevel domain to which the target computer is joined.
	DECLARE_SCOPE(DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN,
					0,
					0,
					0,
					0,
					  DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS
					| DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS
					| DSOP_DOWNLEVEL_FILTER_USERS,
					),

	// The target computer
	DECLARE_SCOPE(DSOP_SCOPE_TYPE_TARGET_COMPUTER,
					DSOP_SCOPE_FLAG_STARTING_SCOPE,
					0,
					0,
					0,
					  DSOP_DOWNLEVEL_FILTER_SYSTEM
					| DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS
					| DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS
					)

}; // struct DSOP_SCOPE_INIT_INFO g_aDSOPScopes

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CSecurityInformation;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CSecurityInformation security wrapper
/////////////////////////////////////////////////////////////////////////////

class CSecurityInformation : public ISecurityInformation, public CComObjectRoot, public IDsObjectPicker
{
	DECLARE_NOT_AGGREGATABLE(CSecurityInformation)
	BEGIN_COM_MAP(CSecurityInformation)
		COM_INTERFACE_ENTRY(ISecurityInformation)
		COM_INTERFACE_ENTRY(IDsObjectPicker)
	END_COM_MAP()

	// *** IUnknown methods ***
	STDMETHOD_(ULONG, AddRef)( void )
	{
		return InternalAddRef();

	}

	STDMETHOD_(ULONG, Release)( void )
	{
		ULONG l = InternalRelease();

		if (l == 0)
		{
			delete this;
		}

		return l;

	}

	// *** ISecurityInformation methods ***
	STDMETHOD(GetObjectInformation)( PSI_OBJECT_INFO pObjectInfo );

	STDMETHOD(GetSecurity)( SECURITY_INFORMATION	RequestedInformation,
							PSECURITY_DESCRIPTOR *	ppSecurityDescriptor,
							BOOL					fDefault ) = 0;

	STDMETHOD(SetSecurity)( SECURITY_INFORMATION	SecurityInformation,
							PSECURITY_DESCRIPTOR	pSecurityDescriptor );

	STDMETHOD(GetAccessRights)( const GUID *	pguidObjectType,
								DWORD			dwFlags,
								PSI_ACCESS *	ppAccess,
								ULONG *			pcAccesses,
								ULONG *			piDefaultAccess );

	STDMETHOD(MapGeneric)( const GUID *		pguidObjectType,
						   UCHAR *			pAceFlags,
						   ACCESS_MASK *	pMask );

	STDMETHOD(GetInheritTypes)( PSI_INHERIT_TYPE * ppInheritTypes,
								ULONG * pcInheritTypes );

	STDMETHOD(PropertySheetPageCallback)( HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage );

	// IDsObjectPicker
	STDMETHODIMP Initialize( PDSOP_INIT_INFO pInitInfo );

	STDMETHODIMP InvokeDialog( HWND hwndParent, IDataObject ** ppdoSelection );

protected:
	CSecurityInformation( void );
	~CSecurityInformation( void );

	HRESULT HrLocalAccountsInSD( IN PSECURITY_DESCRIPTOR pSD, OUT PBOOL pFound );

	PGENERIC_MAPPING	m_pShareMap;
	PSI_ACCESS			m_psiAccess;
	int					m_nDefAccess;
	int					m_nAccessElems;
	DWORD				m_dwFlags;
	CString				m_strServer;
	CString				m_strNode;
	int					m_nLocalSIDErrorMessageID;
	IDsObjectPicker *	m_pObjectPicker;
	LONG				m_cRef;

};

#endif //_ACLBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\aclutils.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		AclUtils.h
//
//	Abstract:
//		Various Access Control List (ACL) utilities.
//
//	Implementation File:
//		AclUtils.cpp
//
//	Author:
//		Galen Barbee	(galenb)	February 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _ACLUTILS_H
#define _ACLUTILS_H

#ifndef _ACLBASE_H
#include "AclBase.h"
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

extern HPROPSHEETPAGE
CreateClusterSecurityPage(
	CSecurityInformation* psecinfo
	);

#endif //_ACLUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\basedlg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BaseDlg.cpp
//
//	Abstract:
//		Implementation of the CBaseDialog class.
//
//	Author:
//		David Potter (davidp)	April 30, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BaseDlg.h"
#include "CluAdmX.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseDialog property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBaseDialog, CDialog)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBaseDialog, CDialog)
	//{{AFX_MSG_MAP(CBaseDialog)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::CBaseDialog
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseDialog::CBaseDialog(void)
{
}  //*** CBaseDialog::CBaseDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::CBaseDialog
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		idd				[IN] Dialog template resource ID.
//		pdwHelpMap		[IN] Control-to-help ID map.
//		pParentWnd		[IN] Parent window for the dialog.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseDialog::CBaseDialog(
	IN UINT				idd,
	IN const DWORD *	pdwHelpMap,
	IN CWnd *			pParentWnd
	)
	: CDialog(idd, pParentWnd)
	, m_dlghelp(pdwHelpMap, idd)
{
}  //*** CBaseDialog::CBaseDialog(UINT, UINT)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU message.
//
//	Arguments:
//		pWnd	Window in which user clicked the right mouse button.
//		point	Position of the cursor, in screen coordinates.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseDialog::OnContextMenu(CWnd * pWnd, CPoint point)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_dlghelp.OnContextMenu(pWnd, point);

}  //*** CBaseDialog::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::OnHelpInfo
//
//	Routine Description:
//		Handler for the WM_HELPINFO message.
//
//	Arguments:
//		pHelpInfo	Structure containing info about displaying help.
//
//	Return Value:
//		TRUE		Help processed.
//		FALSE		Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseDialog::OnHelpInfo(HELPINFO * pHelpInfo)
{
	BOOL	bProcessed;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	bProcessed = m_dlghelp.OnHelpInfo(pHelpInfo);
	if (!bProcessed)
		bProcessed = CDialog::OnHelpInfo(pHelpInfo);
	return bProcessed;

}  //*** CBaseDialog::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::OnCommandHelp
//
//	Routine Description:
//		Handler for the WM_COMMANDHELP message.
//
//	Arguments:
//		wParam		[IN] WPARAM.
//		lParam		[IN] LPARAM.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBaseDialog::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	LRESULT	bProcessed;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	bProcessed = m_dlghelp.OnCommandHelp(wParam, lParam);
	if (!bProcessed)
		bProcessed = CDialog::OnCommandHelp(wParam, lParam);

	return bProcessed;

}  //*** CBaseDialog::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\basedlg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BaseDlg.h
//
//	Abstract:
//		Definition of the CBaseDialogclass.  This class provides base
//		functionality for extension DLL dialogs.
//
//	Implementation File:
//		BaseDlg.cpp
//
//	Author:
//		David Potter (davidp)	April 30, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEDLG_H_
#define _BASEDLG_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _DLGHELP_H_
#include "DlgHelp.h"	// for CDialogHelp
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseDialog;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;

/////////////////////////////////////////////////////////////////////////////
// CBaseDialog dialog
/////////////////////////////////////////////////////////////////////////////

class CBaseDialog : public CDialog
{
	DECLARE_DYNCREATE(CBaseDialog)

// Construction
public:
	CBaseDialog(void);
	CBaseDialog(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN CWnd *			pParentWnd
		);
	virtual ~CBaseDialog(void) { }

// Attributes

// Dialog Data
	//{{AFX_DATA(CBaseDialog)
	enum { IDD = 0 };
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBaseDialog)
	//}}AFX_VIRTUAL

// Implementation
protected:
	void					SetHelpMask(IN DWORD dwMask)	{ m_dlghelp.SetHelpMask(dwMask); }
	CDialogHelp				m_dlghelp;

	// Generated message map functions
	//{{AFX_MSG(CBaseDialog)
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	virtual afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	DECLARE_MESSAGE_MAP()

};  //*** class CBaseDialog

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\basepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      BasePage.cpp
//
//  Abstract:
//      Implementation of the CBasePropertyPage class.
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//      1. Removed the calls to UpdateData from OnWizardNext and OnApply
//         since OnKillActive, called before both these functions does a
//         data update anyway.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "BasePage.inl"
#include "PropList.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CBasePropertyPage, CPropertyPage )

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CBasePropertyPage, CPropertyPage )
    //{{AFX_MSG_MAP(CBasePropertyPage)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage( void )
{
    CommonConstruct();

}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      pdwHelpMap          [IN] Control-to-help ID map.
//      pdwWizardHelpMap    [IN] Control-to-help ID map if this is a wizard page.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
    IN const DWORD *    pdwHelpMap,
    IN const DWORD *    pdwWizardHelpMap
    )
    : m_dlghelp( pdwHelpMap, 0 )
{
    CommonConstruct();
    m_pdwWizardHelpMap = pdwWizardHelpMap;

}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      idd                 [IN] Dialog template resource ID.
//      pdwHelpMap          [IN] Control-to-help ID map.
//      pdwWizardHelpMap    [IN] Control-to-help ID map if this is a wizard page.
//      nIDCaption          [IN] Caption string resource ID.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
    IN UINT             idd,
    IN const DWORD *    pdwHelpMap,
    IN const DWORD *    pdwWizardHelpMap,
    IN UINT             nIDCaption
    )
    : CPropertyPage( idd, nIDCaption )
    , m_dlghelp( pdwHelpMap, idd )
{
    CommonConstruct();
    m_pdwWizardHelpMap = pdwWizardHelpMap;

}  //*** CBasePropertyPage::CBasePropertyPage(UINT, UINT)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::CommonConstruct( void )
{
    //{{AFX_DATA_INIT(CBasePropertyPage)
    //}}AFX_DATA_INIT

    m_peo = NULL;
    m_hpage = NULL;
    m_bBackPressed = FALSE;
    m_bSaved = FALSE;

    m_iddPropertyPage = NULL;
    m_iddWizardPage = NULL;
    m_idsCaption = NULL;

    m_pdwWizardHelpMap = NULL;

    m_bDoDetach = FALSE;

}  //*** CBasePropertyPage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::HrInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//
//  Return Value:
//      S_OK        Page initialized successfully.
//      hr          Error initializing the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CBasePropertyPage::HrInit( IN OUT CExtObject * peo )
{
    ASSERT( peo != NULL );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    HRESULT     hr = S_OK;
    CWaitCursor wc;

    m_peo = peo;

    // Change the help map if this is a wizard page.
    if ( Peo()->BWizard() )
    {
        m_dlghelp.SetMap( m_pdwWizardHelpMap );
    } // if: on wizard page

    // Don't display a help button.
    m_psp.dwFlags &= ~PSP_HASHELP;

    // Construct the property page.
    if ( Peo()->BWizard() )
    {
        ASSERT( IddWizardPage() != NULL );
        Construct( IddWizardPage(), IdsCaption() );
        m_dlghelp.SetHelpMask( IddWizardPage() );
    }  // if:  adding page to wizard
    else
    {
        ASSERT( IddPropertyPage() != NULL );
        Construct( IddPropertyPage(), IdsCaption() );
        m_dlghelp.SetHelpMask( IddPropertyPage() );
    }  // else:  adding page to property sheet

    // Read the properties private to this resource and parse them.
    {
        DWORD           sc;
        CClusPropList   cpl;

        ASSERT( Peo() != NULL );
        ASSERT( Peo()->PrdResData() != NULL );
        ASSERT( Peo()->PrdResData()->m_hresource != NULL );

        // Read the properties.
        sc = cpl.ScGetResourceProperties(
                                Peo()->PrdResData()->m_hresource,
                                CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
                                );

        // Parse the properties.
        if ( sc == ERROR_SUCCESS )
        {
            // Parse the properties.
            try
            {
                sc = ScParseProperties( cpl );
            }  // try
            catch ( CMemoryException * pme )
            {
                sc = ERROR_NOT_ENOUGH_MEMORY;
                pme->Delete();
            }  // catch:  CMemoryException
        }  // if:  properties read successfully

        if ( sc != ERROR_SUCCESS )
        {
            CNTException nte( sc, IDS_ERROR_GETTING_PROPERTIES, NULL, NULL, FALSE );
            nte.ReportError();
            hr = HRESULT_FROM_WIN32( sc );
        }  // if:  error parsing getting or parsing properties
    }  // Read the properties private to this resource and parse them

    return hr;

}  //*** CBasePropertyPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScParseProperties
//
//  Routine Description:
//      Parse the properties of the resource.  This is in a separate function
//      from HrInit so that the optimizer can do a better job.
//
//  Arguments:
//      rcpl            [IN] Cluster property list to parse.
//
//  Return Value:
//      ERROR_SUCCESS   Properties were parsed successfully.
//      Any error returns from ScParseUnknownProperty().
//
//  Exceptions Thrown:
//      Any exceptions from CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScParseProperties( IN CClusPropList & rcpl )
{
    DWORD                   sc;
    DWORD                   cprop;
    const CObjectProperty * pprop;

    ASSERT( rcpl.PbPropList() != NULL );

    sc = rcpl.ScMoveToFirstProperty();
    while ( sc == ERROR_SUCCESS )
    {
        //
        // Parse known properties.
        //
        for ( pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop-- )
        {
            if ( lstrcmpiW( rcpl.PszCurrentPropertyName(), pprop->m_pwszName ) == 0 )
            {
                ASSERT( rcpl.CpfCurrentValueFormat() == pprop->m_propFormat );
                switch ( pprop->m_propFormat )
                {
                    case CLUSPROP_FORMAT_SZ:
                    case CLUSPROP_FORMAT_EXPAND_SZ:
                        ASSERT( ( rcpl.CbCurrentValueLength() == (lstrlenW( rcpl.CbhCurrentValue().pStringValue->sz ) + 1) * sizeof( WCHAR ) )
                             || ( ( rcpl.CbCurrentValueLength() == 0 )
                                 && ( rcpl.CbhCurrentValue().pStringValue->sz[ 0 ] == L'\0' )
                                )
                              );
                        *pprop->m_value.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
                        *pprop->m_valuePrev.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
                        break;
                    case CLUSPROP_FORMAT_DWORD:
                    case CLUSPROP_FORMAT_LONG:
                        ASSERT( rcpl.CbCurrentValueLength() == sizeof( DWORD ) );
                        *pprop->m_value.pdw = rcpl.CbhCurrentValue().pDwordValue->dw;
                        *pprop->m_valuePrev.pdw = rcpl.CbhCurrentValue().pDwordValue->dw;
                        break;
                    case CLUSPROP_FORMAT_BINARY:
                    case CLUSPROP_FORMAT_MULTI_SZ:
                        *pprop->m_value.ppb = rcpl.CbhCurrentValue().pBinaryValue->rgb;
                        *pprop->m_value.pcb = rcpl.CbhCurrentValue().pBinaryValue->cbLength;
                        *pprop->m_valuePrev.ppb = rcpl.CbhCurrentValue().pBinaryValue->rgb;
                        *pprop->m_valuePrev.pcb = rcpl.CbhCurrentValue().pBinaryValue->cbLength;
                        break;
                    default:
                        ASSERT( 0 );  // don't know how to deal with this type
                } // switch: property format

                // Exit the loop since we found the parameter.
                break;
            } // if: found a match
        } // for: each property that we know about

        //
        // If the property wasn't known, ask the derived class to parse it.
        //
        if ( cprop == 0 )
        {
            sc = ScParseUnknownProperty(
                        rcpl.CbhCurrentPropertyName().pName->sz,
                        rcpl.CbhCurrentValue(),
                        rcpl.RPvlPropertyValue().CbDataLeft()
                        );
            if ( sc != ERROR_SUCCESS )
            {
                return sc;
            } // if: error parsing the unknown property
        } // if: property not parsed

        //
        // Advance the buffer pointer past the value in the value list.
        //
        sc = rcpl.ScMoveToNextProperty();
    } // while: more properties to parse

    //
    // If we reached the end of the properties, fix the return code.
    //
    if ( sc == ERROR_NO_MORE_ITEMS )
    {
        sc = ERROR_SUCCESS;
    } // if: ended loop after parsing all properties

    return sc;

}  //*** CBasePropertyPage::ScParseProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnCreate
//
//  Routine Description:
//      Handler for the WM_CREATE message.
//
//  Arguments:
//      lpCreateStruct  [IN OUT] Window create structure.
//
//  Return Value:
//      -1      Error.
//      0       Success.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CBasePropertyPage::OnCreate( LPCREATESTRUCT lpCreateStruct )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Attach the window to the property page structure.
    // This has been done once already in the main application, since the
    // main application owns the property sheet.  It needs to be done here
    // so that the window handle can be found in the DLL's handle map.
    if ( FromHandlePermanent( m_hWnd ) == NULL ) // is the window handle already in the handle map
    {
        HWND hWnd = m_hWnd;
        m_hWnd = NULL;
        Attach( hWnd );
        m_bDoDetach = TRUE;
    } // if: is the window handle in the handle map

    return CPropertyPage::OnCreate( lpCreateStruct );

}  //*** CBasePropertyPage::OnCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnDestroy
//
//  Routine Description:
//      Handler for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnDestroy( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Detach the window from the property page structure.
    // This will be done again by the main application, since it owns the
    // property sheet.  It needs to be done here so that the window handle
    // can be removed from the DLL's handle map.
    if ( m_bDoDetach )
    {
        if ( m_hWnd != NULL )
        {
            HWND hWnd = m_hWnd;

            Detach();
            m_hWnd = hWnd;
        } // if: do we have a window handle?
    } // if: do we need to balance the attach we did with a detach?

    CPropertyPage::OnDestroy();

}  //*** CBasePropertyPage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DoDataExchange( CDataExchange * pDX )
{
    if ( ! pDX->m_bSaveAndValidate || !BSaved() )
    {
        AFX_MANAGE_STATE( AfxGetStaticModuleState() );

        //{{AFX_DATA_MAP(CBasePropertyPage)
            // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
        DDX_Control( pDX, IDC_PP_ICON, m_staticIcon );
        DDX_Control( pDX, IDC_PP_TITLE, m_staticTitle );

        if ( pDX->m_bSaveAndValidate )
        {
            if ( ! BBackPressed() )
            {
                CWaitCursor wc;

                // Validate the data.
                if ( ! BSetPrivateProps( TRUE /*bValidateOnly*/ ) )
                {
                    pDX->Fail();
                } // if: error setting private properties
            }  // if:  Back button not pressed
        }  // if:  saving data from dialog
        else
        {
            // Set the title.
            DDX_Text( pDX, IDC_PP_TITLE, m_strTitle );
        }  // if:  not saving data
    }  // if:  not saving or haven't saved yet

    CPropertyPage::DoDataExchange( pDX );

}  //*** CBasePropertyPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnInitDialog( void )
{
    ASSERT( Peo() != NULL );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Set the title string.
    m_strTitle = Peo()->RrdResData().m_strName;

    // Call the base class method.
    CPropertyPage::OnInitDialog();

    // Display an icon for the object.
    if ( Peo()->Hicon() != NULL )
    {
        m_staticIcon.SetIcon( Peo()->Hicon() );
    } // if: icon was specified

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBasePropertyPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnSetActive( void )
{
    HRESULT     hr;

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Reread the data.
    hr = Peo()->HrGetObjectInfo();
    if ( hr != NOERROR )
    {
        return FALSE;
    } // if: error getting object info

    // Set the title string.
    m_strTitle = Peo()->RrdResData().m_strName;

    m_bBackPressed = FALSE;
    m_bSaved = FALSE;
    return CPropertyPage::OnSetActive();

}  //*** CBasePropertyPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnApply
//
//  Routine Description:
//      Handler for the PSM_APPLY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnApply( void )
{
    ASSERT( ! BWizard() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    CWaitCursor wc;

    if ( ! BApplyChanges() )
    {
        return FALSE;
    } // if: error applying changes

    return CPropertyPage::OnApply();

}  //*** CBasePropertyPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardBack
//
//  Routine Description:
//      Handler for the PSN_WIZBACK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      -1      Don't change the page.
//      0       Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardBack( void )
{
    LRESULT     lResult;

    ASSERT( BWizard() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    lResult = CPropertyPage::OnWizardBack();
    if ( lResult != -1 )
    {
        m_bBackPressed = TRUE;
    } // if: back processing performed successfully

    return lResult;

}  //*** CBasePropertyPage::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardNext
//
//  Routine Description:
//      Handler for the PSN_WIZNEXT message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      -1      Don't change the page.
//      0       Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardNext( void )
{
    ASSERT( BWizard() );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWaitCursor _wc;

    // Update the data in the class from the page.
    // This necessary because, while OnKillActive() will call UpdateData(),
    // it is called after this method is called, and we need to be sure that
    // data has been saved before we apply them.
    if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
    {
        return -1;
    } // if: error updating data

    // Save the data in the sheet.
    if ( ! BApplyChanges() )
    {
        return -1;
    } // if: error applying changes

    // Create the object.

    return CPropertyPage::OnWizardNext();

}  //*** CBasePropertyPage::OnWizardNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardFinish
//
//  Routine Description:
//      Handler for the PSN_WIZFINISH message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      FALSE   Don't change the page.
//      TRUE    Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnWizardFinish( void )
{
    ASSERT( BWizard() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    CWaitCursor wc;

    // BUG! There should be no need to call UpdateData in this function.
    // See BUG: Finish Button Fails Data Transfer from Page to Variables
    // MSDN Article ID: Q150349

    // Update the data in the class from the page.
    if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
    {
        return FALSE;
    } // if: error updating data

    // Save the data in the sheet.
    if ( ! BApplyChanges() )
    {
        return FALSE;
    } // if: error applying changes

    return CPropertyPage::OnWizardFinish();

}  //*** CBasePropertyPage::OnWizardFinish()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnChangeCtrl
//
//  Routine Description:
//      Handler for the messages sent when a control is changed.  This
//      method can be specified in a message map if all that needs to be
//      done is enable the Apply button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnChangeCtrl( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    SetModified( TRUE );

}  //*** CBasePropertyPage::OnChangeCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::EnableNext
//
//  Routine Description:
//      Enables or disables the NEXT or FINISH button.
//
//  Arguments:
//      bEnable     [IN] TRUE = enable the button, FALSE = disable the button.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::EnableNext( IN BOOL bEnable /*TRUE*/ )
{
    ASSERT( BWizard() );
    ASSERT( PiWizardCallback() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    PiWizardCallback()->EnableNext( (LONG *) Hpage(), bEnable );

}  //*** CBasePropertyPage::EnableNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BApplyChanges( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    BOOL        bSuccess;
    CWaitCursor wc;

    // Make sure required dependencies have been set.
    if ( ! BSetPrivateProps() )
    {
        bSuccess = FALSE;
    } // if: all required dependencies are not present
    else
    {
        // Save data.
        bSuccess = BRequiredDependenciesPresent();
    } // else: all required dependencies are present

    return bSuccess;

}  //*** CBasePropertyPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BBuildPropList
//
//  Routine Description:
//      Build the property list.
//
//  Arguments:
//      rcpl        [IN OUT] Cluster property list.
//      bNoNewProps [IN] TRUE = exclude properties marked with opfNew.
//
//  Return Value:
//      TRUE        Property list built successfully.
//      FALSE       Error building property list.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusPropList::ScAddProp().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BBuildPropList(
    IN OUT CClusPropList &  rcpl,
    IN BOOL                 bNoNewProps     // = FALSE
    )
{
    BOOL                    bNewPropsFound = FALSE;
    DWORD                   cprop;
    const CObjectProperty * pprop;

    for ( pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop-- )
    {
        if ( bNoNewProps && ( pprop->m_fFlags & CObjectProperty::opfNew ) )
        {
            bNewPropsFound = TRUE;
            continue;
        } // if:  no new props allowed and this is a new property

        switch ( pprop->m_propFormat )
        {
            case CLUSPROP_FORMAT_SZ:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pstr,
                        *pprop->m_valuePrev.pstr
                        );
                break;
            case CLUSPROP_FORMAT_EXPAND_SZ:
                rcpl.ScAddExpandSzProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pstr,
                        *pprop->m_valuePrev.pstr
                        );
                break;
            case CLUSPROP_FORMAT_DWORD:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pdw,
                        *pprop->m_valuePrev.pdw
                        );
                break;
            case CLUSPROP_FORMAT_LONG:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pl,
                        *pprop->m_valuePrev.pl
                        );
                break;
            case CLUSPROP_FORMAT_BINARY:
            case CLUSPROP_FORMAT_MULTI_SZ:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.ppb,
                        *pprop->m_value.pcb,
                        *pprop->m_valuePrev.ppb,
                        *pprop->m_valuePrev.pcb
                        );
                break;
            default:
                ASSERT( 0 );  // don't know how to deal with this type
                return FALSE;
        }  // switch:  property format
    }  // for:  each property

    return ( ! bNoNewProps || bNewPropsFound );

}  //*** CBasePropertyPage::BBuildPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BSetPrivateProps
//
//  Routine Description:
//      Set the private properties for this object.
//
//  Arguments:
//      bValidateOnly   [IN] TRUE = only validate the data.
//      bNoNewProps     [IN] TRUE = exclude properties marked with opfNew.
//
//  Return Value:
//      ERROR_SUCCESS   The operation was completed successfully.
//      !0              Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BSetPrivateProps(
    IN BOOL bValidateOnly,  // = FALSE
    IN BOOL bNoNewProps     // = FALSE
    )
{
    BOOL            bSuccess   = TRUE;
    CClusPropList   cpl(BWizard() /*bAlwaysAddProp*/);

    ASSERT( Peo() != NULL );
    ASSERT( Peo()->PrdResData() );
    ASSERT( Peo()->PrdResData()->m_hresource );

    // Build the property list.
    try
    {
        bSuccess = BBuildPropList( cpl, bNoNewProps );
    }  // try
    catch ( CException * pe )
    {
        pe->ReportError();
        pe->Delete();
        bSuccess = FALSE;
    }  // catch:  CException

    // Set the data.
    if ( bSuccess )
    {
        if ( ( cpl.PbPropList() != NULL ) && ( cpl.CbPropList() > 0 ) )
        {
            DWORD       sc;
            DWORD       dwControlCode;
            DWORD       cbProps;

            // Determine which control code to use.
            if ( bValidateOnly )
            {
                dwControlCode = CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES;
            } // if: only validating
            else
            {
                dwControlCode = CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES;
            } // else: not just validating

            // Set private properties.
            sc = ClusterResourceControl(
                            Peo()->PrdResData()->m_hresource,
                            NULL,   // hNode
                            dwControlCode,
                            cpl.PbPropList(),
                            cpl.CbPropList(),
                            NULL,   // lpOutBuffer
                            0,      // nOutBufferSize
                            &cbProps
                            );
            if ( sc != ERROR_SUCCESS )
            {
                if ( sc == ERROR_INVALID_PARAMETER )
                {
                    if ( ! bNoNewProps )
                    {
                        bSuccess = BSetPrivateProps( bValidateOnly, TRUE /*bNoNewProps*/ );
                    } // if:  new props are allowed
                    else
                    {
                        bSuccess = FALSE;
                    } // else: new props are not allowed
                } // if:  invalid parameter error occurred
                else
                {
                    bSuccess = FALSE;
                } // else: some other error occurred
            }  // if:  error setting/validating data

            //
            // If an error occurred, display an error message.
            //
            if ( ! bSuccess )
            {
                DisplaySetPropsError( sc, bValidateOnly ? IDS_ERROR_VALIDATING_PROPERTIES : IDS_ERROR_SETTING_PROPERTIES );
                if ( sc == ERROR_RESOURCE_PROPERTIES_STORED )
                {
                    bSuccess = TRUE;
                } // if: properties only stored
            } // if:  error occurred
        }  // if:  there is data to set
    }  // if:  no errors building the property list

    // Save data locally.
    if ( ! bValidateOnly && bSuccess )
    {
        // Save new values as previous values.
        try
        {
            DWORD                   cprop;
            const CObjectProperty * pprop;

            for ( pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop-- )
            {
                switch ( pprop->m_propFormat )
                {
                    case CLUSPROP_FORMAT_SZ:
                    case CLUSPROP_FORMAT_EXPAND_SZ:
                        ASSERT( pprop->m_value.pstr != NULL );
                        ASSERT( pprop->m_valuePrev.pstr != NULL );
                        *pprop->m_valuePrev.pstr = *pprop->m_value.pstr;
                        break;
                    case CLUSPROP_FORMAT_DWORD:
                    case CLUSPROP_FORMAT_LONG:
                        ASSERT( pprop->m_value.pdw != NULL );
                        ASSERT( pprop->m_valuePrev.pdw != NULL );
                        *pprop->m_valuePrev.pdw = *pprop->m_value.pdw;
                        break;
                    case CLUSPROP_FORMAT_BINARY:
                    case CLUSPROP_FORMAT_MULTI_SZ:
                        ASSERT( pprop->m_value.ppb != NULL );
                        ASSERT( *pprop->m_value.ppb != NULL );
                        ASSERT( pprop->m_value.pcb != NULL );
                        ASSERT( pprop->m_valuePrev.ppb != NULL );
                        ASSERT( *pprop->m_valuePrev.ppb != NULL );
                        ASSERT( pprop->m_valuePrev.pcb != NULL );
                        delete [] *pprop->m_valuePrev.ppb;
                        *pprop->m_valuePrev.ppb = new BYTE[ *pprop->m_value.pcb ];
                        if ( *pprop->m_valuePrev.ppb == NULL )
                        {
                            AfxThrowMemoryException();
                        } // if: error allocating memory
                        CopyMemory( *pprop->m_valuePrev.ppb, *pprop->m_value.ppb, *pprop->m_value.pcb );
                        *pprop->m_valuePrev.pcb = *pprop->m_value.pcb;
                        break;
                    default:
                        ASSERT( 0 );    // don't know how to deal with this type
                }  // switch:  property format
            }  // for:  each property
        }  // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
            bSuccess = FALSE;
        }  // catch:  CException
    }  // if:  not just validating and successful so far

    //
    // Indicate we successfully saved the properties.
    //
    if ( ! bValidateOnly && bSuccess )
    {
        m_bSaved = TRUE;
    } // if:  successfully saved data

    return bSuccess;

}  //*** CBasePropertyPage::BSetPrivateProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DisplaySetPropsError
//
//  Routine Description:
//      Display an error caused by setting or validating properties.
//
//  Arguments:
//      sc      [IN] Status to display error on.
//      idsOper [IN] Operation message.
//
//  Return Value:
//      nStatus ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DisplaySetPropsError(
    IN DWORD    sc,
    IN UINT     idsOper
    ) const
{
    CString strErrorMsg;
    CString strOperMsg;
    CString strMsgIdFmt;
    CString strMsgId;
    CString strMsg;

    strOperMsg.LoadString( IDS_ERROR_SETTING_PROPERTIES );
    FormatError( strErrorMsg, sc );
    strMsgIdFmt.LoadString( IDS_ERROR_MSG_ID );
    strMsgId.Format( strMsgIdFmt, sc, sc );
    strMsg.Format( _T("%s\n\n%s%s"), strOperMsg, strErrorMsg, strMsgId );
    AfxMessageBox( strMsg );

}  //*** CBasePropertyPage::DisplaySetPropsError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BRequiredDependenciesPresent
//
//  Routine Description:
//      Determine if the specified list contains each required resource
//      for this type of resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CString::LoadString() or CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BRequiredDependenciesPresent( void )
{
    BOOL                        bFound = TRUE;
    DWORD                       sc;
    CClusPropValueList          pvl;
    HRESOURCE                   hres;
    PCLUS_RESOURCE_CLASS_INFO   prci = NULL;
    CString                     strMissing;

    do
    {
        // Collect the list of required dependencies.
        sc = pvl.ScGetResourceValueList(
                    Peo()->PrdResData()->m_hresource,
                    CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES
                    );
        if ( sc != ERROR_SUCCESS )
        {
            CNTException nte( sc, 0, NULL, NULL, FALSE );
            nte.ReportError();
            break;
        } // if: error collecting required dependencies

        // Move to the first value.
        sc = pvl.ScMoveToFirstValue();

        while ( sc == ERROR_SUCCESS )
        {
            switch ( pvl.CptCurrentValueType() )
            {
                case CLUSPROP_TYPE_RESCLASS:
                    prci = reinterpret_cast< PCLUS_RESOURCE_CLASS_INFO >( &pvl.CbhCurrentValue().pResourceClassInfoValue->li );
                    hres = ResUtilGetResourceDependencyByClass(
                                Hcluster(),
                                Peo()->PrdResData()->m_hresource,
                                prci,
                                FALSE // bRecurse
                                );
                    if ( hres != NULL )
                    {
                        CloseClusterResource( hres );
                    } // if:  found the resource
                    else
                    {
                        if ( ! strMissing.LoadString( IDS_RESCLASS_UNKNOWN + prci->rc ) )
                        {
                            strMissing.LoadString( IDS_RESCLASS_UNKNOWN );
                        } // if: unknown resource class

                        bFound = FALSE;
                    } // else: resource not found
                    break;

                case CLUSPROP_TYPE_NAME:
                    hres = ResUtilGetResourceDependencyByName(
                                Hcluster(),
                                Peo()->PrdResData()->m_hresource,
                                pvl.CbhCurrentValue().pName->sz,
                                FALSE // bRecurse
                                );
                    if ( hres != NULL )
                    {
                        CloseClusterResource( hres );
                    } // if:  found the resource
                    else
                    {
                        GetResTypeDisplayOrTypeName( pvl.CbhCurrentValue().pName->sz, &strMissing );
                        bFound = FALSE;
                    } // else: resource not found
                    break;

            } // switch: value type

            // If a match was not found, changes cannot be applied.
            if ( ! bFound )
            {
                CExceptionWithOper ewo( IDS_REQUIRED_DEPENDENCY_NOT_FOUND, NULL, NULL, FALSE );

                ewo.SetOperation( IDS_REQUIRED_DEPENDENCY_NOT_FOUND, static_cast< LPCWSTR >( strMissing ) );
                ewo.ReportError();

                break;
            }  // if:  not found

            sc = pvl.ScMoveToNextValue();
        } // while: more values in the value list

    } while( 0 );

    return bFound;

} //*** CBasePropertyPage::BRequiredDependenciesPresent()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::GetResTypeDisplayOrTypeName
//
//  Routine Description:
//      Get the display name for a resource type if possible.  If any errors
//      occur, just return the type name.
//
//  Arguments:
//      pszResTypeNameIn
//          [IN] Name of resource type.
//
//      pstrResTypeDisplayNameInOut
//          [IN OUT] CString in which to return the display name.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::GetResTypeDisplayOrTypeName(
    IN      LPCWSTR     pszResTypeNameIn,
    IN OUT  CString *   pstrResTypeDisplayNameInOut
    )
{
    DWORD           sc;
    CClusPropList   cpl;

    // Get resource type properties.
    sc = cpl.ScGetResourceTypeProperties(
                Hcluster(),
                pszResTypeNameIn,
                CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES
                );
    if ( sc != ERROR_SUCCESS )
        goto Error;

    // Find the Name property.
    sc = cpl.ScMoveToPropertyByName( CLUSREG_NAME_RESTYPE_NAME );
    if ( sc != ERROR_SUCCESS )
        goto Error;

    // Move to the first value for the property.
    sc = cpl.ScMoveToFirstPropertyValue();
    if ( sc != ERROR_SUCCESS )
        goto Error;

    // Make sure the name is a string.
    if ( ( cpl.CpfCurrentValueFormat() != CLUSPROP_FORMAT_SZ )
      && ( cpl.CpfCurrentValueFormat() != CLUSPROP_FORMAT_EXPAND_SZ )
      && ( cpl.CpfCurrentValueFormat() != CLUSPROP_FORMAT_EXPANDED_SZ )
       )
       goto Error;

    // Copy the string into the output CString.
    *pstrResTypeDisplayNameInOut = cpl.CbhCurrentValue().pStringValue->sz;

Cleanup:
    return;

Error:
    *pstrResTypeDisplayNameInOut = pszResTypeNameIn;
    goto Cleanup;

} //*** CBasePropertyPage::GetResTypeDisplayOrTypeName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScReadValue
//
//  Routine Description:
//      Read a REG_SZ value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      rstrValue       [OUT] String in which to return the value.
//      hkey            [IN] Handle to the registry key to read from.
//
//  Return Value:
//      sc ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScReadValue(
    IN LPCTSTR      pszValueName,
    OUT CString &   rstrValue,
    IN HKEY         hkey
    )
{
    DWORD       sc;
    LPWSTR      pwszValue  = NULL;
    DWORD       dwValueLen;
    DWORD       dwValueType;

    ASSERT( pszValueName != NULL );
    ASSERT( hkey != NULL );

    rstrValue.Empty();

    try
    {
        // Get the size of the value.
        dwValueLen = 0;
        sc = ::ClusterRegQueryValue(
                        hkey,
                        pszValueName,
                        &dwValueType,
                        NULL,
                        &dwValueLen
                        );
        if ( ( sc == ERROR_SUCCESS ) || ( sc == ERROR_MORE_DATA ) )
        {
            ASSERT( dwValueType == REG_SZ );

            // Allocate enough space for the data.
            pwszValue = rstrValue.GetBuffer( dwValueLen / sizeof( WCHAR ) );
            if ( pwszValue == NULL )
            {
                AfxThrowMemoryException();
            } // if: error getting the buffer
            ASSERT( pwszValue != NULL );
            dwValueLen += 1 * sizeof( WCHAR );  // Don't forget the final null-terminator.

            // Read the value.
            sc = ::ClusterRegQueryValue(
                            hkey,
                            pszValueName,
                            &dwValueType,
                            (LPBYTE) pwszValue,
                            &dwValueLen
                            );
            if ( sc == ERROR_SUCCESS )
            {
                ASSERT( dwValueType == REG_SZ );
            }  // if:  value read successfully
            rstrValue.ReleaseBuffer();
        }  // if:  got the size successfully
    }  // try
    catch ( CMemoryException * pme )
    {
        pme->Delete();
        sc = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException

    return sc;

}  //*** CBasePropertyPage::ScReadValue(LPCTSTR, CString&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScReadValue
//
//  Routine Description:
//      Read a REG_DWORD value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      pdwValue        [OUT] DWORD in which to return the value.
//      hkey            [IN] Handle to the registry key to read from.
//
//  Return Value:
//      _sc ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScReadValue(
    IN LPCTSTR      pszValueName,
    OUT DWORD *     pdwValue,
    IN HKEY         hkey
    )
{
    DWORD       _sc;
    DWORD       _dwValue;
    DWORD       _dwValueLen;
    DWORD       _dwValueType;

    ASSERT(pszValueName != NULL);
    ASSERT(pdwValue != NULL);
    ASSERT(hkey != NULL);

    *pdwValue = 0;

    // Read the value.
    _dwValueLen = sizeof(_dwValue);
    _sc = ::ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &_dwValueType,
                    (LPBYTE) &_dwValue,
                    &_dwValueLen
                    );
    if (_sc == ERROR_SUCCESS)
    {
        ASSERT(_dwValueType == REG_DWORD);
        ASSERT(_dwValueLen == sizeof(_dwValue));
        *pdwValue = _dwValue;
    }  // if:  value read successfully

    return _sc;

}  //*** CBasePropertyPage::ScReadValue(LPCTSTR, DWORD*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScReadValue
//
//  Routine Description:
//      Read a REG_BINARY value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      ppbValue        [OUT] Pointer in which to return the data.  Caller
//                          is responsible for deallocating the data.
//      hkey            [IN] Handle to the registry key to read from.
//
//  Return Value:
//      _sc ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScReadValue(
    IN LPCTSTR      pszValueName,
    OUT LPBYTE *    ppbValue,
    IN HKEY         hkey
    )
{
    DWORD       _sc;
    DWORD       _dwValueLen;
    DWORD       _dwValueType;

    ASSERT(pszValueName != NULL);
    ASSERT(ppbValue != NULL);
    ASSERT(hkey != NULL);

    *ppbValue = NULL;

    // Get the length of the value.
    _dwValueLen = 0;
    _sc = ::ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &_dwValueType,
                    NULL,
                    &_dwValueLen
                    );
    if (_sc != ERROR_SUCCESS)
        return _sc;

    ASSERT(_dwValueType == REG_BINARY);

    // Allocate a buffer,
    try
    {
        *ppbValue = new BYTE[_dwValueLen];
    }  // try
    catch (CMemoryException *)
    {
        _sc = ERROR_NOT_ENOUGH_MEMORY;
        return _sc;
    }  // catch:  CMemoryException

    // Read the value.
    _sc = ::ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &_dwValueType,
                    *ppbValue,
                    &_dwValueLen
                    );
    if (_sc != ERROR_SUCCESS)
    {
        delete [] *ppbValue;
        *ppbValue = NULL;
    }  // if:  value read successfully

    return _sc;

}  //*** CBasePropertyPage::ScReadValue(LPCTSTR, LPBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScWriteValue
//
//  Routine Description:
//      Write a REG_SZ value for this item if it hasn't changed.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      rstrValue       [IN] Value data.
//      rstrPrevValue   [IN OUT] Previous value.
//      hkey            [IN] Handle to the registry key to write to.
//
//  Return Value:
//      _sc
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScWriteValue(
    IN LPCTSTR          pszValueName,
    IN const CString &  rstrValue,
    IN OUT CString &    rstrPrevValue,
    IN HKEY             hkey
    )
{
    DWORD       _sc;

    ASSERT(pszValueName != NULL);
    ASSERT(hkey != NULL);

    // Write the value if it hasn't changed.
    if (rstrValue != rstrPrevValue)
    {
        _sc = ::ClusterRegSetValue(
                        hkey,
                        pszValueName,
                        REG_SZ,
                        (CONST BYTE *) (LPCTSTR) rstrValue,
                        (rstrValue.GetLength() + 1) * sizeof(TCHAR)
                        );
        if (_sc == ERROR_SUCCESS)
            rstrPrevValue = rstrValue;
    }  // if:  value changed
    else
        _sc = ERROR_SUCCESS;
    return _sc;

}  //*** CBasePropertyPage::ScWriteValue(LPCTSTR, CString&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScWriteValue
//
//  Routine Description:
//      Write a REG_DWORD value for this item if it hasn't changed.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      dwValue         [IN] Value data.
//      pdwPrevValue    [IN OUT] Previous value.
//      hkey            [IN] Handle to the registry key to write to.
//
//  Return Value:
//      _sc
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScWriteValue(
    IN LPCTSTR          pszValueName,
    IN DWORD            dwValue,
    IN OUT DWORD *      pdwPrevValue,
    IN HKEY             hkey
    )
{
    DWORD       _sc;

    ASSERT(pszValueName != NULL);
    ASSERT(pdwPrevValue != NULL);
    ASSERT(hkey != NULL);

    // Write the value if it hasn't changed.
    if (dwValue != *pdwPrevValue)
    {
        _sc = ::ClusterRegSetValue(
                        hkey,
                        pszValueName,
                        REG_DWORD,
                        (CONST BYTE *) &dwValue,
                        sizeof(dwValue)
                        );
        if (_sc == ERROR_SUCCESS)
            *pdwPrevValue = dwValue;
    }  // if:  value changed
    else
        _sc = ERROR_SUCCESS;
    return _sc;

}  //*** CBasePropertyPage::ScWriteValue(LPCTSTR, DWORD)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScWriteValue
//
//  Routine Description:
//      Write a REG_BINARY value for this item if it hasn't changed.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      pbValue         [IN] Value data.
//      cbValue         [IN] Size of value data.
//      ppbPrevValue    [IN OUT] Previous value.
//      cbPrevValue     [IN] Size of the previous data.
//      hkey            [IN] Handle to the registry key to write to.
//
//  Return Value:
//      _sc
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScWriteValue(
    IN LPCTSTR          pszValueName,
    IN const LPBYTE     pbValue,
    IN DWORD            cbValue,
    IN OUT LPBYTE *     ppbPrevValue,
    IN DWORD            cbPrevValue,
    IN HKEY             hkey
    )
{
    DWORD       _sc;
    LPBYTE      _pbPrevValue    = NULL;

    ASSERT(pszValueName != NULL);
    ASSERT(pbValue != NULL);
    ASSERT(ppbPrevValue != NULL);
    ASSERT(cbValue > 0);
    ASSERT(hkey != NULL);

    // See if the data has changed.
    if (cbValue == cbPrevValue)
    {
        if (memcmp(pbValue, *ppbPrevValue, cbValue) == 0)
            return ERROR_SUCCESS;
    }  // if:  lengths are the same

    // Allocate a new buffer for the previous data pointer.
    try
    {
        _pbPrevValue = new BYTE[cbValue];
    }
    catch (CMemoryException *)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException
    ::CopyMemory(_pbPrevValue, pbValue, cbValue);

    // Write the value if it hasn't changed.
    _sc = ::ClusterRegSetValue(
                    hkey,
                    pszValueName,
                    REG_BINARY,
                    pbValue,
                    cbValue
                    );
    if (_sc == ERROR_SUCCESS)
    {
        delete [] *ppbPrevValue;
        *ppbPrevValue = _pbPrevValue;
    }  // if:  set was successful
    else
        delete [] _pbPrevValue;

    return _sc;

}  //*** CBasePropertyPage::ScWriteValue(LPCTSTR, const LPBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU message.
//
//  Arguments:
//      pWnd    Window in which user clicked the right mouse button.
//      point   Position of the cursor, in screen coordinates.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_dlghelp.OnContextMenu(pWnd, point);

}  //*** CBasePropertyPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnHelpInfo
//
//  Routine Description:
//      Handler for the WM_HELPINFO message.
//
//  Arguments:
//      pHelpInfo   Structure containing info about displaying help.
//
//  Return Value:
//      TRUE        Help processed.
//      FALSE       Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnHelpInfo(HELPINFO * pHelpInfo)
{
    BOOL    _bProcessed;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    _bProcessed = m_dlghelp.OnHelpInfo(pHelpInfo);
    if (!_bProcessed)
        _bProcessed = CPropertyPage::OnHelpInfo(pHelpInfo);
    return _bProcessed;

}  //*** CBasePropertyPage::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnCommandHelp
//
//  Routine Description:
//      Handler for the WM_COMMANDHELP message.
//
//  Arguments:
//      wParam      [IN] WPARAM.
//      lParam      [IN] LPARAM.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
    LRESULT _bProcessed;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    _bProcessed = m_dlghelp.OnCommandHelp(wParam, lParam);
    if (!_bProcessed)
        _bProcessed = CPropertyPage::OnCommandHelp(wParam, lParam);

    return _bProcessed;

}  //*** CBasePropertyPage::OnCommandHelp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ConstructDefaultDirectory
//
//  Routine Description:
//      Get the name of the first partition from the first storage-class
//      resource on which this resource is dependent.
//
//  Arguments:
//      rstrDir     [OUT] Directory string.
//      idsFormat   [IN] Resource ID for the format string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::ConstructDefaultDirectory(
    OUT CString &   rstrDir,
    IN IDS          idsFormat
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESOURCE               _hres = NULL;
    DWORD                   _sc = ERROR_SUCCESS;
    DWORD                   _cbDiskInfo = sizeof(CLUSPROP_DWORD)
                                        + sizeof(CLUSPROP_SCSI_ADDRESS)
                                        + sizeof(CLUSPROP_DISK_NUMBER)
                                        + sizeof(CLUSPROP_PARTITION_INFO)
                                        + sizeof(CLUSPROP_SYNTAX);
    PBYTE                   _pbDiskInfo = NULL;
    CLUSPROP_BUFFER_HELPER  _cbh;

    // Get the first partition for the resource..
    try
    {
        // Get the storage-class resource on which we are dependent.
        _hres = GetDependentStorageResource();
        if (_hres == NULL)
            return;

        // Get disk info.
        _pbDiskInfo = new BYTE[_cbDiskInfo];
        _sc = ClusterResourceControl(
                        _hres,
                        NULL,
                        CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                        NULL,
                        0,
                        _pbDiskInfo,
                        _cbDiskInfo,
                        &_cbDiskInfo
                        );
        if (_sc == ERROR_MORE_DATA)
        {
            delete [] _pbDiskInfo;
            _pbDiskInfo = new BYTE[_cbDiskInfo];
            _sc = ClusterResourceControl(
                            _hres,
                            NULL,
                            CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                            NULL,
                            0,
                            _pbDiskInfo,
                            _cbDiskInfo,
                            &_cbDiskInfo
                            );
        }  // if:  buffer too small
        if (_sc == ERROR_SUCCESS)
        {
            // Find the first partition.
            _cbh.pb = _pbDiskInfo;
            while (_cbh.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
            {
                if (_cbh.pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO)
                {
                    rstrDir.FormatMessage(
                                        idsFormat,
                                        _cbh.pPartitionInfoValue->szDeviceName
                                        );
                    break;
                }  // if:  found a partition
                _cbh.pb += sizeof(*_cbh.pValue) + ALIGN_CLUSPROP(_cbh.pValue->cbLength);
            }  // while:  not at end of list
        } // if:  no error getting disk info
        else
        {
            CNTException nte( _sc, IDS_ERROR_CONSTRUCTING_DEF_DIR );
            nte.ReportError();
        } // else:  error getting disk info
    }  // try
    catch (CMemoryException * _pme)
    {
        _pme->Delete();
    }  // catch:  CMemoryException

    CloseClusterResource(_hres);
    delete [] _pbDiskInfo;

}  //*** CBasePropertyPage::ConstructDefaultDirectory()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::GetDependentStorageResource
//
//  Routine Description:
//      Construct a default spool directory based on the drive on which
//      this resource is dependent and a default value for the directory.
//
//  Arguments:
//      phres       [OUT] Handle to dependent resource.
//
//  Return Value:
//      HRESOURCE for the open dependent resource, or NULL if error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESOURCE CBasePropertyPage::GetDependentStorageResource(void)
{
    DWORD                       _sc = ERROR_SUCCESS;
    HRESENUM                    _hresenum;
    HRESOURCE                   _hres = NULL;
    DWORD                       _ires;
    DWORD                       _dwType;
    DWORD                       _cchName;
    DWORD                       _cchNameSize;
    LPWSTR                      _pszName = NULL;
    CLUS_RESOURCE_CLASS_INFO    _classinfo;
    DWORD                       _cbClassInfo;

    // Open the dependency enumerator.
    _hresenum = ClusterResourceOpenEnum(
                        Peo()->PrdResData()->m_hresource,
                        CLUSTER_RESOURCE_ENUM_DEPENDS
                        );
    if (_hresenum == NULL)
        return NULL;

    // Allocate a default size name buffer.
    _cchNameSize = 512;
    _pszName = new WCHAR[_cchNameSize];

    for (_ires = 0 ; ; _ires++)
    {
        // Get the name of the next resource.
        _cchName = _cchNameSize;
        _sc = ClusterResourceEnum(
                            _hresenum,
                            _ires,
                            &_dwType,
                            _pszName,
                            &_cchName
                            );
        if (_sc == ERROR_MORE_DATA)
        {
            delete [] _pszName;
            _cchNameSize = _cchName;
            _pszName = new WCHAR[_cchNameSize];
            _sc = ClusterResourceEnum(
                                _hresenum,
                                _ires,
                                &_dwType,
                                _pszName,
                                &_cchName
                                );
        }  // if:  name buffer too small
        if (_sc != ERROR_SUCCESS)
            break;

        // Open the resource.
        _hres = OpenClusterResource(Hcluster(), _pszName);
        if (_hres == NULL)
        {
            _sc = GetLastError();
            break;
        }  // if:  error opening the resource

        // Get the class of the resource.
        _sc = ClusterResourceControl(
                            _hres,
                            NULL,
                            CLUSCTL_RESOURCE_GET_CLASS_INFO,
                            NULL,
                            0,
                            &_classinfo,
                            sizeof(_classinfo),
                            &_cbClassInfo
                            );
        if (_sc != ERROR_SUCCESS)
        {
            CNTException nte( _sc, IDS_ERROR_GET_CLASS_INFO, _pszName, NULL, FALSE /*bAutoDelete*/ );
            nte.ReportError();
            continue;
        }

        // If this is a storage-class resource, we're done.
        if (_classinfo.rc == CLUS_RESCLASS_STORAGE)
            break;

        // Not storage-class resource.
        CloseClusterResource(_hres);
        _hres = NULL;
    }  // for each resource on which we are dependent

    // Handle errors.
    if ((_sc != ERROR_SUCCESS) && (_hres != NULL))
    {
        CloseClusterResource(_hres);
        _hres = NULL;
    }  // if:  error getting resource

    // Cleanup.
    ClusterResourceCloseEnum(_hresenum);
    delete [] _pszName;

    return _hres;

}  //*** CBasePropertyPage::GetDependentStorageResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BGetClusterNetworkNameNode
//
//  Routine Description:
//      Get the node hosting the Network Name resource.
//
//  Arguments:
//      rstrNode    [OUT] - receives the node name
//
//  Return Value:
//      BOOL -- TRUE for success, FALSE for error
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BGetClusterNetworkNameNode( OUT CString & rstrNode )
{
    BOOL                    _bSuccess = TRUE;
    DWORD                   _sc;
    DWORD                   _dwFlag;
    DWORD                   _cbData;
    DWORD                   _ires;
    DWORD                   _dwType;
    DWORD                   _cchName = 0;
    DWORD                   _cchNameCurrent;
    LPWSTR                  _pszName = NULL;
    WCHAR                   _szResType[sizeof(CLUS_RESTYPE_NAME_NETNAME) / sizeof(WCHAR)];
    WCHAR                   _szNode[MAX_COMPUTERNAME_LENGTH+1];
    HCLUSENUM               _hclusenum = NULL;
    HRESOURCE               _hresource = NULL;
    CLUSTER_RESOURCE_STATE  _crs;
    CWaitCursor             _wc;

    try
    {
        // Open a cluster enumerator.
        _hclusenum = ClusterOpenEnum( Hcluster(), CLUSTER_ENUM_RESOURCE );
        if (_hclusenum == NULL)
        {
            ThrowStaticException( GetLastError() );
        }

        // Allocate an initial buffer.
        _cchName = 256;
        _pszName = new WCHAR[_cchName];

        // Loop through each resource.
        for ( _ires = 0 ; ; _ires++ )
        {
            // Get the next resource.
            _cchNameCurrent = _cchName;
            _sc = ClusterEnum( _hclusenum, _ires, &_dwType, _pszName, &_cchNameCurrent );
            if ( _sc == ERROR_MORE_DATA )
            {
                delete [] _pszName;
                _cchName = ++_cchNameCurrent;
                _pszName = new WCHAR[_cchName];
                _sc = ClusterEnum(_hclusenum, _ires, &_dwType, _pszName, &_cchNameCurrent);
            }  // if:  buffer too small
            if (_sc == ERROR_NO_MORE_ITEMS)
                break;
            if (_sc != ERROR_SUCCESS)
                ThrowStaticException(_sc);

            // Open the resource.
            _hresource = OpenClusterResource(Hcluster(), _pszName);
            if (_hresource == NULL)
                ThrowStaticException(GetLastError());

            // Get its flags.
            _sc = ClusterResourceControl(
                                    _hresource,
                                    NULL,
                                    CLUSCTL_RESOURCE_GET_FLAGS,
                                    NULL,
                                    0,
                                    &_dwFlag,
                                    sizeof(DWORD),
                                    &_cbData
                                    );
            if (_sc != ERROR_SUCCESS)
            {
                CNTException nte( _sc, IDS_ERROR_GET_RESOURCE_FLAGS, _pszName, NULL, FALSE /*bAutoDelete*/ );
                nte.ReportError();
                continue;
            }

            // If this isn't a core resource, skip it.
            if ((_dwFlag & CLUS_FLAG_CORE) == 0)
                continue;

            // Get its resource type name.  If the buffer is too small,
            // it isn't a Network Name resource so skip it.
            _sc = ClusterResourceControl(
                                    _hresource,
                                    NULL,
                                    CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                                    NULL,
                                    0,
                                    _szResType,
                                    sizeof(_szResType),
                                    &_cbData
                                    );
            if (_sc == ERROR_MORE_DATA)
                continue;
            if (_sc != ERROR_SUCCESS)
                ThrowStaticException(_sc);

            // If this is a Network Name resource, get which node it is online on.
            if (lstrcmpiW(_szResType, CLUS_RESTYPE_NAME_NETNAME) == 0)
            {
                // Get the state of the resource.
                _crs = GetClusterResourceState(
                                    _hresource,
                                    _szNode,
                                    &_cchName,
                                    NULL,
                                    NULL
                                    );
                if (_crs == ClusterResourceStateUnknown)
                    ThrowStaticException(GetLastError());

                // Save the node name in the return argument.
                rstrNode = _szNode;

                break;
            }  // if:  Network Name resource

            CloseClusterResource( _hresource );
            _hresource = NULL;
        }  // for:  each resource

        if (rstrNode[0] == _T('\0'))
            ThrowStaticException(ERROR_FILE_NOT_FOUND, (IDS) 0);
    }  // try
    catch (CException * _pe)
    {
        _pe->ReportError();
        _pe->Delete();
        _bSuccess = FALSE;
    }  // catch:  CException

    delete [] _pszName;

    if ( _hresource != NULL )
    {
        CloseClusterResource( _hresource );
    } // if: resource is open
    if ( _hclusenum != NULL )
    {
        ClusterCloseEnum( _hclusenum );
    } // if: enumerator is open

    return _bSuccess;

}  //*** CBasePropertyPage::BGetClusterNetworkNameNode()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\basepage.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BasePage.inl
//
//	Abstract:
//		Implementation of inline methods of the CBasePropertyPage class.
//
//	Author:
//		David Potter (davidp)	October 2, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_INL_
#define _BASEPAGE_INL_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////

IWCWizardCallback * CBasePropertyPage::PiWizardCallback(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->PiWizardCallback();
}

BOOL CBasePropertyPage::BWizard(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->BWizard();
}

HCLUSTER CBasePropertyPage::Hcluster(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->Hcluster();
}

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\basepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      BasePage.h
//
//  Abstract:
//      Definition of the CBasePropertyPage class.  This class provides base
//      functionality for extension DLL property pages.
//
//  Implementation File:
//      BasePage.cpp
//      BasePage.inl
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#define _BASEPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _DLGHELP_H_
#include "DlgHelp.h"    // for CDialogHelp
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CClusPropList, CObjectProperty
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
interface IWCWizardCallback;

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE( CBasePropertyPage )

// Construction
public:
    CBasePropertyPage( void );
    CBasePropertyPage(
        IN const DWORD *    pdwHelpMap,
        IN const DWORD *    pdwWizardHelpMap
        );
    CBasePropertyPage(
        IN UINT             idd,
        IN const DWORD *    pdwHelpMap,
        IN const DWORD *    pdwWizardHelpMap,
        IN UINT             nIDCaption = 0
        );
    virtual ~CBasePropertyPage( void ) { }

    // Second phase construction.
    virtual HRESULT         HrInit( IN OUT CExtObject * peo );

protected:
    void                    CommonConstruct( void );

// Attributes
protected:
    CExtObject *            m_peo;
    HPROPSHEETPAGE          m_hpage;

    IDD                     m_iddPropertyPage;
    IDD                     m_iddWizardPage;
    IDS                     m_idsCaption;

    CExtObject *            Peo( void ) const               { return m_peo; }
    HPROPSHEETPAGE          Hpage( void ) const             { return m_hpage; }

    IDD                     IddPropertyPage( void ) const   { return m_iddPropertyPage; }
    IDD                     IddWizardPage( void ) const     { return m_iddWizardPage; }
    IDS                     IdsCaption( void ) const        { return m_idsCaption; }

public:
    void                    SetHpage( IN OUT HPROPSHEETPAGE hpage ) { m_hpage = hpage; }

// Dialog Data
    //{{AFX_DATA(CBasePropertyPage)
    enum { IDD = 0 };
    //}}AFX_DATA
    CStatic m_staticIcon;
    CStatic m_staticTitle;
    CString m_strTitle;

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CBasePropertyPage)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnApply();
    virtual LRESULT OnWizardBack();
    virtual LRESULT OnWizardNext();
    virtual BOOL OnWizardFinish();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    virtual DWORD           ScParseUnknownProperty(
                                IN LPCWSTR                          pwszName,
                                IN const CLUSPROP_BUFFER_HELPER &   rvalue,
                                IN DWORD                            cbBuf
                                )       { return ERROR_SUCCESS; }
    virtual BOOL            BApplyChanges( void );
    virtual BOOL            BBuildPropList( IN OUT CClusPropList & rcpl, IN BOOL bNoNewProps = FALSE );
    virtual void            DisplaySetPropsError( IN DWORD sc, IN UINT idsOper ) const;

    virtual const CObjectProperty * Pprops( void ) const    { return NULL; }
    virtual DWORD                   Cprops( void ) const    { return 0; }

// Implementation
protected:
    BOOL                    m_bBackPressed;
    BOOL                    m_bSaved;
    const DWORD *           m_pdwWizardHelpMap;
    BOOL                    m_bDoDetach;

    BOOL                    BGetClusterNetworkNameNode( OUT CString & rstrNode );
    BOOL                    BBackPressed( void ) const      { return m_bBackPressed; }
    BOOL                    BSaved( void ) const            { return m_bSaved; }
    IWCWizardCallback *     PiWizardCallback( void ) const;
    BOOL                    BWizard( void ) const;
    HCLUSTER                Hcluster( void ) const;
    void                    EnableNext( IN BOOL bEnable = TRUE );

    BOOL                    BRequiredDependenciesPresent( void );

    DWORD                   ScParseProperties( IN CClusPropList & rcpl );
    BOOL                    BSetPrivateProps(
                                IN BOOL             bValidateOnly = FALSE,
                                IN BOOL             bNoNewProps = FALSE
                                );

    DWORD                   ScReadValue(
                                IN LPCTSTR          pszValueName,
                                OUT CString &       rstrValue,
                                IN HKEY             hkey
                                );
    DWORD                   ScReadValue(
                                IN LPCTSTR          pszValueName,
                                OUT DWORD *         pdwValue,
                                IN HKEY             hkey
                                );
    DWORD                   ScReadValue(
                                IN LPCTSTR          pszValueName,
                                OUT LPBYTE *        ppbValue,
                                IN HKEY             hkey
                                );

    DWORD                   ScWriteValue(
                                IN LPCTSTR          pszValueName,
                                IN const CString &  rstrValue,
                                IN OUT CString &    rstrPrevValue,
                                IN HKEY             hkey
                                );
    DWORD                   ScWriteValue(
                                IN LPCTSTR          pszValueName,
                                IN DWORD            dwValue,
                                IN OUT DWORD *      pdwPrevValue,
                                IN HKEY             hkey
                                );
    DWORD                   ScWriteValue(
                                IN LPCTSTR          pszValueName,
                                IN const LPBYTE     pbValue,
                                IN DWORD            cbValue,
                                IN OUT LPBYTE *     ppbPrevValue,
                                IN DWORD            cbPrevValue,
                                IN HKEY             hkey
                                );

    void                    SetHelpMask( IN DWORD dwMask )    { m_dlghelp.SetHelpMask(dwMask); }
    CDialogHelp             m_dlghelp;

    void                ConstructDefaultDirectory(
                                OUT CString &   rstrDir,
                                IN IDS          idsFormat
                                );
    HRESOURCE           GetDependentStorageResource( void );

    void                GetResTypeDisplayOrTypeName(
                                IN      LPCWSTR     pszResTypeNameIn,
                                IN OUT  CString *   pstrResTypeDisplayNameInOut
                                );

    // Generated message map functions
    //{{AFX_MSG(CBasePropertyPage)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG
    virtual afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg void OnChangeCtrl();
    DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertyPage

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList< CBasePropertyPage *, CBasePropertyPage * > CPageList;

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\cluadmx.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      CluAdmX.h
//
//  Description:
//      Global definitions across the DLL.
//
//  Implementation File:
//      CluAdmEx.cpp
//
//  Maintained By:
//      David Potter (davidp)   August 23, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define REGPARAM_NAME                           _T("Name")
#define REGPARAM_PARAMETERS                     _T("Parameters")
#define REGPARAM_TYPE                           _T("Type")
#define REGPARAM_NETWORKS                       _T("Networks")
#define REGPARAM_CONNECTS_CLIENTS               _T("ConnectsClients")

#define REGPARAM_DISKS_SIGNATURE                CLUSREG_NAME_PHYSDISK_SIGNATURE

#define REGPARAM_GENAPP_COMMAND_LINE            CLUSREG_NAME_GENAPP_COMMAND_LINE
#define REGPARAM_GENAPP_CURRENT_DIRECTORY       CLUSREG_NAME_GENAPP_CURRENT_DIRECTORY
#define REGPARAM_GENAPP_INTERACT_WITH_DESKTOP   CLUSREG_NAME_GENAPP_INTERACT_WITH_DESKTOP
#define REGPARAM_GENAPP_USE_NETWORK_NAME        CLUSREG_NAME_GENAPP_USE_NETWORK_NAME

#define REGPARAM_GENSCRIPT_SCRIPT_FILEPATH      CLUSREG_NAME_GENSCRIPT_SCRIPT_FILEPATH

#define REGPARAM_GENSVC_SERVICE_NAME            CLUSREG_NAME_GENSVC_SERVICE_NAME
#define REGPARAM_GENSVC_COMMAND_LINE            CLUSREG_NAME_GENSVC_STARTUP_PARAMS
#define REGPARAM_GENSVC_USE_NETWORK_NAME        CLUSREG_NAME_GENSVC_USE_NETWORK_NAME

#define REGPARAM_IPADDR_ADDRESS                 CLUSREG_NAME_IPADDR_ADDRESS
#define REGPARAM_IPADDR_SUBNET_MASK             CLUSREG_NAME_IPADDR_SUBNET_MASK
#define REGPARAM_IPADDR_NETWORK                 CLUSREG_NAME_IPADDR_NETWORK
#define REGPARAM_IPADDR_ENABLE_NETBIOS          CLUSREG_NAME_IPADDR_ENABLE_NETBIOS

#define REGPARAM_NETNAME_NAME                   CLUSREG_NAME_NETNAME_NAME
#define REGPARAM_NETNAME_REMAP_PIPE_NAMES       CLUSREG_NAME_NETNAME_REMAP_PIPE_NAMES
#define REGPARAM_NETNAME_REQUIRE_DNS            CLUSREG_NAME_NETNAME_REQUIRE_DNS 
#define REGPARAM_NETNAME_REQUIRE_KERBEROS       CLUSREG_NAME_NETNAME_REQUIRE_KERBEROS        
#define REGPARAM_NETNAME_STATUS_NETBIOS         CLUSREG_NAME_NETNAME_STATUS_NETBIOS
#define REGPARAM_NETNAME_STATUS_DNS             CLUSREG_NAME_NETNAME_STATUS_DNS
#define REGPARAM_NETNAME_STATUS_KERBEROS        CLUSREG_NAME_NETNAME_STATUS_KERBEROS

#define REGPARAM_PRINT                          _T("Printers")
#define REGPARAM_PRTSPOOL_DEFAULT_SPOOL_DIR     CLUSREG_NAME_PRTSPOOL_DEFAULT_SPOOL_DIR
#define REGPARAM_PRTSPOOL_TIMEOUT               CLUSREG_NAME_PRTSPOOL_TIMEOUT
#define REGPARAM_PRTSPOOL_DRIVER_DIRECTORY      CLUSREG_NAME_PRTSPOOL_DRIVER_DIRECTORY

#define REGPARAM_FILESHR_SHARE_NAME             CLUSREG_NAME_FILESHR_SHARE_NAME
#define REGPARAM_FILESHR_PATH                   CLUSREG_NAME_FILESHR_PATH
#define REGPARAM_FILESHR_REMARK                 CLUSREG_NAME_FILESHR_REMARK
#define REGPARAM_FILESHR_MAX_USERS              CLUSREG_NAME_FILESHR_MAX_USERS
#define REGPARAM_FILESHR_SECURITY               CLUSREG_NAME_FILESHR_SECURITY
#define REGPARAM_FILESHR_SD                     CLUSREG_NAME_FILESHR_SD
#define REGPARAM_FILESHR_SHARE_SUBDIRS          CLUSREG_NAME_FILESHR_SHARE_SUBDIRS
#define REGPARAM_FILESHR_HIDE_SUBDIR_SHARES     CLUSREG_NAME_FILESHR_HIDE_SUBDIR_SHARES
#define REGPARAM_FILESHR_IS_DFS_ROOT            CLUSREG_NAME_FILESHR_IS_DFS_ROOT
#define REGPARAM_FILESHR_CSC_CACHE              CLUSREG_NAME_FILESHR_CSC_CACHE

#define RESTYPE_NAME_GENERIC_APP                CLUS_RESTYPE_NAME_GENAPP
#define RESTYPE_NAME_GENERIC_SCRIPT             CLUS_RESTYPE_NAME_GENSCRIPT
#define RESTYPE_NAME_GENERIC_SERVICE            CLUS_RESTYPE_NAME_GENSVC
#define RESTYPE_NAME_NETWORK_NAME               CLUS_RESTYPE_NAME_NETNAME
#define RESTYPE_NAME_PHYS_DISK                  CLUS_RESTYPE_NAME_PHYS_DISK
#define RESTYPE_NAME_FT_SET                     CLUS_RESTYPE_NAME_FTSET
#define RESTYPE_NAME_PRINT_SPOOLER              CLUS_RESTYPE_NAME_PRTSPLR
#define RESTYPE_NAME_FILE_SHARE                 CLUS_RESTYPE_NAME_FILESHR
#define RESTYPE_NAME_IP_ADDRESS                 CLUS_RESTYPE_NAME_IPADDR

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

void FormatError(CString & rstrError, DWORD dwError);

extern const WCHAR g_wszResourceTypeNames[];
extern const DWORD g_cchResourceTypeNames;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\clusname.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      ClusName.cpp
//
//  Abstract:
//      Implementation of the CChangeClusterNameDlg class.
//
//  Author:
//      David Potter (davidp)   April 28, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ClusName.h"
#include "DDxDDv.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChangeClusterNameDlg dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CChangeClusterNameDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CChangeClusterNameDlg)
    ON_EN_CHANGE(IDC_CLUSNAME, OnChangeClusName)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CChangeClusterNameDlg::CChangeClusterNameDlg
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pParent         [IN] Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CChangeClusterNameDlg::CChangeClusterNameDlg(CWnd * pParent /*=NULL*/)
    : CBaseDialog(IDD, g_aHelpIDs_IDD_EDIT_CLUSTER_NAME, pParent)
{
    //{{AFX_DATA_INIT(CChangeClusterNameDlg)
    m_strClusName = _T("");
    //}}AFX_DATA_INIT

}  //*** CChangeClusterNameDlg::CChangeClusterNameDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CChangeClusterNameDlg::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CChangeClusterNameDlg::DoDataExchange(CDataExchange * pDX)
{
    CWaitCursor wc;
    CString     strClusName;

    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CChangeClusterNameDlg)
    DDX_Control(pDX, IDOK, m_pbOK);
    DDX_Control(pDX, IDC_CLUSNAME, m_editClusName);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        CLRTL_NAME_STATUS   cnStatus;

        //
        // get the name from the control into a temp variable
        //
        DDX_Text(pDX, IDC_CLUSNAME, strClusName);

        DDV_RequiredText(pDX, IDC_CLUSNAME, IDC_CLUSNAME_LABEL, m_strClusName);
        DDV_MaxChars(pDX, m_strClusName, MAX_CLUSTERNAME_LENGTH);

        //
        // Only do work if the names are different.
        //
        if ( m_strClusName != strClusName )
        {
            //
            // Check to see if the new name is valid
            //
            if( !ClRtlIsNetNameValid(strClusName, &cnStatus, FALSE /*CheckIfExists*/) )
            {
                //
                // The net name is not valid.  Display a message box with the error.
                //
                CString     strMsg;
                UINT        idsError;

                AFX_MANAGE_STATE(AfxGetStaticModuleState());

                switch (cnStatus)
                {
                    case NetNameTooLong:
                        idsError = IDS_INVALID_NETWORK_NAME_TOO_LONG;
                        break;
                    case NetNameInvalidChars:
                        idsError = IDS_INVALID_NETWORK_NAME_INVALID_CHARS;
                        break;
                    case NetNameInUse:
                        idsError = IDS_INVALID_NETWORK_NAME_IN_USE;
                        break;
                    case NetNameDNSNonRFCChars:
                        idsError = IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS;
                        break;
                    default:
                        idsError = IDS_INVALID_NETWORK_NAME;
                        break;
                }  // switch:  cnStatus

                strMsg.LoadString(idsError);

                if ( idsError == IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS )
                {
                    int id = AfxMessageBox(strMsg, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION );

                    if ( id == IDNO )
                    {
                        strMsg.Empty();
                        pDX->Fail();
                    }
                }
                else
                {
                    AfxMessageBox(strMsg, MB_ICONEXCLAMATION);
                    strMsg.Empty(); // exception prep
                    pDX->Fail();
                }
            }  // if:  netname has changed and an invalid network name was specified
            else
            {
                //
                // A valid netname was entered - save it
                //
                m_strClusName = strClusName;
            }
        } // if:    names are different
    }  // if:  saving data from dialog
    else
    {
        //
        // populate the control with data from the member variable
        //
        DDX_Text(pDX, IDC_CLUSNAME, m_strClusName);
    }
}  //*** CChangeClusterNameDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CChangeClusterNameDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CChangeClusterNameDlg::OnInitDialog(void)
{
    CBaseDialog::OnInitDialog();

    if (m_strClusName.GetLength() == 0)
        m_pbOK.EnableWindow(FALSE);

    m_editClusName.SetLimitText(MAX_CLUSTERNAME_LENGTH);

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CChangeClusterNameDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CChangeClusterNameDlg::OnChangeClusName
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Name edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CChangeClusterNameDlg::OnChangeClusName(void)
{
    BOOL    bEnable;

    bEnable = (m_editClusName.GetWindowTextLength() > 0);
    m_pbOK.EnableWindow(bEnable);

}  //*** CChangeClusterNameDlg::OnChangeClusName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\cluadmex.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      CluAdmEx.cpp
//
//  Abstract:
//      Implementation of the CCluAdmExApp class and DLL initialization
//      routines.
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <aclui.h>      // for ISecurityInformation
#include <CluAdmEx.h>
#include "CluAdmX.h"
#include "ExtObj.h"
#include "RegExt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IID_DEFINED
#include "ExtObjID_i.c"

CComModule _Module;

#pragma warning(disable : 4701) // local variable may be used without having been initialized
#include <atlimpl.cpp>
#pragma warning(default : 4701)

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CoCluAdmEx, CExtObject)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppv);
STDAPI DllCanUnloadNow(void);
STDAPI DllRegisterServer(void);
STDAPI DllUnregisterServer(void);
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hcluster);
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hcluster);

/////////////////////////////////////////////////////////////////////////////
// class CCluAdmExApp
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
};

CCluAdmExApp theApp;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExApp::InitInstance
//
//  Routine Description:
//      Initialize this instance of the application.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Application initialized successfully.
//      FALSE       Error initializing application.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCluAdmExApp::InitInstance(void)
{
    _Module.Init(ObjectMap, m_hInstance);

    // Construct the help path.
    {
        TCHAR szPath[_MAX_PATH];
        TCHAR szDrive[_MAX_PATH];
        TCHAR szDir[_MAX_DIR];
        int cchPath;
        VERIFY(::GetSystemWindowsDirectory(szPath, _MAX_PATH));
        cchPath = lstrlen(szPath);
        if (szPath[cchPath - 1] != _T('\\'))
        {
            szPath[cchPath++] = _T('\\');
            szPath[cchPath] = _T('\0');
        } // if: no backslash on the end of the path
        lstrcpy(&szPath[cchPath], _T("Help\\"));
        _tsplitpath(szPath, szDrive, szDir, NULL, NULL);
        _tmakepath(szPath, szDrive, szDir, _T("cluadmin"), _T(".hlp"));
        free((void *) m_pszHelpFilePath);
        BOOL bEnable;
        bEnable = AfxEnableMemoryTracking(FALSE);
        m_pszHelpFilePath = _tcsdup(szPath);
        AfxEnableMemoryTracking(bEnable);
    }  // Construct the help path

    return CWinApp::InitInstance();

}  //*** CCluAdmExApp::InitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExApp::ExitInstance
//
//  Routine Description:
//      Cleans up this instance of the application.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Application's exit code.  0 indicates no errors.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CCluAdmExApp::ExitInstance(void)
{
    _Module.Term();
    return CWinApp::ExitInstance();

}  //*** CCluAdmExApp::ExitInstance()

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow() && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE /*bRegTypeLib*/);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//  FormatError
//
//  Routine Description:
//      Format an error.
//
//  Arguments:
//      rstrError   [OUT] String in which to return the error message.
//      dwError     [IN] Error code to format.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void FormatError(CString & rstrError, DWORD dwError)
{
    DWORD   _cch;
    TCHAR   _szError[512];

    _cch = FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    dwError,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                    _szError,
                    sizeof(_szError) / sizeof(TCHAR),
                    0
                    );
    if (_cch == 0)
    {
        // Format the NT status code from NTDLL since this hasn't been
        // integrated into the system yet.
        _cch = FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                        ::GetModuleHandle(_T("NTDLL.DLL")),
                        dwError,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                        _szError,
                        sizeof(_szError) / sizeof(TCHAR),
                        0
                        );

        if (_cch == 0)    
        {
            // One last chance: see if ACTIVEDS.DLL can format the status code
            HMODULE activeDSHandle = ::LoadLibrary(_T("ACTIVEDS.DLL"));

            _cch = FormatMessage(
                            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                            activeDSHandle,
                            dwError,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                            _szError,
                            sizeof(_szError) / sizeof(TCHAR),
                            0
                            );

            ::FreeLibrary( activeDSHandle );
        }  // if:  error formatting status code from NTDLL
    }  // if:  error formatting status code from system

    if (_cch > 0)
    {
        rstrError = _szError;
    }  // if:  no error
    else
    {

#ifdef _DEBUG

        DWORD   _sc = GetLastError();

        TRACE(_T("FormatError() - Error 0x%08.8x formatting string for error code 0x%08.8x\n"), _sc, dwError);

#endif

        rstrError.Format(_T("Error 0x%08.8x"), dwError);

    }  // else:  error formatting the message

}  //*** FormatError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllRegisterCluAdminExtension
//
//  Routine Description:
//      Register the extension with the cluster database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hCluster)
{
    HRESULT     hr;
    HRESULT     hrReturn = S_OK;
    LPCWSTR     pwszResTypes = g_wszResourceTypeNames;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    hrReturn = RegisterCluAdminClusterExtension(
                hCluster,
                &CLSID_CoCluAdmEx
                );
    if (S_OK == hrReturn)
    {
        while (*pwszResTypes != L'\0')
        {
            wprintf(L"  %s\n", pwszResTypes);
            hr = RegisterCluAdminResourceTypeExtension(
                        hCluster,
                        pwszResTypes,
                        &CLSID_CoCluAdmEx
                        );
            if (hr != S_OK)
                hrReturn = hr;
            pwszResTypes += lstrlenW(pwszResTypes) + 1;
        }  // while:  more resource types
    }

    return hrReturn;

}  //*** DllRegisterCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllUnregisterCluAdminExtension
//
//  Routine Description:
//      Unregister the extension with the cluster database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hCluster)
{
    HRESULT     hr;
    HRESULT     hrReturn = S_OK;
    LPCWSTR     pwszResTypes = g_wszResourceTypeNames;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    hrReturn = UnregisterCluAdminClusterExtension(
                hCluster,
                &CLSID_CoCluAdmEx
                );
    if (S_OK == hrReturn)
    {
        while (*pwszResTypes != L'\0')
        {
            wprintf(L"  %s\n", pwszResTypes);
            hr = UnregisterCluAdminResourceTypeExtension(
                        hCluster,
                        pwszResTypes,
                        &CLSID_CoCluAdmEx
                        );
            if (hr != S_OK)
                hrReturn = hr;
            pwszResTypes += lstrlenW(pwszResTypes) + 1;
        }  // while:  more resource types
    }

    return hrReturn;

}  //*** DllUnregisterCluAdminExtension()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\cluspage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  Module Name:
//      ClusPage.cpp
//
//  Abstract:
//      CClusterSecurityPage class implementation.  This class will encapsulate
//      the cluster security extension page.
//
//  Author:
//      Galen Barbee    (galenb)    February 11, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "ClusPage.h"
#include "AclUtils.h"
#include <clusudef.h>

static GENERIC_MAPPING ShareMap =
{
    CLUSAPI_READ_ACCESS,
    CLUSAPI_CHANGE_ACCESS,
    CLUSAPI_NO_ACCESS,
    CLUSAPI_ALL_ACCESS
};

static SI_ACCESS siClusterAccesses[] =
{
    { &GUID_NULL, CLUSAPI_ALL_ACCESS, MAKEINTRESOURCE(IDS_ACLEDIT_PERM_GEN_ALL), SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC /*| OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE*/ }
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityInformation::CClusterSecurityInformation
//
//  Routine Description:
//      Default contructor
//
//  Arguments:
//      none
//
//  Return Value:
//      none
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterSecurityInformation::CClusterSecurityInformation( void )
    : m_pcsp( NULL )
{
    m_pShareMap     = &ShareMap;
    m_psiAccess     = (SI_ACCESS *) &siClusterAccesses;
    m_nAccessElems  = ARRAYSIZE( siClusterAccesses );
    m_nDefAccess    = 0;
    m_dwFlags       =   SI_EDIT_PERMS
                      | SI_NO_ACL_PROTECT
                      //| SI_UGOP_PROVIDED
                      //| SI_NO_UGOP_ACCOUNT_GROUPS
                      //| SI_NO_UGOP_USERS
                      //| SI_NO_UGOP_LOCAL_GROUPS
                      //| SI_NO_UGOP_WELLKNOWN
                      //| SI_NO_UGOP_BUILTIN
                      ;

} //*** CClusterSecurityInformation::CClusterSecurityInformation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityInformation::GetSecurity
//
//  Routine Description:
//      Give our security descriptor to the ISecurityInfomation UI
//      so it can be displayed and edited.
//
//  Arguments:
//      RequestedInformation    [IN]
//      ppSecurityDescriptor    [IN OUT]
//      fDefault                [IN]
//
//  Return Value:
//      E_FAIL for error and S_OK for success.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterSecurityInformation::GetSecurity(
    IN      SECURITY_INFORMATION RequestedInformation,
    IN OUT  PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
    IN      BOOL fDefault
    )
{
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    HRESULT hr = E_FAIL;

    try
    {
        if ( ppSecurityDescriptor != NULL )
        {
            PSECURITY_DESCRIPTOR    pSD = NULL;

            pSD = ClRtlCopySecurityDescriptor( Pcsp()->Psec() );
            if ( pSD != NULL )
            {
                //hr = HrFixupSD( pSD );
                //if ( SUCCEEDED( hr ) )
                //{
                    *ppSecurityDescriptor = pSD;
                //}
                hr = S_OK;
            } // if: no errors copying the security descriptor
            else
            {
                hr = GetLastError();
                TRACE( _T("CClusterSecurityInformation::GetSecurity() - Error %08.8x copying the security descriptor.\n"), hr );
                hr = HRESULT_FROM_WIN32( hr );
            } // else: error copying the security descriptor
        }
        else
        {
            hr = S_OK;
        } // else: no security descriptor pointer
    }
    catch ( ... )
    {
        TRACE( _T("CClusterSecurityInformation::GetSecurity() - Unknown error occurred.\n") );
    }

    return hr;

} //*** CClusterSecurityInformation::GetSecurity()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityInformation::SetSecurity
//
//  Routine Description:
//      ISecurityInformation is giving back the edited security descriptor.
//
//  Arguments:
//      SecurityInformation [IN]
//      pSecurityDescriptor [IN OUT]
//
//  Return Value:
//      E_FAIL for error and S_OK for success.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterSecurityInformation::SetSecurity(
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    HRESULT hr = E_FAIL;
    PSID    pSystemSid = NULL;
    PSID    pAdminSid = NULL;
    PSID    pServiceSid = NULL;

    try
    {
        SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;

        hr = CSecurityInformation::SetSecurity( SecurityInformation, pSecurityDescriptor );
        if ( hr == S_OK )
        {
            if ( AllocateAndInitializeSid(
                        &siaNtAuthority,
                        1,
                        SECURITY_LOCAL_SYSTEM_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &pSystemSid
                        ) )
            {
                CString strMsg;

                if ( BSidInSD( pSecurityDescriptor, pSystemSid ) )
                {
                    //
                    // allocate and init the Administrators group sid
                    //
                    if ( AllocateAndInitializeSid(
                                &siaNtAuthority,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                DOMAIN_ALIAS_RID_ADMINS,
                                0, 0, 0, 0, 0, 0,
                                &pAdminSid
                                ) )
                    {
                        if ( BSidInSD( pSecurityDescriptor, pAdminSid ) )
                        {
                            //
                            // allocate and init the Service sid
                            //
                            if ( AllocateAndInitializeSid(
                                        &siaNtAuthority,
                                        1,
                                        SECURITY_SERVICE_RID,
                                        0, 0, 0, 0, 0, 0, 0,
                                        &pServiceSid
                                        ) )
                            {
                                if ( BSidInSD( pSecurityDescriptor, pServiceSid ) )
                                {
                                    hr = Pcsp()->HrSetSecurityDescriptor( pSecurityDescriptor );
                                } // if: service SID in the SD
                                else
                                {
                                    strMsg.LoadString( IDS_SERVICE_ACCOUNT_NOT_SPECIFIED );
                                    AfxMessageBox( strMsg, MB_OK | MB_ICONSTOP );

                                    hr = S_FALSE;   // if there are missing required accounts then return S_FALSE to keep AclUi alive.
                                } // else
                            } // if: allocate and init service SID
                        } // if: admin SID in the SD
                        else
                        {
                            strMsg.LoadString( IDS_ADMIN_ACCOUNT_NOT_SPECIFIED );
                            AfxMessageBox( strMsg, MB_OK | MB_ICONSTOP );

                            hr = S_FALSE;   // if there are missing required accounts then return S_FALSE to keep AclUi alive.
                        } // else
                    } // if: allocate and init admin SID
                } // if: system SID in the SD
                else
                {
                    strMsg.LoadString( IDS_SYS_ACCOUNT_NOT_SPECIFIED );
                    AfxMessageBox( strMsg, MB_OK | MB_ICONSTOP );

                    hr = S_FALSE;   // if there are missing required accounts then return S_FALSE to keep AclUi alive.
                } // else
            } // if: allocate and init system SID
        } // if: CSecurityInformation::SetSecurity() worked
    }
    catch( ... )
    {
        ;
    }

    if ( pSystemSid != NULL )
    {
        FreeSid( pSystemSid );
    }

    if ( pAdminSid != NULL )
    {
        FreeSid( pAdminSid );
    }

    return hr;

} //*** CClusterSecurityInformation::SetSecurity()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityInformation::HrInit
//
//  Routine Description:
//      Initialize method.
//
//  Arguments:
//      pcsp        [IN]    back pointer to parent property page wrapper
//      strServer   [IN]    cluster name
//
//  Return Value:
//      S_OK for success.  E_FAIL for failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityInformation::HrInit(
    IN CClusterSecurityPage *   pcsp,
    IN CString const &          strServer,
    IN CString const &          strNode
    )
{
    ASSERT( pcsp != NULL );
    ASSERT( strServer.GetLength() > 0 );
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    m_pcsp                      = pcsp;
    m_strServer                 = strServer;
    m_strNode                   = strNode;
    m_nLocalSIDErrorMessageID   = IDS_LOCAL_ACCOUNTS_SPECIFIED_CLUS;

    return S_OK;

} //*** CClusterSecurityInformation::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityInformation::BSidInSD
//
//  Routine Description:
//      Determines if there is an ACEs for the passed in SID in the
//      Security Descriptor (pSD) after the ACL editor has been called
//
//  Arguments:
//      pSD     [IN] - Security Descriptor to be checked.
//      pSid    [IN] - SID to look for
//
//  Return Value:
//      TRUE if an ACE for the SID was found, False otherwise.
//
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterSecurityInformation::BSidInSD(
    IN PSECURITY_DESCRIPTOR pSD,
    IN PSID                 pSid
    )
{
    BOOL    bSIdInACL = FALSE;

    try
    {
        PACL    pDACL           = NULL;
        BOOL    bHasDACL        = FALSE;
        BOOL    bDaclDefaulted  = FALSE;

        if ( ::GetSecurityDescriptorDacl( pSD, &bHasDACL, &pDACL, &bDaclDefaulted ) )
        {
            if ( bHasDACL && ( pDACL != NULL ) && ::IsValidAcl( pDACL ) )
            {
                ACL_SIZE_INFORMATION    asiAclSize;
                ACCESS_ALLOWED_ACE *    paaAllowedAce;

                if ( ::GetAclInformation( pDACL, (LPVOID) &asiAclSize, sizeof( asiAclSize ), AclSizeInformation ) )
                {
                    //
                    // Search the ACL for the SID
                    //
                    for ( DWORD dwCount = 0; dwCount < asiAclSize.AceCount; dwCount++ )
                    {
                        if ( ::GetAce( pDACL, dwCount, (LPVOID *) &paaAllowedAce ) )
                        {
                            if ( paaAllowedAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE )
                            {
                                if ( EqualSid( &paaAllowedAce->SidStart, pSid ) )
                                {
                                    bSIdInACL = TRUE;
                                    break;
                                } // if: EqualSid
                            } // if: is this an access allowed ace?
                        } // if: can we get the ace from the DACL?
                    } // for
                } // if: get ACL information
            } // if: is the ACL valid
        } // if: get the ACL from the SD
    }
    catch ( ... )
    {
        TRACE( _T("CClusterSecurityInformation::BSidInSD() - Unknown error occurred.\n") );
    }

    return bSIdInACL;

} //*** CClusterSecurityInformation::BSidInSD()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityInformation::HrFixupSD
//
//  Routine Description:
//      Performs any fixups to the SD that may be requrired.
//
//  Arguments:
//      pSD     [IN] - Security Descriptor to be checked.
//
//  Return Value:
//      S_OK, or other Win32 error
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityInformation::HrFixupSD(
    IN PSECURITY_DESCRIPTOR pSD
    )
{
    HRESULT hr = S_OK;
    PSID    pSystemSid = NULL;
    PSID    pAdminSid = NULL;

    try
    {
        SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;

        if ( AllocateAndInitializeSid( &siaNtAuthority,
                                       1,
                                       SECURITY_LOCAL_SYSTEM_RID,
                                       0, 0, 0, 0, 0, 0, 0,
                                       &pSystemSid ) )
        {
            if ( ! BSidInSD( pSD, pSystemSid ) )
            {
                HrAddSidToSD( &pSD, pSystemSid );
            } // if: system SID found in SD
        } // if: allocate system SID

        //
        // allocate and init the Administrators group sid
        //
        if ( AllocateAndInitializeSid(
                    &siaNtAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAdminSid
                    ) ) {
            if ( ! BSidInSD( pSD, pAdminSid ) )
            {
                HrAddSidToSD( &pSD, pAdminSid );
            } // if: admin SID found in SD
        } // if: allocate admin SID
    }
    catch ( ... )
    {
        TRACE( _T("CClusterSecurityInformation::HrFixupSD() - Unknown error occurred.\n") );
    }

    if ( pSystemSid != NULL )
    {
        FreeSid( pSystemSid );
    }

    if ( pAdminSid != NULL )
    {
        FreeSid( pAdminSid );
    }

    return hr;

} //*** CClusterSecurityInformation::HrFixupSD()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityInformation::HrAddSidToSD
//
//  Routine Description:
//      Adds the passed in SID to the DACL of the passed in SD
//
//  Arguments:
//      ppSD    [IN, OUT]   - Security Descriptor to be added to
//      PSid    [IN]        - SID to add
//
//  Return Value:
//      S_OK, or other Win32 error
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityInformation::HrAddSidToSD(
    IN OUT PSECURITY_DESCRIPTOR *   ppSD,
    IN     PSID                     pSid
    )
{
    HRESULT                 hr = S_OK;
    DWORD                   sc;
    SECURITY_DESCRIPTOR     sd;
    DWORD                   dwSDLen = sizeof( SECURITY_DESCRIPTOR );
    PACL                    pDacl = NULL;
    DWORD                   dwDaclLen = 0;
    PACL                    pSacl = NULL;
    DWORD                   dwSaclLen = 0;
    PSID                    pOwnerSid = NULL;
    DWORD                   dwOwnerSidLen = 0;
    PSID                    pGroupSid = NULL;
    DWORD                   dwGroupSidLen = NULL;
    PSECURITY_DESCRIPTOR    pNewSD = NULL;
    DWORD                   dwNewSDLen = 0;

    try
    {
        BOOL bRet = FALSE;

        bRet = ::MakeAbsoluteSD(    *ppSD,              // address of self relative SD
                                    &sd,                // address of absolute SD
                                    &dwSDLen,           // address of size of absolute SD
                                    NULL,               // address of discretionary ACL
                                    &dwDaclLen,         // address of size of discretionary ACL
                                    NULL,               // address of system ACL
                                    &dwSaclLen,         // address of size of system ACL
                                    NULL,               // address of owner SID
                                    &dwOwnerSidLen,     // address of size of owner SID
                                    NULL,               // address of primary-group SID
                                    &dwGroupSidLen      // address of size of group SID
                                    );
        if ( ! bRet )
        {
            sc = ::GetLastError();
            hr = HRESULT_FROM_WIN32( sc );
            if ( hr != ERROR_INSUFFICIENT_BUFFER )      // Duh, we're trying to find out how big the buffer should be?
            {
                goto fnExit;
            }
        }

        //
        // increase the DACL length to hold one more ace and its sid.
        //
        dwDaclLen += ( sizeof( ACCESS_ALLOWED_ACE ) + GetLengthSid( pSid ) +1024 );
        pDacl = (PACL) ::LocalAlloc( LMEM_ZEROINIT, dwDaclLen );
        if ( pDacl == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto fnExit;
        }

        InitializeAcl( pDacl,  dwDaclLen, ACL_REVISION );

        if ( dwSaclLen > 0 )
        {
            pSacl = (PACL) ::LocalAlloc( LMEM_ZEROINIT, dwSaclLen );
            if ( pSacl == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto fnExit;
            }
        }

        if ( dwOwnerSidLen > 0 )
        {
            pOwnerSid = (PSID) ::LocalAlloc( LMEM_ZEROINIT, dwOwnerSidLen );
            if ( pOwnerSid == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto fnExit;
            }
        }

        if ( dwGroupSidLen > 0 )
        {
            pGroupSid = (PSID) ::LocalAlloc( LMEM_ZEROINIT, dwGroupSidLen );
            if ( pGroupSid == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto fnExit;
            }
        }

        bRet = ::MakeAbsoluteSD(    *ppSD,              // address of self relative SD
                                    &sd,                // address of absolute SD
                                    &dwSDLen,           // address of size of absolute SD
                                    pDacl,              // address of discretionary ACL
                                    &dwDaclLen,         // address of size of discretionary ACL
                                    pSacl,              // address of system ACL
                                    &dwSaclLen,         // address of size of system ACL
                                    pOwnerSid,          // address of owner SID
                                    &dwOwnerSidLen,     // address of size of owner SID
                                    pGroupSid,          // address of primary-group SID
                                    &dwGroupSidLen      // address of size of group SID
                                    );
        if ( !bRet )
        {
            goto fnExit;
        }

        //
        // Add the ACE for the SID to the DACL
        //
//      if ( !AddAccessAllowedAceEx( pDacl,
//                                     ACL_REVISION,
//                                     CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
//                                     CLUSAPI_ALL_ACCESS,
//                                     pSid ) )
        if ( ! AddAccessAllowedAce(
                    pDacl,
                    ACL_REVISION,
                    CLUSAPI_ALL_ACCESS,
                    pSid
                    ) )
        {
            sc = ::GetLastError();
            hr = HRESULT_FROM_WIN32( sc );
            goto fnExit;
        }

        if ( ! ::SetSecurityDescriptorDacl( &sd, TRUE, pDacl, FALSE ) )
        {
            sc = ::GetLastError();
            hr = HRESULT_FROM_WIN32( sc );
            goto fnExit;
        }

        if ( ! ::SetSecurityDescriptorOwner( &sd, pOwnerSid, FALSE ) )
        {
            sc = ::GetLastError();
            hr = HRESULT_FROM_WIN32( sc );
            goto fnExit;
        }

        if ( ! ::SetSecurityDescriptorGroup( &sd, pGroupSid, FALSE ) )
        {
            sc = ::GetLastError();
            hr = HRESULT_FROM_WIN32( sc );
            goto fnExit;
        }

        if ( ! ::SetSecurityDescriptorSacl( &sd, TRUE, pSacl, FALSE ) )
        {
            sc = ::GetLastError();
            hr = HRESULT_FROM_WIN32( sc );
            goto fnExit;
        }

        dwNewSDLen = 0 ;

        if ( ! ::MakeSelfRelativeSD( &sd, NULL, &dwNewSDLen ) )
        {
            sc = ::GetLastError();
            hr = HRESULT_FROM_WIN32( sc );
            if ( hr != HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) ) // Duh, we're trying to find out how big the buffer should be?
            {
                goto fnExit;
            }
        }

        pNewSD = ::LocalAlloc( LPTR, dwNewSDLen );
        if ( pNewSD != NULL )
        {
            if ( ! ::MakeSelfRelativeSD( &sd, pNewSD, &dwNewSDLen ) )
            {
                sc = ::GetLastError();
                hr = HRESULT_FROM_WIN32( sc );
                goto fnExit;
            }

            ::LocalFree( *ppSD );
            *ppSD = pNewSD;
            hr = ERROR_SUCCESS;
        } else
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    catch ( ... )
    {
        TRACE( _T("CClusterSecurityInformation::HrAddSidToSD() - Unknown error occurred.\n") );
    }

fnExit:

    if ( pSacl != NULL )
    {
        ::LocalFree( pSacl );
    }

    if ( pOwnerSid != NULL )
    {
        ::LocalFree( pOwnerSid );
    }

    if ( pGroupSid != NULL )
    {
        ::LocalFree( pGroupSid );
    }

    return hr;

} //*** CClusterSecurityInformation::HrAddSidToSD()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::CClusterSecurityPage
//
//  Routine Description:
//      Default contructor.
//
//  Arguments:
//      none
//
//  Return Value:
//      none
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterSecurityPage::CClusterSecurityPage( void )
    : m_psec( NULL )
    , m_psecPrev( NULL )
    , m_hpage( 0 )
    , m_hkey( 0 )
    , m_psecinfo( NULL )
    , m_pOwner( NULL )
    , m_pGroup( NULL )
    , m_fOwnerDef( FALSE )
    , m_fGroupDef( FALSE )
{
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    m_bSecDescModified = FALSE;

} //*** CClusterSecurityPage::CClusterSecurityPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::~CClusterSecurityPage
//
//  Routine Description:
//      Destructor
//
//  Arguments:
//      none
//
//  Return Value:
//      none
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterSecurityPage::~CClusterSecurityPage( void )
{
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    ::LocalFree( m_psec );
    m_psec = NULL;

    ::LocalFree( m_psecPrev );
    m_psecPrev = NULL;

    ::LocalFree( m_pOwner );
    m_pOwner = NULL;

    ::LocalFree( m_pGroup );
    m_pGroup = NULL;

    m_psecinfo->Release();

} //*** CClusterSecurityPage::~CClusterSecurityPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrInit
//
//  Routine Description:
//      Initialize method.
//
//  Arguments:
//      peo     [IN]    back pointer to parent extension object.
//
//  Return Value:
//      S_OK        Page was initialized successfully.
//      hr          Error initializing the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrInit( IN CExtObject * peo )
{
    ASSERT( peo != NULL );
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    HRESULT _hr = S_OK;
    DWORD   _sc;

    if ( peo != NULL )
    {
        m_peo = peo;

        _hr = CComObject< CClusterSecurityInformation >::CreateInstance( &m_psecinfo );
        if ( SUCCEEDED( _hr ) )
        {
            m_psecinfo->AddRef();

            m_hkey = GetClusterKey( Hcluster(), KEY_ALL_ACCESS );
            if ( m_hkey != NULL )
            {
                _hr = HrGetSecurityDescriptor();
                if ( SUCCEEDED( _hr ) )
                {
                    CString strServer;
                    CString strNode;

                    strServer.Format( _T( "\\\\%s" ), StrClusterName() );

                    // Get the node on which the Cluster Name resource is online.
                    if ( BGetClusterNetworkNameNode( strNode ) )
                    {
                        _hr = m_psecinfo->HrInit( this, strServer, strNode );
                        if ( SUCCEEDED( _hr ) )
                        {
                            m_hpage = CreateClusterSecurityPage( m_psecinfo );
                            if ( m_hpage == NULL )
                            {
                                _sc = ::GetLastError();
                                _hr = HRESULT_FROM_WIN32( _sc );
                            } // if: error creating the page
                        } // if: initialized security info successfully
                    } // if: retrieved cluster network name node successfully
                    else
                    {
                    } // else: error getting cluster network name node
                } // if: error getting SD
            } // if: retrieved cluster key
            else
            {
                _sc = ::GetLastError();
                _hr = HRESULT_FROM_WIN32( _sc );
                TRACE( _T( "CClusterSecurityPage::ScInit() - Failed to get the cluster key, 0x%08lx.\n" ), _sc );
            } // else: error getting cluster key
        } // if: created security info object successfully
        else
        {
            TRACE( _T( "CClusterSecurityPage::ScInit() - Failed to create CClusterSecurityInformation object, %0x%08lx.\n" ), _hr );
        }
    } // if: extension object is available

    return _hr;

} //*** CClusterSecurityPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrGetSecurityDescriptor
//
//  Routine Description:
//      Get the security descriptor from the cluster database or create a
//      default one if it doesn't exist.
//
//  Arguments:
//      none
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrGetSecurityDescriptor( void )
{
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );
    HRESULT                 hr = S_OK;
    PSECURITY_DESCRIPTOR    psec = NULL;

    hr = HrGetSDFromClusterDB( &psec );                                             //uses localalloc
    if ( FAILED( hr ) || ( psec == NULL ) )
    {
        DWORD   sc;
        DWORD   dwLen = 0;

        TRACE( _T( "Security Descriptor is NULL.  Build default SD" ) );
        sc = ::ClRtlBuildDefaultClusterSD( NULL, &psec, &dwLen );                   //uses localalloc
        hr = HRESULT_FROM_WIN32( sc );

        if ( sc != ERROR_SUCCESS )
        {
            TRACE( _T( "ClRtlBuildDefaultClusterSD failed, 0x%08x" ), sc );
        } // if: error building the default SD
        hr = HRESULT_FROM_WIN32( sc );
    } // if: error getting SD from cluster database

    if ( SUCCEEDED( hr ) )
    {
        delete m_psec;
        m_psec = ClRtlCopySecurityDescriptor( psec );
        hr = GetLastError();                // Get the last error
        ::LocalFree( psec );
        psec = NULL;
        if ( m_psec == NULL )
        {
            hr = HRESULT_FROM_WIN32( hr );  // Convert to HRESULT
            goto Cleanup;
        } // if: error copying the security descriptor

        hr = HrGetSDOwner( m_psec );
        if ( SUCCEEDED( hr ) )
        {
            hr = HrGetSDGroup( m_psec );
            if ( SUCCEEDED( hr ) )
            {
                m_psecPrev = ClRtlCopySecurityDescriptor( m_psec );
                if ( m_psecPrev == NULL )
                {
                    hr = GetLastError();            // Get the last error
                    hr = HRESULT_FROM_WIN32( hr );  // Convert to HRESULT
                    goto Cleanup;
                } // if: error copying the security descriptor
            } // if: got SD group successfully
        } // if: got SD owner successfully
    } // if: retrieved or built SD successfully

#ifdef _DEBUG
    if ( m_psec != NULL )
    {
        ASSERT( IsValidSecurityDescriptor( m_psec ) );
    }
#endif

Cleanup:
    return hr;

} //*** CClusterSecurityPage::HrGetSecurityDescriptor()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrSetSecurityDescriptor
//
//  Routine Description:
//      Save the new security descriptor to the cluster database.
//
//  Arguments:
//      psec    [IN]    the new security descriptor
//
//  Return Value:
//      hr
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrSetSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR psec
    )
{
    ASSERT( psec != NULL );
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    HRESULT hr = S_OK;

    try
    {
        if ( psec != NULL )
        {
            CWaitCursor wc;

            ASSERT( IsValidSecurityDescriptor( psec ) );
            if ( IsValidSecurityDescriptor( psec ) )
            {
                hr = HrSetSDOwner( psec );
                if ( SUCCEEDED( hr ) )
                {
                    hr = HrSetSDGroup( psec );
                    if ( SUCCEEDED( hr ) )
                    {
                        LocalFree( m_psecPrev );
                        m_psecPrev = NULL;

                        if ( m_psec == NULL )
                        {
                            m_psecPrev = NULL;
                        } // if: no previous value
                        else
                        {
                            m_psecPrev = ClRtlCopySecurityDescriptor( m_psec );
                            if ( m_psecPrev == NULL )
                            {
                                hr = GetLastError();            // Get the last error
                                TRACE( _T( "CClusterSecurityPage::HrSetSecurityDescriptor() - Error %08.8x copying the previous SD.\n" ), hr );
                                hr = HRESULT_FROM_WIN32( hr );  // Convert to HRESULT
                                goto Cleanup;
                            } // if: error copying the security descriptor
                        } // else: previous value exists

                        LocalFree( m_psec );
                        m_psec = NULL;

                        m_psec = ClRtlCopySecurityDescriptor( psec );
                        if ( m_psec == NULL )
                        {
                            hr = GetLastError();            // Get the last error
                            TRACE( _T( "CClusterSecurityPage::HrSetSecurityDescriptor() - Error %08.8x copying the new SD.\n" ), hr );
                            hr = HRESULT_FROM_WIN32( hr );  // Convert to HRESULT
                            goto Cleanup;
                        } // if: error copying the security descriptor

                        SetPermissions( m_psec );
                    } // if: SD group set successfully
                } // if: SD owner set successfully
            } // if: security descriptor is valid
            else
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_SECURITY_DESCR );
                TRACE( _T( "CClusterSecurityPage::HrSetSecurityDescriptor() - Invalid security descriptor.\n" ) );
            } // else: invalid security descriptor
        } // if: security descriptor specified
        else
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_SECURITY_DESCR );
        } // else: no security descriptor specified
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
        TRACE( _T( "CClusterSecurityPage::HrSetSecurityDescriptor() - Unknown error occurred.\n" ) );
    }

Cleanup:
    return hr;

}  //*** CClusterSecurityPage::HrSetSecurityDescriptor()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::SetPermissions
//
//  Routine Description:
//      Set the permissions for accessing the cluster.
//
//  Arguments:
//      psec            [IN] Security descriptor.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusterItem::WriteValue().
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterSecurityPage::SetPermissions(
    IN const PSECURITY_DESCRIPTOR psec
)
{
    ASSERT( psec != NULL );
    ASSERT( IsValidSecurityDescriptor( psec ) );

    DWORD       cbNew;
    DWORD       cbOld;
    LPBYTE      psecPrev;       // buffer for use by ScWriteValue.  Prev SD is saved elsewhere now.

    // Get the length of the two security descriptors.
    if ( m_psecPrev == NULL )
    {
        cbOld = 0;
    }
    else
    {
        cbOld = ::GetSecurityDescriptorLength( m_psecPrev );
    }

    if ( psec == NULL )
    {
        cbNew = 0;
    }
    else
    {
        cbNew = ::GetSecurityDescriptorLength( psec );
    }

    // Allocate a new buffer for the previous data pointer.
    try
    {
        psecPrev = new BYTE [cbOld];
        if ( psecPrev == NULL )
        {
            return;
        } // if: error allocating previous data buffer
    }
    catch ( CMemoryException * )
    {
        return;
    }  // catch:  CMemoryException
    ::CopyMemory( psecPrev, m_psecPrev, cbOld );

    ScWriteValue( CLUSREG_NAME_CLUS_SD, (LPBYTE) psec, cbNew, (LPBYTE *) &psecPrev, cbOld, m_hkey );

    PSECURITY_DESCRIPTOR psd = ClRtlConvertClusterSDToNT4Format( psec );

    ScWriteValue( CLUSREG_NAME_CLUS_SECURITY, (LPBYTE) psd, cbNew, (LPBYTE *) &psecPrev, cbOld, m_hkey );
    ::LocalFree( psd );

    delete [] psecPrev;

}  //*** CClusterSecurityPage::SetPermissions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrGetSDOwner
//
//  Routine Description:
//      Get the owner sid and save it.
//
//  Arguments:
//      psec            [IN] Security descriptor.
//
//  Return Value:
//      hr
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrGetSDOwner(
    IN const PSECURITY_DESCRIPTOR psec
    )
{
    HRESULT hr      = S_OK;
    DWORD   sc;
    PSID    pOwner  = NULL;

    if ( ::GetSecurityDescriptorOwner( psec, &pOwner, &m_fOwnerDef ) != 0 )
    {
        // The security descriptor does not have an owner.
        if ( pOwner == NULL )
        {
            ::LocalFree( m_pOwner );
            m_pOwner = NULL;
        }
        else
        {
            DWORD   dwLen = ::GetLengthSid( pOwner );

            // copy the sid since AclUi will free the SD...
            hr = ::GetLastError();
            if ( SUCCEEDED( hr ) )
            {
                ::LocalFree( m_pOwner );

                m_pOwner = ::LocalAlloc( LMEM_ZEROINIT, dwLen );
                if ( m_pOwner != NULL )
                {
                    if ( ::CopySid( dwLen, m_pOwner, pOwner ) )
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        sc = ::GetLastError();
                        hr = HRESULT_FROM_WIN32( sc );
                    }
                }
                else
                {
                    sc = ::GetLastError();
                    hr = HRESULT_FROM_WIN32( sc );
                }
            }
        }
    }
    else
    {
        sc = ::GetLastError();
        hr = HRESULT_FROM_WIN32( sc );
    }

    return( hr );

}  //*** CClusterSecurityPage::HrGetSDOwner()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrGetSDGroup
//
//  Routine Description:
//      Get the group sid and save it.
//
//  Arguments:
//      psec            [IN] Security descriptor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrGetSDGroup(
    IN const PSECURITY_DESCRIPTOR psec
    )
{
    HRESULT hr      = S_OK;
    DWORD   sc;
    PSID    pGroup  = NULL;

    if ( ::GetSecurityDescriptorOwner( psec, &pGroup, &m_fOwnerDef ) != 0 )
    {
        // This SID does not contain group information.
        if ( pGroup == NULL )
        {
            ::LocalFree( m_pGroup );
            m_pGroup = NULL;
        }
        else
        {
            DWORD   dwLen = ::GetLengthSid( pGroup );

            // copy the sid since AclUi will free the SD...
            hr = ::GetLastError();
            if ( SUCCEEDED( hr ) )
            {
                ::LocalFree( m_pGroup );
                m_pGroup = ::LocalAlloc( LMEM_ZEROINIT, dwLen );
                if ( m_pGroup != NULL )
                {
                    if ( ::CopySid( dwLen, m_pGroup, pGroup ) )
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        sc = ::GetLastError();
                        hr = HRESULT_FROM_WIN32( sc );
                    }
                }
                else
                {
                    sc = ::GetLastError();
                    hr = HRESULT_FROM_WIN32( sc );
                }
            }
        }
    }
    else
    {
        sc = ::GetLastError();
        hr = HRESULT_FROM_WIN32( sc );
    }

    return( hr );

}  //*** CClusterSecurityPage::HrGetSDGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrSetSDOwner
//
//  Routine Description:
//      Set the owner sid.
//
//  Arguments:
//      psec            [IN] Security descriptor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrSetSDOwner(
    IN PSECURITY_DESCRIPTOR psec
    )
{
    HRESULT hr = S_OK;

    if ( !::SetSecurityDescriptorOwner( psec, m_pOwner, m_fOwnerDef ) )
    {
        DWORD sc = ::GetLastError();
        hr = HRESULT_FROM_WIN32( sc );
    }

    return( hr );

}  //*** CClusterSecurityPage::HrSetSDOwner()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrSetSDGroup
//
//  Routine Description:
//      Set the group sid.
//
//  Arguments:
//      psec            [IN] Security descriptor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrSetSDGroup(
    IN PSECURITY_DESCRIPTOR psec
    )
{
    HRESULT hr = S_OK;

    if ( !::SetSecurityDescriptorGroup( psec, m_pGroup, m_fGroupDef ) )
    {
        DWORD sc = ::GetLastError();
        hr = HRESULT_FROM_WIN32( sc );
    }

    return( hr );

}  //*** CClusterSecurityPage::HrSetSDGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrGetSDFromClusterDB
//
//  Routine Description:
//      Retrieve the SD from the cluster database.
//
//  Arguments:
//      ppsec           [OUT] Pointer to security descriptor.
//
//  Return Value:
//      S_OK for success
//      Any error returned by ScReadValue
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrGetSDFromClusterDB(
    OUT PSECURITY_DESCRIPTOR * ppsec
    )
{
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );
    ASSERT( ppsec != NULL );

    HRESULT                 hr = E_FAIL;
    PSECURITY_DESCRIPTOR    psd = NULL;

    if ( ppsec != NULL )
    {
        DWORD sc;

        // Read the security descriptor.
        sc = ScReadValue( CLUSREG_NAME_CLUS_SD, (LPBYTE *) &psd, m_hkey ); //alloc using new
        hr = HRESULT_FROM_WIN32( sc );

        if ( FAILED( hr ) || ( psd == NULL ) )
        {   // try getting the NT4 SD...
            sc = ScReadValue( CLUSREG_NAME_CLUS_SECURITY, (LPBYTE *) &psd, m_hkey ); //alloc using new
            hr = HRESULT_FROM_WIN32( sc );

            if ( SUCCEEDED( hr ) )
            {
                *ppsec = ::ClRtlConvertClusterSDToNT5Format( psd );
            }
        }
        else
        {
            *ppsec = ClRtlCopySecurityDescriptor( psd );
            if ( *ppsec == NULL )
            {
                hr = GetLastError();            // Get the last error
                hr = HRESULT_FROM_WIN32( hr );  // Convert to HRESULT
            } // if: error copying the security descriptor
        }

        delete [] psd;

        if ( *ppsec != NULL )
        {
            ::ClRtlExamineSD( *ppsec, "[ClusPage]" );
        } // if: security descriptor is available to be examined
    }

    return hr;

}  //*** CClusterSecurityPage::HrGetSDFromClusterDB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\cluspage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		ClusPage.h
//
//	Abstract:
//		CClusterSecurityPage class declaration.  This class will encapsulate
//		the cluster security extension page.
//
//	Implementation File:
//		ClusPage.cpp
//
//	Author:
//		Galen Barbee	(galenb)	February 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSPAGE_H_
#define _CLUSPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif //_BASEPAGE_H_

#ifndef _ACLBASE_H_
#include "AclBase.h"
#endif //_ACLBASE_H_

#include "ExtObj.h"

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterSecurityPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CClusterSecurityInformation security information
/////////////////////////////////////////////////////////////////////////////

class CClusterSecurityInformation : public CSecurityInformation
{
	STDMETHOD(GetSecurity)(
		SECURITY_INFORMATION	RequestedInformation,
		PSECURITY_DESCRIPTOR *	ppSecurityDescriptor,
		BOOL					fDefault
		);
	STDMETHOD(SetSecurity)(
		SECURITY_INFORMATION	SecurityInformation,
		PSECURITY_DESCRIPTOR	pSecurityDescriptor
		);

public:
	CClusterSecurityInformation( void );
	virtual ~CClusterSecurityInformation( void )
	{
	} //*** ~CClusterSecurityInformation()

	HRESULT	HrInit( CClusterSecurityPage * pcsp, CString const & strServer, CString const & strNode );

protected:
	CClusterSecurityPage*	m_pcsp;

	BOOL BSidInSD( IN PSECURITY_DESCRIPTOR pSD, IN PSID pSid );
	HRESULT HrFixupSD( IN PSECURITY_DESCRIPTOR pSD );
	HRESULT HrAddSidToSD( IN OUT PSECURITY_DESCRIPTOR * ppSD, IN PSID pSid );

	CClusterSecurityPage*	Pcsp( void ) { return m_pcsp; };

}; //*** class CClusterSecurityInformation

/////////////////////////////////////////////////////////////////////////////
// CClusterSecurityPage security property page wrapper
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// KB: GalenB 18 Feb 1998
// This class only derives from CBasePropertyPage to get the
//  DwRead() and DwWrite() methods.  There is no hpage for this page in the
//  parent sheet.
/////////////////////////////////////////////////////////////////////////////

class CClusterSecurityPage : public CBasePropertyPage
{
public:
	CClusterSecurityPage( void );
	~CClusterSecurityPage( void );

			HRESULT					HrInit( IN CExtObject* peo );
	const	HPROPSHEETPAGE			GetHPage( void ) const		{ return m_hpage; };
	const	PSECURITY_DESCRIPTOR	Psec( void ) const			{ return m_psec; }
			LPCTSTR					StrClusterName( void ) const{ return Peo()->StrClusterName(); }
			HRESULT					HrSetSecurityDescriptor( IN PSECURITY_DESCRIPTOR psec );

protected:
	PSECURITY_DESCRIPTOR						m_psec;
	PSECURITY_DESCRIPTOR						m_psecPrev;
	HPROPSHEETPAGE								m_hpage;
	HKEY										m_hkey;
	BOOL										m_bSecDescModified;
	CComObject< CClusterSecurityInformation > *	m_psecinfo;
	PSID										m_pOwner;
	PSID										m_pGroup;
	BOOL										m_fOwnerDef;
	BOOL										m_fGroupDef;

	void					SetPermissions( IN const PSECURITY_DESCRIPTOR psec );
	HRESULT					HrGetSecurityDescriptor( void );
	HRESULT					HrGetSDOwner( IN const PSECURITY_DESCRIPTOR psec );
	HRESULT					HrGetSDGroup( IN const PSECURITY_DESCRIPTOR psec );
	HRESULT					HrSetSDOwner( IN PSECURITY_DESCRIPTOR psec );
	HRESULT					HrSetSDGroup( IN PSECURITY_DESCRIPTOR psec );
	HRESULT					HrGetSDFromClusterDB( OUT PSECURITY_DESCRIPTOR *ppsec );

}; //*** class CClusterSecurityPage

/////////////////////////////////////////////////////////////////////////////

#endif //_CLUSPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\clusname.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		ClusName.h
//
//	Abstract:
//		Definition of the CChangeClusterNameDlg.
//
//	Implementation File:
//		ClusName.cpp
//
//	Author:
//		David Potter (davidp)	April 29, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSNAME_H_
#define _CLUSNAME_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEDLG_H_
#include "BaseDlg.h"	// for CBaseDialog
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CChangeClusterNameDlg;

/////////////////////////////////////////////////////////////////////////////
// CChangeClusterNameDlg dialog
/////////////////////////////////////////////////////////////////////////////

class CChangeClusterNameDlg : public CBaseDialog
{
// Construction
public:
	CChangeClusterNameDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CChangeClusterNameDlg)
	enum { IDD = IDD_EDIT_CLUSTER_NAME };
	CEdit	m_editClusName;
	CButton	m_pbOK;
	CString	m_strClusName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChangeClusterNameDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDialogHelp				m_dlghelp;

	// Generated message map functions
	//{{AFX_MSG(CChangeClusterNameDlg)
	afx_msg void OnChangeClusName();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CChangeClusterNameDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\dlghelps.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DlgHelpS.cpp
//
//	Abstract:
//		Stub for implementation of dialog help classes.
//
//	Author:
//		David Potter (davidp)	February 18, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\dllbase.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		DllBase.h
//
//	Abstract:
//		Dynamic Loadable Library (DLL) wrapper class.
//
//	Implementation File:
//		DllBase.cpp
//
//	Author:
//		Galen Barbee	(galenb)	February 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DLLBASE_H_
#define _DLLBASE_H_

class CDynamicLibraryBase
{
public:
	CDynamicLibraryBase()
	{
		m_lpszLibraryName = NULL;
		m_lpszFunctionName = NULL;
		m_hLibrary = NULL;
		m_pfFunction = NULL;
	}
	virtual ~CDynamicLibraryBase()
	{
		if (m_hLibrary != NULL)
		{
			::FreeLibrary(m_hLibrary);
			m_hLibrary = NULL;
		}
	}
	BOOL Load()
	{
		if (m_hLibrary != NULL)
			return TRUE; // already loaded

		ASSERT(m_lpszLibraryName != NULL);
		m_hLibrary = ::LoadLibrary(m_lpszLibraryName);
		if (NULL == m_hLibrary)
		{
			// The library is not present
			return FALSE;
		}
		ASSERT(m_lpszFunctionName != NULL);
		ASSERT(m_pfFunction == NULL);
		m_pfFunction = ::GetProcAddress(m_hLibrary, m_lpszFunctionName );
		if ( NULL == m_pfFunction )
		{
			// The library is present but does not have the entry point
			::FreeLibrary( m_hLibrary );
			m_hLibrary = NULL;
			return FALSE;
		}
		ASSERT(m_hLibrary != NULL);
		ASSERT(m_pfFunction != NULL);
		return TRUE;
	}

protected:
	LPCSTR	m_lpszFunctionName;
	LPCTSTR m_lpszLibraryName;
	FARPROC m_pfFunction;
	HMODULE m_hLibrary;
};

#endif //_DLLBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\editacl.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		EditAcl.h
//
//	Abstract:
//		Definition of ACL editor methods.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//			From \nt\private\window\shell\lmui\ntshrui\acl.cxx
//			by BruceFo
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EDITACL_H_
#define _EDITACL_H_

LONG
EditShareAcl(
	IN HWND 					hwndParent,
	IN LPCTSTR					pszServerName,
	IN LPCTSTR					pszShareName,
	IN LPCTSTR					pszClusterNameNode,
	IN PSECURITY_DESCRIPTOR 	pSecDesc,
	OUT BOOL *					pbSecDescModified,
	OUT PSECURITY_DESCRIPTOR *	ppSecDesc
	);

LONG
CreateDefaultSecDesc(
	OUT PSECURITY_DESCRIPTOR* ppSecDesc
	);

VOID
DeleteDefaultSecDesc(
	IN PSECURITY_DESCRIPTOR pSecDesc
	);

PSECURITY_DESCRIPTOR
CopySecurityDescriptor(
	IN PSECURITY_DESCRIPTOR pSecDesc
	);


//
// Cluster API Specific Access Rights
//
#define SHARE_READ_ACCESS		0 //0x00000001L
#define SHARE_CHANGE_ACCESS		0 //0x00000002L
#define SHARE_NO_ACCESS 		0 //0x00000004L
#define SHARE_ALL_ACCESS		(SHARE_READ_ACCESS | SHARE_CHANGE_ACCESS)


//
// Share General Permissions
//


#if 0
#define FILE_PERM_NO_ACCESS 		 (0)
#define FILE_PERM_READ				 (STANDARD_RIGHTS_READ		|\
										SHARE_READ_ACCESS)
#define FILE_PERM_MODIFY			 (STANDARD_RIGHTS_WRITE 	|\
										SHARE_CHANGE_ACCESS)
#define FILE_PERM_ALL				 (STANDARD_RIGHTS_ALL		|\
										SHARE_ALL_ACCESS)
#else
#define FILE_PERM_NO_ACCESS 		(0)
#define FILE_PERM_READ				(GENERIC_READ    |\
									 GENERIC_EXECUTE)
#define FILE_PERM_MODIFY			(GENERIC_READ    |\
									 GENERIC_EXECUTE |\
									 GENERIC_WRITE   |\
									 DELETE )
#define FILE_PERM_ALL				(GENERIC_ALL)
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _EDITACL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\disks.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Disks.cpp
//
//  Abstract:
//      Implementation of the CPhysDiskParamsPage class.
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"
#include "Disks.h"
#include "DDxDDv.h"
#include "PropList.h"
#include "HelpData.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPhysDiskParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CPhysDiskParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CPhysDiskParamsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CPhysDiskParamsPage)
    ON_CBN_SELCHANGE(IDC_PP_DISKS_PARAMS_DISK, OnChangeDisk)
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::CPhysDiskParamsPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CPhysDiskParamsPage::CPhysDiskParamsPage(void)
    : CBasePropertyPage(g_aHelpIDs_IDD_PP_DISKS_PARAMETERS, g_aHelpIDs_IDD_WIZ_DISKS_PARAMETERS)
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CPhysDiskParamsPage)
    m_strDisk = _T("");
    //}}AFX_DATA_INIT

    m_dwSignature = 0;

    m_pbAvailDiskInfo = NULL;
    m_cbAvailDiskInfo = 0;
    m_pbDiskInfo = NULL;
    m_cbDiskInfo = 0;

    // Setup the property array.
    {
        m_rgProps[epropSignature].Set(REGPARAM_DISKS_SIGNATURE, m_dwSignature, m_dwPrevSignature);
    }  // Setup the property array

    m_iddPropertyPage = IDD_PP_DISKS_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_DISKS_PARAMETERS;

}  //*** CPhysDiskParamsPage::CPhysDiskParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::~CPhysDiskParamsPage
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CPhysDiskParamsPage::~CPhysDiskParamsPage(void)
{
    delete [] m_pbAvailDiskInfo;
    delete [] m_pbDiskInfo;

}  //*** CPhysDiskParamsPage::~CPhysDiskParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::HrInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//
//  Return Value:
//      S_OK        Page initialized successfully.
//      hr          Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CPhysDiskParamsPage::HrInit(IN OUT CExtObject * peo)
{
    HRESULT     _hr;
    CWaitCursor _wc;

    do
    {
        // Call the base class method.
        _hr = CBasePropertyPage::HrInit(peo);
        if ( FAILED( _hr ) )
        {
            break;
        } // if: error from base class method

        // Collect available disk information.
        BGetAvailableDisks();

        // If creating a new resource, select the first disk.
        // Otherwise, collect information about the selected disk.
        if (BWizard())
        {
            CLUSPROP_BUFFER_HELPER  buf;

            buf.pb = m_pbAvailDiskInfo;
            if (m_cbAvailDiskInfo > 0)
            {
                while (buf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
                {
                    if (BStringFromDiskInfo(buf, m_cbAvailDiskInfo, m_strDisk))
                        break;
                    ASSERT( (buf.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK)
                        ||  (buf.pSyntax->dw == CLUSPROP_SYNTAX_DISK_SIGNATURE));
                }  // while:  more entries in the list
            }  // if:  there are available disks
        }  // if:  creating a new resource
        else
        {
            // Don't return false because that will prevent the page from showing up.
            BGetDiskInfo();

            // Get the current state of the resource.
            m_crs = GetClusterResourceState(Peo()->PrdResData()->m_hresource, NULL, NULL, NULL, NULL );
        }  // else:  viewing an existing resource
    } while ( 0 );

    return _hr;

}  //*** CPhysDiskParamsPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CPhysDiskParamsPage::DoDataExchange(CDataExchange * pDX)
{
    if (!pDX->m_bSaveAndValidate || !BSaved())
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // TODO: Modify the following lines to represent the data displayed on this page.
        //{{AFX_DATA_MAP(CPhysDiskParamsPage)
        DDX_Control(pDX, IDC_PP_DISKS_PARAMS_DISK, m_cboxDisk);
        DDX_Text(pDX, IDC_PP_DISKS_PARAMS_DISK, m_strDisk);
        //}}AFX_DATA_MAP

        if (pDX->m_bSaveAndValidate)
        {
            if (!BBackPressed())
            {
                if (BWizard()
                    && !(  (m_strDisk.GetLength() == 0)
                        && (m_crs == ClusterResourceOffline)))
                {
                    DDV_RequiredText(pDX, IDC_PP_DISKS_PARAMS_DISK, IDC_PP_DISKS_PARAMS_DISK_LABEL, m_strDisk);
                    m_dwSignature = (DWORD)m_cboxDisk.GetItemData(m_cboxDisk.GetCurSel());
                    ASSERT(m_dwSignature != 0);
                }  // if:  not offline with an empty disk string
            }  // if:  Back button not pressed
        }  // if:  saving data
    }  // if:  not saving or haven't saved yet

    CBasePropertyPage::DoDataExchange(pDX);

}  //*** CPhysDiskParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPhysDiskParamsPage::OnInitDialog(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::OnInitDialog();

    // Set the combobox as read-only if not creating a new resource.
    m_cboxDisk.EnableWindow(BWizard());

    // Fill the disks list.
    FillList();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CPhysDiskParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPhysDiskParamsPage::OnSetActive(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Enable/disable the Next/Finish button.
    if (BWizard())
    {
        if (m_strDisk.GetLength() == 0)
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  enable/disable the Next button

    return CBasePropertyPage::OnSetActive();

}  //*** CPhysDiskParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPhysDiskParamsPage::BApplyChanges(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWaitCursor wc;

    if (!(   (m_strDisk.GetLength() == 0)
          && (m_crs == ClusterResourceOffline)))
    {
        // Call the base class method.
        if (!CBasePropertyPage::BApplyChanges())
            return FALSE;

        // Reread the disk info and the available disks.
        // Ignore errors because we can't do anything about it at this point anyway.
        BGetAvailableDisks();
        BGetDiskInfo();

        // Refill the combobox.
        FillList();
    }  // if:  not offline with an empty disk string

    return TRUE;

}  //*** CPhysDiskParamsPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::OnChangeDisk
//
//  Routine Description:
//      Handler for the CBN_SELCHANGE message on the Disks combobox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CPhysDiskParamsPage::OnChangeDisk(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (BWizard())
    {
        if (m_cboxDisk.GetWindowTextLength() == 0)
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  in a wizard

}  //*** CPhysDiskParamsPage::OnChangeDisk()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::BGetAvailableDisks
//
//  Routine Description:
//      Get the list of disks for this type of resource that can be assigned
//      to a resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The operation was successful.
//      FALSE       The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPhysDiskParamsPage::BGetAvailableDisks(void)
{
    DWORD   dwStatus    = ERROR_SUCCESS;
    DWORD   cbDiskInfo  = sizeof(CLUSPROP_DWORD)
                            + sizeof(CLUSPROP_SCSI_ADDRESS)
                            + sizeof(CLUSPROP_DISK_NUMBER)
                            + sizeof(CLUSPROP_PARTITION_INFO)
                            + sizeof(CLUSPROP_SYNTAX);
    PBYTE   pbDiskInfo = NULL;

    try
    {
        // Get disk info.
        pbDiskInfo = new BYTE[cbDiskInfo];
        dwStatus = ClusterResourceTypeControl(
                        Peo()->Hcluster(),
                        Peo()->PrdResData()->m_strResTypeName,
                        NULL,
                        CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS,
                        NULL,
                        0,
                        pbDiskInfo,
                        cbDiskInfo,
                        &cbDiskInfo
                        );
        if (dwStatus == ERROR_MORE_DATA)
        {
            delete [] pbDiskInfo;
            pbDiskInfo = new BYTE[cbDiskInfo];
            dwStatus = ClusterResourceTypeControl(
                            Peo()->Hcluster(),
                            Peo()->PrdResData()->m_strResTypeName,
                            NULL,
                            CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS,
                            NULL,
                            0,
                            pbDiskInfo,
                            cbDiskInfo,
                            &cbDiskInfo
                            );
        }  // if:  buffer too small
    }  // try
    catch (CMemoryException * pme)
    {
        pme->Delete();
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException

    if (dwStatus != ERROR_SUCCESS)
    {
        CNTException nte(
                        dwStatus,
                        IDS_GET_AVAILABLE_DISKS_ERROR,
                        Peo()->PrdResData()->m_strResTypeName,
                        NULL,
                        FALSE /*bAutoDelete*/
                        );
        delete [] pbDiskInfo;
        nte.ReportError();
        nte.Delete();
        return FALSE;
    }  // if:  error getting disk info

    delete [] m_pbAvailDiskInfo;
    m_pbAvailDiskInfo = pbDiskInfo;
    m_cbAvailDiskInfo = cbDiskInfo;

    return TRUE;

}  //*** CPhysDiskParamsPage::BGetAvailableDisks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::BGetDiskInfo
//
//  Routine Description:
//      Get information about the currently selected disk.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The operation was successful.
//      FALSE       The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPhysDiskParamsPage::BGetDiskInfo(void)
{
    DWORD   dwStatus    = ERROR_SUCCESS;
    DWORD   cbDiskInfo  = sizeof(CLUSPROP_DWORD)
                            + sizeof(CLUSPROP_SCSI_ADDRESS)
                            + sizeof(CLUSPROP_DISK_NUMBER)
                            + sizeof(CLUSPROP_PARTITION_INFO)
                            + sizeof(CLUSPROP_SYNTAX);
    PBYTE   pbDiskInfo = NULL;

    try
    {
        // Get disk info.
        pbDiskInfo = new BYTE[cbDiskInfo];
        dwStatus = ClusterResourceControl(
                        Peo()->PrdResData()->m_hresource,
                        NULL,
                        CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                        NULL,
                        0,
                        pbDiskInfo,
                        cbDiskInfo,
                        &cbDiskInfo
                        );
        if (dwStatus == ERROR_MORE_DATA)
        {
            delete [] pbDiskInfo;
            pbDiskInfo = new BYTE[cbDiskInfo];
            dwStatus = ClusterResourceControl(
                            Peo()->PrdResData()->m_hresource,
                            NULL,
                            CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                            NULL,
                            0,
                            pbDiskInfo,
                            cbDiskInfo,
                            &cbDiskInfo
                            );
        }  // if:  buffer too small
    }  // try
    catch (CMemoryException * pme)
    {
        pme->Delete();
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException

    if (dwStatus != ERROR_SUCCESS)
    {
        CNTException nte(
                        dwStatus,
                        IDS_GET_DISK_INFO_ERROR,
                        Peo()->PrdResData()->m_strName,
                        NULL,
                        FALSE /*bAutoDelete*/
                        );
        delete [] pbDiskInfo;
        nte.ReportError();
        nte.Delete();
        return FALSE;
    }  // if:  error getting disk info

    delete [] m_pbDiskInfo;
    m_pbDiskInfo = pbDiskInfo;
    m_cbDiskInfo = cbDiskInfo;

    return TRUE;

}  //*** CPhysDiskParamsPage::BGetDiskInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::BStringFromDiskInfo
//
//  Routine Description:
//      Convert disk information to a string for display.
//
//  Arguments:
//      rbuf            [IN OUT] Buffer pointer.
//      cbBuf           [IN] Number of bytes in the buffer.
//      rstr            [OUT] String to fill.
//      pdwSignature    [OUT] Signature associated with the disk info being
//                          returned.
//
//  Return Value:
//      TRUE        A string was produced from disk info.
//      FALSE       No string could be produced.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPhysDiskParamsPage::BStringFromDiskInfo(
    IN OUT CLUSPROP_BUFFER_HELPER & rbuf,
    IN DWORD                        cbBuf,
    OUT CString &                   rstr,
    OUT DWORD *                     pdwSignature // = NULL
    ) const
{
    CString strPartitionInfo;
    DWORD   dwSignature = 0;
    DWORD   cbData;
    BOOL    bDisplay;

    ASSERT(cbBuf > 0);
    ASSERT(rbuf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK);

    rstr = _T("");

    if (rbuf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
    {
        do
        {
            // Calculate the size of the value.
            cbData = sizeof(*rbuf.pValue) + ALIGN_CLUSPROP(rbuf.pValue->cbLength);
            ASSERT(cbData <= cbBuf);

            // Parse the value.
            if (rbuf.pSyntax->dw == CLUSPROP_SYNTAX_DISK_SIGNATURE)
            {
                // Save the signature.
                dwSignature = rbuf.pDwordValue->dw;
                ASSERT(dwSignature != 0);
            }  // if:  signature
            else if (rbuf.pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO)
            {
                // Add the partition to the string if it is a usable partition
                // and hasn't been added already.  If the resource is offline,
                // don't check the usable flag.
                bDisplay = ( rstr.Find(rbuf.pPartitionInfoValue->szDeviceName) == -1 );
                if ( bDisplay && ( m_crs == ClusterResourceOnline ) )
                {
                    bDisplay = (rbuf.pPartitionInfoValue->dwFlags & CLUSPROP_PIFLAG_USABLE) == CLUSPROP_PIFLAG_USABLE;
                } // if: resource is online
                if (bDisplay)
                {
                    try
                    {
                        strPartitionInfo.Format(
                                (rbuf.pPartitionInfoValue->szVolumeLabel[0] ? _T("%ls (%ls) ") : _T("%ls ")),
                                rbuf.pPartitionInfoValue->szDeviceName,
                                rbuf.pPartitionInfoValue->szVolumeLabel
                                );
                        rstr += strPartitionInfo;
                        if (pdwSignature != NULL)
                        {
                            _ASSERTE(dwSignature != 0);
                            *pdwSignature = dwSignature;
                        } // if:  caller wants signature as well
                    }  // try
                    catch (...)
                    {
                        // Ignore all errors because there is really nothing we can do.
                        // Displaying a message isn't really very useful.
                    }  // catch:  Anything
                }  // if:  partition should be displayed
            }  // else if:  partition info

            // Advance the buffer pointer
            rbuf.pb += cbData;
            cbBuf -= cbData;

        }  while ( (rbuf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
                && (rbuf.pSyntax->dw != CLUSPROP_SYNTAX_DISK_SIGNATURE));
    }  // if:  not an endmark

    return (rstr.GetLength() > 0);

}  //*** CPhysDiskParamsPage::BStringFromDiskInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::FillList
//
//  Routine Description:
//      Fill the list of disks.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CPhysDiskParamsPage::FillList(void)
{
    CString     strDisk;
    DWORD       dwSignature;
    int         icbox;

    // Clear the list first.
    m_cboxDisk.ResetContent();

    // Add the disk info first.
    if (m_cbDiskInfo > 0)
    {
        CLUSPROP_BUFFER_HELPER  buf;
        
        buf.pb = m_pbDiskInfo;
        if (BStringFromDiskInfo(buf, m_cbDiskInfo, m_strDisk, &dwSignature))
        {
            ASSERT(dwSignature != 0);
            icbox = m_cboxDisk.AddString(m_strDisk);
            m_cboxDisk.SetItemData(icbox, dwSignature);
        } // if:  disk info was found
    }  // if:  there is disk info

    // Now add the available disk info.
    if (m_cbAvailDiskInfo > 0)
    {
        CString                 strDisk;
        CLUSPROP_BUFFER_HELPER  buf;
        
        buf.pb = m_pbAvailDiskInfo;
        while (buf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
        {
            if (BStringFromDiskInfo(buf, m_cbAvailDiskInfo, strDisk, &dwSignature))
            {
                ASSERT(dwSignature != 0);
                icbox = m_cboxDisk.AddString(strDisk);
                m_cboxDisk.SetItemData(icbox, dwSignature);
            } // if:  disk info was found
        }  // while:  more entries in the list
    }  // if:  there is available disk info

    // Now select an item in the list.
    if (m_strDisk.GetLength() > 0)
    {
        int nIndex;

        nIndex = m_cboxDisk.FindStringExact(-1, m_strDisk);
        m_cboxDisk.SetCurSel(nIndex);
    }  // if:  there is a selected item

}  //*** CPhysDiskParamsPage::FillList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\disks.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		Disks.cpp
//
//	Abstract:
//		Definition of the CPhysDiskParamsPage class, which implements the
//		Parameters page for Physical Disk resources.
//
//	Implementation File:
//		Disks.cpp
//
//	Author:
//		David Potter (davidp)	June 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DISKS_H_
#define _DISKS_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CPhysDiskParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusPropList;

/////////////////////////////////////////////////////////////////////////////
// CPhysDiskParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CPhysDiskParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CPhysDiskParamsPage)

// Construction
public:
	CPhysDiskParamsPage(void);
	~CPhysDiskParamsPage(void);

	// Second phase construction.
	virtual HRESULT		HrInit(IN OUT CExtObject * peo);

// Dialog Data
	//{{AFX_DATA(CPhysDiskParamsPage)
	enum { IDD = IDD_PP_DISKS_PARAMETERS};
	CComboBox	m_cboxDisk;
	CString	m_strDisk;
	//}}AFX_DATA
	CString	m_strPrevDisk;
	DWORD	m_dwSignature;
	DWORD	m_dwPrevSignature;

protected:
	enum
	{
		epropSignature,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

// Overrides
public:
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPhysDiskParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual BOOL		BApplyChanges(void);
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:
	PBYTE				m_pbAvailDiskInfo;
	DWORD				m_cbAvailDiskInfo;
	PBYTE				m_pbDiskInfo;
	DWORD				m_cbDiskInfo;
	CLUSTER_RESOURCE_STATE	m_crs;

	BOOL				BGetAvailableDisks(void);
	BOOL				BGetDiskInfo(void);
	BOOL				BStringFromDiskInfo(
							IN OUT CLUSPROP_BUFFER_HELPER &	rbuf,
							IN DWORD						cbBuf,
							OUT CString &					rstr,
							OUT DWORD *						pdwSignature = NULL
							) const;
	void				FillList(void);

	// Generated message map functions
	//{{AFX_MSG(CPhysDiskParamsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeDisk();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CPhysDiskParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _DISKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\extobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1999 Microsoft Corporation
//
//  Module Name:
//      ExtObj.cpp
//
//  Abstract:
//      Implementation of the CExtObject class, which implements the
//      extension interfaces required by a Microsoft Windows NT Cluster
//      Administrator Extension DLL.
//
//  Author:
//      David Potter (davidp)   August 29, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"

#include "GenApp.h"
#include "GenScript.h"
#include "GenSvc.h"
#include "NetName.h"
#include "Disks.h"
#include "PrtSpool.h"
#include "SmbShare.h"
#include "IpAddr.h"
#include "RegRepl.h"
#include "AclUtils.h"
#include "ClusPage.h"

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

const WCHAR g_wszResourceTypeNames[] =
        RESTYPE_NAME_GENERIC_APP L"\0"
        RESTYPE_NAME_GENERIC_SCRIPT L"\0"
        RESTYPE_NAME_GENERIC_SERVICE L"\0"
        RESTYPE_NAME_NETWORK_NAME L"\0"
        RESTYPE_NAME_PHYS_DISK L"\0"
#ifdef SUPPORT_FT_SET
        RESTYPE_NAME_FT_SET L"\0"
#endif // SUPPORT_FT_SET
        RESTYPE_NAME_PRINT_SPOOLER L"\0"
        RESTYPE_NAME_FILE_SHARE L"\0"
        RESTYPE_NAME_IP_ADDRESS L"\0"
        ;
const DWORD g_cchResourceTypeNames  = sizeof(g_wszResourceTypeNames) / sizeof(WCHAR);

static CRuntimeClass * g_rgprtcPSGenAppPages[]  = {
    RUNTIME_CLASS(CGenericAppParamsPage),
    RUNTIME_CLASS(CRegReplParamsPage),
    NULL
    };
static CRuntimeClass * g_rgprtcPSGenScriptPages[]   = {
    RUNTIME_CLASS(CGenericScriptParamsPage),
    NULL
    };
static CRuntimeClass * g_rgprtcPSGenSvcPages[]  = {
    RUNTIME_CLASS(CGenericSvcParamsPage),
    RUNTIME_CLASS(CRegReplParamsPage),
    NULL
    };
static CRuntimeClass * g_rgprtcPSNetNamePages[] = {
    RUNTIME_CLASS(CNetworkNameParamsPage),
    NULL
    };
static CRuntimeClass * g_rgprtcPSPhysDiskPages[]    = {
    RUNTIME_CLASS(CPhysDiskParamsPage),
    NULL
    };
#ifdef SUPPORT_FT_SET
static CRuntimeClass * g_rgprtcPSFTSetPages[]   = {
    RUNTIME_CLASS(CPhysDiskParamsPage),
    NULL
    };
#endif // SUPPORT_FT_SET
static CRuntimeClass * g_rgprtcPSPrintSpoolerPages[]    = {
    RUNTIME_CLASS(CPrintSpoolerParamsPage),
    NULL
    };
static CRuntimeClass * g_rgprtcPSFileSharePages[]   = {
    RUNTIME_CLASS(CFileShareParamsPage),
    NULL
    };
static CRuntimeClass * g_rgprtcPSIpAddrPages[]  = {
    RUNTIME_CLASS(CIpAddrParamsPage),
    NULL
    };

static CRuntimeClass ** g_rgpprtcPSPages[]  = {
    g_rgprtcPSGenAppPages,
    g_rgprtcPSGenScriptPages,
    g_rgprtcPSGenSvcPages,
    g_rgprtcPSNetNamePages,
    g_rgprtcPSPhysDiskPages,
#ifdef SUPPORT_FT_SET
    g_rgprtcPSFTSetPages,
#endif // SUPPORT_FT_SET
    g_rgprtcPSPrintSpoolerPages,
    g_rgprtcPSFileSharePages,
    g_rgprtcPSIpAddrPages,
    };

// Wizard pages and property sheet pages are the same.
static CRuntimeClass ** g_rgpprtcWizPages[] = {
    g_rgprtcPSGenAppPages,
    g_rgprtcPSGenScriptPages,
    g_rgprtcPSGenSvcPages,
    g_rgprtcPSNetNamePages,
    g_rgprtcPSPhysDiskPages,
#ifdef SUPPORT_FT_SET
    g_rgprtcPSFTSetPages,
#endif // SUPPORT_FT_SET
    g_rgprtcPSPrintSpoolerPages,
    g_rgprtcPSFileSharePages,
    g_rgprtcPSIpAddrPages,
    };

#ifdef _DEMO_CTX_MENUS
static WCHAR g_wszGenAppMenuItems[] = {
    L"GenApp Item 1\0First Generic Application menu item\0"
    L"GenApp Item 2\0Second Generic Application menu item\0"
    L"GenApp Item 3\0Third Generic Application menu item\0"
    L"\0"
    };
static WCHAR g_wszGenSvcMenuItems[] = {
    L"GenSvc Item 1\0First Generic Service menu item\0"
    L"GenSvc Item 2\0Second Generic Service menu item\0"
    L"GenSvc Item 3\0Third Generic Service menu item\0"
    L"\0"
    };
static WCHAR g_wszNetNameMenuItems[]    = {
    L"NetName Item 1\0First Network Name menu item\0"
    L"NetName Item 2\0Second Network Name menu item\0"
    L"NetName Item 3\0Third Network Name menu item\0"
    L"\0"
    };
static WCHAR g_wszPhysDiskMenuItems[]   = {
    L"PhysDisk Item 1\0First Physical Disk menu item\0"
    L"PhysDisk Item 2\0Second Physical Disk menu item\0"
    L"PhysDisk Item 3\0Third Physical Disk menu item\0"
    L"\0"
    };
static WCHAR g_wszFileShareMenuItems[]  = {
    L"FileShare Item 1\0First File Share menu item\0"
    L"FileShare Item 2\0Second File Share menu item\0"
    L"FileShare Item 3\0Third File Share menu item\0"
    L"\0"
    };
static WCHAR g_wszIpAddrMenuItems[] = {
    L"IpAddr Item 1\0First IP Address menu item\0"
    L"IpAddr Item 2\0Second IP Address menu item\0"
    L"IpAddr Item 3\0Third IP Address menu item\0"
    L"\0"
    };

static LPWSTR g_rgpwszContextMenuItems[]    = {
    g_wszGenAppMenuItems,
    g_wszGenSvcMenuItems,
    g_wszNetNameMenuItems,
    g_wszPhysDiskMenuItems,
    g_wszFileShareMenuItems,
    g_wszIpAddrMenuItems,
    };
#endif

/////////////////////////////////////////////////////////////////////////////
// CExtObject
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CExtObject
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::CExtObject(void)
{
    m_piData = NULL;
    m_piWizardCallback = NULL;
    m_bWizard = FALSE;
    m_istrResTypeName = 0;

    m_hcluster = NULL;
    m_lcid = NULL;
    m_hfont = NULL;
    m_hicon = NULL;
    m_podObjData = NULL;
    m_pCvi = NULL;

}  //*** CExtObject::CExtObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::~CExtObject
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::~CExtObject(void)
{
    // Release the data interface.
    if (PiData() != NULL)
    {
        PiData()->Release();
        m_piData = NULL;
    }  // if:  we have a data interface pointer

    // Release the wizard callback interface.
    if (PiWizardCallback() != NULL)
    {
        PiWizardCallback()->Release();
        m_piWizardCallback = NULL;
    }  // if:  we have a wizard callback interface pointer

    // Delete the pages.
    {
        POSITION    pos;

        pos = Lpg().GetHeadPosition();
        while (pos != NULL)
            delete Lpg().GetNext(pos);
    }  // Delete the pages

    delete m_podObjData;
    delete m_pCvi;

}  //*** CExtObject::~CExtObject()

/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfo Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::InterfaceSupportsErrorInfo (ISupportErrorInfo)
//
//  Routine Description:
//      Indicates whether an interface suportes the IErrorInfo interface.
//      This interface is provided by ATL.
//
//  Arguments:
//      riid        Interface ID.
//
//  Return Value:
//      S_OK        Interface supports IErrorInfo.
//      S_FALSE     Interface does not support IErrorInfo.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID * rgiid[] =
    {
        &IID_IWEExtendPropertySheet,
        &IID_IWEExtendWizard,
#ifdef _DEMO_CTX_MENUS
        &IID_IWEExtendContextMenu,
#endif
    };
    int     iiid;

    for (iiid = 0 ; iiid < sizeof(rgiid) / sizeof(rgiid[0]) ; iiid++)
    {
        if (InlineIsEqualGUID(*rgiid[iiid], riid))
            return S_OK;
    }
    return S_FALSE;

}  //*** CExtObject::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendPropertySheet Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CreatePropertySheetPages (IWEExtendPropertySheet)
//
//  Routine Description:
//      Create property sheet pages and add them to the sheet.
//
//  Arguments:
//      piData          IUnkown pointer from which to obtain interfaces
//                          for obtaining data describing the object for
//                          which the sheet is being displayed.
//      piCallback      Pointer to an IWCPropertySheetCallback interface
//                          for adding pages to the sheet.
//
//  Return Value:
//      NOERROR         Pages added successfully.
//      E_INVALIDARG    Invalid arguments to the function.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_FAIL          Error creating a page.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreatePropertySheetPages(
    IN IUnknown *                   piData,
    IN IWCPropertySheetCallback *   piCallback
    )
{
    HRESULT             hr      = E_FAIL;
    HPROPSHEETPAGE      hpage   = NULL;
    CException          exc(FALSE /*bAutoDelete*/);
    CRuntimeClass **    pprtc   = NULL;
    int                 irtc;
    CBasePropertyPage * ppage;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Validate the parameters.
    if ((piData == NULL) || (piCallback == NULL))
        return E_INVALIDARG;

    try
    {
        // Get info about displaying UI.
        hr = HrGetUIInfo(piData);
        if (hr != NOERROR)
            throw &exc;

        // Save the data.
        hr = HrSaveData(piData);
        if (hr != NOERROR)
            throw &exc;

        // Delete any previous pages.
        {
            POSITION    pos;

            pos = Lpg().GetHeadPosition();
            while (pos != NULL)
                delete Lpg().GetNext(pos);
            Lpg().RemoveAll();
        }  // Delete any previous pages

        // Create property pages.
        ASSERT(PodObjData() != NULL);
        switch (PodObjData()->m_cot)
        {
            case CLUADMEX_OT_CLUSTER:
                {
                    CClusterSecurityPage    *pClusterSecurityPage = new CClusterSecurityPage;

                    if ( pClusterSecurityPage != NULL )
                    {
                        // Add it to the list.
                        Lpg().AddTail( pClusterSecurityPage );

                        hr = pClusterSecurityPage->HrInit( this );
                        if ( SUCCEEDED( hr ) )
                        {
                            hr = piCallback->AddPropertySheetPage(
                                    (LONG *) pClusterSecurityPage->GetHPage() );
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    if ( FAILED( hr ) )
                    {
                        throw &exc;
                    }
                }
                break;
            case CLUADMEX_OT_RESOURCE:
                pprtc = g_rgpprtcPSPages[IstrResTypeName()];
                break;
            default:
                hr = E_NOTIMPL;
                throw &exc;
                break;
        }  // switch:  object type

        if (pprtc)
        {
            // Create each page.
            for (irtc = 0 ; pprtc[irtc] != NULL ; irtc++)
            {
                // Create the page.
                ppage = (CBasePropertyPage *) pprtc[irtc]->CreateObject();
                ASSERT(ppage->IsKindOf(pprtc[irtc]));

                // Add it to the list.
                Lpg().AddTail(ppage);

                // Initialize the property page.
                hr = ppage->HrInit(this);
                if (FAILED(hr))
                    throw &exc;

                // Create the page.
                hpage = ::CreatePropertySheetPage(&ppage->m_psp);
                if (hpage == NULL)
                {
                    DWORD sc = GetLastError();
                    hr = HRESULT_FROM_WIN32(sc);
                    throw &exc;
                } // if: error creating the page

                // Save the hpage in the page itself.
                ppage->SetHpage(hpage);

                // Add it to the property sheet.
                hr = piCallback->AddPropertySheetPage((LONG *) hpage);
                if (hr != NOERROR)
                    throw &exc;
            }  // for:  each page in the list
        } // if: pprtc is null

    }  // try
    catch (CMemoryException * pme)
    {
        TRACE(_T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n"));
        pme->Delete();
        hr = E_OUTOFMEMORY;
    }  // catch:  anything
    catch (CException * pe)
    {
        TRACE(_T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n"));
        pe->Delete();
        if (hr == NOERROR)
            hr = E_FAIL;
    }  // catch:  anything

    if (hr != NOERROR)
    {
        if (hpage != NULL)
            ::DestroyPropertySheetPage(hpage);
        piData->Release();
        m_piData = NULL;
    }  // if:  error occurred

    piCallback->Release();
    return hr;

}  //*** CExtObject::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendWizard Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CreateWizardPages (IWEExtendWizard)
//
//  Routine Description:
//      Create property sheet pages and add them to the wizard.
//
//  Arguments:
//      piData          IUnkown pointer from which to obtain interfaces
//                          for obtaining data describing the object for
//                          which the wizard is being displayed.
//      piCallback      Pointer to an IWCPropertySheetCallback interface
//                          for adding pages to the sheet.
//
//  Return Value:
//      NOERROR         Pages added successfully.
//      E_INVALIDARG    Invalid arguments to the function.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_FAIL          Error creating a page.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreateWizardPages(
    IN IUnknown *           piData,
    IN IWCWizardCallback *  piCallback
    )
{
    HRESULT             hr      = NOERROR;
    HPROPSHEETPAGE      hpage   = NULL;
    CException          exc(FALSE /*bAutoDelete*/);
    int                 irtc;
    CBasePropertyPage * ppage;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Validate the parameters.
    if ((piData == NULL) || (piCallback == NULL))
        return E_INVALIDARG;

    try
    {
        // Get info about displaying UI.
        hr = HrGetUIInfo(piData);
        if (hr != NOERROR)
            throw &exc;

        // Save the data.
        hr = HrSaveData(piData);
        if (hr != NOERROR)
            throw &exc;

        // Delete any previous pages.
        {
            POSITION    pos;

            pos = Lpg().GetHeadPosition();
            while (pos != NULL)
                delete Lpg().GetNext(pos);
            Lpg().RemoveAll();
        }  // Delete any previous pages

        m_piWizardCallback = piCallback;
        m_bWizard = TRUE;

        // Add each page for this type of resource.
        for (irtc = 0 ; g_rgpprtcWizPages[IstrResTypeName()][irtc] != NULL ; irtc++)
        {
            // Create the property pages.
            ppage = (CBasePropertyPage *) g_rgpprtcWizPages[IstrResTypeName()][irtc]->CreateObject();
            ASSERT(ppage->IsKindOf(g_rgpprtcWizPages[IstrResTypeName()][irtc]));

            // Add it to the list.
            Lpg().AddTail(ppage);

            // Initialize the property page.
            hr = ppage->HrInit(this);
            if (FAILED(hr))
                throw &exc;

            // Create the page.
            hpage = ::CreatePropertySheetPage(&ppage->m_psp);
            if (hpage == NULL)
            {
                DWORD sc = GetLastError();
                hr = HRESULT_FROM_WIN32(sc);
                throw &exc;
            } // if: error creating the page

            // Save the hpage in the page itself.
            ppage->SetHpage(hpage);

            // Add it to the property sheet.
            hr = piCallback->AddWizardPage((LONG *) hpage);
            if (hr != NOERROR)
                throw &exc;
        }  // for:  each page for the type of resource
    }  // try
    catch (CMemoryException * pme)
    {
        TRACE(_T("CExtObject::CreateWizardPages: Failed to add wizard page (CMemoryException)\n"));
        pme->Delete();
        hr = E_OUTOFMEMORY;
    }  // catch:  CMemoryException
    catch (CException * pe)
    {
        TRACE(_T("CExtObject::CreateWizardPages: Failed to add wizard page (CException)\n"));
        pe->Delete();
        if (hr == NOERROR)
            hr = E_FAIL;
    }  // catch:  CException
//  catch (...)
//  {
//      TRACE(_T("CExtObject::CreateWizardPages: Failed to add wizard page (...)\n"));
//  } // catch:  anything

    if (hr != NOERROR)
    {
        if (hpage != NULL)
            ::DestroyPropertySheetPage(hpage);
        piCallback->Release();
        if ( m_piWizardCallback == piCallback )
        {
            m_piWizardCallback = NULL;
        } // if: already saved interface pointer
        piData->Release();
        m_piData = NULL;
    }  // if:  error occurred

    return hr;

}  //*** CExtObject::CreateWizardPages()

#ifdef _DEMO_CTX_MENUS
/////////////////////////////////////////////////////////////////////////////
// IWEExtendContextMenu Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::AddContextMenuItems (IWEExtendContextMenu)
//
//  Routine Description:
//      Add items to a context menu.
//
//  Arguments:
//      piData          IUnkown pointer from which to obtain interfaces
//                          for obtaining data describing the object for
//                          which the context menu is being displayed.
//      piCallback      Pointer to an IWCContextMenuCallback interface
//                          for adding menu items to the context menu.
//
//  Return Value:
//      NOERROR         Pages added successfully.
//      E_INVALIDARG    Invalid arguments to the function.
//      E_FAIL          Error adding context menu item.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes returned by HrSaveData() or IWCContextMenuCallback::
//      AddExtensionMenuItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::AddContextMenuItems(
    IN IUnknown *               piData,
    IN IWCContextMenuCallback * piCallback
    )
{
    HRESULT         hr      = NOERROR;
    CException      exc(FALSE /*bAutoDelete*/);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Validate the parameters.
    if ((piData == NULL) || (piCallback == NULL))
        return E_INVALIDARG;

    try
    {
        // Save the data.
        hr = HrSaveData(piData);
        if (hr != NOERROR)
            throw &exc;

        // Add menu items specific to this resource type.
        {
            ULONG       iCommandID;
            LPWSTR      pwsz = g_rgpwszContextMenuItems[IstrResTypeName()];
            LPWSTR      pwszName;
            LPWSTR      pwszStatusBarText;

            for (iCommandID = 0 ; *pwsz != L'\0' ; iCommandID++)
            {
                pwszName = pwsz;
                pwszStatusBarText = pwszName + (lstrlenW(pwszName) + 1);
                hr = piCallback->AddExtensionMenuItem(
                                    pwszName,           // lpszName
                                    pwszStatusBarText,  // lpszStatusBarText
                                    iCommandID,         // lCommandID
                                    0,                  // lSubCommandID
                                    0                   // uFlags
                                    );
                if (hr != NOERROR)
                    throw &exc;
                pwsz = pwszStatusBarText + (lstrlenW(pwszStatusBarText) + 1);
            }  // while:  more menu items to add
        }  // Add menu items specific to this resource type
    }  // try
    catch (CException * pe)
    {
        TRACE(_T("CExtObject::CreatePropetySheetPages: Failed to add context menu item\n"));
        pe->Delete();
        if (hr == NOERROR)
            hr = E_FAIL;
    }  // catch:  anything

    if (hr != NOERROR)
    {
        piData->Release();
        m_piData = NULL;
    }  // if:  error occurred

    piCallback->Release();
    return hr;

}  //*** CExtObject::AddContextMenuItems()

/////////////////////////////////////////////////////////////////////////////
// IWEInvokeCommand Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::InvokeCommand (IWEInvokeCommand)
//
//  Routine Description:
//      Invoke a command offered by a context menu.
//
//  Arguments:
//      lCommandID      ID of the menu item to execute.  This is the same
//                          ID passed to the IWCContextMenuCallback
//                          ::AddExtensionMenuItem() method.
//      piData          IUnkown pointer from which to obtain interfaces
//                          for obtaining data describing the object for
//                          which the command is to be invoked.
//
//  Return Value:
//      NOERROR         Command invoked successfully.
//      E_INVALIDARG    Invalid arguments to the function.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::InvokeCommand(
    IN ULONG        nCommandID,
    IN IUnknown *   piData
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Find the item that was executed in our table.
    hr = HrSaveData(piData);
    if (hr == NOERROR)
    {
        ULONG       iCommandID;
        LPWSTR      pwsz = g_rgpwszContextMenuItems[IstrResTypeName()];
        LPWSTR      pwszName;
        LPWSTR      pwszStatusBarText;

        for (iCommandID = 0 ; *pwsz != L'\0' ; iCommandID++)
        {
            pwszName = pwsz;
            pwszStatusBarText = pwszName + (lstrlenW(pwszName) + 1);
            if (iCommandID == nCommandID)
                break;
            pwsz = pwszStatusBarText + (lstrlenW(pwszStatusBarText) + 1);
        }  // while:  more menu items to add
        if (iCommandID == nCommandID)
        {
            CString     strMsg;
            CString     strName;

            try
            {
                strName = pwszName;
                strMsg.Format(_T("Item %s was executed"), strName);
                AfxMessageBox(strMsg);
            }  // try
            catch (CException * pe)
            {
                pe->Delete();
            }  // catch:  CException
        }  // if:  command ID found
    }  // if:  no errors saving the data

    piData->Release();
    m_piData = NULL;
    return NOERROR;

}  //*** CExtObject::InvokeCommand()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetUIInfo
//
//  Routine Description:
//      Get info about displaying UI.
//
//  Arguments:
//      piData          IUnkown pointer from which to obtain interfaces
//                          for obtaining data describing the object.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//      or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetUIInfo(IUnknown * piData)
{
    HRESULT         hr  = NOERROR;

    ASSERT(piData != NULL);

    // Save info about all types of objects.
    {
        IGetClusterUIInfo * pi;

        hr = piData->QueryInterface(IID_IGetClusterUIInfo, (LPVOID *) &pi);
        if (hr != NOERROR)
            return hr;

        m_lcid = pi->GetLocale();
        m_hfont = pi->GetFont();
        m_hicon = pi->GetIcon();

        pi->Release();
    }  // Save info about all types of objects

    return hr;

}  //*** CExtObject::HrGetUIInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrSaveData
//
//  Routine Description:
//      Save data from the object so that it can be used for the life
//      of the object.
//
//  Arguments:
//      piData          IUnkown pointer from which to obtain interfaces
//                          for obtaining data describing the object.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//      or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrSaveData(IUnknown * piData)
{
    HRESULT         hr  = NOERROR;

    ASSERT(piData != NULL);

    if (piData != m_piData)
    {
        if (m_piData != NULL)
            m_piData->Release();
        m_piData = piData;
    }  // if:  different data interface pointer

    // Save info about all types of objects.
    {
        IGetClusterDataInfo *   pi;

        hr = piData->QueryInterface(IID_IGetClusterDataInfo, (LPVOID *) &pi);
        if (hr != NOERROR)
            return hr;

        m_hcluster = pi->GetClusterHandle();
        m_cobj = pi->GetObjectCount();
        if (Cobj() != 1)
            hr = E_NOTIMPL;
        else
            hr = HrGetClusterName(pi);

        pi->Release();
        if (hr != NOERROR)
            return hr;
    }  // Save info about all types of objects

    // Save info about this object.
    hr = HrGetObjectInfo();
    if (hr != NOERROR)
        return hr;

    return hr;

}  //*** CExtObject::HrSaveData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetObjectInfo
//
//  Routine Description:
//      Get information about the object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//      or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectInfo(void)
{
    HRESULT                     hr  = NOERROR;
    IGetClusterObjectInfo *     piGcoi;
    CLUADMEX_OBJECT_TYPE        cot = CLUADMEX_OT_NONE;
    CException                  exc(FALSE /*bAutoDelete*/);
    const CString *             pstrResTypeName = NULL;

    ASSERT(PiData() != NULL);

    // Get object info.
    {
        // Get an IGetClusterObjectInfo interface pointer.
        hr = PiData()->QueryInterface(IID_IGetClusterObjectInfo, (LPVOID *) &piGcoi);
        if (hr != NOERROR)
            return hr;

        // Read the object data.
        try
        {
            // Delete the previous object data.
            delete m_podObjData;
            m_podObjData = NULL;

            // Get the type of the object.
            cot = piGcoi->GetObjectType(0);
            switch (cot)
            {
                case CLUADMEX_OT_CLUSTER:
                    m_podObjData = new CObjData;
                    if ( m_podObjData == NULL )
                    {
                        AfxThrowMemoryException();
                    }
                    break;

                case CLUADMEX_OT_RESOURCE:
                    {
                        IGetClusterResourceInfo *   pi;

                        m_podObjData = new CResData;
                        if ( m_podObjData == NULL )
                        {
                            AfxThrowMemoryException();
                        }

                        // Get an IGetClusterResourceInfo interface pointer.
                        hr = PiData()->QueryInterface(IID_IGetClusterResourceInfo, (LPVOID *) &pi);
                        if (hr != NOERROR)
                        {
                            throw &exc;
                        }

                        PrdResDataRW()->m_hresource = pi->GetResourceHandle(0);
                        ASSERT(PrdResDataRW()->m_hresource != NULL);
                        if (PrdResDataRW()->m_hresource == NULL)
                        {
                            hr = E_INVALIDARG;
                        }
                        else
                        {
                            hr = HrGetResourceTypeName(pi);
                        }

                        pi->Release();
                        if (hr != NOERROR)
                        {
                            throw &exc;
                        }

                        pstrResTypeName = &PrdResDataRW()->m_strResTypeName;
                    }  // if:  object is a resource
                    break;

                case CLUADMEX_OT_RESOURCETYPE:
                    m_podObjData = new CObjData;
                    if ( m_podObjData == NULL )
                    {
                        AfxThrowMemoryException();
                    }
                    pstrResTypeName = &PodObjDataRW()->m_strName;
                    break;

                default:
                    hr = E_NOTIMPL;
                    throw &exc;

            }  // switch:  object type

            PodObjDataRW()->m_cot = cot;
            hr = HrGetObjectName(piGcoi);

        }  // try
        catch (CMemoryException * pme)
        {
            pme->Delete();
            hr = E_OUTOFMEMORY;
        } // catch: CMemoryException
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException

        piGcoi->Release();
        if (hr != NOERROR)
        {
            return hr;
        }

    }  // Get object info

    // If this is a resource or resource type, see if we know about this type.
    if (((cot == CLUADMEX_OT_RESOURCE)
            || (cot == CLUADMEX_OT_RESOURCETYPE))
        && (hr == NOERROR))
    {
        LPCWSTR pwszResTypeName = NULL;

        // Find the resource type name in our list.
        // Save the index for use in other arrays.
        for (m_istrResTypeName = 0, pwszResTypeName = g_wszResourceTypeNames
                ; *pwszResTypeName != L'\0'
                ; m_istrResTypeName++, pwszResTypeName += lstrlenW(pwszResTypeName) + 1
                )
        {
            if (pstrResTypeName->CompareNoCase(pwszResTypeName) == 0)
            {
                break;
            }
        }  // for:  each resource type in the list

        if (*pwszResTypeName == L'\0')
        {
            hr = E_NOTIMPL;
        }

    }  // See if we know about this resource type

    return hr;

}  //*** CExtObject::HrGetObjectInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetClusterName
//
//  Routine Description:
//      Get the name of the cluster.
//
//  Arguments:
//      piData          IGetClusterDataInfo interface pointer for getting
//                          the object name.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//      or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetClusterName(
    IN OUT IGetClusterDataInfo *    pi
    )
{
    HRESULT     hr          = NOERROR;
    WCHAR *     pwszName    = NULL;
    LONG        cchName;

    ASSERT(pi != NULL);

    hr = pi->GetClusterName(NULL, &cchName);
    if (hr != NOERROR)
        return hr;

    try
    {
        pwszName = new WCHAR[cchName];
        hr = pi->GetClusterName(pwszName, &cchName);
        if (hr != NOERROR)
        {
            delete [] pwszName;
            pwszName = NULL;
        }  // if:  error getting cluster name

        m_strClusterName = pwszName;
    }  // try
    catch (CMemoryException * pme)
    {
        pme->Delete();
        hr = E_OUTOFMEMORY;
    }  // catch:  CMemoryException

    delete [] pwszName;
    return hr;

}  //*** CExtObject::HrGetClusterName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetObjectName
//
//  Routine Description:
//      Get the name of the object.
//
//  Arguments:
//      piData          IGetClusterObjectInfo interface pointer for getting
//                          the object name.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//      or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectName(
    IN OUT IGetClusterObjectInfo *  pi
    )
{
    HRESULT     hr          = NOERROR;
    WCHAR *     pwszName    = NULL;
    LONG        cchName;

    ASSERT(pi != NULL);

    hr = pi->GetObjectName(0, NULL, &cchName);
    if (hr != NOERROR)
        return hr;

    try
    {
        pwszName = new WCHAR[cchName];
        hr = pi->GetObjectName(0, pwszName, &cchName);
        if (hr != NOERROR)
        {
            delete [] pwszName;
            pwszName = NULL;
        }  // if:  error getting object name

        PodObjDataRW()->m_strName = pwszName;
    }  // try
    catch (CMemoryException * pme)
    {
        pme->Delete();
        hr = E_OUTOFMEMORY;
    }  // catch:  CMemoryException

    delete [] pwszName;
    return hr;

}  //*** CExtObject::HrGetObjectName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetClusterVersion
//
//  Routine Description:
//      Get the version of the cluster.
//
//  Arguments:
//      ppCvi   [OUT]   holds the Cluster version info.
//
//  Return Value:
//      NOERROR         Data retrieved successfully.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from GetClusterInformation()
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetClusterVersion(
    OUT LPCLUSTERVERSIONINFO *ppCvi
    )
{
    ASSERT(ppCvi != NULL);

    HRESULT hr = E_FAIL;

    if (ppCvi != NULL)
    {
        if (m_pCvi == NULL)
        {
            LPWSTR      pwszName    = NULL;
            DWORD       cchName     = 128;
            CWaitCursor wc;

            try
            {
                pwszName = new WCHAR[cchName];
                m_pCvi = new CLUSTERVERSIONINFO;

                m_pCvi->dwVersionInfoSize = sizeof( CLUSTERVERSIONINFO );

                hr = GetClusterInformation(Hcluster(), pwszName, &cchName, m_pCvi);
                if (hr == ERROR_MORE_DATA)
                {
                    delete [] pwszName;
                    cchName++;
                    pwszName = new WCHAR[cchName];
                    hr = GetClusterInformation(Hcluster(), pwszName, &cchName, m_pCvi);
                }  // if:  buffer is too small

                delete [] pwszName;
                *ppCvi = m_pCvi;
            }  // try
            catch (CException *)
            {
                delete [] pwszName;
                delete m_pCvi;
                m_pCvi = NULL;
                throw;
            }  // catch:  CException
        }
        else
        {
            *ppCvi = m_pCvi;
            hr = S_OK;
        }
    }

    return hr;

}  //*** CExtObject::HrGetClusterVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetResourceTypeName
//
//  Routine Description:
//      Get the name of the resource's type.
//
//  Arguments:
//      piData          IGetClusterResourceInfo interface pointer for getting
//                          the resource type name.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//      or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetResourceTypeName(
    IN OUT IGetClusterResourceInfo *    pi
    )
{
    HRESULT     hr          = NOERROR;
    WCHAR *     pwszName    = NULL;
    LONG        cchName;

    ASSERT(pi != NULL);

    hr = pi->GetResourceTypeName(0, NULL, &cchName);
    if (hr != NOERROR)
        return hr;

    try
    {
        pwszName = new WCHAR[cchName];
        hr = pi->GetResourceTypeName(0, pwszName, &cchName);
        if (hr != NOERROR)
        {
            delete [] pwszName;
            pwszName = NULL;
        }  // if:  error getting resource type name

        PrdResDataRW()->m_strResTypeName = pwszName;
    }  // try
    catch (CMemoryException * pme)
    {
        pme->Delete();
        hr = E_OUTOFMEMORY;
    }  // catch:  CMemoryException

    delete [] pwszName;
    return hr;

}  //*** CExtObject::HrGetResourceTypeName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BGetResourceNetworkName
//
//  Routine Description:
//      Get the name of the resource's type.
//
//  Arguments:
//      lpszNetName     [OUT] String in which to return the network name resource name.
//      pcchNetName     [IN OUT] Points to a variable that specifies the
//                          maximum size, in characters, of the buffer.  This
//                          value shold be large enough to contain
//                          MAX_COMPUTERNAME_LENGTH + 1 characters.  Upon
//                          return it contains the actual number of characters
//                          copied.
//
//  Return Value:
//      TRUE        Resource is dependent on a network name resource.
//      FALSE       Resource is NOT dependent on a network name resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BGetResourceNetworkName(
    OUT WCHAR *     lpszNetName,
    IN OUT DWORD *  pcchNetName
    )
{
    BOOL                        bSuccess;
    IGetClusterResourceInfo *   piGcri;

    ASSERT(PiData() != NULL);

    // Get an IGetClusterResourceInfo interface pointer.
    {
        HRESULT     hr;

        hr = PiData()->QueryInterface(IID_IGetClusterResourceInfo, (LPVOID *) &piGcri);
        if (hr != NOERROR)
        {
            SetLastError(hr);
            return FALSE;
        }  // if:  error getting the interface
    }  // Get an IGetClusterResourceInfo interface pointer

    // Get the resource network name.
    bSuccess = piGcri->GetResourceNetworkName(0, lpszNetName, pcchNetName);

    piGcri->Release();

    return bSuccess;

}  //*** CExtObject::BGetResourceNetworkName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterVersionMixed
//
//  Routine Description:
//      Is the cluster of mixed version?  Meaning that a rolling upgrade is
//      is in progress and not all nodes are up to the current version.
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Cluster is mixed version
//      FALSE       Cluster is homogonous
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterVersionMixed(
    void
    )
{
    BOOL                    bRet = FALSE;
    LPCLUSTERVERSIONINFO    pCvi;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        bRet = pCvi->dwFlags & CLUSTER_VERSION_FLAG_MIXED_MODE;
    }

    return bRet;

}  //*** CExtObject::BIsClusterVersionMixed()

#if 0
//SS: cant tell whether a cluster is a mixed mode sp4 and sp3 cluster or a  pure sp3 cluster
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterVersionNT4Sp3
//
//  Routine Description:
//      Is the cluster version NT4Sp3?
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Cluster is version NT4Sp3
//      FALSE       Cluster is not version NT4Sp3
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterVersionNT4Sp3(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if ((CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT4_MAJOR_VERSION) &&
            !(BIsClusterVersionMixed()))
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterVersionNT4Sp3()

#endif//SS: cant tell whether a cluster is a mixed mode sp4 and sp3 cluster or a  pure sp3 cluster

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterVersionNT4Sp4
//
//  Routine Description:
//      Is the cluster version a pure NT4Sp4 cluster
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Cluster is version NT4Sp4
//      FALSE       Cluster is not version NT4Sp4
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterVersionNT4Sp4(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if ((CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT4SP4_MAJOR_VERSION) &&
            !(BIsClusterVersionMixed()))
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterVersionNT4Sp4()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterVersionNT5
//
//  Routine Description:
//      Is the cluster version a pure NT5 version?
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Cluster is version NT5
//      FALSE       Cluster is not version NT5
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterVersionNT5(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if ((CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT5_MAJOR_VERSION) &&
            !(BIsClusterVersionMixed()))
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterVersionNT5()

#if 0
//SS: cant tell whether a cluster is a mixed mode sp4 and sp3 cluster
//or a  pure sp3 cluster
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterHighestVersionNT4Sp3
//
//  Routine Description:
//      Is the highest cluster version NT4Sp3?
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        highest cluster is version NT4Sp3
//      FALSE       highest cluster is not version NT4Sp3
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterHighestVersionNT4Sp3(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterLowestVersion) == NT4_MAJOR_VERSION)
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterHighestVersionNT4Sp3()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterHighestVersionNT4Sp4
//
//  Routine Description:
//      Is the highest cluster version NT4Sp4?
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        highest cluster is version NT4Sp4
//      FALSE       highest cluster is not version NT4Sp4
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterHighestVersionNT4Sp4(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterLowestVersion) == NT4_MAJOR_VERSION)
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterHighestVersionNT4Sp4()

#endif //SS: cant tell whether a cluster is a mixed mode sp4 and sp3 cluster or a  pure sp3 cluster


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterHighestVersionNT5
//
//  Routine Description:
//      Is the highest cluster version NT5?  Is the node with the
//      highest version in the cluster an nt 5 node.
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        highest cluster is version NT5
//      FALSE       highest cluster is not version NT5
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterHighestVersionNT5(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterLowestVersion) == NT4SP4_MAJOR_VERSION)
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterHighestVersionNT5()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterLowestVersionNT4Sp3
//
//  Routine Description:
//      Is the Lowest cluster version NT4Sp3? Is the node with the lowest
//      version an nt4 sp3 node
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Lowest cluster is version NT4Sp3
//      FALSE       Lowest cluster is not version NT4Sp3
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterLowestVersionNT4Sp3(
    void
    )
{

    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT4_MAJOR_VERSION)
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterLowestVersionNT4Sp3()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterLowestVersionNT4Sp4
//
//  Routine Description:
//      Is the Lowest cluster version NT4Sp4?Is the node with the lowest
//      version an nt4 sp4 node.
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Lowest cluster is version NT4Sp4
//      FALSE       Lowest cluster is not version NT4Sp4
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterLowestVersionNT4Sp4(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT4SP4_MAJOR_VERSION)
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterLowestVersionNT4Sp4()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterLowestVersionNT5
//
//  Routine Description:
//      Is the Lowest cluster version NT5?Is the node with the lowest
//      version an nt5 node
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Lowest cluster is version NT5
//      FALSE       Lowest cluster is not version NT5
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterLowestVersionNT5(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT5_MAJOR_VERSION)
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterLowestVersionNT5()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsAnyNodeVersionLowerThanNT5
//
//  Routine Description:
//      Is the Lowest cluster version NT5?Is the node with the lowest
//      version an nt5 node
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Lowest cluster is version NT5
//      FALSE       Lowest cluster is not version NT5
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsAnyNodeVersionLowerThanNT5(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) < NT5_MAJOR_VERSION)
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterLowestVersionNT5()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsNT5ClusterMember
//
//  Routine Description:
//      Is NT5 a cluster member?
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        NT5 is a cluster member
//      FALSE       NT5 is not a cluster member
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsNT5ClusterMember(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if ((CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT5_MAJOR_VERSION)
            || (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterLowestVersion) == NT4SP4_MAJOR_VERSION))
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsNT5ClusterMember()

#if 0
//SS: cant tell whether a cluster is a mixed mode sp4 and sp3 cluster
//or a  pure sp3 cluster
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsNT4Sp3ClusterMember
//
//  Routine Description:
//      Is NT4Sp3 a cluster member?
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        NT4Sp3 is a cluster member
//      FALSE       NT4Sp3 is not a cluster member
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsNT4Sp3ClusterMember(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if ((CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT4_MAJOR_VERSION))
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsNT4Sp3ClusterMember()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsNT4Sp4ClusterMember
//
//  Routine Description:
//      Is NT4Sp4 a cluster member?
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        NT4Sp4 is a cluster member
//      FALSE       NT4Sp4 is not a cluster member
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsNT4Sp4ClusterMember(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if ((CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT4SP4_MAJOR_VERSION)) 
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsNT4Sp4ClusterMember()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\editacl.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		EditAcl.cpp
//
//	Abstract:
//		Implementation of ACL editor methods.
//
//	Author:
//		David Potter (davidp)	October 9, 1996
//			From \nt\private\window\shell\lmui\ntshrui\acl.cxx
//			by BruceFo
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <lmerr.h>

extern "C"
{
#include <sedapi.h>
}

#include "EditAcl.h"
#include "AclHelp.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))


enum SED_PERM_TYPE{
	SED_AUDITS,
	SED_ACCESSES,
	SED_OWNER
};

enum MAP_DIRECTION 
{
	SPECIFIC_TO_GENERIC = 0,
	GENERIC_TO_SPECIFIC = 1
};

const DWORD LOCAL_ACCOUNTS_FILTERED = 2L;
const BOOL bIsFile = 0;
 
//#define MAPBITS
BOOL MapBitsInSD(PSECURITY_DESCRIPTOR pSecDesc, MAP_DIRECTION direction);
BOOL MapBitsInACL(PACL paclACL, MAP_DIRECTION direction);
BOOL MapSpecificBitsInAce(PACCESS_ALLOWED_ACE pAce);
BOOL MapGenericBitsInAce(PACCESS_ALLOWED_ACE pAce);


typedef
DWORD
(*SedDiscretionaryAclEditorType)(
		HWND						 Owner,
		HANDLE						 Instance,
		LPWSTR						 Server,
		PSED_OBJECT_TYPE_DESCRIPTOR  ObjectType,
		PSED_APPLICATION_ACCESSES	 ApplicationAccesses,
		LPWSTR						 ObjectName,
		PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
		ULONG						 CallbackContext,
		PSECURITY_DESCRIPTOR		 SecurityDescriptor,
		BOOLEAN 					 CouldntReadDacl,
		BOOLEAN 					 CantWriteDacl,
		LPDWORD 					 SEDStatusReturn,
		DWORD						 Flags
		);

// NOTE: the SedDiscretionaryAclEditor string is used in GetProcAddress to
// get the correct entrypoint. Since GetProcAddress is not UNICODE, this string
// must be ANSI.
#define ACLEDIT_DLL_STRING					TEXT("acledit.dll")
#define ACLEDIT_HELPFILENAME				TEXT("ntshrui.hlp")
#define SEDDISCRETIONARYACLEDITOR_STRING	("SedDiscretionaryAclEditor")

//
// Declare the callback routine based on typedef in sedapi.h.
//

DWORD
SedCallback(
	HWND					hwndParent,
	HANDLE					hInstance,
	ULONG					ulCallbackContext,
	PSECURITY_DESCRIPTOR	pSecDesc,
	PSECURITY_DESCRIPTOR	pSecDescNewObjects,
	BOOLEAN 				fApplyToSubContainers,
	BOOLEAN 				fApplyToSubObjects,
	LPDWORD 				StatusReturn
	);

//
// Structure for callback function's usage. A pointer to this is passed as
// ulCallbackContext. The callback functions sets bSecDescModified to TRUE
// and makes a copy of the security descriptor. The caller of EditShareAcl
// is responsible for deleting the memory in pSecDesc if bSecDescModified is
// TRUE. This flag will be FALSE if the user hit CANCEL in the ACL editor.
//
struct SHARE_CALLBACK_INFO
{
	BOOL					bSecDescModified;
	PSECURITY_DESCRIPTOR	pSecDesc;
	LPCTSTR 				pszClusterNameNode;
};

//
// Local function prototypes
//

VOID
InitializeShareGenericMapping(
	IN OUT PGENERIC_MAPPING pSHAREGenericMapping
	);

PWSTR
GetResourceString(
	IN DWORD dwId
	);

PWSTR
NewDup(
	IN const WCHAR* psz
	);

//
// The following two arrays define the permission names for NT Files.  Note
// that each index in one array corresponds to the index in the other array.
// The second array will be modifed to contain a string pointer pointing to
// a loaded string corresponding to the IDS_* in the first array.
//

DWORD g_dwSharePermNames[] =
{
	IDS_ACLEDIT_PERM_GEN_NO_ACCESS,
	IDS_ACLEDIT_PERM_GEN_READ,
	IDS_ACLEDIT_PERM_GEN_MODIFY,
	IDS_ACLEDIT_PERM_GEN_ALL
};

SED_APPLICATION_ACCESS g_SedAppAccessSharePerms[] =
{
	{ SED_DESC_TYPE_RESOURCE, FILE_PERM_NO_ACCESS, 0, NULL },
	{ SED_DESC_TYPE_RESOURCE, FILE_PERM_READ,	   0, NULL },
	{ SED_DESC_TYPE_RESOURCE, FILE_PERM_MODIFY,    0, NULL },
	{ SED_DESC_TYPE_RESOURCE, FILE_PERM_ALL,	   0, NULL }
/*
	{ SED_DESC_TYPE_RESOURCE, FILE_PERM_GEN_NO_ACCESS, 0, NULL },
	{ SED_DESC_TYPE_RESOURCE, FILE_PERM_GEN_READ,	   0, NULL },
	{ SED_DESC_TYPE_RESOURCE, FILE_PERM_GEN_MODIFY,    0, NULL },
	{ SED_DESC_TYPE_RESOURCE, FILE_PERM_GEN_ALL,	   0, NULL }
*/
};


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//	Function:	EditShareAcl
//
//	Synopsis:	Invokes the generic ACL editor, specifically for NT shares
//
//	Arguments:	[hwndParent] - Parent window handle
//				[pszServerName] - Name of server on which the object resides.
//				[pszShareName] - Fully qualified name of resource we will
//					edit, basically a share name.
//				[pSecDesc] - The initial security descriptor. If NULL, we will
//					create a default that is "World all" access.
//				[pbSecDescModified] - Set to TRUE if the security descriptor
//					was modified (i.e., the user hit "OK"), or FALSE if not
//					(i.e., the user hit "Cancel")
//				[ppSecDesc] - *ppSecDesc points to a new security descriptor
//					if *pbSecDescModified is TRUE. This memory must be freed
//					by the caller.
//
//	History:
//		  ChuckC   10-Aug-1992	Created. Culled from NTFS ACL code.
//		  Yi-HsinS 09-Oct-1992	Added ulHelpContextBase
//		  BruceFo  4-Apr-95 	Stole and used in ntshrui.dll
//		  DavidP   10-Oct-1996	Modified for use with CLUADMIN
//
//--------------------------------------------------------------------------

LONG
EditShareAcl(
	IN HWND 					hwndParent,
	IN LPCTSTR					pszServerName,
	IN LPCTSTR					pszShareName,
	IN LPCTSTR					pszClusterNameNode,
	IN PSECURITY_DESCRIPTOR 	pSecDesc,
	OUT BOOL *					pbSecDescModified,
	OUT PSECURITY_DESCRIPTOR *	ppSecDesc
	)
{
	ASSERT(pszShareName != NULL);
	ASSERT(pszClusterNameNode != NULL);
	TRACE(_T("EditShareAcl, share %ws\n"), pszShareName);

	ASSERT((pSecDesc == NULL) || IsValidSecurityDescriptor(pSecDesc));
	ASSERT(pbSecDescModified != NULL);
	ASSERT(ppSecDesc != NULL);

	*pbSecDescModified = FALSE;

	LONG err = 0 ;
	PWSTR pszPermName;
	BOOL bCreatedDefaultSecDesc = FALSE;

	do // error breakout
	{
		/*
		 * if pSecDesc is NULL, this is new file share or a file share with no
		 * security descriptor.
		 * we go and create a new (default) security descriptor.
		 */
		if( NULL == pSecDesc )
		{
			TRACE(_T("Security Descriptor is NULL.  Grant everyone Full Control\n") );
			LONG err = CreateDefaultSecDesc( &pSecDesc );
			if (err != NERR_Success)
			{
				err = GetLastError();
				TRACE(_T("CreateDefaultSecDesc failed, 0x%08lx\n"), err);
				break;
			}
			TRACE(_T("CreateDefaultSecDesc descriptor = 0x%08lx\n"), pSecDesc);
			bCreatedDefaultSecDesc = TRUE;
			
		}
		ASSERT(IsValidSecurityDescriptor(pSecDesc));

		/* Retrieve the resource strings appropriate for the type of object we
		 * are looking at
		 */

		CString strTypeName;
		CString strDefaultPermName;

		try
		{
			strTypeName.LoadString(IDS_ACLEDIT_TITLE);
			strDefaultPermName.LoadString(IDS_ACLEDIT_PERM_GEN_ALL);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
		}

		/*
		 * other misc stuff we need pass to security editor
		 */
		SED_OBJECT_TYPE_DESCRIPTOR sedObjDesc ;
		SED_HELP_INFO sedHelpInfo ;
		GENERIC_MAPPING SHAREGenericMapping ;

		// setup mappings
		InitializeShareGenericMapping( &SHAREGenericMapping ) ;

		WCHAR szHelpFile[50] = ACLEDIT_HELPFILENAME;
		sedHelpInfo.pszHelpFileName = szHelpFile;

		sedHelpInfo.aulHelpContext[HC_MAIN_DLG] =				 HC_UI_SHELL_BASE + HC_NTSHAREPERMS ;
		sedHelpInfo.aulHelpContext[HC_ADD_USER_DLG] =			 HC_UI_SHELL_BASE + HC_SHAREADDUSER ;
		sedHelpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_GG_DLG] = HC_UI_SHELL_BASE + HC_SHAREADDUSER_GLOBALGROUP ;
		sedHelpInfo.aulHelpContext[HC_ADD_USER_SEARCH_DLG] =	 HC_UI_SHELL_BASE + HC_SHAREADDUSER_FINDUSER ;

		// These are not used, set to zero
		sedHelpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG]		   = 0 ;
		sedHelpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] = 0 ;

		// setup the object description
		sedObjDesc.Revision 				   = SED_REVISION1 ;
		sedObjDesc.IsContainer				   = FALSE ;
		sedObjDesc.AllowNewObjectPerms		   = FALSE ;
		sedObjDesc.MapSpecificPermsToGeneric   = TRUE ;
		sedObjDesc.GenericMapping			   = &SHAREGenericMapping ;
		sedObjDesc.GenericMappingNewObjects    = &SHAREGenericMapping ;
		sedObjDesc.ObjectTypeName			   = (LPWSTR) (LPCWSTR) strTypeName ;
		sedObjDesc.HelpInfo 				   = &sedHelpInfo ;
		sedObjDesc.SpecialObjectAccessTitle    = NULL ;

		/* Now we need to load the global arrays with the permission names
		 * from the resource file.
		 */
		UINT cArrayItems  = ARRAYLEN(g_SedAppAccessSharePerms);
		PSED_APPLICATION_ACCESS aSedAppAccess = g_SedAppAccessSharePerms ;

		/* Loop through each permission title retrieving the text from the
		 * resource file and setting the pointer in the array.
		 */

		for ( UINT i = 0 ; i < cArrayItems ; i++ )
		{
			pszPermName = GetResourceString(g_dwSharePermNames[i]) ;
			if (NULL == pszPermName)
			{
				TRACE(_T("GetResourceString failed\n"));
				break ;
			}
			aSedAppAccess[i].PermissionTitle = pszPermName;
		}
		if (i < cArrayItems)
		{
			TRACE(_T("failed to get all share permission names\n"));
			break ;
		}

		SED_APPLICATION_ACCESSES sedAppAccesses ;
		sedAppAccesses.Count		   = cArrayItems ;
		sedAppAccesses.AccessGroup	   = aSedAppAccess ;
		sedAppAccesses.DefaultPermName = (LPWSTR) (LPCWSTR) strDefaultPermName;

		/*
		 * pass this along so when the call back function is called,
		 * we can set it.
		 */
		SHARE_CALLBACK_INFO callbackinfo ;
		callbackinfo.pSecDesc			= NULL;
		callbackinfo.bSecDescModified	= FALSE;
		callbackinfo.pszClusterNameNode = pszClusterNameNode;

		//
		// Now, load up the ACL editor and invoke it. We don't keep it around
		// because our DLL is loaded whenever the system is, so we don't want
		// the netui*.dll's hanging around as well...
		//

		HINSTANCE hInstanceAclEditor = NULL;
		SedDiscretionaryAclEditorType pAclEditor = NULL;

		hInstanceAclEditor = LoadLibrary(ACLEDIT_DLL_STRING);


		if (NULL == hInstanceAclEditor)
		{
			err = GetLastError();
			TRACE(_T("LoadLibrary of acledit.dll failed, 0x%08lx\n"), err);
			break;
		}

		pAclEditor = (SedDiscretionaryAclEditorType) GetProcAddress(
														hInstanceAclEditor,
														SEDDISCRETIONARYACLEDITOR_STRING
														);
		if ( pAclEditor == NULL )
		{
			err = GetLastError();
			TRACE(_T("GetProcAddress of SedDiscretionaryAclEditorType failed, 0x%08lx\n"), err);
			break;
		}

#ifdef MAPBITS
		MapBitsInSD( pSecDesc, SPECIFIC_TO_GENERIC );
#endif

		DWORD dwSedReturnStatus ;

		ASSERT(pAclEditor != NULL);
		err = (*pAclEditor)(
						hwndParent,
						AfxGetInstanceHandle(),
						(LPTSTR) pszServerName,
						&sedObjDesc,
						&sedAppAccesses,
						(LPTSTR) pszShareName,
						SedCallback,
						(ULONG) &callbackinfo,
						pSecDesc,
						FALSE, // always can read
						FALSE, // if we can read, we can write
						(LPDWORD) &dwSedReturnStatus,
						0
						);


		if (pSecDesc != NULL)
		{
#ifdef MAPBITS
			MapBitsInSD( pSecDesc, GENERIC_TO_SPECIFIC );
#endif
			ASSERT(IsValidSecurityDescriptor(pSecDesc));
		}  // if:  no security descriptor returned

		if (!FreeLibrary(hInstanceAclEditor))
		{
			LONG err2 = GetLastError();
			TRACE(_T("FreeLibrary of acledit.dll failed, 0x%08lx\n"), err2);
			// not fatal: continue...
		}

		if (0 != err)
		{
			TRACE(_T("SedDiscretionaryAclEditor failed, 0x%08lx\n"), err);
			break ;
		}

		*pbSecDescModified = callbackinfo.bSecDescModified ;

		if (*pbSecDescModified)
		{
			*ppSecDesc = callbackinfo.pSecDesc;
#ifdef MAPBITS
			MapBitsInSD( *ppSecDesc, GENERIC_TO_SPECIFIC );
#endif
			TRACE(_T("After calling acl editor, *ppSecDesc = 0x%08lx\n"), *ppSecDesc);
			ASSERT(IsValidSecurityDescriptor(*ppSecDesc));
		}

	} while (FALSE) ;

	//
	// Free memory...
	//

	UINT cArrayItems  = ARRAYLEN(g_SedAppAccessSharePerms);
	PSED_APPLICATION_ACCESS aSedAppAccess = g_SedAppAccessSharePerms ;
	for ( UINT i = 0 ; i < cArrayItems ; i++ )
	{
		pszPermName = aSedAppAccess[i].PermissionTitle;
		if (NULL == pszPermName)
		{
			// if we hit a NULL, that's it!
			break ;
		}

		delete[] pszPermName;
	}

	if (bCreatedDefaultSecDesc)
	{
		DeleteDefaultSecDesc(pSecDesc);
	}

	ASSERT(!*pbSecDescModified || IsValidSecurityDescriptor(*ppSecDesc));

	if (0 != err)
	{
		CString 	strCaption;
		CString 	strMsg;

		try
		{
			strCaption.LoadString(IDS_MSGTITLE);
			strMsg.LoadString(IDS_NOACLEDITOR);
			MessageBox(hwndParent, strMsg, strCaption, MB_OK | MB_ICONSTOP);
		}  // try
		catch (CException * pe)
		{
			pe->Delete();
		};
	}

	return err;

}  //*** EditShareAcl()



BOOL BLocalAccountsInSD(PSECURITY_DESCRIPTOR pSD, LPCTSTR pszClusterNameNode)
{
/*++

Routine Description:

	Determines if any ACEs for local accounts are in DACL stored in
	Security Descriptor (pSD) after the ACL editor has been called

	Added this function in order to prevent users from selecting local accounts in 
	permissions dialog.
	Rod Sharper 04/29/97

Arguments:

	pSD - Security Descriptor to be checked.

Return Value:

	TRUE if at least one ACE was removed from the DACL, False otherwise.

--*/
	PACL					paclDACL			= NULL;
	BOOL					bHasDACL			= FALSE;
	BOOL					bDaclDefaulted		= FALSE;
	BOOL					bLocalAccountInACL	= FALSE;
	BOOL					bRtn				= FALSE;

	ACL_SIZE_INFORMATION	asiAclSize;
	DWORD					dwBufLength;
	DWORD					dwACL_Index = 0L;
	ACCESS_ALLOWED_ACE *	paaAllowedAce;
	TCHAR					szUserName[128];
	TCHAR					szDomainName[128];
	DWORD					cbUser	= 128;
	DWORD					cbDomain	= 128;
	SID_NAME_USE			SidType;
	PUCHAR					pnSubAuthorityCount;
	PULONG					pnSubAuthority0;
	PULONG					pnSubAuthority1;

	bRtn = IsValidSecurityDescriptor(pSD);
	ASSERT(bRtn);
	if( !bRtn )
		return FALSE;

	bRtn = GetSecurityDescriptorDacl(
									pSD,
									(LPBOOL)&bHasDACL,
									(PACL *)&paclDACL,
									(LPBOOL)&bDaclDefaulted);
	ASSERT(bRtn);
	if( !bRtn )
		return FALSE;
 
	if (NULL == paclDACL)
		return FALSE;

	bRtn = IsValidAcl(paclDACL);
	ASSERT(bRtn);
	if( !bRtn )
		return FALSE;

	dwBufLength = sizeof(asiAclSize);

	bRtn = GetAclInformation(
							paclDACL,
							(LPVOID)&asiAclSize,
							(DWORD)dwBufLength,
							(ACL_INFORMATION_CLASS)AclSizeInformation);
	ASSERT(bRtn);
	if( !bRtn )
		return FALSE;

	// Search the ACL for local account ACEs 
	//
	PSID pSID;
	while( dwACL_Index < asiAclSize.AceCount )
	{
		if (!GetAce(paclDACL, dwACL_Index, (LPVOID *)&paaAllowedAce))
		{
			ASSERT(FALSE);
			return FALSE; 
		}
		if((((PACE_HEADER)paaAllowedAce)->AceType) == ACCESS_ALLOWED_ACE_TYPE)
		{
			//
			//Get SID from ACE
			//

			pSID=(PSID)&((PACCESS_ALLOWED_ACE)paaAllowedAce)->SidStart;
	
			cbUser		= 128;
			cbDomain	= 128;
			if (LookupAccountSid(NULL,
								 pSID,
								 szUserName,
								 &cbUser,
								 szDomainName,
								 &cbDomain,
								 &SidType))
			{
				if (lstrcmpi(szDomainName, _T("BUILTIN")) == 0)
				{
					pnSubAuthorityCount = GetSidSubAuthorityCount( pSID );
					if ( (pnSubAuthorityCount != NULL) && (*pnSubAuthorityCount == 2) )
					{
						// Check to see if this is the local Administrators group.
						pnSubAuthority0 = GetSidSubAuthority( pSID, 0 );
						pnSubAuthority1 = GetSidSubAuthority( pSID, 1 );
						if (   (pnSubAuthority0 == NULL)
							|| (pnSubAuthority1 == NULL)
							|| (   (*pnSubAuthority0 != SECURITY_BUILTIN_DOMAIN_RID)
								&& (*pnSubAuthority1 != SECURITY_BUILTIN_DOMAIN_RID))
							|| (   (*pnSubAuthority0 != DOMAIN_ALIAS_RID_ADMINS)
								&& (*pnSubAuthority1 != DOMAIN_ALIAS_RID_ADMINS)))
						{
							bLocalAccountInACL = TRUE;
							break;
						}  // if:  not the local Administrators group
					}  // if:  exactly 2 sub-authorities
					else
					{
						bLocalAccountInACL = TRUE;
						break;
					}  // else:  unexpected # of sub-authorities
				}  // if:  built-in user or group
				else if (  (lstrcmpi(szDomainName, pszClusterNameNode) == 0)
						&& (SidType != SidTypeDomain) )
				{
					// The domain name is the name of the node on which the
					// cluster name resource is online, so this is a local
					// user or group.
					bLocalAccountInACL = TRUE;
					break;
				}  // else if:	domain is cluster name resource node and not a Domain SID
			}  // if:  LookupAccountSid succeeded
			else
			{
				// If LookupAccountSid failed, assume that the SID is for
				// a user or group that is local to a machine to which we
				// don't have access.
				bLocalAccountInACL = TRUE;
				break;
			}  // else:  LookupAccountSid failed
		}
		dwACL_Index++;
	}

	return bLocalAccountInACL;

}  //*** BLocalAccountsInSD()


//+-------------------------------------------------------------------------
//
//	Function:	SedCallback
//
//	Synopsis:	Security Editor callback for the SHARE ACL Editor
//
//	Arguments:	See sedapi.h
//
//	History:
//		  ChuckC   10-Aug-1992	Created
//		  BruceFo  4-Apr-95 	Stole and used in ntshrui.dll
//		  DavidP   10-Oct-1996	Modified for use with CLUADMIN
//
//--------------------------------------------------------------------------

DWORD
SedCallback(
	HWND					hwndParent,
	HANDLE					hInstance,
	ULONG					ulCallbackContext,
	PSECURITY_DESCRIPTOR	pSecDesc,
	PSECURITY_DESCRIPTOR	pSecDescNewObjects,
	BOOLEAN 				fApplyToSubContainers,
	BOOLEAN 				fApplyToSubObjects,
	LPDWORD 				StatusReturn
	)
{
	SHARE_CALLBACK_INFO * pCallbackInfo = (SHARE_CALLBACK_INFO *)ulCallbackContext;

	TRACE(_T("SedCallback, got pSecDesc = 0x%08lx\n"), pSecDesc);

	ASSERT(pCallbackInfo != NULL);
	ASSERT(IsValidSecurityDescriptor(pSecDesc));

	if ( BLocalAccountsInSD(pSecDesc, pCallbackInfo->pszClusterNameNode) )
	{
		CString strMsg;
		strMsg.LoadString(IDS_LOCAL_ACCOUNTS_SPECIFIED);
		AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
		return LOCAL_ACCOUNTS_FILTERED;
	}  // if:  local users or groups were specified


	ASSERT(pCallbackInfo != NULL);

	delete[] (BYTE*)pCallbackInfo->pSecDesc;
	pCallbackInfo->pSecDesc 		= CopySecurityDescriptor(pSecDesc);
	pCallbackInfo->bSecDescModified = TRUE;

	ASSERT(IsValidSecurityDescriptor(pCallbackInfo->pSecDesc));
	TRACE(_T("SedCallback, return pSecDesc = 0x%08lx\n"), pCallbackInfo->pSecDesc);

	return NOERROR;

}  //*** SedCallback()


//+-------------------------------------------------------------------------
//
//	Function:	InitializeShareGenericMapping
//
//	Synopsis:	Initializes the passed generic mapping structure for shares.
//
//	Arguments:	[pSHAREGenericMapping] - Pointer to GENERIC_MAPPING to be init.
//
//	History:
//		  ChuckC   10-Aug-1992	Created. Culled from NTFS ACL code.
//		  BruceFo  4-Apr-95 	Stole and used in ntshrui.dll
//		  DavidP   10-Oct-1996	Modified for use with CLUADMIN
//
//--------------------------------------------------------------------------

VOID
InitializeShareGenericMapping(
	IN OUT PGENERIC_MAPPING pSHAREGenericMapping
	)
{
	TRACE(_T("InitializeShareGenericMapping\n"));
 
	pSHAREGenericMapping->GenericRead	 = GENERIC_READ;
	pSHAREGenericMapping->GenericWrite	 = GENERIC_WRITE;
	pSHAREGenericMapping->GenericExecute = GENERIC_EXECUTE;
	pSHAREGenericMapping->GenericAll	 = GENERIC_ALL;

}  //*** InitializeShareGenericMapping()


//+-------------------------------------------------------------------------
//
//	Function:	CreateDefaultSecDesc
//
//	Synopsis:	Create a default ACL for either a new share or for
//				a share that doesn't exist.
//
//	Arguments:	[ppSecDesc] - *ppSecDesc points to a "world all" access
//					security descriptor on exit. Caller is responsible for
//					freeing it.
//
//	Returns:	NERR_Success if OK, api error otherwise.
//
//	History:
//		  ChuckC   10-Aug-1992	Created. Culled from NTFS ACL code.
//		  BruceFo  4-Apr-95 	Stole and used in ntshrui.dll
//		  DavidP   10-Oct-1996	Modified for use with CLUADMIN
//
//--------------------------------------------------------------------------

LONG
CreateDefaultSecDesc(
	OUT PSECURITY_DESCRIPTOR* ppSecDesc
	)
{
	TRACE(_T("CreateDefaultSecDesc\n"));

	ASSERT(ppSecDesc != NULL) ;
	ASSERT(*ppSecDesc == NULL) ;

	LONG					err = NERR_Success;
	PSECURITY_DESCRIPTOR	pSecDesc = NULL;
	PACL					pAcl = NULL;
	DWORD					cbAcl;
	PSID					pSid = NULL;

	*ppSecDesc = NULL;

	do		  // error breakout
	{
		// First, create a world SID. Next, create an access allowed
		// ACE with "Generic All" access with the world SID. Put the ACE in
		// the ACL and the ACL in the security descriptor.

		SID_IDENTIFIER_AUTHORITY IDAuthorityWorld = SECURITY_WORLD_SID_AUTHORITY;

		if (!AllocateAndInitializeSid(
					&IDAuthorityWorld,
					1,
					SECURITY_WORLD_RID,
					0, 0, 0, 0, 0, 0, 0,
					&pSid))
		{
			err = GetLastError();
			TRACE(_T("AllocateAndInitializeSid failed, 0x%08lx\n"), err);
			break;
		}

		ASSERT(IsValidSid(pSid));

		cbAcl = sizeof(ACL)
			  + (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))
			  + GetLengthSid(pSid)
			  ;

		try
		{
			pAcl = (PACL) new BYTE[cbAcl];
		}  // try
		catch (CMemoryException * pme)
		{
			err = ERROR_OUTOFMEMORY;
			TRACE(_T("new ACL failed\n"));
			pme->Delete();
			break;
		}  // catch:  CMemoryException

		if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION2))
		{
			err = GetLastError();
			TRACE(_T("InitializeAcl failed, 0x%08lx\n"), err);
			break;
		}

		if (!AddAccessAllowedAce(
					pAcl,
					ACL_REVISION2,
					FILE_PERM_ALL,
					pSid))
		{
			err = GetLastError();
			TRACE(_T("AddAccessAllowedAce failed, 0x%08lx\n"), err);
			break;
		}

		ASSERT(IsValidAcl(pAcl));

		try
		{
			pSecDesc = (PSECURITY_DESCRIPTOR) new BYTE[SECURITY_DESCRIPTOR_MIN_LENGTH];
		}  // try
		catch (CMemoryException * pme)
		{
			err = ERROR_OUTOFMEMORY;
			TRACE(_T("new SECURITY_DESCRIPTOR failed\n"));
			pme->Delete();
			break;
		}  // catch:  CMemoryException

		if (!InitializeSecurityDescriptor(
					pSecDesc,
					SECURITY_DESCRIPTOR_REVISION1))
		{
			err = GetLastError();
			TRACE(_T("InitializeSecurityDescriptor failed, 0x%08lx\n"), err);
			break;
		}

		if (!SetSecurityDescriptorDacl(
					pSecDesc,
					TRUE,
					pAcl,
					FALSE))
		{
			err = GetLastError();
			TRACE(_T("SetSecurityDescriptorDacl failed, 0x%08lx\n"), err);
			break;
		}

		ASSERT(IsValidSecurityDescriptor(pSecDesc));

		// Make the security descriptor self-relative

		DWORD dwLen = GetSecurityDescriptorLength(pSecDesc);
		TRACE(_T("SECURITY_DESCRIPTOR length = %d\n"), dwLen);

		PSECURITY_DESCRIPTOR pSelfSecDesc = NULL;
		try
		{
			pSelfSecDesc = (PSECURITY_DESCRIPTOR) new BYTE[dwLen];
		}  // try
		catch (CMemoryException * pme)
		{
			err = ERROR_OUTOFMEMORY;
			TRACE(_T("new SECURITY_DESCRIPTOR (2) failed\n"));
			pme->Delete();
			break;
		}  // catch:  CMemoryException

		DWORD cbSelfSecDesc = dwLen;
		if (!MakeSelfRelativeSD(pSecDesc, pSelfSecDesc, &cbSelfSecDesc))
		{
			err = GetLastError();
			TRACE(_T("MakeSelfRelativeSD failed, 0x%08lx\n"), err);
			break;
		}

		ASSERT(IsValidSecurityDescriptor(pSelfSecDesc));

		//
		// all done: set the security descriptor
		//

		*ppSecDesc = pSelfSecDesc;

	} while (FALSE) ;

	if (NULL != pSid)
	{
		FreeSid(pSid);
	}
	delete[] (BYTE*)pAcl;
	delete[] (BYTE*)pSecDesc;

	ASSERT(IsValidSecurityDescriptor(*ppSecDesc));

	return err;

}  //*** CreateDefaultSecDesc()


//+-------------------------------------------------------------------------
//
//	Function:	DeleteDefaultSecDesc
//
//	Synopsis:	Delete a security descriptor that was created by
//				CreateDefaultSecDesc
//
//	Arguments:	[pSecDesc] - security descriptor to delete
//
//	Returns:	nothing
//
//	History:
//		  BruceFo  4-Apr-95 	Created
//		  DavidP   10-Oct-1996	Modified for use with CLUADMIN
//
//--------------------------------------------------------------------------

VOID
DeleteDefaultSecDesc(
	IN PSECURITY_DESCRIPTOR pSecDesc
	)
{
	TRACE(_T("DeleteDefaultSecDesc\n"));

	delete[] (BYTE*)pSecDesc;

}  //*** DeleteDefaultSecDesc()


//+-------------------------------------------------------------------------
//
//	Member: 	CopySecurityDescriptor, public
//
//	Synopsis:	Copy an NT security descriptor. The security descriptor must
//				be in self-relative (not absolute) form. Delete the result
//				using "delete[] (BYTE*)pSecDesc".
//
//	History:	19-Apr-95	BruceFo 	Created
//				10-Oct-1996 DavidP		Modified for use with CLUADMIN
//
//--------------------------------------------------------------------------

PSECURITY_DESCRIPTOR
CopySecurityDescriptor(
	IN PSECURITY_DESCRIPTOR pSecDesc
	)
{
	TRACE(_T("CopySecurityDescriptor, pSecDesc = 0x%08lx\n"), pSecDesc);

	if (NULL == pSecDesc)
	{
		return NULL;
	}

	ASSERT(IsValidSecurityDescriptor(pSecDesc));

	DWORD dwLen = GetSecurityDescriptorLength(pSecDesc);
	PSECURITY_DESCRIPTOR pSelfSecDesc = NULL;
	try
	{
		pSelfSecDesc = (PSECURITY_DESCRIPTOR) new BYTE[dwLen];
	}
	catch (CMemoryException * pme)
	{
		TRACE(_T("new SECURITY_DESCRIPTOR (2) failed\n"));
		pme->Delete();
		return NULL;	// actually, should probably return an error
	}  // catch:  CMemoryException

	DWORD cbSelfSecDesc = dwLen;
	if (!MakeSelfRelativeSD(pSecDesc, pSelfSecDesc, &cbSelfSecDesc))
	{
		TRACE(_T("MakeSelfRelativeSD failed, 0x%08lx\n"), GetLastError());

		// assume it failed because it was already self-relative
		CopyMemory(pSelfSecDesc, pSecDesc, dwLen);
	}

	ASSERT(IsValidSecurityDescriptor(pSelfSecDesc));

	return pSelfSecDesc;

}  //*** CopySecurityDescriptor()


//+---------------------------------------------------------------------------
//
//	Function:	GetResourceString
//
//	Synopsis:	Load a resource string, are return a "new"ed copy
//
//	Arguments:	[dwId] -- a resource string ID
//
//	Returns:	new memory copy of a string
//
//	History:	5-Apr-95	BruceFo Created
//				10-Oct-1996 DavidP	Modified for CLUADMIN
//
//----------------------------------------------------------------------------

PWSTR
GetResourceString(
	IN DWORD dwId
	)
{
	CString str;

	if (str.LoadString(dwId))
		return NewDup(str);
	else
		return NULL;

}  //*** GetResourceString()


//+---------------------------------------------------------------------------
//
//	Function:	NewDup
//
//	Synopsis:	Duplicate a string using '::new'
//
//	History:	28-Dec-94	BruceFo   Created
//				10-Oct-1996 DavidP	  Modified for CLUADMIN
//
//----------------------------------------------------------------------------

PWSTR
NewDup(
	IN const WCHAR* psz
	)
{
	PWSTR pszRet = NULL;

	if (NULL == psz)
	{
		TRACE(_T("Illegal string to duplicate: NULL\n"));
		return NULL;
	}

	try
	{
		pszRet = new WCHAR[wcslen(psz) + 1];
	}
	catch (CMemoryException * pme)
	{
		TRACE(_T("OUT OF MEMORY\n"));
		pme->Delete();
		return NULL;
	}  // catch:  CMemoryException

	wcscpy(pszRet, psz);
	return pszRet;

}  //*** NewDup()

//+-------------------------------------------------------------------------
//
//	Function:	MapBitsInSD
//
//	Synopsis:	Maps Specific bits to Generic bit when MAP_DIRECTION is SPECIFIC_TO_GENERIC 
//				Maps Generic bits to Specific bit when MAP_DIRECTION is GENERIC_TO_SPECIFIC

//
//	Arguments:	[pSecDesc] - SECURITY_DESCIRPTOR to be modified
//				[direction] - indicates whether bits are mapped from specific to generic 
//							  or generic to specific.
//	Author:
//		Roderick Sharper (rodsh) April 12, 1997
//
//	History:
//
//--------------------------------------------------------------------------

BOOL MapBitsInSD(PSECURITY_DESCRIPTOR pSecDesc, MAP_DIRECTION direction)
{

	PACL	paclDACL		= NULL;
	BOOL	bHasDACL		= FALSE;
	BOOL	bDaclDefaulted	= FALSE;
	BOOL	bRtn			= FALSE;

	if (!IsValidSecurityDescriptor(pSecDesc))
		return FALSE; 


	if (!GetSecurityDescriptorDacl(pSecDesc,
				 (LPBOOL)&bHasDACL,
				 (PACL *)&paclDACL,
				 (LPBOOL)&bDaclDefaulted))
		return FALSE; 

 
	if (paclDACL)
		bRtn = MapBitsInACL(paclDACL, direction);

 return bRtn;
}


//+-------------------------------------------------------------------------
//
//	Function:	MapBitsInACL
//
//	Synopsis:	Maps Specific bits to Generic bit when MAP_DIRECTION is SPECIFIC_TO_GENERIC 
//				Maps Generic bits to Specific bit when MAP_DIRECTION is GENERIC_TO_SPECIFIC
//
//
//	Arguments:	[paclACL] - ACL (Access Control List) to be modified
//				[direction] - indicates whether bits are mapped from specific to generic 
//							  or generic to specific.
//	Author:
//		Roderick Sharper (rodsh) May 02, 1997
//
//	History:
//
//--------------------------------------------------------------------------

BOOL MapBitsInACL(PACL paclACL, MAP_DIRECTION direction)
{
	ACL_SIZE_INFORMATION		asiAclSize;
	BOOL						bRtn = FALSE;
	DWORD						dwBufLength;
	DWORD						dwACL_Index;
	ACCESS_ALLOWED_ACE	 *paaAllowedAce;

	if (!IsValidAcl(paclACL))
		return FALSE; 

	dwBufLength = sizeof(asiAclSize);

	if (!GetAclInformation(paclACL,
			 (LPVOID)&asiAclSize,
			 (DWORD)dwBufLength,
			 (ACL_INFORMATION_CLASS)AclSizeInformation))
		return FALSE; 

	for (dwACL_Index = 0; dwACL_Index < asiAclSize.AceCount;  dwACL_Index++)
	{
		if (!GetAce(paclACL,
			dwACL_Index,
			(LPVOID *)&paaAllowedAce))
		return FALSE; 

		if( direction == SPECIFIC_TO_GENERIC )
			bRtn = MapSpecificBitsInAce( paaAllowedAce );
		else if( direction == GENERIC_TO_SPECIFIC )
			bRtn = MapGenericBitsInAce( paaAllowedAce );
		else
			bRtn = FALSE;
	}

	return bRtn;
}


//+-------------------------------------------------------------------------
//
//	Function:	MapSpecificBitsInAce  
//
//	Synopsis:	Maps specific bits in ACE to generic bits
//
//	Arguments:	[paaAllowedAce] - ACE (Access Control Entry) to be modified
//				[direction] 	- indicates whether bits are mapped from specific to generic 
//								  or generic to specific.
//	Author:
//		Roderick Sharper (rodsh) May 02, 1997
//
//	History:
//
//--------------------------------------------------------------------------

BOOL MapSpecificBitsInAce(PACCESS_ALLOWED_ACE paaAllowedAce)
{
	ACCESS_MASK amMask = paaAllowedAce->Mask;
	BOOL bRtn = FALSE;

	DWORD dwGenericBits;
	DWORD dwSpecificBits;

	dwSpecificBits			  = (amMask & SPECIFIC_RIGHTS_ALL);
	dwGenericBits			  = 0;

	switch( dwSpecificBits )
	{
		case CLUSAPI_READ_ACCESS:	dwGenericBits = GENERIC_READ;	// GENERIC_READ  == 0x80000000L 
									bRtn = TRUE;
									break;

		case CLUSAPI_CHANGE_ACCESS: dwGenericBits = GENERIC_WRITE;	// GENERIC_WRITE == 0x40000000L 
									bRtn = TRUE;
									break;
		
		case CLUSAPI_NO_ACCESS: 	dwGenericBits = GENERIC_EXECUTE;// GENERIC_EXECUTE == 0x20000000L 
									bRtn = TRUE;
									break;
		
		case CLUSAPI_ALL_ACCESS:	dwGenericBits = GENERIC_ALL;	// GENERIC_ALL	 == 0x10000000L
									bRtn = TRUE;
									break;
		
		default:	dwGenericBits = 0x00000000L;	// Invalid,assign no rights. 
									bRtn = FALSE;
									break;
	}

	amMask = dwGenericBits;
	paaAllowedAce->Mask = amMask;

	return bRtn;
}

//+-------------------------------------------------------------------------
//
//	Function:	MapGenericBitsInAce  
//
//	Synopsis:	Maps generic bits in ACE to specific bits
//
//	Arguments:	[paaAllowedAce] - ACE (Access Control Entry) to be modified
//				[direction] 	- indicates whether bits are mapped from specific to generic 
//								  or generic to specific.
//	Author:
//		Roderick Sharper (rodsh) May 02, 1997
//
//	History:
//
//--------------------------------------------------------------------------

BOOL MapGenericBitsInAce  (PACCESS_ALLOWED_ACE paaAllowedAce)
{
	#define GENERIC_RIGHTS_ALL_THE_BITS  0xF0000000L

	ACCESS_MASK amMask = paaAllowedAce->Mask;
	BOOL bRtn = FALSE;

	DWORD dwGenericBits;
	DWORD dwSpecificBits;

	dwSpecificBits			  = 0;
	dwGenericBits			  = (amMask & GENERIC_RIGHTS_ALL_THE_BITS);

		switch( dwGenericBits )
	{
		case GENERIC_ALL:		dwSpecificBits = CLUSAPI_ALL_ACCESS;	// CLUSAPI_ALL_ACCESS		== 3 
								bRtn = TRUE;
								break;
								
		case GENERIC_EXECUTE:	dwSpecificBits = CLUSAPI_NO_ACCESS; 	// CLUSAPI_NO_ACCESS		== 4
								bRtn = TRUE;
								break;

		case GENERIC_WRITE: 	dwSpecificBits = CLUSAPI_CHANGE_ACCESS; // CLUSAPI_CHANGE_ACCESS	== 2
								bRtn = TRUE;
								break;
								
		case GENERIC_READ:		dwSpecificBits = CLUSAPI_READ_ACCESS;	// CLUSAPI_READ_ACCESS		== 1
								bRtn = TRUE;
								break;
		
		default:				dwSpecificBits = 0x00000000L;			// Invalid, assign no rights. 
								bRtn = FALSE;
								break;
	}						

	amMask = dwSpecificBits;
	paaAllowedAce->Mask = amMask;

	return bRtn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\excopers.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ExcOperS.cpp
//
//	Abstract:
//		Stub for implementation of exception classes.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ExcOper.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\fsadv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		FSAdv.cpp
//
//	Abstract:
//		Implementation of the CFileShareAdvancedDlg classes.
//
//	Author:
//		David Potter (davidp)	June 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "FSAdv.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileShareAdvancedDlg dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CFileShareAdvancedDlg, CBaseDialog)
	//{{AFX_MSG_MAP(CFileShareAdvancedDlg)
	ON_BN_CLICKED(IDC_FILESHR_ADV_NORMAL_SHARE, OnChangedChoice)
	ON_BN_CLICKED(IDC_FILESHR_ADV_DFS_ROOT, OnChangedChoice)
	ON_BN_CLICKED(IDC_FILESHR_ADV_SHARE_SUBDIRS, OnChangedChoice)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareAdvancedDlg::CFileShareAdvancedDlg
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		bShareSubDirs		[IN] Default value for the Share subdirectories radio button.
//		bHideSubDirShare	[IN] Default value for the Hide subdirectory shares checkbox.
//		bIsDfsRoot			[IN] Default value for the DFS Root radio button
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CFileShareAdvancedDlg::CFileShareAdvancedDlg(
	BOOL bShareSubDirs,
	BOOL bHideSubDirShares,
	BOOL bIsDfsRoot,
	CWnd * pParent /*=NULL*/
	)
	: CBaseDialog(IDD, g_aHelpIDs_IDD_FILESHR_ADVANCED, pParent)
{
	//{{AFX_DATA_INIT(CFileShareAdvancedDlg)
	m_bShareSubDirs = bShareSubDirs;
	m_bHideSubDirShares = bHideSubDirShares;
	m_bIsDfsRoot = bIsDfsRoot;
	//}}AFX_DATA_INIT

	// Can't both share subdirs and be a DFS root.
	ASSERT(!(bShareSubDirs && bIsDfsRoot));

	if (m_bIsDfsRoot)
	{
		m_nChoice = 1;
		m_bHideSubDirShares = FALSE;
	} // if:  DFS root
	else if (m_bShareSubDirs)
		m_nChoice = 2;
	else
	{
		m_nChoice = 0;
		m_bHideSubDirShares = FALSE;
	} // else:  normal share

} //*** CFileShareAdvancedDlg::CFileShareAdvancedDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareAdvancedDlg::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareAdvancedDlg::DoDataExchange(CDataExchange * pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFileShareAdvancedDlg)
	DDX_Control(pDX, IDC_FILESHR_ADV_HIDE_SUBDIR_SHARES, m_chkHideSubDirShares);
	DDX_Control(pDX, IDC_FILESHR_ADV_SHARE_SUBDIRS, m_rbShareSubDirs);
	DDX_Radio(pDX, IDC_FILESHR_ADV_NORMAL_SHARE, m_nChoice);
	DDX_Check(pDX, IDC_FILESHR_ADV_HIDE_SUBDIR_SHARES, m_bHideSubDirShares);
	//}}AFX_DATA_MAP

	if (pDX->m_bSaveAndValidate)
	{
		if (m_nChoice == 1)
		{
			m_bIsDfsRoot = TRUE;
			m_bShareSubDirs = FALSE;
			m_bHideSubDirShares = FALSE;
		} // if:  DFS root radio button selected
		else if (m_nChoice == 2)
		{
			m_bIsDfsRoot = FALSE;
			m_bShareSubDirs = TRUE;
		} // else if:  share subdirs radio button selected
		else
		{
			m_bIsDfsRoot = FALSE;
			m_bShareSubDirs = FALSE;
			m_bHideSubDirShares = FALSE;
		} // else:  normal radio button selected
	} // if:  saving data from dialog
	else
	{
		if (m_nChoice == 2)
			m_chkHideSubDirShares.EnableWindow (TRUE);
		else
			m_chkHideSubDirShares.EnableWindow (FALSE);
	} // else:  setting data to dialog

} //*** CFileShareAdvancedDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareAdvancedDlg::OnChangedChoice
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the DFS root or Share
//		subdirectories radio button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareAdvancedDlg::OnChangedChoice(void)
{
	if (m_rbShareSubDirs.GetCheck() == BST_CHECKED)
		m_chkHideSubDirShares.EnableWindow (TRUE);
	else
		m_chkHideSubDirShares.EnableWindow (FALSE);

} //*** CFileShareAdvancedDlg::OnChangedChoice()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\extobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ExtObj.cpp
//
//	Abstract:
//		Definition of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Implementation File:
//		ExtObj.cpp
//
//	Author:
//		David Potter (davidp)	August 23, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTOBJ_H_
#define _EXTOBJ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for CLUADMEX_DATA and interfaces
#endif

#ifndef __extobj_idl_h__
#include "ExtObjID.h"
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage and CPageList
#endif

//#define _DEMO_CTX_MENUS

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
class CObjData;
class CResData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// class CObjData
/////////////////////////////////////////////////////////////////////////////

class CObjData
{
public:
	CString					m_strName;
	CLUADMEX_OBJECT_TYPE	m_cot;

	virtual ~CObjData(void) { }

};  //*** CObjData

/////////////////////////////////////////////////////////////////////////////
// class CResData
/////////////////////////////////////////////////////////////////////////////

class CResData : public CObjData
{
public:
	HRESOURCE	m_hresource;
	CString		m_strResTypeName;

};  //*** CResData

/////////////////////////////////////////////////////////////////////////////
// class CExtObject
/////////////////////////////////////////////////////////////////////////////

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CExtObject :
	public IWEExtendPropertySheet,
	public IWEExtendWizard,
#ifdef _DEMO_CTX_MENUS
	public IWEExtendContextMenu,
	public IWEInvokeCommand,
#endif
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CExtObject, &CLSID_CoCluAdmEx>
{
public:
	CExtObject(void);
BEGIN_COM_MAP(CExtObject)
	COM_INTERFACE_ENTRY(IWEExtendPropertySheet)
	COM_INTERFACE_ENTRY(IWEExtendWizard)
#ifdef _DEMO_CTX_MENUS
	COM_INTERFACE_ENTRY(IWEExtendContextMenu)
	COM_INTERFACE_ENTRY(IWEInvokeCommand)
#endif
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CExtObject)
// Remove the comment from the line above if you don't want your object to
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CExtObject, _T("CLUADMEX.Standard"), _T("CLUADMEX.Standard"), IDS_CLUADMEX_DESC, THREADFLAGS_APARTMENT)

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IWEExtendPropertySheet
public:
	STDMETHOD(CreatePropertySheetPages)(
					IN IUnknown *					piData,
					IN IWCPropertySheetCallback *	piCallback
					);

// IWEExtendWizard
public:
	STDMETHOD(CreateWizardPages)(
					IN IUnknown *			piData,
					IN IWCWizardCallback *	piCallback
					);

#ifdef _DEMO_CTX_MENUS
// IWEExtendContextMenu
public:
	STDMETHOD(AddContextMenuItems)(
					IN IUnknown *				piData,
					IN IWCContextMenuCallback *	piCallback
					);

// IWEInvokeCommand
	STDMETHOD(InvokeCommand)(
					IN ULONG					nCommandID,
					IN IUnknown *				piData
					);
#endif

// Attributes
protected:
	IUnknown *					m_piData;
	IWCWizardCallback *			m_piWizardCallback;
	BOOL						m_bWizard;
	DWORD						m_istrResTypeName;

	// IGetClusterDataInfo data
	CString						m_strClusterName;
	HCLUSTER					m_hcluster;
	LCID						m_lcid;
	HFONT						m_hfont;
	HICON						m_hicon;
	LONG						m_cobj;

	CObjData *					m_podObjData;

	CObjData *					PodObjDataRW(void) const		{ return m_podObjData; }
	CResData *					PrdResDataRW(void) const		{ return (CResData *) m_podObjData; }

public:
	IUnknown *					PiData(void) const				{ return m_piData; }
	IWCWizardCallback *			PiWizardCallback(void) const	{ return m_piWizardCallback; }
	BOOL						BWizard(void) const				{ return m_bWizard; }
	DWORD						IstrResTypeName(void) const		{ return m_istrResTypeName; }

	// IGetClusterDataInfo data
	const CString &				StrClusterName(void) const		{ return m_strClusterName; }
	HCLUSTER					Hcluster(void) const			{ return m_hcluster; }
	LCID						Lcid(void) const				{ return m_lcid; }
	HFONT						Hfont(void) const				{ return m_hfont; }
	HICON						Hicon(void) const				{ return m_hicon; }
	LONG						Cobj(void) const				{ return m_cobj; }

	const CResData &			RrdResData(void) const			{ return (const CResData &) *m_podObjData; }
	const CObjData *			PodObjData(void) const			{ return m_podObjData; }
	const CResData *			PrdResData(void) const			{ return (CResData *) m_podObjData; }

	HRESULT						HrGetUIInfo(IUnknown * piData);
	HRESULT						HrSaveData(IUnknown * piData);
	HRESULT						HrGetObjectInfo(void);
	HRESULT						HrGetClusterName(IN OUT IGetClusterDataInfo * pi);
	HRESULT						HrGetObjectName(IN OUT IGetClusterObjectInfo * pi);
	HRESULT						HrGetResourceTypeName(IN OUT IGetClusterResourceInfo * pi);
	HRESULT						HrGetClusterVersion(OUT LPCLUSTERVERSIONINFO *ppCvi);
	BOOL						BGetResourceNetworkName(OUT WCHAR * lpszNetName, IN OUT DWORD * pcchNetName);
	BOOL						BIsClusterVersionMixed(void);
	BOOL						BIsClusterVersionNT4Sp3(void);
	BOOL						BIsClusterVersionNT4Sp4(void);
	//BOOL						BIsClusterVersionNT4(void);
	BOOL						BIsClusterVersionNT5(void);
	//BOOL						BIsClusterHighestVersionNT4Sp3(void);
	//BOOL						BIsClusterHighestVersionNT4Sp4(void);
	BOOL						BIsClusterHighestVersionNT5(void);
	BOOL						BIsClusterLowestVersionNT4Sp3(void);
	BOOL						BIsClusterLowestVersionNT4Sp4(void);
	BOOL						BIsClusterLowestVersionNT5(void);
	BOOL						BIsNT5ClusterMember(void);
	//BOOL						BIsNT4Sp4ClusterMember(void);
	//BOOL						BIsNT4Sp3ClusterMember(void);
    BOOL                        BIsAnyNodeVersionLowerThanNT5(void);

// Implementation
protected:
	virtual ~CExtObject(void);

	CPageList					m_lpg;
	LPCLUSTERVERSIONINFO		m_pCvi;

	CPageList &					Lpg(void)						{ return m_lpg; }

};  //*** class CExtObject

/////////////////////////////////////////////////////////////////////////////


#endif // _EXTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\fscache.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      FSCache.cpp
//
//  Description:
//      Definition of the CFileShareCachingDlg class.
//
//  Implementation File:
//      FSCache.cpp
//
//  Author:
//      David Potter    (DavidP)    13-MAR-2001
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CFileShareCachingDlg;

/////////////////////////////////////////////////////////////////////////////
// CFileShareCachingDlg dialog
/////////////////////////////////////////////////////////////////////////////

class CFileShareCachingDlg : public CDialog
{
// Construction
public:
    CFileShareCachingDlg(
          DWORD     dwFlagsIn
        , CWnd *    pParent = NULL
        );

// Dialog Data
    //{{AFX_DATA(CFileShareCachingDlg)
    enum { IDD = IDD_FILESHR_CACHE_SETTINGS };
    CComboBox   m_cboCacheOptions;
    CStatic     m_staticHint;
    BOOL        m_fAllowCaching;
    CString     m_strHint;
    //}}AFX_DATA
    DWORD       m_dwFlags;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CFileShareCachingDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CFileShareCachingDlg)
    afx_msg void OnCbnSelchangeCacheOptions();
    afx_msg void OnBnClickedAllowCaching();
    afx_msg void OnBnClickedHelp();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfoIn);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL GetCachedFlag( DWORD dwFlagsIn, DWORD dwFlagToCheckIn );
    void SetCachedFlag( DWORD * pdwFlagsInout, DWORD dwNewFlagIn );

}; //*** class CFileShareCachingDlg

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\fsadv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		FSAdv.cpp
//
//	Abstract:
//		Definition of the CFileShareAdvancedDlg class.
//
//	Implementation File:
//		FSAdv.cpp
//
//	Author:
//		Sivaprasad Padisetty (sivapad))	February 2, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _FSADV_H_
#define _FSADV_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEDLG_H_
#include "BaseDlg.h"	// for CBaseDialog
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CFileShareAdvancedDlg;

/////////////////////////////////////////////////////////////////////////////
// CFileShareAdvancedDlg dialog
/////////////////////////////////////////////////////////////////////////////

class CFileShareAdvancedDlg : public CBaseDialog
{
// Construction
public:
	CFileShareAdvancedDlg(
		BOOL bShareSubDirs,
		BOOL bHideSubDirShares,
		BOOL bIsDfsRoot,
		CWnd * pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CFileShareAdvancedDlg)
	enum { IDD = IDD_FILESHR_ADVANCED };
	CButton	m_chkHideSubDirShares;
	CButton	m_rbShareSubDirs;
	int	m_nChoice;
	BOOL	m_bHideSubDirShares;
	//}}AFX_DATA
	BOOL	m_bShareSubDirs;
	BOOL	m_bIsDfsRoot;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFileShareAdvancedDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFileShareAdvancedDlg)
	afx_msg void OnChangedChoice();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CFileShareAdvancedDlg

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _FSADV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\genscript.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 2000 Microsoft Corporation
//
//	Module Name:
//		GenScript.cpp
//
//	Abstract:
//		Implementation of the CGenericScriptParamsPage class.
//
//	Author:
//		Geoffrey Pease (GPease) 31-JAN-2000
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"
#include "GenScript.h"
#include "DDxDDv.h"
#include "PropList.h"
#include "HelpData.h"	// for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGenericScriptParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CGenericScriptParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CGenericScriptParamsPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CGenericScriptParamsPage)
	ON_EN_CHANGE(IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH, OnChangeRequired)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericScriptParamsPage::CGenericScriptParamsPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGenericScriptParamsPage::CGenericScriptParamsPage(void)
	: CBasePropertyPage(g_aHelpIDs_IDD_PP_GENSCRIPT_PARAMETERS, g_aHelpIDs_IDD_WIZ_GENSCRIPT_PARAMETERS)
{
	//{{AFX_DATA_INIT(CGenericScriptParamsPage)
	m_strScriptFilepath = _T("");
	//}}AFX_DATA_INIT

	// Setup the property array.
	{
		m_rgProps[epropScriptFilepath].Set(REGPARAM_GENSCRIPT_SCRIPT_FILEPATH, m_strScriptFilepath, m_strPrevScriptFilepath);
	}  // Setup the property array

	m_iddPropertyPage = IDD_PP_GENSCRIPT_PARAMETERS;
	m_iddWizardPage = IDD_WIZ_GENSCRIPT_PARAMETERS;

}  //*** CGenericScriptParamsPage::CGenericScriptParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericScriptParamsPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericScriptParamsPage::DoDataExchange(CDataExchange * pDX)
{
	if (!pDX->m_bSaveAndValidate || !BSaved())
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());

		//{{AFX_DATA_MAP(CGenericScriptParamsPage)
		DDX_Control(pDX, IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH, m_editScriptFilepath);
		DDX_Text(pDX, IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH, m_strScriptFilepath);
		//}}AFX_DATA_MAP

		if (!BBackPressed())
		{
			DDV_RequiredText(pDX, IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH, IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH_LABEL, m_strScriptFilepath);
		}  // if:  Back button not pressed
	}  // if:  not saving or haven't saved yet

	CBasePropertyPage::DoDataExchange(pDX);

}  //*** CGenericScriptParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericScriptParamsPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGenericScriptParamsPage::OnInitDialog(void)
{
	// Call the base class.
	CBasePropertyPage::OnInitDialog();

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CGenericScriptParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericScriptParamsPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGenericScriptParamsPage::OnSetActive(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Enable/disable the Next/Finish button.
	if (BWizard())
	{
		if (m_strScriptFilepath.GetLength() == 0)
        {
            EnableNext(FALSE);
        }
		else
        {
			EnableNext(TRUE);
        }
	}  // if:  enable/disable the Next button

	return CBasePropertyPage::OnSetActive();

}  //*** CGenericScriptParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericScriptParamsPage::OnChangeRequired
//
//	Routine Description:
//		Handler for the EN_CHANGE message on required controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericScriptParamsPage::OnChangeRequired(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnChangeCtrl();

	if (BWizard())
	{
		if (m_editScriptFilepath.GetWindowTextLength() == 0)
        {
			EnableNext(FALSE);
        }
		else
        {
			EnableNext(TRUE);
        }
	}  // if:  in a wizard

}  //*** CGenericScriptParamsPage::OnChangeRequired()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\genapp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		GenApp.cpp
//
//	Abstract:
//		Implementation of the CGenericAppParamsPage class.
//
//	Author:
//		David Potter (davidp)	June 5, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"
#include "GenApp.h"
#include "DDxDDv.h"
#include "PropList.h"
#include "HelpData.h"	// for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGenericAppParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CGenericAppParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CGenericAppParamsPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CGenericAppParamsPage)
	ON_EN_CHANGE(IDC_PP_GENAPP_PARAMS_COMMAND_LINE, OnChangeRequired)
	ON_EN_CHANGE(IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY, OnChangeRequired)
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDC_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP, CBasePropertyPage::OnChangeCtrl)
	ON_BN_CLICKED(IDC_PP_GENAPP_PARAMS_USE_NETWORK_NAME, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericAppParamsPage::CGenericAppParamsPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGenericAppParamsPage::CGenericAppParamsPage(void)
	: CBasePropertyPage(g_aHelpIDs_IDD_PP_GENAPP_PARAMETERS, g_aHelpIDs_IDD_WIZ_GENAPP_PARAMETERS)
{
	//{{AFX_DATA_INIT(CGenericAppParamsPage)
	m_strCommandLine = _T("");
	m_strCurrentDirectory = _T("");
	m_bInteractWithDesktop = FALSE;
	m_bUseNetworkName = FALSE;
	//}}AFX_DATA_INIT

	m_bInteractWithDesktop = FALSE;
	m_bUseNetworkName = FALSE;

	// Setup the property array.
	{
		m_rgProps[epropCommandLine].Set(REGPARAM_GENAPP_COMMAND_LINE, m_strCommandLine, m_strPrevCommandLine);
		m_rgProps[epropCurrentDirectory].Set(REGPARAM_GENAPP_CURRENT_DIRECTORY, m_strCurrentDirectory, m_strPrevCurrentDirectory);
		m_rgProps[epropInteractWithDesktop].Set(REGPARAM_GENAPP_INTERACT_WITH_DESKTOP, m_bInteractWithDesktop, m_bPrevInteractWithDesktop);
		m_rgProps[epropUseNetworkName].Set(REGPARAM_GENAPP_USE_NETWORK_NAME, m_bUseNetworkName, m_bPrevUseNetworkName);
	}  // Setup the property array

	m_iddPropertyPage = IDD_PP_GENAPP_PARAMETERS;
	m_iddWizardPage = IDD_WIZ_GENAPP_PARAMETERS;

}  //*** CGenericAppParamsPage::CGenericAppParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericAppParamsPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericAppParamsPage::DoDataExchange(CDataExchange * pDX)
{
	if (!pDX->m_bSaveAndValidate || !BSaved())
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());

		//{{AFX_DATA_MAP(CGenericAppParamsPage)
		DDX_Control(pDX, IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY, m_editCurrentDirectory);
		DDX_Control(pDX, IDC_PP_GENAPP_PARAMS_USE_NETWORK_NAME, m_ckbUseNetworkName);
		DDX_Control(pDX, IDC_PP_GENAPP_PARAMS_COMMAND_LINE, m_editCommandLine);
		DDX_Text(pDX, IDC_PP_GENAPP_PARAMS_COMMAND_LINE, m_strCommandLine);
		DDX_Text(pDX, IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY, m_strCurrentDirectory);
		DDX_Check(pDX, IDC_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP, m_bInteractWithDesktop);
		DDX_Check(pDX, IDC_PP_GENAPP_PARAMS_USE_NETWORK_NAME, m_bUseNetworkName);
		//}}AFX_DATA_MAP

		if (!BBackPressed())
		{
			DDV_RequiredText(pDX, IDC_PP_GENAPP_PARAMS_COMMAND_LINE, IDC_PP_GENAPP_PARAMS_COMMAND_LINE_LABEL, m_strCommandLine);
			DDV_RequiredText(pDX, IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY, IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY_LABEL, m_strCurrentDirectory);
			DDV_Path(pDX, IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY, IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY_LABEL, m_strCurrentDirectory);
		}  // if:  Back button not pressed
	}  // if:  not saving or haven't saved yet

	CBasePropertyPage::DoDataExchange(pDX);

}  //*** CGenericAppParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericAppParamsPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGenericAppParamsPage::OnInitDialog(void)
{
	// Get a default value for the current directory if it hasn't been set yet.
	if (m_strCurrentDirectory.GetLength() == 0)
		ConstructDefaultDirectory(m_strCurrentDirectory, IDS_DEFAULT_GENAPP_CURRENT_DIR);

	// Call the base class.
	CBasePropertyPage::OnInitDialog();

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CGenericAppParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericAppParamsPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGenericAppParamsPage::OnSetActive(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// If there is no network name, hide the UseNetworkName control.
	{
		WCHAR	wszNetName[MAX_COMPUTERNAME_LENGTH + 1];
		DWORD	nSize = sizeof(wszNetName) / sizeof(WCHAR);
		BOOL	bNetNameExists;

		bNetNameExists = Peo()->BGetResourceNetworkName(
									wszNetName,
									&nSize
									);
		m_ckbUseNetworkName.EnableWindow(bNetNameExists);
	}  // If there is no network name, hide the UseNetworkName control

	// Enable/disable the Next/Finish button.
	if (BWizard())
	{
		if ((m_strCommandLine.GetLength() == 0)
				|| (m_strCurrentDirectory.GetLength() == 0))
			EnableNext(FALSE);
		else
			EnableNext(TRUE);
	}  // if:  enable/disable the Next button

	return CBasePropertyPage::OnSetActive();

}  //*** CGenericAppParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericAppParamsPage::OnChangeRequired
//
//	Routine Description:
//		Handler for the EN_CHANGE message on required controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericAppParamsPage::OnChangeRequired(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnChangeCtrl();

	if (BWizard())
	{
		if ((m_editCommandLine.GetWindowTextLength() == 0)
				|| (m_editCurrentDirectory.GetWindowTextLength() == 0))
			EnableNext(FALSE);
		else
			EnableNext(TRUE);
	}  // if:  in a wizard

}  //*** CGenericAppParamsPage::OnChangeRequired()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\genscript.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 2000 Microsoft Corporation
//
//	Module Name:
//		GenScript.h
//
//	Abstract:
//		Definition of the CGenericScriptParamsPage class, which implements the
//		parameters page for Generic Script resources.
//
//	Implementation File:
//		GenApp.cpp
//
//	Author:
//		Geoffrey Pease (GPease) 31-JAN-2000
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _GENSCRIPT_H_
#define _GENSCRIPT_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGenericScriptParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CGenericScriptParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CGenericScriptParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CGenericScriptParamsPage)

// Construction
public:
	CGenericScriptParamsPage(void);

// Dialog Data
	//{{AFX_DATA(CGenericScriptParamsPage)
	enum { IDD = IDD_PP_GENAPP_PARAMETERS };
	CEdit	m_editScriptFilepath;
	CString	m_strScriptFilepath;
	//}}AFX_DATA
	CString	m_strPrevScriptFilepath;

protected:
	enum
	{
		epropScriptFilepath,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

// Overrides
public:
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGenericScriptParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGenericScriptParamsPage)
	afx_msg void OnChangeRequired();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CGenericScriptParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _GENSCRIPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\genapp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		GenApp.h
//
//	Abstract:
//		Definition of the CGenericAppParamsPage class, which implements the
//		Parameters page for Generic Application resources.
//
//	Implementation File:
//		GenApp.cpp
//
//	Author:
//		David Potter (davidp)	June 5, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _GENAPP_H_
#define _GENAPP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGenericAppParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CGenericAppParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CGenericAppParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CGenericAppParamsPage)

// Construction
public:
	CGenericAppParamsPage(void);

// Dialog Data
	//{{AFX_DATA(CGenericAppParamsPage)
	enum { IDD = IDD_PP_GENAPP_PARAMETERS };
	CEdit	m_editCurrentDirectory;
	CButton	m_ckbUseNetworkName;
	CEdit	m_editCommandLine;
	CString	m_strCommandLine;
	CString	m_strCurrentDirectory;
	BOOL	m_bInteractWithDesktop;
	BOOL	m_bUseNetworkName;
	//}}AFX_DATA
	CString	m_strPrevCommandLine;
	CString	m_strPrevCurrentDirectory;
	BOOL	m_bPrevInteractWithDesktop;
	BOOL	m_bPrevUseNetworkName;

protected:
	enum
	{
		epropCommandLine,
		epropCurrentDirectory,
		epropInteractWithDesktop,
		epropUseNetworkName,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

// Overrides
public:
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGenericAppParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGenericAppParamsPage)
	afx_msg void OnChangeRequired();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CGenericAppParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _GENAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\fscache.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      FSCache.cpp
//
//  Description:
//      Implementation of the CFileShareCachingDlg classes.
//
//  Maintained By:
//      David Potter    (DavidP)    12-MAR-2001
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "FSCache.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileShareCachingDlg property page
/////////////////////////////////////////////////////////////////////////////

//const LPSTR CACHE_HELPFILENAME  = "offlinefolders.chm";
//const LPSTR CACHE_HELP_TOPIC    = "csc_and_shares.htm";
const LPSTR CACHE_HELPFILENAME  = "mscsconcepts.chm";
const LPSTR CACHE_HELP_TOPIC    = "cluad_pr_99.htm";

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CFileShareCachingDlg, CDialog )
    //{{AFX_MSG_MAP(CFileShareCachingDlg)
    ON_CBN_SELCHANGE(IDC_FILESHR_CACHE_OPTIONS, OnCbnSelchangeCacheOptions)
    ON_BN_CLICKED(IDC_FILESHR_CACHE_ALLOW_CACHING, OnBnClickedAllowCaching)
    ON_BN_CLICKED(IDC_FILESHR_CACHE_CS_HELP, OnBnClickedHelp)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::CFileShareCachingDlg
//
//  Description:
//      Constructor.
//
//  Arguments:
//      dwFlagsIn   -- Cache flags.
//      pParentIn   -- Parent window.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CFileShareCachingDlg::CFileShareCachingDlg(
      DWORD     dwFlagsIn
    , CWnd *    pParentIn
    )
    : CDialog( CFileShareCachingDlg::IDD, pParentIn )
    , m_dwFlags( dwFlagsIn )
{
    //{{AFX_DATA_INIT(CFileShareCachingDlg)
    m_fAllowCaching = FALSE;
    m_strHint = _T("");
    //}}AFX_DATA_INIT

    m_fAllowCaching = ! GetCachedFlag( m_dwFlags, CSC_CACHE_NONE );

} //*** CFileShareCachingDlg::CFileShareCachingDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::DoDataExchange
//
//  Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareCachingDlg::DoDataExchange(
    CDataExchange * pDX
    )
{
    CDialog::DoDataExchange( pDX );
    //{{AFX_DATA_MAP(CFileShareCachingDlg)
    DDX_Control(pDX, IDC_FILESHR_CACHE_OPTIONS, m_cboCacheOptions);
    DDX_Control(pDX, IDC_FILESHR_CACHE_HINT, m_staticHint);
    DDX_Check(pDX, IDC_FILESHR_CACHE_ALLOW_CACHING, m_fAllowCaching);
    DDX_Text(pDX, IDC_FILESHR_CACHE_HINT, m_strHint);
    //}}AFX_DATA_MAP

} //*** CFileShareCachingDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CFileShareCachingDlg::OnInitDialog( void )
{
    CDialog::OnInitDialog();

    CString strText;
    int     nIndex;

    //
    // Add the various caching options to the combo box.
    // Save the string ID in the item data for easy recognition of the
    // contents of the selected item.
    // If the given cache value is set, select the item and put its hint in
    // the hint field.
    //

    // Add the manual sharing string.
    VERIFY( strText.LoadString( IDS_CSC_MANUAL_WORKGROUP_SHARE ) );
    nIndex = m_cboCacheOptions.AddString( strText );
    ASSERT( ( nIndex != CB_ERR ) && ( nIndex != CB_ERRSPACE ) );
    if ( ( nIndex == CB_ERR ) || ( nIndex == CB_ERRSPACE ) )
    {
        goto Cleanup;
    }
    VERIFY( CB_ERR != m_cboCacheOptions.SetItemData( nIndex, IDS_CSC_MANUAL_WORKGROUP_SHARE ) );
    if ( GetCachedFlag( m_dwFlags, CSC_CACHE_MANUAL_REINT ) )
    {
        VERIFY( CB_ERR != m_cboCacheOptions.SetCurSel( nIndex ) );
        VERIFY( m_strHint.LoadString( IDS_CSC_MANUAL_WORKGROUP_SHARE_HINT ) );
    }

    // Add the automatic workgroup sharing string.
    VERIFY( strText.LoadString( IDS_CSC_AUTOMATIC_WORKGROUP_SHARE ) );
    nIndex = m_cboCacheOptions.AddString( strText );
    ASSERT( ( nIndex != CB_ERR ) && ( nIndex != CB_ERRSPACE ) );
    if ( ( nIndex == CB_ERR ) || ( nIndex == CB_ERRSPACE ) )
    {
        goto Cleanup;
    }
    VERIFY( CB_ERR != m_cboCacheOptions.SetItemData( nIndex, IDS_CSC_AUTOMATIC_WORKGROUP_SHARE ) );
    if ( GetCachedFlag( m_dwFlags, CSC_CACHE_AUTO_REINT ) )
    {
        VERIFY( CB_ERR != m_cboCacheOptions.SetCurSel (nIndex));
        VERIFY( m_strHint.LoadString( IDS_CSC_AUTOMATIC_WORKGROUP_SHARE_HINT ) );
    }

    // Add the automatic application sharing string.
    VERIFY( strText.LoadString( IDS_CSC_AUTOMATIC_APPLICATION_SHARE ) );
    nIndex = m_cboCacheOptions.AddString( strText );
    ASSERT( ( nIndex != CB_ERR ) && ( nIndex != CB_ERRSPACE ) );
    if ( ( nIndex == CB_ERR ) || ( nIndex == CB_ERRSPACE ) )
    {
        goto Cleanup;
    }
    VERIFY( CB_ERR != m_cboCacheOptions.SetItemData( nIndex, IDS_CSC_AUTOMATIC_APPLICATION_SHARE ) );
    if ( GetCachedFlag( m_dwFlags, CSC_CACHE_VDO ) )
    {
        VERIFY( CB_ERR != m_cboCacheOptions.SetCurSel( nIndex ) );
        VERIFY( m_strHint.LoadString( IDS_CSC_AUTOMATIC_APPLICATION_SHARE_HINT ) );
    }

    // Disable able the caching options combo box if caching is not allowed
    if ( ! m_fAllowCaching )
    {
        m_cboCacheOptions.EnableWindow( FALSE );
        m_strHint = L"";
    }

Cleanup:

    UpdateData( FALSE );

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE

} //*** CFileShareCachingDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::OnOK
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the OK button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareCachingDlg::OnOK( void )
{
    DWORD   dwNewFlag = 0;

    if ( ! m_fAllowCaching )
    {
        dwNewFlag = CSC_CACHE_NONE;
    }
    else
    {
        int nIndex = m_cboCacheOptions.GetCurSel();
        ASSERT( nIndex != CB_ERR  );
        if ( nIndex != CB_ERR )
        {
            DWORD   dwData = (DWORD) m_cboCacheOptions.GetItemData( nIndex );

            switch ( dwData )
            {
                case IDS_CSC_MANUAL_WORKGROUP_SHARE:
                    dwNewFlag = CSC_CACHE_MANUAL_REINT;
                    break;

                case IDS_CSC_AUTOMATIC_WORKGROUP_SHARE:
                    dwNewFlag = CSC_CACHE_AUTO_REINT;
                    break;

                case IDS_CSC_AUTOMATIC_APPLICATION_SHARE:
                    dwNewFlag = CSC_CACHE_VDO;
                    break;

                default:
                    ASSERT( 0 );
                    break;
            } // switch: item data
        } // if: option is selected
    } // else: caching is allowed

    SetCachedFlag( &m_dwFlags, dwNewFlag );

    CDialog::OnOK();

} //*** CFileShareCachingDlg::OnOK()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::OnCbnSelchangeCacheOptions
//
//  Description:
//      Handler for the CBN_SELCHANGE message on the options combobox.
//      Change the hint control when the option has changed.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareCachingDlg::OnCbnSelchangeCacheOptions( void )
{
    int nIndex = m_cboCacheOptions.GetCurSel();

    ASSERT( nIndex != CB_ERR );

    if ( nIndex != CB_ERR )
    {
        DWORD   dwData = (DWORD) m_cboCacheOptions.GetItemData( nIndex );

        switch ( dwData )
        {
            case IDS_CSC_MANUAL_WORKGROUP_SHARE:
                VERIFY( m_strHint.LoadString( IDS_CSC_MANUAL_WORKGROUP_SHARE_HINT ) );
                break;

            case IDS_CSC_AUTOMATIC_WORKGROUP_SHARE:
                VERIFY( m_strHint.LoadString( IDS_CSC_AUTOMATIC_WORKGROUP_SHARE_HINT ) );
                break;

            case IDS_CSC_AUTOMATIC_APPLICATION_SHARE:
                VERIFY( m_strHint.LoadString( IDS_CSC_AUTOMATIC_APPLICATION_SHARE_HINT ) );
                break;

            default:
                ASSERT( 0 );
                break;
        } // switch: item data
        UpdateData( FALSE );
    } // if: something is selected

} //*** CFileShareCachingDlg::OnCbnSelchangeCacheOptions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::OnBnClickedAllowCaching
//
//  Description:
//      Handler for the BN_CLICKED message on the Allow Caching checkbox.
//      Enable or disable controls and load a hint if enabled.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareCachingDlg::OnBnClickedAllowCaching( void )
{
    UpdateData( TRUE );
    if ( m_fAllowCaching )
    {
        CString strText;
        int     nIndex;

        m_staticHint.EnableWindow( TRUE );
        m_cboCacheOptions.EnableWindow (TRUE);
        VERIFY( strText.LoadString ( IDS_CSC_MANUAL_WORKGROUP_SHARE ) );
        nIndex = m_cboCacheOptions.SelectString( -1, strText );
        ASSERT( CB_ERR != nIndex );
        if ( CB_ERR != nIndex )
        {
            VERIFY( m_strHint.LoadString( IDS_CSC_MANUAL_WORKGROUP_SHARE_HINT ) );
            UpdateData( FALSE );
        }
    }
    else
    {
        m_staticHint.EnableWindow( FALSE );
        m_cboCacheOptions.SetCurSel( -1 );
        m_cboCacheOptions.EnableWindow( FALSE );
        m_strHint = L"";
        UpdateData( FALSE );
    }

} //*** CFileShareCachingDlg::OnBnClickedAllowCaching()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::OnBnClickedHelp
//
//  Description:
//      Handler for the BN_CLICKED message on the Help pushbutton.
//      Display HTML help.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareCachingDlg::OnBnClickedHelp( void )
{
    ::HtmlHelpA(
              m_hWnd
            , CACHE_HELPFILENAME
            , HH_DISPLAY_TOPIC
            , (ULONG_PTR) CACHE_HELP_TOPIC
            );

} //*** CFileShareCachingDlg::OnBnClickedHelp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::OnHelpInfo
//
//  Description:
//      MFC message handler for help.
//      Display HTML help.
//
//  Arguments:
//      pHelpInfoIn     --
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CFileShareCachingDlg::OnHelpInfo(
    HELPINFO *  pHelpInfoIn
    )
{
    ASSERT( pHelpInfoIn != NULL );

    if (    ( pHelpInfoIn != NULL )
        &&  ( pHelpInfoIn->iContextType == HELPINFO_WINDOW ) )
    {
        ::HtmlHelpA(
                  m_hWnd
                , CACHE_HELPFILENAME
                , HH_DISPLAY_TOPIC
                , (ULONG_PTR) CACHE_HELP_TOPIC
                );
    }

    return CDialog::OnHelpInfo( pHelpInfoIn );

} //*** CFileShareCachingDlg::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::GetCachedFlag
//
//  Description:
//      Get the current state of the specified flag in the specified flags mask.
//
//  Arguments:
//      dwFlagsIn           -- Flags to check.
//      dwFlagsToCheckIn    -- Flag to look for.
//
//
//  Return Values:
//      TRUE    -- Flag is set.
//      FALSE   -- Flag is not set.
//
//--
/////////////////////////////////////////////////////////////////////////////
inline
BOOL
CFileShareCachingDlg::GetCachedFlag(
      DWORD dwFlagsIn
    , DWORD dwFlagToCheckIn
    )
{
    return (dwFlagsIn & CSC_MASK) == dwFlagToCheckIn;

} //*** CFileShareCachingDlg::GetCachedFlag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::GetCachedFlag
//
//  Description:
//      Set the specified flag in the specified flags mask.
//
//  Arguments:
//      pdwFlagsInout   -- Flags mask to modify.
//      dwNewFlagIn     -- Flags to set.
//
//  Return Values:
//      TRUE    -- Flag is set.
//      FALSE   -- Flag is not set.
//
//--
/////////////////////////////////////////////////////////////////////////////
inline
void
CFileShareCachingDlg::SetCachedFlag(
      DWORD *   pdwFlagsInout
    , DWORD     dwNewFlagIn
    )
{
    *pdwFlagsInout &= ~CSC_MASK;
    *pdwFlagsInout |= dwNewFlagIn;

} //*** CFileShareCachingDlg::SetCachedFlag()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\gensvc.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		GenSvc.cpp
//
//	Abstract:
//		Implementation of the CGenericSvcParamsPage class.
//
//	Author:
//		David Potter (davidp)	June 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"
#include "GenSvc.h"
#include "DDxDDv.h"
#include "HelpData.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGenericSvcParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CGenericSvcParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CGenericSvcParamsPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CGenericSvcParamsPage)
	ON_EN_CHANGE(IDC_PP_GENSVC_PARAMS_SERVICE_NAME, OnChangeServiceName)
	//}}AFX_MSG_MAP
	ON_EN_CHANGE(IDC_PP_GENSVC_PARAMS_COMMAND_LINE, CBasePropertyPage::OnChangeCtrl)
	ON_BN_CLICKED(IDC_PP_GENSVC_PARAMS_USE_NETWORK_NAME, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericSvcParamsPage::CGenericSvcParamsPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGenericSvcParamsPage::CGenericSvcParamsPage(void)
	: CBasePropertyPage(g_aHelpIDs_IDD_PP_GENSVC_PARAMETERS, g_aHelpIDs_IDD_WIZ_GENSVC_PARAMETERS)
{
	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_INIT(CGenericSvcParamsPage)
	m_strServiceName = _T("");
	m_strCommandLine = _T("");
	m_bUseNetworkName = FALSE;
	//}}AFX_DATA_INIT

	m_bPrevUseNetworkName = FALSE;

	// Setup the property array.
	{
		m_rgProps[epropServiceName].Set(REGPARAM_GENSVC_SERVICE_NAME, m_strServiceName, m_strPrevServiceName);
		m_rgProps[epropCommandLine].Set(REGPARAM_GENSVC_COMMAND_LINE, m_strCommandLine, m_strPrevCommandLine);
		m_rgProps[epropUseNetworkName].Set(REGPARAM_GENSVC_USE_NETWORK_NAME, m_bUseNetworkName, m_bPrevUseNetworkName);
	}  // Setup the property array

	m_iddPropertyPage = IDD_PP_GENSVC_PARAMETERS;
	m_iddWizardPage = IDD_WIZ_GENSVC_PARAMETERS;

}  //*** CGenericSvcParamsPage::CGenericSvcParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericSvcParamsPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericSvcParamsPage::DoDataExchange(CDataExchange * pDX)
{
	if (!pDX->m_bSaveAndValidate || !BSaved())
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());

		// TODO: Modify the following lines to represent the data displayed on this page.
		//{{AFX_DATA_MAP(CGenericSvcParamsPage)
		DDX_Control(pDX, IDC_PP_GENSVC_PARAMS_USE_NETWORK_NAME, m_ckbUseNetworkName);
		DDX_Control(pDX, IDC_PP_GENSVC_PARAMS_SERVICE_NAME, m_editServiceName);
		DDX_Text(pDX, IDC_PP_GENSVC_PARAMS_SERVICE_NAME, m_strServiceName);
		DDX_Text(pDX, IDC_PP_GENSVC_PARAMS_COMMAND_LINE, m_strCommandLine);
		DDX_Check(pDX, IDC_PP_GENSVC_PARAMS_USE_NETWORK_NAME, m_bUseNetworkName);
		//}}AFX_DATA_MAP

		if (!BBackPressed())
			DDV_RequiredText(pDX, IDC_PP_GENSVC_PARAMS_SERVICE_NAME, IDC_PP_GENSVC_PARAMS_SERVICE_NAME_LABEL, m_strServiceName);
	}  // if:  not saving or haven't saved yet

	CBasePropertyPage::DoDataExchange(pDX);

}  //*** CGenericSvcParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericSvcParamsPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGenericSvcParamsPage::OnSetActive(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// If there is no network name, hide the UseNetworkName control.
	{
		WCHAR	wszNetName[MAX_COMPUTERNAME_LENGTH + 1];
		DWORD	nSize = sizeof(wszNetName) / sizeof(WCHAR);
		BOOL	bNetNameExists;

		bNetNameExists = Peo()->BGetResourceNetworkName(
									wszNetName,
									&nSize
									);
		m_ckbUseNetworkName.EnableWindow(bNetNameExists);
	}  // If there is no network name, hide the UseNetworkName control

	// Enable/disable the Next/Finish button.
	if (BWizard())
	{
		if (m_strServiceName.GetLength() == 0)
			EnableNext(FALSE);
		else
			EnableNext(TRUE);
	}  // if:  enable/disable the Next button

	return CBasePropertyPage::OnSetActive();

}  //*** CGenericSvcParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericSvcParamsPage::OnChangeSignature
//
//	Routine Description:
//		Handler for the EN_CHANGE message on the Service Name edit control.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericSvcParamsPage::OnChangeServiceName(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnChangeCtrl();

	if (BWizard())
	{
		if (m_editServiceName.GetWindowTextLength() == 0)
			EnableNext(FALSE);
		else
			EnableNext(TRUE);
	}  // if:  in a wizard

}  //*** CGenericSvcParamsPage::OnChangeServiceName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericSvcParamsPage::DisplaySetPropsError
//
//	Routine Description:
//		Display an error caused by setting or validating properties.
//
//	Arguments:
//		dwStatus	[IN] Status to display error on.
//
//	Return Value:
//		dwStatus	ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericSvcParamsPage::DisplaySetPropsError(IN DWORD dwStatus) const
{
	CString		strMsg;

	if (dwStatus == ERROR_NOT_SUPPORTED)
		strMsg.FormatMessage(IDS_INVALID_GENERIC_SERVICE, m_strServiceName);
	else
		FormatError(strMsg, dwStatus);

	AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);

}  //*** CGenericSvcParamsPage::DisplaySetPropsError()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\gensvc.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		GenSvc.cpp
//
//	Abstract:
//		Definition of the CGenericSvcParamsPage class, which implements the
//		Parameters page for Generic Service resources.
//
//	Implementation File:
//		GenSvc.cpp
//
//	Author:
//		David Potter (davidp)	June 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _GENSVC_H_
#define _GENSVC_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGenericSvcParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CGenericSvcParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CGenericSvcParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CGenericSvcParamsPage)

// Construction
public:
	CGenericSvcParamsPage(void);

// Dialog Data
	//{{AFX_DATA(CGenericSvcParamsPage)
	enum { IDD = IDD_PP_GENSVC_PARAMETERS };
	CButton	m_ckbUseNetworkName;
	CEdit	m_editServiceName;
	CString	m_strServiceName;
	CString	m_strCommandLine;
	BOOL	m_bUseNetworkName;
	//}}AFX_DATA
	CString	m_strPrevServiceName;
	CString	m_strPrevCommandLine;
	BOOL	m_bPrevUseNetworkName;

protected:
	enum
	{
		epropServiceName,
		epropCommandLine,
		epropUseNetworkName,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

// Overrides
public:
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGenericSvcParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual void		DisplaySetPropsError(IN DWORD dwStatus) const;

	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGenericSvcParamsPage)
	afx_msg void OnChangeServiceName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CGenericSvcParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _GENSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\helpdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.cpp
//
//	Abstract:
//		Data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"

// Define help IDs.
#include "HelpIDs.h"

// Declare arrays.  If we don't do this the arrays don't get instantiated
// in the executable image.
#include "HelpArr.h"

// Define the arrays.
#define INITHELPARRAYS
#include "HelpArr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\helparr.h ===
#define IDH_DISABLEHELP ((DWORD)-1)

#ifdef INITHELPARRAYS


const DWORD g_aHelpIDs_IDD_EDIT_CLUSTER_NAME[]=
{
    IDC_CLUSNAME_TEXT, IDH_DISABLEHELP,
    IDC_CLUSNAME_LABEL, IDH_CLUSNAME,
    IDC_CLUSNAME,IDH_CLUSNAME,
    0, 0
};

const DWORD g_aHelpIDs_IDD_EDIT_REGKEY[]=
{
    IDC_REGKEY_LABEL, IDH_REGKEY,
    IDC_REGKEY,IDH_REGKEY,
    0, 0
};

const DWORD g_aHelpIDs_IDD_FILESHR_ADVANCED[]=
{
    IDC_FILESHR_ADV_NORMAL_SHARE,IDH_FILESHR_ADV_NORMAL_SHARE,
    IDC_FILESHR_ADV_DFS_ROOT,IDH_FILESHR_ADV_DFS_ROOT,
    IDC_FILESHR_ADV_SHARE_SUBDIRS,IDH_FILESHR_ADV_SHARE_SUBDIRS,
    IDC_FILESHR_ADV_HIDE_SUBDIR_SHARES,IDH_FILESHR_ADV_HIDE_SUBDIR_SHARES,
    0, 0
};

const DWORD g_aHelpIDs_IDD_FILESHR_CACHE_SETTINGS[]=
{
    IDC_FILESHR_CACHE_ALLOW_CACHING_GROUP,IDH_FILESHR_CACHE_ALLOW_CACHING,
    IDC_FILESHR_CACHE_ALLOW_CACHING,IDH_FILESHR_CACHE_ALLOW_CACHING,
    IDC_FILESHR_CACHE_SETTINGS_LABEL,IDH_FILESHR_CACHE_OPTIONS,
    IDC_FILESHR_CACHE_OPTIONS,IDH_FILESHR_CACHE_OPTIONS,
    IDC_FILESHR_CACHE_HINT,IDH_FILESHR_CACHE_HINT,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_DISKS_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_DISKS_PARAMS_DISK_LABEL, IDH_PP_DISKS_PARAMS_DISK,
    IDC_PP_DISKS_PARAMS_DISK,IDH_PP_DISKS_PARAMS_DISK,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_FILESHR_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_FILESHR_PARAMS_SHARE_NAME_LABEL, IDH_PP_FILESHR_PARAMS_SHARE_NAME,
    IDC_PP_FILESHR_PARAMS_SHARE_NAME,IDH_PP_FILESHR_PARAMS_SHARE_NAME,
    IDC_PP_FILESHR_PARAMS_PATH_LABEL, IDH_PP_FILESHR_PARAMS_PATH,
    IDC_PP_FILESHR_PARAMS_PATH,IDH_PP_FILESHR_PARAMS_PATH,
    IDC_PP_FILESHR_PARAMS_REMARK_LABEL, IDH_PP_FILESHR_PARAMS_REMARK,
    IDC_PP_FILESHR_PARAMS_REMARK,IDH_PP_FILESHR_PARAMS_REMARK,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_GROUP, IDH_PP_FILESHR_PARAMS_MAX_USERS_GROUP,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB,IDH_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_RB,IDH_PP_FILESHR_PARAMS_MAX_USERS_RB,
    IDC_PP_FILESHR_PARAMS_MAX_USERS,IDH_PP_FILESHR_PARAMS_MAX_USERS,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_END, IDH_DISABLEHELP,
    IDC_PP_FILESHR_PARAMS_PERMISSIONS,IDH_PP_FILESHR_PARAMS_PERMISSIONS,
    IDC_PP_FILESHR_PARAMS_ADVANCED,IDH_PP_FILESHR_PARAMS_ADVANCED,
    IDC_PP_FILESHR_PARAMS_CACHING,IDH_PP_FILESHR_PARAMS_CACHING,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_GENAPP_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_GENAPP_PARAMS_COMMAND_LINE_LABEL, IDH_PP_GENAPP_PARAMS_COMMAND_LINE,
    IDC_PP_GENAPP_PARAMS_COMMAND_LINE,IDH_PP_GENAPP_PARAMS_COMMAND_LINE,
    IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY_LABEL, IDH_PP_GENAPP_PARAMS_CURRENT_DIRECTORY,
    IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY,IDH_PP_GENAPP_PARAMS_CURRENT_DIRECTORY,
    IDC_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP,IDH_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP,
    IDC_PP_GENAPP_PARAMS_USE_NETWORK_NAME,IDH_PP_GENAPP_PARAMS_USE_NETWORK_NAME,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_GENSCRIPT_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH_LABEL,IDH_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH,
    IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH,IDH_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_GENSVC_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP, 
    IDC_PP_GENSVC_PARAMS_SERVICE_NAME_LABEL, IDH_PP_GENSVC_PARAMS_SERVICE_NAME,
    IDC_PP_GENSVC_PARAMS_SERVICE_NAME,IDH_PP_GENSVC_PARAMS_SERVICE_NAME,
    IDC_PP_GENSVC_PARAMS_COMMAND_LINE_LABEL, IDH_PP_GENSVC_PARAMS_COMMAND_LINE,
    IDC_PP_GENSVC_PARAMS_COMMAND_LINE,IDH_PP_GENSVC_PARAMS_COMMAND_LINE,
    IDC_PP_GENSVC_PARAMS_USE_NETWORK_NAME,IDH_PP_GENSVC_PARAMS_USE_NETWORK_NAME,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_IPADDR_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_IPADDR_PARAMS_ADDRESS_LABEL, IDH_PP_IPADDR_PARAMS_ADDRESS,
    IDC_PP_IPADDR_PARAMS_ADDRESS,IDH_PP_IPADDR_PARAMS_ADDRESS,
    IDC_PP_IPADDR_PARAMS_SUBNET_MASK_LABEL, IDH_PP_IPADDR_PARAMS_SUBNET_MASK,
    IDC_PP_IPADDR_PARAMS_SUBNET_MASK,IDH_PP_IPADDR_PARAMS_SUBNET_MASK,
    IDC_PP_IPADDR_PARAMS_NETWORK_LABEL, IDH_PP_IPADDR_PARAMS_NETWORK,
    IDC_PP_IPADDR_PARAMS_NETWORK,IDH_PP_IPADDR_PARAMS_NETWORK,
    IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS,IDH_PP_IPADDR_PARAMS_ENABLE_NETBIOS,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_NETNAME_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_NETNAME_PARAMS_NAME_LABEL, IDH_PP_NETNAME_PARAMS_NAME,
    IDC_PP_NETNAME_PARAMS_NAME,IDH_PP_NETNAME_PARAMS_NAME,
    IDC_PP_NETNAME_PARAMS_RENAME,IDH_PP_NETNAME_PARAMS_RENAME,
    IDC_PP_NETNAME_PARAMS_CORE_TEXT, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_PRTSPOOL_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR_LABEL, IDH_PP_PRTSPOOL_PARAMS_SPOOL_DIR,
    IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR,IDH_PP_PRTSPOOL_PARAMS_SPOOL_DIR,
    IDC_PP_PRTSPOOL_PARAMS_TIMEOUT_LABEL1, IDH_PP_PRTSPOOL_PARAMS_TIMEOUT,
    IDC_PP_PRTSPOOL_PARAMS_TIMEOUT,IDH_PP_PRTSPOOL_PARAMS_TIMEOUT,
    IDC_PP_PRTSPOOL_PARAMS_TIMEOUT_LABEL2, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_REGREPL_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_REGREPL_PARAMS_NOTE, IDH_DISABLEHELP,
    IDC_PP_REGREPL_PARAMS_LIST,IDH_PP_REGREPL_PARAMS_LIST,
    IDC_PP_REGREPL_PARAMS_ADD,IDH_PP_REGREPL_PARAMS_ADD,
    IDC_PP_REGREPL_PARAMS_MODIFY,IDH_PP_REGREPL_PARAMS_MODIFY,
    IDC_PP_REGREPL_PARAMS_REMOVE,IDH_PP_REGREPL_PARAMS_REMOVE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_DISKS_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_DISKS_PARAMS_DISK_LABEL, IDH_PP_DISKS_PARAMS_DISK,
    IDC_PP_DISKS_PARAMS_DISK,IDH_PP_DISKS_PARAMS_DISK,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_FILESHR_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_FILESHR_PARAMS_SHARE_NAME_LABEL, IDH_PP_FILESHR_PARAMS_SHARE_NAME,
    IDC_PP_FILESHR_PARAMS_SHARE_NAME,IDH_PP_FILESHR_PARAMS_SHARE_NAME,
    IDC_PP_FILESHR_PARAMS_PATH_LABEL, IDH_PP_FILESHR_PARAMS_PATH,
    IDC_PP_FILESHR_PARAMS_PATH,IDH_PP_FILESHR_PARAMS_PATH,
    IDC_PP_FILESHR_PARAMS_REMARK_LABEL, IDH_PP_FILESHR_PARAMS_REMARK,
    IDC_PP_FILESHR_PARAMS_REMARK,IDH_PP_FILESHR_PARAMS_REMARK,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_GROUP, IDH_PP_FILESHR_PARAMS_MAX_USERS_GROUP,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB,IDH_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_RB,IDH_PP_FILESHR_PARAMS_MAX_USERS_RB,
    IDC_PP_FILESHR_PARAMS_MAX_USERS,IDH_PP_FILESHR_PARAMS_MAX_USERS,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_END, IDH_DISABLEHELP,
    IDC_PP_FILESHR_PARAMS_PERMISSIONS,IDH_PP_FILESHR_PARAMS_PERMISSIONS,
    IDC_PP_FILESHR_PARAMS_ADVANCED,IDH_PP_FILESHR_PARAMS_ADVANCED,
    IDC_PP_FILESHR_PARAMS_CACHING,IDH_PP_FILESHR_PARAMS_CACHING,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_GENAPP_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_GENAPP_PARAMS_COMMAND_LINE_LABEL, IDH_PP_GENAPP_PARAMS_COMMAND_LINE,
    IDC_PP_GENAPP_PARAMS_COMMAND_LINE,IDH_PP_GENAPP_PARAMS_COMMAND_LINE,
    IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY_LABEL, IDH_PP_GENAPP_PARAMS_CURRENT_DIRECTORY,
    IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY,IDH_PP_GENAPP_PARAMS_CURRENT_DIRECTORY,
    IDC_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP,IDH_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP,
    IDC_PP_GENAPP_PARAMS_USE_NETWORK_NAME,IDH_PP_GENAPP_PARAMS_USE_NETWORK_NAME,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_GENSCRIPT_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH_LABEL,IDH_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH,
    IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH,IDH_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_GENSVC_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP, 
    IDC_PP_GENSVC_PARAMS_SERVICE_NAME_LABEL, IDH_PP_GENSVC_PARAMS_SERVICE_NAME,
    IDC_PP_GENSVC_PARAMS_SERVICE_NAME,IDH_PP_GENSVC_PARAMS_SERVICE_NAME,
    IDC_PP_GENSVC_PARAMS_COMMAND_LINE_LABEL, IDH_PP_GENSVC_PARAMS_COMMAND_LINE,
    IDC_PP_GENSVC_PARAMS_COMMAND_LINE,IDH_PP_GENSVC_PARAMS_COMMAND_LINE,
    IDC_PP_GENSVC_PARAMS_USE_NETWORK_NAME,IDH_PP_GENSVC_PARAMS_USE_NETWORK_NAME,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_IPADDR_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_IPADDR_PARAMS_ADDRESS_LABEL, IDH_PP_IPADDR_PARAMS_ADDRESS,
    IDC_PP_IPADDR_PARAMS_ADDRESS,IDH_PP_IPADDR_PARAMS_ADDRESS,
    IDC_PP_IPADDR_PARAMS_SUBNET_MASK_LABEL, IDH_PP_IPADDR_PARAMS_SUBNET_MASK,
    IDC_PP_IPADDR_PARAMS_SUBNET_MASK,IDH_PP_IPADDR_PARAMS_SUBNET_MASK,
    IDC_PP_IPADDR_PARAMS_NETWORK_LABEL, IDH_PP_IPADDR_PARAMS_NETWORK,
    IDC_PP_IPADDR_PARAMS_NETWORK,IDH_PP_IPADDR_PARAMS_NETWORK,
    IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS,IDH_PP_IPADDR_PARAMS_ENABLE_NETBIOS,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_NETNAME_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_NETNAME_PARAMS_NAME_LABEL, IDH_PP_NETNAME_PARAMS_NAME,
    IDC_PP_NETNAME_PARAMS_NAME,IDH_PP_NETNAME_PARAMS_NAME,
    IDC_PP_NETNAME_PARAMS_RENAME,IDH_PP_NETNAME_PARAMS_RENAME,
    IDC_PP_NETNAME_PARAMS_CORE_TEXT, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_PRTSPOOL_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR_LABEL, IDH_PP_PRTSPOOL_PARAMS_SPOOL_DIR,
    IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR,IDH_PP_PRTSPOOL_PARAMS_SPOOL_DIR,
    IDC_PP_PRTSPOOL_PARAMS_TIMEOUT_LABEL1, IDH_PP_PRTSPOOL_PARAMS_TIMEOUT,
    IDC_PP_PRTSPOOL_PARAMS_TIMEOUT,IDH_PP_PRTSPOOL_PARAMS_TIMEOUT,
    IDC_PP_PRTSPOOL_PARAMS_TIMEOUT_LABEL2, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_REGREPL_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_REGREPL_PARAMS_NOTE, IDH_DISABLEHELP,
    IDC_PP_REGREPL_PARAMS_LIST,IDH_PP_REGREPL_PARAMS_LIST,
    IDC_PP_REGREPL_PARAMS_ADD,IDH_PP_REGREPL_PARAMS_ADD,
    IDC_PP_REGREPL_PARAMS_MODIFY,IDH_PP_REGREPL_PARAMS_MODIFY,
    IDC_PP_REGREPL_PARAMS_REMOVE,IDH_PP_REGREPL_PARAMS_REMOVE,
    0, 0
};


#else

extern const DWORD g_aHelpIDs_IDD_PP_DISKS_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_GENAPP_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_GENSCRIPT_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_GENSVC_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_NETNAME_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_FILESHR_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_IPADDR_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_PRTSPOOL_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_REGREPL_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_DISKS_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_GENAPP_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_GENSCRIPT_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_GENSVC_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_IPADDR_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_NETNAME_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_FILESHR_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_PRTSPOOL_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_REGREPL_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_EDIT_REGKEY[];
extern const DWORD g_aHelpIDs_IDD_EDIT_CLUSTER_NAME[];
extern const DWORD g_aHelpIDs_IDD_FILESHR_ADVANCED[];
extern const DWORD g_aHelpIDs_IDD_FILESHR_CACHE_SETTINGS[];

#endif // INITHELPARRAYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\helpdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.h
//
//	Abstract:
//		Definitions for data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _HELPDATA_H_
#define _HELPDATA_H_

#include "HelpArr.h"

/////////////////////////////////////////////////////////////////////////////

#endif // _HELPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\netname.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1999 Microsoft Corporation
//
//  Module Name:
//      NetName.cpp
//
//  Abstract:
//      Implementation of the CNetworkNameParamsPage class.
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"
#include "NetName.h"
#include "DDxDDv.h"
#include "ExcOper.h"
#include "ClusName.h"
#include "HelpData.h"   // for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetworkNameParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNetworkNameParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNetworkNameParamsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CNetworkNameParamsPage)
    ON_EN_CHANGE(IDC_PP_NETNAME_PARAMS_NAME, OnChangeName)
    ON_BN_CLICKED(IDC_PP_NETNAME_PARAMS_RENAME, OnRename)
    ON_BN_CLICKED(IDC_PP_NETNAME_PARAMS_CHECKBOX_DNS, OnRequireDNS)
    ON_BN_CLICKED(IDC_PP_NETNAME_PARAMS_CHECKBOX_KERBEROS, CBasePropertyPage::OnChangeCtrl)
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::CNetworkNameParamsPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetworkNameParamsPage::CNetworkNameParamsPage(void)
    : CBasePropertyPage(g_aHelpIDs_IDD_PP_NETNAME_PARAMETERS, g_aHelpIDs_IDD_WIZ_NETNAME_PARAMETERS)
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CNetworkNameParamsPage)
    m_strName = _T("");
    m_strPrevName = _T("");
    m_nRequireDNS = BST_UNCHECKED;
    m_nRequireKerberos = BST_UNCHECKED;
    m_dwNetBIOSStatus = 0;
    m_dwDNSStatus = 0;
    m_dwKerberosStatus = 0;
    //}}AFX_DATA_INIT

    // Setup the property array.
    {
        m_rgProps[epropName].Set(REGPARAM_NETNAME_NAME, m_strName, m_strPrevName);
        m_rgProps[epropRequireDNS].Set(REGPARAM_NETNAME_REQUIRE_DNS, m_nRequireDNS, m_nPrevRequireDNS);
        m_rgProps[epropRequireKerberos].Set(REGPARAM_NETNAME_REQUIRE_KERBEROS, m_nRequireKerberos, m_nPrevRequireKerberos);
        m_rgProps[epropStatusNetBIOS].Set(REGPARAM_NETNAME_STATUS_NETBIOS, m_dwNetBIOSStatus, m_dwPrevNetBIOSStatus);
        m_rgProps[epropStatusDNS].Set(REGPARAM_NETNAME_STATUS_DNS, m_dwDNSStatus, m_dwPrevDNSStatus);
        m_rgProps[epropStatusKerberos].Set(REGPARAM_NETNAME_STATUS_KERBEROS, m_dwKerberosStatus, m_dwPrevKerberosStatus);
    }  // Setup the property array

    m_dwFlags = 0;

    m_iddPropertyPage = IDD_PP_NETNAME_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_NETNAME_PARAMETERS;

}  //*** CNetworkNameParamsPage::CNetworkNameParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::HrInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//
//  Return Value:
//      S_OK        Page initialized successfully.
//      hr          Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetworkNameParamsPage::HrInit(IN OUT CExtObject * peo)
{
    HRESULT     hr;
    CWaitCursor wc;
    DWORD   sc;
    DWORD   cbReturned;

    // Call the base class method.
    // This populates the m_rgProps struct.
    hr = CBasePropertyPage::HrInit(peo);   

    if (!FAILED(hr))
    {
        m_strPrevName = m_strName;
        
        // Read the flags for this resource.
        sc = ClusterResourceControl(
                        Peo()->PrdResData()->m_hresource,
                        NULL,
                        CLUSCTL_RESOURCE_GET_FLAGS,
                        NULL,
                        NULL,
                        &m_dwFlags,
                        sizeof(m_dwFlags),
                        &cbReturned
                        );
        if (sc != ERROR_SUCCESS)
        {
            CNTException nte(sc, NULL, NULL, FALSE /*bAutoDelete*/);
            nte.ReportError();
            nte.Delete();
        }  // if:  error retrieving data
        else
        {
            ASSERT(cbReturned == sizeof(m_dwFlags));
        }  // else:  data retrieved successfully
    }  // if: base class init was successful

    return hr;

}  //*** CNetworkNameParamsPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetworkNameParamsPage::DoDataExchange(CDataExchange * pDX)
{
    DWORD       scError;
    BOOL        bError;

    if (!pDX->m_bSaveAndValidate || !BSaved())
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        CWaitCursor wc;
        CString     strNetName;

        // TODO: Modify the following lines to represent the data displayed on this page.
        //{{AFX_DATA_MAP(CNetworkNameParamsPage)
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_NAME_LABEL, m_staticName);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_RENAME, m_pbRename);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_CORE_TEXT, m_staticCore);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_NAME, m_editName);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_CHECKBOX_DNS, m_cbRequireDNS);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_CHECKBOX_KERBEROS, m_cbRequireKerberos);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_STATUS_NETBIOS, m_editNetBIOSStatus);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_STATUS_DNS, m_editDNSStatus);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_STATUS_KERBEROS, m_editKerberosStatus);

        //
        // Get the status of the checkboxes.
        //
        DDX_Check(pDX, IDC_PP_NETNAME_PARAMS_CHECKBOX_DNS, m_nRequireDNS);
        DDX_Check(pDX, IDC_PP_NETNAME_PARAMS_CHECKBOX_KERBEROS, m_nRequireKerberos);
        //}}AFX_DATA_MAP

        bError = FALSE;

        if (pDX->m_bSaveAndValidate && !BBackPressed())
        {
            CLRTL_NAME_STATUS cnStatus;
            CString     strMsg;
            UINT        idsError;

            //
            // Get the name from the control into a temp variable
            //
            DDX_Text(pDX, IDC_PP_NETNAME_PARAMS_NAME, strNetName);
            DDV_RequiredText(pDX, IDC_PP_NETNAME_PARAMS_NAME, IDC_PP_NETNAME_PARAMS_NAME_LABEL, strNetName);
            DDV_MaxChars(pDX, strNetName, MAX_CLUSTERNAME_LENGTH);

            if( m_nRequireDNS == BST_UNCHECKED )
            {
                m_nRequireKerberos = BST_UNCHECKED;
            }

            if ( (m_strName != strNetName ) &&
                 (! ClRtlIsNetNameValid(strNetName, &cnStatus, FALSE /*CheckIfExists*/)) )
            {
                switch (cnStatus)
                {
                    case NetNameTooLong:
                        idsError = IDS_INVALID_NETWORK_NAME_TOO_LONG;
                        break;
                    case NetNameInvalidChars:
                        idsError = IDS_INVALID_NETWORK_NAME_INVALID_CHARS;
                        break;
                    case NetNameInUse:
                        idsError = IDS_INVALID_NETWORK_NAME_IN_USE;
                        break;
                    case NetNameDNSNonRFCChars:
                        idsError = IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS;
                        break;
                    case NetNameSystemError:
                    {
                        scError = GetLastError();
                        CNTException nte(scError, IDS_ERROR_VALIDATING_NETWORK_NAME, (LPCWSTR) strNetName);
                        nte.ReportError();
                        pDX->Fail();
                    }
                    default:
                        idsError = IDS_INVALID_NETWORK_NAME;
                        break;
                }  // switch:  cnStatus

                strMsg.LoadString(idsError);
                if ( idsError == IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS )
                {
                    int id = AfxMessageBox(strMsg, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION );

                    if ( id == IDNO )
                    {
                        strMsg.Empty();
                        pDX->Fail();
                        bError = TRUE;
                    }
                }
                else
                {
                    AfxMessageBox(strMsg, MB_ICONEXCLAMATION);
                    strMsg.Empty(); // exception prep
                    pDX->Fail();
                    bError = TRUE;
                }
            } // if: ((m_strName != strNetName) && (! ClRtlIsNetNameValid(strNetName, &cnStatus, FALSE)) )
            
            //
            // Everything was validated - apply all of the changes.
            //
            if( FALSE == bError )
            {
                m_strName = strNetName;
            }
            
        }// if:  (pDX->m_bSaveAndValidate && !BBackPressed())
        else  // if: populating controls
        {
            CString m_strStatus;

            //
            // Populate the controls with data from the member variables.
            //
            DDX_Text(pDX, IDC_PP_NETNAME_PARAMS_NAME, m_strName);

            m_strStatus.Format( _T("%d (0x%08x)"), m_dwNetBIOSStatus, m_dwNetBIOSStatus );
            DDX_Text( pDX, IDC_PP_NETNAME_PARAMS_STATUS_NETBIOS, m_strStatus );

            m_strStatus.Format( _T("%d (0x%08x)"), m_dwDNSStatus, m_dwDNSStatus );
            DDX_Text( pDX, IDC_PP_NETNAME_PARAMS_STATUS_DNS, m_strStatus );

            m_strStatus.Format( _T("%d (0x%08x)"), m_dwKerberosStatus, m_dwKerberosStatus );
            DDX_Text( pDX, IDC_PP_NETNAME_PARAMS_STATUS_KERBEROS, m_strStatus );
        }
    }  // if:  not saving or haven't saved yet

    CBasePropertyPage::DoDataExchange(pDX);

}  //*** CNetworkNameParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetworkNameParamsPage::OnInitDialog(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::OnInitDialog();

    // Set limits on the edit controls.
    m_editName.SetLimitText(MAX_CLUSTERNAME_LENGTH);

    // Set up the checkboxes.
    m_cbRequireDNS.EnableWindow( TRUE );
    m_cbRequireKerberos.EnableWindow( m_nRequireDNS != 0 );

    // 
    // Make sure we're not dealing with a non-Whistler Cluster.  If we are then
    // disable both checkboxes (the props didn't exist back then - don't set them).
    //
    CheckForDownlevelCluster();
    
    // If this is a core resource, set the name control to be read-only
    // and enable the Core Resource static control.
    if (BCore())
    {
        WINDOWPLACEMENT wpLabel;
        WINDOWPLACEMENT wpName;
        WINDOWPLACEMENT wpButton;
        WINDOWPLACEMENT wpText;
        WINDOWPLACEMENT wpCheckDNS;
        WINDOWPLACEMENT wpCheckKerberos;
        CRect           rectName;
        CRect           rectText;
        RECT *          prect;
        LONG            nHeight;

        // Get the placement of the controls.
        m_editName.GetWindowPlacement(&wpName);
        m_staticCore.GetWindowPlacement(&wpText);
        m_staticName.GetWindowPlacement(&wpLabel);
        m_pbRename.GetWindowPlacement(&wpButton);
        m_cbRequireDNS.GetWindowPlacement(&wpCheckDNS);
        m_cbRequireKerberos.GetWindowPlacement(&wpCheckKerberos);
        
        // Get the positions of the edit control and text control.
        rectName = wpName.rcNormalPosition;
        rectText = wpText.rcNormalPosition;

        // Move the name control to where the text control is.
        prect = &wpName.rcNormalPosition;
        *prect = rectText;
        nHeight = rectName.bottom - rectName.top;
        prect->left = rectName.left;
        prect->right = rectName.right;
        prect->bottom = prect->top + nHeight;
        m_editName.SetWindowPlacement(&wpName);

        // Move the text control to where the name control was.
        prect = &wpText.rcNormalPosition;
        *prect = rectName;
        nHeight = rectText.bottom - rectText.top;
        prect->left = rectText.left;
        prect->right = rectText.right;
        prect->bottom = prect->top + nHeight;
        m_staticCore.SetWindowPlacement(&wpText);

        // Move the name label control to be next to the name edit control.
        prect = &wpLabel.rcNormalPosition;
        nHeight = prect->bottom - prect->top;
        prect->top = wpName.rcNormalPosition.top + 2;
        prect->bottom = prect->top + nHeight;
        m_staticName.SetWindowPlacement(&wpLabel);

        // Move the button control to be next to the name edit control.
        prect = &wpButton.rcNormalPosition;
        nHeight = prect->bottom - prect->top;
        prect->top = wpName.rcNormalPosition.top;
        prect->bottom = prect->top + nHeight;
        m_pbRename.SetWindowPlacement(&wpButton);

        // Move the Require DNS checkbox down.
        prect = &wpCheckDNS.rcNormalPosition;
        nHeight = prect->bottom - prect->top;

        // Move us down by the height of the now displayed static text.
        prect->top = prect->top + (wpText.rcNormalPosition.bottom - wpText.rcNormalPosition.top);
        prect->top = prect->top + rectText.top - rectName.bottom;
        prect->bottom = prect->top + nHeight;
        m_cbRequireDNS.SetWindowPlacement(&wpCheckDNS);
        
        // Move the Require Kerberos checkbox down.
        prect = &wpCheckKerberos.rcNormalPosition;
        nHeight = prect->bottom - prect->top;

        // Move us down by the height of the now displayed static text.
        prect->top = prect->top + (wpText.rcNormalPosition.bottom - wpText.rcNormalPosition.top);
        prect->top = prect->top + rectText.top - rectName.bottom;
        prect->bottom = prect->top + nHeight;
        m_cbRequireKerberos.SetWindowPlacement(&wpCheckKerberos);

        // Prevent the name edit control from being editable and
        // Show the text and the button.
        m_editName.SetReadOnly(TRUE);
        m_staticCore.ShowWindow(SW_SHOW);
        m_pbRename.ShowWindow(SW_SHOW);
        m_pbRename.EnableWindow( TRUE );       
    }
    else // if: core resource (show static text & move other controls down)
    {
        m_editName.SetReadOnly(FALSE);
        m_staticCore.ShowWindow(SW_HIDE);
        m_pbRename.ShowWindow(SW_HIDE);
        m_pbRename.EnableWindow( FALSE );
    }  // else:  not core resource

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNetworkNameParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetworkNameParamsPage::OnSetActive(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Enable/disable the Next/Finish button.
    if (BWizard())
    {
        if (m_strName.GetLength() == 0)
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  enable/disable the Next button

    return CBasePropertyPage::OnSetActive();

}  //*** CNetworkNameParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetworkNameParamsPage::BApplyChanges(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWaitCursor wc;
    BOOL        bSuccess = TRUE;

    // Save data.
    if (BCore())
    {
        DWORD       scStatus;

        //
        // If this is the core Network Name (Cluster Name) we should set the name via
        // the SetClusterName API. If that succeeds then we'll set the other properties.
        //
        if ( m_strName != m_strPrevName )
        {
            scStatus = SetClusterName(Hcluster(), m_strName);
            if (scStatus != ERROR_SUCCESS)
            {
                if (scStatus == ERROR_RESOURCE_PROPERTIES_STORED)
                {
                    TCHAR           szError[1024];
                    CNTException    nte(scStatus, NULL, m_strName, NULL, FALSE /*bAutoDelete*/);
                    nte.FormatErrorMessage(szError, sizeof(szError) / sizeof(TCHAR), NULL, FALSE /*bIncludeID*/);
                    nte.Delete();
                    AfxMessageBox(szError);
                }  // if:  properties stored
                else
                {
                    CNTException    nte(scStatus, IDS_ERROR_SETTING_CLUSTER_NAME, m_strName, NULL, FALSE /*bAutoDelete*/);
                    nte.ReportError();
                    nte.Delete();
                    bSuccess = FALSE;
                }  // else:  other error occurred
            }  // if:  error setting the cluster name
            else
            {
                //
                // By setting the prev value equal to the current value the BSetPrivateProps
                // function will skip this prop when constructing it's list of props to set.
                //
                m_strPrevName = m_strName;
            }
        } // if: name has changed

        //
        // Now set the other private properties.
        //
        if ( bSuccess == TRUE ) 
        {
            bSuccess = BSetPrivateProps();
        }
    }  // if:  core resource
    else
    {   
        bSuccess = BSetPrivateProps();
    }

    //
    // If we applied the changes then clear the require kerberos check if
    // the checkbox was disabled.  Don't make this dependent upon the require
    // DNS checkbox state as the dependency may change in the future.
    //
    if( ( bSuccess == TRUE ) &&
        ( m_cbRequireKerberos.IsWindowEnabled() == FALSE ) )
    {
        m_cbRequireKerberos.SetCheck( BST_UNCHECKED );
    }

    return bSuccess;

}  //*** CNetworkNameParamsPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::OnChangeName
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Name edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetworkNameParamsPage::OnChangeName(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (BWizard())
    {
        if (m_editName.GetWindowTextLength() == 0)
        {
            EnableNext(FALSE);
        }
        else
        {
            EnableNext(TRUE);
        }
    }  // if:  in a wizard

}  //*** CNetworkNameParamsPage::OnChangeName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::OnRename
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Rename push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetworkNameParamsPage::OnRename(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CChangeClusterNameDlg   dlg(this);

    ASSERT(BCore());

    dlg.m_strClusName = m_strName;
    if (dlg.DoModal() == IDOK)
    {
        if (m_strName != dlg.m_strClusName)
        {
            OnChangeCtrl();
            m_strName = dlg.m_strClusName;
            UpdateData(FALSE /*bSaveAndValidate*/);
        }  // if:  the name changed
    }  // if:  user accepted change

}  //*** CNetworkNameParamsPage::OnRename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::OnRequireDNS
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the RequireDNS checkbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetworkNameParamsPage::OnRequireDNS(void)
{
    int nChecked;
    
    nChecked = m_cbRequireDNS.GetCheck();

    m_cbRequireKerberos.EnableWindow( nChecked == BST_CHECKED );

    SetModified( TRUE );
}  //*** CNetworkNameParamsPage::OnRequireDNS()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::CheckForDownlevelCluster
//
//  Routine Description:
//      If determine whether the cluster we're connected to is pre-Whistler.
//      If it is then disable the buttons.  If an error occurs display a
//      message box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetworkNameParamsPage::CheckForDownlevelCluster(void)
{
    CLUSTERVERSIONINFO cvi;
    DWORD sc;
    DWORD scErr;
    DWORD cchName;

    //
    // Determine whether we're talking to a pre-Whistler cluster.
    // If so, disable the Require DNS & Kerberos checkboxes.
    //
    memset( &cvi, 0, sizeof( cvi ) );

    cvi.dwVersionInfoSize = sizeof( cvi );

    cchName = 0;
    sc = GetClusterInformation( Hcluster(), NULL, &cchName, &cvi );
    scErr = GetLastError();

    if( ERROR_SUCCESS != sc )
    {
        //
        // API failed.  Pop up a message box.
        //
        TCHAR           szError[1024];
        CNTException    nte(scErr, IDS_ERROR_GETTING_CLUSTER_INFORMATION, m_strName, NULL, FALSE /*bAutoDelete*/);
        nte.FormatErrorMessage(szError, sizeof(szError) / sizeof(TCHAR), NULL, FALSE /*bIncludeID*/);
        nte.ReportError();
        nte.Delete();

        //
        // We can't be sure that we're on a down-level cluster (chances are that we're not),
        // so leave the checkboxes enabled - the worst that will happen is that some extra props 
        // will be added that are ignored by the resource.
        //
    }
    else
    {
        if( CLUSTER_GET_MAJOR_VERSION( cvi.dwClusterHighestVersion ) < NT51_MAJOR_VERSION )
        {
            //
            // We're on a pre-Whistler Cluster where the DNS & Kerberos setting make no
            // sense.  So, disable the checkboxes to indicate that the settings
            // are unavailable.
            //
            m_cbRequireKerberos.EnableWindow( FALSE );
            m_cbRequireDNS.EnableWindow( FALSE );
        }
    }

}  //*** CNetworkNameParamsPage::CheckForDownlevelCluster()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\helpids.h ===
#define IDH_CLUSNAME    700000000
#define IDH_FILESHR_ADV_DFS_ROOT    700000051
#define IDH_FILESHR_ADV_HIDE_SUBDIR_SHARES  700000053
#define IDH_FILESHR_ADV_NORMAL_SHARE    700000050
#define IDH_FILESHR_ADV_SHARE_SUBDIRS   700000052
#define IDH_FILESHR_CACHE_ALLOW_CACHING 0
#define IDH_FILESHR_CACHE_OPTIONS   0
#define IDH_FILESHR_CACHE_HINT  0
#define IDH_PP_DISKS_PARAMS_DISK    700000100
#define IDH_PP_FILESHR_PARAMS_ADVANCED  700000133
#define IDH_PP_FILESHR_PARAMS_MAX_USERS 700000131
#define IDH_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB  700000129
#define IDH_PP_FILESHR_PARAMS_MAX_USERS_GROUP   700000128
#define IDH_PP_FILESHR_PARAMS_MAX_USERS_RB  700000130
#define IDH_PP_FILESHR_PARAMS_PATH  700000126
#define IDH_PP_FILESHR_PARAMS_PERMISSIONS   700000132
#define IDH_PP_FILESHR_PARAMS_REMARK    700000127
#define IDH_PP_FILESHR_PARAMS_SHARE_NAME    700000125
#define IDH_PP_FILESHR_PARAMS_CACHING   700000302
#define IDH_PP_GENAPP_PARAMS_COMMAND_LINE   700000150
#define IDH_PP_GENAPP_PARAMS_CURRENT_DIRECTORY  700000151
#define IDH_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP  700000152
#define IDH_PP_GENAPP_PARAMS_USE_NETWORK_NAME   700000153
#define IDH_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH 700000154
#define IDH_PP_GENSVC_PARAMS_COMMAND_LINE   700000176
#define IDH_PP_GENSVC_PARAMS_SERVICE_NAME   700000175
#define IDH_PP_GENSVC_PARAMS_USE_NETWORK_NAME   700000177
#define IDH_PP_IPADDR_PARAMS_ADDRESS    700000200
#define IDH_PP_IPADDR_PARAMS_ENABLE_NETBIOS 700000203
#define IDH_PP_IPADDR_PARAMS_NETWORK    700000202
#define IDH_PP_IPADDR_PARAMS_SUBNET_MASK    700000201
#define IDH_PP_NETNAME_PARAMS_NAME  700000225
#define IDH_PP_NETNAME_PARAMS_RENAME    700000226
#define IDH_PP_PRTSPOOL_PARAMS_SPOOL_DIR    700000250
#define IDH_PP_PRTSPOOL_PARAMS_TIMEOUT  700000251
#define IDH_PP_REGREPL_PARAMS_ADD   700000276
#define IDH_PP_REGREPL_PARAMS_LIST  700000275
#define IDH_PP_REGREPL_PARAMS_MODIFY    700000277
#define IDH_PP_REGREPL_PARAMS_REMOVE    700000278
#define IDH_REGKEY  700000025
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\proplsts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		PropLstS.cpp
//
//	Abstract:
//		Stub for implementation of property list classes.
//
//	Author:
//		David Potter (davidp)	February 24, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PropList.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\netname.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1999 Microsoft Corporation
//
//  Module Name:
//      NetName.h
//
//  Abstract:
//      Definition of the CNetworkNameParamsPage class, which implements the
//      Parameters page for Network Name resources.
//
//  Implementation File:
//      NetName.cpp
//
//  Author:
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NETNAME_H_
#define _NETNAME_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"   // for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNetworkNameParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CNetworkNameParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CNetworkNameParamsPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CNetworkNameParamsPage)

// Construction
public:
    CNetworkNameParamsPage(void);

    // Second phase construction.
    virtual HRESULT     HrInit(IN OUT CExtObject * peo);

// Dialog Data
    //{{AFX_DATA(CNetworkNameParamsPage)
    enum { IDD = IDD_PP_NETNAME_PARAMETERS };
    CStatic m_staticName;
    CButton m_pbRename;
    CStatic m_staticCore;
    CEdit   m_editName;
    CString m_strName;

    CButton m_cbRequireDNS;
    int     m_nRequireDNS;

    CButton m_cbRequireKerberos;
    int     m_nRequireKerberos;
    
    CEdit   m_editNetBIOSStatus;
    DWORD   m_dwNetBIOSStatus;
    
    CEdit   m_editDNSStatus;
    DWORD   m_dwDNSStatus;

    CEdit   m_editKerberosStatus;
    DWORD   m_dwKerberosStatus;
    
    //}}AFX_DATA

    CString m_strPrevName;
    int     m_nPrevRequireDNS;
    int     m_nPrevRequireKerberos;
    DWORD   m_dwPrevNetBIOSStatus;
    DWORD   m_dwPrevDNSStatus;
    DWORD   m_dwPrevKerberosStatus;

protected:
    enum
    {
        epropName = 0,
        epropRequireDNS,
        epropRequireKerberos,
        epropStatusNetBIOS,
        epropStatusDNS,
        epropStatusKerberos,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

// Overrides
public:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CNetworkNameParamsPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    virtual BOOL        BApplyChanges(void);

protected:
    virtual const   CObjectProperty *   Pprops(void) const  { return m_rgProps; }
    virtual DWORD   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(CObjectProperty); }

    virtual void CheckForDownlevelCluster();
// Implementation
protected:
    DWORD   m_dwFlags;

    BOOL    BCore(void) const   { return (m_dwFlags & CLUS_FLAG_CORE) != 0; }

    // Generated message map functions
    //{{AFX_MSG(CNetworkNameParamsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeName();
    afx_msg void OnRename();
    afx_msg void OnRequireDNS();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CNetworkNameParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _NETNAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\prtspool.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1999 Microsoft Corporation
//
//  Module Name:
//      PrtSpool.cpp
//
//  Abstract:
//      Implementation of the CPrintSpoolerParamsPage class.
//
//  Author:
//      David Potter (davidp)   October 17, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"
#include "PrtSpool.h"
#include "DDxDDv.h"
#include "HelpData.h"   // for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPrintSpoolerParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CPrintSpoolerParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CPrintSpoolerParamsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CPrintSpoolerParamsPage)
    ON_EN_CHANGE(IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR, OnChangeSpoolDir)
    ON_EN_CHANGE(IDC_PP_PRTSPOOL_PARAMS_DRIVER_DIR, CBasePropertyPage::OnChangeCtrl)
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
    ON_EN_CHANGE(IDC_PP_PRTSPOOL_PARAMS_TIMEOUT, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPrintSpoolerParamsPage::CPrintSpoolerParamsPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CPrintSpoolerParamsPage::CPrintSpoolerParamsPage(void)
    : CBasePropertyPage(g_aHelpIDs_IDD_PP_PRTSPOOL_PARAMETERS, g_aHelpIDs_IDD_WIZ_PRTSPOOL_PARAMETERS)
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CPrintSpoolerParamsPage)
    m_strSpoolDir = _T("");
    m_nJobCompletionTimeout = 0;
    m_strDriverDir = _T("");
    //}}AFX_DATA_INIT

    // Setup the property array.
    {
        m_rgProps[epropSpoolDir].Set(REGPARAM_PRTSPOOL_DEFAULT_SPOOL_DIR, m_strSpoolDir, m_strPrevSpoolDir);
        m_rgProps[epropTimeout].Set(REGPARAM_PRTSPOOL_TIMEOUT, m_nJobCompletionTimeout, m_nPrevJobCompletionTimeout);
        m_rgProps[epropDriverDir].Set(REGPARAM_PRTSPOOL_DRIVER_DIRECTORY, m_strDriverDir, m_strPrevDriverDir);
    }  // Setup the property array

    m_iddPropertyPage = IDD_PP_PRTSPOOL_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_PRTSPOOL_PARAMETERS;

}  //*** CPrintSpoolerParamsPage::CPrintSpoolerParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPrintSpoolerParamsPage::HrInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//
//  Return Value:
//      S_OK        Page initialized successfully.
//      hr          Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CPrintSpoolerParamsPage::HrInit(IN OUT CExtObject * peo)
{
    HRESULT     _hr;
    CWaitCursor _wc;

    do
    {
        // Call the base class method.
        _hr = CBasePropertyPage::HrInit(peo);
        if (FAILED(_hr))
            break;

        if (BWizard())
            m_nJobCompletionTimeout = 160;
        else
        {
            // Convert the job completion timeout to seconds.
            m_nPrevJobCompletionTimeout = m_nJobCompletionTimeout;
            m_nJobCompletionTimeout = (m_nJobCompletionTimeout + 999) / 1000;
        }  // else:  not creating new resource
    } while ( 0 );

    return _hr;

}  //*** CPrintSpoolerParamsPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPrintSpoolerParamsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CPrintSpoolerParamsPage::DoDataExchan