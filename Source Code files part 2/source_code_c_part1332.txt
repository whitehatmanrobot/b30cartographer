HRESULT hr = WBEM_NO_ERROR;

    CCompoundKey* pKey = NULL;

    //
    // We really need a CCompoundKey object
    //

    hr = CreateCompoundKeyFromString(pszCompKey, &pKey);
    if (FAILED(hr))
    {
        *pdwNewCookie = INVALID_COOKIE;
        return hr;
    }

    //
    // make sure that we don't add duplicate keys
    //

    ExtClassCookieIterator it = m_mapCookies.find(pKey);
    if (it != m_mapCookies.end())
    {
        //
        // already there, just pass back the cookie
        //

        *pdwNewCookie = (*it).second;
    }
    else
    {
        //
        // not present in our map yet
        //

        *pdwNewCookie = dwDefCookie;

        if (dwDefCookie == INVALID_COOKIE)
        {
            if (m_dwMaxCookie + 1 == INVALID_COOKIE)
            {
                //
                // If the next cookie is INVALID_COOKIE, we need to search
                // for a free slot. This gets more expansive. But given that
                // it needs to reach 0xFFFFFFFF to have this happen, ordinary
                // situation won't get to this point.
                //

                hr = GetNextFreeCookie(pdwNewCookie);
            }
            else
            {
                *pdwNewCookie = ++m_dwMaxCookie;
            }
        }

        //
        // we need to maintain the other vector, which records the order at which
        // cookies are added (so that it can be preserved and used as access order)
        //

        if (SUCCEEDED(hr))
        {
            //
            // now, push the pair to the vector, it will take care of the memory
            //

            CookieKeyPair* pNewCookieKey = new CookieKeyPair;
            if (pNewCookieKey == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
            else
            {
                pNewCookieKey->dwCookie = *pdwNewCookie;
                pNewCookieKey->pKey = pKey;
                m_vecCookies.push_back(pNewCookieKey);

                //
                // the map takes the ownership of the memory of pKey
                //

                m_mapCookies.insert(MapExtClassCookie::value_type(pKey, *pdwNewCookie));

                pKey = NULL;
            }
        }
    }

    //
    // if we have added it to the map, pKey == NULL. So harmless
    //

    delete pKey;

    return hr;
}

/*
Routine Description: 

Name:

    CExtClassInstCookieList::RemoveCompKey

Functionality:
    
    Will remove the compound key (given by the string) from the store. This is just a helper
    not intended for outside use.

Virtual:
    
    No.
    
Arguments:

    pSceStore      - the store

    pszSectionName - section name

    pszCompKey     - the string version of the compound key to be removed from store

Return Value:

    Will return the cookie for the compound key. INVALID_COOKIE indicate some failure to
    remove the compound key from the store.

Notes:
    (1) No thread safety. Caller must be aware.

*/

DWORD CExtClassInstCookieList::RemoveCompKey (
    IN CSceStore    * pSceStore,
    IN LPCWSTR        pszSectionName,
    IN LPCWSTR        pszCompKey
    )
{
    if (pszCompKey == NULL || *pszCompKey == L'\0')
    {
        return INVALID_COOKIE;
    }

    //
    // We really need a CCompoundKey object
    //

    CCompoundKey* pKey = NULL;
    HRESULT hr = CreateCompoundKeyFromString(pszCompKey, &pKey);
    if (FAILED(hr))
    {
        return INVALID_COOKIE;
    }

    ExtClassCookieIterator it = m_mapCookies.find(pKey);

    DWORD dwCookie = INVALID_COOKIE;
    if (it != m_mapCookies.end())
    {
        dwCookie = (*it).second;
    }

    if (pSceStore && dwCookie != INVALID_COOKIE)
    {
        //
        // found! So, we need to erase it from our map and our vector.
        // make sure that we release the compound key managed by the element
        // of the map and then erase it!
        //

        //
        // if anything goes wrong with deleting from store, then we don't do it
        //

        if (SUCCEEDED(DeleteKeyFromStore(pSceStore, pszSectionName, dwCookie)))
        {
            delete (*it).first;
            m_mapCookies.erase(it);

            //
            // remove it from the vector, too. This is expensive. Again, don't release
            // the pointer of pKey inside the vector's struct element since it's taken care
            // of by the map's release.
            //

            CookieKeyIterator itCookieKey = m_vecCookies.begin();
            while (itCookieKey != m_vecCookies.end() && (*itCookieKey)->dwCookie != dwCookie)
            {
                ++itCookieKey;
            }

            if (itCookieKey != m_vecCookies.end())
            {
                delete (*itCookieKey);
                m_vecCookies.erase(itCookieKey);
            }
        }
    }

    return dwCookie;
}

/*
Routine Description: 

Name:

    CExtClassInstCookieList::Next

Functionality:
    
    Enumeration

Virtual:
    
    No.
    
Arguments:

    pbstrCompoundKey - the string version of the compound key the enumeration finds. May be NULL.

    pdwCookie        - the cookie where the enumeration find. May be NULL.

    pdwResumeHandle  - hint for next enumeration (0 when start enumeration)

Return Value:

    Success: WBEM_E_NO_ERROR
    
    Failure: WBEM_S_NO_MORE_DATA if the enueration has reached the end
             WBEM_E_INVALID_PARAMETER if pdwResumeHandle == NULL
             Other errors may also occur.

Notes:
    (1) No thread safety. Caller must be aware.
    (2) Pass in 0 to start the first enuemration step
    (3) If caller is only interested in the cookie, then pass pbstrCompoundKey == NULL
    (4) Similarly, if the caller is only interested in the string version of the compounp key,
        then pass pdwCookie.

*/
    
HRESULT 
CExtClassInstCookieList::Next (
    OUT BSTR        * pbstrCompoundKey,
    OUT DWORD       * pdwCookie,  
    IN OUT DWORD    * pdwResumeHandle
)
{
    if (pdwResumeHandle == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_NO_ERROR;
    
    //
    // set some good default values
    //

    if (pbstrCompoundKey)
    {
        *pbstrCompoundKey = NULL;
    }

    if (pdwCookie)
    {
        *pdwCookie = INVALID_COOKIE;
    }

    if (*pdwResumeHandle >= m_vecCookies.size())
    {
        hr = WBEM_S_NO_MORE_DATA;
    }
    else
    {
        if (pbstrCompoundKey)
        {
            hr = CreateCompoundKeyString(pbstrCompoundKey, m_vecCookies[*pdwResumeHandle]->pKey);
        }

        if (pdwCookie)
        {
            *pdwCookie = m_vecCookies[*pdwResumeHandle]->dwCookie;
        }

        (*pdwResumeHandle)++;
    }

    return hr;
}

/*
Routine Description: 

Name:

    CExtClassInstCookieList::GetNextFreeCookie

Functionality:
    
    A private helper to deal with cookie value overflow problem. Will search for
    a unused slot for the next cookie. 

Virtual:
    
    No.
    
Arguments:

    pdwCookie        - will pass back the next available cookie

Return Value:

    Success: WBEM_E_NO_ERROR
    
    Failure: WBEM_E_OUT_OF_MEMORY or WBEM_E_INVALID_PARAMETER

Notes:
    (1) No thread safety. Caller must be aware.
    (2) ***Warning*** Don't use it directly!

*/

HRESULT 
CExtClassInstCookieList::GetNextFreeCookie (
    OUT DWORD   * pdwCookie
    )
{
    if (pdwCookie == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    ExtClassCookieIterator it = m_mapCookies.begin();
    ExtClassCookieIterator itEnd = m_mapCookies.end();

    int iCount = m_mapCookies.size();

    //
    // remember pigeon hole principle? iCount + 1 holes will definitely have one
    // that is not occupied! So, we will find one in the first iCount + 1 indexes (1 -> iCount + 1)
    //

    //
    // since we don't want 0, we will waste the first index
    // for easy readability, I opt to wait this bit memory
    //

    BYTE *pdwUsedCookies = new BYTE[iCount + 2];
    if (pdwUsedCookies == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // set all slots unused!
    //

    ::memset(pdwUsedCookies, 0, iCount + 2);

    while(it != itEnd)
    {
        if ((*it).second <= iCount + 1)
        {
            pdwUsedCookies[(*it).second] = 1;
        }
        it++;
    }

    //
    // look for holes from 1 --> iCount + 1
    //

    for (int i = 1; i <= iCount + 1; ++i)
    {
        if (pdwUsedCookies[i] == 0)
            break;
    }
    
    delete [] pdwUsedCookies;

    *pdwCookie = i;

    return WBEM_NO_ERROR;

}

/*
Routine Description: 

Name:

    CExtClassInstCookieList::CreateCompoundKeyFromString

Functionality:
    
    A private helper to deal with cookie value overflow problem. Will search for
    a unused slot for the next cookie. 

Virtual:
    
    No.
    
Arguments:

    pszCompKeyStr   - string version of the compound key

    ppCompKey       - out-bound compound key if the string can be successfully interpreted as
                      compound key

Return Value:

    Success: Any success code (use SUCCEEDED(hr) to test) indicates success.
    
    Failure: any failure code indicates failure.

Notes:
    (1) No thread safety. Caller must be aware.
    (2) As normal, caller is responsible to release *ppCompKey.

*/

HRESULT 
CExtClassInstCookieList::CreateCompoundKeyFromString (
    IN LPCWSTR          pszCompKeyStr,
    OUT CCompoundKey ** ppCompKey
    )
{
    if (ppCompKey == NULL || pszCompKeyStr == NULL || *pszCompKeyStr == L'\0')
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppCompKey = NULL;

    HRESULT hr = WBEM_NO_ERROR;

    //
    // deal with NULL_KEY
    //

    bool bIsNullKey = _wcsicmp(pszCompKeyStr, pszNullKey) == 0;

    if (bIsNullKey)
    {   
        //
        // CCompoundKey(0) creates a null key
        //

        *ppCompKey = new CCompoundKey(0);
        if (*ppCompKey == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        return hr;
    }

    if (m_pVecNames == NULL || m_pVecNames->size() == 0)
    {
        //
        // in this case, you really have to pass in pszCompKeyStr as NULL_KEY.
        //

        return WBEM_E_INVALID_SYNTAX;
    }

    DWORD dwKeyPropCount = m_pVecNames->size();

    *ppCompKey = new CCompoundKey(dwKeyPropCount);
    if (*ppCompKey == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // ready to parse the string version of the compound key
    //

    //
    // hold the key property name
    //

    LPWSTR pszName = NULL;

    //
    // hold the key property value
    //

    VARIANT* pVar = NULL;

    //
    // current parsing point
    //

    LPCWSTR pszCur = pszCompKeyStr;

    //
    // next token point
    //

    LPCWSTR pszNext;
    
    pVar = new VARIANT;

    if (pVar == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        hr = ::ParseCompoundKeyString(pszCur, &pszName, pVar, &pszNext);


        while (SUCCEEDED(hr) && hr != WBEM_S_FALSE)
        {
            //
            // find the index to which the name occupies. Since the number of key properties
            // are always relatively small, we opt not to use fancy algorithms for lookup
            //

            for (DWORD dwIndex = 0; dwIndex < dwKeyPropCount; dwIndex++)
            {
                if (_wcsicmp((*m_pVecNames)[dwIndex], pszName) == 0)
                {
                    break;
                }
            }

            //
            // dwIndex >= dwKeyPropCount indicates that the name is not recognized!
            //

            //
            // since we don't care about the names anymore, release it here
            //

            delete [] pszName;
            pszName = NULL;

            //
            // a valid name, add it to the compound key, it takes the ownership of the variant memory
            //

            if (dwIndex < dwKeyPropCount)
            {
                //
                // if successfully added, pVar will be set to NULL by the function
                //

                hr = (*ppCompKey)->AddKeyPropertyValue(dwIndex, &pVar);
            }
            else
            {
                //
                // not recognized name, discard the variant, won't consider as an error
                //

                ::VariantClear(pVar);
                delete pVar;
                pVar = NULL;
            }

            //
            // start our next around
            //

            if (SUCCEEDED(hr))
            {
                pVar = new VARIANT;
                if (pVar == NULL)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }

            if (SUCCEEDED(hr))
            {
                pszCur = pszNext;
                hr = ::ParseCompoundKeyString(pszCur, &pszName, pVar, &pszNext);
            }
        }
        
        //
        // final cleanup, regarless of success
        //

        if (pVar)
        {
            ::VariantClear(pVar);
            delete pVar;
        }
    }

    //
    // if error occurs, clean up our partially created compound key
    //

    if (FAILED(hr) && *ppCompKey != NULL)
    {
        delete *ppCompKey;
        *ppCompKey = NULL;
    }

    return hr;
}

/*
Routine Description: 

Name:

    CExtClassInstCookieList::CreateCompoundKeyString

Functionality:
    
    Given a compound key, the function creates a string version of the compound key
    and pass it back to the caller.

Virtual:
    
    No.
    
Arguments:

    pszCompKeyStr   - string version of the compound key

    ppCompKey       - out-bound compound key if the string can be successfully interpreted as
                      compound key

Return Value:

    Success: Any success code (use SUCCEEDED(hr) to test) indicates success.
    
    Failure: any failure code indicates failure.

Notes:
    (1) No thread safety. Caller must be aware.
    (2) As normal, caller is responsible to release *pbstrCompKey.

*/

HRESULT 
CExtClassInstCookieList::CreateCompoundKeyString (
    OUT BSTR* pbstrCompKey,
    IN const CCompoundKey* pKey
    )
{
    HRESULT hr = WBEM_NO_ERROR;

    if (pbstrCompKey == NULL)
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    //
    // if no names, or 0 names, or no compound key, then return Null_Key
    //

    else if (m_pVecNames == NULL || m_pVecNames->size() == 0 || pKey == NULL)
    {
        *pbstrCompKey = ::SysAllocString(pszNullKey);

        if (*pbstrCompKey == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        *pbstrCompKey = NULL;

        DWORD dwCount = m_pVecNames->size();

        //
        // Somehow, CComBSTR's += operator doesn't work inside loops for several
        // compilations!
        //

        CComBSTR *pbstrParts = new CComBSTR[dwCount];

        if (pbstrParts == NULL)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        DWORD dwTotalLen = 0;

        //
        // for each key property, we will format the (prop, value) pair
        // into prop<vt:value> format. All each individual prop<vt:value>
        // will be saved in our arrary for later assembling.
        //

        for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++)
        {
            //
            // don't move these CComXXX out of the loop unless you know precisely
            // what needs to be done for these ATL classes
            //

            CComVariant var;
            hr = pKey->GetPropertyValue(dwIndex, &var);

            if (FAILED(hr))
            {
                break;
            }

            CComBSTR bstrData;

            //
            // get the <vt:value> into bstrData
            //

            hr = ::FormatVariant(&var, &bstrData);

            if (SUCCEEDED(hr))
            {
                //
                // create the Name<vt:Value> formatted string
                //

                pbstrParts[dwIndex] = CComBSTR( (*m_pVecNames)[dwIndex] );
                pbstrParts[dwIndex] += bstrData;
            }
            else
            {
                break;
            }

            dwTotalLen += wcslen(pbstrParts[dwIndex]);
        }

        //
        // Do the final assembling - pack all the bstr's in pbstrParts into the 
        // out-bound parameter *pbstrCompKey
        //

        if (SUCCEEDED(hr) && hr != WBEM_S_FALSE)
        {
            *pbstrCompKey = ::SysAllocStringLen(NULL, dwTotalLen + 1);
            if (*pbstrCompKey != NULL)
            {
                //
                // current copying point
                //

                LPWSTR pszCur = *pbstrCompKey;
                DWORD dwLen;

                for (dwIndex = 0; dwIndex < dwCount; dwIndex++)
                {
                    dwLen = wcslen(pbstrParts[dwIndex]);
                    ::memcpy(pszCur, (const void*)(LPCWSTR)(pbstrParts[dwIndex]), dwLen * sizeof(WCHAR));
                    pszCur += dwLen;
                }

                //
                // 0 terminate it
                //

                (*pbstrCompKey)[dwTotalLen] = L'\0';
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }

        delete [] pbstrParts;
    }

    return hr;
}

/*
Routine Description: 

Name:

    CExtClassInstCookieList::Cleanup

Functionality:
    
    Cleanup. 

Virtual:
    
    No.
    
Arguments:

    none

Return Value:

    none

Notes:
    Since we want to clean up after some partial construction.

*/

void  
CExtClassInstCookieList::Cleanup ()
{
    //
    // all those heap CCompoundKey's are released here.
    //

    ExtClassCookieIterator it = m_mapCookies.begin();
    ExtClassCookieIterator itEnd = m_mapCookies.end();

    while(it != itEnd)
    {
        delete (*it).first;
        it++;
    }

    m_mapCookies.clear();

    //
    // m_vecCookies's content (CookieKeyPair) has a compound key,
    // but that memory is not managed by this vector, (released in the map cleanup above).
    //

    for (int i = 0; i < m_vecCookies.size(); i++)
    {
        delete m_vecCookies[i];
    }

    m_vecCookies.clear();

    m_dwMaxCookie = 0;
    m_dwCookieArrayCount = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\extbase.cpp ===
// extbase.cpp: implementation of the CEmbedForeignObj and CLinkForeignObj classes
//
// Copyright (c)1997-2001 Microsoft Corporation
//
// implement extension model's base classes
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "sceprov.h"
#include "extbase.h"

#include "persistmgr.h"
#include "requestobject.h"

//
// just some constants. Don't hardcode literals!
//

LPCWSTR pszMethodPrefix = L"Sce_";
LPCWSTR pszMethodPostfix = L"_Method";

LPCWSTR pszEquivalentPutInstance = L"Sce_MethodCall_PutInstance";
LPCWSTR pszEquivalentDelInstance = L"Sce_MethodCall_DelInstance";

LPCWSTR pszInParameterPrefix        = L"Sce_Param_";
LPCWSTR pszMemberParameterPrefix    = L"Sce_Member_";

LPCWSTR pszAreaAttachmentClasses    = L"Attachment Classes";

LPCWSTR pszForeignNamespace = L"ForeignNamespace";
LPCWSTR pszForeignClassName = L"ForeignClassName";

LPCWSTR pszDelInstance  = L"DelInstance";
LPCWSTR pszPutInstance  = L"PutInstance";
LPCWSTR pszPopInstance  = L"PopInstance";

//
// The method encoding string only contains PutInstance call
//

const DWORD SCE_METHOD_ENCODE_PUT_ONLY = 0x00000001;

//
// The method encoding string only contains DelInstance call
//

const DWORD SCE_METHOD_ENCODE_DEL_ONLY = 0x00000002;

//====================================================================

//
// implementation of CExtClasses
// there will be a shared (global) instance of this class. That is why
// we need protections against data by using a critical section.
//


/*
Routine Description: 

Name:

    CExtClasses::CExtClasses

Functionality:
    
    constructor.

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    none

Notes:

*/

CExtClasses::CExtClasses () 
    : 
    m_bPopulated(false)
{
}

/*
Routine Description: 

Name:

    CExtClasses::~CExtClasses

Functionality:
    
    Destructor. Cleaning up the map managed bstr names (first) and map managed
                CForeignClassInfo heap objects (second).

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    none

Notes:

*/

CExtClasses::~CExtClasses()
{
    ExtClassIterator it = m_mapExtClasses.begin();
    ExtClassIterator itEnd = m_mapExtClasses.end();

    while(it != itEnd)
    {
        //
        // first is a bstr
        //

        ::SysFreeString((*it).first);

        //
        // second is a CForeignClassInfo. It knows how to delete.
        //

        delete (*it).second;

        it++;
    }

    m_mapExtClasses.clear();
}

/*
Routine Description: 

Name:

    CExtClasses::PopulateExtensionClasses

Functionality:
    
    Gather information for all embedding classes.

Virtual:
    
    No.
    
Arguments:

    pNamespace  - The namespace.

    pCtx        - something that WMI passes around. WMI may require it in the future.

Return Value:

    Success : success code from CreateClassEnum.

    Failure: error code from CreateClassEnum.

Notes:
    This is private helper. Only called by our GetForeignClassInfo function if it
    finds that we haven't populated ourselves. Since thread protection is done
    over there, we don't do it here any more. don't make it available to other classes 
    unless you make necessary changes to protect the data.

*/

HRESULT 
CExtClasses::PopulateExtensionClasses (
    IN IWbemServices * pNamespace,
    IN IWbemContext  * pCtx
    )
{
    if (pNamespace == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_NO_ERROR;

    if (!m_bPopulated)
    {
        CComPtr<IEnumWbemClassObject> srpEnum;

        //
        // try to enumerate all embed classes
        //

        CComBSTR bstrEmbedSuperClass(SCEWMI_EMBED_BASE_CLASS);
        hr = pNamespace->CreateClassEnum(bstrEmbedSuperClass,
                                                 WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                                 pCtx,
                                                 &srpEnum
                                                 );
        
        if (SUCCEEDED(hr))
        {   
            //
            // irgnore the result. It may or may not have any extension
            //

            GetSubclasses(pNamespace, pCtx, srpEnum, EXT_CLASS_TYPE_EMBED);
        }

        // now, let's enumerate all link classes
        //srpEnum.Release();
        //CComBSTR bstrLinkSuperClass(SCEWMI_LINK_BASE_CLASS);
        //hr = pNamespace->CreateClassEnum(bstrLinkSuperClass,
        //                                WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
        //                                pCtx,
        //                                &srpEnum
        //                                );

        //if (SUCCEEDED(hr))
        //    GetSubclasses(pNamespace, pCtx, srpEnum, EXT_CLASS_TYPE_LINK);    //irgnore the result. It may or may not have any extension
        
        m_bPopulated = true;
    }

    return hr;
}

/*
Routine Description: 

Name:

    CExtClasses::PutExtendedClass

Functionality:
    
    Put a foreign class information and its embedding class name into our map.

Virtual:
    
    No.
    
Arguments:

    bstrEmbedClassName  - the embedding class's name.

    pFCI                - the foreign class info of the embedding class.

Return Value:

    Success : 
        (1) WBEM_NO_ERROR if the parameters are taken by the map. The map owns the resource.
        (2) WBEM_S_FALSE if the embed class name has already in the map. The map doesn't own the resource.

    Failure: WBEM_E_INVALID_PARAMETER.

Notes:
    (1) This is private helper.

    (2) Caller shouldn't delete the parameters in any fashion. Our map owns the resource
        that is passed into the function unless we return WBEM_S_FALSE.

    (3) Don't make it available to other classes  unless you make necessary changes
        for resource management.

*/

HRESULT 
CExtClasses::PutExtendedClass (
    IN BSTR                   bstrEmbedClassName,
    IN CForeignClassInfo    * pFCI
    )
{
    if (bstrEmbedClassName      == NULL     || 
        *bstrEmbedClassName     == L'\0'    || 
        pFCI                    == NULL     || 
        pFCI->bstrNamespace     == NULL     || 
        pFCI->bstrClassName     == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_NO_ERROR;

    g_CS.Enter();

    if (m_mapExtClasses.find(bstrEmbedClassName) == m_mapExtClasses.end())
    {
        m_mapExtClasses.insert(MapExtClasses::value_type(bstrEmbedClassName, pFCI));
    }
    else
    {
        hr = WBEM_S_FALSE;
    }

    g_CS.Leave();

    return hr;
}

/*
Routine Description: 

Name:

    CExtClasses::GetForeignClassInfo

Functionality:
    
    Return the requested embedding class's foreign class information.

Virtual:
    
    No.
    
Arguments:

    pNamespace  - The namespace.

    pCtx        - something that WMI passes around. WMI may require it in the future.

    bstrEmbedClassName  - the embedding class's name.

Return Value:

    Success : 
        Non Null.

    Failure: 
        NULL.

Notes:
    (1) Please respect the returned pointer. It's constant and caller is no business to change it
        or deleting it.

*/

const CForeignClassInfo * 
CExtClasses::GetForeignClassInfo (
    IN IWbemServices  * pNamespace,
    IN IWbemContext   * pCtx,
    IN BSTR             bstrEmbedClassName
    )
{

    //
    // if we haven't populated, we need to do it so. That is why
    // we need to protect from multi-threads.
    //

    g_CS.Enter();
    if (!m_bPopulated)
    {
        PopulateExtensionClasses(pNamespace, pCtx);
    }

    CForeignClassInfo* pInfo = NULL;

    ExtClassIterator it = m_mapExtClasses.find(bstrEmbedClassName);

    if (it != m_mapExtClasses.end())
    {
        pInfo = (*it).second;
    }

    g_CS.Leave();

    return pInfo;
}

/*
Routine Description: 

Name:

    CExtClasses::GetForeignClassInfo

Functionality:
    
    Return the requested embedding class's foreign class information.

Virtual:
    
    No.
    
Arguments:

    pNamespace  - The namespace.

    pCtx        - something that WMI passes around. WMI may require it in the future.

    pEnumObj    - class enumerator.

    dwClassType - what type of extension class. Currently, we only have one (embedding).
                  It is thus not used.

Return Value:

    Success : 
        Non Null.

    Failure: 
        NULL.

Notes:
    (1) Please respect the returned pointer. It's constant and caller is no business to change it
        or deleting it.

*/

HRESULT 
CExtClasses::GetSubclasses (
    IN IWbemServices        * pNamespace,
    IN IWbemContext         * pCtx,
    IN IEnumWbemClassObject * pEnumObj,
    IN EnumExtClassType       dwClassType
    )
{
    ULONG nEnum = 0;

    HRESULT hr = WBEM_NO_ERROR;

    //
    // CScePropertyMgr helps us to access WMI object's properties.
    //

    CScePropertyMgr ScePropMgr;

    //
    // as long as we continue to discover more classes, keep looping.
    //

    while (true)
    {
        CComPtr<IWbemClassObject> srpObj;

        hr = pEnumObj->Next(WBEM_INFINITE, 1, &srpObj, &nEnum);

        //
        // either not found or some other errors. Stop the enumeration.
        //

        if (FAILED(hr) || srpObj == NULL)
        {
            break;
        }

        if (SUCCEEDED(hr) && nEnum > 0 )
        {
            VARIANT varClass;
            hr = srpObj->Get(L"__CLASS", 0, &varClass, NULL, NULL);

            if (SUCCEEDED(hr) && varClass.vt == VT_BSTR)
            {
                //
                // attach a different the WMI object to the property mgr.
                // This will always succeed.
                //

                ScePropMgr.Attach(srpObj);

                //
                // get the foreign namespace property and foreign class name property.
                // Both are critical.
                //
                
                CComBSTR bstrNamespace, bstrClassName;

                hr = ScePropMgr.GetProperty(pszForeignNamespace, &bstrNamespace);
                if (SUCCEEDED(hr))
                {
                    hr = ScePropMgr.GetProperty(pszForeignClassName, &bstrClassName);
                }

                if (SUCCEEDED(hr))
                {

                    //
                    // we are ready to create the foreign class info
                    //

                    CForeignClassInfo *pNewSubclass = new CForeignClassInfo;

                    if (pNewSubclass != NULL)
                    {
                        //
                        // give the foreign class info namespace and class name bstrs
                        //

                        pNewSubclass->bstrNamespace = bstrNamespace.Detach();
                        pNewSubclass->bstrClassName = bstrClassName.Detach();

                        pNewSubclass->dwClassType = dwClassType;

                        //
                        // we need to know the key property names
                        //

                        hr = PopulateKeyPropertyNames(pNamespace, pCtx, varClass.bstrVal, pNewSubclass);

                        if (SUCCEEDED(hr))
                        {
                            //
                            // let the map owns everything
                            //

                            hr = PutExtendedClass(varClass.bstrVal, pNewSubclass);
                        }

                        if (WBEM_NO_ERROR == hr)
                        {
                            //
                            // ownership taken
                            //

                            varClass.vt = VT_EMPTY;
                            varClass.bstrVal = NULL;
                            pNewSubclass = NULL;

                        }
                        else
                        {
                            ::VariantClear(&varClass);
                            delete pNewSubclass;
                        }
                    }
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                        break;
                    }
                }
                else
                {
                    //
                    // somehow, can't get the class name or namespace, something is wrong with this class
                    // but will try to continue for other classes?
                    //

                    ::VariantClear(&varClass);
                }
            }
        }
    }

    return hr;
}


/*
Routine Description: 

Name:

    CExtClasses::PopulateKeyPropertyNames

Functionality:
    
    Private helper. Will create the new CForeignClassInfo's key
    property name vector. 
Virtual:
    
    No.
    
Arguments:

    pNamespace      - The namespace.

    pCtx            - something that WMI passes around. WMI may require it in the future.

    bstrClassName   - class name.

    pNewSubclass    - The new foreign class info object. Its m_pVecNames member must be NULL
                      entering this function.

Return Value:

    Success : WBEM_NO_ERROR.

    Failure: various error codes.

Notes:

*/

HRESULT 
CExtClasses::PopulateKeyPropertyNames (
    IN IWbemServices            * pNamespace,
    IN IWbemContext             * pCtx,
    IN BSTR                       bstrClassName,
    IN OUT CForeignClassInfo    * pNewSubclass
    )
{
    if (pNamespace                          == NULL || 
        pNewSubclass                        == NULL || 
        pNewSubclass->m_pVecKeyPropNames    != NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // get the class definition.
    //

    CComPtr<IWbemClassObject> srpObj;
    HRESULT hr = pNamespace->GetObject(bstrClassName, 0, pCtx, &srpObj, NULL);

    if (SUCCEEDED(hr))
    {
        //
        // create the key property names vector
        //

        pNewSubclass->m_pVecKeyPropNames = new std::vector<BSTR>;

        if (pNewSubclass->m_pVecKeyPropNames != NULL)
        {
            //
            // flag to indicate if there is any key properties
            //

            bool bHasKeyProperty = false;

            //
            // let's get the key properties. WBEM_FLAG_LOCAL_ONLY flag
            // indicates that we are not interested in base class's members.
            // Base class members are for embedding only and we know those.
            //

            hr = srpObj->BeginEnumeration(WBEM_FLAG_KEYS_ONLY | WBEM_FLAG_LOCAL_ONLY);

            while (SUCCEEDED(hr))
            {
                CComBSTR bstrName;
                hr = srpObj->Next(0, &bstrName, NULL, NULL, NULL);
                if (FAILED(hr) || WBEM_S_NO_MORE_DATA == hr)
                {
                    break;
                }

                //
                // let the m_pVecKeyPropNames own the bstr.
                //

                pNewSubclass->m_pVecKeyPropNames->push_back(bstrName.Detach());

                bHasKeyProperty = true;
            }

            srpObj->EndEnumeration();

            //
            // don't find any key property name, ask it clean up the m_pVecKeyPropNames member.
            //

            if (!bHasKeyProperty)
            {
                pNewSubclass->CleanNames();
            }
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = WBEM_NO_ERROR;
    }

    return hr;
}



//===================================================================
//******** implementation of CSceExtBaseObject************************


/*
Routine Description: 

Name:

    CSceExtBaseObject::CSceExtBaseObject

Functionality:
    
    Constructor

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    None.

Notes:

*/

CSceExtBaseObject::CSceExtBaseObject () 
    : 
    m_pClsInfo(NULL)
{
}


/*
Routine Description: 

Name:

    CSceExtBaseObject::~CSceExtBaseObject

Functionality:
    
    Destructor. Do a clean up.

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    None.

Notes:
    Consider moving your extra clean up work in CleanUp function.

*/
    
CSceExtBaseObject::~CSceExtBaseObject ()
{
    CleanUp();
}


/*
Routine Description: 

Name:

    CSceExtBaseObject::GetPersistPath

Functionality:
    
    Return the store path of the embedding object.

Virtual:
    
    Yes.
    
Arguments:

    pbstrPath   - Receives the store path.

Return Value:

    Success:
        success codes.

    Failure:
        (1) E_UNEXPECTED if this object has no wbem object attached to it successfully.
        (2) WBEM_E_NOT_AVAILABLE if the store path can't be returned.
        (3) Other errors.

Notes:

*/

STDMETHODIMP 
CSceExtBaseObject::GetPersistPath (
    OUT BSTR* pbstrPath
    )
{
    if (pbstrPath == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_E_NOT_FOUND;

    if (m_srpWbemObject)
    {
        CComVariant varVal;
        hr = m_srpWbemObject->Get(pStorePath, 0, &varVal, NULL, NULL);

        if (SUCCEEDED(hr) && varVal.vt == VT_BSTR)
        {
            *pbstrPath = varVal.bstrVal;

            varVal.vt = VT_EMPTY;
            varVal.bstrVal = 0;
        }
        else
        {
            hr = WBEM_E_NOT_AVAILABLE;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}



/*
Routine Description: 

Name:

    CSceExtBaseObject::GetPersistPath

Functionality:
    
    Return the embedding class name.

Virtual:
    
    Yes.
    
Arguments:

    pbstrClassName  - Receive the embedding class name.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:
        (1) WBEM_E_NOT_AVAILABLE if the store path can't be returned.
        (2) Other errors.

Notes:

*/

STDMETHODIMP 
CSceExtBaseObject::GetClassName (
    OUT BSTR* pbstrClassName
    )
{
    if (pbstrClassName == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pbstrClassName = NULL;

    if ((LPCWSTR)m_bstrClassName != NULL)
    {
        *pbstrClassName = ::SysAllocString(m_bstrClassName);
    }
    else
    {
        return WBEM_E_NOT_AVAILABLE;
    }

    return (*pbstrClassName == NULL) ? WBEM_E_OUT_OF_MEMORY : WBEM_NO_ERROR;
}



/*
Routine Description: 

Name:

    CSceExtBaseObject::GetLogPath

Functionality:
    
    Return the log file path.

Virtual:
    
    Yes.
    
Arguments:

    pbstrClassName  - Receive the embedding class name.

Return Value:

    Success:

        WBEM_NO_ERROR.

    Failure:
        (1) WBEM_E_NOT_AVAILABLE if the store path can't be returned.
        (2) Other errors.

Notes:

*/

STDMETHODIMP 
CSceExtBaseObject::GetLogPath (
    OUT BSTR* pbstrPath
    )
{
    if (pbstrPath == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    if ((LPCWSTR)m_bstrLogPath != NULL)
    {
        *pbstrPath = ::SysAllocString(m_bstrLogPath);
    }
    else
    {
        return WBEM_E_NOT_AVAILABLE;
    }

    return (*pbstrPath == NULL) ? WBEM_E_OUT_OF_MEMORY : WBEM_NO_ERROR;
}



/*
Routine Description: 

Name:

    CSceExtBaseObject::Validate

Functionality:
    
    Validate the object. Currently, there is no validation. This can change at any time.
    For example, if we decide to use XML, we might be able to validate using the DTD.

Virtual:
    
    Yes.
    
Arguments:

    None.

Return Value:

    Success:

        WBEM_NO_ERROR.

Notes:

*/

STDMETHODIMP 
CSceExtBaseObject::Validate ()
{
    return WBEM_NO_ERROR;
}



/*
Routine Description: 

Name:

    CSceExtBaseObject::GetProperty

Functionality:
    
    Return the given property's value.

Virtual:
    
    Yes.
    
Arguments:

    pszPropName - Name of the property.

    pValue      - Receives teh value in variant type.

Return Value:

    Success:

        Various success codes.

    Failure:
        various errors.

Notes:

*/

STDMETHODIMP 
CSceExtBaseObject::GetProperty (
    IN LPCWSTR    pszPropName,
    OUT VARIANT * pValue
    )
{
    if (pszPropName == NULL || *pszPropName == L'\0' || pValue == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // we use index to access the property values.
    // Try keys first.
    //

    int iIndex = GetIndex(pszPropName, GIF_Keys);
    HRESULT hr = WBEM_E_NOT_FOUND;

    if (iIndex >= 0)
    {
        hr = ::VariantCopy(pValue, m_vecKeyValues[iIndex]);
    }
    else
    {
        //
        // it doesn't recognize as a key, so, try it as non-key property
        //

        iIndex = GetIndex(pszPropName, GIF_NonKeys);

        if (iIndex >= 0 && m_vecPropValues[iIndex] && m_vecPropValues[iIndex]->vt != VT_NULL)
        {
            hr = ::VariantCopy(pValue, m_vecPropValues[iIndex]);
        }
        else if (m_srpWbemObject)
        {
            hr = m_srpWbemObject->Get(pszPropName, 0, pValue, NULL, NULL);
        }
    }

    return hr;
}



/*
Routine Description: 

Name:

    CSceExtBaseObject::GetProperty

Functionality:
    
    Return the given type property count of the embedding class.

Virtual:
    
    Yes.
    
Arguments:

    type    - Type of the property.

    pCount  - Receives the given type property count.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        WBEM_E_INVALID_PARAMETER

Notes:

*/

STDMETHODIMP 
CSceExtBaseObject::GetPropertyCount (
    IN SceObjectPropertyType    type,
    OUT DWORD                 * pCount
    )
{
    if (type == SceProperty_Invalid || pCount == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pCount = 0;

    if (type == SceProperty_Key)
    {
        *pCount = (DWORD)m_vecKeyProps.size();
    }
    else
    {
        *pCount =  (DWORD)m_vecNonKeyProps.size();
    }

    return WBEM_NO_ERROR;
}



/*
Routine Description: 

Name:

    CSceExtBaseObject::GetPropertyValue

Functionality:
    
    Return the given property's name and, if requested, also its value.

Virtual:
    
    Yes.
    
Arguments:

    type            - Type of the property.

    dwIndex         - Receives the given type property count.

    pbstrPropName   - The property's name.

    pValue          - Receives the property's value in variant. It the caller is not interested
                      in receive the value, it can pass in NULL.

Return Value:

    Success:

        WBEM_NO_ERROR if everything is retrieved correctly.
        WBEM_S_FALSE  if the property value can't be retrieved.

    Failure:

        various error codes.

Notes:
    If you request value (pValue != NULL) and we can't find it for you, then we won't supply
    the name either.

    But if you only request the name, as long as the index is correct (and has memory), we will
    give it back, regardless the value.

*/

STDMETHODIMP 
CSceExtBaseObject::GetPropertyValue (
    IN SceObjectPropertyType  type,
    IN DWORD                  dwIndex,
    OUT BSTR                * pbstrPropName,
    OUT VARIANT             * pValue         OPTIONAL
    )
{
    if (type == SceProperty_Invalid || pbstrPropName == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pbstrPropName = NULL;

    if (pValue)
    {
        ::VariantInit(pValue);
    }

    HRESULT hr = WBEM_NO_ERROR;
    CComBSTR bstrName;

    //
    // if it is asking for key property info
    //

    if (type == SceProperty_Key)
    {
        if (dwIndex >= m_vecKeyValues.size())
        {
            return WBEM_E_VALUE_OUT_OF_RANGE;
        }
        else
        {
            //
            // this is the name
            //

            bstrName = m_vecKeyProps[dwIndex];

            //
            // has a valid name
            //

            if (bstrName.Length() > 0)
            {
                //
                // only tried to supply the value if requested
                //

                if (pValue)
                {
                    //
                    // has value in its array. Any recently updated values will stay
                    // in the array.
                    //

                    if (m_vecKeyValues[dwIndex])
                    {
                        hr = ::VariantCopy(pValue, m_vecKeyValues[dwIndex]);
                    }
                    else if (m_srpWbemObject)
                    {
                        //
                        // otherwise, the value has not been updated, so
                        // go ask the object itself
                        //

                        hr = m_srpWbemObject->Get(bstrName, 0, pValue, NULL, NULL);
                    }

                    if (pValue->vt == VT_NULL || pValue->vt == VT_EMPTY)
                    {
                        //
                        // if the object doesn't have that value, try the key chain
                        //

                        hr = m_srpKeyChain->GetKeyPropertyValue(bstrName, pValue);

                        //
                        // m_srpKeyChain->GetKeyPropertyValue returns WBEM_S_FALSE if it can't be found
                        //
                    }
                }
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }
    }
    else if (type == SceProperty_NonKey)
    {
        //
        // it is requesting non-key value
        //

        if (dwIndex >= m_vecPropValues.size())
        {
            return WBEM_E_VALUE_OUT_OF_RANGE;
        }
        else
        {
            //
            // this is the name
            //

            bstrName = m_vecNonKeyProps[dwIndex];

            if (bstrName.Length() > 0)
            {
                //
                // only tried to supply the value if requested
                //

                if (pValue)
                {
                    //
                    // has value in its array. Any recently updated values will stay
                    // in the array.
                    //

                    if (m_vecPropValues[dwIndex])
                    {
                        hr = ::VariantCopy(pValue, m_vecPropValues[dwIndex]);
                    }
                    else if (m_srpWbemObject)
                    {
                        //
                        // otherwise, the value has not been updated, so
                        // go ask the object itself
                        //

                        hr = m_srpWbemObject->Get(bstrName, 0, pValue, NULL, NULL);
                    }
                }
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    if (SUCCEEDED(hr))
    {
        //
        // we give the name only if we have successfully grabbed the value (when requested).
        //

        *pbstrPropName = bstrName.Detach();

        hr = WBEM_NO_ERROR;

    }

    return hr;
}



/*
Routine Description: 

Name:

    CSceExtBaseObject::Attach

Functionality:
    
    Attach a wbem object to this object.

Virtual:
    
    Yes.
    
Arguments:

    pInst   - the wbem object to be attached.

Return Value:

    Success:

        WBEM_NO_ERROR

    Failure:

        WBEM_E_INVALID_PARAMETER.

Notes:
    You can call this repeatedly. However, passing a different kind of class object
    will lead to undefined behavior because all property names are not updated here.

*/

STDMETHODIMP 
CSceExtBaseObject::Attach (
    IN IWbemClassObject * pInst
    )
{
    if (pInst == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // this opertor::= will release the previous object and assign the new one.
    // all ref count is donw automatically
    //

    m_srpWbemObject = pInst;
    return WBEM_NO_ERROR;
}



/*
Routine Description: 

Name:

    CSceExtBaseObject::GetClassObject

Functionality:
    
    Attach a wbem object to this object.

Virtual:
    
    Yes.
    
Arguments:

    ppInst   - Receives the attached wbem object.

Return Value:

    Success:

        S_OK

    Failure:

        (1) E_UNEXPECTED if no attachment has succeeded.

Notes:
    Be aware, don't blindly simplify 

            m_srpWbemObject->QueryInterface(...);

     to assignment:

            *ppInst = m_srpWbemObject;

    Two reasons:

    (1) We may change what is being cached to something else in the future.
    (2) Out-bound interface pointer must be AddRef'ed.

*/

STDMETHODIMP 
CSceExtBaseObject::GetClassObject (
    OUT IWbemClassObject    ** ppInst
    )
{
    if (m_srpWbemObject == NULL)
    {
        return E_UNEXPECTED;
    }
    else
    {
        return m_srpWbemObject->QueryInterface(IID_IWbemClassObject, (void**)ppInst);
    }
}



/*
Routine Description: 

Name:

    CSceExtBaseObject::CleanUp

Functionality:
    
    Clean up itself.

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    None

Notes:
    
    (1) Make sure that you empty the vectors! Cleanup its contents is not enough because
        this function may be called elsewhere. 

*/

void CSceExtBaseObject::CleanUp()
{
    //
    // m_vecKeyProps and m_vecNonKeyProps just keeps bstrs
    //

    std::vector<BSTR>::iterator itBSTR;
    for (itBSTR = m_vecKeyProps.begin(); itBSTR != m_vecKeyProps.end(); itBSTR++)
    {
        ::SysFreeString(*itBSTR);
    }
    m_vecKeyProps.empty();

    for (itBSTR = m_vecNonKeyProps.begin(); itBSTR != m_vecNonKeyProps.end(); itBSTR++)
    {
        ::SysFreeString(*itBSTR);
    }
    m_vecNonKeyProps.empty();

    //
    // m_vecKeyValues and m_vecPropValues just keeps variant pointers.
    // So, you need to clear the variant, and delete the pointers.
    //

    std::vector<VARIANT*>::iterator itVar;
    for (itVar = m_vecKeyValues.begin(); itVar != m_vecKeyValues.end(); itVar++)
    {
        if (*itVar != NULL)
        {
            ::VariantClear(*itVar);
            delete (*itVar);
        }
    }
    m_vecKeyValues.empty();

    for (itVar = m_vecPropValues.begin(); itVar != m_vecPropValues.end(); itVar++)
    {
        if (*itVar != NULL)
        {
            ::VariantClear(*itVar);
            delete (*itVar);
        }
    }
    m_vecPropValues.empty();
}



/*
Routine Description: 

Name:

    CSceExtBaseObject::PopulateProperties

Functionality:
    
    This function is what populates our vectors. We discover the key properties
    and non-key properties at this stage.
    
    Will use the key chain to populate the key properties. 
    
    But we will also set the non-key properties to empty values.

Virtual:
    
    No.
    
Arguments:

    pKeyChain   - The key chain that contains the key information.

    pNamespace  - the namespace.

    pCtx        - the context pointer passing around for WMI API's.

    pClsInfo    - The foreign class info.

Return Value:

    Success:

        various success codes.

    Failure:

        various error codes.

Notes:

*/

HRESULT 
CSceExtBaseObject::PopulateProperties (
    IN ISceKeyChain             * pKeyChain, 
    IN IWbemServices            * pNamespace, 
    IN IWbemContext             * pCtx,
    IN const CForeignClassInfo  * pClsInfo
    )
{
    //
    // cache these critical information for later use.
    //

    m_srpKeyChain   = pKeyChain; 
    m_srpNamespace  = pNamespace; 
    m_srpCtx        = pCtx;
    m_pClsInfo      = pClsInfo;

    //
    // get the class's defintion
    //

    //
    // clean up the stale pointer
    //

    m_srpWbemObject.Release();

    m_bstrClassName.Empty();
    HRESULT hr = m_srpKeyChain->GetClassName(&m_bstrClassName);

    if (SUCCEEDED(hr))
    {
        hr = m_srpNamespace->GetObject(m_bstrClassName, 0, m_srpCtx, &m_srpWbemObject, NULL);

        if (SUCCEEDED(hr))
        {
            //
            // let's get the key properties.
            // WBEM_FLAG_LOCAL_ONLY means that we don't care about base class members.
            //

            hr = m_srpWbemObject->BeginEnumeration(WBEM_FLAG_KEYS_ONLY | WBEM_FLAG_LOCAL_ONLY);

            while (SUCCEEDED(hr))
            {

                //
                // get the current key property name
                //

                CComBSTR bstrName;
                hr = m_srpWbemObject->Next(0, &bstrName, NULL, NULL, NULL);
                if (FAILED(hr) || WBEM_S_NO_MORE_DATA == hr)
                {
                    break;
                }

                //
                // prevent duplication. Push the newly discovered key to the vectors.
                // We won't pull down the values.
                //

                if (GetIndex(bstrName, GIF_Keys) < 0)
                {
                    m_vecKeyProps.push_back(bstrName.Detach());
                    m_vecKeyValues.push_back(NULL);
                }
            }

            m_srpWbemObject->EndEnumeration();

            if (FAILED(hr))
            {
                return hr;
            }

            //
            // now get non-key properties. The absence of WBEM_FLAG_KEYS_ONLY means non-key.
            // WBEM_FLAG_LOCAL_ONLY means that we don't care about base class members.
            //

            hr = m_srpWbemObject->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY);
            while (SUCCEEDED(hr) && WBEM_S_NO_MORE_DATA != hr)
            {
                //
                // get the current non-key property name
                //

                CComBSTR bstrName;
                hr = m_srpWbemObject->Next(0, &bstrName, NULL, NULL, NULL);
                if (FAILED(hr) || WBEM_S_NO_MORE_DATA == hr)
                {
                    break;
                }

                //
                // prevent duplicate the non-key properties
                // We won't pull down the values.
                //

                if (GetIndex(bstrName, GIF_Both) < 0)
                {
                    m_vecNonKeyProps.push_back(bstrName.Detach());
                    m_vecPropValues.push_back(NULL);
                }
            }

            m_srpWbemObject->EndEnumeration();
        }
    }

    return hr;
}



/*
Routine Description: 

Name:

    CSceExtBaseObject::GetIndex

Functionality:
    
    Get the index of the property.

Virtual:
    
    No.
    
Arguments:

    pszPropName - The property's name.

    fKey        - Flag for get index. You can OR the flags (GIF_Both) for looking
                  up in both key and non-key names.

Return Value:

    Success:

        index of the property.

    Failure:

        -1 if not found.

Notes:
    
    $consider: We should consider using maps for quick lookup.

*/

int 
CSceExtBaseObject::GetIndex (
    IN LPCWSTR       pszPropName,
    IN GetIndexFlags fKey
    )
{
    if (pszPropName == NULL || *pszPropName == L'\0')
    {
        return -1;
    }

    std::vector<BSTR>::iterator it;
    int iIndex = 0;

    if (fKey & GIF_Keys)
    {
        for (it = m_vecKeyProps.begin(); it != m_vecKeyProps.end(); it++, iIndex++)
        {
            if (_wcsicmp(*it, pszPropName) == 0)
            {
                return iIndex;
            }
        }
    }

    if (fKey & GIF_NonKeys)
    {
        for (it = m_vecNonKeyProps.begin(); it != m_vecNonKeyProps.end(); it++, iIndex++)
        {
            if (_wcsicmp(*it, pszPropName) == 0)
            {
                return iIndex;
            }
        }
    }

    return -1;
}


//=============================================================================
//******** implementation of CEmbedForeignObj**********************************
// this class implements the embedding model for SCE provider. A foreign
// object can be embedded into SCE namespace by declaring a class derived from
// Sce_EmbedFO (embed foreign object) in a MOF file. This design allows post
// release integration of foreign objects into SCE namespace.
//=============================================================================




/*
Routine Description: 

Name:

    CEmbedForeignObj::CEmbedForeignObj

Functionality:
    
    Constructor. Passing the parameters to base constructor, plus initializing
    the foreign class info pointer.

Virtual:
    
    No.
    
Arguments:

    pKeyChain   - The key chain.

    pNamespace  - Namespace

    pCtx        - The context pointer passing around for WMI API's.

    pClsInfo    - The foreign class info.

Return Value:

    None.

Notes:

*/

CEmbedForeignObj::CEmbedForeignObj (
    IN ISceKeyChain             * pKeyChain, 
    IN IWbemServices            * pNamespace,
    IN IWbemContext             * pCtx,
    IN const CForeignClassInfo  * pClsInfo
    )
    : 
    CGenericClass(pKeyChain, pNamespace, pCtx), 
    m_pClsInfo(pClsInfo)
{
}



/*
Routine Description: 

Name:

    CEmbedForeignObj::~CEmbedForeignObj

Functionality:
    
    Destructor. Clean up.

Virtual:
    
    Yes.
    
Arguments:

    None.

Return Value:

    None.

Notes:

*/

CEmbedForeignObj::~CEmbedForeignObj ()
{
    CleanUp();
}



/*
Routine Description: 

Name:

    CEmbedForeignObj::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_EmbedFO's subclasses,
    which is persistence oriented, this will cause the embedding class object's properties 
    to be saved in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst       - COM interface pointer to the WMI class (Sce_PasswordPolicy) object.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:

*/

HRESULT 
CEmbedForeignObj::PutInst (
    IN IWbemClassObject * pInst, 
    IN IWbemObjectSink  * pHandler,
    IN IWbemContext     * pCtx
    )
{
    //
    // Look how trivial it is for us to save!
    //

    CComPtr<IScePersistMgr> srpScePersistMgr;
    HRESULT hr = CreateScePersistMgr(pInst, &srpScePersistMgr);

    if (SUCCEEDED(hr))
    {
        hr = srpScePersistMgr->Save();
    }

    return hr;
}


/*
Routine Description: 

Name:

    CEmbedForeignObj::CreateObject

Functionality:
    
    Create WMI objects representing embedding classes (subclass of Sce_EmbedFO). 
    Depending on parameter atAction, this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT 
CEmbedForeignObj::CreateObject (
    IN IWbemObjectSink * pHandler, 
    IN ACTIONTYPE        atAction
    )
{
    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Delete a single instance ACTIONTYPE_DELETE
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET     != atAction &&
         ACTIONTYPE_DELETE  != atAction &&
         ACTIONTYPE_QUERY   != atAction ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    //
    // We must have the pStorePath property because that is where
    // our instance is stored. 
    // m_srpKeyChain->GetKeyPropertyValue WBEM_S_FALSE if the key is not recognized
    // So, we need to test against WBEM_S_FALSE if the property is mandatory
    //

    CComVariant varPath;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(pStorePath, &varPath);

    if (FAILED(hr))
    {
        return hr;
    }
    else if (WBEM_S_FALSE == hr)
    {
        return WBEM_E_NOT_AVAILABLE;
    }

    //
    // Now, this is embedding class loading. 
    // We let our persistence manager handle everything.
    //

    CComPtr<IScePersistMgr> srpScePersistMgr;
    hr = CreateScePersistMgr(NULL, &srpScePersistMgr);

    if (SUCCEEDED(hr))
    {
        if (atAction == ACTIONTYPE_GET || atAction == ACTIONTYPE_QUERY)
        {
            hr = srpScePersistMgr->Load(varPath.bstrVal, pHandler);
        }
        else if (atAction == ACTIONTYPE_DELETE)
        {
            hr = srpScePersistMgr->Delete(varPath.bstrVal, pHandler);
        }
    }

    return hr;
}


/*
Routine Description: 

Name:

    CEmbedForeignObj::ExecMethod

Functionality:
    
    This is perhaps the most important function. It executes a method on a foreign class/object.

    Our embedding model is to allow us to persist foreign class information in our store. This
    function is to use that stored information and goes to execute a method on the foreign class/object.

    Each embedding class has a method encoding string. That string encodes the information as what we
    should do on the foreign class/object when the embedding object is asked to execute a particular method.

    The heavy duty work is done in CExtClassMethodCaller::ExecuteForeignMethod function.

Virtual:
    
    Yes.
    
Arguments:

    bstrPath    - Template's path (file name).

    bstrMethod  - method's name.

    bIsInstance - if this is an instance, should always be false.

    pInParams   - Input parameter from WMI to the method execution.

    pHandler    - sink that informs WMI of execution results.

    pCtx        - the usual context that passes around to make WMI happy.

Return Value:

    Success: many different success code (use SUCCEEDED(hr) to test)

    Failure: various errors code.

Notes:
    Consider logging your result if you need to add more functionality.

*/
    
HRESULT 
CEmbedForeignObj::ExecMethod (
    IN BSTR                 bstrPath,
    IN BSTR                 bstrMethod,
    IN bool                 bIsInstance,
    IN IWbemClassObject   * pInParams,
    IN IWbemObjectSink    * pHandler,
    IN IWbemContext       * pCtx
    )
{
    //
    // this ISceClassObject provides us the access to the embeded class
    //

    CComPtr<ISceClassObject> srpSceObj;
    HRESULT hr = CreateBaseObject(&srpSceObj);

    if (SUCCEEDED(hr))
    {
        //
        // get the object
        //

        CComPtr<IWbemClassObject> srpInst;
        hr = m_srpNamespace->GetObject(bstrPath, 0, pCtx, &srpInst, NULL);

        if (SUCCEEDED(hr))
        {
            srpSceObj->Attach(srpInst);

            //
            // we will use CExtClassMethodCaller to help us
            //

            CExtClassMethodCaller clsMethodCaller(srpSceObj, m_pClsInfo);

            //
            // CExtClassMethodCaller needs a result logging object 
            //

            CMethodResultRecorder clsResLog;

            //
            // result log needs class name and log path. Don't let go these two variables
            // since CMethodResultRecorder don't cache them
            //

            CComBSTR bstrClassName;
            hr = m_srpKeyChain->GetClassName(&bstrClassName);
            if (FAILED(hr))
            {
                return hr;  // can't even log
            }

            // find the LogFilePath [in] parameter
            CComVariant varVal;
            hr = pInParams->Get(pLogFilePath, 0, &varVal, NULL, NULL);

            //
            // initialize the CMethodResultRecorder object
            //

            if (SUCCEEDED(hr) && varVal.vt == VT_BSTR && varVal.bstrVal)
            {
                hr = clsResLog.Initialize(varVal.bstrVal, bstrClassName, m_srpNamespace, pCtx);
            }
            else
            {
                //
                // no LogFilePath, we will log it, but allow the method execution to continue
                // because the logging will go to the default log file.
                //

                hr = clsResLog.Initialize(NULL, bstrClassName, m_srpNamespace, pCtx);
                HRESULT hrLog = clsResLog.LogResult(WBEM_E_INVALID_PARAMETER, NULL, pInParams, NULL, bstrMethod, L"GetLogFilePath", IDS_GET_LOGFILEPATH, NULL);
                if (FAILED(hrLog))
                {
                    hr = hrLog;
                }
            }

            //
            // set up the CExtClassMethodCaller object
            //

            hr = clsMethodCaller.Initialize(&clsResLog);

            if (SUCCEEDED(hr))
            {
                //
                // now, call the method!
                //

                CComPtr<IWbemClassObject> srpOut;
                hr = clsMethodCaller.ExecuteForeignMethod(bstrMethod, pInParams, pHandler, pCtx, &srpOut);

                //
                // let's allow verbose logging to log the embedded object. Will ignore the return result
                //

                clsResLog.LogResult(hr, srpInst, NULL, NULL, bstrMethod, L"ExecutedForeignMethods", IDS_EXE_FOREIGN_METHOD, NULL);
            }
        }
    }

    return hr;
}



/*
Routine Description: 

Name:

    CEmbedForeignObj::CreateBaseObject

Functionality:
    
    Private helper to create the ISceClassObject object to represent ourselves in front
    of CScePersistMgr.

Virtual:
    
    No.
    
Arguments:

    ppObj    - receives the ISceClassObject on behalf of this embedding class.

Return Value:

    Success: many different success code (use SUCCEEDED(hr) to test)

    Failure: various errors code.

Notes:

*/

HRESULT 
CEmbedForeignObj::CreateBaseObject (
    OUT ISceClassObject ** ppObj
    )
{
    CComObject<CSceExtBaseObject> *pExtBaseObj = NULL;
    HRESULT hr = CComObject<CSceExtBaseObject>::CreateInstance(&pExtBaseObj);

    if (SUCCEEDED(hr))
    {
        //
        // if you wonder why we need this pair of AddRef and Release (just several lines below),
        // just remember this rule: you can't use a CComObject<xxx> until you have AddRef'ed.
        // Of course, this AddRef must have a matching Release.
        //

        pExtBaseObj->AddRef();

        //
        // This populates the object
        //

        hr = pExtBaseObj->PopulateProperties(m_srpKeyChain, m_srpNamespace, m_srpCtx, m_pClsInfo);
        if (SUCCEEDED(hr))
        {
            hr = pExtBaseObj->QueryInterface(IID_ISceClassObject, (void**)ppObj);
        }

        pExtBaseObj->Release();
    }
    return hr;
}



/*
Routine Description: 

Name:

    CEmbedForeignObj::CreateScePersistMgr

Functionality:
    
    Private helper to create the CScePersistMgr.

Virtual:
    
    No.
    
Arguments:

    pInst           - The ultimate wbem object this CScePersistMgr will represent. In this impelmentation
                      this is what our ISceClassObject object will attach to.

    ppPersistMgr    - Receives the CScePersistMgr object.

Return Value:

    Success: many different success code (use SUCCEEDED(hr) to test)

    Failure: various errors code.

Notes:

*/

HRESULT 
CEmbedForeignObj::CreateScePersistMgr (
    IN IWbemClassObject *  pInst,
    OUT IScePersistMgr  ** ppPersistMgr
    )
{
    //
    // create a ISceClassObject that the CScePersistMgr object needs
    //

    CComPtr<ISceClassObject> srpSceObj;
    HRESULT hr = CreateBaseObject(&srpSceObj);

    if (SUCCEEDED(hr))
    {
        if (pInst)
        {
            srpSceObj->Attach(pInst);
        }

        CComPtr<IScePersistMgr> srpScePersistMgr;

        //
        // now, create the CScePersistMgr object.
        //

        CComObject<CScePersistMgr> *pMgr = NULL;
        hr = CComObject<CScePersistMgr>::CreateInstance(&pMgr);

        if (SUCCEEDED(hr))
        {
            pMgr->AddRef();
            hr = pMgr->QueryInterface(IID_IScePersistMgr, (void**)&srpScePersistMgr);
            pMgr->Release();

            if (SUCCEEDED(hr))
            {
                //
                // this IScePersistMgr is for our newly created ISceClassObject
                //

                hr = srpScePersistMgr->Attach(IID_ISceClassObject, srpSceObj);

                if (SUCCEEDED(hr))
                {
                    //
                    // everything is fine. Hand it over the the out-bound parameter.
                    // This detach effectively transfers the srpScePersistMgr AddRef'ed
                    // interface pointer to the receiving *ppPersistMgr.
                    //

                    *ppPersistMgr = srpScePersistMgr.Detach();
                }
            }
        }
    }

    return hr;
}


//===========================================================================
// CExtClassMethodCaller implementation
//===========================================================================



/*
Routine Description: 

Name:

    CExtClassMethodCaller::CExtClassMethodCaller

Functionality:
    
    Constructor.

Virtual:
    
    No.
    
Arguments:

    pSceObj     - Our custom object for each embedding class.

    pClsInfo    - The foreign class info.

Return Value:

    None.

Notes:

*/

CExtClassMethodCaller::CExtClassMethodCaller (
    ISceClassObject         * pSceObj,
    const CForeignClassInfo * pClsInfo
    ) 
    : 
    m_srpSceObject(pSceObj), 
    m_pClsInfo(pClsInfo), 
    m_bStaticCall(true)
{
}



/*
Routine Description: 

Name:

    CExtClassMethodCaller::~CExtClassMethodCaller

Functionality:
    
    Destructor.

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    None.

Notes:

*/

CExtClassMethodCaller::~CExtClassMethodCaller()
{
}



/*
Routine Description: 

Name:

    CExtClassMethodCaller::Initialize

Functionality:
    
    Initialize the object:
        (1) First, it tries to find the foreign provider. 
        (2) Secondly, it asks the foreign provider if it recognizes the class.

Virtual:
    
    No.
    
Arguments:

    pLog    - the object that does the logging. Can't be NULL

Return Value:

    Success:
        
        Various success code.

    Failure:
        (1) WBEM_E_INVALID_OBJECT if the object is not ready. It must be that the constructor
            is not properly called.
        (2) WBEM_E_INVALID_PARAMETER if pLog is NULL;
        (3) Other error codes indicating other errors.

Notes:

*/

HRESULT 
CExtClassMethodCaller::Initialize (
    IN CMethodResultRecorder * pLog
    )
{
    if (m_srpSceObject == NULL || m_pClsInfo == NULL)
    {
        return WBEM_E_INVALID_OBJECT;
    }
    else if (pLog == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    m_pLogRecord = pLog;

    //
    // try to find the foreign provider
    //

    CComPtr<IWbemLocator> srpLocator;
    HRESULT hr = ::CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
                                    IID_IWbemLocator, (LPVOID *) &srpLocator);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // try to get the foreign namespace of the foreign provider.
    // Our foreign class info pointer has namespace information.
    //

    hr = srpLocator->ConnectServer(m_pClsInfo->bstrNamespace, NULL, NULL, NULL, 0, NULL, NULL, &m_srpForeignNamespace);

    if (SUCCEEDED(hr))
    {
        //
        // does the foreign provider really know this class?
        //

        hr = m_srpForeignNamespace->GetObject(m_pClsInfo->bstrClassName, 0, NULL, &m_srpClass, NULL);

        //
        // if it doesn't, this foreign provider is useless. Let it go.
        //

        if (FAILED(hr))
        {
            m_srpForeignNamespace.Release();
        }
    }

    return hr;
}



/*
Routine Description: 

Name:

    CExtClassMethodCaller::ExecuteForeignMethod

Functionality:
    
    This is the function that truly executes the method on the foreign class/object.

    In order to accomplish this, we need to do many preparations:

        (1) Phase 1. Find the method encoding string, and decipher what it means. We call this
            the blockthe method call context preparation.

        (2) Phase 2. Depending on the context, we go into the foreign class/object preparation phase.
            If the encoding is so simple as to simply PutInstance/DelInstance, pretty much we are done.

        (3) Phase 3: parameter preparation and individual method execution.

Virtual:
    
    No.
    
Arguments:

    pszMethod    - The method name.

    pInParams   - the in parameter of the method.

    pHandler    - what we use to notify WMI.

    pCtx        - used to various WMI API's

    ppOut       - the out parameter.

Return Value:

    Success:
        
        Various success code.

    Failure:
        
        various error codes

Notes:
    
    If you need to add more functionality, consider logging your results, regardless success or
    failure. It's up to the logging options to determine if a success or failure will be logged.

*/

HRESULT 
CExtClassMethodCaller::ExecuteForeignMethod (
    IN LPCWSTR               pszMethod,
    IN IWbemClassObject   *  pInParams,
    IN IWbemObjectSink    *  pHandler, 
    IN IWbemContext       *  pCtx,
    OUT IWbemClassObject  ** ppOut
    )
{
    //
    // get the class definition
    //

    CComPtr<IWbemClassObject> srpWbemObj;
    HRESULT hr = m_srpSceObject->GetClassObject(&srpWbemObj);

    CComVariant varForeignObjPath;
    DWORD dwContext = 0;

    HRESULT hrLog = WBEM_NO_ERROR;

    //
    // Phase 1. Method call context preparation
    //

    if (SUCCEEDED(hr))
    {
        //
        // first, let us get the method encoding string
        //

        CComVariant varVal;

        //
        // try to see if there is a encoding string
        //

        //
        // build the method encoding string property's name
        //

        LPWSTR pszEncodeStrName = new WCHAR[wcslen(pszMethodPrefix) + wcslen(pszMethod) + wcslen(pszMethodPostfix) + 1];

        if (pszEncodeStrName == NULL)
        {
            hrLog = m_pLogRecord->LogResult(WBEM_E_OUT_OF_MEMORY, srpWbemObj, pInParams, NULL, pszMethod, L"GetMethodEncodingString", IDS_E_NAME_TOO_LONG, NULL);
            return WBEM_E_OUT_OF_MEMORY;
        }

        wsprintf(pszEncodeStrName, L"%s%s%s", pszMethodPrefix, pszMethod, pszMethodPostfix);

        //
        // get the class's method encoding string
        //

        hr = srpWbemObj->Get(pszEncodeStrName, 0, &varVal, NULL, NULL);

        //
        // we are done with the encoding string property's name
        //

        delete [] pszEncodeStrName;
        pszEncodeStrName = NULL;

        //
        // parse the encoding string to figure out the context, i.e.,
        // how many methods there are, in what order, what are their parameters, etc.
        //

        if (SUCCEEDED(hr) && varVal.vt == VT_BSTR)
        {
            CComBSTR bstrError;
            hr = ParseMethodEncodingString(varVal.bstrVal, &dwContext, &bstrError);

            //
            // if failed, we definitely want to log.
            //

            if (FAILED(hr))
            {
                hrLog = m_pLogRecord->LogResult(hr, srpWbemObj, pInParams, NULL, pszMethod, L"ParseEncodeString", IDS_E_ENCODE_ERROR, bstrError);
                return hr;
            }
        }
        else
        {
            //
            // this method is not supported
            //

            hrLog = m_pLogRecord->LogResult(WBEM_E_NOT_SUPPORTED, srpWbemObj, pInParams, NULL, pszMethod, L"GetMethodEncodingString", IDS_GET_EMBED_METHOD, NULL);
            
            //
            // considered as a success
            //

            return WBEM_S_FALSE;
        }
    }
    else
    {
        //
        // fails to get the class definition
        //

        hrLog = m_pLogRecord->LogResult(hr, srpWbemObj, pInParams, NULL, pszMethod, L"GetClassObject", IDS_GET_SCE_CLASS_OBJECT, NULL);
        return hr;
    }
    
    //
    // Phase 1. Method call context preparation finishes.
    //


    //
    // Phase 2. foreign class/object preparation
    //

    CComPtr<IWbemClassObject> srpForeignObj;

    //
    // now m_vecMethodContext is fully populated, we need the foreign instance.
    //

    hr = m_srpClass->SpawnInstance(0, &srpForeignObj);
    if (FAILED(hr))
    {
        hrLog = m_pLogRecord->LogResult(hr, srpWbemObj, pInParams, NULL, pszMethod, L"SpawnInstance", IDS_SPAWN_INSTANCE, NULL);
        return hr;
    }

    //
    // Our m_srpSceObject has all the property values,
    // populate the foreign object using our ISceClassObject
    //

    hr = PopulateForeignObject(srpForeignObj, m_srpSceObject, m_pLogRecord);
    if (FAILED(hr))
    {
        hrLog = m_pLogRecord->LogResult(hr, srpWbemObj, pInParams, NULL, pszMethod, L"PopulateForeignObject", IDS_POPULATE_FO, NULL);
        return hr;
    }

    //
    // see if this foreign object has a path or not. It shouldn't fail.
    //

    hr = srpForeignObj->Get(L"__Relpath", 0, &varForeignObjPath, NULL, NULL);
    if (FAILED(hr))
    {
        hrLog = m_pLogRecord->LogResult(hr, srpForeignObj, pInParams, NULL, pszMethod, L"GetPath", IDS_GET_FULLPATH, NULL);
        return hr;
    }
    else if (SUCCEEDED(hr) && varForeignObjPath.vt == VT_NULL || varForeignObjPath.vt == VT_EMPTY)
    {
        //
        // we will assume that the caller wants to make static calls.
        // we will allow to continue if the methods are all static ones.
        // m_bStaticCall is properly set during ParseMethodEncodingString.
        //

        //
        // if not static call, this can't be done.
        //
        if (!m_bStaticCall)
        {
            hr = WBEM_E_INVALID_OBJECT;
            hrLog = m_pLogRecord->LogResult(hr, srpForeignObj, pInParams, NULL, pszMethod, L"GetPath", IDS_NON_STATIC_CALL, NULL);
            return hr;
        }
        else
        {
            //
            // we only needs the class name as the path for static calls.
            //

            varForeignObjPath = m_pClsInfo->bstrClassName;
        }
    }

    //
    // give WMI the foreign object
    //

    //
    // does the foreign object exist?
    //

    CComPtr<IWbemClassObject> srpObject;
    hr = m_srpForeignNamespace->GetObject(varForeignObjPath.bstrVal, 0, NULL, &srpObject, NULL);


    if (FAILED(hr))
    {
        //
        // the object doesn't exist, we need to put first.
        //

        if (!m_bStaticCall)
        {
            hr = m_srpForeignNamespace->PutInstance(srpForeignObj, 0, pCtx, NULL);

            //
            // from this point on, srpObject is the foreign object
            //

            srpObject = srpForeignObj;
        }

        //
        // failed to put instance but the methods is really just delete, we will consider it not an error
        //

        if (FAILED(hr) && (dwContext & SCE_METHOD_ENCODE_DEL_ONLY))
        {
            hr = WBEM_NO_ERROR;
            hrLog = m_pLogRecord->LogResult(hr, srpObject, pInParams, NULL, pszMethod, pszDelInstance, IDS_DELETE_INSTANCE, NULL);
            return hr;
        }

        else if (FAILED(hr) || (dwContext & SCE_METHOD_ENCODE_PUT_ONLY))
        {
            //
            // fails to put or the methods are put only, then we are done.
            //

            hrLog = m_pLogRecord->LogResult(hr, srpObject, pInParams, NULL, pszMethod, pszPutInstance, IDS_PUT_INSTANCE, NULL);
            return hr;
        }
    }
    else
    {   
        //
        // Foreign object already exists, then we need to update the foreign object's properties
        //

        hr = PopulateForeignObject(srpObject, m_srpSceObject, m_pLogRecord);
        if (FAILED(hr))
        {
            hrLog = m_pLogRecord->LogResult(hr, srpObject, pInParams, NULL, pszMethod, pszPopInstance, IDS_POPULATE_FO, NULL);
            return hr;
        }

        //
        // unless we are making a static call, we must re-put to reflect our property updates
        //

        if (!m_bStaticCall)
        {
            hr = m_srpForeignNamespace->PutInstance(srpObject, 0, pCtx, NULL);
        }

        //
        // failed to put instance or it's put only, we are done.
        //

        if (FAILED(hr) || (dwContext & SCE_METHOD_ENCODE_PUT_ONLY))
        {
            hrLog = m_pLogRecord->LogResult(hr, srpObject, pInParams, NULL, pszMethod, pszPutInstance, IDS_PUT_INSTANCE, NULL);
            return hr;
        }

    }

    //
    // Phase 2. foreign class/object preparation finishes
    //


    //
    // Phase 3. parameter preparation and individual method execution.
    //

    //
    // loop through each method and call it against the foreign object
    //

    for (MCIterator it = m_vecMethodContext.begin(); it != m_vecMethodContext.end(); ++it)
    {
        //
        // fill in the parameters
        //

        if (*it == NULL)
        {
            hr = WBEM_E_FAILED;
            hrLog = m_pLogRecord->LogResult(hr, srpForeignObj, pInParams, NULL, pszMethod, NULL, IDS_INVALID_METHOD_CONTEXT, NULL);
            break;
        }

        CMethodContext* pMContext = *it;

        //
        // special cases
        //

        if (!m_bStaticCall && _wcsicmp(pMContext->m_pszMethodName, pszEquivalentPutInstance) == 0)
        {
            //
            // the current method is a Put. But we have already done a put
            //

            hr = WBEM_NO_ERROR;
            hrLog = m_pLogRecord->LogResult(hr, srpForeignObj, pInParams, NULL, pszMethod, pszPutInstance, IDS_PUT_INSTANCE, NULL);
        }
        else if (!m_bStaticCall && _wcsicmp(pMContext->m_pszMethodName, pszEquivalentDelInstance) == 0)
        {
            //
            // the current method is a Delete.
            //

            hr = m_srpForeignNamespace->DeleteInstance(varForeignObjPath.bstrVal, 0, pCtx, NULL);
            hrLog = m_pLogRecord->LogResult(hr, srpForeignObj, pInParams, NULL, pszMethod, pszDelInstance, IDS_DELETE_INSTANCE, NULL);
        }
        else
        {
            //
            // will truly call the method on the foreign object
            //

            CComPtr<IWbemClassObject> srpInClass;
            CComPtr<IWbemClassObject> srpInInst;

            //
            // create in paramter. We know for sure that this method is supported during parsing method context
            //

            hr = m_srpClass->GetMethod(pMContext->m_pszMethodName, 0, &srpInClass, NULL);
            if (FAILED(hr))
            {
                hrLog = m_pLogRecord->LogResult(hr, srpForeignObj, pInParams, NULL, pszMethod, L"GetParameter", IDS_E_OUT_OF_MEMROY, NULL);
                break;
            }

            //
            // make sure that we take the lesser of the pramater names and values.
            //

            int iParamCount = pMContext->m_vecParamValues.size();
            if (iParamCount > pMContext->m_vecParamNames.size())
            {
                iParamCount = pMContext->m_vecParamNames.size();
            }

            if (srpInClass == NULL && iParamCount > 0)
            {
                //
                // if can't get in parameter but we say we have parameter
                //

                hrLog = m_pLogRecord->LogResult(WBEM_E_INVALID_SYNTAX, srpForeignObj, pInParams, NULL, pszMethod, L"GetParameter", IDS_PUT_IN_PARAMETER, NULL);
                iParamCount = 0;    // no parameter to put
            }
            else if (srpInClass)
            {
                //
                // prepare an input parameter that we can fill in values
                //

                hr = srpInClass->SpawnInstance(0, &srpInInst);
                if (FAILED(hr))
                {
                    hrLog = m_pLogRecord->LogResult(hr, srpObject, pInParams, NULL, pszMethod, L"SpawnParameterObject", IDS_SPAWN_INSTANCE, NULL);
                    break;
                }
            }
            
            //
            // fill in parameter values:
            //

            //
            // if the parameter name is prefixed by pszInParameterPrefix (Sce_Param_), then we need
            // to pull the value from the in parameter (whose name is the parameter name without the prefix)
            //

            //
            // if the parameter name is prefixed by pszMemberParameterPrefix (Sce_Member_), then we need
            // to pull the value from our member (whose name is the parameter name without the prefix).
            //

            //
            // In both cases, the target parameter name is encoded as the string value of this parameter
            //

            for (int i = 0; i < iParamCount; ++i)
            {
                //
                // if a memeber is the parameter
                //

                if (IsMemberParameter(pMContext->m_vecParamNames[i]))
                { 
                    //
                    // get the member value from our object.
                    // Taking away the prefix becomes the property name!
                    //

                    CComVariant varVal;
                    hr = m_srpSceObject->GetProperty(pMContext->m_vecParamNames[i]+ wcslen(pszMemberParameterPrefix), &varVal);
                    
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Fill in the parameter value
                        //

                        hr = srpInInst->Put(pMContext->m_vecParamValues[i]->bstrVal, 0, &varVal, 0);
                    }
                }
                else if (IsInComingParameter(pMContext->m_vecParamNames[i]))
                {
                    //
                    // is an in-bound parameter
                    //

                    CComVariant varVal;

                    //
                    // the parameter value is inside the in parameter
                    //

                    if (pInParams)
                    {
                        //
                        // Take away the prefix is the in-coming parameter name
                        //

                        LPCWSTR pszParamName = pMContext->m_vecParamNames[i] + wcslen(pszInParameterPrefix);

                        //
                        // get the value from the in-paramter
                        //

                        hr = pInParams->Get(pszParamName, 0, &varVal, NULL, NULL);

                        if (SUCCEEDED(hr))
                        {
                            //
                            // Fill in the parameter value
                            //

                            hr = srpInInst->Put(pMContext->m_vecParamValues[i]->bstrVal, 0, &varVal, 0);
                        }
                    }
                }
                else
                {
                    //
                    // hard coded parameter value inside the encoding string
                    //

                    hr = srpInInst->Put(pMContext->m_vecParamNames[i], 0, pMContext->m_vecParamValues[i], 0);
                }

                if (FAILED(hr))
                {
                    //
                    // will ignore log result's return value. 
                    // execution stops
                    //

                    hrLog = m_pLogRecord->LogResult(hr, srpObject, pInParams, NULL, pszMethod, L"PutParameter", IDS_PUT_IN_PARAMETER, pMContext->m_vecParamNames[i]);
                    break;
                }
            }

            //
            // Wow, it's a lot of work to prepare the method execution. 
            // But we are finally ready.
            //

            if (SUCCEEDED(hr))
            {

                //
                // issue the method execution command!
                //

                hr = m_srpForeignNamespace->ExecMethod(varForeignObjPath.bstrVal, pMContext->m_pszMethodName, 0, NULL, srpInInst, ppOut, NULL);
                
                //
                // if method failed, then we don't continue with the rest of methods any further
                //

                if (FAILED(hr))
                {
                    //
                    // will ignore log result's return value
                    //

                    hrLog = m_pLogRecord->LogResult(hr, srpObject, pInParams, *ppOut, pszMethod, pMContext->m_pszMethodName, IDS_E_METHOD_FAIL, NULL);
                    
                    break;
                }
                else
                {
                    //
                    // will ignore log result's return value (whether that really happens is up to the log options.
                    //

                    hrLog = m_pLogRecord->LogResult(hr, srpObject, pInParams, *ppOut, pszMethod, pMContext->m_pszMethodName, IDS_SUCCESS, NULL);
                }
            }
            else
            {
                //
                // any failure causes us to stop executing the rest of the methods in the encoding string
                //

                break;
            }
        }
    }

    return hr;
}



/*
Routine Description: 

Name:

    CExtClassMethodCaller::PopulateForeignObject

Functionality:
    
    Use our embedding object's properties to populate foreign object.

Virtual:
    
    No.
    
Arguments:

    pForeignObj    - The foreign object.

    pSceObject     - Our embedding object that holds properties and other information

    pLogRecord     - Error logger.

Return Value:

    Success:
        
        various success codes.

    Failure:
        
        various error codes.

Notes:
    
    If you need to add more functionality, consider logging your results, regardless success or
    failure. It's up to the logging options to determine if a success or failure will be logged.

*/

HRESULT 
CExtClassMethodCaller::PopulateForeignObject (
    IN IWbemClassObject      * pForeignObj,
    IN ISceClassObject       * pSceObject,
    IN CMethodResultRecorder * pLogRecord   OPTIONAL
    )const
{
    if (m_bStaticCall)
    {
        return WBEM_S_FALSE;
    }

    DWORD dwCount = 0;
    
    //
    // populate the key property values
    //

    HRESULT hr = pSceObject->GetPropertyCount(SceProperty_Key, &dwCount);

    if (SUCCEEDED(hr) && dwCount > 0)
    {
        for (DWORD dwIndex = 0; dwIndex < dwCount; ++dwIndex)
        {
            CComBSTR bstrName;
            CComVariant varValue;
            hr = pSceObject->GetPropertyValue(SceProperty_Key, dwIndex, &bstrName, &varValue);

            //
            // we will log and quit if missing key property
            //

            if (FAILED(hr))
            {
                if (pLogRecord)
                {
                    pLogRecord->LogResult(hr, pForeignObj, NULL, 0, L"PopulateForeignObject", L"GetKeyProperty", IDS_GET_KEY_PROPERTY, NULL);
                }
                
                return hr;
            }
            else if (varValue.vt != VT_NULL && 
                     varValue.vt != VT_EMPTY && 
                     !IsMemberParameter(bstrName))
            {
                //
                // we will ignore the result. The reason is that our embedding
                // class may have more key properties than the foreign object.
                //

                HRESULT hrIgnore = pForeignObj->Put(bstrName, 0, &varValue, 0);
            }
        }
    }

    //
    // populate the nonkey property values
    //

    hr = pSceObject->GetPropertyCount(SceProperty_NonKey, &dwCount);
    if (SUCCEEDED(hr) && dwCount > 0)
    {
        for (DWORD dwIndex = 0; dwIndex < dwCount; ++dwIndex)
        {
            CComBSTR bstrName;
            CComVariant varValue;

            HRESULT hrIgnore = pSceObject->GetPropertyValue(SceProperty_NonKey, dwIndex, &bstrName, &varValue);

            //
            // missing property information is acceptable, but we will log
            //

            if (FAILED(hrIgnore) && pLogRecord) 
            {
                pLogRecord->LogResult(hrIgnore, pForeignObj, NULL, 0, L"PopulateForeignObject", L"GetNonKeyProperty", IDS_GET_NON_KEY_PROPERTY, NULL);
            }

            if (SUCCEEDED(hrIgnore) && varValue.vt != VT_NULL && varValue.vt != VT_EMPTY && !IsMemberParameter(bstrName))
            {
                //
                // missing non-key property is acceptable
                //

                hrIgnore = pForeignObj->Put(bstrName, 0, &varValue, 0);
            }
        }
    }

    return hr;
}



/*
Routine Description: 

Name:

    CExtClassMethodCaller::IsInComingParameter

Functionality:
    
    Test if the name is an in-coming parameter.

Virtual:
    
    No.
    
Arguments:

    szName    - The name of to test.

Return Value:

    true if and only if the name is considered a in-parameter.

Notes:
    
    To specify that we should use an in parameter of the embedding object's method as
    a parameter for the foreign class/object's parameter, we use a prefix "Sce_Param_"
    to tell them apart. This is the test to see if the name contains this prefix or not.

    For example, Sce_Param_Test<VT_BSTR : "Try"> means:

    (1) use the embedding object's parameter called "Test" as the foreign object's paramter called "Try".

*/

bool 
CExtClassMethodCaller::IsInComingParameter (
    IN LPCWSTR szName
    )const
{
    LPCWSTR pszPrefix = wcsstr(szName, pszInParameterPrefix);
    return (pszPrefix - szName == 0);
}


/*
Routine Description: 

Name:

    CExtClassMethodCaller::IsMemberParameter

Functionality:
    
    Test if the name is an member parameter. See notes for more explanation.

Virtual:
    
    No.
    
Arguments:

    szName    - The name of to test.

Return Value:

    true if and only the name is considered a member parameter.

Notes:
    
    To specify that we should use a member property of the embedding object's as
    a parameter for the foreign class/object's parameter, we use a prefix "Sce_Member_"
    to tell them apart. This is the test to see if the name contains this prefix or not.

    For example, Sce_Member_Test<VT_BSTR : "Try"> means:

    (1) use the embedding object member property called "Test" as the foreign object's paramter called "Try".

*/

bool CExtClassMethodCaller::IsMemberParameter (
    IN LPCWSTR szName
    )const
{
    LPCWSTR pszPrefix = wcsstr(szName, pszMemberParameterPrefix);
    return (pszPrefix - szName == 0);
}


/*
Routine Description: 

Name:

    CExtClassMethodCaller::IsStaticMethod

Functionality:
    
    Test if the method is a static method on the foreign class.

Virtual:
    
    No.
    
Arguments:

    szName    - The name of to test.

Return Value:

    true if and only if the named method is verfied as a static method with the foreign class.

Notes:

    In other words, if we can't determine for whatever reasons, we return false.

*/

bool 
CExtClassMethodCaller::IsStaticMethod (
    IN LPCWSTR szMethodName
    )const
{
    //
    // default answer is false
    //

    bool bIsStatic = false;

    if (m_srpClass && szMethodName != NULL && *szMethodName != L'\0')
    {
        //
        // IWbemQualifierSet can tell us whether the STATIC qualifier
        // is specified in the schema
        //

        CComPtr<IWbemQualifierSet> srpQS;
        HRESULT hr = m_srpClass->GetMethodQualifierSet(szMethodName, &srpQS);

        if (SUCCEEDED(hr))
        {
            CComVariant var;
            hr = srpQS->Get(L"STATIC", 0, &var, NULL);

            if (SUCCEEDED(hr) && var.vt == VT_BOOL && var.boolVal == VARIANT_TRUE)
            {
                bIsStatic = true;
            }
        }
    }

    return bIsStatic;
}



/*
Routine Description: 

Name:

    CExtClassMethodCaller::FormatSyntaxError

Functionality:
    
    A logging helper to format a string for syntax error.

Virtual:
    
    No.
    
Arguments:

    wchMissChar     - The char that is missing.

    dwMissCharIndex - the index where the missing char is expected.

    pszString       - Where the error happens.

    pbstrError      - Receives the output.

    

Return Value:

    None.

Notes:

*/

void 
CExtClassMethodCaller::FormatSyntaxError (
    IN WCHAR wchMissChar,
    IN DWORD dwMissCharIndex,
    IN LPCWSTR pszString,
    OUT BSTR* pbstrError        OPTIONAL
    )
{
    if (pbstrError)
    {
        *pbstrError = NULL;
        CComBSTR bstrErrorFmtStr;

        if (bstrErrorFmtStr.LoadString(IDS_MISSING_TOKEN))
        {
            const int MAX_INDEX_LENGTH = 32;

            //
            // 3 is for the SingleQuote + wchMissChar + SingleQuote
            //

            WCHAR wszMissing[] = {L'\'', wchMissChar, L'\''};
            int iLen = wcslen(bstrErrorFmtStr) + wcslen(pszString) + 3 + MAX_INDEX_LENGTH + 1;

            *pbstrError = ::SysAllocStringLen(NULL, iLen);

            if (*pbstrError != NULL)
            {
                ::wsprintf(*pbstrError, (LPCWSTR)bstrErrorFmtStr, wszMissing, dwMissCharIndex, pszString);
            }
        }
    }
}



/*
Routine Description: 

Name:

    CExtClassMethodCaller::ParseMethodEncodingString

Functionality:
    
    Parsing the encoding string and populate its calling context.

Virtual:
    
    No.
    
Arguments:

    pszEncodeString - The encoding string.

    pdwContext      - Receives overall. Other than 0, it's either

                        SCE_METHOD_ENCODE_DEL_ONLY -- meaning the whole string just encodes a delete call

                      or

                        SCE_METHOD_ENCODE_PUT_ONLY --  meaning the whole string just encodes a put call

    pbstrError      - string about the error found. Caller is responsible for releasing it.

    

Return Value:

    Success:
        Various success codes.

    Failure:
        Various error codes. If error happens and if it's encoding error,
        we will have error information string passed back to the caller.

Notes:

    --------------------------------------------------------------------
     methods are encoded in the following format:

        method_1(parameter1, parameter2,,,);method_2();method_3(...)

     where method_1, method_2 are names for the foreign object's methods
     and parameter1 and parameter2 (etc.) are of the form 

        name<vt:value>

     where name is the name of the parameter, and vt will be the 
     variant's vt for "value". If vt == VT_VARIANT, then
     the "value" is the name for a memeber variable of the class

    --------------------------------------------------------------------
     ************************Warning***********************************
     this method has a lost of consideration of heap allocation for
     efficiency reasons. Unless the length needed for the token is longer
     than MAX_PATH (which will be the case for 99% cases), we are just going
     to use the stack varialbes. If you modify the routine, please don't
     return at the middle unless you are sure that you have freed the memory
    --------------------------------------------------------------------

*/

HRESULT 
CExtClassMethodCaller::ParseMethodEncodingString (
    IN LPCWSTR    pszEncodeString,
    OUT DWORD   * pdwContext,
    OUT BSTR    * pbstrError
    )
{
    if (pbstrError == NULL || pdwContext == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // current parsing point
    //

    LPCWSTR pCur = pszEncodeString;

    HRESULT hr = WBEM_NO_ERROR;

    //
    // determines if all is about delete
    //

    bool bIsDel = false;

    //
    // determines if all is about put
    //

    bool bIsPut = false;

    DWORD dwCount = 0;

    //
    // in most cases, the method name will be held here, unless the name is too long
    //

    WCHAR szMethodName[MAX_PATH];

    //
    // in most cases, the value will be held here, unless the value is too long
    //

    WCHAR szParameterValue[MAX_PATH];


    LPWSTR pszName  = NULL;
    LPWSTR pszValue = NULL;

    //
    // to avoid costly allocation/free, we will rely on most cases (if the length is
    // not more than MAX_PATH) the stack variables to store the parsed method name.
    //

    LPWSTR pszHeapName = NULL;
    LPWSTR pszHeapValue = NULL;

    //
    // current name string's length
    //

    int iCurNameLen = 0;

    //
    // current value's string length
    //

    int iCurValueLen = 0;

    if (pbstrError)
    {
        *pbstrError = NULL;
    }

    //
    // not used, but needed for the parsing routines
    //

    bool bEscaped;

    while (true)
    {
        LPCWSTR pNext = pCur;

        //
        // get the method name, upto '('
        //

        while (*pNext != L'\0' && *pNext != wchMethodLeft)
        {
            ++pNext;
        }

        //
        // must have '('
        //

        if (*pNext != wchMethodLeft)
        {
            FormatSyntaxError(wchMethodLeft, (pNext - pszEncodeString), pszEncodeString, pbstrError);
            hr = WBEM_E_INVALID_SYNTAX;
            break;
        }

        //
        // from pCur to pNext is the name
        //

        int iTokenLen = pNext - pCur;

        if (iTokenLen >= MAX_PATH)
        {
            //
            // stack variable is not long enough, see if heap is long enough
            //

            if (iCurNameLen < iTokenLen + 1)
            {
                //
                // release previously allocated memory and make it enough length for the current token.
                //

                delete [] pszHeapName;

                iCurNameLen = iTokenLen + 1;

                pszHeapName = new WCHAR[iCurNameLen];

                if (pszHeapName == NULL)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                    break;
                }
            }

            //
            // this is where our name should be copied
            //

            pszName = pszHeapName;
        }
        else
        {
            //
            // this is where our name should should be copied.
            //

            pszName = szMethodName;
        }

        //
        // copy the name, no white space, please
        //

        ::TrimCopy(pszName, pCur, iTokenLen);

        //
        // don't worry, we are also keep tracking of the number of 
        // methods encoded. If that is 1, then we are going to 
        // use these two variables.
        //

        bIsPut = (_wcsicmp(pszName, pszEquivalentPutInstance) == 0);
        bIsDel = (_wcsicmp(pszName, pszEquivalentDelInstance) == 0);

        if (!bIsPut && !bIsDel)
        {
            // 
            // not put, nor delete
            // validate that this method is supported
            //

            CComPtr<IWbemClassObject> srpInClass;
            hr = m_srpClass->GetMethod(pszName, 0, &srpInClass, NULL);
            if (FAILED(hr))
            { 
                //
                // method not supported/out of memory
                //

                if (hr == WBEM_E_NOT_FOUND)
                {
                    CComBSTR bstrMsg;
                    bstrMsg.LoadString(IDS_METHOD_NOT_SUPPORTED);
                    bstrMsg += CComBSTR(pszName);
                    *pbstrError = bstrMsg.Detach();
                }
                break;
            }
        }

        //
        // now grab the parameter
        //

        pCur = ++pNext; // skip over the '('

        DWORD dwMatchCount = 0;
        bool bIsInQuote = false;

        //
        // seek to the enclosing ')' char (wchMethodRight)
        // as long as it is inside an open '(', or inside quote, or not ')'
        //

        while (*pNext != L'\0' && (dwMatchCount > 0 || bIsInQuote || *pNext != wchMethodRight ))
        {
            if (!bIsInQuote)
            {
                //
                // not inside quote
                //

                if (*pNext == wchMethodLeft)
                {
                    dwMatchCount += 1;
                }
                else if (*pNext == wchMethodRight)
                {
                    dwMatchCount -= 1;
                }
            }

            if (*pNext == L'"')
            {
                bIsInQuote = !bIsInQuote;
            }

            ++pNext;
        }


        //
        // must have ')'
        //

        if (*pNext != wchMethodRight)
        {
            FormatSyntaxError(wchMethodRight, (pNext - pszEncodeString), pszEncodeString, pbstrError);
            hr = WBEM_E_INVALID_SYNTAX;
            break;
        }

        //
        // from pCur to pNext is the parameter list
        //

        iTokenLen = pNext - pCur;

        if (iTokenLen >= MAX_PATH)
        {
            //
            // stack variable is not long enough for the parameter value, see if heap is long enough
            //

            if (iCurValueLen < iTokenLen + 1)
            {
                //
                // release previously allocated memory, and allocate enough for the new length
                //

                delete [] pszHeapValue;
                iCurValueLen = iTokenLen + 1;

                pszHeapValue = new WCHAR[iCurValueLen];
                if (pszHeapValue == NULL)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                    break;
                }
            }

            //
            // this is where the value will be copied to
            //

            pszValue = pszHeapValue;
        }
        else
        {
            //
            // this is where the value will be copied to
            //

            pszValue = szParameterValue;
        }

        //
        // copy the value, no white space
        //

        ::TrimCopy(pszValue, pCur, iTokenLen);

        //
        // We got the name and the value, 
        // build the method and the parameter list
        //

        ++dwCount;
        hr = BuildMethodContext(pszName, pszValue, pbstrError);
        if (FAILED(hr))
        {
            break;
        }

        //
        // as long as there is one method that is not static, it's not a static seqeunce.
        //

        if (!IsStaticMethod(pszName))
        {
            m_bStaticCall = false;
        }

        //
        // skip the ')'
        //

        pCur = ++pNext;

        //
        // seek to ';'
        //

        while (*pNext != L'\0' && *pNext != wchMethodSep)
        {
            ++pNext;
        }

        if (*pNext != wchMethodSep) 
        {
            //
            // not seen ';'
            //

            break;
        }

        //
        // skip the ';'
        //

        pCur = pNext + 1;
    }

    *pdwContext = 0;

    if (SUCCEEDED(hr))
    {
        if (dwCount == 1 && bIsDel)
        {
            *pdwContext = SCE_METHOD_ENCODE_DEL_ONLY;
        }
        else if (dwCount == 1 && bIsPut)
        {
            *pdwContext = SCE_METHOD_ENCODE_PUT_ONLY;
        }
    }

    delete [] pszHeapName;
    delete [] pszHeapValue;

    return hr;
}



/*
Routine Description: 

Name:

    CExtClassMethodCaller::BuildMethodContext

Functionality:
    
    Given a method name and its parameter encoding string, build this method call's context.

Virtual:
    
    No.
    
Arguments:

    szMethodName    - name of the method on foreign object.

    szParameter     - encoding string for the paramter. See Notes for sample.

    pbstrError      - string about the errors found. Caller is responsible for releasing it.

    

Return Value:

    Success:
        Various success codes.

    Failure:
        Various error codes. If error happens and if it's encoding error,
        we will have error information string passed back to the caller.

Notes:

    (1) this function is to parse the parameter list, which comes in the
        following format (exclude parentheses)
            
              (parameter1, parameter2,,,) 
              
        where parameter1 is in the following format 
            
              name<vt:value>

    (2) ************************Warning***********************************
        this method has a lost of consideration of heap allocation for
        efficiency reasons. Unless the length needed for the token is longer
        than MAX_PATH (which will be the case for 99% cases), we are just going
        to use the stack varialbes. If you modify the routine, please don't
        return at the middle unless you are sure that you have freed the memory

    (3) Don't blindly return. We opt to use goto so that we can deal with memory
        deallocation.

  */

HRESULT 
CExtClassMethodCaller::BuildMethodContext (
    IN LPCWSTR    szMethodName,
    IN LPCWSTR    szParameter,
    OUT BSTR    * pbstrError 
    )
{
    //
    // current parsing point
    //

    LPCWSTR pCur = szParameter;

    HRESULT hr          = WBEM_NO_ERROR;

    LPWSTR pszParamName = NULL;
    LPWSTR pszValue     = NULL;

    //
    // normally, the value goes to szParameterValue unless it's too long.
    //

    WCHAR szParameterValue[MAX_PATH];

    LPWSTR pszHeapValue = NULL;

    int iCurValueLen = 0;

    VARIANT* pVar = NULL;

    int iTokenLen = 0;

    //
    // the moving point of parsing
    //

    LPCWSTR pNext = pCur;

    //
    // only needed for parsing routines
    //

    bool bEscaped = false;

    //
    // we will build one context
    //

    CMethodContext *pNewContext = new CMethodContext;

    if (pNewContext == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto Error;
    }

    //
    // need to copy the method
    //

    pNewContext->m_pszMethodName = new WCHAR[wcslen(szMethodName) + 1];

    if (pNewContext->m_pszMethodName == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto Error;
    }

    wcscpy(pNewContext->m_pszMethodName, szMethodName);

    //
    // now, scan through the parameter encoding string to find the parameter name and its value
    //

    while (*pCur != L'\0')
    {
        //
        // get the parameter name, upto '<'. 
        // Last parameter == true means moving to end if not found
        //

        pNext = ::EscSeekToChar(pCur, wchTypeValLeft, &bEscaped, true);

        if (*pNext != wchTypeValLeft)
        {
            //
            // don't see one, then syntax error
            //

            FormatSyntaxError(wchTypeValLeft, (pNext - szParameter), szParameter, pbstrError);
            hr = WBEM_E_INVALID_SYNTAX;
            goto Error;
        }

        //
        // from pCur to pNext is the parameter name
        //

        iTokenLen = pNext - pCur;
        pszParamName = new WCHAR[iTokenLen + 1];
        if (pszParamName == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto Error;
        }

        //
        // get the name, but no white space.
        //

        ::TrimCopy(pszParamName, pCur, iTokenLen);

        //
        // add the name to the name list, the context is responsible to manage the memory
        //

        pNewContext->m_vecParamNames.push_back(pszParamName);

        //
        // pCur is at '<'
        //

        pCur = pNext;

        //
        // move to '>'. 
        // Last parameter == true means moving to end if not found
        //

        pNext = ::EscSeekToChar(pCur, wchTypeValRight, &bEscaped, true);

        if (*pNext != wchTypeValRight)
        {  
            //
            // must have '>'
            //

            FormatSyntaxError(wchTypeValRight, (pNext - szParameter), szParameter, pbstrError);
            hr = WBEM_E_INVALID_SYNTAX;
            goto Error;
        }

        //
        // skip over '>'
        //

        ++pNext;

        //
        // from pCur to pNext is the <vt:value>, copy it into szParValue
        //

        iTokenLen = pNext - pCur;

        if (iTokenLen >= MAX_PATH)
        {
            //
            // stack variable is not long enough for the parameter value, see if heap is long enough
            //

            if (iCurValueLen < iTokenLen + 1)
            {
                //
                // release previously allocated memory and give a longer buffer
                //

                delete [] pszHeapValue;

                iCurValueLen = iTokenLen + 1;
                pszHeapValue = new WCHAR[iCurValueLen];

                if (pszHeapValue == NULL)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                    goto Error;
                }
            }

            //
            // this is where the value will be written
            //

            pszValue = pszHeapValue;
        }
        else
        {
            //
            // this is where the value will be written
            //

            pszValue = szParameterValue;
        }

        //
        // get the value string, no white space
        //

        ::TrimCopy(pszValue, pCur, iTokenLen);

        //
        // translate the string into a value
        //

        pVar = new VARIANT;
        if (pVar == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto Error;
        }

        hr = ::VariantFromFormattedString(pszValue, pVar);

        if (FAILED(hr))
        {
            *pbstrError = ::SysAllocString(pszValue);
            goto Error;
        }

        //
        // add this parameter into the list. It owns the variant!
        //

        pNewContext->m_vecParamValues.push_back(pVar);
        pVar = NULL;

        //
        // skip while spaces
        //

        while (*pNext != L'\0' && iswspace(*pNext))
        {
            ++pNext;
        }

        //
        // if *pNext == ',', need to work further
        //

        if (*pNext == wchParamSep)
        {
            //
            // skip ','
            //

            ++pNext;
        }
        else if (*pNext == L'\0')
        {
            break;
        }
        else
        {
            //
            // syntax errors
            //

            FormatSyntaxError(wchParamSep, (pNext - szParameter), szParameter, pbstrError);
            hr = WBEM_E_INVALID_SYNTAX;
            goto Error;
        }

        //
        // for next loop.
        //

        pCur = pNext;
    }

    //
    // everything is fine, push the context to our vector. It owns the context from this point on.
    //

    m_vecMethodContext.push_back(pNewContext);

    delete [] pszHeapValue;

return hr;

Error:

    //
    // CMethodContext knows how to delete itself cleanly
    //

    delete pNewContext;

    if (pVar)
    {
        ::VariantClear(pVar);
    }
    delete pVar;

    delete [] pszHeapValue;

    return hr;
}

//=========================================================================
// CExtClassMethodCaller::CMethodContext impelementation


/*
Routine Description: 

Name:

    CExtClassMethodCaller::CMethodContext::CMethodContext

Functionality:

    This is the constructor. trivial.

Virtual:
    
    No

Arguments:

    None.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CExtClassMethodCaller::CMethodContext::CMethodContext() 
    : 
    m_pszMethodName(NULL)
{
}


/*
Routine Description: 

Name:

    CExtClassMethodCaller::CMethodContext::~CMethodContext

Functionality:

    This is the Destructor. Just do clean up of all the resources managed by the context.

Virtual:
    
    No

Arguments:

    None.

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about clean them up here.

*/

CExtClassMethodCaller::CMethodContext::~CMethodContext ()
{
    delete [] m_pszMethodName;

    int iCount = m_vecParamValues.size();
    
    //
    // m_vecParamValues is a vector of heap allocated variant*
    //

    for (int i = 0; i < iCount; ++i)
    {
        //
        // need to release the variant and then delete the variant
        //

        ::VariantClear(m_vecParamValues[i]);
        delete m_vecParamValues[i];
    }
    m_vecParamValues.clear();

    //
    // m_vecParamNames is just a vector of strings
    //

    iCount = m_vecParamNames.size();
    for (int i = 0; i < iCount; ++i)
    {
        delete [] m_vecParamNames[i];
    }
    m_vecParamNames.clear();
}

//========================================================================
// implementation CMethodResultRecorder



/*
Routine Description: 

Name:

    CMethodResultRecorder::CMethodResultRecorder

Functionality:

    This is the Constructor. Trivial.

Virtual:
    
    No

Arguments:

    None.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initializing them here.

*/

CMethodResultRecorder::CMethodResultRecorder ()
{
}


/*
Routine Description: 

Name:

    CMethodResultRecorder::Initialize

Functionality:

    Initializes itself.

Virtual:
    
    No

Arguments:

    pszLogFilePath  - log file's path.

    pszClassName    - The class name.

    pNativeNS       - SCE namespace.

    pCtx            - what WMI API's need.

Return Value:

    Success:

        Various success codes.

    Failure:

        Various error codes.

Notes:

*/

HRESULT 
CMethodResultRecorder::Initialize (
    IN LPCWSTR          pszLogFilePath,
    IN LPCWSTR          pszClassName,
    IN IWbemServices  * pNativeNS, 
    IN IWbemContext   * pCtx
    )
{
    if (pszClassName == NULL || pNativeNS == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_NO_ERROR;

    if (pszLogFilePath != NULL && *pszLogFilePath != L'\0')
    {
        m_bstrLogFilePath = pszLogFilePath;
    }
    else
    {

        //
        // no log file? we will log to the default log file.
        //

        //
        // protect the global variable
        //
        g_CS.Enter();

        m_bstrLogFilePath = ::SysAllocString(g_bstrDefLogFilePath);

        g_CS.Leave();
    }

    m_bstrClassName = pszClassName;
    m_srpNativeNS = pNativeNS;
    m_srpCtx = pCtx;

    return hr;
}



/*
Routine Description: 

Name:

    CMethodResultRecorder::LogResult

Functionality:

    Do all the dirty work to log!.

Virtual:
    
    No

Arguments:
    
    hrResult            - the RESULT value.

    pObj                - The embedding object.

    pParam              - the in parameter.

    pParam              - the out parameter.

    pszMethod           - method name.

    pszForeignAction    - action on the foreign object.

    uMsgResID           - resource string id.

    pszExtraInfo        - Other information in string.

Return Value:

    Success:

        Various success codes.

    Failure:

        Various error codes.

Notes:
    (1) we will generate such a string to log:

            <ClassName>.<pszMethod>[pszForeignAction], 
            Failure Cause=xxx. 
            Object detail=xxx, 
            Parameter detail=xxx

        whereas

            Failure Cause=xxx only present with errors

            Object detail=xxx only present if logging verbosely

            Parameter detail=xxx only present if logging verbosely


*/

HRESULT 
CMethodResultRecorder::LogResult (
    IN HRESULT            hrResult,               
    IN IWbemClassObject * pObj,         
    IN IWbemClassObject * pParam,       
    IN IWbemClassObject * pOutParam,    
    IN LPCWSTR            pszMethod,
    IN LPCWSTR            pszForeignAction,
    IN UINT               uMsgResID,
    IN LPCWSTR            pszExtraInfo
    )const
{
    //
    // Logging only happens when we execute a method on Sce_Operation CSceOperation::ExecMethod
    // We block reentrance to that function if there is a thread executing that function. This
    // eliminates the need to protect this global variable
    // 

    //
    // get the logging option
    //

    SCE_LOG_OPTION status = g_LogOption.GetLogOption();

    if (status == Sce_log_None)
    {
        return WBEM_NO_ERROR;
    }
    else if ( (status & Sce_log_Success) == 0 && SUCCEEDED(hrResult))  
    {
        //
        // not to log success code
        //

        return WBEM_NO_ERROR;
    }
    else if ( (status & Sce_log_Error) == 0 && FAILED(hrResult))  
    {
        //
        // not to log error code
        //

        return WBEM_NO_ERROR;
    }

    if (pszMethod == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( m_srpNativeNS                 == NULL || 
              (LPCWSTR)m_bstrLogFilePath    == NULL || 
              (LPCWSTR)m_bstrClassName      == NULL     )
    {
        return WBEM_E_INVALID_OBJECT;
    }

    //
    // create each property of the log record object
    //

    DWORD dwLength;

    CComBSTR bstrAction, bstrErrorCause, bstrObjDetail, bstrParamDetail;

    if (pszForeignAction)
    {
        //
        // creating something like this:
        //
        //      ClassName.Method[ForeignMethod]
        //

        dwLength = wcslen(m_bstrClassName) + 1 + wcslen(pszMethod) + 1 + wcslen(pszForeignAction) + 1 + 1;
        bstrAction.m_str = ::SysAllocStringLen(NULL, dwLength);
        if (bstrAction.m_str != NULL)
        {
            ::_snwprintf(bstrAction.m_str, dwLength, L"%s.%s[%s]", (LPCWSTR)m_bstrClassName, pszMethod, pszForeignAction);
        }
        else
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        //
        // creating something like this:
        //
        //      ClassName.Method
        //

        dwLength = wcslen(m_bstrClassName) + 1 + wcslen(pszMethod) + 1;
        bstrAction.m_str = ::SysAllocStringLen(NULL, dwLength);

        if (bstrAction.m_str != NULL)
        {
            ::_snwprintf(bstrAction.m_str, dwLength, L"%s.%s", (LPCWSTR)m_bstrClassName, pszMethod);
        }
        else
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    if (FAILED(hrResult))
    {
        //
        // in case of error, the error cause will be like:
        //
        //      ErrorMsg: [extra info]
        //
        // if no extra info, then the msg will be the only one we can use
        //

        bstrErrorCause.LoadString(uMsgResID);
        if (pszExtraInfo != NULL)
        {
            CComBSTR bstrMsg;
            bstrMsg.m_str = bstrErrorCause.Detach();

            dwLength = wcslen(bstrMsg) + 1 + 1 + 1 + wcslen(pszExtraInfo) + 1 + 1;
            bstrErrorCause.m_str = ::SysAllocStringLen(NULL, dwLength);
            if (bstrErrorCause.m_str != NULL)
            {
                ::_snwprintf(bstrErrorCause.m_str, dwLength, L"%s: [%s]", (LPCWSTR)bstrMsg, pszExtraInfo);
            }
            else
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    //
    // log verbosely if so set. Verbose pretty much means that we are going to log the objects.
    //

    if (Sce_log_Verbose & status)
    {
        //
        // format object, will ignore the return result
        //

        FormatVerboseMsg(pObj, &bstrObjDetail);

        //
        // format in parameter
        //

        CComBSTR bstrIn;
        FormatVerboseMsg(pParam, &bstrIn);

        //
        // format out parameter
        //

        CComBSTR bstrOut;
        FormatVerboseMsg(pOutParam, &bstrOut);

        CComBSTR bstrInLabel;
        bstrInLabel.LoadString(IDS_IN_PARAMETER);

        CComBSTR bstrOutLabel;
        bstrOutLabel.LoadString(IDS_OUT_PARAMETER);

        //
        // now create the in and out parameter verbose message
        //

        if (NULL != (LPCWSTR)bstrIn && NULL != (LPCWSTR)bstrOut)
        {   
            //
            // <bstrInLabel>=<bstrIn>; <bstrOutLabel>=<bstrOut>
            //

            dwLength = wcslen(bstrInLabel) + 1 + wcslen(bstrIn) + 2 + wcslen(bstrOutLabel) + 1 + wcslen(bstrOut) + 1; 
            bstrParamDetail.m_str = ::SysAllocStringLen(NULL, dwLength);

            if (bstrParamDetail.m_str != NULL)
            {
                ::_snwprintf(bstrParamDetail.m_str, 
                             dwLength, 
                             L"%s=%s; %s=%s", 
                             (LPCWSTR)bstrInLabel, 
                             (LPCWSTR)bstrIn, 
                             (LPCWSTR)bstrOutLabel, 
                             (LPCWSTR)bstrOut
                             );
            }
            else
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else if (NULL != (LPCWSTR)bstrIn)
        {
            //
            // <bstrInLabel>=<bstrIn>.
            //

            dwLength = wcslen(bstrInLabel) + 1 + wcslen(bstrIn) + 2; 
            bstrParamDetail.m_str = ::SysAllocStringLen(NULL, dwLength);
            if (bstrParamDetail.m_str != NULL)
            {
                ::_snwprintf(bstrParamDetail.m_str, 
                             dwLength, 
                             L"%s=%s", 
                             (LPCWSTR)bstrInLabel, 
                             (LPCWSTR)bstrIn
                             );
            }
            else
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else if (NULL != (LPCWSTR)bstrOut)
        {
            //
            // <bstrOutLabel>=<bstrOut>.
            //

            dwLength = wcslen(bstrOutLabel) + 1 + wcslen(bstrOut) + 2; 
            bstrParamDetail.m_str = ::SysAllocStringLen(NULL, dwLength);
            if (bstrParamDetail.m_str != NULL)
            {
                ::_snwprintf(bstrParamDetail.m_str, 
                             dwLength, 
                             L"%s=%s", 
                             (LPCWSTR)bstrOutLabel, 
                             (LPCWSTR)bstrOut
                             );
            }
            else
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    //
    // now create a logging instance (Sce_ConfigurationLogRecord) and put it. 
    //

    CComPtr<IWbemClassObject> srpObj;
    HRESULT hr = m_srpNativeNS->GetObject(SCEWMI_LOG_CLASS, 0, NULL, &srpObj, NULL);

    if (SUCCEEDED(hr))
    {
        CComPtr<IWbemClassObject> srpLogInst;
        hr = srpObj->SpawnInstance(0, &srpLogInst);

        //
        // populate the log instance's properties
        //

        if (SUCCEEDED(hr))
        {
            //
            // CScePropertyMgr helps us to access WMI object's properties
            // create an instance and attach the WMI object to it.
            // This will always succeed.
            //

            CScePropertyMgr ScePropMgr;
            ScePropMgr.Attach(srpLogInst);

            //
            // need to add escape for backslash
            //

            CComBSTR bstrDblBackSlash;
            hr = ::ConvertToDoubleBackSlashPath(m_bstrLogFilePath, L'\\', &bstrDblBackSlash);

            //
            // set all available members. If we can't set log file path, then we have to quit
            // we will allow other properties to be missing
            //

            if (SUCCEEDED(hr))
            {
                hr = ScePropMgr.PutProperty(pLogFilePath, bstrDblBackSlash);
            }
            if (SUCCEEDED(hr))
            {
                hr = ScePropMgr.PutProperty(pLogArea, pszAreaAttachmentClasses);
            }

            if (SUCCEEDED(hr) && NULL != (LPCWSTR)bstrAction)
            {
                hr = ScePropMgr.PutProperty(pAction, bstrAction);
            }

            if (SUCCEEDED(hr) && NULL != (LPCWSTR)bstrErrorCause)
            {
                hr = ScePropMgr.PutProperty(pErrorCause, bstrErrorCause);
            }

            if (SUCCEEDED(hr) && NULL != (LPCWSTR)bstrObjDetail)
            {
                hr = ScePropMgr.PutProperty(pObjectDetail, bstrObjDetail);
            }

            if (SUCCEEDED(hr) && NULL != (LPCWSTR)bstrParamDetail)
            {
                hr = ScePropMgr.PutProperty(pParameterDetail, bstrParamDetail);
            }

            if (SUCCEEDED(hr))
            {
                hr = ScePropMgr.PutProperty(pLogErrorCode, (DWORD)hrResult);
            }

            //
            // if all information is takenly, then we can put the instance
            // whic will cause a log record.
            //

            if (SUCCEEDED(hr))
            {
                hr = m_srpNativeNS->PutInstance(srpLogInst, 0, m_srpCtx, NULL);
            }
        }
    }

    return hr;
}


/*
Routine Description: 

Name:

    CMethodResultRecorder::FormatVerboseMsg

Functionality:

    Create a verbose message for a wbem object. Used for logging.

Virtual:
    
    No

Arguments:

    pObject    - The wbem object.

    pbstrMsg   - receives the verbose message.

Return Value:

    Success:

        Various success codes.

    Failure:

        Various error codes.

Notes:
    (1) we will generate such a string:

            Object detail = xxxxxxxxxxxxxxxxxxx

    (2) All values will share our common syntax that is used everywhere:
            
            <VT_Type : xxxxxx >

*/

HRESULT 
CMethodResultRecorder::FormatVerboseMsg (          
    IN IWbemClassObject * pObject,
    OUT BSTR            * pbstrMsg
    )const
{
    HRESULT hr = WBEM_S_FALSE;

    if (pbstrMsg == NULL || pObject == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pbstrMsg = NULL;

    //
    // vecNameData will hold each member's formatted string. This is more efficient than appending (n-square).
    //

    std::vector<LPWSTR> vecNameData;
    DWORD dwTotalLength = 0;

    //
    // go through all of the class's properties (not those in base class)
    //

    hr = pObject->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY);

    while (SUCCEEDED(hr))
    {
        CComBSTR bstrName;
        CComVariant varValue;
        hr = pObject->Next(0, &bstrName, &varValue, NULL, NULL);
        if (FAILED(hr) || WBEM_S_NO_MORE_DATA == hr)
        {
            break;
        }

        CComBSTR bstrData;

        //
        // in case the data is not present
        //

        if (varValue.vt == VT_EMPTY || varValue.vt == VT_NULL)
        {
            bstrData = L"<NULL>";
        }
        else
        {
            hr = ::FormatVariant(&varValue, &bstrData);
        }

        //
        // format the (name, data) in the name = data fashion.
        //

        if (SUCCEEDED(hr))
        {
            //
            // 1 for '=', and 1 for '\0'
            //

            DWORD dwSize = wcslen(bstrName) + 1 + wcslen(bstrData) + 1;
            LPWSTR pszMsg = new WCHAR[dwSize];

            if (pszMsg != NULL)
            {
                _snwprintf(pszMsg, dwSize, L"%s=%s", (LPCWSTR)bstrName, (LPCWSTR)bstrData);

                //
                // vector takes care of this memory
                //

                vecNameData.push_back(pszMsg);

                //
                // accumulating the total length
                //

                dwTotalLength += dwSize - 1;
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    pObject->EndEnumeration();


    //
    // put all those in the output bstr
    //

    DWORD dwSize = vecNameData.size();

    if (dwSize > 0)
    {
        //
        // each 2 for ", " between properties, 1 for the '\0'
        //

        *pbstrMsg = ::SysAllocStringLen(NULL, (2 * dwSize) + dwTotalLength + 1);

        //
        // running point for writing
        //

        LPWSTR pszCur = *pbstrMsg;
        DWORD dwIndex = 0;

        //
        // for each item in the vector, we need to copy it to the running point for writing
        //

        if (*pbstrMsg != NULL)
        {
            for (dwIndex = 0; dwIndex < dwSize; ++dwIndex)
            {
                //
                // put the name. Our buffer size makes sure that we won't overrun buffer.
                //

                wcscpy(pszCur, vecNameData[dwIndex]);

                //
                // moving the running point for writing
                //

                pszCur += wcslen(vecNameData[dwIndex]);

                if (dwIndex < dwSize - 1)
                {
                    wcscpy(pszCur, L", ");
                    pszCur += 2;
                }
                else if (dwIndex == dwSize - 1)
                {
                    wcscpy(pszCur, L". ");
                    pszCur += 2;
                }
            }

            //
            // done. So 0 terminate it!
            //

            *pszCur = L'\0';
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        //
        // now, clean up the memory
        //

        for (dwIndex = 0; dwIndex < dwSize; ++dwIndex)
        {
            delete [] vecNameData[dwIndex];
        }
    }

    return (*pbstrMsg != NULL) ? WBEM_NO_ERROR : hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\extbase.h ===
// extbase.h: implementation of link and embed foreign objects in SCE store
// Copyright (c)1997-2001 Microsoft Corporation
//
// this is the extension model base (hence the name)
//////////////////////////////////////////////////////////////////////
#if !defined(AFX_EXTBASE_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_EXTBASE_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

//
// forward declaration
//

class CPropValuePair;

//
// For quick lookup of embedding class's foreign class information
// by the embedding class's name we use a map.
//

typedef std::map<BSTR, CForeignClassInfo*, strLessThan<BSTR> > MapExtClasses;
typedef MapExtClasses::iterator ExtClassIterator;

//=============================================================================

/*

Class description
    
    Naming: 
         CExtClasses stands Extension Classes.
    
    Base class: 
         None.
    
    Purpose of class:
        (1) This class is to provide, for each embedding class, the foreign class' information.
            A foreign class is one that is provided by other WMI providers. Normally, we don't
            have any control over it. For example, we can't force it to be saved in a store for
            later use.

            We invented the notation called Embedding so that we can store foreign class instances
            in our SCE store and later knows how to use it.

            For each foreign class that SCE wants to use, SCE will have a embedding class derived
            from WMI class Sce_EmbedFO (stands for Embedding Foreign Object). See sceprov.mof for
            its schema.

            We need a global map that maps our embedding class' name to the foreign class'
            information. This is the task of this class.
    
    Design:
        (1) For quick name to Foreign Class Info lookup, we use a map: m_mapExtClasses.

        (2) Populating all such embedding class's foreign information is costly. We delay that loading
            until the need for embedding classes arrives. For that we use m_bPopulated. Once this
            is populated, we no longer populate again. For that reasons, if you register more embedding
            classes, you need to make sure that our dll is unloaded so that we can populate again.
            $consider: should we change this behavior?

        (3) GetForeignClassInfo is all it takes to find the embedding class' foreign class information.
    
    Use:
        (1) Create an instance of this class.
        (2) Call GetForeignClassInfo when you need a foreign class information.

*/

class CExtClasses
{
public:

    CExtClasses();

    ~CExtClasses();

    const CForeignClassInfo* GetForeignClassInfo (
                                                 IWbemServices* pNamespace, 
                                                 IWbemContext* pCtx, 
                                                 BSTR pszEmbedClassName
                                                 );

private:

    HRESULT PopulateExtensionClasses (
                                     IWbemServices* pNamespace, 
                                     IWbemContext* pCtx
                                     );

    HRESULT PutExtendedClass (
                             BSTR pszSubClassName, 
                             CForeignClassInfo* pFCI
                             );

    HRESULT GetSubclasses (
                          IWbemServices* pNamespace, 
                          IWbemContext* pCtx, 
                          IEnumWbemClassObject* pEnumObj, 
                          EnumExtClassType dwClassType
                          );

    HRESULT PopulateKeyPropertyNames (
                                     IWbemServices* pNamespace, 
                                     IWbemContext* pCtx, 
                                     BSTR bstrClassName, 
                                     CForeignClassInfo* pNewSubclass
                                     );
    
    MapExtClasses m_mapExtClasses;

    bool m_bPopulated;
};

extern CExtClasses g_ExtClasses;

//=============================================================================

/*

Class description
    
    Naming: 
         CSceExtBaseObject stands Sce Extension Base Object.
    
    Base class: 
         (1) CComObjectRootEx for threading model and IUnknown.
         (2) ISceClassObject our interface for auto persistence (that IScePersistMgr uses)
    
    Purpose of class:
        (1) This is our implementation of ISceClassObject. Our embedding classes uses this
            for IScePersistMgr's persistence. We no longer needs to write persistence functionality
            like what we do for all the core object. For embedding classes, this class together with
            CScePersistMgr takes care of support for persistence.
    
    Design:
        (1) This is not a directly instantiatable class. See the constructor and destructor, they are
            both protected. See Use section for creation steps.

        (2) This is not an externally createable class. It's for internal use. No class factory support
            is given.
    
    Use:
        (1) Create an instance of this class. Since it's not a directly instantiatable class, you need
            to use CComObject<CSceExtBaseObject> for creation:

                CComObject<CSceExtBaseObject> *pSceObject = NULL;
                hr = CComObject<CSceExtBaseObject>::CreateInstance(&pSceObject);

        (2) Call PopulateProperties. This populate the ourselves.
        
        (3) Since what this class is good at is to provide ISceClassObject.  So you normally
            QueryInterface for ISceClassObject.

        (4) After you get the ISceClassObject interface pointer, you attach (Attach) the Wbem object
            to this object. Since we managed WMI object's persistence in sce store, there must be an
            wbem object you need to persist. That is how you do it.

        (5) Since the sole purpose of this class is for IScePersistMgr to use it for retrieving data,
            you normally has a IScePersistMgr object waiting for this object. Once we have done the
            three steps above, you can finally satisfy IScePersistMgr by attaching this object to the
            IScePersistMgr.

            Everything happens automatically.

        See CEmbedForeignObj::CreateScePersistMgr for sample code.

*/

class ATL_NO_VTABLE CSceExtBaseObject :
    public CComObjectRootEx<CComMultiThreadModel>,
    public ISceClassObject
{

protected:
    CSceExtBaseObject();
    virtual ~CSceExtBaseObject();

public:

//
// ISceClassObject is the only interface we support, well besides IUnknown.
//

BEGIN_COM_MAP(CSceExtBaseObject)
    COM_INTERFACE_ENTRY(ISceClassObject)
END_COM_MAP()

//
// we allow this to be aggregated
//

DECLARE_NOT_AGGREGATABLE( CSceExtBaseObject )

//
// though we don't have registry resource, ATL requires this macro. No harm.
//

DECLARE_REGISTRY_RESOURCEID(IDR_SceProv)


    //
    // ISceClassObject methods
    //

    STDMETHOD(GetPersistPath) (
                              BSTR* pbstrPath         // [out] 
                              );

    STDMETHOD(GetClassName) (
                            BSTR* pbstrClassName    // [out] 
                            );

    STDMETHOD(GetLogPath) (
                          BSTR* pbstrPath         // [out] 
                          );

    STDMETHOD(Validate)();
    
    STDMETHOD(GetProperty) (
                           LPCWSTR pszPropName,    // [in, string] 
                           VARIANT* pValue         // [in] 
                           );

    STDMETHOD(GetPropertyCount) (
                                SceObjectPropertyType type, // [in] 
                                DWORD* pCount               // [out] 
                                );

    STDMETHOD(GetPropertyValue) (
                                SceObjectPropertyType type, // [in] 
                                DWORD dwIndex,              // [in] 
                                BSTR* pbstrPropName,        // [out] 
                                VARIANT* pValue             // [out] 
                                );

    STDMETHOD(Attach) (
                       IWbemClassObject* pInst     // [in]
                       );

    STDMETHOD(GetClassObject) (
                              IWbemClassObject** ppInst   //[out] 
                              );

    void CleanUp();

    HRESULT PopulateProperties (
                                ISceKeyChain *pKeyChain, 
                                IWbemServices *pNamespace, 
                                IWbemContext *pCtx, 
                                const CForeignClassInfo* pClsInfo
                                );

private:

    enum GetIndexFlags
    {
        GIF_Keys    = 0x00000001,
        GIF_NonKeys = 0x00000002,
        GIF_Both    = 0x00000003,
    };

    int GetIndex(LPCWSTR pszName, GetIndexFlags fKey);
    
    const CForeignClassInfo* m_pClsInfo;

    std::vector<BSTR> m_vecKeyProps;
    std::vector<BSTR> m_vecNonKeyProps;
    
    std::vector<VARIANT*> m_vecKeyValues;
    std::vector<VARIANT*> m_vecPropValues;
    
    CComPtr<ISceKeyChain> m_srpKeyChain;

    CComPtr<IWbemServices> m_srpNamespace; 

    CComPtr<IWbemContext> m_srpCtx;

    CComPtr<IWbemClassObject> m_srpWbemObject;
    
    CComBSTR m_bstrLogPath;
    
    CComBSTR m_bstrClassName;
};

//=============================================================================

/*

Class description
    
    Naming: 
         CEmbedForeignObj stands Sce Embed Foreign Object.
    
    Base class: 
         CGenericClass since this class will be persisted. It is representing any sub-classes of Sce_EmbedFO.
    
    Purpose of class:
        (1) This is our implementation of the embedding model for open extension architecture.
    
    Design:
        (1) It knows how to PutInst, how to CreateObject (for querying, enumerating, deleting, getting 
            single instance, etc), and most importantly, it knows how to execute a method, abeit it 
            uses CExtClassMethodCaller.

        (2) It knows how to create a persistence manager for its persistence needs.

        (3) In order to use the persistence manager, it must knows how to create a ISceClassObject
            representing this object.
    
    Use:
        (1) You will not create this your own. Everything is handled by CRequestObject via the
            interface of CGenericClass. This is just a CGenericClass.

*/

class CEmbedForeignObj : public CGenericClass
{

public:
    CEmbedForeignObj (
                     ISceKeyChain *pKeyChain, 
                     IWbemServices *pNamespace, 
                     IWbemContext *pCtx, 
                     const CForeignClassInfo* pClsInfo
                     );

    virtual ~CEmbedForeignObj();

public:

    virtual HRESULT PutInst (
                            IWbemClassObject *pInst, 
                            IWbemObjectSink *pHandler, 
                            IWbemContext *pCtx
                            );

    virtual HRESULT CreateObject (
                                 IWbemObjectSink *pHandler, 
                                 ACTIONTYPE atAction
                                 );

    virtual HRESULT ExecMethod (
                               BSTR bstrPath, 
                               BSTR bstrMethod, 
                               bool bIsInstance, 
                               IWbemClassObject *pInParams,
                               IWbemObjectSink *pHandler, 
                               IWbemContext *pCtx
                               );

private:
    HRESULT CreateBaseObject (
                             ISceClassObject** ppObj
                             );

    HRESULT CreateScePersistMgr (
                                IWbemClassObject *pInst, 
                                IScePersistMgr** ppPersistMgr
                                );
    
    const CForeignClassInfo* m_pClsInfo;
};

//=============================================================================

/*

Class description
    
    Naming: 
         CMethodResultRecorder stands Method call Results Recorder.
    
    Base class: 
        None.
    
    Purpose of class:
        (1) Make logging method call results easy. Logging a result is a compliated and repeatitive work.
            This class hides all the details of creating those WMI objects for logging, etc.
    
    Design:
        (1) Just two functions to make it extremely simple to use.
    
    Use:
        (1) Create an instance.
        (2) Call Initialize. You can actually call this multiple times to switch the context.
        (3) Call LogResult when you need to push the information to the log file.

*/

class CMethodResultRecorder
{

public:

    CMethodResultRecorder ();

    HRESULT Initialize (
                       LPCWSTR pszLogFilePath, 
                       LPCWSTR pszClassName, 
                       IWbemServices *pNativeNS, 
                       IWbemContext *pCtx
                       );

    HRESULT LogResult (
                      HRESULT hrResult,            // [in]
                      IWbemClassObject *pObj,      // [in]
                      IWbemClassObject *pParam,    // [in]
                      IWbemClassObject *pOutParam, // [in]
                      LPCWSTR pszMethod,           // [in]
                      LPCWSTR pszForeignAction,    // [in]
                      UINT uMsgResID,              // [in]
                      LPCWSTR pszExtraInfo         // [in]
                      )const;
private:

    HRESULT FormatVerboseMsg (
                             IWbemClassObject *pObject,     // [in]
                             BSTR* pbstrMsg                 // [out]
                             )const;

    CComBSTR m_bstrLogFilePath;
    CComBSTR m_bstrClassName;

    CComPtr<IWbemContext> m_srpCtx;
    CComPtr<IWbemServices> m_srpNativeNS;
};

//=============================================================================

/*

Class description
    
    Naming: 
        CExtClassMethodCaller stands for Extension Class Method Caller.
    
    Base class: 
        None.
    
    Purpose of class:
        Help to make executing a method on foreign objects easy. It works with CMethodResultRecorder.
    
    Design:
        (1) Just two functions to make it extremely simple to use.
    
    Use:
        (1) Create an instance.
        (2) Call Initialize. You can actually call this multiple times to switch the context.
        (3) Call LogResult when you need to push the information to the log file.

*/

class CExtClassMethodCaller
{
public:
    CExtClassMethodCaller (
                          ISceClassObject* pSceClassObj, 
                          const CForeignClassInfo* pClsInfo
                          );

    ~CExtClassMethodCaller ();

    HRESULT Initialize (
                       CMethodResultRecorder* pLog
                       );

    HRESULT ExecuteForeignMethod (
                                 LPCWSTR              pszMethod,
                                 IWbemClassObject   * pInParams,
                                 IWbemObjectSink    * pHandler,
                                 IWbemContext       * pCtx,
                                 IWbemClassObject  ** ppOut
                                 );

private:

    HRESULT ParseMethodEncodingString (
                                      LPCWSTR pszEncodeString, 
                                      DWORD* pdwContext, 
                                      BSTR* pbstrError
                                      );

    HRESULT BuildMethodContext (
                               LPCWSTR szMethodName, 
                               LPCWSTR szParameter, 
                               BSTR* pbstrError
                               );

    HRESULT PopulateForeignObject (
                                  IWbemClassObject* pForeignObj, 
                                  ISceClassObject* pSceObject, 
                                  CMethodResultRecorder* LogRecord
                                  )const;
    
    bool IsMemberParameter (
                           LPCWSTR szName
                           )const;

    bool IsInComingParameter (
                             LPCWSTR szName
                             )const;

    bool IsStaticMethod (
                        LPCWSTR szName
                        )const;

    void FormatSyntaxError (
                           WCHAR wchMissChar,
                           DWORD dwMissCharIndex,
                           LPCWSTR pszEncodeString,    // [in]
                           BSTR* pbstrError            // [out]
                           );
    
    CComPtr<ISceClassObject> m_srpSceObject;

    CComPtr<IWbemServices> m_srpForeignNamespace;

    CComPtr<IWbemClassObject> m_srpClass;
    
    const CForeignClassInfo* m_pClsInfo;
    
    //
    // CMethodContext is internal class just to make resource management easy.
    // It manages the method call context - its parameters and the method name.
    //

    class CMethodContext
    {
    public:
        CMethodContext();
        ~CMethodContext();
        LPWSTR m_pszMethodName;
        std::vector<VARIANT*> m_vecParamValues;
        std::vector<LPWSTR> m_vecParamNames;
    };
    
    std::vector<CMethodContext*> m_vecMethodContext;

    typedef std::vector<CMethodContext*>::iterator MCIterator;

    CMethodResultRecorder* m_pLogRecord;

    bool m_bStaticCall;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\eventlog.h ===
// eventlog.h: interface for the CEventLogSettings class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_EVENTLOG_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_EVENTLOG_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

/*

Class description
    
    Naming: 

        CEventLogSettings.
    
    Base class: 

        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_EventLog
        
    Purpose of class:
    
        (1) Implement Sce_EventLog WMI class.
    
    Design:
         
        (1) Almost trivial other than implementing necessary method as a concrete class
    
    Use:
        (1) Almost never used directly. Always through the common interface defined by
            CGenericClass.
    
*/

class CEventLogSettings : public CGenericClass
{
public:
        CEventLogSettings (
                           ISceKeyChain *pKeyChain, 
                           IWbemServices *pNamespace, 
                           IWbemContext *pCtx = NULL
                           );

        virtual ~CEventLogSettings ();

        virtual HRESULT PutInst (
                                 IWbemClassObject *pInst, 
                                 IWbemObjectSink *pHandler, 
                                 IWbemContext *pCtx
                                 );

        virtual HRESULT CreateObject (
                                      IWbemObjectSink *pHandler, 
                                      ACTIONTYPE atAction
                                      );

private:

        HRESULT ConstructInstance (
                                   IWbemObjectSink *pHandler, 
                                   CSceStore* pSceStore, 
                                   LPCWSTR wszLogStorePath, 
                                   LPCWSTR wszLogType, 
                                   BOOL bPostFilter 
                                   );

        HRESULT DeleteInstance (
                                IWbemObjectSink *pHandler, 
                                CSceStore* pSceStore, 
                                LPCWSTR wszLogType 
                                );

        HRESULT ValidateEventlogType (
                                      LPCWSTR wszLogType, 
                                      DWORD *pIndex
                                      );

        HRESULT SaveSettingsToStore (
                                     CSceStore* pScePersist, 
                                     LPCWSTR Section,
                                     DWORD dwSize, 
                                     DWORD dwRet, 
                                     DWORD dwDays, 
                                     DWORD dwRestrict
                                     );

};

PCWSTR GetEventLogType (DWORD idx);

#endif // !defined(AFX_EVENTLOG_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\genericclass.cpp ===
// GenericClass.cpp: implementation of the CGenericClass class.
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"

#include "GenericClass.h"
#include "persistmgr.h"
#include <wininet.h>

#define   READ_HANDLE 0
#define   WRITE_HANDLE 1

/*
Routine Description: 

Name:

    CGenericClass::CGenericClass

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you add more members, think about initialize them here

*/

CGenericClass::CGenericClass (
    IN ISceKeyChain     * pKeyChain, 
    IN IWbemServices    * pNamespace, 
    IN IWbemContext     * pCtx
    )
    : 
    m_srpKeyChain(pKeyChain), 
    m_srpNamespace(pNamespace), 
    m_srpCtx(pCtx)
{
}

/*
Routine Description: 

Name:

    CGenericClass::~CGenericClass

Functionality:
    
    Destructor. Good C++ discipline requires this to be virtual.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you add more members, think about whether
    there is any need for a non-trivial destructor

*/

CGenericClass::~CGenericClass()
{
    CleanUp();
}

/*
Routine Description: 

Name:

    CGenericClass::CleanUp

Functionality:
    
    Destructor. Good C++ discipline requires this to be virtual.

Virtual:
    
    Yes.
    
Arguments:

    none.

Return Value:

    None.

Notes:
    if you add more members, think about whether
    there is any need for a non-trivial destructor

*/

void CGenericClass::CleanUp()
{
    //
    // Please note: CComPtr<XXX>.Release is a different function, rather than
    // delegating to the wrapped pointer. Basically, this does a Release call
    // to the wrapped pointer if it is non NULL and then set the wrapped pointer
    // to NULL. So, don't replace these CComPtr<XXX>.Release with
    // CComPtr<XXX>->Release. That will be a big mistake.
    //

    //
    // Read ReadMe.doc for information regarding releasing CComPtr<XXX>.
    //

    m_srpNamespace.Release();
    m_srpClassForSpawning.Release();
    m_srpCtx.Release();
    m_srpKeyChain.Release();
}

/*
Routine Description: 

Name:

    CGenericClass::SpawnAnInstance

Functionality:
    
    Creating a WMI class instance is a two step process. 
        (1) First, we must get the class definition. That is done by m_srpNamespace->GetObject.
        (2) Secondly, we Spawn an instance.
    
    Object (IWbemClassObject) pointers created in this fashion can be used to fill in
    properties. Object pointers returned by m_srpNamespace->GetObject can NOT be used to
    fill in properties. That is the major reason why we need this function.


Virtual:
    
    No.
    
Arguments:

    none.

Return Value:

    None.

Notes:

*/

HRESULT 
CGenericClass::SpawnAnInstance (
    OUT IWbemClassObject **ppObj
    )
{
    if (ppObj == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if (m_srpKeyChain == NULL)
    {
        return WBEM_E_INVALID_OBJECT;
    }

    *ppObj = NULL;

    HRESULT hr = WBEM_NO_ERROR;

    //
    // Need ask WMI for the class definition so that we can spawn an instance of it.
    //

    if (!m_srpClassForSpawning)
    {
        CComBSTR bstrClassName;

        //
        // must return success code if something is got.
        //

        hr = m_srpKeyChain->GetClassName(&bstrClassName);

        if (SUCCEEDED(hr))
        {
            hr = m_srpNamespace->GetObject(bstrClassName, 0, m_srpCtx, &m_srpClassForSpawning, NULL);
        }
    }

    //
    // Now, let's spawn one that can be used to fill in properties.
    // This instance will be blank except those with default values. All properties
    // with default values are properly filled up with a spawned instance.
    //

    if (SUCCEEDED(hr))
    {
        hr = m_srpClassForSpawning->SpawnInstance(0, ppObj);
    }

    return hr;
}

/*
Routine Description: 

Name:

    ProvSceStatusToDosError

Functionality:
    
    converts SCESTATUS error code to dos error defined in winerror.h

Virtual:
    
    No.
    
Arguments:

    none.

Return Value:

    None.

Notes:

*/

DWORD
ProvSceStatusToDosError (
    IN SCESTATUS SceStatus
    )
{
    switch(SceStatus) {

    case SCESTATUS_SUCCESS:
        return(NO_ERROR);

    case SCESTATUS_OTHER_ERROR:
        return(ERROR_EXTENDED_ERROR);

    case SCESTATUS_INVALID_PARAMETER:
        return(ERROR_INVALID_PARAMETER);

    case SCESTATUS_RECORD_NOT_FOUND:
        return(ERROR_NO_MORE_ITEMS);

    case SCESTATUS_NO_MAPPING:
        return(ERROR_NONE_MAPPED);

    case SCESTATUS_TRUST_FAIL:
        return(ERROR_TRUSTED_DOMAIN_FAILURE);

    case SCESTATUS_INVALID_DATA:
        return(ERROR_INVALID_DATA);

    case SCESTATUS_OBJECT_EXIST:
        return(ERROR_FILE_EXISTS);

    case SCESTATUS_BUFFER_TOO_SMALL:
        return(ERROR_INSUFFICIENT_BUFFER);

    case SCESTATUS_PROFILE_NOT_FOUND:
        return(ERROR_FILE_NOT_FOUND);

    case SCESTATUS_BAD_FORMAT:
        return(ERROR_BAD_FORMAT);

    case SCESTATUS_NOT_ENOUGH_RESOURCE:
        return(ERROR_NOT_ENOUGH_MEMORY);

    case SCESTATUS_ACCESS_DENIED:
        return(ERROR_ACCESS_DENIED);

    case SCESTATUS_CANT_DELETE:
        return(ERROR_CURRENT_DIRECTORY);

    case SCESTATUS_PREFIX_OVERFLOW:
        return(ERROR_BUFFER_OVERFLOW);

    case SCESTATUS_ALREADY_RUNNING:
        return(ERROR_SERVICE_ALREADY_RUNNING);
    case SCESTATUS_SERVICE_NOT_SUPPORT:
        return(ERROR_NOT_SUPPORTED);

    case SCESTATUS_MOD_NOT_FOUND:
        return(ERROR_MOD_NOT_FOUND);

    case SCESTATUS_EXCEPTION_IN_SERVER:
        return(ERROR_EXCEPTION_IN_SERVICE);

    default:
        return(ERROR_EXTENDED_ERROR);
    }
}


/*
Routine Description: 

Name:

    ProvDosErrorToWbemError

Functionality:
    
    converts SCESTATUS error code to dos error defined in winerror.h

Virtual:
    
    No.
    
Arguments:

    none.

Return Value:

    None.

Notes:

*/

HRESULT
ProvDosErrorToWbemError(
    IN DWORD rc
    )
{
    switch(rc) {

    case NO_ERROR:
        return(WBEM_S_NO_ERROR);

    case ERROR_INVALID_PARAMETER:
        return(WBEM_E_INVALID_PARAMETER);

    case ERROR_NO_MORE_ITEMS:
    case ERROR_NONE_MAPPED:
    case ERROR_FILE_NOT_FOUND:
    case ERROR_MOD_NOT_FOUND:
        return(WBEM_E_NOT_FOUND);

    case ERROR_INVALID_DATA:
    case ERROR_BAD_FORMAT:
        return(WBEM_E_INVALID_CONTEXT);

    case ERROR_FILE_EXISTS:
    case ERROR_SERVICE_ALREADY_RUNNING:
        return(WBEM_S_ALREADY_EXISTS);

    case ERROR_INSUFFICIENT_BUFFER:
        return(WBEM_E_BUFFER_TOO_SMALL);

    case ERROR_NOT_ENOUGH_MEMORY:
        return(WBEM_E_OUT_OF_MEMORY);

    case ERROR_ACCESS_DENIED:
        return(WBEM_E_ACCESS_DENIED);

    case ERROR_BUFFER_OVERFLOW:
        return(WBEM_E_QUEUE_OVERFLOW);

    case ERROR_NOT_SUPPORTED:
        return(WBEM_E_NOT_SUPPORTED);

    default:
        return(WBEM_E_FAILED);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\genericclass.h ===
// GenericClass.h: interface for the CGenericClass class.
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GENERICCLASS_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_GENERICCLASS_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <ntsecapi.h>
#include <secedit.h>
//#include "sceprov.h"

const AREA_INFORMATION AreaBogus = 0x80000000L;

//
// forward declarations of the classes used in the parameters of the functions
//

class CScePropertyMgr;
class CSceStore;

/*

Class description
    
    Naming: 
         CGenericClass. This is the base class implementation for for all SCE's WMI classes.
    
    Base class: 
         None
    
    Purpose of class:
        (1) defines the interface for CRequestObject class to respond to all WMI access to our 
            provider. Our provider architecture is pretty much a delegation the WMI request to
            CRequestObject, where the request is translated into a particular class's function
            call. The CRequestObject uses the WMI class name information to create the
            appropriate C++ classes who all share this CGenericClass's interface (the set of
            virtual functions defined in this class). So this class pretty much is what 
            CRequestObject uses to fulfill the the provider's request.
    
    Design:
        (1) To satisfy PutInstance request, it has a PutInst pure virtual function.
        
        (2) To satisfy GetInstance/QueryInstance/DeleteInstance/EnumerateInstance request,
            it has a CreateObject pure virtual function. The parameter atAction tells apart
            what is truly being requested. This was closely tied to the legacy INF persistence
            model where every Get/Query/Del/Enum action is really being done in the same
            fashion. Since it works, we opt to keep it this way for the time being.
        
        (3) To facilitate a uniform clean up, it has a CleanUp virtual function.
        
        (4) To satisfy ExecMethod request for those classes that support method execution, it
            has a ExecMethod function.
        
        (5) To ease the creation of a blank instance that can be used to fill in properties,
            We have a function SpawnAnInstance. m_srpClassForSpawning is the object pointer
            that can be used repeatedly to spawn. This will have a performance gain for cases
            where a lot number of instances needs to be spawned.
        
        (6) We cache the namespace this object belongs to by m_srpNamespace.
        
        (7) We cache the IWbemContext pointer by m_srpCtx. WMI is not clear about this pointer
            yet. But it says that we should expect WMI to require this pointer in many of their
            API's (which currently can happily take a NULL).
        
        (8) We cache all parsed information into m_srpKeyChain. Since all WMI request comes into
            our provider in the form of some text that must be interpreted, we must have parsed
            WMI requests before the request is translated into a per-class function call. All
            these parsing results are encapulated by ISceKeyChain.
    
    Use:
        (1) Derive your class from this class.
        
        (2) Implement those pure virtual functions.
        
        (3) If you have a particular need for clean up, override the CleanUp function and at the end
            of your override, call the base class version as well.
        
        (4) If you need to implement method execution, override ExecMethod function to your desire.
            Don't forget to register a method for the WMI class inside the MOF file (see Sce_Operation)
            for example.
        
        (5) In CRequestObject::CreateClass, put an entry for your class.
        
        Once you have done all the above steps, you have implemented all necessary steps for a new
        WMI class for this provider. Don't forget to update your MOF and compile the mof file.
*/

class CGenericClass
{
public:
    CGenericClass (
                   ISceKeyChain *pKeyChain, 
                   IWbemServices *pNamespace, 
                   IWbemContext *pCtx = NULL
                   );

    virtual ~CGenericClass();

    //
    // Pure virtual. sub-class must implement this function to be concreate.
    //

    virtual HRESULT PutInst (
                             IWbemClassObject *pInst, 
                             IWbemObjectSink *pHandler, 
                             IWbemContext *pCtx
                             )  = 0;

    //
    // Pure virtual. sub-class must implement this function to be concreate.
    //

    virtual HRESULT CreateObject (
                                  IWbemObjectSink *pHandler, 
                                  ACTIONTYPE atAction
                                  ) = 0;

    //
    // virtual. sub-class may override this function to be support method execution.
    //

    virtual HRESULT ExecMethod (
                                BSTR bstrPath, 
                                BSTR bstrMethod, 
                                bool bIsInstance, 
                                IWbemClassObject *pInParams,
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    virtual void CleanUp ();

protected:

    HRESULT SpawnAnInstance (
                             IWbemClassObject **pObj
                             );

    CComPtr<IWbemServices> m_srpNamespace;

    CComPtr<IWbemClassObject> m_srpClassForSpawning;

    CComPtr<IWbemContext> m_srpCtx;
    
    CComPtr<ISceKeyChain> m_srpKeyChain;
};

//
// Translate SCE status into DOS errors
//

DWORD
ProvSceStatusToDosError(
    IN SCESTATUS SceStatus
    );

//
// Translate DOS errors into HRESULT
//

HRESULT
ProvDosErrorToWbemError(
    IN DWORD rc
    );

#endif // !defined(AFX_GENERICCLASS_H__F370C612_D96E_11D1_8B5D_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\group.h ===
// group.h: interface for the CRGroups class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GROUP_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_GROUP_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

/*

Class description
    
    Naming: 

        CRGroups stands for Restricted Groups.
    
    Base class: 

        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_RestrictedGroup
    
    Purpose of class:
    
        (1) Implement Sce_RestrictedGroup WMI class.
    
    Design:
         
        (1) Almost trivial other than implementing necessary method as a concrete class
    
    Use:
        (1) Almost never used directly. Always through the common interface defined by
            CGenericClass.
    
*/

class CRGroups : public CGenericClass
{
public:
        CRGroups (
                  ISceKeyChain *pKeyChain, 
                  IWbemServices *pNamespace, 
                  IWbemContext *pCtx = NULL
                  );

        virtual ~CRGroups ();

        virtual HRESULT PutInst (
                                 IWbemClassObject *pInst,
                                 IWbemObjectSink *pHandler, 
                                 IWbemContext *pCtx
                                 );

        virtual HRESULT CreateObject (
                                      IWbemObjectSink *pHandler, 
                                      ACTIONTYPE atAction
                                      );

private:

        HRESULT ConstructInstance (
                                   IWbemObjectSink *pHandler, 
                                   CSceStore* pSceStore, 
                                   LPCWSTR wszLogStorePath, 
                                   LPCWSTR wszGroupName, 
                                   BOOL bPostFilter );

        HRESULT DeleteInstance (
                                IWbemObjectSink *pHandler, 
                                CSceStore* pSceStore, 
                                LPCWSTR wszGroupName 
                                );

        HRESULT SaveSettingsToStore (
                                     CSceStore* pSceStore, 
                                     LPCWSTR wszGroupName, 
                                     DWORD mode, 
                                     PSCE_NAME_LIST pnlAdd, 
                                     PSCE_NAME_LIST pnlRemove
                                     );

};

#endif // !defined(AFX_GROUP_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\group.cpp ===
// group.cpp: implementation of the CRGroups class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "group.h"
#include "persistmgr.h"
#include <io.h>
#include "requestobject.h"

/*
Routine Description: 

Name:

    CRGroups::CRGroups

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CRGroups::CRGroups (
    IN ISceKeyChain     * pKeyChain, 
    IN IWbemServices    * pNamespace,
    IN IWbemContext     * pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{

}

/*
Routine Description: 

Name:

    CRGroups::~CRGroups

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/

CRGroups::~CRGroups ()
{
}

/*
Routine Description: 

Name:

    CRGroups::CreateObject

Functionality:
    
    Create WMI objects (Sce_RestrictedGroup). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT 
CRGroups::CreateObject (
    IN IWbemObjectSink * pHandler, 
    IN ACTIONTYPE        atAction
    )
{
    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Delete a single instance ACTIONTYPE_DELETE
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET != atAction &&
         ACTIONTYPE_DELETE != atAction &&
         ACTIONTYPE_QUERY != atAction ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // We must have the pStorePath property because that is where
    // our instance is stored. 
    // m_srpKeyChain->GetKeyPropertyValue WBEM_S_FALSE if the key is not recognized
    // So, we need to test against WBEM_S_FALSE if the property is mandatory
    //

    CComVariant varGroupName;
    CComVariant varStorePath;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(pStorePath, &varStorePath);

    if (SUCCEEDED(hr))
    {
        hr = m_srpKeyChain->GetKeyPropertyValue(pGroupName, &varGroupName);

        if (FAILED(hr))
        {
            return hr;
        }
        else if (hr == WBEM_S_FALSE && (ACTIONTYPE_QUERY != atAction) ) 
        {
            return WBEM_E_NOT_FOUND;
        }
    }
    else
    {
        return hr;
    }

    //
    // if we have a valid store path
    //

    if (varStorePath.vt == VT_BSTR) 
    {
        //
        // create a store with that path
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistPath(varStorePath.bstrVal);

        if ( SUCCEEDED(hr) ) 
        {

            //
            // make sure the store (just a file) really exists. The raw path
            // may contain env variables, so we need the expanded path
            //

            DWORD dwAttrib = GetFileAttributes(SceStore.GetExpandedPath());

            if ( dwAttrib != -1 ) 
            {
                //
                // Make sure that the store type matches
                //

                if ( SceStore.GetStoreType() < SCE_INF_FORMAT ||
                     SceStore.GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) 
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                }

                //
                // everything is ready. We will do a delete or construct depending on the action type.
                //

                if ( SUCCEEDED(hr) ) 
                {
                    if ( ACTIONTYPE_DELETE == atAction )
                    {
                        hr = DeleteInstance(pHandler, &SceStore, varGroupName.bstrVal);
                    }
                    else 
                    {
                        BOOL bPostFilter=TRUE;
                        DWORD dwCount = 0;
                        m_srpKeyChain->GetKeyPropertyCount(&dwCount);

                        if ( varGroupName.vt == VT_EMPTY && dwCount == 1 ) 
                        {
                            //
                            // it's a get single instance
                            //

                            bPostFilter = FALSE;
                        }

                        hr = ConstructInstance(pHandler, 
                                               &SceStore, 
                                               varStorePath.bstrVal,
                                               (varGroupName.vt == VT_BSTR) ? varGroupName.bstrVal : NULL,
                                               bPostFilter
                                               );
                    }
                }
            } 
            else 
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CRGroups::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_RestrictedGroup,
    which is persistence oriented, this will cause the Sce_RestrictedGroup object's property 
    information to be saved in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst       - COM interface pointer to the WMI class (Sce_RestrictedGroup) object.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

*/

HRESULT 
CRGroups::PutInst (
    IN IWbemClassObject    * pInst,
    IN IWbemObjectSink     * pHandler,
    IN IWbemContext        * pCtx
    )
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    CComBSTR bstrGroup;
    PSCE_NAME_LIST pnlAdd=NULL;
    DWORD mode;

    CSceStore SceStore;

    //
    // CScePropertyMgr helps us to access WMI object's properties
    // create an instance and attach the WMI object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pInst);

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    // get group name, can't be NULL
    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pGroupName, &bstrGroup));
    if ( hr == WBEM_S_RESET_TO_DEFAULT)
    {
        hr = WBEM_E_ILLEGAL_NULL;
        goto CleanUp;
    }

    // get mode, must be defined
    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pMode, &mode));
    if ( hr == WBEM_S_RESET_TO_DEFAULT)
    {
        hr = WBEM_E_ILLEGAL_NULL;
        goto CleanUp;
    }

    //
    // get AddList
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pAddList, &pnlAdd));

    //
    // ignore RemoveList for now (since we don't support the mode)
    //

    //
    // Attach the WMI object instance to the store and let the store know that
    // it's store is given by the pStorePath property of the instance.
    //

    SCE_PROV_IfErrorGotoCleanup(SceStore.SetPersistProperties(pInst, pStorePath));

    //
    // now save the info to file
    //

    hr = SaveSettingsToStore(&SceStore,
                              bstrGroup,
                              mode,
                              pnlAdd,
                              NULL
                              );

CleanUp:

    if ( pnlAdd )
    {
        SceFreeMemory(pnlAdd, SCE_STRUCT_NAME_LIST);
    }

    return hr;
}

/*
Routine Description: 

Name:

    CRGroups::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_RestrictedGroup.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszLogStorePath - store path, a key property of Sce_RestrictedGroup class.

    wszGroupName    - a corresponding key property of Sce_RestrictedGroup class.

    bPostFilter     - Controls how WMI will be informed with pHandler->SetStatus.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:

*/

HRESULT 
CRGroups::ConstructInstance (
    IN IWbemObjectSink * pHandler,
    IN CSceStore       * pSceStore,
    IN LPCWSTR           wszLogStorePath,
    IN LPCWSTR           wszGroupName       OPTIONAL,
    IN BOOL              bPostFilter
    )
{
    if (pSceStore == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // ask SCE to read a gigantic structure out from the store. Only SCE
    // knows now to release the memory. Don't just delete it! Use our CSceStore
    // to do the releasing (FreeSecurityProfileInfo)
    //

    PSCE_PROFILE_INFO pInfo=NULL;
    HRESULT hr = pSceStore->GetSecurityProfileInfo(
                                   AREA_GROUP_MEMBERSHIP,
                                   &pInfo,
                                   NULL
                                   );

    if (SUCCEEDED(hr))
    {
        //
        // we have to search for the user right name in the returned list
        //

        PSCE_GROUP_MEMBERSHIP pGroups = pInfo->pGroupMembership;

        if (wszGroupName)
        {
            //
            // for all the groups, copy the group names
            //

            while ( pGroups) 
            {
                if ( pGroups->GroupName == NULL ) 
                {
                    continue;
                }

                if ( _wcsicmp(pGroups->GroupName, wszGroupName)== 0 ) 
                {
                    break;
                }

                pGroups = pGroups->Next;
            }
        }

        PSCE_GROUP_MEMBERSHIP pTmpGrp = pGroups;

        //
        // if the Group information buffer is empty, treat it as "not found"
        //

        if ( pGroups == NULL ) 
        {
            hr = WBEM_E_NOT_FOUND;
            goto CleanUp;
        }

        //
        // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
        // a "goto CleanUp;" with hr set to the return value from
        // the function (macro parameter)
        //

        CComBSTR bstrLogOut;
        SCE_PROV_IfErrorGotoCleanup(MakeSingleBackSlashPath(wszLogStorePath, L'\\', &bstrLogOut));

        //
        // CScePropertyMgr helps us to access WMI object's properties.
        //

        CScePropertyMgr ScePropMgr;

        for ( ; pTmpGrp != NULL; pTmpGrp = pTmpGrp->Next ) 
        {
            CComPtr<IWbemClassObject> srpObj;
            SCE_PROV_IfErrorGotoCleanup(SpawnAnInstance(&srpObj));

            //
            // attach a different WMI object to the property mgr.
            // This will always succeed.
            //

            ScePropMgr.Attach(srpObj);

            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pStorePath, bstrLogOut));
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pGroupName, pTmpGrp->GroupName));

            //
            // hardcode the mode for now
            //

            DWORD mode = 1;
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pMode, mode));

            if ( pTmpGrp->pMembers )
            {
                SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pAddList, pTmpGrp->pMembers));
            }

            //
            // ignore RemoveList for now
            //

            //
            // do the necessary gestures to WMI.
            // the use of WBEM_STATUS_REQUIREMENTS in SetStatus is not documented by WMI
            // at this point. Consult WMI team for detail if you suspect problems with
            // the use of WBEM_STATUS_REQUIREMENTS
            //

            if ( !bPostFilter ) {
                pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_FALSE, NULL, NULL);
            } else {
                pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);
            }

            //
            // pass the new instance to WMI
            //

            hr = pHandler->Indicate(1, &srpObj);

            if ( wszGroupName ) 
            {
                //
                // get single instance only
                //

                break;
            }
        }
    }

CleanUp:
    pSceStore->FreeSecurityProfileInfo(pInfo);

    return hr;
}


/*
Routine Description: 

Name:

    CRGroups::DeleteInstance

Functionality:
    
    remove an instance of Sce_RestrictedGroup from the specified store.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszGroupName    - property of the Sce_RestrictedGroup class.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: WBEM_E_INVALID_PARAMETER.

Notes:

*/

HRESULT 
CRGroups::DeleteInstance (
    IN IWbemObjectSink *pHandler,
    IN CSceStore* pSceStore,
    IN LPCWSTR wszGroupName
    )
{
    if (pSceStore == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    pSceStore->DeleteSectionFromStore(wszGroupName);

    return WBEM_NO_ERROR;
}

/*
Routine Description: 

Name:

    CRGroups::SaveSettingsToStore

Functionality:
    
    With all the properties of a Sce_RestrictedGroup, this function just saves
    the instance properties to our store.

Virtual:
    
    No.
    
Arguments:

    pSceStore       - the store.

    wszGroupName    - a corresponding key property of Sce_RestrictedGroup class.

    mode            - another corresponding property of the Sce_RestrictedGroup class.

    pnlAdd          - another corresponding property of the Sce_RestrictedGroup class.

    pnlRemove       - another corresponding property of the Sce_RestrictedGroup class.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any error indicates the failure to save the instance.

Notes:
*/

HRESULT 
CRGroups::SaveSettingsToStore (
    IN CSceStore    * pSceStore,
    IN LPCWSTR        wszGroupName, 
    IN DWORD          mode,
    IN PSCE_NAME_LIST pnlAdd, 
    IN PSCE_NAME_LIST pnlRemove
    )
{
    DWORD dwDump;

    //
    // For a new .inf file. Write an empty buffer to the file
    // will creates the file with right header/signature/unicode format
    // this is harmless for existing files.
    // For database store, this is a no-op.
    //

    HRESULT hr = pSceStore->WriteSecurityProfileInfo(
                                                    AreaBogus, 
                                                    (PSCE_PROFILE_INFO)&dwDump, 
                                                    NULL,
                                                    false 
                                                    );
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // ask SCE to read a gigantic structure out from the store. Only SCE
    // knows now to release the memory. Don't just delete it! Use our CSceStore
    // to do the releasing (FreeSecurityProfileInfo)
    //

    PSCE_PROFILE_INFO pInfo=NULL;
    hr = pSceStore->GetSecurityProfileInfo(
                                   AREA_GROUP_MEMBERSHIP,
                                   &pInfo,
                                   NULL
                                   );

    if ( SUCCEEDED(hr) ) 
    {
        //
        // for INF format, we have to search for the servic name in the returned array
        //

        PSCE_GROUP_MEMBERSHIP pGroups= pInfo->pGroupMembership;
        PSCE_GROUP_MEMBERSHIP pParent=NULL;
        DWORD i=0;

        while ( pGroups ) 
        {
            if ( pGroups->GroupName == NULL ) 
            {
                continue;
            }

            if ( _wcsicmp(pGroups->GroupName, wszGroupName)== 0 ) 
            {
                break;
            }
            pParent = pGroups;
            pGroups = pGroups->Next;
        }

        if ( pGroups ) 
        {
            //
            // find it
            //

            if ( mode == SCE_NO_VALUE ) 
            {
                //
                // delete it
                //

                if ( pParent ) 
                {
                    pParent->Next = pGroups->Next;
                }
                else 
                {
                    pInfo->pGroupMembership = pGroups->Next;
                }

                //
                // the following worries me: where do we get the knowledge that we need to free this memory?
                // free buffer
                //

                pGroups->Next = NULL;
                SceFreeMemory(pGroups, SCE_STRUCT_GROUP);

            } 
            else 
            {
                //
                // modify it
                //
                
                //
                // the following worries me: where do we get the knowledge that we need to free this memory?
                //

                if ( pGroups->pMembers )
                {
                    SceFreeMemory(pGroups->pMembers, SCE_STRUCT_NAME_LIST);
                }

                pGroups->pMembers = pnlAdd;

            }

            if ( SUCCEEDED(hr) ) 
            {

                hr = pSceStore->WriteSecurityProfileInfo(
                                                         AREA_GROUP_MEMBERSHIP,
                                                         pInfo,
                                                         NULL,
                                                         false
                                                         );
            }

            if ( mode != SCE_NO_VALUE ) 
            {
                //
                // reset the buffer
                //

                pGroups->pMembers = NULL;
            }

        } 
        else 
        {
            //
            // not found
            //

            if ( mode == SCE_NO_VALUE ) 
            {
                //
                // try to delete non exist object
                //

                hr = WBEM_E_NOT_FOUND;

            } 
            else 
            {
                //
                // add this one in
                //

                SCE_GROUP_MEMBERSHIP addGroup;

                addGroup.GroupName = (PWSTR)wszGroupName;
                addGroup.pMembers = pnlAdd;
                addGroup.pMemberOf = NULL;
                addGroup.pPrivilegesHeld = NULL;
                addGroup.Status = 0;
                addGroup.Next = NULL;

                //
                // set the temp buffer pointer to pInfo to set to the store
                //

                pGroups = pInfo->pGroupMembership;
                pInfo->pGroupMembership = &addGroup;

                //
                // append this item to the section
                //

                hr = pSceStore->WriteSecurityProfileInfo(
                                                         AREA_GROUP_MEMBERSHIP,
                                                         pInfo,
                                                         NULL,
                                                         true
                                                         );

                //
                // reset the buffer pointer
                //

                pInfo->pGroupMembership = pGroups;
            }
        }
    }

    if (pInfo != NULL)
    {
        pSceStore->FreeSecurityProfileInfo(pInfo);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\kerberos.cpp ===
// kerberos.cpp: implementation of the CKerberosPolicy class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "kerberos.h"
#include "persistmgr.h"
#include <io.h>
#include "requestobject.h"

#define KeyTicket       L"MaxTicketAge"
#define KeyRenew        L"MaxRenewAge"
#define KeyService      L"MaxServiceAge"
#define KeyClock        L"MaxClockSkew"
#define KeyClient       L"TicketValidateClient"

/*
Routine Description: 

Name:

    CKerberosPolicy::CKerberosPolicy

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CKerberosPolicy::CKerberosPolicy (
    ISceKeyChain    * pKeyChain, 
    IWbemServices   * pNamespace,
    IWbemContext    * pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{

}

/*
Routine Description: 

Name:

    CKerberosPolicy::~CKerberosPolicy

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/
    
CKerberosPolicy::~CKerberosPolicy()
{
}

/*
Routine Description: 

Name:

    CKerberosPolicy::CreateObject

Functionality:
    
    Create WMI objects (Sce_KerberosPolicy). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler -  COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT 
CKerberosPolicy::CreateObject (
    IWbemObjectSink * pHandler, 
    ACTIONTYPE        atAction
    )
{
    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Delete a single instance ACTIONTYPE_DELETE
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET != atAction &&
         ACTIONTYPE_DELETE != atAction &&
         ACTIONTYPE_QUERY != atAction ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // We must have the pStorePath property because that is where
    // our instance is stored. 
    // m_srpKeyChain->GetKeyPropertyValue WBEM_S_FALSE if the key is not recognized
    // So, we need to test against WBEM_S_FALSE if the property is mandatory
    //

    CComVariant varStorePath;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(pStorePath, &varStorePath);

    if (SUCCEEDED(hr) && hr != WBEM_S_FALSE && varStorePath.vt == VT_BSTR)
    {
        //
        // create a store to do the reading
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistPath(varStorePath.bstrVal);

        if ( SUCCEEDED(hr) )
        {
            //
            // make sure the store (just a file) really exists. The raw path
            // may contain env variables, so we need the expanded path
            //

            DWORD dwAttrib = GetFileAttributes(SceStore.GetExpandedPath());

            if ( dwAttrib != -1 )
            {
                if (ACTIONTYPE_DELETE == atAction)
                {
                    hr = DeleteInstance(pHandler, &SceStore);
                }
                else
                {
                    hr = ConstructInstance(pHandler, &SceStore, varStorePath.bstrVal, atAction);
                }
            } 
            else 
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CKerberosPolicy::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_KerberosPolicy,
    which is persistence oriented, this will cause the Sce_KerberosPolicy object's property 
    information to be saved in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst - COM interface pointer to the WMI class (Sce_KerberosPolicy) object.

    pHandler - COM interface pointer for notifying WMI of any events.

    pCtx - COM interface pointer. This interface is just something we pass around.
            WMI may mandate it (not now) in the future. But we never construct
            such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

*/

HRESULT 
CKerberosPolicy::PutInst (
    IN IWbemClassObject * pInst, 
    IN IWbemObjectSink  * pHandler,
    IN IWbemContext     * pCtx
)
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;

    //
    // SCE_NO_VALUE means the property is not available from the instance.
    //

    DWORD dwTicket  = SCE_NO_VALUE;
    DWORD dwRenew   = SCE_NO_VALUE;
    DWORD dwService = SCE_NO_VALUE;
    DWORD dwClock   = SCE_NO_VALUE;
    DWORD dwClient  = SCE_NO_VALUE;

    //
    // CScePropertyMgr helps us to access WMI object's properties
    // create an instance and attach the WMI object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pInst);

    CSceStore SceStore;

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    //
    // in hours
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pMaxTicketAge, &dwTicket));

    //
    // in days
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pMaxRenewAge, &dwRenew));

    //
    // in minutes
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pMaxServiceAge, &dwService));

    //
    // dependency check
    //

    if ( dwTicket   != SCE_NO_VALUE && 
         dwRenew    != SCE_NO_VALUE &&
         dwService  != SCE_NO_VALUE ) 
    {
        //
        // dwRenew >= dwTicket
        // dwRenew > dwService
        // dwTicket > dwService
        //

        if ( dwService < 10 || dwService > 99999L   ||
            dwRenew == 0    || dwRenew > 99999L     ||
            dwTicket == 0   || dwTicket > 99999L    ) 
        {
            hr = WBEM_E_VALUE_OUT_OF_RANGE;
        } 
        else 
        {
            DWORD dHours = dwRenew * 24;

            if ( dHours < dwTicket ||
                 (dHours * 60) <= dwService ||
                 (dwTicket * 60) <= dwService ) 
            {
                hr = WBEM_E_VALUE_OUT_OF_RANGE;
            }
        }

    } 
    else if ( dwTicket  != SCE_NO_VALUE || 
              dwRenew   != SCE_NO_VALUE ||
              dwService != SCE_NO_VALUE ) 
    {
        hr = WBEM_E_ILLEGAL_NULL;
    }

    if ( FAILED(hr) ) 
    {
        goto CleanUp;
    }

    //
    // in minutes
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pMaxClockSkew, &dwClock));

    if ( dwClock != SCE_NO_VALUE && dwClock > 99999L ) 
    {
        hr = WBEM_E_VALUE_OUT_OF_RANGE;
        goto CleanUp;
    }

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pEnforceLogonRestrictions, &dwClient));
    
    //
    // Attach the WMI object instance to the store and let the store know that
    // it's store is given by the pStorePath property of the instance.
    //

    SCE_PROV_IfErrorGotoCleanup(SceStore.SetPersistProperties(pInst, pStorePath));

    //
    // now save the info to file
    //

    hr = SaveSettingsToStore(&SceStore,
                              dwTicket,
                              dwRenew,
                              dwService,
                              dwClock,
                              dwClient
                              );

CleanUp:
    return hr;

}

/*
Routine Description: 

Name:

    CKerberosPolicy::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_KerberosPolicy.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszLogStorePath - store path, a key property of Sce_KerberosPolicy class.

    atAction        - indicates whether it is querying or get single instance.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:

*/

HRESULT 
CKerberosPolicy::ConstructInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore,
    IN LPWSTR             wszLogStorePath,
    IN ACTIONTYPE         atAction
    )
{
    // 
    // make sure that we have a valid store
    //

    if ( pSceStore == NULL ||
         pSceStore->GetStoreType() < SCE_INF_FORMAT ||
         pSceStore->GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // ask SCE to read a gigantic structure out from the store. Only SCE
    // knows now to release the memory. Don't just delete it! Use our CSceStore
    // to do the releasing (FreeSecurityProfileInfo)
    //

    PSCE_PROFILE_INFO pInfo=NULL;
    HRESULT hr = pSceStore->GetSecurityProfileInfo(
                                                   AREA_SECURITY_POLICY,
                                                   &pInfo,
                                                   NULL
                                                   );

    if (SUCCEEDED(hr) && pInfo->pKerberosInfo == NULL)
    {
        hr = WBEM_E_NOT_FOUND;
    }

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    if (SUCCEEDED(hr))
    {

        CComPtr<IWbemClassObject> srpObj;

        CComBSTR bstrLogOut;
        LPCWSTR pszExpandedPath = pSceStore->GetExpandedPath();

        if ( ACTIONTYPE_QUERY == atAction ) 
        {
            SCE_PROV_IfErrorGotoCleanup(MakeSingleBackSlashPath(wszLogStorePath, L'\\', &bstrLogOut));
            pszExpandedPath = bstrLogOut;
        }

        SCE_PROV_IfErrorGotoCleanup(SpawnAnInstance(&srpObj));
        
        //
        // CScePropertyMgr helps us to access WMI object's properties
        // create an instance and attach the WMI object to it.
        // This will always succeed.
        //

        CScePropertyMgr ScePropMgr;
        ScePropMgr.Attach(srpObj);

        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pStorePath, pszExpandedPath));

        if (pInfo->pKerberosInfo->MaxTicketAge != SCE_NO_VALUE ) {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pMaxTicketAge, pInfo->pKerberosInfo->MaxTicketAge));
        }

        if (pInfo->pKerberosInfo->MaxRenewAge != SCE_NO_VALUE ) {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pMaxRenewAge, pInfo->pKerberosInfo->MaxRenewAge));
        }

        if (pInfo->pKerberosInfo->MaxServiceAge != SCE_NO_VALUE ) {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pMaxServiceAge, pInfo->pKerberosInfo->MaxServiceAge));
        }

        if (pInfo->pKerberosInfo->MaxClockSkew != SCE_NO_VALUE ) {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pMaxClockSkew, pInfo->pKerberosInfo->MaxClockSkew));
        }

        if (pInfo->pKerberosInfo->TicketValidateClient != SCE_NO_VALUE ) {
            bool bValue = pInfo->pKerberosInfo->TicketValidateClient ? TRUE : FALSE;
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pEnforceLogonRestrictions, bValue));
        }

        //
        // do the necessary gestures to WMI.
        // the use of WBEM_STATUS_REQUIREMENTS in SetStatus is not documented by WMI
        // at this point. Consult WMI team for detail if you suspect problems with
        // the use of WBEM_STATUS_REQUIREMENTS
        //

        if ( ACTIONTYPE_QUERY == atAction ) {
            pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_FALSE, NULL, NULL);
        } else {
            pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);
        }

        //
        // pass the new instance to WMI
        //

        hr = pHandler->Indicate(1, &srpObj);
    }

CleanUp:
    
    pSceStore->FreeSecurityProfileInfo(pInfo);

    return hr;
}

/*
Routine Description: 

Name:

    CKerberosPolicy::DeleteInstance

Functionality:
    
    remove an instance of Sce_KerberosPolicy from the specified store.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: WBEM_E_INVALID_PARAMETER.

Notes:

*/

HRESULT 
CKerberosPolicy::DeleteInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore
    )
{
    //
    // make sure we are given a valid store
    //

    if ( pSceStore == NULL ||
         pSceStore->GetStoreType() < SCE_INF_FORMAT ||
         pSceStore->GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    pSceStore->DeleteSectionFromStore(szKerberosPolicy);
    return WBEM_NO_ERROR;
}


/*
Routine Description: 

Name:

    CKerberosPolicy:SaveSettingsToStore

Functionality:
    
    With all the properties of a Sce_KerberosPolicy, this function just saves
    the instance properties to our store.

Virtual:
    
    No.
    
Arguments:

    pSceStore   - store path, a key property of Sce_KerberosPolicy class.

    dwTicket    - a corresponding key property of Sce_KerberosPolicy class.

    dwRenew     - another corresponding property of the Sce_KerberosPolicy class.

    dwService   - another corresponding property of the Sce_KerberosPolicy class.

    dwClock     - another corresponding property of the Sce_KerberosPolicy class.

    dwClient    - another corresponding property of the Sce_KerberosPolicy class.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any error indicates the failure to save the instance.

Notes:
*/

HRESULT 
CKerberosPolicy::SaveSettingsToStore (
    IN CSceStore  * pSceStore,
    IN DWORD        dwTicket, 
    IN DWORD        dwRenew, 
    IN DWORD        dwService,
    IN DWORD        dwClock, 
    IN DWORD        dwClient
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hrTmp;

    DWORD dwDump;

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    //
    // For a new .inf file. Write an empty buffer to the file
    // will creates the file with right header/signature/unicode format
    // this is harmless for existing files.
    // For database store, this is a no-op.
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->WriteSecurityProfileInfo(AreaBogus,
                                                                    (PSCE_PROFILE_INFO)&dwDump,
                                                                    NULL, 
                                                                    false
                                                                    )
                                );

    //
    // TicketAge
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(szKerberosPolicy, KeyTicket, dwTicket));

    //
    // RenewAge
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(szKerberosPolicy, KeyRenew, dwRenew));

    //
    // ServiceAge
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(szKerberosPolicy, KeyService, dwService));

    //
    // Clock Skew
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(szKerberosPolicy, KeyClock, dwClock));

    //
    // Validate client
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(szKerberosPolicy, KeyClient, dwClient));

CleanUp:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\kerberos.h ===
// kerberos.h: interface for the CKerberosPolicy class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_KERBEROS_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_KERBEROS_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

/*

Class description
    
    Naming: 
        
        CKerberosPolicy stands for Kerberos Policy.
    
    Base class: 

        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_KerberosPolicy
    
    Purpose of class:
    
        (1) Implement Sce_KerberosPolicy WMI class.
    
    Design:
         
        (1) Almost trivial other than implementing necessary method as a concrete class
    
    Use:

        (1) Almost never used directly. Always through the common interface defined by
            CGenericClass.
    
*/

class CKerberosPolicy : public CGenericClass
{
public:
        CKerberosPolicy (
                        ISceKeyChain *pKeyChain, 
                        IWbemServices *pNamespace, 
                        IWbemContext *pCtx = NULL
                        );

        virtual ~CKerberosPolicy();

        virtual HRESULT PutInst (
                                IWbemClassObject *pInst, 
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                );

        virtual HRESULT CreateObject (
                                     IWbemObjectSink *pHandler, 
                                     ACTIONTYPE atAction
                                     );

private:

        HRESULT ConstructInstance (
                                  IWbemObjectSink *pHandler,
                                  CSceStore* pSceStore,
                                  LPWSTR wszLogStorePath, 
                                  ACTIONTYPE atAction
                                  );

        HRESULT DeleteInstance (
                               IWbemObjectSink *pHandler, 
                               CSceStore* pSceStore
                               );
        
        HRESULT SaveSettingsToStore (
                                    CSceStore* pSceStore, 
                                    DWORD dwTicket, 
                                    DWORD dwRenew, 
                                    DWORD dwService,
                                    DWORD dwClock, 
                                    DWORD dwClient 
                                    );

};

#endif // !defined(AFX_KERBEROS_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\lockout.cpp ===
// lockout.cpp, implementation of CAccountLockout class
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "lockout.h"
#include "persistmgr.h"
#include <io.h>
#include "requestobject.h"

#define KeyThreshold    L"LockoutBadCount"
#define KeyReset        L"ResetLockoutCount"
#define KeyDuration     L"LockoutDuration"

/*
Routine Description: 

Name:

    CAccountLockout::CAccountLockout

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CAccountLockout::CAccountLockout (
    IN ISceKeyChain  * pKeyChain, 
    IN IWbemServices * pNamespace,
    IN IWbemContext  * pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{
}

/*
Routine Description: 

Name:

    CAccountLockout::~CAccountLockout

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/

CAccountLockout::~CAccountLockout ()
{
}

/*
Routine Description: 

Name:

    CAccountLockout::CreateObject

Functionality:
    
    Create WMI objects (Sce_AccountLockoutPolicy). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT 
CAccountLockout::CreateObject (
    IN IWbemObjectSink * pHandler, 
    IN ACTIONTYPE        atAction
    )
{
    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Delete a single instance ACTIONTYPE_DELETE
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET != atAction &&
         ACTIONTYPE_DELETE != atAction &&
         ACTIONTYPE_QUERY != atAction ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // We must have the pStorePath property because that is where
    // our instance is stored. 
    // m_srpKeyChain->GetKeyPropertyValue WBEM_S_FALSE if the key is not recognized
    // So, we need to test against WBEM_S_FALSE if the property is mandatory
    //

    CComVariant varStorePath;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(pStorePath, &varStorePath);

    if (SUCCEEDED(hr) && hr != WBEM_S_FALSE && varStorePath.vt == VT_BSTR)
    {

        //
        // Prepare a store (for persistence) for this store path (file)
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistPath(varStorePath.bstrVal);

        if ( SUCCEEDED(hr) ) 
        {

            //
            // make sure the store (just a file) really exists. The raw path
            // may contain env variables, so we need the expanded path
            //

            DWORD dwAttrib = GetFileAttributes(SceStore.GetExpandedPath());

            if ( dwAttrib != -1 ) 
            {
                if ( ACTIONTYPE_DELETE == atAction )
                {
                    hr = DeleteInstance(pHandler, &SceStore);
                }
                else
                {
                    hr = ConstructInstance(pHandler, &SceStore, varStorePath.bstrVal, atAction);
                }

            } 
            else 
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CAccountLockout::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_AccountLockoutPolicy,
    which is persistence oriented, this will cause the Sce_AccountLockoutPolicy object's property 
    information to be saved in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst       - COM interface pointer to the WMI class (Sce_AccountLockoutPolicy) object.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

*/

HRESULT CAccountLockout::PutInst (
    IN IWbemClassObject * pInst, 
    IN IWbemObjectSink  * pHandler,
    IN IWbemContext     * pCtx
    )
{
    HRESULT hr = WBEM_NO_ERROR;

    DWORD dwThreshold=SCE_NO_VALUE;
    DWORD dwReset=SCE_NO_VALUE;
    DWORD dwDuration=SCE_NO_VALUE;

    //
    // CScePropertyMgr helps us to access WMI object's properties
    // create an instance and attach the WMI object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pInst);

    hr = ScePropMgr.GetProperty(pThreshold, &dwThreshold);

    if (SUCCEEDED(hr))
    {
        //
        // dependency check
        //

        if ( dwThreshold != SCE_NO_VALUE && dwThreshold > 0 ) 
        {
            //
            // get values for these two properties only if threshold is defined
            //

            if ( dwThreshold > 999 ) 
            {
                hr = WBEM_E_VALUE_OUT_OF_RANGE;
            } 
            else 
            {
                //
                // SCE_NO_VALUE means the property is not available
                //

                hr = ScePropMgr.GetProperty(pResetTimer, &dwReset);
                if (FAILED(hr))
                {
                    return hr;
                }

                hr = ScePropMgr.GetProperty(pDuration, &dwDuration);
                if (FAILED(hr))
                {
                    return hr;
                }

                //
                // check dependency now
                //

                if ( dwReset != SCE_NO_VALUE && dwDuration != SCE_NO_VALUE ) 
                {
                    if ( dwReset > dwDuration ) 
                    {
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    }
                    if ( dwReset > 99999L || dwDuration >= 99999L ) 
                    {
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    }
                } 
                else
                {
                    hr = WBEM_E_ILLEGAL_NULL;
                }
            }

            if ( FAILED(hr) ) 
            {
                return hr;
            }
        }
    }

    //
    // Attach the WMI object instance to the store and let the store know that
    // it's store is given by the pStorePath property of the instance.
    //

    CSceStore SceStore;
    hr = SceStore.SetPersistProperties(pInst, pStorePath);

    if (SUCCEEDED(hr))
    {
        hr = SaveSettingsToStore(&SceStore, dwThreshold, dwReset, dwDuration);
    }

    return hr;
}

/*
Routine Description: 

Name:

    CAccountLockout::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_AccountLockoutPolicy.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszLogStorePath - store path, a key property of Sce_AccountLockoutPolicy class.

    atAction        - determines if this is a query or a single instance GET.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:

*/

HRESULT 
CAccountLockout::ConstructInstance (
    IN IWbemObjectSink * pHandler,
    IN CSceStore       * pSceStore,
    IN LPCWSTR            wszLogStorePath,
    IN ACTIONTYPE        atAction
    )
{
    // 
    // make sure that we have a valid store
    //

    if ( pSceStore == NULL ||
         pSceStore->GetStoreType() < SCE_INF_FORMAT ||
         pSceStore->GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // ask SCE to read a gigantic structure out from the store. Only SCE
    // knows now to release the memory. Don't just delete it! Use our CSceStore
    // to do the releasing (FreeSecurityProfileInfo)
    //

    PSCE_PROFILE_INFO pInfo=NULL;

    HRESULT hr = pSceStore->GetSecurityProfileInfo (
                                                   AREA_SECURITY_POLICY,
                                                   &pInfo,
                                                   NULL
                                                   );

    CComPtr<IWbemClassObject> srpObj;

    //
    // CScePropertyMgr helps us to access WMI object's properties.
    //

    CScePropertyMgr ScePropMgr;

    if (SUCCEEDED(hr))
    {
        if ( pInfo->LockoutBadCount     == SCE_NO_VALUE &&
             pInfo->LockoutDuration     == SCE_NO_VALUE &&
             pInfo->ResetLockoutCount   == SCE_NO_VALUE ) 
        {
            hr = WBEM_E_NOT_FOUND;
            goto CleanUp;
        }

        //
        // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
        // a "goto CleanUp;" with hr set to the return value from
        // the function (macro parameter)
        //

        CComBSTR bstrLogOut;
        LPCWSTR pszExpandedPath = pSceStore->GetExpandedPath();

        if ( ACTIONTYPE_QUERY == atAction ) 
        {
            SCE_PROV_IfErrorGotoCleanup(MakeSingleBackSlashPath(wszLogStorePath, L'\\', &bstrLogOut));
            pszExpandedPath = bstrLogOut;
        }

        SCE_PROV_IfErrorGotoCleanup(SpawnAnInstance(&srpObj));

        //
        // attach the WMI object to the property manager.
        // This will always succeed.
        //

        ScePropMgr.Attach(srpObj);

        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pStorePath, pszExpandedPath));

        if (pInfo->LockoutBadCount != SCE_NO_VALUE ) {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pThreshold, pInfo->LockoutBadCount));
        }

        if (pInfo->LockoutDuration != SCE_NO_VALUE ) {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pDuration, pInfo->LockoutDuration));
        }

        if (pInfo->ResetLockoutCount != SCE_NO_VALUE ) {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pResetTimer, pInfo->ResetLockoutCount));
        }

        //
        // do the necessary gestures to WMI.
        // the use of WBEM_STATUS_REQUIREMENTS in SetStatus is not documented by WMI
        // at this point. Consult WMI team for detail if you suspect problems with
        // the use of WBEM_STATUS_REQUIREMENTS
        //

        if ( ACTIONTYPE_QUERY == atAction ) {
            pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_FALSE, NULL, NULL);
        } else {
            pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);
        }

        //
        // pass the new instance to WMI
        //

        hr = pHandler->Indicate(1, &srpObj);
    }

CleanUp:

    pSceStore->FreeSecurityProfileInfo(pInfo);

    return hr;
}


/*
Routine Description: 

Name:

    CAccountLockout::DeleteInstance

Functionality:
    
    remove an instance of Sce_AccountLockoutPolicy from the specified store.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: WBEM_E_INVALID_PARAMETER.

Notes:

*/

HRESULT 
CAccountLockout::DeleteInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore
    )
{
    // 
    // make sure that we have a valid store
    //

    if ( pSceStore == NULL ||
         pSceStore->GetStoreType() < SCE_INF_FORMAT ||
         pSceStore->GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_NO_ERROR;

    DWORD val = SCE_NO_VALUE;

    hr = SaveSettingsToStore(pSceStore, val, val, val);

    return hr;

}

/*
Routine Description: 

Name:

    CAccountLockout::SaveSettingsToStore

Functionality:
    
    With all the properties of a Sce_AccountLockoutPolicy, this function just saves
    the instance properties to our store.

Virtual:
    
    No.
    
Arguments:

    pSceStore       - the store.

    dwThreshold     - a corresponding key property of Sce_AccountLockoutPolicy class.

    dwReset         - another corresponding property of the Sce_AccountLockoutPolicy class.

    dwDuration      - another corresponding property of the Sce_AccountLockoutPolicy class.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any error indicates the failure to save the instance.

Notes:
*/

HRESULT 
CAccountLockout::SaveSettingsToStore (
    IN CSceStore  * pSceStore,
    IN DWORD        dwThreshold, 
    IN DWORD        dwReset,
    IN DWORD        dwDuration
    )
{
    DWORD dwDump;

    //
    // For a new .inf file. Write an empty buffer to the file
    // will creates the file with right header/signature/unicode format
    // this is harmless for existing files.
    // For database store, this is a no-op.
    //

    HRESULT hr = pSceStore->WriteSecurityProfileInfo(
                                                    AreaBogus,
                                                    (PSCE_PROFILE_INFO)&dwDump,
                                                    NULL,
                                                    false
                                                    );

    //
    // Threshold
    //

    if (SUCCEEDED(hr))
    {
        hr = pSceStore->SavePropertyToStore(szSystemAccess, KeyThreshold, dwThreshold);

        if (SUCCEEDED(hr))
        {
            //
            // Reset
            //

            hr = pSceStore->SavePropertyToStore(szSystemAccess, KeyReset, dwReset);
            if (SUCCEEDED(hr))
            {
                //
                // Duration
                //

                hr = pSceStore->SavePropertyToStore(szSystemAccess, KeyDuration, dwDuration);
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\lockout.h ===
// lockout.h: interface for the CAccountLockout class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOCKOUT_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_LOCKOUT_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

/*

Class description
    
    Naming: 

        CAccountLockout stands for Account Lockout Policy.
    
    Base class: 
        
        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_AccountLockoutPolicy
    
    Purpose of class:
    
        (1) Implement Sce_AccountLockoutPolicy WMI class.
    
    Design:
         
        (1) Almost trivial other than implementing necessary method as a concrete class
    
    Use:

        (1) Almost never used directly. Always through the common interface defined by
            CGenericClass.
    
*/

class CAccountLockout : public CGenericClass
{
public:
        CAccountLockout (
                        ISceKeyChain *pKeyChain, 
                        IWbemServices *pNamespace,
                        IWbemContext *pCtx = NULL
                        );

        virtual ~CAccountLockout ();

        virtual HRESULT PutInst (
                                IWbemClassObject *pInst, 
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                );

        virtual HRESULT CreateObject (
                                     IWbemObjectSink *pHandler, 
                                     ACTIONTYPE atAction
                                     );

private:

        HRESULT ConstructInstance (
                                  IWbemObjectSink *pHandler, 
                                  CSceStore* pSceStore, 
                                  LPCWSTR wszLogStorePath, 
                                  ACTIONTYPE atAction
                                  );

        HRESULT DeleteInstance (
                               IWbemObjectSink *pHandler, 
                               CSceStore* pSceStore
                               );

        HRESULT SaveSettingsToStore (
                                    CSceStore* pSceStore, 
                                    DWORD dwThreshold, 
                                    DWORD dwReset, 
                                    DWORD dwDuration
                                    );

};

#endif // !defined(AFX_LOCKOUT_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\logrec.cpp ===
// logrec.cpp, implementation of CLogRecord class
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "logrec.h"
#include "persistmgr.h"
#include <io.h>
#include "requestobject.h"

// global instance for error text lookup
static CErrorInfo g_ErrorInfo;

const TCHAR c_szCRLF[]    = TEXT("\r\n");

/*
Routine Description: 

Name:

    CLogRecord::CLogRecord

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CLogRecord::CLogRecord (
    IN ISceKeyChain  * pKeyChain, 
    IN IWbemServices * pNamespace,
    IN IWbemContext  * pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{
}

/*
Routine Description: 

Name:

    CLogRecord::~CLogRecord

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/
    
CLogRecord::~CLogRecord()
{
}

/*
Routine Description: 

Name:

    CLogRecord::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements 
    Sce_ConfigurationLogRecord, upon being called to put an instance, we
    will write a log record into the log file (which is a property of the instance).

Virtual:
    
    Yes.
    
Arguments:

    pInst       - COM interface pointer to the WMI class (Sce_ConfigurationLogRecord) object.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

*/

HRESULT CLogRecord::PutInst
(
IWbemClassObject *pInst, 
IWbemObjectSink *pHandler,
IWbemContext *pCtx
)
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;

    CComBSTR bstrLogPath;

    CComBSTR bstrErrorLabel;

    CComBSTR bstrActionLabel;
    CComBSTR bstrAction;

    CComBSTR bstrCauseLabel;
    CComBSTR bstrErrorCause;

    CComBSTR bstrObjLabel;
    CComBSTR bstrObjDetail;

    CComBSTR bstrParamLabel;
    CComBSTR bstrParamDetail;

    CComBSTR bstrArea;

    LPWSTR tmp = NULL;
    LPWSTR pszLine = NULL;
    DWORD dwCode = 0;
    DWORD Len = 0;

    DWORD dwBytesWritten=0;
    HANDLE hLogFile=INVALID_HANDLE_VALUE;

    DWORD dwCRLF = wcslen(c_szCRLF);

    CComBSTR bstrErrorCode;

    //
    // CScePropertyMgr helps us to access WMI object's properties
    // create an instance and attach the WMI object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pInst);

    BOOL bDb = FALSE;

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetExpandedPath(pLogFilePath, &bstrLogPath, &bDb));

    //
    // we will only log into a plain text file, not a database file
    //

    if ( bDb ) 
    {
        hr = WBEM_E_INVALID_PARAMETER;
        goto CleanUp;
    }

    //
    // retrieve all those properties, see the definition of this WMI class
    // inside sceprov.mof for detail.
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pLogArea, &bstrArea));

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pLogErrorCode, &dwCode));
    if ( hr == WBEM_S_RESET_TO_DEFAULT ) 
    {
        dwCode = 0;
    }

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pAction, &bstrAction));

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pErrorCause, &bstrErrorCause));
    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pObjectDetail, &bstrObjDetail));
    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pParameterDetail, &bstrParamDetail));

    //
    // merge data into one buffer
    //

    bstrErrorLabel.LoadString(IDS_ERROR_CODE);

    //
    // get the text version of the error code
    //

    hr = g_ErrorInfo.GetErrorText(dwCode, &bstrErrorCode);

    //
    // we really can't do anything if this even fails
    //

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // now calculate the giant buffer size!
    //

    //
    //  11 counts for "0xXXXXXXXX=", 1 for \t
    //

    Len = wcslen(bstrErrorLabel) + 11  + wcslen(bstrErrorCode) + 1;

    //
    //  1 for \t
    //

    Len += wcslen(bstrArea) + 1;

    if ( NULL != (LPCWSTR)bstrAction )
    {
        bstrActionLabel.LoadString(IDS_ACTION);

        //
        //  1 for \t
        //

        Len += dwCRLF + 1 + wcslen(bstrActionLabel) + wcslen(bstrAction);
    }

    if ( NULL != (LPCWSTR)bstrErrorCause )
    {
        bstrCauseLabel.LoadString(IDS_FAILURE_CAUSE);

        //
        //  1 for \t
        //

        Len += dwCRLF + 1 + wcslen(bstrCauseLabel) + wcslen(bstrErrorCause);
    }

    if ( NULL != (LPCWSTR)bstrObjDetail )
    {
        bstrObjLabel.LoadString(IDS_OBJECT_DETAIL);

        //
        //  1 for \t
        //

        Len += dwCRLF + 1 + wcslen(bstrObjLabel) + wcslen(bstrObjDetail); 
    }

    if ( NULL != (LPCWSTR)bstrParamDetail )
    {
        bstrParamLabel.LoadString(IDS_PARAMETER_DETAIL);

        //
        //  1 for \t
        //

        Len += dwCRLF + 1 + wcslen(bstrParamLabel) + wcslen(bstrParamDetail);
    }

    //
    // each log will create a blank line, i.e. two c_szCRLF
    //

    Len += dwCRLF * 2;

    //
    // now, we have the length, we need a buffer of that length.
    // need to free, 1 for '\0'
    //

    pszLine = new WCHAR[Len + 1];

    if ( NULL == pszLine ) 
    { 
        hr = WBEM_E_OUT_OF_MEMORY; 
        goto CleanUp;
    }

    //
    // if we get the buffer, then, we will format various information
    // into this buffer to be written to the log file
    //

    //
    // error code will look like this: ErrorCode: 0xXXXXXXXX=ErrorText, where 0xXXXXXXXX is the code itself
    //

    swprintf(pszLine, L"%s0x%08X=%s\t", (LPCWSTR)bstrErrorLabel, dwCode, (LPCWSTR)bstrErrorCode);
    wcscat(pszLine, bstrArea);

    if (NULL != (LPCWSTR)bstrAction)
    {
        wcscat(pszLine, c_szCRLF);
        wcscat(pszLine, L"\t");
        wcscat(pszLine, bstrActionLabel);
        wcscat(pszLine, bstrAction);
    }

    if (NULL != (LPCWSTR)bstrErrorCause)
    {
        wcscat(pszLine, c_szCRLF);
        wcscat(pszLine, L"\t");
        wcscat(pszLine, bstrCauseLabel);
        wcscat(pszLine, bstrErrorCause);
    }

    if (NULL != (LPCWSTR)bstrObjDetail)
    {
        wcscat(pszLine, c_szCRLF);
        wcscat(pszLine, L"\t");
        wcscat(pszLine, bstrObjLabel);
        wcscat(pszLine, bstrObjDetail);
    }

    if (NULL != (LPCWSTR)bstrParamDetail)
    {
        wcscat(pszLine, c_szCRLF);
        wcscat(pszLine, L"\t");
        wcscat(pszLine, bstrParamLabel);
        wcscat(pszLine, bstrParamDetail);
    }

    wcscat(pszLine, c_szCRLF);
    wcscat(pszLine, c_szCRLF);

    //
    // now save the info to log file
    //

    hLogFile = ::CreateFile(bstrLogPath,
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

    if ( INVALID_HANDLE_VALUE != hLogFile ) 
    {

        //
        // don't overwrite the old log records
        //

        SetFilePointer (hLogFile, 0, NULL, FILE_END);

        //
        // try to write. WriteFile returns 0 it fails.
        //

        if ( 0 == WriteFile (hLogFile, 
                             (LPCVOID) pszLine,
                             Len * sizeof(WCHAR),
                             &dwBytesWritten,
                             NULL
                            )  ) 
        {
            //
            // GetLastError() eeds to be translated to HRESULT.
            // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
            //

            hr = ProvDosErrorToWbemError(GetLastError());
        }

        CloseHandle( hLogFile );

    } 
    else 
    {
        //
        // GetLastError() eeds to be translated to HRESULT.
        // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
        //

        hr = ProvDosErrorToWbemError(GetLastError());
    }

CleanUp:
    delete [] pszLine;

    return hr;
}

//
// implementation of CErrorInfo, the error text lookup object
//

/*
Routine Description: 

Name:

    CErrorInfo::CErrorInfo

Functionality:

    This is the constructor. We will create the WMI IWbemStatusCodeText object here.

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    none.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CErrorInfo::CErrorInfo ()
{
    //
    // if this fails, we just won't be able to lookup error text
    //

    ::CoCreateInstance (CLSID_WbemStatusCodeText, 
                        0, CLSCTX_INPROC_SERVER, 
                        IID_IWbemStatusCodeText, 
                        (LPVOID*)&m_srpStatusCodeText
                       );
}

/*
Routine Description: 

Name:

    CErrorInfo::GetErrorText

Functionality:

    This is the HRESULT --> text translation function..

Virtual:
    
    No

Arguments:

    none.

Return Value:

    Success: (1) whatever is returned from IWbemStatusCodeText::GetErrorCodeText if that succeeds.
             (2) WBEM_S_FALSE if IWbemStatusCodeText::GetErrorCodeText fails to get the text
                 and in that case, we will simply try to give the caller the text version of
                 the error code, something like 0x81002321

    Failure: WBEM_E_INVALID_PARAMETER if pbstrErrText == NULL
             WBEM_E_OUT_OF_MEMORY if we can't allocate the bstr.
             WBEM_E_NOT_AVAILABLE if our IWbemStatusCodeText object can't be created

Notes:
    caller is responsible to release the bstr *pbstrErrText

*/

HRESULT 
CErrorInfo::GetErrorText (
    IN HRESULT    hrCode,
    OUT BSTR    * pbstrErrText
    )
{
    if (pbstrErrText == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pbstrErrText = NULL;
    
    HRESULT hr = WBEM_E_NOT_AVAILABLE;

    if (m_srpStatusCodeText)
    {
        //
        // IWbemStatusCodeText is to translate the HRESULT to text
        //

        hr = m_srpStatusCodeText->GetErrorCodeText(hrCode, 0, 0, pbstrErrText);
    }
    
    if (FAILED(hr) || *pbstrErrText == NULL)
    {
        //
        // we fall back to just formatting the error code
        //

        *pbstrErrText = ::SysAllocStringLen(NULL, 16);
        if (*pbstrErrText != NULL)
        {
            wsprintf(*pbstrErrText, L"%08x", hrCode);
            hr = WBEM_S_FALSE;
        }

    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\object.cpp ===
// object.cpp: implementation of the CObjSecurity class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "object.h"
#include "persistmgr.h"
#include <io.h>
#include "requestobject.h"

/*
Routine Description: 

Name:

    CObjSecurity::CObjSecurity

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    type - determines whether it is a Sce_FileObject or Sce_KeyObject.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CObjSecurity::CObjSecurity (
    IN ISceKeyChain *pKeyChain, 
    IN IWbemServices *pNamespace, 
    IN int type,
    IN IWbemContext *pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx), 
    m_Type(type)
{
}

/*
Routine Description: 

Name:

    CObjSecurity::~CObjSecurity

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/

CObjSecurity::~CObjSecurity()
{
}

/*
Routine Description: 

Name:

    CObjSecurity::CreateObject

Functionality:
    
    Create WMI objects (Sce_FileObject/Sce_KeyObject). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT 
CObjSecurity::CreateObject (
    IN IWbemObjectSink * pHandler, 
    IN ACTIONTYPE        atAction
    )
{
    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Delete a single instance ACTIONTYPE_DELETE
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET != atAction &&
         ACTIONTYPE_DELETE != atAction &&
         ACTIONTYPE_QUERY != atAction ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT hr = WBEM_S_NO_ERROR;

    //
    // We must have the pStorePath property because that is where
    // our instance is stored. 
    // m_srpKeyChain->GetKeyPropertyValue WBEM_S_FALSE if the key is not recognized
    // So, we need to test against WBEM_S_FALSE if the property is mandatory
    //

    CComVariant varStorePath;
    hr = m_srpKeyChain->GetKeyPropertyValue(pStorePath, &varStorePath);
    CComVariant varPath;

    if (SUCCEEDED(hr) && hr != WBEM_S_FALSE)
    {
        hr = m_srpKeyChain->GetKeyPropertyValue(pPath, &varPath);
        if (FAILED(hr))
        {
            return hr;
        }
        else if (hr == WBEM_S_FALSE && (ACTIONTYPE_QUERY != atAction) ) 
        {
            return WBEM_E_NOT_FOUND;
        }
    }
    else if (hr == WBEM_S_FALSE)
    {
        return WBEM_E_NOT_FOUND;
    }
    else
    {
        return hr;
    }

    //
    // if we have a valid store path
    //

    if (varStorePath.vt == VT_BSTR)
    {
        //
        // Prepare a store (for persistence) for this store path (file)
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistPath(varStorePath.bstrVal);

        if ( SUCCEEDED(hr) ) {

            //
            // make sure the store (just a file) really exists. The raw path
            // may contain env variables, so we need the expanded path
            //

            DWORD dwAttrib = GetFileAttributes(SceStore.GetExpandedPath());

            if ( dwAttrib != -1 ) 
            {
                //
                // make sure the store type is not mismatching
                //

                if ( SceStore.GetStoreType() < SCE_INF_FORMAT ||
                     SceStore.GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) 
                {

                    hr = WBEM_E_INVALID_PARAMETER;
                }

                int objType = m_Type;

                if ( SUCCEEDED(hr) ) 
                {
                    BOOL bPostFilter=TRUE;
                    DWORD dwCount = 0;

                    m_srpKeyChain->GetKeyPropertyCount(&dwCount);

                    if ( varPath.vt == VT_BSTR ) 
                    {
                        //
                        // get one instance or delete one instance
                        //

                        if ( ACTIONTYPE_DELETE == atAction )
                        {
                            hr = DeleteInstance(pHandler, &SceStore, objType, varPath.bstrVal);
                        }
                        else 
                        {
                            if (dwCount == 2 ) 
                            {
                                bPostFilter = FALSE;
                            }

                            hr = ConstructInstance(pHandler,
                                                   &SceStore, 
                                                   varStorePath.bstrVal,
                                                   objType, 
                                                   (varPath.vt == VT_BSTR) ? varPath.bstrVal : NULL, 
                                                   bPostFilter);
                        }

                    } 
                    else if ( ACTIONTYPE_QUERY == atAction ) 
                    {
                        //
                        // query support
                        //

                        if ( dwCount == 1 ) 
                        {
                            bPostFilter = FALSE;
                        }

                        hr = ConstructQueryInstances(pHandler, &SceStore, varStorePath.bstrVal, objType, bPostFilter);

                    } 
                    else 
                    {
                        hr = WBEM_E_INVALID_OBJECT_PATH;
                    }
                }
            } 
            else 
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CObjSecurity::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_FileObject/Sce_KeyObject,
    which is persistence oriented, this will cause the Sce_FileObject/Sce_KeyObject object's property 
    information to be saved in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst       - COM interface pointer to the WMI class (Sce_FileObject/Sce_KeyObject) object.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

*/

HRESULT 
CObjSecurity::PutInst (
    IN IWbemClassObject * pInst, 
    IN IWbemObjectSink  * pHandler,
    IN IWbemContext     * pCtx
    )
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    CComBSTR bstrObjConvert;
    CComBSTR bstrObjPath;
    CComBSTR bstrSDDL;

    //
    // SCE_NO_VALUE means the property is not available
    //

    DWORD mode = SCE_NO_VALUE;

    CSceStore SceStore;

    //
    // CScePropertyMgr helps us to access WMI object's properties
    // create an instance and attach the WMI object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pInst);


    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    //
    // get object path, can't be NULL
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pPath, &bstrObjPath));
    if ( hr == WBEM_S_RESET_TO_DEFAULT)
    {
        hr = WBEM_E_ILLEGAL_NULL;
        goto CleanUp;
    }

    SCE_PROV_IfErrorGotoCleanup(MakeSingleBackSlashPath(bstrObjPath, L'\\', &bstrObjConvert));

    //
    // get mode, default to 0
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pMode, &mode));

    //
    // get SDDLString, can't be NULL
    //

    if (WBEM_S_RESET_TO_DEFAULT == ScePropMgr.GetProperty(pSDDLString, &bstrSDDL))
    {
        hr = WBEM_E_ILLEGAL_NULL;
        goto CleanUp;
    }

    //
    // Attach the WMI object instance to the store and let the store know that
    // it's store is given by the pStorePath property of the instance.
    //

    SceStore.SetPersistProperties(pInst, pStorePath);

    //
    // now save the info to file
    //

    hr = SaveSettingsToStore(&SceStore,
                                      m_Type,
                                      bstrObjConvert,
                                      mode,
                                      bstrSDDL
                                     );


CleanUp:

    return hr;
}


/*
Routine Description: 

Name:

    CObjSecurity::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_FileObject/Sce_KeyObject.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszLogStorePath - store path, a key property of Sce_FileObject/Sce_KeyObject class.

    ObjType         - a corresponding key property of Sce_FileObject/Sce_KeyObject class.

    wszObjName      - object name.

    bPostFilter     - Controls how WMI will be informed with pHandler->SetStatus.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:

*/

HRESULT CObjSecurity::ConstructInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore,
    IN LPCWSTR            wszLogStorePath,
    IN int                ObjType,
    IN LPCWSTR            wszObjName        OPTIONAL,
    IN BOOL               bPostFilter
    )
{
    //
    // parameters are checked before it's called
    //

    HRESULT hr=WBEM_S_NO_ERROR;

    //
    // ask SCE to read a gigantic structure out from the store. Only SCE
    // knows now to release the memory. Don't just delete it! Use our CSceStore
    // to do the releasing (FreeSecurityProfileInfo)
    //

    //
    // for INT format store
    //

    PSCE_PROFILE_INFO pInfo = NULL;

    //
    // for database format store
    //

    PSCE_OBJECT_SECURITY pObjSecurity = NULL;

    AREA_INFORMATION Area;

    if ( ObjType == SCE_OBJECT_TYPE_FILE ) {
        Area = AREA_FILE_SECURITY;
    } else {
        Area = AREA_REGISTRY_SECURITY;
    }

    //
    // for INF format store
    //

    if ( pSceStore->GetStoreType() == SCE_INF_FORMAT ) 
    {

        hr = pSceStore->GetSecurityProfileInfo(
                                               Area,
                                               &pInfo,
                                               NULL
                                              );

    } 
    else 
    {
        //
        // for database format store
        //

        hr = pSceStore->GetObjectSecurity (
                                           Area,
                                           wszObjName,
                                           &pObjSecurity
                                          );

    }


    if ( pSceStore->GetStoreType() == SCE_INF_FORMAT ) 
    {
        if ( pInfo == NULL ) 
        {
            hr = WBEM_E_NOT_FOUND;
        }

        if ( SUCCEEDED(hr) ) 
        {

            //
            // for INF format, we have to search for the object name in the returned array
            //

            PSCE_OBJECT_ARRAY pObjArr = (ObjType == SCE_OBJECT_TYPE_FILE) ? pInfo->pFiles.pAllNodes : pInfo->pRegistryKeys.pAllNodes;

            if ( pObjArr && pObjArr->pObjectArray ) 
            {

                for ( DWORD i=0; i<pObjArr->Count; i++) 
                {

                    if ( (pObjArr->pObjectArray)[i]->Name == NULL ) 
                    {
                        continue;
                    }

                    if ( _wcsicmp((pObjArr->pObjectArray)[i]->Name, wszObjName)== 0 ) 
                    {
                        break;
                    }
                }

                //
                // find it
                //

                if ( i < pObjArr->Count ) 
                {
                    pObjSecurity = (pObjArr->pObjectArray)[i];
                }
            }
        }
    }

    //
    // if the object's security information buffer is empty, treat it as "not found"
    //

    if ( pObjSecurity == NULL ) 
    {
        hr = WBEM_E_NOT_FOUND;
    }

    CComBSTR bstrLogOut;

    if ( SUCCEEDED(hr) ) 
    {
        hr = MakeSingleBackSlashPath(wszLogStorePath, L'\\', &bstrLogOut);

        if (SUCCEEDED(hr))
        {
            hr = PutDataInstance(pHandler, 
                                 bstrLogOut, 
                                 ObjType, 
                                 wszObjName,
                                 (int)(pObjSecurity->Status), 
                                 pObjSecurity->pSecurityDescriptor,
                                 pObjSecurity->SeInfo, 
                                 bPostFilter);
        }
    }

    pSceStore->FreeSecurityProfileInfo(pInfo);

    if ( pSceStore->GetStoreType() != SCE_INF_FORMAT && pObjSecurity ) 
    {
        pSceStore->FreeObjectSecurity(pObjSecurity);
    }

    return hr;
}

/*
Routine Description: 

Name:

    CObjSecurity::ConstructQueryInstances

Functionality:
    
    Querying instances of Sce_FileObject/Sce_KeyObject whose key properties meet the specified parameters.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer used to notify WMI when instances are created.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszLogStorePath - Log's store path.

    ObjType         - may be NULL.

    bPostFilter     - controls how pHandler->SetStatus is called.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the operation is not carried out

Notes:

*/

HRESULT 
CObjSecurity::ConstructQueryInstances (
    IN IWbemObjectSink * pHandler,
    IN CSceStore       * pSceStore,
    IN LPCWSTR            wszLogStorePath,
    IN int               ObjType,
    IN BOOL              bPostFilter
    )
{
    //
    // parameters are checked before it's called
    //

    HRESULT hr = WBEM_S_NO_ERROR;

    CComBSTR bstrLogOut;
    hr = MakeSingleBackSlashPath(wszLogStorePath, L'\\', &bstrLogOut);

    if (FAILED(hr))
    {
        return hr;
    }

        //
        // query object information from the profile
        //

        if ( pSceStore->GetStoreType() == SCE_INF_FORMAT ) 
        {

            //
            // ask SCE to read a gigantic structure out from the store. Only SCE
            // knows now to release the memory. Don't just delete it! Use our CSceStore
            // to do the releasing (FreeSecurityProfileInfo)
            //

            PSCE_PROFILE_INFO pInfo = NULL;

            hr = pSceStore->GetSecurityProfileInfo(
                                                   (ObjType == SCE_OBJECT_TYPE_FILE) ? AREA_FILE_SECURITY : AREA_REGISTRY_SECURITY,
                                                   &pInfo,
                                                   NULL
                                                   );


            if ( SUCCEEDED(hr) ) 
            {

                //
                // for INF format, we have to search for the object name in the returned array
                //

                PSCE_OBJECT_ARRAY pObjArr = (ObjType == SCE_OBJECT_TYPE_FILE) ? pInfo->pFiles.pAllNodes : pInfo->pRegistryKeys.pAllNodes;

                if ( pObjArr && pObjArr->pObjectArray ) 
                {

                    for ( DWORD i=0; SUCCEEDED(hr) && i < pObjArr->Count; i++) 
                    {

                        if ( (pObjArr->pObjectArray)[i]->Name == NULL ) 
                        {
                            continue;
                        }

                        //
                        // create instance of this one
                        //

                        hr = PutDataInstance(pHandler,
                                            bstrLogOut,
                                            ObjType,
                                            (pObjArr->pObjectArray)[i]->Name,
                                            (int)((pObjArr->pObjectArray)[i]->Status),
                                            (pObjArr->pObjectArray)[i]->pSecurityDescriptor,
                                            (pObjArr->pObjectArray)[i]->SeInfo,
                                            bPostFilter
                                           );
                    }
                }
            }

            pSceStore->FreeSecurityProfileInfo(pInfo);

        } 
        else 
        {
            //
            // the original design of the sce algorithms prevents a clean redesign of this access
            // because it relies on a continuing enumeration of the open profile file
            //

            PVOID hProfile=NULL;
            PSCESVC_CONFIGURATION_INFO pObjInfo=NULL;
            SCESTATUS rc = SceOpenProfile(pSceStore->GetExpandedPath(), (SCE_FORMAT_TYPE)pSceStore->GetStoreType(), &hProfile);
            
            if ( rc != SCESTATUS_SUCCESS )
            {
                //
                // SCE returned errors needs to be translated to HRESULT.
                //

                return ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
            }

            SCEP_HANDLE scepHandle;
            scepHandle.hProfile = hProfile;
            scepHandle.SectionName = (ObjType == SCE_OBJECT_TYPE_FILE ) ? (PWSTR)szFileSecurity : (PWSTR)szRegistryKeys;

            SCE_ENUMERATION_CONTEXT EnumHandle=0;
            DWORD CountReturned;

            do {

                //
                // enumerate the info
                //

                CountReturned = 0;

                rc = SceSvcQueryInfo((SCE_HANDLE)&scepHandle,
                                     SceSvcConfigurationInfo,
                                     NULL,
                                     FALSE,
                                     (PVOID *)&pObjInfo,
                                     &EnumHandle
                                    );

                //
                // SCE returned errors needs to be translated to HRESULT.
                // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
                //

                hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));

                if ( SUCCEEDED(hr) && pObjInfo && pObjInfo->Count > 0 && pObjInfo->Lines ) 
                {

                    //
                    // got something
                    //

                    CountReturned = pObjInfo->Count;
                    int mode;

                    for ( DWORD i=0; SUCCEEDED(hr) && i<pObjInfo->Count; i++ ) 
                    {

                        //
                        // create instance for each one
                        //

                        if ( SUCCEEDED(hr) ) 
                        {

                            //
                            // prefast will complain about the following line of code
                            // first wchar of Value is mode?
                            //

                            mode = *((BYTE *)(pObjInfo->Lines[i].Value));

                            hr = PutDataInstance(pHandler,
                                                bstrLogOut,
                                                ObjType,
                                                pObjInfo->Lines[i].Key,
                                                mode,
                                                pObjInfo->Lines[i].Value + 1,
                                                bPostFilter
                                                );
                        }
                    }
                }

                if ( pObjInfo ) 
                {
                    SceSvcFree(pObjInfo);
                    pObjInfo = NULL;
                }

            } while ( SUCCEEDED(hr) && CountReturned >= SCESVC_ENUMERATION_MAX );

            SceCloseProfile( &hProfile );
        }

    return hr;
}


/*
Routine Description: 

Name:

    CObjSecurity::PutDataInstance

Functionality:
    
    With all the properties of a Sce_FileObject/Sce_KeyObject, this function just creates a new
    instance and populate the properties and then hand it back to WMI.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    wszStoreName    - store path, a key property of Sce_FileObject/Sce_KeyObject class.

    ObjType         - Sce_FileObject/Sce_KeyObject

    wszObjName      - the name

    mode            - a property of the Sce_FileObject/Sce_KeyObject class

    pSD             - Security Descriptor

    SeInfo          - SECURITY_INFORMATION

    bPostFilter     - Controls how WMI will be informed with pHandler->SetStatus.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any error indicates the failure to create the instance.

Notes:
*/

HRESULT CObjSecurity::PutDataInstance (
    IN IWbemObjectSink    * pHandler,
    IN LPCWSTR              wszStoreName,
    IN int                  ObjType,
    IN LPCWSTR              wszObjName,
    IN int                  mode,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    IN BOOL                 bPostFilter
    )
{
    PWSTR strSD=NULL;

    HRESULT hr=WBEM_S_NO_ERROR;

    if ( pSD ) 
    {
        //
        // convert security descriptor to string
        //

        DWORD dSize=0;
        SCESTATUS rc = SceSvcConvertSDToText(
                                            pSD,
                                            SeInfo,
                                            &strSD,
                                            &dSize
                                            );

        if ( rc != SCESTATUS_SUCCESS ) 
        {

            //
            // SCE returned errors needs to be translated to HRESULT.
            //

            return ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
        }
    }

    hr = PutDataInstance(pHandler, wszStoreName, ObjType, wszObjName, mode, strSD, bPostFilter);

    if ( strSD ) 
    {
        LocalFree(strSD);
    }

    return hr;
}

/*
Routine Description: 

Name:

    CObjSecurity::PutDataInstance

Functionality:
    
    With all the properties of a Sce_FileObject/Sce_KeyObject, this function just creates a new
    instance and populate the properties and then hand it back to WMI.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    wszStoreName    - store path, a key property of Sce_AuditPolicy class.

    ObjType         - Sce_FileObject/Sce_KeyObject

    wszObjName      - the name

    mode            - a property of the Sce_FileObject/Sce_KeyObject class

    strSD           - string format of a Security Descriptor

    bPostFilter     - Controls how WMI will be informed with pHandler->SetStatus.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any error indicates the failure to create the instance.

Notes:
*/

HRESULT CObjSecurity::PutDataInstance (
    IN IWbemObjectSink * pHandler,
    IN LPCWSTR           wszStoreName,
    IN int               ObjType,
    IN LPCWSTR           wszObjName,
    IN int               mode,
    IN LPCWSTR           strSD,
    IN BOOL              bPostFilter
    )
{
    //
    // create a blank object to fill in the properties
    //

    CComPtr<IWbemClassObject> srpObj;
    HRESULT hr = SpawnAnInstance(&srpObj);
    
    if (SUCCEEDED(hr))
    {
        //
        // CScePropertyMgr helps us to access WMI object's properties
        // create an instance and attach the WMI object to it.
        // This will always succeed.
        //

        CScePropertyMgr ScePropMgr;
        ScePropMgr.Attach(srpObj);

        //
        // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
        // a "goto CleanUp;" with hr set to the return value from
        // the function (macro parameter)
        //

        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pStorePath, wszStoreName));
        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pPath, wszObjName));
        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pMode, (DWORD)mode));

        if ( strSD ) 
        {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pSDDLString, strSD));
        }

        //
        // do the necessary gestures to WMI.
        // the use of WBEM_STATUS_REQUIREMENTS in SetStatus is not documented by WMI
        // at this point. Consult WMI team for detail if you suspect problems with
        // the use of WBEM_STATUS_REQUIREMENTS
        //

        if ( !bPostFilter ) {
            pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_FALSE, NULL, NULL);
        } else {
            pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);
        }

        //
        // pass the new instance to WMI
        //

        hr = pHandler->Indicate(1, &srpObj);

    }

CleanUp:
    return hr;
}

/*
Routine Description: 

Name:

    CObjSecurity::DeleteInstance

Functionality:
    
    remove an instance of Sce_FileObject/Sce_KeyObject from the specified store.

Virtual:
    
    No.
    
Arguments:

    pHandler    - COM interface pointer for notifying WMI of any events.

    pSceStore   - Pointer to our store. It must have been appropriately set up.

    ObjType     - Sce_FileObject or Sce_KeyObject

    wszObjName  - a corresponding property of the Sce_FileObject/Sce_KeyObject class.

Return Value:

    whatever SaveSettingsToStore function returns.

Notes:

*/

HRESULT 
CObjSecurity::DeleteInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore,
    IN int                ObjType,
    IN LPCWSTR            wszObjName
    )
{
    return SaveSettingsToStore(pSceStore, ObjType, wszObjName, SCE_NO_VALUE, NULL);
}


/*
Routine Description: 

Name:

    CObjSecurity::DeleteInstance

Functionality:
    
    remove an instance of Sce_FileObject/Sce_KeyObject from the specified store.

Virtual:
    
    No.
    
Arguments:

    pHandler    - COM interface pointer for notifying WMI of any events.

    pSceStore   - Pointer to our store. It must have been appropriately set up.

    ObjType     - Sce_FileObject or Sce_KeyObject

    wszObjName  - a corresponding property of the Sce_FileObject/Sce_KeyObject class.

Return Value:

    whatever SaveSettingsToStore function returns.

Notes:

*/

HRESULT CObjSecurity::SaveSettingsToStore (
    IN CSceStore    * pSceStore, 
    IN int            ObjType,
    IN PCWSTR         wszObjName, 
    IN DWORD          mode, 
    IN PCWSTR         wszSDDL
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    DWORD dwDump;

    //
    // For a new .inf file. Write an empty buffer to the file
    // will creates the file with right header/signature/unicode format
    // this is harmless for existing files.
    // For database store, this is a no-op.
    //

    hr = pSceStore->WriteSecurityProfileInfo(
                                            AreaBogus,
                                            (PSCE_PROFILE_INFO)&dwDump,
                                            NULL,
                                            false
                                            );
    if (SUCCEEDED(hr))
    {
        AREA_INFORMATION Area;

        //
        // ask SCE to read a gigantic structure out from the store. Only SCE
        // knows now to release the memory. Don't just delete it! Use our CSceStore
        // to do the releasing (FreeSecurityProfileInfo)
        //

        PSCE_PROFILE_INFO pInfo=NULL;

        if ( ObjType == SCE_OBJECT_TYPE_FILE ) {
            Area = AREA_FILE_SECURITY;
        } else {
            Area = AREA_REGISTRY_SECURITY;
        }

        //
        // query object information from the profile
        //

        hr = pSceStore->GetSecurityProfileInfo(
                                       Area,
                                       &pInfo,
                                       NULL
                                       );

        if ( SUCCEEDED(hr) ) {

            //
            // for INF format, we have to search for the object name in the returned array
            //

            SCE_OBJECTS pObjects= (ObjType == SCE_OBJECT_TYPE_FILE) ? pInfo->pFiles : pInfo->pRegistryKeys;
            PSCE_OBJECT_ARRAY pObjArr = pObjects.pAllNodes;
            DWORD i=0;

            if ( pObjArr && pObjArr->pObjectArray ) 
            {
                for ( i=0; i<pObjArr->Count; i++) 
                {
                    if ( (pObjArr->pObjectArray[i])->Name == NULL ) 
                    {
                        continue;
                    }

                    if ( _wcsicmp((pObjArr->pObjectArray[i])->Name, wszObjName) == 0 ) 
                    {
                        break;
                    }
                }
            }

            if ( pObjArr && pObjArr->pObjectArray && i<pObjArr->Count ) 
            {
                //
                // find it
                //

                if ( mode == SCE_NO_VALUE || wszSDDL == NULL ) 
                {
                    //
                    // delete it
                    // free buffer first
                    //

                    if ( (pObjArr->pObjectArray[i])->pSecurityDescriptor ) 
                    {
                        LocalFree((pObjArr->pObjectArray[i])->pSecurityDescriptor);
                    }

                    LocalFree((pObjArr->pObjectArray[i])->Name);

                    //
                    // shift everything else up
                    //

                    for (DWORD j=i; j<pObjArr->Count-1; j++) 
                    {
                        (pObjArr->pObjectArray[j])->Name                = pObjArr->pObjectArray[j+1]->Name;
                        (pObjArr->pObjectArray[j])->Status              = pObjArr->pObjectArray[j+1]->Status;
                        (pObjArr->pObjectArray[j])->IsContainer         = pObjArr->pObjectArray[j+1]->IsContainer;
                        (pObjArr->pObjectArray[j])->pSecurityDescriptor = pObjArr->pObjectArray[j+1]->pSecurityDescriptor;
                        (pObjArr->pObjectArray[j])->SeInfo              = pObjArr->pObjectArray[j+1]->SeInfo;
                    }

                    //
                    // empty the last one
                    //

                    (pObjArr->pObjectArray[j])->Name                = NULL;
                    (pObjArr->pObjectArray[j])->Status              = 0;
                    (pObjArr->pObjectArray[j])->IsContainer         = 0;
                    (pObjArr->pObjectArray[j])->pSecurityDescriptor = NULL;
                    (pObjArr->pObjectArray[j])->SeInfo              = 0;

                    //
                    // decrement the count
                    //

                    pObjArr->Count--;

                } 
                else 
                {
                    //
                    // modify it
                    //

                    (pObjArr->pObjectArray[i])->Status = (BYTE)mode;

                    SECURITY_INFORMATION SeInfo=0;
                    PSECURITY_DESCRIPTOR pSD=NULL;
                    DWORD dSize=0;

                    SCESTATUS rc = SceSvcConvertTextToSD ((PWSTR)wszSDDL, &pSD, &dSize, &SeInfo);

                    if ( rc == SCESTATUS_SUCCESS && pSD ) 
                    {

                        if ( (pObjArr->pObjectArray[i])->pSecurityDescriptor ) 
                        {
                            LocalFree((pObjArr->pObjectArray[i])->pSecurityDescriptor);
                        }

                        (pObjArr->pObjectArray[i])->pSecurityDescriptor = pSD;
                        pSD = NULL;

                        (pObjArr->pObjectArray[i])->SeInfo = SeInfo;

                    } 
                    else 
                    {
                        //
                        // SCE returned errors needs to be translated to HRESULT.
                        // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
                        //

                        hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
                    }
                }

                if ( SUCCEEDED(hr) ) 
                {
                    hr = pSceStore->WriteSecurityProfileInfo(
                                                             Area,
                                                             pInfo,
                                                             NULL,
                                                             false
                                                            );
                }

            } 
            else 
            {
                //
                // not found
                //

                if ( mode == SCE_NO_VALUE || wszSDDL == NULL ) 
                {
                    //
                    // try to delete non exist object
                    //
                    hr = WBEM_E_NOT_FOUND;

                } 
                else 
                {
                    //
                    // add this one in
                    // pInfo->pFiles or pRegistryKeys is already saved in pObjects
                    //

                    SCE_OBJECT_SECURITY ObjSec;
                    PSCE_OBJECT_SECURITY pObjSec = &ObjSec;
                    SCE_OBJECT_ARRAY    ObjArray;

                    ObjArray.Count = 1;
                    ObjArray.pObjectArray = &pObjSec;

                    pObjArr = &ObjArray;

                    SECURITY_INFORMATION SeInfo=0;
                    PSECURITY_DESCRIPTOR pSD=NULL;
                    DWORD dSize=0;

                    SCESTATUS rc = SceSvcConvertTextToSD((PWSTR)wszSDDL, &pSD, &dSize, &SeInfo);

                    if ( rc == SCESTATUS_SUCCESS && pSD ) 
                    {

                        ObjSec.Name = (PWSTR)wszObjName;
                        ObjSec.Status = (BYTE)mode;
                        ObjSec.IsContainer = 0;
                        ObjSec.pSecurityDescriptor = pSD;
                        ObjSec.SeInfo = SeInfo;

                        //
                        // set the temp buffer pointer to pInfo to set to the store
                        //

                        SCE_OBJECTS sceObj;
                        sceObj.pAllNodes = pObjArr;

                        if ( ObjType == SCE_OBJECT_TYPE_FILE ) 
                        {
                            pInfo->pFiles = sceObj;
                        }

                        else pInfo->pRegistryKeys = sceObj;

                        //
                        // append this item to the section
                        //

                        hr = pSceStore->WriteSecurityProfileInfo (
                                                                  Area,
                                                                  pInfo,
                                                                  NULL,
                                                                  true 
                                                                 );
                        //
                        // reset the buffer pointer
                        //

                        if ( ObjType == SCE_OBJECT_TYPE_FILE ) 
                        {
                            pInfo->pFiles = pObjects;
                        }
                        else 
                        {
                            pInfo->pRegistryKeys = pObjects;
                        }
                    }
                    else
                    {
                        //
                        // SCE returned errors needs to be translated to HRESULT.
                        // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
                        //

                        hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
                    }

                    if ( pSD ) 
                    {
                        LocalFree(pSD);
                    }
                }
            }
        }

        pSceStore->FreeSecurityProfileInfo(pInfo);

    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
//
//  Module: SCE WMI provider code
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//***************************************************************************
#include <objbase.h>
#include <initguid.h>
#include "sceprov.h"
#include "scecore_i.c"
#include "sceparser.h"
#include "persistmgr.h"
#include "resource.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

//
// this is the ATL wrapper for our module
//

CComModule _Module;

//
// this is the ATL object map. If you need to create another COM object that
// is externally createable, then you need to add an entry here. You don't need
// to mess with class factory stuff.
//

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_SceProv, CSceWmiProv)
    OBJECT_ENTRY(CLSID_ScePathParser, CScePathParser)
    OBJECT_ENTRY(CLSID_SceQueryParser, CSceQueryParser)
    OBJECT_ENTRY(CLSID_ScePersistMgr, CScePersistMgr)
END_OBJECT_MAP()

LPCWSTR lpszSceProvMof = L"Wbem\\SceProv.mof";


/*
Routine Description: 

Name:

    DllMain

Functionality:
    
    Entry point for DLL.
    
Arguments:

    See DllMain on MSDN.

Return Value:

    TRUE if OK.

Notes:
    DllMain will be called for attach and detach. When other dlls are loaded, this function
    will also get called. So, this is not necessary a good place for you to initialize some
    globals unless you know precisely what you are doing. Please read MSDN for details before
    you try to modify this function.

    As a general design approach, we use gloal class instances to guarantee its creation and 
    destruction.

*/

extern "C"
BOOL WINAPI DllMain (
    IN HINSTANCE    hInstance, 
    IN ULONG        ulReason,
    LPVOID          pvReserved
    )
{
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (ulReason == DLL_PROCESS_ATTACH)
    {
        OutputDebugString(L"SceProv.dll loaded.\n");
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (ulReason == DLL_PROCESS_DETACH)
    {
        OutputDebugString(L"SceProv.dll unloaded.\n");
        _Module.Term();
    }
    return TRUE;
}

/*
Routine Description: 

Name:

    DllGetClassObject

Functionality:
    
    Retrieves the class object from a DLL object handler or object application. 
    DllGetClassObject is called from within the CoGetClassObject function when the 
    class context is a DLL.

    As a benefit of using ATL, we just need to delegate this to our _Module object.
    
Arguments:

    rclsid      - Class ID (guid) for the class object being requested.

    riid        - Interface GUID that is being requested.

    ppv         - the interface pointer being returned if successful

Return Value:

    Whatever GetClassObject returns for this class ID and its requested interface id.

Notes:

*/

STDAPI DllGetClassObject (
    IN REFCLSID rclsid, 
    IN REFIID   riid, 
    OUT PPVOID  ppv
    )
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/*
Routine Description: 

Name:

    DllCanUnloadNow

Functionality:
    
    Called periodically by COM in order to determine if the DLL can be freed.

    As a benefit of using ATL, we just need to delegate this to our _Module object.
    
Arguments:

    None

Return Value:

    S_OK if the dll can be unloaded. Otherwise, it returns S_FALSE;

Notes:

*/

STDAPI DllCanUnloadNow (void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}

/*
Routine Description: 

Name:
    DllRegisterServer

Functionality:
    
    (1) Called during dll registration.
        As a benefit of using ATL, we just need to delegate this to our _Module object.

    (2) Since we are a provider, we will also compile our MOF file(s).
    
Arguments:

    None

Return Value:

    Success: success code (use SUCCEEDED(hr) to test).
    
    Failure: it returns various errors;

Notes:

*/

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    HRESULT hr = _Module.RegisterServer(TRUE);

    //
    // now compile the MOF file. This is only our current approach. It is not
    // required to compile the MOF file during DLL registration. Users can compile
    // MOF file(s) indenpendently from dll registration
    //

    if (SUCCEEDED(hr))
    {
        const int WBEM_MOF_FILE_LEN = 30;
        WCHAR szBuffer[MAX_PATH];
        WCHAR szMofFile[MAX_PATH + WBEM_MOF_FILE_LEN];

        szBuffer[0] = L'\0';
        szMofFile[0] = L'\0';

        if ( GetSystemDirectory( szBuffer, MAX_PATH ) ) {

            LPWSTR sz = szBuffer + wcslen(szBuffer);
            if ( sz != szBuffer && *(sz-1) != L'\\') {
                *sz++ = L'\\';
                *sz = L'\0';
            }

            hr = WBEM_NO_ERROR;

            //
            // this protects buffer overrun
            //

            if (wcslen(lpszSceProvMof) < WBEM_MOF_FILE_LEN)
            {
                wcscpy(szMofFile, szBuffer);
                wcscat( szMofFile, lpszSceProvMof);

                //
                // we need COM to be ready
                //

                hr = ::CoInitialize (NULL);

                if (SUCCEEDED(hr))
                {
                    //
                    // Get the MOF compiler interface
                    //

                    CComPtr<IMofCompiler> srpMof;
                    hr = ::CoCreateInstance (CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (void **)&srpMof);

                    if (SUCCEEDED(hr))
                    {
                        WBEM_COMPILE_STATUS_INFO  stat;

                        hr = srpMof->CompileFile( szMofFile,
                                                NULL,NULL,NULL,NULL,
                                                0,0,0, &stat);

                    }

                    ::CoUninitialize();
                }
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:
    DllRegisterServer

Functionality:
    
    (1) Called when it is time to remove the registry entries.
        As a benefit of using ATL, we just need to delegate this to our _Module object.
    
Arguments:

    None

Return Value:

    Success: S_OK (same as NOERROR).
    
    Failure: it returns various errors;

Notes:
    There is no MOF unregistration. Otherwise, we should probably do a MOF unregistration

*/

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\logrec.h ===
// logrec.h: interface for the CLogRecord class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOGREC_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_LOGREC_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

/*

Class description
    
    Naming: 

        CLogRecord stands for Logging Record.
    
    Base class: 

        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_ConfigurationLogRecord
    
    Purpose of class:
    
        (1) Implement Sce_ConfigurationLogRecord WMI class.
    
    Design:
         
        (1) Almost trivial other than implementing necessary method as a concrete class.
        (2) Since log record is to create a log files for human to read, we don't support
            creating WMI object of this class. We only support PutInstance (writing to the 
            log file).
    
    Use:

        (1) This class allows us to log information into a log file. That use has been
            encapulated by CMethodResultRecorder::LogResult. If you have to do it without
            the help from CMethodResultRecorder, then read that function for details.
    
*/

class CLogRecord : public CGenericClass
{
public:
        CLogRecord (
                   ISceKeyChain *pKeyChain, 
                   IWbemServices *pNamespace, 
                   IWbemContext *pCtx = NULL
                   );

        virtual ~CLogRecord ();

        virtual HRESULT PutInst (
                                IWbemClassObject *pInst, 
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                );

        virtual HRESULT CreateObject (
                                     IWbemObjectSink *pHandler, 
                                     ACTIONTYPE atAction
                                     )
                {
                    return WBEM_E_NOT_SUPPORTED;
                }

};

/*

Class description
    
    Naming:
    
        CErrorInfo error information.
    
    Base class: 

         none.
    
    Purpose of class:
    
        (1) Wrapper for using WMI COM interface of IWbemStatusCodeText.
    
    Design:
         
        (1) Instead of requiring each caller to requesting their own IWbemStatusCodeText
            from WMI, we can create a global (single) instance to translate the HRESULT
            into text form. This is precisely why we design this class.
    
    Use:

        (1) This class allows us to log information into a log file. That use has been
            encapulated by CMethodResultRecorder::LogResult. If you have to do it without
            the help from CMethodResultRecorder, then read that function for details.
    
*/

class CErrorInfo
{
public:
    CErrorInfo();

    HRESULT GetErrorText (
                         HRESULT hr, 
                         BSTR* pbstrErrText
                         );

private:
    CComPtr<IWbemStatusCodeText> m_srpStatusCodeText;
};


#endif // !defined(AFX_LOGREC_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\operation.cpp ===
// operation.cpp, implementation of CSceOperation class
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "operation.h"
#include "persistmgr.h"
#include "requestobject.h"
#include <io.h>
#include "extbase.h"
#include "sequence.h"
#include "sceprov.h"
#include "Tranx.h"

/*
Routine Description: 

Name:

    CSceOperation::CSceOperation

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CSceOperation::CSceOperation (
    IN ISceKeyChain     * pKeyChain, 
    IN IWbemServices    * pNamespace,
    IN IWbemContext     * pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{
}

/*
Routine Description: 

Name:

    CSceOperation::ExecMethod

Functionality:
    
    Called by CRequestObject to execute a method supported by Sce_Operation class.
    This function will also trigger the extension classes method execution. This is
    the entry point of all our Configure, Import/Export actitivities.

Virtual:
    
    Yes.
    
Arguments:

    bstrPath    - Template's path (file name).

    bstrMethod  - method's name.

    bIsInstance - if this is an instance, should always be false.

    pInParams   - Input parameter from WMI to the method execution.

    pHandler    - sink that informs WMI of execution results.

    pCtx        - the usual context that passes around to make WMI happy.

Return Value:

    Success: many different success code (use SUCCEEDED(hr) to test)

    Failure: various errors code.

Notes:

*/
    
HRESULT 
CSceOperation::ExecMethod (
    IN BSTR                 bstrPath,
    IN BSTR                 bstrMethod,
    IN bool                 bIsInstance,
    IN IWbemClassObject   * pInParams,
    IN IWbemObjectSink    * pHandler,
    IN IWbemContext       * pCtx
    )
{
    if ( pInParams == NULL || pHandler == NULL ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr=WBEM_S_NO_ERROR;
    METHODTYPE mtAction;

    if ( !bIsInstance ) 
    {

        //
        //Static Methods
        //

        if(0 == _wcsicmp(bstrMethod, pwMethodImport))
        {
            mtAction = METHODTYPE_IMPORT;
        }
        else if(0 == _wcsicmp(bstrMethod, pwMethodExport))
        {
            mtAction = METHODTYPE_EXPORT;
        }
        else if(0 == _wcsicmp(bstrMethod, pwMethodApply))
        {
            mtAction = METHODTYPE_APPLY;
        }
        else
        {
            hr = WBEM_E_NOT_SUPPORTED;
        }

    } 
    else 
    {

        //
        //Non-Static Methods
        //

        hr = WBEM_E_NOT_SUPPORTED;
    }

    if ( FAILED(hr) ) 
    {
        return hr;
    }


    //
    // will cache various SCE operation's status return value
    //

    SCESTATUS rc;

    //
    // enum for recognizing various operations (methods)
    //

    DWORD Option;

    //
    // parse the input parameters
    //

    CComBSTR bstrDatabase;
    CComBSTR bstrTemplate;
    CComBSTR bstrLog;
    CComBSTR bstrCfg;

    UINT uiStatus = 0;

    CComBSTR bstrReturnValue(L"ReturnValue");

    CComPtr<IWbemClassObject> srpClass;
    CComPtr<IWbemClassObject> srpOutClass;
    CComPtr<IWbemClassObject> srpReturnValObj;

    //
    // attach a WMI object to the property mgr.
    // This will always succeed.
    //

    CScePropertyMgr SceInParam;
    SceInParam.Attach(pInParams);

    CComBSTR bstrClassName;
    m_srpKeyChain->GetClassName(&bstrClassName);

    //
    // to avoid reentrance to this function by different threads (which may cause
    // serious system consistency problems).
    // ***************************************************************************
    // *****don't blindly return. Allow us to leave the Critical section*****
    // ***************************************************************************
    //

    s_OperationCS.Enter();

    try 
    {
        //
        // g_LogOption is global variable. Need protection.
        //

        g_CS.Enter();

        //
        // update the logging operations
        //

        g_LogOption.GetLogOptionsFromWbemObject(m_srpNamespace);

        g_CS.Leave();

        //
        // need to find out what methods this class really supports. For that purpose
        // we need a definition object of this class.
        //

        m_srpNamespace->GetObject(bstrClassName, 0, pCtx, &srpClass, NULL);

        if(SUCCEEDED(hr))
        {
            //
            // does it really supports this method?
            //

            if(SUCCEEDED(hr = srpClass->GetMethod(bstrMethod, 0, NULL, &srpOutClass)))
            {

                if(SUCCEEDED(hr = srpOutClass->SpawnInstance(0, &srpReturnValObj)))
                {

                    //
                    // execute a method is on a database template (even though our extension
                    // classes are store neutral). This is due to the SCE engine side's implementation.
                    // Get DatabaseName. No template name, no action can be taken.
                    //

                    BOOL bDB=FALSE;
                    hr = SceInParam.GetExpandedPath(pDatabasePath, &bstrDatabase, &bDB);
                    if (hr == WBEM_S_RESET_TO_DEFAULT)
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                    }

                    if(SUCCEEDED(hr))
                    {
                        //
                        // Again, at this moment, SCE only supports configuring database.
                        // however, that is not true for extension classes
                        //

                        BOOL bSCEConfigure = bDB;

                        if ( SUCCEEDED(hr) ) 
                        {

                            //
                            // get area mask, which determines which area the method will be applied.
                            //

                            DWORD dwAreas=0;
                            hr = SceInParam.GetProperty(pAreaMask, &dwAreas);

                            if ( hr == WBEM_S_RESET_TO_DEFAULT ) 
                            {
                                dwAreas = AREA_ALL;
                            }

                            bool bOverwrite=FALSE;

                            switch ( mtAction ) 
                            {
                            case METHODTYPE_IMPORT:
                            case METHODTYPE_EXPORT:

                                //
                                //Get TemplateName, not exist for the apply method
                                //

                                hr = SceInParam.GetExpandedPath(pTemplatePath, &bstrTemplate, &bDB);

                                if ( hr == WBEM_S_RESET_TO_DEFAULT && bDB) 
                                {
                                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                                }

                                if ( SUCCEEDED(hr) && mtAction == METHODTYPE_IMPORT ) 
                                {

                                    //
                                    // get overwrite flag
                                    //

                                    hr = SceInParam.GetProperty(pOverwrite, &bOverwrite);

                                } 
                                else 
                                {

                                    //
                                    // make sure the template name has only single back slash
                                    // import method doesn't need to do this because it takes
                                    // names in both single slash and double back slash
                                    //

                                    hr = MakeSingleBackSlashPath(bstrTemplate, L'\\', &bstrCfg);

                                    if (SUCCEEDED(hr))
                                    {
                                        bstrTemplate = bstrCfg;
                                    }
                                }

                                break;

                            case METHODTYPE_APPLY:

                                //
                                // get LogName, optional
                                //

                                hr = SceInParam.GetExpandedPath(pLogFilePath, &bstrLog, &bDB);
                                if ( SUCCEEDED(hr) && bDB )    
                                {
                                    //
                                    // can't log into a database
                                    //

                                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                                }

                                break;
                            default:
                                hr = WBEM_E_INVALID_PARAMETER;
                                break;
                            }

                            //
                            // prepare a logger. It can log various execution results
                            //

                            hr = m_clsResLog.Initialize(bstrLog, SCEWMI_OPERATION_CLASS, m_srpNamespace, pCtx);

                            if ( SUCCEEDED(hr) ) 
                            {

                                //
                                // process options
                                //

                                if ( bOverwrite )
                                {
                                    Option = SCE_OVERWRITE_DB;
                                }
                                else
                                {
                                    Option = SCE_UPDATE_DB;
                                }

                                if ( (LPCWSTR)bstrLog == NULL || wcslen(bstrLog) == 0)
                                {
                                    Option |= SCE_DISABLE_LOG;
                                }
                                else
                                {
                                    Option |= SCE_VERBOSE_LOG;
                                }

                                HRESULT hrExe = WBEM_NO_ERROR;

                                try
                                {
                                    switch ( mtAction ) 
                                    {
                                    case METHODTYPE_IMPORT:
                                        Option |= SCE_NO_CONFIG;

                                        //
                                        // fall through
                                        //

                                    case METHODTYPE_APPLY:

                                        //
                                        //Call for import/configure
                                        //

                                        if (METHODTYPE_APPLY == mtAction)
                                        {
                                            CTranxID::BeginTransaction(bstrDatabase);
                                        }

                                        //
                                        // see comments where this variable is declared
                                        //

                                        if (bSCEConfigure)  
                                        {
                                            rc = SceConfigureSystem(
                                                                    NULL,
                                                                    ((LPCWSTR)bstrTemplate == NULL) ? NULL : bstrTemplate,
                                                                    bstrDatabase,
                                                                    ((LPCWSTR)bstrLog == NULL) ? NULL : bstrLog,
                                                                    Option,
                                                                    (AREA_INFORMATION)dwAreas,
                                                                    NULL,
                                                                    NULL,
                                                                    NULL
                                                                    );

                                            //
                                            // SCE returned errors needs to be translated to HRESULT.
                                            //

                                            hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));

                                            //
                                            // Log the execution result.
                                            // will ignore the return result, see declaration of m_clsResLog for reasoning
                                            //

                                            if (mtAction == METHODTYPE_IMPORT)
                                            {
                                                m_clsResLog.LogResult(hr, NULL, pInParams, NULL, pwMethodImport, NULL, IDS_IMPORT_TEMPLATE, bstrDatabase);
                                            }
                                            else
                                            {
                                                m_clsResLog.LogResult(hr, NULL, pInParams, NULL, pwMethodApply, NULL, IDS_CONFIGURE_DB, bstrDatabase);
                                            }
                                        }

                                        if ( mtAction == METHODTYPE_APPLY ) 
                                        {
                                            //
                                            // for Sce_Pod
                                            //

                                            hrExe = ProcessAttachmentData(pCtx, 
                                                                          bstrDatabase, 
                                                                          ((LPCWSTR)bstrLog == NULL) ? NULL : bstrLog,
                                                                          pwMethodApply, 
                                                                          Option, 
                                                                          (DWORD *)&rc);

                                            //
                                            // track the first error
                                            //

                                            if (SUCCEEDED(hr))
                                            {
                                                hr = hrExe;
                                            }

                                            //
                                            // we will continue our execution even if hr has indicated failures
                                            //

                                            //
                                            // for Sce_EmbedFO, error will be loged inside embed class's method execution
                                            //

                                            hrExe = ExecMethodOnForeignObjects(pCtx, 
                                                                               bstrDatabase, 
                                                                               ((LPCWSTR)bstrLog == NULL) ? NULL : bstrLog, 
                                                                               pwMethodApply, 
                                                                               Option, 
                                                                               (DWORD *)&rc);

                                            //
                                            // track the first error
                                            //

                                            if (SUCCEEDED(hr))
                                            {
                                                hr = hrExe;
                                            }

                                            // for Sce_LinkFO
                                            //hr = ExecMethodOnForeignObjects(pCtx, 
                                            //                                bstrDatabase, 
                                            //                                ((LPCWSTR)bstrLog == NULL) ? NULL : bstrLog, 
                                            //                                SCEWMI_LINK_BASE_CLASS,
                                            //                                pwMethodApply, 
                                            //                                Option, 
                                            //                                (DWORD *)&rc);

                                            if ( SUCCEEDED(hr) && rc != ERROR_SUCCESS )
                                            {
                                                uiStatus = rc;
                                            }
                                        }

                                        if (METHODTYPE_APPLY == mtAction)
                                        {
                                            CTranxID::EndTransaction();
                                        }

                                        break;

                                    case METHODTYPE_EXPORT:

                                        uiStatus = SceSetupGenerateTemplate(
                                                                    NULL,
                                                                    bstrDatabase,
                                                                    FALSE,
                                                                    ((LPCWSTR)bstrTemplate == NULL) ? NULL : bstrTemplate,
                                                                    ((LPCWSTR)bstrLog == NULL) ? NULL : bstrLog,
                                                                    (AREA_INFORMATION)dwAreas
                                                                    );

                                        //
                                        // SCE returned errors needs to be translated to HRESULT.
                                        //

                                        hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(uiStatus));

                                        //
                                        // will ignore the return result, see declaration of m_clsResLog for reasoning
                                        //

                                        m_clsResLog.LogResult(hr, NULL, pInParams, NULL, pwMethodExport, NULL, IDS_EXPORT_DB, bstrDatabase);

                                        break;
                                    default:

                                        //
                                        //hr = WBEM_E_NOT_SUPPORTED;
                                        //

                                        break;
                                    }

                                }
                                catch(...)
                                {
                                    uiStatus = RPC_E_SERVERFAULT;
                                }

                                if ( SUCCEEDED(hr) ) 
                                {

                                    //
                                    //Set up ReturnValue
                                    //

                                    VARIANT v;
                                    ::VariantInit(&v);
                                    V_VT(&v) = VT_I4;
                                    V_I4(&v) = uiStatus;

                                    if(SUCCEEDED(hr = srpReturnValObj->Put(bstrReturnValue, 0, &v, NULL)))
                                    {
                                        pHandler->Indicate(1, &srpReturnValObj);
                                    }

                                    ::VariantClear(&v);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    catch (...)
    {
    }

    s_OperationCS.Leave();

    return hr;
}

/*
Routine Description: 

Name:

    CSceOperation::ProcessAttachmentData

Functionality:
    
    Private helper. Called by CSceOperation::ExecMethod to execute a method supported by all
    Sce_Pod classes.

Virtual:
    
    no.
    
Arguments:

    pCtx        - the usual context that passes around to make WMI happy.

    pszDatabase - Template's path (file name).

    pszLog      - the log file's path.

    bstrMethod  - method's name.

    Option      - doesn't seem to be used any more.

    pdwStatus   - the returned SCESTATUS value.

Return Value:

    Success: many different success code (use SUCCEEDED(hr) to test)

    Failure: various errors codes. If for multiple instances, one of them return errors during
    execution of the methods, we will try to return to first such error.

Notes:

*/

HRESULT 
CSceOperation::ProcessAttachmentData (
    IN IWbemContext * pCtx,
    IN LPCWSTR        pszDatabase,
    IN LPCWSTR        pszLog        OPTIONAL,
    IN LPCWSTR        pszMethod,
    IN DWORD          Option,
    OUT DWORD       * pdwStatus
    )
{
    if ( pszDatabase == NULL || pdwStatus == NULL ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pdwStatus = 0;
    HRESULT hr;

    //
    // get all inherited classes from pszExtBaseClass (currently, we have Sce_Pod, Sce_EmbedFO, Sce_LinkFO
    // one class per attachment
    //

    CComBSTR bstrSuperClass(SCEWMI_POD_CLASS);
    if ( (BSTR)bstrSuperClass == NULL ) 
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CComPtr<IEnumWbemClassObject> srpEnum;
    ULONG n=0;

    hr = m_srpNamespace->CreateClassEnum(bstrSuperClass,
                                        WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                        pCtx,
                                        &srpEnum
                                        );

    if (FAILED(hr))
    {
        //
        // will ignore the return result, see declaration of m_clsResLog for reasoning
        //

        m_clsResLog.LogResult(hr, NULL, NULL, NULL, L"CSceOperation::ProcessAttachmentData", NULL, IDS_CREATE_CLASSENUM, bstrSuperClass);
        return hr;
    }

    HRESULT hrFirstError = WBEM_NO_ERROR;

    if (SUCCEEDED(hr))
    {
        CComBSTR bstrMethod(pszMethod);

        //
        // build the input parameters
        //

        //
        // each instance returned should represent one attachment
        //

        do {
            CComPtr<IWbemClassObject> srpObj;
            CComPtr<IWbemClassObject> srpInClass;

                hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &n);

                // 
                // failed to enumerate or doesn't return anything, we are fine with that
                // since if the store doesn't contain any instances, we don't have to do anything
                // and it is not an error
                //

                if (FAILED(hr) || hr == WBEM_S_FALSE ) 
                {
                    hr = WBEM_NO_ERROR;
                    break;
                }

                if (SUCCEEDED(hr) && n>0 )
                {
                    //
                    // find one attachment class
                    //

                    CComVariant varClass;

                    //
                    // need this class's name
                    //

                    if(SUCCEEDED(hr=srpObj->Get(L"__CLASS", 0, &varClass, NULL, NULL)))
                    {
                        if (SUCCEEDED(hr))
                        {
                            if (varClass.vt != VT_BSTR)
                            {
                                break;
                            }
                        }

                        if ( SUCCEEDED(hr) ) 
                        {
                            //
                            // create input parameters
                            //

                            hr = srpObj->GetMethod(bstrMethod, 0, &srpInClass, NULL);
                        }

                        // everything is fine, we will then execute this pod's method

                        if ( SUCCEEDED(hr) ) 
                        {
                            hr = ExecutePodMethod(pCtx, pszDatabase, pszLog, varClass.bstrVal, bstrMethod, srpInClass, pdwStatus);
                        }
                    }

                    if (FAILED(hr) && SUCCEEDED(hrFirstError))
                    {
                        hrFirstError = hr;
                    }
                }
        } while (true);
    }

    //
    // will report the first error
    //

    return SUCCEEDED(hrFirstError) ? hr : hrFirstError;
}



/*
Routine Description: 

Name:

    CSceOperation::ExecMethodOnForeignObjects

Functionality:
    
    Private helper. Called by CSceOperation::ExecMethod to execute a method supported by all
    extension classes.

Virtual:
    
    no.
    
Arguments:

    pCtx        - the usual context that passes around to make WMI happy.

    pszDatabase - Template's path (file name).

    pszLog      - the log file's path.

    bstrMethod  - method's name.

    Option      - Log options.

    pdwStatus   - the returned SCESTATUS value.

Return Value:

    Success: many different success code (use SUCCEEDED(hr) to test)

    Failure: various errors codes. If for multiple instances, one of them return errors during
    execution of the methods, we will try to return to first such error.

Notes:
    (1) For each method, we may have a particular order for the classes to execute the method.
        Our CSequencer class knows how to create the order.
    (2) We will report any error, but at this point, we will continue to execute other instances'
        method even if the previous instance has an error.
    (3) We will always capture the first error and return it to the caller.
    (4) We should also log errors.

*/

HRESULT 
CSceOperation::ExecMethodOnForeignObjects (
    IN  IWbemContext * pCtx,
    IN  LPCWSTR        pszDatabase,
    IN  LPCWSTR        pszLog       OPTIONAL,
    IN  LPCWSTR        pszMethod,
    IN  DWORD          Option,
    OUT DWORD        * pdwStatus
    )
{
    if ( pszDatabase == NULL || pdwStatus == NULL ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pdwStatus = 0;

    //
    // build the class sequence for the method
    // we need to build the sequence of classes for this method
    //

    CSequencer seq;
    HRESULT hr = seq.Create(m_srpNamespace, pszDatabase, pszMethod);
    if (FAILED(hr))
    {
        //
        // will ignore the return result, see declaration of m_clsResLog for reasoning
        //

        m_clsResLog.LogResult(hr, NULL, NULL, NULL, L"CSceOperation::ExecMethodOnForeignObjects", NULL, IDS_CREATE_SEQUENCER, pszDatabase);
        return hr;
    }

    //
    // this variable will cache all classes that have been called to execute
    //

    MapExecutedClasses mapExcuted;

    //
    // we will execute the method according this sequence first
    //

    HRESULT hrFirstError = WBEM_NO_ERROR;;

    const COrderNameList* pClsList = NULL;

    if (SUCCEEDED(seq.GetOrderList(&pClsList)) && pClsList)
    {
        DWORD dwEnumHandle = 0;

        //
        // pList must not be released here
        //

        const CNameList* pList = NULL;

        while (SUCCEEDED(pClsList->GetNext(&pList, &dwEnumHandle)) && pList)
        {
            //
            // we will report any error
            //
            
            for (int i = 0; i < pList->m_vList.size(); i++)
            {
                hr = ExeClassMethod(pCtx, pszDatabase, pszLog, pList->m_vList[i], pszMethod, Option, pdwStatus, &mapExcuted);

                //
                // catch the first error to return
                //

                if (FAILED(hr) && SUCCEEDED(hrFirstError))
                {
                    hrFirstError = hr;
                }
            }

            //
            // reset its value for next loop
            //

            pList = NULL;
        }
    }

    //
    // now, we need to execute the rest of the embedded classes whose name doesn't 
    // show up in the sequencer
    //

    //
    // try all inherited classes from SCEWMI_EMBED_BASE_CLASS
    //

    hr = ExeClassMethod(pCtx, pszDatabase, pszLog, SCEWMI_EMBED_BASE_CLASS, pszMethod, Option, pdwStatus, &mapExcuted);

    //
    // catch the first error to return
    //

    if (FAILED(hr) && SUCCEEDED(hrFirstError))
    {
        hrFirstError = hr;
    }

    //
    // now clean up the map that caches our already-executed classes map
    //

    MapExecutedClasses::iterator it = mapExcuted.begin();

    while (it != mapExcuted.end())
    {
        ::SysFreeString((*it).first);
        ++it;
    }

    return FAILED(hrFirstError) ? hrFirstError : hr;
}

/*
Routine Description: 

Name:

    CSceOperation::ExeClassMethod

Functionality:
    
    Private helper. Called to execute the method on a particular embedding class.

Virtual:
    
    no.
    
Arguments:

    pCtx        - the usual context that passes around to make WMI happy.

    pszDatabase - Template's path (file name).

    pszClsName  - individual class name.

    pszLog      - the log file's path.

    bstrMethod  - method's name.

    Option      - Log options, not really used at this time. This is for SCE engine.

    pdwStatus   - the returned SCESTATUS value.

    pExecuted   - used to update the list of classes that are execute during this call.

Return Value:

    Success: many different success code (use SUCCEEDED(hr) to test)

    Failure: various errors codes. If for multiple instances, one of them return errors during
    execution of the methods, we will try to return to first such error..

Notes:

*/

HRESULT 
CSceOperation::ExeClassMethod (
    IN      IWbemContext        * pCtx,
    IN      LPCWSTR               pszDatabase,
    IN      LPCWSTR               pszLog        OPTIONAL,
    IN      LPCWSTR               pszClsName,
    IN      LPCWSTR               pszMethod,
    IN      DWORD                 Option,
    OUT     DWORD               * pdwStatus,
    IN OUT  MapExecutedClasses  * pExecuted
)
{
    //
    // WMI needs bstr names
    //

    CComBSTR bstrClass(pszClsName);

    if ( (BSTR)bstrClass == NULL ) 
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // ask WMI for all those classes of the given name pszClsName
    // We need to enumerate because there might be sub-classes of this given name.
    //

    CComPtr<IEnumWbemClassObject> srpEnum;
    ULONG lRetrieved = 0;

    HRESULT hr = m_srpNamespace->CreateClassEnum(bstrClass,
                                                 WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                                 pCtx,
                                                 &srpEnum
                                                 );

    if (FAILED(hr))
    {
        //
        // will ignore the return result, see declaration of m_clsResLog for reasoning
        //

        m_clsResLog.LogResult(hr, NULL, NULL, NULL, L"CSceOperation::ExeClassMethod", NULL, IDS_CREATE_CLASSENUM, pszClsName);
        return hr;
    }

    //
    // determines if this class has any sub-classes or not 
    //

    ULONG lTotlRetrieved = 0;

    //
    // catch the first error to return
    //

    HRESULT hrFirstError = WBEM_NO_ERROR;

    if (SUCCEEDED(hr))
    {
        CComBSTR bstrMethod(pszMethod);

        do {
            CComPtr<IWbemClassObject> srpObj;
            CComPtr<IWbemClassObject> srpInClass;

            //
            // get one class a time
            //

            hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &lRetrieved);

            lTotlRetrieved += lRetrieved;

            //
            // if the class has no subclass, then we need to try the class itself. We will allow this to fail,
            // meaning that we can't find any instance of this class
            //

            if ((FAILED(hr) || hr == WBEM_S_FALSE) ) 
            {
                //
                // if we have successfully gone through some sub-classes, then we can break
                // because it tells us that it doesn't have any more subs.
                //

                if (lTotlRetrieved > 0) 
                {
                    break;
                }

                //
                // try to get the definition of this class in case this is not an abstract one
                //

                else if (FAILED(m_srpNamespace->GetObject(bstrClass, 0, pCtx, &srpObj, NULL)))
                {
                    m_clsResLog.LogResult(hr, NULL, NULL, NULL, L"CSceOperation::ExeClassMethod", NULL, IDS_GET_CLASS_INSTANCE, pszClsName);
                    break;
                }
            }


            //
            // we truly have an object of this class
            //

            if (SUCCEEDED(hr) && srpObj)
            {
                //
                // get the class's name. Remember, we might be retrieving based on the base class's name
                // therefore, bstrClass may not be really the instance's class name
                //

                CComVariant varClass;
                if(SUCCEEDED(hr = srpObj->Get(L"__CLASS", 0, &varClass, NULL, NULL)))
                {
                    if (SUCCEEDED(hr))
                    {
                        if (varClass.vt != VT_BSTR)
                        {
                            break;
                        }
                    }

                    //
                    // see if the class has been executed before
                    //

                    MapExecutedClasses::iterator it = pExecuted->find(varClass.bstrVal);

                    //
                    // if not yet executed, then of course, we need to execute it
                    //

                    if (it == pExecuted->end())
                    {
                        if ( SUCCEEDED(hr) ) 
                        {
                            hr = srpObj->GetMethod(bstrMethod, 0, &srpInClass, NULL);
                        }

                        if ( SUCCEEDED(hr) ) 
                        {
                            hr = ExecuteExtensionClassMethod(pCtx, pszDatabase, pszLog, varClass.bstrVal, bstrMethod, srpInClass, pdwStatus);
                        }

                        //
                        // add it to the already-executed class map, the map takes the ownership of the bstr in the variant
                        // and that is why we can't let the variant to go ahead destroying itself.
                        //

                        pExecuted->insert(MapExecutedClasses::value_type(varClass.bstrVal, 0));

                        //
                        // prevent the variant from self-destruction
                        //

                        varClass.bstrVal = NULL;
                        varClass.vt = VT_EMPTY;
                    }
                }
                else
                {
                    m_clsResLog.LogResult(hr, NULL, NULL, NULL, L"CSceOperation::ExeClassMethod", NULL, IDS_GET_CLASS_DEFINITION, pszClsName);
                }
            }

            //
            // don't overwrite the first error
            //

            if (FAILED(hr) && SUCCEEDED(hrFirstError))
            {
                hrFirstError = hr;
            }

            //
            // don't loop if this is not a subclass enumeration
            //

            if (lRetrieved == 0)
            {
                break;
            }

        } while (true);
    }

    //
    // will report first error
    //

    return SUCCEEDED(hrFirstError) ? hr : hrFirstError;
}

/*
Routine Description: 

Name:

    CSceOperation::ExecutePodMethod

Functionality:
    
    Private helper. Called to execute each Pod's method.

Virtual:
    
    no.
    
Arguments:

    pCtx        - the usual context that passes around to make WMI happy.

    pszDatabase - Template's path (file name).

    pszLog      - the log file's path.

    bstrMethod  - method's name.

    Option      - doesn't seem to be used any more.

    pInClass    - input parameter's spawning object.

    pdwStatus   - the returned SCESTATUS value.

Return Value:

    Success: many different success code (use SUCCEEDED(hr) to test)

    Failure: various errors codes. If for multiple instances, one of them return errors during
    execution of the methods, we will try to try to first such error.

Notes:

*/

HRESULT CSceOperation::ExecutePodMethod (
    IN  IWbemContext      * pCtx, 
    IN  LPCWSTR             pszDatabase,
    IN  LPCWSTR             pszLog          OPTIONAL, 
    IN  BSTR                bstrClass,
    IN  BSTR                bstrMethod,
    IN  IWbemClassObject  * pInClass,
    OUT DWORD             * pdwStatus
    )
{

    //
    // get ready to fill in the input parameters. Without that, we can't make
    // a successful method call.
    //

    CComPtr<IWbemClassObject> srpInParams;
    HRESULT hr = pInClass->SpawnInstance(0, &srpInParams);

    if (FAILED(hr))
    {
        m_clsResLog.LogResult(hr, NULL, NULL, NULL, L"CSceOperation::ExecutePodMethod", NULL, IDS_SPAWN_INSTANCE, bstrClass);
    }

    if (SUCCEEDED(hr)) 
    {
        //
        // try to fill in in-bound parameter's properties
        //

        //
        // CScePropertyMgr helps us to access WMI object's properties
        // create an instance and attach the WMI object to it.
        // This will always succeed.
        //

        CScePropertyMgr ScePropMgr;
        ScePropMgr.Attach(srpInParams);

        //
        // fill in the in parameter
        //

        hr = ScePropMgr.PutProperty(pStorePath, pszDatabase);
        if (FAILED(hr))
        {
            //
            // indicating that the class's pStorePath key property can't be put
            //

            CComBSTR bstrExtraInfo = bstrClass;
            bstrExtraInfo += CComBSTR(L".");
            bstrExtraInfo += CComBSTR(pStorePath);

            m_clsResLog.LogResult(hr, NULL, NULL, NULL, L"CSceOperation::ExecutePodMethod", NULL, IDS_PUT_PROPERTY, bstrExtraInfo);
            return hr;
        }

        //
        // fill in the in parameter
        //

        hr = ScePropMgr.PutProperty(pLogFilePath, pszLog);

        if ( FAILED(hr) )
        {
            //
            // indicating that the class's pLogFilePath key property can't be put
            //

            CComBSTR bstrExtraInfo = bstrClass;
            bstrExtraInfo += CComBSTR(L".");
            bstrExtraInfo += CComBSTR(pLogFilePath);
            m_clsResLog.LogResult(hr, NULL, NULL, NULL, L"CSceOperation::ExecutePodMethod", NULL, IDS_PUT_PROPERTY, bstrExtraInfo);
        }
        else 
        {
            //
            // create the out-bound parameter
            //

            CComPtr<IWbemClassObject> srpOutParams;

            //
            // make a call the the attachment provider
            // must be in synchronous mode
            //

            hr = m_srpNamespace->ExecMethod(bstrClass,
                                          bstrMethod,
                                          0,
                                          pCtx,
                                          srpInParams,
                                          &srpOutParams,
                                          NULL
                                          );

            if ( SUCCEEDED(hr) && srpOutParams ) 
            {
                //
                // retrieve the return value
                //

                //
                // CScePropertyMgr helps us to access WMI object's properties
                // create an instance and attach the WMI object to it.
                // This will always succeed.
                //

                CScePropertyMgr SceOutReader;
                SceOutReader.Attach(srpOutParams);
                hr = SceOutReader.GetProperty(L"ReturnValue", pdwStatus);
            }

            //
            // ignore not found error
            // if there is no data for an attachment
            //

            if ( hr == WBEM_E_NOT_FOUND || hr == WBEM_E_INVALID_QUERY) 
            {
                hr = WBEM_S_NO_ERROR;
            }

        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CSceOperation::ExecuteExtensionClassMethod

Functionality:
    
    Private helper. Called to execute the method on a particular embedding class instance.

Virtual:
    
    no.
    
Arguments:

    pCtx        - the usual context that passes around to make WMI happy.

    pszDatabase - Template's path (file name).

    pszClsName  - individual class name.

    pszLog      - the log file's path.

    bstrMethod  - method's name.

    Option      - Log options, not really used at this time. This is for SCE engine.

    pInClass    - input parameter's spawning object.

    pdwStatus   - the returned SCESTATUS value.


Return Value:

    Success: many different success code (use SUCCEEDED(hr) to test)

    Failure: various errors codes. If for multiple instances, one of them return errors during
    execution of the methods, we will try to return to first such error..

Notes:
    This is the per-instance method call, the final leg of method execution process.

*/

HRESULT 
CSceOperation::ExecuteExtensionClassMethod (
    IN  IWbemContext      * pCtx, 
    IN  LPCWSTR             pszDatabase,
    IN  LPCWSTR             pszLog          OPTIONAL, 
    IN  BSTR                bstrClass,
    IN  BSTR                bstrMethod,
    IN  IWbemClassObject  * pInClass,
    OUT DWORD             * pdwStatus
    )
{
    //
    // create the input parameter instance.
    //

    CComPtr<IWbemClassObject> srpInParams;
    HRESULT hr = pInClass->SpawnInstance(0, &srpInParams);

    //
    // catch the first error to return
    //

    HRESULT hrFirstError = WBEM_NO_ERROR;

    if (SUCCEEDED(hr)) 
    {
        //
        // create a blank object
        //

        CComPtr<IWbemClassObject> srpSpawn;
        hr = m_srpNamespace->GetObject(bstrClass, 0, m_srpCtx, &srpSpawn, NULL);
        if (FAILED(hr))
        {
            return hr;
        }

        //
        // CScePropertyMgr helps us to access WMI object's properties
        // create an instance and attach the WMI object to it.
        // This will always succeed.
        //

        CScePropertyMgr ScePropMgr;
        ScePropMgr.Attach(srpInParams);

        hr = ScePropMgr.PutProperty(pLogFilePath, pszLog);
        if (FAILED(hr))
        {
            //
            // indicating that the class's pLogFilePath key property can't be put
            //

            CComBSTR bstrExtraInfo = bstrClass;
            bstrExtraInfo += CComBSTR(L".");
            bstrExtraInfo += CComBSTR(pLogFilePath);
            m_clsResLog.LogResult(hr, NULL, NULL, NULL, L"CSceOperation::ExecuteExtensionClassMethod", NULL, IDS_PUT_PROPERTY, bstrExtraInfo);
        }

        //
        // Prepare a store (for persistence) for this store path (file)
        //

        CSceStore SceStore;
        SceStore.SetPersistPath(pszDatabase);

        //
        // now create the list for the class so that we can get the path of the instances.
        // this way, we don't need to query WMI for instances. That is very slow and a lot of redundant
        // reading.
        //

        CExtClassInstCookieList clsInstCookies;

        //
        // we need the foreign class's info for the instance list
        //

        const CForeignClassInfo* pFCInfo = g_ExtClasses.GetForeignClassInfo(m_srpNamespace, pCtx, bstrClass);

        if (pFCInfo == NULL)
        {
            hr = WBEM_E_NOT_FOUND;
        }
        else
        {
            hr = clsInstCookies.Create(&SceStore, bstrClass, pFCInfo->m_pVecKeyPropNames);
        }

        if (FAILED(hr))
        {
            m_clsResLog.LogResult(hr, NULL, NULL, NULL, L"CSceOperation::ExecuteExtensionClassMethod", NULL, IDS_CREATE_INSTANCE_LIST, bstrClass);
            return hr;
        }

        //
        // we have the instance list, so, ready to get the path and execute the method
        //

        if (SUCCEEDED(hr))
        {
            DWORD dwResumeHandle = 0;

            //
            // get the string version of the compound key, which can be
            // used to get the object's path
            //

            CComBSTR bstrEachCompKey;
            hr = clsInstCookies.Next(&bstrEachCompKey, NULL, &dwResumeHandle);

            while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
            {
                //
                // as long as there is more item, keep looping
                //

                if (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
                {
                    //
                    // WMI only takes the path (instead of the object) to execute the method.
                    // Now, we have the instanace list and it has given its the string version
                    // of the compound key, we can ask CScePersistMgr for the object path
                    //

                    CComBSTR bstrObjPath;
                    hr = ::GetObjectPath(srpSpawn, SceStore.GetExpandedPath(), bstrEachCompKey, &bstrObjPath);
                    
                    //
                    // we get the instanace's path
                    //

                    if (SUCCEEDED(hr))
                    {
                        //
                        // any execution error will be logged in the calling function
                        //

                        CComPtr<IWbemClassObject> srpOutParams;
                        hr = m_srpNamespace->ExecMethod(bstrObjPath,
                                                        bstrMethod,
                                                        0,
                                                        pCtx,
                                                        srpInParams,
                                                        &srpOutParams,
                                                        NULL
                                                        );

                        //
                        // don't overwrite the first error
                        //

                        if (FAILED(hr) && SUCCEEDED(hrFirstError))
                        {
                            hrFirstError = hr;
                        }
                    }
                    else
                    {
                        m_clsResLog.LogResult(hr, NULL, NULL, NULL, L"CSceOperation::ExecuteExtensionClassMethod", NULL, IDS_GET_FULLPATH, bstrClass);
                    }
                }

                //
                // get ready to be reused!
                // 

                bstrEachCompKey.Empty();

                hr = clsInstCookies.Next(&bstrEachCompKey, NULL, &dwResumeHandle);
            }
        }
    }
    return SUCCEEDED(hrFirstError) ? hr : hrFirstError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\operation.h ===
// operation.h: interface for the CSceOperation class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_OPERATION_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_OPERATION_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "Extbase.h"

typedef std::map<BSTR, DWORD, strLessThan<BSTR> > MapExecutedClasses;

/*

Class description
    
    Naming:

        CSceOperation stands for Sce objects that executes Operation(s). 
    
    Base class:
    
        CGenericClass, because it is a class representing two WMI  
        objects - WMI class names are Sce_Operation
    
    Purpose of class:
    
        (1) Implement Sce_Operation WMI class, which is the only WMI class provided
            by SCE provider that can execute a method. This class has no other property
            other than the capability to execute some methods. See sceprov.mof file for detail.

        (2) Do all the hard work to start the extension classes' method execution. Currently,
            we have two different extension model (embedding being the one truly used, while Pod
            model is for history reasons).
    
    Design:
         
        (1) Almost trivial as a sub-class of CGenericClass. Even simpler than most other
            peers because this class doesn't support PutInstnace and GetInstance operations
            since it only implements several static methods.

        (2) To support our open extension model, this class does trigger all other extension
            classes to execute the method. The private methods are all design for that purpose.

        (3) ProcessAttachmentData/ExecutePodMethod is to trigger the Pod model extension classes.

        (4) The rest privates are to trigger the embedding model extension classes.
    
    Use:

        (1) Almost never used directly. Always through the common interface defined by
            CGenericClass.

*/

class CSceOperation : public CGenericClass
{
public:
        CSceOperation (
                       ISceKeyChain *pKeyChain, 
                       IWbemServices *pNamespace, 
                       IWbemContext *pCtx = NULL
                       );

        virtual ~CSceOperation(){}

        virtual HRESULT PutInst (
                                IN IWbemClassObject * pInst, 
                                IN IWbemObjectSink  * pHandler, 
                                IN IWbemContext     * pCtx
                                )
                {
                    return WBEM_E_NOT_SUPPORTED;
                }

        virtual HRESULT CreateObject (
                                     IN IWbemObjectSink * pHandler, 
                                     IN ACTIONTYPE        atAction
                                     )
                {
                    return WBEM_E_NOT_SUPPORTED;
                }

        virtual HRESULT ExecMethod (
                                   BSTR bstrPath, 
                                   BSTR bstrMethod, 
                                   bool bIsInstance, 
                                   IWbemClassObject *pInParams,
                                   IWbemObjectSink *pHandler, 
                                   IWbemContext *pCtx
                                   );

        static CCriticalSection s_OperationCS;

private:
        HRESULT ProcessAttachmentData (
                                      IWbemContext *pCtx, 
                                      LPCWSTR pszDatabase,
                                      LPCWSTR pszLog, 
                                      LPCWSTR pszMethod, 
                                      DWORD Option,
                                      DWORD *dwStatus
                                      );

        HRESULT ExecMethodOnForeignObjects(IWbemContext *pCtx, 
                                            LPCWSTR pszDatabase,
                                            LPCWSTR pszLog,
                                            LPCWSTR pszMethod, 
                                            DWORD Option,
                                            DWORD *dwStatus
                                            );

        HRESULT ExeClassMethod(
                              IWbemContext *pCtx,
                              LPCWSTR pszDatabase,
                              LPCWSTR pszLog OPTIONAL,
                              LPCWSTR pszClsName,
                              LPCWSTR pszMethod,
                              DWORD Option,
                              DWORD *pdwStatus,
                              MapExecutedClasses* pExecuted
                              );

        HRESULT ExecutePodMethod(
                                IWbemContext *pCtx, 
                                LPCWSTR pszDatabase,
                                LPCWSTR pszLog OPTIONAL, 
                                BSTR bstrClass,
                                BSTR bstrMethod,
                                IWbemClassObject* pInClass,
                                DWORD *pdwStatus
                                );

        HRESULT ExecuteExtensionClassMethod(
                                            IWbemContext *pCtx, 
                                            LPCWSTR pszDatabase,
                                            LPCWSTR pszLog OPTIONAL, 
                                            BSTR bstrClass,
                                            BSTR bstrMethod,
                                            IWbemClassObject* pInClass,
                                            DWORD *pdwStatus
                                            );

        //
        // will ignore the return result from m_clsResLog.LogResult because there is really nothing
        // we can do and we don't want to a diagnose helper to stop our normal function
        //

        CMethodResultRecorder m_clsResLog;
};

#endif // !defined(AFX_OPERATION_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\object.h ===
// object.h: interface for the CObjSecurity class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_OBJECT_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_OBJECT_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"


/*

Class description
    
    Naming: 

        CObjSecurity stands for Object Security. 
    
    Base class: 

        CGenericClass, because it is a class representing two WMI  
        objects - WMI class names are Sce_FileObject and Sce_KeyObject
    
    Purpose of class:
    
        (1) Implement Sce_FileObject and Sce_KeyObject WMI classes. The difference between
            these two classes are obviously reflected by m_Type member.
    
    Design:
         
        (1) Almost trivial other than implementing necessary method as a concrete class
    
    Use:

        (1) Almost never used directly. Always through the common interface defined by
            CGenericClass.
    

*/

class CObjSecurity : public CGenericClass
{
public:
        CObjSecurity (
                     ISceKeyChain *pKeyChain, 
                     IWbemServices *pNamespace, 
                     int type, 
                     IWbemContext *pCtx = NULL
                     );

        virtual ~CObjSecurity ();

        virtual HRESULT PutInst (
                                IWbemClassObject *pInst, 
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                );

        virtual HRESULT CreateObject (
                                     IWbemObjectSink *pHandler,
                                     ACTIONTYPE atAction
                                     );

private:

        int m_Type;

        HRESULT ConstructInstance (
                                  IWbemObjectSink *pHandler, 
                                  CSceStore* pSceStore, 
                                  LPCWSTR wszLogStorePath, 
                                  int ObjType, 
                                  LPCWSTR wszObjName, 
                                  BOOL bPostFilter
                                  );

        HRESULT ConstructQueryInstances (
                                        IWbemObjectSink *pHandler, 
                                        CSceStore* pSceStore, 
                                        LPCWSTR wszLogStorePath, 
                                        int ObjType, 
                                        BOOL bPostFilter
                                        );

        HRESULT DeleteInstance (
                               IWbemObjectSink *pHandler, 
                               CSceStore* pSceStore, 
                               int ObjType, 
                               LPCWSTR wszObjName
                               );

        HRESULT SaveSettingsToStore (
                                    CSceStore* pSceStore, 
                                    int ObjType,
                                    LPCWSTR wszObjName, 
                                    DWORD mode, 
                                    LPCWSTR wszSDDL
                                    );

        HRESULT PutDataInstance (
                                IWbemObjectSink *pHandler,
                                LPCWSTR wszStoreName,
                                int ObjType,
                                LPCWSTR wszObjName,
                                int mode,
                                PSECURITY_DESCRIPTOR pSD,
                                SECURITY_INFORMATION SeInfo, 
                                BOOL bPostFilter
                                );

        HRESULT PutDataInstance (
                                IWbemObjectSink *pHandler,
                                LPCWSTR wszStoreName,
                                int ObjType,
                                LPCWSTR wszObjName,
                                int mode,
                                LPCWSTR strSD, 
                                BOOL bPostFilter
                                );

};

#endif // !defined(AFX_OBJECT_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\option.cpp ===
// option.cpp, implementation of CSecurityOptions class
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "option.h"
#include "persistmgr.h"
#include <io.h>
#include "requestobject.h"

#define KeyAdmin        L"NewAdministratorName"
#define KeyGuest        L"NewGuestName"


/*
Routine Description: 

Name:

    CSecurityOptions::CSecurityOptions

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CSecurityOptions::CSecurityOptions (
    IN ISceKeyChain  * pKeyChain, 
    IN IWbemServices * pNamespace,
    IN IWbemContext  * pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{

}

/*
Routine Description: 

Name:

    CSecurityOptions::~CSecurityOptions

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/

CSecurityOptions::~CSecurityOptions ()
{

}

/*
Routine Description: 

Name:

    CSecurityOptions::CreateObject

Functionality:
    
    Create WMI objects (Sce_SecurityOptions). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT 
CSecurityOptions::CreateObject (
    IN IWbemObjectSink * pHandler, 
    IN ACTIONTYPE        atAction
    )
{
    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Delete a single instance ACTIONTYPE_DELETE
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET != atAction &&
         ACTIONTYPE_DELETE != atAction &&
         ACTIONTYPE_QUERY != atAction ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // return WBEM_S_FALSE if the key is not recognized
    //

    CComVariant varStorePath;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(pStorePath, &varStorePath); 

    if (SUCCEEDED(hr) && hr != WBEM_S_FALSE && varStorePath.vt == VT_BSTR)
    {
        //
        // Prepare a store (for persistence) for this store path (file)
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistPath(varStorePath.bstrVal);

        if ( SUCCEEDED(hr) ) 
        {

            //
            // make sure the store (just a file) really exists. The raw path
            // may contain env variables, so we need the expanded path
            //

            DWORD dwAttrib = GetFileAttributes(SceStore.GetExpandedPath());

            if ( dwAttrib != -1 ) 
            {

                if ( ACTIONTYPE_DELETE == atAction )
                {
                    hr = DeleteInstance(pHandler, &SceStore);
                }
                else 
                {
                    BOOL bPostFilter=TRUE;
                    DWORD dwCount = 0;
                    m_srpKeyChain->GetKeyPropertyCount(&dwCount);

                    if ( ACTIONTYPE_QUERY == atAction && dwCount == 1 ) 
                    {
                        bPostFilter = FALSE;
                    }

                    hr = ConstructInstance(pHandler, &SceStore, varStorePath.bstrVal, bPostFilter);
                }

            } 
            else 
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CSecurityOptions::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_SecurityOptions,
    which is persistence oriented, this will cause the Sce_SecurityOptions object's property 
    information to be saved in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst       - COM interface pointer to the WMI class (Sce_SecurityOptions) object.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

*/

HRESULT 
CSecurityOptions::PutInst (
    IN IWbemClassObject * pInst, 
    IN IWbemObjectSink  * pHandler,
    IN IWbemContext     * pCtx
    )
{
    CComBSTR bstrAdmin;
    CComBSTR bstrGuest;

    //
    // CScePropertyMgr helps us to access WMI object's properties
    // create an instance and attach the WMI object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pInst);

    HRESULT hr = ScePropMgr.GetProperty(pAdministratorAccountName, &bstrAdmin);
    if (SUCCEEDED(hr))
    {
        hr = ScePropMgr.GetProperty(pGuestAccountName, &bstrGuest);
    }

    //
    // now save the info to file
    //

    if (SUCCEEDED(hr))
    {
        //
        // Attach the WMI object instance to the store and let the store know that
        // it's store is given by the pStorePath property of the instance.
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistProperties(pInst, pStorePath);

        //
        // an INF template file
        // Write an empty buffer to the file
        // will creates the file with right header/signature/unicode format
        //

        if (SUCCEEDED(hr))
        {
            DWORD dwDump;

            //
            // For a new .inf file. Write an empty buffer to the file
            // will creates the file with right header/signature/unicode format
            // this is harmless for existing files.
            // For database store, this is a no-op.
            //

            hr = SceStore.WriteSecurityProfileInfo(
                                        AreaBogus,
                                        (PSCE_PROFILE_INFO)&dwDump,
                                        NULL, 
                                        false
                                        );
        }
        if (SUCCEEDED(hr))
        {
            hr = SceStore.SavePropertyToStore(szSystemAccess, KeyAdmin, bstrAdmin);
        }

        if (SUCCEEDED(hr))
        {
            hr = SceStore.SavePropertyToStore(szSystemAccess, KeyGuest, bstrGuest);
        }
    }

    return hr;
}


/*
Routine Description: 

Name:

    CSecurityOptions::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_SecurityOptions.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszLogStorePath - store path, a key property of Sce_SecurityOptions class.

    bPostFilter     - Controls how WMI will be informed with pHandler->SetStatus.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:

*/

HRESULT CSecurityOptions::ConstructInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore,
    IN LPCWSTR            wszLogStorePath,
    IN BOOL               bPostFilter
    )
{
    // 
    // make sure that we have a valid store
    //

    if ( pSceStore == NULL ||
         pSceStore->GetStoreType() < SCE_INF_FORMAT ||
         pSceStore->GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // ask SCE to read a gigantic structure out from the store. Only SCE
    // knows now to release the memory. Don't just delete it! Use our CSceStore
    // to do the releasing (FreeSecurityProfileInfo)
    //

    PSCE_PROFILE_INFO pInfo=NULL;
    HRESULT hr = pSceStore->GetSecurityProfileInfo(
                                                   AREA_SECURITY_POLICY,
                                                   &pInfo,
                                                   NULL
                                                   );


    if (SUCCEEDED(hr) && pInfo != NULL && pInfo->NewAdministratorName == NULL && pInfo->NewGuestName == NULL ) 
    {
        hr = WBEM_E_NOT_FOUND;
    }

    if (SUCCEEDED(hr))
    {
        CComBSTR bstrLogOut;

        //
        // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
        // a "goto CleanUp;" with hr set to the return value from
        // the function (macro parameter)
        //

        SCE_PROV_IfErrorGotoCleanup(MakeSingleBackSlashPath(wszLogStorePath, L'\\', &bstrLogOut));
        
        CComPtr<IWbemClassObject> srpObj;
        SCE_PROV_IfErrorGotoCleanup(SpawnAnInstance(&srpObj));

        //
        // CScePropertyMgr helps us to access WMI object's properties
        // create an instance and attach the WMI object to it.
        // This will always succeed.
        //

        CScePropertyMgr ScePropMgr;
        ScePropMgr.Attach(srpObj);

        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pStorePath, bstrLogOut));

        if (pInfo->NewAdministratorName != NULL ) 
        {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pAdministratorAccountName, pInfo->NewAdministratorName));
        }

        if (pInfo->NewGuestName != NULL ) 
        {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pGuestAccountName, pInfo->NewGuestName));
        }

        //
        // do the necessary gestures to WMI.
        // the use of WBEM_STATUS_REQUIREMENTS in SetStatus is not documented by WMI
        // at this point. Consult WMI team for detail if you suspect problems with
        // the use of WBEM_STATUS_REQUIREMENTS
        //

        if ( !bPostFilter ) 
        {
            pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_FALSE, NULL, NULL);
        } 
        else 
        {
            pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);
        }

        //
        // everything alright, pass to WMI the newly created instance!
        //

        hr = pHandler->Indicate(1, &srpObj);

    }

CleanUp:

    pSceStore->FreeSecurityProfileInfo(pInfo);

    return hr;
}


/*
Routine Description: 

Name:

    CSecurityOptions::DeleteInstance

Functionality:
    
    remove an instance of Sce_SecurityOptions from the specified store.

Virtual:
    
    No.
    
Arguments:

    pHandler    - COM interface pointer for notifying WMI of any events.

    pSceStore   - Pointer to our store. It must have been appropriately set up.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: WBEM_E_INVALID_PARAMETER.

Notes:

*/

HRESULT 
CSecurityOptions::DeleteInstance (
    IWbemObjectSink *pHandler,
    CSceStore* pSceStore
    )
{
    // 
    // make sure that we have a valid store
    //

    if ( pSceStore == NULL ||
         pSceStore->GetStoreType() < SCE_INF_FORMAT ||
         pSceStore->GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // this shouldn't fail unless parameter is not valid.
    // If it fails, then we don't bother to delete the second property
    //

    HRESULT hr = pSceStore->SavePropertyToStore(szSystemAccess, KeyAdmin, (LPCWSTR)NULL);

    if (SUCCEEDED(hr))
    {
        hr = pSceStore->SavePropertyToStore(szSystemAccess, KeyGuest, (LPCWSTR)NULL);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\option.h ===
// option.h: interface for the CSecurityOptions class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_OPTION_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_OPTION_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

/*

Class description
    
    Naming:

        CSecurityOptions stands for Security Options.
    
    Base class:

        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_SecurityOptions
    
    Purpose of class:
    
        (1) Implement Sce_SecurityOptions WMI class.
    
    Design:
         
        (1) Almost trivial other than implementing necessary method as a concrete class
    
    Use:

        (1) Almost never used directly. Alway through the common interface defined by
            CGenericClass.
    

*/

class CSecurityOptions : public CGenericClass
{
public:
        CSecurityOptions (
                         ISceKeyChain *pKeyChain, 
                         IWbemServices *pNamespace, 
                         IWbemContext *pCtx = NULL
                         );

        virtual ~CSecurityOptions();

        virtual HRESULT PutInst (
                                IWbemClassObject *pInst, 
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                );

        virtual HRESULT CreateObject (
                                     IWbemObjectSink *pHandler, 
                                     ACTIONTYPE atAction
                                     );

private:

        HRESULT ConstructInstance (
                                  IWbemObjectSink *pHandler, 
                                  CSceStore* pSceStore, 
                                  LPCWSTR wszLogStorePath, 
                                  BOOL bPostFilter
                                  );

        HRESULT DeleteInstance (
                               IWbemObjectSink *pHandler, 
                               CSceStore* pSceStore
                               );

};

#endif // !defined(AFX_OPTION_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\persistmgr.cpp ===
// persistmgr.cpp: implementation of the SCE provider persistence related classes
// declared inside persistmgr.h.
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
// original author: shawnwu
// creation date: 1/3/2001

#include "precomp.h"
#include <wininet.h>
#include "genericclass.h"
#include "persistmgr.h"
#include "requestobject.h"
#include "extbase.h"

//
// some global constants
//
const WCHAR wchCookieSep    = L':';
const WCHAR wchTypeValSep   = L':';
const WCHAR wchValueSep     = L':';
const WCHAR wchParamSep     = L',';

const WCHAR wchTypeValLeft  = L'<';
const WCHAR wchTypeValRight = L'>';

const WCHAR wchMethodLeft   = L'(';
const WCHAR wchMethodRight  = L')';
const WCHAR wchMethodSep    = L';';

const WCHAR wchCySeparator  = L'.';
const WCHAR wchQuote        = L'\"';

LPCWSTR pszListPrefix       = L"A";
LPCWSTR pszKeyPrefix        = L"K";

LPCWSTR pszAttachSectionValue   = L"1";

LPCWSTR pszNullKey = L"NULL_KEY";

//
// the types that we support
//

VtTypeStruct gVtTypeToStructArray[] =
{   
    {L"VT_BOOL",            VT_BOOL},
    {L"VT_I2",              VT_I2},
    {L"VT_I4",              VT_I4},
    //{L"VT_I8",              VT_I8},
    {L"VT_R4",              VT_R4},
    {L"VT_R8",              VT_R8},
    {L"VT_CY",              VT_CY},
    {L"VT_DATE",            VT_DATE},
    {L"VT_BSTR",            VT_BSTR},
    {L"VT_UI1",             VT_UI1},
    {L"VT_UI2",             VT_UI2},
    {L"VT_UI4",             VT_UI4},            // somehow, WMI doesn't work with VT_UI4
    {L"VT_UINT",            VT_UINT},
    //{L"VT_UI8",             VT_UI8},
    {L"VT_ARRAY(VT_BOOL)",  VT_ARRAY | VT_BOOL},
    {L"VT_ARRAY(VT_I2)",    VT_ARRAY | VT_I2},
    {L"VT_ARRAY(VT_I4)",    VT_ARRAY | VT_I4},
    //{L"VT_ARRAY(VT_I8)",    VT_ARRAY | VT_I8},
    {L"VT_ARRAY(VT_R4)",    VT_ARRAY | VT_R4},
    {L"VT_ARRAY(VT_R8)",    VT_ARRAY | VT_R8},
    {L"VT_ARRAY(VT_CY)",    VT_ARRAY | VT_CY},
    {L"VT_ARRAY(VT_DATE)",  VT_ARRAY | VT_DATE},
    {L"VT_ARRAY(VT_BSTR)",  VT_ARRAY | VT_BSTR},
    {L"VT_ARRAY(VT_UI1)",   VT_ARRAY | VT_UI1},
    {L"VT_ARRAY(VT_UI2)",   VT_ARRAY | VT_UI2},
    {L"VT_ARRAY(VT_UI4)",   VT_ARRAY | VT_I4},  // somehow, WMI doesn't work with VT_ARRAY(VT_UI4)
    {L"VT_ARRAY(VT_UINT)",  VT_ARRAY | VT_UINT},
    //{L"VT_ARRAY(VT_UI8)",   VT_ARRAY | VT_UI8},
};

/*
Routine Description: 

Name:

    IsVT_Array

Functionality:
    
    test if a VARTYPE is a safearray.

Virtual:
    
    N/A.
    
Arguments:

    vt  - The VARTYPE to test.

Return Value:

    true if yes, false if no.

Notes:

*/

bool 
IsVT_Array (
    IN VARTYPE vt
    )
{
    return ( (vt & VT_ARRAY) == VT_ARRAY );
}

/*
Routine Description: 

Name:

    GetSubType

Functionality:
    
    Get the safearray's element type.

Virtual:
    
    N/A.
    
Arguments:

    vt  - The VARTYPE to get the sub-type. The result is not defined if vt is not representing
          a safearray type.

Return Value:

    true if yes, false if no.

Notes:

*/

VARTYPE 
GetSubType (
    IN VARTYPE vt
    )
{
    return (vt & (~VT_ARRAY));
}

//
// global instance of maps from string to vt and from vt to string
//

CMapVtToString gVtToStringMap(sizeof(gVtTypeToStructArray)/sizeof(VtTypeStruct), gVtTypeToStructArray);

CMapStringToVt gStringToVtMap(sizeof(gVtTypeToStructArray)/sizeof(VtTypeStruct), gVtTypeToStructArray);

/*
Routine Description: 

Name:

    IsEscapedChar

Functionality:
    
    test if the wchar is a char that we need to be escaped.

Virtual:
    
    N/A.
    
Arguments:

    ch  - The wchar to test.

Return Value:

    true if yes, false if no.

Notes:

*/

bool 
IsEscapedChar (
    IN WCHAR ch
    )
{
    return (ch == L'\\' || ch == L'"');
}

/*
Routine Description: 

Name:

    GetEscapeCharCount

Functionality:
    
    will return the count of characters that needs to be escaped - determined by
    ::IsEscapedChar function

Virtual:
    
    N/A.
    
Arguments:

    pszStr  - The string to count the escape characters.

Return Value:

    The count of escape characters.

Notes:

*/

DWORD 
GetEscapeCharCount (
    IN LPCWSTR pszStr
    )
{
    DWORD dwCount = 0;
    while (*pszStr != L'\0')
    {
        if (::IsEscapedChar(*pszStr))
        {
            ++dwCount;
        }
        ++pszStr;
    }
    return dwCount;
};

/*
Routine Description: 

Name:

    TrimCopy

Functionality:
    
    Will copy the portion from pSource that is of length iLen. The difference is
    that the result string won't have leading and trailing white spaces (determined
    by iswspace)

Virtual:
    
    N/A.
    
Arguments:

    pDest   - Receives the copied sub-string.

    pSource - The source.

    iLen    - The length the sub-string is.

Return Value:

    None.

Notes:
    Caller must guarantee pSource/pDest to have enough room, including the L'\0'. That is
    the buffer size is >= iLen + 1.

*/

void 
TrimCopy (
    OUT LPWSTR  pDest, 
    IN LPCWSTR  pSource, 
    IN int      iLen
    )
{
    LPCWSTR pHead = pSource;

    //
    // avoid modifying iLen
    //

    int iRealLen = iLen;

    //
    // skip the leading white spaces. Make sure that our target
    // is decreasing at the same rate.

    while (*pHead != L'\0' && iswspace(*pHead) && iRealLen)
    {
        ++pHead;
        --iRealLen;
    }

    if (iRealLen <= 0)
    {
        pDest[0] = L'\0';
    }
    else
    {
        //
        // caller guarantees the pDest if long enough
        //

        wcsncpy(pDest, pHead, iRealLen);
        while (iLen > 1 && iswspace(pDest[iRealLen - 1]))
        {
            --iRealLen;
        }

        //
        // 0 terminate it
        //

        pDest[iRealLen] = '\0';
    }
};

/*
Routine Description: 

Name:

    EscSeekToChar

Functionality:
    
    Will find the target character (wchChar) in the pszSource. If found, the return
    pointer points to that character. Any backslash characeter L'\\' will cause an escape.
    If such escape happens, then pbEscaped parameter will pass back true.
    If no escape is found, then, pbEscaped will pass back false. The return result in case of
    of no escape depends on bEndIfNotFound. If bEndIfNotFound is true, then the return value
    points to the 0 terminator the source pszSource, otherwise, it returns NULL.

    This escaping won't happen if the special characters (wchChar and the escaped chars) are
    inside a quoted string.

Virtual:
    
    N/A.
    
Arguments:

    pszSource       - source.

    wchChar         - The sought wchar.

    pbEscaped       - passback whether it has really been escaped.

    bEndIfNotFound  - whether we should return the end of the source or not 
                      if the sought char is not found

Return Value:

    If the wchar is not found:
        NULL if bEndIfNotFound == false;
        End of the source if bEndIfNotFound == true;
    
    If the wchar is found:
        address of the sought character.

Notes:
    User must pass in valid parameter values.

*/

LPCWSTR 
EscSeekToChar (
    IN LPCWSTR  pszSource, 
    IN WCHAR    wchChar, 
    OUT bool  * pbEscaped, 
    IN bool     bEndIfNotFound
    )
{
    *pbEscaped = false;

    //
    // flag if we are currently escaping
    //

    bool bIsEscaping = false;

    //
    // flag if we are currently inside a quoted string
    //

    bool bIsInsideQuote = false;

    while (*pszSource != L'\0')
    {
        if (bIsEscaping)
        {
            bIsEscaping = false;
            ++pszSource;
        }
        else if (*pszSource == L'\\')
        {
            ++pszSource;
            bIsEscaping = true;
            *pbEscaped = true;
        }
        else if (*pszSource == wchChar && !bIsInsideQuote)
        {
            //
            // found it
            //

            return pszSource;
        }
        else
        {
            //
            // see if we are starting a quoted section
            //

            if (*pszSource == L'"')
            {
                bIsInsideQuote = !bIsInsideQuote;
            }
            ++pszSource;
        }
    }

    if (bEndIfNotFound)
    {
        return pszSource;
    }
    else
    {
        return NULL;
    }
}

/*
Routine Description: 

Name:

    EscapeStringData

Functionality:
    
    Given source (pszStr) string, we will produce a destination string, which will
    have the backslash character added in front of the characters that need escape.

Virtual:
    
    N/A.
    
Arguments:

    pszStr  - source.

    pbstr   - receives the result.

    bQuote  - flag if we should quote the result string or not.

Return Value:

    Success: WBEM_NO_ERROR
    
    Failure: (1) WBEM_E_INVALID_PARAMETER.
             (2) WBEM_E_OUT_OF_MEMORY.

Notes:

*/

HRESULT 
EscapeStringData (
    IN LPCWSTR    pszStr,
    OUT BSTR    * pbstr, 
    IN bool       bQuote
    )
{
    if (pszStr == NULL || pbstr == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    DWORD dwEscCharCount = GetEscapeCharCount(pszStr);
    DWORD dwStrLen = wcslen(pszStr);

    DWORD dwTotalLen = dwStrLen + dwEscCharCount + (bQuote ? 2 : 0) + 1;

    *pbstr = ::SysAllocStringLen(NULL, dwTotalLen);
    if (*pbstr == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // nothing to escape
    //

    if (dwEscCharCount == 0)
    {
        //
        // add quote if necessary
        //

        LPWSTR lpszCur = *pbstr;
        if (bQuote)
        {
            lpszCur[0] = wchQuote;
            ++lpszCur;
        }

        ::memcpy(lpszCur, pszStr, dwStrLen * sizeof(WCHAR));

        if (bQuote)
        {
            (*pbstr)[dwTotalLen - 2] = wchQuote;
        }

        (*pbstr)[dwTotalLen - 1] = L'\0';

    }
    else
    {    
        //
        // do some real escaping here
        //

        LPWSTR pszCur = *pbstr;

        //
        // add L'\"' if necessary
        //

        if (bQuote)
        {
            *pszCur = wchQuote;
            ++pszCur;
        }

        //
        // do escaping copy
        //

        bool bIsEscaping = false;
        while (*pszStr != L'\0')
        {
            if (!bIsEscaping && ::IsEscapedChar(*pszStr))
            {
                *pszCur = L'\\';
                ++pszCur;
            }

            if (!bIsEscaping && *pszStr == L'\\')
            {
                bIsEscaping = true;
            }
            else if (bIsEscaping)
            {
                bIsEscaping = false;
            }

            *pszCur = *pszStr;

            ++pszCur;
            ++pszStr;
        }

        //
        // add L'\"' if necessary
        //

        if (bQuote)
        {
            *pszCur = wchQuote;
            ++pszCur;
        }

        *pszCur = L'\0';
    }

    return WBEM_NO_ERROR;
}

/*
Routine Description: 

Name:

    DeEscapeStringData

Functionality:
    
    Inverse of EscapeStringData. See EscapeStringData for functionality.

Virtual:
    
    N/A.
    
Arguments:

    pszStr  - source.

    pbstr   - receives the result.

    bQuote  - flag if we should get rid of the startind and ending quote.

Return Value:

    Success: WBEM_NO_ERROR
    
    Failure: (1) WBEM_E_INVALID_PARAMETER.
             (2) WBEM_E_OUT_OF_MEMORY.

Notes:

*/

HRESULT 
DeEscapeStringData (
    IN LPCWSTR    pszStr,
    OUT BSTR    * pbstr,
    IN bool       bTrimQuote 
    )
{
    if (pszStr == NULL || pbstr == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pbstr = NULL;
    DWORD dwLen = wcslen(pszStr);

    LPCWSTR pszCurSrc = pszStr;

    //
    // there is a start quote
    //

    if (bTrimQuote && *pszCurSrc == wchQuote)  
    {
        //
        // there must be an ending quote
        //

        if (dwLen < 2 || pszCurSrc[dwLen - 1] != wchQuote)
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        //
        // skip the leading quote
        //

        ++pszCurSrc;

        //
        // need two characters less
        //

        dwLen -= 2;
    }

    *pbstr = ::SysAllocStringLen(NULL, dwLen + 1);

    if (*pbstr != NULL)
    {
        LPWSTR pszCur = *pbstr;
        do
        {
            if (*pszCurSrc == L'\\')
            {

                //
                // escape it
                //

                ++pszCurSrc;
            }

            *pszCur = *pszCurSrc;
            ++pszCur;

            if (*pszCurSrc == L'\0')
            {
                break;
            }

            ++pszCurSrc;

        } while ((pszCurSrc - pszStr) <= dwLen);

        *pszCur = L'\0';
    }

    return (*pbstr != NULL) ? WBEM_NO_ERROR : WBEM_E_OUT_OF_MEMORY;
}

//=========================================================================

/*
Routine Description: 

Name:

    CMapStringToVt::CMapStringToVt

Functionality:
    
    constructor. We will create the map using the passed in array information.

Virtual:
    
    No.
    
Arguments:

    dwCount     - The count of the array pInfoArray.

    pInfoArray  - The array that has the information.

Return Value:

    none

Notes:
    Caller must guarantee that pInfoArray is at least as many elements as dwCount.

*/

CMapStringToVt::CMapStringToVt (
    IN DWORD          dwCount, 
    IN VtTypeStruct * pInfoArray
    )
{
    for (DWORD dwIndex = 0; dwIndex < dwCount; ++dwIndex)
    {
        m_Map.insert(MapStringToVt::value_type(pInfoArray[dwIndex].pszVtTypeString, pInfoArray[dwIndex].vt));
    }
}

/*
Routine Description: 

Name:

    CMapStringToVt::GetType

Functionality:
    
    Given the string version of variant type information, translate it to VARTYPE value.

Virtual:
    
    No.
    
Arguments:

    pszTypeStr  - The string version of the VARTYPE info.

    pSubType    - The array element's type if pszTypeStr is an array's type string.

Return Value:

    If pszTypeStr is in correct format, we return the appropriate VARTYPE.

    Otherwise, we return VT_EMPTY

Notes:

*/

VARTYPE CMapStringToVt::GetType (
    IN LPCWSTR    pszTypeStr,
    OUT VARTYPE * pSubType      OPTIONAL
    )
{
    //
    // look up
    //

    MapStringToVt::iterator it = m_Map.find(pszTypeStr);

    if (pSubType)
    {
        *pSubType = VT_EMPTY;
    }

    if (it != m_Map.end())
    {
        VARTYPE vt = (*it).second;
        if (::IsVT_Array(vt))
        {
            if (pSubType)
            {
                *pSubType = ::GetSubType(vt);
            }
            return VT_ARRAY;
        }
        else
        {
            return vt;
        }
    }
    
    return VT_EMPTY;
}


/*
Routine Description: 

Name:

    CMapVtToString::CMapVtToString

Functionality:
    
    Constructor. We will create the map.

Virtual:
    
    No.
    
Arguments:

    dwCount     - The count of the array pInfoArray.

    pInfoArray  - The array that has the information.

Return Value:

    None.

Notes:
    Caller must guarantee that pInfoArray is at least as many elements as dwCount.

*/

CMapVtToString::CMapVtToString (
    IN DWORD          dwCount, 
    IN VtTypeStruct * pInfoArray
    )
{
    for (DWORD dwIndex = 0; dwIndex < dwCount; ++dwIndex)
        m_Map.insert(MapVtToString::value_type(pInfoArray[dwIndex].vt, pInfoArray[dwIndex].pszVtTypeString));
}

/*
Routine Description: 

Name:

    CMapVtToString::GetTypeString

Functionality:
    
    Given VARTYPE and (if vt == VT_ARRAY) array element's type, it returns
    our formatted string representation of the type.

Virtual:
    
    No.
    
Arguments:

    vt     - The VARTYPE.

    vtSub  - The array's element's type if vt == VT_ARRAY. Otherwise, it's ignored.

Return Value:

    NULL if the type is not supported.

    The global string. As the prototype indicates, this return value is constant.

Notes:
    If vt == VT_ARRAY, then vtSub must contain a valid vt type that we support

*/

LPCWSTR 
CMapVtToString::GetTypeString (
    IN VARTYPE vt,
    IN VARTYPE vtSub
    )
{
    MapVtToString::iterator it;
    if (::IsVT_Array(vt))
    {
        it = m_Map.find(vt | vtSub);
    }
    else
    {
        it = m_Map.find(vt);
    }

    if (it != m_Map.end())
    {
        return (*it).second;
    }
    
    return NULL;
}

/*
Routine Description: 

Name:

    CMapVtToString::GetTypeString

Functionality:
    
    Given VARTYPE, it returns our formatted string representation of the type.

Virtual:
    
    No.
    
Arguments:

    vt     - The VARTYPE.

Return Value:

    NULL if the type is not supported.

    The global string. As the prototype indicates, this return value is constant.

Notes:
    (1) If vt == VT_ARRAY, then vtSub must contain a valid vt type that we support.
    (2) This version of the override doesn't work for array types.

*/

LPCWSTR 
CMapVtToString::GetTypeString (
    IN VARTYPE vt
    )
{
    MapVtToString::iterator it = m_Map.find(vt);
    if (it != m_Map.end())
    {
        return (*it).second;
    }
    else
    {
        return NULL;
    }
}


//=========================================================================
// implementations for class CScePropertyMgr

/*
Routine Description: 

Name:

    CScePropertyMgr::CScePropertyMgr

Functionality:
    
    constructor. Trivial

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    none

Notes:
    Consider initializing additional members if you need to add them.

*/

CScePropertyMgr::CScePropertyMgr ()
{
}

/*
Routine Description: 

Name:

    CScePropertyMgr::~CScePropertyMgr

Functionality:
    
    Destructor. Trivial since we only have smart pointer members that automatically initialize themselves.

Virtual:
    
    No. Since we never intend to have sub-classes.
    
Arguments:

    None.

Return Value:

    none

Notes:
    Consider freeing additional members if you need to add them.

*/

CScePropertyMgr::~CScePropertyMgr()
{
}

/*
Routine Description: 

Name:

    CScePropertyMgr::Attach

Functionality:
    
    Attach the object to our property manager. You can safely reattach another
    object to this manager.

Virtual:
    
    No.
    
Arguments:

    pObj    - the object this manager will be attached to.

Return Value:

    none

Notes:
    Caller must not call any property access functions until a valid attachment has
    been established.

*/

void 
CScePropertyMgr::Attach (
    IN IWbemClassObject *pObj
    )
{
    m_srpClassObj.Release();
    m_srpClassObj = pObj;
}

/*
Routine Description: 

Name:

    CScePropertyMgr::PutProperty

Functionality:
    
    Put a variant property for the given property.

Virtual:
    
    No.
    
Arguments:

    pszProperty - The property's name.

    pVar        - The value for the property.

Return Value:

    Whatever IWbemClassObject::Put returns.

Notes:

*/

HRESULT 
CScePropertyMgr::PutProperty (
    IN LPCWSTR    pszProperty, 
    IN VARIANT  * pVar
    )
{
    return m_srpClassObj->Put(pszProperty, 0, pVar, CIM_EMPTY);
}

/*
Routine Description: 

Name:

    CScePropertyMgr::PutProperty

Functionality:
    
    Put a string valued property for the given property.

Virtual:
    
    No.
    
Arguments:

    pszProperty - The property's name.

    pszValue    - The string value for the property.

Return Value:

    Success: Whatever IWbemClassObject::Put returns.
    
    Failure: Either WBEM_E_OUT_OF_MEMORY or whatever IWbemClassObject::Put returns.

Notes:

*/

HRESULT 
CScePropertyMgr::PutProperty ( 
    IN LPCWSTR pszProperty,
    IN LPCWSTR pszValue
    )
{
    HRESULT hr = WBEM_NO_ERROR;

    //
    // WMI always wants variant
    //

    CComVariant var(pszValue);

    if (var.vt != VT_ERROR)
    {
        hr = m_srpClassObj->Put(pszProperty, 0, &var, CIM_EMPTY);
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

/*
Routine Description: 

Name:

    CScePropertyMgr::PutProperty

Functionality:
    
    Put an integral valued property for the given property.

Virtual:
    
    No.
    
Arguments:

    pszProperty - The property's name.

    dwValue     - The value for the property. SCE_NULL_INTEGER is an invalid SCE integral value

Return Value:

    Success: Whatever IWbemClassObject::Put returns.
    
    Failure: whatever IWbemClassObject::Put returns.

Notes:
    We have observed that WMI will always promote all 4-byte integral types to VT_I4.

*/

HRESULT 
CScePropertyMgr::PutProperty (
    IN LPCWSTR  pszProperty,
    IN DWORD    dwValue
    )
{
    HRESULT hr = WBEM_NO_ERROR; 
    
    //
    // no need to worry about resource leaking, so, use straight forward variant
    //

    VARIANT var;
    V_VT(&var) = VT_I4;

    if (dwValue == SCE_NULL_INTEGER)
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
        V_I4(&var) = dwValue;
        hr = m_srpClassObj->Put(pszProperty, 0, &var, CIM_EMPTY);
    }

    return hr;
}

/*
Routine Description: 

Name:

    CScePropertyMgr::PutProperty

Functionality:
    
    Put an float valued property for the given property.

Virtual:
    
    No.
    
Arguments:

    pszProperty - The property's name.

    fValue      - The value for the property.

Return Value:

    Success: Whatever IWbemClassObject::Put returns.
    
    Failure: whatever IWbemClassObject::Put returns.

Notes:

*/

HRESULT 
CScePropertyMgr::PutProperty (
    IN LPCWSTR  pszProperty,
    IN float    fValue
    )
{
    //
    // no need to worry about resource leaking, so, use straight forward variant
    //

    VARIANT var;    
    V_VT(&var) = VT_R4;
    V_R4(&var) = fValue;

    return m_srpClassObj->Put(pszProperty, 0, &var, CIM_EMPTY);
}

/*
Routine Description: 

Name:

    CScePropertyMgr::PutProperty

Functionality:
    
    Put a double value property for the given property.

Virtual:
    
    No.
    
Arguments:

    pszProperty - The property's name.

    dValue      - The value for the property.

Return Value:

    Success: Whatever IWbemClassObject::Put returns.
    
    Failure: whatever IWbemClassObject::Put returns.

Notes:

*/

HRESULT 
CScePropertyMgr::PutProperty ( 
    IN LPCWSTR  pszProperty,
    IN double   dValue
    )
{
    //
    // no need to worry about resource leaking, so, use straight forward variant
    //

    VARIANT var;
    V_VT(&var) = VT_R8;
    V_DATE(&var) = dValue;

    return m_srpClassObj->Put(pszProperty, 0, &var, CIM_DATETIME);
}

/*
Routine Description: 

Name:

    CScePropertyMgr::PutProperty

Functionality:
    
    Put a boolean value property for the given property.

Virtual:
    
    No.
    
Arguments:

    pszProperty - The property's name.

    bValue      - The value for the property.

Return Value:

    Success: Whatever IWbemClassObject::Put returns.
    
    Failure: whatever IWbemClassObject::Put returns.

Notes:

*/

HRESULT 
CScePropertyMgr::PutProperty (
    IN LPCWSTR  pszProperty,
    IN bool     bValue
    )
{
    //
    // no need to worry about resource leaking, so, use straight forward variant
    //

    VARIANT var;
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = bValue ? VARIANT_TRUE : VARIANT_FALSE;

    return m_srpClassObj->Put(pszProperty, 0, &var, CIM_EMPTY);
}

/*
Routine Description: 

Name:

    CScePropertyMgr::PutProperty

Functionality:
    
    Put a name list (string) value property for the given property.

Virtual:
    
    No.
    
Arguments:

    pszProperty - The property's name.

    strList     - A SCE specific linked list.

Return Value:

    Success: Whatever IWbemClassObject::Put returns.
    
    Failure: whatever IWbemClassObject::Put returns.

Notes:

*/

HRESULT 
CScePropertyMgr::PutProperty (
    IN LPCWSTR          pszProperty, 
    IN PSCE_NAME_LIST   strList
    )
{
    //
    // make sure that our parameters are in good shape to proceed
    //

    if (NULL == pszProperty || *pszProperty == 0 || NULL == strList)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if (NULL == strList)
    {
        //
        // nothing to save
        //

        return WBEM_NO_ERROR;
    }

    HRESULT hr = WBEM_NO_ERROR;

    //
    // find count of the list
    //

    long lCount = 0;
    PSCE_NAME_LIST pTemp;

    for ( pTemp = strList; pTemp != NULL; pTemp=pTemp->Next)
    {
        lCount++;
    }

    if ( lCount == 0 )
    {
        //
        // nothing to save
        //

        return hr;
    }

    CComVariant varValueArray;

    //
    // create a bstr safearray
    //

    SAFEARRAYBOUND sbArrayBounds ;

    sbArrayBounds.cElements = lCount;
    sbArrayBounds.lLbound   = 0;

    //
    // will put all the names inside SCE_NAME_LIST into the safe array
    //

    if (V_ARRAY(&varValueArray) = ::SafeArrayCreate(VT_BSTR, 1, &sbArrayBounds))
    {
        V_VT(&varValueArray) = VT_BSTR | VT_ARRAY ;

        pTemp = strList;
        for (long j = 0; SUCCEEDED(hr) && pTemp != NULL ; pTemp=pTemp->Next)
        {
            CComVariant varVal(pTemp->Name);
            if (varVal.vt == VT_BSTR)
            {
                hr = ::SafeArrayPutElement(V_ARRAY(&varValueArray), &j, varVal.bstrVal);
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                break;
            }
            j++;
        }

        //
        // only put if we succeeded in the previous actions
        //

        if (SUCCEEDED(hr))
        {
            hr = m_srpClassObj->Put(pszProperty, 0, &varValueArray, CIM_EMPTY);
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

/*
Routine Description: 

Name:

    CScePropertyMgr::GetProperty

Functionality:
    
    Get the property's value in variant form.

Virtual:
    
    No.
    
Arguments:

    pszProperty - The property's name.

    pVar        - receives the value.

Return Value:

    Success: Whatever IWbemClassObject::Get returns.
    
    Failure: whatever IWbemClassObject::Get returns.

Notes:

*/

HRESULT 
CScePropertyMgr::GetProperty (
    IN LPCWSTR    pszProperty,
    OUT VARIANT * pVar
    )
{
    return m_srpClassObj->Get(pszProperty, 0, pVar, NULL, NULL);
}

/*
Routine Description: 

Name:

    CScePropertyMgr::GetProperty

Functionality:
    
    Get the property's value in bstr form.

Virtual:
    
    No.
    
Arguments:

    pszProperty - The property's name.

    pbstrValues - receives bstr value.

Return Value:

    Success: Whatever IWbemClassObject::Get returns, or
             WBEM_S_RESET_TO_DEFAULT if the value is not returned from the wbem object.
    
    Failure: whatever IWbemClassObject::Get returns.

Notes:
    Caller must not pass NULL for the out parameter. 
    Caller is responsible for releasing the received bstr.

*/

HRESULT 
CScePropertyMgr::GetProperty (
    IN LPCWSTR    pszProperty,
    OUT BSTR    * pbstrValue
    )
{
    *pbstrValue = NULL;

    //
    // we don't know what this Get will give us, but we are asking for BSTR
    // so, let the CComVariant take care of the resource issues
    CComVariant varVal;
    HRESULT hr = m_srpClassObj->Get(pszProperty, 0, &varVal, NULL, NULL);

    if (varVal.vt == VT_BSTR && wcslen(varVal.bstrVal) > INTERNET_MAX_PATH_LENGTH)
    {
        hr = WBEM_E_INVALID_METHOD_PARAMETERS;
    }
    else if (varVal.vt == VT_BSTR)
    {
        *pbstrValue = ::SysAllocString(varVal.bstrVal);
        if (*pbstrValue == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else if(varVal.vt == VT_EMPTY || varVal.vt == VT_NULL ) 
    {
        hr = WBEM_S_RESET_TO_DEFAULT;
    }

    return hr;
}

/*
Routine Description: 

Name:

    CScePropertyMgr::GetProperty

Functionality:
    
    Get the property's value in DWORD form.

Virtual:
    
    No.
    
Arguments:

    pszProperty - The property's name.

    pdwValue    - receives DWORD value.

Return Value:

    Success: Whatever IWbemClassObject::Get returns, or
             WBEM_S_RESET_TO_DEFAULT if the value is not returned from the wbem object.
    
    Failure: whatever IWbemClassObject::Get returns.

Notes:
    Caller must not pass NULL for the out parameter.

*/

HRESULT 
CScePropertyMgr::GetProperty (
    IN LPCWSTR    pszProperty,
    OUT DWORD   * pdwValue
    )
{
    //
    // this is a unusable integer for SCE
    //

    *pdwValue = SCE_NULL_INTEGER;

    //
    // we are asking for int, but Get may not give us that
    //

    CComVariant var;
    HRESULT hr = m_srpClassObj->Get(pszProperty, 0, &var, NULL, NULL);

    if (SUCCEEDED(hr))
    {
        if (var.vt == VT_I4) 
        {
            *pdwValue = var.lVal;
        }
        else if (var.vt == VT_UI4)
        {
            *pdwValue = var.ulVal;
        }
        else if (var.vt == VT_BOOL)
        {
            *pdwValue = (var.boolVal == VARIANT_TRUE) ? 1 : 0;
        }
        else if (var.vt == VT_EMPTY || var.vt == VT_NULL )
        {
            *pdwValue = SCE_NO_VALUE;
            hr = WBEM_S_RESET_TO_DEFAULT;
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CScePropertyMgr::GetProperty

Functionality:
    
    Get the property's value in boolean form.

Virtual:
    
    No.
    
Arguments:

    pszProperty - The property's name.

    pbValue     - receives DWORD value.

Return Value:

    Success: Whatever IWbemClassObject::Get returns, or
             WBEM_S_RESET_TO_DEFAULT if the value is not returned from the wbem object.
    
    Failure: whatever IWbemClassObject::Get returns.

Notes:
    Caller must not pass NULL for the out parameter.

*/

HRESULT 
CScePropertyMgr::GetProperty ( 
    IN LPCWSTR pszProperty,
    OUT bool *pbValue
    )
{
    *pbValue = false;
    
    CComVariant var;

    HRESULT hr = m_srpClassObj->Get(pszProperty, 0, &var, NULL, NULL);

    if (var.vt == VT_BOOL) 
    {
        *pbValue = (var.boolVal == VARIANT_TRUE) ? true : false;
    }
    else if (var.vt == VT_EMPTY || var.vt == VT_NULL )
    {
        *pbValue = false;
        hr = WBEM_S_RESET_TO_DEFAULT;
    }
    
    return hr;
}

/*
Routine Description: 

Name:

    CScePropertyMgr::GetProperty

Functionality:
    
    Get the property's value in string list form (SCE specific)

Virtual:
    
    No.
    
Arguments:

    pszProperty - The property's name.

    strList     - receives names list.

Return Value:

    Success: Whatever IWbemClassObject::Get returns, or
             WBEM_S_RESET_TO_DEFAULT if the value is not returned from the wbem object.
    
    Failure: whatever IWbemClassObject::Get returns.

Notes:
    Caller must not pass NULL for the out parameter.

*/

HRESULT 
CScePropertyMgr::GetProperty ( 
    IN LPCWSTR           pszProperty, 
    OUT PSCE_NAME_LIST * strList
    )
{
    *strList = NULL;

    CComVariant var;
    HRESULT hr = m_srpClassObj->Get(pszProperty, 0, &var, NULL, NULL);

    if (SUCCEEDED(hr)) 
    {
        if ( var.vt == (VT_BSTR | VT_ARRAY) ) 
        {
            //
            // walk the array
            //

            if( var.parray )
            {

                LONG lDimension  = 1;
                LONG lLowerBound = 0;
                LONG lUpperBound = 0;
                BSTR bstrElement = NULL;

                SafeArrayGetLBound ( var.parray , lDimension , &lLowerBound ) ;
                SafeArrayGetUBound ( var.parray , lDimension , &lUpperBound ) ;

                for ( LONG lIndex = lLowerBound ; lIndex <= lUpperBound ; lIndex++ )
                {
                    ::SafeArrayGetElement ( var.parray , &lIndex , &bstrElement ) ;

                    if ( bstrElement ) 
                    {

                        //
                        // add it to the list
                        //

                        SCESTATUS rc = SceAddToNameList(strList, bstrElement, 0);

                        ::SysFreeString(bstrElement);
                        bstrElement = NULL;

                        if ( rc != SCESTATUS_SUCCESS ) 
                        {

                            //
                            // SCE returned errors needs to be translated to HRESULT.
                            // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
                            //

                            hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
                            break;
                        }
                    }
                }
            }

        } 
        else if (var.vt == VT_EMPTY || var.vt == VT_NULL ) 
        {
            hr = WBEM_S_RESET_TO_DEFAULT;
        }

    }

    if ( FAILED(hr) && *strList ) 
    {
        SceFreeMemory(*strList, SCE_STRUCT_NAME_LIST);
        *strList = NULL;
    }

    return hr;
}

/*
Routine Description: 

Name:

    CScePropertyMgr::GetExpandedPath

Functionality:
    
    Given a path's property name, we will get the path property and expand it, if necessary,
    and then pass back the expanded path to the caller.

Virtual:
    
    No.
    
Arguments:

    pszPathName         - Property name for the path.

    pbstrExpandedPath   - receives the expanded path.

    pbIsDB              - Confirms if this is a database (.sdb) path or not.

Return Value:

    Success: Various success code.
    
    Failure: various error code. Any of them indicates failure to get the property and
             expanded it.

Notes:
    Caller must not pass NULL for the out parameters.

*/

HRESULT 
CScePropertyMgr::GetExpandedPath (
    IN LPCWSTR    pszPathName,
    OUT BSTR    * pbstrExpandedPath,
    OUT BOOL    * pbIsDB
    )
{
    if (pbstrExpandedPath == NULL || pbIsDB == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pbstrExpandedPath = NULL;
    *pbIsDB = false;
    CComBSTR bstrPath;

    HRESULT hr = GetProperty(pszPathName, &bstrPath);

    if (SUCCEEDED(hr) && hr != WBEM_S_RESET_TO_DEFAULT)
    {
        hr = CheckAndExpandPath(bstrPath, pbstrExpandedPath, pbIsDB);
    }
    else
    {
        hr = WBEM_E_NOT_AVAILABLE;
    }

    return hr;
}

//========================================================================================
// implementation of CSceStore

/*
Routine Description: 

Name:

    CSceStore::CSceStore

Functionality:
    
    constructor. Trivial

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    none

Notes:
    Consider initializing additional members if you need to add them.

*/

CSceStore::CSceStore() 
    : 
    m_SceStoreType(SCE_STORE_TYPE_INVALID)
{
}


/*
Routine Description: 

Name:

    CSceStore::SetPersistProperties

Functionality:
    
    Inform the store what type of persistence context it is expected to handle.

    The caller calls this function to indicate that it is expected to handle persistence
    on behalf of this wbem object. The store path is available as the property value
    of the given proeprty name.

Virtual:
    
    No.
    
Arguments:

    pClassObj               - the object.

    lpszPathPropertyName    - path's property name.

Return Value:

    Whatever CScePropertyMgr::GetExpandedPath returns.

Notes:

*/

HRESULT 
CSceStore::SetPersistProperties (
    IN IWbemClassObject * pClassObj,
    IN LPCWSTR            lpszPathPropertyName
    )
{
    //
    // CScePropertyMgr helps us to access WMI object's properties
    // create an instance and attach the WMI object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pClassObj);
    
    //
    // get the expanded persist path
    //

    m_bstrExpandedPath.Empty();

    //
    // now, we need to get the path property and see what type of store we are expectig to deal with
    //

    BOOL bIsDB = FALSE;
    HRESULT hr = ScePropMgr.GetExpandedPath(lpszPathPropertyName, &m_bstrExpandedPath, &bIsDB);

    //
    // cache our store type information.
    //

    m_SceStoreType = (SCE_STORE_TYPE)(bIsDB ? SCE_STORE_TYPE_CONFIG_DB : SCE_STORE_TYPE_TEMPLATE);

    return hr;
}

/*
Routine Description: 

Name:

    CSceStore::SetPersistPath

Functionality:
    
    Inform the store what type of persistence context it is expected to handle by directly
    giving the store path. Since store type is determined by the path name, this is all we need.

Virtual:
    
    No.
    
Arguments:

    pszPath - the given path.

Return Value:

    Success: whatever MakeSingleBackSlashPath returns.

    Failure: WBEM_E_INVALID_PARAMETER or
             whatever CheckAndExpandPath returns or whatever MakeSingleBackSlashPath returns.

Notes:

*/

HRESULT 
CSceStore::SetPersistPath (
    IN LPCWSTR pszPath
    )
{
    if (pszPath == NULL || *pszPath == L'\0')
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
    //
    // clean up first
    //

    m_bstrExpandedPath.Empty();
    m_SceStoreType = SCE_STORE_TYPE_INVALID;
    
    //
    // now expand the path if necessary
    //

    CComBSTR bstrStorePath;
    BOOL bIsDB = FALSE;
    
    HRESULT hr = ::CheckAndExpandPath(pszPath, &bstrStorePath, &bIsDB);

    if (SUCCEEDED(hr))
    {
        hr = ::MakeSingleBackSlashPath(bstrStorePath, L'\\', &m_bstrExpandedPath);
    
        //
        // cache our store type
        //

        if (SUCCEEDED(hr) && m_bstrExpandedPath)
        {
            m_SceStoreType = (SCE_STORE_TYPE)(bIsDB ? SCE_STORE_TYPE_CONFIG_DB : SCE_STORE_TYPE_TEMPLATE);
        }
    }
    return hr;
}

/*
Routine Description: 

Name:

    CSceStore::WriteSecurityProfileInfo

Functionality:
    
    Delegate the call to Sce backend supported function in a hope to isolate persistence
    functionalities. See Sce API for detail.

Virtual:
    
    No.
    
Arguments:

    Area            - Area info.
    ppInfoBuffer    - buffer
    pErrlog         - Error log
    bAppend         - Whether this is appending or not.

Return Value:

    Translated HRESULT from whatever SceWriteSecurityProfileInfo or 
    SceAppendSecurityProfileInfo returns.

Notes:
    See Sce API for detail.

*/

HRESULT 
CSceStore::WriteSecurityProfileInfo (
    IN AREA_INFORMATION       Area,
    IN PSCE_PROFILE_INFO      ppInfoBuffer,
    OUT PSCE_ERROR_LOG_INFO * pErrlog,
    IN bool                   bAppend
    )const
{
    HRESULT hr = WBEM_NO_ERROR;
    if (m_SceStoreType == SCE_STORE_TYPE_TEMPLATE)
    {
        SCESTATUS rc = SCESTATUS_SUCCESS;
        if (bAppend)
        {
            rc = ::SceAppendSecurityProfileInfo(m_bstrExpandedPath, Area, ppInfoBuffer, pErrlog);
        }
        else
        {
            rc = ::SceWriteSecurityProfileInfo(m_bstrExpandedPath, Area, ppInfoBuffer, pErrlog);
        }

        if ( rc != SCESTATUS_SUCCESS )
        {
            //
            // SCE returned errors needs to be translated to HRESULT.
            // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
            //

            hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
        }
    }
    return hr;
}

/*
Routine Description: 

Name:

    CSceStore::SavePropertyToDB

Functionality:
    
    Will save the string data into a database store.

Virtual:
    
    No.
    
Arguments:

    pszSection  - Section name.
    pszKey      - Key name
    pszData     - string data

Return Value:

    Translated HRESULT from whatever SceOpenProfile or SceSetDatabaseSetting returns.

Notes:
    See Sce API for detail.

*/

HRESULT 
CSceStore::SavePropertyToDB (
    IN LPCWSTR pszSection, 
    IN LPCWSTR pszKey, 
    IN LPCWSTR pszData
    )const
{
    PVOID hProfile = NULL;

    SCESTATUS rc = ::SceOpenProfile(m_bstrExpandedPath, SCE_JET_FORMAT, &hProfile);

    HRESULT hr;
    if ( SCESTATUS_SUCCESS == rc ) 
    {
        DWORD dwDataSize = (pszData != NULL) ? wcslen(pszData) * sizeof(*pszData) : 0;
        rc = ::SceSetDatabaseSetting(
                                   hProfile,
                                   SCE_ENGINE_SMP,
                                   (PWSTR)pszSection,   // these casting are caused by SceSetDatabaseSetting prototyping errors
                                   (PWSTR)pszKey,       // prototyping errors
                                   (PWSTR)pszData,      // prototyping errors
                                   dwDataSize);

        //
        // SCE returned errors needs to be translated to HRESULT.
        // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
        //

        hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));

        ::SceCloseProfile(&hProfile);
    }
    else
    {
        //
        // SCE returned errors needs to be translated to HRESULT.
        //

        hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
    }

    return hr;
}

/*
Routine Description: 

Name:

    CSceStore::SavePropertyToStore

Functionality:
    
    Will save the string data into a store. This is store neutral call.

Virtual:
    
    No.
    
Arguments:

    pszSection  - Section name.

    pszKey      - Key name

    pszValue    - string data

Return Value:

    Translated HRESULT from whatever WritePrivateProfileSection/ WritePrivateProfileString 
    or SavePropertyToDB returns.

Notes:
    See Sce API for detail.
    There is a very legacy (rooted at .INF) problem: save and delete uses the same function.
    its behavior depends on the parameters passed in. This is confusing at least.

*/

HRESULT 
CSceStore::SavePropertyToStore (
    IN LPCWSTR pszSection, 
    IN LPCWSTR pszKey, 
    IN LPCWSTR pszValue
    )const
{

    if ( wcslen(m_bstrExpandedPath) == 0 || pszSection == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if (m_SceStoreType == SCE_STORE_TYPE_STREAM)
    {
        //
        //we don't not supporting custom persistence yet
        //

        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT hr = WBEM_E_NOT_SUPPORTED;

    if (m_SceStoreType == SCE_STORE_TYPE_CONFIG_DB)
    {
        hr = SavePropertyToDB(pszSection, pszKey, pszValue);
    }
    else if (m_SceStoreType == SCE_STORE_TYPE_TEMPLATE)
    {
        hr = WBEM_NO_ERROR;

        BOOL bWriteResult = FALSE;
        if ( pszKey == NULL )   
        {
            //
            // delete the key
            //

            bWriteResult = ::WritePrivateProfileSection(pszSection, NULL, m_bstrExpandedPath);
        }
        else    
        {
            //
            // may be deleting the (key, value) if pszValue == NULL
            //

            bWriteResult = ::WritePrivateProfileString(pszSection, pszKey, pszValue, m_bstrExpandedPath);
        }

        if (!bWriteResult)
        {
            //
            // GetLastError() eeds to be translated to HRESULT.
            // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
            //

            hr = ProvDosErrorToWbemError(GetLastError());
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CSceStore::SavePropertyToStore

Functionality:
    
    Will save the DWORD data property into a store. This is store neutral call.

Virtual:
    
    No.
    
Arguments:

    pszSection  - Section name.

    pszKey      - Key name

    dwData      - DWORD data

Return Value:

    if error happens before writing.

        WBEM_E_NOT_SUPPORTED, 
        WBEM_E_INVALID_PARAMETER and 
        WBEM_E_OUT_OF_MEMORY

    If writing is attempted, then

        Translated HRESULT from whatever WritePrivateProfileSection/WritePrivateProfileString 
        or SavePropertyToDB returns.

Notes:
    See MSDN for INF file API's.
    There is a very legacy (rooted at .INF) problem: save and delete uses the same function.
    its behavior depends on the parameters passed in. This is confusing at least.

*/

HRESULT 
CSceStore::SavePropertyToStore (
    IN LPCWSTR pszSection, 
    IN LPCWSTR pszKey, 
    IN DWORD   dwData
    )const
{
    if ( wcslen(m_bstrExpandedPath) == 0 || pszSection == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if (m_SceStoreType == SCE_STORE_TYPE_STREAM)
    {    
        //
        //we don't not supporting custom persistence yet
        //

        return WBEM_E_NOT_SUPPORTED;
    }

    LPCWSTR pszData = NULL;
    WCHAR wchData[MAX_INT_LENGTH];

    //
    // need to format pszData to write
    //

    if (pszKey != NULL && dwData != SCE_NO_VALUE)
    {   
        //
        // this is safe even though prefast will complain
        //

        swprintf(wchData, L"%d", dwData);
        pszData = wchData;
    }

    HRESULT hr;

    //
    // if it is saving to database store
    //

    if (m_SceStoreType == SCE_STORE_TYPE_CONFIG_DB)
    {
        hr = SavePropertyToDB(pszSection, pszKey, pszData);
    }
    else if (m_SceStoreType == SCE_STORE_TYPE_TEMPLATE)
    {
        BOOL bWriteResult = FALSE;
        if ( pszKey == NULL ) 
        {
            //
            // delete the section
            //

            bWriteResult = ::WritePrivateProfileSection(pszSection, NULL, m_bstrExpandedPath);
        }
        else 
        {
            //
            // set data, might be deleting when pszData == NULL
            //

            bWriteResult = ::WritePrivateProfileString(pszSection, pszKey, pszData, m_bstrExpandedPath);
        }
        
        if (!bWriteResult)
        {
            //
            // GetLastError() eeds to be translated to HRESULT.
            // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
            //

            hr = ProvDosErrorToWbemError(GetLastError());
        }
    }

    return hr;
}


/*
Routine Description: 

Name:

    CSceStore::SavePropertyToStore

Functionality:
    
    This is a very SCE specific save. It pretty much format the data and save.
    See its use for any samples.

Virtual:
    
    No.
    
Arguments:

    pszSection  - Section name.

    pszKey      - Key name

    dwData      - DWORD data

Return Value:

    if error happens before writing.

        WBEM_E_NOT_SUPPORTED, 
        WBEM_E_INVALID_PARAMETER and 
        WBEM_E_OUT_OF_MEMORY

    If writing is attempted, then

        Translated HRESULT from whatever WritePrivateProfileSection/WritePrivateProfileString 
        or SavePropertyToDB returns.

Notes:
    See MSDN for INF file API's

*/

HRESULT CSceStore::SavePropertyToStore ( 
    IN LPCWSTR pszSection, 
    IN LPCWSTR pszKey, 
    IN DWORD   dwData, 
    IN WCHAR   delim, 
    IN LPCWSTR pszValue
    )const
{
    if ( wcslen(m_bstrExpandedPath) == 0 || pszSection == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if (m_SceStoreType == SCE_STORE_TYPE_STREAM)
    {
        //
        //we don't not supporting custom persistence yet
        //

        return WBEM_E_NOT_SUPPORTED;
    }


    LPWSTR pszData = NULL;

    //
    // need to format pszData
    //

    if (pszKey != NULL && dwData != SCE_NO_VALUE)
    {
        pszData = new WCHAR[MAX_INT_LENGTH + 1 + wcslen(pszValue) + 1];
        if (pszData == NULL)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        if ( pszValue )
        {
            swprintf(pszData, L"%d%c%s", dwData, delim, pszValue);
        }
        else
        {
            swprintf(pszData, L"%d", dwData);
        }
    }

    HRESULT hr;
    if (m_SceStoreType == SCE_STORE_TYPE_CONFIG_DB)
    {
        hr = SavePropertyToDB(pszSection, pszKey, pszData);
    }
    else if (m_SceStoreType == SCE_STORE_TYPE_TEMPLATE)
    {
        BOOL bWriteResult = FALSE;
        if ( pszKey == NULL )  
        {
            //
            // delete the section
            //

            bWriteResult = ::WritePrivateProfileSection(pszSection, NULL, m_bstrExpandedPath);
        }

        else    
        {
            //
            // when ( dwData == SCE_NO_VALUE ) we will delete the key, that is accomplished by pszData == NULL
            //

            bWriteResult = ::WritePrivateProfileString(pszSection, pszKey, pszData, m_bstrExpandedPath);
        }
        
        if (!bWriteResult)
        {
            //
            // GetLastError() eeds to be translated to HRESULT.
            // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
            //

            hr = ProvDosErrorToWbemError(GetLastError());
        }
    }

    delete [] pszData;
    return hr;
}

/*
Routine Description: 

Name:

    CSceStore::WriteAttachmentSection

Functionality:
    
    SCE backend won't be able to import an INF template for non-native sections
    unless there is a entry in its Attachments section. This is to write (for a
    particular non-native section) such an entry.

Virtual:
    
    No.
    
Arguments:

    pszKey      - The section name.

    pszData     - value for the key. This is not pretty much ignored for now.

Return Value:

    Success: WBEM_NO_ERROR

    Failure: Translated HRESULT from whatever WritePrivateProfileString returns.

Notes:
    (1) See MSDN for INF file API's.
    (2) This is No-Op for database store.

*/

HRESULT 
CSceStore::WriteAttachmentSection (
    IN LPCWSTR pszKey,
    IN LPCWSTR pszData
    )const
{
    HRESULT hr = WBEM_NO_ERROR;

    if (m_SceStoreType == SCE_STORE_TYPE_TEMPLATE)
    {
        BOOL bWriteResult = ::WritePrivateProfileString(pAttachmentSections, pszKey, pszData, m_bstrExpandedPath);
        
        if (!bWriteResult)
        {
            //
            // GetLastError() eeds to be translated to HRESULT.
            // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
            //

            hr = ProvDosErrorToWbemError(GetLastError());
        }
    }
    return hr;
}


/*
Routine Description: 

Name:

    CSceStore::DeleteSectionFromStore

Functionality:
    
    remove the entire section.

Virtual:
    
    No.
    
Arguments:

    pszSection  - The section name. Must NOT be NULL.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: Whatever SavePropertyToStore or WriteAttachmentSection returns.

Notes:

*/

HRESULT 
CSceStore::DeleteSectionFromStore (
    IN LPCWSTR pszSection
    )const
{
    HRESULT hr = SavePropertyToStore(pszSection, (LPCWSTR)NULL, (LPCWSTR)NULL);

    //
    // we should also delete the attachment entry because all are gone now.
    //

    if (SUCCEEDED(hr))
    {
        hr = WriteAttachmentSection(pszSection, (LPCWSTR)NULL);
    }

    return hr;
}


/*
Routine Description: 

Name:

    CSceStore::GetPropertyFromStore

Functionality:
    
    Get the named property value into a string buffer. This is store neutral.

Virtual:
    
    No.
    
Arguments:

    pszSection  - The section name. Must NOT be NULL.

    pszKey      - The key name.

    ppszBuffer  - Receiving heap allocated memory containing the string. Must NOT be NULL.

    pdwRead     - receives information about how many bytes we have read. Must NOT be NULL.

Return Value:

    Success: WBEM_NO_ERROR

    Failure: Translated HRESULT from whatever GetPrivateProfileString returns.

Notes:
    (1) caller must free memory allocated by this function

*/

HRESULT 
CSceStore::GetPropertyFromStore (
    IN LPCWSTR   pszSection, 
    IN LPCWSTR   pszKey, 
    IN LPWSTR  * ppszBuffer,
    IN DWORD   * pdwRead
    )const
{
    if ( wcslen(m_bstrExpandedPath) == 0    || 
         pszSection                 == NULL || 
         ppszBuffer                 == NULL || 
         pdwRead                    == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pdwRead = 0;
    *ppszBuffer = NULL;
    
    HRESULT hr;
    if (m_SceStoreType == SCE_STORE_TYPE_CONFIG_DB)
    {
        hr = GetPropertyFromDB(pszSection, pszKey, ppszBuffer, pdwRead);
    }
    else if (m_SceStoreType == SCE_STORE_TYPE_STREAM)
    {
        //
        //we don't not supporting custom persistence yet
        //

        return WBEM_E_NOT_SUPPORTED;
    }
    else if (m_SceStoreType == SCE_STORE_TYPE_TEMPLATE)
    {
        int TotalLength = MAX_PATH;
        *ppszBuffer = new WCHAR[TotalLength];

        if (ppszBuffer == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            //
            // try to read the buffer out
            //

            while (true)
            {
                *pdwRead = ::GetPrivateProfileString(pszSection, pszKey, NULL, *ppszBuffer, TotalLength, m_bstrExpandedPath);

                if (*pdwRead > 0 && *pdwRead < TotalLength - 1)
                {   
                    //
                    // everything is read out
                    //

                    hr = WBEM_NO_ERROR;
                    break;
                }
                else if (*pdwRead > 0)
                {   
                    //
                    // buffer is most likely truncated, will try to continue unless out of memory
                    //

                    delete [] *ppszBuffer;

                    if (TotalLength < 0x00010000)
                    {
                        //
                        // if TotalLength is small enough, we will double its length
                        //

                        TotalLength *= 2;
                    }
                    else
                    {
                        //
                        // if TotalLength is already big, we will try to add 0x00100000 more bytes
                        //

                        TotalLength += 0x00010000;
                    }

                    *ppszBuffer = new WCHAR[TotalLength];

                    if (*ppszBuffer == NULL)
                    {
                        *pdwRead = 0;
                        hr = WBEM_E_OUT_OF_MEMORY;
                        break;
                    }
                }
                else
                {
                    //
                    // *pdwRead == 0
                    //

                    //
                    // GetLastError() needs to be translated to HRESULT.
                    // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
                    //

                    hr = ProvDosErrorToWbemError(GetLastError());
                    
                    //
                    // if no error is encountered, then we will simply say we can't find the property
                    //

                    if (SUCCEEDED(hr))
                    {
                        hr = WBEM_E_NOT_FOUND;
                    }

                    break;
                }
            }
        }

        //
        // if we say we failed, then better not return any valid string pointer to caller
        //

        if (FAILED(hr) && *ppszBuffer)
        {
            delete [] *ppszBuffer;

            *ppszBuffer = NULL;
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CSceStore::GetPropertyFromDB

Functionality:
    
    Get the named property's value into a string buffer. This is database store specific.

Virtual:
    
    No.
    
Arguments:

    pszSection  - The section name. Must NOT be NULL.

    pszKey      - The key name.

    ppszBuffer  - Receiving heap allocated memory containing the string. Must NOT be NULL.

    pdwRead     - receives information about how many bytes we have read. Must NOT be NULL.

Return Value:

    Success: WBEM_NO_ERROR

    Failure: Translated HRESULT from whatever WritePrivateProfileString returns.

Notes:
    (1) caller must free memory allocated by this function

*/

HRESULT 
CSceStore::GetPropertyFromDB (
    IN LPCWSTR    pszSection, 
    IN LPCWSTR    pszKey, 
    IN LPWSTR   * ppszBuffer,
    IN DWORD    * pdwRead
    )const
{
    if ( wcslen(m_bstrExpandedPath) == 0 || pszSection == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if (m_SceStoreType == SCE_STORE_TYPE_STREAM)
    {
        //
        //we don't not supporting custom persistence yet
        //

        return WBEM_E_NOT_SUPPORTED;
    }

    *pdwRead = 0;
    *ppszBuffer = NULL;

    HRESULT hr;

    if (m_SceStoreType == SCE_STORE_TYPE_CONFIG_DB)
    {
        //
        // get the information from database
        //

        PVOID hProfile=NULL;
        LPWSTR pszSceBuffer = NULL;

        SCESTATUS rc = ::SceOpenProfile(m_bstrExpandedPath, SCE_JET_FORMAT, &hProfile);

        if ( SCESTATUS_SUCCESS == rc ) 
        {
            rc = ::SceGetDatabaseSetting (
                                         hProfile,
                                         SCE_ENGINE_SMP,
                                         (PWSTR)pszSection,
                                         (PWSTR)pszKey,
                                         &pszSceBuffer,           // needs to be freed, use LocalFree!!!
                                         pdwRead
                                         );

            ::SceCloseProfile(&hProfile);
        }

        //
        // SCE returned errors needs to be translated to HRESULT.
        // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
        //

        hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));

        if (SUCCEEDED(hr) && *pdwRead > 0 && pszSceBuffer != NULL)
        {
            long lLen = wcslen(pszSceBuffer);
            *ppszBuffer = new WCHAR[lLen + 1];

            if (*ppszBuffer == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
            else
            {
                ::memcpy(*ppszBuffer, pszSceBuffer, sizeof(WCHAR) * (lLen + 1));
            }
        }

        ::LocalFree(pszSceBuffer);
    }
    
    return hr;
}

/*
Routine Description: 

Name:

    CSceStore::GetSecurityProfileInfo

Functionality:
    
    Delegate the call to SceGetSecurityProfileInfo in an effort to hide the sce
    persistence detail from caller.

Virtual:
    
    No.
    
Arguments:

    Area        - Area of the profile section.

    ppInfo      - Receiving the profile info.

    pErrlog     - Receiving the error log info.

Return Value:

    Success: WBEM_NO_ERROR

    Failure: Translated HRESULT from whatever SceOpenProfile/SceGetSecurityProfileInfo returns.

Notes:
    (1) This is very SCE specific function.
    (2) Caller must remember to call FreeSecurityProfileInfo to free the resource allocated by
        this function through ppInfo.
    (3) See SCE API for detail.

*/

HRESULT 
CSceStore::GetSecurityProfileInfo (
    IN AREA_INFORMATION       Area,
    OUT PSCE_PROFILE_INFO   * ppInfo,
    OUT PSCE_ERROR_LOG_INFO * pErrlog
    )const
{
    if (ppInfo == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppInfo = NULL;

    SCETYPE ProfileType = (m_SceStoreType == SCE_INF_FORMAT) ? SCE_ENGINE_SCP : SCE_ENGINE_SMP;

    PVOID hProfile = NULL;

    SCE_FORMAT_TYPE SceFormatType = SCE_INF_FORMAT;

    if (m_SceStoreType == SCE_STORE_TYPE_CONFIG_DB)
    {
        SceFormatType = SCE_JET_FORMAT;
    }

    SCESTATUS rc = SceOpenProfile(m_bstrExpandedPath, SceFormatType, &hProfile);

    if ( rc != SCESTATUS_SUCCESS )
    {
        //
        // SCE returned errors needs to be translated to HRESULT.
        //

        return ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
    }

    rc = SceGetSecurityProfileInfo(hProfile,
                                   ProfileType,
                                   Area,
                                   ppInfo,
                                   pErrlog
                                   );
    SceCloseProfile( &hProfile );

    if ( rc != SCESTATUS_SUCCESS || *ppInfo == NULL )
    {
        //
        // SCE returned errors needs to be translated to HRESULT.
        //

        return ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
    }

    return WBEM_NO_ERROR;
}

/*
Routine Description: 

Name:

    CSceStore::GetObjectSecurity

Functionality:
    
    Delegate the call to SceGetObjectSecurity in an effort to hide the sce
    persistence detail from caller.

Virtual:
    
    No.
    
Arguments:

    Area        - Area of the profile section.

    pszObjectName   - Name of the object.

    ppObjSecurity   - Receiving the security object.

Return Value:

    Success: WBEM_NO_ERROR

    Failure: Translated HRESULT from whatever SceOpenProfile/SceGetObjectSecurity returns.

Notes:
    (1) This is very SCE specific function.
    (2) Caller must remember to call FreeObjectSecurit to free the resource allocated by
        this function through ppObjSecurity.
    (3) See SCE API for detail.

*/

HRESULT 
CSceStore::GetObjectSecurity (
    IN AREA_INFORMATION       Area,
    IN LPCWSTR                pszObjectName,
    IN PSCE_OBJECT_SECURITY * ppObjSecurity
    )const
{
    if (ppObjSecurity == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppObjSecurity = NULL;
    SCETYPE ProfileType = (m_SceStoreType == SCE_INF_FORMAT) ? SCE_ENGINE_SCP : SCE_ENGINE_SMP;

    PVOID hProfile = NULL;

    //
    // let's assume INF format
    //

    SCE_FORMAT_TYPE SceFormatType = SCE_INF_FORMAT;

    if (m_SceStoreType == SCE_STORE_TYPE_CONFIG_DB)
    {
        SceFormatType = SCE_JET_FORMAT;
    }

    SCESTATUS rc = ::SceOpenProfile(m_bstrExpandedPath, SceFormatType, &hProfile);

    if ( rc != SCESTATUS_SUCCESS )
    {
        //
        // SCE returned errors needs to be translated to HRESULT.
        //

        return ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
    }

    //
    // the following cast (to PWSTR) is caused by a mistake in the prototype of SceGetObjectSecurity
    //

    rc = ::SceGetObjectSecurity (
                                hProfile, 
                                ProfileType, 
                                Area, 
                                (PWSTR)pszObjectName, 
                                ppObjSecurity 
                                );

    ::SceCloseProfile( &hProfile );

    if ( rc != SCESTATUS_SUCCESS || *ppObjSecurity == NULL )
    {
        //
        // SCE returned errors needs to be translated to HRESULT.
        // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
        //

        return ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
    }

    return WBEM_S_NO_ERROR;
}

//=========================================================================================
// CScePersistMgr implementation
//=========================================================================================

/*
Routine Description: 

Name:

    CScePersistMgr::CScePersistMgr

Functionality:
    
    Constructor. trivial since all our current members will automatically create themselves.

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    none

Notes:
    Consider initializing your members if you add more non-self-constructing members..

*/

CScePersistMgr::CScePersistMgr ()
{
}

/*
Routine Description: 

Name:

    CScePersistMgr::~CScePersistMgr

Functionality:
    
    Destructor. Just do a cleanup.

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    none

Notes:
    Consider adding cleanup code if you add more non-self-destructing members..

*/

CScePersistMgr::~CScePersistMgr ()
{
}


/*
Routine Description: 

Name:

    CScePersistMgr::Attach

Functionality:
    
    Attach an object (that knows how to provide properties) to this persistence manager so
    that it knows where to get data for persistence.

    Any use of this class without a successfuly attaching object will cause catastrophic failure.
    This function is the first thing you need to do with CScePersistMgr object.

Virtual:
    
    Yes. (function of IScePersistMgr)
    
Arguments:

    guid    - the in-coming interface pointer (pObj) interface guid. Currently, we only support
              IID_ISceClassObject.

    pObj    - the attaching object's interface pointer. Currently, we only take ISceClassObject*.

Return Value:

    Success: S_OK.

    Failure: 
        (1) E_NOINTERFACE if the supplied interface is not supported.
        (2) E_INVALIDARG if pObj is NULL.

Notes:
    Currently, we only work with ISceClassObject interface.

*/

STDMETHODIMP 
CScePersistMgr::Attach ( 
    IN REFIID     guid,    // [in]
    IN IUnknown * pObj     // [iid_is][in]
    )
{
    if (pObj == NULL)
    {
        return E_INVALIDARG;
    }
    
    if (guid == IID_ISceClassObject)
    {
        return pObj->QueryInterface(IID_ISceClassObject, (void**)&m_srpObject);
    }
    else
    {
        return E_NOINTERFACE;
    }
}

/*
Routine Description: 

Name:

    CScePersistMgr::Save

Functionality:
    
    Save an attached instance into a store.

Virtual:
    
    Yes. (function of IScePersistMgr)
    
Arguments:

    None.

Return Value:

    Success: successful code (use SUCCEEDED(hr) to test). No guarantee the return result will be S_OK.

    Failure: 
        (1) E_UNEXPECTED no successful attachment was ever done.
        (2) Other error code.

Notes:
    Since this is a regular COM server interface function, we will in most cases return well known COM
    HRESULTs instead of WMI specific HRESULTs. However, this is no WMI specific, be prepared to see
    your result results in WMI specific HRESULTs.

*/        

STDMETHODIMP 
CScePersistMgr::Save ()
{
    HRESULT hr = S_OK;

    if (m_srpObject == NULL)
    {
        return E_UNEXPECTED;
    }
    else if (FAILED(hr = m_srpObject->Validate()))
    {
        return hr;
    }
    
    DWORD dwDump;

    //
    // need to set the store path and we must have a store path.
    //

    CComBSTR bstrPersistPath;
    CComBSTR bstrExpandedPath;
    hr = m_srpObject->GetPersistPath(&bstrPersistPath);

    if (FAILED(hr))
    {
        return hr;
    }
    
    //
    // Prepare a store (for persistence) for this store path (file)
    //

    CSceStore SceStore;
    hr = SceStore.SetPersistPath(bstrPersistPath);
    if (FAILED(hr))
    {
        return hr;
    }
    

    //
    // For a new .inf file. Write an empty buffer to the file
    // will creates the file with right header/signature/unicode format
    // this is harmless for existing files.
    // For database store, this is a no-op.
    //

    hr = SceStore.WriteSecurityProfileInfo (
                                            AreaBogus,
                                            (PSCE_PROFILE_INFO)&dwDump, 
                                            NULL, 
                                            false   // not appending
                                            );
    
    //
    // now, we need to form a section, which will be the class name
    //

    CComBSTR bstrSectionName;
    hr = GetSectionName(&bstrSectionName);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // this is necessary for any extension class
    // SCE doesn't care about the value, so, we are using a static value here
    //

    hr = SceStore.WriteAttachmentSection(bstrSectionName, pszAttachSectionValue);
    if (FAILED(hr))
    {
        return hr;
    }
    
    //
    // now we need to get all key property names to form a unique key for the section
    //

    DWORD dwCookie = INVALID_COOKIE;
    CComBSTR bstrCompoundKey;
    hr = GetCompoundKey(&bstrCompoundKey);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // now create the current list of instances in this store for the class
    // so that we can add the new one (its cookie). 
    // Extension classes are identified by their instance cookies. 
    //

    CExtClassInstCookieList clsInstCookies;
    hr = clsInstCookies.Create(&SceStore, bstrSectionName, GetKeyPropertyNames(NULL, NULL));

    if (SUCCEEDED(hr))
    {
        //
        // add this class to the cookie list
        //

        //
        // We are adding the compound key and potentially requesting (by INVALID_COOKIE) a new cookie.
        //

        hr = clsInstCookies.AddCompKey(bstrCompoundKey, INVALID_COOKIE, &dwCookie);

        if (SUCCEEDED(hr))
        {
            //
            // save the new list of instances.
            // key properties are save with cookie list.
            //

            hr = clsInstCookies.Save(&SceStore, bstrSectionName);
        }
    }
    
    //
    // non-key properties
    //

    if (SUCCEEDED(hr))
    {
        hr = SaveProperties(&SceStore, dwCookie, bstrSectionName);
    }

    return hr;
}
        
/*
Routine Description: 

Name:

    CScePersistMgr::Load

Functionality:
    
    Loading instance(s) from a store. Depending on attached object (which may or may not have complete
    key information), this load may be a single instanace loading if complete key is available, or 
    a multiple instance loading (if no complete key is available).

Virtual:
    
    Yes. (function of IScePersistMgr)
    
Arguments:

    bstrStorePath   - the path to the store.

    pHandler        - COM interface pointer to notify WMI if instance(s) are loaded.

Return Value:

    Success: successful code (use SUCCEEDED(hr) to test). No guarantee the return result will be S_OK.

    Failure: 
        (1) E_UNEXPECTED no successful attachment was ever done.
        (2) WBEM_E_NOT_FOUND if there is no such instance.
        (2) Other error code.

Notes:
    Since this is a regular COM server interface function, we will in most cases return well known COM
    HRESULTs instead of WMI specific HRESULTs. However, this is no WMI specific, be prepared to see
    your result results in WMI specific HRESULTs.

*/ 

STDMETHODIMP 
CScePersistMgr::Load (
    IN BSTR              bstrStorePath,
    IN IWbemObjectSink * pHandler
    )
{
    HRESULT hr = S_OK;

    if (m_srpObject == NULL)
    {
        return E_UNEXPECTED;
    }
    else if (FAILED(hr = m_srpObject->Validate()))
    {
        return hr;
    }

    CComBSTR bstrSectionName;

    //
    // we have an attached object, we must also know the section 
    // (actually, as it is now, it's the name of the class)
    //

    hr = GetSectionName(&bstrSectionName);
    if (FAILED(hr))
    {
        return hr;
    }
    
    //
    // Prepare a store (for persistence) for this store path (file)
    //

    CSceStore SceStore;
    SceStore.SetPersistPath(bstrStorePath);

    //
    // Need to know what instances (their cookies) are present in the store for this class.
    //

    CExtClassInstCookieList clsInstCookies;

    hr = clsInstCookies.Create(&SceStore, bstrSectionName, GetKeyPropertyNames(NULL, NULL));
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // get this attached object's cookie if possible (in non-querying loading)
    //

    DWORD dwCookie;
    CComBSTR bstrCompoundKey;

    //
    // it returns WBEM_S_FALSE if no compound key can be returned.
    //

    hr = GetCompoundKey(&bstrCompoundKey);

    //
    // if we can't create a complete compound cookie, then we are querying
    //

    if (hr == WBEM_S_FALSE)
    {
        //
        // we will track first error during querying
        //

        HRESULT hrFirstError = WBEM_NO_ERROR;

        DWORD dwResumeHandle = 0;
        CComBSTR bstrEachCompKey;

        //
        // will try to load everything. Enumerate through the cookies...
        //

        hr = clsInstCookies.Next(&bstrEachCompKey, &dwCookie, &dwResumeHandle);

        while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
        {
            //
            // as long as there is more item, keep looping
            //

            if (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
            {
                CComPtr<IWbemClassObject> srpNewObj;

                //
                // LoadInstance will return WBEM_S_FALSE if there is no such instance.
                //

                hr = LoadInstance(&SceStore, bstrSectionName, bstrEachCompKey, dwCookie, &srpNewObj);
                if (SUCCEEDED(hr) && hr != WBEM_S_FALSE)
                {
                    hr = pHandler->Indicate(1, &srpNewObj);
                }

                //
                // we will track first error during querying
                //
                
                if (SUCCEEDED(hrFirstError) && FAILED(hr))
                {
                    hrFirstError = hr;
                }
            }

            //
            // prepare to be re-used
            //

            bstrEachCompKey.Empty();

            //
            // next cookie
            //

            hr = clsInstCookies.Next(&bstrEachCompKey, &dwCookie, &dwResumeHandle);
        }
        
        //
        // if error have happened, then we will pass that error back while trying our best to query
        //

        if (FAILED(hrFirstError))
        {
            hr = hrFirstError;
        }
    }
    else if (SUCCEEDED(hr))
    { 
        //
        // unique instance load, we can get the cookie!
        //

        ExtClassCookieIterator it;
        dwCookie = clsInstCookies.GetCompKeyCookie(bstrCompoundKey, &it);

        //
        // We must have a cookie since this instance is unique
        //

        if (dwCookie != INVALID_COOKIE)
        {
            CComPtr<IWbemClassObject> srpNewObj;

            //
            // LoadInstance will return WBEM_S_FALSE if there is no such instance.
            //

            hr = LoadInstance(&SceStore, bstrSectionName, bstrCompoundKey, dwCookie, &srpNewObj);

            if (SUCCEEDED(hr) && hr != WBEM_S_FALSE)
            {
                hr = pHandler->Indicate(1, &srpNewObj);
            }
            else if ( hr == WBEM_S_FALSE)
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
        else
        {
            hr = WBEM_E_NOT_FOUND;
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CScePersistMgr::LoadInstance

Functionality:
    
    Loading a single instanace with the given cookie.

Virtual:
    
    No.
    
Arguments:

    pSceStore       - the store.

    pszSectionName  - the section name.

    pszCompoundKey  - the compound key.

    dwCookie        - the cookie.

    ppObj           - Receives the WMI object.

Return Value:

    Success: 
        (1) S_OK if instance is loaded.
        (2) WBEM_S_FALSE if no such instance is found.

    Failure: 
        (1) various error codes.

Notes:
    (1) This is a private helper, we don't check all validity of the attached object.
    (2) Since this is a regular COM server interface function, we will in most cases return well known COM
        HRESULTs instead of WMI specific HRESULTs. However, this is no WMI specific, be prepared to see
        your result results in WMI specific HRESULTs.
    (3) This routine can be enhanced to get rid of the compound key parameter since once a cookie is found
        all key property information is available via the use of CCompoundKey.

*/ 

HRESULT 
CScePersistMgr::LoadInstance (
    IN CSceStore         *  pSceStore,
    IN LPCWSTR              pszSectionName,
    IN LPCWSTR              pszCompoundKey, 
    IN DWORD                dwCookie,
    OUT IWbemClassObject ** ppObj
    )
{

    if (ppObj == NULL || pszCompoundKey == NULL || *pszCompoundKey == L'\0')
    {
        return E_INVALIDARG;
    }

    CComPtr<IWbemClassObject> srpObj;
    HRESULT hr = m_srpObject->GetClassObject(&srpObj);
    
    //
    // spawn a new instance, we won't pass it back until everything is loaded successfully
    // so, this is a local object at this point.
    //

    CComPtr<IWbemClassObject> srpNewObj;
    hr = srpObj->SpawnInstance(0, &srpNewObj);

    DWORD dwLoadedProperties = 0;
    
    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(hr))
        {
            //
            // CScePropertyMgr helps us to access WMI object's properties
            // create an instance and attach the WMI object to it.
            // This will always succeed.
            //

            CScePropertyMgr ScePropMgr;
            ScePropMgr.Attach(srpNewObj);
            
            //
            // store path is the only property not managed by the ISceClassObject
            //

            hr = ScePropMgr.PutProperty(pStorePath, pSceStore->GetExpandedPath());
            if (FAILED(hr))
            {
                return hr;
            }

            //
            // pszCompoundKey == pszNullKey means loading singleton (foreign object)
            // or an abstract method call. So, pszNullKey means no need to populate
            // key properties.
            //

            if (_wcsicmp(pszCompoundKey, pszNullKey) != 0)
            {
                hr = ::PopulateKeyProperties(pszCompoundKey, &ScePropMgr);
            }

            if (FAILED(hr))
            {
                return hr;
            }
            
            //
            // now read the non-key properties and set each one
            //

            DWORD dwCount = 0;
            m_srpObject->GetPropertyCount(SceProperty_NonKey, &dwCount);
            
            for (int i = 0; i < dwCount; i++)
            {
                CComBSTR bstrPropName;
                CComBSTR bstrKey;

                //
                // get i-th property name
                //

                hr = FormatNonKeyPropertyName(dwCookie, i, &bstrKey, &bstrPropName);
                if (FAILED(hr))
                {
                    break;
                }
                
                DWORD dwRead = 0;

                //
                // need to delete this memory
                //

                LPWSTR pszBuffer = NULL;

                //
                // the property may not be present in the store.
                // So, ignore the result since the property may be missing in the store
                //
                
                if (SUCCEEDED(pSceStore->GetPropertyFromStore(pszSectionName, bstrKey, &pszBuffer, &dwRead)))
                {
                    //
                    // translate the string to a variant and set the property
                    //

                    CComVariant var;
                    hr = ::VariantFromFormattedString(pszBuffer, &var);

                    if (SUCCEEDED(hr))
                    {
                        ScePropMgr.PutProperty(bstrPropName, &var);
                    }
                }

                delete [] pszBuffer;
            }

            if (SUCCEEDED(hr))
            {
                //
                // give it to the out-bound parameter
                //

                *ppObj = srpNewObj.Detach();
                hr = S_OK;
            }
            else
            {
                hr = WBEM_S_FALSE;  // no instance loaded
            }
        }
    }

    return hr;
}
        
/*
Routine Description: 

Name:

    CScePersistMgr::Delete

Functionality:
    
    Delete an instance from the store.

Virtual:
    
    Yes. (function of IScePersistMgr)
    
Arguments:

    bstrStorePath   - the store.

    pHandler        - COM interface to notify WMI of successful operation.

Return Value:

    Success: 
        (1) Various success codes.

    Failure: 
        (1) E_UNEXPECTED means no successfully attached object.
        (1) various other error codes.

Notes:

*/

STDMETHODIMP 
CScePersistMgr::Delete (
    IN BSTR bstrStorePath,
    IN IWbemObjectSink *pHandler
    )
{

    if (m_srpObject == NULL)
    {
        return E_UNEXPECTED;
    }
    
    if (bstrStorePath == NULL || pHandler == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
    //
    // we have an attached object, we must also know the section 
    // (actually, as it is now, it's the name of the class)
    //

    CComBSTR bstrSectionName;
    HRESULT hr = GetSectionName(&bstrSectionName);

    if (SUCCEEDED(hr))
    {
        CComBSTR bstrCompoundKey;
        hr = GetCompoundKey(&bstrCompoundKey);

        //
        // Prepare a store (for persistence) for this store path (file)
        //

        CSceStore SceStore;
        SceStore.SetPersistPath(bstrStorePath);

        //
        // if we can't create a complete compound cookie, then we are deleting everything of the class
        //

        if (hr == WBEM_S_FALSE)
        {
            //
            // delete the whole section
            //

            SceStore.DeleteSectionFromStore(bstrSectionName);
        }
        else if (SUCCEEDED(hr))
        {
            //
            // unique instance delete
            // now create the instance list (cookies are enough) for the class
            //

            CExtClassInstCookieList clsInstCookies;
            hr = clsInstCookies.Create(&SceStore, bstrSectionName, GetKeyPropertyNames(NULL, NULL));

            if (SUCCEEDED(hr))
            {
                //
                // see if we are really deleting the last one?
                // if yes, then we can simply delete the section.
                //

                ExtClassCookieIterator it;
                DWORD dwCookie = clsInstCookies.GetCompKeyCookie(bstrCompoundKey, &it);

                if (dwCookie != INVALID_COOKIE && clsInstCookies.GetCookieCount() == 1)
                {
                    //
                    // Yes, there is only one cookie and this is the one, so everything is gone
                    //

                    SceStore.DeleteSectionFromStore(bstrSectionName);
                }
                else
                {

                    //
                    // remove the instance's key properties from the in-memory cookie list
                    //

                    dwCookie = clsInstCookies.RemoveCompKey(&SceStore, bstrSectionName, bstrCompoundKey);

                    //
                    // save the new list, this will effectively remove the instance's key properties
                    // from the store. Key properties are saved as part of the cookie list
                    //

                    hr = clsInstCookies.Save(&SceStore, bstrSectionName);

                    //
                    // now, delete non-key the properties
                    //

                    if (SUCCEEDED(hr))
                    {
                        hr = DeleteAllNonKeyProperties(&SceStore, dwCookie, bstrSectionName);
                    }
                }
            }
        }
        else
        {
            hr = WBEM_E_NOT_FOUND;
        }
    }

    //
    // Inform WMI that the action is complete
    //

    pHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

    return hr;
}

/*
Routine Description: 

Name:

    CScePersistMgr::SaveProperties

Functionality:
    
    Saves the non-key properties. Key properties are saved as part of the instance cookie list.

Virtual:
    
    No.
    
Arguments:

    pSceStore   - the store.

    dwCookie    - the instance cookie.

    pszSection  - the section name.

Return Value:

    Success: 
        (1) Various success codes.

    Failure: 
        (1) various error codes.

Notes:
    This is private helper. No checking against attached object's validity.

*/

HRESULT 
CScePersistMgr::SaveProperties (
    IN CSceStore * pSceStore,
    IN DWORD       dwCookie,
    IN LPCWSTR     pszSection
    )
{    
    DWORD dwCount = 0;

    HRESULT hr = m_srpObject->GetPropertyCount(SceProperty_NonKey, &dwCount);

    if (SUCCEEDED(hr))
    {
        for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++)
        {
            //
            // This is what is used to identify the property in the store.
            // When you save a property, use this name.
            //

            CComBSTR bstrStorePropName;

            //
            // real name of the property
            //

            CComBSTR bstrTrueName;

            //
            // get the dwIndex-th non-key property names
            //

            hr = FormatNonKeyPropertyName(dwCookie, dwIndex, &bstrStorePropName, &bstrTrueName);
            if (FAILED(hr))
            {
                break;
            }

            BSTR bstrData = NULL;

            //
            // get the dwIndex-th non-key property value in string format!
            //

            hr = FormatPropertyValue(SceProperty_NonKey, dwIndex, &bstrData);

            //
            // if a property is not present, we are fine with that.
            //

            if (SUCCEEDED(hr) && bstrData != NULL)
            {
                hr = pSceStore->SavePropertyToStore(pszSection, bstrStorePropName, bstrData);
                ::SysFreeString(bstrData);
            }

            if (FAILED(hr))
            {
                break;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CScePersistMgr::DeleteAllNonKeyProperties

Functionality:
    
    Delete the non-key properties. Key properties are saved/delete as part of the instance cookie list.

Virtual:
    
    No.
    
Arguments:

    pSceStore   - the store.

    dwCookie    - the instance cookie.

    pszSection  - the section name.

Return Value:

    Success: 
        (1) Various success codes.

    Failure: 
        (1) various error codes.

Notes:
    This is private helper. No checking against attached object's validity.

*/

HRESULT 
CScePersistMgr::DeleteAllNonKeyProperties (
    IN CSceStore * pSceStore,
    IN DWORD       dwCookie,
    IN LPCWSTR     pszSection
    )
{
    DWORD dwCount = 0;
    HRESULT hr = m_srpObject->GetPropertyCount(SceProperty_NonKey, &dwCount);

    HRESULT hrDelete = WBEM_NO_ERROR;

    if (SUCCEEDED(hr))
    {
        for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++)
        {
            //
            // This is what is used to identify the property in the store.
            // When you save a property, use this name.
            //

            CComBSTR bstrStorePropName;
            CComBSTR bstrTrueName;

            hr = FormatNonKeyPropertyName(dwCookie, dwIndex, &bstrStorePropName, &bstrTrueName);
            if (FAILED(hr))
            {
                break;
            }

            //
            // we will delete the property.
            // In case of error, such deletion will continue, but the error will be reported
            //

            hr = pSceStore->DeletePropertyFromStore(pszSection, bstrStorePropName);

            if (FAILED(hr))
            {
                hrDelete = hr;
            }
        }
    }

    return FAILED(hrDelete) ? hrDelete : hr;
}

/*
Routine Description: 

Name:

    CScePersistMgr::FormatNonKeyPropertyName

Functionality:
    
    Given a non-key property index, get the property's real name and its instance-specific 
    name inside a store.

    Currently, its name inside a store has the cookie's number prefixed to guarantee its
    uniquess inside a section. This is a result of the .INF file format limitations.

Virtual:
    
    No.
    
Arguments:

    dwCookie            - the instance cookie.

    dwIndex             - the index of the property.

    pbstrStorePropName  - The property's name inside the store for the instance

    pbstrTrueName       - The real name of the property

Return Value:

    Success: 
        (1) Various success codes.

    Failure: 
        (1) various error codes.

Notes:
    This is private helper. No checking against attached object's validity.

*/

HRESULT 
CScePersistMgr::FormatNonKeyPropertyName (
    IN DWORD    dwCookie,
    IN DWORD    dwIndex,
    OUT BSTR  * pbstrStorePropName,
    OUT BSTR  * pbstrTrueName 
    )
{
    if (pbstrStorePropName == NULL || pbstrTrueName == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pbstrStorePropName = NULL;
    *pbstrTrueName = NULL;

    //
    // We are only interested in the name, not the value
    //

    HRESULT hr = m_srpObject->GetPropertyValue(SceProperty_NonKey, dwIndex, pbstrTrueName, NULL);

    if (SUCCEEDED(hr))
    {
        int iNameLen = wcslen(*pbstrTrueName);

        *pbstrStorePropName = ::SysAllocStringLen(NULL, MAX_INT_LENGTH + iNameLen + 1);
        if (*pbstrStorePropName == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            //
            // prefix the real name with the cookie number.
            //

            wsprintf(*pbstrStorePropName, L"%d%s", dwCookie, *pbstrTrueName);
        }
    }

    if (FAILED(hr))
    {
        //
        // bstr might have been allocated. Free them
        //

        if (*pbstrTrueName != NULL)
        {
            ::SysFreeString(*pbstrTrueName);
            *pbstrTrueName = NULL;
        }

        if (*pbstrStorePropName != NULL)
        {
            ::SysFreeString(*pbstrStorePropName);
            *pbstrStorePropName = NULL;
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CScePersistMgr::FormatPropertyValue

Functionality:
    
    Given the type (key or non-key) of and its index (of the property), 
    get the property's value in string format.

    This works for both key and non-key properties.

Virtual:
    
    No.
    
Arguments:

    type            - what type of property (key or non-key).

    dwIndex         - the index of the property.

    pbstrValue      - receives the value in string format

Return Value:

    Success: 
        (1) Various success codes.

    Failure: 
        (1) various error codes.

Notes:
    This is private helper. No checking against attached object's validity.

*/

HRESULT 
CScePersistMgr::FormatPropertyValue (
    IN SceObjectPropertyType   type,
    IN DWORD                   dwIndex,
    OUT BSTR                 * pbstrValue
    )
{
    CComBSTR bstrName;
    CComVariant varValue;

    HRESULT hr = m_srpObject->GetPropertyValue(type, dwIndex, &bstrName, &varValue);

    *pbstrValue = NULL;

    if (SUCCEEDED(hr) && (varValue.vt != VT_EMPTY && varValue.vt != VT_NULL))
    {
        hr = ::FormatVariant(&varValue, pbstrValue);
    }

    return hr;
}

/*
Routine Description: 

Name:

    CScePersistMgr::GetCompoundKey

Functionality:
    
    Given the type (key or non-key) of and its index (of the property), 
    get the property's value in string format.

    This works for both key and non-key properties.

Virtual:
    
    No.
    
Arguments:

    pbstrKey      - receives compound key in string format. See header file for format explanation.

Return Value:

    Success: 
        (1) WBEM_S_FALSE if information doesn't give complete key properties.
        (2) WBEM_NO_ERROR if the compond key is successfully generated.

    Failure: 
        (1) various error codes.

Notes:
    This is private helper. No checking against attached object's validity.

*/

HRESULT 
CScePersistMgr::GetCompoundKey (
    OUT BSTR* pbstrKey
    )
{
    if (pbstrKey == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pbstrKey = NULL;

    DWORD dwCount = 0;
    HRESULT hr = m_srpObject->GetPropertyCount(SceProperty_Key, &dwCount);

    if (SUCCEEDED(hr) && dwCount == 0)
    {
        //
        // no key, must be singleton/static, thus no compound key
        //

        *pbstrKey = ::SysAllocString(pszNullKey);
        return WBEM_S_FALSE;
    }

    if (SUCCEEDED(hr))
    {

        //
        // these are the individual key property's format string
        //

        CComBSTR *pbstrKeyProperties = new CComBSTR[dwCount];

        if (pbstrKeyProperties == NULL)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        DWORD dwTotalLen = 0;

        //
        // for each key property, we will format the (prop, value) pair
        // into prop<vt:value> format
        //

        for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++)
        {
            CComVariant var;

            //
            // put the property name to pbstrKeyProperties[dwIndex] first.
            //

            hr = m_srpObject->GetPropertyValue(SceProperty_Key, dwIndex, &pbstrKeyProperties[dwIndex], &var);

            if (FAILED(hr) || var.vt == VT_NULL || var.vt == VT_EMPTY)
            {
                //
                // will quit because we don't have enough information, 
                // but just that we can't find the key property value.
                // We'd like to be more specific about the error. However, we have observed that
                // WMI will return inconsistent code for not finding the property. Sometimes it
                // simply returns success but without a value in the variant. But other times, it 
                // returns errors. We have to treat it as if the property is not present in the object.
                //

                hr = WBEM_S_FALSE;
                break;
            }

            //
            // put the variant's value in string format (like <VT_I4 : 123456>)
            //

            CComBSTR bstrData;
            hr = ::FormatVariant(&var, &bstrData);
            if (SUCCEEDED(hr))
            {
                //
                // append the value to pbstrKeyProperties[dwIndex] so that
                // pbstrKeyProperties[dwIndex] all have this format: PropName<VT_TYPE : value>
                //

                pbstrKeyProperties[dwIndex] += bstrData;
            }
            else
            {
                break;
            }

            //
            // so that we can re-use it
            //

            bstrData.Empty();

            //
            // keep track of total length
            //

            dwTotalLen += wcslen(pbstrKeyProperties[dwIndex]);
        }

        //
        // hr == WBEM_S_FALSE indicates no compound key
        //

        if (SUCCEEDED(hr) && hr != WBEM_S_FALSE)
        {
            //
            // now, we are ready to generate the final buffer for the caller
            // 1 for the '\0' terminator
            //

            *pbstrKey = ::SysAllocStringLen(NULL, dwTotalLen + 1);

            if (*pbstrKey != NULL)
            {
                //
                // pszCur is the current point to write
                //

                LPWSTR pszCur = *pbstrKey;
                DWORD dwLen;

                //
                // pack each pbstrKeyProperties[dwIndex] into the final bstr
                //

                for (dwIndex = 0; dwIndex < dwCount; dwIndex++)
                {
                    dwLen = wcslen(pbstrKeyProperties[dwIndex]);

                    //
                    // Since each pbstrKeyProperties[dwIndex] is a CComBSTR, 
                    // do some casting to remove any ambiguity.
                    //

                    ::memcpy(pszCur, (const void*)(LPCWSTR)(pbstrKeyProperties[dwIndex]), dwLen * sizeof(WCHAR));

                    //
                    // move the current write point
                    //

                    pszCur += dwLen;
                }

                (*pbstrKey)[dwTotalLen] = L'\0';
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }

        //
        // we are done with the individual parts
        //

        delete [] pbstrKeyProperties;
    }

    //
    // truly successfully generated the compound key
    //

    if (SUCCEEDED(hr) && hr != WBEM_S_FALSE)
    {
        hr = WBEM_NO_ERROR;
    }

    return hr;
}


/*
Routine Description: 

Name:

    GetKeyPropertyNames

Functionality:
    
    private helper. Will get this class's key property names vector


Virtual:
    
    No.
    
Arguments:

    pNamespace  - The provider namespace.
    
    pCtx        - The context pointer that we are given and pass around for WMI API's.

Return Value:

    Success: Non-NULL.

    Failure: NULL.

Notes:

*/

std::vector<LPWSTR>* 
CScePersistMgr::GetKeyPropertyNames (
    IN IWbemServices * pNamespace,
    IN IWbemContext  * pCtx
    )
{
    CComBSTR bstrClassName;
    HRESULT hr = GetClassName(&bstrClassName);

    if (FAILED(hr))
    {
        return NULL;
    }

    const CForeignClassInfo* pFCInfo = NULL;

    if (SUCCEEDED(hr))
    {
        pFCInfo = g_ExtClasses.GetForeignClassInfo(pNamespace, pCtx, bstrClassName);
    }

    if (pFCInfo == NULL)
    {
        return NULL;
    }
    else
    {
        return pFCInfo->m_pVecKeyPropNames;
    }
}

//
// Implementing those global helper parsing related functions.
//


/*
Routine Description: 

Name:

    FormatVariant

Functionality:
    
    Given a variant, we will get our format of string representing the variant value.
    For example, if pVar is of VT_I4 type and value 12345, this function will return:

            < VT_I4 : 12345 >;

    We also support arrays. For example, a safearray of bstrs that has "This is "
    value at its first element and "Microsoft SCE" at its second value will receive:

            < VT_ARRAY(VT_BSTR) : "This is " , "Microsoft SCE" >;


Virtual:
    
    N/A.
    
Arguments:

    pVar        - The variant.
    
    pbstrData   - The string (in our format) receives the formatted string.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: Various errors may occurs. 
             Most obvious is 
             WBEM_E_INVALID_SYNTAX, 
             WBEM_E_OUT_OF_MEMORY,
             WBEM_E_NOT_SUPPORTED

Notes:

*/

HRESULT 
FormatVariant (
    IN VARIANT  * pVar,
    OUT BSTR    * pbstrData
    )
{
    if (pVar == NULL || pbstrData == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_NO_ERROR;

    *pbstrData = NULL;

    //
    // if it is not a safearray
    //

    if ( (pVar->vt & VT_ARRAY) != VT_ARRAY)
    {
        CComBSTR bstrValue;
        hr = ::GetStringPresentation(pVar, &bstrValue);

        LPCWSTR pszType = gVtToStringMap.GetTypeString(pVar->vt);
        if (SUCCEEDED(hr) && pszType)
        {
            //
            // formatted string has both type and value information
            //

            ULONG uLen = wcslen(bstrValue);
            ULONG uTypeLen = wcslen(pszType);
            ULONG uTotalLen = uLen + uTypeLen + 4;
            
            //
            // don't be surprised that we do the formatting this way, it turns out that
            // wsprintf doesn't work for strings longer than 1K
            //

            *pbstrData = ::SysAllocStringLen(NULL, uTotalLen);

            if (*pbstrData != NULL)
            {
                //
                // this is the current point to write formatted string
                //

                LPWSTR pszCurDataPtr = *pbstrData;

                //
                // put the < character and move one index
                //

                pszCurDataPtr[0] = wchTypeValLeft;
                ++pszCurDataPtr;

                //
                // write the type string, like VT_BSTR, and move over that many characters
                //

                memcpy(pszCurDataPtr, pszType, uTypeLen * sizeof(WCHAR));
                pszCurDataPtr += uTypeLen;

                //
                // put the type and value separater, and move one index
                //

                pszCurDataPtr[0] = wchTypeValSep;
                ++pszCurDataPtr;

                //
                // put the value and value separater, and move over that many characters
                //

                memcpy(pszCurDataPtr, bstrValue, uLen * sizeof(WCHAR));

                pszCurDataPtr += uLen;

                //
                // put the < character and move one index
                //

                pszCurDataPtr[0] = wchTypeValRight;
                pszCurDataPtr[1] = L'\0';
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
           
        }
        else if (SUCCEEDED(hr))
        {
            hr = WBEM_E_NOT_SUPPORTED;
        }
    }
    else
    {
        hr = ::FormatArray(pVar, pbstrData);
    }

    return hr;
}

/*
Routine Description: 

Name:

    GetObjectPath

Functionality:
    
    Given a store path and an instance's compound key, this will generate the instance's path.

    This is to reduce WMI traffic. WMI uses paths to execute method. But we don't have path until
    the object is avaiable. As a result, we need to read the object out (which may contain many 
    properties), and then get the path and feed the path to WMI to execute a method. When WMI receives
    that request, it again ask us for the object (using the path we gave in the above sequence)
    and we have to load the instance again.

    This is obviously too much traffic. So, to reduce the traffic, we will create the path ourselves.
    For each class, we have a cookie list. For each instance, we have a cookie in the cookie list.
    For each cookie, we know the compound key very easily (key property counts are always small).
    This function creates a path based on the compound key.

Virtual:
    
    N/A.
    
Arguments:

    pSpawn            - COM interface pointer that has all the class definition. We need this
                        to for the path creation.

    pszStorePath      - The store's path

    pszCompoundKey    - The instance's compound key

    pbstrPath         - receives the path.

Return Value:

    Success: 
        (1) various success codes.

    Failure: 
        (1) various error codes.

Notes:
    As usual, caller is responsible for freeing the bstr.

*/

HRESULT 
GetObjectPath (
    IN IWbemClassObject * pSpawn,
    IN LPCWSTR            pszStorePath,  
    IN LPCWSTR            pszCompoundKey,
    OUT BSTR            * pbstrPath
    )
{
    if (pSpawn          == NULL     || 
        pszCompoundKey  == NULL     || 
        *pszCompoundKey == L'\0'    || 
        pbstrPath       == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pbstrPath = NULL;

    //
    // this instance is not going to live beyond the scope of the function
    //

    CComPtr<IWbemClassObject> srpTempObj;
    HRESULT hr = pSpawn->SpawnInstance(0, &srpTempObj);

    DWORD dwLoadedProperties = 0;
    
    //
    // We will populate the key properties into this temp object and ask it for the path
    //

    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(hr))
        {
            CScePropertyMgr ScePropMgr;
            ScePropMgr.Attach(srpTempObj);
            
            //
            // this is the only property not managed by the ISceClassObject
            //

            hr = ScePropMgr.PutProperty(pStorePath, pszStorePath);
            if (FAILED(hr))
            {
                return hr;
            }

            if (_wcsicmp(pszCompoundKey, pszNullKey) != 0)
            {
                hr = PopulateKeyProperties(pszCompoundKey, &ScePropMgr);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        CComVariant varPath;

        //
        // a fully populated (as far as key properties are concerned) will have a path
        //

        hr = srpTempObj->Get(L"__RelPath",  0, &varPath, NULL, NULL);
        if (SUCCEEDED(hr) && varPath.vt == VT_BSTR)
        {
            //
            // this is it.
            //

            *pbstrPath = varPath.bstrVal;

            //
            // since the bstr is now owned by the out parameter, we'd better stop the auto-destruction
            // by CComVariant
            //

            varPath.bstrVal = NULL;
            varPath.vt = VT_EMPTY;
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    VariantFromFormattedString

Functionality:
    
    Given a formatted string representing a variant value, transform it to a variant value.
    For example,

        VariantFromFormattedString(L"<VT_I4 : 12345>", &var);

    will assign VT_I4 value 12345 to var.

    We also support arrays. For example,

        VariantFromFormattedString(L"<VT_ARRAY(VT_BSTR) : "This is " , "Microsoft SCE" >", &var);

    will assign VT_ARRAY | VT_BSTR to var and it contains a safearray of bstrs that has "This is "
    value at its first element and "Microsoft SCE" at its second value.

Virtual:
    
    N/A.
    
Arguments:

    pszString   - The string (in our format) representing a value.
    
    pVar        - receives the variant value.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: Various errors may occurs. 
             Most obvious is 
             WBEM_E_INVALID_SYNTAX, 
             WBEM_E_OUT_OF_MEMORY,
             WBEM_E_NOT_SUPPORTED

Notes:

*/

HRESULT 
VariantFromFormattedString (
    IN LPCWSTR pszString,
    OUT VARIANT* pVar    
    )
{
    // USES_CONVERSION;

    if (pszString == NULL || pVar == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    ::VariantInit(pVar);

    //
    // the current point of parsing
    //

    LPCWSTR pCur = pszString;

    //
    // scan the string for <xxx:
    // the last parameter true indicates that we want the see to move to end 
    // if the wanted char was not found.
    //

    bool bEscaped = false;
    pCur = ::EscSeekToChar(pCur, wchTypeValLeft, &bEscaped, true);

    if (*pCur == L'\0')     
    {
        //
        // no value is encoded
        //

        return WBEM_NO_ERROR;
    }

    //
    // pCur points to '<'. skip the <
    //

    ++pCur;

    //
    // seek till ':'
    //

    LPCWSTR pNext = ::EscSeekToChar(pCur, wchTypeValSep, &bEscaped, true);

    //
    // must contain something before ':'
    //

    if (*pNext != wchTypeValSep || pCur == pNext) 
    {
        return WBEM_E_INVALID_SYNTAX;
    }

    //
    // length of the found token
    //

    int iTokenLen = pNext - pCur;

    LPWSTR pszType = new WCHAR[iTokenLen + 1];  // need to release the memory
    if (pszType == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // copy the token, but trim the white space at both ends
    //

    ::TrimCopy(pszType, pCur, iTokenLen);

    VARTYPE varSubType;
    VARTYPE varVT = gStringToVtMap.GetType(pszType, &varSubType);

    //
    // done with the type string
    //

    delete [] pszType;

    if (varVT == VT_EMPTY)
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // must have more data
    //

    pCur = ++pNext; // pCur point to char after ':'

    if (*pCur == L'\0')
    {
        return WBEM_E_INVALID_SYNTAX;
    }

    pNext = ::EscSeekToChar(pCur, wchTypeValRight, &bEscaped, true); // move to end if not found

    //
    // must see '>'
    //

    if (*pNext != wchTypeValRight)
    {
        return WBEM_E_INVALID_SYNTAX;
    }

    //
    // length of the found token
    //

    iTokenLen = pNext - pCur;

    LPWSTR pszValue = new WCHAR[iTokenLen + 1];  // need to release the memory
    if (pszValue == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // copy the token, but trim the white space at both ends
    //

    ::TrimCopy(pszValue, pCur, iTokenLen);

    HRESULT hr = WBEM_NO_ERROR;

    //
    // arrays not more complicated to format
    //

    if ((varVT & VT_ARRAY) != VT_ARRAY)
    {
        hr = ::VariantFromStringValue(pszValue, varVT, pVar);
    }
    else
    {
        hr = ::ArrayFromFormatString(pszValue, varSubType, pVar);
    }

    delete [] pszValue;

    return hr;
}

/*
Routine Description: 

Name:

    VariantFromStringValue

Functionality:
    
    Given a formatted string representing a variant value, transform it to a variant value.
    For example,

        VariantFromStringValue(L"12345", VT_I4, &var);

    will assign VT_I4 value 12345 to var.

    We do not support array at this function. That is done ArrayFromFormatString.

Virtual:
    
    N/A.
    
Arguments:

    szValue - The string (in our format) representing a value.

    vt      - VARTYPE
    
    pVar    - receives the variant value.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: Various errors may occurs. 
             Most obvious is
             WBEM_E_INVALID_PARAMETER,
             WBEM_E_INVALID_SYNTAX, 
             WBEM_E_OUT_OF_MEMORY,
             WBEM_E_NOT_SUPPORTED

Notes:

*/

HRESULT 
VariantFromStringValue (
    IN LPCWSTR    szValue,
    IN VARTYPE    vt,
    IN VARIANT  * pVar
    )
{
    //
    // so that we can use those W2CA like macros
    //

    USES_CONVERSION;

    if (szValue == NULL || *szValue == L'\0' || pVar == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    ::VariantInit(pVar);
    pVar->vt = vt;

    HRESULT hr = WBEM_NO_ERROR;

    switch (vt)
    {
        case VT_BSTR:
            hr = ::DeEscapeStringData(szValue, &(pVar->bstrVal), true);
            break;

        case VT_BOOL:
            if (*szValue == L'0' || _wcsicmp(szValue, L"FALSE") == 0)
            {
                pVar->boolVal = VARIANT_FALSE;
            }
            else
            {
                pVar->boolVal = VARIANT_TRUE;
            }
            break;

        case VT_I2:
            pVar->iVal = (short)(_wtol(szValue));
            break;

        case VT_UI1:
            pVar->bVal = (BYTE)(_wtol(szValue));
            break;

        case VT_UI2:
            pVar->uiVal = (USHORT)(_wtol(szValue));
            break;

        case VT_UI4:
            pVar->ulVal = (ULONG)(_wtol(szValue));
            break;

        case VT_I4:
            pVar->lVal = (long)(_wtol(szValue));
            break;

        case VT_DATE:
        case VT_R4:
        case VT_R8:
            {
                double fValue = atof(W2CA(szValue));

                if (vt == VT_DATE)
                {
                    pVar->date = fValue;
                }
                else if (vt == VT_R4)
                {
                    pVar->fltVal = (float)fValue;
                }
                else
                {
                    pVar->dblVal = fValue;
                }
            }
            break;

        case VT_CY:
            hr = ::CurrencyFromFormatString(szValue, pVar);
            break;

        default:
            hr = WBEM_E_NOT_SUPPORTED;
            break;
    }

    if (FAILED(hr))
    {
        ::VariantInit(pVar);
    }

    return hr;
}

/*
Routine Description: 

Name:

    CurrencyFromFormatString

Functionality:
    
    Given a formatted string representing a currency value, translate into a variant.

Virtual:
    
    N/A.
    
Arguments:

    lpszFmtStr  - The string (in our format) representing currency value.
    
    pVar        - receives the variant value.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: Various errors may occurs. 
             Most obvious is 
             WBEM_E_INVALID_SYNTAX, 
             WBEM_E_INVALID_PARAMETER

Notes:

*/

HRESULT
CurrencyFromFormatString (
    IN LPCWSTR    lpszFmtStr,
    OUT VARIANT * pVar
    )
{
    if (lpszFmtStr == NULL || pVar == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    ::VariantInit(pVar);
    pVar->vt = VT_CY;

    LPCWSTR lpszDot = lpszFmtStr;
    while (*lpszDot != L'\0' && *lpszDot != wchCySeparator)
    {
        ++lpszDot;
    }

    if (*lpszDot != wchCySeparator)
    {
        return WBEM_E_INVALID_SYNTAX;
    }
    else
    {
        pVar->cyVal.Lo = (short)(_wtol(lpszDot + 1));

        //
        // _wtol won't read past the dot
        //

        pVar->cyVal.Hi = (short)(_wtol(lpszFmtStr));
    }

    return WBEM_NO_ERROR;
}

/*
Routine Description: 

Name:

    ArrayFromFormatString

Functionality:
    
    Given a formatted string representing array value, translate into a variant.

Virtual:
    
    N/A.
    
Arguments:

    lpszFmtStr  - The string (in our format) representing array value.

    vt          - sub type (the array's element type)
    
    pVar        - receives the variant value.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: Various errors may occurs. 
             Most obvious is 
             WBEM_E_INVALID_SYNTAX, 
             WBEM_E_INVALID_PARAMETER

Notes:

*/

HRESULT 
ArrayFromFormatString (
    IN LPCWSTR    lpszFmtStr,
    IN VARTYPE    vt,
    OUT VARIANT * pVar
    )
{
    if (lpszFmtStr == NULL || pVar == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    ::VariantInit(pVar);

    //
    // need to find out how many are there in the array, we will just count the delimiter wchValueSep == ','
    //

    LPCWSTR pszCur = lpszFmtStr;

    //
    // get the count
    //

    DWORD dwCount = 1;
    bool bEscaped;
    while (pszCur = EscSeekToChar(pszCur, wchValueSep, &bEscaped, false))
    {
        ++dwCount;
        ++pszCur;   // skip the separator
    }

    //
    // we know this is the type
    //

    pVar->vt = VT_ARRAY | vt;

    //
    // create a safearray
    //

    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = dwCount;
    pVar->parray = ::SafeArrayCreate(vt, 1, rgsabound);

    HRESULT hr = WBEM_NO_ERROR;

    if (pVar->parray == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        long lIndecies[1];

        LPCWSTR pszNext = pszCur = lpszFmtStr;
        long lLength = 0;

        //
        // pszValue will be used to hold each individual value. This buffer
        // is generous enough. Need to free the memory.
        //

        LPWSTR pszValue = new WCHAR[wcslen(lpszFmtStr) + 1];

        if (pszValue == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            //
            // all values are separated by the character wchValueSep
            // We will loop through and get each value out and put them
            // into the safearray
            //

            for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++)
            {
                pszNext = ::EscSeekToChar(pszCur, wchValueSep, &bEscaped, true);

                if (pszNext == pszCur)
                {
                    break;
                }

                lLength = pszNext - pszCur;

                lIndecies[0] = dwIndex;
                ::TrimCopy(pszValue, pszCur, lLength);

                VARIANT var;
                hr = ::VariantFromStringValue(pszValue, vt, &var);
                if (FAILED(hr))
                {
                    break;
                }

                if (vt == VT_BSTR)
                {
                    hr = ::SafeArrayPutElement(pVar->parray, lIndecies, var.bstrVal);
                }
                else
                {
                    hr = ::SafeArrayPutElement(pVar->parray, lIndecies, ::GetVoidPtrOfVariant(var.vt, &var));
                }

                ::VariantClear(&var);

                if (FAILED(hr))
                {
                    break;
                }

                pszCur = pszNext;

                //
                // we won't quit until we see the end of the buffer.
                //

                if (*pszCur != L'\0')
                {
                    ++pszCur;
                }
                else
                {
                    break;
                }
            }

            delete [] pszValue;
        }
    }

    if (FAILED(hr))
    {
        ::VariantClear(pVar);
    }

    return hr;
}

/*
Routine Description: 

Name:

    FormatArray

Functionality:
    
    Given a variant, get the formatted (our format) string representation.

    For example, given a variant of array (say, 3 elements) of VT_I4 of value 1, 2, 3, this function
    will give   < VT_ARRAY(VT_I4) : 1, 2, 3, >

    For example, given a variant of array (say, 3 elements) VT_BSTR of value 
    "Microsoft", "Security" "Configuration", this function
    will give   < VT_ARRAY(VT_BSTR) : "Microsoft" , "Security", "Configuration" >

Virtual:
    
    N/A.
    
Arguments:
    
    pVar        - The varaint to be formatted. Must be a safearray

    pbstrData   - Receive the formatted string.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: Various errors may occurs. 
             Most obvious is 
             WBEM_E_INVALID_SYNTAX, 
             WBEM_E_INVALID_PARAMETER

Notes:

*/

HRESULT
FormatArray (
    IN VARIANT  * pVar, 
    OUT BSTR    * pbstrData
    )
{
    if (pVar == NULL || pbstrData == NULL || (pVar->vt & VT_ARRAY) != VT_ARRAY)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pbstrData = NULL;

    VARTYPE vtSub = ::GetSubType(pVar->vt);

    long lLowerBound, lUpperBound;
    HRESULT hr = ::SafeArrayGetLBound(pVar->parray, 1, &lLowerBound);

    if (FAILED(hr))
    {
        return hr;
    }

    hr = ::SafeArrayGetUBound(pVar->parray, 1, &lUpperBound);
    if (FAILED(hr))
    {
        return hr;
    }

    long lIndexes[1];

    //
    // get lUpperBound - lLowerBound + 1 bstrs and set all to NULL
    //

    BSTR * pbstrArray = new BSTR[lUpperBound - lLowerBound + 1];

    if (pbstrArray == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    ::memset(pbstrArray, 0, sizeof(BSTR) * (lUpperBound - lLowerBound + 1));

    //
    // this is the nightmare to deal with CComBSTR's appending, its += operator
    // doesn't work for loops!
    //

    long lTotalLen = 0;
    LPWSTR pszNextToWrite = NULL;

    for (long i = lLowerBound; i <= lUpperBound; i++)
    {
        CComBSTR bstrValue;

        CComVariant var;
        var.vt = vtSub;

        //
        // i-th element of the array
        //

        lIndexes[0] = i;

        void* pv = ::GetVoidPtrOfVariant(vtSub, &var);

        hr = ::SafeArrayGetElement(pVar->parray, lIndexes, pv);

        if (FAILED(hr))
        {
            break;
        }

        hr = ::GetStringPresentation(&var, &bstrValue);

        if (FAILED(hr))
        {
            break;
        }

        int iValueLen = wcslen(bstrValue);

        if (i == 0)
        {
            //
            // This is the start of the format, we need to get the VARTYPE string.
            // first, put the type string.
            //

            LPCWSTR pszType = gVtToStringMap.GetTypeString(VT_ARRAY, vtSub);
            if (pszType == NULL)
            {
                hr = WBEM_E_NOT_SUPPORTED;
                break;
            }

            int iTypeLen = wcslen(pszType);
            pbstrArray[i] = ::SysAllocStringLen(NULL, 1 + iTypeLen + 1 + iValueLen + 2);

            if (pbstrArray[i] == (LPCWSTR)NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                break;
            }

            pszNextToWrite = pbstrArray[i];

            //
            // put the separator, move over one wchar position
            //

            pszNextToWrite[0] = wchTypeValLeft;

            ++pszNextToWrite;

            ::memcpy(pszNextToWrite, pszType, iTypeLen * sizeof(WCHAR));

            //
            // have copied over that many WCHAR, move that many positions.
            //

            pszNextToWrite += iTypeLen;

            //
            // put the separator, move over one wchar position
            //

            pszNextToWrite[0] = wchTypeValSep;

            ++pszNextToWrite;

            ::memcpy(pszNextToWrite, (void*)((LPCWSTR)bstrValue), iValueLen * sizeof(WCHAR));
            
            //
            // have copied over that many WCHAR, move that many positions.
            //

            pszNextToWrite += iValueLen;
        }
        else    
        {
            //
            // not the first value any more
            //

            pbstrArray[i] = ::SysAllocStringLen(NULL, 1 + iValueLen + 2);
            if (pbstrArray[i] == (LPCWSTR)NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                break;
            }
            pszNextToWrite = pbstrArray[i];

            //
            // put the separator, move over one wchar position
            //

            pszNextToWrite[0] = wchValueSep;
            ++pszNextToWrite;

            ::memcpy(pszNextToWrite, (void*)((LPCWSTR)bstrValue), iValueLen * sizeof(WCHAR));

            //
            // have copied over that many WCHAR, move that many positions.
            //

            pszNextToWrite += iValueLen;
        }

        bstrValue.Empty();

        //
        // enclosing >
        //

        if (i == pVar->parray->rgsabound[0].cElements - 1)
        {
            pszNextToWrite[0] = wchTypeValRight;
            ++pszNextToWrite;
        }

        pszNextToWrite[0] = L'\0';

        lTotalLen += wcslen(pbstrArray[i]);
    }

    //
    // now if everything is fine, pack them into one single output parameter
    //

    if (SUCCEEDED(hr))
    {
        //
        // this is what we will passback
        //

        *pbstrData = ::SysAllocStringLen(NULL, lTotalLen + 1);
        if (*pbstrData == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            pszNextToWrite = *pbstrData;
            long lLen = 0;

            for (i = lLowerBound; i <= lUpperBound; i++)
            {
                lLen = wcslen(pbstrArray[i]);

                //
                // have copied over that many WCHAR, move that many positions.
                //

                ::memcpy(pszNextToWrite, (void*)((LPCWSTR)pbstrArray[i]), lLen * sizeof(WCHAR));
                pszNextToWrite += lLen;
            }

            pszNextToWrite[0] = L'\0';
        }
    }

    //
    // release the bstrs
    //

    for (long i = lLowerBound; i <= lUpperBound; i++)
    {
        if (pbstrArray[i] != NULL)
        {
            ::SysFreeString(pbstrArray[i]);
        }
    }

    delete [] pbstrArray;

    return hr;
}

/*
Routine Description: 

Name:

    GetStringPresentation

Functionality:
    
    Given a variant, get the formatted (our format) string representation.

    For example, given a variant of type VT_I4 of value 12345, this function
    will give   < VT_I4 : 12345 >

    For example, given a variant of type VT_BSTR of value "Microsoft's SCE", this function
    will give   < VT_BSTR : "Microsoft's SCE" >

Virtual:
    
    N/A.
    
Arguments:

    pVar        - The varaint to be formatted. Must not be VT_ARRAY's variant. That is done by 
                  FormatArray function.

    pbstrData   - Receive the formatted string.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: Various errors may occurs. 
             Most obvious is 
             WBEM_E_INVALID_SYNTAX, 
             WBEM_E_INVALID_PARAMETER

Notes:

*/

HRESULT 
GetStringPresentation ( 
    IN VARIANT  * pVar,
    OUT BSTR    * pbstrData 
    )
{
    USES_CONVERSION;

    if (pVar == NULL || pbstrData == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    int iFormat = 0;
    DWORD dwValue;
    double dblValue = 0.0F;
    *pbstrData = NULL;

    HRESULT hr = WBEM_NO_ERROR;
    switch (pVar->vt)
    {
        case VT_BSTR:
            hr = ::EscapeStringData(pVar->bstrVal, pbstrData, true);     // adding quote
            break;
        case VT_BOOL:
            dwValue = (pVar->boolVal == VARIANT_TRUE) ? 1 : 0;  
            iFormat = iFormatIntegral;
            break;     
        case VT_I2:  
            dwValue = pVar->iVal; 
            iFormat = iFormatIntegral;
            break;
        case VT_UI1:
            dwValue = pVar->bVal;
            iFormat = iFormatIntegral;
            break;
        case VT_UI2:
            dwValue = pVar->uiVal;
            iFormat = iFormatIntegral;
            break;
        case VT_UI4:
            dwValue = pVar->ulVal;
            iFormat = iFormatIntegral;
            break;
        case VT_I4:
            dwValue = pVar->lVal;
            iFormat = iFormatIntegral;
            break;
        //case VT_I8:  
        //    dwValue = pVar->hVal;
        //    iFormat = iFormatInt8;
        //    break;
        //case VT_UI8:
        //    dwValue = pVar->uhVal;
        //    iFormat = iFormatInt8;
        //    break;

        case VT_DATE:
            dblValue = pVar->date;
            iFormat = iFormatFloat;
            break;
        case VT_R4:
            dblValue = pVar->fltVal;
            iFormat = iFormatFloat;
            break;
        case VT_R8:
            dblValue = pVar->dblVal;
            iFormat = iFormatFloat;
            break;
        case VT_CY:
            iFormat = iFormatCurrenty;
            break;
        default:
            hr = WBEM_E_NOT_SUPPORTED;
            break;
    }

    //
    // The the data type is a integral type
    //

    if (iFormat == iFormatIntegral)
    {
        *pbstrData = ::SysAllocStringLen(NULL, MAX_INT_LENGTH);
        if (*pbstrData != NULL)
        {
            wsprintf(*pbstrData, L"%d", dwValue);
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else if (iFormat == iFormatFloat)
    {
        //
        // there is no wsprintf for float data types!
        //

        char chData[MAX_DOUBLE_LENGTH];
        ::sprintf(chData, "%f", dblValue);
        *pbstrData = ::SysAllocString(A2W(chData));

        if (*pbstrData == NULL)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else if (iFormat == iFormatCurrenty)
    {
        //
        // the data type is currency!
        //

        *pbstrData = ::SysAllocStringLen(NULL, MAX_DOUBLE_LENGTH);
        if (*pbstrData != NULL)
        {
            wsprintf(*pbstrData, L"%d%c%d", pVar->cyVal.Hi, wchCySeparator, pVar->cyVal.Lo);
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    GetVoidPtrOfVariant

Functionality:
    
    Helper. Will return the address of the data member of the variant for non array data type.

Virtual:
    
    N/A.
    
Arguments:

    vt      - The type we want. Can't be VT_ARRAY, which is done separately

    pVar    - The variant. This may be empty!

Return Value:

    Success: Non-NULL void*.

    Failure: NULL. Either this type is not supportd or the variant is NULL.

Notes:

*/

void*
GetVoidPtrOfVariant ( 
    VARTYPE vt,
    VARIANT* pVar       
    )
{
    if (pVar == NULL)
    {
        return NULL;
    }

    switch (vt)
    {
        case VT_BSTR:
            return &(pVar->bstrVal);
        case VT_BOOL:
            return &(pVar->boolVal); 
        case VT_I2:  
            return &(pVar->iVal); 
        case VT_UI1:
            return &(pVar->bVal);
        case VT_UI2:
            return &(pVar->uiVal);
        case VT_UI4:
            return &(pVar->ulVal);
        case VT_I4:
            return &(pVar->lVal);
        //case VT_I8:  
        //    return &(pVar->hVal);
        //case VT_UI8:
        //    return &(pVar->uhVal);

        case VT_DATE:
            return &(pVar->date);
        case VT_R8:
            return &(pVar->dblVal);
        case VT_R4:
            return &(pVar->fltVal);
        case VT_CY:
            return &(pVar->cyVal);
        default:
            return NULL;
    }
}

/*
Routine Description: 

Name:

    ParseCompoundKeyString

Functionality:
    
    Will parse the compound key string to get one (name, value) pair and advance the pointer
    to the next position to continue the same parsing. This is designed to be called repeatedly
    in a loop.

Virtual:
    
    N/A.
    
Arguments:

    pszCurStart - Current position to start the parsing.

    ppszName    - Receives the name. Optional. If caller is not interested in the name,
                  it can simply pass in NULL.

    pVar        - Receives the variant value. Optional. If caller is not interested in the value,
                  it can simply pass in NULL.

    ppNext      - Receives the pointer for next parsing step, must not be null.

Return Value:

    Success: WBEM_S_FALSE if no parsing needs to be done.
             WBEM_NO_ERROR if results are returned.

    Failure: various error code.

Notes:
    Caller is responsible for releasing the out parameters if function is successful.

*/

HRESULT 
ParseCompoundKeyString (
    IN LPCWSTR pszCurStart,
    OUT LPWSTR* ppszName    OPTIONAL,
    OUT VARIANT* pVar       OPTIONAL,
    OUT LPCWSTR* ppNext
    )
{
    if (ppNext == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    if (ppszName != NULL)
    {
        *ppszName = NULL;
    }
    if (pVar != NULL)
    {
        ::VariantInit(pVar);
    }

    *ppNext = NULL;

    if (pszCurStart == NULL || *pszCurStart == L'\0')
    {
        return WBEM_S_FALSE;
    }

    //
    // we don't use this bEsc.
    //

    bool bEsc;

    //
    // this is our current position to start parsing
    //

    LPCWSTR pCur = pszCurStart;

    //
    // get the name, which is delimited by wchTypeValLeft ('<')
    //

    LPCWSTR pNext = ::EscSeekToChar(pCur, wchTypeValLeft, &bEsc, true);

    if (*pNext != wchTypeValLeft)
    {
        return WBEM_S_FALSE;
    }

    HRESULT hr = WBEM_S_FALSE;

    //
    // it wants the name
    //

    if (ppszName != NULL)
    {
        //
        // caller is responsible for releasing it.
        //

        *ppszName = new WCHAR[pNext - pCur + 1];
        if (*ppszName == NULL)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        //
        // *pNext == '<', thus from pCur to pNext is the name of the key property
        //

        ::TrimCopy(*ppszName, pCur, pNext - pCur);
    }

    //
    // ready for value
    //

    pCur = pNext;   // pCur is pointing at '<'

    //
    // move pNext to '>'
    //

    pNext = ::EscSeekToChar(pCur, wchTypeValRight, &bEsc, true);

    //
    // if not see the wchTypeValRight, it's syntax error
    //

    if (*pNext != wchTypeValRight)
    {
        //
        // caller won't do the releasing in this case
        //

        if (ppszName)
        {
            delete [] *ppszName;
            *ppszName = NULL;
        }

        return WBEM_E_INVALID_SYNTAX;
    }

    ++pNext;    // skip the '>'

    if (pVar != NULL)
    {
        //
        // from pCur to pNext is the encoded value <xxx:yyyyyyy>. Copy this to szValue
        //

        LPWSTR pszValue = new WCHAR[pNext - pCur + 1];

        if (pszValue != NULL)
        {
            ::TrimCopy(pszValue, pCur, pNext - pCur);
            hr = ::VariantFromFormattedString(pszValue, pVar);
            delete [] pszValue;
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    
    if (SUCCEEDED(hr))
    {
        *ppNext = pNext;
        hr = WBEM_NO_ERROR;
    }
    else
    {
        delete [] *ppszName;
        *ppszName = NULL;
    }

    return hr;
}

/*
Routine Description: 

Name:

    PopulateKeyProperties

Functionality:
    
    Will parse the compound key string and feed the property values to the property manager,
    which has been attached to the appropriate object.

Virtual:
    
    N/A.
    
Arguments:

    pszCompoundKey  - The compound key string.

    pScePropMgr     - The property manager where the parsed (key) properties will be put. It must
                      be prepared correctly for the object to receive the properties.

Return Value:

    Success: WBEM_S_FALSE if no thing was done.
             WBEM_NO_ERROR if results are returned.

    Failure: various error code.

Notes:
    Partial properties might have been set to the object if the parsing fails at a later stage.
    We don't try to undo those partially filled properties.

*/

HRESULT 
PopulateKeyProperties (
    IN LPCWSTR            pszCompoundKey,
    IN CScePropertyMgr  * pScePropMgr
    )
{
    if (pszCompoundKey == NULL || *pszCompoundKey == L'\0')
    {
        //
        // nothing to populate
        //

        return WBEM_S_FALSE;
    }

    LPWSTR pszName = NULL;
    VARIANT var;
    ::VariantInit(&var);

    LPCWSTR pszCur = pszCompoundKey;
    LPCWSTR pszNext;

    HRESULT hr = ::ParseCompoundKeyString(pszCur, &pszName, &var, &pszNext);

    bool bHasSetProperties = false;

    while (SUCCEEDED(hr) && hr != WBEM_S_FALSE)
    {
        hr = pScePropMgr->PutProperty(pszName, &var);
        
        if (SUCCEEDED(hr))
        {
            bHasSetProperties = true;
        }

        delete [] pszName;
        ::VariantClear(&var);

        //
        // start our next round
        //

        pszCur = pszNext;

        hr = ::ParseCompoundKeyString(pszCur, &pszName, &var, &pszNext);
    }

    if (SUCCEEDED(hr) && bHasSetProperties)
    {
        hr = WBEM_NO_ERROR;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\password.h ===
// password.h: interface for the CPasswordPolicy class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PASSWORD_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_PASSWORD_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

/*

Class description
    
    Naming: 

        CPasswordPolicy stands for Security Options.
    
    Base class: 

        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_PasswordPolicy
    
    Purpose of class:
    
        (1) Implement Sce_PasswordPolicy WMI class.
    
    Design:
         
        (1) Almost trivial other than implementing necessary method as a concrete class
    
    Use:

        (1) Almost never used directly. Alway through the common interface defined by
            CGenericClass.
    
    
*/

class CPasswordPolicy : public CGenericClass
{
public:
        CPasswordPolicy (
                        ISceKeyChain *pKeyChain, 
                        IWbemServices *pNamespace, 
                        IWbemContext *pCtx = NULL
                        );

        virtual ~CPasswordPolicy();

        virtual HRESULT PutInst (
                                IWbemClassObject *pInst, 
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                );

        virtual HRESULT CreateObject (
                                     IWbemObjectSink *pHandler, 
                                     ACTIONTYPE atAction
                                     );

private:

        HRESULT ConstructInstance (
                                  IWbemObjectSink *pHandler, 
                                  CSceStore* pSceStore, 
                                  LPWSTR wszLogStorePath, 
                                  ACTIONTYPE atAction
                                  );

        HRESULT DeleteInstance (
                                IWbemObjectSink *pHandler,
                                CSceStore* pSceStore
                               );

        HRESULT SaveSettingsToStore (
                                    CSceStore* pSceStore, 
                                    DWORD dwMinAge, 
                                    DWORD dwMaxAge, 
                                    DWORD dwMinLen, 
                                    DWORD dwHistory, 
                                    DWORD dwComplexity, 
                                    DWORD dwClear, 
                                    DWORD dwForce, 
                                    DWORD dwLSAPol, 
                                    DWORD dwAdmin, 
                                    DWORD dwGuest
                                    );

};

#endif // !defined(AFX_PASSWORD_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\precomp.h ===
#include <ole2.h>
#include <windows.h>
#include <stdio.h>
#include <atlbase.h>

#include "sceprov.h"
#include "scecore.h"

#include <map>
#include <vector>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\regvalue.cpp ===
// Regvalue.cpp: implementation of the CRegistryValue class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "regvalue.h"
#include "persistmgr.h"
#include <io.h>
#include "requestobject.h"

/*
Routine Description: 

Name:

    CRegistryValue::CRegistryValue

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CRegistryValue::CRegistryValue (
    IN ISceKeyChain  * pKeyChain, 
    IN IWbemServices * pNamespace,
    IN IWbemContext  * pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{

}

/*
Routine Description: 

Name:

    CRegistryValue::~CRGroups

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/

CRegistryValue::~CRegistryValue ()
{

}

/*
Routine Description: 

Name:

    CRegistryValue::CreateObject

Functionality:
    
    Create WMI objects (Sce_RegistryValue). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT 
CRegistryValue::CreateObject (
    IN IWbemObjectSink * pHandler, 
    IN ACTIONTYPE        atAction
    )
{
    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Delete a single instance ACTIONTYPE_DELETE
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET != atAction &&
         ACTIONTYPE_DELETE != atAction &&
         ACTIONTYPE_QUERY != atAction ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // We must have the pStorePath property because that is where
    // our instance is stored. 
    // m_srpKeyChain->GetKeyPropertyValue WBEM_S_FALSE if the key is not recognized
    // So, we need to test against WBEM_S_FALSE if the property is mandatory
    //

    CComVariant varStorePath;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(pStorePath, &varStorePath);

    if (SUCCEEDED(hr) && hr != WBEM_S_FALSE && varStorePath.vt == VT_BSTR)
    {

        //
        // search for regitry value path
        //

        CComVariant varPath;
        hr = m_srpKeyChain->GetKeyPropertyValue(pPath, &varPath); 

        if (FAILED(hr))
        {
            return hr;
        }
        else if (hr == WBEM_S_FALSE && (ACTIONTYPE_QUERY != atAction) ) 
        {
            return WBEM_E_NOT_FOUND;
        }

        //
        // Prepare a store (for persistence) for this store path (file)
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistPath(varStorePath.bstrVal);

        if ( SUCCEEDED(hr) ) {

            //
            // make sure the store (just a file) really exists. The raw path
            // may contain env variables, so we need the expanded path
            //

            DWORD dwAttrib = GetFileAttributes(SceStore.GetExpandedPath());

            if ( dwAttrib != -1 ) {

                //
                // this file exists
                //

                DWORD dwCount = 0;
                m_srpKeyChain->GetKeyPropertyCount(&dwCount);
                if ( varPath.vt == VT_BSTR && varPath.bstrVal != NULL ) 
                {

                    if ( ACTIONTYPE_DELETE == atAction )
                    {
                        hr = DeleteInstance(pHandler, &SceStore, varPath.bstrVal);
                    }
                    else
                    {
                        hr = ConstructInstance(pHandler, &SceStore, varStorePath.bstrVal, varPath.bstrVal,TRUE);
                    }

                } 
                else 
                {
                    //
                    // query support
                    //

                    hr = ConstructInstance(pHandler, &SceStore, varStorePath.bstrVal, NULL, (dwCount == 1)? FALSE : TRUE);
                }

            } 
            else 
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CRegistryValue::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_RegistryValue,
    which is persistence oriented, this will cause the Sce_RegistryValue object's property 
    information to be saved in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst       - COM interface pointer to the WMI class (Sce_RegistryValue) object.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

*/

HRESULT 
CRegistryValue::PutInst (
    IN IWbemClassObject    * pInst,
    IN IWbemObjectSink     * pHandler,
    IN IWbemContext        * pCtx
    )
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;

    CComBSTR bstrRegPath;
    CComBSTR bstrDoublePath;

    CComBSTR bstrConvertPath;
    CComBSTR bstrValue;

    CSceStore SceStore;

    //
    // CScePropertyMgr helps us to access WMI object's properties
    // create an instance and attach the WMI object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pInst);

    DWORD RegType=0;
    DWORD dwDump;

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pPath, &bstrRegPath));
    SCE_PROV_IfErrorGotoCleanup(ConvertToDoubleBackSlashPath(bstrRegPath, L'\\',&bstrDoublePath));

    //
    // if the property doesn't exist (NULL or empty), WBEM_S_RESET_TO_DEFAULT is returned
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pType, &RegType));

    if ( hr == WBEM_S_RESET_TO_DEFAULT)
    {
        hr = WBEM_E_ILLEGAL_NULL;
        goto CleanUp;
    }

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pData, &bstrValue));
    if ( hr == WBEM_S_RESET_TO_DEFAULT)
    {
        hr = WBEM_E_ILLEGAL_NULL;
        goto CleanUp;
    }

    //
    // should validate the registry value path to see if it's supported (in sceregvl.inf)
    //

    SCE_PROV_IfErrorGotoCleanup(ValidateRegistryValue(bstrDoublePath, RegType, bstrValue ));

    //
    // convert registry path from double backslash to single backslash
    //

    SCE_PROV_IfErrorGotoCleanup(MakeSingleBackSlashPath(bstrRegPath, L'\\', &bstrConvertPath));

    //
    // Attach the WMI object instance to the store and let the store know that
    // it's store is given by the pStorePath property of the instance.
    //

    SceStore.SetPersistProperties(pInst, pStorePath);

    //
    // For a new .inf file. Write an empty buffer to the file
    // will creates the file with right header/signature/unicode format
    // this is harmless for existing files.
    // For database store, this is a no-op.
    //

    SCE_PROV_IfErrorGotoCleanup(SceStore.WriteSecurityProfileInfo(
                                                                  AreaBogus,
                                                                  (PSCE_PROFILE_INFO)&dwDump,
                                                                  NULL, 
                                                                  false
                                                                  )  );

    //
    // now save the info to file
    //

    SCE_PROV_IfErrorGotoCleanup(SceStore.SavePropertyToStore(szRegistryValues, bstrConvertPath, RegType, L',', bstrValue));

CleanUp:
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CRegistryValue::ConstructInstance
/*
Routine Description: 

Name:

    CRegistryValue::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_RegistryValue.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszLogStorePath - store path, a key property of Sce_RegistryValue class.

    wszGroupName    - a corresponding key property of Sce_RegistryValue class.

    bPostFilter     - Controls how WMI will be informed with pHandler->SetStatus.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:

*/

HRESULT 
CRegistryValue::ConstructInstance (
    IN IWbemObjectSink * pHandler,
    IN CSceStore       * pSceStore,
    IN LPCWSTR           wszLogStorePath,
    IN LPCWSTR           wszRegPath       OPTIONAL,
    IN BOOL              bPostFilter
    )
{
    // 
    // make sure that we have a valid store
    //

    if ( pSceStore == NULL || pSceStore->GetStoreType() < SCE_INF_FORMAT ||
         pSceStore->GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // ask SCE to read a gigantic structure out from the store. Only SCE
    // knows now to release the memory. Don't just delete it! Use our CSceStore
    // to do the releasing (FreeSecurityProfileInfo)
    //

    PSCE_PROFILE_INFO pInfo=NULL;
    HRESULT hr = pSceStore->GetSecurityProfileInfo(
                                   AREA_SECURITY_POLICY,
                                   &pInfo,
                                   NULL
                                   );

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // search for the registry value
    //

    DWORD iKey=0;

    if ( wszRegPath ) 
    {
        //
        // get the registry key
        //

        for ( iKey=0; iKey<pInfo->RegValueCount; iKey++ ) 
        {
            if ( pInfo->aRegValues[iKey].FullValueName == NULL )
            {
                continue;
            }

            if ( _wcsicmp(pInfo->aRegValues[iKey].FullValueName, wszRegPath) == 0 ) 
            {
                break;
            }
        }

        if ( iKey > pInfo->RegValueCount ) 
        {
            hr = WBEM_E_NOT_FOUND;
        }
    }

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    if ( SUCCEEDED(hr) ) 
    {
        CComBSTR bstrLogOut;
        SCE_PROV_IfErrorGotoCleanup(MakeSingleBackSlashPath(wszLogStorePath, L'\\', &bstrLogOut));

        for (DWORD i = iKey; i < pInfo->RegValueCount; i++) 
        {
            CComPtr<IWbemClassObject> srpObj;
            SCE_PROV_IfErrorGotoCleanup(SpawnAnInstance(&srpObj));

            //
            // CScePropertyMgr helps us to access WMI object's properties
            // create an instance and attach the WMI object to it.
            // This will always succeed.
            //

            CScePropertyMgr ScePropMgr;
            ScePropMgr.Attach(srpObj);

            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pStorePath, bstrLogOut));
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pPath,  pInfo->aRegValues[i].FullValueName));

            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pType, pInfo->aRegValues[i].ValueType ));

            if ( pInfo->aRegValues[i].Value )
            {
                SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pData, pInfo->aRegValues[i].Value ));
            }

            //
            // do the necessary gestures to WMI.
            // the use of WBEM_STATUS_REQUIREMENTS in SetStatus is not documented by WMI
            // at this point. Consult WMI team for detail if you suspect problems with
            // the use of WBEM_STATUS_REQUIREMENTS
            //

            if ( !bPostFilter ) 
            {
                pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_FALSE, NULL, NULL);
            } 
            else 
            {
                pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);
            }

            //
            // pass the new instance to WMI
            //

            hr = pHandler->Indicate(1, &srpObj);

            if ( wszRegPath ) 
            {
                // to get one instance only
                break;
            }
        }
    }

CleanUp:
    
    pSceStore->FreeSecurityProfileInfo(pInfo);
    return hr;
}

/*
Routine Description: 

Name:

    CRegistryValue::DeleteInstance

Functionality:
    
    remove an instance of Sce_RegistryValue from the specified store.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszRegPath      - property of the Sce_RegistryValue class.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: WBEM_E_INVALID_PARAMETER.

Notes:

*/

HRESULT CRegistryValue::DeleteInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore,
    IN LPCWSTR            wszRegPath
    )
{
    // 
    // make sure that we have a valid store
    //

    if ( pSceStore == NULL || pSceStore->GetStoreType() < SCE_INF_FORMAT ||
         pSceStore->GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // passing a NULL value will cause the property to be deleted.
    //

    return pSceStore->SavePropertyToStore(szRegistryValues, wszRegPath, (LPCWSTR)NULL);
}


/*
Routine Description: 

Name:

    CRegistryValue::ValidateRegistryValue

Functionality:
    
    Private helper. Will verify if the registry value is valid.

Virtual:
    
    No.
    
Arguments:

    wszRegPath      - Registry value's path. A property of the Sce_RegistryValue class.

    bstrValue       - The string value of the property. A property of the Sce_RegistryValue class.

    RegType         - data type of the registry value. A property of the Sce_RegistryValue class.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: WBEM_E_INVALID_PARAMETER.

Notes:

*/

HRESULT CRegistryValue::ValidateRegistryValue (
    IN BSTR     bstrRegPath,
    IN DWORD    RegType,
    IN BSTR     bstrValue 
    )
{

    if ( bstrRegPath == NULL || bstrValue == NULL ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    DWORD Len = SysStringLen(bstrRegPath);

    LPCWSTR pQuery = L"SELECT * FROM Sce_KnownRegistryValues WHERE PathName=\"";


    //
    // memory allocated for the bstrQueryCategories will be automatically released by CComBSTR
    //

    CComBSTR bstrQueryCategories;

    //
    // 1 for closing quote and 1 for 0 terminator
    //

    bstrQueryCategories.m_str = ::SysAllocStringLen(NULL, Len + wcslen(pQuery) + 2);

    if ( bstrQueryCategories.m_str == NULL ) 
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // this won't overrun. See allocation size above
    //

    wcscpy(bstrQueryCategories.m_str, pQuery);    
    wcscat(bstrQueryCategories.m_str, bstrRegPath);
    wcscat(bstrQueryCategories.m_str, L"\"");

    HRESULT hr;
    CComPtr<IEnumWbemClassObject> srpEnum;
    CComPtr<IWbemClassObject> srpObj;
    ULONG n = 0;

    //
    // query all registry values of this path name
    //

    hr = m_srpNamespace->ExecQuery(L"WQL",
                                   bstrQueryCategories,
                                   WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                   NULL,
                                   &srpEnum
                                   );

    if (SUCCEEDED(hr))
    {
        //
        // should get one and only one instance
        //

        hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &n);

        if ( hr == WBEM_S_FALSE ) 
        {   
            //
            // not find any
            //

            hr = WBEM_E_INVALID_PARAMETER;
        }

        if (SUCCEEDED(hr))
        {
            if (n > 0)
            {
                //
                // find the instance
                //

                DWORD dwValue = 0;

                //
                // CScePropertyMgr helps us to access WMI object's properties
                // create an instance and attach the WMI object to it.
                // This will always succeed.
                //

                CScePropertyMgr ScePropMgr;
                ScePropMgr.Attach(srpObj);
                hr = ScePropMgr.GetProperty(pType, &dwValue);

                if ( SUCCEEDED(hr) ) 
                {
                    if ( hr != WBEM_S_RESET_TO_DEFAULT && (DWORD)dwValue == RegType ) 
                    {
                        hr = WBEM_S_NO_ERROR;
                    }
                    else 
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                    }
                }
            } 
            else 
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\password.cpp ===
//////////////////////////////////////////////////////////////////////
// password.cpp: implementation of the CPasswordPolicy class
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "password.h"
#include "persistmgr.h"
#include <io.h>
#include "requestobject.h"

#define KeyMinAge       L"MinimumPasswordAge"
#define KeyMaxAge       L"MaximumPasswordAge"
#define KeyMinLength    L"MinimumPasswordLength"
#define KeyHistory      L"PasswordHistorySize"
#define KeyComplexity   L"PasswordComplexity"
#define KeyClearText    L"ClearTextPassword"
#define KeyForceLogoff  L"ForceLogoffWhenHourExpire"
#define KeyEnableAdmin L"EnableAdminAccount"
#define KeyEnableGuest L"EnableGuestAccount"
#define KeyLSAAnonLookup  L"LSAAnonymousNameLookup"

/*
Routine Description: 

Name:

    CPasswordPolicy::CPasswordPolicy

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CPasswordPolicy::CPasswordPolicy (
    IN ISceKeyChain  * pKeyChain, 
    IN IWbemServices * pNamespace,
    IN IWbemContext  * pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{

}

/*
Routine Description: 

Name:

    CPasswordPolicy::~CPasswordPolicy

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/

CPasswordPolicy::~CPasswordPolicy ()
{
}

/*
Routine Description: 

Name:

    CRGroups::CreateObject

Functionality:
    
    Create WMI objects (Sce_PasswordPolicy). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT 
CPasswordPolicy::CreateObject (
    IN IWbemObjectSink * pHandler, 
    IN ACTIONTYPE        atAction
    )
{
    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Delete a single instance ACTIONTYPE_DELETE
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET != atAction &&
         ACTIONTYPE_DELETE != atAction &&
         ACTIONTYPE_QUERY != atAction ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // We must have the pStorePath property because that is where
    // our instance is stored. 
    // m_srpKeyChain->GetKeyPropertyValue WBEM_S_FALSE if the key is not recognized
    // So, we need to test against WBEM_S_FALSE if the property is mandatory
    //

    CComVariant varStorePath;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(pStorePath, &varStorePath);

    if (SUCCEEDED(hr) && hr != WBEM_S_FALSE && varStorePath.vt == VT_BSTR)
    {
        //
        // Prepare a store (for persistence) for this store path (file)
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistPath(varStorePath.bstrVal);

        if ( SUCCEEDED(hr) ) 
        {

            //
            // make sure the store (just a file) really exists. The raw path
            // may contain env variables, so we need the expanded path
            //

            DWORD dwAttrib = GetFileAttributes(SceStore.GetExpandedPath());

            if ( dwAttrib != -1 ) 
            {

                if ( ACTIONTYPE_DELETE == atAction )
                {
                    hr = DeleteInstance(pHandler, &SceStore);
                }
                else
                {
                    hr = ConstructInstance(pHandler, &SceStore, varStorePath.bstrVal,atAction);
                }

            } 
            else 
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CPasswordPolicy::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_PasswordPolicy,
    which is persistence oriented, this will cause the Sce_PasswordPolicy object's property 
    information to be saved in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst       - COM interface pointer to the WMI class (Sce_PasswordPolicy) object.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

*/

HRESULT 
CPasswordPolicy::PutInst (
    IN IWbemClassObject * pInst, 
    IN IWbemObjectSink  * pHandler,
    IN IWbemContext     * pCtx
    )
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;

    //
    // These are all password policy's properties.
    // SCE_NO_VALUE means the property is not set.
    //

    DWORD dwMinAge      = SCE_NO_VALUE;
    DWORD dwMaxAge      = SCE_NO_VALUE;
    DWORD dwMinLen      = SCE_NO_VALUE;
    DWORD dwHistory     = SCE_NO_VALUE;
    DWORD dwComplexity  = SCE_NO_VALUE;
    DWORD dwClear       = SCE_NO_VALUE;
    DWORD dwForce       = SCE_NO_VALUE;
    DWORD dwLSAPol      = SCE_NO_VALUE;
    DWORD dwAdmin       = SCE_NO_VALUE;
    DWORD dwGuest       = SCE_NO_VALUE;

    //
    // CScePropertyMgr helps us to access WMI object's properties
    // create an instance and attach the WMI object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pInst);

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pMinAge, &dwMinAge));

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pMaxAge, &dwMaxAge));

    //
    // check dependency
    //

    if ( dwMinAge != SCE_NO_VALUE && dwMaxAge != SCE_NO_VALUE ) 
    {
        if ( dwMinAge >= dwMaxAge ) 
        {
            hr = WBEM_E_VALUE_OUT_OF_RANGE;
        }
        if ( dwMinAge > 999 || dwMaxAge > 999 ) 
        {
            hr = WBEM_E_VALUE_OUT_OF_RANGE;
        }
    } 
    else if (dwMinAge != SCE_NO_VALUE || dwMaxAge != SCE_NO_VALUE ) 
    {
        hr = WBEM_E_ILLEGAL_NULL;
    }

    if ( FAILED(hr) )
    {
        goto CleanUp;
    }

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pMinLength, &dwMinLen));

    //
    // check validity of the minimum length property
    //

    if ( dwMinLen != SCE_NO_VALUE && dwMinLen > 14 ) 
    {
        hr = WBEM_E_VALUE_OUT_OF_RANGE;
        goto CleanUp;
    }

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pHistory, &dwHistory));

    //
    // check validity of the history property
    //

    if ( dwHistory != SCE_NO_VALUE && dwHistory > 24 ) 
    {
        hr = WBEM_E_VALUE_OUT_OF_RANGE;
        goto CleanUp;
    }

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pComplexity, &dwComplexity));

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pStoreClearText, &dwClear));

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pForceLogoff, &dwForce));

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pLSAPol, &dwLSAPol));

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pEnableAdmin, &dwAdmin));

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pEnableGuest, &dwGuest));

    //
    // this set of braces allow us to define the store instance closer to where it is used
    //

    {
        //
        // Attach the WMI object instance to the store and let the store know that
        // it's store is given by the pStorePath property of the instance.
        //

        CSceStore SceStore;
        SceStore.SetPersistProperties(pInst, pStorePath);

        //
        // now save the info to file
        //

        hr = SaveSettingsToStore(&SceStore,
                                  dwMinAge,
                                  dwMaxAge,
                                  dwMinLen,
                                  dwHistory,
                                  dwComplexity,
                                  dwClear,
                                  dwForce,
                                  dwLSAPol,
                                  dwAdmin,
                                  dwGuest
                                  );
    }

CleanUp:

    return hr;
}

/*
Routine Description: 

Name:

    CRGroups::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_PasswordPolicy.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszLogStorePath - store path, a key property of Sce_PasswordPolicy class.

    atAction        - whether it's querying or a single instance fetching.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:

*/

HRESULT 
CPasswordPolicy::ConstructInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore,
    IN LPWSTR             wszLogStorePath,
    IN ACTIONTYPE         atAction
    )
{
    // 
    // make sure that we have a valid store
    //

    if ( pSceStore == NULL ||
         pSceStore->GetStoreType() < SCE_INF_FORMAT ||
         pSceStore->GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // ask SCE to read a gigantic structure out from the store. Only SCE
    // knows now to release the memory. Don't just delete it! Use our CSceStore
    // to do the releasing (FreeSecurityProfileInfo)
    //

    PSCE_PROFILE_INFO pInfo=NULL;
    HRESULT hr = pSceStore->GetSecurityProfileInfo(
                                                   AREA_SECURITY_POLICY,
                                                   &pInfo,
                                                   NULL
                                                   );

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // If one of the following properties are missing from the store,
    // we won't construct the wmi object for it.
    //

    if (pInfo->MinimumPasswordAge        == SCE_NO_VALUE &&
        pInfo->MaximumPasswordAge        == SCE_NO_VALUE &&
        pInfo->MinimumPasswordLength     == SCE_NO_VALUE &&
        pInfo->PasswordHistorySize       == SCE_NO_VALUE &&
        pInfo->PasswordComplexity        == SCE_NO_VALUE &&
        pInfo->ClearTextPassword         == SCE_NO_VALUE &&
        pInfo->ForceLogoffWhenHourExpire == SCE_NO_VALUE &&
        pInfo->LSAAnonymousNameLookup    == SCE_NO_VALUE ) 
    {
        pSceStore->FreeSecurityProfileInfo(pInfo);
        return WBEM_E_NOT_FOUND;
    }

    CComBSTR bstrLogOut;
    LPCWSTR pszExpandedPath = pSceStore->GetExpandedPath();

    CComPtr<IWbemClassObject> srpObj;

    //
    // CScePropertyMgr helps us to access WMI object's properties.
    //

    CScePropertyMgr ScePropMgr;

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    if ( ACTIONTYPE_QUERY == atAction )
    {
        SCE_PROV_IfErrorGotoCleanup(MakeSingleBackSlashPath(wszLogStorePath, L'\\', &bstrLogOut));
        pszExpandedPath = bstrLogOut;
    }

    SCE_PROV_IfErrorGotoCleanup(SpawnAnInstance(&srpObj));
    
    //
    // attach the WMI object to the property mgr.
    // This will always succeed.
    //

    ScePropMgr.Attach(srpObj);

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pStorePath, pszExpandedPath));

    if (pInfo->MinimumPasswordAge != SCE_NO_VALUE ) {
        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pMinAge, pInfo->MinimumPasswordAge));
    }

    if (pInfo->MaximumPasswordAge != SCE_NO_VALUE ) {
        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pMaxAge, pInfo->MaximumPasswordAge));
    }

    if (pInfo->MinimumPasswordLength != SCE_NO_VALUE ) {
        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pMinLength, pInfo->MinimumPasswordLength));
    }

    if (pInfo->PasswordHistorySize != SCE_NO_VALUE ) {
        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pHistory, pInfo->PasswordHistorySize));
    }

    if (pInfo->PasswordComplexity != SCE_NO_VALUE ) {
        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pComplexity, (pInfo->PasswordComplexity==1)? true : false));
    }

    if (pInfo->ClearTextPassword != SCE_NO_VALUE ) {
        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pStoreClearText, (pInfo->ClearTextPassword==1)? true : false));
    }

    if (pInfo->ForceLogoffWhenHourExpire != SCE_NO_VALUE ) {
        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pForceLogoff, (pInfo->ForceLogoffWhenHourExpire==1)? true : false));
    }

    if (pInfo->LSAAnonymousNameLookup != SCE_NO_VALUE ) {
        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pLSAPol, (pInfo->LSAAnonymousNameLookup==1)? true : false));
    }

    //
    // do the necessary gestures to WMI.
    // the use of WBEM_STATUS_REQUIREMENTS in SetStatus is not documented by WMI
    // at this point. Consult WMI team for detail if you suspect problems with
    // the use of WBEM_STATUS_REQUIREMENTS
    //

    if ( ACTIONTYPE_QUERY == atAction ) {
        pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_FALSE, NULL, NULL);
    } else {
        pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);
    }

    //
    // pass the new instance to WMI
    //

    hr = pHandler->Indicate(1, &srpObj);

CleanUp:

    pSceStore->FreeSecurityProfileInfo(pInfo);

    return hr;
}

/*
Routine Description: 

Name:

    CPasswordPolicy::DeleteInstance

Functionality:
    
    remove an instance of Sce_PasswordPolicy from the specified store.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: WBEM_E_INVALID_PARAMETER.

Notes:

*/

HRESULT 
CPasswordPolicy::DeleteInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore
    )
{
    // 
    // make sure that we have a valid store
    //

    if ( pSceStore == NULL || pSceStore->GetStoreType() < SCE_INF_FORMAT ||
         pSceStore->GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr=WBEM_S_NO_ERROR;

    //
    // a SCE_NO_VALUE will cause that property to be delete by SaveSettingsToStore
    //

    hr = SaveSettingsToStore(pSceStore, 
                             SCE_NO_VALUE, 
                             SCE_NO_VALUE, 
                             SCE_NO_VALUE, 
                             SCE_NO_VALUE, 
                             SCE_NO_VALUE, 
                             SCE_NO_VALUE, 
                             SCE_NO_VALUE, 
                             SCE_NO_VALUE, 
                             SCE_NO_VALUE, 
                             SCE_NO_VALUE
                             );

    return hr;

}

/*
Routine Description: 

Name:

    CPasswordPolicy::SaveSettingsToStore

Functionality:
    
    With all the properties of a Sce_PasswordPolicy, this function just saves
    the instance properties to our store.

Virtual:
    
    No.
    
Arguments:

    pSceStore       - the store.

    dwMinAge        - a corresponding key property of Sce_PasswordPolicy class.

    dwMaxAge        - another corresponding property of the Sce_PasswordPolicy class.
    
    dwMinLen        - another corresponding property of the Sce_PasswordPolicy class.

    dwHistory       - another corresponding property of the Sce_PasswordPolicy class.

    dwComplexity,   - another corresponding property of the Sce_PasswordPolicy class.

    dwClear         - another corresponding property of the Sce_PasswordPolicy class.

    dwForce         - another corresponding property of the Sce_PasswordPolicy class.

    dwLSAPol        - another corresponding property of the Sce_PasswordPolicy class.
    
    dwAdmin         - another corresponding property of the Sce_PasswordPolicy class.
    
    dwGuest         - another corresponding property of the Sce_PasswordPolicy class.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any error indicates the failure to save the instance.

Notes:
*/

HRESULT 
CPasswordPolicy::SaveSettingsToStore (
    IN CSceStore    * pSceStore,
    IN DWORD          dwMinAge, 
    IN DWORD          dwMaxAge, 
    IN DWORD          dwMinLen,
    IN DWORD          dwHistory, 
    IN DWORD          dwComplexity, 
    IN DWORD          dwClear,
    IN DWORD          dwForce, 
    IN DWORD          dwLSAPol, 
    IN DWORD          dwAdmin, 
    IN DWORD          dwGuest
    )
{
    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    DWORD dwDump;

    //
    // For a new .inf file. Write an empty buffer to the file
    // will creates the file with right header/signature/unicode format
    // this is harmless for existing files.
    // For database store, this is a no-op.
    //

    HRESULT hr = WBEM_NO_ERROR;

    SCE_PROV_IfErrorGotoCleanup(pSceStore->WriteSecurityProfileInfo(AreaBogus,
                                                                    (PSCE_PROFILE_INFO)&dwDump,
                                                                    NULL, false));

    //
    // MinAge
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(szSystemAccess, KeyMinAge, dwMinAge));

    //
    // MaxAge
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(szSystemAccess, KeyMaxAge, dwMaxAge));

    //
    // MinLength
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(szSystemAccess, KeyMinLength, dwMinLen));
    
    //
    // History
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(szSystemAccess, KeyHistory, dwHistory));
    
    //
    // Complexity
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(szSystemAccess, KeyComplexity, dwComplexity));
    
    //
    // Cleartext
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(szSystemAccess, KeyClearText, dwClear));
    
    //
    // Force logoff
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(szSystemAccess, KeyForceLogoff, dwForce));

    //
    // LSA Anonymous Lookup
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(szSystemAccess, KeyLSAAnonLookup, dwLSAPol));

    //
    // disable admin
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(szSystemAccess, KeyEnableAdmin, dwAdmin));

    //
    // disable guest
    //

    SCE_PROV_IfErrorGotoCleanup(pSceStore->SavePropertyToStore(szSystemAccess, KeyEnableGuest, dwGuest));

CleanUp:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\persistmgr.h ===
// persistmgr.h: interface for the SCE persistence related classes.
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <ntsecapi.h>
#include <secedit.h>
#include "compkey.h"

//
// macro to save the similar code
//

#define SCE_PROV_IfErrorGotoCleanup(x) {if (FAILED(hr = (x))) goto CleanUp;}

//
// some helper functions 
//

LPCWSTR EscSeekToChar(LPCWSTR pszSource, WCHAR wchChar, bool* pbEscaped, bool bEndIfNotFound);

void TrimCopy(LPWSTR pDest, LPCWSTR pSource, int iLen);

//
// make them visible to all those who include this header
//

extern const WCHAR wchCookieSep;
extern const WCHAR wchTypeValSep;

extern const WCHAR wchTypeValLeft;
extern const WCHAR wchTypeValRight;

extern const WCHAR wchMethodLeft;
extern const WCHAR wchMethodRight;
extern const WCHAR wchMethodSep;

extern const WCHAR wchParamSep;

extern LPCWSTR pszListPrefix;
extern LPCWSTR pszKeyPrefix;
extern LPCWSTR pszNullKey;

extern LPCWSTR pszAttachSectionValue;

//
// some constants
//

const int iFormatIntegral   = 1;
const int iFormatInt8       = 2;
const int iFormatFloat      = 3;
const int iFormatCurrenty   = 4;
const int iFormatArray      = 5;

const int MAX_INT_LENGTH    = 32;
const int MAX_DOUBLE_LENGTH = 64;

const int MAX_COOKIE_COUNT_PER_LINE = 10;

const DWORD INVALID_COOKIE = 0; 


/*

Class description
    
    Naming: 
         CScePropertyMgr stands SCE wbem Property Manager.
    
    Base class: 
         None.
    
    Purpose of class:
        (1) This class is used to access properties (both Put and Get). The main
            reason for having this function is that we can override many versions,
            one for each major data type the caller is expecting. Otherwise, it will
            be all variants.
    
    Design:
        (1) Trivial. Just some overrides of both Get and Put.
        (2) The class is attaching (Attach) to a particular wbem object. It can
            be freely re-attached by calling Attach multiple times. This is good
            inside a loop.
    
    Use:
        (1) Create an instance of this class.
        (2) Attach the wbem object to the manager.
        (3) Access (put or get) the properties as you wish.
*/


class CScePropertyMgr
{
public:
    CScePropertyMgr();
    ~CScePropertyMgr();

    void Attach(IWbemClassObject *pObj);

    //
    //property Put methods:
    //

    HRESULT PutProperty(LPCWSTR pszProperty, VARIANT* pVar);
    HRESULT PutProperty(LPCWSTR pszProperty, LPCWSTR szValue);
    HRESULT PutProperty(LPCWSTR pszProperty, DWORD iValue);
    HRESULT PutProperty(LPCWSTR pszProperty, float fValue);
    HRESULT PutProperty(LPCWSTR pszProperty, double dValue);
    HRESULT PutProperty(LPCWSTR pszProperty, bool bValue);
    HRESULT PutProperty(LPCWSTR pszProperty, PSCE_NAME_LIST strList);

    //
    // property Get methods:
    //

    HRESULT GetProperty(LPCWSTR pszProperty, VARIANT* pVar);
    HRESULT GetProperty(LPCWSTR pszProperty, BSTR *pbstrValue);
    HRESULT GetProperty(LPCWSTR pszProperty, DWORD *piValue);
    HRESULT GetProperty(LPCWSTR pszProperty, bool *pbValue);
    HRESULT GetProperty(LPCWSTR szProperty, PSCE_NAME_LIST *strList);

    //
    // we can expand the the path as well.
    //

    HRESULT GetExpandedPath(LPCWSTR pszPathName, BSTR *pbstrValue, BOOL* pbIsDB);

private:
    CComPtr<IWbemClassObject> m_srpClassObj;
};

/*

Class description
    
    Naming: 
         CSceStore stands SCE Store.
    
    Base class: 
         None.
    
    Purpose of class:
        (1) This class is to encapulate the notation of persistence store for SCE. Almost
            everything we do with SCE provider (other than execute a function like Configure)
            is to put instances into a template store. That store can currently be a .INF file,
            or a database (.sdb). Our goal is to isolate this store from the rest of the
            code so that when we expand our store types (like XML), the code affected will
            be greatly reduced and thus improve code maintainability drastically.
    
    Design:
        (1) Move all SCE engine backend specific functionality here. This is a little bit
            confusing because there are so many. See the comments to locate these functions.

        (2) To support current property saving, we have SavePropertyToStore (several overrides)
            function.

        (3) To support current property saving, we have GetPropertyFromStore (several overrides)
            function. Both (2) and (3) maintain a high fidelity to the current .inf and .sdb APIs.

        (4) To ease the confusion that saving in a particular way means to delete, we also have
            DeletePropertyFromStore, DeleteSectionFromStore functions.

        (5) Ideally, we only need GetPropertyFromStore and SavePropertyToStore functions.

        (6) To allow future growth of maximum extensibility, we planned (not yet) to support IPersistStream.
    
    Use:
        (1) Create an instance of this class.
        (2) Specify the persistence properties (SetPersistPath and SetPersistProperties).
        (3) Call appropriate functions.

*/

class CSceStore
{
public:
    CSceStore();
    ~CSceStore(){}

    HRESULT SetPersistProperties(IWbemClassObject* pClassObj, LPCWSTR lpszPathPropertyName);

    HRESULT SetPersistPath(LPCWSTR pszPath);

    HRESULT SetPersistStream(IPersistStream* pSceStream)
    {
        return WBEM_E_NOT_SUPPORTED;    // not yet
    }

    HRESULT SavePropertyToStore(LPCWSTR pszSection, LPCWSTR pszKey, LPCWSTR pszValue)const;
    HRESULT SavePropertyToStore(LPCWSTR pszSection, LPCWSTR pszKey, DWORD Data)const;
    HRESULT SavePropertyToStore(LPCWSTR pszSection, LPCWSTR pszKey, DWORD Data, WCHAR delim, LPCWSTR pszValue)const;

    HRESULT GetPropertyFromStore(LPCWSTR pszSection, LPCWSTR pszKey, LPWSTR *ppszBuffer, DWORD* pdwRead)const;
    
    //
    // the following two methods are to stop our current semantics to let
    // deleting and saving share the same function. Callers be aware:
    // WritePrivateProfileString (which we ultimately use in inf file store) can't report
    // error when deleting a non existent key. So, don't rely on this return code to catch
    // the "deleting non-existent property" error.
    //

    HRESULT
    DeletePropertyFromStore (
        IN LPCWSTR pszSection, 
        IN LPCWSTR pszKey
        )const
    {
    return SavePropertyToStore(pszSection, pszKey, (LPCWSTR)NULL);
    }

    HRESULT DeleteSectionFromStore (
                                    IN LPCWSTR pszSection
                                    )const;

    //
    // the following functions are designed for the maximum compability of the current INF file API and its
    // SCE backend support on reading/writing
    //

    HRESULT GetSecurityProfileInfo (
                                   AREA_INFORMATION Area,
                                   PSCE_PROFILE_INFO *ppInfoBuffer, 
                                   PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
                                   )const;

    HRESULT WriteSecurityProfileInfo (
                                     AREA_INFORMATION Area, 
                                     PSCE_PROFILE_INFO ppInfoBuffer, 
                                     PSCE_ERROR_LOG_INFO *Errlog, 
                                     bool bAppend
                                     )const;
    void 
    FreeSecurityProfileInfo (
        IN OUT PSCE_PROFILE_INFO pInfo
        )const
    {
        if (pInfo != NULL)
        {
            SceFreeProfileMemory(pInfo);
        }
    }

    HRESULT GetObjectSecurity (
                              AREA_INFORMATION Area, 
                              LPCWSTR pszObjectName, 
                              PSCE_OBJECT_SECURITY *ppObjSecurity
                              )const;

    void 
    FreeObjectSecurity (
        IN OUT PSCE_OBJECT_SECURITY pObjSecurity
        )const
    {
        if (pObjSecurity)
            SceFreeMemory(pObjSecurity, SCE_STRUCT_OBJECT_SECURITY);
    }

    LPCWSTR 
    GetExpandedPath ()const
    {
        return m_bstrExpandedPath;
    }

    SCE_STORE_TYPE 
    GetStoreType ()const
    {
        return m_SceStoreType;
    }

    HRESULT WriteAttachmentSection (
                                    LPCWSTR pszKey, 
                                    LPCWSTR pszData
                                    )const;

private:

    HRESULT SavePropertyToDB (
                             LPCWSTR pszSection, 
                             LPCWSTR pszKey, 
                             LPCWSTR pszData
                             )const;

    HRESULT GetPropertyFromDB (
                              LPCWSTR pszSection, 
                              LPCWSTR pszKey, 
                              LPWSTR *ppszBuffer, 
                              DWORD* pdwRead
                              )const;


    CComBSTR m_bstrExpandedPath;

    CComPtr<IWbemClassObject> m_srpWbemClassObj;

    SCE_STORE_TYPE m_SceStoreType;
};

//==========================================================================

//
// some global parsing related functions:
//

HRESULT VariantFromFormattedString (
                                   LPCWSTR pszString,  // [in]
                                   VARIANT* pVar       // [out]
                                   );

HRESULT FormatVariant (
                      VARIANT* pVar, 
                      BSTR* pbstrData
                      );

HRESULT GetObjectPath (
                      IWbemClassObject* pSpawn,  // [in]
                      LPCWSTR pszStorePath,      // [in]
                      LPCWSTR pszCompoundKey,    // [in]
                      BSTR* pbstrPath            // [out]
                      );

HRESULT ParseCompoundKeyString (
                               LPCWSTR pszCur, 
                               LPWSTR* ppszName, 
                               VARIANT* pVar, 
                               LPCWSTR* ppNext
                               );

HRESULT PopulateKeyProperties (
                              LPCWSTR pszCompoundKey,     // [in]
                              CScePropertyMgr* pPropMgr   // [in]
                              );

HRESULT CurrencyFromFormatString (
                                 LPCWSTR lpszFmtStr, 
                                 VARIANT* pVar
                                 );

HRESULT ArrayFromFormatString (
                              LPCWSTR lpszFmtStr, 
                              VARTYPE vt, 
                              VARIANT* pVar
                              );

HRESULT FormatArray (
                    VARIANT* pVar, 
                    BSTR* pbstrData
                    );

HRESULT GetStringPresentation ( 
                              VARIANT* pVar, 
                              BSTR* pbstrValue
                              );

void* GetVoidPtrOfVariant (
                          VARTYPE vt,         // can't be VT_ARRAY, which is done separately
                          VARIANT* pVar
                          );

HRESULT VariantFromStringValue (
                               LPCWSTR szValue,    // [in]
                               VARTYPE vt,         // [in]
                               VARIANT* pVar       // [out]
                               );

//==========================================================================


/*

Class description
    
    Naming: 
        CScePersistMgr stands SCE Persistence Manager.
    
    Base class: 
        (1) CComObjectRootEx<CComMultiThreadModel> for threading model and IUnknown
        (2) CComCoClass<CScePersistMgr, &CLSID_ScePersistMgr> for class factory support
        (3) IScePersistMgr, our custom interface
    
    Purpose of class:
        (1) This class is to encapulate the ultimate goal of persistence. This manager
            can persist any cooperating class (ISceClassObject). ISceClassObject is designed
            to supply a wbem object's (name, value) pairs together with its easy access to
            the information whether a property is a key property or not. All these are rather
            straight forward for any wbem object.
        (2) Make the persistence model extremely simple: Save, Load, Delete.
        (3) Current use of this persistence manager is intended for embedding classes. To adapt it
            for use of native classes, we need a lot more work. The reason is that native object's
            persistence is an intimate knowledge of SCE backend. It knows precisely how the instances
            are persisted. That kind of dependency ties both sides up. Unless the SCE backend modifies
            for a more object-oriented approach, any attempt for persisting native objects will fail.
    
    Design:
        (1) This is an IScePersistMgr.

        (2) This is not a directly instantiatable class. See the constructor and destructor, they are
            both protected. See Use section for creation steps.

        (3) maintain two vectors, one for key property values and one for non-key property values.
            We very often need to access key properties differently because they form the key to
            identify the object.

        (4) To quickly identify an instance and keep redundant data away from the store, an instance is
            identified by its cookie (just a unique DWORD number). For each cookie, the key properties
            should be conveniently available. For that purpose, we developed the notation of string
            format Compound Key. It is pretty much just an encoding of key property names and its
            values using a string. For example, if the key of the class has two properties CompanyName (string)
            and RegNumber (DWORD), then an instance of this class identified by:
                
                  CompanyName = "ABCDEFG Inc.", RegNumber = 123456789

            will have its compound key in string format as follows:

                  CompanyName<VT_BSTR : "ABCDEFG Inc.">RegNumber<VT_I4 : 123456789>
    
    Use:
        (1) Create an instance of this class. Since it's not a directly instantiatable class, you need
            to use CComObject<CScePersistMgr> for creation:

                CComObject<CScePersistMgr> *pPersistMgr = NULL;
                hr = CComObject<CScePersistMgr>::CreateInstance(&pPersistMgr);

        (2) Attach an ISceClassObject object to this instance by calling Attach.
        (3) Call appropriate functions.

    Notes:
        This class is not intended for derivation. It's a final class. The destructor is thus not virtual.
*/

class ATL_NO_VTABLE CScePersistMgr
    : public CComObjectRootEx<CComMultiThreadModel>,
      public CComCoClass<CScePersistMgr, &CLSID_ScePersistMgr>,
      public IScePersistMgr
{
public:

BEGIN_COM_MAP(CScePersistMgr)
    COM_INTERFACE_ENTRY(IScePersistMgr)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE( CScePersistMgr )
DECLARE_REGISTRY_RESOURCEID(IDR_SceProv)

protected:
    CScePersistMgr();
    ~CScePersistMgr();

public:

    //
    // IScePersistMgr
    //

    STDMETHOD(Attach) ( 
                      REFIID guid,    // [in]
                      IUnknown *pObj  // [iid_is][in]
                      );

    STDMETHOD(Save) ();
        
    STDMETHOD(Load) (
                    BSTR bstrStorePath,         // [in]
                    IWbemObjectSink *pHandler   //[in] 
                    );
        
    STDMETHOD(Delete) (
                      BSTR bstrStorePath,         // [in] 
                      IWbemObjectSink *pHandler   //[in] 
                      );

private:

    HRESULT GetCompoundKey (
                           BSTR* pbstrKey  // [out]
                           );

    //
    // inline
    //

    HRESULT 
    GetSectionName (
        OUT BSTR* pbstrSection
        )
    {
        return m_srpObject->GetClassName(pbstrSection);
    }

    //
    // inline
    //

    HRESULT 
    GetClassName (
        OUT BSTR* pbstrClassName
        )
    {
        return m_srpObject->GetClassName(pbstrClassName);
    }

    HRESULT FormatNonKeyPropertyName (
                                     DWORD dwCookie,             // [in]
                                     DWORD dwIndex,              // [in]
                                     BSTR* pbstrStorePropName,   // [out]
                                     BSTR* pbstrTrueName         // [out]
                                     );

    HRESULT FormatPropertyValue (
                                SceObjectPropertyType type, // [in]
                                DWORD dwIndex,              // [in]
                                BSTR* pbstrProp             // [out]
                                );


    HRESULT LoadInstance (
                         CSceStore* pSceStore,
                         LPCWSTR pszSectionName,
                         LPCWSTR pszCompoundKey, 
                         DWORD dwCookie,
                         IWbemClassObject** ppNewObj
                         );

    HRESULT SaveProperties (
                           CSceStore* pSceStore, 
                           DWORD dwCookie, 
                           LPCWSTR pszSection
                           );

    HRESULT DeleteAllNonKeyProperties (
                                      CSceStore* pSceStore, 
                                      DWORD dwCookie, 
                                      LPCWSTR pszSection
                                      );

    std::vector<LPWSTR>* GetKeyPropertyNames (
                                             IWbemServices* pNamespace, 
                                             IWbemContext* pCtx
                                             );


    std::vector<CPropValuePair*> m_vecKeyValueList;

    std::vector<CPropValuePair*> m_vecPropValueList;

    CComPtr<ISceClassObject> m_srpObject;
};

//==========================================================================

typedef struct tagVtTypeStruct
{
    LPCWSTR pszVtTypeString;
    VARTYPE    vt;
} VtTypeStruct;

//==========================================================================

/*
     
Class description
    
    Naming:

        CMapStringToVt stands for String to VT (VARTYPE) Map.
    
    Base class: 
        None.
    
    Purpose of class:
        CMapStringToVt is a straight forward class wrapping up a map.
    
    Design:
        (1) GetType very efficiently returns the VARTYPE for the given string version of the vt.
    
    Use:
        (1) Create an instance of this class.
        (2) Call GetType to get the VARTYPE value for the given string version of the vt. For
            example, GetType(L"VT_BSTR") will return VT_BSTR;
*/

class CMapStringToVt
{
public:
    CMapStringToVt (
                   DWORD dwCount, 
                   VtTypeStruct* pInfoArray
                   );

    VARTYPE GetType (
                    LPCWSTR, 
                    VARTYPE* pSubType
                    );

private:

typedef std::map<LPCWSTR, VARTYPE, strLessThan<LPCWSTR> > MapStringToVt;

    MapStringToVt m_Map;
};

//==========================================================================

/*
     
Class description
    
    Naming:

        CMapVtToString stands for VT (VARTYPE) to String Map.
    
    Base class: 
        None.
    
    Purpose of class:
        CMapVtToString is a straight forward class wrapping up a map. It is the exact inverse
        version of CMapStringToVt
    
    Design:
        (1) GetTypeString very efficiently returns the string version of the given VARTYPE.

        (2) GetTypeString can also efficiently return the string version of the given VARTYPE
            plus the sub-VARTYPE if the given VARTYPE is VT_ARRAY.
    
    Use:
        (1) Create an instance of this class.
        (2) Call GetTypeString to get the string version of the given VARTYPE. For
            example, GetTypeString(VT_BSTR) will return L"VT_BSTR", and GetTypeString(VT_ARRAY, VT_BSTR)
            will return L"VT_ARRAY(VT_BSTR)"
*/

class CMapVtToString
{
public:
    CMapVtToString(DWORD dwCount, VtTypeStruct* pInfoArray);

    LPCWSTR GetTypeString(VARTYPE vt, VARTYPE vtSub);
    LPCWSTR GetTypeString(VARTYPE vt);

private:

typedef std::map<VARTYPE, LPCWSTR> MapVtToString;

    MapVtToString m_Map;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\regvalue.h ===
// regvalue.h: interface for the CRegistryValue class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGVALUE_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_REGVALUE_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

/*

Class description
    
    Naming: 

        CRegistryValue stands for Registry Value.
    
    Base class: 

        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_RegistryValue
    
    Purpose of class:
    
        (1) Implement Sce_RegistryValue WMI class.
    
    Design:
         
        (1) Almost trivial other than implementing necessary method as a concrete class
    
    Use:

        (1) Almost never used directly. Alway through the common interface defined by
            CGenericClass.
    
*/

class CRegistryValue : public CGenericClass
{
public:
        CRegistryValue (
                       ISceKeyChain *pKeyChain, 
                       IWbemServices *pNamespace, 
                       IWbemContext *pCtx = NULL
                       );

        virtual ~CRegistryValue ();

        virtual HRESULT PutInst (
                                IWbemClassObject *pInst, 
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                );

        virtual HRESULT CreateObject (
                                     IWbemObjectSink *pHandler, 
                                     ACTIONTYPE atAction
                                     );

private:

        HRESULT ConstructInstance (
                                  IWbemObjectSink *pHandler, 
                                  CSceStore* pSceStore, 
                                  LPCWSTR wszLogStorePath, 
                                  LPCWSTR wszRegPath, 
                                  BOOL bPostFilter 
                                  );

        HRESULT DeleteInstance (
                               IWbemObjectSink *pHandler, 
                               CSceStore* pSceStore, 
                               LPCWSTR wszRegPath 
                               );

        HRESULT ValidateRegistryValue (
                                      BSTR bstrRegPath, 
                                      DWORD RegType, 
                                      BSTR bstrValue 
                                      );

};

#endif // !defined(AFX_REGVALUE_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sceprov.rc
//
#define IDS_E_NAME_TOO_LONG             1
#define IDS_SUCCESS                     2
#define IDS_E_ENCODE_ERROR              3
#define IDS_GET_EMBED_METHOD            4
#define IDS_GET_SCE_CLASS_OBJECT        5
#define IDS_SPAWN_INSTANCE              6
#define IDS_POPULATE_FO                 7
#define IDS_GET_FULLPATH                8
#define IDS_DELETE_INSTANCE             9
#define IDS_PUT_INSTANCE                10
#define IDS_INVALID_METHOD_CONTEXT      11
#define IDS_E_OUT_OF_MEMROY             12
#define IDS_E_METHOD_FAIL               13
#define IDS_PUT_IN_PARAMETER            14
#define IDS_GET_LOGFILEPATH             15
#define IDS_IMPORT_TEMPLATE             16
#define IDS_CONFIGURE_DB                17
#define IDS_EXPORT_DB                   18
#define IDS_GET_KEY_PROPERTY            19
#define IDS_GET_NON_KEY_PROPERTY        20
#define IDS_NON_STATIC_CALL             21
#define IDS_MISSING_TOKEN               22
#define IDS_FAILURE_CAUSE               23
#define IDS_OBJECT_DETAIL               24
#define IDS_PARAMETER_DETAIL            25
#define IDS_ACTION                      26
#define IDS_ERROR_CODE                  27
#define IDS_EXE_FOREIGN_METHOD          28
#define IDS_IN_PARAMETER                29
#define IDS_OUT_PARAMETER               30
#define IDS_METHOD_NOT_SUPPORTED        31
#define IDS_CREATE_SEQUENCER            32
#define IDS_CREATE_CLASSENUM            33
#define IDS_GET_CLASS_DEFINITION        34
#define IDS_GET_CLASS_INSTANCE          35
#define IDS_CREATE_INSTANCE_LIST        36
#define IDS_PUT_PROPERTY                37
#define IDR_SceProv                     200

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\rights.h ===
// Rights.h: interface for the CUserPrivilegeRights class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RIGHTS_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_RIGHTS_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

/*

Class description
    
    Naming: 

        CUserPrivilegeRights stands for User Privilege Right.
    
    Base class: 

        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_UserPrivilegeRight
    
    Purpose of class:
    
        (1) Implement Sce_UserPrivilegeRight WMI class.
    
    Design:
         
        (1) Almost trivial other than implementing necessary method as a concrete class
    
    Use:

        (1) Almost never used directly. Alway through the common interface defined by
            CGenericClass.
    
*/

class CUserPrivilegeRights : public CGenericClass
{
public:
        CUserPrivilegeRights (
                              ISceKeyChain *pKeyChain, 
                              IWbemServices *pNamespace, 
                              IWbemContext *pCtx = NULL
                              );

        virtual ~CUserPrivilegeRights ();

        virtual HRESULT PutInst (
                                IWbemClassObject *pInst, 
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                );

        virtual HRESULT CreateObject (
                                     IWbemObjectSink *pHandler, 
                                     ACTIONTYPE atAction
                                     );

private:

        HRESULT ConstructInstance (
                                  IWbemObjectSink *pHandler, 
                                  CSceStore* pSceStore, 
                                  LPCWSTR wszLogStorePath, 
                                  LPCWSTR wszRightName, 
                                  BOOL bPostFilter 
                                  );

        HRESULT DeleteInstance (
                               IWbemObjectSink *pHandler, 
                               CSceStore* pSceStore, 
                               LPCWSTR wszRightName 
                               );

        HRESULT SaveSettingsToStore (
                                    CSceStore* pSceStore, 
                                    LPCWSTR wszRightName, 
                                    DWORD mode, 
                                    PSCE_NAME_LIST pnlAdd, 
                                    PSCE_NAME_LIST pnlRemove
                                    );

        HRESULT ValidatePrivilegeRight (
                                       BSTR bstrRight
                                       );

};

#endif // !defined(AFX_RIGHTS_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\requestobject.cpp ===
// RequestObject.cpp: implementation of the CRequestObject class.
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <stdio.h>
#include <wininet.h>
#include "sceprov.h"
#include "requestobject.h"

//Classes
#include "template.h"
#include "password.h"
#include "lockout.h"
#include "database.h"
#include "operation.h"
#include "kerberos.h"
#include "audit.h"
#include "eventlog.h"
#include "regvalue.h"
#include "option.h"
#include "object.h"
#include "service.h"
#include "rights.h"
#include "group.h"
#include "support.h"
#include "attachment.h"
#include "logrec.h"
#include "sequence.h"
#include "Tranx.h"

#include "sceparser.h"

#include "extbase.h"

//
// The global instance that manages all SCE Emebedding classes
//

CExtClasses g_ExtClasses;

/*
Routine Description: 

Name:

    CRequestObject::CreateObject

Functionality:
    
    Parse the given path and use the key property information from the path
    to create an object.

Virtual:
    
    No.
    
Arguments:

    bstrPath - The path to the object that is being requsted by WMI.
    
    pHandler - COM interface pointer for notifying WMI for creation result.

    pCtx     - COM interface pointer being passed around for various WMI API's.

    ActType  -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE
                Enumerate instances ACTIONTYPE_ENUM

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. 

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:
    
    Any created object is returned to WMI via pHandler->Indicate. You won't see an out
    parameter to pass that instance back.

*/

HRESULT
CRequestObject::CreateObject (
    IN BSTR               bstrPath, 
    IN IWbemObjectSink  * pHandler, 
    IN IWbemContext     * pCtx, 
    IN ACTIONTYPE         ActType
    )
{
    HRESULT hr = WBEM_NO_ERROR;

    //
    // we only know how to deal with a CGenericClass
    //

    CGenericClass *pClass = NULL;

    //
    // need to parse the path to gain critical information
    // for the object (all key properties)
    //

    CComPtr<ISceKeyChain> srpKC;
    hr = CreateKeyChain(bstrPath, &srpKC);

    if (SUCCEEDED(hr))
    {
        //
        // Once we have succesfully created a key chain,
        // we have access to the key properties and class name.
        // so we can go ahead create the class. The created class
        // will be a heap object, don't forget to delete the pointer.
        //

        hr = CreateClass(srpKC, &pClass, pCtx);

        if (SUCCEEDED(hr))
        {
            hr = pClass->CreateObject(pHandler, ActType);
            delete pClass;
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CRequestObject::CreateKeyChain

Functionality:
    
    Do the parsing of object path (given by WMI) in terms of returning our
    custom interface ISceKeyChain.

Virtual:
    
    No.
    
Arguments:

    pszPath     - The path to the object that is being requsted by WMI.
    
    ppKeyChain  - COM interface pointer of our key chain object. A key chain object
                  allows you to access the key properties given by a path easily. Must
                  not be NULL.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. 
    
    Failure: Various errors may occurs.

Notes:

*/

HRESULT CRequestObject::CreateKeyChain (
    IN  LPCWSTR         pszPath, 
    OUT ISceKeyChain ** ppKeyChain
    )
{
    if (ppKeyChain == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppKeyChain = NULL;

    //
    // create our object to do the parsing
    //

    CComObject<CScePathParser> *pPathParser;
    HRESULT hr = CComObject<CScePathParser>::CreateInstance(&pPathParser);

    if (SUCCEEDED(hr))
    {
        //
        // Make sure that the object is there while you do COM activities.
        // This AddRef needs to be paired with a Release.
        //

        pPathParser->AddRef();

        //
        // Ask for the path parser interface since this is a path.
        //

        CComPtr<IScePathParser> srpPathParser;
        hr = pPathParser->QueryInterface(IID_IScePathParser, (void**)&srpPathParser);

        //
        // neutralize the above AddRef
        //

        pPathParser->Release();

        //
        // parse the path
        //

        if (SUCCEEDED(hr))
        {
            //
            // if parsing is successful, then the object must have a key chain available
            //

            hr = srpPathParser->ParsePath(pszPath);
            if (SUCCEEDED(hr))
            {
                hr = srpPathParser->QueryInterface(IID_ISceKeyChain, (void**)ppKeyChain);
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CRequestObject::CreateKeyChain

Functionality:
    
    Do the parsing of object path (given by WMI) in terms of returning our
    custom interface ISceKeyChain.

Virtual:
    
    No.
    
Arguments:

    pKeyChain   - COM interface pointer of our key chain object. A key chain object
                  allows you to access the key properties given by a path easily. Must
                  not be NULL.

    ppClass     - The path to the object that is being requsted by WMI.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. 
    
    Failure: Various errors may occurs.

Notes:
    (1) This is not a very efficient implementation because every time, we have to
        compare the string. A better approach will be to build a map to have a faster lookup.

*/

HRESULT CRequestObject::CreateClass (
    IN  ISceKeyChain    *  pKeyChain, 
    OUT CGenericClass   ** ppClass, 
    IN  IWbemContext    *  pCtx
    )
{
    if (pKeyChain == NULL || ppClass == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_S_NO_ERROR;

    //
    // Ask the key chain for the class name. We must have this to proceed.
    //

    CComBSTR bstrClassName;
    hr = pKeyChain->GetClassName(&bstrClassName);
    if (FAILED(hr))
    {
        return hr;
    }
    else if ((LPCWSTR)bstrClassName == NULL)
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    //
    // Create the appropriate class
    //

    if(0 == _wcsicmp(bstrClassName, SCEWMI_TEMPLATE_CLASS))
    {
        *ppClass = new CSecurityTemplate(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_DATABASE_CLASS))
    {
        *ppClass = new CSecurityDatabase(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_PASSWORD_CLASS))
    {
        *ppClass = new CPasswordPolicy(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_LOCKOUT_CLASS))
    {
        *ppClass = new CAccountLockout(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_KERBEROS_CLASS))
    {
        *ppClass = new CKerberosPolicy(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_OPERATION_CLASS))
    {
        *ppClass = new CSceOperation(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_AUDIT_CLASS))
    {
        *ppClass = new CAuditSettings(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_EVENTLOG_CLASS))
    {
        *ppClass = new CEventLogSettings(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_REGVALUE_CLASS))
    {
        *ppClass = new CRegistryValue(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_OPTION_CLASS))
    {
        *ppClass = new CSecurityOptions(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_FILEOBJECT_CLASS)) 
    {
        *ppClass = new CObjSecurity(pKeyChain, m_srpNamespace, SCE_OBJECT_TYPE_FILE, pCtx);
    } 
    else if (0 == _wcsicmp(bstrClassName, SCEWMI_KEYOBJECT_CLASS)) 
    {
        *ppClass = new CObjSecurity(pKeyChain, m_srpNamespace, SCE_OBJECT_TYPE_KEY, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_SERVICE_CLASS))
    {
        *ppClass = new CGeneralService(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_RIGHT_CLASS))
    {
        *ppClass = new CUserPrivilegeRights(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_GROUP_CLASS))
    {
        *ppClass = new CRGroups(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_KNOWN_REG_CLASS))
    {
        *ppClass = new CEnumRegistryValues(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_KNOWN_PRIV_CLASS))
    {
        *ppClass = new CEnumPrivileges(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_PODDATA_CLASS))
    {
        *ppClass = new CPodData(pKeyChain, m_srpNamespace, pCtx);
    }
    else if(0 == _wcsicmp(bstrClassName, SCEWMI_LOG_CLASS))
    {
        *ppClass = new CLogRecord(pKeyChain, m_srpNamespace, pCtx);
    }
    else if (0 == _wcsicmp(bstrClassName, SCEWMI_CLASSORDER_CLASS))
    {
        *ppClass = new CClassOrder(pKeyChain, m_srpNamespace, pCtx);
    }
    else if (0 == _wcsicmp(bstrClassName, SCEWMI_TRANSACTION_ID_CLASS))
    {
        *ppClass = new CTranxID(pKeyChain, m_srpNamespace, pCtx);
    }
    else
    {
        //
        // we might be requesting embedded classes
        //

        const CForeignClassInfo* pClsInfo = g_ExtClasses.GetForeignClassInfo(m_srpNamespace, pCtx, bstrClassName);
        
        if (pClsInfo == NULL)
        {
            return WBEM_E_NOT_FOUND;
        }
        else if (pClsInfo->dwClassType == EXT_CLASS_TYPE_EMBED)
        {
            *ppClass = new CEmbedForeignObj(pKeyChain, m_srpNamespace, pCtx, pClsInfo);
        }
        //else if (pClsInfo->dwClassType == EXT_CLASS_TYPE_LINK)      // embed classes
        //{
        //    *pClass = new CLinkForeignObj(pKeyChain, m_srpNamespace, pCtx, pClsInfo);
        //}
        else
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
    }

    if (*ppClass == NULL) 
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

/*
Routine Description: 

Name:

    CRequestObject::PutObject 

Functionality:
    
    Put an instance as instructed by WMI. We simply delegate this to the appropriate
    CGenericClass's subclasses.

    One excetion: Since we don't have a C++ class for sce_transactiontoken class (it
    is an in-memory instance), we will handle it here.

Virtual:
    
    No.
    
Arguments:

    pInst       - COM interface pointer to the WMI class (Sce_RestrictedGroup) object.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:

*/

HRESULT CRequestObject::PutObject (
    IN IWbemClassObject * pInst,
    IN IWbemObjectSink  * pHandler, 
    IN IWbemContext     * pCtx
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CComBSTR bstrPath;

    //
    // Get the path
    //

    hr = GetWbemObjectPath(pInst, &bstrPath);
    
    if (SUCCEEDED(hr))
    {
        //
        // get the key chain that knows what's in the path
        //

        CComPtr<ISceKeyChain> srpKC;
        hr = CreateKeyChain(bstrPath, &srpKC);

        //
        // See if we have a C++ class to respond represent the WMI object
        //

        CGenericClass* pClass = NULL;
        if (SUCCEEDED(hr))
        {
            hr = CreateClass(srpKC, &pClass, pCtx);
        }

        //
        // We do have a C++ object to represent the WMI object,
        // then just delegate the call.
        //

        if (SUCCEEDED(hr))
        {
            hr = pClass->PutInst(pInst, pHandler, pCtx);
            delete pClass;
        }
        else
        {
            //
            // The only WMI that we don't have a C++ implementation is sce_transactiontoken.
            // See if it is that one.
            //

            //
            // create sce_transactiontoken's (singleton) path
            //

            CComBSTR bstrTranxTokenPath(SCEWMI_TRANSACTION_TOKEN_CLASS);
            bstrTranxTokenPath += CComBSTR(L"=@");

            //
            // Is this the same as the object's path?
            //

            if (0 == _wcsicmp(bstrPath, bstrTranxTokenPath))
            {
                //
                // update our global variable.
                // remember, sce_transactiontoken is handled by in-memory data.
                //

                g_CS.Enter();

                //
                // invalidate our global variable
                //

                g_bstrTranxID.Empty();

                //
                // get the token property from the object
                //

                CComVariant varToken;
                hr = pInst->Get(pTranxGuid, 0, &varToken, NULL, NULL);

                if (SUCCEEDED(hr) && varToken.vt == VT_BSTR)
                {
                    //
                    // detach the CComVariant's bstr to our global
                    //

                    g_bstrTranxID.m_str = varToken.bstrVal;

                    varToken.vt = VT_EMPTY;
                    varToken.bstrVal = NULL;
                }
                else if (SUCCEEDED(hr))
                {
                    hr = WBEM_E_INVALID_OBJECT;
                }
                g_CS.Leave();
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CRequestObject::ExecMethod 

Functionality:
    
    Delegate the exec method call to the appropriate classes. Currently, we only
    have Sce_Operation class that support method exectuion. Of course, all our
    embedding class do as well. Embedding classes are totally object-oriented.

Virtual:
    
    No.
    
Arguments:

    bstrPath    - Object's path.

    bstrMethod  - Method name.

    pInParams   - In parameter of the method.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of the
    method execution. All such failures are logged in a log files (either specified
    by the in parameter or to a default log file - see CLogRecord for detail)

Notes:

*/

HRESULT CRequestObject::ExecMethod (
    IN BSTR               bstrPath, 
    IN BSTR               bstrMethod, 
    IN IWbemClassObject * pInParams,
    IN IWbemObjectSink  * pHandler, 
    IN IWbemContext     * pCtx
    )
{
    HRESULT hr = WBEM_NO_ERROR;
    CGenericClass *pClass = NULL;

    //
    // need to know the path's contents. Our key chain object is what is needed
    //

    CComPtr<ISceKeyChain> srpKC;
    hr = CreateKeyChain(bstrPath, &srpKC);

    //
    // If a key chain is created, then the class name should be available
    //

    if (SUCCEEDED(hr))
    {
        hr = CreateClass(srpKC, &pClass, pCtx);
    }

    if (SUCCEEDED(hr))
    {
        //
        // somehow, our ExecMethod identifies if the call is for an instance or not (dwCount > 0).
        // This might be a little bit misleading because a singleton won't have any key property either.
        //

        DWORD dwCount = 0;
        hr = srpKC->GetKeyPropertyCount(&dwCount);

        if (SUCCEEDED(hr))
        {
            hr = pClass->ExecMethod(bstrPath, bstrMethod, ((dwCount > 0) ? TRUE : FALSE), pInParams, pHandler, pCtx);
        }

        delete pClass;
    }

    return hr;
}

/*
Routine Description: 

Name:

    CRequestObject::DeleteObject 

Functionality:
    
    Delete the object.

Virtual:
    
    No.
    
Arguments:

    bstrPath    - Object's path.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of the
    deletion. However, we don't guarantee the integrity of the object to be deleted.

Notes:

*/

HRESULT 
CRequestObject::DeleteObject (
    IN BSTR               bstrPath, 
    IN IWbemObjectSink  * pHandler, 
    IN IWbemContext     * pCtx
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CGenericClass *pClass = NULL;

    //
    // need to know the path's contents. Our key chain object is what is needed
    //

    CComPtr<ISceKeyChain> srpKC;
    hr = CreateKeyChain(bstrPath, &srpKC);

    //
    // Create the appropriate C++ class
    //

    if (SUCCEEDED(hr))
    {
        hr = CreateClass(srpKC, &pClass, pCtx);
    }

    if(SUCCEEDED(hr))
    {
        //
        // ask the C++ object to do the deletion
        //

        hr = pClass->CreateObject(pHandler, ACTIONTYPE_DELETE);
        delete pClass;
    }

    //
    // we only have one WMI class sce_transactiontoken that doesn't
    // have a C++ class implementing it. Instead, it lives in our global variable.
    //

    if (FAILED(hr))
    {
        //
        // create sce_transactiontoken's (singleton) path
        //

        CComBSTR bstrTranxTokenPath(SCEWMI_TRANSACTION_TOKEN_CLASS);
        bstrTranxTokenPath += CComBSTR(L"=@");

        //
        // Is this the same as the object's path?
        //

        if (0 == _wcsicmp(bstrPath, bstrTranxTokenPath))
        {
            g_CS.Enter();

            //
            // invalidate our variable so that the instance is gone
            //

            g_bstrTranxID.Empty();

            //
            // this is a success
            //

            hr = WBEM_NO_ERROR;

            g_CS.Leave();
        }
    }
    return hr;
}

#ifdef _EXEC_QUERY_SUPPORT


/*
Routine Description: 

Name:

    CRequestObject::ExecQuery 

Functionality:
    
    Execute the query as instrcuted by the our provider. Objects created that 
    satisfy the query will be indicated to WMI through pHandler.

Virtual:
    
    No.
    
Arguments:

    bstrQuery   - the query to be executed.

    pHandler    - COM interface pointer for notifying WMI of any queried objects.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of
    executing the query

Notes:

*/

HRESULT CRequestObject::ExecQuery (
    IN BSTR               bstrQuery, 
    IN IWbemObjectSink  * pHandler, 
    IN IWbemContext     * pCtx
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    //
    // Eventually, this class will do the work
    //

    CGenericClass *pClass = NULL;

    //
    // we need a query parser
    //

    CComObject<CSceQueryParser> *pQueryParser;
    hr = CComObject<CSceQueryParser>::CreateInstance(&pQueryParser);

    if (SUCCEEDED(hr))
    {
        //
        // This is necessary to lock the pQueryParser
        //

        pQueryParser->AddRef();

        //
        // can this pQueryParser propvide a ISceQueryParser interface?
        //

        CComPtr<ISceQueryParser> srpQueryParser;
        hr = pQueryParser->QueryInterface(IID_ISceQueryParser, (void**)&srpQueryParser);

        //
        // neutralize the above AddRef
        //

        pQueryParser->Release();

        if (SUCCEEDED(hr))
        {
            //
            // Do the parsing
            //

            hr = srpQueryParser->ParseQuery(bstrQuery, pStorePath);

            //
            // if successful, it will have a key chain
            //

            CComPtr<ISceKeyChain> srpKC;
            if (SUCCEEDED(hr))
            {
                hr = srpQueryParser->QueryInterface(IID_ISceKeyChain, (void**)&srpKC);
            }

            //
            // Create the appropriate class using the key chain
            //

            if (SUCCEEDED(hr))
            {
                hr = CreateClass(srpKC, &pClass, pCtx);

                if (SUCCEEDED(hr))
                {
                    //
                    // Query the objects. pHandler will be used to indicate to WMI
                    // if objects are created that satisfy the query.
                    //

                    hr = pClass->CreateObject(pHandler, ACTIONTYPE_QUERY);

                    //
                    // we are fine with WBEM_E_NOT_FOUND
                    //

                    if (hr == WBEM_E_NOT_FOUND)
                    {
                        hr = WBEM_NO_ERROR;
                    }
                }
            }
        }
    }

    delete pClass;

    return hr;
}

/*
Routine Description: 

Name:

    CRequestObject::GetWbemObjectPath 

Functionality:
    
    Query the wbem object's path. To this date, we rely on WMI to provide the path.
    This dependency has one major problems:

        The object's path is not available if some key properties are missing.

    To resolve this problem, we can build a partial "path" ourselves that at least
    contains the class name and the SceStorePath. These two pieces of information
    will allow us to move on to more friendly interface.

    This latter functionality is not implemented yet.

Virtual:
    
    No.
    
Arguments:

    pInst       - the instance whose path is requested.

    pbstrPath   - output parameter that receives the path if successfully created.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of
    getting the object's path

Notes:

*/

HRESULT 
CRequestObject::GetWbemObjectPath (
    IN  IWbemClassObject    * pInst,
    OUT BSTR                * pbstrPath
    )
{
    if (pInst == NULL || pbstrPath == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pbstrPath = NULL;

    CComVariant varPath;
    HRESULT hr = pInst->Get(L"__RELPATH", 0, &varPath, NULL, NULL);

    /*
    if (FAILED(hr) || varPath.vt != VT_BSTR)
    {
        varPath.Clear();

        //
        // can't get the path, we will create a partial path: classname.scestorepath=value
        //

        CComVariant varClass;
        hr = pInst->Get(L"__CLASS", 0, &varClass, NULL, NULL);
        if (SUCCEEDED(hr) && varClass.vt == VT_BSTR)
        {
            CComVariant varStorePath;
            hr = pInst->Get(pStorePath, 0, &varStorePath, NULL, NULL);
            if (SUCCEEDED(hr) && varStorePath.vt == VT_BSTR)
            {
                varPath.vt = VT_BSTR;

                //
                //$undone:shawnwu need to escape the storepath
                //

                DWORD dwLength = wcslen(varClass.bstrVal) + 1 + wcslen(pStorePath) + 1 + wcslen(varStorePath.bstrVal) + 1;
                varPath.bstrVal = ::SysAllocStringLen(NULL, dwLength);
                if (varPath.bstrVal != NULL)
                {
                    //
                    // won't overrun buffer
                    //

                    ::swprintf(varPath.bstrVal, L"%s.%s=\"%s\"", varClass.bstrVal, pStorePath, varStorePath.bstrVal);
                }
                else
                    hr = WBEM_E_OUT_OF_MEMORY;
            }
            else
                hr = WBEM_E_INVALID_OBJECT_PATH;
        }
        else
            hr = WBEM_E_INVALID_OBJECT_PATH;
    }
    */

    if (SUCCEEDED(hr) && varPath.vt == VT_BSTR)
    {
        *pbstrPath = varPath.bstrVal;
        varPath.vt = VT_EMPTY;
    }
    else
    {
        //
        // this object doesn't have the properties for a path
        //

        hr = WBEM_E_INVALID_OBJECT;
    }

    return hr;
}

#endif //_EXEC_QUERY_SUPPORT


//
//Properties
//

const WCHAR * pPath = L"Path";
const WCHAR * pDescription = L"Description";
const WCHAR * pVersion = L"Sce_Version";
const WCHAR * pReadonly = L"Readonly";
const WCHAR * pDirty = L"Dirty";
const WCHAR * pStorePath = L"SceStorePath";
const WCHAR * pStoreType = L"SceStoreType";
const WCHAR * pMinAge = L"MinAge";
const WCHAR * pMaxAge = L"MaxAge";
const WCHAR * pMinLength = L"MinLength";
const WCHAR * pHistory = L"History";
const WCHAR * pComplexity = L"Complexity";
const WCHAR * pStoreClearText = L"StoreClearText";
const WCHAR * pForceLogoff = L"ForceLogoff";
const WCHAR * pEnableAdmin = L"EnableAdmin";
const WCHAR * pEnableGuest = L"EnableGuest";
const WCHAR * pLSAPol = L"LsaLookupPol";
const WCHAR * pThreshold = L"Threshold";
const WCHAR * pDuration = L"Duration";
const WCHAR * pResetTimer = L"ResetTimer";
const WCHAR * pEvent = L"Event";
const WCHAR * pAuditSuccess = L"AuditSuccess";
const WCHAR * pAuditFailure = L"AuditFailure";
const WCHAR * pType = L"Type";
const WCHAR * pData = L"Data";
const WCHAR * pDatabasePath = L"DatabasePath";
const WCHAR * pTemplatePath = L"TemplatePath";
const WCHAR * pLogFilePath = L"LogFilePath";
const WCHAR * pOverwrite = L"Overwrite";
const WCHAR * pAreaMask = L"AreaMask";
const WCHAR * pMaxTicketAge = L"MaxTicketAge";
const WCHAR * pMaxRenewAge = L"MaxRenewAge";
const WCHAR * pMaxServiceAge = L"MaxServiceAge";
const WCHAR * pMaxClockSkew = L"MaxClockSkew";
const WCHAR * pEnforceLogonRestrictions = L"EnforceLogonRestrictions";
const WCHAR * pCategory = L"Category";
const WCHAR * pSuccess = L"Success";
const WCHAR * pFailure = L"Failure";
const WCHAR * pSize = L"Size";
const WCHAR * pOverwritePolicy = L"OverwritePolicy";
const WCHAR * pRetentionPeriod = L"RetentionPeriod";
const WCHAR * pRestrictGuestAccess = L"RestrictGuestAccess";
const WCHAR * pAdministratorAccountName = L"AdministratorAccountName";
const WCHAR * pGuestAccountName = L"GuestAccountName";
const WCHAR * pMode = L"Mode";
const WCHAR * pSDDLString = L"SDDLString";
const WCHAR * pService = L"Service";
const WCHAR * pStartupMode = L"StartupMode";
const WCHAR * pUserRight = L"UserRight";
const WCHAR * pAddList = L"AddList";
const WCHAR * pRemoveList = L"RemoveList";
const WCHAR * pGroupName = L"GroupName";
const WCHAR * pPathName = L"PathName";
const WCHAR * pDisplayName = L"DisplayName";
const WCHAR * pDisplayDialog = L"DisplayDialog";
const WCHAR * pDisplayChoice = L"DisplayChoice";
const WCHAR * pDisplayChoiceResult = L"DisplayChoiceResult";
const WCHAR * pUnits = L"Units";
const WCHAR * pRightName = L"RightName";
const WCHAR * pPodID = L"PodID";
const WCHAR * pPodSection = L"PodSection";
const WCHAR * pKey = L"Key";
const WCHAR * pValue = L"Value";
const WCHAR * pLogArea = L"LogArea";
const WCHAR * pLogErrorCode = L"LogErrorCode";
const WCHAR * pLogErrorType = L"LogErrorType";
const WCHAR * pLogVerbose   = L"Verbose";
const WCHAR * pAction           = L"Action";
const WCHAR * pErrorCause       = L"ErrorCause";
const WCHAR * pObjectDetail     = L"ObjectDetail";
const WCHAR * pParameterDetail  = L"ParameterDetail";
const WCHAR * pLastAnalysis = L"LastAnalysis";
const WCHAR * pLastConfiguration = L"LastConfiguration";
const WCHAR * pAttachmentSections = L"Attachment Sections";
const WCHAR * pClassOrder       = L"ClassOrder";
const WCHAR * pTranxGuid        = L"TranxGuid";
const WCHAR * pwMethodImport = L"IMPORT";
const WCHAR * pwMethodExport = L"EXPORT";
const WCHAR * pwMethodApply = L"CONFIGURE";
const WCHAR * pwAuditSystemEvents = L"AuditSystemEvents";
const WCHAR * pwAuditLogonEvents = L"AuditLogonEvents";
const WCHAR * pwAuditObjectAccess = L"AuditObjectAccess";
const WCHAR * pwAuditPrivilegeUse = L"AuditPrivilegeUse";
const WCHAR * pwAuditPolicyChange = L"AuditPolicyChange";
const WCHAR * pwAuditAccountManage = L"AuditAccountManage";
const WCHAR * pwAuditProcessTracking = L"AuditProcessTracking";
const WCHAR * pwAuditDSAccess = L"AuditDSAccess";
const WCHAR * pwAuditAccountLogon = L"AuditAccountLogon";
const WCHAR * pwApplication = L"Application Log";
const WCHAR * pwSystem = L"System Log";
const WCHAR * pwSecurity = L"Security Log";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\sceparser.h ===
// sceparser.h: path and query parser provided by sce provider
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "sceprov.h"

/*

Class description

    Naming: 
        CScePathParser stands for SCE Path Parser.

    Base class: 
        CComObjectRootEx for threading model and IUnknown.
        CComCoClass for class factory support.
        IScePathParser and ISceKeyChain for custom interfaces.

    Purpose of class:
        (1) We wish to simplify path parsing. This is our effort of creation Sce path parser
            that can be externally CoCreateInstance'd.
        (2) To support a more friendly and uniform interface, both SCE path parser and SCE query 
            let client use the service via ISceKeyChain.

    Design:
        (1) See IScePathParser and ISceKeyChain. Almost everything is captured by these two interfaces.
        (2) This is not a directly instantiatable class. See Use section for creation steps.
        (3) Since paths only contains class name and key properties, we opt to use a less fancier data
            structure - vector to store the properties' (name,value) pair. The nature of key properties
            being normally limited in number should offer you comfort in using this data structure.
        (4) Class name and namespace are cached in separate string members.

    Use:
        (1) For external users:

            (a) CoCreateInstance of our class (CLSID_ScePathParser) and request for IID_IScePathParser.
            (b) Call ParsePath to parse the path string.
            (c) QI ISceKeyChain and use the key chain to access the results.

        (2) For internal users:

            (a) CComObject<CScePathParser>::CreateInstance(&pPathParser);
            (b) QI for IScePathParser.
            (c) ParsePath
            (d) QI ISceKeyChain and use the key chain to access the results.
            See CRequestObject's use for sample.

    Notes:
        (1) This class is not intended to be further derived. It is a final class. It's 
            destructor is thus not virtual!
        (2) Refer to MSDN and ATL COM programming for the use of ATL.
        (3) The caller can't cache the interface pointer (ISceKeyChain) and do another parsing (which
            is allowed) and expect the previous ISceKeyChain interface to work for the previous parsing.

*/

class ATL_NO_VTABLE CScePathParser 
    : public CComObjectRootEx<CComMultiThreadModel>,
      public CComCoClass<CScePathParser, &CLSID_ScePathParser>,
      public IScePathParser,
      public ISceKeyChain
{
public:

BEGIN_COM_MAP(CScePathParser)
    COM_INTERFACE_ENTRY(IScePathParser)
    COM_INTERFACE_ENTRY(ISceKeyChain)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE( CScePathParser )
DECLARE_REGISTRY_RESOURCEID(IDR_SceProv)

protected:
    CScePathParser();
    ~CScePathParser();

public:

    //
    // IScePathParser
    //

    STDMETHOD(ParsePath) ( 
                IN LPCWSTR strObjectPath
                );
    
    //
    // ISceKeyChain
    //

    STDMETHOD(GetKeyPropertyCount) ( 
                OUT DWORD *pCount
                );
    
    STDMETHOD(GetNamespace) ( 
                OUT BSTR *pbstrNamespace
                );

    STDMETHOD(GetClassName) ( 
                OUT BSTR *pbstrClassName
                );
    
    STDMETHOD(GetKeyPropertyValue) ( 
                IN LPCWSTR pszKeyPropName,
                OUT VARIANT *pvarValue
                );
    
    STDMETHOD(GetKeyPropertyValueByIndex) ( 
                IN DWORD dwIndex,
                OUT BSTR* pbstrKeyPropName, 
                OUT VARIANT *pvarValue
                );

private:
    void Cleanup();

    std::vector<CPropValuePair*> m_vecKeyValueList;

    LPWSTR m_pszClassName;
    LPWSTR m_pszNamespace;

};

/*

Class description

    Naming: 

        CSceQueryParser stands for SCE Query Parser.

    Base class: 

        (1) CComObjectRootEx for threading model and IUnknown.
        (2) CComCoClass for class factory support.
        (3) ISceQueryParser and ISceKeyChain for custom interfaces.

    Purpose of class:

        (1) We wish to simplify query parsing. This is our effort of creation Sce query parser
            that can be externally CoCreateInstance'd.
        (2) To support a more friendly and uniform interface, both SCE path parser and SCE query 
            let client use the service via ISceKeyChain.

    Design:

        (1) See ISceQueryParser and ISceKeyChain. Almost everything is captured by these two interfaces.
        (2) This is not a directly instantiatable class. See Use section for creation steps.
        (3) Parsing a query is a very complicated matter. WMI support of complicated queries are limited
            too. We are very pragmatic about it: we only cares about the class names (actually, WMI limits
            its queries to unary - one class name only) and one important property - let's call it the querying
            property (m_bstrQueryingPropName). For SCE use, that querying property is almost always 
            the store path.
        (4) Class names are cached in string list member m_vecClassList.
        (5) The query property values (in string) will be cached in a string list member - m_vecQueryingPropValueList.

    Use:

        (1) For external users:
            (a) CoCreateInstance of our class (CLSID_SceQueryParser) and request for IID_ISceQueryParser.
            (b) Call ParseQuery to parse the query.
            (c) QI ISceKeyChain and use the key chain to access the results.

        (2) For internal users:
            (a) CComObject<CScePathParser>::CreateInstance(&pPathParser);
            (b) QI for ISceQueryParser.
            (c) Call ParseQuery to parse the query.
            (d) QI ISceKeyChain and use the key chain to access the results.
            See CRequestObject's use for sample.

    Notes:

        (1) This class is not intended to be further derived. It is a final class. It's 
            destructor is thus not virtual!
        (2) Refer to MSDN and ATL COM programming for the use of ATL.

*/

class ATL_NO_VTABLE CSceQueryParser 
    : public CComObjectRootEx<CComMultiThreadModel>,
      public CComCoClass<CSceQueryParser, &CLSID_SceQueryParser>,
      public ISceQueryParser,
      public ISceKeyChain
{
public:

BEGIN_COM_MAP(CSceQueryParser)
    COM_INTERFACE_ENTRY(ISceQueryParser)
    COM_INTERFACE_ENTRY(ISceKeyChain)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE( CSceQueryParser )
DECLARE_REGISTRY_RESOURCEID(IDR_SceProv)

protected:
    CSceQueryParser();
    ~CSceQueryParser();

public:

    //
    // ISceQueryParser
    //

    STDMETHOD(ParseQuery) ( 
                 IN LPCWSTR strQuery,
                 IN LPCWSTR strQueryPropName
                 );
    
    STDMETHOD(GetClassCount) (
                 OUT DWORD* pdwCount
                 )
        {
            if (pdwCount == NULL)
            {
                return E_INVALIDARG;
            }

            *pdwCount = m_vecClassList.size();
            return S_OK;
        }

    STDMETHOD(GetClassName) (
                IN int     iIndex,
                OUT BSTR * pbstrClassName
                );
    
    STDMETHOD(GetQueryingPropertyValueCount) (
                 OUT DWORD* pdwCount
                 )
        {
            if (pdwCount == NULL)
            {
                return E_INVALIDARG;
            }

            *pdwCount = m_vecQueryingPropValueList.size();
            return S_OK;
        }

    STDMETHOD(GetQueryingPropertyValue) (
                IN int     iIndex,
                OUT BSTR * pbstrQPValue
                );

    //
    // ISceKeyChain
    //

    STDMETHOD(GetKeyPropertyCount) ( 
                OUT DWORD *pCount
                )
        {
            if (pCount == NULL)
            {
                return E_INVALIDARG;
            }
            *pCount = m_vecQueryingPropValueList.size() > 0 ? 1 : 0;
            return S_OK;
        }
    
    STDMETHOD(GetNamespace) ( 
                OUT BSTR *pbstrNamespace
                )
        {
            *pbstrNamespace = NULL;
            return WBEM_E_NOT_SUPPORTED;
        }

    STDMETHOD(GetClassName) ( 
                OUT BSTR *pbstrClassName
                )
        {
            //
            // since we only support single class query, this must be it
            //

            return GetClassName(0, pbstrClassName);
        }
    
    STDMETHOD(GetKeyPropertyValue) ( 
                IN LPCWSTR    pszKeyPropName,
                OUT VARIANT * pvarValue
                );
    
    STDMETHOD(GetKeyPropertyValueByIndex) ( 
                IN  DWORD     dwIndex,
                OUT BSTR    * pbstrKeyPropName,
                OUT VARIANT * pvarValue
                )
        {
            if (pbstrKeyPropName == NULL || pvarValue == NULL)
            {
                return E_INVALIDARG;
            }

            *pbstrKeyPropName = NULL;
            ::VariantInit(pvarValue);

            return WBEM_E_NOT_SUPPORTED;
        }


private:

    void Cleanup();

    HRESULT ExtractClassNames (
                              SWbemRpnEncodedQuery *pRpn
                              );

    HRESULT ExtractQueryingProperties (
                                      SWbemRpnEncodedQuery *pRpn, 
                                      LPCWSTR strQueryPropName
                                      );

    HRESULT GetQueryPropFromToken (
                                  SWbemRpnQueryToken *pRpnQueryToken, 
                                  LPCWSTR strQueryPropName
                                  );

    std::vector<LPWSTR> m_vecClassList;
    std::vector<LPWSTR> m_vecQueryingPropValueList;

    CComBSTR m_bstrQueryingPropName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\sceprov.cpp ===
//***************************************************************************
//
//  SceProv.CPP
//
//  Module: SCE WMI provider code
//
//  Purpose: Defines the CSceWmiProv class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c) 1000-2001 Microsoft Corporation
//
//***************************************************************************

#include "sceprov.h"
#include "requestobject.h"
#include <process.h>
#include <Userenv.h>
#include "genericclass.h"
#include "Tranx.h"
#include "operation.h"

//
// instantiate out unique static member
//

CHeap_Exception CSceWmiProv::m_he(CHeap_Exception::E_ALLOCATION_ERROR);

LPCWSTR pszDefLogFilePath   = L"\\Local Settings\\SceWMILog\\MethodLog.txt";

CComBSTR g_bstrDefLogFilePath;

//
// definition of our global variables
//

CCriticalSection g_CS;

CLogOptions g_LogOption;

CComBSTR g_bstrTranxID;

CCriticalSection CSceOperation::s_OperationCS;


/*
Routine Description: 

Name:

    CCriticalSection::CCriticalSection

Functionality:

    Constructor. Initializing the critical section

Virtual:
    
    No.

Arguments:

    None.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here
*/

CCriticalSection::CCriticalSection ()
{
    ::InitializeCriticalSection(&m_cs);
}

/*
Routine Description: 

Name:

    CCriticalSection::~CCriticalSection

Functionality:

    Destructor. Deleting the critical section.

Virtual:
    
    No.

Arguments:

    None.

Return Value:

    None as any destructor.

Notes:
    if you create any local members, think about initialize them here
*/

CCriticalSection::~CCriticalSection()
{
    ::DeleteCriticalSection(&m_cs);
}

/*
Routine Description: 

Name:

    CCriticalSection::Enter

Functionality:

    Equivalent of EnterCriticalSection

Virtual:
    
    No.

Arguments:

    None.

Return Value:

    None.

Notes:
*/

void CCriticalSection::Enter()
{
    ::EnterCriticalSection(&m_cs);
}

/*
Routine Description: 

Name:

    CCriticalSection::Leave

Functionality:

    Equivalent of LeaveCriticalSection

Virtual:
    
    No.

Arguments:

    None.

Return Value:

    None.

Notes:
*/

void CCriticalSection::Leave()
{
    ::LeaveCriticalSection(&m_cs);
}

//
// implementing CLogOptions 
//

/*
Routine Description: 

Name:

    CLogOptions::GetLogOptionsFromWbemObject

Functionality:

    Query the unique WMI object for SCE logging options and update the class members.

Virtual:
    
    No.

Arguments:

    None.

Return Value:

    None.

Notes:
    log options is determined by our WMI class called Sce_LogOptions.
    a unique instance is deposited in WMI depository for controlling log options.
    This function will query for this instance and thus update the log options
    in case it has been modified.
*/

void CLogOptions::GetLogOptionsFromWbemObject (
    IN IWbemServices* pNamespace
    )
{
    //
    // we can't update the log options without a namespace. In case of any failure
    // to reach the instance, we leave our default option (which is to log error only
    // non-verbose)
    //

    if (pNamespace != NULL)
    {
        CComPtr<IWbemClassObject> srpLogStatus;
        HRESULT hr = pNamespace->GetObject(SCEWMI_LOGOPTIONS_CLASS, 0, NULL, &srpLogStatus, NULL);

        if (SUCCEEDED(hr))
        {
            CComVariant varErrorType, varVerbose;

            //
            // m_dwOption is a bit pattern recording the error logging options
            // (inside SCE_LOG_Error_Mask) and verbose logging options (inside SCE_LOG_Verbose_Mask)
            //

            //
            // preserve the verbose portion of the option (SCE_LOG_Verbose_Mask), but
            // update the error portion of the option (SCE_LOG_Error_Mask)
            //

            if (SUCCEEDED(srpLogStatus->Get(pLogErrorType, 0, &varErrorType, NULL, NULL)))
            {
                m_dwOption = (m_dwOption & SCE_LOG_Verbose_Mask) | (SCE_LOG_Error_Mask & varErrorType.iVal);
            }

            //
            // Verbose is a boolean property. Set/unset the bit depending on the boolean value
            //

            if (SUCCEEDED(srpLogStatus->Get(pLogVerbose, 0, &varVerbose, NULL, NULL)))
            {
                if (varVerbose.vt == VT_BOOL && varVerbose.boolVal == VARIANT_TRUE)
                {
                    m_dwOption = Sce_log_Verbose | m_dwOption;
                }
                else
                {
                    m_dwOption &= ~Sce_log_Verbose;
                }
            }
        }
    }
}


//===========================================================================
// CForeignClassInfo implementations
//===========================================================================

/*
Routine Description: 

Name:

    CForeignClassInfo::~CForeignClassInfo

Functionality:

    Destructor. Cleanup.

Virtual:
    
    No.

Arguments:

    None.

Return Value:

    None as any destructor

Notes:
    if you create any more local members, think about initialize them in
    constructor and clean them up in CleanNames or here.
*/

CForeignClassInfo::~CForeignClassInfo()
{
    ::SysFreeString(bstrNamespace);
    ::SysFreeString(bstrClassName);
    CleanNames();
}

/*
Routine Description: 

Name:

    CForeignClassInfo::CleanNames

Functionality:

    Cleanup the names vector.

Virtual:
    
    No.

Arguments:

    None.

Return Value:

    None as any destructor

Notes:
    if you create any more local members, think about initialize them in
    constructor and clean them up in CleanNames or here.
*/

void CForeignClassInfo::CleanNames ()
{
    if (m_pVecKeyPropNames)
    {
        for (int i = 0; i < m_pVecKeyPropNames->size(); i++)
        {
            ::SysFreeString((*m_pVecKeyPropNames)[i]);
        }

        delete m_pVecKeyPropNames;

        //
        // since this is not a destructor, better reset the variable.
        //

        m_pVecKeyPropNames = NULL;
    }
}

//===========================================================================
// Implementing CSceWmiProv
//===========================================================================

/*
Routine Description: 

Name:

    CSceWmiProv::Initialize

Functionality:

    Implementating IWbemProviderInit. Initialize the provider as instrcuted by WMI infrastructure.

Virtual:
    
    Yes.

Arguments:

    pszUser         - User.

    lFlags          - not used.

    pszNamespace    - Namespace string.

    pszLocale       - Locale string.

    pNamespace      - COM interface pointer to our namespace.

    pCtx            - COM interface pointer that was passed around for WMI APIs.

    pInitSink       - COM interface pointer to notify WMI of results.

Return Value:

    Success: WBEM_NO_ERROR.
    Failure: Various error code. It is either caused by Impersonation failure or
             failure to create default log file directory.

Notes:
    You should never call this directly. It's intended for WMI calls.

*/

STDMETHODIMP 
CSceWmiProv::Initialize (
    IN LPWSTR                   pszUser, 
    IN LONG                     lFlags,
    IN LPWSTR                   pszNamespace, 
    IN LPWSTR                   pszLocale,
    IN IWbemServices          * pNamespace,
    IN IWbemContext           * pCtx,
    IN IWbemProviderInitSink  * pInitSink
    )
{
    HRESULT hres = WBEM_NO_ERROR;

    //
    // make sure that we have a fall back default log file
    //

    hres = CheckImpersonationLevel();
    if (SUCCEEDED(hres))
    {
        //
        // going to modify global data, need thread safety
        //

        g_CS.Enter();

        if (pNamespace)
        {
            m_srpNamespace = pNamespace;
        }

        g_bstrDefLogFilePath.Empty();

        hres = ::CreateDefLogFile(&g_bstrDefLogFilePath);

        g_CS.Leave();
    }

    //
    // Let CIMOM know you are initialized
    //

    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);

    return hres;
}

/*
Routine Description: 

Name:

    CSceWmiProv::CreateInstanceEnumAsync

Functionality:

    Asynchronously enumerates the instances.

Virtual:
    
    Yes.

Arguments:

    strClass        - class name that is to be enumerated.

    lFlags          - not used.

    pCtx            - COM interface pointer that was passed around for WMI APIs.

    pSink           - COM interface pointer to notify WMI of results.

Return Value:

    Success: Various success code. No guarantee to return WBEM_NO_ERROR.
    Failure: Various error code. It is either caused by Impersonation failure or
             failure to enumerate the instances.

Notes:
    You should never call this directly. It's intended for WMI calls.

*/

STDMETHODIMP 
CSceWmiProv::CreateInstanceEnumAsync (
    const BSTR        strClass, 
    long              lFlags,
    IWbemContext    * pCtx, 
    IWbemObjectSink * pSink
    )
{
    if(strClass == NULL || pSink == NULL || m_srpNamespace == NULL)
    {
        //
        // inform WMI that action is complete with errors (WBEM_E_INVALID_PARAMETER)
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_INVALID_PARAMETER, NULL, NULL);
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_NO_ERROR;

    // our classes are following COM rule so that they won't throw. The following try-catch
    // is to guard against critical errors inside our code so that it won't crash the host process
    try
    {
        //
        // always impersonated
        //
        
        hr = CheckImpersonationLevel();
        if ( SUCCEEDED(hr) ) 
        {
            //
            // We take care of Sce_TransactionToken directly because that is managed by our global variable
            //

            if (_wcsicmp(strClass, SCEWMI_TRANSACTION_TOKEN_CLASS) == 0)
            {
                //
                // protecting global from multi threads access
                //

                g_CS.Enter();

                LPCWSTR pszTranxID = (LPCWSTR)g_bstrTranxID;
                if (NULL == pszTranxID || L'\0' == *pszTranxID)
                {
                    hr = WBEM_E_NOT_FOUND;
                }
                else
                {
                    hr = CTranxID::SpawnTokenInstance(m_srpNamespace, pszTranxID, pCtx, pSink);
                }

                g_CS.Leave();
            }
            else
            {
                //
                // everything else goes through CRequestObject
                //

                CRequestObject ReqObj(m_srpNamespace);

                hr = ReqObj.CreateObject(strClass, pSink, pCtx, ACTIONTYPE_ENUM);
            }
        }

        //
        // inform WMI that action is complete with hr as result
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
    }
    catch(...)
    {
        hr = WBEM_E_CRITICAL_ERROR;

        //
        // inform WMI that action is complete with error (WBEM_E_CRITICAL_ERROR)
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
    }

    return hr;
}

/*
Routine Description: 

Name:

    CSceWmiProv::CreateInstanceEnumAsync

Functionality:

    WMI is asking for a unique single instance (not querying). This function uses
    CRequestObject to fulfill the request.

Virtual:
    
    Yes.

Arguments:

    strObjectPath   - object's path.

    lFlags          - not used.

    pCtx            - COM interface pointer that was passed around for WMI APIs.

    pSink           - COM interface pointer to notify WMI of results (in this case
                      it is used to notify WMI of the created object.

Return Value:

    Success: Various success code. No guarantee to return WBEM_NO_ERROR.
    Failure: Various error code. It is either caused by Impersonation failure or
             failure to get the instances.

Notes:
    You should never call this directly. It's intended for WMI calls.

*/

STDMETHODIMP
CSceWmiProv::GetObjectAsync (
    IN const BSTR         strObjectPath, 
    IN long               lFlags,
    IN IWbemContext     * pCtx, 
    IN IWbemObjectSink  * pSink
    )
{

    //
    //check parameters
    //
    
    if(strObjectPath == NULL || pSink == NULL || m_srpNamespace == NULL)
    {
        //
        // inform WMI that action is complete with WBEM_E_INVALID_PARAMETER as error result
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_INVALID_PARAMETER, NULL, NULL);
        return WBEM_E_INVALID_PARAMETER;
    }


    HRESULT hr = WBEM_NO_ERROR;

    //
    // our classes are following COM rule so that they won't throw. The following try-catch
    // is to guard against critical errors inside our code so that it won't crash the host process
    //

    try
    {
        //
        // make sure impersonated
        //
        
        hr = CheckImpersonationLevel();

        if ( SUCCEEDED(hr) ) 
        {
            CRequestObject ReqObj(m_srpNamespace);

            //
            // Get the requested object. It's a single instance get!
            //

            hr = ReqObj.CreateObject(strObjectPath, pSink, pCtx, ACTIONTYPE_GET);

            //
            // if CRequestObject doesn't know how to create the object, it might be Sce_TransactionToken
            //

            if (FAILED(hr) && wcsstr(strObjectPath, SCEWMI_TRANSACTION_TOKEN_CLASS) != NULL)
            {
                //
                // protecting global memory
                //

                g_CS.Enter();

                //
                // whether this Sce_TransactionToken instance exists all depends on the global variable
                //

                LPCWSTR pszTranxID = (LPCWSTR)g_bstrTranxID;
                if (NULL == pszTranxID || L'\0' == *pszTranxID)
                {
                    hr = WBEM_E_NOT_FOUND;
                }
                else
                {
                    hr = CTranxID::SpawnTokenInstance(m_srpNamespace, pszTranxID, pCtx, pSink);
                }

                g_CS.Leave();
            }
        }

        //
        // inform WMI that action is complete with hr as result
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
    }
    catch(...)
    {
        hr = WBEM_E_CRITICAL_ERROR;

        //
        // inform WMI that action is complete with error (WBEM_E_CRITICAL_ERROR)
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
    }

    return hr;
}

/*
Routine Description: 

Name:

    CSceWmiProv::PutInstanceAsync

Functionality:

    WMI requests that something has created and put this instance. For all of our
    WMI classes, except one, this means to persist the instance information into a store.

Virtual:
    
    Yes.

Arguments:

    pInst       - COM interface pointer that identifies the WMI object.

    lFlags      - not used.

    pCtx        - COM interface pointer that was passed around for WMI APIs.

    pSink       - COM interface pointer to notify WMI of results (in this case
                  it is used to notify WMI of the created object.

Return Value:

    Success: Various success code. No guarantee to return WBEM_NO_ERROR.
    Failure: Various error code. It is either caused by Impersonation failure or
             failure to put the instances into our namespace.

Notes:
    You should never call this directly. It's intended for WMI calls.

*/

STDMETHODIMP CSceWmiProv::PutInstanceAsync (
    IN IWbemClassObject FAR * pInst, 
    IN long                   lFlags, 
    IN IWbemContext         * pCtx,
    IN IWbemObjectSink FAR  * pSink
    )
{
    if(pInst == NULL || pSink == NULL)
    {
        //
        // inform WMI that action is complete with error (WBEM_E_INVALID_PARAMETER)
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_INVALID_PARAMETER, NULL, NULL);
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_NO_ERROR;

    //
    // our classes are following COM rule so that they won't throw. The following try-catch
    // is to guard against critical errors inside our code so that it won't crash the host process.
    //

    try
    {
        //
        // make sure impersonated
        //
        
        if (SUCCEEDED(hr = CheckImpersonationLevel()))
        {
            CRequestObject ReqObj(m_srpNamespace);

            //
            // Put the object
            //

            hr = ReqObj.PutObject(pInst, pSink, pCtx);
        }

        //
        // inform WMI that action is complete with hr as result
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE, hr , NULL, NULL);
    }
    catch(...)
    {
        hr = WBEM_E_CRITICAL_ERROR;

        //
        // inform WMI that action is complete with error (WBEM_E_CRITICAL_ERROR)
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
    }
    return hr;
}

/*
Routine Description: 

Name:

    CSceWmiProv::ExecMethodAsync

Functionality:

    Executes a method on an SCE class or instance

Virtual:
    
    Yes.

Arguments:

    ObjectPath  - the path of the WMI object.

    Method      - the method.

    lFlags      - not used.

    pCtx        - COM interface pointer that was passed around for WMI APIs.

    pInParams   - COM interface pointer the input parameter object.

    pSink       - COM interface pointer to notify WMI of results (in this case
                  it is used to notify WMI of the created object.

Return Value:

    Success: Various success code. No guarantee to return WBEM_NO_ERROR.
    Failure: Various error code. It is either caused by Impersonation failure or
             failure to execute the method.

Notes:
    You should never call this directly. It's intended for WMI calls.

*/
    
STDMETHODIMP CSceWmiProv::ExecMethodAsync (
    IN const BSTR         ObjectPath, 
    IN const BSTR         Method, 
    IN long               lFlags,
    IN IWbemContext     * pCtx, 
    IN IWbemClassObject * pInParams,
    IN IWbemObjectSink  * pSink
    )
{
    HRESULT hr = WBEM_NO_ERROR;

    //
    // Do a check of arguments and make sure we have pointer to Namespace
    //

    if (pSink == NULL)
    {
        //
        // we can't even notify because the sink is null. Not likely to happen unless WMI has some serious problems.
        //

        return WBEM_E_INVALID_PARAMETER;
    }
    else if (ObjectPath == NULL || Method == NULL)
    {
        //
        // inform WMI that action is complete with error (WBEM_E_INVALID_PARAMETER
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_INVALID_PARAMETER, NULL, NULL);
        return WBEM_E_INVALID_PARAMETER;
    } 

    //
    // is to guard against critical errors inside our code so that it won't crash the host process
    //

    try
    {
        //
        // make sure impersonated
        //

        if (SUCCEEDED(hr = CheckImpersonationLevel()))
        {
            CRequestObject ReqObj(m_srpNamespace);

            //
            //Execute the method
            //

            hr = ReqObj.ExecMethod(ObjectPath, Method, pInParams, pSink, pCtx);
        }

        //
        // inform WMI that action is complete with hr as result
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE, hr , NULL, NULL);
    }
    catch(...)
    {
        hr = WBEM_E_CRITICAL_ERROR;

        //
        // inform WMI that action is complete with error (WBEM_E_CRITICAL_ERROR)
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
    }

    return hr;
}

/*
Routine Description: 

Name:

    CSceWmiProv::DeleteInstanceAsync

Functionality:

    Delete the instance identified by the given path.

Virtual:
    
    Yes.

Arguments:

    ObjectPath  - the path of the WMI object.

    lFlags      - not used.

    pCtx        - COM interface pointer that was passed around for WMI APIs.

    pInParams   - COM interface pointer the input parameter object.

    pSink       - COM interface pointer to notify WMI of results (in this case
                  it is used to notify WMI of the created object.

Return Value:

    Success: Various success code. No guarantee to return WBEM_NO_ERROR.
    Failure: Various error code. It is either caused by Impersonation failure or
             failure to delete the instance.

Notes:
    You should never call this directly. It's intended for WMI calls.

*/
    
STDMETHODIMP CSceWmiProv::DeleteInstanceAsync (
    IN const BSTR         ObjectPath, 
    IN long               lFlags, 
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    if (pSink == NULL)
    {
        //
        // we can't even notify because the sink is null. Not likely to happen unless WMI has some serious problems.
        //

        return WBEM_E_INVALID_PARAMETER;
    }
    else if (ObjectPath == NULL) 
    {
        //
        // inform WMI that action is complete with error (WBEM_E_INVALID_PARAMETER)
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_INVALID_PARAMETER, NULL, NULL);
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr = WBEM_NO_ERROR;

    //
    // our classes are following COM rule so that they won't throw. The following try-catch
    // is to guard against critical errors inside our code so that it won't crash the host process
    //

    try
    {
        //
        // make sure impersonated
        //

        if (SUCCEEDED(hr = CheckImpersonationLevel()))
        {
            CRequestObject ReqObj(m_srpNamespace);

            hr = ReqObj.DeleteObject(ObjectPath, pSink, pCtx);
        }

    #ifdef _PRIVATE_DEBUG
        if(!HeapValidate(GetProcessHeap(),NULL , NULL)) DebugBreak();
    #endif

        //
        // inform WMI that action is complete with hr as result
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE ,hr , NULL, NULL);
    }
    catch(...)
    {
        hr = WBEM_E_CRITICAL_ERROR;

        //
        // inform WMI that action is complete with error (WBEM_E_CRITICAL_ERROR)
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
    }

    return hr;
}


/*
Routine Description: 

Name:

    CSceWmiProv::ExecQueryAsync

Functionality:

    Execute the given query and return the results (objects) to WMI.

Virtual:
    
    Yes.

Arguments:

    QueryLanguage   - the language. Currently, it's alway L"WQL".

    Query           - the query itself

    lFlags          - not used.

    pCtx            - COM interface pointer that was passed around for WMI APIs.

    pSink           - COM interface pointer to notify WMI of results (in this case
                      it is used to notify WMI of the created object.

Return Value:

    Success: Various success code. No guarantee to return WBEM_NO_ERROR.
    Failure: Various error code. It is either caused by Impersonation failure or
             failure to execute the query

Notes:
    You should never call this directly. It's intended for WMI calls.

*/

STDMETHODIMP CSceWmiProv::ExecQueryAsync (
    IN const BSTR         QueryLanguage, 
    IN const BSTR         Query, 
    IN long               lFlags,
    IN IWbemContext     * pCtx, 
    IN IWbemObjectSink  * pSink
    )
{
    HRESULT hr = WBEM_NO_ERROR;

    //
    // our classes are following COM rule so that they won't throw. The following try-catch
    // is to guard against critical errors inside our code so that it won't crash the host process.
    //

    try
    {
        //
        // make sure impersonated
        //

        hr = CheckImpersonationLevel();

        if (SUCCEEDED(hr))
        {
            CRequestObject ReqObj(m_srpNamespace);
            hr = ReqObj.ExecQuery(Query, pSink, pCtx);

            //
            // inform WMI that action is complete with hr as result
            //

            pSink->SetStatus(0 ,hr , NULL, NULL);
        }
    }
    catch(...)
    {
        hr = WBEM_E_CRITICAL_ERROR;

        //
        // inform WMI that action is complete with error (WBEM_E_CRITICAL_ERROR)
        //

        pSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
    }
    return hr;
}

/*
Routine Description: 

Name:

    CreateDefLogFile

Functionality:

    Global helper. Will create the default log file's directory. Also it will pass back
    the default log file's full path.

Virtual:
    
    N/A.

Arguments:

    pbstrDefLogFilePath   - the default log file's path

Return Value:

    Success: Various success code. No guarantee to return WBEM_NO_ERROR.
    Failure: Various error code. Any failure indicates failure to create the default log
             file directory, plus the out parameter will be NULL.

Notes:
    (1) Default log file is located at sub-dir of the personal profile directory. Your call to this
        function may fail if you haven't impersonated the caller.

*/

HRESULT CreateDefLogFile (
    OUT BSTR* pbstrDefLogFilePath
    )
{
    //
    // make sure that parameter is good for output
    //

    if (pbstrDefLogFilePath == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pbstrDefLogFilePath = NULL;

    HRESULT hr = WBEM_NO_ERROR;

    HANDLE hToken = NULL;

    //
    // need the thread token to locate the profile directory
    //

    if (::OpenThreadToken(::GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken))
    {
        //
        // try to get the size of buffer needed for the path
        //

        DWORD dwSize = 0;

        //
        // return result doesn't matter, but it shouldn't fail
        //
        ::GetUserProfileDirectory(hToken, NULL, &dwSize);
        
        //
        // got the buffer size
        //

        if (dwSize > 0)
        {
            //
            // need a buffer with enough room
            //

            DWORD dwDefSize = wcslen(pszDefLogFilePath);

            *pbstrDefLogFilePath = ::SysAllocStringLen(NULL, dwSize + dwDefSize + 1);

            //
            // for readability
            //

            LPWSTR pszLogFile = (LPWSTR)(*pbstrDefLogFilePath);

            if ((LPCWSTR)pszLogFile == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
            else if (::GetUserProfileDirectory(hToken, pszLogFile, &dwSize))
            {
                //
                // append the pszDefLogFilePath, plus the 0 terminator
                //

                ::memcpy(pszLogFile + wcslen(pszLogFile), pszDefLogFilePath, (dwDefSize + 1) * sizeof(WCHAR));

                long lLen = wcslen(pszLogFile) - 1;

                //
                // we only need the sub-directory name. Lookback to the last backslash or slash
                //

                while (lLen > 0 && pszLogFile[lLen] != L'\\' && pszLogFile[lLen] != L'/')
                {
                    --lLen;
                }

                if (lLen > 0)
                {
                    //
                    // get rid of the trailing backslash if still have it (because it may have 2 backslashes)
                    //

                    if (pszLogFile[lLen-1] == L'\\' || pszLogFile[lLen-1] == L'/')
                    {
                        --lLen;
                    }

                    if (lLen > 0)
                    {
                        //
                        // create a shorter bstr with the front of the pszLogFile
                        //

                        CComBSTR bstrLogPathDir = ::SysAllocStringLen(pszLogFile, lLen);

                        if ((LPCWSTR)bstrLogPathDir != NULL)
                        {
                            //
                            // now, create the directory. This will create all non-existent parent sub-directory as well!
                            //

                            if (SUCCEEDED(hr) && !::CreateDirectory(bstrLogPathDir, NULL))
                            {
                                //
                                // GetLastError() eeds to be translated to HRESULT.
                                // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
                                //

                                DWORD dwError = GetLastError();

                                if (dwError == ERROR_ALREADY_EXISTS)
                                {
                                    hr = WBEM_NO_ERROR;
                                }
                                else
                                {
                                    hr = ProvDosErrorToWbemError(dwError);
                                }
                            }
                        }
                        else
                        {
                            hr = WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                }
            }
        }

        ::CloseHandle(hToken);
    }
    else
    {
        //
        // open thread token fails
        //

        //
        // GetLastError() eeds to be translated to HRESULT.
        // In case this is not an error, hr will be assigned to WBEM_NO_ERROR
        //

        hr = ProvDosErrorToWbemError(GetLastError());
    }

    //
    // if can't create the default log file, reset the default log file path
    //

    if (FAILED(hr) && *pbstrDefLogFilePath != NULL)
    {
        //
        // we have no default log file
        //

        ::SysFreeString(*pbstrDefLogFilePath);
        *pbstrDefLogFilePath = NULL;
    }

    return hr;
}

/*
Routine Description: 

Name:

    CheckImpersonationLevel

Functionality:

    Impersonate the calling thread.

Virtual:
    
    N/A.

Arguments:

    none

Return Value:

    Success: Various success code. No guarantee to return WBEM_NO_ERROR.
    Failure: Various error code, but most noticeable is WBEM_E_ACCESS_DENIED.

Notes:

*/

HRESULT CheckImpersonationLevel()
{
    //
    // we will assume access being denied
    //

    HRESULT hr = WBEM_E_ACCESS_DENIED;

    if (SUCCEEDED(CoImpersonateClient()))
    {

        //
        // Now, let's check the impersonation level.  First, get the thread token
        //

        HANDLE hThreadTok;
        DWORD dwImp, dwBytesReturned;

        if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadTok ))
        {
            hr = WBEM_NO_ERROR;
        }
        else
        {

            if (GetTokenInformation(hThreadTok, 
                                    TokenImpersonationLevel, 
                                    &dwImp, 
                                    sizeof(DWORD), 
                                    &dwBytesReturned) )
            {

                //
                // Is the impersonation level Impersonate?
                //

                if (dwImp >= SecurityImpersonation) 
                {
                    hr = WBEM_S_NO_ERROR;
                }
                else 
                {
                    hr = WBEM_E_ACCESS_DENIED;
                }

            }
            else 
            {
                hr = WBEM_E_FAILED;
            }

            CloseHandle(hThreadTok);
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CheckAndExpandPath

Functionality:

    (1) Check if the in-bound parameter has a env variable or not.
        If yes, we will expand the variable and pass back the result via
        out parameter. 
    (2) As a by product, it also returns the store type
        of the given path. Checking the store path is obviously what 
        this function is designed for.
    (3) The output parameter will have double backslah for each single
        backslash of the input parameter.

Virtual:
    
    N/A.

Arguments:

    pszIn   - the path to check and/or expand.

    bstrOut - the expanded path.

    pbSdb   - if interested, we will determined it the path is a database
              file. We only recognize .sdb as database file.

Return Value:

    Success: Various success code. No guarantee to return WBEM_NO_ERROR. If
             an out parameter is given, that parameter will be filled with
             appropriate information. Caller is responsible for releasing 
             the bstr.

    Failure: Various error code. Any error indicates our failure to check or expand.

Notes:

*/

HRESULT CheckAndExpandPath (
    IN LPCWSTR    pszIn,
    OUT BSTR    * bstrOut   OPTIONAL,
    OUT BOOL    * pbSdb     OPTIONAL
    )
{
    if ( pszIn == NULL) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }


    DWORD Len = wcslen(pszIn);

    if ( Len <= 6 ) 
    { 
        //
        // x : .sdb or % % .sdb
        //

        return WBEM_E_INVALID_PARAMETER;
    }

    if (pbSdb)
    {
        if ( _wcsicmp(pszIn + Len - 4, L".sdb") == 0 ) 
        {
            //
            // database
            //

            *pbSdb = TRUE;
        } 
        else 
        {
            *pbSdb = FALSE;
        }
    }

    HRESULT hr = WBEM_NO_ERROR;

    if ( bstrOut ) 
    {
        //
        // expand environment variable
        //

        if ( wcsstr(pszIn, L"%") ) 
        {

            PWSTR pBuf=NULL;
            PWSTR pBuf2=NULL;

            DWORD dwSize = ExpandEnvironmentStrings(pszIn,NULL, 0);

            if ( dwSize > 0 ) 
            {
                //
                // allocate buffer big enough to have two \\s
                //

                pBuf = (PWSTR)LocalAlloc(LPTR, (dwSize+1)*sizeof(WCHAR));

                if ( pBuf ) 
                {
                    pBuf2 = (PWSTR)LocalAlloc(LPTR, (dwSize+256)*sizeof(WCHAR));

                    if ( pBuf2 ) 
                    {

                        DWORD dwNewSize = ExpandEnvironmentStrings(pszIn,pBuf, dwSize);

                        if ( dwNewSize > 0) 
                        {
                            //
                            // convert the string from one \ to \\ (for use with WMI)
                            //

                            PWSTR pTemp1=pBuf, pTemp2=pBuf2;

                            while ( *pTemp1 != L'\0') 
                            {
                                if ( *pTemp1 != L'\\') 
                                {
                                    *pTemp2++ = *pTemp1;
                                } 
                                else if ( *(pTemp1+1) != L'\\') 
                                {
                                    //
                                    // single back slash, add another one
                                    //

                                    *pTemp2++ = *pTemp1;
                                    *pTemp2++ = L'\\';
                                } 
                                else 
                                {
                                    //
                                    // double back slashs, just copy
                                    //

                                    *pTemp2++ = *pTemp1++;
                                    *pTemp2++ = *pTemp1;
                                }

                                pTemp1++;
                            }
                            *bstrOut = SysAllocString(pBuf2);

                            if ( *bstrOut == NULL ) {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }
                        }

                        LocalFree(pBuf2);
                        pBuf2 = NULL;

                    } 
                    else 
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }

                    LocalFree(pBuf);
                    pBuf = NULL;

                } 
                else 
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

            } 
            else 
            {
                hr = WBEM_E_FAILED;
            }

        } 
        else 
        {
            *bstrOut = SysAllocString(pszIn);

            if ( *bstrOut == NULL ) 
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    MakeSingleBackSlashPath

Functionality:

    (1) Replace the double backslash with the given WCHAR (wc).

Virtual:
    
    N/A.

Arguments:

    pszIn   - the path to be processed.

    wc      - the WCHAR that will be replacing the backslash.

    bstrOut - the replaced path.

Return Value:

    Success: Various success code. No guarantee to return WBEM_NO_ERROR.
             Caller is responsible for releasing the bstr.

    Failure: Various error code. Any error indicates our failure to do the replacement.

Notes:

*/

HRESULT MakeSingleBackSlashPath (
    IN LPCWSTR  pszIn, 
    IN WCHAR    wc, 
    OUT BSTR  * bstrOut
    )
{
    if ( pszIn == NULL || bstrOut == NULL ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // convert the string from two \ to one (for save in SCE store)
    //

    //
    // two chars for the quotes
    //

    PWSTR pBuf2 = (PWSTR)LocalAlloc(LPTR, (wcslen(pszIn)+3)*sizeof(WCHAR));
    if ( pBuf2 == NULL ) 
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    HRESULT hr = WBEM_S_NO_ERROR;

    PWSTR pTemp1=(PWSTR)pszIn, pTemp2=pBuf2;

    while ( *pTemp1 != L'\0') 
    {
        if ( *pTemp1 != L'\\' || *(pTemp1 + 1) != L'\\' ) 
        {
            //
            // not back slash or single back slash
            //

            *pTemp2++ = *pTemp1;
        } 
        else 
        {
            //
            // double back slashs, remove one
            //

            *pTemp2++ = wc;
            pTemp1++;
        }
        pTemp1++;
    }

    *bstrOut = SysAllocString(pBuf2);

    if ( *bstrOut == NULL ) 
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    LocalFree(pBuf2);
    pBuf2 = NULL;

    return hr;

}

/*
Routine Description: 

Name:

    ConvertToDoubleBackSlashPath

Functionality:

    The inverse function of MakeSingleBackSlashPath, except that the character
    this function looks for is the given parameter wc.

Virtual:
    
    N/A.

Arguments:

    pszIn   - the path to be processed.

    wc      - the WCHAR that will be replaced during the operation.

    bstrOut - the replaced path.

Return Value:

    Success: Various success code. No guarantee to return WBEM_NO_ERROR.
             Caller is responsible for releasing the bstr.

    Failure: Various error code. Any error indicates our failure to do the replacement.

Notes:

*/

HRESULT ConvertToDoubleBackSlashPath (
    IN LPCWSTR  strIn,
    IN WCHAR    wc,
    OUT BSTR  * bstrOut
    )
{

    if ( strIn == NULL || bstrOut == NULL ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hr=WBEM_S_NO_ERROR;
    LPWSTR pBuf=NULL;

    //
    // allocate buffer big enough to have two \\s
    //

    pBuf = (PWSTR)LocalAlloc(LPTR, (wcslen(strIn)+256)*sizeof(WCHAR));

    if ( pBuf == NULL ) return WBEM_E_OUT_OF_MEMORY;

    //
    // convert the string from wc to \\ (for use with WMI)
    //

    LPCWSTR pTemp1=strIn;
    LPWSTR pTemp2=pBuf;

    while ( *pTemp1 != L'\0') 
    {
        if ( *pTemp1 != wc) 
        {
            *pTemp2++ = *pTemp1;
        } 
        else if ( *(pTemp1+1) != wc) 
        {
            //
            // single wc, put two back slashes
            //

            *pTemp2++ = L'\\';
            *pTemp2++ = L'\\';
        } 
        else 
        {
            //
            // double back slashs (or double wc), just copy
            //

            *pTemp2++ = *pTemp1++;
            *pTemp2++ = *pTemp1;
        }

        //
        // move to next wchar
        //

        pTemp1++;
    }

    *bstrOut = SysAllocString(pBuf);

    if ( *bstrOut == NULL ) 
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    LocalFree(pBuf);

    return hr;
}

/*
Routine Description: 

Name:

    GetWbemPathParser

Functionality:

    wrapper for the CoCreateInstance of the wbem Path parser

Virtual:
    
    N/A.

Arguments:

    ppPathParser   - the output parameter receiving the wbem path parser.

Return Value:

    Success: Various success code. No guarantee to return WBEM_NO_ERROR.
             Caller is responsible for releasing the bstr.

    Failure: Various error code. Any error indicates failure to create the wbem path parser.

Notes:
    (1) Of course, as always, caller is responsible for releasing the out parameter.

*/

HRESULT GetWbemPathParser (
    OUT IWbemPath** ppPathParser
    )
{
    return ::CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER, IID_IWbemPath, (LPVOID *) ppPathParser);
}

/*
Routine Description: 

Name:

    GetWbemQuery

Functionality:

    wrapper for the CoCreateInstance of the wbem query parser

Virtual:
    
    N/A.

Arguments:

    ppQuery   - the output parameter receiving the wbem query parser.

Return Value:

    Success: Various success code. No guarantee to return WBEM_NO_ERROR.
             Caller is responsible for releasing the bstr.

    Failure: Various error code. Any error indicates failure to create the wbem path parser.

Notes:
    (1) Of course, as always, caller is responsible for releasing the out parameter.

*/

HRESULT GetWbemQuery (
    OUT IWbemQuery** ppQuery
    )
{
    return ::CoCreateInstance(CLSID_WbemQuery, 0, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (LPVOID *) ppQuery);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\rights.cpp ===
// Rights.cpp: implementation of the CUserPrivilegeRights class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "rights.h"
#include "persistmgr.h"
#include <io.h>
#include "requestobject.h"

/*
Routine Description: 

Name:

    CUserPrivilegeRights::CUserPrivilegeRights

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CUserPrivilegeRights::CUserPrivilegeRights (
    IN ISceKeyChain  * pKeyChain, 
    IN IWbemServices * pNamespace,
    IN IWbemContext  * pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{
}

/*
Routine Description: 

Name:

    CUserPrivilegeRights::~CUserPrivilegeRights

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/

CUserPrivilegeRights::~CUserPrivilegeRights ()
{

}

/*
Routine Description: 

Name:

    CUserPrivilegeRights::CreateObject

Functionality:
    
    Create WMI objects (Sce_UserPrivilegeRight). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT 
CUserPrivilegeRights::CreateObject (
    IN IWbemObjectSink * pHandler, 
    IN ACTIONTYPE        atAction
    )
{
    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Delete a single instance ACTIONTYPE_DELETE
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET != atAction &&
         ACTIONTYPE_DELETE != atAction &&
         ACTIONTYPE_QUERY != atAction ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    int idxStorePath=-1, idxRight=-1;

    //
    // We must have the pStorePath property because that is where
    // our instance is stored. 
    // m_srpKeyChain->GetKeyPropertyValue WBEM_S_FALSE if the key is not recognized
    // So, we need to test against WBEM_S_FALSE if the property is mandatory
    //

    CComVariant varStorePath;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(pStorePath, &varStorePath);
    CComVariant varUserRight;

    if (SUCCEEDED(hr) && WBEM_S_FALSE != hr)
    {
        hr = m_srpKeyChain->GetKeyPropertyValue(pUserRight, &varUserRight);
        if (FAILED(hr))
        {
            return hr;
        }
        else if (hr == WBEM_S_FALSE && (ACTIONTYPE_QUERY != atAction) ) 
        {
            return WBEM_E_NOT_FOUND;
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // Prepare a store (for persistence) for this store path (file)
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistPath(varStorePath.bstrVal);

        if ( SUCCEEDED(hr) ) {

            //
            // make sure the store (just a file) really exists. The raw path
            // may contain env variables, so we need the expanded path
            //

            DWORD dwAttrib = GetFileAttributes(SceStore.GetExpandedPath());

            if ( dwAttrib != -1 ) 
            {
                //
                // make sure our store is valid
                //

                if ( SceStore.GetStoreType() < SCE_INF_FORMAT ||
                     SceStore.GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) 
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                }

                if ( SUCCEEDED(hr) ) 
                {
                    if ( ACTIONTYPE_DELETE == atAction )
                    {
                        hr = DeleteInstance(pHandler, &SceStore, varUserRight.bstrVal);
                    }
                    else 
                    {

                        //
                        // get the key property count to determin how we should be construct the instance(s)
                        //

                        BOOL bPostFilter=TRUE;
                        DWORD dwCount = 0;
                        m_srpKeyChain->GetKeyPropertyCount(&dwCount);

                        if ( varUserRight.vt == VT_EMPTY && dwCount == 1 ) 
                        {
                            //
                            // something else is specified in the path
                            // have filter on
                            //

                            bPostFilter = FALSE;
                        }

                        hr = ConstructInstance(
                                               pHandler, 
                                               &SceStore, 
                                               varStorePath.bstrVal,
                                               (varUserRight.vt == VT_BSTR) ? varUserRight.bstrVal : NULL,
                                               bPostFilter
                                               );
                    }
                }
            } 
            else 
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CUserPrivilegeRights::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_UserPrivilegeRight,
    which is persistence oriented, this will cause the Sce_UserPrivilegeRight object's property 
    information to be saved in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst       - COM interface pointer to the WMI class (Sce_UserPrivilegeRight) object.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

*/

HRESULT 
CUserPrivilegeRights::PutInst (
    IN IWbemClassObject    * pInst,
    IN IWbemObjectSink     * pHandler,
    IN IWbemContext        * pCtx
    )
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;

    CComBSTR bstrRight = NULL;

    PSCE_NAME_LIST pnlAdd = NULL;

    DWORD mode;

    CSceStore SceStore;

    //
    // CScePropertyMgr helps us to access WMI object's properties
    // create an instance and attach the WMI object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pInst);

    //
    // get user right name, can't be NULL
    // user right name should be validated
    //

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pUserRight, &bstrRight));
    if ( hr == WBEM_S_RESET_TO_DEFAULT) 
    {
        hr = WBEM_E_ILLEGAL_NULL;
        goto CleanUp;
    }

    //
    // validate the privilege right
    //

    SCE_PROV_IfErrorGotoCleanup(ValidatePrivilegeRight(bstrRight));

    //
    // get mode
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pMode, &mode));
    if ( hr == WBEM_S_RESET_TO_DEFAULT)
    {
        hr = WBEM_E_ILLEGAL_NULL;
        goto CleanUp;
    }

    //
    // get AddList
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pAddList, &pnlAdd));

    //
    // ignore RemoveList for now (since we don't support the mode)
    //

    //
    // Attach the WMI object instance to the store and let the store know that
    // it's store is given by the pStorePath property of the instance.
    //

    SceStore.SetPersistProperties(pInst, pStorePath);

    //
    // now save the info to file
    //

    hr = SaveSettingsToStore(&SceStore,
                             bstrRight,
                             mode,
                             pnlAdd,
                             NULL
                             );

CleanUp:

    if ( pnlAdd )
    {
        SceFreeMemory(pnlAdd, SCE_STRUCT_NAME_LIST);
    }

    return hr;

}


/*
Routine Description: 

Name:

    CUserPrivilegeRights::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_UserPrivilegeRight.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszLogStorePath - store path, a key property of Sce_UserPrivilegeRight class.

    wszRightName    - a corresponding key property of Sce_UserPrivilegeRight class.

    bPostFilter     - Controls how WMI will be informed with pHandler->SetStatus.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:

*/

HRESULT 
CUserPrivilegeRights::ConstructInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore,
    IN LPCWSTR            wszLogStorePath,
    IN LPCWSTR            wszRightName      OPTIONAL,
    IN BOOL               bPostFilter
    )
{
    //
    // ask SCE to read a gigantic structure out from the store. Only SCE
    // knows now to release the memory. Don't just delete it! Use our CSceStore
    // to do the releasing (FreeSecurityProfileInfo)
    //

    PSCE_PROFILE_INFO pInfo=NULL;
    HRESULT hr = pSceStore->GetSecurityProfileInfo(
                                                   AREA_PRIVILEGES,
                                                   &pInfo,
                                                   NULL
                                                   );

    //
    // nothing is read from the store
    //

    if ( pInfo == NULL ) 
    {
        if ( wszRightName )
        {
            hr = WBEM_E_NOT_FOUND;
        }
        else
        {
            hr = WBEM_S_NO_ERROR;
        }
        return hr;
    }

    //
    // we have to search for the user right name in the returned list
    //

    PSCE_PRIVILEGE_ASSIGNMENT pPrivileges = pInfo->OtherInfo.smp.pPrivilegeAssignedTo;

    if ( wszRightName ) 
    {
        while ( pPrivileges ) 
        {

            if ( pPrivileges->Name == NULL ) 
            {
                continue;
            }

            if ( _wcsicmp(pPrivileges->Name, wszRightName)== 0 ) 
            {
                break;
            }

            pPrivileges = pPrivileges->Next;
        }

        //
        // if the service information buffer is empty, treat it as "not found"
        //

        if ( pPrivileges == NULL ) 
        {
            hr = WBEM_E_NOT_FOUND;
        }
    }

    CComBSTR bstrLogOut;

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    if ( SUCCEEDED(hr) ) 
    {

        PSCE_PRIVILEGE_ASSIGNMENT pTmp = pPrivileges;

        SCE_PROV_IfErrorGotoCleanup(MakeSingleBackSlashPath(wszLogStorePath, L'\\', &bstrLogOut));

        while ( pTmp ) 
        {
            CComPtr<IWbemClassObject> srpObj;
            SCE_PROV_IfErrorGotoCleanup(SpawnAnInstance(&srpObj));

            //
            // CScePropertyMgr helps us to access WMI object's properties
            // create an instance and attach the WMI object to it.
            // This will always succeed.
            //

            CScePropertyMgr ScePropMgr;
            ScePropMgr.Attach(srpObj);

            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pStorePath, bstrLogOut));
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pUserRight, pTmp->Name));

            //
            // hardcode the mode for now
            //

            DWORD mode = 1;
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pMode, mode));

            if ( pPrivileges->AssignedTo )
            {
                SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pAddList, pPrivileges->AssignedTo));
            }

            //
            // ignore RemoveList for now
            //

            //
            // do the necessary gestures to WMI.
            // the use of WBEM_STATUS_REQUIREMENTS in SetStatus is not documented by WMI
            // at this point. Consult WMI team for detail if you suspect problems with
            // the use of WBEM_STATUS_REQUIREMENTS
            //

            if ( !bPostFilter ) {
                pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_FALSE, NULL, NULL);
            } else {
                pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);
            }

            //
            // pass the new instance to WMI
            //

            hr = pHandler->Indicate(1, &srpObj);

            if ( wszRightName ) 
            {
                // get the single instance
                break;
            }

            //
            // go to the next item
            //

            pTmp = pTmp->Next;
        }
    }

CleanUp:

    pSceStore->FreeSecurityProfileInfo(pInfo);

    return hr;
}

/*
Routine Description: 

Name:

    CUserPrivilegeRights::DeleteInstance

Functionality:
    
    remove an instance of Sce_UserPrivilegeRight from the specified store.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszRightName    - property of the Sce_UserPrivilegeRight class.

Return Value:

    See SaveSettingsToStore.

Notes:

*/

HRESULT CUserPrivilegeRights::DeleteInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore,
    IN LPCWSTR            wszRightName
    )
{
    //
    // SCE_NO_VALUE and NULL pointers indicate to SaveSettingsToStore that this is a delete
    //

    return SaveSettingsToStore(pSceStore, wszRightName, SCE_NO_VALUE, NULL, NULL);
}


/*
Routine Description: 

Name:

    CUserPrivilegeRights::SaveSettingsToStore

Functionality:
    
    With all the properties of a Sce_UserPrivilegeRight, this function just saves
    the instance properties to our store.

Virtual:
    
    No.
    
Arguments:

    pSceStore       - the store.

    wszGroupName    - a corresponding key property of Sce_UserPrivilegeRight class.

    mode            - another corresponding property of the Sce_UserPrivilegeRight class.

    pnlAdd          - another corresponding property of the Sce_UserPrivilegeRight class.

    pnlRemove       - another corresponding property of the Sce_UserPrivilegeRight class.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any error indicates the failure to save the instance.

Notes:
*/

HRESULT CUserPrivilegeRights::SaveSettingsToStore (
    IN CSceStore    * pSceStore,
    IN PCWSTR         wszRightName, 
    IN DWORD          mode,
    IN PSCE_NAME_LIST pnlAdd, 
    IN PSCE_NAME_LIST pnlRemove
    )
{
    //
    // ask SCE to read a gigantic structure out from the store. Only SCE
    // knows now to release the memory. Don't just delete it! Use our CSceStore
    // to do the releasing (FreeSecurityProfileInfo)
    //

    PSCE_PROFILE_INFO pInfo=NULL;

    HRESULT hr = pSceStore->GetSecurityProfileInfo(
                                       AREA_PRIVILEGES,
                                       &pInfo,
                                       NULL
                                       );
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // if it is INF template, then the following function will do the job as commented below
    //

    DWORD dwDump;

    //
    // For a new .inf file. Write an empty buffer to the file
    // will creates the file with right header/signature/unicode format
    // this is harmless for existing files.
    // For database store, this is a no-op.
    //

    hr = pSceStore->WriteSecurityProfileInfo(AreaBogus, (PSCE_PROFILE_INFO)&dwDump, NULL, false);
    
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // for INF format, we have to search for the servic name in the returned array
    //

    PSCE_PRIVILEGE_ASSIGNMENT pRight    = pInfo->OtherInfo.smp.pPrivilegeAssignedTo;
    PSCE_PRIVILEGE_ASSIGNMENT pParent   = NULL;

    DWORD i = 0;

    while ( pRight ) 
    {
        if ( pRight->Name == NULL ) 
        {
            continue;
        }

        if ( _wcsicmp(pRight->Name, wszRightName)== 0 ) 
        {
            break;
        }

        pParent = pRight;
        pRight = pRight->Next;
    }

    if ( pRight ) 
    {
        //
        // find it
        //

        if ( mode == SCE_NO_VALUE ) 
        {
            //
            // delete it
            //

            if ( pParent ) 
            {
                pParent->Next = pRight->Next;
            }
            else 
            {
                pInfo->OtherInfo.smp.pPrivilegeAssignedTo = pRight->Next;
            }

            //
            // free buffer
            //

            pRight->Next = NULL;
            SceFreeMemory(pRight, SCE_STRUCT_PRIVILEGE);

        } 
        else 
        {
            //
            // modify it
            //

            if ( pRight->AssignedTo ) 
            {
                SceFreeMemory(pRight->AssignedTo, SCE_STRUCT_NAME_LIST);
            }

            pRight->AssignedTo = pnlAdd;
        }

        //
        // write the section header
        //

        if ( SUCCEEDED(hr) ) 
        {
            hr = pSceStore->WriteSecurityProfileInfo(AREA_PRIVILEGES, pInfo, NULL, false);
        }

        if ( mode != SCE_NO_VALUE ) 
        {
            //
            // reset the buffer pointer
            //

            pRight->AssignedTo = NULL;
        }

    } 
    else 
    {
        //
        // not found
        //

        if ( mode == SCE_NO_VALUE )
        {
            //
            // try to delete non exist object
            //

            hr = WBEM_E_NOT_FOUND;

        } 
        else 
        {
            //
            // add this one in
            //

            SCE_PRIVILEGE_ASSIGNMENT addRight;

            addRight.Name = (PWSTR)wszRightName;
            addRight.Value = 0;
            addRight.AssignedTo = pnlAdd;
            addRight.Status = 0;
            addRight.Next = NULL;

            //
            // set the temp buffer pointer to pInfo to set to the store
            //

            pRight = pInfo->OtherInfo.smp.pPrivilegeAssignedTo;
            pInfo->OtherInfo.smp.pPrivilegeAssignedTo = &addRight;

            //
            // append this item to the section
            //

            hr = pSceStore->WriteSecurityProfileInfo(
                                                     AREA_PRIVILEGES,
                                                     pInfo,
                                                     NULL,
                                                     true  // appending
                                                     );
            //
            // reset the buffer pointer
            //

            pInfo->OtherInfo.smp.pPrivilegeAssignedTo = pRight;

        }
    }

    //
    // Free the profile buffer
    //

    pSceStore->FreeSecurityProfileInfo(pInfo);

    return hr;
}

/*
Routine Description: 

Name:

    CUserPrivilegeRights::ValidatePrivilegeRight

Functionality:
    
    Private helper to verify that the given right is valid. Will query all
    supported user rights (Sce_SupportedUserRights) to see if this is one of them.

Virtual:
    
    No.
    
Arguments:

    bstrRight    - a corresponding key property of Sce_UserPrivilegeRight class.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any error indicates the failure to save the instance.

Notes:
*/

HRESULT CUserPrivilegeRights::ValidatePrivilegeRight (
    IN BSTR bstrRight
    )
{
    
    if ( bstrRight == NULL ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    DWORD Len = SysStringLen(bstrRight);

    //
    // memory allocated for this BSTR strQueryCategories will be automatically released by CComBSTR
    //

    //
    // prepare the query
    //

    LPCWSTR pQuery = L"SELECT * FROM Sce_SupportedUserRights WHERE RightName=\"";

    //
    // 1 for closing quote and 1 for 0 terminator
    //

    CComBSTR strQueryCategories;
    strQueryCategories.m_str = ::SysAllocStringLen(NULL, Len + wcslen(pQuery) + 2);
    if ( strQueryCategories.m_str == NULL ) 
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // this won't overrun. See allocation size above
    //

    wcscpy(strQueryCategories.m_str, pQuery);    
    wcscat(strQueryCategories.m_str, bstrRight);
    wcscat(strQueryCategories.m_str, L"\"");

    //
    // execute the query
    //

    CComPtr<IEnumWbemClassObject> srpEnum;
    CComPtr<IWbemClassObject> srpObj;
    ULONG n = 0;

    HRESULT hr = m_srpNamespace->ExecQuery(L"WQL",
                                           strQueryCategories,
                                           WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                                           NULL,
                                           &srpEnum
                                           );

    if (SUCCEEDED(hr))
    {
        //
        // should get one and only one instance
        //

        hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &n);
        if ( hr == WBEM_S_FALSE ) 
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }

        if ( SUCCEEDED(hr) ) 
        {
            if (n > 0)
            {
                //
                // find the instance
                //

                hr = WBEM_S_NO_ERROR;

            } 
            else 
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\sceparser.cpp ===
// scecore.h: interface for the core services sceprov provides.
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "sceprov.h"
#include "sceparser.h"

// IScePathParser

/*
Routine Description: 

Name:

    CScePathParser::CScePathParser

Functionality:
    
    Constructor. Initialize pointer members.

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    None.

Notes:
    
    If you add more members, please initialize them here.

*/

CScePathParser::CScePathParser ()
    : 
    m_pszNamespace(NULL), 
    m_pszClassName(NULL)
{
}

/*
Routine Description: 

Name:

    CScePathParser::~CScePathParser

Functionality:
    
    Destructor. Do clean up (free memory).

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    None.

Notes:
    
    If you add more members, please consider do clean up in the Cleanup function.

*/

CScePathParser::~CScePathParser()
{
    Cleanup();
}

/*
Routine Description: 

Name:

    CScePathParser::ParsePath

Functionality:
    
    Parsing given path and store results in our members.

Virtual:
    
    Yes.
    
Arguments:

    pszObjectPath - the path to be parsed.

Return Value:

    Success: S_OK
    
    Failure: various error code. Any such error indicates the failure to parse the path.
        (1) E_INVALIDARG
        (2) E_OUTOFMEMORY
        (3) E_UNEXPECTED for syntax error

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CScePathParser::ParsePath ( 
    IN LPCWSTR pszObjectPath
    )
{
    if (pszObjectPath == NULL || *pszObjectPath == L'\0')
    {
        return E_INVALIDARG;
    }

    //
    // just in case, this object has already parsed before. This allows repeated use of the same
    // CScePathParser for parsing different paths. 
    //

    Cleanup();

    //
    // Ask WMI for their path parser
    //

    CComPtr<IWbemPath> srpPathParser;
    HRESULT hr = ::GetWbemPathParser(&srpPathParser);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // This is the parsing function.
    //

    hr = srpPathParser->SetText(WBEMPATH_CREATE_ACCEPT_ALL | WBEMPATH_TREAT_SINGLE_IDENT_AS_NS, pszObjectPath);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Get the results...
    //

    ULONG uBufSize = 0;
    DWORD dwCount = 0;

    //
    // get namespace count
    //

    hr = srpPathParser->GetNamespaceCount(&dwCount);

    if (dwCount > 0)
    {
        //
        // get the length needed for the namespace
        //

        hr = srpPathParser->GetNamespaceAt(0, &uBufSize, NULL);

        if (FAILED(hr))
        {
            return hr;
        }

        //
        // we will free this memory.
        //

        m_pszNamespace = new WCHAR[uBufSize];

        if (m_pszNamespace == NULL)
        {
            return E_OUTOFMEMORY;
        }

        //
        // will ignore the result
        //

        hr = srpPathParser->GetNamespaceAt(0, &uBufSize, m_pszNamespace);
    }

    //
    // get the buffer size needed for the class name
    //

    uBufSize = 0;
    hr = srpPathParser->GetClassName(&uBufSize, NULL);

    if (SUCCEEDED(hr))
    {
        //
        // we will free this memory.
        //

        m_pszClassName = new WCHAR[uBufSize];

        if (m_pszClassName == NULL)
        {
            return E_OUTOFMEMORY;
        }

        //
        // WMI path parser don't have a documented behavior as when the class name
        // will be missing.
        //

        hr = srpPathParser->GetClassName(&uBufSize, m_pszClassName);
    }
    else    
    {   
        //
        // this clearly don't have a class name, then the namespace should be the class name.
        // for some reason, Query parser doesn't give us class name in case of singleton
        // and the class name ends up in the namespace member. Obviously, in this case, there is no
        // key properties.
        //

        //
        // must have a namespace
        //

        if (m_pszNamespace)
        {
            //
            // prepare to switch m_pszClassName to point to what the namesapce does.
            //

            delete [] m_pszClassName;
            m_pszClassName = m_pszNamespace;

            m_pszNamespace = NULL;

            //
            // we can return because there is no key property
            //

            return S_OK;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // get key properties
    //

    CComPtr<IWbemPathKeyList> srpKeyList;
    hr = srpPathParser->GetKeyList(&srpKeyList);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // now get the Key and value pairs
    //

    ULONG uKeyCount = 0;
    hr = srpKeyList->GetCount(&uKeyCount);
    if (FAILED(hr) || uKeyCount == 0)
    {
        return hr;
    }

    for (ULONG i = 0; i < uKeyCount; i++)
    {
        //
        // this pKeyVal will cache the (name, value) pair
        //

        CPropValuePair* pKeyVal = NULL;
        uBufSize = 0;

        //
        // now get the size of buffer needed
        //

        CComVariant var;
        ULONG uCimType = CIM_EMPTY;

        hr = srpKeyList->GetKey2(i,
                                0,
                                &uBufSize,
                                NULL,
                                &var,
                                &uCimType);

        if (SUCCEEDED(hr))
        {
            //
            // our vector will manage the memory used by pKeyVal
            //

            pKeyVal = new CPropValuePair;
            if (pKeyVal == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            //
            // need the name buffer
            //

            pKeyVal->pszKey = new WCHAR[uBufSize];

            //
            // variant member of pKeyVal needs to be initialized as well.
            //

            ::VariantInit(&(pKeyVal->varVal));

            //
            // secondary allocation fails, need to free the first level pointer
            //

            if (pKeyVal->pszKey == NULL)
            {
                delete pKeyVal;
                pKeyVal = NULL;
                hr = E_OUTOFMEMORY;
                break;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = srpKeyList->GetKey2(i,
                                    0,
                                    &uBufSize,
                                    pKeyVal->pszKey,
                                    &(pKeyVal->varVal),
                                    &uCimType);
        }

        if (SUCCEEDED(hr))
        {
            m_vecKeyValueList.push_back(pKeyVal);
        }
        else
        {
            //
            // for any failure, we need to free the resource already partially allocated
            // for the pKeyVal. This pKeyVal is pointing to our class, which knows how to free its members,
            // this delete is enough.
            //

            delete pKeyVal;
            break;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    return hr;
}
        
/*
Routine Description: 

Name:

    CScePathParser::GetKeyPropertyCount

Functionality:
    
    Get the key proeprty count contained in the path.

Virtual:
    
    Yes.
    
Arguments:

    pCount - receives the count.

Return Value:

    Success: S_OK
    
    Failure: E_INVALIDARG.

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CScePathParser::GetKeyPropertyCount ( 
    OUT DWORD *pCount
    )
{
    if (pCount == NULL)
    {
        return E_INVALIDARG;
    }

    *pCount = m_vecKeyValueList.size();
    return S_OK;
}

/*
Routine Description: 

Name:

    CScePathParser::GetNamespace

Functionality:
    
    Get the namespace.

Virtual:
    
    Yes.
    
Arguments:

    pbstrNamespace - receives the namespace string.

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG
        (2) E_OUTOFMEMORY
        (3) E_UNEXPECTED for syntax error

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CScePathParser::GetNamespace ( 
    OUT BSTR *pbstrNamespace
    )
{
    if (pbstrNamespace == NULL)
    {
        return E_INVALIDARG;
    }

    if (m_pszNamespace)
    {
        *pbstrNamespace = ::SysAllocString(m_pszNamespace);
    }
    else
    {
        return E_UNEXPECTED;
    }

    return (*pbstrNamespace) ? S_OK : E_OUTOFMEMORY;
}

/*
Routine Description: 

Name:

    CScePathParser::GetClassName

Functionality:
    
    Get the class name.

Virtual:
    
    Yes.
    
Arguments:

    pbstrClassName - receives the class name string.

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG
        (2) E_OUTOFMEMORY
        (3) E_UNEXPECTED for syntax error

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CScePathParser::GetClassName ( 
    OUT BSTR *pbstrClassName
    )
{
    if (pbstrClassName == NULL)
    {
        return E_INVALIDARG;
    }

    if (m_pszClassName)
    {
        *pbstrClassName = ::SysAllocString(m_pszClassName);
    }
    else
    {
        return E_UNEXPECTED;
    }

    return (*pbstrClassName) ? S_OK : E_OUTOFMEMORY;
}
        
/*
Routine Description: 

Name:

    CScePathParser::GetKeyPropertyValue

Functionality:
    
    Get the named property's value

Virtual:
    
    Yes.
    
Arguments:

    pszKeyPropName  - The key property's name whose value is to be retrieved.

    pvarValue       - receives the value.

Return Value:

    Success: S_OK if the property value is properly retrieved.
             WBEM_S_FALSE if the property value can't be found.
    
    Failure:
        (1) E_INVALIDARG
        (2) E_OUTOFMEMORY
        (5) Or errors from VariantCopy

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CScePathParser::GetKeyPropertyValue ( 
    IN LPCWSTR pszKeyPropName,
    OUT VARIANT *pvarValue    
    )
{
    if (pszKeyPropName == NULL || *pszKeyPropName == L'\0' || pvarValue == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // set the variant to a valid empty initial state
    //

    ::VariantInit(pvarValue);

    //
    // assume we can't find the property
    //

    HRESULT hr = WBEM_S_FALSE;

    std::vector<CPropValuePair*>::iterator it;

    //
    // find the property (case-insensitive name comparison) and copy the value
    //

    for (it = m_vecKeyValueList.begin(); it != m_vecKeyValueList.end(); it++)
    {
        if (_wcsicmp((*it)->pszKey, pszKeyPropName) == 0)
        {
            hr = ::VariantCopy(pvarValue, &((*it)->varVal));
            break;
        }
    }

    return hr;
}
        
/*
Routine Description: 

Name:

    CScePathParser::GetKeyPropertyValueByIndex

Functionality:
    
    Get the indexed property name and value.

Virtual:
    
    Yes.
    
Arguments:
    
    dwIndex           - the (name, value) pair's index.

    pbstrKeyPropName  - receives key property's name.

    pvarValue         - receives the value. In caller not interested, this can be NULL.

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY
        (3) E_UNEXPECTED for can't find the property
        (4) Or errors from VariantCopy

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP CScePathParser::GetKeyPropertyValueByIndex ( 
    IN DWORD dwIndex,
    OUT BSTR* pbstrKeyPropName,
    OUT VARIANT *pvarValue  OPTIONAL
    )
{
    if (dwIndex >= m_vecKeyValueList.size() || pbstrKeyPropName == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // assume we can't find it
    //

    HRESULT hr = E_UNEXPECTED;

    //
    // initialize the out parameters
    //

    *pbstrKeyPropName = NULL;

    if (pvarValue)
    {
        ::VariantInit(pvarValue);
    }

    CPropValuePair *pKV = m_vecKeyValueList[dwIndex];

    if (pKV)
    {
        *pbstrKeyPropName = ::SysAllocString(pKV->pszKey);

        if (pbstrKeyPropName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr) && pvarValue)
        {
            hr = ::VariantCopy(pvarValue, &(pKV->varVal));

            //
            // don't want to return partial results
            //

            if (FAILED(hr))
            {
                ::SysFreeString(*pbstrKeyPropName);
                *pbstrKeyPropName = NULL;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CScePathParser::Cleanup

Functionality:
    
    Free memory resources.

Virtual:
    
    No.
    
Arguments:
    
    None.

Return Value:

    None.

Notes:
    Consider adding your clean up code here should you need to add members.

*/

void CScePathParser::Cleanup()
{
    //
    // empty the vector. Since the vector manages the (name, value) pair,
    // its contents need to be deleted!
    //

    std::vector<CPropValuePair*>::iterator it;
    for (it = m_vecKeyValueList.begin(); it != m_vecKeyValueList.end(); ++it)
    {
        delete *it;
    }
    m_vecKeyValueList.empty();

    //
    // This function may be called not just inside the destructor,
    // so, properly reset the pointer values after free its memory.
    //

    delete [] m_pszNamespace;
    m_pszNamespace = NULL;

    delete [] m_pszClassName;
    m_pszClassName = NULL;
}

//================================================================================================
// implementations for CSceQueryParser
//================================================================================================

/*
Routine Description: 

Name:

    CSceQueryParser::CSceQueryParser

Functionality:
    
    Constructor. All members are classes. They initialize automatically.

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    None.

Notes:
    
    If you add more members, please initialize them here.

*/

CSceQueryParser::CSceQueryParser()
{
}

/*
Routine Description: 

Name:

    CSceQueryParser::~CSceQueryParser

Functionality:
    
    Destructor. do clean up.

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    None.

Notes:
    
    If you add more members, please initialize them here.

*/

CSceQueryParser::~CSceQueryParser()
{
    Cleanup();
}

/*
Routine Description: 

Name:

    CSceQueryParser::GetClassName

Functionality:
    
    Get the class's name for the given index.

Virtual:
    
    Yes.
    
Arguments:

    iIndex          - The index of the class. Currently, this is not used because WMI only
                      support unary query - query that spans over one class. What we won't
                     design our interface into that.
    
    pbstrClassName  - Receives the class name.

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY
        (3) E_UNEXPECTED for can't find the property
        (4) Or errors from VariantCopy

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CSceQueryParser::GetClassName (
    IN int      iIndex,       
    OUT BSTR  * pbstrClassName
    )
{
    if (pbstrClassName == NULL || iIndex >= m_vecClassList.size())
    {
        return E_INVALIDARG;
    }

    if (m_vecClassList[iIndex])
    {
        *pbstrClassName = ::SysAllocString(m_vecClassList[iIndex]);
    }
    else
    {
        return E_UNEXPECTED;
    }

    return (*pbstrClassName) ? S_OK : E_OUTOFMEMORY;
}

/*
Routine Description: 

Name:

    CSceQueryParser::GetGetQueryingPropertyValue

Functionality:
    
    Get querying property's value given the index.

Virtual:
    
    Yes.
    
Arguments:

    iIndex          - Since the same querying property may have multiple values in the where clause
                      this is to get the iIndex-th value of the querying property. If you have a query 
                      like this: 

                        select * from Foo where FooVal = 1 AND BarVal = 5 OR FooVal = 2 AND BarVal = 6

                      you will end up only with FooVal's. The reason for this limitation is that WMI
                      doesn't have a full support on it (parser is maturing) and it's way too complicated
                      for our SCE parser. For users who needs that kind of support, please use WMI's query
                      parser directly.
    
    pbstrQPValue    - Receives the querying property's value in string format.

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY
        (3) E_UNEXPECTED for can't find the property

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CSceQueryParser::GetQueryingPropertyValue (
    IN int      iIndex,
    OUT BSTR  * pbstrQPValue
    )
{
    if (pbstrQPValue == NULL || iIndex >= m_vecQueryingPropValueList.size())
    {
        return E_INVALIDARG;
    }

    if (m_vecQueryingPropValueList[iIndex])
    {
        *pbstrQPValue = ::SysAllocString(m_vecQueryingPropValueList[iIndex]);
    }
    else
    {
        return E_UNEXPECTED;
    }

    return (*pbstrQPValue) ? S_OK : E_OUTOFMEMORY;
}

/*
Routine Description: 

Name:

    CSceQueryParser::Cleanup

Functionality:
    
    free the resources held by our members.

Virtual:
    
    No.
    
Arguments:

    None.

Return Value:

    None.

Notes:
    (1) Consider add clean up code here should you need to add more members.

*/

void CSceQueryParser::Cleanup()
{
    //
    // both vectors are storing heap strings, need to delete the contents!
    //

    std::vector<LPWSTR>::iterator it;

    for (it = m_vecClassList.begin(); it != m_vecClassList.end(); it++)
    {
        delete [] (*it);
    }
    m_vecClassList.empty();

    for (it = m_vecQueryingPropValueList.begin(); it != m_vecQueryingPropValueList.end(); it++)
    {
        delete [] (*it);
    }
    m_vecQueryingPropValueList.empty();

    m_bstrQueryingPropName.Empty();
}

/*
Routine Description: 

Name:

    CSceQueryParser::ParseQuery

Functionality:
    
    Given the property name we are looking for, this function will parsing the query.

Virtual:
    
    Yes.
    
Arguments:

    strQuery          - The query to be parsed.
    
    strQueryPropName  - The querying property (the property we are looking for in the query).

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY
        (3) E_UNEXPECTED for can't find the property
        (4) Other errors from WMI query parser.

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP CSceQueryParser::ParseQuery ( 
    IN LPCWSTR strQuery,
    IN LPCWSTR strQueryPropName
    )
{
    if (strQuery == NULL || *strQuery == L'\0')
    {
        return E_INVALIDARG;
    }

    CComPtr<IWbemQuery> srpQuery;

    //
    // Get the WMI query object
    //

    HRESULT hr = ::GetWbemQuery(&srpQuery);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Set up the query parser to use
    //

    ULONG uFeatures[] = {WMIQ_LF1_BASIC_SELECT, WMIQ_LF2_CLASS_NAME_IN_QUERY};

    hr = srpQuery->SetLanguageFeatures(0, sizeof(uFeatures)/sizeof(*uFeatures), uFeatures);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // we are ready to parse, so, cleanup
    //

    Cleanup();

    //
    // parse the query
    //

    hr = srpQuery->Parse(L"WQL", strQuery, 0);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Get the parsing results
    //

    //
    // need to free memory. Don't do it ourselves. Ask query to free it!
    //

    SWbemRpnEncodedQuery *pRpn = 0;
    hr = srpQuery->GetAnalysis(WMIQ_ANALYSIS_RPN_SEQUENCE, 0, (LPVOID *) &pRpn);

    if (SUCCEEDED(hr))
    {
        //
        // Need the class name from the results
        //

        hr = ExtractClassNames(pRpn);

        //
        // need the querying property values
        //

        if (SUCCEEDED(hr) && strQueryPropName && *strQueryPropName != L'\0')
        {
            m_bstrQueryingPropName = strQueryPropName;
            hr = ExtractQueryingProperties(pRpn, strQueryPropName);
        }

        srpQuery->FreeMemory(pRpn);
    }

    return SUCCEEDED(hr) ? S_OK : hr;
}

/*
Routine Description: 

Name:

    CSceQueryParser::ExtractClassNames

Functionality:
    
    Private helper to get the class name(s) from the query results.

Virtual:
    
    No.
    
Arguments:

    pRpn    - The query result.

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY.

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

HRESULT CSceQueryParser::ExtractClassNames (
    SWbemRpnEncodedQuery *pRpn
    )
{
    if (pRpn == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    int iLen = 0;
    LPWSTR pszClassName = NULL;

    //
    // get the from clause, i.e., the class names
    //

    if (pRpn->m_uFromTargetType & WMIQ_RPN_FROM_UNARY)
    {
        //
        // only one class
        //

        //
        // copy the class name and push it to our list
        //

        iLen = wcslen(pRpn->m_ppszFromList[0]);
        pszClassName = new WCHAR[iLen + 1];

        if (pszClassName != NULL)
        {
            //
            // won't overrun buffer, see size above
            //

            wcscpy(pszClassName, pRpn->m_ppszFromList[0]);
            m_vecClassList.push_back(pszClassName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (pRpn->m_uFromTargetType & WMIQ_RPN_FROM_CLASS_LIST)
    {
        //
        // multiple classes. Won't happen for the time being. But we want to be ready
        // for WMI parser's enhancement.
        //

        for (ULONG uIndex = 0; uIndex < pRpn->m_uFromListSize; uIndex++)
        {
            iLen = wcslen(pRpn->m_ppszFromList[uIndex]);
            pszClassName = new WCHAR[iLen + 1];
            if (pszClassName != NULL)
            {
                //
                // won't overrun buffer, see size above
                //
                wcscpy(pszClassName, pRpn->m_ppszFromList[uIndex]);
                m_vecClassList.push_back(pszClassName);
            }
            else
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CSceQueryParser::ExtractQueryingProperties

Functionality:
    
    Private helper to get the class name(s) from the query results.

Virtual:
    
    No.
    
Arguments:

    pRpn              - The query result.

    strQueryPropName  - the querying property's name

Return Value:

    Success: S_OK
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY.

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.
    (2) We only care about one querying property. Each subexpression will only have one querying property.
        Plus, if the subexpressions are AND'ed together, we will skip the rest subexpressions until we
        sees an OR again.
    (3) We can't support NOT very well. For example, how can we answer:

            select * from where NOT (SceStorePath = "c:\\test.inf")

        Fundamentally, we can't do that because we don't know the score of files not equal "c:\\test.inf".

*/

//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
HRESULT CSceQueryParser::ExtractQueryingProperties (
    IN SWbemRpnEncodedQuery * pRpn,
    IN LPCWSTR                strQueryPropName
    )
{
    if (pRpn == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    SWbemRpnQueryToken *pQueryToken = NULL;

    //
    // flags if we should ignore the next token
    //

    bool bSkip = false;

    for (ULONG uIndex = 0; uIndex < pRpn->m_uWhereClauseSize; uIndex++)
    {
        pQueryToken = pRpn->m_ppRpnWhereClause[uIndex];

        switch (pQueryToken->m_uTokenType)
        {
            case WMIQ_RPN_TOKEN_EXPRESSION:

                //
                // there is a subexpression, potentially a querying property here
                //

                if (!bSkip)
                {
                    hr = GetQueryPropFromToken(pQueryToken, strQueryPropName);
                }

                //
                // if hr == S_FALSE, then it means it doesn't find any Store path
                // see it's use in case WMIQ_RPN_TOKEN_AND bellow
                //

                if (FAILED(hr))
                {
                    return hr;
                }
                break;

            case WMIQ_RPN_TOKEN_OR:

                //
                // we see an OR, next tokens should NOT been skipped
                //

                bSkip = false;
                break;

            case WMIQ_RPN_TOKEN_AND:

                //
                // see comments about S_FALSE in case WMIQ_RPN_TOKEN_EXPRESSION above
                //

                bSkip = (hr == S_FALSE) ? false : true;

                //
                // fall through
                //

            case WMIQ_RPN_TOKEN_NOT:
            default:

                //
                // don't support parsing these tokens, so skip
                //

                bSkip = true;
                break;
        }
    }

    return S_OK;
}

/*
Routine Description: 

Name:

    CSceQueryParser::GetQueryPropFromToken

Functionality:
    
    Private helper analyze the token and get the querying property's value if found.

Virtual:
    
    No.
    
Arguments:

    pRpnQueryToken    - The token to analyze.

    strQueryPropName  - the querying property's name

Return Value:

    Success: S_OK if a querying property's value is successfully retrieved.
             S_FALSE if no querying property name if found in the token.
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY.
        (3) Other errors only defined by WMI, such as WBEM_E_INVALID_SYNTAX, WBEM_E_NOT_SUPPORTED.

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.
    (2) We only care about one querying property. Each subexpression will only have one querying property.
        Plus, if the subexpressions are AND'ed together, we will skip the rest subexpressions until we
        sees an OR again.
    (3) We can't support NOT very well. For example, how can we answer:

            select * from where NOT (SceStorePath = "c:\\test.inf")

        Fundamentally, we can't do that because we don't know the score of files not equal "c:\\test.inf".

*/

HRESULT 
CSceQueryParser::GetQueryPropFromToken (
    IN SWbemRpnQueryToken * pRpnQueryToken,
    IN LPCWSTR              strQueryPropName
    )
{
    HRESULT hr = S_OK;

    //
    // we only support <propertyName> = <value> and
    // <value> should be string
    //

    if (pRpnQueryToken->m_uOperator             != WMIQ_RPN_OP_EQ ||
        pRpnQueryToken->m_uConstApparentType    != VT_LPWSTR        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // must have left identifier, we don't support it if it doesn't have one.
    //

    if (pRpnQueryToken->m_pLeftIdent == NULL)
    {
        hr = WBEM_E_NOT_SUPPORTED;
    }
    else 
    {
        SWbemQueryQualifiedName *pLeft = pRpnQueryToken->m_pLeftIdent;

        //
        // no left, invalid
        //

        if (pLeft == NULL)
        {
            return WBEM_E_INVALID_SYNTAX;
        }

        if (pLeft->m_uNameListSize != 1)
        {
            return WBEM_E_NOT_SUPPORTED;
        }

        // if the right is StoreName, then this is what we need
        if (_wcsicmp(strQueryPropName, pLeft->m_ppszNameList[0]) == 0)
        {
            int iLen = wcslen(pRpnQueryToken->m_Const.m_pszStrVal);
            LPWSTR pName = new WCHAR[iLen + 1];

            if (pName)
            {
                //
                // won't overrun the buffer
                //

                wcscpy(pName, pRpnQueryToken->m_Const.m_pszStrVal);
                m_vecQueryingPropValueList.push_back(pName);
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
        else
        {   
            //
            // no match for querying property name
            //

            hr = S_FALSE;
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CSceQueryParser::GetQueryPropFromToken

Functionality:
    
    Get key proeprty value parsed from the query. Due to our query limitation, the property name
    should really be the querying property name.

Virtual:
    
    Yes.
    
Arguments:

    pszKeyPropName  - The key property name.

    pvarValue       - receives the value.

Return Value:

    Success: S_OK if a key property's value is successfully retrieved.
             WBEM_S_FALSE if the property can't be found.
    
    Failure:
        (1) E_INVALIDARG (illegal null or index out of range)
        (2) E_OUTOFMEMORY.
        (3) Other errors only defined by WMI, such as WBEM_E_INVALID_SYNTAX, WBEM_E_NOT_SUPPORTED.

Notes:
    (1) Since this is regular COM server interface function, we use regular COM errors
        instead of WMI errors. However, we can't guarantee what WMI returns.

*/

STDMETHODIMP 
CSceQueryParser::GetKeyPropertyValue ( 
    IN LPCWSTR    pszKeyPropName,
    OUT VARIANT * pvarValue
    )
{
    if (pvarValue == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // ready to say that we can't find it
    //

    HRESULT hr = WBEM_S_FALSE;
    ::VariantInit(pvarValue);

    //
    // If you are asking for the querying property's value, we certainly can give you one.
    //

    if ((LPCWSTR)m_bstrQueryingPropName != NULL && _wcsicmp(pszKeyPropName, m_bstrQueryingPropName) == 0)
    {
        CComBSTR bstrVal;
        hr = GetQueryingPropertyValue(0, &bstrVal);

        if (SUCCEEDED(hr))
        {
            //
            // hand it over to the out parameter
            //

            pvarValue->vt = VT_BSTR;
            pvarValue->bstrVal = bstrVal.Detach();

            hr = S_OK;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\requestobject.h ===
// RequestObject.h: interface for the CRequestObject class.
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REQUESTOBJECT_H__bd7570f7_9f0e_4c6b_b525_e078691b6d0e__INCLUDED_)
#define AFX_REQUESTOBJECT_H__bd7570f7_9f0e_4c6b_b525_e078691b6d0e__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//
// make these Properties available to all those who included this header
//

extern const WCHAR * pPath;
extern const WCHAR * pDescription;
extern const WCHAR * pVersion;
extern const WCHAR * pReadonly;
extern const WCHAR * pDirty;
extern const WCHAR * pStorePath;
extern const WCHAR * pStoreType;
extern const WCHAR * pMinAge;
extern const WCHAR * pMaxAge;
extern const WCHAR * pMinLength;
extern const WCHAR * pHistory;
extern const WCHAR * pComplexity;
extern const WCHAR * pStoreClearText;
extern const WCHAR * pForceLogoff;
extern const WCHAR * pEnableAdmin;
extern const WCHAR * pEnableGuest;
extern const WCHAR * pLSAPol;
extern const WCHAR * pThreshold;
extern const WCHAR * pDuration;
extern const WCHAR * pResetTimer;
extern const WCHAR * pEvent;
extern const WCHAR * pAuditSuccess;
extern const WCHAR * pAuditFailure;
extern const WCHAR * pType;
extern const WCHAR * pData;
extern const WCHAR * pDatabasePath;
extern const WCHAR * pTemplatePath;
extern const WCHAR * pLogFilePath;
extern const WCHAR * pOverwrite;
extern const WCHAR * pAreaMask;
extern const WCHAR * pMaxTicketAge;
extern const WCHAR * pMaxRenewAge;
extern const WCHAR * pMaxServiceAge;
extern const WCHAR * pMaxClockSkew;
extern const WCHAR * pEnforceLogonRestrictions;
extern const WCHAR * pCategory;
extern const WCHAR * pSuccess;
extern const WCHAR * pFailure;
extern const WCHAR * pSize;
extern const WCHAR * pOverwritePolicy;
extern const WCHAR * pRetentionPeriod;
extern const WCHAR * pRestrictGuestAccess;
extern const WCHAR * pAdministratorAccountName;
extern const WCHAR * pGuestAccountName;
extern const WCHAR * pMode;
extern const WCHAR * pSDDLString;
extern const WCHAR * pService;
extern const WCHAR * pStartupMode;
extern const WCHAR * pUserRight;
extern const WCHAR * pAddList;
extern const WCHAR * pRemoveList;
extern const WCHAR * pGroupName;
extern const WCHAR * pPathName;
extern const WCHAR * pDisplayName;
extern const WCHAR * pDisplayDialog;
extern const WCHAR * pDisplayChoice;
extern const WCHAR * pDisplayChoiceResult;
extern const WCHAR * pUnits;
extern const WCHAR * pRightName;
extern const WCHAR * pPodID;
extern const WCHAR * pPodSection;
extern const WCHAR * pKey;
extern const WCHAR * pValue;
extern const WCHAR * pLogArea;
extern const WCHAR * pLogErrorCode;
extern const WCHAR * pLogErrorType;
extern const WCHAR * pLogVerbose;  
extern const WCHAR * pAction;
extern const WCHAR * pErrorCause;
extern const WCHAR * pObjectDetail;
extern const WCHAR * pParameterDetail;
extern const WCHAR * pLastAnalysis;
extern const WCHAR * pLastConfiguration;
extern const WCHAR * pAttachmentSections;
extern const WCHAR * pClassOrder;
extern const WCHAR * pTranxGuid;
extern const WCHAR * pwMethodImport;
extern const WCHAR * pwMethodExport;
extern const WCHAR * pwMethodApply;
extern const WCHAR * pwAuditSystemEvents;
extern const WCHAR * pwAuditLogonEvents;
extern const WCHAR * pwAuditObjectAccess;
extern const WCHAR * pwAuditPrivilegeUse;
extern const WCHAR * pwAuditPolicyChange;
extern const WCHAR * pwAuditAccountManage;
extern const WCHAR * pwAuditProcessTracking;
extern const WCHAR * pwAuditDSAccess;
extern const WCHAR * pwAuditAccountLogon;
extern const WCHAR * pwApplication;
extern const WCHAR * pwSystem;
extern const WCHAR * pwSecurity;

//
// macro that calculates the size of the (input parameter) array
//

#define SCEPROV_SIZEOF_ARRAY(x) (sizeof(x)/sizeof(*x))

//
// forward declaration
//

class CGenericClass;



/*

Class description
    
    Naming: 

        CRequestObject stands for Object that delegates Request from WMI.
    
    Base class: 

        None
    
    Purpose of class:

        (1) This is the general delegator for any WMI calls into the provider. Basically
            any WMI action is sent to this class for further process. Its public functions
            thus defines the interface between our provider and what individual classes
            for the WMI classes interact.
    
    Design:

        (1) We know how to create a WMI object (representing our WMI classes). 
            Implemented by CreateObject.

        (2) We know how to Put an instance. Implemented by PutObject.

        (3) We know how to execute a query. That is done by ExecQuery.

        (4) We know how to delete an instance (representing our WMI classes).
            That is done by DeleteObject.
        
        To facilitate these functionality, we designed the following private helpers:
        
        (5) We know how to create a C++ class that serves the need for the corresponding
            WMI class given the WMI class's name. That is implemented inside CreateClass function.

        (6) We know how to parse a WMI object path for critical information. That is done by
            CreateKeyChain.

        (7) We know how to parse a query for critical information. That is done by
            ParseQuery.
    
    Use:

         (1) Create an instance.

         (2) Call the appropriate function.

         (3) Actually, you very rarely need to use it in the above fashion. Most likely,
             what you need to do is the expand the WMI classes we are going to provide.
             And in that case, all you need to do is:

             (a) Implement a C++ class to fulfill the WMI obligation for the WMI class.
                 Most obviously, you need to derive your C++ from CGenericClass.

             (b) Add an entry in the CreateClass function of this class.

             Everything else should happen automatically.

*/

class CRequestObject
{
public:

    CRequestObject(IWbemServices *pNamespace) : m_srpNamespace(pNamespace)
        {
        }

    HRESULT CreateObject (
                         BSTR bstrPath, 
                         IWbemObjectSink *pHandler, 
                         IWbemContext *pCtx, 
                         ACTIONTYPE ActType
                         );

    HRESULT PutObject (
                      IWbemClassObject *pInst, 
                      IWbemObjectSink *pHandler, 
                      IWbemContext *pCtx
                      );

    HRESULT ExecMethod (
                       BSTR bstrPath, 
                       BSTR bstrMethod, 
                       IWbemClassObject *pInParams,
                       IWbemObjectSink *pHandler, 
                       IWbemContext *pCtx
                       );

    HRESULT DeleteObject (
                         BSTR bstrPath, 
                         IWbemObjectSink *pHandler, 
                         IWbemContext *pCtx
                         );

#ifdef _EXEC_QUERY_SUPPORT

    HRESULT ExecQuery (
                      BSTR bstrQuery, 
                      IWbemObjectSink *pHandler, 
                      IWbemContext *pCtx
                      );

    bool ParseQuery (
                    BSTR bstrQuery
                    );

#endif

private:

    HRESULT CreateKeyChain (
                            LPCWSTR pszPath, 
                            ISceKeyChain** pKeyChain
                            );

    HRESULT CreateClass (
                        ISceKeyChain* pKeyChain, 
                        CGenericClass **pClass, 
                        IWbemContext *pCtx
                        );

    HRESULT GetWbemObjectPath (
                              IWbemClassObject* pInst,
                              BSTR* pbstrPath
                              );

protected:

    CComPtr<IWbemServices> m_srpNamespace;
};

#endif // !defined(AFX_REQUESTOBJECT_H__bd7570f7_9f0e_4c6b_b525_e078691b6d0e__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\sequence.h ===
// sequence.h: interface for the class sequencing.
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "precomp.h"
#include "sceprov.h"

#include "GenericClass.h"

using namespace std;

#include <list>

//=======================================================================

/*
Class description
    
    Naming: 
         CNameList stands for Names List.
    
    Base class: 
         None.
    
    Purpose of class:
         (1) A simple wrapper to get rid of the burden of releasing
             memories of the list of string
    
    Design:
         (1) Just a non-trivial destructor.
    
    Use:
         (1) Obvious.
*/

class CNameList
{
public:
    ~CNameList();
    vector<LPWSTR> m_vList;
};


//=======================================================================


/*

Class description
    
    Naming: 
         COrderNameList stands Ordered (by priority) Names List.
    
    Base class: 
         None.
    
    Purpose of class:
         (1) To support class sequencing. Classes need to be put in a particular
             order when we spawn them to execute methods. They may have dependencies.
             To support a flexible ordering of classes, we use several classes. This
             is the most important one.
    
    Design:
         (1) To support sequencing classes, we have developed a mechanism that allows
             certain classes to have the same priority. Within the same priority, 
             the classes names are again ordered. Priorities are DWORD numbers. The smaller
             the numeric value is, the higher the priority.
         (2) To manage this list within list structure, we use map (m_mapPriNames) 
             mapping from priority to a CNameList. That map allows us to quickly lookup
             the names list for a given priority.
         (3) All existing priorities are managed by a vector m_listPriority.
         (4) Names in the lower priority has overall lower priority in the sequence of classes.
    
    Use:
         (1) To create a new order name list, you call BeginCreation followed by a
             serious of CreateOrderList calls. When all such list info are parsed and you have
             finished the creation process, then you call EndCreation.
         (2) To start enumerating the ordered name list, you first call GetNext 
             with *pdwEnumHandle = 0. This *pdwEnumHandle becomes your next GetNext's 
             input parameter.
*/

class COrderNameList
{
public:
    COrderNameList();
    ~COrderNameList();

    void BeginCreation() 
    {
        Cleanup();
    }

    HRESULT CreateOrderList (
                            DWORD dwPriority, 
                            LPCWSTR pszListInfo
                            );

    HRESULT EndCreation();

    HRESULT GetNext (
                    const CNameList** ppList, 
                    DWORD* pdwEnumHandle
                    )const;

private:

    void Cleanup();

typedef map<DWORD, CNameList* > MapPriorityToNames;
typedef MapPriorityToNames::iterator PriToNamesIter;

typedef list<DWORD> PriorityList;
typedef PriorityList::iterator ListIter;

    MapPriorityToNames m_mapPriNames;

    PriorityList m_listPriority;

    CNameList** m_ppList;
};


//=======================================================================


/*    
    
Class description
    
    Naming: 
         CSequencer stands for sequencing object.
    
    Base class: 
         None.
    
    Purpose of class:
         (1) When we execute a method on a store, the order objects are created for the
             execution is of great importance. For all Sce core objects, the engine takes
             over control. But for extension classes, we must build a flexible ordering
             mechanism. This is the out-most layer for this implementation.
    
    Design:
         (1) We can create ourself.
         (2) After creation, caller can call to get a non-modifiable COrderNameList to serve
             the ordering need.
    
    Use:
         (1) Create an instance of this class.
         (2) Call Create to populate its contents.
         (3) Call GetOrderList, caller gets the access to the ordered name list.
*/

class CSequencer
{
public:

    HRESULT GetOrderList(const COrderNameList** pList);
    HRESULT Create(IWbemServices* pNamespace, LPCWSTR pszStore, LPCWSTR pszMethod);

private:

    COrderNameList m_ClassList;
};

//=======================================================================

/*
    
Class description
    
    Naming: 
         CClassOrder stands for Classes Order.
    
    Base class: 
         CGenericClass, because it is a class representing a WMI  
         object - its WMI class name is Sce_AuditPolicy
    
    Purpose of class:
         (1) Certain template may want to have its own ordering. This class implements
             our WMI class Sce_ClassOrder for per-template class sequencing.
    
    Design:
         (1) it implements all pure virtual functions declared in CGenericClass
             so that it is a concrete class to create.
         (2) Since it has virtual functions, the desctructor should be virtual.
         (3) Per-tempalte sequencing takes precedence over namespace-wise class
             sequencing.
    
    Use:
         (1) We probably will never directly use this class. All its use is driven by
             CGenericClass's interface (its virtual functions).
*/

class CClassOrder : public CGenericClass
{

public:
    CClassOrder (
                ISceKeyChain *pKeyChain, 
                IWbemServices *pNamespace, 
                IWbemContext *pCtx
                );

    virtual ~CClassOrder();

public:
    
    virtual HRESULT PutInst (
                            IWbemClassObject *pInst, 
                            IWbemObjectSink *pHandler, 
                            IWbemContext *pCtx
                            );

    virtual HRESULT CreateObject (
                                 IWbemObjectSink *pHandler, 
                                 ACTIONTYPE atAction
                                 );

private:

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\sequence.cpp ===
// sequence.cpp: implementation of the various classes related to sequencing
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "sequence.h"
#include "persistmgr.h"
#include "requestobject.h"

/*
Routine Description: 

Name:

    CNameList::~CNameList

Functionality:

    Destructor. Simply cleans up the vector, which contains heap allocated strings.

Virtual:
    
    No

Arguments:

    None.

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about releasing them here.

*/

CNameList::~CNameList()
{
    int iCount = m_vList.size();
    for (int i = 0; i < iCount; ++i)
    {
        delete [] m_vList[i];
    }
    m_vList.clear();
}

/*
Routine Description: 

Name:

    COrderNameList::COrderNameList

Functionality:

    Contructor. Simple initialization.

Virtual:
    
    No

Arguments:

    None.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initializing them here.

*/

COrderNameList::COrderNameList() : m_ppList(NULL)
{
}

/*
Routine Description: 

Name:

    COrderNameList::~COrderNameList

Functionality:

    Detructor. Simple Cleanup.

Virtual:
    
    No

Arguments:

    None.

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about releasing them in Cleanup method.

*/

COrderNameList::~COrderNameList()
{
    Cleanup();
}

/*
Routine Description: 

Name:

    COrderNameList::Cleanup

Functionality:

    Clean up the map and the vector, both of which hold heap memory resources.

Virtual:
    
    No

Arguments:

    None.

Return Value:

    None.

Notes:
    if you create any local members, think about initializing them here.

*/

void 
COrderNameList::Cleanup()
{
    PriToNamesIter it = m_mapPriNames.begin();
    PriToNamesIter itEnd = m_mapPriNames.end();

    while (it != itEnd)
    {
        delete (*it).second;
        ++it;
    }
    m_mapPriNames.clear();

    m_listPriority.clear();

    delete [] m_ppList;
    m_ppList = NULL;
}

/*
Routine Description: 

Name:

    COrderNameList::EndCreation

Functionality:

    As name lists are added, we don't sort them (by priority). This function
    is the trigger for such sorting. You must call this function after all names
    lists are added.

Virtual:
    
    No

Arguments:

    None.

Return Value:

    Success: various success code. No guarantee it will be WBEM_NO_ERROR. Use SUCCEEDED(hr) to test.

    Failure: various failure code. It means the sorting effort has failed.

Notes:

*/

HRESULT 
COrderNameList::EndCreation () 
{
    m_listPriority.sort();

    //
    // now we are going to create an array for easy management.
    // Memory resource is not managed by m_ppList. It's managed by the map and the m_listPriority.
    // m_ppList is merely a array (of size m_listPriority.size()) of pointers.
    //

    delete [] m_ppList;
    m_ppList = new CNameList*[m_listPriority.size()];

    if (m_ppList == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // now build the list. Since we have sorted the priority list,
    // it has the natural order!
    //

    ListIter it = m_listPriority.begin();
    ListIter itEnd = m_listPriority.end();

    int iIndex = 0;
    while (it != itEnd)
    {
        PriToNamesIter itList = m_mapPriNames.find(*it);

        if (itList != m_mapPriNames.end())
        {
            m_ppList[iIndex] = (*itList).second;
        }
        else
        {
            m_ppList[iIndex] = NULL;
        }

        ++it;
        ++iIndex;
    }

    return WBEM_NO_ERROR;
}

/*
Routine Description: 

Name:

    COrderNameList::CreateOrderList

Functionality:

    Given a priority, together with its list information string, this will add
    a CNameList object to our map.

Virtual:
    
    No

Arguments:

    dwPriority      - The priority value.

    pszListInfo     - string containing the order information. The names are separated by
                      wchCookieSep (colon char ':').

Return Value:

    Success: WBEM_NO_ERROR.

    Failure: various failure code. It means the creation has failed.

Notes:
    (1) This function merely pushes the created CNameList to the map and the priority
        to the list. It doesn't sort the list. So, this is a function a caller calls
        amid its creation. EndCreation does that sorting.
*/

HRESULT 
COrderNameList::CreateOrderList (
    IN DWORD dwPriority,
    IN LPCWSTR pszListInfo
    )
{
    if (pszListInfo == NULL || *pszListInfo == L'\0')
    {
        return WBEM_S_FALSE;
    }

    HRESULT hr = WBEM_S_FALSE;

    CNameList* pTheList = new CNameList;
    if (pTheList == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // pszCur is the current point of parsing
    //

    LPCWSTR pszCur = pszListInfo;

    //
    // pszNext is the next token's point of the current parsing
    //

    LPCWSTR pszNext = pszCur;

    while (*pszNext != L'\0')
    {
        //
        // seek to the separater
        //

        while (*pszNext != L'\0' && *pszNext != wchCookieSep)
        {
            ++pszNext;
        }

        int iLen = pszNext - pszCur;
        if (iLen > 0)
        {
            LPWSTR pszName = new WCHAR[iLen + 1];

            if (pszName == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                break;
            }

            //
            // copy, but no white spaces
            //

            ::TrimCopy(pszName, pszCur, iLen);

            //
            // if we have a non-empty name, then add to our list
            //

            if (*pszName == L'\0')
            {
                delete [] pszName;
            }
            else    
            {
                //
                // give it to the list and the list manages the memory from this point
                //

                pTheList->m_vList.push_back(pszName);
            }
        }

        //
        // either skip wchNameSep or stop
        //

        if (*pszNext == wchCookieSep)
        {
            ++pszNext;
        }
        else if (*pszNext == L'\0')
        {
            //
            // end
            //

            break;
        }
        else
        {
            hr = WBEM_E_INVALID_SYNTAX;
            break;
        }

        pszCur = pszNext;
    }

    //
    // if failed
    //

    if (FAILED(hr))
    {
        delete pTheList;
    }
    else if (pTheList->m_vList.size() == 0)
    { 
        //
        // nothing ahs been added
        //

        hr = WBEM_S_FALSE;
    }
    else
    {
        //
        // we need to push this to our map and list
        //

        hr = WBEM_NO_ERROR;
        m_mapPriNames.insert(MapPriorityToNames::value_type(dwPriority, pTheList));
        m_listPriority.insert(m_listPriority.end(), dwPriority);
    }

    return hr;
}

/*
Routine Description: 

Name:

    COrderNameList::GetNext

Functionality:

    Enumerating what is managed by the class.

Virtual:
    
    No

Arguments:

    ppList          - Receives the CNameList of the enumeration.

    pdwEnumHandle   - in-bound value == where to start the enumeration. Out-bound value ==
                      where to start for the caller's next enumeration.

Return Value:

    Success: (1) WBEM_NO_ERROR if the enumeration is successful.
             (2) WBEM_S_NO_MORE_DATA if there is no more data.

    Failure: WBEM_E_INVALID_PARAMETER.

Notes:
    (1) Internally, the pdwEnumHandle is used as the index. But it is an opaque data to caller.
    (2) For maximum robustness, you should also check against *ppList == NULL.
    (3) As the parameter indicates, the returned *ppList must not be deleted by caller.
*/

HRESULT 
COrderNameList::GetNext (
    IN const CNameList  ** ppList,
    IN OUT DWORD        *  pdwEnumHandle
    )const
{
    if (ppList == NULL || pdwEnumHandle == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *ppList = NULL;

    HRESULT hr = WBEM_NO_ERROR;

    if (m_ppList && *pdwEnumHandle < m_listPriority.size())
    {
        *ppList = m_ppList[*pdwEnumHandle];
        ++(*pdwEnumHandle);
    }
    else
    {
        *ppList = NULL;
        hr = WBEM_S_NO_MORE_DATA;
    }

    return hr;
}

/*
Routine Description: 

Name:

    CSequencer::GetOrderList

Functionality:

    Access to the COrderNameList object. Caller will use this object directly.

Virtual:
    
    No

Arguments:

    pList   - Receives the COrderNameList.

Return Value:

    WBEM_NO_ERROR.

Notes:
    (1) As the parameter indicates, the returned *pList must not be deleted by caller.
*/

HRESULT 
CSequencer::GetOrderList (
    OUT const COrderNameList** pList
    )
{
    *pList = &m_ClassList;
    return WBEM_NO_ERROR;
}


/*
Routine Description: 

Name:

    CSequencer::Create

Functionality:

    This creates the SCE namespace-wise sequencing order for embedding classes, plus
    template (pszStore) wise class ordering.

    As indicated before, template-wise class ordering takes precedence over namespace-wise
    class ordering.

Virtual:
    
    No

Arguments:

    pNamespace   - The namespace pointer we rely on to query Sce_Sequence instances.

    pszStore    - the store's path

Return Value:

    Success: various success code. Use SUCCEEDED(hr) to test.
    Failure: various failure code. All means that the sequencer can't be created.

Notes:
    (1) As the parameter indicates, the returned *pList must not be deleted by caller.
*/
//--------------------------------------------------------------------
// we need to query all instances of Sce_Sequence class and then
// build our class list for each namespace. The ordering of
// classes is determined by Sce_Sequence's priority member,
// The smaller of priority value, the higher its priority
//--------------------------------------------------------------------
HRESULT 
CSequencer::Create (
    IN IWbemServices    * pNamespace,
    IN LPCWSTR            pszStore,
    IN LPCWSTR            pszMethod
    )
{
    if (pNamespace == NULL || pszMethod == NULL || *pszMethod == L'\0')
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // need the template sequencing first. This sequencing order, if present, will take precedence
    // over the template independent sequencing.
    //

    //
    // Prepare a store (for persistence) for this store path (file)
    //

    CSceStore SceStore;
    HRESULT hr = SceStore.SetPersistPath(pszStore);
    if (FAILED(hr))
    {
        return hr;
    }

    // we just need to read ClassOrder string out.
    LPWSTR pszTemplateClassOrder = NULL;
    DWORD dwRead = 0;

    //
    // try to create a template-wise class order. Since such an order may not exist,
    // we will tolerate WBEM_E_NOT_FOUND.
    // Need to free the pszTemplateClassOrder.
    //

    hr = SceStore.GetPropertyFromStore(SCEWMI_CLASSORDER_CLASS, pClassOrder, &pszTemplateClassOrder, &dwRead);

    if (hr == WBEM_E_NOT_FOUND)
    {
        hr = WBEM_NO_ERROR;
    }
    else if (FAILED(hr))
    {
        return hr;
    }

    //
    // try to get all sequencing instances.
    //

    LPCWSTR pszQueryFmt = L"SELECT * FROM Sce_Sequence WHERE Method=\"%s\"";
    DWORD dwFmtLen = wcslen(pszQueryFmt);
    DWORD dwClassLen = wcslen(pszMethod);

    //
    // don't forget to ::SysFreeString of this bstrQuery
    //

    BSTR bstrQuery= ::SysAllocStringLen(NULL, dwClassLen + dwFmtLen + 1);
    if ( bstrQuery == NULL ) 
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    
    CComPtr<IEnumWbemClassObject> srpEnum;
    if (SUCCEEDED(hr))
    {
        //
        // this won't overrun the buffer, total length allocated is greater than needed
        //

        wsprintf(bstrQuery, pszQueryFmt, pszMethod);

        hr = pNamespace->ExecQuery(L"WQL", bstrQuery, WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &srpEnum);

        //
        // free the bstr
        //

        ::SysFreeString(bstrQuery);
    }

    //
    // the previous query will allow us to enumerate through all Sce_Sequence instances
    //

    if (SUCCEEDED(hr))
    {
        //
        // ready to create the list. We will follow the usage of COrderNameList
        // to call BeginCreation first and end all creation by EndCreation.
        //

        m_ClassList.BeginCreation();

        //
        // now, if there is a template-wise sequencing, then, use it
        // we use absolute priority 0 for this sequencing list. All other
        // sequencing list is 1 lower than what they claimed themselves
        //

        if (pszTemplateClassOrder != NULL)
        {
            //
            // we will allow this to fail
            //

            m_ClassList.CreateOrderList(0, pszTemplateClassOrder);
        }

        //
        // CScePropertyMgr helps us to access WMI object's properties.
        //

        CScePropertyMgr ScePropMgr;

        DWORD dwPriority;

        //
        // this will hold the individual Sce_Sequence instance.
        //

        CComPtr<IWbemClassObject> srpObj;
        ULONG nEnum = 0;
        hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &nEnum);

        //
        // for each Sce_Sequence, let's parse its order property to build a list
        //

        while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA && srpObj)
        {
            CComBSTR bstrSeq;

            //
            // attach a different WMI object to the property mgr.
            // This will always succeed.
            //

            ScePropMgr.Attach(srpObj);
            dwPriority = 0;

            //
            // we must have priority property, it's a key property
            //

            hr = ScePropMgr.GetProperty(L"Priority", &dwPriority);
            if (SUCCEEDED(hr))
            {
                //
                // we will ignore those instances that has no "sequence" property
                //

                if (SUCCEEDED(ScePropMgr.GetProperty(L"Order", &bstrSeq)))
                {
                    //
                    // ask the list to add the names encoded in this string. Don't cleanup the existing ones.
                    // add 1 more to the claimed priority so that no Sce_Sequence instance can really have
                    // 0 (highest) priority. We reserve 0 for the template's sequencing list.
                    //

                    dwPriority = (dwPriority + 1 == 0) ? dwPriority : dwPriority + 1;
                    hr = m_ClassList.CreateOrderList(dwPriority, bstrSeq);
                }
            }

            if (SUCCEEDED(hr))
            {   
                //
                // get it ready to be reused
                //

                srpObj.Release();

                //
                // ready to loop to the next item
                //

                hr = srpEnum->Next(WBEM_INFINITE, 1, &srpObj, &nEnum);
            }
        }

        //
        // this is the good result
        //

        if (hr == WBEM_S_NO_MORE_DATA)
        {
            hr = WBEM_NO_ERROR;
        }

        //
        // EndCreation will only return WBEM_E_OUT_OF_MEMORY or WBEM_NO_ERROR
        //

        if (WBEM_E_OUT_OF_MEMORY == m_ClassList.EndCreation())
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    delete [] pszTemplateClassOrder;
 
    return hr;
}

//=========================================================================
// implementation for template-wise class sequencing
//=========================================================================

/*
Routine Description: 

Name:

    CClassOrder::CClassOrder

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CClassOrder::CClassOrder (
    IN ISceKeyChain *pKeyChain, 
    IN IWbemServices *pNamespace,
    IN IWbemContext *pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{
}

/*
Routine Description: 

Name:

    CClassOrder::~CClassOrder

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/

CClassOrder::~CClassOrder()
{
}

/*
Routine Description: 

Name:

    CClassOrder::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_ClassOrder,
    which is persistence oriented, this will cause the Sce_ClassOrder object's property 
    information to be saved in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst       - COM interface pointer to the WMI class (Sce_ClassOrder) object.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                    WMI may mandate it (not now) in the future. But we never construct
                    such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

*/

HRESULT CClassOrder::PutInst (
    IN IWbemClassObject * pInst, 
    IN IWbemObjectSink  * pHandler,
    IN IWbemContext     * pCtx
    )
{

    //
    // CScePropertyMgr helps us to access WMI object's properties
    // create an instance and attach the WMI object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pInst);

    //
    // must have a store path
    //

    CComBSTR vbstrStorePath;
    HRESULT hr = ScePropMgr.GetProperty(pStorePath, &vbstrStorePath);
    if (SUCCEEDED(hr))
    {
        CComBSTR bstrOrder;
        hr = ScePropMgr.GetProperty(pClassOrder, &bstrOrder);

        //
        // if everything is fine, we need to save it
        //

        if (SUCCEEDED(hr))
        {
            //
            // Attach the WMI object instance to the store and let the store know that
            // it's store is given by the pStorePath property of the instance.
            //

            CSceStore SceStore;
            SceStore.SetPersistProperties(pInst, pStorePath);

            DWORD dwDump;

            //
            // For a new .inf file. Write an empty buffer to the file
            // will creates the file with right header/signature/unicode format
            // this is harmless for existing files.
            // For database store, this is a no-op.
            //

            hr = SceStore.WriteSecurityProfileInfo(AreaBogus, (PSCE_PROFILE_INFO)&dwDump, NULL, false);

            //
            // also, we need to write it to attachment section because it's not a native core object
            // without an entry in the attachment section, inf file tempalte can't be imported to
            // database stores. For database store, this is no-op
            //

            if (SUCCEEDED(hr))
            {
                hr = SceStore.WriteAttachmentSection(SCEWMI_CLASSORDER_CLASS, pszAttachSectionValue);
            }

            //
            // final save
            //

            if (SUCCEEDED(hr))
            {
                hr = SceStore.SavePropertyToStore(SCEWMI_CLASSORDER_CLASS, pClassOrder, (LPCWSTR)bstrOrder);
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CClassOrder::CreateObject

Functionality:
    
    Create WMI objects (Sce_ClassOrder). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.

    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT CClassOrder::CreateObject (
    IN IWbemObjectSink * pHandler, 
    IN ACTIONTYPE        atAction
    )
{
    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Delete a single instance ACTIONTYPE_DELETE
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET     != atAction &&
         ACTIONTYPE_DELETE  != atAction &&
         ACTIONTYPE_QUERY   != atAction ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // We must have the pStorePath property because that is where
    // our instance is stored. 
    // m_srpKeyChain->GetKeyPropertyValue WBEM_S_FALSE if the key is not recognized
    // So, we need to test against WBEM_S_FALSE if the property is mandatory
    //

    CComVariant varStorePath;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(pStorePath, &varStorePath);

    if (SUCCEEDED(hr) && hr != WBEM_S_FALSE && varStorePath.vt == VT_BSTR)
    {
        //
        // Prepare a store (for persistence) for this store path (file)
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistPath(varStorePath.bstrVal);

        if ( SUCCEEDED(hr) ) 
        {
            //
            // make sure the store (just a file) really exists. The raw path
            // may contain env variables, so we need the expanded path
            //

            DWORD dwAttrib = GetFileAttributes(SceStore.GetExpandedPath());

            //
            // if the file exist
            //

            if ( dwAttrib != -1 ) 
            {
                if ( ACTIONTYPE_DELETE == atAction )
                {
                    //
                    // just save a blank section because we only has one instance
                    //

                    hr = SceStore.SavePropertyToStore(SCEWMI_CLASSORDER_CLASS, (LPCWSTR)NULL, (LPCWSTR)NULL);
                }
                else
                {
                    //
                    // we need to read out the ClassOrder property
                    //

                    LPWSTR pszClassOrder = NULL;    
                    DWORD dwRead = 0;

                    //
                    // need to free pszClassOrder!
                    //

                    hr = SceStore.GetPropertyFromStore(SCEWMI_CLASSORDER_CLASS, pClassOrder, &pszClassOrder, &dwRead);

                    //
                    // read is successful
                    //

                    if (SUCCEEDED(hr) && dwRead > 0)
                    {
                        //
                        // create a blank new instance to fill in properties
                        //

                        CComPtr<IWbemClassObject> srpObj;
                        hr = SpawnAnInstance(&srpObj);

                        //
                        // if successful, then ready to fill in the properties
                        //

                        if (SUCCEEDED(hr))
                        {
                            //
                            // CScePropertyMgr helps us to access WMI object's properties
                            // create an instance and attach the WMI object to it.
                            // This will always succeed.
                            //

                            CScePropertyMgr ScePropMgr;
                            ScePropMgr.Attach(srpObj);
                            hr = ScePropMgr.PutProperty(pStorePath, SceStore.GetExpandedPath());

                            if (SUCCEEDED(hr))
                            {
                                hr = ScePropMgr.PutProperty(pClassOrder, pszClassOrder);
                            }
                        }

                        //
                        // pass the new instance to WMI if we are successful
                        //

                        if (SUCCEEDED(hr))
                        {
                            hr = pHandler->Indicate(1, &srpObj);
                        }

                        delete [] pszClassOrder;
                    }
                }
            } 
            else
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // do the necessary gestures to WMI.
        // the use of WBEM_STATUS_REQUIREMENTS in SetStatus is not documented by WMI
        // at this point. Consult WMI team for detail if you suspect problems with
        // the use of WBEM_STATUS_REQUIREMENTS
        //

        if ( ACTIONTYPE_QUERY == atAction )
        {
            pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_FALSE, NULL, NULL);
        }
        else if (ACTIONTYPE_GET  == atAction)
        {
            pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\sceprov.h ===
//***************************************************************************
//
//  sceprov.h
//
//  Module: SCE WMI provider code
//
//  Purpose: Genral purpose include file.
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//***************************************************************************
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _SceProv_H_
#define _SceProv_H_

#include "precomp.h"
#include <wbemidl.h>
#include <wbemprov.h>
#include <eh.h>
#include "wmiutils.h"

//
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
//

extern CComModule _Module;

//
// make these global objects available to those who include this header file
//

extern CComBSTR g_bstrTranxID;

extern CComBSTR g_bstrDefLogFilePath;

#include <atlcom.h>

#include "resource.h"

typedef LPVOID * PPVOID;

//
// integer value reserved for null
//

#define SCE_NULL_INTEGER (DWORD)-2

//
// struct that encapulate the profile handle
//

typedef struct _tag_SCEP_HANDLE
{
    LPVOID hProfile;    // SCE_HANDLE
    PWSTR SectionName;  // Section name.
} SCEP_HANDLE, *LPSCEP_HANDLE;

//
// action type enum
//

typedef enum tagACTIONTYPE
{
        ACTIONTYPE_ENUM =       0,
        ACTIONTYPE_GET =        1,
        ACTIONTYPE_QUERY =      2,
        ACTIONTYPE_DELETE =     3

} ACTIONTYPE;

//
// method type enum
//

typedef enum tagMETHODTYPE
{
        METHODTYPE_IMPORT =     0,
        METHODTYPE_EXPORT =     1,
        METHODTYPE_APPLY =      2

} METHODTYPE;

//
// store type enum
//

typedef enum tagSCESTORETYPE
{
    SCE_STORE_TYPE_INVALID      = 0,
    SCE_STORE_TYPE_TEMPLATE     = 1,
    SCE_STORE_TYPE_CONFIG_DB    = 2,            // currently not supported
    SCE_STORE_TYPE_STREAM       = 0x00010000,   // currently not supported
} SCE_STORE_TYPE;

//
// some constants
//

#define SCE_OBJECT_TYPE_FILE        0
#define SCE_OBJECT_TYPE_KEY         1

#define SCE_AUDIT_EVENT_SUCCESS     (0x00000001L)
#define SCE_AUDIT_EVENT_FAILURE     (0x00000002L)

#define SCEWMI_TEMPLATE_CLASS       L"Sce_Template"
#define SCEWMI_PASSWORD_CLASS       L"Sce_PasswordPolicy"
#define SCEWMI_LOCKOUT_CLASS        L"Sce_AccountLockoutPolicy"
#define SCEWMI_OPERATION_CLASS      L"Sce_Operation"
#define SCEWMI_DATABASE_CLASS       L"Sce_Database"
#define SCEWMI_KERBEROS_CLASS       L"Sce_KerberosPolicy"
#define SCEWMI_ATTACHMENT_CLASS     L"Sce_Pod"
#define SCEWMI_AUDIT_CLASS          L"Sce_AuditPolicy"
#define SCEWMI_EVENTLOG_CLASS       L"Sce_EventLog"
#define SCEWMI_REGVALUE_CLASS       L"Sce_RegistryValue"
#define SCEWMI_OPTION_CLASS         L"Sce_SecurityOptions"
#define SCEWMI_FILEOBJECT_CLASS     L"Sce_FileObject"
#define SCEWMI_KEYOBJECT_CLASS      L"Sce_KeyObject"
#define SCEWMI_SERVICE_CLASS        L"Sce_SystemService"
#define SCEWMI_RIGHT_CLASS          L"Sce_UserPrivilegeRight"
#define SCEWMI_GROUP_CLASS          L"Sce_RestrictedGroup"
#define SCEWMI_KNOWN_REG_CLASS      L"Sce_KnownRegistryValues"
#define SCEWMI_KNOWN_PRIV_CLASS     L"Sce_SupportedPrivileges"
#define SCEWMI_POD_CLASS            L"Sce_Pod"
#define SCEWMI_PODDATA_CLASS        L"Sce_PodData"
#define SCEWMI_LOG_CLASS            L"Sce_ConfigurationLogRecord"
#define SCEWMI_EMBED_BASE_CLASS     L"Sce_EmbedFO"
#define SCEWMI_LINK_BASE_CLASS      L"Sce_LinkFO"
#define SCEWMI_SEQUENCE             L"Sce_Sequence"
#define SCEWMI_LOGOPTIONS_CLASS     L"Sce_LogOptions"
#define SCEWMI_CLASSORDER_CLASS     L"Sce_ClassOrder"
#define SCEWMI_TRANSACTION_ID_CLASS L"Sce_TransactionID"
#define SCEWMI_TRANSACTION_TOKEN_CLASS L"Sce_TransactionToken"

//
// extension class type enum
//

typedef enum tagExtClassType
{
EXT_CLASS_TYPE_INVALID,
EXT_CLASS_TYPE_EMBED,
EXT_CLASS_TYPE_LINK     // not supported at this point
} EnumExtClassType;

//====================================================================================

/*

Class description
    
    Naming:

        CForeignClassInfo stands for Foreign Class Information.
    
    Base class:

        None
    
    Purpose of class:

        (1) This class encapulates information regarding a foreign class
    
    Design:

        (1) foreign provider's namespace.

        (2) foreign class's name.

        (3) how we are seeing this class (whether embedding or linking).
            Currently, we only support embedding.

        (4) Our embedding class's key property names. This is needed for easy comparison.
            there is a need to know if a particular instance already exists. Knowing this
            is not a very easy work. Theoretically, we know an instance when we know its
            key. WMI encapulates key notation in terms of path (a string). However, WMI
            doesn't return a canonical form of the path. I've observed that when using
            boolean property has part of the key, WMI sometimes returns the path using
            boolPropertyName=1, while it returns boolPropertyName=TRUE at other times.
            This forces us to compare instances using its key property values.
            Currently, the key property names are populated inside 
            CExtClasses::PopulateKeyPropertyNames
    
    Use:

        This class is pretty much a wrapper to ease memory management. Since it's members will be
        used extensively for dealing with embedded classes, we make all them public.
    
*/

class CForeignClassInfo
{
public:
    CForeignClassInfo() 
        : bstrNamespace(NULL), 
          bstrClassName(NULL), 
          dwClassType(EXT_CLASS_TYPE_INVALID),
          m_pVecKeyPropNames(NULL)
    {
    }

    ~CForeignClassInfo();

    void CleanNames();

    BSTR bstrNamespace;

    BSTR bstrClassName;

    EnumExtClassType dwClassType;

    std::vector<BSTR>* m_pVecKeyPropNames;
};

//====================================================================================

//
// trivial wrapper just to ease the memory management and initialization
//

class CPropValuePair
{
public:
    CPropValuePair::CPropValuePair() : pszKey(NULL)
    {
        ::VariantInit(&varVal);
    }
    CPropValuePair::~CPropValuePair()
    {
        delete [] pszKey;
        ::VariantClear(&varVal);
    }

    LPWSTR pszKey;
    VARIANT varVal;
};

//====================================================================================

//
// this trivial wrapper class is to make it easy for an unique global instance. No other purpose
//

class CCriticalSection
{
public:
    CCriticalSection();
    ~CCriticalSection();
    void Enter();
    void Leave();
private:
    CRITICAL_SECTION m_cs;
};

//====================================================================================

//
// Our unique instance of critical section wrapper.
// make it visible to those who include this header
//

extern CCriticalSection g_CS;

const DWORD SCE_LOG_Error_Mask = 0x0000FFFF;
const DWORD SCE_LOG_Verbose_Mask = 0xFFFF0000;

//====================================================================================

/*

    This struct determines how logging is done. Currently, logging comes in two
    separate aspects: 

         (1) types of errors (success) to log (SCE_LOG_Error_Mask), and 

         (2) detail level of logging (SCE_LOG_Verbose_Mask)

    We use bit patterns to control these two aspects

*/

typedef enum tag_SCE_LOG_OPTION
{
    Sce_log_None        = 0x00000000,   // log nothing
    Sce_log_Error       = 0x00000001,   // log errors
    Sce_log_Success     = 0x00000002,   // log success
    Sce_log_All         = Sce_log_Error | Sce_log_Success,
    Sce_log_Verbose     = 0x00010000,   // log verbose
    Sce_Log_Parameters  = 0x00100000,   // log parameters (in and out)
};

typedef DWORD SCE_LOG_OPTION;

//====================================================================================

//
// this class determines how we should log errors
//

class CLogOptions
{
public:
    CLogOptions() : m_dwOption(Sce_log_Error){}

    void GetLogOptionsFromWbemObject(IWbemServices* pNamespace);

    SCE_LOG_OPTION GetLogOption()const 
        {
            return m_dwOption;
        }

private:
    SCE_LOG_OPTION m_dwOption; 
};

//
// unique global instance to the log options
// must protect its access for thread safety
//

extern CLogOptions g_LogOption;

//====================================================================================

//
// case insensitive comparison for our map functor
//

template< class T>
struct strLessThan : public std::binary_function< T, T, bool >
{
    bool operator()( const T& X, const T& Y ) const
    {
        return ( _wcsicmp( X, Y ) < 0 );
    }

};

//====================================================================================

class CHeap_Exception
{
public:

        enum HEAP_ERROR
        {
                E_ALLOCATION_ERROR = 0 ,
                E_FREE_ERROR
        };

private:

        HEAP_ERROR m_Error;

public:

        CHeap_Exception ( HEAP_ERROR e ) : m_Error ( e ) {}
        ~CHeap_Exception () {}

        HEAP_ERROR GetError() { return m_Error ; }
} ;

//====================================================================================

/*

Class description
    
    Naming: 

        CSceWmiProv stands for SCE Provider for WMI.
    
    Base class: 

        (1) CComObjectRootEx for threading model and IUnknown.

        (2) CComCoClass for class factory support.

        (3) IWbemServices and IWbemProviderInit for being a WMI provider.
    
    Purpose of class:

        (1) This class is what makes our dll a WMI provider.
        
        (2) Cache m_srpNamespace.
    
    Design:

        (1) We rely on ATL for support of a Multi-Threaded Apartment server.
        
        (2) We rely on ATL for class factory support.
        
        (3) We rely on ATL for IUnknown support (using BEGIN_COM_MAP).
        
        (4) We rely on ATL for script registration (.rgs) for our dll.
        
        (5) We don't implement most of the IWbemServices functionalities.
            See all those WBEM_E_NOT_SUPPORTED return values.
    
    Use:

        This class is pretty much a wrapper to ease memory management. Since it's members will be
        used extensively for dealing with embedded classes, we make all them public.
    
    Notes: 

        (1) See winnt.h for many of the typedef's like STDMETHODCALLTYPE

        (2) This class is not intended for any further derivation. That is why we don't even bother
            to have a virtual destructor.

        (3) For security reasons, all WMI calls (IWbemServices or IWbemProviderInit) should be impersonated.

*/ 

class CSceWmiProv 
: public CComObjectRootEx<CComMultiThreadModel>,
  public CComCoClass<CSceWmiProv, &CLSID_SceProv>,
  public IWbemServices, 
  public IWbemProviderInit
{
public:

//
// determines which interfaces are exposed
//

BEGIN_COM_MAP(CSceWmiProv)
    COM_INTERFACE_ENTRY(IWbemServices)
    COM_INTERFACE_ENTRY(IWbemProviderInit)
END_COM_MAP()

//
// registry script support
//

DECLARE_REGISTRY_RESOURCEID(IDR_SceProv)

        //
        // methods of IWbemProviderInit
        //

        HRESULT STDMETHODCALLTYPE Initialize(
             IN LPWSTR pszUser,
             IN LONG lFlags,
             IN LPWSTR pszNamespace,
             IN LPWSTR pszLocale,
             IN IWbemServices *pNamespace,
             IN IWbemContext *pCtx,
             IN IWbemProviderInitSink *pInitSink
             );

        //
        // methods of IWbemServices
        //

        //
        // the following methods are supported by our provider
        //

        HRESULT STDMETHODCALLTYPE GetObjectAsync(
            IN const BSTR ObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler
            );

        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
            IN const BSTR ObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler
            );

        HRESULT STDMETHODCALLTYPE PutInstanceAsync(
            IN IWbemClassObject __RPC_FAR *pInst,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler
            );

        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync(
            IN const BSTR Class,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler
            );

        HRESULT STDMETHODCALLTYPE ExecQueryAsync(
            IN const BSTR QueryLanguage,
            IN const BSTR Query,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler
            );

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            IN const BSTR, 
            IN const BSTR, 
            IN long lFlags,
            IN IWbemContext __RPC_FAR * pCtx, 
            IN IWbemClassObject __RPC_FAR * pInParams, 
            IN IWbemObjectSink __RPC_FAR * pResponse
            );

        //
        // the following methods are NOT supported by our provider
        //

        HRESULT STDMETHODCALLTYPE OpenNamespace(
            IN const BSTR Namespace,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN OUT IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            IN OUT IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE CancelAsyncCall(
            IN IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE QueryObjectSink(
            IN long lFlags,
            OUT IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE GetObject(
            IN const BSTR ObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN OUT IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            IN OUT IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE PutClass(
            IN IWbemClassObject __RPC_FAR *pObject,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN OUT IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE PutClassAsync(
            IN IWbemClassObject __RPC_FAR *pObject,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE DeleteClass(
            IN const BSTR Class,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN OUT IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE DeleteClassAsync(
            IN const BSTR Class,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE CreateClassEnum(
            IN const BSTR Superclass,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            OUT IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(
            IN const BSTR Superclass,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE PutInstance(
            IN IWbemClassObject __RPC_FAR *pInst,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN OUT IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE DeleteInstance(
            IN const BSTR ObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN OUT IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE CreateInstanceEnum(
            IN const BSTR Class,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            OUT IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE ExecQuery(
            IN const BSTR QueryLanguage,
            IN const BSTR Query,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            OUT IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE ExecNotificationQuery(
            IN const BSTR QueryLanguage,
            IN const BSTR Query,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            OUT IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync(
            IN const BSTR QueryLanguage,
            IN const BSTR Query,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE ExecMethod( 
            IN const BSTR, 
            IN const BSTR, 
            IN long lFlags, 
            IN IWbemContext*,
            IN IWbemClassObject*, 
            OUT IWbemClassObject**, 
            OUT IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

private:

        CComPtr<IWbemServices> m_srpNamespace;
        static CHeap_Exception m_he;
};

typedef CSceWmiProv *PCSceWmiProv;

//
// some global functions. See their definition for details.
//

HRESULT CheckImpersonationLevel();

HRESULT CheckAndExpandPath(LPCWSTR pszIn, BSTR *pszOut, BOOL *pbSdb);

HRESULT MakeSingleBackSlashPath(LPCWSTR pszIn, WCHAR wc, BSTR *pszrOut);

HRESULT ConvertToDoubleBackSlashPath(LPCWSTR strIn, WCHAR wc, BSTR *pszOut);

HRESULT GetWbemPathParser(IWbemPath** ppPathParser);

HRESULT GetWbemQuery(IWbemQuery** ppQuery);

HRESULT CreateDefLogFile(BSTR* pbstrDefLogFilePath);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\service.cpp ===
// service.cpp: implementation of the CGeneralService class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "service.h"
#include "persistmgr.h"
#include <io.h>
#include "requestobject.h"

const DWORD dwDefaultStartupType = 2;

/*
Routine Description: 

Name:

    CGeneralService::CGeneralService

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CGeneralService::CGeneralService (
    IN ISceKeyChain     * pKeyChain, 
    IN IWbemServices    * pNamespace,
    IN IWbemContext     * pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{

}

/*
Routine Description: 

Name:

    CGeneralService::~CGeneralService

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/

CGeneralService::~CGeneralService()
{

}

/*
Routine Description: 

Name:

    CGeneralService::CreateObject

Functionality:
    
    Create WMI objects (Sce_SystemService). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT 
CGeneralService::CreateObject (
    IN IWbemObjectSink * pHandler, 
    IN ACTIONTYPE        atAction
    )
{
    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Delete a single instance ACTIONTYPE_DELETE
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET     != atAction &&
         ACTIONTYPE_DELETE  != atAction &&
         ACTIONTYPE_QUERY   != atAction ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // We must have the pStorePath property because that is where
    // our instance is stored. 
    // m_srpKeyChain->GetKeyPropertyValue WBEM_S_FALSE if the key is not recognized
    // So, we need to test against WBEM_S_FALSE if the property is mandatory
    //

    CComVariant varStorePath;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(pStorePath, &varStorePath);
    CComVariant varService;

    if (SUCCEEDED(hr) && hr != WBEM_S_FALSE)
    {
        hr = m_srpKeyChain->GetKeyPropertyValue(pService, &varService);
        
        //
        // unless it's querying, no complete key info means we can't get the single instance
        //

        if (hr == WBEM_S_FALSE && (ACTIONTYPE_QUERY != atAction) ) 
        {
            hr = WBEM_E_NOT_FOUND;
        }
    }
    else if (hr == WBEM_S_FALSE)
    {
        hr = WBEM_E_NOT_FOUND;
    }

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // has a valid store path
    //

    if (varStorePath.vt == VT_BSTR)
    {
        //
        // Prepare a store (for persistence) for this store path (file)
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistPath(varStorePath.bstrVal);

        if ( SUCCEEDED(hr) ) 
        {
            //
            // make sure the store (just a file) really exists. The raw path
            // may contain env variables, so we need the expanded path
            //

            DWORD dwAttrib = GetFileAttributes(SceStore.GetExpandedPath());

            if ( dwAttrib != -1 ) 
            {

                //
                // make sure our store is valid
                //

                if ( SceStore.GetStoreType() < SCE_INF_FORMAT ||
                     SceStore.GetStoreType() > SCE_JET_ANALYSIS_REQUIRED ) 
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                }

                if ( SUCCEEDED(hr) ) 
                {
                    if ( ACTIONTYPE_DELETE == atAction )
                    {
                        hr = DeleteInstance(pHandler, &SceStore, (varService.vt == VT_BSTR) ? varService.bstrVal : NULL);
                    }
                    else 
                    {

                        BOOL bPostFilter=TRUE;
                        DWORD dwCount = 0;
                        m_srpKeyChain->GetKeyPropertyCount(&dwCount);

                        if ( varService.vt == VT_EMPTY && dwCount == 1 ) 
                        {
                            //
                            // something else is specified in the path
                            // have filter on
                            //

                            bPostFilter = FALSE;
                        }

                        hr = ConstructInstance(pHandler, 
                                               &SceStore, 
                                               varStorePath.bstrVal, 
                                               (varService.vt == VT_BSTR) ? varService.bstrVal : NULL, 
                                               bPostFilter);
                    }
                }
            } 
            else
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CGeneralService::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_SystemService,
    which is persistence oriented, this will cause the Sce_SystemService object's property 
    information to be saved in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst       - COM interface pointer to the WMI class (Sce_SystemService) object.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

*/

HRESULT 
CGeneralService::PutInst (
    IN IWbemClassObject    * pInst,
    IN IWbemObjectSink     * pHandler,
    IN IWbemContext        * pCtx
    )
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    CComBSTR bstrObjPath;
    CComBSTR bstrSDDL;
    DWORD mode;

    CSceStore SceStore;

    //
    // CScePropertyMgr helps us to access WMI object's properties
    // create an instance and attach the WMI object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pInst);

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    // get service name, can't be NULL
    // no validation is needed because we should allow a template w/ any service defined

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pService, &bstrObjPath));
    if ( hr == WBEM_S_RESET_TO_DEFAULT)
    {
        hr = WBEM_E_ILLEGAL_NULL;
        goto CleanUp;
    }

    //
    // get startuptype, default to 2 (dwDefaultStartupType)
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pStartupMode, &mode));
    if ( hr == WBEM_S_RESET_TO_DEFAULT)
        mode = dwDefaultStartupType;

    //
    // get SDDLString, can't be NULL
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pSDDLString, &bstrSDDL));
    if ( hr == WBEM_S_RESET_TO_DEFAULT)
    {
        hr = WBEM_E_ILLEGAL_NULL;
        goto CleanUp;
    }

    //
    // Attach the WMI object instance to the store and let the store know that
    // it's store is given by the pStorePath property of the instance.
    //

    SceStore.SetPersistProperties(pInst, pStorePath);

    //
    // now save the info to file
    //

    hr = SaveSettingsToStore(&SceStore,
                                      bstrObjPath,
                                      mode,
                                      bstrSDDL
                                     );

CleanUp:

    return hr;
}


/*
Routine Description: 

Name:

    CGeneralService::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_SystemService.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszLogStorePath - store path, a key property of Sce_SystemService class.

    wszObjName      - a corresponding key property of Sce_SystemService class.

    bPostFilter     - Controls how WMI will be informed with pHandler->SetStatus.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:

*/

HRESULT CGeneralService::ConstructInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore,
    IN LPCWSTR            wszLogStorePath,
    IN LPCWSTR            wszObjName,
    IN BOOL               bPostFilter
    )
{
    //
    // ask SCE to read a gigantic structure out from the store. Only SCE
    // knows now to release the memory. Don't just delete it! Use our CSceStore
    // to do the releasing (FreeSecurityProfileInfo)
    //

    PSCE_PROFILE_INFO pInfo=NULL;

    //
    // string version of security descriptor
    //

    PWSTR strSD = NULL;

    HRESULT hr = pSceStore->GetSecurityProfileInfo(
                                                   AREA_SYSTEM_SERVICE,
                                                   &pInfo,
                                                   NULL
                                                   );

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // we have to search for the service name in the returned list
    //

    PSCE_SERVICES pInfoService = pInfo->pServices;

    if ( wszObjName )
    {
        while ( pInfoService ) 
        {
            if ( pInfoService->ServiceName == NULL )
            {
                continue;
            }

            if ( _wcsicmp(pInfoService->ServiceName, wszObjName)== 0 ) 
            {
                break;
            }

            pInfoService = pInfoService->Next;
        }

        //
        // if the service information buffer is empty, treat it as "not found"
        //

        if ( pInfoService == NULL ) 
        {
            hr = WBEM_E_NOT_FOUND;
        }
    }

    if ( SUCCEEDED(hr) ) 
    {
        CComBSTR bstrLogOut;
        PSCE_SERVICES pServ = pInfoService;

        //
        // CScePropertyMgr helps us to access WMI object's properties.
        //

        CScePropertyMgr ScePropMgr;

        hr = MakeSingleBackSlashPath(wszLogStorePath, L'\\', &bstrLogOut);

        for ( pServ=pInfoService; pServ != NULL; pServ = pServ->Next ) 
        {

            if ( pServ->General.pSecurityDescriptor ) 
            {
                //
                // convert security descriptor to string
                //

                DWORD dSize=0;
                SCESTATUS rc;

                if ( SCESTATUS_SUCCESS != (rc=SceSvcConvertSDToText(pServ->General.pSecurityDescriptor,
                                                                    pServ->SeInfo,
                                                                    &strSD,
                                                                    &dSize
                                                                    )) ) 
                {
                    //
                    // SCE returned errors needs to be translated to HRESULT.
                    //

                    hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
                    goto CleanUp;
                }
            }

            CComPtr<IWbemClassObject> srpObj;

            //
            // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
            // a "goto CleanUp;" with hr set to the return value from
            // the function (macro parameter)
            //

            SCE_PROV_IfErrorGotoCleanup(SpawnAnInstance(&srpObj));

            //
            // attach a different WMI object to the proeprty mgr.
            // This will always succeed.
            //

            ScePropMgr.Attach(srpObj);

            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pStorePath, bstrLogOut));
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pService, pServ->ServiceName));

            DWORD dwStartUp = pServ->Startup;
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pStartupMode, dwStartUp));

            if ( strSD )
            {
                SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pSDDLString, strSD));
            }

            //
            // do the necessary gestures to WMI.
            // the use of WBEM_STATUS_REQUIREMENTS in SetStatus is not documented by WMI
            // at this point. Consult WMI team for detail if you suspect problems with
            // the use of WBEM_STATUS_REQUIREMENTS
            //

            if ( !bPostFilter ) {
                pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_FALSE, NULL, NULL);
            } else {
                pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);
            }

            //
            // pass the new instance to WMI
            //

            hr = pHandler->Indicate(1, &srpObj);

            if ( wszObjName ) 
            {
                // single instance only
                break;
            }
        }

    }

CleanUp:

    pSceStore->FreeSecurityProfileInfo(pInfo);

    if ( strSD ) 
    {
        LocalFree(strSD);
    }

    return hr;
}


/*
Routine Description: 

Name:

    CGeneralService::DeleteInstance

Functionality:
    
    remove an instance of Sce_SystemService from the specified store.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    pSceStore       - Pointer to our store. It must have been appropriately set up.

    wszObjName      - property of the Sce_SystemService class.

Return Value:

    see SaveSettingsToStore.

Notes:

*/

HRESULT CGeneralService::DeleteInstance (
    IN IWbemObjectSink  * pHandler,
    IN CSceStore        * pSceStore,
    IN LPCWSTR            wszObjName
    )
{
    return SaveSettingsToStore(pSceStore, wszObjName,SCE_NO_VALUE, NULL);
}


/*
Routine Description: 

Name:

    CGeneralService::SaveSettingsToStore

Functionality:
    
    With all the properties of a Sce_SystemService, this function just saves
    the instance properties to our store.

Virtual:
    
    No.
    
Arguments:

    pSceStore   - the store.

    wszObjName  - a corresponding key property of Sce_SystemService class.

    Startup     - another corresponding property of the Sce_SystemService class.

    wszSDDL     - another corresponding property of the Sce_SystemService class.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any error indicates the failure to save the instance.

Notes:
*/

HRESULT CGeneralService::SaveSettingsToStore (
    IN CSceStore    * pSceStore,
    IN LPCWSTR        wszObjName, 
    IN DWORD          Startup, 
    IN LPCWSTR        wszSDDL
    )
{
    DWORD dwDump;

    //
    // For a new .inf file. Write an empty buffer to the file
    // will creates the file with right header/signature/unicode format
    // this is harmless for existing files.
    // For database store, this is a no-op.
    //

    HRESULT hr = pSceStore->WriteSecurityProfileInfo(
                                                    AreaBogus,
                                                    (PSCE_PROFILE_INFO)&dwDump,
                                                    NULL,
                                                    false
                                                    );

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // ask SCE to read a gigantic structure out from the store. Only SCE
    // knows now to release the memory. Don't just delete it! Use our CSceStore
    // to do the releasing (FreeSecurityProfileInfo)
    //

    PSCE_PROFILE_INFO pInfo = NULL;

    hr = pSceStore->GetSecurityProfileInfo(
                                           AREA_SYSTEM_SERVICE,
                                           &pInfo,
                                           NULL
                                           );

    if ( SUCCEEDED(hr) ) 
    {

        //
        // for INF format, we have to search for the servic name in the returned array
        //

        PSCE_SERVICES pInfoService  = pInfo->pServices;
        PSCE_SERVICES pParent       = NULL;
        DWORD i=0;

        while ( pInfoService ) 
        {
            if ( pInfoService->ServiceName == NULL ) 
            {
                continue;
            }

            if ( _wcsicmp(pInfoService->ServiceName, wszObjName)== 0 ) 
            {
                break;
            }
            pParent = pInfoService;
            pInfoService = pInfoService->Next;
        }

        if ( pInfoService ) 
        {
            //
            // find it
            //

            if ( Startup == SCE_NO_VALUE || wszSDDL == NULL ) 
            {
                //
                // delete it
                //

                if ( pParent ) 
                {
                    pParent->Next = pInfoService->Next;
                }
                else 
                {
                    pInfo->pServices = pInfoService->Next;
                }

                //
                // free buffer
                //

                pInfoService->Next = NULL;
                SceFreeMemory(pInfoService, SCE_STRUCT_SERVICES);

            } 
            else 
            {
                //
                // modify it
                //

                pInfoService->Startup = (BYTE)Startup;

                SECURITY_INFORMATION SeInfo=0;
                PSECURITY_DESCRIPTOR pSD=NULL;
                DWORD dSize=0;

                SCESTATUS rc = SceSvcConvertTextToSD ((PWSTR)wszSDDL, &pSD, &dSize, &SeInfo);

                if ( rc == SCESTATUS_SUCCESS && pSD ) 
                {
                    if ( pInfoService->General.pSecurityDescriptor ) 
                    {
                        LocalFree(pInfoService->General.pSecurityDescriptor);
                    }

                    pInfoService->General.pSecurityDescriptor = pSD;
                    pSD = NULL;

                    pInfoService->SeInfo = SeInfo;

                } 
                else 
                {
                    //
                    // SCE returned errors needs to be translated to HRESULT.
                    //

                    hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
                }
            }

            if ( SUCCEEDED(hr) ) 
            {

                //
                // write the section header
                //

                hr = pSceStore->WriteSecurityProfileInfo(
                                                         AREA_SYSTEM_SERVICE,
                                                         pInfo,
                                                         NULL,
                                                         false  // not appending
                                                         );
            }

        } 
        else 
        {
            //
            // not found
            //

            if ( Startup == SCE_NO_VALUE || wszSDDL == NULL ) 
            {
                //
                // try to delete non exist object
                //

                hr = WBEM_E_NOT_FOUND;

            } 
            else 
            {
                //
                // add this one in
                //

                SCE_SERVICES addService;

                SECURITY_INFORMATION SeInfo=0;
                PSECURITY_DESCRIPTOR pSD=NULL;
                DWORD dSize=0;

                SCESTATUS rc = SceSvcConvertTextToSD ((PWSTR)wszSDDL, &pSD, &dSize, &SeInfo);

                if ( rc == SCESTATUS_SUCCESS && pSD ) 
                {
                    addService.ServiceName  = (PWSTR)wszObjName;
                    addService.DisplayName  = NULL;
                    addService.Status       = 0;
                    addService.Startup      = (BYTE)Startup;
                    addService.General.pSecurityDescriptor = pSD;
                    addService.SeInfo       = SeInfo;
                    addService.Next         = NULL;

                    //
                    // set the temp buffer pointer to pInfo to set to the store
                    //

                    pInfoService = pInfo->pServices;
                    pInfo->pServices = &addService;

                    //
                    // append this item to the section
                    //

                    hr = pSceStore->WriteSecurityProfileInfo(
                                                             AREA_SYSTEM_SERVICE,
                                                             pInfo,
                                                             NULL,
                                                             true  // appending
                                                             );
                    //
                    // reset the buffer pointer
                    //

                    pInfo->pServices = pInfoService;
                }

                if ( rc != SCESTATUS_SUCCESS )
                {
                    //
                    // SCE returned errors needs to be translated to HRESULT.
                    //

                    hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
                }

                if ( pSD ) 
                {
                    LocalFree(pSD);
                }
            }
        }
    }
    
    pSceStore->FreeSecurityProfileInfo(pInfo);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\support.h ===
// support.h: interface for the CEnumPrivileges and CEnumRegistryValues.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SUPPORT_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_SUPPORT_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

/*

Class description
    
    Naming:

        CEnumRegistryValues stands for Registry Values Enumerator.
    
    Base class: 

        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_KnownRegistryValues
    
    Purpose of class:
    
        (1) Implement Sce_KnownRegistryValues WMI class.

        (2) Help to find out if a particular registry is one of the known registry values.
    
    Design:
         
        (1) Almost trivial other than implementing necessary method as a concrete class
    
    Use:

        (1) Almost never used directly. Alway through the common interface defined by
            CGenericClass.
    
*/

class CEnumRegistryValues : public CGenericClass
{
public:
        CEnumRegistryValues (
                            ISceKeyChain *pKeyChain, 
                            IWbemServices *pNamespace, 
                            IWbemContext *pCtx = NULL
                            );

        virtual ~CEnumRegistryValues ();

        virtual HRESULT PutInst (
                                IWbemClassObject *pInst, 
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                );

        virtual HRESULT CreateObject (
                                     IWbemObjectSink *pHandler, 
                                     ACTIONTYPE atAction
                                     );

private:
        HRESULT EnumerateInstances (
                                   IWbemObjectSink *pHandler
                                   );

        HRESULT ConstructInstance (
                                  IWbemObjectSink *pHandler, 
                                  LPCWSTR wszRegKeyName, 
                                  LPCWSTR wszRegPath, 
                                  HKEY hKeyRoot 
                                  );

        HRESULT DeleteInstance (
                               IWbemObjectSink *pHandler,
                               LPCWSTR wszRegKeyName 
                               );

        HRESULT SavePropertyToReg (
                                  LPCWSTR wszKeyName, 
                                  int RegType, 
                                  int DispType,
                                  LPCWSTR wszDispName, 
                                  LPCWSTR wszUnits,
                                  PSCE_NAME_LIST pnlChoice, 
                                  PSCE_NAME_LIST pnlResult
                                  );

};

//================================================================================

/*

Class description
    
    Naming:

        CEnumPrivileges stands for Supported Privilege Enumerator.
    
    Base class:

        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_SupportedPrivileges
    
    Purpose of class:
    
        (1) Implement Sce_SupportedPrivileges WMI class.

        (2) Help to determine if a certain privilege is supported or not.
    
    Design:
         
        (1) Almost trivial other than implementing necessary method as a concrete class

        (2) We don't allow supported privileges to grow. So, not PutInstance support.
    
    Use:

        (1) Almost never used directly. Alway through the common interface defined by
            CGenericClass.
    
*/


class CEnumPrivileges : public CGenericClass
{
public:
        CEnumPrivileges (
                        ISceKeyChain *pKeyChain, 
                        IWbemServices *pNamespace, 
                        IWbemContext *pCtx = NULL
                        );

        virtual ~CEnumPrivileges ();

        virtual HRESULT PutInst (
                                IWbemClassObject *pInst, 
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                )
                {
                    return WBEM_E_NOT_SUPPORTED;
                }

        virtual HRESULT CreateObject (
                                     IWbemObjectSink *pHandler,
                                     ACTIONTYPE atAction
                                     );

private:

        HRESULT ConstructInstance (
                                  IWbemObjectSink *pHandler, 
                                  LPCWSTR PrivName
                                  );

};

#endif // !defined(AFX_SUPPORT_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\service.h ===
// service.h: interface for the CGeneralService class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SERVICE_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_SERVICE_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

/*

Class description
    
    Naming:

        CGeneralService stands for System Service.
    
    Base class:

        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_SystemService
    
    Purpose of class:
    
        (1) Implement Sce_SystemService WMI class.
    
    Design:
         
        (1) Almost trivial other than implementing necessary method as a concrete class
    
    Use:

        (1) Almost never used directly. Alway through the common interface defined by
            CGenericClass.
    
*/

class CGeneralService : public CGenericClass
{
public:
        CGeneralService (
                        ISceKeyChain *pKeyChain, 
                        IWbemServices *pNamespace, 
                        IWbemContext *pCtx = NULL
                        );

        virtual ~CGeneralService ();

        virtual HRESULT PutInst (
                                IWbemClassObject *pInst, 
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                );

        virtual HRESULT CreateObject (
                                     IWbemObjectSink *pHandler, 
                                     ACTIONTYPE atAction
                                     );

private:

        HRESULT ConstructInstance (
                                  IWbemObjectSink *pHandler, 
                                  CSceStore* pSceStore, 
                                  LPCWSTR wszLogStorePath, 
                                  LPCWSTR wszObjName, 
                                  BOOL bPostFilter);

        HRESULT DeleteInstance (
                               IWbemObjectSink *pHandler, 
                               CSceStore* pSceStore, 
                               LPCWSTR wszObjName
                               );

        HRESULT SaveSettingsToStore (
                                    CSceStore* pSceStore, 
                                    LPCWSTR wszObjName, 
                                    DWORD Startup, 
                                    LPCWSTR wszSDDL
                                    );

};

#endif // !defined(AFX_SERVICE_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\support.cpp ===
// SUPPORT.cpp: implementation of the CEnumRegistryValues and CEnumPrivileges classes.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "support.h"
#include "persistmgr.h"
#include <io.h>
#include "requestobject.h"

/*
Routine Description: 

Name:

    CEnumRegistryValues::CEnumRegistryValues

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CEnumRegistryValues::CEnumRegistryValues (
    IN ISceKeyChain     * pKeyChain, 
    IN IWbemServices    * pNamespace,
    IN IWbemContext     * pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{

}

/*
Routine Description: 

Name:

    CEnumRegistryValues::~CEnumRegistryValues

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/

CEnumRegistryValues::~CEnumRegistryValues()
{

}

/*
Routine Description: 

Name:

    CEnumRegistryValues::CreateObject

Functionality:
    
    Create WMI objects (Sce_KnownRegistryValues). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT CEnumRegistryValues::CreateObject (
    IN IWbemObjectSink * pHandler, 
    IN ACTIONTYPE        atAction
    )
{

    // 
    // we know how to:
    //      Enumerate instances ACTIONTYPE_ENUM
    //      Get single instance ACTIONTYPE_GET
    //      Get several instances ACTIONTYPE_QUERY
    //      Delete a single instance ACTIONTYPE_DELETE
    //

    HRESULT hr = WBEM_S_NO_ERROR;

    if ( ACTIONTYPE_ENUM != atAction &&
         ACTIONTYPE_GET != atAction &&
         ACTIONTYPE_QUERY != atAction &&
         ACTIONTYPE_DELETE != atAction ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // We must have the pPathName property.
    //

    CComVariant varPathName;
    if ( ACTIONTYPE_ENUM != atAction ) 
    {
        //
        // We are not enumerating, let's determine the scope of enumeration
        // by testing the path property. If it existis, it must be a bstr.
        //

        hr = m_srpKeyChain->GetKeyPropertyValue(pPathName, &varPathName);
    }

    //
    // if enumeratig, or querying without a path, then get all
    //

    if ( ACTIONTYPE_ENUM    == atAction ||
        (ACTIONTYPE_QUERY   == atAction && varPathName.vt != VT_BSTR ) ) 
    {

        //
        // enumerate all supported registry values
        //

        hr = EnumerateInstances(pHandler);

    } 
    else if (varPathName.vt == VT_BSTR ) 
    {
        //
        // convert the reg path from \ to /
        // Create the registry value instance
        //

        CComBSTR bstrKeyName;
        CComBSTR bstrLogName;

        hr = MakeSingleBackSlashPath(varPathName.bstrVal, L'\\', &bstrLogName);

        if ( SUCCEEDED(hr) ) 
        {
            bstrKeyName = SysAllocString(bstrLogName);

            if ( bstrKeyName ) 
            {
                for ( PWSTR pTemp = (PWSTR)bstrKeyName; *pTemp != L'\0'; pTemp++ ) 
                {
                    if ( *pTemp == L'\\' ) 
                    {
                        *pTemp = L'/';
                    }
                }
                hr = WBEM_S_NO_ERROR;
            } 
            else 
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }

        //
        // successfully converted the backslashed path to forward slashed path
        //

        if ( SUCCEEDED(hr) ) 
        {
            if ( ACTIONTYPE_DELETE == atAction )
            {
                hr = DeleteInstance(pHandler, bstrKeyName);
            }
            else
            {
                hr = ConstructInstance(pHandler, bstrKeyName, bstrLogName, NULL);
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CEnumRegistryValues::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_KnownRegistryValues,
    which is registry persistence oriented, this will cause the Sce_KnownRegistryValues object's property 
    information to be saved in the registry.

Virtual:
    
    Yes.
    
Arguments:

    pInst       - COM interface pointer to the WMI class (Sce_KnownRegistryValues) object.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

*/

HRESULT CEnumRegistryValues::PutInst (
    IN IWbemClassObject    * pInst,
    IN IWbemObjectSink     * pHandler,
    IN IWbemContext        * pCtx
    )
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;

    CComBSTR bstrRegPath;
    CComBSTR bstrConvertPath;
    CComBSTR bstrDispName;
    CComBSTR bstrUnits;

    PSCE_NAME_LIST pnlChoice = NULL;
    PSCE_NAME_LIST pnlResult = NULL;

    //
    // CScePropertyMgr helps us to access WMI object's properties
    // create an instance and attach the WMI object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pInst);

    DWORD RegType=0;
    DWORD DispType=0;

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pPathName, &bstrRegPath));

    //
    // convert double back slash to /
    //

    SCE_PROV_IfErrorGotoCleanup(MakeSingleBackSlashPath(bstrRegPath, L'/', &bstrConvertPath));

    //
    // make sure single back slash is handled too.
    //

    for ( PWSTR pTemp= bstrConvertPath; *pTemp != L'\0'; pTemp++) 
    {
        if ( *pTemp == L'\\' ) 
        {
            *pTemp = L'/';
        }
    }

    //
    // type info must exists
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pType, &RegType));

    if ( hr == WBEM_S_RESET_TO_DEFAULT) 
    {
        hr = WBEM_E_ILLEGAL_NULL;
        goto CleanUp;
    }

    //
    // We also need DisplayDialog property
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pDisplayDialog, &DispType));
    if ( hr == WBEM_S_RESET_TO_DEFAULT) 
    {
        hr = WBEM_E_ILLEGAL_NULL;
        goto CleanUp;
    }

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pDisplayName, &bstrDispName));

    if ( DispType == SCE_REG_DISPLAY_CHOICE ) 
    {
        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pDisplayChoice, &pnlChoice));
        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pDisplayChoiceResult, &pnlResult));

    } 
    else if ( DispType == SCE_REG_DISPLAY_NUMBER ) 
    {
        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.GetProperty(pUnits, &bstrUnits));
    }

    //
    // now save the info to registry
    //

    hr = SavePropertyToReg( bstrConvertPath, RegType, DispType, bstrDispName, bstrUnits, pnlChoice, pnlResult);

CleanUp:

    if ( pnlChoice )
    {
        SceFreeMemory(pnlChoice, SCE_STRUCT_NAME_LIST);
    }

    if ( pnlResult )
    {
        SceFreeMemory(pnlResult, SCE_STRUCT_NAME_LIST);
    }

    return hr;

}

/*
Routine Description: 

Name:

    CEnumRegistryValues::EnumerateInstances

Functionality:
    
    Private helper to enumerate all registry values supported by SCE from registry.

Virtual:
    
    No.
    
Arguments:

    pHandler    - COM interface pointer for notifying WMI of any events.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    This is a registry reading routine. Refer to MSDN if you have questions.

*/

HRESULT 
CEnumRegistryValues::EnumerateInstances (
    IN IWbemObjectSink *pHandler
    )
{
    DWORD   Win32Rc;
    HKEY    hKey=NULL;
    DWORD   cSubKeys = 0;
    DWORD   nMaxLen;

    HRESULT hr;
    PWSTR   szName=NULL;
    BSTR    bstrName=NULL;

    Win32Rc = RegOpenKeyEx(
                           HKEY_LOCAL_MACHINE,
                           SCE_ROOT_REGVALUE_PATH,
                           0,
                           KEY_READ,
                           &hKey
                           );

    if ( Win32Rc == ERROR_SUCCESS ) 
    {

        //
        // enumerate all subkeys of the key
        //

        Win32Rc = RegQueryInfoKey (
                                hKey,
                                NULL,
                                NULL,
                                NULL,
                                &cSubKeys,
                                &nMaxLen,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );
    }

    hr = ProvDosErrorToWbemError(Win32Rc);

    if ( Win32Rc == ERROR_SUCCESS && cSubKeys > 0 ) 
    {

        szName = (PWSTR)LocalAlloc(0, (nMaxLen+2)*sizeof(WCHAR));

        if ( !szName ) 
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        } 
        else 
        {
            DWORD   BufSize;
            DWORD   index = 0;

            do {

                BufSize = nMaxLen + 1;
                Win32Rc = RegEnumKeyEx(
                                  hKey,
                                  index,
                                  szName,
                                  &BufSize,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL);

                if ( ERROR_SUCCESS == Win32Rc ) 
                {
                    index++;

                    //
                    // convert the path name (from single / to double \\)
                    //

                    bstrName = SysAllocString(szName);
                    if ( bstrName == NULL ) 
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                        break;
                    }

                    //
                    // replace / with \.
                    //

                    for ( PWSTR pTemp=(PWSTR)bstrName; *pTemp != L'\0'; pTemp++) 
                    {
                        if ( *pTemp == L'/' ) 
                        {
                            *pTemp = L'\\';
                        }
                    }

                    //
                    // get all information from registry for this key
                    // and create an instance
                    //

                    hr = ConstructInstance(pHandler, szName, bstrName, hKey);

                    SysFreeString(bstrName);
                    bstrName = NULL;

                    if ( FAILED(hr) ) 
                    {
                        break;
                    }

                } 
                else if ( ERROR_NO_MORE_ITEMS != Win32Rc ) 
                {
                    hr = ProvDosErrorToWbemError(Win32Rc);
                    break;
                }

            } while ( Win32Rc != ERROR_NO_MORE_ITEMS );

            LocalFree(szName);
            szName = NULL;

            if ( bstrName ) 
            {
                SysFreeString(bstrName);
            }

        }
    }

    if ( hKey )
    {
        RegCloseKey(hKey);
    }

    return hr;

}


/*
Routine Description: 

Name:

    CEnumRegistryValues::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_KnownRegistryValues.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    wszRegKeyName   - name of the registry key.

    wszRegPath      - the registry key's path.

    hKeyRoot        - Root key.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:
    (1) This is a registry reading routine. Refer to MSDN if you have questions.
    (2) There are numerous memory allocations. Make sure that you don't blindly
        short-circuit return and cause memory leaks.
    (3) It also opens registry keys. Don't forget to close them. Make sure that
        you don't blindly short-circuit return and cause key handle leaks.

*/

HRESULT CEnumRegistryValues::ConstructInstance (
    IN IWbemObjectSink * pHandler,
    IN LPCWSTR           wszRegKeyName,
    IN LPCWSTR           wszRegPath,
    IN HKEY              hKeyRoot       OPTIONAL
    )
{
    //
    // Get registry information
    //

    HRESULT hr      = WBEM_S_NO_ERROR;
    DWORD Win32Rc   = NO_ERROR;

    HKEY    hKey1   = NULL;
    HKEY    hKey    = NULL;
    DWORD   dSize   = sizeof(DWORD);
    DWORD   RegType = 0;

    PWSTR   szDisplayName   = NULL;
    PWSTR   szUnit          = NULL;
    PWSTR   mszChoices      = NULL;
    int     dType           = -1;
    int     dDispType       = -1;


    if ( hKeyRoot ) 
    {
        hKey = hKeyRoot;
    } 
    else 
    {
        //
        // open the root key
        //

        Win32Rc = RegOpenKeyEx(
                               HKEY_LOCAL_MACHINE,
                               SCE_ROOT_REGVALUE_PATH,
                               0,
                               KEY_READ,
                               &hKey
                               );

        if ( Win32Rc != NO_ERROR ) 
        {
            //
            // translate win32 error into HRESULT error
            //

            return ProvDosErrorToWbemError(Win32Rc);
        }

    }

    //
    // try to open the reg key
    //

    if (( Win32Rc = RegOpenKeyEx(hKey,
                                 wszRegKeyName,
                                 0,
                                 KEY_READ,
                                 &hKey1
                                )) == ERROR_SUCCESS ) 
    {

        //
        // get reg type
        //

        Win32Rc = RegQueryValueEx(hKey1,
                                  SCE_REG_VALUE_TYPE,
                                  0,
                                  &RegType,
                                  (BYTE *)&dType,
                                  &dSize
                                  );

        if ( Win32Rc == ERROR_FILE_NOT_FOUND )
        {
            Win32Rc = NO_ERROR;
        }

        if ( Win32Rc == NO_ERROR ) 
        {

            //
            // get display type
            //

            dSize = sizeof(DWORD);

            Win32Rc = RegQueryValueEx(hKey1,
                                      SCE_REG_DISPLAY_TYPE,
                                      0,
                                      &RegType,
                                      (BYTE *)&dDispType,
                                      &dSize
                                      );

            if ( Win32Rc == ERROR_FILE_NOT_FOUND )
            {
                Win32Rc = NO_ERROR;
            }

            if ( Win32Rc == NO_ERROR )
            {
                //
                // get display name
                //

                dSize = 0;
                Win32Rc = RegQueryValueEx(hKey1,
                                          SCE_REG_DISPLAY_NAME,
                                          0,
                                          &RegType,
                                          NULL,
                                          &dSize
                                          );

                if ( Win32Rc == NO_ERROR )
                {
                    if ( RegType != REG_SZ ) 
                    {
                        Win32Rc = ERROR_INVALID_DATA;
                    }
                }

                if ( Win32Rc == NO_ERROR ) 
                {
                    //
                    // need to free it!
                    //

                    szDisplayName = (PWSTR)LocalAlloc(LPTR, (dSize+1)*sizeof(WCHAR));

                    if ( szDisplayName == NULL ) 
                    {
                        Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                if ( Win32Rc == NO_ERROR ) 
                {

                    Win32Rc = RegQueryValueEx(hKey1,
                                              SCE_REG_DISPLAY_NAME,
                                              0,
                                              &RegType,
                                              (BYTE *)szDisplayName,   // prefast will complain about this line
                                              &dSize
                                              );
                }

                if ( Win32Rc == ERROR_FILE_NOT_FOUND ) 
                {
                    Win32Rc = NO_ERROR;
                }

                if ( Win32Rc == NO_ERROR ) 
                {

                    //
                    // get display unit
                    //

                    dSize = 0;
                    Win32Rc = RegQueryValueEx(hKey1,
                                              SCE_REG_DISPLAY_UNIT,
                                              0,
                                              &RegType,
                                              NULL,
                                              &dSize
                                              );

                    if ( Win32Rc == NO_ERROR )
                    {
                        if ( RegType != REG_SZ ) 
                        {
                            Win32Rc = ERROR_INVALID_DATA;
                        }
                    }

                    if ( Win32Rc == NO_ERROR ) 
                    {

                        //
                        // need to free it!
                        //

                        szUnit = (PWSTR)LocalAlloc(LPTR, (dSize+1)*sizeof(WCHAR));

                        if ( szUnit == NULL ) 
                        {
                            Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }

                    if ( Win32Rc == NO_ERROR ) 
                    {

                        Win32Rc = RegQueryValueEx(hKey1,
                                                  SCE_REG_DISPLAY_UNIT,
                                                  0,
                                                  &RegType,
                                                  (BYTE *)szUnit,     // prefast will complain about this line
                                                  &dSize
                                                  );
                    }

                    if ( Win32Rc == ERROR_FILE_NOT_FOUND ) 
                    {
                        Win32Rc = NO_ERROR;
                    }

                    if ( Win32Rc == NO_ERROR ) 
                    {

                        //
                        // get display choices
                        //

                        dSize = 0;
                        Win32Rc = RegQueryValueEx(hKey1,
                                                  SCE_REG_DISPLAY_CHOICES,
                                                  0,
                                                  &RegType,
                                                  NULL,
                                                  &dSize
                                                  ) ;

                        if ( Win32Rc == NO_ERROR )
                        {
                            if ( RegType != REG_MULTI_SZ ) 
                            {
                                Win32Rc = ERROR_INVALID_DATA;
                            }
                        }

                        if ( Win32Rc == NO_ERROR ) 
                        {

                            //
                            // Need to free it
                            //

                            mszChoices = (PWSTR)LocalAlloc(LPTR, (dSize+2)*sizeof(WCHAR));

                            if ( mszChoices == NULL ) 
                            {
                                Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }

                        if ( Win32Rc == NO_ERROR ) 
                        {
                            Win32Rc = RegQueryValueEx(hKey1,
                                                      SCE_REG_DISPLAY_CHOICES,
                                                      0,
                                                      &RegType,
                                                      (BYTE *)mszChoices,     // prefast will complain about this line
                                                      &dSize
                                                      );
                        }

                        if ( Win32Rc == ERROR_FILE_NOT_FOUND )
                        {
                            Win32Rc = NO_ERROR;
                        }
                    }
                }
            }
        }
    }

    hr = ProvDosErrorToWbemError(Win32Rc);

    PSCE_NAME_LIST pnlChoice=NULL;
    PSCE_NAME_LIST pnlResult=NULL;

    if ( Win32Rc == NO_ERROR ) 
    {
        //
        // break up choices
        //

        PWSTR pT2;
        DWORD Len;
        SCESTATUS rc;

        for ( PWSTR pTemp = mszChoices; pTemp != NULL && pTemp[0] != L'\0'; ) 
        {

            Len = wcslen(pTemp);
            pT2 = wcschr(pTemp, L'|');

            if ( pT2 ) 
            {
                rc = SceAddToNameList(&pnlResult, pTemp, (DWORD)(pT2-pTemp));

                if ( rc == SCESTATUS_SUCCESS ) 
                {
                    rc = SceAddToNameList(&pnlChoice, pT2 + 1, Len - (DWORD)(pT2 - pTemp) - 1);
                }
                Win32Rc = ProvSceStatusToDosError(rc);

                pTemp += Len + 1;

            } 
            else 
            {
                Win32Rc = ERROR_INVALID_DATA;
                break;
            }
        }
    }

    hr = ProvDosErrorToWbemError(Win32Rc);

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    if ( Win32Rc == NO_ERROR ) 
    {

        //
        // now create the WMI instance
        //

        CComPtr<IWbemClassObject> srpObj;
        SCE_PROV_IfErrorGotoCleanup(SpawnAnInstance(&srpObj));

        //
        // CScePropertyMgr helps us to access WMI object's properties
        // create an instance and attach the WMI object to it.
        // This will always succeed.
        //

        CScePropertyMgr ScePropMgr;
        ScePropMgr.Attach(srpObj);

        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pPathName, wszRegPath));

        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pType, (DWORD)dType ));

        SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pDisplayDialog, (DWORD)dDispType ));

        if ( szDisplayName )
        {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pDisplayName, szDisplayName ));
        }

        if ( szUnit )
        {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pUnits, szUnit ));
        }

        if ( pnlChoice )
        {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pDisplayChoice, pnlChoice ));
        }

        if ( pnlResult )
        {
            SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pDisplayChoiceResult, pnlResult ));
        }

        //
        // give WMI the instance
        //

        hr = pHandler->Indicate(1, &srpObj);

    }

CleanUp:

    if( hKey1 )
    {
        RegCloseKey( hKey1 );
    }

    if ( szDisplayName )
    {
        LocalFree(szDisplayName);
    }

    if ( szUnit )
    {
        LocalFree(szUnit);
    }

    if ( mszChoices )
    {
        LocalFree(mszChoices);
    }

    if ( pnlChoice ) 
    {
        SceFreeMemory(pnlChoice, SCE_STRUCT_NAME_LIST);
    }

    if ( pnlResult ) 
    {
        SceFreeMemory(pnlResult, SCE_STRUCT_NAME_LIST);
    }

    if ( hKey != hKeyRoot )
    {
        RegCloseKey(hKey);
    }

    return hr;
}

/*
Routine Description: 

Name:

    CEnumRegistryValues::DeleteInstance

Functionality:
    
    This is private function to delete an instance of Sce_KnownRegistryValues.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events. Not used here.

    wszRegKeyName   - name of the registry key.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:
    (1) This is a registry reading routine. Refer to MSDN if you have questions.
    (2) It also opens registry keys. Don't forget to close them. Make sure that
        you don't blindly short-circuit return and cause key handle leaks.

Notes:

*/

HRESULT CEnumRegistryValues::DeleteInstance (
    IN IWbemObjectSink * pHandler,
    IN LPCWSTR           wszRegKeyName
    )
{

    HKEY hKey = NULL;
    DWORD Win32Rc;

    //
    // open the root key
    //

    Win32Rc = RegOpenKeyEx(
                           HKEY_LOCAL_MACHINE,
                           SCE_ROOT_REGVALUE_PATH,
                           0,
                           KEY_WRITE,
                           &hKey
                           );

    if ( Win32Rc == NO_ERROR ) 
    {
        //
        // delete the subkey
        //

        Win32Rc = RegDeleteKey (hKey, wszRegKeyName);
    }

    if ( hKey ) 
    {
        RegCloseKey(hKey);
    }

    return ProvDosErrorToWbemError(Win32Rc);

}

/*
Routine Description: 

Name:

    CEnumRegistryValues::SavePropertyToReg

Functionality:
    
    This is private function to save instance of Sce_KnownRegistryValues to registry.

Virtual:
    
    No.
    
Arguments:

    wszKeyName  - name of the registry key. Property of the WMI class (Sce_KnownRegistryValues).

    RegType     - Property of the WMI class.

    DispType    - Property of the WMI class.

    wszDispName - Property of the WMI class.

    wszUnits    - Property of the WMI class.

    pnlChoice   - Property of the WMI class.

    pnlResult   - name of the registry key.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:
    (1) This is a registry reading routine. Refer to MSDN if you have questions.
    (2) It also opens registry keys. Don't forget to close them. Make sure that
        you don't blindly short-circuit return and cause key handle leaks.
    (3) It also allocates heap memory. Make sure that you don't blindly
        short-circuit return and cause memory leaks.

Notes:

*/

HRESULT CEnumRegistryValues::SavePropertyToReg (
    IN LPCWSTR          wszKeyName, 
    IN int              RegType, 
    IN int              DispType,
    IN LPCWSTR          wszDispName, 
    IN LPCWSTR          wszUnits,
    IN PSCE_NAME_LIST   pnlChoice, 
    IN PSCE_NAME_LIST   pnlResult
    )
{
    if ( wszKeyName == NULL ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // merge pnlChoice and pnlResult to one buffer
    //

    DWORD Len=0;
    PSCE_NAME_LIST pName;
    DWORD cnt1,cnt2;

    for ( cnt1=0, pName=pnlChoice; pName != NULL; cnt1++, pName=pName->Next)
    {
        Len += wcslen(pName->Name);
    }

    for ( cnt2=0, pName=pnlResult; pName != NULL; cnt2++, pName=pName->Next)
    {
        Len += wcslen(pName->Name);
    }

    if ( cnt1 != cnt2 ) 
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    PWSTR mszChoices=NULL;

    if ( cnt1 != 0 ) 
    { 
        //
        // each string has a | and a \0
        //

        Len += cnt1 * 2 + 1;

        //
        // need to free the memory pointed to by mszChoices
        //

        mszChoices = (PWSTR)LocalAlloc(LPTR, Len*sizeof(WCHAR));
        if ( mszChoices == NULL ) 
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    PWSTR pTemp = mszChoices;
    pName = pnlResult;
    PSCE_NAME_LIST pName2 = pnlChoice;

    while ( pName ) 
    {
        //
        // these wcscpy are not overrunning the buffer. See size of allocation above
        //

        wcscpy(pTemp, pName->Name);
        pTemp += wcslen(pName->Name);
        *pTemp++ = L'|';
        wcscpy(pTemp, pName2->Name);
        pTemp += wcslen(pName2->Name);
        *pTemp++ = L'\0';

        pName = pName->Next;
        pName2 = pName2->Next;
    }

    HRESULT hr=WBEM_S_NO_ERROR;
    DWORD rc;
    DWORD   Disp;
    HKEY hKeyRoot=NULL;
    HKEY hKey=NULL;

    rc = RegCreateKeyEx(
                       HKEY_LOCAL_MACHINE,
                       SCE_ROOT_REGVALUE_PATH,
                       0,
                       NULL,                        // LPTSTR lpClass,
                       REG_OPTION_NON_VOLATILE,
                       KEY_WRITE,                   // KEY_SET_VALUE,
                       NULL,                        // &SecurityAttributes,
                       &hKeyRoot,
                       &Disp
                       );

    if ( rc == ERROR_SUCCESS ) 
    {
        rc = RegCreateKeyEx(
                            hKeyRoot,
                            wszKeyName,
                            0,
                            NULL,
                            0,
                            KEY_WRITE,
                            NULL,
                            &hKey,
                            &Disp
                            );

        if ( rc == ERROR_SUCCESS ) 
        {
            DWORD dValue = RegType;
            rc = RegSetValueEx (hKey,
                                SCE_REG_VALUE_TYPE,
                                0,
                                REG_DWORD,
                                (BYTE *)&dValue,
                                sizeof(DWORD)
                                );

            if ( rc == ERROR_SUCCESS ) 
            {
                dValue = DispType;
                rc = RegSetValueEx (hKey,
                                    SCE_REG_DISPLAY_TYPE,
                                    0,
                                    REG_DWORD,
                                    (BYTE *)&dValue,
                                    sizeof(DWORD)
                                    );

                if ( rc == ERROR_SUCCESS && wszDispName ) 
                {
                    rc = RegSetValueEx (hKey,
                                        SCE_REG_DISPLAY_NAME,
                                        0,
                                        REG_SZ,
                                        (BYTE *)wszDispName,      // prefast will complain about this line
                                        (wcslen(wszDispName)+1)*sizeof(WCHAR)
                                        );
                }

                if ( rc == ERROR_SUCCESS && wszUnits ) 
                {
                    rc = RegSetValueEx (hKey,
                                        SCE_REG_DISPLAY_UNIT,
                                        0,
                                        REG_SZ,
                                        (BYTE *)wszUnits,         // prefast will complain about this line
                                        (wcslen(wszUnits)+1)*sizeof(WCHAR)
                                        );
                }

                if ( rc == ERROR_SUCCESS && mszChoices ) 
                {
                    rc = RegSetValueEx (hKey,
                                        SCE_REG_DISPLAY_CHOICES,
                                        0,
                                        REG_MULTI_SZ,
                                        (BYTE *)mszChoices,       // prefast will complain about this line
                                        Len*sizeof(WCHAR)
                                        );
                }
            }

            if ( rc != ERROR_SUCCESS && REG_CREATED_NEW_KEY == Disp ) 
            {
                //
                // something failed during create/save the registry thing
                // delete it if it's created
                //

                RegCloseKey(hKey);
                hKey = NULL;
                RegDeleteKey (hKeyRoot, wszKeyName);
            }
        }
    }

    if ( hKeyRoot ) 
    {
        RegCloseKey(hKeyRoot);
    }

    if ( hKey ) 
    {
        RegCloseKey(hKey);
    }

    hr = ProvDosErrorToWbemError(rc);

    LocalFree(mszChoices);

    return hr;
}

//=====================================================================
// implementing CEnumPrivileges
//=====================================================================

/*
Routine Description: 

Name:

    CEnumPrivileges::CEnumPrivileges

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CEnumPrivileges::CEnumPrivileges (
    IN ISceKeyChain     * pKeyChain, 
    IN IWbemServices    * pNamespace,
    IN IWbemContext     * pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{

}

/*
Routine Description: 

Name:

    CEnumPrivileges::~CEnumPrivileges

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/
    
CEnumPrivileges::~CEnumPrivileges ()
{
}

/*
Routine Description: 

Name:

    CEnumPrivileges::CreateObject

Functionality:
    
    Create WMI objects (Sce_SupportedPrivileges). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Enumerate instances (atAction == ACTIONTYPE_ENUM)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Enumerate instances ACTIONTYPE_ENUM

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT 
CEnumPrivileges::CreateObject (
    IN IWbemObjectSink * pHandler, 
    IN ACTIONTYPE        atAction
    )
{
    // 
    // we know how to:
    //      Enumerate instances ACTIONTYPE_ENUM
    //      Get single instance ACTIONTYPE_GET
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_ENUM    != atAction &&
         ACTIONTYPE_GET     != atAction &&
         ACTIONTYPE_QUERY   != atAction ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT hr = WBEM_S_NO_ERROR;

    //
    // if not enumerating, then see if we have the Right name property
    //

    CComVariant varRightName;
    if ( ACTIONTYPE_ENUM != atAction ) 
    {  
        //
        // this property must be a bstr
        //

        hr = m_srpKeyChain->GetKeyPropertyValue(pRightName, &varRightName);
    }

    if ( ACTIONTYPE_ENUM    == atAction ||
         (ACTIONTYPE_QUERY  == atAction && varRightName.vt != VT_BSTR) ) 
    {

        //
        // if enumeration or query for all instances
        //

        WCHAR PrivName[128];
        SCESTATUS rc;

        for ( int i = 0; i < cPrivCnt; i++ ) 
        {
            int cbName = 128;

            //
            // get the privilege right name so that we can constrcut the instance
            //

            rc = SceLookupPrivRightName(
                                        i,
                                        PrivName,
                                        &cbName
                                        );

            if ( SCESTATUS_SUCCESS != rc ) 
            {
                //
                // SCE returned errors needs to be translated to HRESULT.
                //

                hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));

            }
            else 
            {

                //
                // get one privilege
                //

                hr = ConstructInstance(pHandler, PrivName);

            }

            if ( FAILED(hr) ) 
            {
                break;
            }

        }

    } 
    else if (varRightName.vt == VT_BSTR) 
    {

        //
        // Create the privilege instance
        //

        hr = ConstructInstance(pHandler, varRightName.bstrVal);

    }

    return hr;
}


/*
Routine Description: 

Name:

    CEnumPrivileges::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_SupportedPrivileges.

Virtual:
    
    No.
    
Arguments:

    pHandler    - COM interface pointer for notifying WMI of any events.

    PrivName    - privilege name.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:

*/

HRESULT CEnumPrivileges::ConstructInstance (
    IN IWbemObjectSink * pHandler,
    IN LPCWSTR           PrivName
    )
{
    //
    // lookup privilege display name
    //

    HRESULT hr = WBEM_S_NO_ERROR;

    DWORD dwLang;
    WCHAR DispName[256];
    DWORD cbName = 255;
    DispName[0] = L'\0';

    if ( LookupPrivilegeDisplayName(NULL, PrivName, DispName, &cbName,&dwLang) ) 
    {
        //
        // create a blank instance so that we can fill in the properties
        //

        CComPtr<IWbemClassObject> srpObj;

        if (FAILED(hr = SpawnAnInstance(&srpObj)))
        {
            return hr;
        }

        //
        // CScePropertyMgr helps us to access WMI object's properties
        // create an instance and attach the WMI object to it.
        // This will always succeed.
        //

        CScePropertyMgr ScePropMgr;
        ScePropMgr.Attach(srpObj);

        hr = ScePropMgr.PutProperty(pRightName, PrivName);

        if (SUCCEEDED(hr) && DispName[0] != L'\0' )
        {
            ScePropMgr.PutProperty(pDisplayName, DispName );
        }

        hr = pHandler->Indicate(1, &srpObj);
    } 

    //
    // if not find it (it's a user right, ignore it)
    //

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\template.cpp ===
// template.cpp: implementation of the CSecurityTemplate class.
// template.cpp
// Copyright (c)1999-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Template.h"
#include "persistmgr.h"
#include <io.h>
#include "requestobject.h"

LPCWSTR pszRelSecTemplateDir    = L"\\security\\templates\\";
LPCWSTR pszSecTemplateFileExt   = L"*.inf";
LPCWSTR pszDescription          = L"Description";
LPCWSTR pszVersion              = L"Version";
LPCWSTR pszRevision             = L"Revision";

/*
Routine Description: 

Name:

    CSecurityTemplate::CSecurityTemplate

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CSecurityTemplate::CSecurityTemplate (
    IN ISceKeyChain     * pKeyChain, 
    IN IWbemServices    * pNamespace,
    IN IWbemContext     * pCtx
    )
    :
    CGenericClass(pKeyChain, pNamespace, pCtx)
{

}

/*
Routine Description: 

Name:

    CSecurityTemplate::~CSecurityTemplate

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/

CSecurityTemplate::~CSecurityTemplate()
{

}

/*
Routine Description: 

Name:

    CSecurityTemplate::CreateObject

Functionality:
    
    Create WMI objects (Sce_Template). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Enumerate instances (atAction == ACTIONTYPE_ENUM)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Enumerate instances ACTIONTYPE_ENUM

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT
CSecurityTemplate::CreateObject (
    IN IWbemObjectSink * pHandler, 
    IN ACTIONTYPE        atAction
    )
{
    // 
    // we know how to:
    //      Enumerate instances ACTIONTYPE_ENUM
    //      Get single instance ACTIONTYPE_GET
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_ENUM    != atAction &&
         ACTIONTYPE_GET     != atAction &&
         ACTIONTYPE_QUERY   != atAction ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    DWORD dwCount = 0;
    HRESULT hr = m_srpKeyChain->GetKeyPropertyCount(&dwCount);

    if (FAILED(hr))
    {
        return hr;
    }

    if ( ACTIONTYPE_ENUM == atAction ||
         (ACTIONTYPE_QUERY == atAction && dwCount == 0) ) {

        //
        // enumeration of all templates in the path
        // if path is not defined, enumerate existing templates
        // in %windir%\security\templates directory
        //

        //
        // Prepare %windir% directory
        //

        //
        // system windows directory is < MAX_PATH, the security template dir is < MAX_PATH
        //

        WCHAR szTemplateDir[MAX_PATH * 2 + 1];
        szTemplateDir[0] = L'\0';

        //
        // szTemplateDir is merely the system windows directory
        //

        UINT uDirLen = ::GetSystemWindowsDirectory(szTemplateDir, MAX_PATH);
        szTemplateDir[MAX_PATH - 1] = L'\0';

        //
        // szTemplateDir will now be the real security template dir
        //

        wcscat(szTemplateDir, pszRelSecTemplateDir);    
        
        //
        // security template dir's length
        //

        uDirLen += wcslen(pszRelSecTemplateDir);

        //
        // security template dir is < 2 * MAX_PATH, plus the file
        //

        WCHAR szFile[3 * MAX_PATH + 1];
        wcscpy(szFile, szTemplateDir); 

        //
        // szFile is the search file filter
        //

        wcscat(szFile, pszSecTemplateFileExt);

        //
        // Enumerate all templates in %windir%\security\templates directory
        //

        struct _wfinddata_t FileInfo;
        intptr_t hFile = _wfindfirst(szFile, &FileInfo);

        if ( hFile != -1 ) 
        {
            //
            // find some files
            //

            do 
            {
                //
                // remember: szFile + uDirLen is where the file name starts
                //

                wcscpy((LPWSTR)(szFile + uDirLen), FileInfo.name);

                //
                // got the template file name, we can constrcut the instance now.
                //

                hr = ConstructInstance(pHandler, szFile, szFile, (FileInfo.attrib & _A_RDONLY));

            } while ( SUCCEEDED(hr) && _wfindnext(hFile, &FileInfo) == 0 );

            _findclose(hFile);
        }

    } 
    else if (dwCount == 1) 
    {

        hr = WBEM_E_INVALID_OBJECT_PATH;

        //
        // m_srpKeyChain->GetKeyPropertyValue WBEM_S_FALSE if the key is not recognized
        // So, we need to test against WBEM_S_FALSE if the property is mandatory
        //

        CComVariant var;
        hr = m_srpKeyChain->GetKeyPropertyValue(pPath, &var);

        if (SUCCEEDED(hr) && hr != WBEM_S_FALSE && var.vt == VT_BSTR)
        {
            //
            // Create the template instance
            //
            
            CComBSTR bstrPath;
            BOOL bDb = FALSE;

            hr = CheckAndExpandPath(var.bstrVal, &bstrPath, &bDb);

            if ( bDb ) 
            {
                hr = WBEM_E_INVALID_OBJECT_PATH;
            } 
            else if ( SUCCEEDED(hr) && (LPCWSTR)bstrPath != NULL ) 
            {
                //
                // make sure the store (just a file) really exists.
                //

                DWORD dwAttrib = GetFileAttributes(bstrPath);

                if ( dwAttrib != -1 ) 
                {
                    //
                    // got the template file name, we can constrcut the instance now.
                    //

                    hr = ConstructInstance(pHandler, bstrPath, var.bstrVal, (dwAttrib & FILE_ATTRIBUTE_READONLY));
                } 
                else 
                {
                    hr = WBEM_E_NOT_FOUND;
                }
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CSecurityTemplate::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements Sce_Template,
    which is persistence oriented, this will cause the Sce_Template object's property 
    information to be saved in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst       - COM interface pointer to the WMI class (Sce_Template) object.

    pHandler    - COM interface pointer for notifying WMI of any events.

    pCtx        - COM interface pointer. This interface is just something we pass around.
                  WMI may mandate it (not now) in the future. But we never construct
                  such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:
    (1) Since GetProperty will return a success code (WBEM_S_RESET_TO_DEFAULT) when the
    requested property is not present, don't simply use SUCCEEDED or FAILED macros
    to test for the result of retrieving a property.

    (2) For this class, only Description is writable

*/

HRESULT 
CSecurityTemplate::PutInst (
    IN IWbemClassObject    * pInst,
    IN IWbemObjectSink     * pHandler,
    IN IWbemContext        * pCtx
    )
{

    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    
    //
    // CScePropertyMgr helps us to access WMI object's properties
    // create an instance and attach the WMI object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pInst);

    CComBSTR bstrDescription;
    hr = ScePropMgr.GetProperty(pDescription, &bstrDescription);
    if (SUCCEEDED(hr))
    {
        //
        // Attach the WMI object instance to the store and let the store know that
        // it's store is given by the pStorePath property of the instance.
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistProperties(pInst, pPath);

        //
        // now save the info to file
        //

        if (SUCCEEDED(hr))
        {
            //
            // make sure the store (just a file) really exists. The raw path
            // may contain env variables, so we need the expanded path
            //

            DWORD dwAttrib = GetFileAttributes(SceStore.GetExpandedPath());

            if ( dwAttrib == -1 ) 
            {
                DWORD dwDump;

                //
                // For a new .inf file. Write an empty buffer to the file
                // will creates the file with right header/signature/unicode format
                // this is harmless for existing files.
                // For database store, this is a no-op.
                //

                hr = SceStore.WriteSecurityProfileInfo(AreaBogus, (PSCE_PROFILE_INFO)&dwDump, NULL, false);
            }

            if (SUCCEEDED(hr))
            {
                //
                // remove the entire description section
                //

                hr = SceStore.SavePropertyToStore(szDescription, NULL, (LPCWSTR)NULL);
            }

            if (SUCCEEDED(hr))
            {
                //
                // write the new description
                //

                hr = SceStore.SavePropertyToStore(szDescription, pszDescription, bstrDescription);
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CSecurityTemplate::ConstructInstance

Functionality:
    
    This is private function to create an instance of Sce_Template.

Virtual:
    
    No.
    
Arguments:

    pHandler        - COM interface pointer for notifying WMI of any events.

    wszTemplateName - Name of the template.

    wszLogStorePath - store path, a key property of Sce_Template class.

    bReadOnly       - a property of Sce_Template class

Return Value:

    Success:  it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the creating the instance.

Notes:

*/

HRESULT 
CSecurityTemplate::ConstructInstance (
    IN IWbemObjectSink * pHandler,
    IN LPCWSTR           wszTemplateName,
    IN LPCWSTR           wszLogStorePath,
    IN BOOL              bReadOnly
    )
{
    //
    // Get description from the INF template
    //

    HRESULT hr = WBEM_S_NO_ERROR;
    SCESTATUS rc;
    PVOID hProfile = NULL;
    DWORD dwRevision = 0;

    rc = SceOpenProfile(wszTemplateName, SCE_INF_FORMAT, &hProfile);

    if ( rc != SCESTATUS_SUCCESS ) 
    {
        //
        // SCE returned errors needs to be translated to HRESULT.
        //

        return ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
    }

    LPWSTR wszDescription=NULL;
    CComBSTR bstrLogOut;

    CComPtr<IWbemClassObject> srpObj;

    //
    // CScePropertyMgr helps us to access WMI object's properties.
    //

    CScePropertyMgr ScePropMgr;

    //
    // description is not required so it could be NULL
    //

    //
    // need to free wszDescription
    //

    rc = SceGetScpProfileDescription( hProfile, &wszDescription ); 

    //
    // reading is over, so close the profile
    //

    SceCloseProfile( &hProfile );
    hProfile = NULL;

    if ( rc != SCESTATUS_SUCCESS && rc != SCESTATUS_RECORD_NOT_FOUND ) 
    {
        //
        // SCE returned errors needs to be translated to HRESULT.
        //

        hr = ProvDosErrorToWbemError(ProvSceStatusToDosError(rc));
        goto CleanUp;
    }

    //
    // Get version from the INF template
    //

    dwRevision = GetPrivateProfileInt(pszVersion, pszRevision, 0, wszTemplateName);

    //
    // the use of the macro SCE_PROV_IfErrorGotoCleanup cause
    // a "goto CleanUp;" with hr set to the return value from
    // the function (macro parameter)
    //

    SCE_PROV_IfErrorGotoCleanup(MakeSingleBackSlashPath(wszLogStorePath, L'\\', &bstrLogOut));

    SCE_PROV_IfErrorGotoCleanup(SpawnAnInstance(&srpObj));

    //
    // attach a WMI object to the property mgr.
    // This will always succeed.
    //

    ScePropMgr.Attach(srpObj);

    //
    // put path and descriptions
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pPath, bstrLogOut));
    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pDescription, wszDescription));

    //
    // put Revision
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pVersion, dwRevision));

    //
    // put bReadOnly and dirty
    //

    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pReadonly, bReadOnly ? true : false));
    SCE_PROV_IfErrorGotoCleanup(ScePropMgr.PutProperty(pDirty, false));

    SCE_PROV_IfErrorGotoCleanup(pHandler->Indicate(1, &srpObj));

CleanUp:

    delete [] wszDescription;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\template.h ===
// Template.h: interface for the CSecurityTemplate class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TEMPLATE_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
#define AFX_TEMPLATE_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

/*

Class description
    
    Naming:

        CSecurityTemplate stands for Security Template.
    
    Base class: 

        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_Template
    
    Purpose of class:
    
        (1) Implement Sce_Template WMI class.
    
    Design:
         
        (1) Almost trivial other than implementing necessary method as a concrete class
    
    Use:

        (1) Almost never used directly. Alway through the common interface defined by
            CGenericClass.
    
*/

class CSecurityTemplate : public CGenericClass
{
public:
        CSecurityTemplate (
                          ISceKeyChain *pKeyChain, 
                          IWbemServices *pNamespace, 
                          IWbemContext *pCtx = NULL
                          );

        virtual ~CSecurityTemplate ();

        virtual HRESULT PutInst (
                                IWbemClassObject *pInst, 
                                IWbemObjectSink *pHandler, 
                                IWbemContext *pCtx
                                );

        virtual HRESULT CreateObject (
                                     IWbemObjectSink *pHandler, 
                                     ACTIONTYPE atAction
                                     );

private:

        HRESULT ConstructInstance (
                                  IWbemObjectSink *pHandler,
                                  LPCWSTR wszTemplateName,
                                  LPCWSTR wszLogStorePath,
                                  BOOL bReadOnly 
                                  );
};

#endif // !defined(AFX_TEMPLATE_H__BD7570F7_9F0E_4C6B_B525_E078691B6D0E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\podtest\classfac.cpp ===
//***************************************************************************
//
//  CLASSFAC.CPP
//
//  Module: WMI Instance provider sample code (ESCAPE attachment)
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include "podprov.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;

    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    CPodTestProv *   pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.

    pObj=new CPodTestProv();
    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\tranx.cpp ===
// Tranx.cpp: implementation of the transaction support
//
// Copyright (c)1997-2001 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "Tranx.h"
#include "persistmgr.h"
#include "requestobject.h"

//
// this is a file scope global constant, representing the string length needed for a guid
// Our string guid is in this form as what StringFromGUID2 returns (includint braces):
//      {ab1ff71d-fff7-4162-818f-13d6e30c3110}

const DWORD GUID_STRING_LENGTH = 39;

/*
Routine Description: 

Name:

    CTranxID::CTranxID

Functionality:

    This is the constructor. Pass along the parameters to the base class

Virtual:
    
    No (you know that, constructor won't be virtual!)

Arguments:

    pKeyChain - Pointer to the ISceKeyChain COM interface which is prepared
        by the caller who constructs this instance.

    pNamespace - Pointer to WMI namespace of our provider (COM interface).
        Passed along by the caller. Must not be NULL.

    pCtx - Pointer to WMI context object (COM interface). Passed along
        by the caller. It's up to WMI whether this interface pointer is NULL or not.

Return Value:

    None as any constructor

Notes:
    if you create any local members, think about initialize them here

*/

CTranxID::CTranxID (
    IN ISceKeyChain     * pKeyChain, 
    IN IWbemServices    * pNamespace, 
    IN IWbemContext     * pCtx
    ) 
    : 
    CGenericClass(pKeyChain, pNamespace, pCtx)
{
}

/*
Routine Description: 

Name:

    CTranxID::~CTranxID

Functionality:
    
    Destructor. Necessary as good C++ discipline since we have virtual functions.

Virtual:
    
    Yes.
    
Arguments:

    none as any destructor

Return Value:

    None as any destructor

Notes:
    if you create any local members, think about whether
    there is any need for a non-trivial destructor

*/
CTranxID::~CTranxID ()
{
}

/*
Routine Description: 

Name:

    CTranxID::PutInst

Functionality:
    
    Put an instance as instructed by WMI. Since this class implements
    Sce_TransactionID, which is persistence oriented, this will cause
    the Sce_TransactionID object's property information to be saved
    in our store.

Virtual:
    
    Yes.
    
Arguments:

    pInst - COM interface pointer to the WMI class (Sce_TransactionID) object.

    pHandler - COM interface pointer for notifying WMI of any events.

    pCtx - COM interface pointer. This interface is just something we pass around.
            WMI may mandate it (not now) in the future. But we never construct
            such an interface and so, we just pass around for various WMI API's

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR.

    Failure: Various errors may occurs. Any such error should indicate the failure of persisting
    the instance.

Notes:

*/
HRESULT 
CTranxID::PutInst (
    IN IWbemClassObject * pInst, 
    IN IWbemObjectSink  * pHandler, 
    IN IWbemContext     * pCtx
    )
{
    //
    // CScePropertyMgr helps us to access WMI object's properties
    // create an instance and attach the WMI object to it.
    // This will always succeed.
    //

    CScePropertyMgr ScePropMgr;
    ScePropMgr.Attach(pInst);

    //
    // need to get the storepath property from the WMI object
    //

    CComBSTR vbstrStorePath;
    HRESULT hr = ScePropMgr.GetProperty(pStorePath, &vbstrStorePath);
    //
    // if storepath is missing, we can't continue because we don't know where to store the info
    //

    if (SUCCEEDED(hr))
    {
        //
        // get the transaction guid (we actually use string)
        //
        CComBSTR bstrToken;
        hr = ScePropMgr.GetProperty(pTranxGuid, &bstrToken);

        //
        // we will allow the object not to have a guid. In that case, we will create one ourselves
        //

        if (FAILED(hr) || WBEM_S_RESET_TO_DEFAULT == hr)
        {
            GUID guid = GUID_NULL;
            hr = ::CoCreateGuid(&guid);

            if (SUCCEEDED(hr))
            {
                //
                // allocate buffer for the guid's string representation
                // warning: don't blindly free this memory, it will be done by CComBSTR automatically!
                //
                bstrToken.m_str = ::SysAllocStringLen(NULL, GUID_STRING_LENGTH);
                if (bstrToken.m_str == NULL)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
                else
                {
                    //
                    // the only possibility for failure is that our buffer is too small
                    // which should not happen!
                    //
                    if (::StringFromGUID2(guid, bstrToken.m_str, GUID_STRING_LENGTH) == 0)
                    {
                        hr = WBEM_E_BUFFER_TOO_SMALL;
                    }
                }
            }
        }

        //
        // ready to save if everything is fine
        //

        if (SUCCEEDED(hr))
        {
            //
            // this store will be responsible for persisting the instance
            //

            CSceStore SceStore;

            //
            // the persistence is for having a storepath and on behalf of the instance
            //

            SceStore.SetPersistProperties(pInst, pStorePath);

            //
            // write the template header for inf files. For databases, this is a no-op
            //
            DWORD dwDump;
            hr = SceStore.WriteSecurityProfileInfo(AreaBogus, (PSCE_PROFILE_INFO)&dwDump, NULL, false);

            //
            // also, we need to write it to attachment section because it's not a native core object
            // without an entry in the attachment section, inf file tempalte can't be imported to
            // database stores. For database store, this is no-op
            //

            if (SUCCEEDED(hr))
            {
                hr = SceStore.WriteAttachmentSection(SCEWMI_TRANSACTION_ID_CLASS, pszAttachSectionValue);
            }

            //
            // Save all the properties
            //
            if (SUCCEEDED(hr))
            {
                hr = SceStore.SavePropertyToStore(SCEWMI_TRANSACTION_ID_CLASS, pTranxGuid, (LPCWSTR)bstrToken);
            }
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    CTranxID::CreateObject

Functionality:
    
    Create WMI objects (Sce_TransactionID). Depending on parameter atAction,
    this creation may mean:
        (a) Get a single instance (atAction == ACTIONTYPE_GET)
        (b) Get several instances satisfying some criteria (atAction == ACTIONTYPE_QUERY)
        (c) Delete an instance (atAction == ACTIONTYPE_DELETE)

Virtual:
    
    Yes.
    
Arguments:

    pHandler - COM interface pointer for notifying WMI for creation result.
    atAction -  Get single instance ACTIONTYPE_GET
                Get several instances ACTIONTYPE_QUERY
                Delete a single instance ACTIONTYPE_DELETE

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. The returned objects are indicated to WMI,
    not directly passed back via parameters.

    Failure: Various errors may occurs. Except WBEM_E_NOT_FOUND, any such error should indicate 
    the failure of getting the wanted instance. If WBEM_E_NOT_FOUND is returned in querying
    situations, this may not be an error depending on caller's intention.

Notes:

*/

HRESULT 
CTranxID::CreateObject (
    IN IWbemObjectSink  * pHandler,
    IN ACTIONTYPE         atAction
    )
{
    // 
    // we know how to:
    //      Get single instance ACTIONTYPE_GET
    //      Delete a single instance ACTIONTYPE_DELETE
    //      Get several instances ACTIONTYPE_QUERY
    //

    if ( ACTIONTYPE_GET != atAction &&
         ACTIONTYPE_DELETE != atAction &&
         ACTIONTYPE_QUERY != atAction ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // need to know where to look for the instance(s), i.e., the store path!
    //
    CComVariant varStorePath;

    HRESULT hr = m_srpKeyChain->GetKeyPropertyValue(pStorePath, &varStorePath);

    //
    // GetKeyPropertyValue returns WBEM_S_FALSE if the key is not recognized.
    // WMI may return success code with empty variant. So, we won't proceed
    // unless we know that we get a bstr
    //

    if (SUCCEEDED(hr) && hr != WBEM_S_FALSE && varStorePath.vt == VT_BSTR)
    {
        //
        // our store knows needs to know where to read instances.
        // If this fails, it doesn't make sense to continue.
        //

        CSceStore SceStore;
        hr = SceStore.SetPersistPath(varStorePath.bstrVal);

        if ( SUCCEEDED(hr) ) 
        {
            //
            // make sure the store (just a file) really exists. The raw path
            // may contain env variables, so we need the expanded path
            //

            DWORD dwAttrib = GetFileAttributes(SceStore.GetExpandedPath());

            if ( dwAttrib == -1 )
            {
                //
                // if store is not there, we indicate that the instance can't be found
                //
                hr = WBEM_E_NOT_FOUND;
            }
            else 
            {
                if ( ACTIONTYPE_DELETE == atAction )
                {
                    //
                    // since we will only ever have one instance,
                    // deleting the one means to remove the entire section
                    //

                    hr = SceStore.DeleteSectionFromStore(SCEWMI_TRANSACTION_ID_CLASS);
                }
                else
                {
                    //
                    // Will hold the transation ID. 
                    // Warning! Need to free this memory! So, don't blindly return!
                    //

                    LPWSTR pszTranxID = NULL;

                    DWORD dwRead = 0;
                    hr = SceStore.GetPropertyFromStore(SCEWMI_TRANSACTION_ID_CLASS, pTranxGuid, &pszTranxID, &dwRead);

                    //
                    // If successful, then fill in the tranx guid and store path properties.
                    // If transaction id can't be found, the object will be useless. So, should abort.
                    //

                    if (SUCCEEDED(hr))
                    {
                        //
                        // get from WMI a blank instance. See function definition for details.
                        // Smart pointer srpObj will automatically release interface pointer.
                        //

                        CComPtr<IWbemClassObject> srpObj;
                        hr = SpawnAnInstance(&srpObj);

                        if (SUCCEEDED(hr))
                        {
                            //
                            // use property manager to put the properties for this instance srpObj,
                            // Attach will always succeed.
                            //

                            CScePropertyMgr ScePropMgr;
                            ScePropMgr.Attach(srpObj);

                            //
                            // we have two properties to put: pStorePath, and pTranxGuid
                            //

                            hr = ScePropMgr.PutProperty(pStorePath, SceStore.GetExpandedPath());
                            if (SUCCEEDED(hr))
                            {
                                hr = ScePropMgr.PutProperty(pTranxGuid, pszTranxID);
                            }

                            //
                            // everything alright, pass to WMI the newly created instance!
                            //

                            if (SUCCEEDED(hr))
                            {
                                hr = pHandler->Indicate(1, &srpObj);
                            }
                        }
                    }

                    //
                    // we promise to release this memory
                    //

                    delete [] pszTranxID;
                }
            } 
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // do the necessary gestures to WMI.
        // the use of WBEM_STATUS_REQUIREMENTS in SetStatus is not documented by WMI
        // at this point. Consult WMI team for detail if you suspect problems with
        // the use of WBEM_STATUS_REQUIREMENTS
        //

        if ( ACTIONTYPE_QUERY == atAction )
        {
            pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_FALSE, NULL, NULL);
        }
        else if (ACTIONTYPE_GET  == atAction)
        {
            pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    static CTranxID::BeginTransaction

Functionality:
    
    Given a store path (file to the template), this function will start a transaction
    by creating our transaction token (an ID).

Virtual:
    
    no.
    
Arguments:

    pszStorePath - 0 terminated string as the tempalte file's path

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR. 

    Failure: Various errors may occurs. Except WBEM_E_NOT_AVAILABLE, any such error should indicate 
    the serious failure. WBEM_E_NOT_AVAILABLE is used to indicate that this template does
    not have any transaction related information, and therefore the template won't be able
    to have its own transaction context. This may or may not be an error

Notes:
    Our transction token (Sce_TransactionToken) is not persisted. Our provider provides that
    instance on bases of the validility of our global BSTR varialbe g_bstrTranxID. Due to
    the global nature of g_bstrTranxID, its access should be protected from different threads.
    For that purpose, we use a global critical section g_CS, which is an instance of
    CCriticalSection. CCriticalSection is a very simple wrapper of CRITICAL_SECTION to simply
    its creation/destruction time.

*/
HRESULT 
CTranxID::BeginTransaction (
    IN LPCWSTR  pszStorePath
    )
{
    //
    // we don't allow NULL path or zero length path
    //

    if (pszStorePath == NULL || *pszStorePath == L'\0')
        return WBEM_E_INVALID_PARAMETER;

    //
    // Inform the store that all its reading action will take place inside this template
    //

    CSceStore SceStore;
    HRESULT hr = SceStore.SetPersistPath(pszStorePath);

    if ( SUCCEEDED(hr) ) 
    {
        //
        // make sure that the template really exists!
        // Since passed-in parameter of store path may contain env varaibles, we need to use its
        // expanded path for file access!
        //

        DWORD dwAttrib = ::GetFileAttributes(SceStore.GetExpandedPath());

        //
        // if the file exist
        //
        if ( dwAttrib != -1 ) 
        {
            DWORD dwRead = 0;

            //
            // GetPropertyFromStore will allocate memory for the property read.
            // We are responsible to free it.
            //
            LPWSTR pszTranxID = NULL;

            //
            // Read the transaction id property, dwRead will contain the bytes read from the store.
            // Since we have no minimum length requirement, dwRead is ignored as long as something is read!
            //

            hr = SceStore.GetPropertyFromStore(SCEWMI_TRANSACTION_ID_CLASS, pTranxGuid, &pszTranxID, &dwRead);
            if (SUCCEEDED(hr))
            {
                //
                // To flag ourselves that a transaction is in place, we set our global
                // varialbe b_bstrTranxID to a valid value (non-empty means valid). Since it's
                // global, we need thread protection!
                //
                g_CS.Enter();
                g_bstrTranxID.Empty();
                g_bstrTranxID = pszTranxID;
                g_CS.Leave();
            }
            delete [] pszTranxID;
        } 
        else
        {
            // indicate that the store doesn't exists
            hr = WBEM_E_NOT_AVAILABLE;
        }
    }

    return hr;
}

/*
Routine Description: 

Name:

    static CTranxID::EndTransaction

Functionality:
    
    Terminate the transaction. Unlike real transaction management, we don't
    have a commit function because without the user initiated the rollback, we
    can't do a rollback. Therefore, our "transaction" only has a begin and end
    to define its range of action.

Virtual:
    
    no.
    
Arguments:

    none

Return Value:

    WBEM_NO_ERROR

Notes:
    See CTranxID::BeginTransaction

*/
HRESULT 
CTranxID::EndTransaction()
{
    //
    // now the transaction is over, we will remove the Sce_TransactionToken instance.
    // We do that by invalidating our global variable g_bstrTranxID. An empty g_bstrTranxID
    // means it's invalid.
    //

    g_CS.Enter();
    g_bstrTranxID.Empty();
    g_CS.Leave();
    return WBEM_NO_ERROR;
}

/*
Routine Description: 

Name:

    static CTranxID::SpawnTokenInstance

Functionality:
    
    Caller gives us the transaction ID, we will make a WMI object (Sce_TransactionToken)
    to the caller.

Virtual:
    
    no.
    
Arguments:

    pNamespace - COM interface pointer to IWbemServices. This is the namespace. 
            Can't be NULL.

    pszTranxID - caller supplied string representing the transactio id.

    pCtx - COM interface pointer to IWbemContext. Need to pass this around in 
            various WMI calls.

    pSink - COM interface pointer to IWbemObjectSink. Used to notify WMI for newly 
            created instance. Must not be NULL.

Return Value:

    Success: it must return success code (use SUCCEEDED to test). It is
    not guaranteed to return WBEM_NO_ERROR (up to WMI)

    Failure: Various errors may occurs. Any such error should indicate failure to create the
    Sce_TransactionToken instance for the caller.

Notes:
    Call this function with a transaction ID string will cause an instance of
    Sce_TransactionToken being created.

*/

HRESULT 
CTranxID::SpawnTokenInstance (
    IN IWbemServices    * pNamespace,
    IN LPCWSTR            pszTranxID,
    IN IWbemContext     * pCtx,
    IN IWbemObjectSink  * pSink
    )
{
    //
    // minimu requirement for the parameters:
    // (1) non-NULL namepsace
    // (2) a valid id string (length greater than 0)
    // (3) a valid sink (so that we can notify WMI)
    //

    if (pNamespace == NULL || pszTranxID == NULL || *pszTranxID == L'\0' || pSink == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // GetObject (WMI defined) requires a BSTR. We use a CComBSTR for auto releasing of memory
    //
    CComBSTR bstrClassName(SCEWMI_TRANSACTION_TOKEN_CLASS);

    //
    // What returned from pNamespace->GetObject can't be used to fill in properties.
    // It's only good for spawn a blank instance which can be used to fill in properties!
    // Some weird WMI protocol!
    //
    CComPtr<IWbemClassObject> srpSpawnObj;
    HRESULT hr = pNamespace->GetObject(bstrClassName, 0, NULL, &srpSpawnObj, NULL);

    //
    // This one will be good to fill in properties
    //

    CComPtr<IWbemClassObject> srpBlankObj;
    if (SUCCEEDED(hr))
    {
        hr = srpSpawnObj->SpawnInstance(0, &srpBlankObj);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Use our property manager to fill in property for this newly spawned instance
        //

        CScePropertyMgr ScePropMgr;
        ScePropMgr.Attach(srpBlankObj);
        hr = ScePropMgr.PutProperty(pTranxGuid, pszTranxID);

        //
        // we never want to hand out a Sce_TransactionToken object without
        // its critical property of transaction id. So, only when we have successfully
        // put in that property will we inform WMI for the object.
        //
        if (SUCCEEDED(hr))
        {
            hr = pSink->Indicate(1, &srpBlankObj);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\tranx.h ===
// Tranx.h: interface for transaction support.
// Copyright (c)1997-2001 Microsoft Corporation
//
// Original date of creation: 4/09/2001
// Author: shawnwu
//////////////////////////////////////////////////////////////////////
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "precomp.h"
#include "sceprov.h"

#include "GenericClass.h"

/*

Class description
    
    Naming: 

        CTranxID stands for Transaction ID
    
    Base class: 

        CGenericClass, because it is a class representing a WMI  
        object - its WMI class name is Sce_TransactionID
    
    Purpose of class:

        (1) Sce_TransactionID is the transaction ID that is used for
            providers to identify who is causing its action so that 
            we stand a chance to ask that provider to rollback this action.
            Foreign providers should use this ID to identify what they did
            during the transaction. Currently, WMI doesn't have transaction
            support and we need to do it our own. When WMI has that support,
            we can remove this class all together (if no third parties are
            using it).

        (2) CTranxID implements this WMI class Sce_TransactionID so that
            the SCE provider can process request for this WMI class. This
            Sce_TransactionID is a store oriented class, i.e., it is saved
            into a store when PutInst is called to this class.
    
    Design:

        (1) it implements all pure virtual functions declared in CGenericClass
            so that it is a concrete class to create.

        (2) Since it has virtual functions, the desctructor should be virtual.

        (3) This class is the only one that will create another WMI class called
            Sce_TransactionToken. See function header comments of SpawnTokenInstance.
    Use:

        (1) This class fulfills its obligation to Sce_TransactionID. The use for that
            functionality is guided by CGenericClass and you use it just as it is a
            CGenericClass object.

        (2) Use its static function in the following ways:

            (a) if you have a transaction id (in the form of a string), you can
                spawn a WMI instance of Sce_TransactionToken by calling SpawnTokenInstance

            (b) Call BeginTransaction to begin a transaction if that store (parameter)
                has a transaction id instance (Sce_TransactionID), then it will start
                a transaction. When you are done, call EndTransaction.
*/

class CTranxID : public CGenericClass
{

public:
    CTranxID(
            ISceKeyChain *pKeyChain, 
            IWbemServices *pNamespace, 
            IWbemContext *pCtx
            );
    virtual ~CTranxID();

public:

    //
    // The following four virtual functions are all mandatory to implement to become a concrete class
    //

    virtual HRESULT PutInst(
                            IWbemClassObject *pInst, 
                            IWbemObjectSink *pHandler, 
                            IWbemContext *pCtx
                            );

    virtual HRESULT CreateObject(
                                IWbemObjectSink *pHandler, 
                                ACTIONTYPE atAction
                                );

    // 
    // we have nothing to clean up
    //

    virtual void CleanUp(){}

    static HRESULT BeginTransaction(
                                    LPCWSTR pszStorePath
                                    );
                                    
    static HRESULT EndTransaction();

    static HRESULT SpawnTokenInstance(
                                      IWbemServices* pNamespace,
                                      LPCWSTR pszTranxID,
                                      IWbemContext *pCtx,
                                      IWbemObjectSink* pSink
                                      );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\podtest\genericclass.h ===
// GenericClass.h: interface for the CGenericClass class.
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GENERICCLASS_H__c5f6cc21_6195_4555_b9d8_3ef327763cae__INCLUDED_)
#define AFX_GENERICCLASS_H__c5f6cc21_6195_4555_b9d8_3ef327763cae__INCLUDED_

#include "requestobject.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CGenericClass
{
public:
    CGenericClass(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
    virtual ~CGenericClass();

    //The instance write class which can optionally be implemented
    virtual HRESULT PutInst(IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)  = 0;

    IWbemClassObject *m_pObj;

    //The instance creation class which must be implemented
    virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction) = 0;

    //The method execution class which can be optionally be implemented
    virtual HRESULT ExecMethod(BSTR bstrMethod, bool bIsInstance, IWbemClassObject *pInParams,IWbemObjectSink *pHandler, IWbemContext *pCtx) = 0;

    void CleanUp();

    CRequestObject *m_pRequest;

protected:
    //Property Methods
    HRESULT PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, WCHAR *wcValue);
    HRESULT PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, int iValue);
    HRESULT PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, float dValue);
    HRESULT PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, bool bValue);
    HRESULT PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, WCHAR *mszValue, CIMTYPE cimtype);

    //Key Property Methods
    HRESULT PutKeyProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, WCHAR *wcValue,
        bool *bKey, CRequestObject *pRequest);
    HRESULT PutKeyProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, int iValue,
        bool *bKey, CRequestObject *pRequest);

    //Utility Methods
    bool FindIn(BSTR bstrProp[], BSTR bstrSearch, int *iPos);
    HRESULT SetSinglePropertyPath(WCHAR wcProperty[]);
    HRESULT GetProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, WCHAR *wcValue);
    HRESULT GetProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, BSTR *wcValue);
    HRESULT GetProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, int *piValue);
    HRESULT GetProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, bool *pbValue);

    WCHAR * GetFirstGUID(WCHAR wcIn[], WCHAR wcOut[]);
    WCHAR * RemoveFinalGUID(WCHAR wcIn[], WCHAR wcOut[]);

    HRESULT SpawnAnInstance(IWbemServices *pNamespace, IWbemContext *pCtx,
                        IWbemClassObject **pObj, BSTR bstrName);
    HRESULT SpawnAnInstance(IWbemClassObject **pObj);

    int m_iRecurs;
    IWbemServices *m_pNamespace;
    IWbemClassObject *m_pClassForSpawning;
    IWbemContext *m_pCtx;

    WCHAR * GetNextVar(WCHAR *pwcStart);
    long GetVarCount(void * pEnv);

};

#endif // !defined(AFX_GENERICCLASS_H__c5f6cc21_6195_4555_b9d8_3ef327763cae__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\podtest\genericclass.cpp ===
// GenericClass.cpp: implementation of the CGenericClass class.
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "GenericClass.h"
#include <wininet.h>

#define   READ_HANDLE 0
#define   WRITE_HANDLE 1

/////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGenericClass::CGenericClass(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx)
{
    m_pRequest = pObj;
    m_pNamespace = pNamespace;
    m_pCtx = pCtx;
    m_iRecurs = 0;
    m_pObj = NULL;
    m_pClassForSpawning = NULL;

}

CGenericClass::~CGenericClass()
{
}

void CGenericClass::CleanUp()
{
    if(m_pClassForSpawning){

        m_pClassForSpawning->Release();
        m_pClassForSpawning = NULL;
    }

}


HRESULT CGenericClass::SetSinglePropertyPath(WCHAR wcProperty[])
{
    if(m_pRequest->m_iValCount > m_pRequest->m_iPropCount){

        m_pRequest->m_Property[m_pRequest->m_iPropCount] = SysAllocString(wcProperty);

        if(!m_pRequest->m_Property[(m_pRequest->m_iPropCount)++])
            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
    }

    return S_OK;
}

WCHAR * CGenericClass::GetFirstGUID(WCHAR wcIn[], WCHAR wcOut[])
{
    wcscpy(wcOut, wcIn);
    wcOut[38] = NULL;

    return wcOut;
}

WCHAR * CGenericClass::RemoveFinalGUID(WCHAR wcIn[], WCHAR wcOut[])
{

    wcscpy(wcOut, wcIn);
    wcOut[wcslen(wcOut) - 38] = NULL;

    return wcOut;
}

HRESULT CGenericClass::SpawnAnInstance(IWbemServices *pNamespace, IWbemContext *pCtx,
                        IWbemClassObject **pObj, BSTR bstrName)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(!m_pClassForSpawning){

        //Get ourselves an instance
        if(FAILED(hr = m_pNamespace->GetObject(bstrName, 0, m_pCtx, &m_pClassForSpawning, NULL))){

            *pObj = NULL;
            return hr;
        }
    }

    hr = m_pClassForSpawning->SpawnInstance(0, pObj);

    return hr;
}

HRESULT CGenericClass::SpawnAnInstance(IWbemClassObject **pObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(!m_pClassForSpawning){

        //Get ourselves an instance
        if(FAILED(hr = m_pNamespace->GetObject(m_pRequest->m_bstrClass, 0, m_pCtx,
            &m_pClassForSpawning, NULL))){

            *pObj = NULL;
            return hr;
        }
    }

    hr = m_pClassForSpawning->SpawnInstance(0, pObj);

    return hr;
}

HRESULT CGenericClass::PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, WCHAR *wcValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
    BSTR bstrName = SysAllocString(wcProperty);
    if(!bstrName)
        throw he;

    VARIANT *vp = new VARIANT;
    VariantInit(vp);
    V_VT(vp) = VT_BSTR;
    V_BSTR(vp) = SysAllocString(wcValue);
    if(!V_BSTR(vp)){

        SysFreeString(bstrName);
        throw he;
    }

    if((wcValue == NULL) || (0 != _wcsicmp(wcValue, L""))){

        hr = pObj->Put(bstrName, 0, vp, NULL);

        if(FAILED(hr)){

            SysFreeString(bstrName);
            VariantClear(vp);
            delete vp;
            throw hr;
        }

    }else hr = WBEM_E_FAILED;

    SysFreeString(bstrName);
    VariantClear(vp);
    delete vp;

    return hr;
}

HRESULT CGenericClass::PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, int iValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    BSTR bstrName = SysAllocString(wcProperty);
    if(!bstrName)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;


    VARIANT *pv = new VARIANT;

    if(iValue != POD_NULL_INTEGER){

        VariantInit(pv);
        V_VT(pv) = VT_I4;
        V_I4(pv) = iValue;

        hr = pObj->Put(bstrName, 0, pv, NULL);

        VariantClear(pv);

        if(FAILED(hr)){

            SysFreeString(bstrName);
            delete pv;
            throw hr;
        }

    }else hr = WBEM_E_FAILED;

    SysFreeString(bstrName);
    delete pv;

    return hr;
}

HRESULT CGenericClass::PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, float dValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    BSTR bstrName = SysAllocString(wcProperty);
    if(!bstrName)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    VARIANT *pv = new VARIANT;

    VariantInit(pv);
    V_VT(pv) = VT_R4;
    V_R4(pv) = dValue;

    hr = pObj->Put(bstrName, 0, pv, NULL);

    SysFreeString(bstrName);
    VariantClear(pv);
    delete pv;

    if(FAILED(hr))
        throw hr;

    return hr;
}

HRESULT CGenericClass::PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, bool bValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    BSTR bstrName = SysAllocString(wcProperty);
    if(!bstrName)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    VARIANT *pv = new VARIANT;
    VariantInit(pv);
    V_VT(pv) = VT_BOOL;
    if(bValue) V_BOOL(pv) = VARIANT_TRUE;
    else V_BOOL(pv) = VARIANT_FALSE;

    hr = pObj->Put(bstrName, 0, pv, NULL);

    SysFreeString(bstrName);
    VariantClear(pv);
    delete pv;

    if(FAILED(hr))
        throw hr;

    return hr;
}


HRESULT CGenericClass::PutProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, WCHAR *mszValue, CIMTYPE cimtype)
{

    HRESULT hr = WBEM_S_NO_ERROR;
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    long lCount=0;
    PWSTR pTemp;

    for ( pTemp = mszValue; pTemp != NULL && pTemp[0] != L'\0'; pTemp = pTemp + wcslen(pTemp)+1,lCount++);
    if ( lCount == 0 ) return hr; // nothing to save

    BSTR bstrName = SysAllocString(wcProperty);
    if(!bstrName)
        throw he;

    VARIANT v;
    SAFEARRAYBOUND sbArrayBounds ;

    sbArrayBounds.cElements = lCount;
    sbArrayBounds.lLbound = 0;

    if(V_ARRAY(&v) = SafeArrayCreate(VT_BSTR, 1, &sbArrayBounds)){

        V_VT(&v) = VT_BSTR | VT_ARRAY ;

        BSTR bstrVal;
        long j;

        //get each string in the MULTI-SZ string
        for(j = 0, pTemp = mszValue;
            j < lCount && pTemp != NULL && pTemp[0] != L'\0';
            j++, pTemp=pTemp+wcslen(pTemp)+1){

            bstrVal = SysAllocString(pTemp);
            SafeArrayPutElement(V_ARRAY(&v), &j, bstrVal);
            SysFreeString(bstrVal);
        }

        hr = pObj->Put(bstrName, 0, &v, NULL);

        if ( FAILED(hr) ) {
            SysFreeString(bstrName);
            VariantClear(&v);
            throw hr;
        }

    }else hr = WBEM_E_FAILED;

    SysFreeString(bstrName);
    VariantClear(&v);

    return hr;
}

HRESULT CGenericClass::PutKeyProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, WCHAR *wcValue,
                                      bool *bKey, CRequestObject *pRequest)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    BSTR bstrName = SysAllocString(wcProperty);
    if(!bstrName)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    VARIANT *pv = new VARIANT;
    VariantInit(pv);
    V_VT(pv) = VT_BSTR;
#ifdef _STRIP_ESCAPED_CHARS
    V_BSTR(pv) = SysAllocString(ConvertToASCII(wcValue));
#else
    V_BSTR(pv) = SysAllocString(wcValue);
#endif //_STRIP_ESCAPED_CHARS

    if(!V_BSTR(pv))
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    if((wcValue == NULL) || (0 != wcscmp(wcValue, L""))){

        hr = pObj->Put(bstrName, 0, pv, NULL);

        if(FAILED(hr)){

            SysFreeString(bstrName);
            VariantClear(pv);
            delete pv;
            throw hr;
        }

        // Find the keys
        *bKey = false;
        int iPos = -1;
        if(FindIn(pRequest->m_Property, bstrName, &iPos) &&
            FindIn(pRequest->m_Value, V_BSTR(pv), &iPos)) *bKey = true;

    }else hr = WBEM_E_FAILED;

    SysFreeString(bstrName);
    VariantClear(pv);
    delete pv;

    return hr;
}

HRESULT CGenericClass::PutKeyProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, int iValue,
                                      bool *bKey, CRequestObject *pRequest)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    BSTR bstrName = SysAllocString(wcProperty);
    if(!bstrName)
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

    VARIANT *pv = new VARIANT;
    WCHAR wcBuf[BUFF_SIZE];

    if(iValue != POD_NULL_INTEGER){

        VariantInit(pv);
        V_VT(pv) = VT_I4;
        V_I4(pv) = iValue;

        hr = pObj->Put(bstrName, 0, pv, NULL);

        VariantClear(pv);
        delete pv;

        if(FAILED(hr)){

            SysFreeString(bstrName);
            throw hr;
        }

        // Find the keys
        _itow(iValue, wcBuf, 10);
        BSTR bstrValue = SysAllocString(wcBuf);
        if(!bstrValue)
            throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);;

        *bKey = false;
        int iPos = -1;
        if(FindIn(pRequest->m_Property, bstrName, &iPos) &&
            FindIn(pRequest->m_Value, bstrValue, &iPos)) *bKey = true;

        SysFreeString(bstrValue);

    }else hr = WBEM_E_FAILED;

    SysFreeString(bstrName);

    return hr;
}

bool CGenericClass::FindIn(BSTR bstrProp[], BSTR bstrSearch, int *iPos)
{
    int i = 0;

    if(*iPos == (-1)){

        while(bstrProp[i] != NULL){

            if(0 == _wcsicmp(bstrProp[i], bstrSearch)){

                *iPos = i;
                return true;
            }

            i++;
        }

    }else{

        if(0 == _wcsicmp(bstrProp[*iPos], bstrSearch)) return true;
    }

    return false;
}


HRESULT CGenericClass::GetProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, WCHAR *wcValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    VARIANT v;
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrProp = SysAllocString(wcProperty);
    if(!bstrProp)
        throw he;

    VariantInit(&v);

    if(SUCCEEDED(hr = pObj->Get(bstrProp, 0, &v, NULL, NULL))){

        if(V_VT(&v) == VT_BSTR) wcscpy(wcValue, V_BSTR(&v));
        else if(V_VT(&v) == VT_EMPTY || V_VT(&v) == VT_NULL ) hr = WBEM_S_RESET_TO_DEFAULT;
        else wcscpy(wcValue, L"");
    }

    SysFreeString(bstrProp);
    VariantClear(&v);

    return hr;
}

HRESULT CGenericClass::GetProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, BSTR *wcValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    VARIANT v;
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrProp = SysAllocString(wcProperty);
    if(!bstrProp)
        throw he;

    VariantInit(&v);

    if(SUCCEEDED(hr = pObj->Get(bstrProp, 0, &v, NULL, NULL))){

        if(wcslen(V_BSTR(&v)) > INTERNET_MAX_PATH_LENGTH) return WBEM_E_INVALID_METHOD_PARAMETERS;

        if(V_VT(&v) == VT_BSTR) *wcValue = SysAllocString(V_BSTR(&v));
        else if(V_VT(&v) == VT_EMPTY || V_VT(&v) == VT_NULL ) hr = WBEM_S_RESET_TO_DEFAULT;
        else *wcValue = SysAllocString(L"");

        if(hr != WBEM_S_RESET_TO_DEFAULT && !wcValue)
            throw he;
    }

    SysFreeString(bstrProp);
    VariantClear(&v);

    return hr;
}

HRESULT CGenericClass::GetProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, int *piValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    VARIANT v;
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrProp = SysAllocString(wcProperty);
    if(!bstrProp)
        throw he;

    VariantInit(&v);

    if(SUCCEEDED(hr = pObj->Get(bstrProp, 0, &v, NULL, NULL))){

        if(V_VT(&v) == VT_I4) *piValue = V_I4(&v);
        else if(V_VT(&v) == VT_EMPTY || V_VT(&v) == VT_NULL ) hr = WBEM_S_RESET_TO_DEFAULT;
        else *piValue = 0;
    }

    SysFreeString(bstrProp);
    VariantClear(&v);

    return hr;
}

HRESULT CGenericClass::GetProperty(IWbemClassObject *pObj, const WCHAR *wcProperty, bool *pbValue)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    VARIANT v;
    CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrProp = SysAllocString(wcProperty);
    if(!bstrProp)
        throw he;

    VariantInit(&v);

    if(SUCCEEDED(hr = pObj->Get(bstrProp, 0, &v, NULL, NULL))){

        if((V_VT(&v) == VT_BOOL) & V_BOOL(&v)) *pbValue = true;
        else if(V_VT(&v) == VT_EMPTY || V_VT(&v) == VT_NULL ) hr = WBEM_S_RESET_TO_DEFAULT;
        else *pbValue = false;
    }

    SysFreeString(bstrProp);
    VariantClear(&v);

    return hr;
}


WCHAR * CGenericClass::GetNextVar(WCHAR *pwcStart)
{

    WCHAR *pwc = pwcStart;

    //get to end of variable
    while(*pwc){ pwc++; }

    return ++pwc;
}

long CGenericClass::GetVarCount(void * pEnv)
{

    long lRetVal = 0;
    WCHAR *pwc = (WCHAR *)pEnv;

    //count the variables
    while(*pwc){

        //get to end of variable
        while(*pwc){ pwc++; }

        pwc++;
        lRetVal++;
    }

    return lRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\podtest\podprov.cpp ===
//***************************************************************************
//
//  PodProv.CPP
//
//  Module: Sample WMIprovider (SCE attachment)
//
//  Purpose: Defines the CPodTestProv class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#include "podprov.h"
#include "requestobject.h"
// #define _MT
#include <process.h>

CHeap_Exception CPodTestProv::m_he(CHeap_Exception::E_ALLOCATION_ERROR);

//***************************************************************************
//
// CPodTestProv::CPodTestProv
// CPodTestProv::~CPodTestProv
//
//***************************************************************************

CPodTestProv::CPodTestProv()
{
    m_cRef=0;
    m_pNamespace = NULL;

    InterlockedIncrement(&g_cObj);
    return;
}

CPodTestProv::~CPodTestProv(void)
{
    if(m_pNamespace) m_pNamespace->Release();

    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CPodTestProv::QueryInterface
// CPodTestProv::AddRef
// CPodTestProv::Release
//
// Purpose: IUnknown members for CPodTestProv object.
//***************************************************************************


STDMETHODIMP CPodTestProv::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;


    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;

}


STDMETHODIMP_(ULONG) CPodTestProv::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CPodTestProv::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;

    return nNewCount;
}

/***********************************************************************
*                                                                      *
*   CPodTestProv::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CPodTestProv::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace,
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
    HRESULT hres;

    if(pNamespace){
        m_pNamespace = pNamespace;
        m_pNamespace->AddRef();
    }

    //Let CIMOM know you are initialized
    //==================================

    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CPodTestProv::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.
//
//***************************************************************************

STDMETHODIMP CPodTestProv::CreateInstanceEnumAsync(const BSTR strClass, long lFlags,
        IWbemContext *pCtx, IWbemObjectSink* pSink)
{
    //check parameters
    //=========================
    if(strClass == NULL || pSink == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // make sure impersonated
    //======================================
    HRESULT hr=WBEM_S_NO_ERROR;
    CRequestObject *pRObj = NULL;

    try{

        if ( FAILED( CoImpersonateClient() ) ) return WBEM_E_ACCESS_DENIED;

        //Create the RequestObject
        pRObj = new CRequestObject();
        if(!pRObj) throw m_he;

        pRObj->Initialize(m_pNamespace);

        //Get the requested object(s)
        hr = pRObj->CreateObjectEnum(strClass, pSink, pCtx);

        pRObj->Cleanup();
        delete pRObj;

        // Set status
        pSink->SetStatus(0, hr, NULL, NULL);

    }catch(CHeap_Exception e_HE){

        hr = WBEM_E_OUT_OF_MEMORY;

        pSink->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){

            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(HRESULT e_hr){

        hr = e_hr;

        pSink->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){

            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(...){

        hr = WBEM_E_CRITICAL_ERROR;

        pSink->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){

            pRObj->Cleanup();
            delete pRObj;
        }
    }

    return hr;
}


//***************************************************************************
//
// CPodTestProv::GetObjectByPath
// CPodTestProv::GetObjectByPathAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************

SCODE CPodTestProv::GetObjectAsync(const BSTR strObjectPath, long lFlags,
                    IWbemContext  *pCtx, IWbemObjectSink* pSink)
{

    //check parameters
    //=========================
    if(strObjectPath == NULL || pSink == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    HRESULT hr=WBEM_S_NO_ERROR;
    CRequestObject *pRObj = NULL;

    try{

        if ( FAILED( CoImpersonateClient() ) ) return WBEM_E_ACCESS_DENIED;

        //Create the RequestObject
        pRObj = new CRequestObject();
        if(!pRObj) throw m_he;

        pRObj->Initialize(m_pNamespace);

        //Get the requested object(s)
        hr = pRObj->CreateObject(strObjectPath, pSink, pCtx);

        pRObj->Cleanup();
        delete pRObj;

        // Set status
        pSink->SetStatus(0, hr, NULL, NULL);

    }catch(CHeap_Exception e_HE){

        hr = WBEM_E_OUT_OF_MEMORY;

        pSink->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){

            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(HRESULT e_hr){

        hr = e_hr;

        pSink->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){

            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(...){

        hr = WBEM_E_CRITICAL_ERROR;

        pSink->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){

            pRObj->Cleanup();
            delete pRObj;
        }
    }

    return hr;
}

//***************************************************************************
//
// CPodTestProv::PutInstanceAsync
//
// Purpose: Writes an instance.
//
//***************************************************************************
SCODE CPodTestProv::PutInstanceAsync(IWbemClassObject FAR *pInst, long lFlags, IWbemContext  *pCtx,
                                 IWbemObjectSink FAR *pSink)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pRObj = NULL;

    try{
        // Do a check of arguments and make sure we have pointer to Namespace
        if(pInst == NULL || pSink == NULL)
            return WBEM_E_INVALID_PARAMETER;

        if ( FAILED( CoImpersonateClient() ) ) return WBEM_E_ACCESS_DENIED;

        //Create the RequestObject
        pRObj = new CRequestObject();
        if(!pRObj) throw m_he;

        pRObj->Initialize(m_pNamespace);

        //Put the object
        hr = pRObj->PutObject(pInst, pSink, pCtx);

        pRObj->Cleanup();
        delete pRObj;

        // Set Status
        pSink->SetStatus(0 ,hr , NULL, NULL);

    }catch(CHeap_Exception e_HE){
        hr = WBEM_E_OUT_OF_MEMORY;

        pSink->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){
            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(HRESULT e_hr){
        hr = e_hr;

        pSink->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){
            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(...){

        hr = WBEM_E_CRITICAL_ERROR;

        pSink->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){
            pRObj->Cleanup();
            delete pRObj;
        }
    }

    return hr;
}

//***************************************************************************
//
// CPodTestProv::ExecMethodAsync
//
// Purpose: Executes a method on a class
//
//***************************************************************************
SCODE CPodTestProv::ExecMethodAsync(const BSTR ObjectPath, const BSTR Method, long lFlags,
                                IWbemContext *pCtx, IWbemClassObject *pInParams,
                                IWbemObjectSink *pResponse)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pRObj = NULL;

    try{

        // Do a check of arguments and make sure we have pointer to Namespace
        if(ObjectPath == NULL || Method == NULL || pResponse == NULL)
            return WBEM_E_INVALID_PARAMETER;

        if ( FAILED( CoImpersonateClient() ) ) return WBEM_E_ACCESS_DENIED;

        //Create the RequestObject
        pRObj = new CRequestObject();
        if(!pRObj) throw m_he;

        pRObj->Initialize(m_pNamespace);

        //Execute the method
        hr = pRObj->ExecMethod(ObjectPath, Method, pInParams, pResponse, pCtx);

        pRObj->Cleanup();
        delete pRObj;

        // Set Status
        pResponse->SetStatus(WBEM_STATUS_COMPLETE ,hr , NULL, NULL);

    }catch(CHeap_Exception e_HE){

        hr = WBEM_E_OUT_OF_MEMORY;

        pResponse->SetStatus(WBEM_STATUS_COMPLETE , hr, NULL, NULL);

        if(pRObj){

            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(HRESULT e_hr){
        hr = e_hr;

        pResponse->SetStatus(WBEM_STATUS_COMPLETE , hr, NULL, NULL);

        if(pRObj){

            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(...){

        hr = WBEM_E_CRITICAL_ERROR;

        pResponse->SetStatus(WBEM_STATUS_COMPLETE , hr, NULL, NULL);

        if(pRObj){

            pRObj->Cleanup();
            delete pRObj;
        }
    }

    return hr;
}

SCODE CPodTestProv::DeleteInstanceAsync(const BSTR ObjectPath, long lFlags, IWbemContext *pCtx,
                                    IWbemObjectSink *pResponseHandler)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pRObj = NULL;

    try{
        // Do a check of arguments and make sure we have pointer to Namespace
        if(ObjectPath == NULL || pResponseHandler == NULL) return WBEM_E_INVALID_PARAMETER;

        if ( FAILED( CoImpersonateClient() ) ) return WBEM_E_ACCESS_DENIED;

        //Create the RequestObject
        pRObj = new CRequestObject();
        if(!pRObj) throw m_he;

        pRObj->Initialize(m_pNamespace);

        //Delete the requested object
        hr = pRObj->DeleteObject(ObjectPath, pResponseHandler, pCtx);

        pRObj->Cleanup();
        delete pRObj;

        // Set Status
        pResponseHandler->SetStatus(0 ,hr , NULL, NULL);

    }catch(CHeap_Exception e_HE){
        hr = WBEM_E_OUT_OF_MEMORY;

        pResponseHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){
            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(HRESULT e_hr){
        hr = e_hr;

        pResponseHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){
            pRObj->Cleanup();
            delete pRObj;
        }

    }catch(...){
        hr = WBEM_E_CRITICAL_ERROR;

        pResponseHandler->SetStatus(0 , hr, NULL, NULL);

        if(pRObj){
            pRObj->Cleanup();
            delete pRObj;
        }
    }

#ifdef _PRIVATE_DEBUG
    if(!HeapValidate(GetProcessHeap(),NULL , NULL)) DebugBreak();
#endif

    return hr;
}


HRESULT CPodTestProv::ExecQueryAsync(const BSTR QueryLanguage, const BSTR Query, long lFlags,
                                 IWbemContext __RPC_FAR *pCtx, IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr;

    hr = WBEM_E_NOT_SUPPORTED;

    return hr;
}



HRESULT CheckAndExpandPath(BSTR bstrIn,
                           BSTR *bstrOut
                          )
{

    if ( bstrIn == NULL || bstrOut == NULL ) {
        return WBEM_E_INVALID_PARAMETER;
    }

    DWORD Len = SysStringLen(bstrIn);

    HRESULT hr=WBEM_S_NO_ERROR;

    //
    // expand environment variable
    //
    if ( wcsstr(bstrIn, L"%") ) {

        PWSTR pBuf=NULL;
        PWSTR pBuf2=NULL;

        DWORD dwSize = ExpandEnvironmentStrings(bstrIn,NULL, 0);

        if ( dwSize > 0 ) {
            //
            // allocate buffer big enough to have two \\s
            //
            pBuf = (PWSTR)LocalAlloc(LPTR, (dwSize+1)*sizeof(WCHAR));
            if ( pBuf ) {

                pBuf2 = (PWSTR)LocalAlloc(LPTR, (dwSize+256)*sizeof(WCHAR));
                if ( pBuf2 ) {

                    DWORD dwNewSize = ExpandEnvironmentStrings(bstrIn,pBuf, dwSize);
                    if ( dwNewSize > 0) {
                        //
                        // convert the string from one \ to \\ (for use with WMI)
                        //
                        PWSTR pTemp1=pBuf, pTemp2=pBuf2;

                        while ( *pTemp1 != L'\0') {
                            if ( *pTemp1 != L'\\') {
                                *pTemp2++ = *pTemp1;
                            } else if ( *(pTemp1+1) != L'\\') {
                                // single back slash, add another one
                                *pTemp2++ = *pTemp1;
                                *pTemp2++ = L'\\';
                            } else {
                                // double back slashs, just copy
                                *pTemp2++ = *pTemp1++;
                                *pTemp2++ = *pTemp1;
                            }
                            pTemp1++;
                        }

                        *bstrOut = SysAllocString(pBuf2);

                        if ( *bstrOut == NULL ) {
                            hr = WBEM_E_OUT_OF_MEMORY;
                        }
                    }

                    LocalFree(pBuf2);
                    pBuf2 = NULL;

                } else {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

                LocalFree(pBuf);
                pBuf = NULL;

            } else {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        } else {
            hr = WBEM_E_FAILED;
        }

    } else {

        *bstrOut = SysAllocString(bstrIn);

        if ( *bstrOut == NULL ) {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\podtest\podbase.h ===
// podbase.h: interface for the CPodBase class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PODBASE_H__c5f6cc21_6195_4555_b9d8_3ef327763cae__INCLUDED_)
#define AFX_PODBASE_H__c5f6cc21_6195_4555_b9d8_3ef327763cae__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CPodBase : public CGenericClass
{
public:
        CPodBase(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
        virtual ~CPodBase();

        virtual HRESULT PutInst(IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
                {return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

        virtual HRESULT ExecMethod(BSTR bstrMethod, bool bIsInstance, IWbemClassObject *pInParams,IWbemObjectSink *pHandler, IWbemContext *pCtx);

private:

        HRESULT PodConfigure(IWbemContext *pCtx,BSTR bstrDb, BSTR bstrLog, LONG *pStatus);
        HRESULT LogOneRecord(IWbemContext *pCtx,BSTR bstrLog, HRESULT hr, PWSTR bufKey, PWSTR bufValue);

};

#endif // !defined(AFX_PODBASE_H__c5f6cc21_6195_4555_b9d8_3ef327763cae__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\podtest\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
//
//  Module: Sample WMI provider - SCE attachment
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include <initguid.h>
#include "podprov.h"

HMODULE ghModule;

DEFINE_GUID(CLSID_PodTestProv,0xc5f6cc21, 0x6195, 0x4555, 0xb9, 0xd8, 0x3e, 0xf3, 0x27, 0x76, 0x3c, 0xae);
//{c5f6cc21_6195_4555_b9d8_3ef327763cae}

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// DllMain
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
        ghModule = hInstance;
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_PodTestProv != rclsid)
        return E_FAIL;

    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the
    // class factory.

    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "Sample SCE Pod Provider";
    char * pModel = "Both";
    HKEY hKey1, hKey2;
    LONG rc=NO_ERROR;

    // Create the path.

    StringFromGUID2(CLSID_PodTestProv, wcID, 128);
    wcstombs(szID, wcID, 128);
    strcpy(szCLSID, "Software\\classes\\CLSID\\");
    strcat(szCLSID, szID);

    // Create entries under CLSID

    rc = RegCreateKeyA(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    if ( NO_ERROR == rc ) {

        rc = RegSetValueExA(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, strlen(pName)+1);
        if ( NO_ERROR == rc ) {

            rc = RegCreateKeyA(hKey1,"InprocServer32",&hKey2);
            if ( NO_ERROR == rc ) {

                GetModuleFileNameA(ghModule, szModule,  MAX_PATH);
                rc = RegSetValueExA(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule,
                                        strlen(szModule)+1);
                if ( NO_ERROR == rc ) {
                    rc = RegSetValueExA(hKey2, "ThreadingModel", 0, REG_SZ,
                                        (BYTE *)pModel, strlen(pModel)+1);
                }
                CloseHandle(hKey2);
            }
        }
        CloseHandle(hKey1);
    }

    return rc;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_PodTestProv, wcID, 128);
    wcstombs(szID, wcID, 128);
    strcpy(szCLSID, "Software\\classes\\CLSID\\");
    strcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKeyA(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKeyA(hKey, "InProcServer32");
        CloseHandle(hKey);

        dwRet = RegOpenKeyA(HKEY_LOCAL_MACHINE, "Software\\classes\\CLSID", &hKey);
        if(dwRet == NO_ERROR)
        {
            RegDeleteKeyA(hKey,szID);
            CloseHandle(hKey);
        }

    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\podtest\podbase.cpp ===
// podbase.cpp, implementation of CPodBase class
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "podbase.h"
#include <io.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPodBase::CPodBase(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CPodBase::~CPodBase()
{

}

//////////////////////////////////////////////////////////////////////
// CPodBase::CreateObject
//
// Create one instance for the requested Sample_BaseClass
//////////////////////////////////////////////////////////////////////
HRESULT CPodBase::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( ACTIONTYPE_DELETE == atAction ) {

        //
        // do not support enumeration because we don't know the scope of the request
        //
        hr = WBEM_E_NOT_SUPPORTED;

    } else if ( ACTIONTYPE_GET == atAction ||
                ACTIONTYPE_ENUM == atAction ) {


        // Create the instance
        //============================
        try{

            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

            //----------------------------------------------------


            hr = PutProperty(m_pObj, pPodID, (PWSTR)szPodGUID);

            if ( SUCCEEDED(hr) ) {
                hr = pHandler->Indicate(1, &m_pObj);
            }

            m_pObj->Release();
            m_pObj = NULL;


        }catch(...){

            if(m_pObj){

                m_pObj->Release();
                m_pObj = NULL;
            }

            // Clean up
            // ========
            throw;
        }


    } else {
        //
        // not supported for now
        //
        hr = WBEM_E_NOT_SUPPORTED;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPodBase::ExecMethod
// execute static and non static methods defined in the class
//////////////////////////////////////////////////////////////////////
HRESULT CPodBase::ExecMethod(IN BSTR bstrMethod,
                                     IN bool bIsInstance,
                                     IN IWbemClassObject *pInParams,
                                     IN IWbemObjectSink *pHandler,
                                     IN IWbemContext *pCtx
                                     )
{
    if ( pInParams == NULL || pHandler == NULL ) {
        return WBEM_E_INVALID_PARAMETER;
    }


    HRESULT hr=WBEM_S_NO_ERROR;

    if ( !bIsInstance ) {

        //Static Methods

        if(0 != _wcsicmp(bstrMethod, L"Configure"))
            hr = WBEM_E_NOT_SUPPORTED;

    } else {

        //Non-Static Methods
        hr = WBEM_E_NOT_SUPPORTED;
    }

    if ( FAILED(hr) ) return hr;


    //
    // parse the input parameters
    //
    BSTR bstrDatabase = NULL;
    BSTR bstrLog = NULL;
    LONG ulStatus = 0;

    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;

    if(SUCCEEDED(hr = m_pRequest->m_pNamespace->GetObject(m_pRequest->m_bstrClass,
        0, pCtx, &pClass, NULL))){

        if(SUCCEEDED(hr = pClass->GetMethod(bstrMethod, 0, NULL, &pOutClass))){

            if(SUCCEEDED(hr = pOutClass->SpawnInstance(0, &pOutParams))){

                //Get DatabaseName
                hr = GetProperty(pInParams, pSceStorePath, &bstrDatabase);
                if ( hr == WBEM_S_RESET_TO_DEFAULT ) hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                if(SUCCEEDED(hr)){
                    if( SysStringLen(bstrDatabase) == 0 ) hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                }

                if(SUCCEEDED(hr)){

                    // get LogName, optional
                    GetProperty(pInParams, pLogFilePath, &bstrLog);

                    // now query data then configure this component

                    hr = PodConfigure(pCtx, bstrDatabase, bstrLog, &ulStatus);

                    if ( SUCCEEDED(hr) ) {

                        //Set up ReturnValue
                        VariantInit(&v);
                        V_VT(&v) = VT_I4;
                        V_I4(&v) = ulStatus;

                        if(SUCCEEDED(hr = pOutParams->Put(bstrReturnValue, 0,
                            &v, NULL)))
                            pHandler->Indicate(1, &pOutParams);
                    }

                }

                pOutParams->Release();
            }
            pOutClass->Release();
        }
        pClass->Release();
    }

    if ( bstrDatabase ) SysFreeString(bstrDatabase);
    if ( bstrLog ) SysFreeString(bstrLog);

    SysFreeString(bstrReturnValue);

    return hr;
}


//////////////////////////////////////////////////////////////////////
// CPodBase::PodConfigure
//
// Configure the Pod using data defined for the Pod
// for this sample app, it just creates/sets the data to registry
//////////////////////////////////////////////////////////////////////
HRESULT CPodBase::PodConfigure(IWbemContext *pCtx, BSTR bstrDb, BSTR bstrLog, LONG *pStatus)
{
    if ( !bstrDb || !pStatus ) return WBEM_E_INVALID_PARAMETER;

    *pStatus = 0;

    HRESULT hr=WBEM_S_NO_ERROR;

    //
    // query data from the store
    //

    DWORD Len = SysStringLen(bstrDb);
    WCHAR *pQuery =TEXT("SELECT * FROM Sce_PodData WHERE SceStorePath=\"");
    WCHAR *pQuery2 =TEXT("\" AND PodID=\"");
    WCHAR *pQuery3 = TEXT("\" AND PodSection=\"1\"");

    PWSTR tmp=(PWSTR)LocalAlloc(LPTR, (Len+wcslen(pQuery)+wcslen(pQuery2)+wcslen(szPodGUID)+wcslen(pQuery3)+2)*sizeof(WCHAR));
    if ( tmp == NULL ) return WBEM_E_OUT_OF_MEMORY;

    wcscpy(tmp, pQuery);
    wcscat(tmp, bstrDb);
    wcscat(tmp, pQuery2);
    wcscat(tmp, szPodGUID);
    wcscat(tmp, pQuery3);

    BSTR strQueryCategories = SysAllocString(tmp);
    LocalFree(tmp);

    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject * pObj = NULL;
    ULONG n = 0;
    HKEY hKey1=NULL;
    BOOL bFindOne=FALSE;

    hr = m_pNamespace->ExecQuery(TEXT("WQL"),
                               strQueryCategories,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);

    if (SUCCEEDED(hr))
    {
        //
        // get data
        //
        do {

            hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &n);
            if ( hr == WBEM_S_FALSE ) {
                if ( bFindOne ) {
                    hr = WBEM_S_NO_ERROR;
                    break;
                } else hr = WBEM_E_NOT_FOUND; // not find any
            }

            if ( SUCCEEDED(hr) && n > 0) {

                bFindOne = TRUE;

                //
                // find the instance
                //
                BSTR bstrKey=NULL;
                BSTR bstrValue=NULL;

                hr = GetProperty(pObj, pKey, &bstrKey);
                if ( SUCCEEDED(hr) )
                    hr = GetProperty(pObj, pValue, &bstrValue);

                // log the operation
                LogOneRecord(pCtx, bstrLog, hr, (PWSTR)bstrKey, (PWSTR)bstrValue);

                if ( bstrKey && bstrValue ) {
                    //
                    // set the registry value
                    //

                    DWORD rc = RegCreateKey(HKEY_LOCAL_MACHINE, L"software\\microsoft\\windows nt\\currentversion\\secedit", &hKey1);
                    if ( NO_ERROR == rc ) {

                        rc = RegSetValueEx(hKey1, (PWSTR)bstrKey, 0, REG_SZ, (BYTE *)bstrValue, (wcslen(bstrValue)+1)*sizeof(WCHAR));

                        RegCloseKey(hKey1);
                        hKey1 = NULL;
                    }
                    if ( rc != NO_ERROR )
                        *pStatus = rc;

                }

                if ( bstrKey ) {
                    SysFreeString(bstrKey);
                    bstrKey = NULL;
                }

                if ( bstrValue ) {
                    SysFreeString(bstrValue);
                    bstrValue = NULL;
                }

            }

            if (pObj)
            {
                pObj->Release();
                pObj = NULL;
            }

        } while ( SUCCEEDED(hr) );

        if ( WBEM_E_NOT_FOUND == hr )
            LogOneRecord(pCtx, bstrLog, hr, L"No data to configure", NULL);
        else if ( FAILED(hr) )
            LogOneRecord(pCtx, bstrLog, hr, L"Query pod data failed", NULL);

    }

    SysFreeString(strQueryCategories);

    if (pEnum)
    {
        pEnum->Release();
    }


    return hr;
}


//////////////////////////////////////////////////////////////////////
// CPodBase::LogOneRecord
//
// Log a record for the Pod
//////////////////////////////////////////////////////////////////////
HRESULT CPodBase::LogOneRecord(IWbemContext *pCtx, BSTR bstrLog, HRESULT hrLog, PWSTR bufKey, PWSTR bufValue)
{
    if ( !bstrLog ) return WBEM_E_INVALID_PARAMETER;

    //
    // build the log record string
    //
    DWORD Len=0;

    if ( bufKey ) Len += wcslen(bufKey) + 1;
    if ( bufValue ) Len += wcslen(bufValue) + 1;

    PWSTR tmp=(PWSTR)LocalAlloc(LPTR, (Len+2)*sizeof(WCHAR));
    if ( !tmp ) return WBEM_E_OUT_OF_MEMORY;

    if ( bufKey ) {
        wcscat(tmp, bufKey);
        wcscat(tmp, L"\t");
    }
    if ( bufValue ) {
        wcscat(tmp, bufValue);
        wcscat(tmp, L"\t");
    }

    BSTR bstrRecord=SysAllocString(tmp);
    LocalFree(tmp);

    if ( !bstrRecord ) return WBEM_E_OUT_OF_MEMORY;

    HRESULT hr = WBEM_S_NO_ERROR;

    //
    // get the log class
    //
    BSTR bstrClass=SysAllocString(L"Sce_ConfigurationLogRecord");
    if ( !bstrClass ) hr = WBEM_E_OUT_OF_MEMORY;

    IWbemClassObject *pClass=NULL;
    IWbemClassObject *pObj=NULL;


    if ( SUCCEEDED(hr) ) {
        //
        // create an instance of the log class
        //
        hr = m_pNamespace->GetObject(bstrClass, 0, pCtx, &pClass, NULL);

        if ( SUCCEEDED(hr) ) {
            hr = pClass->SpawnInstance(0, &pObj);
        }

        if ( SUCCEEDED(hr) ) {

            bool bName=FALSE;
            // fill in the properties of this class
            hr = PutKeyProperty(pObj, pLogFilePath, (PWSTR)bstrLog, &bName, m_pRequest);

            if (SUCCEEDED(hr) )
                hr = PutKeyProperty(pObj, pLogArea, (PWSTR)szPodGUID, &bName, m_pRequest);

            if (SUCCEEDED(hr) )
                hr = PutKeyProperty(pObj, pLogFileRecord, (PWSTR)bstrRecord, &bName, m_pRequest);

            if (SUCCEEDED(hr) )
                hr = PutProperty(pObj, pLogErrorCode, (int)hrLog);

            if ( SUCCEEDED(hr) ) {
                // save this instance
                hr = m_pNamespace->PutInstance( pObj, 0, pCtx, NULL );
            }
        }
    }

    if ( bstrClass ) SysFreeString(bstrClass);
    if ( bstrRecord ) SysFreeString(bstrRecord);

    if ( pClass ) {
        pClass->Release();
    }
    if ( pObj ) {
        pObj->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\podtest\poddata.h ===
// poddata.h: interface for the CPodData class.
//
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PODDATA_H__c5f6cc21_6195_4555_b9d8_3ef327763cae__INCLUDED_)
#define AFX_PODDATA_H__c5f6cc21_6195_4555_b9d8_3ef327763cae__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CPodData : public CGenericClass
{
public:
        CPodData(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
        virtual ~CPodData();

        virtual HRESULT PutInst(IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx);

        virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

        virtual HRESULT ExecMethod(BSTR bstrMethod, bool bIsInstance, IWbemClassObject *pInParams,IWbemObjectSink *pHandler, IWbemContext *pCtx)
                {return WBEM_E_NOT_SUPPORTED;}

private:

        HRESULT ConstructInstance(IWbemObjectSink *pHandler,ACTIONTYPE acAction, LPCWSTR wszStoreName, LPWSTR KeyName);
        HRESULT SaveSettingsToStore(PCWSTR wszStoreName, PWSTR KeyName, PWSTR szValue);

};

#endif // !defined(AFX_PODDATA_H__c5f6cc21_6195_4555_b9d8_3ef327763cae__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\podtest\poddata.cpp ===
// poddata.cpp, implementation of CPodData class
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "poddata.h"
#include <io.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPodData::CPodData(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CPodData::~CPodData()
{

}

//////////////////////////////////////////////////////////////////////
// CPodData::CreateObject
//
// Create one or more instances for the requested Sample_DataClass class
//////////////////////////////////////////////////////////////////////
HRESULT CPodData::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( ACTIONTYPE_ENUM == atAction ) {

        //
        // do not support enumeration because we don't know the scope of the request
        //
        hr = WBEM_E_NOT_SUPPORTED;

    } else if ( ACTIONTYPE_GET == atAction ||
                ACTIONTYPE_DELETE == atAction ) {

        // Check the number of keys
        // ========================

        hr = WBEM_E_INVALID_OBJECT_PATH;

        // Check prop name
        // ==============
        int idxStorePath=-1, idxKey=-1;

        for ( int i=0; i<m_pRequest->m_iPropCount; i++ ) {

            //
            // search for StorePath value
            //
            if(m_pRequest->m_Property[i] != NULL &&
               m_pRequest->m_Value[i] != NULL &&
                _wcsicmp(m_pRequest->m_Property[i], pSceStorePath) == 0 ) {

                idxStorePath = i;
                continue;
            }
            if(m_pRequest->m_Property[i] != NULL &&
               m_pRequest->m_Value[i] != NULL &&
                _wcsicmp(m_pRequest->m_Property[i], pKeyName) == 0 ) {

                idxKey = i;
                continue;
            }
            if(idxStorePath >= 0 && idxKey >= 0 )
                break;

        }

        if(idxStorePath >= 0 && idxKey >= 0 ) {

            // Create the Pod instance
            //============================

            BSTR bstrPath=NULL;
            hr = CheckAndExpandPath(m_pRequest->m_Value[idxStorePath], &bstrPath);

            if ( SUCCEEDED(hr) ) {

                DWORD dwAttrib = GetFileAttributes(bstrPath);

                if ( dwAttrib != -1 ) {

                    hr = ConstructInstance(pHandler, atAction, bstrPath, m_pRequest->m_Value[idxKey]);

                } else {

                    hr = WBEM_E_NOT_FOUND;
                }
            }

            if ( bstrPath ) SysFreeString(bstrPath);

        }

    } else {
        //
        // not supported for now
        //
        hr = WBEM_E_NOT_SUPPORTED;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPodData::PutInst
//
// Save an instance to the store
//////////////////////////////////////////////////////////////////////
HRESULT CPodData::PutInst(IWbemClassObject *pInst,
                                 IWbemObjectSink *pHandler,
                                 IWbemContext *pCtx)
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    BSTR bstrStorePath=NULL;
    BSTR bstrKey=NULL;
    BSTR bstrValue=NULL;
    BSTR bstrPath=NULL;

    try{

        hr = GetProperty(pInst, pSceStorePath, &bstrStorePath);
        if ( FAILED(hr) ) throw hr;

        hr = CheckAndExpandPath(bstrStorePath, &bstrPath);
        if ( FAILED(hr) ) throw hr;

        // if the property doesn't exist (NULL or empty), WBEM_S_RESET_TO_DEFAULT is returned
        hr = GetProperty(pInst, pKeyName, &bstrKey);
        if ( FAILED(hr) ) throw hr;

        hr = GetProperty(pInst, pValue, &bstrValue);
        if ( FAILED(hr) ) throw hr;

        //
        // now save the info to file
        //
        hr = SaveSettingsToStore((PCWSTR)bstrPath,
                                 (PWSTR)bstrKey,
                                 (PWSTR)bstrValue
                                 );


    }catch(...){

        // Clean up
        // ========

        if ( bstrStorePath )
            SysFreeString(bstrStorePath);

        if ( bstrPath )
            SysFreeString(bstrPath);

        if ( bstrKey )
            SysFreeString(bstrKey);

        if ( bstrValue )
            SysFreeString(bstrValue);

        throw;
     }

     if ( bstrStorePath )
         SysFreeString(bstrStorePath);

     if ( bstrPath )
         SysFreeString(bstrPath);

     if ( bstrKey )
         SysFreeString(bstrKey);

     if ( bstrValue )
         SysFreeString(bstrValue);

    return hr;

}

//////////////////////////////////////////////////////////////////////
// CPodData::ConstructInstance
//
// construction of one password instance
//////////////////////////////////////////////////////////////////////
HRESULT CPodData::ConstructInstance(IWbemObjectSink *pHandler,
                                    ACTIONTYPE atAction,
                                    LPCWSTR wszStoreName,
                                    LPWSTR KeyName
                                    )
{
    HRESULT hr=WBEM_S_NO_ERROR;
    bool bName=FALSE;
    BSTR bstrValue=NULL;

    //
    // build object path
    //
    WCHAR *pPath1=TEXT("Sce_PodData.SceStorePath=\"");
    WCHAR *pPath2=TEXT("\",PodID=\"");
    WCHAR *pPath3=TEXT("\",PodSection=\"1\",Key=\"");

    DWORD Len=wcslen(pPath1)+wcslen(wszStoreName)+wcslen(pPath2)+wcslen(szPodGUID)+wcslen(pPath3)+wcslen(KeyName)+2;
    PWSTR tmp=(PWSTR)LocalAlloc(LPTR, Len*sizeof(WCHAR));

    if ( !tmp ) return WBEM_E_OUT_OF_MEMORY;

    wcscpy(tmp, pPath1);
    wcscat(tmp, wszStoreName);
    wcscat(tmp, pPath2);
    wcscat(tmp, szPodGUID);
    wcscat(tmp, pPath3);
    wcscat(tmp, KeyName);
    wcscat(tmp, L"\"");

    BSTR bstrObjectPath=SysAllocString(tmp);
    LocalFree(tmp);
    if ( !bstrObjectPath ) return WBEM_E_OUT_OF_MEMORY;

    IWbemClassObject *pPodObj=NULL;

    if ( ACTIONTYPE_DELETE == atAction ) {

        hr = m_pNamespace->DeleteInstance(bstrObjectPath, 0, m_pCtx, NULL);

    } else {

        try{

            //
            // get the data
            //

            hr = m_pNamespace->GetObject(bstrObjectPath, 0, m_pCtx, &pPodObj, NULL);


            if ( SUCCEEDED(hr) ) {

                // get the value property
                hr = GetProperty(pPodObj, pValue, &bstrValue);
            }

            if ( pPodObj ) {
                pPodObj->Release();
                pPodObj = NULL;
            }

            if ( FAILED(hr) ) throw hr;
            if ( !bstrValue ) throw WBEM_E_NOT_FOUND;

            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

            //----------------------------------------------------

            hr = PutKeyProperty(m_pObj, pSceStorePath, (PWSTR)wszStoreName, &bName, m_pRequest);
            if ( SUCCEEDED(hr) )
                hr = PutKeyProperty(m_pObj, pKeyName, KeyName, &bName, m_pRequest);

            if ( SUCCEEDED(hr) )
                hr = PutProperty(m_pObj, pValue, bstrValue);

            if ( SUCCEEDED(hr) ) {
                hr = pHandler->Indicate(1, &m_pObj);
            }

            m_pObj->Release();
            m_pObj = NULL;


        }catch(...){

            if(m_pObj){

                m_pObj->Release();
                m_pObj = NULL;
            }

            // Clean up
            // ========
            SysFreeString(bstrObjectPath);

            if ( pPodObj ) {
                pPodObj->Release();
            }

            throw;
        }

    }

    SysFreeString(bstrObjectPath);

    return hr;

}

//////////////////////////////////////////////////////////////////////
// CPodData::SaveSettingsToStore
//
// set/reset the setting for this POD
//////////////////////////////////////////////////////////////////////
HRESULT CPodData::SaveSettingsToStore(PCWSTR wszStoreName,
                                      PWSTR KeyName, PWSTR szValue)
{
    HRESULT hr=WBEM_S_NO_ERROR;
    //
    // get the PodData class
    //
    BSTR bstrClass=SysAllocString(L"Sce_PodData");
    if ( !bstrClass ) hr = WBEM_E_OUT_OF_MEMORY;

    IWbemClassObject *pClass=NULL;
    IWbemClassObject *pObj=NULL;
    bool bName=FALSE;


    if ( SUCCEEDED(hr) ) {

        try {

            //
            // create an instance of the log class
            //
            hr = m_pNamespace->GetObject(bstrClass, 0, m_pCtx, &pClass, NULL);

            if ( SUCCEEDED(hr) ) {
                hr = pClass->SpawnInstance(0, &pObj);
            }

            if ( SUCCEEDED(hr) ) {

                // fill in the properties of this class
                hr = PutKeyProperty(pObj, pSceStorePath, (PWSTR)wszStoreName, &bName, m_pRequest);
                if (SUCCEEDED(hr))
                    hr = PutKeyProperty(pObj, pPodID, (PWSTR)szPodGUID, &bName, m_pRequest);
                if (SUCCEEDED(hr) )
                    hr = PutKeyProperty(pObj, pPodSection, (PWSTR)L"1", &bName, m_pRequest);
                if (SUCCEEDED(hr) )
                    hr = PutKeyProperty(pObj, pKey, (PWSTR)KeyName, &bName, m_pRequest);
                if (SUCCEEDED(hr) )
                    hr = PutProperty(pObj, pValue, szValue);

                if ( SUCCEEDED(hr) ) {
                    // save this instance
                    hr = m_pNamespace->PutInstance( pObj, 0, m_pCtx, NULL );
                }
            }

        }catch(...){

            // Clean up
            // ========

            if ( bstrClass ) SysFreeString(bstrClass);

            if ( pClass ) {
                pClass->Release();
            }
            if ( pObj ) {
                pObj->Release();
            }

            throw;
        }

    }

    if ( bstrClass ) SysFreeString(bstrClass);

    if ( pClass ) {
        pClass->Release();
    }
    if ( pObj ) {
        pObj->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\podtest\precomp.h ===
#include <ole2.h>
#include <windows.h>
#include <stdio.h>

#include "podprov.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\podtest\podprov.h ===
//***************************************************************************
//
//  podprov.h
//
//  Module: Sample WMI provider (ESCAPE attachment)
//
//  Purpose: Genral purpose include file.
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#ifndef _PodProv_H_
#define _PodProv_H_

#include <wbemidl.h>
#include <wbemprov.h>
#include <eh.h>

typedef LPVOID * PPVOID;

#define BUFF_SIZE 512
#define QUERY_SIZE 128
#define POD_KEY_LIST_SIZE 10
#define POD_NULL_INTEGER  0x80000000L

typedef enum tagACTIONTYPE
{
        ACTIONTYPE_ENUM =       0,
        ACTIONTYPE_GET =        1,
        ACTIONTYPE_QUERY =      2,
        ACTIONTYPE_DELETE =     3

} ACTIONTYPE;


/**************************************************************
 *
 **************************************************************/

class CHeap_Exception
{
public:

        enum HEAP_ERROR
        {
                E_ALLOCATION_ERROR = 0 ,
                E_FREE_ERROR
        };

private:

        HEAP_ERROR m_Error;

public:

        CHeap_Exception ( HEAP_ERROR e ) : m_Error ( e ) {}
        ~CHeap_Exception () {}

        HEAP_ERROR GetError() { return m_Error ; }
} ;

// Provider interfaces are provided by objects of this class

class CPodTestProv : public IWbemServices, public IWbemProviderInit
{
    protected:
        ULONG               m_cRef;         //Object reference count
        IWbemClassObject *  m_pTemplateClass;
        IWbemClassObject *  m_pPasswordClass;

     public:

         IWbemServices *m_pNamespace;
        CPodTestProv();
        ~CPodTestProv();

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

                //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

        //IWbemServices

        HRESULT STDMETHODCALLTYPE OpenNamespace(
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE CancelAsyncCall(
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE QueryObjectSink(
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE GetObject(
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE GetObjectAsync(
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        HRESULT STDMETHODCALLTYPE PutClass(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE PutClassAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE DeleteClass(
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE DeleteClassAsync(
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE CreateClassEnum(
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE PutInstance(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE PutInstanceAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        HRESULT STDMETHODCALLTYPE DeleteInstance(
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        HRESULT STDMETHODCALLTYPE CreateInstanceEnum(
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync(
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        HRESULT STDMETHODCALLTYPE ExecQuery(
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE ExecQueryAsync(
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        HRESULT STDMETHODCALLTYPE ExecNotificationQuery(
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync(
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long,
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*);

private:

        static CHeap_Exception m_he;
};

typedef CPodTestProv *PCPodTestProv;

// This class is the class factory for CServExtPro objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;


// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

HRESULT CheckAndExpandPath(BSTR bstrIn,BSTR *bstrOut );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\exe\stringid.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    stringid.h

Abstract:

    This module defines resource IDs for strings

Author:

    Jin Huang (Jinhuang) 22-Feb-1997

Revision History:

--*/

#define SECEDITP_TASK_COMPLETE_NO_ERROR          7100
#define SECEDITP_CANNOT_FIND_TEMPLATE            7101
#define SECEDITP_COMPILE_OK                      7102
#define SECEDITP_TASK_COMPLETE_WARNING           7103
#define SECEDITP_TASK_COMPLETE_ERROR             7104
#define SECEDITP_TASK_SEE_LOG                    7105
#define SECEDITP_TASK_SEE_DEF_LOG                7106
#define SECEDITP_FILE_MAY_CORRUPTED              7107

#define SECEDITP_STRING_REGISTER                 7111
#define SECEDITP_STRING_REFRESH                  7112

#define SECEDITP_REGISTER_OK                     7115
#define SECEDITP_REFRESH_OK                      7116
#define SECEDITP_REFRESH_ERROR                   7117
#define SECEDITP_ANALYSIS_NOT_ALLOWED_1          7118
#define SECEDITP_ANALYSIS_NOT_ALLOWED_2          7119
#define SECEDITP_CONFIG_WARNING_LINE1            7120
#define SECEDITP_CONFIG_WARNING_LINE2            7121
#define SECEDITP_CONFIG_WARNING_LINE3            7122
#define SECEDITP_CONFIG_WARNING_CONFIRM          7123

#define SECEDITP_WARNING_NOT_FOUND               7124
#define SECEDITP_WARNING_IN_USE                  7125
#define SECEDITP_WARNING_OTHER_WARNING           7126

#define SECEDITP_STRING_MERGE                    7160
#define SECEDITP_STRING_ENFORCE                  7161

#define SECEDITP_CONFIG_NOT_ALLOWED_1            7162
#define SECEDITP_CONFIG_NOT_ALLOWED_2            7163


#define SECEDITP_STRING_VERBOSE_LOG              7167
#define SECEDITP_STRING_NO_LOG                   7168

#define SECEDITP_WITH_SECTIONNAME                7180
#define SECEDITP_NO_SECTIONNAME                  7181
#define SECEDITP_SICURITY_POLICY                 7182
#define SECEDITP_SYSTEM_SERVICE                  7183

#define SECEDITP_IDS_YES                         7184
#define SECEDITP_PATH_NOT_CANONICALIZABLE        7185
#define SECEDITP_OUT_OF_MEMORY                   7186
#define SECEDITP_ENVI_VARS_AMBIGUOUS             7187
#define SECEDITP_PATH_NOT_VALID                  7188

#define SECEDITP_TEMPLATE_NEWVERSION             7189
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\exe\secedit.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    secedit.c

Abstract:

    Command line tool "secedit" to configure/analyze security

Author:

    Jin Huang (jinhuang) 7-Nov-1996

--*/
//
// System header files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <shlwapi.h>
//
// CRT header files
//

#include <process.h>
#include <wchar.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <limits.h>

#include "secedit.h"
#include "scesetup.h"
#include "stringid.h"
//#include <aclapi.h>
#include <io.h>
#include "userenv.h"
#include <locale.h>

#define GPT_EFS_NEW_PATH TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{B1BE8D72-6EAC-11D2-A4EA-00C04F79F83A}")
#define GPT_SCEDLL_NEW_PATH TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{827D319E-6EAC-11D2-A4EA-00C04F79F83A}")

#define SECEDITP_MAX_STRING_LENGTH    50
#define SCE_ENGINE_GENERATE           1
#define SCE_ENGINE_COMPILE            2
#define SCE_ENGINE_REGISTER           3
#define SCE_ENGINE_REFRESH            4
#define SCE_ENGINE_BROWSE             5

#define SECEDIT_DETAIL_HELP           1
#define SECEDIT_AREA_HELP             2
#define SECEDIT_OVERWRITE_HELP        4

#define             SeceditpArgumentConfigure       TEXT("/configure")
#define             SeceditpArgumentAnalyze         TEXT("/analyze")
#define             SeceditpArgumentGenerate        TEXT("/export")
#define             SeceditpArgumentScpPath         TEXT("/CFG")
#define             SeceditpArgumentSadPath         TEXT("/DB")
#define             SeceditpArgumentArea            TEXT("/areas")
#define             SeceditpArgumentLog             TEXT("/log")
#define             SeceditpArgumentVerbose         TEXT("/verbose")
#define             SeceditpArgumentQuiet           TEXT("/quiet")
#define             SeceditpArgumentAppend          TEXT("/overwrite")
#define             SeceditpArgumentCompile         TEXT("/validate")
#define             SeceditpArgumentRegister        TEXT("/register")
#define             SeceditpArgumentRefresh         TEXT("/RefreshPolicy")
#define             SeceditpArgumentMerge           TEXT("/MergedPolicy")
#define             SeceditpArgumentEnforce         TEXT("/Enforce")

#define             SeceditpAreaPolicy              TEXT("SECURITYPOLICY")
#define             SeceditpAreaUser                TEXT("USER_MGMT")
#define             SeceditpAreaGroup               TEXT("GROUP_MGMT")
#define             SeceditpAreaRight               TEXT("USER_RIGHTS")
#define             SeceditpAreaDsObject            TEXT("DSOBJECTS")
#define             SeceditpAreaRegistry            TEXT("REGKEYS")
#define             SeceditpAreaFile                TEXT("FILESTORE")
#define             SeceditpAreaService             TEXT("SERVICES")
#define             SCE_LOCAL_FREE(ptr)             if (ptr != NULL) LocalFree(ptr)

HMODULE          hMod=NULL;
static           DWORD    dOptions=0;
static           HANDLE  hCmdToolLogFile=INVALID_HANDLE_VALUE;
static           PWSTR   LogFile=NULL;


VOID
ScepPrintHelp(DWORD nLevel);

WCHAR *
SecEditPConvertToFullPath(
    WCHAR *UserFilename,
    DWORD *retCode
    );

BOOL
ScepCmdToolLogInit(
    PWSTR    logname
    );

VOID
ScepCmdToolLogWrite(
    PWSTR    pErrString
    );

SCESTATUS
ScepCmdToolLogClose(
    );

SCESTATUS
SeceditpErrOut(
    IN DWORD rc,
    IN LPTSTR buf OPTIONAL
    );

DWORD
SeceditpSceStatusToDosError(
    IN SCESTATUS SceStatus
    );

BOOL CALLBACK
SceCmdVerboseCallback(
    IN HANDLE CallbackHandle,
    IN AREA_INFORMATION Area,
    IN DWORD TotalTicks,
    IN DWORD CurrentTicks
    );

DWORD
pProgressRoutine(
    IN PWSTR StringUpdate
    );

BOOL
ScepPrintConfigureWarning();

BOOL CALLBACK
pBrowseCallback(
    IN LONG ID,
    IN PWSTR KeyName OPTIONAL,
    IN PWSTR GpoName OPTIONAL,
    IN PWSTR Value OPTIONAL,
    IN DWORD Len
    );

#define SECEDIT_OPTION_DEBUG       0x01L
#define SECEDIT_OPTION_VERBOSE     0x02L
#define SECEDIT_OPTION_QUIET       0x04L
#define SECEDIT_OPTION_OVERWRITE   0x08L
#define SECEDIT_OPTION_MACHINE     0x10L
#define SECEDIT_OPTION_MERGE       0x20L
#define SECEDIT_OPTION_APPEND      0x40L
#define SECEDIT_OPTION_ENFORCE     0x80L

int __cdecl
My_wprintf(
    const wchar_t *format,
    ...
    );

int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
    );

int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   );

int __cdecl
My_printf(
    const char *format,
    ...
    );


int __cdecl wmain(int argc, WCHAR * argv[])
{
    PWSTR               InfFile=NULL;
//    PWSTR               LogFile=NULL;
    PWSTR               SadFile=NULL;
    PWSTR               pTemp=NULL;

    AREA_INFORMATION    Area=AREA_ALL;
    SCESTATUS           rc;
    int                 rCode=0;
    DWORD               EngineType=0;
    LONG                i;
    DWORD               j;
    DWORD               Len, TotalLen;
    BOOL                bTest=FALSE;
    BOOL                bVerbose=TRUE;
    BOOL                bQuiet=FALSE;
    BOOL                bAppend=TRUE;

    PVOID               hProfile=NULL;
    PSCE_PROFILE_INFO   ProfileInfo=NULL;
    PSCE_ERROR_LOG_INFO ErrBuf=NULL;
    PSCE_ERROR_LOG_INFO pErr;

    DWORD               dWarning=0;
    WCHAR               LineString[256];
    WCHAR               WarningStr[256];

    BOOL              bMachine=FALSE, bMerge=FALSE, bEnforce=FALSE;
    UINT              rId=0;
    HKEY              hKey=NULL, hKey1=NULL;

    UINT    ConsoleCP;
    char    szConsoleCP[6];


    // check for /quiet and LogFile if any - set relevant flags (need this info immediately to log errors)
    for ( i=1; i<argc; i++ ){

        if ( _wcsicmp(argv[i], SeceditpArgumentLog ) == 0 ) {
            if ( i+1 < argc && argv[i+1][0] != L'/' ) {
                LogFile = SecEditPConvertToFullPath(argv[i+1], &rCode);
                if (rCode == 2) {
                    goto Done;
                }
            } else {
                ScepPrintHelp(EngineType);
                rCode = 1;
                goto Done;
            }

            i++;
            continue;

        }

        if ( _wcsicmp(argv[i], SeceditpArgumentQuiet ) == 0 ) {
            bQuiet = TRUE;
            dOptions |= SCE_DISABLE_LOG;
        }

    }

    if ( rCode == 0 )
        ScepCmdToolLogInit(LogFile);


    ConsoleCP = GetConsoleOutputCP();
//    szConsoleCP[0] = '.';
//    itoa(ConsoleCP, &szConsoleCP[1], 10);
    sprintf(szConsoleCP, ".%d", ConsoleCP);

//    setlocale(LC_ALL, ".OCP");
    setlocale(LC_ALL, szConsoleCP);


    hMod = GetModuleHandle(NULL);

    if ( hMod == NULL ) {
        My_wprintf(L"Cannot find the module handle\n");
        return 2;  // system error
    }

    for ( i=1; i<argc; i++ )
        if ( _wcsicmp(argv[i], L"/?") == 0 ) {
            ScepPrintHelp(0);
            goto Done;
        }

    if ( argc < 2 ) {

        ScepPrintHelp(0);
        return 1;

    } else {

        for ( i=1; i<argc; i++ ) {
            SCE_LOCAL_FREE(pTemp);

            Len = wcslen(argv[i]);
            pTemp = (PWSTR)LocalAlloc( 0, (Len+1)*sizeof(WCHAR));
            if ( pTemp == NULL ) {
                My_wprintf(L"Not enough memory\n");
                rCode=2;  //system error
                goto Done;
            }

            wcscpy(pTemp, argv[i]);

            //
            // configure engine type ?
            //
            if ( _wcsicmp(pTemp, SeceditpArgumentConfigure) == 0 ) {
                if ( EngineType != 0 ) {
                    ScepPrintHelp(EngineType);
                    rCode = 1; // invalid parameter
                    goto Done;
                }
                EngineType = SCE_ENGINE_SCP;
                continue;
            }

            //
            // analyze engine type ?
            //
            if ( _wcsicmp(pTemp, SeceditpArgumentAnalyze) == 0 ) {
                if ( EngineType != 0 ) {
                    ScepPrintHelp(EngineType);
                    rCode = 1;  //invalid parameter
                    goto Done;
                }
                EngineType = SCE_ENGINE_SAP;
                continue;
            }
            //
            // generate template ?
            //
            if ( _wcsicmp(pTemp, SeceditpArgumentGenerate) == 0 ) {
                if ( EngineType != 0 ) {
                    ScepPrintHelp(EngineType);
                    rCode = 1;
                    goto Done;
                }
                EngineType = SCE_ENGINE_GENERATE;
                continue;
            }

            //
            // compile a template ?
            //
            if ( _wcsicmp(pTemp, SeceditpArgumentCompile) == 0 ) {
                if ( EngineType != 0 ) {
                    ScepPrintHelp(EngineType);
                    rCode = 1;
                    goto Done;
                }
                EngineType = SCE_ENGINE_COMPILE;
                //
                // compile requires a INF template name
                //
                if ( i+1 < argc && argv[i+1][0] != L'/' ) {
                    InfFile = SecEditPConvertToFullPath(argv[i+1], &rCode);
                    if (rCode == 2) {
                        goto Done;
                    }
                } else {
                    ScepPrintHelp(EngineType);
                    rCode = 1;
                    goto Done;
                }

                i++;
                continue;
            }

            //
            // register a template for registry values ?
            //
            if ( _wcsicmp(pTemp, SeceditpArgumentRegister) == 0 ) {

                if ( EngineType != 0 ) {
                    ScepPrintHelp(EngineType);
                    rCode = 1;
                    goto Done;
                }
                EngineType = SCE_ENGINE_REGISTER;

                //
                // register requires a INF template name
                //
                if ( i+1 < argc && argv[i+1][0] != L'/' ) {
                    InfFile = SecEditPConvertToFullPath(argv[i+1], &rCode);
                    if (rCode == 2) {
                        goto Done;
                    }
                } else {
                    ScepPrintHelp(EngineType);
                    rCode = 1;
                    goto Done;
                }

                i++;
                continue;
            }

            //
            // refresh policy
            //
            if ( _wcsicmp(pTemp, SeceditpArgumentRefresh) == 0 ) {
                //
                // do not support refresh policy because it's supported by refgp.exe
                //
                ScepPrintHelp(EngineType);
                rCode = 1;
                goto Done;
/*
                if ( EngineType != 0 ) {
                    ScepPrintHelp(EngineType);
                    rCode = 1;
                    goto Done;

                }
                EngineType = SCE_ENGINE_REFRESH;

                //
                // next argument is the policy area
                //
                if ( i+1 < argc && argv[i+1][0] != L'/' ) {

                    if ( 0 == _wcsicmp(argv[i+1], L"MACHINE_POLICY") ) {
                        bMachine = TRUE;
                    } else if ( 0 == _wcsicmp(argv[i+1], L"USER_POLICY") ) {
                        bMachine = FALSE;
                    } else {
                        ScepPrintHelp(EngineType);
                        rCode = 1;
                        goto Done;
                    }

                } else {
                    ScepPrintHelp(EngineType);
                    rCode = 1;
                    goto Done;
                }

                i++;
                continue;
*/
            }

            if ( _wcsicmp(pTemp, L"/browse") == 0 ) {
                if ( EngineType != 0 ) {
                    ScepPrintHelp(EngineType);
                    rCode = 1;
                    goto Done;
                }
                EngineType = SCE_ENGINE_BROWSE;
                //
                // next argument is the table
                //
                if ( i+1 < argc && argv[i+1][0] != L'/' ) {

                    if ( 0 == _wcsicmp(argv[i+1], L"scp") ) {
                        dWarning = SCE_ENGINE_SCP;
                    } else if ( 0 == _wcsicmp(argv[i+1], L"smp") ) {
                        dWarning = SCE_ENGINE_SMP;
                    } else if ( 0 == _wcsicmp(argv[i+1], L"sap") ) {
                        dWarning = SCE_ENGINE_SAP;
                    } else if ( 0 == _wcsicmp(argv[i+1], L"tattoo") ) {
                        dWarning = SCE_ENGINE_SAP;
                        bMerge = TRUE;
                    } else {
                        ScepPrintHelp(EngineType);
                        rCode = 1;
                        goto Done;
                    }

                } else {
                    ScepPrintHelp(EngineType);
                    rCode = 1;
                    goto Done;
                }

                i++;
                continue;
            }

            if ( _wcsicmp(pTemp, L"/debug") == 0 ) {
                bTest = TRUE;
                continue;
            }
            if ( _wcsicmp(pTemp, SeceditpArgumentVerbose ) == 0 ) {
                bVerbose = TRUE;
                continue;
            }
            if ( _wcsicmp(pTemp, SeceditpArgumentQuiet ) == 0 ) {
                bQuiet = TRUE;
                continue;
            }
            if ( _wcsicmp(pTemp, SeceditpArgumentAppend ) == 0 ) {
                bAppend = FALSE;
                continue;
            }
            if ( _wcsicmp(pTemp, SeceditpArgumentMerge ) == 0 ) {
                bMerge = TRUE;
                continue;
            }
            if ( _wcsicmp(pTemp, SeceditpArgumentEnforce ) == 0 ) {
                bEnforce = TRUE;
                continue;
            }

            //
            // scp profile name, it may be empty  "/scppath"
            //
            if ( _wcsicmp(pTemp, SeceditpArgumentScpPath) == 0 ) {

                if ( i+1 < argc && argv[i+1][0] != L'/' ) {
                    InfFile = SecEditPConvertToFullPath(argv[i+1], &rCode);
                    if (rCode == 2) {
                        goto Done;
                    }
                } else {
                    ScepPrintHelp(EngineType);
                    rCode = 1;
                    goto Done;
                }

                i++;
                continue;
            }

            //
            // sad database name, it may be empty
            //
            if ( _wcsicmp(pTemp, SeceditpArgumentSadPath) == 0 ) {

                if ( i+1 < argc && argv[i+1][0] != L'/' ) {
                    SadFile = SecEditPConvertToFullPath(argv[i+1], &rCode);
                    if (rCode == 2) {
                        goto Done;
                    }
                } else {
                    ScepPrintHelp(EngineType);
                    rCode = 1;
                    goto Done;
                }

                i++;
                continue;
            }

            //
            // area(s)
            //
            if ( _wcsicmp(pTemp, SeceditpArgumentArea ) == 0 ) {
                //
                //

                for ( j=(DWORD)i, Area=0; j+1 < (DWORD)argc && argv[j+1][0] != L'/'; j++ ) {

                    SCE_LOCAL_FREE(pTemp);

                    Len = wcslen(argv[j+1]);
                    pTemp = (PWSTR)LocalAlloc( 0, (Len+1)*sizeof(WCHAR));
                    if ( pTemp == NULL ) {
                        My_wprintf(L"Not enough memory\n");
                        rCode = 2;
                        goto Done;
                    }
                    wcscpy(pTemp, argv[j+1]);

                    //
                    // Process all arguments for Areas
                    //
                    if ( _wcsicmp( pTemp, SeceditpAreaPolicy) == 0 ) {
                        // security policy
                        Area |= AREA_SECURITY_POLICY;
                        continue;
                    }
    /*
                    if ( _wcsicmp( pTemp, SeceditpAreaUser) == 0 ) {
                        // user
                        Area |= AREA_USER_SETTINGS;
                        continue;
                    }
    */
                    if ( _wcsicmp( pTemp, SeceditpAreaGroup) == 0 ) {
                        // group
                        Area |= AREA_GROUP_MEMBERSHIP;
                        continue;
                    }
                    if ( _wcsicmp( pTemp, SeceditpAreaRight) == 0 ) {
                        // privilege rights
                        Area |= AREA_PRIVILEGES;
                        continue;
                    }
    #if 0
                    if ( _wcsicmp( pTemp, SeceditpAreaDsObject) == 0 ) {
                        // ds objects
                        Area |= AREA_DS_OBJECTS;
                        continue;
                    }
    #endif
                    if ( _wcsicmp( pTemp, SeceditpAreaRegistry) == 0 ) {
                        // Registry
                        Area |= AREA_REGISTRY_SECURITY;
                        continue;
                    }
                    if ( _wcsicmp( pTemp, SeceditpAreaFile) == 0 ) {
                        // file
                        Area |= AREA_FILE_SECURITY;
                        continue;
                    }
                    if ( _wcsicmp( pTemp, SeceditpAreaService) == 0 ) {
                        // services
                        Area |= AREA_SYSTEM_SERVICE;
                        continue;
                    }
                    //
                    // unrecognized parameter
                    //
                    ScepPrintHelp(EngineType);
                    rCode = 1;
                    goto Done;

                }

                i = (LONG)j;
                continue;
            }

            //
            // ignore if "/log filename" since already processed at the beginning
            //

            if ( _wcsicmp(pTemp, SeceditpArgumentLog ) == 0 ) {
                if ( i+1 < argc && argv[i+1][0] != L'/' ) {
                } else {
                    ScepPrintHelp(EngineType);
                    rCode = 1;
                    goto Done;
                }

                i++;
                continue;
            }

            //
            // unrecognized argument
            //
            ScepPrintHelp(EngineType);
            rCode = 1;
            goto Done;

        }
    }

    if ( EngineType == 0 ) {
        ScepPrintHelp(0);
        rCode = 1;
        goto Done;
    }

    SetConsoleCtrlHandler(NULL, TRUE);

    //
    // Initialize
    //

    if ( bTest ) {
        dOptions |= SCE_DEBUG_LOG;
    } else if ( bVerbose ) {
        dOptions |= SCE_VERBOSE_LOG;
    }


    switch ( EngineType ) {
    case SCE_ENGINE_SCP:

        //
        // configure the system
        //
        if ( (SadFile == NULL) ||
             SceIsSystemDatabase(SadFile) ) {

            rc = SCESTATUS_INVALID_PARAMETER;

            LoadString( hMod,
                        SECEDITP_CONFIG_NOT_ALLOWED_1,
                        LineString,
                        256
                        );
            My_wprintf(LineString);

            LoadString( hMod,
                        SECEDITP_CONFIG_NOT_ALLOWED_2,
                        LineString,
                        256
                        );
            My_wprintf(LineString);

            EngineType = 0;

        } else {

            bMachine = TRUE;

            if ( bAppend && InfFile != NULL ) {
                dOptions |= SCE_UPDATE_DB;
            } else {
                dOptions |= SCE_OVERWRITE_DB;

                if ( FALSE == bAppend && InfFile != NULL && !bQuiet ) {
                    //
                    // will overwrite the database with the new inf file.
                    // warn users for this serious problem.
                    // If this is a normal user logon, the operation will fail
                    // by the server site.
                    //

                    bMachine = ScepPrintConfigureWarning();  // temp. use of bMachine

                }
            }

            if ( bMachine ) {
                rc = SceConfigureSystem(
                          NULL,
                          InfFile,
                          SadFile,
                          LogFile,
                          dOptions,
                          Area,
                          (bVerbose || bTest ) ?
                            (PSCE_AREA_CALLBACK_ROUTINE)SceCmdVerboseCallback : NULL,
                          NULL,
                          &dWarning
                          );
            } else {
                rc = SCESTATUS_SUCCESS;
                dWarning = ERROR_REQUEST_ABORTED;
                goto Done;
            }
        }

        break;

    case SCE_ENGINE_SAP:
         //
         // analyze the system
         //
         if ( !bTest )
             Area = AREA_ALL;

//         if ( bAppend && InfFile != NULL ) {
//             dOptions |= SCE_UPDATE_DB;
//         } else {
//             dOptions |= SCE_OVERWRITE_DB;
//         }
         dOptions |= SCE_OVERWRITE_DB;

//         if ( InfFile == NULL || SadFile != NULL ) {
         if ( (SadFile != NULL) &&
              !SceIsSystemDatabase(SadFile) ) {

             rc = SceAnalyzeSystem(
                            NULL,
                            InfFile,
                            SadFile,
                            LogFile,
                            dOptions,
                            Area,
                            (bVerbose || bTest ) ?
                              (PSCE_AREA_CALLBACK_ROUTINE)SceCmdVerboseCallback : NULL,
                            NULL,
                            &dWarning
                            );
         } else {

             rc = SCESTATUS_INVALID_PARAMETER;

             LoadString( hMod,
                         SECEDITP_ANALYSIS_NOT_ALLOWED_1,
                         LineString,
                         256
                         );
             My_wprintf(LineString);

             LoadString( hMod,
                         SECEDITP_ANALYSIS_NOT_ALLOWED_2,
                         LineString,
                         256
                         );
             My_wprintf(LineString);

             EngineType = 0;
         }

         break;

    case SCE_ENGINE_GENERATE:

        if ( InfFile != NULL ) {
            //
            // must have a inf file name
            //
            rc = SceSetupGenerateTemplate(NULL,
                                          SadFile,
                                          bMerge,
                                          InfFile,
                                          LogFile,
                                          Area);

            if (ERROR_NOT_ENOUGH_MEMORY == rc ||
                ERROR_SERVICE_ALREADY_RUNNING == rc ) {
                rCode = 2;
            } else if ( rc ) {
                rCode = 1;
            }

        } else {
            rCode = 1;
            ScepPrintHelp(EngineType);
            goto Done;
        }

        break;

    case SCE_ENGINE_BROWSE:

        //
        // must have a inf file name
        //
        if ( Area == 0 ) {
            Area = AREA_ALL;
        }

        rc = SceBrowseDatabaseTable(SadFile,
                                    (SCETYPE)dWarning,
                                    Area,
                                    bMerge,
                                    (PSCE_BROWSE_CALLBACK_ROUTINE)pBrowseCallback
                                    );
        dWarning = 0; // reset the value

        if (ERROR_NOT_ENOUGH_MEMORY == rc ||
            ERROR_SERVICE_ALREADY_RUNNING == rc ) {
            rCode = 2;
        } else if ( rc ) {
            rCode = 1;
        }

        break;

    case SCE_ENGINE_COMPILE:

        rc = 0;
        if ( InfFile != NULL ) {
            //
            // must have a inf file name
            //
            rc = SceOpenProfile(InfFile,
                               SCE_INF_FORMAT,
                               &hProfile);

            if ( rc == SCESTATUS_SUCCESS && hProfile ) {
                //
                // get profile info will parse the template first
                //
                rc = SceGetSecurityProfileInfo(hProfile,
                                              SCE_ENGINE_SCP,
                                              AREA_ALL,
                                              &ProfileInfo,
                                              &ErrBuf);

                if ( SCESTATUS_SUCCESS == rc && ErrBuf ) {
                    //
                    // this is a new version template
                    //

                    LoadString( hMod,
                                SECEDITP_TEMPLATE_NEWVERSION,
                                LineString,
                                256
                                );

                    SeceditpErrOut(0, LineString);

                    rc = SCESTATUS_INVALID_DATA;

                }

                for ( pErr=ErrBuf; pErr != NULL; pErr = pErr->next ) {

                    if ( pErr->buffer != NULL ) {

                        SeceditpErrOut( pErr->rc, pErr->buffer );
                    }
                }

                SceFreeMemory((PVOID)ErrBuf, SCE_STRUCT_ERROR_LOG_INFO);
                ErrBuf = NULL;

                if ( ProfileInfo != NULL ) {
                    SceFreeMemory((PVOID)ProfileInfo, Area);
                    LocalFree(ProfileInfo);
                }

                SceCloseProfile(&hProfile);

            } else {

                if (SCESTATUS_OTHER_ERROR == rc) {
                    LoadString( hMod,
                                SECEDITP_FILE_MAY_CORRUPTED,
                                LineString,
                                256
                                );
                }
                else {
                    LoadString( hMod,
                                SECEDITP_CANNOT_FIND_TEMPLATE,
                                LineString,
                                256
                                );
                }

                SeceditpErrOut(SeceditpSceStatusToDosError(rc),
                               LineString);
            }

            if (SCESTATUS_NOT_ENOUGH_RESOURCE == rc ||
                SCESTATUS_ALREADY_RUNNING == rc ) {
                rCode = 2;
            } else if ( rc ) {
                rCode = 1;
            }

        } else {
            rCode = 1;
            ScepPrintHelp(EngineType);
            goto Done;
        }

        if ( SCESTATUS_SUCCESS == rc && InfFile) {
            LoadString( hMod,
                        SECEDITP_COMPILE_OK,
                        LineString,
                        256
                        );

            My_wprintf(LineString, InfFile);
        }
        break;

    case SCE_ENGINE_REGISTER:

        rc = 0;
        if ( InfFile != NULL ) {

            rc = SceRegisterRegValues(InfFile);

            if (ERROR_NOT_ENOUGH_MEMORY == rc ) {
                rCode = 2;
            } else if ( rc ) {
                rCode = 1;
            }

        } else {
            rCode = 1;
            ScepPrintHelp(EngineType);
            goto Done;
        }

        if ( SCESTATUS_SUCCESS == rc && InfFile) {
            LoadString( hMod,
                        SECEDITP_REGISTER_OK,
                        LineString,
                        256
                        );

            My_wprintf(LineString, InfFile);
        }
        break;

    case SCE_ENGINE_REFRESH:
        break;

    default:
        rc = 0;
        rCode = 1;

        ScepPrintHelp(EngineType);
        break;
    }
    SetConsoleCtrlHandler(NULL, FALSE);

    if ( EngineType == SCE_ENGINE_SCP ||
         EngineType == SCE_ENGINE_SAP ||
         EngineType == SCE_ENGINE_GENERATE ||
         EngineType == SCE_ENGINE_BROWSE ) {

        My_wprintf(L"                                                                           \n");

        if ( SCESTATUS_SUCCESS == rc ) {

            if ( ERROR_SUCCESS == dWarning ) {

                rId = SECEDITP_TASK_COMPLETE_NO_ERROR;
            } else {

//                SeceditpErrOut( dWarning, NULL);

                rId = SECEDITP_TASK_COMPLETE_WARNING;
            }
        } else {

            SeceditpErrOut( SeceditpSceStatusToDosError(rc), NULL);

            rId = SECEDITP_TASK_COMPLETE_ERROR;
        }

        LoadString( hMod,
                    rId,
                    LineString,
                    256
                    );

        if ( rId == SECEDITP_TASK_COMPLETE_WARNING ) {
            //
            // explain the warnings
            //
            WarningStr[0] = L'\0';

            switch ( dWarning ) {
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:

                LoadString( hMod,
                            SECEDITP_WARNING_NOT_FOUND,
                            WarningStr,
                            256
                            );
                break;

            case ERROR_SHARING_VIOLATION:
                LoadString( hMod,
                            SECEDITP_WARNING_IN_USE,
                            WarningStr,
                            256
                            );
                break;

            default:
                LoadString( hMod,
                            SECEDITP_WARNING_OTHER_WARNING,
                            WarningStr,
                            256
                            );
                break;
            }

            My_wprintf(LineString, WarningStr);

        } else {

            My_wprintf(LineString);
        }

        if (bQuiet == FALSE) {
            if ( LogFile ) {

                LoadString( hMod,
                            SECEDITP_TASK_SEE_LOG,
                            LineString,
                            256
                            );

                My_wprintf(LineString, LogFile);

            } else {

                LoadString( hMod,
                            SECEDITP_TASK_SEE_DEF_LOG,
                            LineString,
                            256
                            );

                My_wprintf(L"%s", LineString);
            }

        }

    }

Done:

    if ( dOptions & SCE_DISABLE_LOG ){

        ScepCmdToolLogClose();
    }

    SCE_LOCAL_FREE(InfFile);
    SCE_LOCAL_FREE(SadFile);
    SCE_LOCAL_FREE(LogFile);
    SCE_LOCAL_FREE(pTemp);

    FreeLibrary( hMod );

    if ( rCode )
        return rCode;
    else if ( rc ) {

        if (SCESTATUS_NOT_ENOUGH_RESOURCE == rc ||
            SCESTATUS_ALREADY_RUNNING == rc )
            return 2;
        else
            return 1;
    } else if ( dWarning ) {
        return 3;
    } else
        return 0;

}


VOID
ScepPrintHelp(DWORD nLevel)
{

    PROCESS_INFORMATION ProcInfo;
    STARTUPINFOA StartInfo;
    BOOL fOk;


    RtlZeroMemory(&StartInfo,sizeof(StartInfo));
    StartInfo.cb = sizeof(StartInfo);
    StartInfo.dwFlags = STARTF_USESHOWWINDOW;
    StartInfo.wShowWindow = (WORD)SW_SHOWNORMAL;

    fOk = CreateProcessA(NULL, "hh secedit.chm",
                   NULL, NULL, FALSE,
                   0,
                   NULL,
                   NULL,
                   &StartInfo,
                   &ProcInfo
                   );

    if ( fOk ) {
        CloseHandle(ProcInfo.hProcess);
        CloseHandle(ProcInfo.hThread);
    }
}


SCESTATUS
SeceditpErrOut(
    IN DWORD rc,
    IN LPTSTR buf OPTIONAL
    )
{
    LPVOID     lpMsgBuf=NULL;

    if ( rc != NO_ERROR ) {

        //
        // get error description of rc
        //

        FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                       NULL,
                       rc,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                       (LPTSTR)&lpMsgBuf,
                       0,
                       NULL
                    );
    }

    //
    // Display to screen
    //

    if ( buf ) {

        if (lpMsgBuf != NULL )
            My_fwprintf( stdout, L"%s %s\n", (PWSTR)lpMsgBuf, buf );
        else
            My_fwprintf( stdout, L"%s\n", buf );
    } else {

        if (lpMsgBuf != NULL )
            My_fwprintf( stdout, L"%s\n", (PWSTR)lpMsgBuf);
    }

    SCE_LOCAL_FREE(lpMsgBuf);

    return(SCESTATUS_SUCCESS);
}


DWORD
SeceditpSceStatusToDosError(
    IN SCESTATUS SceStatus
    )
// converts SCESTATUS error code to dos error defined in winerror.h
{
    switch(SceStatus) {

    case SCESTATUS_SUCCESS:
        return(NO_ERROR);

    case SCESTATUS_OTHER_ERROR:
        return(ERROR_EXTENDED_ERROR);

    case SCESTATUS_INVALID_PARAMETER:
        return(ERROR_INVALID_PARAMETER);

    case SCESTATUS_RECORD_NOT_FOUND:
        return(ERROR_NO_MORE_ITEMS);

    case SCESTATUS_NO_MAPPING:
        return(ERROR_NONE_MAPPED);

    case SCESTATUS_TRUST_FAIL:
        return(ERROR_TRUSTED_DOMAIN_FAILURE);

    case SCESTATUS_INVALID_DATA:
        return(ERROR_INVALID_DATA);

    case SCESTATUS_OBJECT_EXIST:
        return(ERROR_FILE_EXISTS);

    case SCESTATUS_BUFFER_TOO_SMALL:
        return(ERROR_INSUFFICIENT_BUFFER);

    case SCESTATUS_PROFILE_NOT_FOUND:
        return(ERROR_FILE_NOT_FOUND);

    case SCESTATUS_BAD_FORMAT:
        return(ERROR_BAD_FORMAT);

    case SCESTATUS_NOT_ENOUGH_RESOURCE:
        return(ERROR_NOT_ENOUGH_MEMORY);

    case SCESTATUS_ACCESS_DENIED:
        return(ERROR_ACCESS_DENIED);

    case SCESTATUS_CANT_DELETE:
        return(ERROR_CURRENT_DIRECTORY);

    case SCESTATUS_PREFIX_OVERFLOW:
        return(ERROR_BUFFER_OVERFLOW);

    case SCESTATUS_ALREADY_RUNNING:
        return(ERROR_SERVICE_ALREADY_RUNNING);

    case SCESTATUS_SERVICE_NOT_SUPPORT:
        return(ERROR_NOT_SUPPORTED);

    case SCESTATUS_MOD_NOT_FOUND:
        return(ERROR_MOD_NOT_FOUND);

    case SCESTATUS_EXCEPTION_IN_SERVER:
        return(ERROR_EXCEPTION_IN_SERVICE);

    case SCESTATUS_JET_DATABASE_ERROR:
        return(ERROR_DATABASE_FAILURE);

    case SCESTATUS_TIMEOUT:
        return(ERROR_TIMEOUT);

    case SCESTATUS_PENDING_IGNORE:
        return(ERROR_IO_PENDING);

    case SCESTATUS_SPECIAL_ACCOUNT:
        return(ERROR_SPECIAL_ACCOUNT);

    default:
        return(ERROR_EXTENDED_ERROR);
    }
}


BOOL CALLBACK
SceCmdVerboseCallback(
    IN HANDLE CallbackHandle,
    IN AREA_INFORMATION Area,
    IN DWORD TotalTicks,
    IN DWORD CurrentTicks
    )
{
    LPCTSTR SectionName;
    DWORD nProg;
    WCHAR LineString[256];

    switch ( Area ) {
    case AREA_SECURITY_POLICY:
        SectionName = NULL;
        break;
    case AREA_PRIVILEGES:
        SectionName = szPrivilegeRights;
        break;
    case AREA_GROUP_MEMBERSHIP:
        SectionName = szGroupMembership;
        break;
    case AREA_FILE_SECURITY:
        SectionName = szFileSecurity;
        break;
    case AREA_REGISTRY_SECURITY:
        SectionName = szRegistryKeys;
        break;
    case AREA_DS_OBJECTS:
        SectionName = szDSSecurity;
        break;
    case AREA_SYSTEM_SERVICE:
        SectionName = NULL;
        break;
    default:
        SectionName = NULL;
        break;
    }

    if ( TotalTicks ) {
        nProg = (CurrentTicks+1)*100/TotalTicks;
        if ( nProg > 100 ) {
            nProg = 100;
        }
    } else {
        nProg = 0;
    }

    if ( SectionName ) {
        LoadString( hMod,
                    SECEDITP_WITH_SECTIONNAME,
                    LineString,
                    256
                    );
        My_wprintf(LineString, nProg, CurrentTicks, TotalTicks, SectionName);

    } else if ( Area == AREA_SECURITY_POLICY ) {
        LoadString( hMod,
                    SECEDITP_SICURITY_POLICY,
                    LineString,
                    256
                    );
        My_wprintf(LineString, nProg, CurrentTicks, TotalTicks);
    } else if ( Area == AREA_SYSTEM_SERVICE ) {
        LoadString( hMod,
                    SECEDITP_SYSTEM_SERVICE,
                    LineString,
                    256
                    );
        My_wprintf(LineString, nProg, CurrentTicks, TotalTicks);
    } else {
        LoadString( hMod,
                    SECEDITP_NO_SECTIONNAME,
                    LineString,
                    256
                    );
        My_wprintf(LineString, nProg, CurrentTicks, TotalTicks);
    }


    return TRUE;

}

DWORD
pProgressRoutine(
    IN PWSTR StringUpdate
    )
{

    if ( StringUpdate ) {
        My_wprintf(L"Process %s\n", StringUpdate);
    }
    return 0;
}

BOOL
ScepPrintConfigureWarning()
{

    WCHAR               LineString[256];
    WCHAR               wch;

    LoadString( hMod,
                SECEDITP_CONFIG_WARNING_LINE1,
                LineString,
                256
                );
    My_wprintf(LineString);

    LoadString( hMod,
                SECEDITP_CONFIG_WARNING_LINE2,
                LineString,
                256
                );
    My_wprintf(LineString);

    LoadString( hMod,
                SECEDITP_CONFIG_WARNING_LINE3,
                LineString,
                256
                );
    My_wprintf(LineString);

    //
    // get user input
    //
    LoadString( hMod,
                SECEDITP_CONFIG_WARNING_CONFIRM,
                LineString,
                256
                );

    My_wprintf(LineString);

    wch = getwc(stdin);
    getwc(stdin);

    //
    // load string for Yes
    //
    LineString[0] = L'\0';
    LoadString( hMod,
                SECEDITP_IDS_YES,
                LineString,
                256
                );

    if ( towlower(wch) == towlower(LineString[0]) ) {
        return(TRUE);
    } else {
        return(FALSE);
    }

}


BOOL CALLBACK
pBrowseCallback(
    IN LONG ID,
    IN PWSTR KeyName OPTIONAL,
    IN PWSTR GpoName OPTIONAL,
    IN PWSTR Value OPTIONAL,
    IN DWORD Len
    )
{

    BYTE *pb=NULL;

    My_wprintf(L"\n");
    if ( ID > 0 ) {
        My_printf("%d\t", ID);
    }

    if (GpoName ) {
        My_wprintf(L"%s    ", GpoName);
    }

    if ( KeyName ) {
        My_wprintf(L"%s", KeyName);

        if ( Value && Len > 0 ) {
            if ( Len > 30 ) {
                My_wprintf(L"\n");
            } else {
                My_wprintf(L"\t");
            }
            if ( iswprint(Value[0]) ) {
                My_wprintf(L"%c%s\n", Value[0], (Len>1) ? Value+1 : L"");
            } else {

                pb = (BYTE *)Value;

                My_wprintf(L"%d %d ", pb[1], pb[0]);
/*

                if ( isprint( pc[0] ) ) {
                    My_printf("%c ", pc[0] );
                } else {
                    My_printf("%d ", (int)(pc[0]) );
                }
                if ( isprint( pc[1] ) ) {
                    My_printf("%c ", pc[1] );
                } else {
                    My_printf("%d ", (int)pc[1] );
                }
*/
                if ( Len > 1 && Value[1] != L'\0' ) {
                    My_wprintf(L"%s\n", Value+1);
                } else {
                    My_wprintf(L"No value\n");
                }

            }

        } else {
            My_wprintf(L"\n");
        }
    } else {
        My_wprintf(L"\n");
    }

    return(TRUE);
}


 /***
 * My_wprintf(format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW.
 * Note: This My_wprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

int __cdecl
My_wprintf(
    const wchar_t *format,
    ...
    )

{
    DWORD  cchWChar = 0;
    DWORD  dwBytesWritten;

    va_list args;
    va_start( args, format );

    cchWChar = My_vfwprintf(stdout, format, args);

    va_end(args);

    return cchWChar;
}



 /***
 * My_fwprintf(stream, format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW.
 * Note: This My_fwprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   )

{
    DWORD  cchWChar = 0;

    va_list args;
    va_start( args, format );

    cchWChar = My_vfwprintf(str, format, args);

    va_end(args);

    return cchWChar;
}


int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   )

{
    HANDLE hOut;

    // if the /quiet option is specified, suppress printing to stdout
    // and instead print to the logfile. If logfile not specified
    // don't print at all

    if (dOptions & SCE_DISABLE_LOG){
        DWORD  cchWChar = 0;
        LPTSTR  szBufferMessage = (LPTSTR) LocalAlloc (LPTR, 2048 * sizeof(TCHAR));

        if (szBufferMessage) {

            vswprintf( szBufferMessage, format, argptr );
            cchWChar = wcslen(szBufferMessage);
            // remove trailing LFs
            if (szBufferMessage[cchWChar-1] == L'\n')
                szBufferMessage[cchWChar-1] = L'\0';
            // remove leading LFs
            if (szBufferMessage[0] == L'\n')
                szBufferMessage[0] = L' ';
            ScepCmdToolLogWrite(szBufferMessage);
            SCE_LOCAL_FREE(szBufferMessage);
        }

        return cchWChar;
    }

    if (str == stderr) {
        hOut = GetStdHandle(STD_ERROR_HANDLE);
    }
    else {
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    if ((GetFileType(hOut) & ~FILE_TYPE_REMOTE) == FILE_TYPE_CHAR) {
        DWORD  cchWChar;
        WCHAR  szBufferMessage[1024];

        vswprintf( szBufferMessage, format, argptr );
        cchWChar = wcslen(szBufferMessage);
        WriteConsoleW(hOut, szBufferMessage, cchWChar, &cchWChar, NULL);
        return cchWChar;
    }

    return fwprintf(str, format, argptr);
}

///////////////////////////////////////////////////////////////////////////////
// This function is to suppress printf if the /quiet option is specified
///////////////////////////////////////////////////////////////////////////////

int __cdecl
My_printf(
    const char *format,
    ...
    )

{
    int cchChar = 0;

    va_list argptr;

    va_start( argptr, format );

    cchChar = printf(format, argptr);

    va_end(argptr);

    return cchChar;

}


///////////////////////////////////////////////////////////////////////////////
// This function takes the user string that is supplied at the command line
// and converts it into full path names for eg. it takes ..\%windir%\hisecws.inf
// and converts it to C:\winnt\security\templates\hisecws.inf
///////////////////////////////////////////////////////////////////////////////

WCHAR *
SecEditPConvertToFullPath(
    WCHAR *pUserFilename,
    DWORD *pRetCode
    )
{
    BOOL        NeedCurrDirFlag = TRUE;
    SCESTATUS   rc;
    DWORD       Len;
    DWORD       LenCurrDir;
    PWSTR       pCurrentDir = NULL;
    PWSTR       pAbsolutePath = NULL;
    PWSTR       pAbsolutePathDirOnly = NULL;
    PWSTR       pToMerge = NULL;
    PWSTR       pLastSlash = NULL;
    WCHAR       FirstThree[4];
    WCHAR       LineString[256];

    if (pUserFilename == NULL) {
        *pRetCode = 2;
        goto ScePathConvertFuncError;
    }

    // PathIsRoot() works only if exact strings
    // such as C:\ are passed - so need to extract

    wcsncpy(FirstThree, pUserFilename, 3);
    FirstThree[3] = L'\0';

    // if pUserFilename C:\ etc. then we do not need the current directory -
    // Note: extraction hack not needed if PathIsRoot() worked as published

    NeedCurrDirFlag = !PathIsRoot(FirstThree);
    if (NeedCurrDirFlag){
        LenCurrDir = GetCurrentDirectory(0, NULL);
        pCurrentDir = (PWSTR)LocalAlloc(LMEM_ZEROINIT, (LenCurrDir+1)*sizeof(WCHAR));
        if ( pCurrentDir == NULL ) {
            rc = GetLastError();
            LoadString( hMod,
                        SECEDITP_OUT_OF_MEMORY,
                        LineString,
                        256
                        );
            SeceditpErrOut(rc, LineString );
            *pRetCode = 2;
            goto ScePathConvertFuncError;
        }
        GetCurrentDirectory(LenCurrDir, pCurrentDir);
        if  (pCurrentDir[LenCurrDir - 2] != L'\\')
            wcscat(pCurrentDir, L"\\");
    }

    // allocate space for string that holds the to-be-expanded string

    Len = wcslen(pUserFilename);
    if (NeedCurrDirFlag)
        Len += LenCurrDir;
    pToMerge = (PWSTR)LocalAlloc(LMEM_ZEROINIT, (Len+1)*sizeof(WCHAR));
    if ( pToMerge == NULL ) {
        rc = GetLastError();
        LoadString( hMod,
                    SECEDITP_OUT_OF_MEMORY,
                    LineString,
                    256
                    );
        SeceditpErrOut(rc, LineString );
        *pRetCode = 2;
        goto ScePathConvertFuncError;
    }

    if (NeedCurrDirFlag)
        wcscat(pToMerge, pCurrentDir);

    wcscat(pToMerge, pUserFilename);

    // allocate space for string that holds the final full path - can't be > wcslen(pToMerge)
#ifdef DBG
    // shlwapi is lame on chk builds and verifies that the dest buffer is MAX_PATH
    pAbsolutePath = (PWSTR)LocalAlloc(LMEM_ZEROINIT, MAX_PATH*sizeof(WCHAR));
#else
    pAbsolutePath = (PWSTR)LocalAlloc(LMEM_ZEROINIT, (Len+1)*sizeof(WCHAR));
#endif

    if ( pAbsolutePath == NULL ) {
        rc = GetLastError();
        LoadString( hMod,
                    SECEDITP_OUT_OF_MEMORY,
                    LineString,
                    256
                    );
        SeceditpErrOut(rc, LineString );
        *pRetCode = 2;
        goto ScePathConvertFuncError;
    }

    // canonicalize pToMerge i.e. collapse all ..\, .\ and merge

    if (PathCanonicalize(pAbsolutePath, pToMerge) == FALSE){
        LoadString( hMod,
                    SECEDITP_PATH_NOT_CANONICALIZABLE,
                    LineString,
                    256
                    );
        My_wprintf(LineString);
        SCE_LOCAL_FREE(pAbsolutePath);
        *pRetCode = 2;
        goto ScePathConvertFuncError;
    }

    // allocate string to verify validity of directory

    pAbsolutePathDirOnly = (PWSTR)LocalAlloc(LMEM_ZEROINIT, ((wcslen(pAbsolutePath)+1)*sizeof(WCHAR)));
    if ( pAbsolutePathDirOnly == NULL ) {
        rc = GetLastError();
        LoadString( hMod,
                    SECEDITP_OUT_OF_MEMORY,
                    LineString,
                    256
                    );
        SeceditpErrOut(rc, LineString );
        SCE_LOCAL_FREE(pAbsolutePath);
        *pRetCode = 2;
        goto ScePathConvertFuncError;
    }

    // prepare pAbsolutePathDirOnly to have directory part only

    wcscpy(pAbsolutePathDirOnly, pAbsolutePath);
    pLastSlash = wcsrchr(pAbsolutePathDirOnly, L'\\');
    if (pLastSlash)
        *pLastSlash = L'\0';
    if (PathIsDirectory(pAbsolutePathDirOnly) == FALSE){
        LoadString( hMod,
                    SECEDITP_PATH_NOT_VALID,
                    LineString,
                    256
                    );
        My_wprintf(L"\n%s - %s\n", LineString, pAbsolutePathDirOnly);
        SCE_LOCAL_FREE(pAbsolutePath);
        *pRetCode = 2;
        goto ScePathConvertFuncError;
    }

ScePathConvertFuncError:

    SCE_LOCAL_FREE(pCurrentDir);
    SCE_LOCAL_FREE(pToMerge);
    SCE_LOCAL_FREE(pAbsolutePathDirOnly);

    return  pAbsolutePath;
}

///////////////////////////////////////////////////////////////////////////////
//   This function opens the log file specified and saves the name and its handle
//   in global variables
///////////////////////////////////////////////////////////////////////////////

BOOL
ScepCmdToolLogInit(
    PWSTR    logname
    )
{
    DWORD  rc=NO_ERROR;

    if ( logname && wcslen(logname) > 3 ) {

        hCmdToolLogFile = CreateFile(logname,
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

        if ( INVALID_HANDLE_VALUE != hCmdToolLogFile ) {

            DWORD dwBytesWritten;
            CHAR TmpBuf[3];

            SetFilePointer (hCmdToolLogFile, 0, NULL, FILE_BEGIN);

            TmpBuf[0] = (CHAR)0xFF;
            TmpBuf[1] = (CHAR)0xFE;
            TmpBuf[2] = '\0';

            WriteFile (hCmdToolLogFile, (LPCVOID)TmpBuf, 2,
                       &dwBytesWritten,
                       NULL);

            SetFilePointer (hCmdToolLogFile, 0, NULL, FILE_END);

        }

    } else {

        hCmdToolLogFile = INVALID_HANDLE_VALUE;

    }

    if ( hCmdToolLogFile == INVALID_HANDLE_VALUE && (logname != NULL ) ) {

            rc = ERROR_INVALID_NAME;
    }

    if ( INVALID_HANDLE_VALUE != hCmdToolLogFile ) {

        CloseHandle( hCmdToolLogFile );

    }

    hCmdToolLogFile = INVALID_HANDLE_VALUE;

    return(rc);
}

VOID
ScepCmdToolLogWrite(
    PWSTR    pErrString
    )
{
    DWORD   cchWChar;
    const TCHAR c_szCRLF[]    = TEXT("\r\n");

    if ( LogFile && wcslen(LogFile) > 3 ) {

        hCmdToolLogFile = CreateFile(LogFile,
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

        if ( INVALID_HANDLE_VALUE != hCmdToolLogFile ) {

            SetFilePointer (hCmdToolLogFile, 0, NULL, FILE_END);

            cchWChar =  wcslen( pErrString );

            WriteFile(hCmdToolLogFile,
                      (LPCVOID)pErrString,
                      sizeof(WCHAR) * cchWChar,
                      &cchWChar,
                      NULL);

            WriteFile (hCmdToolLogFile, (LPCVOID) c_szCRLF,
                       2 * sizeof(WCHAR),
                       &cchWChar,
                       NULL);

//            SetFilePointer (hCmdToolLogFile, 0, NULL, FILE_END);

            CloseHandle( hCmdToolLogFile );

            hCmdToolLogFile = INVALID_HANDLE_VALUE;

            return;

        }
    }

}


///////////////////////////////////////////////////////////////////////////////
//   This function closes the log file if there is one opened and
//   clears the log variables
///////////////////////////////////////////////////////////////////////////////

SCESTATUS
ScepCmdToolLogClose()
{
   if ( INVALID_HANDLE_VALUE != hCmdToolLogFile ) {
       CloseHandle( hCmdToolLogFile );
   }

   hCmdToolLogFile = INVALID_HANDLE_VALUE;

   return(SCESTATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\fileshr\smbdllrc.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    smbdllrc.h

Abstract:

    This module defines resource IDs for strings

Author:

    Jin Huang (Jinhuang) 27-Feb.-1998

Revision History:

--*/
#ifndef __smbdllrc__
#define __smbdllrc__

#define SMBSVC_ERROR_ANALYZE           7100
#define SMBSVC_ERROR_CONFIGURE         7101
#define SMBSVC_ERROR_ENUM_SHARE        7102
#define SMBSVC_ERROR_QUERY             7103
#define SMBSVC_ERROR_SAVE_INFO         7104
#define SMBSVC_UNKNOWN_KEYWORD         7105

#define SMBSVC_ANALYZE_CLIENT_DONE     7110
#define SMBSVC_ANALYZE_CLIENT_START    7111
#define SMBSVC_ANALYZE_SERVER_DONE     7112
#define SMBSVC_ANALYZE_SERVER_START    7113
#define SMBSVC_CONFIGURE_CLIENT_DONE   7114
#define SMBSVC_CONFIGURE_CLIENT_START  7115
#define SMBSVC_CONFIGURE_SERVER_DONE   7116
#define SMBSVC_CONFIGURE_SERVER_START  7117

#define SMBSVC_MATCH                   7120
#define SMBSVC_MISMATCH                7121
#define SMBSVC_NOT_CONFIGURED          7122
#define SMBSVC_QUERY_INFO              7123
#define SMBSVC_SAVE_INFO               7124
#define SMBSVC_UPDATE_INFO             7125

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\podtest\requestobject.h ===
// RequestObject.h: interface for the CRequestObject class.
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REQUESTOBJECT_H__c5f6cc21_6195_4555_b9d8_3ef327763cae__INCLUDED_)
#define AFX_REQUESTOBJECT_H__c5f6cc21_6195_4555_b9d8_3ef327763cae__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CGenericClass;

class CRequestObject
{
public:
    CRequestObject();
    virtual ~CRequestObject();

    void Initialize(IWbemServices *pNamespace);

    HRESULT CreateObject(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT CreateObjectEnum(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT PutObject(IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT ExecMethod(BSTR bstrPath, BSTR bstrMethod, IWbemClassObject *pInParams,
                   IWbemObjectSink *pHandler, IWbemContext *pCtx);
    HRESULT DeleteObject(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx);

    bool ParsePath(BSTR bstrPath);
    bool Cleanup();

    BSTR m_bstrClass;
    BSTR m_bstrPath;
    BSTR m_Property[POD_KEY_LIST_SIZE];
    BSTR m_Value[POD_KEY_LIST_SIZE];
    int m_iPropCount;
    int m_iValCount;

    IWbemServices *m_pNamespace;
    IWbemObjectSink *m_pHandler;

private:
    HRESULT CreateClass(CGenericClass **pClass, IWbemContext *pCtx);

    bool IsInstance();
    static CHeap_Exception m_he;

protected:
    ULONG m_cRef;         //Object reference count
};

//Properties
//////////////////
extern const WCHAR *pSceStorePath;
extern const WCHAR *pLogFilePath;
extern const WCHAR *pLogFileRecord;
extern const WCHAR *pLogArea;
extern const WCHAR *pLogErrorCode;
extern const WCHAR *pKeyName;
extern const WCHAR *pKey;
extern const WCHAR *pValue;
extern const WCHAR *pPodID;
extern const WCHAR *pPodSection;
extern const WCHAR *szPodGUID;

#endif // !defined(AFX_REQUESTOBJECT_H__c5f6cc21_6195_4555_b9d8_3ef327763cae__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\escprov\podtest\requestobject.cpp ===
// RequestObject.cpp: implementation of the CRequestObject class.
// Copyright (c)1997-1999 Microsoft Corporation
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "requestobject.h"
#include <stdio.h>

//Classes
#include "poddata.h"
#include "podbase.h"

//Associations

CHeap_Exception CRequestObject::m_he(CHeap_Exception::E_ALLOCATION_ERROR);

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRequestObject::CRequestObject()
{
    m_cRef = 0;
    m_bstrPath = NULL;
    m_bstrClass = NULL;
}

CRequestObject::~CRequestObject()
{
}

//***************************************************************************
//
// CRequestObject::QueryInterface
// CRequestObject::AddRef
// CRequestObject::Release
//
// Purpose: IUnknown members for CRequestObject object.
//***************************************************************************
/*
STDMETHODIMP CRequestObject::QueryInterface(REFIID riid, PPVOID ppv)
{
    return E_NOINTERFACE;

}


STDMETHODIMP_(ULONG) CRequestObject::AddRef(void)
{
    InterlockedIncrement((long *)&m_cRef);

    return m_cRef;
}

STDMETHODIMP_(ULONG) CRequestObject::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);

//    if(0L == nNewCount) delete this;

    return nNewCount;
}
*/
void CRequestObject::Initialize(IWbemServices *pNamespace)
{
    m_pNamespace = pNamespace;
    m_pHandler = NULL;
    m_bstrClass = NULL;
    m_bstrPath = NULL;
    m_iPropCount = m_iValCount = 0;

    for(int i = 0; i < POD_KEY_LIST_SIZE; i++) m_Property[i] = m_Value[i] = NULL;

}

HRESULT CRequestObject::CreateObject(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CGenericClass *pClass = NULL;

    m_bstrPath = SysAllocString(bstrPath);
    if(!m_bstrPath)
        throw m_he;

    if(ParsePath(bstrPath)){

        try{
            //create the appropriate class
            if(SUCCEEDED(hr = CreateClass(&pClass, pCtx))){

                if(!pClass)
                    throw m_he;

                //get the requested object
                hr = pClass->CreateObject(pHandler, ACTIONTYPE_GET);
            }

        }catch(...){

            if(pClass){
                pClass->CleanUp();
                delete pClass;
            }
            throw;
        }

        if(pClass){

            pClass->CleanUp();
            delete pClass;
        }

    }else hr = WBEM_E_FAILED;

    return hr;
}

HRESULT CRequestObject::CreateClass(CGenericClass **pClass, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;

        //Create the appropriate class
/////////////
// Classes //
/////////////
    if(0 == _wcsicmp(m_bstrClass, L"Sample_DataClass")){
        *pClass = new CPodData(this, m_pNamespace, pCtx);

    } else if(0 == _wcsicmp(m_bstrClass, L"Sample_BaseClass")){
        *pClass = new CPodBase(this, m_pNamespace, pCtx);

//////////////////
// Associations //
//////////////////
    }else return WBEM_E_NOT_FOUND;

    if(!(*pClass)) throw m_he;

    return hr;
};

HRESULT CRequestObject::CreateObjectEnum(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CGenericClass *pClass = NULL;

    m_bstrPath = SysAllocString(bstrPath);
    if(!m_bstrPath) throw m_he;

    if(ParsePath(bstrPath)){

        try{
            //Create the appropriate class
            if(SUCCEEDED(hr = CreateClass(&pClass, pCtx))){

                if(!pClass) throw m_he;

                //Enumerate the objects
                hr = pClass->CreateObject(pHandler, ACTIONTYPE_ENUM);
            }

        }catch(...){

            if(pClass){
                pClass->CleanUp();
                delete pClass;
            }
            throw;
        }

        if(pClass){
            pClass->CleanUp();
            delete pClass;
        }

    }else hr = WBEM_E_FAILED;

    return hr;
}

HRESULT CRequestObject::PutObject(IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CGenericClass *pClass = NULL;
    VARIANT v;

    VariantInit(&v);

    if(SUCCEEDED(pInst->Get(L"__RELPATH", 0, &v, NULL, NULL))){

        m_bstrPath = SysAllocString(V_BSTR(&v));
        if(!m_bstrPath) throw m_he;

        if(!ParsePath(V_BSTR(&v))) hr = WBEM_E_FAILED;

    }else hr = WBEM_E_FAILED;

    if(SUCCEEDED(pInst->Get(L"__CLASS", 0, &v, NULL, NULL))){

        try{

            m_bstrClass = SysAllocString(V_BSTR(&v));
            if(!m_bstrClass) throw m_he;

            //Create the appropriate class
            if(SUCCEEDED(hr = CreateClass(&pClass, pCtx))){

                if(!pClass) throw m_he;

                //Enumerate the objects
                hr = pClass->PutInst(pInst, pHandler, pCtx);
            }

        }catch(...){

            if(pClass){
                pClass->CleanUp();
                delete pClass;
            }
            throw;
        }

        if(pClass){
            pClass->CleanUp();
            delete pClass;
        }

    }else hr = WBEM_E_FAILED;

    VariantClear(&v);

    return hr;
}

HRESULT CRequestObject::ExecMethod(BSTR bstrPath, BSTR bstrMethod, IWbemClassObject *pInParams,
                   IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CGenericClass *pClass = NULL;

    m_bstrPath = SysAllocString(bstrPath);
    if(!m_bstrPath) throw m_he;

    if(ParsePath(bstrPath)){

        try{
            //Create the appropriate class
            if(SUCCEEDED(hr = CreateClass(&pClass, pCtx))){

                if(!pClass) throw m_he;

                //execute the method
                hr = pClass->ExecMethod(bstrMethod, IsInstance(), pInParams, pHandler, pCtx);
            }

        }catch(...){

            if(pClass){
                pClass->CleanUp();
                delete pClass;
            }
            throw;
        }

        if(pClass){
            pClass->CleanUp();
            delete pClass;
        }

    }else
        return WBEM_E_FAILED;

    return hr;
}

HRESULT CRequestObject::DeleteObject(BSTR bstrPath, IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CGenericClass *pClass = NULL;

    m_bstrPath = SysAllocString(bstrPath);
    if(!m_bstrPath) throw m_he;

    if(ParsePath(bstrPath)){

        try{
            //Create the appropriate class
            if(SUCCEEDED(hr = CreateClass(&pClass, pCtx))){

                if(!pClass) throw m_he;

                //delete the object
                hr = pClass->CreateObject(pHandler, ACTIONTYPE_DELETE);
            }

        }catch(...){

            if(pClass){
                pClass->CleanUp();
                delete pClass;
            }
            throw;
        }

        if(pClass){
            pClass->CleanUp();
            delete pClass;
        }
    }else hr = WBEM_E_FAILED;

    return hr;
}

bool CRequestObject::ParsePath(BSTR bstrPath)
{
    if(wcslen(bstrPath) < 1) return false;

    WCHAR wcTest[(BUFF_SIZE) + 1];
    wcscpy(wcTest, bstrPath);
    WCHAR *pwcTest = NULL;
    WCHAR *pwcClassStart = wcTest;
    WCHAR *pwcNamespace = NULL;
    WCHAR *pwcStart = NULL;
    WCHAR *pwcStrip = NULL;
    WCHAR wcPrevious = NULL;
    int iNumQuotes = 0;
    bool bClass = false;
    bool bDoubles = false;

    //Main Parsing Loop
    for(pwcTest = wcTest; *pwcTest; pwcTest++){

        if((*pwcTest == L'\\') && !bClass){

            for(pwcNamespace = pwcTest; *pwcNamespace != L':'; pwcNamespace++){}
            pwcClassStart = pwcNamespace + 1;
            pwcTest = pwcNamespace;

        }else if(*pwcTest == L'.'){

            if(iNumQuotes == 0){

                // issolate the class name.
                *pwcTest = NULL;
                if(m_bstrClass){

                    SysFreeString(m_bstrClass);
                    m_bstrClass = NULL;
                }
                m_bstrClass = SysAllocString(pwcClassStart);
                if(!m_bstrClass) throw m_he;

                bClass = true;
                pwcStart = (pwcTest + 1);
            }

        }else if(*pwcTest == L'='){

            if(iNumQuotes == 0){

                if(!bClass){

                    // issolate the class name.
                    *pwcTest = NULL;
                    if(m_bstrClass){

                        SysFreeString(m_bstrClass);
                        m_bstrClass = NULL;
                    }
                    m_bstrClass = SysAllocString(pwcClassStart);
                    if(!m_bstrClass) throw m_he;

                    bClass = true;
                    pwcStart = (pwcTest + 1);

                }else{

                    // issolate the property name.
                    *pwcTest = NULL;
                    if(pwcStart != NULL){

                        m_Property[m_iPropCount] = SysAllocString(pwcStart);
                        if(!m_Property[m_iPropCount++]) throw m_he;
                        pwcStart = (pwcTest + 1);

                    }else pwcStart = (pwcTest + 1);
                }
            }
        }else if(*pwcTest == L','){

            if(iNumQuotes != 1){

                // issolate the property value.
                *pwcTest = NULL;
                if(pwcStart != NULL){

                    m_Value[m_iValCount] = SysAllocString(pwcStart);
                    if(!m_Value[m_iValCount++]) throw m_he;
                    pwcStart = (pwcTest + 1);

                }else return false;
            }

        }else if(*pwcTest == L'\"'){

            if(wcPrevious != L'\\'){

                // deal with quotes in path.
                iNumQuotes++;
                if(iNumQuotes == 1) pwcStart = (pwcTest + 1);
                else if(iNumQuotes == 2){

                    *pwcTest = NULL;
                    iNumQuotes = 0;
                }

            }else if(iNumQuotes == 1){

                //deal with embedded quotes
                for(pwcStrip = (--pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

                *pwcStrip = NULL;
            }

        }else if((*pwcTest == L'\\') && (wcPrevious == L'\\') && bClass && !bDoubles){

            for(pwcStrip = (--pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

            *pwcStrip = NULL;
        }

#ifdef _STRIP_ESCAPED_CHARS
        else if(*pwcTest == L'%'){

            //deal with escaped URL characters
            if(*(pwcTest + 1) == L'0'){

                if(*(pwcTest + 2) == L'7'){
                    //bell
                    *pwcTest = L'\\';
                    *(++pwcTest) = L'a';

                    for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

                    *pwcStrip = NULL;

                }else if(*(pwcTest + 2) == L'8'){
                    //backspace
                    *pwcTest = L'\\';
                    *(++pwcTest) = L'b';

                    for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

                    *pwcStrip = NULL;

                }else if(*(pwcTest + 2) == L'9'){
                    //horizontal tab
                    *pwcTest = L'\\';
                    *(++pwcTest) = L't';

                    for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

                    *pwcStrip = NULL;

                }else if((*(pwcTest + 2) == L'A') || (*(pwcTest + 2) == L'a')){
                    //newline
                    *pwcTest = L'\\';
                    *(++pwcTest) = L'n';

                    for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

                    *pwcStrip = NULL;

                }else if((*(pwcTest + 2) == L'B') || (*(pwcTest + 2) == L'b')){
                    //vertical tab
                    *pwcTest = L'\\';
                    *(++pwcTest) = L'v';

                    for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

                    *pwcStrip = NULL;

                }else if((*(pwcTest + 2) == L'C') || (*(pwcTest + 2) == L'c')){
                    //formfeed
                    *pwcTest = L'\\';
                    *(++pwcTest) = L'f';

                    for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

                    *pwcStrip = NULL;

                }else if((*(pwcTest + 2) == L'D') || (*(pwcTest + 2) == L'd')){
                    //carriage return
                    *pwcTest = L'\\';
                    *(++pwcTest) = L'r';

                    for(pwcStrip = (++pwcTest); *pwcStrip; pwcStrip++) *pwcStrip = *(pwcStrip + 1);

                    *pwcStrip = NULL;

                }else return false;

            }else if(*(pwcTest + 1) == L'1'){

                return false;

            }else if(*(pwcTest + 1) == L'2'){

                if(*(pwcTest + 2) == L'0'){

                    //space
                    *pwcTest++ = L' ';

                    for(int ip = 0; ip < 2; ip++)
                        for(pwcStrip = (pwcTest); *pwcStrip; pwcStrip++)
                            *pwcStrip = *(pwcStrip + 1);

                    *pwcStrip = NULL;

                }else return false;
            }
        }
#endif //_STRIP_ESCAPED_CHARS

        if((wcPrevious == *pwcTest) && !bDoubles) bDoubles = true;
        else bDoubles = false;

        wcPrevious = *pwcTest;
    }

    // if we still have values to add, do so now
    if(pwcStart != NULL){
        m_Value[m_iValCount] = SysAllocString(pwcStart);
        if(!m_Value[m_iValCount++]) throw m_he;

    }else if((m_iPropCount < 1) && (m_iValCount < 1)){

        if(m_bstrClass){

            SysFreeString(m_bstrClass);
            m_bstrClass = NULL;
        }
        m_bstrClass = SysAllocString(pwcClassStart);
        if(!m_bstrClass) throw m_he;
    }

    if(iNumQuotes != 0) return false;

    if(m_iValCount != m_iPropCount){
        if(m_iValCount > m_iPropCount){ if(m_iValCount != 1) return false;  }
        else return false;
    }

    if(!m_bstrClass) return false;

    return true;
}

bool CRequestObject::Cleanup()
{
    //Let's destroy our list and clear up some space
    if(m_bstrClass != NULL) SysFreeString(m_bstrClass);
    if(m_bstrPath != NULL) SysFreeString(m_bstrPath);

    for(int i = 0; i < POD_KEY_LIST_SIZE; i++){

        if(m_Property[i] != NULL) SysFreeString(m_Property[i]);
        if(m_Value[i] != NULL) SysFreeString(m_Value[i]);
    }

    return true;
}

bool CRequestObject::IsInstance()
{
    if((m_iPropCount > 0) || (m_iValCount > 0)) return true;
    return false;
}


//Properties
/////////////////////

const WCHAR *pSceStorePath = L"SceStorePath";
const WCHAR *pLogFilePath = L"LogFilePath";
const WCHAR *pLogFileRecord = L"LogFileRecord";
const WCHAR *pLogArea = L"LogArea";
const WCHAR *pLogErrorCode = L"LogErrorCode";
const WCHAR *pKeyName = L"KeyName";
const WCHAR *pKey = L"Key";
const WCHAR *pValue = L"Value";
const WCHAR *pPodID = L"PodID";
const WCHAR *pPodSection = L"PodSection";
const WCHAR *szPodGUID = L"{c5f6cc21_6195_4555_b9d8_3ef327763cae}";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\fileshr\smbsvcp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    smbsvcp.h

Abstract:

    This module defines the interfaces for SMB server engine attachment

Author:

    Jin Huang (jinhuang) 11-Jul-1997

Revision History:

--*/

#ifndef _SMBSVCP_
#define _SMBSVCP_

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef __cplusplus
}
#endif

//
// Windows Headers
//

#include <windows.h>
//#include <rpc.h>

//
// C Runtime Header
//

#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <signal.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <lmcons.h>
#include <lmshare.h>
#if defined(_NT4BACK_PORT)
#include <secedit.h>
#else
#include <sddl.h>
#endif

#include <scesvc.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SMBSVC_NO_VALUE                 (BYTE)-2
#define SMBSVC_STATUS_GOOD              0
#define SMBSVC_STATUS_MISMATCH          1
#define SMBSVC_STATUS_NOT_CONFIGURED    2

typedef struct _SMBSVC_KEY_LOOKUP {
   PWSTR    KeyString;
   UINT     Offset;
   CHAR     BufferType;
}SMBSVC_KEY_LOOKUP;


typedef struct _SMBSVC_SHARES_ {

    LPTSTR                  ShareName;
    DWORD                   Status;
    PSECURITY_DESCRIPTOR    pShareSD;
    struct _SMBSVC_SHARES_   *Next;

} SMBSVC_SHARES, *PSMBSVC_SHARES;

typedef struct _SMBSVC_SEC_INFO_ {

    BYTE EnableClientSecuritySignature;
    BYTE RequireClientSecuritySignature;
    BYTE EnablePlainTextPassword;
    BYTE RequireEnhancedChallengeResponse;
    BYTE SendNTResponseOnly;

    BYTE EnableAutoShare;
    BYTE EnableServerSecuritySignature;
    BYTE RequireServerSecuritySignature;
    BYTE RestrictNullSessionAccess;

    BYTE EnableForcedLogOff;
    DWORD AutoDisconnect;

    PWSTR NullSessionPipes;
    DWORD LengthPipes;    // number of bytes
    PWSTR NullSessionShares;
    DWORD LengthShares;   // number of bytes

    PSMBSVC_SHARES pShares;

} SMBSVC_SEC_INFO, *PSMBSVC_SEC_INFO;


SCESTATUS
WINAPI
SceSvcAttachmentConfig(
    IN PSCESVC_CALLBACK_INFO pSceInfo
    );

SCESTATUS
WINAPI
SceSvcAttachmentAnalyze(
    IN PSCESVC_CALLBACK_INFO pSceInfo
    );

SCESTATUS
WINAPI
SceSvcAttachmentUpdate(
    IN PSCESVC_CALLBACK_INFO pSceInfo,
    IN SCESVC_CONFIGURATION_INFO *ServiceInfo
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\fileshr\smbsvc.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    smbsvc.cpp

Abstract:

    File sharing security engine attachment for Security Configuration Editor

Author:

    Jin Huang (jinhuang) 11-Jul-1997

Revision History:

--*/

#include "smbsvcp.h"
#include "util.h"
#include "smbdllrc.h"
#include <lmapibuf.h>
#pragma hdrstop

#define SMBSVC_BUF_LEN     1024
#define SCESMB_ROOT_PATH   SCE_ROOT_SERVICE_PATH TEXT("\\LanManServer")

#define SmbsvcServerKey L"System\\CurrentControlSet\\Services\\LanManServer\\Parameters"
#define SmbsvcRdrKey    L"System\\CurrentControlSet\\Services\\MrxSmb\\Parameters"

#define SmbsvcEnableSS  L"EnableSecuritySignature"
#define SmbsvcRequireSS L"RequireSecuritySignature"
#define SmbsvcPlainPassword L"EnablePlainTextPassword"
#define SmbsvcRequireECR L"RequireEnhancedChallengeResponse"
#define SmbsvcNTResponse L"SendNTResponseOnly"

#define SmbsvcRestrictNull  L"RestrictNullSessAccess"
#define SmbsvcAutoShareServer L"AutoShareServer"
#define SmbsvcAutoShareWks L"AutoShareWks"
#define SmbsvcForcedLogOff L"EnableForcedLogOff"
#define SmbsvcAutoDisconnect L"AutoDisconnect"

#define NUM_COMP  14

#if defined(_NT4BACK_PORT)

HINSTANCE MyModuleHandle = NULL;

#else
/*
#if !defined(Thread)
#define Thread  __declspec( thread )
#endif
HINSTANCE Thread MyModuleHandle=NULL;
*/

HINSTANCE MyModuleHandle=NULL;

#endif

static NT_PRODUCT_TYPE ProductType;

GENERIC_MAPPING ShareGenMap = {
                STANDARD_RIGHTS_READ     | SYNCHRONIZE | 0x1,
                STANDARD_RIGHTS_WRITE    | SYNCHRONIZE | 0x2,
                STANDARD_RIGHTS_EXECUTE  | SYNCHRONIZE | 0x4,
                STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF
                };

SCESTATUS
SmbsvcpResetInfo(
    IN PSMBSVC_SEC_INFO pInfo
    );

SCESTATUS
SmbsvcpGetInformation(
    IN PSCESVC_CALLBACK_INFO pSceCbInfo,
    OUT PSMBSVC_SEC_INFO pSmbInfo
    );

SCESTATUS
SmbsvcpAddAShareToList(
    OUT PSMBSVC_SHARES *pShareList,
    IN PWSTR ShareName,
    IN DWORD Status,
    IN PSECURITY_DESCRIPTOR pSD
    );

SCESTATUS
SmbsvcpFree(
    IN PSMBSVC_SEC_INFO pSmbInfo
    );

SCESTATUS
SmbsvcpFreeShareList(
    PSMBSVC_SHARES pShares
    );

SCESTATUS
SmbsvcpWriteError(
    IN PFSCE_LOG_INFO pfLogCallback,
    IN INT ErrLevel,
    IN DWORD ErrCode,
    IN PWSTR Mes
    );

SCESTATUS
SmbsvcpWriteError2(
    IN PFSCE_LOG_INFO pfLogCallback,
    IN INT ErrLevel,
    IN DWORD ErrCode,
    IN UINT nId,
    ...
    );

SCESTATUS
SmbsvcpConfigureValue(
    IN PCWSTR RegKey,
    IN PCWSTR ValueName,
    IN DWORD  Value
    );

SCESTATUS
SmbsvcpQueryShareList(
    OUT PSMBSVC_SHARES *pShareList,
    OUT PDWORD ShareCount
    );

SCESTATUS
SmbsvcpAnalyzeValue(
    IN PCWSTR RegKey,
    IN PCWSTR RegValueName,
    IN PCWSTR KeyName,
    IN DWORD ConfigValue,
    OUT PSCESVC_ANALYSIS_LINE pLineInfo,
    IN OUT PDWORD pCount
    );

DWORD
SmbsvcpConvertStringToMultiSz(
    IN PWSTR theStr,
    IN DWORD theLen,
    OUT PBYTE *outValue,
    OUT PDWORD outLen
    );

SCESTATUS
SmbsvcpAnalyzeMultiSzString(
   IN PCWSTR RegKey,
   IN PCWSTR RegValueName,
   IN PWSTR pConfigInfo,
   IN DWORD InfoLength,
   OUT PSCESVC_ANALYSIS_LINE pLineInfo,
   IN OUT PDWORD pCount
   );

DWORD
SmbsvcpChangeMultiSzToString(
    IN PWSTR Value
    );

DWORD
SmbsvcpCompareMultiSzString(
    IN PWSTR pConfigInfo,
    IN PWSTR Value,
    OUT PDWORD pValueLen,
    OUT PBOOL pDiff
    );

DWORD
SmbsvcpCountComponents(
    IN PWSTR Value,
    OUT PDWORD ValueLen,
    OUT PDWORD Count
    );

SCESTATUS
SmbsvcpUpdateMultiSzString(
    IN PSCESVC_CALLBACK_INFO pSceCbInfo,
    IN SCESVC_CONFIGURATION_LINE NewLine,
    IN PSCESVC_CONFIGURATION_INFO pConfigInfo OPTIONAL,
    IN PSCESVC_ANALYSIS_INFO pAnaInfo OPTIONAL
    );

SCESTATUS
SmbsvcpUpdateShareValue(
    IN PSCESVC_CALLBACK_INFO pSceCbInfo,
    IN SCESVC_CONFIGURATION_LINE NewLine,
    IN PSCESVC_CONFIGURATION_INFO pConfigInfo OPTIONAL,
    IN PSCESVC_ANALYSIS_INFO pAnaInfo OPTIONAL
    );

SCESTATUS
SmbsvcpEqualSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSD1,
    IN PSECURITY_DESCRIPTOR pSD2,
    IN BOOL bExplicitOnly,
    OUT PBOOL pbEqual
    );

DWORD
SmbsvcEveryoneFullAccess(
    IN PACL pAcl,
    IN BOOL bExplicit,
    OUT PBOOL pbEqual
    );

DWORD
SmbsvcpCompareAcl(
    IN PACL pAcl1,
    IN PACL pAcl2,
    IN BOOL bExplicitOnly,
    OUT PBOOL pDifferent
    );

DWORD
SmbsvcpAnyExplicitAcl(
    IN PACL Acl,
    IN DWORD Processed,
    OUT PBOOL pExist
    );

BOOL
SmbsvcpEqualAce(
    IN ACE_HEADER *pAce1,
    IN ACE_HEADER *pAce2
    );

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Implementation of well-known interfaces
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SCESTATUS
WINAPI
SceSvcAttachmentConfig(
    IN PSCESVC_CALLBACK_INFO pSceCbInfo
    )
/*
Routine Description:


Arguments:

    pSceCbInfo - the callback info structure which contains the database handle,
                callback functions to query info, set info, and free info.
               All configuration information for SMB server is stored in the storage.

Return Value:

    SCESTATUS
*/
{
    if ( pSceCbInfo == NULL ||
         pSceCbInfo->sceHandle == NULL ||
         pSceCbInfo->pfQueryInfo == NULL ||
         pSceCbInfo->pfSetInfo == NULL ||
         pSceCbInfo->pfFreeInfo == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( !RtlGetNtProductType(&ProductType) ) {

        return(SmbsvcpDosErrorToSceStatus(GetLastError()));
    }

    SCESTATUS rc;
    SMBSVC_SEC_INFO  SmbInfo;
    PSMBSVC_SEC_INFO pSmbInfo=&SmbInfo;

    SmbsvcpResetInfo(&SmbInfo);

    SmbsvcpWriteError2(
             pSceCbInfo->pfLogInfo,
             SCE_LOG_LEVEL_DETAIL,
             0,
             SMBSVC_QUERY_INFO
             );

    rc = SmbsvcpGetInformation(
             pSceCbInfo,
             pSmbInfo
             );

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // configure the registry keys first
        //

        SmbsvcpWriteError2(
                pSceCbInfo->pfLogInfo,
                SCE_LOG_LEVEL_DETAIL,
                0,
                SMBSVC_CONFIGURE_CLIENT_START
                );

        SCESTATUS rc2;

        //
        // EnableSecuritySignature for client
        //
        rc2 = SmbsvcpConfigureValue(
                 SmbsvcRdrKey,
                 SmbsvcEnableSS,
                 pSmbInfo->EnableClientSecuritySignature
                 );
        if ( rc2 != SCESTATUS_SUCCESS ) {

            SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                              SCE_LOG_LEVEL_ERROR,
                              SmbsvcpSceStatusToDosError(rc2),
                              SMBSVC_ERROR_CONFIGURE,
                              SmbsvcEnableSS);

            if ( rc == SCESTATUS_SUCCESS &&
                 rc2 != SCESTATUS_PROFILE_NOT_FOUND ) {
                rc = rc2;
            }
        }
        //
        // RequireSecuritySignature for client
        //
        rc2 = SmbsvcpConfigureValue(
                 SmbsvcRdrKey,
                 SmbsvcRequireSS,
                 pSmbInfo->RequireClientSecuritySignature
                 );
        if ( rc2 != SCESTATUS_SUCCESS ) {

            SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                              SCE_LOG_LEVEL_ERROR,
                              SmbsvcpSceStatusToDosError(rc2),
                              SMBSVC_ERROR_CONFIGURE,
                              SmbsvcRequireSS);

            if ( rc == SCESTATUS_SUCCESS && rc2 != SCESTATUS_PROFILE_NOT_FOUND )
                rc = rc2;
        }
        //
        // EnablePlainTextPassword (client only)
        //
        rc2 = SmbsvcpConfigureValue(
                 SmbsvcRdrKey,
                 SmbsvcPlainPassword,
                 pSmbInfo->EnablePlainTextPassword
                 );
        if ( rc2 != SCESTATUS_SUCCESS ) {

            SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                              SCE_LOG_LEVEL_ERROR,
                              SmbsvcpSceStatusToDosError(rc2),
                              SMBSVC_ERROR_CONFIGURE,
                              SmbsvcPlainPassword);

            if ( rc == SCESTATUS_SUCCESS && rc2 != SCESTATUS_PROFILE_NOT_FOUND )
                rc = rc2;
        }

        //
        // RequireEnhancedChallengeResponse (client only)
        //
        rc2 = SmbsvcpConfigureValue(
                 SmbsvcRdrKey,
                 SmbsvcRequireECR,
                 pSmbInfo->RequireEnhancedChallengeResponse
                 );
        if ( rc2 != SCESTATUS_SUCCESS ) {

            SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                              SCE_LOG_LEVEL_ERROR,
                              SmbsvcpSceStatusToDosError(rc2),
                              SMBSVC_ERROR_CONFIGURE,
                              SmbsvcRequireECR);

            if ( rc == SCESTATUS_SUCCESS && rc2 != SCESTATUS_PROFILE_NOT_FOUND )
                rc = rc2;
        }
        //
        //  SendNTResponseOnly (client only)
        //
        rc2 = SmbsvcpConfigureValue(
                 SmbsvcRdrKey,
                 SmbsvcNTResponse,
                 pSmbInfo->SendNTResponseOnly
                 );
        if ( rc2 != SCESTATUS_SUCCESS ) {

            SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                              SCE_LOG_LEVEL_ERROR,
                              SmbsvcpSceStatusToDosError(rc2),
                              SMBSVC_ERROR_CONFIGURE,
                              SmbsvcNTResponse);

            if ( rc == SCESTATUS_SUCCESS && rc2 != SCESTATUS_PROFILE_NOT_FOUND )
                rc = rc2;
        }

        if ( SCESTATUS_SUCCESS == rc ) {

           SmbsvcpWriteError2(
                   pSceCbInfo->pfLogInfo,
                   SCE_LOG_LEVEL_DETAIL,
                   0,
                   SMBSVC_CONFIGURE_CLIENT_DONE
                   );
        }

        //
        // !!!!!!!! server settings !!!!!!!!!
        //
        SmbsvcpWriteError2(
                pSceCbInfo->pfLogInfo,
                SCE_LOG_LEVEL_DETAIL,
                0,
                SMBSVC_CONFIGURE_SERVER_START
                );

        SCESTATUS rc3 = rc;
        rc = SCESTATUS_SUCCESS;

        //
        // EnableSecuritySignature for server
        //
        rc2 = SmbsvcpConfigureValue(
                 SmbsvcServerKey,
                 SmbsvcEnableSS,
                 pSmbInfo->EnableServerSecuritySignature
                 );
        if ( rc2 != SCESTATUS_SUCCESS ) {

            SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                              SCE_LOG_LEVEL_ERROR,
                              SmbsvcpSceStatusToDosError(rc2),
                              SMBSVC_ERROR_CONFIGURE,
                              SmbsvcEnableSS);

            if ( rc == SCESTATUS_SUCCESS && rc2 != SCESTATUS_PROFILE_NOT_FOUND )
                rc = rc2;
        }

        //
        // RequireSecuritySignature for server
        //
        rc2 = SmbsvcpConfigureValue(
                 SmbsvcServerKey,
                 SmbsvcRequireSS,
                 pSmbInfo->RequireServerSecuritySignature
                 );
        if ( rc2 != SCESTATUS_SUCCESS ) {

            SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                              SCE_LOG_LEVEL_ERROR,
                              SmbsvcpSceStatusToDosError(rc2),
                              SMBSVC_ERROR_CONFIGURE,
                              SmbsvcRequireSS);

            if ( rc == SCESTATUS_SUCCESS && rc2 != SCESTATUS_PROFILE_NOT_FOUND )
                rc = rc2;
        }
        //
        // RestrictNullSessionAccess
        //
        rc2 = SmbsvcpConfigureValue(
                 SmbsvcServerKey,
                 SmbsvcRestrictNull,
                 pSmbInfo->RestrictNullSessionAccess
                 );
        if ( rc2 != SCESTATUS_SUCCESS ) {

            SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                              SCE_LOG_LEVEL_ERROR,
                              SmbsvcpSceStatusToDosError(rc2),
                              SMBSVC_ERROR_CONFIGURE,
                              SmbsvcRestrictNull);

            if ( rc == SCESTATUS_SUCCESS && rc2 != SCESTATUS_PROFILE_NOT_FOUND )
                rc = rc2;
        }

        //
        // AutoShareServer or AutoShareWks
        //
        PCWSTR AutoValueName;

        if ( ProductType == NtProductLanManNt ||
             ProductType == NtProductServer) {
            AutoValueName = SmbsvcAutoShareServer;
        } else {
            AutoValueName = SmbsvcAutoShareWks;
        }

        rc2 = SmbsvcpConfigureValue(
                 SmbsvcServerKey,
                 AutoValueName,
                 pSmbInfo->EnableAutoShare
                 );
        if ( rc2 != SCESTATUS_SUCCESS ) {

            SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                              SCE_LOG_LEVEL_ERROR,
                              SmbsvcpSceStatusToDosError(rc2),
                              SMBSVC_ERROR_CONFIGURE,
                              (PWSTR)AutoValueName);

            if ( rc == SCESTATUS_SUCCESS && rc2 != SCESTATUS_PROFILE_NOT_FOUND )
                rc = rc2;
        }

        //
        // EnableForcedLogOff
        //
        rc2 = SmbsvcpConfigureValue(
                 SmbsvcServerKey,
                 SmbsvcForcedLogOff,
                 pSmbInfo->EnableForcedLogOff
                 );
        if ( rc2 != SCESTATUS_SUCCESS ) {

            SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                              SCE_LOG_LEVEL_ERROR,
                              SmbsvcpSceStatusToDosError(rc2),
                              SMBSVC_ERROR_CONFIGURE,
                              SmbsvcForcedLogOff);

            if ( rc == SCESTATUS_SUCCESS && rc2 != SCESTATUS_PROFILE_NOT_FOUND )
                rc = rc2;
        }
        //
        // AutoDisconnectTime
        //
        rc2 = SmbsvcpConfigureValue(
                 SmbsvcServerKey,
                 SmbsvcAutoDisconnect,
                 pSmbInfo->AutoDisconnect
                 );
        if ( rc2 != SCESTATUS_SUCCESS ) {

            SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                              SCE_LOG_LEVEL_ERROR,
                              SmbsvcpSceStatusToDosError(rc2),
                              SMBSVC_ERROR_CONFIGURE,
                              SmbsvcAutoDisconnect);

            if ( rc == SCESTATUS_SUCCESS && rc2 != SCESTATUS_PROFILE_NOT_FOUND )
                rc = rc2;
        }

        //
        // configure Null Session Pipes and Shares
        //
        // buffer NullSessionPipes and NullSessionShares are already in MULTI_SZ format
        //
        DWORD Win32rc;
        PBYTE MultiSzValue=NULL;
        DWORD MultiSzLength=0;

        if ( pSmbInfo->LengthPipes != SMBSVC_NO_VALUE ) {

            Win32rc = SmbsvcpConvertStringToMultiSz(
                        pSmbInfo->NullSessionPipes,
                        pSmbInfo->LengthPipes,
                        &MultiSzValue,
                        &MultiSzLength
                        );
            if ( Win32rc == ERROR_SUCCESS ) {

                Win32rc = SmbsvcpRegSetValue(
                            HKEY_LOCAL_MACHINE,
                            SmbsvcServerKey,
                            L"NullSessionPipes",
                            REG_MULTI_SZ,
                            MultiSzValue,
                            MultiSzLength
                            );
            }

            if ( Win32rc != ERROR_SUCCESS ) {

                SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                                  SCE_LOG_LEVEL_ERROR,
                                  Win32rc,
                                  SMBSVC_ERROR_CONFIGURE,
                                  L"NullSessionPipes");

                if ( rc == SCESTATUS_SUCCESS && Win32rc != ERROR_FILE_NOT_FOUND )
                    rc = SmbsvcpDosErrorToSceStatus(Win32rc);;
            }
        }

        if ( pSmbInfo->LengthShares != SMBSVC_NO_VALUE ) {

            Win32rc = SmbsvcpConvertStringToMultiSz(
                        pSmbInfo->NullSessionShares,
                        pSmbInfo->LengthShares,
                        &MultiSzValue,
                        &MultiSzLength
                        );
            if ( Win32rc == ERROR_SUCCESS ) {

                Win32rc = SmbsvcpRegSetValue(
                                HKEY_LOCAL_MACHINE,
                                SmbsvcServerKey,
                                L"NullSessionShares",
                                REG_MULTI_SZ,
                                (PBYTE)(pSmbInfo->NullSessionShares),
                                pSmbInfo->LengthShares
                                );
            }

            if ( Win32rc != ERROR_SUCCESS ) {

                SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                                  SCE_LOG_LEVEL_ERROR,
                                  Win32rc,
                                  SMBSVC_ERROR_CONFIGURE,
                                  L"NullSessionShares");

                if ( rc == SCESTATUS_SUCCESS && Win32rc != ERROR_FILE_NOT_FOUND )
                    rc = SmbsvcpDosErrorToSceStatus(Win32rc);;
            }

        }

        //
        // configure security on existing shares
        //
        SHARE_INFO_1501 ShareInfo;
        PSMBSVC_SHARES pTemp;

        for ( pTemp=pSmbInfo->pShares; pTemp != NULL;
              pTemp = pTemp->Next) {

            ShareInfo.shi1501_reserved = 0;
            ShareInfo.shi1501_security_descriptor = pTemp->pShareSD;

            Win32rc = NetShareSetInfo (
                        NULL,
                        pTemp->ShareName,
                        1501,
                        (LPBYTE)&ShareInfo,
                        NULL
                        );


            if ( Win32rc != ERROR_SUCCESS ) {

                SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                                  SCE_LOG_LEVEL_ERROR,
                                  Win32rc,
                                  SMBSVC_ERROR_CONFIGURE,
                                  pTemp->ShareName);

                if ( rc == SCESTATUS_SUCCESS )
                    rc = SmbsvcpDosErrorToSceStatus(Win32rc);;
            }
            //
            // continue to configure even if error occurs
            //
        }

        if ( SCESTATUS_SUCCESS == rc ) {

           SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                             SCE_LOG_LEVEL_DETAIL,
                             0,
                             SMBSVC_CONFIGURE_SERVER_DONE
                             );
           rc = rc3;  // saved status for client configuration

        }
        //
        // free memory
        //
        SmbsvcpFree(pSmbInfo);
    }

    return(rc);

}



SCESTATUS
WINAPI
SceSvcAttachmentAnalyze(
    IN PSCESVC_CALLBACK_INFO pSceCbInfo
    )
/*
Routine Description:


Arguments:

    pSceCbInfo - the callback info structure which contains a opaque database handle
                 and callback function pointers to query info, set info, and free info.
               Only mismatched info for SMB server is stored in the storage.

Return Value:

    SCESTATUS
*/
{
    if ( pSceCbInfo == NULL ||
         pSceCbInfo->sceHandle == NULL ||
         pSceCbInfo->pfQueryInfo == NULL ||
         pSceCbInfo->pfSetInfo == NULL ||
         pSceCbInfo->pfFreeInfo == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( !RtlGetNtProductType(&ProductType) )
        return(SmbsvcpDosErrorToSceStatus(GetLastError()));

    SCESTATUS rc, Saverc;
    SMBSVC_SEC_INFO  SmbInfo;
    PSMBSVC_SEC_INFO pSmbInfo=&SmbInfo;

    PWSTR ErrPoint=NULL;
    WCHAR Errbuf[64];

    //
    // reset the Smb buffer
    //
    SmbsvcpResetInfo(&SmbInfo);


    SmbsvcpWriteError2(
             pSceCbInfo->pfLogInfo,
             SCE_LOG_LEVEL_DETAIL,
             0,
             SMBSVC_QUERY_INFO
             );

    //
    // get configuration information
    //
    rc = SmbsvcpGetInformation(
             pSceCbInfo,
             pSmbInfo
             );

    if ( rc == SCESTATUS_SUCCESS ) {

//         rc == SCESTATUS_RECORD_NOT_FOUND ) {
        //
        // analyze share information to a buffer
        //
        PSMBSVC_SHARES pShares=NULL;
        DWORD ShareCount=0;
        //
        // get all shares
        //
        rc = SmbsvcpQueryShareList(&pShares, &ShareCount);

        if ( rc == SCESTATUS_SUCCESS ) {

            //
            // Allocate PSCESVC_ANALYSIS_INFO buffer
            //
            PSCESVC_ANALYSIS_INFO pAnaInfo;
            DWORD nCount;

            pAnaInfo = (PSCESVC_ANALYSIS_INFO)LocalAlloc(LMEM_FIXED, sizeof(SCESVC_ANALYSIS_INFO));

            if ( pAnaInfo != NULL ) {

                pAnaInfo->Count = 0;
                pAnaInfo->Lines = (PSCESVC_ANALYSIS_LINE)LocalAlloc(LMEM_ZEROINIT,
                                        (NUM_COMP+ShareCount)*sizeof(SCESVC_ANALYSIS_LINE));

                if ( pAnaInfo->Lines != NULL ) {

                    nCount = 0;

                    SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                                      SCE_LOG_LEVEL_DETAIL,
                                      0,
                                      SMBSVC_ANALYZE_CLIENT_START
                                      );

                     //
                     // EnableSecuritySignature for client
                     //
                     rc = SmbsvcpAnalyzeValue(
                              SmbsvcRdrKey,
                              SmbsvcEnableSS,
                              L"EnableClientSecuritySignature",
                              pSmbInfo->EnableClientSecuritySignature,
                              &(pAnaInfo->Lines[nCount]),
                              &nCount
                              );
                     ErrPoint = SmbsvcEnableSS;

                    if ( rc == SCESTATUS_SUCCESS || rc == SCESTATUS_PROFILE_NOT_FOUND) {
                        //
                        // RequireSecuritySignature for client
                        //
                        rc = SmbsvcpAnalyzeValue(
                                 SmbsvcRdrKey,
                                 SmbsvcRequireSS,
                                 L"RequireClientSecuritySignature",
                                 pSmbInfo->RequireClientSecuritySignature,
                                 &(pAnaInfo->Lines[nCount]),
                                 &nCount
                                 );
                        ErrPoint = SmbsvcRequireSS;
                    }
                    if ( rc == SCESTATUS_SUCCESS || rc == SCESTATUS_PROFILE_NOT_FOUND) {
                        //
                        // EnablePlainTextPassword (client only)
                        //
                        rc = SmbsvcpAnalyzeValue(
                                 SmbsvcRdrKey,
                                 SmbsvcPlainPassword,
                                 L"EnablePlainTextPassword",
                                 pSmbInfo->EnablePlainTextPassword,
                                 &(pAnaInfo->Lines[nCount]),
                                 &nCount
                                 );
                        ErrPoint = SmbsvcPlainPassword;
                    }
                    if ( rc == SCESTATUS_SUCCESS || rc == SCESTATUS_PROFILE_NOT_FOUND) {
                        //
                        // RequireEnhancedChallengeResponse
                        //
                        rc = SmbsvcpAnalyzeValue(
                                 SmbsvcRdrKey,
                                 SmbsvcRequireECR,
                                 L"RequireEnhancedChallengeResponse",
                                 pSmbInfo->RequireEnhancedChallengeResponse,
                                 &(pAnaInfo->Lines[nCount]),
                                 &nCount
                                 );
                        ErrPoint = SmbsvcRequireECR;
                    }
                    if ( rc == SCESTATUS_SUCCESS || rc == SCESTATUS_PROFILE_NOT_FOUND) {
                        //
                        // SendNTResponseOnly
                        //
                        rc = SmbsvcpAnalyzeValue(
                                 SmbsvcRdrKey,
                                 SmbsvcNTResponse,
                                 L"SendNTResponseOnly",
                                 pSmbInfo->SendNTResponseOnly,
                                 &(pAnaInfo->Lines[nCount]),
                                 &nCount
                                 );
                        ErrPoint = SmbsvcNTResponse;
                    }

                    if ( rc == SCESTATUS_PROFILE_NOT_FOUND ) {
                        rc = SCESTATUS_SUCCESS;
                    }

                    if ( rc == SCESTATUS_SUCCESS ) {

                        SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                                          SCE_LOG_LEVEL_DETAIL,
                                          0,
                                          SMBSVC_ANALYZE_CLIENT_DONE
                                          );
                    } else {

                        SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                                          SCE_LOG_LEVEL_ERROR,
                                          SmbsvcpSceStatusToDosError(rc),
                                          SMBSVC_ERROR_ANALYZE,
                                          ErrPoint
                                          );
                    }

                    Saverc = rc;

                    SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                                      SCE_LOG_LEVEL_DETAIL,
                                      0,
                                      SMBSVC_ANALYZE_SERVER_START
                                      );

                    //
                    // EnableSecuritySignature for server
                    //
                    rc = SmbsvcpAnalyzeValue(
                             SmbsvcServerKey,
                             SmbsvcEnableSS,
                             L"EnableServerSecuritySignature",
                             pSmbInfo->EnableServerSecuritySignature,
                             &(pAnaInfo->Lines[nCount]),
                             &nCount
                             );
                    ErrPoint = SmbsvcEnableSS;

                    if ( rc == SCESTATUS_SUCCESS || rc == SCESTATUS_PROFILE_NOT_FOUND) {
                        //
                        // RequireSecuritySignature for server
                        //
                        rc = SmbsvcpAnalyzeValue(
                                 SmbsvcServerKey,
                                 SmbsvcRequireSS,
                                 L"RequireServerSecuritySignature",
                                 pSmbInfo->RequireServerSecuritySignature,
                                 &(pAnaInfo->Lines[nCount]),
                                 &nCount
                                 );
                        ErrPoint = SmbsvcRequireSS;
                    }

                    if ( rc == SCESTATUS_SUCCESS || rc == SCESTATUS_PROFILE_NOT_FOUND) {
                        //
                        // RestrictNullSessionAccess
                        //
                        rc = SmbsvcpAnalyzeValue(
                                 SmbsvcServerKey,
                                 SmbsvcRestrictNull,
                                 L"RestrictNullSessionAccess",
                                 pSmbInfo->RestrictNullSessionAccess,
                                 &(pAnaInfo->Lines[nCount]),
                                 &nCount
                                 );
                        ErrPoint = SmbsvcRestrictNull;
                    }
                    if ( rc == SCESTATUS_SUCCESS || rc == SCESTATUS_PROFILE_NOT_FOUND) {
                        //
                        // AutoShareServer or AutoShareWks
                        //

                        PCWSTR AutoValueName;

                        if ( ProductType == NtProductLanManNt ||
                             ProductType == NtProductServer ) {
                            AutoValueName = SmbsvcAutoShareServer;
                        } else {
                            AutoValueName = SmbsvcAutoShareWks;
                        }

                        rc = SmbsvcpAnalyzeValue(
                                 SmbsvcServerKey,
                                 AutoValueName,
                                 L"EnableAutoShare",
                                 pSmbInfo->EnableAutoShare,
                                 &(pAnaInfo->Lines[nCount]),
                                 &nCount
                                 );
                        ErrPoint = (PWSTR)AutoValueName;
                    }
                    if ( rc == SCESTATUS_SUCCESS || rc == SCESTATUS_PROFILE_NOT_FOUND) {
                        //
                        // EnableForcedLogOff
                        //
                        rc = SmbsvcpAnalyzeValue(
                                 SmbsvcServerKey,
                                 SmbsvcForcedLogOff,
                                 L"EnableForcedLogOff",
                                 pSmbInfo->EnableForcedLogOff,
                                 &(pAnaInfo->Lines[nCount]),
                                 &nCount
                                 );
                        ErrPoint = SmbsvcForcedLogOff;
                    }
                    if ( rc == SCESTATUS_SUCCESS || rc == SCESTATUS_PROFILE_NOT_FOUND) {
                        //
                        // AutoDisconnectTime
                        //
                        rc = SmbsvcpAnalyzeValue(
                                 SmbsvcServerKey,
                                 SmbsvcAutoDisconnect,
                                 L"AutoDisconnect",
                                 pSmbInfo->AutoDisconnect,
                                 &(pAnaInfo->Lines[nCount]),
                                 &nCount
                                 );
                        ErrPoint = SmbsvcAutoDisconnect;
                    }

                    if ( rc == SCESTATUS_PROFILE_NOT_FOUND ) {
                        //
                        // the key does not exist
                        //
                        rc = SCESTATUS_SUCCESS;

                    }


                    if ( rc == SCESTATUS_SUCCESS ) {
                        //
                        // analyze Null Session Pipes and Shares
                        //
                        rc = SmbsvcpAnalyzeMultiSzString(
                                        SmbsvcServerKey,
                                        L"NullSessionPipes",
                                        pSmbInfo->NullSessionPipes,
                                        pSmbInfo->LengthPipes,
                                        &(pAnaInfo->Lines[nCount]),
                                        &nCount
                                        );
                        wcscpy(Errbuf, L"NullSessionPipes");
                        ErrPoint = Errbuf;
                        if ( rc == SCESTATUS_SUCCESS ) {

                            rc = SmbsvcpAnalyzeMultiSzString(
                                            SmbsvcServerKey,
                                            L"NullSessionShares",
                                            pSmbInfo->NullSessionShares,
                                            pSmbInfo->LengthShares,
                                            &(pAnaInfo->Lines[nCount]),
                                            &nCount
                                            );
                            wcscpy(Errbuf, L"NullSessionShares");
                            ErrPoint = Errbuf;
                        }
                    }
                    //
                    // analyze existing shares
                    //
                    if ( rc == SCESTATUS_SUCCESS ) {

                        PSMBSVC_SHARES pTemp, pConfigShare;
                        //
                        // process each share
                        //
                        for ( pTemp=pShares; pTemp != NULL;
                              pTemp = pTemp->Next) {
                            //
                            // Compare with configuration data
                            //
                            for ( pConfigShare=pSmbInfo->pShares;
                                  pConfigShare != NULL; pConfigShare = pConfigShare->Next ) {

                                if ( _wcsicmp(pTemp->ShareName, pConfigShare->ShareName) == 0 ) {
                                    //
                                    // find the share in configuation data, compare security descriptor
                                    //
                                    break;
                                }
                            }

                            BOOL bEqual = FALSE;
                            DWORD Status;

                            if ( pConfigShare != NULL ) {

                                rc = SmbsvcpEqualSecurityDescriptor(
                                            pTemp->pShareSD,
                                            pConfigShare->pShareSD,
                                            FALSE,
                                            &bEqual
                                            );
                                wcscpy(Errbuf, pTemp->ShareName);
                                ErrPoint = Errbuf;
                                Status = SMBSVC_STATUS_MISMATCH;

                            } else
                                Status = SMBSVC_STATUS_NOT_CONFIGURED;

                            if ( rc == SCESTATUS_SUCCESS && !bEqual ) {
                                //
                                // different, save this share
                                //
                               if ( pSmbInfo->pShares == NULL ) {

                                   SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                                                      SCE_LOG_LEVEL_DETAIL,
                                                      0,
                                                      SMBSVC_NOT_CONFIGURED,
                                                      pTemp->ShareName
                                                      );
                               } else {

                                  SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                                                     SCE_LOG_LEVEL_DETAIL,
                                                     0,
                                                     SMBSVC_MISMATCH,
                                                     pTemp->ShareName
                                                     );
                               }

                                PWSTR TextSD=NULL;
                                DWORD SDsize=0;

                                if ( pTemp->pShareSD != NULL ) {
#if defined(_NT4BACK_PORT)
                                    rc = SceSvcConvertSDToText(
                                                   pTemp->pShareSD,
                                                   DACL_SECURITY_INFORMATION,
                                                   &TextSD,
                                                   &SDsize
                                                   );
                                    rc = SmbsvcpDosErrorToSceStatus(rc);

#else
                                    if ( !ConvertSecurityDescriptorToStringSecurityDescriptor(
                                                    pTemp->pShareSD,
                                                    SDDL_REVISION,
                                                    DACL_SECURITY_INFORMATION,
                                                    &TextSD,
                                                    &SDsize
                                                    ) ) {
                                        rc = SmbsvcpDosErrorToSceStatus(GetLastError());
                                    } else {
                                        rc = SCESTATUS_SUCCESS;

                                    }
#endif
                                    wcscpy(Errbuf, pTemp->ShareName);
                                    ErrPoint = Errbuf;
                                }

                                PWSTR Value;

                                Value = (PWSTR)LocalAlloc(LMEM_FIXED, (SDsize+9)*sizeof(WCHAR));
                                if ( Value != NULL ) {

                                    if ( TextSD != NULL )
                                        swprintf(Value, L"Share,%1d,%s", Status, TextSD);
                                    else
                                        swprintf(Value, L"Share,%1d,", Status);

                                    Value[SDsize+8] = L'\0';

                                    pAnaInfo->Lines[nCount].Key = pTemp->ShareName;
                                    pAnaInfo->Lines[nCount].Value = (PBYTE)Value;
                                    pAnaInfo->Lines[nCount].ValueLen = (SDsize+8)*sizeof(WCHAR);
                                    pTemp->ShareName = NULL;

                                    nCount++;

                                } else {
                                    wcscpy(Errbuf, pTemp->ShareName);
                                    ErrPoint = Errbuf;
                                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                }

                                if ( TextSD != NULL )
                                    LocalFree(TextSD);
                                TextSD = NULL;

                            } else {

                                  SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                                                     SCE_LOG_LEVEL_DETAIL,
                                                     0,
                                                     SMBSVC_MATCH,
                                                     pTemp->ShareName
                                                     );
                            }

                            if ( rc != SCESTATUS_SUCCESS ) {
                                break;
                            }
                        }
                    }

                    if ( rc == SCESTATUS_SUCCESS ) {

                        SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                                      SCE_LOG_LEVEL_DETAIL,
                                      0,
                                      SMBSVC_ANALYZE_SERVER_DONE
                                      );
                        rc = Saverc;  // saved status for client analysis

                    } else {

                        SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                                          SCE_LOG_LEVEL_ERROR,
                                          SmbsvcpSceStatusToDosError(rc),
                                          SMBSVC_ERROR_ANALYZE,
                                          ErrPoint
                                          );
                    }

                    //
                    // Now save the information to the database
                    //
                    if ( rc == SCESTATUS_SUCCESS ) {

                       SmbsvcpWriteError2(
                                pSceCbInfo->pfLogInfo,
                                SCE_LOG_LEVEL_DETAIL,
                                0,
                                SMBSVC_SAVE_INFO
                                );

                        pAnaInfo->Count = nCount;

                        __try {
                            rc = (*(pSceCbInfo->pfSetInfo))(
                                        pSceCbInfo->sceHandle,
                                        SceSvcAnalysisInfo,
                                        NULL,
                                        FALSE,
                                        (PVOID)pAnaInfo
                                        );
                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                        }

                        if ( SCESTATUS_SUCCESS != rc ) {

                            SmbsvcpWriteError2(
                                 pSceCbInfo->pfLogInfo,
                                 SCE_LOG_LEVEL_ERROR,
                                 SmbsvcpSceStatusToDosError(rc),
                                 SMBSVC_ERROR_SAVE_INFO
                                 );
                        }
                    }

                    //
                    // free pAnaInfo
                    //
                    __try {
                        (*(pSceCbInfo->pfFreeInfo))((PVOID)pAnaInfo);

                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        //
                        // BUGBUG: buffer is not freed ??
                        //
                    }

                } else {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    LocalFree(pAnaInfo);
                }

            } else
                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

            SmbsvcpFreeShareList(pShares);

        } else {

           SmbsvcpWriteError2(
                    pSceCbInfo->pfLogInfo,
                    SCE_LOG_LEVEL_ERROR,
                    SmbsvcpSceStatusToDosError(rc),
                    SMBSVC_ERROR_ENUM_SHARE
                    );
        }

        //
        // free memory
        //
        SmbsvcpFree(pSmbInfo);
    }

    return(rc);
}


SCESTATUS
WINAPI
SceSvcAttachmentUpdate(
    IN PSCESVC_CALLBACK_INFO pSceCbInfo,
    IN SCESVC_CONFIGURATION_INFO *ServiceInfo
    )
/*
Routine Description:


Arguments:

    pSceCbInfo - the callback handle and function pointers to SCE.

    ServiceInfo - The update configuration information for SMB server to process.

Return Value:

    SCESTATUS
*/
{
    if ( pSceCbInfo == NULL ||
         pSceCbInfo->sceHandle == NULL ||
         pSceCbInfo->pfQueryInfo == NULL ||
         pSceCbInfo->pfSetInfo == NULL ||
         pSceCbInfo->pfFreeInfo == NULL ||
         ServiceInfo == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;

    PSCESVC_CONFIGURATION_INFO pConfigInfo=NULL;
    SCE_ENUMERATION_CONTEXT EnumHandle;

    PSCESVC_ANALYSIS_INFO pAnaInfo=NULL;

    //
    // prepare two buffers for update
    //
    SCESVC_ANALYSIS_INFO UpdtAnaInfo;
    SCESVC_ANALYSIS_LINE UpdtAnaLine;

    SCESVC_CONFIGURATION_INFO UpdtConfigInfo;
    SCESVC_CONFIGURATION_LINE UpdtConfigLine;

    UpdtAnaInfo.Count = 1;
    UpdtAnaInfo.Lines = &UpdtAnaLine;

    UpdtConfigInfo.Count = 1;
    UpdtConfigInfo.Lines = &UpdtConfigLine;

    //
    // process each line
    //
    for ( DWORD i=0; i<ServiceInfo->Count; i++ ) {


       SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                          SCE_LOG_LEVEL_DETAIL,
                          0,
                          SMBSVC_UPDATE_INFO,
                          ServiceInfo->Lines[i].Key
                          );
        //
        // query the configuration setting
        //
        EnumHandle = 0;

        __try {
            rc = (*(pSceCbInfo->pfQueryInfo))(
                    pSceCbInfo->sceHandle,
                    SceSvcConfigurationInfo,
                    ServiceInfo->Lines[i].Key,
                    TRUE,
                    (PVOID *)&pConfigInfo,
                    &EnumHandle
                    );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rc = SCESTATUS_SERVICE_NOT_SUPPORT;
        }

        if ( rc == SCESTATUS_SUCCESS || rc == SCESTATUS_RECORD_NOT_FOUND ) {

//            if ( ServiceInfo->Lines[i].Value == NULL ) {
            if ( ServiceInfo->Lines[i].ValueLen == SMBSVC_NO_VALUE ) {

                //
                // delete is requested
                //
                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // delete the configuration, but make sure analysis is ok
                    //
                    EnumHandle = 0;

                    __try {
                        rc = (*(pSceCbInfo->pfQueryInfo))(
                                pSceCbInfo->sceHandle,
                                SceSvcAnalysisInfo,
                                ServiceInfo->Lines[i].Key,
                                TRUE,
                                (PVOID *)&pAnaInfo,
                                &EnumHandle
                                );

                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                    }

                    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                        //
                        // analysis info does not exist, matched.
                        // should save configuration info as analysis
                        //
                        UpdtAnaLine.Key = ServiceInfo->Lines[i].Key;
                        UpdtAnaLine.Value = (PBYTE)(pConfigInfo->Lines[0].Value);
                        UpdtAnaLine.ValueLen = pConfigInfo->Lines[0].ValueLen;

                        if ( pConfigInfo->Lines[0].ValueLen > 14 &&
                             pConfigInfo->Lines[0].Value != NULL &&
                             _wcsnicmp(L"Share,", pConfigInfo->Lines[0].Value, 6) == 0 ) {
                            //
                            // this is a share, needs to update status
                            //
                            *(pConfigInfo->Lines[0].Value+6) = L'2';
                        }

                        __try {
                            rc = (*(pSceCbInfo->pfSetInfo))(
                                    pSceCbInfo->sceHandle,
                                    SceSvcAnalysisInfo,
                                    NULL,
                                    TRUE,
                                    (PVOID)&UpdtAnaInfo
                                    );

                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                        }
                    }
                    if ( rc == SCESTATUS_SUCCESS ) {
                        //
                        // delete the configuration info
                        //
                        __try {
                            rc = (*(pSceCbInfo->pfSetInfo))(
                                    pSceCbInfo->sceHandle,
                                    SceSvcConfigurationInfo,
                                    ServiceInfo->Lines[i].Key,
                                    TRUE,
                                    NULL
                                    );
                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                        }
                    }

                } // if configuration is not found, just continue

            } else {

                if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    //
                    // no configuration setting for this one,
                    // either a new added share, or other configuration settings.
                    // BUGBUG: need to validate the key for other settings.
                    //
                    // if not valid, break out here
                }
                //
                // query the analysis setting
                //
                EnumHandle = 0;

                __try {
                    rc = (*(pSceCbInfo->pfQueryInfo))(
                            pSceCbInfo->sceHandle,
                            SceSvcAnalysisInfo,
                            ServiceInfo->Lines[i].Key,
                            TRUE,
                            (PVOID *)&pAnaInfo,
                            &EnumHandle
                            );

                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                }

                if ( rc == SCESTATUS_SUCCESS || rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    //
                    // mismatch is found for this one, or a matched item
                    //
                    if ( _wcsicmp(L"NullSessionShares", ServiceInfo->Lines[i].Key ) == 0 ||
                         _wcsicmp(L"NullSessionPipes", ServiceInfo->Lines[i].Key ) == 0 ) {

                        rc = SmbsvcpUpdateMultiSzString(
                                                  pSceCbInfo,
                                                  ServiceInfo->Lines[i],
                                                  pConfigInfo,
                                                  pAnaInfo
                                                  );
                    } else if ( ServiceInfo->Lines[i].ValueLen > 14 &&
                                ServiceInfo->Lines[i].Value != NULL &&
                                _wcsnicmp(L"Share,", ServiceInfo->Lines[i].Value, 6) == 0 ) {
                        //
                        // shares
                        //
                        rc = SmbsvcpUpdateShareValue(pSceCbInfo,
                                                     ServiceInfo->Lines[i],
                                                     pConfigInfo,
                                                     pAnaInfo
                                                     );
                    } else {
                        //
                        // other BYTE or DWORD type fields
                        //

                        DWORD NewValue = SMBSVC_NO_VALUE;

                        if ( swscanf(ServiceInfo->Lines[i].Value, L"%d", &NewValue) != EOF ) {

                            DWORD ConfigValue = SMBSVC_NO_VALUE;
                            DWORD AnaValue = SMBSVC_NO_VALUE;

                            if ( pConfigInfo != NULL && pConfigInfo->Lines != NULL )
                                swscanf(pConfigInfo->Lines[0].Value, L"%d", &ConfigValue);

                            if ( pAnaInfo != NULL && pAnaInfo->Lines != NULL ) {
                                swscanf((PWSTR)(pAnaInfo->Lines[0].Value), L"%d", &AnaValue);
                            }

                            if ( AnaValue != SMBSVC_NO_VALUE ) {
                                //
                                // old status is mismatch for this item
                                //
                                if ( NewValue == AnaValue ) {
                                    //
                                    // now it is matched, delete the analysis entry
                                    //

                                    SmbsvcpWriteError(pSceCbInfo->pfLogInfo,
                                                    SCE_LOG_LEVEL_DEBUG,
                                                    0,
                                                    L"mismatch->match"
                                                    );
                                    __try {
                                        rc = (*(pSceCbInfo->pfSetInfo))(
                                                pSceCbInfo->sceHandle,
                                                SceSvcAnalysisInfo,
                                                ServiceInfo->Lines[i].Key,
                                                TRUE,
                                                NULL
                                                );

                                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                                        rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                                    }
                                }
                                if ( NewValue != ConfigValue ) {
                                    //
                                    // update the configuration setting
                                    //
                                    UpdtConfigLine.Key = ServiceInfo->Lines[i].Key;
                                    UpdtConfigLine.Value = ServiceInfo->Lines[i].Value;
                                    UpdtConfigLine.ValueLen = ServiceInfo->Lines[i].ValueLen;

                                    __try {
                                        rc = (*(pSceCbInfo->pfSetInfo))(
                                                pSceCbInfo->sceHandle,
                                                SceSvcConfigurationInfo,
                                                NULL,
                                                TRUE,
                                                (PVOID)&UpdtConfigInfo
                                                );

                                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                                        rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                                    }
                                }
                            } else {
                                //
                                // old status is match, or a new added configuration key
                                //
                                if ( NewValue != ConfigValue ) {

                                    SmbsvcpWriteError(pSceCbInfo->pfLogInfo,
                                                     SCE_LOG_LEVEL_DEBUG,
                                                     0,
                                                     L"match->mismatch"
                                                     );
                                    //
                                    // mismatch should be raised with ConfigValue
                                    //
                                    UpdtAnaLine.Key = ServiceInfo->Lines[i].Key;
                                    UpdtAnaLine.Value = ( pConfigInfo != NULL ) ? (PBYTE)(pConfigInfo->Lines[0].Value) : NULL ;
                                    UpdtAnaLine.ValueLen = ( pConfigInfo != NULL ) ? pConfigInfo->Lines[0].ValueLen : 0;

                                    __try {
                                        rc = (*(pSceCbInfo->pfSetInfo))(
                                                pSceCbInfo->sceHandle,
                                                SceSvcAnalysisInfo,
                                                NULL,
                                                TRUE,
                                                (PVOID)&UpdtAnaInfo
                                                );

                                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                                        rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                                    }

                                    if ( rc == SCESTATUS_SUCCESS ) {

                                        if ( NewValue == SMBSVC_NO_VALUE ) {

                                           SmbsvcpWriteError(pSceCbInfo->pfLogInfo,
                                                             SCE_LOG_LEVEL_DEBUG,
                                                             0,
                                                             L"delelte base setting"
                                                             );
                                            //
                                            // delete configuration setting
                                            //
                                            __try {
                                                rc = (*(pSceCbInfo->pfSetInfo))(
                                                        pSceCbInfo->sceHandle,
                                                        SceSvcConfigurationInfo,
                                                        ServiceInfo->Lines[i].Key,
                                                        TRUE,
                                                        NULL
                                                        );

                                            } __except (EXCEPTION_EXECUTE_HANDLER) {
                                                rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                                            }
                                        } else {
                                            //
                                            // update configuration setting with NewValue
                                            //
                                            UpdtConfigLine.Key = ServiceInfo->Lines[i].Key;
                                            UpdtConfigLine.Value = ServiceInfo->Lines[i].Value;
                                            UpdtConfigLine.ValueLen = ServiceInfo->Lines[i].ValueLen;

                                            __try {
                                                rc = (*(pSceCbInfo->pfSetInfo))(
                                                        pSceCbInfo->sceHandle,
                                                        SceSvcConfigurationInfo,
                                                        NULL,
                                                        TRUE,
                                                        (PVOID)&UpdtConfigInfo
                                                        );

                                            } __except (EXCEPTION_EXECUTE_HANDLER) {
                                                rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                                            }
                                        }
                                    }
                                }
                            }

                        } else
                            rc = SCESTATUS_INVALID_DATA;
                    }

                    if ( pAnaInfo != NULL ) {

                        __try {
                            (*(pSceCbInfo->pfFreeInfo))((PVOID)pAnaInfo);

                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                        }
                    }
                    pAnaInfo = NULL;

                }
            }

            if ( pConfigInfo != NULL ) {

                __try {
                    (*(pSceCbInfo->pfFreeInfo))((PVOID)pConfigInfo);
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                }
            }
            pConfigInfo = NULL;

        }

        if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
            rc = SCESTATUS_SUCCESS;
        }

        if ( rc != SCESTATUS_SUCCESS ) {
            break;
        }
    }

    return(rc);

}


SCESTATUS
SmbsvcpResetInfo(
    IN PSMBSVC_SEC_INFO pInfo
    )
/*
Routine Description:

    This routine resets or initializes the buffer. All BYTE and DWORD
    type fields are set to SMBSVC_NO_VALUE and all othe pointers are
    set to NULL

Arguments:

    pInfo - the buffer to reset.

Return Value:

    SCESTATUS
*/
{
    if ( pInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    pInfo->EnableClientSecuritySignature = SMBSVC_NO_VALUE;
    pInfo->RequireClientSecuritySignature = SMBSVC_NO_VALUE;
    pInfo->EnablePlainTextPassword = SMBSVC_NO_VALUE;
    pInfo->RequireEnhancedChallengeResponse = SMBSVC_NO_VALUE;
    pInfo->SendNTResponseOnly = SMBSVC_NO_VALUE;

    pInfo->EnableAutoShare = SMBSVC_NO_VALUE;
    pInfo->EnableServerSecuritySignature = SMBSVC_NO_VALUE;
    pInfo->RequireServerSecuritySignature = SMBSVC_NO_VALUE;
    pInfo->RestrictNullSessionAccess = SMBSVC_NO_VALUE;

    pInfo->EnableForcedLogOff = SMBSVC_NO_VALUE;
    pInfo->AutoDisconnect = SMBSVC_NO_VALUE;

    pInfo->NullSessionShares = NULL;
    pInfo->LengthShares = SMBSVC_NO_VALUE;

    pInfo->NullSessionPipes = NULL;
    pInfo->LengthPipes = SMBSVC_NO_VALUE;

    pInfo->pShares=NULL;

    return(SCESTATUS_SUCCESS);
}


SCESTATUS
SmbsvcpGetInformation(
    IN PSCESVC_CALLBACK_INFO pSceCbInfo,
    OUT PSMBSVC_SEC_INFO pSmbInfo
    )
/*
Routine Description:

    This routine queries information from the storage pointed by sceHandle.
    Infomration is loaded into each field in the buffer pSmbInfo. Type argument
    indicates configuration information or analysis information to query.

Arguments:

    pSceCbInfo - the callback info structure

    Type - SceSvcConfigurationInfo or SceSvcAnalysisInfo

    pSmbInfo - the buffer to hold information. Note, this buffer must be allocated
                before this call

Return Value:

    SCESTATUS
*/
{
    if ( pSceCbInfo == NULL ||
         pSceCbInfo->sceHandle == NULL ||
         pSceCbInfo->pfQueryInfo == NULL ||
        pSmbInfo == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;
    SCE_ENUMERATION_CONTEXT EnumHandle=0;
    PSCESVC_CONFIGURATION_INFO pConfigInfo=NULL;

    SMBSVC_KEY_LOOKUP LookupKeys[] = {
        {(PWSTR)TEXT("EnableForcedLogOff"),     offsetof(struct _SMBSVC_SEC_INFO_, EnableForcedLogOff),    'B'},
        {(PWSTR)TEXT("AutoDisconnect"), offsetof(struct _SMBSVC_SEC_INFO_, AutoDisconnect),'D'},
        {(PWSTR)TEXT("EnableAutoShare"),    offsetof(struct _SMBSVC_SEC_INFO_, EnableAutoShare),   'B'},
        {(PWSTR)TEXT("EnableServerSecuritySignature"),offsetof(struct _SMBSVC_SEC_INFO_, EnableServerSecuritySignature),'B'},
        {(PWSTR)TEXT("RequireServerSecuritySignature"),offsetof(struct _SMBSVC_SEC_INFO_, RequireServerSecuritySignature), 'B'},
        {(PWSTR)TEXT("RestrictNullSessionAccess"),     offsetof(struct _SMBSVC_SEC_INFO_, RestrictNullSessionAccess),    'B'},
        {(PWSTR)TEXT("EnableClientSecuritySignature"),offsetof(struct _SMBSVC_SEC_INFO_, EnableClientSecuritySignature),'B'},
        {(PWSTR)TEXT("RequireClientSecuritySignature"),offsetof(struct _SMBSVC_SEC_INFO_, RequireClientSecuritySignature), 'B'},
        {(PWSTR)TEXT("EnablePlainTextPassword"),     offsetof(struct _SMBSVC_SEC_INFO_, EnablePlainTextPassword),    'B'},
        {(PWSTR)TEXT("RequireEnhancedChallengeResponse"),offsetof(struct _SMBSVC_SEC_INFO_, RequireEnhancedChallengeResponse),'B'},
        {(PWSTR)TEXT("SendNTResponseOnly"),offsetof(struct _SMBSVC_SEC_INFO_, SendNTResponseOnly), 'B'},
        {(PWSTR)TEXT("NullSessionPipes"),      offsetof(struct _SMBSVC_SEC_INFO_, NullSessionPipes),    'M'},
        {(PWSTR)TEXT("NullSessionShares"),     offsetof(struct _SMBSVC_SEC_INFO_, NullSessionShares),    'M'}
        };

    DWORD cKeys = sizeof(LookupKeys) / sizeof(SMBSVC_KEY_LOOKUP);
    DWORD CountReturned;

    PSMBSVC_SHARES pShareList=NULL;

    //
    // read configuration information for smb server
    //
    do {

        CountReturned = 0;

        __try {
            rc = (*(pSceCbInfo->pfQueryInfo))(
                    pSceCbInfo->sceHandle,
                    SceSvcConfigurationInfo,
                    NULL,
                    FALSE,
                    (PVOID *)&pConfigInfo,
                    &EnumHandle
                    );

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rc = SCESTATUS_SERVICE_NOT_SUPPORT;
        }

        if ( rc == SCESTATUS_SUCCESS && pConfigInfo != NULL &&
             pConfigInfo->Count > 0 ) {
            //
            // got something
            //
            CountReturned = pConfigInfo->Count;

            DWORD i, j;
            PSECURITY_DESCRIPTOR pTempSD=NULL;
            DWORD KeyValue, ValueLen, k;
            PCHAR StrValue=NULL;

            for ( i=0; i<pConfigInfo->Count; i++ ) {

                if ( pConfigInfo->Lines[i].Key == NULL )
                    continue;

                for (j=0; j<cKeys; j++) {

                    if ( _wcsicmp( pConfigInfo->Lines[i].Key, LookupKeys[j].KeyString) == 0 ) {
                        //
                        // find the matched string
                        //
                        switch ( LookupKeys[j].BufferType ) {
                        case 'B':

                            if ( pConfigInfo->Lines[i].Value != NULL ) {
                                KeyValue = _wtoi(pConfigInfo->Lines[i].Value);
                                *((BYTE *)pSmbInfo+LookupKeys[j].Offset) = (BYTE)KeyValue;
                            }
                            break;

                        case 'D':

                            if ( pConfigInfo->Lines[i].Value != NULL ) {
                                KeyValue = _wtol(pConfigInfo->Lines[i].Value);
                                *((DWORD *)((BYTE *)pSmbInfo+LookupKeys[j].Offset)) = KeyValue;
                            }

                            break;

                        case 'M':
                            // comma separated strings,
                            ValueLen = pConfigInfo->Lines[i].ValueLen;

                            if ( pConfigInfo->Lines[i].Value != NULL ) {

                                StrValue = (PCHAR)LocalAlloc(LMEM_FIXED, ValueLen + 4 );

                                if ( StrValue != NULL ) {

                                    memcpy((PVOID)StrValue, (PVOID)(pConfigInfo->Lines[i].Value),
                                              ValueLen);
                                    //
                                    // terminate the buffer by two L'\0's
                                    //
                                    *((WCHAR *)(StrValue+ValueLen)) = L'\0';
                                    *((WCHAR *)(StrValue+ValueLen+2)) = L'\0';
/*
                                    //
                                    // replace ',' with '\0's
                                    //
                                    for ( k=0; k<ValueLen; k++ ) {
                                        if ( StrValue[k] == ',' ) {
                                            StrValue[k] = '\0';
                                        }
                                    }
*/
                                    *((PVOID *)((BYTE *)pSmbInfo+LookupKeys[j].Offset)) = (PVOID)StrValue;
                                    StrValue = NULL;
                                    *((DWORD *)((BYTE *)pSmbInfo+LookupKeys[j].Offset+sizeof(PVOID))) = ValueLen;

                                } else {

                                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                                }
                            }
                            break;

                        default:
                            //
                            // unknown type, should not occur, ignore!!!
                            //
                            break;
                        }

                       break;
                    }
                }

                if ( j >= cKeys && rc == SCESTATUS_SUCCESS ) {
                    //
                    // did not find a match for pre-defined keywords
                    //
                    if ( pConfigInfo->Lines[i].Value != NULL && pConfigInfo->Lines[i].ValueLen > 14 &&
                         _wcsnicmp(L"Share,", pConfigInfo->Lines[i].Value, 6) == 0 ) {
                        //
                        // shares and security
                        //
                        if ( wcslen(pConfigInfo->Lines[i].Value) > 8) {

#if defined(_NT4BACK_PORT)
                            DWORD SDsize;
                            SECURITY_INFORMATION SeInfo;

                            rc = SceSvcConvertTextToSD(
                                           pConfigInfo->Lines[i].Value+8,
                                           &pTempSD,
                                           &SDsize,
                                           &SeInfo
                                           );

                            rc = SmbsvcpDosErrorToSceStatus(rc);
#else
                            if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
                                        (PCWSTR)(pConfigInfo->Lines[i].Value+8),
                                        SDDL_REVISION,
                                        &pTempSD,
                                        NULL
                                        ) ) {
                                rc = SmbsvcpDosErrorToSceStatus(GetLastError());
                            }
#endif
                        } else {
                            pTempSD = NULL;
                        }

                        DWORD Status = *(pConfigInfo->Lines[i].Value+6)-L'0';

                        if ( rc == SCESTATUS_SUCCESS ) {

                            rc = SmbsvcpAddAShareToList(&pShareList,
                                                        pConfigInfo->Lines[i].Key,
                                                        Status,
                                                        pTempSD
                                                        );

                            if ( rc != SCESTATUS_SUCCESS && pTempSD != NULL ) {
                                LocalFree(pTempSD);
                            }
                        }

                        if ( rc != SCESTATUS_SUCCESS && pSceCbInfo->pfLogInfo != NULL ) {

                            SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                                              SCE_LOG_LEVEL_ERROR,
                                              SmbsvcpSceStatusToDosError(rc),
                                              SMBSVC_ERROR_QUERY,
                                              pConfigInfo->Lines[i]
                                              );
                        }

                    } else if (pSceCbInfo->pfLogInfo != NULL ) {
                        //
                        // did not find a match
                        // warning for unknown data, but return success
                        //
                        SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                                         SCE_LOG_LEVEL_ERROR,
                                         0,
                                         SMBSVC_UNKNOWN_KEYWORD,
                                         pConfigInfo->Lines[i].Key
                                         );
                    }
                } else if ( rc != SCESTATUS_SUCCESS &&
                            pSceCbInfo->pfLogInfo != NULL ) {

                   SmbsvcpWriteError2(pSceCbInfo->pfLogInfo,
                                     SCE_LOG_LEVEL_ERROR,
                                     SmbsvcpSceStatusToDosError(rc),
                                     SMBSVC_ERROR_QUERY,
                                     pConfigInfo->Lines[i]
                                     );
                }

                if ( rc != SCESTATUS_SUCCESS )
                    break;

            }

            __try {

                (*(pSceCbInfo->pfFreeInfo))((PVOID)pConfigInfo);

            } __except (EXCEPTION_EXECUTE_HANDLER) {
            }

            pConfigInfo = NULL;
        }

    } while ( rc == SCESTATUS_SUCCESS && CountReturned >= SCESVC_ENUMERATION_MAX );  //0

    if ( pShareList != NULL ) {
        pSmbInfo->pShares = pShareList;
    }

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // free memory
        //
        SmbsvcpFree(pSmbInfo);

    }

    return(rc);

}


SCESTATUS
SmbsvcpAddAShareToList(
    OUT PSMBSVC_SHARES *pShareList,
    IN PWSTR ShareName,
    IN DWORD Status,
    IN PSECURITY_DESCRIPTOR pSD
    )
/*
Routine Description:

    This routine adds a share's information (Name, Security descriptor, and
    security information) to the list of shares. Memory allocated for the
    share node must be freed using LocalFree

Arguments:

    pShareList - The ouput list of shares

    ShareName - The name of the share

    pSD - The security descriptor of the share object

Return Value:

    SCESTATUS
*/
{
    if ( pShareList == NULL || ShareName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    PSMBSVC_SHARES pTempShare;

    pTempShare = (PSMBSVC_SHARES)LocalAlloc(LMEM_FIXED, sizeof(SMBSVC_SHARES));

    if ( pTempShare == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    } else {

        SCESTATUS rc=SCESTATUS_SUCCESS;

        pTempShare->ShareName = (PWSTR)LocalAlloc(LMEM_FIXED, (wcslen(ShareName)+1)*sizeof(WCHAR));

        if ( pTempShare->ShareName == NULL ) {
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

        } else {
            wcscpy(pTempShare->ShareName, ShareName);
            pTempShare->pShareSD = pSD;
            pTempShare->Status = Status;

            pTempShare->Next = *pShareList;
            *pShareList = pTempShare;
        }

        if ( rc != SCESTATUS_SUCCESS ) {
            LocalFree(pTempShare);
        }

        return(rc);
    }
}


SCESTATUS
SmbsvcpFree(
    IN PSMBSVC_SEC_INFO pSmbInfo
    )
/*
Routine Description:

    This routine frees the memory allocated for the components in the buffer.

Arguments:

    pSmbInfo - the buffer to free.

Return Value:

    SCESTATUS
*/
{
    if ( pSmbInfo == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( pSmbInfo->NullSessionPipes != NULL ) {
        LocalFree(pSmbInfo->NullSessionPipes);
    }

    if ( pSmbInfo->NullSessionShares != NULL ) {
        LocalFree(pSmbInfo->NullSessionShares);
    }

    SmbsvcpFreeShareList(pSmbInfo->pShares);

    return( SmbsvcpResetInfo( pSmbInfo ) );

}


SCESTATUS
SmbsvcpFreeShareList(
    PSMBSVC_SHARES pShares
    )
{
    PSMBSVC_SHARES pTemp, pTemp2;

    pTemp = pShares;
    while (pTemp != NULL ) {

        if ( pTemp->ShareName != NULL )
            LocalFree(pTemp->ShareName);

        if (pTemp->pShareSD != NULL )
            LocalFree(pTemp->pShareSD);

        pTemp2 = pTemp;
        pTemp = pTemp->Next;

        LocalFree(pTemp2);
    }

    return(SCESTATUS_SUCCESS);
}



SCESTATUS
SmbsvcpWriteError(
    IN PFSCE_LOG_INFO pfLogCallback,
    IN INT ErrLevel,
    IN DWORD ErrCode,
    IN PWSTR Mes
    )

{
    if ( Mes == NULL || pfLogCallback == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    SCESTATUS rc;

    __try {

        rc = (*pfLogCallback)(ErrLevel,
                              ErrCode,
                              Mes);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        rc = SCESTATUS_SERVICE_NOT_SUPPORT;
    }

    return(rc);

}

SCESTATUS
SmbsvcpWriteError2(
    IN PFSCE_LOG_INFO pfLogCallback,
    IN INT ErrLevel,
    IN DWORD ErrCode,
    IN UINT nId,
    ...
    )
{
    WCHAR              szTempString[256];
    TCHAR              buf[SMBSVC_BUF_LEN];
    va_list            args;

    if ( nId > 0 && pfLogCallback ) {

        szTempString[0] = L'\0';

        if ( MyModuleHandle != NULL ) {

            LoadString( MyModuleHandle,
                        nId,
                        szTempString,
                        256
                        );
        }

        //
        // check arguments
        //
        va_start( args, nId );
        vswprintf( buf, szTempString, args );
        va_end( args );

        return ( SmbsvcpWriteError(pfLogCallback,
                                   ErrLevel,
                                   ErrCode,
                                   buf) );
    }

    return(SCESTATUS_SUCCESS);

}



SCESTATUS
SmbsvcpConfigureValue(
    IN PCWSTR RegKey,
    IN PCWSTR ValueName,
    IN DWORD  Value
    )
{
    if ( Value == (DWORD)SMBSVC_NO_VALUE ||
         (BYTE)Value == (BYTE)SMBSVC_NO_VALUE ) {
        return(SCESTATUS_SUCCESS);
    }

    DWORD Win32rc;

    Win32rc = SmbsvcpRegSetIntValue(
                HKEY_LOCAL_MACHINE,
                (PWSTR)RegKey,
                (PWSTR)ValueName,
                Value
                );

    return(SmbsvcpDosErrorToSceStatus(Win32rc));
}


SCESTATUS
SmbsvcpQueryShareList(
    OUT PSMBSVC_SHARES *pShareList,
    OUT PDWORD ShareCount
    )
{
    if ( pShareList == NULL || ShareCount == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    LPSHARE_INFO_502 pShareInfo=NULL;
    DWORD EntriesRead, TotalEntries, ResumeHandle=0;

    SCESTATUS rc=SCESTATUS_SUCCESS;

    DWORD Win32rc;
    DWORD nCount=0;

    *ShareCount = 0;

    do {

        Win32rc = NetShareEnum (
                        NULL,
                        502,
                        (LPBYTE *)&pShareInfo,
                        0xFFFFFFFF,
                        &EntriesRead,
                        &TotalEntries,
                        &ResumeHandle
                        );

        if ( Win32rc == ERROR_SUCCESS ) {

            nCount += EntriesRead;

            for( DWORD i=0; i < EntriesRead; i++ ) {

                if( (pShareInfo + i)->shi502_type == STYPE_DISKTREE )
                {
                    PSECURITY_DESCRIPTOR pSD=NULL;

                    if ( (pShareInfo + i)->shi502_security_descriptor != NULL ) {

                        NTSTATUS status;
                        DWORD RequireLength=0;

                        status = RtlMakeSelfRelativeSD(
                                        (pShareInfo + i)->shi502_security_descriptor,
                                        NULL,
                                        &RequireLength
                                        );

                        if ( status == STATUS_BUFFER_TOO_SMALL ) {

                            pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, RequireLength+1);

                            status = RtlMakeSelfRelativeSD(
                                            (pShareInfo + i)->shi502_security_descriptor,
                                            pSD,
                                            &RequireLength
                                            );
                        }
                        rc = SmbsvcpDosErrorToSceStatus(RtlNtStatusToDosError(status));
                    }

                    if ( rc == SCESTATUS_SUCCESS ) {

                        rc = SmbsvcpAddAShareToList(pShareList,
                                                    (pShareInfo + i)->shi502_netname,
                                                    0,
                                                    pSD
                                                    );
                        if ( rc == SCESTATUS_SUCCESS ) {
                            (*ShareCount)++;

                        } else if ( pSD != NULL ) {
                            LocalFree(pSD);
                            pSD = NULL;
                        }

                    }
                    if ( rc != SCESTATUS_SUCCESS ) {
                        break;
                    }
                }
            }
            //
            // free the buffer
            //
            NetApiBufferFree(pShareInfo);
            pShareInfo = NULL;

        } else
            rc = SmbsvcpDosErrorToSceStatus(Win32rc);

    } while ( rc == SCESTATUS_SUCCESS && nCount < TotalEntries );

    if ( rc != SCESTATUS_SUCCESS && *pShareList != NULL ) {

        SmbsvcpFreeShareList(*pShareList);
        *pShareList = NULL;

        *ShareCount = 0;
    }

    return(rc);
}


SCESTATUS
SmbsvcpAnalyzeValue(
    IN PCWSTR RegKey,
    IN PCWSTR RegValueName,
    IN PCWSTR KeyName,
    IN DWORD ConfigValue,
    OUT PSCESVC_ANALYSIS_LINE pLineInfo,
    IN OUT PDWORD pCount
    )
{
    if ( RegKey == NULL || RegValueName == NULL ||
         KeyName == NULL || pLineInfo == NULL || pCount == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( ConfigValue == (DWORD)SMBSVC_NO_VALUE ||
         (BYTE)ConfigValue == (BYTE)SMBSVC_NO_VALUE ) {
        return(SCESTATUS_SUCCESS);
    }
    //
    // query the registry value
    //
    DWORD Value=0;
    DWORD Win32rc = SmbsvcpRegQueryIntValue(
                        HKEY_LOCAL_MACHINE,
                        (PWSTR)RegKey,
                        (PWSTR)RegValueName,
                        &Value
                        );
    if ( Win32rc == ERROR_SUCCESS || Win32rc == ERROR_FILE_NOT_FOUND ) {

        Win32rc = ERROR_SUCCESS;

        if ( ConfigValue != Value ) {
            //
            // mismatched
            //
            PWSTR Key, StrValue;
            DWORD ValueLen;
            //
            // allocate buffer for key and value
            //
            Key = (PWSTR)LocalAlloc(LMEM_FIXED, (wcslen(KeyName)+1)*sizeof(WCHAR));

            if ( Key != NULL ) {

                WCHAR TempBuf[16];

                memset(TempBuf, '\0', 32);
                swprintf(TempBuf, L"%d", Value);

                DWORD Len = wcslen(TempBuf);

                StrValue = (PWSTR)LocalAlloc(LMEM_FIXED, (Len+1)*sizeof(WCHAR));

                if ( StrValue != NULL ) {
                    //
                    // assign to the line buffer and increment the count
                    //
                    wcsncpy(StrValue, TempBuf, Len);
                    StrValue[Len] = L'\0';

                    wcscpy(Key, KeyName);

                    pLineInfo->Key = Key;
                    pLineInfo->Value = (PBYTE)StrValue;
                    pLineInfo->ValueLen = Len*sizeof(WCHAR);

                    (*pCount)++;

                } else {
                    Win32rc = ERROR_NOT_ENOUGH_MEMORY;
                    LocalFree(Key);
                }

            } else
                Win32rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return(SmbsvcpDosErrorToSceStatus(Win32rc));

}

DWORD
SmbsvcpConvertStringToMultiSz(
    IN PWSTR theStr,
    IN DWORD theLen,
    OUT PBYTE *outValue,
    OUT PDWORD outLen
    )
{
    if ( outValue == NULL || outLen == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }
    *outValue = NULL;
    *outLen = 0;

    if ( theStr == NULL || theLen == 0 || theLen == SMBSVC_NO_VALUE ) {
        return ERROR_SUCCESS;
    }

    *outValue = (PBYTE)LocalAlloc(0, theLen+4);

    if ( *outValue != NULL ) {
        wcscpy((PWSTR)(*outValue), theStr);
        // terminate the last w-char with 0 for Multi-Sz format
        *((PWSTR)(*outValue+theLen+2)) = L'\0';

        // replace ',' with '\0'
        PWSTR pTemp = (PWSTR)(*outValue);

        while ( pTemp != NULL ) {
            pTemp = wcschr(pTemp, L',');
            if ( pTemp != NULL ) {
                *pTemp = L'\0';
                pTemp++;
            }
        }

        return ERROR_SUCCESS;

    } else
        return ERROR_NOT_ENOUGH_MEMORY;

}


SCESTATUS
SmbsvcpAnalyzeMultiSzString(
   IN PCWSTR RegKey,
   IN PCWSTR RegValueName,
   IN PWSTR  pConfigInfo,
   IN DWORD  InfoLength,
   OUT PSCESVC_ANALYSIS_LINE pLineInfo,
   IN OUT PDWORD pCount
   )
{
   if ( RegKey == NULL || RegValueName == NULL ||
        pLineInfo == NULL || pCount == NULL ) {

       return(SCESTATUS_INVALID_PARAMETER);
   }

   if ( InfoLength == SMBSVC_NO_VALUE ) {
       // do not configure
       return(SCESTATUS_SUCCESS);
   }
   //
   // query the registry value
   //
   DWORD RegType;
   PWSTR Value=NULL;

   DWORD Win32rc = SmbsvcpRegQueryValue(
                       HKEY_LOCAL_MACHINE,
                       (PWSTR)RegKey,
                       (PWSTR)RegValueName,
                       (PVOID *)&Value,
                       &RegType
                       );

   if ( Win32rc == ERROR_SUCCESS || Win32rc == ERROR_FILE_NOT_FOUND ) {

       BOOL Diff;
       DWORD ValueLen;

       //
       // change multi-sz to comma separated strings IN PLACE
       //
       SmbsvcpChangeMultiSzToString(Value);

       Win32rc = SmbsvcpCompareMultiSzString(pConfigInfo, Value, &ValueLen, &Diff);

       if (Win32rc == ERROR_SUCCESS && Diff ) {
           //
           // mismatched
           //
           PWSTR Key;
           //
           // allocate buffer for key and value
           //
           Key = (PWSTR)LocalAlloc(LMEM_FIXED, (wcslen(RegValueName)+1)*sizeof(WCHAR));

           if ( Key != NULL ) {

               //
               // assign to the line buffer and increment the count
               //
               wcscpy(Key, RegValueName);

               pLineInfo->Key = Key;
               pLineInfo->Value = (PBYTE)Value;
               pLineInfo->ValueLen = ValueLen*sizeof(WCHAR);

               (*pCount)++;

               Value = NULL;
           } else
               Win32rc = ERROR_NOT_ENOUGH_MEMORY;
       }
       //
       // free Value is not NULL
       //
       if ( Value != NULL ) {
           LocalFree(Value);
       }
   }

   return(SmbsvcpDosErrorToSceStatus(Win32rc));

}


DWORD
SmbsvcpChangeMultiSzToString(
    IN PWSTR Value
    )
{
    if ( Value == NULL )
        return ERROR_SUCCESS;

    //
    // replace '\0' with ','s
    //
    PWSTR pTemp=Value;

    while ( pTemp ) {

        if ( *pTemp == L'\0' ) {

            if ( *(pTemp+1) != L'\0' )
                *pTemp = L',';
            else
                break;
        }

        pTemp++;
    }


    return ERROR_SUCCESS;

}


DWORD
SmbsvcpCompareMultiSzString(
    IN PWSTR pConfigInfo,
    IN PWSTR Value,
    OUT PDWORD pValueLen,
    OUT PBOOL pDiff
    )
{
    if ( pDiff == NULL || pValueLen == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *pDiff = FALSE;
    *pValueLen = 0;

    if ( pConfigInfo == NULL && Value == NULL ) {
        return(ERROR_SUCCESS);
    }

    if ( (pConfigInfo == NULL && Value != NULL) ||
         (pConfigInfo != NULL && Value == NULL) ) {

        *pDiff = TRUE;
        return ERROR_SUCCESS;
    }

    DWORD CountValue=0, ValueLen=0;
    DWORD ConfigLen=0, CountConfig=0;

    DWORD Win32rc;

    Win32rc = SmbsvcpCountComponents(Value, &ValueLen, &CountValue);

    //
    // both pConfigInfo and Value are not NULL
    //
    if ( Win32rc == ERROR_SUCCESS ) {
        *pValueLen = ValueLen;
        Win32rc = SmbsvcpCountComponents(pConfigInfo, &ConfigLen, &CountConfig);
    }

    if ( Win32rc == ERROR_SUCCESS ) {

        if ( ConfigLen != ValueLen ||
             CountConfig != CountValue ) {

            *pDiff = TRUE;
            return(Win32rc);
        }

        if ( CountConfig == 0 ) {
            //
            // No component, return FALSE for *pDiff
            //
            return(Win32rc);
        }
        //
        // both value are not empty, have the same count and same length
        // build the pointers into array to compare
        //
        PWSTR *ConfigPtr;
        PWSTR *ValuePtr;

        ConfigPtr = (PWSTR *)LocalAlloc(LMEM_FIXED, CountConfig*sizeof(PWSTR));
        if ( ConfigPtr != NULL ) {

            ValuePtr = (PWSTR *)LocalAlloc(LMEM_FIXED, CountValue*2*sizeof(PWSTR));

            if ( ValuePtr != NULL ) {

                PWSTR pTemp = (PWSTR)pConfigInfo;
                DWORD i = 0;

                //
                // build the pointers from pConfigInfo into ConfigPtr
                //
                do {
                    ConfigPtr[i++] = pTemp;
                    pTemp = wcschr(pTemp, L',');

                    if ( pTemp != NULL ) {
                        pTemp++;
                    }
                } while ( pTemp != NULL );

                pTemp = (PWSTR)Value;
                i = 0;

                //
                // build the pointers from Value into ValuePtr
                //
                do {
                    ValuePtr[i++] = pTemp;
                    pTemp = wcschr(pTemp, L',');

                    if ( pTemp != NULL ) {
                        ValuePtr[i] = (PWSTR)((DWORD_PTR)pTemp-(DWORD_PTR)(ValuePtr[i-1]));
                        i++;
                        pTemp++;

                    } else {

                        ValuePtr[i] = (PWSTR)(wcslen(ValuePtr[i-1]));
                        i++;
                    }

                } while ( pTemp != NULL );

                DWORD j, nLen;

                //
                // compare two pointer arrays. if a match is found, the pointer element is set to NULL
                // so next time it won't be compared again.
                //
                for ( i=0; i<CountConfig; i++ ) {

                    if ( i == CountConfig-1 )
                        // the last one
                        nLen = wcslen(ConfigPtr[i]);
                    else
                        nLen = (DWORD)(ConfigPtr[i+1]-ConfigPtr[i]-1);

                    for ( j=0; j<CountValue*2; j+=2) {

                        if ( ValuePtr[j] != NULL ) {

                            if ( (DWORD_PTR)(ValuePtr[j+1]) == nLen &&
                                 _wcsnicmp(ConfigPtr[i], ValuePtr[j], nLen) == 0 ) {

                                ValuePtr[j] = NULL;
                                break;
                            }
                        }
                    }

                    if ( j >= CountValue*2 ) {
                        //
                        // did not find a match
                        //
                        *pDiff = TRUE;
                        break;
                    }
                }

                for ( j=0; j < CountValue*2; j+=2 ) {

                    if ( ValuePtr[j] != NULL ) {
                        *pDiff = TRUE;
                        break;
                    }
                }

                LocalFree(ValuePtr);

            } else
                Win32rc = ERROR_NOT_ENOUGH_MEMORY;


            LocalFree(ConfigPtr);

        } else
            Win32rc = ERROR_NOT_ENOUGH_MEMORY;

    }

    return(Win32rc);

}


DWORD
SmbsvcpCountComponents(
    IN PWSTR Value,
    OUT PDWORD ValueLen,
    OUT PDWORD Count
    )
{
    if ( ValueLen == NULL ||
         Count == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( Value == NULL ) {
        *ValueLen = 0;
        *Count = 0;
        return(ERROR_SUCCESS);
    }

    PWSTR pTemp = (PWSTR)Value;

    DWORD Len = 0;
    *Count = 0;
    *ValueLen = wcslen(pTemp);

    do {

        (*Count)++;
        pTemp = wcschr(pTemp, L',');
        if ( pTemp != NULL ) {
            pTemp++;
        }

    } while ( pTemp != NULL );


    return(ERROR_SUCCESS);
}


SCESTATUS
SmbsvcpUpdateMultiSzString(
    IN PSCESVC_CALLBACK_INFO pSceCbInfo,
    IN SCESVC_CONFIGURATION_LINE NewLine,
    IN PSCESVC_CONFIGURATION_INFO pConfigInfo OPTIONAL,
    IN PSCESVC_ANALYSIS_INFO pAnaInfo OPTIONAL
    )
{
    //
    // the value in the structure is Multi-Sz
    //
    if ( pSceCbInfo == NULL ||
         pSceCbInfo->sceHandle == NULL ||
         pSceCbInfo->pfSetInfo == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;
    DWORD Win32rc;

    BOOL bDiff, bDiff2;
    DWORD ValueLen;

    //
    // prepare an update buffer
    //
    SCESVC_ANALYSIS_INFO UpdtAnaInfo;
    SCESVC_ANALYSIS_LINE UpdtAnaLine;

    UpdtAnaInfo.Count = 1;
    UpdtAnaInfo.Lines = &UpdtAnaLine;

    SCESVC_CONFIGURATION_INFO UpdtConfigInfo;
    SCESVC_CONFIGURATION_LINE UpdtConfigLine;

    UpdtConfigInfo.Count = 1;
    UpdtConfigInfo.Lines = &UpdtConfigLine;


    if ( pAnaInfo == NULL ) {
        //
        // old status is match, or new added configuration key
        //
        if ( pConfigInfo != NULL && pConfigInfo->Lines != NULL ) {
            // match item
            Win32rc = SmbsvcpCompareMultiSzString(
                            NewLine.Value,
                            pConfigInfo->Lines[0].Value,
                            &ValueLen,
                            &bDiff
                            );
            if ( Win32rc != ERROR_SUCCESS ) {
                return(SmbsvcpDosErrorToSceStatus(Win32rc));
            }

        } else {
            // new add
            bDiff = TRUE;
            ValueLen = 0;
        }

        if ( bDiff ) {

           SmbsvcpWriteError(pSceCbInfo->pfLogInfo,
                             SCE_LOG_LEVEL_DEBUG,
                             0,
                             L"match->mismatch"
                             );
            //
            // mismatch should be raised with ConfigValue
            //
            UpdtAnaLine.Key = NewLine.Key;
            UpdtAnaLine.Value = ( pConfigInfo != NULL ) ? (PBYTE)(pConfigInfo->Lines[0].Value) : NULL;
            UpdtAnaLine.ValueLen = ( pConfigInfo != NULL ) ? pConfigInfo->Lines[0].ValueLen : 0;

            __try {
                rc = (*(pSceCbInfo->pfSetInfo))(
                        pSceCbInfo->sceHandle,
                        SceSvcAnalysisInfo,
                        NULL,
                        TRUE,
                        (PVOID)&UpdtAnaInfo
                        );
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                rc = SCESTATUS_SERVICE_NOT_SUPPORT;
            }

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // update configuration setting with NewValue
                //
                UpdtConfigLine.Key = NewLine.Key;
                UpdtConfigLine.Value = NewLine.Value;
                UpdtConfigLine.ValueLen = NewLine.ValueLen;

                __try {
                    rc = (*(pSceCbInfo->pfSetInfo))(
                            pSceCbInfo->sceHandle,
                            SceSvcConfigurationInfo,
                            NULL,
                            TRUE,
                            (PVOID)&UpdtConfigInfo
                            );

                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                }
            }
        }

    } else {
        //
        // old status is mismatch for this item
        //
        Win32rc = SmbsvcpCompareMultiSzString(
                        NewLine.Value,
                        (PWSTR)(pAnaInfo->Lines[0].Value),
                        &ValueLen,
                        &bDiff
                        );
        if ( Win32rc == ERROR_SUCCESS ) {

            if (pConfigInfo != NULL && pConfigInfo->Lines != NULL ) {

                Win32rc = SmbsvcpCompareMultiSzString(
                            NewLine.Value,
                            pConfigInfo->Lines[0].Value,
                            &ValueLen,
                            &bDiff2
                            );
            } else {
                bDiff2 = TRUE;
                ValueLen = 0;
            }

        }
        if ( Win32rc != ERROR_SUCCESS ) {
            return(SmbsvcpDosErrorToSceStatus(Win32rc));
        }

        if ( !bDiff ) {

           SmbsvcpWriteError(pSceCbInfo->pfLogInfo,
                             SCE_LOG_LEVEL_DEBUG,
                             0,
                             L"mismatch->match"
                             );
            //
            // now it is matched, delete the analysis entry
            //
            __try {
                rc = (*(pSceCbInfo->pfSetInfo))(
                        pSceCbInfo->sceHandle,
                        SceSvcAnalysisInfo,
                        NewLine.Key,
                        TRUE,
                        NULL
                        );

            } __except (EXCEPTION_EXECUTE_HANDLER) {
                rc = SCESTATUS_SERVICE_NOT_SUPPORT;
            }
        }

        if ( bDiff2 ) {
            //
            // update the configuration setting
            //
            UpdtConfigLine.Key = NewLine.Key;
            UpdtConfigLine.Value = NewLine.Value;
            UpdtConfigLine.ValueLen = NewLine.ValueLen;

            __try {
                rc = (*(pSceCbInfo->pfSetInfo))(
                        pSceCbInfo->sceHandle,
                        SceSvcConfigurationInfo,
                        NULL,
                        TRUE,
                        (PVOID)&UpdtConfigInfo
                        );
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                rc = SCESTATUS_SERVICE_NOT_SUPPORT;
            }
        }
    }

    return(rc);
}


SCESTATUS
SmbsvcpUpdateShareValue(
    IN PSCESVC_CALLBACK_INFO pSceCbInfo,
    IN SCESVC_CONFIGURATION_LINE NewLine,
    IN PSCESVC_CONFIGURATION_INFO pConfigInfo OPTIONAL,
    IN PSCESVC_ANALYSIS_INFO pAnaInfo OPTIONAL
    )
{
    //
    // the value in the structure is "Share," followed by a security descriptor text
    //
    if ( pSceCbInfo == NULL ||
         pSceCbInfo->sceHandle == NULL ||
         pSceCbInfo->pfSetInfo == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc=SCESTATUS_SUCCESS;

    //
    // prepare an update buffer
    //
    SCESVC_ANALYSIS_INFO UpdtAnaInfo;
    SCESVC_ANALYSIS_LINE UpdtAnaLine;

    UpdtAnaInfo.Count = 1;
    UpdtAnaInfo.Lines = &UpdtAnaLine;

    SCESVC_CONFIGURATION_INFO UpdtConfigInfo;
    SCESVC_CONFIGURATION_LINE UpdtConfigLine;

    UpdtConfigInfo.Count = 1;
    UpdtConfigInfo.Lines = &UpdtConfigLine;

    PSECURITY_DESCRIPTOR pSD1=NULL, pSD2=NULL;
    DWORD SDsize;
    BOOL bEqual;

    if ( pAnaInfo == NULL ) {
        //
        // old status is match, or a new added share
        //
        if ( pConfigInfo == NULL ) {
            //
            // a new share, query the current setting in the system
            //
            PSHARE_INFO_1501 ShareInfo=NULL;
            DWORD Win32rc;

            Win32rc = NetShareGetInfo (
                            NULL,
                            NewLine.Key,
                            1501,
                            (LPBYTE *)&ShareInfo
                            );

            if ( Win32rc == ERROR_SUCCESS ) {

                PWSTR TextSD=NULL;
                DWORD SDsize=0;

                if ( ShareInfo->shi1501_security_descriptor != NULL ) {

#if defined(_NT4BACK_PORT)
                    rc = SceSvcConvertSDToText(
                                    ShareInfo->shi1501_security_descriptor,
                                    DACL_SECURITY_INFORMATION,
                                    &TextSD,
                                    &SDsize
                                    );
                    rc = SmbsvcpDosErrorToSceStatus(rc);
#else
                    if ( !ConvertSecurityDescriptorToStringSecurityDescriptor(
                                    ShareInfo->shi1501_security_descriptor,
                                    SDDL_REVISION,
                                    DACL_SECURITY_INFORMATION,
                                    &TextSD,
                                    &SDsize
                                    ) ) {
                        rc = SmbsvcpDosErrorToSceStatus(GetLastError());
                    } else {
                        rc = SCESTATUS_SUCCESS;

                    }
#endif
                }

                if ( rc == SCESTATUS_SUCCESS ) {

                    PWSTR Value;

                    Value = (PWSTR)LocalAlloc(LMEM_FIXED, (SDsize+9)*sizeof(WCHAR));

                    if ( Value != NULL ) {

                        if ( TextSD != NULL )
                            swprintf(Value, L"Share,%1d,%s", SMBSVC_STATUS_NOT_CONFIGURED, TextSD );
                        else
                            swprintf(Value, L"Share,%1d,",SMBSVC_STATUS_NOT_CONFIGURED);

                        Value[SDsize+8] = L'\0';

                        UpdtAnaLine.Key = NewLine.Key;
                        UpdtAnaLine.Value = (PBYTE)Value;
                        UpdtAnaLine.ValueLen = (SDsize+8)*sizeof(WCHAR);

                        __try {
                            rc = (*(pSceCbInfo->pfSetInfo))(
                                    pSceCbInfo->sceHandle,
                                    SceSvcAnalysisInfo,
                                    NULL,
                                    TRUE,
                                    (PVOID)&UpdtAnaInfo
                                    );

                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                        }

                        LocalFree(Value);

                    } else
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                }

                NetApiBufferFree(ShareInfo);

            } else
                rc = SmbsvcpDosErrorToSceStatus(Win32rc);

        } else {
            //
            // matched item.
            //
            bEqual = FALSE;

            SECURITY_INFORMATION SeInfo;

            if ( NewLine.ValueLen > 14 &&
                 NewLine.Value != NULL &&
                 NewLine.Value[8] != L'\0' ) {

#if defined(_NT4BACK_PORT)

                rc = SceSvcConvertTextToSD(
                           NewLine.Value+8,
                           &pSD1,
                           &SDsize,
                           &SeInfo
                           );
                rc = SmbsvcpDosErrorToSceStatus(rc);

#else
                if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
                            (PCWSTR)(NewLine.Value+8),
                            SDDL_REVISION,
                            &pSD1,
                            NULL
                            ) ) {
                    rc = SmbsvcpDosErrorToSceStatus(GetLastError());
                } else {
                    rc = SCESTATUS_SUCCESS;
                }
#endif
            }
            if ( rc == SCESTATUS_SUCCESS && pConfigInfo->Lines != NULL &&
                 pConfigInfo->Lines[0].ValueLen > 14 &&
                 pConfigInfo->Lines[0].Value != NULL &&
                 pConfigInfo->Lines[0].Value[8] != L'\0' ) {

#if defined(_NT4BACK_PORT)

                rc = SceSvcConvertTextToSD(
                              pConfigInfo->Lines[0].Value+8,
                              &pSD2,
                              &SDsize,
                              &SeInfo
                              );
                rc = SmbsvcpDosErrorToSceStatus(rc);

#else
                if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
                            (PCWSTR)(pConfigInfo->Lines[0].Value+8),
                            SDDL_REVISION,
                            &pSD2,
                            NULL
                            ) ) {
                    rc = SmbsvcpDosErrorToSceStatus(GetLastError());
                }
#endif
            }

            if ( rc == SCESTATUS_SUCCESS ) {

                rc = SmbsvcpEqualSecurityDescriptor(
                            pSD1,
                            pSD2,
                            FALSE,
                            &bEqual
                            );
            }

            if ( rc == SCESTATUS_SUCCESS && !bEqual ) {

               SmbsvcpWriteError(pSceCbInfo->pfLogInfo,
                                 SCE_LOG_LEVEL_DEBUG,
                                 0,
                                 L"match->mismatch"
                                 );
                //
                // mismatch should be raised with ConfigValue
                //
                UpdtAnaLine.Key = NewLine.Key;
                UpdtAnaLine.Value = (PBYTE)(pConfigInfo->Lines[0].Value);
                UpdtAnaLine.ValueLen = pConfigInfo->Lines[0].ValueLen;

                __try {
                    rc = (*(pSceCbInfo->pfSetInfo))(
                            pSceCbInfo->sceHandle,
                            SceSvcAnalysisInfo,
                            NULL,
                            TRUE,
                            (PVOID)&UpdtAnaInfo
                            );

                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                }
            }
        }

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // update configuration setting with NewValue
            //
            UpdtConfigLine.Key = NewLine.Key;
            UpdtConfigLine.Value = NewLine.Value;
            UpdtConfigLine.ValueLen = NewLine.ValueLen;

            __try {
                rc = (*(pSceCbInfo->pfSetInfo))(
                        pSceCbInfo->sceHandle,
                        SceSvcConfigurationInfo,
                        NULL,
                        TRUE,
                        (PVOID)&UpdtConfigInfo
                        );

            } __except (EXCEPTION_EXECUTE_HANDLER) {
                rc = SCESTATUS_SERVICE_NOT_SUPPORT;
            }
        }

    } else {
        //
        // old status is mismatch for this item
        //
        bEqual = FALSE;

        if ( NewLine.ValueLen > 14 &&
             NewLine.Value != NULL &&
             NewLine.Value[8] != L'\0' ) {

#if defined(_NT4BACK_PORT)

                SECURITY_INFORMATION SeInfo;

                rc = SceSvcConvertTextToSD(
                           NewLine.Value+8,
                           &pSD1,
                           &SDsize,
                           &SeInfo
                           );
                rc = SmbsvcpDosErrorToSceStatus(rc);

#else
            if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
                        (PCWSTR)(NewLine.Value+8),
                        SDDL_REVISION,
                        &pSD1,
                        NULL
                        ) ) {
                rc = SmbsvcpDosErrorToSceStatus(GetLastError());
            } else {
                rc = SCESTATUS_SUCCESS;
            }
#endif
        }
        if ( rc == SCESTATUS_SUCCESS && pAnaInfo->Lines != NULL &&
             pAnaInfo->Lines[0].ValueLen > 14 &&
             pAnaInfo->Lines[0].Value != NULL &&
             ((PWSTR)(pAnaInfo->Lines[0].Value))[8] != L'\0' ) {

#if defined(_NT4BACK_PORT)

                SECURITY_INFORMATION SeInfo;

                rc = SceSvcConvertTextToSD(
                           (PWSTR)(pAnaInfo->Lines[0].Value+8),
                           &pSD2,
                           &SDsize,
                           &SeInfo
                           );
                rc = SmbsvcpDosErrorToSceStatus(rc);

#else
            if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
                        (PCWSTR)(pAnaInfo->Lines[0].Value+8),
                        SDDL_REVISION,
                        &pSD2,
                        NULL
                        ) ) {
                rc = SmbsvcpDosErrorToSceStatus(GetLastError());
            } else {
                rc = SCESTATUS_SUCCESS;
            }
#endif
        }

        if ( rc == SCESTATUS_SUCCESS ) {

            rc = SmbsvcpEqualSecurityDescriptor(
                        pSD1,
                        pSD2,
                        FALSE,
                        &bEqual
                        );
        }

        if ( rc == SCESTATUS_SUCCESS && bEqual ) {

           SmbsvcpWriteError(pSceCbInfo->pfLogInfo,
                             SCE_LOG_LEVEL_DEBUG,
                             0,
                             L"mismatch->match"
                             );
            //
            // now it is matched, delete the analysis entry
            //
            __try {
                rc = (*(pSceCbInfo->pfSetInfo))(
                        pSceCbInfo->sceHandle,
                        SceSvcAnalysisInfo,
                        NewLine.Key,
                        TRUE,
                        NULL
                        );

            } __except (EXCEPTION_EXECUTE_HANDLER) {
                rc = SCESTATUS_SERVICE_NOT_SUPPORT;
            }
        }

        if ( rc == SCESTATUS_SUCCESS ) {

            //
            // update the configuration setting
            //
            UpdtConfigLine.Key = NewLine.Key;
            UpdtConfigLine.Value = NewLine.Value;
            UpdtConfigLine.ValueLen = NewLine.ValueLen;

            __try {
                rc = (*(pSceCbInfo->pfSetInfo))(
                        pSceCbInfo->sceHandle,
                        SceSvcConfigurationInfo,
                        NULL,
                        TRUE,
                        (PVOID)&UpdtConfigInfo
                        );
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                rc = SCESTATUS_SERVICE_NOT_SUPPORT;
            }
        }
    }

    if ( pSD1 != NULL ) {
        LocalFree(pSD1);
    }
    if ( pSD2 != NULL ) {
        LocalFree(pSD2);
    }

    return(rc);

}


SCESTATUS
SmbsvcpEqualSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSD1,
    IN PSECURITY_DESCRIPTOR pSD2,
    IN BOOL bExplicitOnly,
    OUT PBOOL pbEqual
    )
{
    if ( pbEqual == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    *pbEqual = TRUE;

    if ( pSD1 == NULL && pSD2 == NULL )
        return(SCESTATUS_SUCCESS);

    BOOLEAN aclPresent, tFlag;
    PACL pAcl1=NULL, pAcl2=NULL;

    //
    // get the DACL in each SD
    //
    if ( pSD1 == NULL ||
         !NT_SUCCESS( RtlGetDaclSecurityDescriptor(
                                     pSD1,
                                     &aclPresent,
                                     &pAcl1,
                                     &tFlag)
                                   ) ) {

        pAcl1 = NULL;
    } else if ( !aclPresent )
        pAcl1 = NULL;

    if ( pSD2 == NULL ||
        !NT_SUCCESS( RtlGetDaclSecurityDescriptor(
                                     pSD2,
                                     &aclPresent,
                                     &pAcl2,
                                     &tFlag)
                                   ) ) {

        pAcl2 = NULL;
    } else if ( !aclPresent )
        pAcl2 = NULL;
    //
    // NOTE:
    // if SD is NULL, it is Everyone Full Control
    //
    if ( pSD1 == NULL ) {
        //
        // check if pAcl2 has only Everyone Full Access
        //
        return( SmbsvcpDosErrorToSceStatus(
                  SmbsvcEveryoneFullAccess(pAcl2, bExplicitOnly, pbEqual) ));
    }
    if ( pSD2 == NULL ) {
        //
        // check if pAcl1 has only Everyone Full Access
        //
        return(SmbsvcpDosErrorToSceStatus(
                  SmbsvcEveryoneFullAccess(pAcl1, bExplicitOnly, pbEqual) ));
    }

    if ( pAcl1 == NULL && pAcl2 == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    // if DACL is NULL, it is deny everyone access
    if ( !bExplicitOnly) {
        //
        // if all aces are checked, they are different when one is NULL
        //
        if ( (pAcl1 == NULL && pAcl2 != NULL) ||
             (pAcl1 != NULL && pAcl2 == NULL) ) {

            *pbEqual = FALSE;
            return(SCESTATUS_SUCCESS);
        }
    }
    //
    // compare two ACLs
    //
    BOOL bDifferent = FALSE;
    DWORD rc;

    rc = SmbsvcpCompareAcl( pAcl1, pAcl2, bExplicitOnly, &bDifferent );

    if ( rc == ERROR_SUCCESS ) {

        if (bDifferent )
            *pbEqual = FALSE;

    } else
        *pbEqual = FALSE;

    return(SmbsvcpDosErrorToSceStatus(rc));
}


DWORD
SmbsvcEveryoneFullAccess(
    IN PACL pAcl,
    IN BOOL bExplicit,
    OUT PBOOL pbEqual
    )
{
    if ( pbEqual == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *pbEqual = FALSE;
    if ( pAcl == NULL ) {
        return(ERROR_SUCCESS);
    }

    NTSTATUS NtStatus;
    PSID pSidEveryone=NULL;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority=SECURITY_WORLD_SID_AUTHORITY;
    //
    // build everyone sid
    //
    pSidEveryone = (PSID) LocalAlloc(LMEM_FIXED, RtlLengthRequiredSid(1));

    if (NULL == pSidEveryone )
        return(ERROR_NOT_ENOUGH_MEMORY);

    NtStatus = RtlInitializeSid(pSidEveryone, &IdentifierAuthority, (UCHAR)1);

    if ( !NT_SUCCESS(NtStatus) ) {
        LocalFree(pSidEveryone);
        return(RtlNtStatusToDosError(NtStatus));
    }

    *(RtlSubAuthoritySid(pSidEveryone, 0)) = SECURITY_WORLD_RID;


    ACE_HEADER *pAce=NULL;
    PSID    pSid;
    ACCESS_MASK Access;
    DWORD nAceCount, j;

    for ( j=0, nAceCount=0; j<pAcl->AceCount; j++ ) {

        NtStatus = RtlGetAce(pAcl, j, (PVOID *)&pAce);

        if ( !NT_SUCCESS(NtStatus) )
            break;

        if ( pAce == NULL )
            continue;

        if ( bExplicit && (pAce->AceFlags & INHERITED_ACE) ) {
            //
            // find a inherit Ace in Acl
            //
            continue;
        }

        nAceCount++;

        if ( nAceCount == 1 && pAce->AceType == ACCESS_ALLOWED_ACE_TYPE ) {

            pSid = (PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
            Access = ((PACCESS_ALLOWED_ACE)pAce)->Mask;

            if ( pSid != NULL ) {
                if ( Access == FILE_ALL_ACCESS || Access == GENERIC_ALL ) {

                    if ( EqualSid(pSid, pSidEveryone) )
                        *pbEqual = TRUE;
                }
            }
        }
        if ( !*pbEqual)
             break;

        if ( nAceCount > 1 ) { // should only allow one ace
            *pbEqual = FALSE;
            break;
        }
    }

    LocalFree(pSidEveryone);

    return(RtlNtStatusToDosError(NtStatus));
}


DWORD
SmbsvcpCompareAcl(
    IN PACL pAcl1,
    IN PACL pAcl2,
    IN BOOL bExplicitOnly,
    OUT PBOOL pDifferent
    )
/*
Routine Description:

    This routine compares explicit aces of two ACLs for exact match. Exact
    match means: same access type, same inheritance flag, same access mask,
    same GUID/Object GUID (if available), and same SID.

    Inherited aces (INHERITED_ACE is set) are ignored.

Arguments:

    pAcl1 - The first ACL

    pAcl2 - The 2nd ACL

    pDifferent - The output flag to indicate different

Return Value:

    Win32 error codes
*/
{
    NTSTATUS        NtStatus=STATUS_SUCCESS;
    DWORD           i, j;
    ACE_HEADER      *pAce1=NULL;
    ACE_HEADER      *pAce2=NULL;
    DWORD           ProcessAce=0;


    *pDifferent = FALSE;

    //
    // if pAcl1 is NULL, pAcl2 should have 0 explicit Ace
    //
    if ( pAcl1 == NULL ) {
        return( SmbsvcpAnyExplicitAcl( pAcl2, 0, pDifferent ) );
    }

    //
    // if pAcl2 is NULL, pAcl1 should have 0 explicit Ace
    //
    if ( pAcl2 == NULL ) {
        return( SmbsvcpAnyExplicitAcl( pAcl1, 0, pDifferent ) );
    }
    //
    // both ACLs are not NULL
    // BUGBUG: note there is a limit of AceCount because of DWORD (32 bits)
    //
    for ( i=0; i<pAcl1->AceCount; i++) {

        NtStatus = RtlGetAce(pAcl1, i, (PVOID *)&pAce1);
        if ( !NT_SUCCESS(NtStatus) )
            goto Done;
        //
        // ignore inherited Aces
        //
        if ( bExplicitOnly && (pAce1->AceFlags & INHERITED_ACE) )
            continue;

        //
        // try to find a match in pAcl2
        //
        for ( j=0; j<pAcl2->AceCount; j++ ) {

            if ( ProcessAce & (1 << j) )
                // this one is already processed
                continue;

            NtStatus = RtlGetAce(pAcl2, j, (PVOID *)&pAce2);
            if ( !NT_SUCCESS(NtStatus) )
                goto Done;

            //
            // ignore inherited Aces too
            //
            if ( bExplicitOnly && (pAce2->AceFlags & INHERITED_ACE) ) {
                ProcessAce |= (1 << j);
                continue;
            }

            //
            // compare two Aces (pAce1 and pAce2)
            //
            if ( SmbsvcpEqualAce(pAce1, pAce2) ) {
                //
                // find a match
                //
                ProcessAce |= (1 << j);
                break;
            }

        }

        if ( j >= pAcl2->AceCount ) {
            //
            // did not find a match for pAce1
            //
            *pDifferent = TRUE;
            return(ERROR_SUCCESS);
        }
    }

    if ( i >= pAcl1->AceCount ) {
        //
        // every Ace in pAcl1 finds a match in pAcl2
        // see if every Ace in pAcl2 has a match
        //
        return( SmbsvcpAnyExplicitAcl( pAcl2, ProcessAce, pDifferent ) );
    }
Done:

    return(RtlNtStatusToDosError(NtStatus));
}


DWORD
SmbsvcpAnyExplicitAcl(
    IN PACL Acl,
    IN DWORD Processed,
    OUT PBOOL pExist
    )
/*
Routine Description:

    This routine detects if there is any explicit ace in the Acl. The DWORD
    Processed is a bit mask of the aces already checked.

Arguments:

    Acl - The Acl

    Processed - The bit mask for the processed aces (so it won't be checked again)

    pExist - The output flag to indicate if there is any explicit ace

Return Value:

    win32 error codes
*/
{
    NTSTATUS    NtStatus=STATUS_SUCCESS;
    DWORD       j;
    ACE_HEADER  *pAce=NULL;

    //
    // check output argument
    //
    if ( pExist == NULL )
        return(ERROR_INVALID_PARAMETER);

    *pExist = FALSE;

    if ( Acl == NULL )
        return(ERROR_SUCCESS);

    for ( j=0; j<Acl->AceCount; j++ ) {
        if ( Processed & (1 << j) )
            continue;

        NtStatus = RtlGetAce(Acl, j, (PVOID *)&pAce);

        if ( !NT_SUCCESS(NtStatus) )
            return(RtlNtStatusToDosError(NtStatus));

        if ( pAce == NULL )
            continue;

        if ( !(pAce->AceFlags & INHERITED_ACE) ) {
            //
            // find a explicit Ace in Acl
            //
            *pExist = TRUE;
            break;
        }

    }

    return(RtlNtStatusToDosError(NtStatus));

}


BOOL
SmbsvcpEqualAce(
    IN ACE_HEADER *pAce1,
    IN ACE_HEADER *pAce2
    )
// compare two aces for exact match. The return BOOL value indicates the
// match or not
{
    PSID    pSid1=NULL, pSid2=NULL;
    ACCESS_MASK Access1=0, Access2=0;

    if ( pAce1 == NULL && pAce2 == NULL )
        return(TRUE);

    if ( pAce1 == NULL || pAce2 == NULL )
        return(FALSE);

    //
    // compare ace access type
    //
    if ( pAce1->AceType != pAce2->AceType )
        return(FALSE);

    //
    // compare ace inheritance flag
    //
    if ( pAce1->AceFlags != pAce2->AceFlags )
        return(FALSE);

    switch ( pAce1->AceType ) {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        pSid1 = (PSID)&((PACCESS_ALLOWED_ACE)pAce1)->SidStart;
        pSid2 = (PSID)&((PACCESS_ALLOWED_ACE)pAce2)->SidStart;
        Access1 = ((PACCESS_ALLOWED_ACE)pAce1)->Mask;
        Access2 = ((PACCESS_ALLOWED_ACE)pAce2)->Mask;
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        pSid1 = (PSID)&((PACCESS_ALLOWED_OBJECT_ACE)pAce1)->SidStart;
        pSid2 = (PSID)&((PACCESS_ALLOWED_OBJECT_ACE)pAce2)->SidStart;
        Access1 = ((PACCESS_ALLOWED_OBJECT_ACE)pAce1)->Mask;
        Access2 = ((PACCESS_ALLOWED_OBJECT_ACE)pAce2)->Mask;

        //
        // ignore the guids
        //
        break;
    default:
        return(FALSE); // not recognized Ace type
    }

    if ( pSid1 == NULL || pSid2 == NULL )
        //
        // no Sid, ignore the Ace
        //
        return(FALSE);

    //
    // compare the sids
    //
    if ( !EqualSid(pSid1, pSid2) )
        return(FALSE);

    //
    // access mask
    //
    // Translation is already done when calculating security descriptor
    // for file objects and registry objects
    //
    if ( Access1 != Access2 ) {
        RtlMapGenericMask (
            &Access2,
            &ShareGenMap
            );
        if ( Access1 != Access2)
            return(FALSE);
    }

    return(TRUE);
}


/*=============================================================================
**  Procedure Name:     DllMain
**
**  Arguments:
**
**
**
**  Returns:    0 = SUCCESS
**             !0 = ERROR
**
**  Abstract:
**
**  Notes:
**
**===========================================================================*/
BOOL WINAPI DllMain(
    IN HANDLE DllHandle,
    IN ULONG ulReason,
    IN LPVOID Reserved )
{

    switch(ulReason) {

    case DLL_PROCESS_ATTACH:

        MyModuleHandle = (HINSTANCE)DllHandle;

        //
        // Fall through to process first thread
        //

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp;

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, SCESMB_ROOT_PATH, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }


    RegSetValueEx (hKey, TEXT("ServiceAttachmentPath"), 0, REG_SZ, (LPBYTE)TEXT("seFilShr.dll"),
                   (lstrlen(TEXT("seFilShr.dll")) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{

    RegDeleteKey (HKEY_LOCAL_MACHINE, SCESMB_ROOT_PATH);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\idl\sceimp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sceimp.h

Abstract:

    Security Configuration Editor Engine - Private Includes

Author:

    Jin Huang       (jinhuang)       Jan 27, 1998

Environment:

Revision History:

--*/

#include <nt.h>
#include <windef.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\fileshr\util.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    util.c

Abstract:

    Shared utility routines

Author:

    Jin Huang (jinhuang) 14-Jul-1997

Revision History:

--*/

#include "util.h"
#pragma hdrstop



DWORD
SmbsvcpRegQueryIntValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName,
    OUT DWORD *Value
    )
/* ++

Routine Description:

   This routine queries a REG_DWORD value from a value name/subkey.

Arguments:

   hKeyRoot    - root

   SubKey      - key path

   ValueName   - name of the value

   Value       - the output value for the ValueName

Return values:

   Win32 error code
-- */
{
    DWORD   Rcode;
    DWORD   RegType;
    DWORD   dSize=0;
    HKEY    hKey=NULL;

    if(( Rcode = RegOpenKeyEx(hKeyRoot,
                              SubKey,
                              0,
                              KEY_READ,
                              &hKey
                             )) == ERROR_SUCCESS ) {

        if(( Rcode = RegQueryValueEx(hKey,
                                     ValueName,
                                     0,
                                     &RegType,
                                     NULL,
                                     &dSize
                                    )) == ERROR_SUCCESS ) {
            switch (RegType) {
            case REG_DWORD:
            case REG_DWORD_BIG_ENDIAN:

                Rcode = RegQueryValueEx(hKey,
                                       ValueName,
                                       0,
                                       &RegType,
                                       (BYTE *)Value,
                                       &dSize
                                      );
                if ( Rcode != ERROR_SUCCESS ) {

                    if ( Value != NULL )
                        *Value = 0;

                }
                break;

            default:

                Rcode = ERROR_INVALID_DATATYPE;

                break;
            }
        }
    }

    if( hKey )
        RegCloseKey( hKey );

    return(Rcode);
}


DWORD
SmbsvcpRegSetIntValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName,
    IN DWORD Value
    )
/* ++

Routine Description:

   This routine sets a REG_DWORD value to a value name/subkey.

Arguments:

   hKeyRoot    - root

   SubKey      - key path

   ValueName   - name of the value

   Value       - the value to set

Return values:

   Win32 error code
-- */
{
    DWORD   Rcode;
    HKEY    hKey=NULL;

    if(( Rcode = RegOpenKeyEx(hKeyRoot,
                              SubKey,
                              0,
                              KEY_SET_VALUE,
                              &hKey
                             )) == ERROR_SUCCESS ) {

        Rcode = RegSetValueEx( hKey,
                               ValueName,
                               0,
                               REG_DWORD,
                               (BYTE *)&Value,
                               4
                               );

    }

    if( hKey )
        RegCloseKey( hKey );

    return(Rcode);
}


DWORD
SmbsvcpRegSetValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName,
    IN DWORD RegType,
    IN BYTE *Value,
    IN DWORD ValueLen
    )
/* ++

Routine Description:

   This routine sets a string value to a value name/subkey.

Arguments:

   hKeyRoot    - root

   SubKey      - key path

   ValueName   - name of the value

   Value       - the value to set

   ValueLen    - The number of bytes in Value

Return values:

   Win32 error code
-- */
{
    DWORD   Rcode;
    DWORD   NewKey;
    HKEY    hKey=NULL;
    SECURITY_ATTRIBUTES     SecurityAttributes;
    PSECURITY_DESCRIPTOR    SecurityDescriptor=NULL;


    if(( Rcode = RegOpenKeyEx(hKeyRoot,
                              SubKey,
                              0,
                              KEY_SET_VALUE,
                              &hKey
                             )) != ERROR_SUCCESS ) {

        SecurityAttributes.nLength              = sizeof( SECURITY_ATTRIBUTES );
        SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;
        SecurityAttributes.bInheritHandle       = FALSE;

        Rcode = RegCreateKeyEx(
                   hKeyRoot,
                   SubKey,
                   0,
                   NULL, // LPTSTR lpClass,
                   0,
                   KEY_SET_VALUE,
                   NULL, // &SecurityAttributes,
                   &hKey,
                   &NewKey
                  );
    }

    if ( Rcode == ERROR_SUCCESS ) {

        Rcode = RegSetValueEx( hKey,
                               ValueName,
                               0,
                               RegType,
                               Value,
                               ValueLen
                               );

    }

    if( hKey )
        RegCloseKey( hKey );

    return(Rcode);
}

DWORD
SmbsvcpRegQueryValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PCWSTR ValueName,
    OUT PVOID *Value,
    OUT LPDWORD pRegType
    )
/* ++

Routine Description:

   This routine queries a REG_SZ value from a value name/subkey.
   The output buffer is allocated if it is NULL. It must be freed
   by LocalFree

Arguments:

   hKeyRoot    - root

   SubKey      - key path

   ValueName   - name of the value

   Value       - the output string for the ValueName

Return values:

   Win32 error code
-- */
{
    DWORD   Rcode;
    DWORD   dSize=0;
    HKEY    hKey=NULL;
    BOOL    FreeMem=FALSE;

    if ( SubKey == NULL || ValueName == NULL ||
         Value == NULL || pRegType == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if(( Rcode = RegOpenKeyEx(hKeyRoot,
                              SubKey,
                              0,
                              KEY_READ,
                              &hKey
                             )) == ERROR_SUCCESS ) {

        if(( Rcode = RegQueryValueEx(hKey,
                                     ValueName,
                                     0,
                                     pRegType,
                                     NULL,
                                     &dSize
                                    )) == ERROR_SUCCESS ) {
            switch (*pRegType) {
            case REG_DWORD:
            case REG_DWORD_BIG_ENDIAN:

                Rcode = RegQueryValueEx(hKey,
                                       ValueName,
                                       0,
                                       pRegType,
                                       (BYTE *)(*Value),
                                       &dSize
                                      );
                if ( Rcode != ERROR_SUCCESS ) {

                    if ( *Value != NULL )
                        *((BYTE *)(*Value)) = 0;
                }
                break;

            case REG_SZ:
            case REG_EXPAND_SZ:
            case REG_MULTI_SZ:
                if ( *Value == NULL ) {
                    *Value = (PVOID)LocalAlloc( LMEM_ZEROINIT, (dSize+1)*sizeof(TCHAR));
                    FreeMem = TRUE;
                }

                if ( *Value == NULL ) {
                    Rcode = ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    Rcode = RegQueryValueEx(hKey,
                                           ValueName,
                                           0,
                                           pRegType,
                                           (BYTE *)(*Value),
                                           &dSize
                                          );
                    if ( Rcode != ERROR_SUCCESS && FreeMem ) {
                        LocalFree(*Value);
                        *Value = NULL;
                    }
                }

                break;
            default:

                Rcode = ERROR_INVALID_DATATYPE;

                break;
            }
        }
    }

    if( hKey )
        RegCloseKey( hKey );

    return(Rcode);
}


DWORD
SmbsvcpSceStatusToDosError(
    IN SCESTATUS SceStatus
    )
// converts SCESTATUS error code to dos error defined in winerror.h
{
    switch(SceStatus) {

    case SCESTATUS_SUCCESS:
        return(NO_ERROR);

    case SCESTATUS_OTHER_ERROR:
        return(ERROR_EXTENDED_ERROR);

    case SCESTATUS_INVALID_PARAMETER:
        return(ERROR_INVALID_PARAMETER);

    case SCESTATUS_RECORD_NOT_FOUND:
        return(ERROR_NO_MORE_ITEMS);

    case SCESTATUS_INVALID_DATA:
        return(ERROR_INVALID_DATA);

    case SCESTATUS_OBJECT_EXIST:
        return(ERROR_FILE_EXISTS);

    case SCESTATUS_BUFFER_TOO_SMALL:
        return(ERROR_INSUFFICIENT_BUFFER);

    case SCESTATUS_PROFILE_NOT_FOUND:
        return(ERROR_FILE_NOT_FOUND);

    case SCESTATUS_BAD_FORMAT:
        return(ERROR_BAD_FORMAT);

    case SCESTATUS_NOT_ENOUGH_RESOURCE:
        return(ERROR_NOT_ENOUGH_MEMORY);

    case SCESTATUS_ACCESS_DENIED:
        return(ERROR_ACCESS_DENIED);

    case SCESTATUS_CANT_DELETE:
        return(ERROR_CURRENT_DIRECTORY);

    case SCESTATUS_PREFIX_OVERFLOW:
        return(ERROR_BUFFER_OVERFLOW);

    case SCESTATUS_ALREADY_RUNNING:
        return(ERROR_SERVICE_ALREADY_RUNNING);

    case SCESTATUS_SERVICE_NOT_SUPPORT:
        return(ERROR_NOT_SUPPORTED);

    default:
        return(ERROR_EXTENDED_ERROR);
    }
}


SCESTATUS
SmbsvcpDosErrorToSceStatus(
    DWORD rc
    )
{
    switch(rc) {
    case NO_ERROR:
        return(SCESTATUS_SUCCESS);

    case ERROR_INVALID_PARAMETER:
        return(SCESTATUS_INVALID_PARAMETER);

    case ERROR_INVALID_DATA:
        return(SCESTATUS_INVALID_DATA);

    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:

        return(SCESTATUS_PROFILE_NOT_FOUND);

    case ERROR_ACCESS_DENIED:
    case ERROR_SHARING_VIOLATION:
    case ERROR_LOCK_VIOLATION:
    case ERROR_NETWORK_ACCESS_DENIED:

        return(SCESTATUS_ACCESS_DENIED);

    case ERROR_NOT_ENOUGH_MEMORY:
    case ERROR_OUTOFMEMORY:
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    case ERROR_BAD_FORMAT:
        return(SCESTATUS_BAD_FORMAT);

    case ERROR_CURRENT_DIRECTORY:
        return(SCESTATUS_CANT_DELETE);

    case ERROR_SECTOR_NOT_FOUND:
    case ERROR_NONE_MAPPED:
    case ERROR_SERVICE_DOES_NOT_EXIST:
    case ERROR_RESOURCE_DATA_NOT_FOUND:
    case ERROR_NO_MORE_ITEMS:
#if !defined(_NT4BACK_PORT)
    case ERROR_INVALID_TRANSFORM:
#endif

        return(SCESTATUS_RECORD_NOT_FOUND);

    case ERROR_DUP_NAME:
    case ERROR_FILE_EXISTS:

        return(SCESTATUS_OBJECT_EXIST);

    case ERROR_BUFFER_OVERFLOW:
        return(SCESTATUS_PREFIX_OVERFLOW);

    case ERROR_INSUFFICIENT_BUFFER:

        return(SCESTATUS_BUFFER_TOO_SMALL);

    case ERROR_SERVICE_ALREADY_RUNNING:
        return(SCESTATUS_ALREADY_RUNNING);

    case ERROR_NOT_SUPPORTED:
        return(SCESTATUS_SERVICE_NOT_SUPPORT);

    default:
        return(SCESTATUS_OTHER_ERROR);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\fileshr\util.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    util.h

Abstract:

    This module defines the shared data structure and function prototypes
    for the security manager

Author:

    Jin Huang (jinhuang) 23-Jan-1997

Revision History:

--*/

#ifndef _UTIL_
#define _UTIL_

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef __cplusplus
}
#endif

//
// Windows Headers
//

#include <windows.h>
//#include <rpc.h>

//
// C Runtime Header
//

#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <signal.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <scesvc.h>


#ifdef __cplusplus
extern "C" {
#endif


//
// function definitions
//

SCESTATUS
SmbsvcpDosErrorToSceStatus(
    DWORD rc
    );

DWORD
SmbsvcpRegQueryIntValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName,
    OUT DWORD *Value
    );

DWORD
SmbsvcpRegSetIntValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName,
    IN DWORD Value
    );

DWORD
SmbsvcpRegQueryValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PCWSTR ValueName,
    OUT PVOID *Value,
    OUT LPDWORD pRegType
    );

DWORD
SmbsvcpRegSetValue(
    IN HKEY hKeyRoot,
    IN PWSTR SubKey,
    IN PWSTR ValueName,
    IN DWORD RegType,
    IN BYTE *Value,
    IN DWORD ValueLen
    );

DWORD
SmbsvcpSceStatusToDosError(
    IN SCESTATUS SceStatus
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\convert.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    convert.cpp

Abstract:

    SCE APIs to set security on converted drives
    The main routine is
        exposed via RPC to SCE client (for immediate conversion)
        executed as an asynchronous thread spawned by the server during reboot (for scheduled conversion)

Author:

    Vishnu Patankar (vishnup) 07-Aug-2000 created

Revision History:

--*/

#include "headers.h"
#include "serverp.h"
#include "winsvcp.h"
#include "userenvp.h"

extern HINSTANCE MyModuleHandle;

DWORD
ScepExamineDriveInformation(
    IN  PWSTR   pszRootDrive,
    IN  PWSTR   LogFileName,
    OUT BOOL    *pbSetSecurity
    );

DWORD
ScepSetDefaultSecurityDocsAndSettings(
    );

DWORD
ScepExtractRootDacl(
    OUT PSECURITY_DESCRIPTOR    *ppSDSet,
    OUT PACL    *ppDacl,
    OUT SECURITY_INFORMATION *pSeInfo
    );

VOID
ScepSecureUserProfiles(
    IN PWSTR pCurrDrive
    );

DWORD
ScepConfigureConvertedFileSecurityImmediate(
                                           IN PWSTR    pszDriveName
                                           );

VOID
ScepConfigureConvertedFileSecurityReboot(
    IN PVOID pV
    )
/*++

Routine Description:

    The actual routine to configure setup style security for drives converted from FAT to NTFS.

    The following applies foreach volume that is NTFS - otherwise we log an error and continue with
    other drives (if any)

    First we need to set security on the \Docs&Settings folder if it sits below the drive
    under consideration. Upgrade style security configuration for this folder is done by the userenv API
    DetermineProfilesLocation(). Also need to read SD - add protected bit to SD - set SD back to \Docs&Settings
    such that configuring root with MARTA later will not whack this security. This step is not required if
    security set by userenv is diffetent from default FAT security on the root drive (since marta will not
    detect inheritance and hence will not whack security on \Docs&Settings). The latter is the more likely
    case.

    (a) If we are dealing with the system drive

    Then we just use the security template
    %windir%\security\templates\setup security.inf to configure setup style security (make an RPC
    call into scesrv).

    (b) If we are dealing with a non system drive (whatever the OS maybe), we just use MARTA APIs to set
    security on the root drive (from scecli itself). Currently, this is the design since there is no
    reliable way of parsing the boot files (boot.ini/boot.nvr).

    Then continue with the next drive as in the reg value.

    Since we are doing all this at reboot (scheduled), delete the reg value after we're done.

    Note on error reporting:
        All errors are logged to the logfile %windir%\security\logs\convert.log. but if it is not possible
        to log an error to the logfile, we log it to the event log with source "SceSrv". Also, higher level
        errors/successes are logged to both the logfile and the eventlog.

Arguments:

    pV              -  MULTI_SZ drive name(s) argument

Return:

    none
--*/
{
    //
    // arguments for the thread in which this routine executes
    //

    PWSTR   pmszDriveNames = (PWSTR)pV;

    //
    // Error codes
    //

    DWORD rc = ERROR_SUCCESS;
    DWORD rcSave = ERROR_SUCCESS;

    //
    // folders to use for logging etc.
    //

    WCHAR   szWinDir[MAX_PATH*2 + 1];
    WCHAR   LogFileName[MAX_PATH + 1];
    WCHAR   pszSystemDrive[MAX_PATH];
    WCHAR   InfFileName[MAX_PATH + 1];
    WCHAR   DatabaseName[MAX_PATH + 1];

    //
    // other variables
    //

    BOOL    bSetSecurity = TRUE;
    PSECURITY_DESCRIPTOR    pSDSet=NULL;
    PACL    pDacl=NULL;
    BOOLEAN bRootDaclExtracted = FALSE;

    //
    // before attempting to do any useful work, validate arguments for this thread etc.
    // todo - should we handle exceptions ?
    //
    (void) InitializeEvents(L"SceSrv");

    if ( pmszDriveNames == NULL) {

        //
        // should not happen - parameters have been checked by all callers
        //

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEEVENT_ERROR_CONVERT_PARAMETER,
                 IDS_ERROR_CONVERT_PARAMETER
                );

        //(void) ShutdownEvents();

        return;
    }

    pszSystemDrive[0] = L'\0';

    //
    // ready the log file, logging level etc.
    //

    //
    // logging, database creation (if required) etc. is done in %windir%\security\*
    //

    szWinDir[0] = L'\0';

    if ( GetSystemWindowsDirectory( szWinDir, MAX_PATH ) == 0 ) {

        //
        // too bad if this happens
        //

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEEVENT_ERROR_CONVERT_BAD_ENV_VAR,
                 IDS_ERROR_CONVERT_BAD_ENV_VAR,
                 L"%windir%"
                );

        //(void) ShutdownEvents();

        return;
    }

    LogFileName[0] = L'\0';
    wcscpy(LogFileName, szWinDir);
    wcscat(LogFileName, L"\\security\\logs\\convert.log");

    ScepEnableDisableLog(TRUE);

    ScepSetVerboseLog(3);

    if ( ScepLogInitialize( LogFileName ) == ERROR_INVALID_NAME ) {

        ScepLogOutput3(1,0, SCEDLL_LOGFILE_INVALID, LogFileName );

    }

    //
    // continue even if we cannot initialize log file but we absolutely
    // need the following environment var, so if we can't get it, quit
    //

    if ( GetEnvironmentVariable( L"SYSTEMDRIVE", pszSystemDrive, MAX_PATH) == 0 ) {

        ScepLogOutput3(0,0, SCEDLL_CONVERT_BAD_ENV_VAR, L"%SYSTEMDRIVE%");

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEEVENT_ERROR_CONVERT_BAD_ENV_VAR,
                 IDS_ERROR_CONVERT_BAD_ENV_VAR,
                 L"%systemdrive%"
                );

        ScepLogClose();

        //(void) ShutdownEvents();

        return;
    }

    //
    // following two will be used only if system drive
    //

    OSVERSIONINFOEX   osVersionInfo;
    BYTE    ProductType = VER_NT_WORKSTATION;

    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if ( GetVersionEx((LPOSVERSIONINFO) &osVersionInfo) ){

        ProductType = osVersionInfo.wProductType;
        // use osVersionInfo.wSuiteMask when Personal Template Bug is fixed
    }

    else {

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEDLL_CONVERT_PROD_TYPE,
                 IDS_ERROR_CONVERT_PROD_TYPE,
                 GetLastError()
                );

        ScepLogClose();

        //(void) ShutdownEvents();

        return;

    }

    //
    // use the right template
    //

    InfFileName[0] = L'\0';
    wcscpy(InfFileName, szWinDir);

    switch(ProductType){

    case VER_NT_WORKSTATION:
        wcscat(InfFileName, L"\\inf\\defltwk.inf");
        break;

    case VER_NT_DOMAIN_CONTROLLER:
        wcscat(InfFileName, L"\\inf\\defltdc.inf");
        break;

    case VER_NT_SERVER:
        wcscat(InfFileName, L"\\inf\\defltsv.inf");
        break;

    default:
        //
        // won't happen unless API is bad - default to wks
        //

        wcscat(InfFileName, L"\\inf\\defltwk.inf");

        break;
    }


    DatabaseName[0] = L'\0';
    wcscpy(DatabaseName, szWinDir);
    wcscat(DatabaseName, L"\\security\\database\\convert.sdb");

    //
    // condition in the loop will end when it sees the last two \0 s in a
    // MULTI_SZ string such as C:\0E:\0\0
    //

    for (PWSTR  pCurrDrive = pmszDriveNames; pCurrDrive[0] != L'\0' ; pCurrDrive += wcslen(pCurrDrive) + 1) {

        //
        // try next drive if this drive is not securable or if error in querying drive information
        //

        if (ERROR_SUCCESS != (rc = ScepExamineDriveInformation(pCurrDrive, LogFileName, &bSetSecurity))) {
            rcSave = rc;
            continue;
        }

        if (!bSetSecurity) {

            //
            // reset for next iteration
            //

            bSetSecurity = TRUE;
            continue;
        }

        ScepLogOutput3(0,0, SCEDLL_CONVERT_ROOT_NTFS_VOLUME, pCurrDrive);

        //
        // set security on userprofiles directory if root of profile dir == current drive
        // ignore if error - template will have ignore entry for Docs&settings
        //

        ScepSecureUserProfiles(pCurrDrive);

        if ( _wcsicmp(pszSystemDrive, pCurrDrive) == 0 ) {

                //
                // always use the same databases and log files for convert
                //

                //
                // check config options
                //

                rc = ScepServerConfigureSystem(
                                              InfFileName,
                                              DatabaseName,
                                              LogFileName,
                                              0,
                                              AREA_FILE_SECURITY
                                              );

                if (rc != ERROR_SUCCESS) {
                    ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_TEMPLATE_APPLY, rc, pCurrDrive);
                } else {
                    ScepLogOutput3(0,0, SCEDLL_CONVERT_SUCCESS_TEMPLATE_APPLY, pCurrDrive);
                }

                //
                // for now use MARTA to set root DACL (another possibility is to use root.inf when checked in)
                //

        }

        //
        // set root DACL - use MARTA to set security
        //

        if ( rc == ERROR_SUCCESS ) {
            //
            // extract DACL once only
            //

            SECURITY_INFORMATION SeInfo = 0;

            if (!bRootDaclExtracted) {

                rc = ScepExtractRootDacl(&pSDSet, &pDacl, &SeInfo);

                ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_DACL, rc, SDDLRoot);

            }

            if (rc == ERROR_SUCCESS) {

                WCHAR   szCurrDriveSlashed[MAX_PATH];

                memset(szCurrDriveSlashed, '\0', (MAX_PATH) * sizeof(WCHAR));
                wcsncpy(szCurrDriveSlashed, pCurrDrive, 5);
                wcscat(szCurrDriveSlashed, L"\\");

                bRootDaclExtracted = TRUE;

                rc = SetNamedSecurityInfo(szCurrDriveSlashed,
                                          SE_FILE_OBJECT,
                                          SeInfo,
                                          NULL,
                                          NULL,
                                          pDacl,
                                          NULL
                                         );

                if (rc != ERROR_SUCCESS) {
                    ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_MARTA, rc, szCurrDriveSlashed);
                } else {
                    ScepLogOutput3(0,0, SCEDLL_CONVERT_SUCCESS_MARTA, szCurrDriveSlashed);
                }

            }
        }

        if (rc != ERROR_SUCCESS) {
            LogEvent(MyModuleHandle,
                     STATUS_SEVERITY_INFORMATIONAL,
                     SCEEVENT_INFO_ERROR_CONVERT_DRIVE,
                     0,
                     pCurrDrive
                    );
        } else {
            LogEvent(MyModuleHandle,
                     STATUS_SEVERITY_INFORMATIONAL,
                     SCEEVENT_INFO_SUCCESS_CONVERT_DRIVE,
                     0,
                     pCurrDrive
                    );
        }

        if (rc != ERROR_SUCCESS) {
            rcSave = rc;
            rc = ERROR_SUCCESS;
        }

    }

    //
    // delete the value (done using this value)
    //

    ScepRegDeleteValue(
                      HKEY_LOCAL_MACHINE,
                      SCE_ROOT_PATH,
                      L"FatNtfsConvertedDrives"
                      );

    if (pSDSet) {
        LocalFree(pSDSet);
    }

    //
    // if scheduled, then services.exe allocated space - so free it
    //

    LocalFree(pmszDriveNames);

    ScepLogClose();


    //(void) ShutdownEvents();

    return;
}


DWORD
ScepExamineDriveInformation(
    IN  PWSTR   pszRootDrive,
    IN  PWSTR   LogFileName,
    OUT BOOL    *pbSetSecurity
    )
/*++

Routine Description:

    If drive type is remote or FAT, do not set security.

Arguments:

    pszRootDrive    - Name of drive (Null terminated)

    pbSetSecurity   - whether we should attempt to set security on this drive


Return:

    win32 error code
--*/
{

    UINT    DriveType;
    DWORD   FileSystemFlags;
    DWORD   rc = ERROR_SUCCESS;
    WCHAR   pszDriveNameWithSlash[MAX_PATH];

    if (pszRootDrive == NULL || pbSetSecurity == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // drives are of type c:\ only (cannot have drives of type cd:\)
    //

    memset(pszDriveNameWithSlash, '\0', MAX_PATH * sizeof(WCHAR));
    wcsncpy(pszDriveNameWithSlash, pszRootDrive, 5);
    wcscat(pszDriveNameWithSlash, L"\\");

    //
    // detect if the partition is FAT
    //
    DriveType = GetDriveType(pszDriveNameWithSlash);

    if ( DriveType == DRIVE_FIXED ||
         DriveType == DRIVE_RAMDISK ) {

        if ( GetVolumeInformation(pszDriveNameWithSlash,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL,
                                  &FileSystemFlags,
                                  NULL,
                                  0
                                 ) == TRUE ) {

            if ( !(FileSystemFlags & FS_PERSISTENT_ACLS)  ) {
                //
                // only set security on NTFS partition
                //
                ScepLogOutput3(0,0, SCEDLL_CONVERT_ROOT_NON_NTFS, pszRootDrive);

                *pbSetSecurity = FALSE;

            }

        } else {
            //
            // something is wrong
            //
            rc = GetLastError();

            ScepLogOutput3(0,0, SCEDLL_CONVERT_ROOT_ERROR_QUERY_VOLUME, rc, pszRootDrive);

            *pbSetSecurity = FALSE;

        }
    }
    else {
        //
        // do not set security on remote drives
        //
        ScepLogOutput3(0,0, SCEDLL_CONVERT_ROOT_NOT_FIXED_VOLUME, pszRootDrive);

        *pbSetSecurity = FALSE;

    }

    return(rc);
}



DWORD
ScepExtractRootDacl(
    OUT PSECURITY_DESCRIPTOR    *ppSDSet,
    OUT PACL    *ppDacl,
    OUT SECURITY_INFORMATION *pSeInfo
    )
/*++

Routine Description:

    Extract root dacl (binary) from golden SD in (in text)

Arguments:

    ppDacl    - pointer to pointer to converted binary dacl


Return:

    win32 error code (DWORD)
--*/
{

    DWORD   rc = ERROR_SUCCESS;
    DWORD   dwSize=0;
    BOOLEAN tFlag;
    BOOLEAN aclPresent;
    SECURITY_DESCRIPTOR_CONTROL Control=0;
    ULONG Revision;


    if ( ppSDSet == NULL || ppDacl == NULL || pSeInfo == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    rc = ConvertTextSecurityDescriptor (SDDLRoot,
                                        ppSDSet,
                                        &dwSize,
                                        pSeInfo
                                       );

    if (rc == ERROR_SUCCESS) {



        RtlGetControlSecurityDescriptor (
                *ppSDSet,
                &Control,
                &Revision
                );

        //
        // Get DACL address
        //

        *ppDacl = NULL;
        rc = RtlNtStatusToDosError(
                  RtlGetDaclSecurityDescriptor(
                                *ppSDSet,
                                &aclPresent,
                                ppDacl,
                                &tFlag));

        if (rc == NO_ERROR && !aclPresent )
            *ppDacl = NULL;

        //
        // if error occurs for this one, do not set. return
        //

        if ( Control & SE_DACL_PROTECTED ) {
            *pSeInfo |= PROTECTED_DACL_SECURITY_INFORMATION;
        }



    }

    return rc;

}


VOID
ScepWaitForServicesEventAndConvertSecurityThreadFunc(
    IN PVOID pV
    )
/*++

Routine Description:

    The main purpose of this thread is to wait for the autostart services event and thereafter call
    ScepConfigureConvertedFileSecurityThreadFunc to do the real configuration work

Arguments:

    pV              -  thread argument simply passed on to ScepConfigureConvertedFileSecurityThreadFunc

Return:

    none
--*/
{

    HANDLE  hConvertCanStartEvent = NULL;
    DWORD   Status;
    WCHAR   szWinDir[MAX_PATH*2 + 1];
    WCHAR   LogFileName[MAX_PATH + 1];

    szWinDir[0] = L'\0';

    if ( GetSystemWindowsDirectory( szWinDir, MAX_PATH ) == 0 ) {

        //
        // too bad if this happens - can't log anwhere
        //

        return;
    }

    //
    // same log file is used by this thread as well as the actual configuration
    // routine ScepConfigureConvertedFileSecurityThreadFunc (without passing handles)
    //

    LogFileName[0] = L'\0';
    wcscpy(LogFileName, szWinDir);
    wcscat(LogFileName, L"\\security\\logs\\convert.log");

    ScepEnableDisableLog(TRUE);

    ScepSetVerboseLog(3);

    if ( ScepLogInitialize( LogFileName ) == ERROR_INVALID_NAME ) {

        ScepLogOutput3(1,0, SCEDLL_LOGFILE_INVALID, LogFileName );

    }

    hConvertCanStartEvent =  OpenEvent(
                                SYNCHRONIZE,
                                FALSE,
                                SC_AUTOSTART_EVENT_NAME
                                );

    if (hConvertCanStartEvent == NULL) {

        ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_EVENT_HANDLE, GetLastError(), SC_AUTOSTART_EVENT_NAME);

        if (pV) {
            LocalFree(pV);
        }

        ScepLogClose();

        return;
    }

    //
    // timeout after 10 mins
    //

    Status = WaitForSingleObjectEx(
                                   hConvertCanStartEvent,
                                   10*60*1000,
                                   FALSE
                                   );
    //
    // done using the handle
    //

    CloseHandle(hConvertCanStartEvent);

    if (Status == WAIT_OBJECT_0) {

        ScepLogOutput3(0,0, SCEDLL_CONVERT_SUCCESS_EVENT_WAIT, SC_AUTOSTART_EVENT_NAME);

        //
        // close the log file - since ScepConfigureConvertedFileSecurityThreadFunc will
        // need to open a handle to the same log file
        //

        ScepLogClose();

        ScepConfigureConvertedFileSecurityReboot(pV);

    } else {

        ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_EVENT_WAIT, RtlNtStatusToDosError(Status), SC_AUTOSTART_EVENT_NAME);

        ScepLogClose();
    }

    ExitThread(RtlNtStatusToDosError(Status));

    return;

}

VOID
ScepSecureUserProfiles(
    PWSTR   pCurrDrive
    )
/*++

Routine Description:

    Configure Docs&Settings and folders under it

Arguments:

    None

Return:

    win32Error code
--*/
{
    DWORD   rc = ERROR_SUCCESS;
    WCHAR   szProfilesDir[MAX_PATH + 1];

    szProfilesDir[0] = L'\0';

    BOOL  bSecureUserProfiles = TRUE;

    if (pCurrDrive == NULL) {
        return;
    }

    DWORD   dwLen = MAX_PATH;
    //
    // don't care for error translating this environment variable -
    // just log and continue
    //

    if ( GetProfilesDirectory(szProfilesDir, &dwLen ) ){

        //
        // both strings are NULL terminated
        //

        ULONG uPosition;

        for ( uPosition = 0;
             szProfilesDir[uPosition] != L'\0' &&
             pCurrDrive[uPosition] != L'\0' &&
             szProfilesDir[uPosition] != L':' &&
             pCurrDrive[uPosition] != L':' &&
             towlower(szProfilesDir[uPosition]) ==  towlower(pCurrDrive[uPosition]);
             uPosition++ );

        if (!(uPosition > 0 &&
            szProfilesDir[uPosition] == L':' &&
            pCurrDrive[uPosition] == L':')) {

            //
            // only if mismatch happened, do not set user profiles
            //

            bSecureUserProfiles = FALSE;

        }

    }

    else {

        ScepLogOutput3(0,0, SCEDLL_CONVERT_BAD_ENV_VAR, L"%USERPROFILE%");

    }

    if ( bSecureUserProfiles ) {

        //
        // DetermineProfilesLocation secures Docs&Settings
        // SecureUserProfiles() secures folders under Docs&Settings
        //

        if ( DetermineProfilesLocation(FALSE) ){

            SecureUserProfiles();

        }

        else {

            rc = GetLastError();

        }

    }

    if ( bSecureUserProfiles ) {

        if ( rc == ERROR_SUCCESS ) {

            ScepLogOutput3(0,0, SCEDLL_CONVERT_SUCCESS_PROFILES_DIR, pCurrDrive);

        } else {

            ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_PROFILES_DIR, rc, pCurrDrive);

        }
    }

    return;
}




DWORD
ScepConfigureConvertedFileSecurityImmediate(
                                           IN PWSTR    pszDriveName
                                           )
/*++

Routine Description:

    The actual routine to configure setup style security for drives converted from FAT to NTFS.

    We are dealing only with a non system drive (whatever the OS maybe), we just use MARTA APIs to set
    security on the root drive (from scecli itself). Currently, this is the design since there is no
    reliable way of parsing the boot files (boot.ini/boot.nvr) and take care of dual boot scenarios.

    Note on error reporting:
        All errors are logged to the logfile %windir%\security\logs\convert.log. but if it is not possible
        to log an error to the logfile, we log it to the event log with source "SceSrv". Also, higher level
        errors/successes are logged to both the logfile and the eventlog.

    Note that this routine could be done in the client but due to commonality of the error logging,
    functionality etc, an RPC call is made to the server

Arguments:

    pszDriveName   -   Name of the volume to be converted
                        (not freed by services.exe - freed by convert.exe)


Return:

    win32 error code
--*/
{

    DWORD rc = ERROR_SUCCESS;
    DWORD rcSave = ERROR_SUCCESS;

    //
    // folders to use for logging etc.
    //

    WCHAR   szWinDir[MAX_PATH*2 + 1];
    WCHAR   LogFileName[MAX_PATH + 1];
    WCHAR   pszSystemDrive[MAX_PATH];

    //
    // other variables
    //

    BOOL    bImmediate;
    BOOL    bSetSecurity = TRUE;
    PSECURITY_DESCRIPTOR    pSDSet=NULL;
    PACL    pDacl=NULL;
    BOOLEAN bRootDaclExtracted = FALSE;

    //
    // before attempting to do any useful work, validate arguments for this thread etc.
    // todo - should we handle exceptions ?
    //
    (void) InitializeEvents(L"SceSrv");

    if (pszDriveName == NULL) {

        //
        // should not happen - parameters have been checked by all callers
        //

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEEVENT_ERROR_CONVERT_PARAMETER,
                 IDS_ERROR_CONVERT_PARAMETER
                );

        //(void) ShutdownEvents();

        return ERROR_INVALID_PARAMETER;
    }

    pszSystemDrive[0] = L'\0';

    //
    // ready the log file, logging level etc.
    //

    szWinDir[0] = L'\0';

    if ( GetSystemWindowsDirectory( szWinDir, MAX_PATH ) == 0 ) {

        //
        // too bad if this happens
        //

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEEVENT_ERROR_CONVERT_BAD_ENV_VAR,
                 IDS_ERROR_CONVERT_BAD_ENV_VAR,
                 L"%windir%"
                );

        //(void) ShutdownEvents();

        return ERROR_ENVVAR_NOT_FOUND;
    }

    LogFileName[0] = L'\0';
    wcscpy(LogFileName, szWinDir);
    wcscat(LogFileName, L"\\security\\logs\\convert.log");

    ScepEnableDisableLog(TRUE);

    ScepSetVerboseLog(3);

    if ( ScepLogInitialize( LogFileName ) == ERROR_INVALID_NAME ) {

        ScepLogOutput3(1,0, SCEDLL_LOGFILE_INVALID, LogFileName );

    }

    //
    // continue even if we cannot initialize log file but we absolutely
    // need the following environment var, so if we can't get it, quit
    //

    if ( GetEnvironmentVariable( L"SYSTEMDRIVE", pszSystemDrive, MAX_PATH) == 0 ) {

        ScepLogOutput3(0,0, SCEDLL_CONVERT_BAD_ENV_VAR, L"%SYSTEMDRIVE%");

        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_ERROR,
                 SCEEVENT_ERROR_CONVERT_BAD_ENV_VAR,
                 IDS_ERROR_CONVERT_BAD_ENV_VAR,
                 L"%systemdrive%"
                );

        ScepLogClose();

        //(void) ShutdownEvents();

        return ERROR_ENVVAR_NOT_FOUND;
    }

    //
    // called immediately (not reboot/scheduled conversion)
    // template never used here - only marta
    //

    PWSTR  pCurrDrive = pszDriveName;

    rc = ScepExamineDriveInformation(pCurrDrive, LogFileName, &bSetSecurity);

    if (rc == ERROR_SUCCESS && bSetSecurity) {

        ScepLogOutput3(0,0, SCEDLL_CONVERT_ROOT_NTFS_VOLUME, pCurrDrive);

        //
        // set security on userprofiles directory if root of profile dir == current drive
        //

        ScepSecureUserProfiles(pCurrDrive);

        //
        // non system drive - use MARTA to set security
        //

        //
        // extract DACL once only, potentially for multiple "other-OS" drives
        //

        SECURITY_INFORMATION SeInfo = 0;

        if (!bRootDaclExtracted) {

            rc = ScepExtractRootDacl(&pSDSet, &pDacl, &SeInfo);

            ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_DACL, rc, SDDLRoot);

        }

        if (rc == ERROR_SUCCESS) {

            WCHAR   szCurrDriveSlashed[MAX_PATH];

            szCurrDriveSlashed[0] = L'\0';
            wcscpy(szCurrDriveSlashed, pCurrDrive);
            wcscat(szCurrDriveSlashed, L"\\");

            bRootDaclExtracted = TRUE;

            rc = SetNamedSecurityInfo(szCurrDriveSlashed,
                                      SE_FILE_OBJECT,
                                      SeInfo,
                                      NULL,
                                      NULL,
                                      pDacl,
                                      NULL
                                     );

            if (rc != ERROR_SUCCESS) {
                ScepLogOutput3(0,0, SCEDLL_CONVERT_ERROR_MARTA, rc, szCurrDriveSlashed);
            } else {
                ScepLogOutput3(0,0, SCEDLL_CONVERT_SUCCESS_MARTA, szCurrDriveSlashed);
            }


        }

    }

    if (rc != ERROR_SUCCESS) {
        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_INFORMATIONAL,
                 SCEEVENT_INFO_ERROR_CONVERT_DRIVE,
                 0,
                 pCurrDrive
                );
    } else {
        LogEvent(MyModuleHandle,
                 STATUS_SEVERITY_INFORMATIONAL,
                 SCEEVENT_INFO_SUCCESS_CONVERT_DRIVE,
                 0,
                 pCurrDrive
                );
    }

    if (rc != ERROR_SUCCESS) {
        rcSave = rc;
    }


    if (pSDSet) {
        LocalFree(pSDSet);
    }

    ScepLogClose();

    //(void) ShutdownEvents();

    //    return rcSave;
    return rc ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\dumpnt.h ===
/*
 *	Dumpnt.h
 *
 *	Prototypes for functions in Dump.c
 *
 *	TimF	17-Sep-91
 */


VOID
Dump_ACE_FLAGS(
	IN	UCHAR			f
);


VOID
Dump_ACE_TYPE(
	IN	UCHAR			t
);


VOID
Dump_GROUP_ATTRIBUTES(
	IN	ULONG			a
);


VOID
Dump_OBJA_ATTRIBUTES(
	IN	ULONG			a
);


VOID
DumpACE(
	IN	ACE_HEADER		*a
);


VOID
DumpACL(
	IN	ACL			*a
);


VOID
DumpLARGE_INTEGER(
	IN	LARGE_INTEGER		*l
);


VOID
DumpOBJECT_ATTRIBUTES(
	IN	OBJECT_ATTRIBUTES	*o
);


VOID
DumpSID(
	IN	PSID			s
);


VOID
DumpSECURITY_DESCRIPTOR(
	IN	PSECURITY_DESCRIPTOR	s
);


VOID
DumpSECURITY_QUALITY_OF_SERVICE(
	IN	SECURITY_QUALITY_OF_SERVICE *s
);


VOID
DumpSTRING(
	IN	STRING			*a
);


VOID
DumpTIME(
	IN	TIME			*t
);


VOID
DumpTOKEN_DEFAULT_DACL(
	IN	TOKEN_DEFAULT_DACL	*d
);


VOID
DumpTOKEN_GROUPS(
	IN	TOKEN_GROUPS		*g
);


VOID
DumpTOKEN_OWNER(
	IN	TOKEN_OWNER		*p
);


VOID
DumpTOKEN_PRIMARY_GROUP(
	IN	TOKEN_PRIMARY_GROUP	*p
);


VOID
DumpTOKEN_PRIVILEGES(
	IN	TOKEN_PRIVILEGES	*p
);


VOID
DumpUNICODE_STRING(
	IN	UNICODE_STRING		*s
);


VOID
DumpTOKEN_USER(
	IN	TOKEN_USER		*p
);


VOID
DumpVM_COUNTERS(
	IN	VM_COUNTERS		*v
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\analyze.cpp ===
//depot/private/vishnup_branch/DS/security/services/scerpc/server/analyze.cpp#6 - edit change 937 (text)
/*++
Copyright (c) 1996 Microsoft Corporation

Module Name:

    analyze.c

Abstract:

    Routines to analyze a system. The analysis information is saved in memory

Author:

    Jin Huang (jinhuang) 25-Nov-1996

Revision History:

--*/

#include "headers.h"
#include "serverp.h"
#include "pfp.h"
#include "infp.h"
#include "service.h"
#include "regvalue.h"
#include "authz.h"
#if _WIN32_WINNT>=0x0500
#include "kerberos.h"
#endif
#include <aclapi.h>
#include <io.h>

#pragma hdrstop

#define Add2Ptr(pv, cb)  ((BYTE *) pv + cb)
#define PSD_BASE_LENGTH  100

//
// properties of SAP engine (thread safe variables)
//

#define SE_VALID_CONTROL_BITS ( SE_DACL_UNTRUSTED | \
                                SE_SERVER_SECURITY | \
                                SE_DACL_AUTO_INHERIT_REQ | \
                                SE_SACL_AUTO_INHERIT_REQ | \
                                SE_DACL_AUTO_INHERITED | \
                                SE_SACL_AUTO_INHERITED | \
                                SE_DACL_PROTECTED | \
                                SE_SACL_PROTECTED )

extern PSCECONTEXT  Thread          hProfile;
PSCESECTION  Thread                 hSection=NULL;
extern AUTHZ_RESOURCE_MANAGER_HANDLE ghAuthzResourceManager;


DWORD Thread BadCnt;
DWORD Thread gOptions=0;


static  PWSTR AccessItems[] = {
        {(PWSTR)TEXT("MinimumPasswordAge")},
        {(PWSTR)TEXT("MaximumPasswordAge")},
        {(PWSTR)TEXT("MinimumPasswordLength")},
        {(PWSTR)TEXT("PasswordComplexity")},
        {(PWSTR)TEXT("PasswordHistorySize")},
        {(PWSTR)TEXT("LockoutBadCount")},
        {(PWSTR)TEXT("ResetLockoutCount")},
        {(PWSTR)TEXT("LockoutDuration")},
        {(PWSTR)TEXT("RequireLogonToChangePassword")},
        {(PWSTR)TEXT("ForceLogoffWhenHourExpire")},
        {(PWSTR)TEXT("ClearTextPassword")},
        {(PWSTR)TEXT("LSAAnonymousNameLookup")},
        {(PWSTR)TEXT("EnableAdminAccount")},
        {(PWSTR)TEXT("EnableGuestAccount")}
        };

#define MAX_ACCESS_ITEMS        sizeof(AccessItems)/sizeof(PWSTR)

#define IDX_MIN_PASS_AGE        0
#define IDX_MAX_PASS_AGE        1
#define IDX_MIN_PASS_LEN        2
#define IDX_PASS_COMPLEX        3
#define IDX_PASS_HISTORY        4
#define IDX_LOCK_COUNT          5
#define IDX_RESET_COUNT         6
#define IDX_LOCK_DURATION       7
#define IDX_CHANGE_PASS         8
#define IDX_FORCE_LOGOFF        9
#define IDX_CLEAR_PASS          10
#define IDX_LSA_ANON_LOOKUP     11
#define IDX_ENABLE_ADMIN       12
#define IDX_ENABLE_GUEST       13

static PWSTR LogItems[]={
        {(PWSTR)TEXT("MaximumLogSize")},
        {(PWSTR)TEXT("AuditLogRetentionPeriod")},
        {(PWSTR)TEXT("RetentionDays")},
        {(PWSTR)TEXT("RestrictGuestAccess")}
        };

#define MAX_LOG_ITEMS           4

#define IDX_MAX_LOG_SIZE        0
#define IDX_RET_PERIOD          1
#define IDX_RET_DAYS            2
#define IDX_RESTRICT_GUEST      3

static PWSTR EventItems[]={
        {(PWSTR)TEXT("AuditSystemEvents")},
        {(PWSTR)TEXT("AuditLogonEvents")},
        {(PWSTR)TEXT("AuditObjectAccess")},
        {(PWSTR)TEXT("AuditPrivilegeUse")},
        {(PWSTR)TEXT("AuditPolicyChange")},
        {(PWSTR)TEXT("AuditAccountManage")},
        {(PWSTR)TEXT("AuditProcessTracking")},
        {(PWSTR)TEXT("AuditDSAccess")},
        {(PWSTR)TEXT("AuditAccountLogon")}};

#define MAX_EVENT_ITEMS         9

#define IDX_AUDIT_SYSTEM        0
#define IDX_AUDIT_LOGON         1
#define IDX_AUDIT_OBJECT        2
#define IDX_AUDIT_PRIV          3
#define IDX_AUDIT_POLICY        4
#define IDX_AUDIT_ACCOUNT       5
#define IDX_AUDIT_PROCESS       6
#define IDX_AUDIT_DS            7
#define IDX_AUDIT_ACCT_LOGON    8

//
// forward references
//

SCESTATUS
ScepAnalyzeInitialize(
    IN PCWSTR InfFileName OPTIONAL,
    IN PWSTR DatabaseName,
    IN BOOL bAdminLogon,
    IN AREA_INFORMATION Area,
    IN DWORD AnalyzeOptions
    );

SCESTATUS
ScepAnalyzeStart(
    IN AREA_INFORMATION Area,
    IN BOOL bSystemDb
    );

NTSTATUS
ScepAdminGuestAccountsToManage(
    IN SAM_HANDLE DomainHandle,
    IN DWORD AccountType,
    IN PWSTR TargetName OPTIONAL,
    OUT PBOOL ToRename,
    OUT PWSTR *CurrentName OPTIONAL,
    OUT PDWORD pNameLen OPTIONAL
    );

SCESTATUS
ScepAnalyzePrivileges(
    IN PSCE_PRIVILEGE_ASSIGNMENT pPrivilegeList
    );

DWORD
ScepGetLSAPolicyObjectInfo(
    OUT  DWORD   *pdwAllow
    );

/*
NTSTATUS
ScepGetCurrentPrivilegesRights(
    IN LSA_HANDLE   PolicyHandle,
    IN SAM_HANDLE   BuiltinDomainHandle,
    IN PSID         BuiltinDomainSid,
    IN SAM_HANDLE   DomainHandle,
    IN PSID         DomainSid,
    IN SAM_HANDLE   UserHandle OPTIONAL,
    IN PSID         AccountSid,
    OUT PDWORD      PrivilegeRights,
    OUT PSCE_NAME_STATUS_LIST *pPrivList
    );
*/
SCESTATUS
ScepAddAllBuiltinGroups(
    IN PSCE_GROUP_MEMBERSHIP *pGroupList
    );

SCESTATUS
ScepAnalyzeGroupMembership(
    IN PSCE_GROUP_MEMBERSHIP pGroupMembership
    );

NTSTATUS
ScepCompareMembersOfGroup(
    IN SAM_HANDLE       DomainHandle,
    IN PSID             ThisDomainSid,
    IN LSA_HANDLE       PolicyHandle,
    IN SID_NAME_USE     GrpUse,
    IN SAM_HANDLE       GroupHandle,
    IN PSCE_NAME_LIST    pChkMembers,
    OUT PSCE_NAME_LIST   *ppMembers,
    OUT PBOOL           bDifferent
    );

SCESTATUS
ScepEnumerateRegistryRoots(
    OUT PSCE_OBJECT_LIST *pRoots
    );

SCESTATUS
ScepEnumerateFileRoots(
    OUT PSCE_OBJECT_LIST *pRoots
    );

SCESTATUS
ScepAnalyzeObjectSecurity(
    IN PSCE_OBJECT_LIST pObjectCheckList,
    IN AREA_INFORMATION Area,
    IN BOOL bSystemDb
    );

DWORD
ScepAnalyzeOneObjectInTree(
    IN PSCE_OBJECT_TREE ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    );

DWORD
ScepAnalyzeObjectOnly(
    IN PWSTR ObjectFullName,
    IN BOOL IsContainer,
    IN SE_OBJECT_TYPE ObjectType,
    IN PSECURITY_DESCRIPTOR ProfileSD,
    IN SECURITY_INFORMATION ProfileSeInfo
    );

DWORD
ScepGetFileSecurityInfo(
    IN  HANDLE                 Handle,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * pSecurityDescriptor
    );

DWORD
ScepGetSecurityDescriptorParts(
    IN PISECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SECURITY_INFORMATION SecurityInfo,
    OUT PSECURITY_DESCRIPTOR *pOutSecurityDescriptor
    );

DWORD
ScepGetKeySecurityInfo(
    IN  HANDLE Handle,
    IN  SECURITY_INFORMATION SecurityInfo,
    OUT PSECURITY_DESCRIPTOR *pSecurityDescriptor
    );

DWORD
ScepAnalyzeObjectAndChildren(
    IN PWSTR ObjectFullName,
    IN SE_OBJECT_TYPE ObjectType,
    IN PSECURITY_DESCRIPTOR ProfileSD,
    IN SECURITY_INFORMATION ProfileSeInfo
    );

SCESTATUS
ScepAnalyzeSystemAuditing(
    IN PSCE_PROFILE_INFO pSmpInfo,
    IN PPOLICY_AUDIT_EVENTS_INFO auditEvent
    );

SCESTATUS
ScepAnalyzeDeInitialize(
    IN SCESTATUS  rc,
    IN DWORD Options
    );

NTSTATUS
ScepGetPDCName(
    OUT PUNICODE_STRING pPDCName
    );

SCESTATUS
ScepMigrateDatabaseRevision0(
    IN PSCECONTEXT cxtProfile
    );

SCESTATUS
ScepMigrateDatabaseRevision1(
    IN PSCECONTEXT cxtProfile
    );

SCESTATUS
ScepMigrateObjectSection(
    IN PSCECONTEXT cxtProfile,
    IN PCWSTR szSection
    );

SCESTATUS
ScepMigrateOneSection(
    PSCESECTION hSection
    );

SCESTATUS
ScepMigrateLocalTableToTattooTable(
   IN PSCECONTEXT hProfile
   );

SCESTATUS
ScepMigrateDatabase(
    IN PSCECONTEXT cxtProfile,
    IN BOOL bSystemDb
    );

SCESTATUS
ScepDeleteOldRegValuesFromTable(
    IN PSCECONTEXT hProfile,
    IN SCETYPE TableType
    );

BOOL
ScepCompareSidNameList(
    IN PSCE_NAME_LIST pList1,
    IN PSCE_NAME_LIST pList2
    );
DWORD
ScepConvertSidListToStringName(
    IN LSA_HANDLE LsaPolicy,
    IN OUT PSCE_NAME_LIST pList
    );

BOOL
ScepCompareGroupNameList(
    IN PUNICODE_STRING DomainName,
    IN PSCE_NAME_LIST pListToCmp,
    IN PSCE_NAME_LIST pList
    );

SCESTATUS
ScepGetSystemPrivileges(
    IN DWORD Options,
    IN OUT PSCE_ERROR_LOG_INFO *pErrLog,
    OUT PSCE_PRIVILEGE_ASSIGNMENT *pCurrent
    );

//
// function implementations
//

SCESTATUS
ScepAnalyzeSystem(
    IN PCWSTR InfFileName OPTIONAL,
    IN PWSTR DatabaseName,
    IN DWORD AnalyzeOptions,
    IN BOOL bAdminLogon,
    IN AREA_INFORMATION Area,
    IN PDWORD pdWarning OPTIONAL,
    IN PWSTR InfRollback OPTIONAL
    )
/*++
Routine Description:

   This routine is the exported API to analyze a system and save mismatched/
   unknown information to the SAP profile. If any error occurs when loading SMP
   information into memory, this routine will stop, free memmory, and return
   the error code. If a error occurs when analyze an area, it will stop analyze.
   All successful and fail transactions will be logged to the logfile(or stdout).

   All analysis information is saved to a SAP profile with a date/time stamp.

   All old analysis information is cleared before new SAP information is saved.

Arguments:

    InfFileName -   The file name of a SCP used to compare the analysis of a system

    DatabaseName -   The JET analysis database name. If NULL, default is used.

    AnalyzeOptions - options to analyze

    bAdminLogon    - if the current calling thread is in administrator's logon

    Area -          One or more areas to configure.
                      AREA_SECURITY_POLICY
                      AREA_USER_SETTINGS
                      AREA_GROUP_MEMBERSHIP
                      AREA_REGISTRY_SECURITY
                      AREA_SYSTEM_SERVICE
                      AREA_FILE_SECURITY

    pdWarning      - the warning level

Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_NOT_ENOUGH_RESOURCE
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_ALREADY_RUNNING

    Status from ScepGetDatabaseInfo

-- */
{
    SCESTATUS            rc;

    if ( AnalyzeOptions & SCE_GENERATE_ROLLBACK ) {

         if ( InfRollback == NULL )
             return SCESTATUS_INVALID_PARAMETER;

         //
         // check if we can write to the file first
         //
         rc = ScepVerifyTemplateName(InfRollback, NULL);

         if ( rc != ERROR_SUCCESS )
             return ScepDosErrorToSceStatus(rc);

         Area = Area & ( AREA_SECURITY_POLICY |
                          AREA_GROUP_MEMBERSHIP |
                          AREA_PRIVILEGES |
                          AREA_SYSTEM_SERVICE);
    }

    rc = ScepAnalyzeInitialize(
                InfFileName,
                DatabaseName,
                bAdminLogon,
                Area,
                AnalyzeOptions
                );

    if ( rc != SCESTATUS_SUCCESS ) {

        ScepLogOutput3(0,0, SCEDLL_SAP_INIT_ERROR);

        ScepPostProgress(gTotalTicks, 0, NULL);

    } else {
        ScepLogOutput3(0,0, SCEDLL_SAP_INIT_SUCCESS);

        if ( !(AnalyzeOptions & SCE_RE_ANALYZE) &&
             (AnalyzeOptions & SCE_NO_ANALYZE) ) {
//            && hProfile &&
//             ( (hProfile->Type & 0xF0L) == SCEJET_MERGE_TABLE_1 ||
//               (hProfile->Type & 0xF0L) == SCEJET_MERGE_TABLE_2 ) ) {
            //
            // there is "merged" policy table already, do not query any policy
            //
            ScepLogOutput3(0, 0, IDS_NO_ANALYSIS);

        } else {

            BOOL bSystemDb = FALSE;

            if ( bAdminLogon &&
                 ( AnalyzeOptions & SCE_SYSTEM_DB) ) {

                bSystemDb = TRUE;
            }

            rc = ScepAnalyzeStart( Area, bSystemDb);

            if ( AnalyzeOptions & SCE_GENERATE_ROLLBACK ) {
                //
                // export the settings in SMP to the INF file
                //

                if ( !WritePrivateProfileSection(
                                    L"Version",
                                    L"signature=\"$CHICAGO$\"\0Revision=1\0\0",
                                    (LPCTSTR)InfRollback) ) {

                    rc = ScepDosErrorToSceStatus(GetLastError());
                } else {

                    HINSTANCE  hSceCliDll = LoadLibrary(TEXT("scecli.dll"));

                    if ( hSceCliDll ) {

                        PFSCEINFWRITEINFO pfSceInfWriteInfo = (PFSCEINFWRITEINFO)GetProcAddress(
                                                               hSceCliDll,
                                                               "SceWriteSecurityProfileInfo");

                        if ( pfSceInfWriteInfo ) {

                            PSCE_ERROR_LOG_INFO  pErrlog=NULL, pErr;
                            PSCE_PROFILE_INFO pSmpInfo=NULL;

                            //
                            // get from database
                            //
                            rc = ScepGetDatabaseInfo(
                                        hProfile,
                                        SCE_ENGINE_SMP,
                                        Area,
                                        0,
                                        &pSmpInfo,
                                        &pErrlog
                                        );

                            if ( rc == SCESTATUS_SUCCESS && pSmpInfo ) {
                                //
                                // write it into the template
                                //
                                rc = (*pfSceInfWriteInfo) (
                                        InfRollback,
                                        Area,
                                        pSmpInfo,
                                        &pErrlog
                                        );
                            }
                            //
                            // log error
                            //
                            for ( pErr=pErrlog; pErr != NULL; pErr = pErr->next ) {

                                if ( pErr->buffer != NULL ) {

                                    ScepLogOutput2(1, pErr->rc, pErr->buffer );
                                }
                            }

                            //
                            // free buffer
                            //
                            ScepFreeErrorLog(pErrlog);

                            if ( pSmpInfo ) {
                                SceFreeProfileMemory(pSmpInfo);
                            }

                        } else {
                            rc = ScepDosErrorToSceStatus(GetLastError());
                        }

                        FreeLibrary(hSceCliDll);

                    } else {
                        rc = ScepDosErrorToSceStatus(GetLastError());
                    }
                }

                if ( rc != SCESTATUS_SUCCESS ) {
                    ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                                   SCEDLL_ERROR_GENERATE,
                                   InfRollback
                                   );
                }
                //
                // empty local policy table
                //
                ScepDeleteInfoForAreas(
                          hProfile,
                          SCE_ENGINE_SMP,
                          AREA_ALL
                          );
            }

        }

    }

    ScepLogOutput3(0,0, SCEDLL_SAP_UNINIT);

    if ( pdWarning ) {
        *pdWarning = gWarningCode;
    }

    //
    // return failure if invalid data is found in the template
    //
    if ( gbInvalidData ) {
        rc = SCESTATUS_INVALID_DATA;
    }

    ScepAnalyzeDeInitialize( rc, AnalyzeOptions );

    return(rc);
}



SCESTATUS
ScepAnalyzeStart(
    IN AREA_INFORMATION Area,
    IN BOOL bSystemDb
    )
/*
Routine Description:

    Analyze the system (the real work)

Arguments:

    Area - the security areas to analyze

Return Value:

    SCESTATUS
*/
{
    SCESTATUS            rc;
    SCESTATUS            Saverc=SCESTATUS_SUCCESS;
    SCE_PROFILE_INFO     SmpInfo;
    PSCE_PROFILE_INFO    pSmpInfo=NULL;
    PPOLICY_AUDIT_EVENTS_INFO     auditEvent=NULL;
    BOOL                 bAuditOff=FALSE;
    PBYTE                pFullAudit = NULL;

    pSmpInfo = &SmpInfo;
    memset(pSmpInfo, '\0', sizeof(SCE_PROFILE_INFO));

    //
    // turn off object access auditing if file/key is to be configured
    // in system context.
    //
    if ( (Area & AREA_FILE_SECURITY) || (Area & AREA_REGISTRY_SECURITY) )
        bAuditOff = TRUE;

    //
    // if set, this regkey will decide to audit all
    //
    ScepRegQueryBinaryValue(
         HKEY_LOCAL_MACHINE,
         L"System\\CurrentControlSet\\Control\\Lsa",
         L"fullprivilegeauditing",
         &pFullAudit
         );

    if (pFullAudit) {
        if (*pFullAudit & (BYTE)1)
            bAuditOff = FALSE;
        ScepFree(pFullAudit);
    }

    rc = ScepSaveAndOffAuditing(&auditEvent, bAuditOff, NULL);

//    if ( rc != SCESTATUS_SUCCESS )
//        goto Done;
// if auditing can't be turned on for some reason, e.g., access denied for
// normal user, just continue (actually normal user shouldn't turn off auditing

    //
    // privileges
    //
    if ( Area & AREA_PRIVILEGES ) {

        ScepPostProgress(0, AREA_PRIVILEGES, NULL);

        ScepLogOutput3(0,0, SCEDLL_SAP_READ_PROFILE);

        rc = ScepGetProfileOneArea(
                   hProfile,
                   bSystemDb ? SCE_ENGINE_SCP : SCE_ENGINE_SMP,
                   AREA_PRIVILEGES,
                   SCE_ACCOUNT_SID,
                   &pSmpInfo
                   );

        if ( rc == SCESTATUS_SUCCESS ) {

            ScepLogOutput3(0,0, SCEDLL_SAP_BEGIN_PRIVILEGES);

            rc = ScepAnalyzePrivileges( pSmpInfo->OtherInfo.smp.pPrivilegeAssignedTo);

            SceFreeMemory((PVOID)pSmpInfo, AREA_PRIVILEGES );

        } else {

            ScepPostProgress(TICKS_PRIVILEGE, AREA_PRIVILEGES, NULL);
        }

        if( rc != SCESTATUS_SUCCESS ) {
            Saverc = rc;
            ScepLogOutput3(0,0, SCEDLL_SAP_PRIVILEGES_ERROR);
        } else {
            ScepLogOutput3(0,0, SCEDLL_SAP_PRIVILEGES_SUCCESS);
        }

    }

    //
    // Group membership
    //

    if ( ( Area & AREA_GROUP_MEMBERSHIP) &&
         !(gOptions & SCE_NO_ANALYZE) ) {

        ScepPostProgress(0, AREA_GROUP_MEMBERSHIP, NULL);

        ScepLogOutput3(0,0, SCEDLL_SAP_READ_PROFILE);

        rc = ScepGetProfileOneArea(
                   hProfile,
                   bSystemDb ? SCE_ENGINE_SCP : SCE_ENGINE_SMP,
                   AREA_GROUP_MEMBERSHIP,
                   SCE_ACCOUNT_SID,
                   &pSmpInfo
                   );
// need to support nested groups
        if ( rc == SCESTATUS_SUCCESS ) {
            ScepLogOutput3(0,0, SCEDLL_SAP_BEGIN_GROUPMGMT);

            //
            // Prepare a JET section
            //
            rc = ScepStartANewSection(
                        hProfile,
                        &hSection,
                        (gOptions & SCE_GENERATE_ROLLBACK) ? SCEJET_TABLE_SMP : SCEJET_TABLE_SAP,
                        szGroupMembership
                        );

            if ( rc == SCESTATUS_SUCCESS ) {

                //
                // analyze all builtin groups, what is the baseline for them ?
                // don't care if errors
                //
                if ( !(gOptions & SCE_GENERATE_ROLLBACK) ) {
                    ScepAddAllBuiltinGroups(&(pSmpInfo->pGroupMembership));
                }

#if _WIN32_WINNT>=0x0500
                if ( ProductType == NtProductLanManNt ) {

                    rc = ScepAnalyzeDsGroups( pSmpInfo->pGroupMembership );

                    //
                    // some groups may not be analyzed by the DS function
                    // so do it again here
                    //
                    SCESTATUS rc2 = ScepAnalyzeGroupMembership( pSmpInfo->pGroupMembership );
                    if ( SCESTATUS_SUCCESS != rc2 )
                        rc = rc2;

                } else {
#endif

                    //
                    // workstation or NT4 DCs
                    //
                    rc = ScepAnalyzeGroupMembership( pSmpInfo->pGroupMembership );

#if _WIN32_WINNT>=0x0500
                }
#endif

            } else {

                ScepPostProgress(TICKS_GROUPS, AREA_GROUP_MEMBERSHIP, NULL);

                ScepLogOutput3(0, ScepSceStatusToDosError(rc),
                               SCEDLL_ERROR_OPEN, (PWSTR)szGroupMembership);
            }

            SceFreeMemory((PVOID)pSmpInfo, AREA_GROUP_MEMBERSHIP );

        } else {
            ScepPostProgress(TICKS_GROUPS, AREA_GROUP_MEMBERSHIP, NULL);
        }

        if( rc != SCESTATUS_SUCCESS ) {
            Saverc = rc;
            ScepLogOutput3(0,0, SCEDLL_SAP_GROUPMGMT_ERROR);
        } else {
            ScepLogOutput3(0,0, SCEDLL_SAP_GROUPMGMT_SUCCESS);
        }

    }

    //
    // Registry Security area
    // do not support snapshot and rollback
    //

    if ( Area & AREA_REGISTRY_SECURITY &&
         !(gOptions & SCE_NO_ANALYZE) &&
         !(gOptions & SCE_GENERATE_ROLLBACK ) ) {

        ScepPostProgress(0, AREA_REGISTRY_SECURITY, NULL);

        ScepLogOutput3(0,0, SCEDLL_SAP_READ_PROFILE);

        rc = ScepGetProfileOneArea(
                   hProfile,
                   bSystemDb ? SCE_ENGINE_SCP : SCE_ENGINE_SMP,
                   AREA_REGISTRY_SECURITY,
                   0,
                   &pSmpInfo
                   );

        if ( rc == SCESTATUS_SUCCESS ) {

            ScepLogOutput3(0,0, SCEDLL_SAP_BEGIN_REGISTRY);

            rc = ScepEnumerateRegistryRoots(&(pSmpInfo->pRegistryKeys.pOneLevel));

            if ( rc == SCESTATUS_SUCCESS ) {
                rc = ScepAnalyzeObjectSecurity(pSmpInfo->pRegistryKeys.pOneLevel,
                                              AREA_REGISTRY_SECURITY,
                                              bSystemDb
                                             );
            } else {
                ScepPostProgress(gMaxRegTicks, AREA_REGISTRY_SECURITY, NULL);
            }

            SceFreeMemory((PVOID)pSmpInfo, AREA_REGISTRY_SECURITY);
        } else {

            ScepPostProgress(gMaxRegTicks, AREA_REGISTRY_SECURITY, NULL);
        }

        if( rc != SCESTATUS_SUCCESS ) {
            Saverc = rc;
            ScepLogOutput3(0,0, SCEDLL_SAP_REGISTRY_ERROR);
        } else {
            ScepLogOutput3(0,0, SCEDLL_SAP_REGISTRY_SUCCESS);
        }
    }

    //
    // File Security area
    // do not support snapshot and rollback
    //

    if ( Area & AREA_FILE_SECURITY &&
         !(gOptions & SCE_NO_ANALYZE) &&
         !(gOptions & SCE_GENERATE_ROLLBACK)) {

        ScepPostProgress(0, AREA_FILE_SECURITY, NULL);

        ScepLogOutput3(0,0, SCEDLL_SAP_READ_PROFILE);

        rc = ScepGetProfileOneArea(
                   hProfile,
                   bSystemDb ? SCE_ENGINE_SCP : SCE_ENGINE_SMP,
                   AREA_FILE_SECURITY,
                   0,
                   &pSmpInfo
                   );

        if ( rc == SCESTATUS_SUCCESS ) {

            ScepLogOutput3(0,0, SCEDLL_SAP_BEGIN_FILE);

            rc = ScepEnumerateFileRoots(&(pSmpInfo->pFiles.pOneLevel));

            if ( rc == SCESTATUS_SUCCESS ) {
                rc = ScepAnalyzeObjectSecurity(pSmpInfo->pFiles.pOneLevel,
                                              AREA_FILE_SECURITY,
                                              bSystemDb
                                             );
            } else {

                ScepPostProgress(gMaxFileTicks, AREA_FILE_SECURITY, NULL);
            }
            SceFreeMemory((PVOID)pSmpInfo, AREA_FILE_SECURITY);

        } else {
            ScepPostProgress(gMaxFileTicks, AREA_FILE_SECURITY, NULL);
        }

        if( rc != SCESTATUS_SUCCESS ) {
            Saverc = rc;
            ScepLogOutput3(0,0, SCEDLL_SAP_FILE_ERROR);
        } else {
            ScepLogOutput3(0,0, SCEDLL_SAP_FILE_SUCCESS);
        }
    }

    //
    // System Service area
    //

    if ( Area & AREA_SYSTEM_SERVICE &&
         !(gOptions & SCE_NO_ANALYZE) ) {

        ScepPostProgress(0, AREA_SYSTEM_SERVICE, NULL);

        ScepLogOutput3(0,0, SCEDLL_SAP_BEGIN_GENERALSVC);

        rc = ScepAnalyzeGeneralServices( hProfile, gOptions);

        if( rc != SCESTATUS_SUCCESS ) {
            Saverc = rc;
            ScepLogOutput3(0,0, SCEDLL_SAP_GENERALSVC_ERROR);
        } else {
            ScepLogOutput3(0,0, SCEDLL_SAP_GENERALSVC_SUCCESS);
        }

        if ( !(gOptions & SCE_GENERATE_ROLLBACK) ) {
            //
            // attachments
            //
            ScepLogOutput3(0,0, SCEDLL_SAP_BEGIN_ATTACHMENT);

            rc = ScepInvokeSpecificServices( hProfile, FALSE, SCE_ATTACHMENT_SERVICE );

            if( rc != SCESTATUS_SUCCESS && SCESTATUS_SERVICE_NOT_SUPPORT != rc ) {
                Saverc = rc;
                ScepLogOutput3(0,0, SCEDLL_SAP_ATTACHMENT_ERROR);
            } else {
                ScepLogOutput3(0,0, SCEDLL_SAP_ATTACHMENT_SUCCESS);
            }
        }
    }

    //
    // System Access area
    //
    if ( Area & AREA_SECURITY_POLICY ) {

        ScepPostProgress(0, AREA_SECURITY_POLICY, NULL);

        ScepLogOutput3(0,0, SCEDLL_SAP_READ_PROFILE);

        rc = ScepGetProfileOneArea(
                   hProfile,
                   bSystemDb ? SCE_ENGINE_SCP : SCE_ENGINE_SMP,
                   AREA_SECURITY_POLICY,
                   0,
                   &pSmpInfo
                   );
        if ( rc == SCESTATUS_SUCCESS ) {

            ScepLogOutput3(0,0, SCEDLL_SAP_BEGIN_POLICY);

            rc = ScepAnalyzeSystemAccess( pSmpInfo, NULL, 0, NULL, NULL );

            //
            // in setup fresh installed, SAM domain can't be opened
            // because computer name is changed. In this case
            // do not log error because nothing needs to be analyzed
            //
            if ( !(gOptions & SCE_NO_ANALYZE) ||
                 (rc != SCESTATUS_SERVICE_NOT_SUPPORT) ) {

                if( rc != SCESTATUS_SUCCESS ) {
                    Saverc = rc;
                    ScepLogOutput3(0,0, SCEDLL_SAP_ACCESS_ERROR);
                } else {
                    ScepLogOutput3(0,0, SCEDLL_SAP_ACCESS_SUCCESS);
                }
            }

            ScepPostProgress(TICKS_SYSTEM_ACCESS,
                             AREA_SECURITY_POLICY,
                             (LPTSTR)szSystemAccess);

            //
            // System Auditing area
            //
            rc = ScepAnalyzeSystemAuditing( pSmpInfo, auditEvent );

            if( rc != SCESTATUS_SUCCESS ) {
                Saverc = rc;

                ScepLogOutput3(0,0, SCEDLL_SAP_AUDIT_ERROR);
            } else {
                ScepLogOutput3(0,0, SCEDLL_SAP_AUDIT_SUCCESS);
            }

            ScepPostProgress(TICKS_SYSTEM_AUDITING,
                             AREA_SECURITY_POLICY,
                             (LPTSTR)szAuditEvent);

#if _WIN32_WINNT>=0x0500
            if ( ProductType == NtProductLanManNt &&
                 !(gOptions & SCE_NO_ANALYZE) ) {

                //
                // analyze kerberos policy
                //
                rc = ScepAnalyzeKerberosPolicy( hProfile, pSmpInfo->pKerberosInfo, gOptions );

                if( rc != SCESTATUS_SUCCESS ) {
                    Saverc = rc;
                    ScepLogOutput3(0,0, SCEDLL_SAP_KERBEROS_ERROR);
                } else {
                    ScepLogOutput3(0,0, SCEDLL_SAP_KERBEROS_SUCCESS);
                }

            }
#endif
            ScepPostProgress(TICKS_KERBEROS,
                             AREA_SECURITY_POLICY,
                             (LPTSTR)szKerberosPolicy);
            //
            // analyze registry values
            //
            DWORD RegFlag;
            if ( gOptions & SCE_NO_ANALYZE ) RegFlag = SCEREG_VALUE_SNAPSHOT;
            else if ( gOptions & SCE_GENERATE_ROLLBACK ) RegFlag = SCEREG_VALUE_ROLLBACK;
            else RegFlag = SCEREG_VALUE_ANALYZE;

            rc = ScepAnalyzeRegistryValues( hProfile,
                                            RegFlag,
                                            pSmpInfo
                                          );

            if( rc != SCESTATUS_SUCCESS ) {
                Saverc = rc;
                ScepLogOutput3(0,0, SCEDLL_SAP_REGVALUES_ERROR);
            } else {
                ScepLogOutput3(0,0, SCEDLL_SAP_REGVALUES_SUCCESS);
            }

            ScepPostProgress(TICKS_REGISTRY_VALUES,
                             AREA_SECURITY_POLICY,
                             (LPTSTR)szRegistryValues);

            SceFreeMemory((PVOID)pSmpInfo, AREA_SECURITY_POLICY);

        } else {

            ScepPostProgress(TICKS_SECURITY_POLICY_DS, AREA_SECURITY_POLICY, NULL);

            Saverc = rc;
            ScepLogOutput3(0,0, SCEDLL_SAP_POLICY_ERROR);
        }

        ScepLogOutput3(0,0, SCEDLL_SAP_BEGIN_ATTACHMENT);

        if ( !(gOptions & SCE_NO_ANALYZE) &&
             !(gOptions & SCE_GENERATE_ROLLBACK) ) {
            //
            // attachments
            //

            rc = ScepInvokeSpecificServices( hProfile, FALSE, SCE_ATTACHMENT_POLICY );

            if( rc != SCESTATUS_SUCCESS && SCESTATUS_SERVICE_NOT_SUPPORT != rc ) {
                Saverc = rc;
                ScepLogOutput3(0,0, SCEDLL_SAP_ATTACHMENT_ERROR);
            } else {
                ScepLogOutput3(0,0, SCEDLL_SAP_ATTACHMENT_SUCCESS);
            }
        } else {

            ScepPostProgress(TICKS_SPECIFIC_POLICIES, AREA_SECURITY_POLICY, NULL);
        }
    }

    if ( NULL != auditEvent && bAuditOff ) {
        //
        // turn auditing back on if it was on
        //
        if ( auditEvent->AuditingMode )
            rc = ScepRestoreAuditing(auditEvent,NULL);

        LsaFreeMemory(auditEvent);
    }

    return(Saverc);

}



NTSTATUS
ScepGetPDCName(
    OUT PUNICODE_STRING pPDCName
    )
/*
Routine Description:

    This routine retrieve the primary domain name of current system.

Arguments:

    pPDCName - output buffer to hold primary domain name

Return Value:

    NTSTATUS
*/
{
    NTSTATUS                     NtStatus;
    PPOLICY_PRIMARY_DOMAIN_INFO  pPrimaryDomain=NULL;
    LSA_HANDLE                   LsaHandle=NULL;

    //
    // Open the LSA policy
    //
    NtStatus = ScepOpenLsaPolicy(
                POLICY_VIEW_LOCAL_INFORMATION,
                &LsaHandle,
                TRUE
                );

    if ( NT_SUCCESS( NtStatus) ) {

        //
        // query primary domain policy
        //
        NtStatus = LsaQueryInformationPolicy(
                        LsaHandle,
                        PolicyPrimaryDomainInformation,
                        (PVOID *)&pPrimaryDomain
                        );
        if ( NT_SUCCESS( NtStatus) ) {

            if ( pPDCName->Length > 0 ) {
                RtlFreeUnicodeString( pPDCName );
                pPDCName->Length = 0;
            }
            RtlCreateUnicodeString(pPDCName, pPrimaryDomain->Name.Buffer);

            LsaFreeMemory(pPrimaryDomain);
        }

    }

    LsaClose( LsaHandle );

    return(NtStatus);
}



SCESTATUS
ScepAnalyzeInitialize(
    IN PCWSTR InfFileName OPTIONAL,
    IN PWSTR DatabaseName,
    IN BOOL bAdminLogon,
    IN AREA_INFORMATION Area,
    IN DWORD AnalyzeOptions
    )
/* ++

Routine Description:

     This routine initializes the SAP engine.

Arguments:

      InfFileName -         The file name of a SCP file used to compare with the sytem

      DatabaseName -         The Jet analysis database name

      bAdminLogon  -     if administrator logs on

      AnalyzeOptions -      The flag to indicate if the template should be appended to the
                            existing database if one exists

      Area           - security area to analyze

Return value:

      SCESTATUS_SUCCESS
      SCESTATUS_INVALID_PARAMETER
      SCESTATUS_PROFILE_NOT_FOUND
      SCESTATUS_NOT_ENOUGH_RESOURCE
      SCESTATUS_ALREADY_RUNNING

-- */
{

    SCESTATUS            rc=SCESTATUS_SUCCESS;
    PCHAR                FileName=NULL;
    DWORD                MBLen=0;
    NTSTATUS            NtStatus;
    DWORD               NameLen=MAX_COMPUTERNAME_LENGTH;
    PSCE_ERROR_LOG_INFO  Errlog=NULL;
    DWORD               SCPLen=0, DefLen=0;
    PWSTR               BaseProfile=NULL;

    PSECURITY_DESCRIPTOR pSD=NULL;
    SECURITY_INFORMATION SeInfo;
    DWORD                SDsize;
    SCEJET_CREATE_TYPE   DbFlag;
    HKEY hCurrentUser=NULL;

    //
    // database name can't be NULL because it's already resolved
    //

    if ( !DatabaseName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    BOOL bSetupDb = (bAdminLogon && (AnalyzeOptions & SCE_NO_ANALYZE) && (AnalyzeOptions & SCE_SYSTEM_DB));

    //
    // get other system values
    //

    if ( RtlGetNtProductType (&ProductType) == FALSE ) {
        rc = ScepDosErrorToSceStatus(GetLastError());
        goto Leave;
    }

    gTotalTicks = 4*TICKS_MIGRATION_SECTION+TICKS_MIGRATION_V11;
    gCurrentTicks = 0;
    gWarningCode = 0;
    gbInvalidData = FALSE;
    cbClientFlag = (BYTE)(AnalyzeOptions & (SCE_CALLBACK_DELTA |
                                            SCE_CALLBACK_TOTAL));


    DefLen = wcslen(DatabaseName);

    if ( InfFileName != NULL ) {

        SCPLen = wcslen(InfFileName);
    }

    //
    // Open the file
    //

    NtStatus = RtlUnicodeToMultiByteSize(&MBLen, DatabaseName, DefLen*sizeof(WCHAR));

    if ( !NT_SUCCESS(NtStatus) ) {
        //
        // cannot get the length, set default to 512
        //
        MBLen = 512;
    }

    FileName = (PCHAR)ScepAlloc(LPTR, MBLen+2);

    if ( FileName == NULL ) {
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        goto Leave;
    }

    NtStatus = RtlUnicodeToMultiByteN(
                    FileName,
                    MBLen+1,
                    NULL,
                    DatabaseName,
                    DefLen*sizeof(WCHAR)
                    );
    if ( !NT_SUCCESS(NtStatus) ) {
        ScepLogOutput3(3, RtlNtStatusToDosError(NtStatus),
                       SCEDLL_ERROR_PROCESS_UNICODE, DatabaseName );
        rc = ScepDosErrorToSceStatus( RtlNtStatusToDosError(NtStatus) );
        goto Leave;
    }

    //
    // if the tattoo table doesn't exist yet, the call will still return success
    //
    rc = SceJetOpenFile(
                (LPSTR)FileName,
                (AnalyzeOptions & SCE_GENERATE_ROLLBACK) ? SCEJET_OPEN_READ_WRITE : SCEJET_OPEN_EXCLUSIVE,
                bSetupDb ? SCE_TABLE_OPTION_TATTOO : 0,
                &hProfile
                );

    //
    // if database exist with wrong format, migrate it
    // if it's the system database, delete everything since info there is not needed
    // migrate the database
    //
    SDsize = 0;

    if ( (SCESTATUS_BAD_FORMAT == rc) &&
         !(AnalyzeOptions & SCE_GENERATE_ROLLBACK) ) {

        //
        // should this in transaction ???
        //

        rc = SceJetOpenFile(
                    (LPSTR)FileName,
                    SCEJET_OPEN_NOCHECK_VERSION,
                    0,
                    &hProfile
                    );

        if ( SCESTATUS_SUCCESS == rc ) {

            rc = ScepMigrateDatabase( hProfile, bSetupDb );


            if ( rc != SCESTATUS_BAD_FORMAT ) {
                //
                // old or current version, migrated
                //

                if ( rc != SCESTATUS_SUCCESS ) {
                    ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                                   SCEDLL_ERROR_CONVERT, DatabaseName);
                }
                SDsize = 1;

            } // else newer version, not migrated

        } else {

            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_OPEN, DatabaseName);

            rc = SCESTATUS_BAD_FORMAT;
        }

        if ( SDsize == 0 ) {

            ScepPostProgress(4*TICKS_MIGRATION_SECTION+TICKS_MIGRATION_V11, 0, NULL);
        }

        if ( rc != SCESTATUS_SUCCESS ) {
            goto Leave;
        }

    } else if ( SCESTATUS_SUCCESS == rc && bSetupDb ) {
        //
        // for system database, check to see if the database contain tattoo table
        //
        if ( hProfile->JetSapID != JET_tableidNil ) {

            //
            // if the tattoo table already exists, this is the latest database
            // nothing needs to be done to migrate
            // but we need to make sure that for domain controllers, the tattoo
            // table does not contain filtered policies (user rights, account policies)
            //

            if ( ProductType == NtProductLanManNt ) {

                //
                // empty tattoo policy settings
                //
                ScepDeleteInfoForAreas(
                      hProfile,
                      SCE_ENGINE_SAP,  // tattoo table
                      AREA_PRIVILEGES
                      );
                //
                // delete szSystemAccess section info
                //
                ScepDeleteOneSection(
                         hProfile,
                         SCE_ENGINE_SAP,
                         szSystemAccess
                         );

                //
                // delete szAuditEvent section info
                //
                ScepDeleteOneSection(
                         hProfile,
                         SCE_ENGINE_SAP,
                         szAuditEvent
                         );

                //
                // delete szKerberosPolicy section info
                //
                ScepDeleteOneSection(
                         hProfile,
                         SCE_ENGINE_SAP,
                         szKerberosPolicy
                         );

                ScepLogOutput2(0, 0, L"Empty tattoo table on domain controllers");
            }
        } else {
            //
            // create the tattoo table and move data from local table to the tattoo table
            // for the settings defined in merged policy
            //

            rc = SceJetCreateTable(
                            hProfile,
                            "SmTblTattoo",
                            SCEJET_TABLE_TATTOO,
                            SCEJET_CREATE_IN_BUFFER,
                            NULL,
                            NULL
                            );
            if ( SCESTATUS_SUCCESS == rc &&
                 ( (hProfile->Type & 0xF0L) == SCEJET_MERGE_TABLE_1 ||
                   (hProfile->Type & 0xF0L) == SCEJET_MERGE_TABLE_2 ) ) {
                //
                // effective policy table exist
                // migrate local policy to tattoo table
                // do not care errors
                // note, on domain controllers, user rights are not migrated
                //
                ScepMigrateLocalTableToTattooTable(hProfile);

                ScepLogOutput2(0, 0, L"Migrate local table to tattoo table");
            }
        }
        //
        // empty local policy settings
        //
        if ( SCESTATUS_SUCCESS == rc )
            ScepDeleteInfoForAreas(
                  hProfile,
                  SCE_ENGINE_SMP,
                  AREA_ALL
                  );

        ScepPostProgress(4*TICKS_MIGRATION_SECTION+TICKS_MIGRATION_V11, 0, NULL);

    } else {

        ScepPostProgress(4*TICKS_MIGRATION_SECTION+TICKS_MIGRATION_V11, 0, NULL);
    }

    //
    // Logic to determine what to do with the template
    //
    //  if InfFileName provided
    //      if Jet database exist (either the default, or the DatabaseName)
    //
    //          if append flag is on
    //              append the template on top of the database then continue to analyze
    //
    //          else if DatabaseName provided
    //              overwrite the database then continue to analyze
    //          else
    //              log an error to ignore the template, then continue to analyze
    //      else
    //          overwrite the database then continue to analyze
    //  else
    //      if Jet database exist
    //          continue to analyze
    //      else if query system settings
    //          create the database then query settings
    //      else
    //          error out
    //

    //
    // the HKEY_CURRENT_USER may be linked to .default
    // depends on the current calling process
    //
    if ( RegOpenCurrentUser(
                KEY_READ | KEY_WRITE,
                &hCurrentUser
                ) != ERROR_SUCCESS ) {

        hCurrentUser = NULL;
    }

    if ( hCurrentUser == NULL ) {
        hCurrentUser = HKEY_CURRENT_USER;
    }

    if ( rc == SCESTATUS_SUCCESS &&
         (SCPLen <= 0 || ((AnalyzeOptions & SCE_OVERWRITE_DB) &&
                          (AnalyzeOptions & SCE_SYSTEM_DB))) ) {
        //
        // database exists with no template or
        // database exists with template but template is overwriting to the existing database
        //
        if ( SCPLen > 0 && (AnalyzeOptions & SCE_OVERWRITE_DB) &&
                           (AnalyzeOptions & SCE_SYSTEM_DB)) {
            ScepLogOutput3(0,0, SCEDLL_SAP_IGNORE_TEMPLATE);
        }
        //
        // continue the analysis
        //
    } else {

        if ( rc != SCESTATUS_SUCCESS && SCPLen <= 0 ) {
            //
            // database does not exist, and template is not provided
            // if SCE_NO_ANALYZE is provided, query the system,
            // otherwise, error out, rc is the error, will be logged later

            if ( AnalyzeOptions & SCE_NO_ANALYZE ) {

                if ( DatabaseName != NULL && DefLen > 0 ) {

                    rc = ConvertTextSecurityDescriptor (
                                    L"D:P(A;CIOI;GRGW;;;WD)(A;CIOI;GA;;;BA)",
                                    &pSD,
                                    &SDsize,
                                    &SeInfo
                                    );
                    if ( rc != NO_ERROR )
                        ScepLogOutput3(1, rc, SCEDLL_ERROR_BUILD_SD, DatabaseName );

                    ScepChangeAclRevision(pSD, ACL_REVISION);

                    ScepCreateDirectory(
                            DatabaseName,
                            FALSE,      // a file name
                            pSD        // take parent's security setting
                            );
                    if ( pSD )
                        ScepFree(pSD);

                }

                rc = SceJetCreateFile(
                            (LPSTR)FileName,
                            SCEJET_OPEN_DUP_EXCLUSIVE,
                            SCE_TABLE_OPTION_TATTOO,
                            &hProfile
                            );
            }

        } else {

            if ( rc == SCESTATUS_SUCCESS && SCPLen > 0 &&
                (AnalyzeOptions & SCE_UPDATE_DB ) ) {

                //
                // database exist, template provided to append
                //

                DbFlag = SCEJET_OPEN_DUP_EXCLUSIVE;

            } else if ( AnalyzeOptions & SCE_GENERATE_ROLLBACK ) {

                DbFlag = SCEJET_OPEN_DUP;

            } else {

                DbFlag = SCEJET_OVERWRITE_DUP;
            }

            //
            // database exist and opened, will be closed when calling CreateFile
            //

            //
            // InfFileName must exist when gets here.
            //
            ScepLogOutput3(3, 0, SCEDLL_PROCESS_TEMPLATE, (PWSTR)InfFileName );

            //
            // make sure the directories exist for the file
            //
            if ( DatabaseName != NULL && DefLen > 0 ) {

                rc = ConvertTextSecurityDescriptor (
                                L"D:P(A;CIOI;GRGW;;;WD)(A;CIOI;GA;;;BA)",
                                &pSD,
                                &SDsize,
                                &SeInfo
                                );
                if ( rc != NO_ERROR )
                    ScepLogOutput3(1, rc, SCEDLL_ERROR_BUILD_SD, DatabaseName );

                ScepChangeAclRevision(pSD, ACL_REVISION);

                ScepCreateDirectory(
                        DatabaseName,
                        FALSE,      // a file name
                        pSD        // take parent's security setting
                        );
                if ( pSD )
                    ScepFree(pSD);

            }


            //
            // close the database
            //
            SceJetCloseFile( hProfile, FALSE, FALSE );

            rc = SceJetConvertInfToJet(
                    InfFileName,
                    (LPSTR)FileName,
                    DbFlag,
                    bAdminLogon ?
                       AnalyzeOptions :
                       (AnalyzeOptions & ~SCE_SYSTEM_DB),
                    Area
                    );

            if ( rc != SCESTATUS_SUCCESS ) {
                goto Leave;
            }

            rc = SceJetOpenFile(
                        (LPSTR)FileName,
                        (AnalyzeOptions & SCE_GENERATE_ROLLBACK) ? SCEJET_OPEN_READ_WRITE : SCEJET_OPEN_EXCLUSIVE,
                        0,
                        &hProfile
                       );

            if ( rc == SCESTATUS_SUCCESS ) {

                rc = ScepRegSetValue(
                        bAdminLogon ?
                            HKEY_LOCAL_MACHINE : hCurrentUser,
                        SCE_ROOT_PATH,
                        L"TemplateUsed",
                        REG_SZ,
                        (BYTE *)InfFileName,
                        SCPLen*sizeof(WCHAR)
                        );
                if ( rc != NO_ERROR )  // Win32 error code
                    ScepLogOutput3(1, rc, SCEDLL_ERROR_SAVE_REGISTRY, L"TemplateUsed");

                rc = SCESTATUS_SUCCESS;
            }
        }
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_OPEN, DatabaseName);
            goto Leave;
        }

    }

    rc = ScepRegSetValue(
            bAdminLogon ? HKEY_LOCAL_MACHINE : hCurrentUser,
            SCE_ROOT_PATH,
            L"LastUsedDatabase",
            REG_SZ,
            (BYTE *)DatabaseName,
            DefLen*sizeof(WCHAR)
            );
    if ( rc != NO_ERROR )
        ScepLogOutput3(1, rc, SCEDLL_ERROR_SAVE_REGISTRY, L"LastUsedDatabase");

    //
    // query the total ticks of this analysis
    //
    rc = ScepGetTotalTicks(
                NULL,
                hProfile,
                Area,
                SCE_FLAG_ANALYZE,
                &gTotalTicks
                );
    if ( SCESTATUS_SUCCESS != rc &&
         SCESTATUS_RECORD_NOT_FOUND != rc ) {

        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                     SCEDLL_TOTAL_TICKS_ERROR);
    }

    gTotalTicks += (4*TICKS_MIGRATION_SECTION+TICKS_MIGRATION_V11);

    //
    // start a new SAP table.
    // Note here the backup SAP is controlled by the transaction
    //
/* // Maximal version store is 64K by default.
    rc = SceJetStartTransaction( hProfile );

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepLogOutput2(0, 0, L"Cannot start a transaction");
        goto Leave;
    }
*/
    gOptions = AnalyzeOptions;

    if ( !(AnalyzeOptions & SCE_NO_ANALYZE) &&
                !(AnalyzeOptions & SCE_GENERATE_ROLLBACK) ) {

        rc = SceJetDeleteTable( hProfile, "SmTblSap", SCEJET_TABLE_SAP );

        if ( SCESTATUS_ACCESS_DENIED != rc ) {

            rc = SceJetCreateTable(
                     hProfile,
                     "SmTblSap",
                     SCEJET_TABLE_SAP,
                     SCEJET_CREATE_IN_BUFFER,
                     NULL,
                     NULL
                     );
        }

        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_ERROR_CREATE, L"SAP.");
            goto Leave;
        }

    }

    ScepIsDomainLocal(NULL);

Leave:

    if ( hCurrentUser && hCurrentUser != HKEY_CURRENT_USER ) {
        RegCloseKey(hCurrentUser);
    }

    if ( FileName ) {
        ScepFree(FileName);
    }
    return(rc);

}

SCESTATUS
ScepMigrateLocalTableToTattooTable(
   IN PSCECONTEXT hProfile
   )
/*
   Copy settings from local policy table to tattoo policy table
   if the settings exist in effective table.

   on domain controllers, privileges are not migrated because we do not
   want to handle the tattoo problem for domain controllers.

   hProfile is opened with tattoo table.
*/
{

   //
   // delete old registry values from SMP table (because they are
   // moved to new location). Don't care error
   //
   ScepDeleteOldRegValuesFromTable( hProfile, SCE_ENGINE_SMP );
   ScepDeleteOldRegValuesFromTable( hProfile, SCE_ENGINE_SCP );

   SCESTATUS rc=SCESTATUS_SUCCESS;

   //
   // now move the table
   //
   PSCE_ERROR_LOG_INFO  Errlog=NULL;

   rc = ScepCopyLocalToMergeTable(hProfile, 0,
                                  SCE_LOCAL_POLICY_MIGRATE |
                                     ((ProductType == NtProductLanManNt) ? SCE_LOCAL_POLICY_DC : 0),
                                  &Errlog );

   ScepLogWriteError( Errlog,1 );
   ScepFreeErrorLog( Errlog );
   Errlog = NULL;

   if ( rc != SCESTATUS_SUCCESS )
       ScepLogOutput2(1,ScepSceStatusToDosError(rc),L"Error occurred in migration");

   return(rc);
}


SCESTATUS
ScepAnalyzeSystemAccess(
    IN OUT PSCE_PROFILE_INFO pSmpInfo,
    IN PSCE_PROFILE_INFO pScpInfo OPTIONAL,
    IN DWORD dwSaveOption,
    OUT BOOL *pbChanged,
    IN OUT PSCE_ERROR_LOG_INFO *pErrLog
    )
/* ++

Routine Description:

   This routine analyzies the system security in the area of system access
   which includes account policy, rename admin/guest accounts, and some
   registry values.

Arguments:

   pSmpInfo - The buffer which contains SMP information to compare with
                If dwSaveOption is set to non zero, the difference is saved
                in this buffer to output

   pScpInfo - If dwSaveOption is set to non zero, pScpInfo may be present to
                be used (as effective policy) to compare with

   dwSaveOption    - used by policy filter when to query policy difference
                    SCEPOL_SYSTEM_SETTINGS - query for system setting mode
                    SCEPOL_SAVE_DB - policy filter for local database
                    SCEPOL_SAVE_BUFFER - policy filter for GPO mode (DC)
                    0 - analyze mode

   pbChanged    - TRUE if there is any policy changed

Return value:

   SCESTATUS_SUCCESS
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER

-- */
{
    SCESTATUS   rc=SCESTATUS_SUCCESS;
    SCESTATUS   saveRc=rc;
    NTSTATUS    NtStatus;

    SAM_HANDLE  DomainHandle=NULL,
                ServerHandle=NULL,
                UserHandle1=NULL;
    PSID        DomainSid=NULL;

    PVOID       Buffer=NULL;
    DWORD       BaseVal;
    PWSTR       RegBuf=NULL;
    DWORD       CurrentVal;
    BOOL        ToRename=FALSE;
    DWORD   dwAllow = 0;


    if ( dwSaveOption &&
         !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS) &&
         (pbChanged == NULL) ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }
    //
    // Open account domain
    //

    NtStatus = ScepOpenSamDomain(
                        SAM_SERVER_READ | SAM_SERVER_EXECUTE,
                        DOMAIN_READ | DOMAIN_EXECUTE,
                        &ServerHandle,
                        &DomainHandle,
                        &DomainSid,
                        NULL,
                        NULL
                       );
    rc = RtlNtStatusToDosError( NtStatus );
    if (!NT_SUCCESS(NtStatus)) {

        if ( !(gOptions & SCE_NO_ANALYZE) && ( ERROR_NO_SUCH_DOMAIN == rc ) ) {

            ScepLogOutput3(1, 0, IDS_NO_ANALYSIS_FRESH);
            return(SCESTATUS_SERVICE_NOT_SUPPORT);

        } else {

            if ( pErrLog ) {
                ScepBuildErrorLogInfo(
                    rc,
                    pErrLog,
                    SCEDLL_ACCOUNT_DOMAIN
                    );
            }

            ScepLogOutput3(1, rc, SCEDLL_ACCOUNT_DOMAIN);
            return( ScepDosErrorToSceStatus(rc) );
        }
    }

    PSCE_PROFILE_INFO pTmpInfo=pSmpInfo;

    if ( !dwSaveOption ) {

        //
        // Prepare a new section
        //
        BOOL bSaveSnapshot = FALSE;
        if ( (gOptions & SCE_NO_ANALYZE) ||
             (gOptions & SCE_GENERATE_ROLLBACK ) ) {
            bSaveSnapshot = TRUE;
        }

        rc = ScepStartANewSection(
                    hProfile,
                    &hSection,
                    bSaveSnapshot ? SCEJET_TABLE_SMP : SCEJET_TABLE_SAP,
                    szSystemAccess
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_SAP_START_SECTION, (PWSTR)szSystemAccess);
            goto GETOUT;
        }

    } else if ( pScpInfo ) {
        //
        // if saved in buffer (policy filter), should compare with effective
        // policy to determine if anything changed
        //
        pTmpInfo = pScpInfo;
    }

    DWORD AccessValues[MAX_ACCESS_ITEMS];

    for ( CurrentVal=0; CurrentVal<MAX_ACCESS_ITEMS; CurrentVal++ ) {
        AccessValues[CurrentVal] = SCE_ERROR_VALUE;
    }

    //
    // Get the current password settings...
    //

    Buffer=NULL;
    NtStatus = SamQueryInformationDomain(
                  DomainHandle,
                  DomainPasswordInformation,
                  &Buffer
                  );

    rc = RtlNtStatusToDosError( NtStatus );
    if ( NT_SUCCESS(NtStatus) ) {

        rc = SCESTATUS_SUCCESS;

        CurrentVal = ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MinPasswordLength;
        BaseVal = pTmpInfo->MinimumPasswordLength;

        if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {

            pSmpInfo->MinimumPasswordLength = CurrentVal;

        } else if ( dwSaveOption ) {

            if ( ( CurrentVal != BaseVal ) &&
                 ( BaseVal != SCE_NO_VALUE) ) {

                pSmpInfo->MinimumPasswordLength = CurrentVal;
                *pbChanged = TRUE;
            } else if ( dwSaveOption & SCEPOL_SAVE_DB ) {
                //
                // turn this item off to indicate this one is not changed
                //
                pSmpInfo->MinimumPasswordLength = SCE_NO_VALUE;
            }

        } else {

            rc = ScepCompareAndSaveIntValue(
                       hSection,
                       L"MinimumPasswordLength",
                       (gOptions & SCE_GENERATE_ROLLBACK),
                       (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : BaseVal,
                       CurrentVal);

            if ( rc == SCESTATUS_SUCCESS &&
                 !(gOptions & SCE_NO_ANALYZE) ) {
                AccessValues[IDX_MIN_PASS_LEN] = CurrentVal;
            }
        }

        if ( rc == SCESTATUS_SUCCESS ) {

            CurrentVal = ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordHistoryLength;
            BaseVal = pTmpInfo->PasswordHistorySize;

            if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {

                pSmpInfo->PasswordHistorySize = CurrentVal;

            } else if ( dwSaveOption ) {

                if ( ( CurrentVal != BaseVal ) &&
                     ( BaseVal != SCE_NO_VALUE) )  {
                    pSmpInfo->PasswordHistorySize = CurrentVal;
                    *pbChanged = TRUE;
                } else if ( dwSaveOption & SCEPOL_SAVE_DB ) {
                    //
                    // turn this item off to indicate this one is not changed
                    //
                    pSmpInfo->PasswordHistorySize = SCE_NO_VALUE;
                }

            } else {

                rc = ScepCompareAndSaveIntValue(
                           hSection,
                           L"PasswordHistorySize",
                           (gOptions & SCE_GENERATE_ROLLBACK),
                           (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : BaseVal,
                           CurrentVal
                           );
                if ( rc == SCESTATUS_SUCCESS &&
                     !(gOptions & SCE_NO_ANALYZE) ) {
                    AccessValues[IDX_PASS_HISTORY] = CurrentVal;
                }
            }

            if ( rc == SCESTATUS_SUCCESS ) {

                if ( (gOptions & SCE_GENERATE_ROLLBACK) &&
                     (pTmpInfo->MaximumPasswordAge == SCE_NO_VALUE) &&
                     (pTmpInfo->MinimumPasswordAge == SCE_NO_VALUE) ) {
                    //
                    // generate rollback template. These two are not defined
                    // no need to query/compare
                    //
                } else {

                    if ( ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MaxPasswordAge.HighPart == MINLONG &&
                         ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MaxPasswordAge.LowPart == 0 ) {

                        //
                        // Maximum password age value is MINLONG,0
                        //

                        CurrentVal = SCE_FOREVER_VALUE;

                    }  else {

                        CurrentVal = (DWORD) (-1 * (((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MaxPasswordAge.QuadPart /
                                                       (LONGLONG)(10000000L)) );
                        CurrentVal /= 3600;
                        CurrentVal /= 24;

                    }

                    BaseVal = pTmpInfo->MaximumPasswordAge;

                    if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {

                        pSmpInfo->MaximumPasswordAge = CurrentVal;

                    } else if ( dwSaveOption ) {

                        if ( ( CurrentVal != BaseVal ) &&
                             ( BaseVal != SCE_NO_VALUE) )  {
                            pSmpInfo->MaximumPasswordAge = CurrentVal;
                            *pbChanged = TRUE;
                        } else if ( dwSaveOption & SCEPOL_SAVE_DB ) {
                            //
                            // turn this item off to indicate this one is not changed
                            //
                            pSmpInfo->MaximumPasswordAge = SCE_NO_VALUE;
                        }

                    } else {

                        rc = ScepCompareAndSaveIntValue(
                                   hSection,
                                   L"MaximumPasswordAge",
                                   FALSE,
                                   (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : BaseVal,
                                   CurrentVal);

                        if ( rc == SCESTATUS_SUCCESS &&
                             !(gOptions & SCE_NO_ANALYZE) ) {
                            AccessValues[IDX_MAX_PASS_AGE] = CurrentVal;
                        }
                    }

                    if ( rc == SCESTATUS_SUCCESS ) {

                        CurrentVal = (DWORD) (-1 * (((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MinPasswordAge.QuadPart /
                                                          (LONGLONG)(10000000L)) );
                        CurrentVal /= 3600;
                        CurrentVal /= 24;

                        BaseVal = pTmpInfo->MinimumPasswordAge;

                        if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {

                            pSmpInfo->MinimumPasswordAge = CurrentVal;

                        } else if ( dwSaveOption ) {

                            if ( ( CurrentVal != BaseVal ) &&
                                 ( BaseVal != SCE_NO_VALUE) )  {
                                pSmpInfo->MinimumPasswordAge = CurrentVal;
                                *pbChanged = TRUE;
                            } else if ( dwSaveOption & SCEPOL_SAVE_DB ) {
                                //
                                // turn this item off to indicate this one is not changed
                                //
                                pSmpInfo->MinimumPasswordAge = SCE_NO_VALUE;
                            }

                        } else {

                            rc = ScepCompareAndSaveIntValue(
                                       hSection,
                                       L"MinimumPasswordAge",
                                       FALSE,
                                       (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : BaseVal,
                                       CurrentVal);

                            if ( rc == SCESTATUS_SUCCESS &&
                                 !(gOptions & SCE_NO_ANALYZE) ) {
                                AccessValues[IDX_MIN_PASS_AGE] = CurrentVal;
                            }
                        }
                    }
                }

                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // Password Complexity
                    //
                    if ( ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordProperties &
                         DOMAIN_PASSWORD_COMPLEX )
                        CurrentVal = 1;
                    else
                        CurrentVal = 0;

                    BaseVal = pTmpInfo->PasswordComplexity;

                    if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {

                        pSmpInfo->PasswordComplexity = CurrentVal;

                    } else if ( dwSaveOption ) {

                        if ( ( CurrentVal != BaseVal ) &&
                             ( BaseVal != SCE_NO_VALUE) )  {
                            pSmpInfo->PasswordComplexity = CurrentVal;
                            *pbChanged = TRUE;
                        } else if ( dwSaveOption & SCEPOL_SAVE_DB ) {
                            //
                            // turn this item off to indicate this one is not changed
                            //
                            pSmpInfo->PasswordComplexity = SCE_NO_VALUE;
                        }

                    } else {

                        rc = ScepCompareAndSaveIntValue(
                                hSection,
                                L"PasswordComplexity",
                                (gOptions & SCE_GENERATE_ROLLBACK),
                                (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : BaseVal,
                                CurrentVal);

                        if ( rc == SCESTATUS_SUCCESS &&
                             !(gOptions & SCE_NO_ANALYZE) ) {
                            AccessValues[IDX_PASS_COMPLEX] = CurrentVal;
                        }
                    }

                    if ( rc == SCESTATUS_SUCCESS ) {
                        //
                        // RequireLogonToChangePassword
                        //
                        if ( ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordProperties &
                             DOMAIN_PASSWORD_NO_ANON_CHANGE )
                            CurrentVal = 1;
                        else
                            CurrentVal = 0;

                        BaseVal = pTmpInfo->RequireLogonToChangePassword;

                        if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {

                            pSmpInfo->RequireLogonToChangePassword = CurrentVal;

                        } else if ( dwSaveOption ) {

                            if ( ( CurrentVal != BaseVal ) &&
                                 ( BaseVal != SCE_NO_VALUE) ) {
                                pSmpInfo->RequireLogonToChangePassword = CurrentVal;
                                *pbChanged = TRUE;
                            } else if ( dwSaveOption & SCEPOL_SAVE_DB ) {
                                //
                                // turn this item off to indicate this one is not changed
                                //
                                pSmpInfo->RequireLogonToChangePassword = SCE_NO_VALUE;
                            }

                        } else {

                            rc = ScepCompareAndSaveIntValue(
                                    hSection,
                                    L"RequireLogonToChangePassword",
                                    (gOptions & SCE_GENERATE_ROLLBACK),
                                    (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : BaseVal,
                                    CurrentVal);

                            if ( rc == SCESTATUS_SUCCESS &&
                                 !(gOptions & SCE_NO_ANALYZE) ) {
                                AccessValues[IDX_CHANGE_PASS] = CurrentVal;
                            }
                        }
#if _WIN32_WINNT>=0x0500
                        if ( rc == SCESTATUS_SUCCESS ) {
                            //
                            // Clear Text Password
                            //
                            CurrentVal = 0;

                            if ( ( (ProductType == NtProductLanManNt) ||
                                   (ProductType == NtProductServer ) ) &&
                                 (gOptions & SCE_NO_ANALYZE) ) {
                                //
                                // NT4 DC upgrade, check the registry value
                                //
                                CurrentVal = 0;

                                rc = ScepRegQueryIntValue(
                                            HKEY_LOCAL_MACHINE,
                                            L"System\\CurrentControlSet\\Control\\Lsa\\MD5-CHAP",
                                            L"Store Cleartext Passwords",
                                            &CurrentVal
                                            );

                                if ( rc != SCESTATUS_SUCCESS ) {
                                    CurrentVal = 0;
                                    rc = SCESTATUS_SUCCESS;
                                }

                            }

                            if ( CurrentVal == 0 ) {
                                // if not NT4 DC upgrade, or clear text password disabled on NT4

                                if ( ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordProperties &
                                     DOMAIN_PASSWORD_STORE_CLEARTEXT  ) {

                                    CurrentVal = 1;
                                } else {

                                    CurrentVal = 0;
                                }
                            }

                            BaseVal = pTmpInfo->ClearTextPassword;

                            if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {

                                pSmpInfo->ClearTextPassword = CurrentVal;

                            } else if ( dwSaveOption ) {

                                if ( ( CurrentVal != BaseVal ) &&
                                     ( BaseVal != SCE_NO_VALUE) ) {
                                    pSmpInfo->ClearTextPassword = CurrentVal;
                                    *pbChanged = TRUE;
                                } else if ( dwSaveOption & SCEPOL_SAVE_DB ) {
                                    //
                                    // turn this item off to indicate this one is not changed
                                    //
                                    pSmpInfo->ClearTextPassword = SCE_NO_VALUE;
                                }

                            } else {
                                rc = ScepCompareAndSaveIntValue(
                                        hSection,
                                        L"ClearTextPassword",
                                        (gOptions & SCE_GENERATE_ROLLBACK),
                                        (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : BaseVal,
                                        CurrentVal);

                                if ( rc == SCESTATUS_SUCCESS &&
                                     !(gOptions & SCE_NO_ANALYZE) ) {
                                    AccessValues[IDX_CLEAR_PASS] = CurrentVal;
                                }
                            }
                        }
#else

                        AccessValues[IDX_CLEAR_PASS] = 1;
#endif
                    }
                }
            }
        }

        SamFreeMemory(Buffer);

        if ( rc != SCESTATUS_SUCCESS ) {
            saveRc = rc;
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                            SCEDLL_SAP_ERROR_PASSWORD);

            if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS) ) {
                //
                // if it's not getting system setting, quit on error
                //
                goto GETOUT;

            }

        } else
            ScepLogOutput3(1, 0, SCEDLL_SAP_PASSWORD );

    } else {
        saveRc = ScepDosErrorToSceStatus(rc);

        ScepLogOutput3(1,rc, SCEDLL_ERROR_QUERY_PASSWORD);  // ntstatus

        if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS) ) {
            //
            // if it's not getting system setting, quit on error
            //
            goto GETOUT;
        }
    }

    if ( pErrLog && (saveRc != SCESTATUS_SUCCESS) ) {

        //
        // password policy failed.
        //
        ScepBuildErrorLogInfo(
                ScepSceStatusToDosError(saveRc),
                pErrLog,
                SCEDLL_ERROR_QUERY_PASSWORD
                );
    }

    //
    // Analyze Lockout information
    //

    if ( (gOptions & SCE_GENERATE_ROLLBACK) &&
         (pTmpInfo->LockoutBadCount == SCE_NO_VALUE) &&
         (pTmpInfo->ResetLockoutCount == SCE_NO_VALUE) &&
         (pTmpInfo->LockoutDuration == SCE_NO_VALUE) ) {

        rc = NtStatus = STATUS_SUCCESS;

    } else {

        Buffer = NULL;
        NtStatus = SamQueryInformationDomain(
                      DomainHandle,
                      DomainLockoutInformation,
                      &Buffer
                      );

        rc = RtlNtStatusToDosError( NtStatus );
        if ( NT_SUCCESS(NtStatus) ) {

            rc = SCESTATUS_SUCCESS;

            CurrentVal = ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutThreshold;
            BaseVal = pTmpInfo->LockoutBadCount;
            DWORD dwLockOut = BaseVal;

            if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {
                //
                // system setting
                //
                pSmpInfo->LockoutBadCount = CurrentVal;

            } else if ( dwSaveOption ) {
                //
                // policy filter mode
                //
                if ( CurrentVal != BaseVal &&
                     BaseVal != SCE_NO_VALUE ) {

                    pSmpInfo->LockoutBadCount = CurrentVal;
                    *pbChanged = TRUE;

                    if ( CurrentVal == 0 ) {
                        //
                        // if no lockout is allowed,
                        // make sure to delete the entries below
                        //
                        pSmpInfo->ResetLockoutCount = SCE_NO_VALUE;
                        pSmpInfo->LockoutDuration = SCE_NO_VALUE;
                    }

                } else if ( dwSaveOption & SCEPOL_SAVE_DB ) {
                    //
                    // turn this item off to indicate this one is not changed
                    //
                    pSmpInfo->LockoutBadCount = SCE_NO_VALUE;
                }
            } else {

                //
                // analyze
                //
                rc = ScepCompareAndSaveIntValue(
                           hSection,
                           L"LockoutBadCount",
                           FALSE,
                           (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : BaseVal,
                           CurrentVal);
                if ( rc == SCESTATUS_SUCCESS &&
                     !(gOptions & SCE_NO_ANALYZE) ) {
                    AccessValues[IDX_LOCK_COUNT] = CurrentVal;
                }
            }

            if ( rc == SCESTATUS_SUCCESS &&
                 ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutThreshold >  0 ) {

                CurrentVal = (DWORD) (-1 * ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutObservationWindow.QuadPart /
                              (60 * 10000000L) );

                BaseVal = pTmpInfo->ResetLockoutCount;

                if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {

                    pSmpInfo->ResetLockoutCount = CurrentVal;

                } else if ( dwSaveOption ) {

                    //
                    // if this setting is defined or LockoutBadCount is defined
                    // filter this value
                    //
                    if ( CurrentVal != BaseVal &&
                         (BaseVal != SCE_NO_VALUE || dwLockOut != SCE_NO_VALUE) ) {

                        pSmpInfo->ResetLockoutCount = CurrentVal;
                        *pbChanged = TRUE;

                    } else if ( dwSaveOption & SCEPOL_SAVE_DB ) {
                        //
                        // turn this item off to indicate this one is not changed
                        //
                        pSmpInfo->ResetLockoutCount = SCE_NO_VALUE;
                    }

                } else {

                    rc = ScepCompareAndSaveIntValue(
                             hSection,
                             L"ResetLockoutCount",
                             FALSE,
                             (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : BaseVal,
                             CurrentVal);
                    if ( rc == SCESTATUS_SUCCESS &&
                         !(gOptions & SCE_NO_ANALYZE) ) {
                        AccessValues[IDX_RESET_COUNT] = CurrentVal;
                    }
                }

                if ( rc == SCESTATUS_SUCCESS ) {
                    if ( ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutDuration.HighPart == MINLONG &&
                         ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutDuration.LowPart == 0 ) {
                        //
                        // forever
                        //
                        CurrentVal = SCE_FOREVER_VALUE;
                    } else
                        CurrentVal = (DWORD)(-1 * ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutDuration.QuadPart /
                                     (60 * 10000000L) );

                    BaseVal = pTmpInfo->LockoutDuration;

                    if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {

                        pSmpInfo->LockoutDuration = CurrentVal;

                    } else if ( dwSaveOption ) {

                        //
                        // if this setting is defined or LockoutBadCount is defined
                        // filter this value
                        //
                        if ( CurrentVal != BaseVal &&
                            (BaseVal != SCE_NO_VALUE || dwLockOut != SCE_NO_VALUE) ) {

                            pSmpInfo->LockoutDuration = CurrentVal;
                            *pbChanged = TRUE;

                        } else if ( dwSaveOption & SCEPOL_SAVE_DB ) {
                            //
                            // turn this item off to indicate this one is not changed
                            //
                            pSmpInfo->LockoutDuration = SCE_NO_VALUE;
                        }

                    } else {
                        rc = ScepCompareAndSaveIntValue(
                                hSection,
                                L"LockoutDuration",
                                FALSE,
                                (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : BaseVal,
                                CurrentVal);
                        if ( rc == SCESTATUS_SUCCESS &&
                             !(gOptions & SCE_NO_ANALYZE) ) {
                            AccessValues[IDX_LOCK_DURATION] = CurrentVal;
                        }
                    }
                }
            } else {

                AccessValues[IDX_RESET_COUNT] = SCE_NOT_ANALYZED_VALUE;
                AccessValues[IDX_LOCK_DURATION] = SCE_NOT_ANALYZED_VALUE;
            }

            SamFreeMemory(Buffer);

            if ( rc != SCESTATUS_SUCCESS ) {
                saveRc = rc;
                ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                                SCEDLL_SAP_ERROR_LOCKOUT);

                if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS) ) {

                    goto GETOUT;
                }
            } else
                ScepLogOutput3(1, 0, SCEDLL_SAP_LOCKOUT );

        } else {
            saveRc = ScepDosErrorToSceStatus(rc);
            ScepLogOutput3(1,rc, SCEDLL_ERROR_QUERY_LOCKOUT);  // ntstatus

            if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS) ) {

                goto GETOUT;
            }
        }

        if ( pErrLog && ( rc != NO_ERROR) ) {

            //
            // account lockout policy failed.
            //
            ScepBuildErrorLogInfo(
                    ScepSceStatusToDosError(saveRc),
                    pErrLog,
                    SCEDLL_ERROR_QUERY_LOCKOUT
                    );

        }
    }

    //
    // Force Logoff when hour expire - (on non-DCs too)
    //
    Buffer = NULL;
    NtStatus = SamQueryInformationDomain(
                                        DomainHandle,
                                        DomainLogoffInformation,
                                        &Buffer
                                        );

    rc = RtlNtStatusToDosError( NtStatus );
    if ( NT_SUCCESS(NtStatus) ) {

        rc = SCESTATUS_SUCCESS;

        if ( ((DOMAIN_LOGOFF_INFORMATION *)Buffer)->ForceLogoff.HighPart == 0 &&
             ((DOMAIN_LOGOFF_INFORMATION *)Buffer)->ForceLogoff.LowPart == 0 ) {
            // yes
            CurrentVal = 1;
        } else
            CurrentVal = 0;

        BaseVal = pTmpInfo->ForceLogoffWhenHourExpire;

        if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {

            pSmpInfo->ForceLogoffWhenHourExpire = CurrentVal;

        } else if ( dwSaveOption ) {

            if ( ( CurrentVal != BaseVal ) &&
                 ( BaseVal != SCE_NO_VALUE) ) {
                pSmpInfo->ForceLogoffWhenHourExpire = CurrentVal;
                *pbChanged = TRUE;
            } else if ( dwSaveOption & SCEPOL_SAVE_DB ) {
                //
                // turn this item off to indicate this one is not changed
                //
                pSmpInfo->ForceLogoffWhenHourExpire = SCE_NO_VALUE;
            }

        } else {

            rc = ScepCompareAndSaveIntValue(
                                           hSection,
                                           L"ForceLogOffWhenHourExpire",
                                           (gOptions & SCE_GENERATE_ROLLBACK),
                                           (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : BaseVal,
                                           CurrentVal);
            if ( rc == SCESTATUS_SUCCESS &&
                 !(gOptions & SCE_NO_ANALYZE) ) {
                AccessValues[IDX_FORCE_LOGOFF] = CurrentVal;
            }
        }

        SamFreeMemory(Buffer);

        if ( rc != SCESTATUS_SUCCESS ) {
            saveRc = rc;
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_SAP_ERROR_LOGOFF);

            if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS) ) {

                goto GETOUT;
            }
        } else
            ScepLogOutput3(1, 0, SCEDLL_SAP_LOGOFF );

    } else {
        saveRc = ScepDosErrorToSceStatus(rc);
        ScepLogOutput3(1,rc, SCEDLL_ERROR_QUERY_LOGOFF);  // ntstatus

        if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS) ) {

            goto GETOUT;
        }
    }

    if ( pErrLog && (rc != NO_ERROR) ) {
        //
        // force logoff failed.
        //
        ScepBuildErrorLogInfo(
                ScepSceStatusToDosError(saveRc),
                pErrLog,
                SCEDLL_ERROR_QUERY_LOGOFF
                );
    }

    //
    // Check if Administrator/Guest accounts need to be renamed
    //
    if ( (dwSaveOption & SCEPOL_SYSTEM_SETTINGS) ||
         (!(gOptions & SCE_NO_ANALYZE) && (dwSaveOption == 0)) ) {

        RegBuf=NULL;
        CurrentVal=0;

        if ( (gOptions & SCE_GENERATE_ROLLBACK) &&
             (pSmpInfo->NewAdministratorName == NULL ) ) {

            NtStatus = STATUS_SUCCESS;
            ToRename = FALSE;

        } else {

            NtStatus = ScepAdminGuestAccountsToManage(
                               DomainHandle,
                               SCE_RENAME_ADMIN,
                               pSmpInfo->NewAdministratorName,
                               &ToRename,
                               &RegBuf,
                               &CurrentVal
                               );
        }
        rc = RtlNtStatusToDosError(NtStatus);

        if ( NT_SUCCESS( NtStatus ) ) {

            if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {

                pSmpInfo->NewAdministratorName = RegBuf;

            } else {

                if ( ToRename ) {
                    rc = ScepCompareAndSaveStringValue(
                                hSection,
                                L"NewAdministratorName",
                                pSmpInfo->NewAdministratorName,
                                RegBuf,
                                CurrentVal*sizeof(WCHAR)
                                );
                    rc = ScepSceStatusToDosError(rc);
                }

                ScepFree(RegBuf);
            }
            RegBuf=NULL;

        } else if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS) &&
                    !(gOptions & SCE_GENERATE_ROLLBACK) ) {

            //
            // raise this one
            //
            ScepRaiseErrorString(
                hSection,
                L"NewAdministratorName",
                NULL
                );
        }

        if ( rc != NO_ERROR ) {
            saveRc = ScepDosErrorToSceStatus(rc);

            if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS) ) {
                ScepLogOutput3(1, rc, SCEDLL_SAP_ERROR_ADMINISTRATOR);
                goto GETOUT;

            } else if ( pErrLog ) {
                //
                // account name failed.
                //
                ScepBuildErrorLogInfo(
                        rc,
                        pErrLog,
                        SCEDLL_SAP_ERROR_ADMINISTRATOR
                        );
            }
        }

        RegBuf=NULL;
        CurrentVal=0;

        if ( (gOptions & SCE_GENERATE_ROLLBACK) &&
             (pSmpInfo->NewGuestName == NULL ) ) {

            NtStatus = STATUS_SUCCESS;
            ToRename = FALSE;

        } else {

            NtStatus = ScepAdminGuestAccountsToManage(
                               DomainHandle,
                               SCE_RENAME_GUEST,
                               pSmpInfo->NewGuestName,
                               &ToRename,
                               &RegBuf,
                               &CurrentVal
                               );
        }

        rc = RtlNtStatusToDosError(NtStatus);

        if ( NT_SUCCESS( NtStatus ) ) {
            if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {

                pSmpInfo->NewGuestName = RegBuf;

            } else {
                if ( ToRename ) {
                    rc = ScepCompareAndSaveStringValue(
                                hSection,
                                L"NewGuestName",
                                pSmpInfo->NewGuestName,
                                RegBuf,
                                CurrentVal*sizeof(WCHAR)
                                );
                    rc = ScepSceStatusToDosError(rc);
                }

                ScepFree(RegBuf);
            }
            RegBuf=NULL;

        } else if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS) &&
                    !(gOptions & SCE_GENERATE_ROLLBACK) ) {

            //
            // raise this one
            //
            ScepRaiseErrorString(
                hSection,
                L"NewGuestName",
                NULL
                );
        }

        if ( rc != NO_ERROR ) {
            saveRc = ScepDosErrorToSceStatus(rc);

            if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS)) {
                ScepLogOutput3(1, rc, SCEDLL_SAP_ERROR_GUEST);
                goto GETOUT;

            } else if ( pErrLog ) {
                //
                // account name failed.
                //
                ScepBuildErrorLogInfo(
                        rc,
                        pErrLog,
                        SCEDLL_SAP_ERROR_GUEST
                        );
            }
        }
    }

    //
    // Analyze LSA Anonymous Lookup information
    //

    rc = ScepGetLSAPolicyObjectInfo( &dwAllow );

    if ( rc == ERROR_SUCCESS ) {

        CurrentVal = dwAllow;
        BaseVal = pTmpInfo->LSAAnonymousNameLookup;

        if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {
            //
            // system setting
            //
            pSmpInfo->LSAAnonymousNameLookup = CurrentVal;

        } else if ( dwSaveOption ) {
            //
            // policy filter mode
            //
            // (this setting should not be filtered : bug #344311)
/*
            if ( CurrentVal != BaseVal &&
                 BaseVal != SCE_NO_VALUE ) {

                pSmpInfo->LSAAnonymousNameLookup = CurrentVal;
                *pbChanged = TRUE;

            } else if ( dwSaveOption & SCEPOL_SAVE_DB ) {
                //
                // turn this item off to indicate this one is not changed
                //
                pSmpInfo->LSAAnonymousNameLookup = SCE_NO_VALUE;
            }
*/
        } else {

            //
            // analyze
            //
            rc = ScepCompareAndSaveIntValue(
                       hSection,
                       L"LSAAnonymousNameLookup",
                       (gOptions & SCE_GENERATE_ROLLBACK),
                       (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : BaseVal,
                       CurrentVal);

            if ( rc == SCESTATUS_SUCCESS && !(gOptions & SCE_NO_ANALYZE) ) {
                AccessValues[IDX_LSA_ANON_LOOKUP] = CurrentVal;
            }
        }

        if ( rc != SCESTATUS_SUCCESS ) {
            saveRc = rc;
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                            SCEDLL_SAP_ERROR_LSA_ANON_LOOKUP);

            if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS) ) {

                goto GETOUT;
            }
        } else
            ScepLogOutput3(1, 0, SCEDLL_SAP_LSAPOLICY );

    } else {
        saveRc = ScepDosErrorToSceStatus(rc);
        ScepLogOutput3(1,rc, SCEDLL_SAP_ERROR_LSA_ANON_LOOKUP);

        if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS) ) {

            goto GETOUT;
        }
    }

    if ( pErrLog && (rc != NO_ERROR) ) {
        //
        // lsa policy failed.
        //
        ScepBuildErrorLogInfo(
                ScepSceStatusToDosError(saveRc),
                pErrLog,
                SCEDLL_SAP_ERROR_LSA_ANON_LOOKUP
                );
    }

    //
    // Admin/Guest accounts are not filtered (controlled by dwSaveOption flag)
    //
    if ( (dwSaveOption & SCEPOL_SYSTEM_SETTINGS) ||
         (!(gOptions & SCE_NO_ANALYZE) && (dwSaveOption == 0)) ) {

        //
        // Analyze administrator account status
        //

        ToRename = FALSE;
        NtStatus = ScepAdminGuestAccountsToManage(
                           DomainHandle,
                           SCE_DISABLE_ADMIN,
                           NULL,
                           &ToRename,  // TRUE = disabled
                           NULL,
                           NULL
                           );

        rc = RtlNtStatusToDosError(NtStatus);

        if ( NT_SUCCESS( NtStatus ) ) {
            if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {

                pSmpInfo->EnableAdminAccount = ToRename ? 0 : 1;

            } else {
                rc = ScepCompareAndSaveIntValue(
                            hSection,
                            L"EnableAdminAccount",
                           (gOptions & SCE_GENERATE_ROLLBACK),
                            pSmpInfo->EnableAdminAccount,
                            ToRename ? 0 : 1
                            );

                if ( rc == SCESTATUS_SUCCESS && !(gOptions & SCE_NO_ANALYZE) ) {
                    AccessValues[IDX_ENABLE_ADMIN] = ToRename ? 0 : 1;
                }
                rc = ScepSceStatusToDosError(rc);

            }

        } else if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS) &&
                    !(gOptions & SCE_GENERATE_ROLLBACK) ) {

            //
            // raise this one
            //
            ScepRaiseErrorString(
                hSection,
                L"EnableAdminAccount",
                NULL
                );
        }

        if ( rc != NO_ERROR ) {
            saveRc = ScepDosErrorToSceStatus(rc);

            if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS)) {
                ScepLogOutput3(1, rc, SCEDLL_SAP_ERROR_DISABLE_ADMIN);
                goto GETOUT;

            } else if ( pErrLog ) {
                //
                // account name failed.
                //
                ScepBuildErrorLogInfo(
                        rc,
                        pErrLog,
                        SCEDLL_SAP_ERROR_DISABLE_ADMIN
                        );
            }
        }

        //
        // Analyze administrator account status
        //

        ToRename = FALSE;
        NtStatus = ScepAdminGuestAccountsToManage(
                           DomainHandle,
                           SCE_DISABLE_GUEST,
                           NULL,
                           &ToRename,  // TRUE=disabled
                           NULL,
                           NULL
                           );

        rc = RtlNtStatusToDosError(NtStatus);

        if ( NT_SUCCESS( NtStatus ) ) {
            if ( dwSaveOption & SCEPOL_SYSTEM_SETTINGS ) {

                pSmpInfo->EnableGuestAccount = ToRename ? 0 : 1;

            } else {
                rc = ScepCompareAndSaveIntValue(
                            hSection,
                            L"EnableGuestAccount",
                            (gOptions & SCE_GENERATE_ROLLBACK),
                            pSmpInfo->EnableGuestAccount,
                            ToRename ? 0 : 1
                            );
                if ( rc == SCESTATUS_SUCCESS && !(gOptions & SCE_NO_ANALYZE) ) {
                    AccessValues[IDX_ENABLE_GUEST] = ToRename ? 0 : 1;
                }
                rc = ScepSceStatusToDosError(rc);
            }

        } else if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS) &&
                    !(gOptions & SCE_GENERATE_ROLLBACK) ) {

            //
            // raise this one
            //
            ScepRaiseErrorString(
                hSection,
                L"EnableGuestAccount",
                NULL
                );
        }

        if ( rc != NO_ERROR ) {
            saveRc = ScepDosErrorToSceStatus(rc);

            if ( !(dwSaveOption & SCEPOL_SYSTEM_SETTINGS)) {
                ScepLogOutput3(1, rc, SCEDLL_SAP_ERROR_DISABLE_GUEST);
                goto GETOUT;

            } else if ( pErrLog ) {
                //
                // account name failed.
                //
                ScepBuildErrorLogInfo(
                        rc,
                        pErrLog,
                        SCEDLL_SAP_ERROR_DISABLE_GUEST
                        );
            }
        }
    }

    //
    // compare the snapshot with SmpInfo and write to SAP section
    //

    ScepLogOutput3(1, 0, SCEDLL_SAP_OTHER_POLICY);

GETOUT:

    //
    // Clear out memory and return
    //

    SamCloseHandle( DomainHandle );
    SamCloseHandle( ServerHandle );
    if ( DomainSid != NULL )
        SamFreeMemory(DomainSid);

    //
    // see if there is anything needs to be raised for error
    //

    if ( (dwSaveOption == 0) && !(gOptions & SCE_NO_ANALYZE) &&
         !(gOptions & SCE_GENERATE_ROLLBACK) ) {

        for ( CurrentVal=0; CurrentVal<MAX_ACCESS_ITEMS; CurrentVal++ ) {
            if ( AccessValues[CurrentVal] == SCE_ERROR_VALUE ||
                 AccessValues[CurrentVal] == SCE_NOT_ANALYZED_VALUE) {
                //
                // raise this one
                //
                ScepCompareAndSaveIntValue(
                         hSection,
                         AccessItems[CurrentVal],
                         FALSE,
                         SCE_NO_VALUE,
                         AccessValues[CurrentVal]);

            }
        }
    }

    return( saveRc );
}



NTSTATUS
ScepAdminGuestAccountsToManage(
    IN SAM_HANDLE DomainHandle,
    IN DWORD      AccountType,
    IN PWSTR TargetName OPTIONAL,
    OUT PBOOL ToRename,
    OUT PWSTR *CurrentName OPTIONAL,
    OUT PDWORD pNameLen OPTIONAL
    )
/* ++
Routine Description:

   This routine checks the specified account's name to see if the account
   needs to be renamed

Arguments:

   DomainHandle - The account domain handle

   AccountType  - indicate it is Administrator account or Guest account
                     SCE_RENAME_ADMIN
                     SCE_RENAME_GUEST
                     SCE_DISABLE_ADMIN
                     SCE_DISABLE_GUEST
   ToRename     - for the rename operations,
                    TRUE = rename the account, FALSE=do not need to rename
                  for the disable operations,
                    TRUE = disabled, FALSE = enabled

Return value:

   NTSTATUS error codes

-- */
{
   SAM_HANDLE UserHandle1=NULL;
   PVOID pInfoBuffer=NULL;
   USER_NAME_INFORMATION *Buffer=NULL;
   USER_CONTROL_INFORMATION *pControlBuffer = NULL;
   NTSTATUS NtStatus;
   ULONG    UserId;
   BOOL bDisable=FALSE;

   //
   // find the right userid for the account
   //
   switch ( AccountType ) {
   case SCE_DISABLE_ADMIN:
       bDisable = TRUE;
       // fall through
   case SCE_RENAME_ADMIN:
       UserId = DOMAIN_USER_RID_ADMIN;
       break;
   case SCE_DISABLE_GUEST:
       bDisable = TRUE;
       // fall through
   case SCE_RENAME_GUEST:
       UserId = DOMAIN_USER_RID_GUEST;

       break;
   default:
       return(STATUS_INVALID_PARAMETER);
   }

   *ToRename = TRUE;
   if ( pNameLen )
       *pNameLen = 0;

   NtStatus = SamOpenUser(
                 DomainHandle,
                 USER_READ_GENERAL | (bDisable ? USER_READ_ACCOUNT : 0), // USER_READ | USER_EXECUTE,
                 UserId,
                 &UserHandle1
                 );

   if ( NT_SUCCESS( NtStatus ) ) {

       NtStatus = SamQueryInformationUser(
                     UserHandle1,
                     bDisable ? UserControlInformation : UserNameInformation,
                     &pInfoBuffer
                     );

       if ( NT_SUCCESS( NtStatus ) ) {

           if ( bDisable ) {
               //
               // check disable flags
               //
               pControlBuffer = (USER_CONTROL_INFORMATION *)pInfoBuffer;

               if ( pControlBuffer->UserAccountControl & USER_ACCOUNT_DISABLED ) {
                   *ToRename = TRUE;
               } else {
                   *ToRename = FALSE;
               }
           } else {

               //
               // check account names
               //
               Buffer = (USER_NAME_INFORMATION *)pInfoBuffer;

               if ( Buffer->UserName.Length > 0 && Buffer->UserName.Buffer ) {
                   if (CurrentName) {

                       *CurrentName = (PWSTR)ScepAlloc(0, Buffer->UserName.Length+2);
                       if ( *CurrentName ) {
                           wcsncpy(*CurrentName, Buffer->UserName.Buffer, Buffer->UserName.Length/2);
                           (*CurrentName)[Buffer->UserName.Length/2] = L'\0';
                       } else
                           NtStatus = STATUS_NO_MEMORY;
                   }
                   if ( pNameLen ) {
                       *pNameLen = Buffer->UserName.Length/2;
                   }

                   if ( NT_SUCCESS( NtStatus ) && TargetName ) {

                       if ( _wcsnicmp(Buffer->UserName.Buffer, TargetName, Buffer->UserName.Length/2 ) == 0 )
                           *ToRename = FALSE;
                   }
               }
           }
       }
       SamFreeMemory(pInfoBuffer);
       SamCloseHandle( UserHandle1 );
   }

   return( NtStatus );

}

BOOL
ScepIsThisItemInNameList(
    IN PWSTR Item,
    IN BOOL bIsSid,
    IN PSCE_NAME_LIST pList
    )
{
    PSCE_NAME_LIST pName2;
    BOOL bSid2;

    if ( Item == NULL || pList == NULL ) {
        return(FALSE);
    }

    for ( pName2=pList; pName2 != NULL; pName2 = pName2->Next ) {

        if ( pName2->Name == NULL ) {
            continue;
        }
        if ( ScepValidSid( (PSID)(pName2->Name) ) ) {
            bSid2 = TRUE;
        } else {
            bSid2 = FALSE;
        }

        //
        // if SID/Name format mismatch, return
        //
        if ( bIsSid != bSid2 ) {
            continue;
        }

        if ( bIsSid && RtlEqualSid( (PSID)(Item), (PSID)(pName2->Name) ) ) {
            //
            // find a SID match
            //
            break;
        }

        if ( !bIsSid && _wcsicmp(Item, pName2->Name) == 0 ) {
            //
            // find a match
            //
            break;  // the second for loop
        }
    }

    if ( pName2 ) {
        //
        // find it
        //
        return(TRUE);
    } else {
        return(FALSE);
    }
}

BOOL
ScepCompareSidNameList(
    IN PSCE_NAME_LIST pList1,
    IN PSCE_NAME_LIST pList2
    )
/*
Compare two lists where the name field can be a SID or Name.
The rule is to compare SID to SID and name to name because name
is only there when it can be mapped to a SID
*/
{
    PSCE_NAME_LIST pName1, pName2;
    DWORD CountSid1=0, CountSid2=0;
    DWORD CountN1=0, CountN2=0;


    if ( (pList2 == NULL && pList1 != NULL) ||
         (pList2 != NULL && pList1 == NULL) ) {
//        return(TRUE);
// should be not equal
        return(FALSE);
    }

    for ( pName2=pList2; pName2 != NULL; pName2 = pName2->Next ) {

        if ( pName2->Name == NULL ) {
            continue;
        }
        if ( ScepValidSid( (PSID)(pName2->Name) ) ) {
            CountSid2++;
        } else {
            CountN2++;
        }
    }

    BOOL bSid1;

    for ( pName1=pList1; pName1 != NULL; pName1 = pName1->Next ) {

        if ( pName1->Name == NULL ) {
            continue;
        }
        if ( ScepValidSid( (PSID)(pName1->Name) ) ) {
            bSid1 = TRUE;
            CountSid1++;
        } else {
            bSid1 = FALSE;
            CountN1++;
        }

        if ( !ScepIsThisItemInNameList( pName1->Name, bSid1, pList2 ) ) {
            //
            // does not find a match
            //
            return(FALSE);
        }
    }

    if ( CountSid1 != CountSid2 )
        return(FALSE);

    if ( CountN2 != CountN2 ) {
        return(FALSE);
    }

    return(TRUE);

}


DWORD
ScepConvertSidListToStringName(
    IN LSA_HANDLE LsaPolicy,
    IN OUT PSCE_NAME_LIST pList
    )
{

    PSCE_NAME_LIST pSidList;
    DWORD  rc=ERROR_SUCCESS;
    PWSTR StringSid=NULL;

    for ( pSidList=pList; pSidList != NULL;
          pSidList=pSidList->Next) {

        if ( pSidList->Name == NULL ) {
            continue;
        }
        if ( ScepValidSid( (PSID)(pSidList->Name) ) ) {

            //
            // if the SID is a domain account, convert it to sid string
            // otherwise, convert it to name, then add to the name list
            //
            if ( ScepIsSidFromAccountDomain( (PSID)(pSidList->Name) ) ) {

                rc = ScepConvertSidToPrefixStringSid( (PSID)(pSidList->Name), &StringSid );
            } else {
                //
                // should conver it to name
                //
                rc = RtlNtStatusToDosError(
                          ScepConvertSidToName(
                            LsaPolicy,
                            (PSID)(pSidList->Name),
                            FALSE,
                            &StringSid,
                            NULL
                            ));
            }

            if ( rc == ERROR_SUCCESS ) {

                ScepFree( pSidList->Name );
                pSidList->Name = StringSid;
                StringSid = NULL;

            } else {
                break;
            }
        } else {
            //
            // this is not a valid sid so it must be in name format already.
            // just leave it as it is.
            //

        }
    }

    return(rc);
}



SCESTATUS
ScepAnalyzePrivileges(
    IN PSCE_PRIVILEGE_ASSIGNMENT pPrivilegeList
    )
/* ++

Routine Description:

   This routine analyzies local system privilege's direct assignments to accounts.
   Different assignment from the profile is saved to the SAP profile

Arguments:

   pSmpInfo - The buffer which contains profile information to compare with

Return value:

   SCESTATUS_SUCCESS
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER

-- */
{

    if ( (gOptions & SCE_GENERATE_ROLLBACK) &&
         pPrivilegeList == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    NTSTATUS    NtStatus;
    ULONG       CountReturned;
    UNICODE_STRING UserRight;
    PLSA_ENUMERATION_INFORMATION EnumBuffer=NULL;

    LSA_HANDLE  PolicyHandle=NULL;
    PLSA_TRANSLATED_NAME Names=NULL;
    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains=NULL;
    DWORD  i=0, j;
    SCESTATUS rc;

    PSCE_NAME_LIST  pNameList=NULL;
    PSCE_PRIVILEGE_ASSIGNMENT  pPrivilege;
    DWORD   nPrivCount=0;

    //
    // Open LSA policy
    //
    NtStatus = ScepOpenLsaPolicy(
                    GENERIC_READ | GENERIC_EXECUTE,
                    &PolicyHandle,
                    TRUE
                    );

    if ( !NT_SUCCESS(NtStatus) ) {
        rc = RtlNtStatusToDosError(NtStatus);
        ScepLogOutput3(1, rc, SCEDLL_LSA_POLICY );
        ScepPostProgress(TICKS_PRIVILEGE, AREA_PRIVILEGES, NULL);

        return(ScepDosErrorToSceStatus( rc ));
    }

    //
    // Prepare Jet's section to write
    //
    rc = ScepStartANewSection(
                hProfile,
                &hSection,
                (gOptions & SCE_NO_ANALYZE || gOptions & SCE_GENERATE_ROLLBACK) ?
                    SCEJET_TABLE_SMP : SCEJET_TABLE_SAP,
                szPrivilegeRights
                );

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                       SCEDLL_SAP_START_SECTION, (PWSTR)szPrivilegeRights);
        goto Done;
    }

    //
    // enumerate accounts for each user right
    //
    INT iStat=0;

    for ( i=0; i<cPrivCnt; i++) {

        iStat = 0;
        if ( gOptions & SCE_NO_ANALYZE ) {
            pPrivilege = NULL;
            iStat = 3;

        } else {

            for ( pPrivilege=pPrivilegeList;
                  pPrivilege != NULL;
                  pPrivilege = pPrivilege->Next ) {

                // should compare name, because value is different
//                if ( i == pPrivilege->Value)
                if ( _wcsicmp(SCE_Privileges[i].Name, pPrivilege->Name) == 0 )
                    break;
            }

            if ( pPrivilege == NULL ) {
                if ( gOptions & SCE_GENERATE_ROLLBACK )
                    continue;
                iStat = 2;
            } else {
                iStat = 1;
            }
        }

        RtlInitUnicodeString( &UserRight, (PCWSTR)(SCE_Privileges[i].Name));

        ScepLogOutput3(1, 0, SCEDLL_SAP_ANALYZE, SCE_Privileges[i].Name);

        if ( nPrivCount < TICKS_PRIVILEGE ) {

            //
            // only post maximum TICKS_PRIVILEGE ticks because that's the number
            // remembers in the total ticks
            //

            ScepPostProgress(1, AREA_PRIVILEGES, SCE_Privileges[i].Name);
            nPrivCount++;
        }

        NtStatus = LsaEnumerateAccountsWithUserRight(
                            PolicyHandle,
                            &UserRight,
                            (PVOID *)&EnumBuffer,   // account SIDs
                            &CountReturned
                            );

        if ( NT_SUCCESS(NtStatus) ) {

            BOOL bUsed;
            for ( j=0; j<CountReturned; j++ ) {
                //
                // build each account into the name list
                // Note, if the SID is invalid, do not add it to
                // the valid account list
                //

                if ( !ScepValidSid( EnumBuffer[j].Sid ) ) {
                    continue;
                }

                rc = ScepAddSidToNameList(
                              &pNameList,
                              EnumBuffer[j].Sid,
                              FALSE,
                              &bUsed
                              );

                if ( rc != NO_ERROR ) {

                    ScepLogOutput3(1, rc,
                                   SCEDLL_SAP_ERROR_SAVE,
                                   SCE_Privileges[i].Name);

                    NtStatus = STATUS_NO_MEMORY;
                    break;
                }
            }

            LsaFreeMemory( EnumBuffer );
            EnumBuffer = NULL;

        } else if ( NtStatus != STATUS_NO_MORE_ENTRIES &&
                    NtStatus != STATUS_NO_SUCH_PRIVILEGE &&
                    NtStatus != STATUS_NOT_FOUND ) {
            ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                          SCEDLL_SAP_ERROR_ENUMERATE,SCE_Privileges[i].Name);
        }

        if ( NtStatus == STATUS_NO_SUCH_PRIVILEGE &&
              !pNameList ) {

            ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                          SCEDLL_SAP_ERROR_ENUMERATE,SCE_Privileges[i].Name);

            gWarningCode = RtlNtStatusToDosError(NtStatus);

            if ( !(gOptions & SCE_NO_ANALYZE) &&
                 !(gOptions & SCE_GENERATE_ROLLBACK) ) {

                ScepRaiseErrorString(
                            hSection,
                            SCE_Privileges[i].Name,
                            NULL
                            );
            }
            NtStatus = STATUS_SUCCESS;
            continue;
        }

        if ( (NtStatus == STATUS_NOT_FOUND ||
              NtStatus == STATUS_NO_MORE_ENTRIES) &&
             !pNameList ) {
            //
            // no account is assigned this privilege
            // should continue the process
            //
            NtStatus = STATUS_SUCCESS;
        }

        if ( NtStatus == STATUS_NO_MORE_ENTRIES ||
            NtStatus == STATUS_NO_SUCH_PRIVILEGE ||
            NtStatus == STATUS_NOT_FOUND ) {

            if ( pNameList != NULL ) {

                ScepFreeNameList(pNameList);
                pNameList = NULL;
            }

            if ( !(gOptions & SCE_NO_ANALYZE) &&
                 !(gOptions & SCE_GENERATE_ROLLBACK) ) {

                ScepRaiseErrorString(
                            hSection,
                            SCE_Privileges[i].Name,
                            NULL
                            );
            }
            continue;

        } else if ( !NT_SUCCESS(NtStatus) ) {
            goto Done;

        } else {
            NtStatus = STATUS_SUCCESS;
            //
            // all entries for this priv is added to the pNameList.
            // compare with SMP privileges list to match
            //
            if ( pPrivilege == NULL ||
                 ScepCompareSidNameList(pPrivilege->AssignedTo, pNameList) == FALSE ) {
                //
                // this priv does not exist in the SMP list, or have different
                // accounts assigned to. Save it
                //
                rc = ScepConvertSidListToStringName(PolicyHandle, pNameList);

                if ( SCESTATUS_SUCCESS == rc ) {
                    rc = ScepWriteNameListValue(
                            PolicyHandle,
                            hSection,
                            SCE_Privileges[i].Name,
                            pNameList,
                            SCE_WRITE_EMPTY_LIST,
                            iStat
                            );

                    if ( rc != SCESTATUS_SUCCESS ) {
                        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                                       SCEDLL_SAP_ERROR_SAVE,
                                       SCE_Privileges[i].Name);
                        NtStatus = STATUS_NO_MEMORY;
                        goto Done;
                    }

                } else if ( !(gOptions & SCE_NO_ANALYZE) &&
                            !(gOptions & SCE_GENERATE_ROLLBACK) ) {

                    ScepRaiseErrorString(
                                hSection,
                                SCE_Privileges[j].Name,
                                NULL
                                );
                }

            }

            if ( pNameList != NULL ) {

                ScepFreeNameList(pNameList);
                pNameList = NULL;
            }

        }
    }

Done:

    if ( !(gOptions & SCE_NO_ANALYZE) &&
         !(gOptions & SCE_GENERATE_ROLLBACK) ) {

        for ( j=i; j<cPrivCnt; j++) {
            //
            // raise error for anything not analyzed
            //
            ScepRaiseErrorString(
                        hSection,
                        SCE_Privileges[j].Name,
                        NULL
                        );
        }
    }

    if ( pNameList != NULL )
        ScepFreeNameList( pNameList );

    LsaClose(PolicyHandle);

    if ( nPrivCount < TICKS_PRIVILEGE ) {

        ScepPostProgress(TICKS_PRIVILEGE-nPrivCount,
                         AREA_PRIVILEGES, NULL);
    }

    return( ScepDosErrorToSceStatus( RtlNtStatusToDosError(NtStatus) ) );
}



SCESTATUS
ScepRaiseErrorString(
    IN PSCESECTION hSectionIn OPTIONAL,
    IN PWSTR KeyName,
    IN PCWSTR szSuffix OPTIONAL
    )
{
    if ( KeyName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    PWSTR NewKeyName = NULL;

    if ( szSuffix ) {
        //
        // this is for group membership section
        // append the suffix (szMembers, or szMemberOf)
        //

        NewKeyName = (PWSTR)ScepAlloc(0, (wcslen(KeyName)+wcslen(szSuffix)+1)*sizeof(WCHAR));
        if ( NewKeyName != NULL ) {

            swprintf(NewKeyName, L"%s%s\0", KeyName, szSuffix);
        } else {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }

    } else {
        NewKeyName = KeyName;
    }


    SceJetSetLine(
        hSectionIn ? hSectionIn : hSection,
        NewKeyName,
        FALSE,
        SCE_ERROR_STRING,
        wcslen(SCE_ERROR_STRING)*sizeof(WCHAR),
        0
        );

    //
    // free memory
    //
    if ( NewKeyName != KeyName &&
         NewKeyName ) {
        ScepFree(NewKeyName);
    }

    return SCESTATUS_SUCCESS;
}

#if 0


NTSTATUS
ScepGetCurrentPrivilegesRights(
    IN LSA_HANDLE PolicyHandle,
    IN SAM_HANDLE BuiltinDomainHandle,
    IN PSID       BuiltinDomainSid,
    IN SAM_HANDLE DomainHandle,
    IN PSID DomainSid,
    IN SAM_HANDLE UserHandle OPTIONAL,
    IN PSID       AccountSid,
    OUT PDWORD    PrivilegeRights,
    OUT PSCE_NAME_STATUS_LIST *pPrivList
    )
/* ++
Routine Description:

    This routine queries privilege/rights of a account by looking rights
    assigned to the account explicitly, to the local groups (aliases) the
    account is a member of, or to the global groups the account is a member
    of. The aliases are checked both directly and indirectly. the user rights
    are stores in a DWORD type variable PrivilegeRights, in which each bit
    represents a privilege/right.

Arguments:

    PolicyHandle    - Lsa Policy Domain handle

    BuiltinDomainHandle    - SAM builtin domain handle

    BuiltinDomainSid - SAM builtin domain SID

    DomainHandle    - SAM account domain handle

    DomainSid       - SAM account domain SID

    UserHandle      - SAM user account handle

    AccountSid      - The SID for the account

    PrivilegeRights - Privilege/Rights of this account

Return value:

    NTSTATUS
-- */
{
    NTSTATUS    NtStatus;
    SCESTATUS    rc;
    DWORD       Rights=0;
    PGROUP_MEMBERSHIP  GroupAttributes=NULL;
    ULONG       GroupCount=0;
    PSID        GroupSid=NULL;
    PSID        *Sids=NULL;
    ULONG       PartialCount;
    PULONG      Aliases=NULL;

    PSID        OtherSid=NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority=SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldAuthority=SECURITY_WORLD_SID_AUTHORITY;

    DWORD       i;
    PUNICODE_STRING      GroupName=NULL;
    PSID_NAME_USE        Use=NULL;



    // initialize
    *PrivilegeRights = 0;

    //
    // Check the explicitly assigned rights
    //

    NtStatus = ScepGetAccountExplicitRight(
                    PolicyHandle,
                    AccountSid,
                    &Rights
                    );

    if ( !NT_SUCCESS(NtStatus) )
        goto Done;

    *PrivilegeRights |= Rights;

    //
    // add to Privilege list
    //
    if ( pPrivList != NULL && Rights != 0 ) {
        rc = ScepAddToPrivList( pPrivList, Rights, NULL, 0 );
        if ( rc != SCESTATUS_SUCCESS ) {
            NtStatus = STATUS_NO_MEMORY;
            goto Done;
        }
    }

    if ( UserHandle != NULL ) {

        //
        // groups (direct) the account belongs to.
        //

        NtStatus = SamGetGroupsForUser(
                        UserHandle,
                        &GroupAttributes,
                        &GroupCount
                        );

        if ( GroupCount == 0 )
            NtStatus = ERROR_SUCCESS;

        if ( !NT_SUCCESS(NtStatus) )
            goto Done;
    }

        //
        // build sids including the user itself
        //

    Sids = (PSID *)ScepAlloc( (UINT)0, (GroupCount+1)*sizeof(PSID));
    if ( Sids == NULL ) {
        NtStatus = STATUS_NO_MEMORY;
        goto Done;
    }

    Sids[0] = AccountSid;

    //
    // get each group's explicitly assigned rights
    //

    for ( i=0; i < GroupCount; i++ ) {
        NtStatus = ScepDomainIdToSid(
                         DomainSid,
                         GroupAttributes[i].RelativeId,
                         &GroupSid
                         );
        if ( !NT_SUCCESS(NtStatus) )
            goto Done;

        //
        // Check the explicitly assigned rights for this group
        //

        Rights = 0;
        NtStatus = ScepGetAccountExplicitRight(
                        PolicyHandle,
                        GroupSid,
                        &Rights
                        );

        if ( !NT_SUCCESS(NtStatus) )
            goto Done;

        *PrivilegeRights |= Rights;
        //
        // add to Privilege list
        //
        if ( pPrivList != NULL && Rights != 0 ) {
            //
            // Lookup for group's name
            //
            NtStatus = SamLookupIdsInDomain(
                DomainHandle,
                1,
                &(GroupAttributes[i].RelativeId),
                &GroupName,
                &Use
                );

            if ( !NT_SUCCESS(NtStatus) )
                goto Done;

            rc = ScepAddToPrivList( pPrivList, Rights, GroupName[0].Buffer, GroupName[0].Length/2 );
            if ( rc != SCESTATUS_SUCCESS ) {
                NtStatus = STATUS_NO_MEMORY;
                goto Done;
            }

            SamFreeMemory(Use);
            Use = NULL;

            SamFreeMemory(GroupName);
            GroupName = NULL;
        }

        //
        // Save this Sid in the array for GetAliasMembership
        //
        Sids[i+1] = GroupSid;
        GroupSid = NULL;
    }

    //
    // See what indirect local groups the account belongs to.
    // account domain
    //

    NtStatus = SamGetAliasMembership(
                    DomainHandle,
                    GroupCount+1,
                    Sids,
                    &PartialCount,
                    &Aliases );

    if ( !NT_SUCCESS(NtStatus) )
        goto Done;

    for ( i=0; i<PartialCount; i++) {
        NtStatus = ScepDomainIdToSid(
                         DomainSid,
                         Aliases[i],
                         &GroupSid
                         );
        if ( !NT_SUCCESS(NtStatus) )
            goto Done;

        //
        // Check the explicitly assigned rights for this group
        //

        Rights = 0;
        NtStatus = ScepGetAccountExplicitRight(
                        PolicyHandle,
                        GroupSid,
                        &Rights
                        );

        if ( !NT_SUCCESS(NtStatus) )
            goto Done;

        *PrivilegeRights |= Rights;
        //
        // add to Privilege list
        //
        if ( pPrivList != NULL && Rights != 0 ) {
            //
            // Lookup for group's name
            //
            NtStatus = SamLookupIdsInDomain(
                DomainHandle,
                1,
                &(Aliases[i]),
                &GroupName,
                &Use
                );

            if ( !NT_SUCCESS(NtStatus) )
                goto Done;

            rc = ScepAddToPrivList( pPrivList, Rights, GroupName[0].Buffer, GroupName[0].Length/2 );
            if ( rc != SCESTATUS_SUCCESS ) {
                NtStatus = STATUS_NO_MEMORY;
                goto Done;
            }

            SamFreeMemory(Use);
            Use = NULL;

            SamFreeMemory(GroupName);
            GroupName = NULL;

        }

        ScepFree(GroupSid);
        GroupSid = NULL;
    }

    SamFreeMemory(Aliases);
    Aliases = NULL;

    //
    // check the builtin domain for alias membership
    //

    NtStatus = SamGetAliasMembership(
                    BuiltinDomainHandle,
                    GroupCount+1,
                    Sids,
                    &PartialCount,
                    &Aliases );

    if ( !NT_SUCCESS(NtStatus) )
        goto Done;

    for ( i=0; i<PartialCount; i++) {
        NtStatus = ScepDomainIdToSid(
                         BuiltinDomainSid,
                         Aliases[i],
                         &GroupSid
                         );
        if ( !NT_SUCCESS(NtStatus) )
            goto Done;

        //
        // Check the explicitly assigned rights for this group
        //

        Rights = 0;
        NtStatus = ScepGetAccountExplicitRight(
                        PolicyHandle,
                        GroupSid,
                        &Rights
                        );
        if ( !NT_SUCCESS(NtStatus) )
            goto Done;

        *PrivilegeRights |= Rights;
        //
        // add to Privilege list
        //
        if ( pPrivList != NULL && Rights != 0 ) {
            //
            // Lookup for group's name
            //
            NtStatus = SamLookupIdsInDomain(
                BuiltinDomainHandle,
                1,
                &(Aliases[i]),
                &GroupName,
                &Use
                );

            if ( !NT_SUCCESS(NtStatus) )
                goto Done;

            rc = ScepAddToPrivList( pPrivList, Rights, GroupName[0].Buffer, GroupName[0].Length/2 );
            if ( rc != SCESTATUS_SUCCESS ) {
                NtStatus = STATUS_NO_MEMORY;
                goto Done;
            }

            SamFreeMemory(Use);
            Use = NULL;

            SamFreeMemory(GroupName);
            GroupName = NULL;
        }

        ScepFree(GroupSid);
        GroupSid = NULL;
    }

    //
    // Checking privileges/rights for Everyone and Interactive Users
    //

    NtStatus = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    1,
                    SECURITY_INTERACTIVE_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &OtherSid
                    );

    if ( NT_SUCCESS(NtStatus) ) {

        Rights = 0;
        NtStatus = ScepGetAccountExplicitRight(
                        PolicyHandle,
                        OtherSid,
                        &Rights
                        );
        if ( !NT_SUCCESS(NtStatus) )
            goto Done;

        *PrivilegeRights |= Rights;
        //
        // add to Privilege list
        //
        if ( pPrivList != NULL && Rights != 0 ) {
            rc = ScepAddToPrivList( pPrivList, Rights, L"Interactive Users", 17 );
            if ( rc != SCESTATUS_SUCCESS ) {
                NtStatus = STATUS_NO_MEMORY;
                goto Done;
            }
        }

        RtlFreeSid(OtherSid);
        OtherSid = NULL;
    }

    NtStatus = RtlAllocateAndInitializeSid(
                    &WorldAuthority,
                    1,
                    SECURITY_WORLD_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &OtherSid
                    );

    if ( NT_SUCCESS(NtStatus) ) {

        Rights = 0;
        NtStatus = ScepGetAccountExplicitRight(
                        PolicyHandle,
                        OtherSid,
                        &Rights
                        );
        if ( !NT_SUCCESS(NtStatus) )
            goto Done;

        *PrivilegeRights |= Rights;
        //
        // add to Privilege list
        //
        if ( pPrivList != NULL && Rights != 0 ) {
            rc = ScepAddToPrivList( pPrivList, Rights, L"Everyone", 8 );
            if ( rc != SCESTATUS_SUCCESS ) {
                NtStatus = STATUS_NO_MEMORY;
                goto Done;
            }
        }
        RtlFreeSid(OtherSid);
        OtherSid = NULL;
    }

Done:

    SamFreeMemory(GroupAttributes);

    if ( GroupSid != NULL )
        ScepFree(GroupSid);

    if ( OtherSid != NULL )
        RtlFreeSid(OtherSid);

    if ( Sids != NULL ) {
        //
        // index 0 is the accountSid, DO NOT free
        //
        for ( i=1; i<GroupCount; i++ ) {
            ScepFree(Sids[i]);
        }
        ScepFree(Sids);
    }

    if ( Aliases != NULL )
        SamFreeMemory(Aliases);

    return NtStatus;

}
#endif



SCESTATUS
ScepAddAllBuiltinGroups(
    IN PSCE_GROUP_MEMBERSHIP *pGroupList
    )
{
    NTSTATUS                        NtStatus=ERROR_SUCCESS;
    SCESTATUS                       rc=SCESTATUS_SUCCESS;
    DWORD                           Win32rc;

    SAM_ENUMERATE_HANDLE            EnumerationContext=0;
    ULONG                           CountReturned;
    DWORD                           i;
    PVOID                           Buffer=NULL;

    SAM_HANDLE                      ServerHandle=NULL,
                                    DomainHandle=NULL,
                                    BuiltinDomainHandle=NULL;
    PSID                            DomainSid=NULL,
                                    BuiltinDomainSid=NULL;

    //
    // open sam handle
    //
    NtStatus = ScepOpenSamDomain(
                    SAM_SERVER_READ | SAM_SERVER_EXECUTE,
                    DOMAIN_READ | DOMAIN_EXECUTE,
                    &ServerHandle,
                    &DomainHandle,
                    &DomainSid,
                    &BuiltinDomainHandle,
                    &BuiltinDomainSid
                   );

    if (!NT_SUCCESS(NtStatus)) {

        Win32rc = RtlNtStatusToDosError(NtStatus);
        ScepLogOutput3(1, Win32rc, SCEDLL_ACCOUNT_DOMAIN);
        rc = ScepDosErrorToSceStatus(Win32rc);
        return( rc );
    }

    //
    // enumerate all aliases
    //
    do {
        NtStatus = SamEnumerateAliasesInDomain(
                        BuiltinDomainHandle,
                        &EnumerationContext,
                        &Buffer,
                        12000,
                        &CountReturned
                        );

        if ( NT_SUCCESS(NtStatus) && Buffer != NULL ) {

            for (i=0; i<CountReturned; i++) {

                //
                // add this group in
                //
                rc = ScepAddToGroupMembership(
                        pGroupList,
                        ((PSAM_SID_ENUMERATION)(Buffer))[i].Name.Buffer,
                        ((PSAM_SID_ENUMERATION)(Buffer))[i].Name.Length/2,
                        NULL,   // always use NULL list so mismatch will be raised for administrators, guests, and users
                        1,      // memberof list, members should be NC
                        TRUE,   // seek to the right group if one exists
                        FALSE   // if to overwrite the value if something is already there
                        );

                if ( rc != SCESTATUS_SUCCESS )
                    break;

            }
            SamFreeMemory( Buffer );
            Buffer = NULL;

        } else
            rc = ScepDosErrorToSceStatus(RtlNtStatusToDosError(NtStatus));

    } while ( NtStatus == STATUS_MORE_ENTRIES );

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // grouplist will be freed outside, so continue here
        //
    }

    //
    // close all handles
    //
    SamCloseHandle( DomainHandle );
    SamCloseHandle( BuiltinDomainHandle );
    SamCloseHandle( ServerHandle );

    if ( DomainSid != NULL )
        SamFreeMemory(DomainSid);

    if ( BuiltinDomainSid != NULL )
        RtlFreeSid(BuiltinDomainSid);


    return(rc);
}




SCESTATUS
ScepAnalyzeGroupMembership(
    IN PSCE_GROUP_MEMBERSHIP pGroupMembership
    )
/* ++
Routine Description:

    This routine queries groups specified in pGroupMembership and their members

Arguments:

    ppGroupMembership - The groups and members list in SMP profile

Return value:

    SCESTATUS

-- */
{

    SCESTATUS            rc=SCESTATUS_SUCCESS;

    if ( pGroupMembership == NULL ) {

        //
        // post progress
        //
        ScepPostProgress(TICKS_GROUPS,
                         AREA_GROUP_MEMBERSHIP,
                         NULL);

        return(rc);
    }

    DWORD               Win32rc;
    NTSTATUS            NtStatus;
    SAM_HANDLE          ServerHandle=NULL,
                        DomainHandle=NULL,
                        BuiltinDomainHandle=NULL;
    PSID                DomainSid=NULL,
                        BuiltinDomainSid=NULL;
    LSA_HANDLE          PolicyHandle=NULL;

    SAM_HANDLE          ThisDomain=NULL;
    PSID                ThisDomainSid=NULL;
    UNICODE_STRING      Name;
    PULONG              GrpId=NULL;
    PSID_NAME_USE       GrpUse=NULL;
    PSID                GrpSid=NULL;
    SAM_HANDLE          GroupHandle=NULL;

    PWSTR               KeyName=NULL;
    DWORD               GroupLen;
    PSCE_GROUP_MEMBERSHIP pGroup;
    PSCE_NAME_LIST        pGroupMembers=NULL;
    PSCE_NAME_LIST        pGroupsMemberof=NULL;
    PSCE_NAME_STATUS_LIST pPrivilegesHeld=NULL;
    BOOL                bDifferent;
    DWORD               nGroupCount=0;

    //
    // Open account domain
    //

    NtStatus = ScepOpenSamDomain(
                    SAM_SERVER_READ | SAM_SERVER_EXECUTE,
                    DOMAIN_READ | DOMAIN_EXECUTE,
                    &ServerHandle,
                    &DomainHandle,
                    &DomainSid,
                    &BuiltinDomainHandle,
                    &BuiltinDomainSid
                   );

    if (!NT_SUCCESS(NtStatus)) {
        Win32rc = RtlNtStatusToDosError(NtStatus);
        ScepLogOutput3(1, Win32rc, SCEDLL_ACCOUNT_DOMAIN);
        rc = ScepDosErrorToSceStatus(Win32rc);

        ScepPostProgress(TICKS_GROUPS,
                         AREA_GROUP_MEMBERSHIP,
                         NULL);

        return( rc );
    }

    //
    // open local policy
    //
    NtStatus = ScepOpenLsaPolicy(
                   POLICY_LOOKUP_NAMES,
                   &PolicyHandle,
                   TRUE
                   );
    if (!NT_SUCCESS(NtStatus)) {
        Win32rc = RtlNtStatusToDosError(NtStatus);
        ScepLogOutput3(1, Win32rc, SCEDLL_LSA_POLICY);
        rc = ScepDosErrorToSceStatus(Win32rc);
        goto Done;
    }

    //
    // Process each group in the GroupMembership list
    //

    UNICODE_STRING uName;
    LPTSTR pTemp;

    for ( pGroup=pGroupMembership; pGroup != NULL; pGroup = pGroup->Next ) {

        if ( (gOptions & SCE_GENERATE_ROLLBACK) &&
             (pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS) &&
             (pGroup->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) {
            continue;
        }

        if ( (ProductType == NtProductLanManNt) &&
             (pGroup->Status & SCE_GROUP_STATUS_DONE_IN_DS) ) {
            nGroupCount++;
            continue;
        }

        if ( KeyName ) {
            LocalFree(KeyName);
            KeyName = NULL;
        }

        pTemp = wcschr(pGroup->GroupName, L'\\');
        if ( pTemp ) {

            //
            // there is a domain name, check it with computer/domain name
            //

            uName.Buffer = pGroup->GroupName;
            uName.Length = ((USHORT)(pTemp-pGroup->GroupName))*sizeof(TCHAR);

            if ( !ScepIsDomainLocal(&uName) ) {
                ScepLogOutput3(1, 0, SCEDLL_NO_MAPPINGS, pGroup->GroupName);
                rc = SCESTATUS_INVALID_DATA;
                continue;
            }

            ScepConvertNameToSidString(
                    PolicyHandle,
                    pGroup->GroupName,
                    FALSE,
                    &KeyName,
                    &GroupLen
                    );

            pTemp++;

        } else {

            if ( ScepLookupNameTable(pGroup->GroupName, &KeyName ) ) {

                GroupLen = wcslen(KeyName);
            } else {
                KeyName = NULL;
                GroupLen = wcslen(pGroup->GroupName);
            }

            pTemp = pGroup->GroupName;
        }

        ScepLogOutput3(0,0, SCEDLL_SAP_ANALYZE, pGroup->GroupName);

        if ( nGroupCount < TICKS_GROUPS ) {
            ScepPostProgress(1, AREA_GROUP_MEMBERSHIP, pGroup->GroupName);
            nGroupCount++;
        }

        // initialize a UNICODE_STRING for the group name
        RtlInitUnicodeString(&Name, pTemp);

        //
        // lookup the group name in account domain first
        //
        NtStatus = SamLookupNamesInDomain(
                        DomainHandle,
                        1,
                        &Name,
                        &GrpId,
                        &GrpUse
                        );
        ThisDomain = DomainHandle;
        ThisDomainSid = DomainSid;

        if ( NtStatus == STATUS_NONE_MAPPED ) {
            //
            // not found in account domain. Lookup in the builtin domain
            //
            NtStatus = SamLookupNamesInDomain(
                            BuiltinDomainHandle,
                            1,
                            &Name,
                            &GrpId,
                            &GrpUse
                            );
            ThisDomain=BuiltinDomainHandle;
            ThisDomainSid = BuiltinDomainSid;
        }

        if ( NtStatus == STATUS_NONE_MAPPED ) {
            ScepLogOutput3(1, 0, SCEDLL_NO_MAPPINGS, pGroup->GroupName);

            gWarningCode = ERROR_SOME_NOT_MAPPED;
            NtStatus = STATUS_SUCCESS;

            if ( !(gOptions & SCE_GENERATE_ROLLBACK) ) {
                ScepRaiseErrorString(
                     hSection,
                     KeyName ? KeyName : pGroup->GroupName,
                     szMembers
                     );
            }

            continue;

        } else if ( !NT_SUCCESS(NtStatus) ) {
            Win32rc = RtlNtStatusToDosError(NtStatus);
            ScepLogOutput3(1, Win32rc, SCEDLL_NO_MAPPINGS, pGroup->GroupName);
            rc = ScepDosErrorToSceStatus(Win32rc);
            goto Done;
        }

        if ( GrpId[0] == DOMAIN_GROUP_RID_USERS ) {

//            ||
//             GrpId[0] == DOMAIN_ALIAS_RID_USERS )
            //
            // do not check this one
            //

            if ( !(gOptions & SCE_GENERATE_ROLLBACK) ) {
                ScepRaiseErrorString(
                     hSection,
                     KeyName ? KeyName : pGroup->GroupName,
                     szMembers
                     );
            }

            SamFreeMemory(GrpId);
            GrpId = NULL;

            SamFreeMemory(GrpUse);
            GrpUse = NULL;

            continue;
        }

        NtStatus = ScepDomainIdToSid(
                        ThisDomainSid,
                        GrpId[0],
                        &GrpSid
                        );
        if ( !NT_SUCCESS(NtStatus) ) {
            Win32rc = RtlNtStatusToDosError(NtStatus);
            rc = ScepDosErrorToSceStatus(Win32rc);
            goto Done;
        }

        // open the group to get a handle
        switch ( GrpUse[0] ) {
        case SidTypeGroup:
            NtStatus = SamOpenGroup(
                            ThisDomain,
                            GROUP_READ | GROUP_EXECUTE,
                            GrpId[0],
                            &GroupHandle
                            );

            break;
        case SidTypeAlias:
            NtStatus = SamOpenAlias(
                            ThisDomain,
                            ALIAS_READ | ALIAS_EXECUTE,
                            GrpId[0],
                            &GroupHandle
                            );
            break;
        default:
            NtStatus = STATUS_DATA_ERROR;
            ScepLogOutput3(1, 0, SCEDLL_INVALID_GROUP, pGroup->GroupName);
        }

        if ( !NT_SUCCESS(NtStatus) ) {
            Win32rc = RtlNtStatusToDosError(NtStatus);
            ScepLogOutput3(1, Win32rc,
                           SCEDLL_ERROR_OPEN, pGroup->GroupName);
            rc = ScepDosErrorToSceStatus(Win32rc);
            goto Done;
        }

        //
        //
        // compare members for the group
        //
        NtStatus = ScepCompareMembersOfGroup(
                        ThisDomain,
                        ThisDomainSid,
                        PolicyHandle,
                        GrpUse[0],
                        GroupHandle,
                        pGroup->pMembers,
                        &pGroupMembers,
                        &bDifferent
                        );

        if ( !NT_SUCCESS(NtStatus) ) {
            Win32rc = RtlNtStatusToDosError(NtStatus);
            ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_ANALYZE_MEMBERS, pGroup->GroupName);
            rc = ScepDosErrorToSceStatus(Win32rc);

            if ( STATUS_NONE_MAPPED == NtStatus ) {
                SamFreeMemory(GrpId);
                GrpId = NULL;

                SamFreeMemory(GrpUse);
                GrpUse = NULL;

                ScepFree(GrpSid);
                GrpSid = NULL;

                SamCloseHandle(GroupHandle);
                GroupHandle = NULL;

                continue;

            } else {
                goto Done;
            }
        }

        //
        // save members for the group
        // if there is any member difference, then save the whole member list
        //
        if ( bDifferent || ( (gOptions & SCE_GENERATE_ROLLBACK) &&
                             (pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS) ) ) {
            //
            // not same members, or not configured. Save pGroupMembers now
            //

            rc = ScepSaveMemberMembershipList(
                    PolicyHandle,
                    szMembers,
                    KeyName ? KeyName : pGroup->GroupName,
                    GroupLen,
                    pGroupMembers,
                    ( pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS ) ? 2 : 1
                    );
        }
        ScepFreeNameList(pGroupMembers);
        pGroupMembers = NULL;

        //
        // get memberof list
        //
        NtStatus = ScepGetGroupsForAccount(
                          DomainHandle,
                          BuiltinDomainHandle,
                          GroupHandle,
                          GrpSid,
                          &pGroupsMemberof
                          );
        if ( !NT_SUCCESS(NtStatus) ) {
            Win32rc = RtlNtStatusToDosError(NtStatus);
            ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_ANALYZE_MEMBEROF, pGroup->GroupName);
            rc = ScepDosErrorToSceStatus(Win32rc);
            goto Done;
        }

        //
        // not configured, or compare and save MemberOf for the group
        // pMemberOf must not have domain prefix because they must be alias
        //
        if ( ( pGroup->Status & SCE_GROUP_STATUS_NC_MEMBEROF ) ||
             SceCompareNameList(pGroup->pMemberOf, pGroupsMemberof) == FALSE ) {
            //
            // there is difference. Save the memberOf
            //
            INT iStat = 0;

            if ( (pGroup->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ||
                        (pGroup->pMemberOf == NULL) ) {
                iStat = 2;
            } else {
                iStat = 1;
            }

            rc = ScepSaveMemberMembershipList(
                    PolicyHandle,
                    szMemberof,
                    KeyName ? KeyName : pGroup->GroupName,
                    GroupLen,
                    pGroupsMemberof,
                    iStat
                    );
        }
        ScepFreeNameList(pGroupsMemberof);
        pGroupsMemberof = NULL;

        SamFreeMemory(GrpId);
        GrpId = NULL;

        SamFreeMemory(GrpUse);
        GrpUse = NULL;

        ScepFree(GrpSid);
        GrpSid = NULL;

        SamCloseHandle(GroupHandle);
        GroupHandle = NULL;
    }

Done:

    if ( KeyName != NULL )
        ScepFree(KeyName);

    if ( GrpId != NULL )
        SamFreeMemory(GrpId);

    if ( GrpUse != NULL )
        SamFreeMemory(GrpUse);

    if ( GrpSid != NULL )
        ScepFree(GrpSid);

    if ( pGroupMembers != NULL )
        ScepFreeNameList( pGroupMembers );

    if ( pGroupsMemberof != NULL )
        ScepFreeNameList( pGroupsMemberof );

    if ( pPrivilegesHeld != NULL )
        ScepFreeNameStatusList( pPrivilegesHeld );

    SamCloseHandle(GroupHandle);

    //
    // raise groups that are errored
    //
    if ( !(gOptions & SCE_GENERATE_ROLLBACK) ) {

        for ( PSCE_GROUP_MEMBERSHIP pTmpGrp=pGroup;
              pTmpGrp != NULL; pTmpGrp = pTmpGrp->Next ) {

            if ( pTmpGrp->GroupName == NULL ) {
                continue;
            }

            if ( pTmpGrp->Status & SCE_GROUP_STATUS_DONE_IN_DS ) {
                continue;
            }

            if ( wcschr(pTmpGrp->GroupName, L'\\') ) {

                ScepConvertNameToSidString(
                        PolicyHandle,
                        pTmpGrp->GroupName,
                        FALSE,
                        &KeyName,
                        &GroupLen
                        );
            } else {

                if ( !ScepLookupNameTable(pTmpGrp->GroupName, &KeyName ) ) {

                    KeyName = NULL;
                }

            }

            ScepRaiseErrorString(
                     hSection,
                     KeyName ? KeyName : pTmpGrp->GroupName,
                     szMembers
                     );

            if ( KeyName ) {
                LocalFree(KeyName);
                KeyName = NULL;
            }
        }
    }

    LsaClose( PolicyHandle);

    SamCloseHandle( DomainHandle );
    SamCloseHandle( BuiltinDomainHandle );
    SamCloseHandle( ServerHandle );
    if ( DomainSid != NULL ) {
        SamFreeMemory(DomainSid);
    }
    if ( BuiltinDomainSid != NULL ) {
        RtlFreeSid(BuiltinDomainSid);
    }

    //
    // post progress to the end of this area
    //

    if ( nGroupCount < TICKS_GROUPS ) {
        ScepPostProgress(TICKS_GROUPS-nGroupCount,
                         AREA_GROUP_MEMBERSHIP,
                         NULL);
    }

    return(rc);

}



SCESTATUS
ScepSaveMemberMembershipList(
    IN LSA_HANDLE LsaPolicy,
    IN PCWSTR szSuffix,
    IN PWSTR GroupName,
    IN DWORD GroupLen,
    IN PSCE_NAME_LIST pList,
    IN INT Status
    )
{
    PWSTR KeyName;
    SCESTATUS rc;

    if ( szSuffix == NULL || GroupName == NULL || GroupLen == 0 ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    KeyName = (PWSTR)ScepAlloc(0, (GroupLen+wcslen(szSuffix)+1)*sizeof(WCHAR));
    if ( KeyName != NULL ) {

        swprintf(KeyName, L"%s%s", GroupName, szSuffix);

        rc = ScepWriteNameListValue(
                LsaPolicy,
                hSection,
                KeyName,
                pList,
                SCE_WRITE_EMPTY_LIST | SCE_WRITE_CONVERT,
                Status
                );
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_SAP_ERROR_SAVE, GroupName);
        }
        ScepFree(KeyName);

    } else
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

    return(rc);
}



NTSTATUS
ScepCompareMembersOfGroup(
    IN SAM_HANDLE       DomainHandle,
    IN PSID             ThisDomainSid,
    IN LSA_HANDLE       PolicyHandle,
    IN SID_NAME_USE     GrpUse,
    IN SAM_HANDLE       GroupHandle,
    IN PSCE_NAME_LIST    pChkMembers,
    OUT PSCE_NAME_LIST   *ppMembers,
    OUT PBOOL           bDifferent
    )
/* ++
Routine Description:

    This routine compares members in a group GroupHandle in the domain specified
    by ThisDomainSid with the pChkMembers list. If there is mismatch, the current
    members are added to the output list ppMembers. The domain can be account
    domain or the builtin domain. Groups can be global groups or aliases, indicated
    by GrpUse.

Arguments:

    ThisDomainSid - The domain SID

    PolicyHandle - The LSA policy handle

    GrpUse   - The "type" of the group

    GroupHandle - the group handle

    pChkMembers - The member list to check with

    ppMembers - The group members list to output

Return value:

    NTSTATUS
-- */
{
    NTSTATUS                NtStatus=ERROR_SUCCESS;

    PULONG                  MemberIds=NULL;
    PULONG                  Attributes=NULL;
    ULONG                   MemberCount=0;
    PUNICODE_STRING         Names=NULL;
    PSID_NAME_USE           Use=NULL;

    PSID                    *MemberAliasSids=NULL;
    PLSA_REFERENCED_DOMAIN_LIST     ReferencedDomains=NULL;
    PLSA_TRANSLATED_NAME            LsaNames=NULL;

    PUNICODE_STRING         MemberNames=NULL;
    PSID                    *Sids=NULL;
    ULONG                   ChkCount=0;

    DWORD                   i, j;
    DWORD                   rc;
    BOOL                    bMismatch;


    *ppMembers = NULL;
    *bDifferent = FALSE;

    switch ( GrpUse ) {
    case SidTypeGroup:

        NtStatus = SamGetMembersInGroup(
                        GroupHandle,
                        &MemberIds,
                        &Attributes,
                        &MemberCount
                        );
        if ( !NT_SUCCESS(NtStatus) )
            goto Done;
//
// group members only exist in the same domain as the group
//
        if ( MemberCount > 0 ) {

            NtStatus = SamLookupIdsInDomain(
                            DomainHandle,
                            MemberCount,
                            MemberIds,
                            &Names,
                            &Use
                            );
        }
        break;
    case SidTypeAlias:
//
// members of alias may exist in everywhere
//
        NtStatus = SamGetMembersInAlias(
                        GroupHandle,
                        &MemberAliasSids,
                        &MemberCount
                        );

        break;
    default:
        NtStatus = STATUS_DATA_ERROR;
        ScepLogOutput3(1, 0, SCEDLL_INVALID_GROUP);
        return(NtStatus);
    }

    if ( !NT_SUCCESS(NtStatus) )
        goto Done;

    if ( GrpUse == SidTypeGroup ) {
        //
        // add members to the list
        // DomainHandle must point to a account domain because builtin domain
        // won't have SidTypeGroup account
        //
        PDOMAIN_NAME_INFORMATION DomainName=NULL;

        SamQueryInformationDomain(
                DomainHandle,
                DomainNameInformation,
                (PVOID *)&DomainName
                );

        for (j=0; j<MemberCount; j++) {
            if ( Names[j].Length <= 0 )
                continue;
            if ( DomainName && DomainName->DomainName.Length > 0 &&
                 DomainName->DomainName.Buffer ) {
                rc = ScepAddTwoNamesToNameList(
                                  ppMembers,
                                  TRUE,
                                  DomainName->DomainName.Buffer,
                                  DomainName->DomainName.Length/2,
                                  Names[j].Buffer,
                                  Names[j].Length/2
                                  );
            } else {
                rc = ScepAddToNameList(ppMembers, Names[j].Buffer, Names[j].Length/2);
            }

#ifdef SCE_DBG
            wprintf(L"rc=%d, Add %s to Members list\n", rc, Names[j].Buffer);
#endif
        }

        // compare with pChkMembers
        if ( !(gOptions & SCE_NO_ANALYZE) && ScepCompareGroupNameList(&(DomainName->DomainName),
                                                    pChkMembers,
                                                    *ppMembers) == TRUE ) {
            //
            // it is same. return NULL for ppMembers
            //
            ScepFreeNameList(*ppMembers);
            *ppMembers = NULL;
        } else {

            *bDifferent = TRUE;
        }

        if ( DomainName ) {
            SamFreeMemory(DomainName);
            DomainName = NULL;
        }
    } else {  // alias
        // translate pChkMembers to Sids
        NtStatus = ScepGetMemberListSids(
                            ThisDomainSid,
                            PolicyHandle,
                            pChkMembers,
                            &MemberNames,
                            &Sids,
                            &ChkCount
                            );
        bMismatch = FALSE;

        //
        // if returned error, we consider the members different
        //

        if ( NT_SUCCESS(NtStatus) && !(gOptions & SCE_NO_ANALYZE) ) {
/*
            // The number of members on system and in the configuration must match, including
            // unmapped accounts.
            DWORD newCount=0;
            for ( i=0; i<ChkCount; i++ )
                if ( Sids[i] != NULL ) newCount++;

            if ( newCount == MemberCount ) {
*/
            if ( ChkCount == MemberCount ) {

                for ( i=0; i<ChkCount; i++ ) {

                    if ( Sids[i] != NULL ) {

                        for ( j=0; j<MemberCount; j++ ) {

                           if ( Sids[i] != NULL && MemberAliasSids[j] != NULL &&
                                EqualSid(Sids[i], MemberAliasSids[j]) )
                               break;
                        }
                        if ( j >= MemberCount )
                            // not find a match
                            break;
                    } else {
                        // a mismatch for unmapped account
                        break;
                    }
                }
                if ( i < ChkCount )
                    // something mismatch
                    bMismatch = TRUE;
            } else
                bMismatch = TRUE;

        } else if ( NtStatus != STATUS_NO_MEMORY ) {
            NtStatus = STATUS_SUCCESS;
            bMismatch = TRUE;
        }

        *bDifferent = bMismatch;

        if ( bMismatch ) {
            //
            // translate SID into names
            //
            if ( MemberCount > 0 ) {
                NtStatus = LsaLookupSids(
                             PolicyHandle,
                             MemberCount,
                             MemberAliasSids,
                             &ReferencedDomains,
                             &LsaNames
                             );
                if ( !NT_SUCCESS(NtStatus) )
                    goto Done;
            }
            //
            // add members to the list to output
            //
            PWSTR StringSid;

            for (j=0; j<MemberCount; j++) {
                //
                // shouldn't ignore the unknown accounts
                // they might be unresolvable at this moment - show SID string instead
                //
//                if ( LsaNames[j].Name.Length <= 0 )
//                    continue;

                if ( LsaNames[j].Use == SidTypeInvalid ||
                     LsaNames[j].Use == SidTypeUnknown ||
                     LsaNames[j].Name.Length <= 0 ) {
                     //
                     // convert SID to sid string
                     //
                    if ( ScepConvertSidToPrefixStringSid(
                                MemberAliasSids[j],
                                &StringSid) ) {

                        ScepAddToNameList(ppMembers, StringSid, 0);

                        ScepFree(StringSid);
                        StringSid = NULL;
                    }
                    continue;
                }

                if ( ReferencedDomains->Entries > 0 && LsaNames[0].Use != SidTypeWellKnownGroup &&
                     ReferencedDomains->Domains != NULL &&
                     LsaNames[j].DomainIndex != -1 &&
                     (ULONG)(LsaNames[j].DomainIndex) < ReferencedDomains->Entries &&
                     ScepIsSidFromAccountDomain( ReferencedDomains->Domains[LsaNames[j].DomainIndex].Sid ) ) {
                    //
                    // should add both the domain name and the account name
                    //
                    rc = ScepAddTwoNamesToNameList(
                                  ppMembers,
                                  TRUE,
                                  ReferencedDomains->Domains[LsaNames[j].DomainIndex].Name.Buffer,
                                  ReferencedDomains->Domains[LsaNames[j].DomainIndex].Name.Length/2,
                                  LsaNames[j].Name.Buffer,
                                  LsaNames[j].Name.Length/2
                                  );
#ifdef SCE_DBG
                wprintf(L"rc=%d, Add %s\\%s to Members list\n", rc,
                    ReferencedDomains->Domains[LsaNames[j].DomainIndex].Name.Buffer, LsaNames[j].Name.Buffer);
#endif
                } else {
                    rc = ScepAddToNameList(ppMembers, LsaNames[j].Name.Buffer, LsaNames[j].Name.Length/2);
#ifdef SCE_DBG
                wprintf(L"rc=%d, Add %s to Members list\n", rc, LsaNames[j].Name.Buffer);
#endif
                }
                if ( rc != NO_ERROR) {
                    NtStatus = STATUS_NO_MEMORY;
                    goto Done;
                }
            }
        }
    }

Done:

    if (Use != NULL)
        SamFreeMemory(Use);

    if (Names != NULL)
        SamFreeMemory(Names);

    if (MemberIds != NULL)
        SamFreeMemory(MemberIds);

    if (Attributes != NULL)
        SamFreeMemory(Attributes);

    if (MemberAliasSids != NULL)
        SamFreeMemory(MemberAliasSids);

    if (ReferencedDomains != NULL)
        LsaFreeMemory(ReferencedDomains);

    if (LsaNames != NULL)
        LsaFreeMemory(LsaNames);

    if ( Sids != NULL ) {
        for ( i=0; i<ChkCount; i++ ) {
            if ( Sids[i] != NULL )
                ScepFree( Sids[i] );
        }
        ScepFree( Sids );
    }

    if ( MemberNames != NULL )
        RtlFreeHeap(RtlProcessHeap(), 0, MemberNames);

    return(NtStatus);
}



SCESTATUS
ScepEnumerateRegistryRoots(
    OUT PSCE_OBJECT_LIST *pRoots
    )
/*
Routine Description:

    Enumerate all registry roots (MACHINE, USERS, CURRENT_USER, CLASSES_ROOT,
    and CONFIG) and add them to pRoots. If the root is already in the list,
    ignore the addition.

    This routine is used for analysis of all registry roots no matter if the
    root is specified in the profile.

Arguments:

    pRoots - the object list to add to

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_NOT_ENOUGH_RESOURCE
*/
{
    DWORD rc;

    rc = ScepAddToObjectList(
                pRoots,
                L"MACHINE",
                7,
                TRUE,
                SCE_STATUS_IGNORE,
                0,
                SCE_CHECK_DUP  //TRUE // check for duplicate
                );

    if ( rc != ERROR_SUCCESS ) {
        ScepLogOutput3(1, rc, SCEDLL_SAP_ERROR_ADD, L"MACHINE");

        if ( rc == ERROR_NOT_ENOUGH_MEMORY ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }
    }
    //
    // ignore invalid parameter error and continue
    //
    rc = ScepAddToObjectList(
                pRoots,
                L"USERS",
                5,
                TRUE,
                SCE_STATUS_IGNORE,
                0,
                SCE_CHECK_DUP // TRUE
                );

    if ( rc != ERROR_SUCCESS ) {
        ScepLogOutput3(1, rc, SCEDLL_SAP_ERROR_ADD, L"USERS");

        if ( rc == ERROR_NOT_ENOUGH_MEMORY ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }
    }

    //
    // ignore invalid parameter error and continue
    //
    rc = ScepAddToObjectList(
                pRoots,
                L"CLASSES_ROOT",
                12,
                TRUE,
                SCE_STATUS_IGNORE,
                0,
                SCE_CHECK_DUP //TRUE
                );

    if ( rc != ERROR_SUCCESS ) {
        ScepLogOutput3(1, rc, SCEDLL_SAP_ERROR_ADD, L"CLASSES_ROOT");

        if ( rc == ERROR_NOT_ENOUGH_MEMORY ) {
            return(SCESTATUS_NOT_ENOUGH_RESOURCE);
        }
    }

    return(SCESTATUS_SUCCESS);
}



SCESTATUS
ScepEnumerateFileRoots(
    OUT PSCE_OBJECT_LIST *pRoots
    )
/*
Routine Description:

    Add all local disk drives (DRIVE_FIXED, DRIVE_REMOVABLE, DRIVE_RAMDISK)
    to the list if they are not in the list. The drive is added to the list
    in the format of a drive letter plus ":\". If the drive is already in
    the list, ignore the addition.

    This routine is used for analysis of all disk drives no matter if the
    drive is specified in the profile.

Arguments:

    pRoots - the object list to add to

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_NOT_ENOUGH_RESOURCE
*/
{
    SCESTATUS            rc=SCESTATUS_SUCCESS;
    DWORD               Length;
    TCHAR               Drives[128];   // 128 characters is enough for 32 drives
    PWSTR               pTemp;
    UINT                dType;
    DWORD               Len;


    memset(Drives, '\0', 256);
    Length = GetLogicalDriveStrings(127, Drives);

    if ( Length > 0 ) {

        pTemp = Drives;
        while ( *pTemp != L'\0') {

           dType = GetDriveType(pTemp);
           Len = wcslen(pTemp);

           if ( dType == DRIVE_FIXED ||
                dType == DRIVE_RAMDISK ) {
               //
               // add this to the root object list (check duplicate)
               //
               pTemp[Len-1] = L'\0';  // take out the '\'
                rc = ScepAddToObjectList(
                            pRoots,
                            pTemp,
                            Len-1, // only drive letter and ':' is added
                            TRUE,
                            SCE_STATUS_IGNORE,
                            0,
                            SCE_CHECK_DUP // TRUE
                            );
                if ( rc != ERROR_SUCCESS ) {
                    //
                    // Log the error and continue
                    //
                    ScepLogOutput3(1, rc, SCEDLL_SAP_ERROR_ADD, pTemp);

                    if ( rc == ERROR_NOT_ENOUGH_MEMORY ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                        break;
                    } else {
                        // ignore other errors

                        rc = SCESTATUS_SUCCESS;
                    }
                }
           }
           //
           // go to next drive
           //
           pTemp += (Len + 1);
        }
    } else {
        //
        // ignore this error, only log it
        //
        ScepLogOutput3(1, GetLastError(), SCEDLL_ERROR_QUERY_INFO, L"file system");
    }

    return(rc);
}



SCESTATUS
ScepAnalyzeObjectSecurity(
   IN PSCE_OBJECT_LIST pRoots,
   IN AREA_INFORMATION Area,
   IN BOOL bSystemDb
   )
/* ++

Routine Description:

   Analyze the security setting on objects (registry keys, files, etc) as
   specified in pObjectCheckList. The Recursive is TRUE, all sub keys/
   directories under a object will be checked too. All checked objects
   and their security settings are returned in ppObjectChecked


Arguments:

   pObjectCheckList   - a n-tree of objects to check

   ObjectType         - Indicate permission or auditing

   Recursive          - TRUE = check all subkeys/directories

Return value:

   SCESTATUS error codes

++ */
{
    SCESTATUS            rc;
    DWORD               Win32rc=NO_ERROR;
    HANDLE              Token;
    PSCE_OBJECT_LIST     pOneRoot;
    PSCE_OBJECT_CHILD_LIST   pSecurityObject=NULL;
    PCWSTR              SectionName=NULL;
    DWORD               FileSystemFlags;
    PSCE_OBJECT_LIST        pTempRoot=NULL;
    WCHAR       theDrive[4];
    UINT        DriveType;


    if ( pRoots == NULL && Area != AREA_DS_OBJECTS ) {
        return(SCESTATUS_SUCCESS);
    }

    switch (Area) {
    case AREA_REGISTRY_SECURITY:
        SectionName = szRegistryKeys;
        break;
    case AREA_FILE_SECURITY:
        SectionName = szFileSecurity;
        break;
#if 0
    case AREA_DS_OBJECTS:
        SectionName = szDSSecurity;
        break;
#endif
    default:
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // get current thread/process's token
    //
    if (!OpenThreadToken( GetCurrentThread(),
                          TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, //TOKEN_ALL_ACCESS,
                          FALSE,
                          &Token)) {
        if (!OpenProcessToken( GetCurrentProcess(),
                               TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, //TOKEN_ALL_ACCESS,
                               &Token)) {
            ScepLogOutput3(1, GetLastError(), SCEDLL_ERROR_QUERY_INFO, L"TOKEN");
            return(ScepDosErrorToSceStatus(GetLastError()));
        }
    }

    //
    // SE_SECURITY_PRIVILEGE, ignore the error if can't adjust privilege
    //
    Win32rc = SceAdjustPrivilege( SE_SECURITY_PRIVILEGE, TRUE, Token );

    if ( Win32rc != NO_ERROR ) {
        ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_ADJUST, L"SE_SECURITY_PRIVILEGE");
    }
    //
    // Prepare JET section to write to
    //
    rc = ScepStartANewSection(
                hProfile,
                &hSection,
                SCEJET_TABLE_SAP,
                SectionName
                );
    if ( rc != SCESTATUS_SUCCESS ) {
        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                       SCEDLL_SAP_START_SECTION, (PWSTR)SectionName);
        goto Done;
    }

    if ( Area == AREA_DS_OBJECTS && pRoots == NULL ) {
        //
        // nothing specified in the template, then save the domain in SAP
        //
        rc = ScepLdapOpen(NULL);

        if ( rc == SCESTATUS_SUCCESS ) {

            rc = ScepEnumerateDsObjectRoots(NULL, &pTempRoot);

            if ( rc == SCESTATUS_SUCCESS ) {

                rc = ScepSaveDsStatusToSection(
                            pTempRoot->Name,
                            TRUE,
                            SCE_STATUS_NOT_CONFIGURED,
                            NULL,
                            0
                            );
                ScepFreeObjectList(pTempRoot);
            }
            ScepLdapClose(NULL);
        }
        if ( rc != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                           SCEDLL_SAP_ERROR_SAVE, SectionName);
        }
    }

    //
    // Process each root
    // note: SCE_STATUS_NO_AUTO_INHERIT is treated the same as SCE_STATUS_CHECK
    // in analysis
    //
    for ( pOneRoot=pRoots; pOneRoot != NULL; pOneRoot=pOneRoot->Next ) {

        if ( Area == AREA_FILE_SECURITY &&
            (pOneRoot->Status == SCE_STATUS_CHECK ||
             pOneRoot->Status == SCE_STATUS_NO_AUTO_INHERIT ||
             pOneRoot->Status == SCE_STATUS_OVERWRITE) ) {

            //
            // make sure the input data follows file format
            //
            if ( pOneRoot->Name[1] != L'\0' && pOneRoot->Name[1] != L':') {

                ScepLogOutput3(1, ERROR_INVALID_DATA, SCEDLL_CANNOT_FIND, pOneRoot->Name);

                rc = ScepSaveObjectString(
                                hSection,
                                pOneRoot->Name,
                                FALSE,
                                SCE_STATUS_ERROR_NOT_AVAILABLE,
                                NULL,
                                0
                                );
                continue;
            }

            //
            // check if support acl
            //
            theDrive[0] = pOneRoot->Name[0];
            theDrive[1] = L':';
            theDrive[2] = L'\\';
            theDrive[3] = L'\0';

            DriveType = GetDriveType(theDrive);

            if ( DriveType == DRIVE_FIXED ||
                 DriveType == DRIVE_RAMDISK ) {

                if ( GetVolumeInformation(theDrive,
                                          NULL,
                                          0,
                                          NULL,
                                          NULL,
                                          &FileSystemFlags,
                                          NULL,
                                          0
                                        ) == TRUE ) {

                     if ( !( FileSystemFlags & FS_PERSISTENT_ACLS)  ) {

                        pOneRoot->Status = SCE_STATUS_NO_ACL_SUPPORT;

                        rc = ScepSaveObjectString(
                                        hSection,
                                        theDrive,
                                        TRUE,
                                        SCE_STATUS_NO_ACL_SUPPORT,
                                        NULL,
                                        0
                                        );

                        if ( rc != SCESTATUS_SUCCESS )
                            goto Done;

                        continue;
                     }

                } else {
                    //
                    // ignore the error and treat the drive as NTFS
                    // if it is not, it will error out later
                    //
                    ScepLogOutput3(1, GetLastError(),
                                   SCEDLL_ERROR_QUERY_VOLUME, theDrive);
                }

            } else {

                rc = ScepSaveObjectString(
                                hSection,
                                theDrive,
                                TRUE,
                                SCE_STATUS_NO_ACL_SUPPORT,
                                NULL,
                                0
                                );
                if ( rc != SCESTATUS_SUCCESS )
                    goto Done;

                continue;
            }

        }

        if ( pOneRoot->Status != SCE_STATUS_CHECK &&
             pOneRoot->Status != SCE_STATUS_NO_AUTO_INHERIT &&
             pOneRoot->Status != SCE_STATUS_OVERWRITE ) {
            //
            // log a point in SAP for not analyzing
            //
            if ( Area == AREA_DS_OBJECTS ) {
                rc = ScepSaveDsStatusToSection(
                            pOneRoot->Name,
                            TRUE,
                            SCE_STATUS_NOT_CONFIGURED,
                            NULL,
                            0
                            );
            } else {
                rc = ScepSaveObjectString(
                            hSection,
                            pOneRoot->Name,
                            TRUE,
                            SCE_STATUS_NOT_CONFIGURED,
                            NULL,
                            0
                            );
            }

            if ( rc != SCESTATUS_SUCCESS )
                goto Done;

            continue;
        }
        //
        // read scp information for this area
        //
        rc = ScepGetOneSection(
                        hProfile,
                        Area,
                        pOneRoot->Name,
                        bSystemDb ? SCE_ENGINE_SCP : SCE_ENGINE_SMP,
                        (PVOID *)&pSecurityObject
                        );
        if ( rc != SCESTATUS_SUCCESS )
            goto Done;

        if ( pSecurityObject == NULL ) {
            continue;
        }

        //
        // then process each node in the list
        //
        for (PSCE_OBJECT_CHILD_LIST pTemp = pSecurityObject; pTemp != NULL; pTemp=pTemp->Next) {

            if ( pTemp->Node == NULL ) continue;

            if ( Area == AREA_FILE_SECURITY ) {
                if ( pTemp->Node->ObjectFullName[1] == L':' &&
                     pTemp->Node->ObjectFullName[2] == L'\0' ) {

                    pTemp->Node->ObjectFullName[2] = L'\\';
                    pTemp->Node->ObjectFullName[3] = L'\0';
                }
            }

            //
            // compute the "real" security descriptor for each node,
            // Ds objects DO NOT need to be computed
            //
            if ( Area == AREA_FILE_SECURITY ) {
                rc = ScepCalculateSecurityToApply(
                            pTemp->Node,
                            SE_FILE_OBJECT,
                            Token,
                            &FileGenericMapping
                            );
            } else if ( Area == AREA_REGISTRY_SECURITY ) {
                rc = ScepCalculateSecurityToApply(
                            pTemp->Node,
                            SE_REGISTRY_KEY,
                            Token,
                            &KeyGenericMapping
                            );
            }

            if ( rc != SCESTATUS_SUCCESS ) {
                ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                               SCEDLL_ERROR_COMPUTESD,
                             pTemp->Node->ObjectFullName);
                goto Done;

            } else {
                BadCnt = 0;

                if ( Area == AREA_FILE_SECURITY ) {
                    //
                    // analyze file object tree
                    //
                    Win32rc = ScepAnalyzeOneObjectInTree(
                                   pTemp->Node,
                                   SE_FILE_OBJECT,
                                   Token,
                                   &FileGenericMapping
                                   );
                } else if ( Area == AREA_REGISTRY_SECURITY ) {
                    //
                    // analyze registry object tree
                    //
                    Win32rc = ScepAnalyzeOneObjectInTree(
                                   pTemp->Node,
                                   SE_REGISTRY_KEY,
                                   Token,
                                   &KeyGenericMapping
                                   );
                } else {
                    //
                    // analyze ds objects
                    //
                    Win32rc = ScepAnalyzeDsSecurity( pTemp->Node );
                }

                ScepLogOutput3(0, Win32rc, IDS_ANALYSIS_MISMATCH,
                               BadCnt, pTemp->Node->ObjectFullName);
                rc = ScepDosErrorToSceStatus(Win32rc);
            }

            if ( rc != ERROR_SUCCESS ) {
                break;
            }
        }

        ScepFreeObject2Security( pSecurityObject, FALSE);
        pSecurityObject = NULL;
    }

Done:
    //
    // if privilege is adjusted, turn it off.
    //

    SceAdjustPrivilege( SE_SECURITY_PRIVILEGE, FALSE, Token );

    CloseHandle(Token);

    if ( pSecurityObject != NULL )
        ScepFreeObject2Security( pSecurityObject, FALSE);

    return(rc);

}



DWORD
ScepAnalyzeOneObjectInTree(
    IN PSCE_OBJECT_TREE ThisNode,
    IN SE_OBJECT_TYPE ObjectType,
    IN HANDLE Token,
    IN PGENERIC_MAPPING GenericMapping
    )
/* ++

Routine Description:

   Recursively Analyze each node in the object tree. If Recursive is set to
   TRUE, all sub keys/directories under an node will be analyzed too. All
   files/directories with DIFFERENT security setting from the profile are
   returned in ppObjectChecked.


Arguments:

   ThisNode           - one node in the n-tree to analyze

   ObjectType         - Indicate file object or registry object

   Token              - thread token used to compute creator owner

   GenericMapping     - generic access mapping

Return value:

   SCESTATUS error codes

++ */
{

    DWORD           rc=NO_ERROR;
    BOOL StartChecking = FALSE;
    PSCE_OBJECT_TREE pTempNode;


    if ( ThisNode == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( ThisNode->Status != SCE_STATUS_CHECK &&
         ThisNode->Status != SCE_STATUS_NO_AUTO_INHERIT &&
         ThisNode->Status != SCE_STATUS_OVERWRITE ) {
        //
        // Log a point in SAP
        //
        rc = ScepSaveObjectString(
                    hSection,
                    ThisNode->ObjectFullName,
                    ThisNode->IsContainer,
                    SCE_STATUS_NOT_CONFIGURED,
                    NULL,
                    0
                    );

        goto SkipNode;
    }

    if ( ThisNode->pSecurityDescriptor != NULL ) {
        //
        // notify the progress bar if there is any
        //
        switch(ObjectType) {
        case SE_FILE_OBJECT:
            ScepPostProgress(1, AREA_FILE_SECURITY, ThisNode->ObjectFullName);
            break;
        case SE_REGISTRY_KEY:
            ScepPostProgress(1, AREA_REGISTRY_SECURITY, ThisNode->ObjectFullName);
            break;
        default:
            ScepPostProgress(1, 0, ThisNode->ObjectFullName);
            break;
        }
    }

    //
    // find if this is the first node in this path to be configured
    //

    for ( pTempNode=ThisNode; pTempNode != NULL;
          pTempNode = pTempNode->Parent ) {

        if ( NULL != pTempNode->pApplySecurityDescriptor ) {

            StartChecking = TRUE;
            break;
        }
    }

    if ( StartChecking &&
         ( NULL != ThisNode->pSecurityDescriptor) ||
         ( ThisNode->Status == SCE_STATUS_OVERWRITE ) ) {

        //
        // only analyze objects with explicit aces specified,
        // or when parent's status is overwrite
        // if this node doesn't have a SD, it's status is coming from the parent
        //
        // process this node first
        //
        rc = ScepAnalyzeObjectOnly(
                    ThisNode->ObjectFullName,
                    ThisNode->IsContainer,
                    ObjectType,
                    ThisNode->pApplySecurityDescriptor,
                    ThisNode->SeInfo
                    );
        //
        // if the object denies access, skip it.
        //
        if ( rc == ERROR_ACCESS_DENIED ||
             rc == ERROR_CANT_ACCESS_FILE ||
             rc == ERROR_SHARING_VIOLATION) {
            //
            // log a point in SAP for skipping
            //
            gWarningCode = rc;

            goto ProcChild;
        }
        //
        // if the object specified in the profile does not exist, skip it and children
        //
        if ( rc == ERROR_FILE_NOT_FOUND ||
             rc == ERROR_PATH_NOT_FOUND ||
             rc == ERROR_INVALID_HANDLE ) {

            gWarningCode = rc;

            rc = SCESTATUS_SUCCESS;
            goto SkipNode;
        }

    } else {
        //
        // log a point in SAP for not analyzing
        //
        rc = ScepSaveObjectString(
                    hSection,
                    ThisNode->ObjectFullName,
                    ThisNode->IsContainer,
                    SCE_STATUS_CHILDREN_CONFIGURED,
                    NULL,
                    0
                    );
    }
    if ( rc != ERROR_SUCCESS )
        return(rc);

    //
    // only process the child objects if the flag is overwrite
    // because for auto-inherit or no inherit case, all child objects will
    // be enumerated as "N.C." status by GetObjectChildren api.
    //

    PSCE_OBJECT_CHILD_LIST pTemp;

    if ( (StartChecking  && ThisNode->Status == SCE_STATUS_OVERWRITE) ) { //||
//         (!StartChecking && NULL != ThisNode->LeftChild ) ) {
        //
        // analyze security for other files/keys under this directory
        // or log SAP point for not analyzing
        //


        DWORD           BufSize;
        PWSTR           Buffer=NULL;
        INT             i;
        DWORD           EnumRc=0;


        switch ( ObjectType ) {
        case SE_FILE_OBJECT:

            struct _wfinddata_t *    pFileInfo;
            //
            // find all files under this directory/file
            //
            pFileInfo = (struct _wfinddata_t *)ScepAlloc(0,sizeof(struct _wfinddata_t));
            if ( pFileInfo == NULL ) {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            BufSize = wcslen(ThisNode->ObjectFullName)+4;
            Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
            if ( Buffer == NULL ) {
                ScepFree(pFileInfo);
                pFileInfo = NULL;
                rc = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            BOOL            BackSlashExist;
            intptr_t            hFile;

            BackSlashExist = ScepLastBackSlash(ThisNode->ObjectFullName);
            if ( BackSlashExist )
                swprintf(Buffer, L"%s*.*", ThisNode->ObjectFullName);
            else
                swprintf(Buffer, L"%s\\*.*", ThisNode->ObjectFullName);

            hFile = _wfindfirst(Buffer, pFileInfo);

            ScepFree(Buffer);
            Buffer = NULL;

            if ( hFile != -1 ) {
                do {
                    if ( wcscmp(L"..", pFileInfo->name) == 0 ||
                         wcscmp(L".", pFileInfo->name) == 0 )
                        continue;

                    //
                    // if the file/subdir is in the children list
                    // process it later.
                    //
                    for ( pTemp = ThisNode->ChildList, i=-1;
                          pTemp != NULL;
                          pTemp = pTemp->Next ) {
                        if ( pTemp->Node == NULL ) continue;
                        i=_wcsicmp(pTemp->Node->Name, pFileInfo->name);
                        if ( i == 0 )
                            break;
                    }

                    if ( pTemp == NULL || i != 0 ) {
                        //
                        // The name is not in the list, so analyze this one
                        //
                        BufSize = wcslen(ThisNode->ObjectFullName)+wcslen(pFileInfo->name)+1;
                        Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                        if ( Buffer == NULL ) {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                            break;
                        }
                        if ( BackSlashExist )
                            swprintf(Buffer, L"%s%s", ThisNode->ObjectFullName, pFileInfo->name);
                        else
                            swprintf(Buffer, L"%s\\%s", ThisNode->ObjectFullName, pFileInfo->name);

                        EnumRc = pFileInfo->attrib; // borrow this variable temperaorily

                        ScepFree(pFileInfo);
                        pFileInfo = NULL;

//                      if ( StartChecking ) { // raise N.C. status even for SCE_STATUS_CHECK
                        if ( StartChecking && ThisNode->Status == SCE_STATUS_OVERWRITE ) {
                            //
                            // do not check owner and group information
                            //
                            if ( EnumRc & _A_SUBDIR ) {

                                rc = ScepAnalyzeObjectAndChildren(
                                            Buffer,
                                            ObjectType,
                                            NULL,
                                            (ThisNode->SeInfo & DACL_SECURITY_INFORMATION) |
                                            (ThisNode->SeInfo & SACL_SECURITY_INFORMATION)
                                            );
                            } else {
                                rc = ScepAnalyzeObjectOnly(
                                            Buffer,
                                            FALSE,
                                            ObjectType,
                                            NULL,
                                            (ThisNode->SeInfo & DACL_SECURITY_INFORMATION) |
                                            (ThisNode->SeInfo & SACL_SECURITY_INFORMATION)
                                            );
                            }
                        } else {
/*
                            //
                            // Log the SAP point
                            //
                            rc = ScepSaveObjectString(
                                        hSection,
                                        Buffer,
                                        (EnumRc & _A_SUBDIR) ? TRUE : FALSE,
                                        SCE_STATUS_NOT_CONFIGURED,
                                        NULL,
                                        0
                                        );
*/
                        }

                        ScepFree(Buffer);
                        Buffer = NULL;

                        if ( rc != ERROR_SUCCESS )
                            break;

                        pFileInfo = (struct _wfinddata_t *)ScepAlloc(0,sizeof(struct _wfinddata_t));
                        if ( pFileInfo == NULL ) {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                            break;
                        }

                    }
                } while ( _wfindnext(hFile, pFileInfo) == 0 );

                _findclose(hFile);
            }

            if ( pFileInfo != NULL ) {
                ScepFree(pFileInfo);
                pFileInfo = NULL;
            }

            break;

        case SE_REGISTRY_KEY:

            PWSTR           Buffer1;
            HKEY            hKey;
            DWORD           index;

            //
            // open the key
            //
            Buffer1=NULL;
            rc = ScepOpenRegistryObject(
                        SE_REGISTRY_KEY,
                        ThisNode->ObjectFullName,
                        KEY_READ,
                        &hKey
                        );

            if ( rc == ERROR_SUCCESS ) {
                index = 0;
                //
                // enumerate all subkeys of the key
                //
                do {
                    Buffer1 = (PWSTR)ScepAlloc(LMEM_ZEROINIT, MAX_PATH*sizeof(WCHAR));
                    if ( Buffer1 == NULL ) {
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                    BufSize = MAX_PATH;

                    EnumRc = RegEnumKeyEx(hKey,
                                    index,
                                    Buffer1,
                                    &BufSize,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);

                    if ( EnumRc == ERROR_SUCCESS ) {
                        index++;
                        //
                        // find if the subkey is already in the tree
                        // if it is in the tree, it will be processed later
                        //
                        for ( pTemp = ThisNode->ChildList, i=-1;
                              pTemp != NULL;
                              pTemp = pTemp->Next ) {

                            if ( pTemp->Node == NULL ) continue;
                            i=_wcsicmp(pTemp->Node->Name, Buffer1);
                            if ( i >= 0 )
                                break;
                        }

                        if ( pTemp == NULL || i > 0 ) {
                            //
                            // The name is not in the list
                            //
                            BufSize += wcslen(ThisNode->ObjectFullName)+1;
                            Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                            if ( Buffer == NULL ) {
                                rc = ERROR_NOT_ENOUGH_MEMORY;
                                break;
                            }
                            swprintf(Buffer, L"%s\\%s", ThisNode->ObjectFullName, Buffer1);

                            ScepFree(Buffer1);
                            Buffer1 = NULL;

//                            if ( StartChecking ) {  // raise N.C. status even for SCE_STATUS_CHECK
                            if ( StartChecking && ThisNode->Status == SCE_STATUS_OVERWRITE ) {
                                //
                                // do not check owner and group information
                                //
                                rc = ScepAnalyzeObjectAndChildren(
                                            Buffer,
                                            ObjectType,
                                            NULL,
                                            (ThisNode->SeInfo & DACL_SECURITY_INFORMATION) |
                                            (ThisNode->SeInfo & SACL_SECURITY_INFORMATION)
                                            );
                            } else {
/*
                                rc = ScepSaveObjectString(
                                            hSection,
                                            Buffer,
                                            TRUE,
                                            SCE_STATUS_NOT_CONFIGURED,
                                            NULL,
                                            0
                                            );
*/

                            }
                            if ( rc != ERROR_SUCCESS )
                                ScepLogOutput3(1, rc, SCEDLL_SAP_ERROR_SECURITY, Buffer);

                            ScepFree(Buffer);
                            Buffer = NULL;

                            if ( rc != ERROR_SUCCESS )
                                break;

                        }

                    } else if ( EnumRc != ERROR_NO_MORE_ITEMS ) {
                        //
                        // Enumeration shouldn't fail if RegOpenKeyEx works right
                        // because the ENUMERATE_SUB_KEYS access was requested in
                        // the open call.
                        // However, due to a app compat bug (for terminal server)
                        // when a registry key is opened with some access rights,
                        // it is actually opened with MAXIMUM_ALLOWED for certain
                        // keys. This will cause RegEnumKeyEx fail with access denied
                        // error.
                        // In this case, we treat it the same as the open key failed
                        // with the error.
                        //
                        ScepSaveObjectString(
                                hSection,
                                ThisNode->ObjectFullName,
                                TRUE,
                                SCE_STATUS_ERROR_NOT_AVAILABLE,
                                NULL,
                                0
                                );
                        //
                        // skip it
                        //
                        gWarningCode = EnumRc;
                        rc = ERROR_SUCCESS;
                    }

                    if ( Buffer1 != NULL ) {

                        ScepFree(Buffer1);
                        Buffer1 = NULL;
                    }

                } while ( EnumRc == ERROR_SUCCESS );


                RegCloseKey(hKey);

                if ( EnumRc != ERROR_SUCCESS && EnumRc != ERROR_NO_MORE_ITEMS ) {
                    ScepLogOutput3(1, EnumRc, SCEDLL_SAP_ERROR_ENUMERATE,
                                   ThisNode->ObjectFullName);
                }
            } else {

                ScepSaveObjectString(
                        hSection,
                        ThisNode->ObjectFullName,
                        TRUE,
                        SCE_STATUS_ERROR_NOT_AVAILABLE,
                        NULL,
                        0
                        );
                //
                // if access is denied or key does not exist, skip it
                //
                if ( rc == ERROR_PATH_NOT_FOUND ||
                     rc == ERROR_FILE_NOT_FOUND ||
                     rc == ERROR_INVALID_HANDLE ) {

                    gWarningCode = rc;

                    rc = ERROR_SUCCESS;

                } else if ( rc == ERROR_ACCESS_DENIED ||
                            rc == ERROR_CANT_ACCESS_FILE ||
                          rc == ERROR_SHARING_VIOLATION) {

                    gWarningCode = rc;
                    rc = ERROR_SUCCESS;

                }
            }

            if ( Buffer1 != NULL ) {
                ScepFree(Buffer1);
                Buffer1 = NULL;
            }

            break;

        default:
            break;
        }

        if ( Buffer != NULL ) {
            ScepFree(Buffer);
            Buffer = NULL;
        }

    }

    if ( rc != ERROR_SUCCESS )
        return(rc);

ProcChild:

    //
    // then process left child
    //
    for(pTemp = ThisNode->ChildList; pTemp != NULL; pTemp=pTemp->Next) {

        if ( pTemp->Node == NULL ) continue;

        rc = ScepAnalyzeOneObjectInTree(
                    pTemp->Node,
                    ObjectType,
                    Token,
                    GenericMapping
                    );
        if ( rc != ERROR_SUCCESS ) {
            break;
        }
    }

SkipNode:

    return(rc);
}




DWORD
ScepAnalyzeObjectOnly(
    IN PWSTR ObjectFullName,
    IN BOOL IsContainer,
    IN SE_OBJECT_TYPE ObjectType,
    IN PSECURITY_DESCRIPTOR ProfileSD,
    IN SECURITY_INFORMATION ProfileSeInfo
    )
/* ++

Routine Description:

   Get security setting for the current object and compare it with the profile
   setting. This routine analyzes the current object only. If there is
   difference in the security setting, the object will be added to the
   ppObjectChecked object tree to return.

Arguments:

   ObjectFullName     - The object's full path name

   ObjectType         - Indicate file object or registry object

   ProfileSD          - security descriptor specified in the template

   ProfileSeInfo      - security information specified in the template

Return value:

   SCESTATUS error codes

++ */
{
    DWORD                   Win32rc=NO_ERROR;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor=NULL;


//    UCHAR                   psdbuffer[PSD_BASE_LENGTH];
//    PISECURITY_DESCRIPTOR   psecuritydescriptor = (PISECURITY_DESCRIPTOR) psdbuffer;
//    ULONG                   NewBytesNeeded, BytesNeeded;
//    NTSTATUS    NtStatus;


    //
    // get security information for this object
    //

// win32 api is too slow!!!
    Win32rc = GetNamedSecurityInfo(
                        ObjectFullName,
                        ObjectType,
                        ProfileSeInfo,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &pSecurityDescriptor
                        );
/*

    Win32rc = ScepGetNamedSecurityInfo(
                    ObjectFullName,
                    ObjectType,
                    ProfileSeInfo,
                    &pSecurityDescriptor
                    );
*/
    if ( Win32rc == ERROR_SUCCESS ) {

        //
        // Compare the analysis security descriptor with the profile
        //

        Win32rc = ScepCompareAndAddObject(
                            ObjectFullName,
                            ObjectType,
                            IsContainer,
                            pSecurityDescriptor,
                            ProfileSD,
                            ProfileSeInfo,
                            TRUE,
                            NULL
                            );

        ScepFree(pSecurityDescriptor);

        if ( Win32rc != ERROR_SUCCESS ) {

            ScepLogOutput3(1, Win32rc, SCEDLL_SAP_ERROR_ANALYZE, ObjectFullName);
        }

    } else {
        ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_QUERY_SECURITY, ObjectFullName);
    }

    if ( Win32rc != ERROR_SUCCESS ) {

        ScepSaveObjectString(
                hSection,
                ObjectFullName,
                IsContainer,
                SCE_STATUS_ERROR_NOT_AVAILABLE,
                NULL,
                0
                );
    }

    return(Win32rc);

}



DWORD
ScepGetNamedSecurityInfo(
    IN PWSTR ObjectFullName,
    IN SE_OBJECT_TYPE ObjectType,
    IN SECURITY_INFORMATION ProfileSeInfo,
    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    )
{
    DWORD Win32rc=ERROR_INVALID_PARAMETER;
    HANDLE                  Handle=NULL;

    *ppSecurityDescriptor = NULL;

    switch ( ObjectType ) {
    case SE_FILE_OBJECT:
        Win32rc = ScepOpenFileObject(
                    (LPWSTR)ObjectFullName,
                    ScepGetDesiredAccess(READ_ACCESS_RIGHTS, ProfileSeInfo),
                    &Handle
                    );
        if (Win32rc == ERROR_SUCCESS ) {
            Win32rc = ScepGetFileSecurityInfo(
                                    Handle,
                                    ProfileSeInfo,
                                    ppSecurityDescriptor);
            CloseHandle(Handle);
        }
        break;

    case SE_REGISTRY_KEY:
#ifdef _WIN64
    case SE_REGISTRY_WOW64_32KEY:
#endif
        Win32rc = ScepOpenRegistryObject(
                        ObjectType,
                        (LPWSTR)ObjectFullName,
                        ScepGetDesiredAccess(READ_ACCESS_RIGHTS, ProfileSeInfo),
                        (PHKEY)&Handle
                        );
        if (Win32rc == ERROR_SUCCESS ) {
            Win32rc = ScepGetKeySecurityInfo(
                            (HKEY)Handle,
                            ProfileSeInfo,
                            ppSecurityDescriptor);

            RegCloseKey((HKEY)Handle);
        }

        break;

    }

    if ( Win32rc != NO_ERROR && *ppSecurityDescriptor != NULL ) {
        ScepFree(*ppSecurityDescriptor);
        *ppSecurityDescriptor = NULL;
    }

    return(Win32rc);
}



DWORD
ScepGetFileSecurityInfo(
    IN  HANDLE                 Handle,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * pSecurityDescriptor
    )
/* ++
A modified copy of GetKernelSecurityInfo from windows\base\accctrl\kernel.cxx
-- */
{

    UCHAR psdbuffer[PSD_BASE_LENGTH];
    PISECURITY_DESCRIPTOR psecuritydescriptor = (PISECURITY_DESCRIPTOR) psdbuffer;
    DWORD status = NO_ERROR;
    NTSTATUS ntstatus;
    ULONG bytesneeded = 0;
    ULONG newbytesneeded;

    if ( !NT_SUCCESS(ntstatus = NtQuerySecurityObject( Handle,
                                                       SecurityInfo,
                                                       psecuritydescriptor,
                                                       PSD_BASE_LENGTH,
                                                       &bytesneeded))) {
        if (STATUS_BUFFER_TOO_SMALL == ntstatus) {
            if (NULL == (psecuritydescriptor = (PISECURITY_DESCRIPTOR)
                                 ScepAlloc( LMEM_ZEROINIT, bytesneeded))) {
                 return(ERROR_NOT_ENOUGH_MEMORY);
            } else {
                if ( !NT_SUCCESS(ntstatus = NtQuerySecurityObject(Handle,
                                                          SecurityInfo,
                                                          psecuritydescriptor,
                                                          bytesneeded,
                                                          &newbytesneeded))) {
                    status = RtlNtStatusToDosError(ntstatus);
                }
            }
        } else {
            status = RtlNtStatusToDosError(ntstatus);
        }
    }
    if (NO_ERROR == status) {
         status = ScepGetSecurityDescriptorParts( psecuritydescriptor,
                                              SecurityInfo,
                                              pSecurityDescriptor);
    }
//    if (bytesneeded > PSD_BASE_LENGTH) {
    if ( psecuritydescriptor != (PISECURITY_DESCRIPTOR)psdbuffer ) {
        ScepFree(psecuritydescriptor);
    }
    return(status);
}



DWORD
ScepGetSecurityDescriptorParts(
    IN PISECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SECURITY_INFORMATION SecurityInfo,
    OUT PSECURITY_DESCRIPTOR *pOutSecurityDescriptor
    )
/* ++
A modified copy of GetSecurityDescriptorParts from windows\base\accctrl\src\common.cxx
-- */
{
    NTSTATUS        ntstatus;
    DWORD           status = NO_ERROR;
    PSID            owner = NULL,
                    group = NULL;
    PACL            dacl = NULL,
                    sacl = NULL;
    ULONG           csize = sizeof(SECURITY_DESCRIPTOR);
    BOOLEAN         bDummy, bParmPresent = FALSE;
    PISECURITY_DESCRIPTOR   poutsd;
    PVOID           bufptr=NULL;
    SECURITY_DESCRIPTOR_CONTROL theControl=0;
    ULONG           theRevision=0;

    //
    // if no security descriptor found, don't return one!
    //
    *pOutSecurityDescriptor = NULL;

    if ( pSecurityDescriptor ) {
        //
        // if the security descriptor is self relative, get absolute
        // pointers to the components
        //
        ntstatus = RtlGetOwnerSecurityDescriptor( pSecurityDescriptor,
                                                  &owner,
                                                  &bDummy);
        if (NT_SUCCESS(ntstatus)) {
            ntstatus = RtlGetGroupSecurityDescriptor( pSecurityDescriptor,
                                                      &group,
                                                      &bDummy);
        }

        if (NT_SUCCESS(ntstatus)) {
            ntstatus = RtlGetDaclSecurityDescriptor( pSecurityDescriptor,
                                                     &bParmPresent,
                                                     &dacl,
                                                     &bDummy);
            if (NT_SUCCESS(ntstatus) && !bParmPresent)
                dacl = NULL;
        }

        if (NT_SUCCESS(ntstatus)) {
            ntstatus = RtlGetSaclSecurityDescriptor( pSecurityDescriptor,
                                                     &bParmPresent,
                                                     &sacl,
                                                     &bDummy);
            if (NT_SUCCESS(ntstatus) && !bParmPresent)
                sacl = NULL;
        }

        if (NT_SUCCESS(ntstatus)) {
            //
            // Build the new security descriptor
            //
            csize = RtlLengthSecurityDescriptor( pSecurityDescriptor ) +
                    sizeof(SECURITY_DESCRIPTOR) - sizeof(SECURITY_DESCRIPTOR_RELATIVE);

            //
            // There is size difference in relative form and absolute form
            // on 64 bit system. - always add the difference to the size.
            // This has no effect on 32bit system. On 64bit system, if the input
            // security descriptor is in absolute form already, we will waste
            // 16 bytes per security descriptor.
            //
            // Another option is to detect the form of the input security descriptor
            // but that takes a pointer deref, a & operation, and code complexity.
            // Plus, it will affect performance of 32bit system. The output SD
            // will be freed after a short period of time, so we go with
            // the first option.
            //

            if (NULL == (poutsd = (PISECURITY_DESCRIPTOR)ScepAlloc(LMEM_ZEROINIT, csize)))
                return(ERROR_NOT_ENOUGH_MEMORY);

            RtlCreateSecurityDescriptor(poutsd, SECURITY_DESCRIPTOR_REVISION);

            ntstatus = RtlGetControlSecurityDescriptor (
                            pSecurityDescriptor,
                            &theControl,
                            &theRevision
                            );
            if ( NT_SUCCESS(ntstatus) ) {

                theControl &= SE_VALID_CONTROL_BITS;
                RtlSetControlSecurityDescriptor (
                            poutsd,
                            theControl,
                            theControl
                            );
            }
            ntstatus = STATUS_SUCCESS;

            bufptr = Add2Ptr(poutsd, sizeof(SECURITY_DESCRIPTOR));

            if (SecurityInfo & OWNER_SECURITY_INFORMATION) {
                if (NULL != owner) {
                    //
                    // no error checking as these should not fail!!
                    //
                    ntstatus = RtlCopySid(RtlLengthSid(owner), (PSID)bufptr, owner);
                    if ( NT_SUCCESS(ntstatus) ) {
                        ntstatus = RtlSetOwnerSecurityDescriptor(poutsd,
                                                  (PSID)bufptr, FALSE);
                        if ( NT_SUCCESS(ntstatus) )
                            bufptr = Add2Ptr(bufptr,RtlLengthSid(owner));
                    }
                } else
                    ntstatus = STATUS_NO_SECURITY_ON_OBJECT;
            }

            if (NT_SUCCESS(ntstatus) && (SecurityInfo & GROUP_SECURITY_INFORMATION) ) {
                if (NULL != group) {
                    //
                    // no error checking as these should not fail!!
                    //
                    ntstatus = RtlCopySid(RtlLengthSid(group), (PSID)bufptr, group);
                    if ( NT_SUCCESS(ntstatus) ) {
                        ntstatus = RtlSetGroupSecurityDescriptor(poutsd,
                                                  (PSID)bufptr, FALSE);
                        if ( NT_SUCCESS(ntstatus) )
                            bufptr = Add2Ptr(bufptr,RtlLengthSid(group));
                    }
                } else
                    ntstatus = STATUS_NO_SECURITY_ON_OBJECT;
            }

            //
            // The DACL and SACL may or may not be on the object.
            //
            if ( NT_SUCCESS(ntstatus) && (SecurityInfo & DACL_SECURITY_INFORMATION) ) {
                if (NULL != dacl) {
                    RtlCopyMemory(bufptr, dacl, dacl->AclSize);
                    ntstatus = RtlSetDaclSecurityDescriptor(poutsd,
                                           TRUE,
                                           (ACL *)bufptr,
                                           FALSE);
                    if ( NT_SUCCESS(ntstatus) )
                        bufptr = Add2Ptr(bufptr, dacl->AclSize);
                }
            }

            if ( NT_SUCCESS(ntstatus) && (SecurityInfo & SACL_SECURITY_INFORMATION)){
                if (NULL != sacl) {
                    RtlCopyMemory(bufptr, sacl, sacl->AclSize);
                    ntstatus = RtlSetSaclSecurityDescriptor(poutsd,
                                       TRUE,
                                       (ACL *)bufptr,
                                       FALSE);
                }
            }

            if (!NT_SUCCESS(ntstatus))
                ScepFree(poutsd);
            else
                *pOutSecurityDescriptor = poutsd;
        }

        status = RtlNtStatusToDosError(ntstatus);

    }
    return(status);
}



DWORD
ScepGetKeySecurityInfo(
    IN  HANDLE Handle,
    IN  SECURITY_INFORMATION SecurityInfo,
    OUT PSECURITY_DESCRIPTOR *pSecurityDescriptor
    )
/* ++
A modified copy of GetRegistrySecurityInfo in windows\base\accctrl\src\registry.cxx
-- */
{
    if ( SecurityInfo == 0 || pSecurityDescriptor == NULL )
        return ERROR_INVALID_PARAMETER;

    UCHAR psdbuffer[PSD_BASE_LENGTH];
    PISECURITY_DESCRIPTOR psecuritydescriptor = (PISECURITY_DESCRIPTOR) psdbuffer;
    DWORD status;
    ULONG bytesneeded = PSD_BASE_LENGTH;

    if ( NO_ERROR != (status = RegGetKeySecurity(
                                      (HKEY)Handle,
                                      SecurityInfo,
                                      psecuritydescriptor,
                                      &bytesneeded) ) ) {
        if (ERROR_INSUFFICIENT_BUFFER == status) {
            if (NULL == (psecuritydescriptor = (PISECURITY_DESCRIPTOR)
                                            ScepAlloc(LMEM_ZEROINIT, bytesneeded))) {
                 return(ERROR_NOT_ENOUGH_MEMORY);
            } else {
                status = RegGetKeySecurity((HKEY)Handle,
                                           SecurityInfo,
                                           psecuritydescriptor,
                                           &bytesneeded);
            }
        }
    }
    if (NO_ERROR == status) {
         status = ScepGetSecurityDescriptorParts(
                              psecuritydescriptor,
                              SecurityInfo,
                              pSecurityDescriptor);
    }
//    if (bytesneeded > PSD_BASE_LENGTH)
    if ( psecuritydescriptor != (PISECURITY_DESCRIPTOR)psdbuffer )
        ScepFree(psecuritydescriptor);

    return(status);
}


DWORD
ScepCompareAndAddObject(
    IN PWSTR ObjectFullName,
    IN SE_OBJECT_TYPE ObjectType,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR ProfileSD,
    IN SECURITY_INFORMATION ProfileSeInfo,
    IN BOOL AddObject,
    OUT PBYTE IsDifferent OPTIONAL
    )
/* ++

Routine Description:

   Compare two security descriptors and add the object to the analysis database
   if there is difference.

Arguments:

   ObjectFullName     - The object's full path name

   pSecurityDescriptor - The security descriptor of current object's setting

   ProfileSD          - security descriptor specified in the template

   ProfileSeInfo      - security information specified in the template

Return value:

   SCESTATUS error codes

++ */
{
    DWORD rc;
    BYTE Status;
    PWSTR   SDspec=NULL;
    DWORD   SDsize;

    rc = ScepCompareObjectSecurity(ObjectType,
                                   IsContainer,
                                  pSecurityDescriptor,
                                  ProfileSD,
                                  ProfileSeInfo,
                                  &Status
                                  );

    if ( NO_ERROR == rc ) {

        if ( AddObject && Status && ObjectFullName != NULL ) {
            //
            // save this one in SAP section
            //
            rc = ConvertSecurityDescriptorToText(
                                pSecurityDescriptor,
                                ProfileSeInfo,
                                &SDspec,
                                &SDsize
                                );
            if ( rc == ERROR_SUCCESS ) {
                //
                // Save to the SAP section
                //

                if ( ObjectType == SE_DS_OBJECT ) {

                    rc = ScepSaveDsStatusToSection(
                                    ObjectFullName,
                                    IsContainer,
                                    Status,
                                    SDspec,
                                    SDsize
                                    );
                } else {

                    rc = ScepSaveObjectString(
                                    hSection,
                                    ObjectFullName,
                                    IsContainer,
                                    Status,
                                    SDspec,
                                    SDsize
                                    );
                }
                if ( SCESTATUS_OBJECT_EXIST == rc ) {

                    ScepLogOutput3(1, ERROR_FILE_EXISTS, SCEDLL_SAP_ERROR_SAVE, ObjectFullName);
                    rc = ERROR_SUCCESS;

                } else if ( rc != SCESTATUS_SUCCESS )
                    rc = ScepSceStatusToDosError(rc);

            } else
                ScepLogOutput3(1, rc, SCEDLL_SAP_ERROR_SAVE, ObjectFullName);

            if ( SDspec != NULL )
                ScepFree(SDspec);

            BadCnt++;
        }

        if ( IsDifferent ) {
            *IsDifferent = Status;
        }

    } else {

        if ( ObjectFullName ) {

            ScepLogOutput3(1, rc, SCEDLL_SAP_ERROR_ACL, ObjectFullName);
        }
    }

    return(rc);
}



DWORD
ScepAnalyzeObjectAndChildren(
    IN PWSTR ObjectFullName,
    IN SE_OBJECT_TYPE ObjectType,
    IN PSECURITY_DESCRIPTOR ProfileSD,
    IN SECURITY_INFORMATION ProfileSeInfo
    )
/* ++

Routine Description:

   Analyze current object and all subkeys/files/directories under the object.
   If there is difference in security setting for any object, the object will
   be added to the analysis database.

Arguments:

   ObjectFullName     - The object's full path name

   ObjectType         - Indicate file object or registry object

   ProfileSD          - security descriptor specified in the template

   ProfileSeInfo      - security information specified in the template

Return value:

   SCESTATUS error codes

++ */
{
    DWORD           rc=0;
    PWSTR           Buffer=NULL;
    intptr_t            hFile;
    struct _wfinddata_t *    pFileInfo=NULL;
    DWORD           index;
    DWORD           BufSize;
    PWSTR           Buffer1=NULL;
    DWORD           EnumRc=0;
    HKEY            hKey;
    DWORD           ObjectLen;

    //
    // analyze this file/key first
    //
    rc = ScepAnalyzeObjectOnly(
                ObjectFullName,
                TRUE,
                ObjectType,
                ProfileSD,
                ProfileSeInfo
                );

    //
    // if the object denies access or does not exist, skip it.
    //
    if ( rc == ERROR_ACCESS_DENIED ||
         rc == ERROR_CANT_ACCESS_FILE ||
         rc == ERROR_SHARING_VIOLATION) {

        gWarningCode = rc;
        rc = ScepSaveObjectString(
                    hSection,
                    ObjectFullName,
                    TRUE,
                    SCE_STATUS_ERROR_NOT_AVAILABLE,
                    NULL,
                    0
                    );
        return(rc);
    } else if ( rc == ERROR_FILE_NOT_FOUND ||
                rc == ERROR_PATH_NOT_FOUND ||
                rc == ERROR_INVALID_HANDLE ) {
        gWarningCode = rc;
        return(SCESTATUS_SUCCESS);
    }

    if ( rc != ERROR_SUCCESS )
        return(rc);

    //
    // recursively analyze all children under this file/key
    //

    ObjectLen = wcslen(ObjectFullName);

    switch ( ObjectType ) {
    case SE_FILE_OBJECT:

        pFileInfo = (struct _wfinddata_t *)ScepAlloc(0,sizeof(struct _wfinddata_t));
        if ( pFileInfo == NULL ) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        //
        // find all files under this directory/file
        //
        BufSize = ObjectLen+4;
        Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
        if ( Buffer == NULL ) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        swprintf(Buffer, L"%s\\*.*", ObjectFullName);

        hFile = _wfindfirst(Buffer, pFileInfo);

        ScepFree(Buffer);
        Buffer = NULL;

        if ( hFile != -1 ) {
            do {
                if ( wcscmp(L"..", pFileInfo->name) == 0 ||
                     wcscmp(L".", pFileInfo->name) == 0 )
                    continue;

                //
                // The name is not in the list, so analyze this one
                //
                BufSize = ObjectLen+wcslen(pFileInfo->name)+1;

                Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                if ( Buffer == NULL ) {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                swprintf(Buffer, L"%s\\%s", ObjectFullName, pFileInfo->name);

                EnumRc = pFileInfo->attrib;  // use this variable temp

                ScepFree(pFileInfo);
                pFileInfo = NULL;

                if ( EnumRc & _A_SUBDIR ) {
                    rc = ScepAnalyzeObjectAndChildren(
                            Buffer,
                            ObjectType,
                            ProfileSD,
                            ProfileSeInfo
                            );
                } else {
                    rc = ScepAnalyzeObjectOnly(
                                Buffer,
                                FALSE,
                                ObjectType,
                                ProfileSD,
                                ProfileSeInfo
                                );
                }

                ScepFree(Buffer);
                Buffer = NULL;

                if ( rc != ERROR_SUCCESS )
                    break;

                pFileInfo = (struct _wfinddata_t *)ScepAlloc(0,sizeof(struct _wfinddata_t));
                if ( pFileInfo == NULL ) {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

            } while ( _wfindnext(hFile, pFileInfo) == 0 );

            _findclose(hFile);
        }
        break;

    case SE_REGISTRY_KEY:
        //
        // open the key
        //
        rc = ScepOpenRegistryObject(
                    SE_REGISTRY_KEY,
                    ObjectFullName,
                    KEY_READ,
                    &hKey
                    );

        if ( rc == ERROR_SUCCESS ) {
            index = 0;
            //
            // enumerate all subkeys of the key
            //
            do {
                Buffer1 = (PWSTR)ScepAlloc(LMEM_ZEROINIT, MAX_PATH*sizeof(WCHAR));
                if ( Buffer1 == NULL ) {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                BufSize = MAX_PATH;

                EnumRc = RegEnumKeyEx(hKey,
                                index,
                                Buffer1,
                                &BufSize,
                                NULL,
                                NULL,
                                NULL,
                                NULL);

                if ( EnumRc == ERROR_SUCCESS ) {
                    index++;
                    //
                    // analyze children under this key
                    //
                    BufSize += ObjectLen+1;
                    Buffer = (PWSTR)ScepAlloc( 0, (BufSize+1)*sizeof(WCHAR));
                    if ( Buffer == NULL ) {
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                    swprintf(Buffer, L"%s\\%s", ObjectFullName, Buffer1);

                    ScepFree(Buffer1);
                    Buffer1 = NULL;

                    rc = ScepAnalyzeObjectAndChildren(
                                Buffer,
                                ObjectType,
                                ProfileSD,
                                ProfileSeInfo
                                );

                    ScepFree(Buffer);
                    Buffer = NULL;

                    if ( rc != ERROR_SUCCESS )
                        break;

                } else if ( EnumRc != ERROR_NO_MORE_ITEMS ) {
                    //
                    // Enumeration shouldn't fail if RegOpenKeyEx works right
                    // because the ENUMERATE_SUB_KEYS access was requested in
                    // the open call.
                    // However, due to a app compat bug (for terminal server)
                    // when a registry key is opened with some access rights,
                    // it is actually opened with MAXIMUM_ALLOWED for certain
                    // keys. This will cause RegEnumKeyEx fail with access denied
                    // error.
                    // In this case, we treat it the same as the open key failed
                    // with the error.
                    //
                    // skip it
                    //
                    rc = EnumRc;
                }
                if ( Buffer1 != NULL ) {
                    ScepFree(Buffer1);
                    Buffer1 = NULL;
                }

            } while ( EnumRc == ERROR_SUCCESS );

            RegCloseKey(hKey);

            if ( EnumRc != ERROR_SUCCESS && EnumRc != ERROR_NO_MORE_ITEMS ) {
                ScepLogOutput3(1, EnumRc, SCEDLL_SAP_ERROR_ENUMERATE, ObjectFullName);
                rc = EnumRc;
            }
        } else
            ScepLogOutput3(1, rc, SCEDLL_ERROR_OPEN, ObjectFullName);

        if ( rc == ERROR_ACCESS_DENIED ||
             rc == ERROR_CANT_ACCESS_FILE ||
             rc == ERROR_SHARING_VIOLATION) {

            gWarningCode = rc;
            rc = ScepSaveObjectString(
                        hSection,
                        ObjectFullName,
                        TRUE,
                        SCE_STATUS_ERROR_NOT_AVAILABLE,
                        NULL,
                        0
                        );
        } else if ( rc == ERROR_PATH_NOT_FOUND ||
                    rc == ERROR_FILE_NOT_FOUND ||
                    rc == ERROR_INVALID_HANDLE ) {
            gWarningCode = rc;
            rc = SCESTATUS_SUCCESS;
        }

        break;

    default:
        break;
    }

    if ( Buffer != NULL ) {
        ScepFree(Buffer);
    }

    if ( Buffer1 != NULL ) {
        ScepFree(Buffer1);
    }

    if ( pFileInfo != NULL ) {
        ScepFree(pFileInfo);
    }

    return(rc);
}




SCESTATUS
ScepAnalyzeSystemAuditing(
    IN PSCE_PROFILE_INFO pSmpInfo,
    IN PPOLICY_AUDIT_EVENTS_INFO AuditEvent
    )
/* ++

Routine Description:

   This routine queries the system auditing security which includes event log
   setting, audit event setting, SACL for registry, and SACL for files.

Arguments:

   SnapShot - The buffer which contains analyzed system info

Return value:

   SCESTATUS_SUCCESS
   SCESTATUS_NOT_ENOUGH_MEMORY
   SCESTATUS_INVALID_PARAMETER
   SCESTATUS_OTHER_ERROR

-- */
{
    SCESTATUS                     rc;
    DWORD                         i,retRc=NO_ERROR;
    WCHAR                         MsgBuf[256];
    PCWSTR                        szAuditSection=NULL;
    DWORD                         MaxSize=0;
    DWORD                         Retention=0;
    DWORD                         AuditLogRetentionPeriod;
    DWORD                         RetentionDays;
    DWORD                         RestrictGuest;

    NTSTATUS                      NtStatus;
    LSA_HANDLE                    LsaHandle=NULL;
    PPOLICY_AUDIT_FULL_QUERY_INFO AuditFull=NULL;

    BOOL bSaveSnapshot=FALSE;

    if ( (gOptions & SCE_NO_ANALYZE) || (gOptions & SCE_GENERATE_ROLLBACK) )
        bSaveSnapshot = TRUE;

    if ( !(gOptions & SCE_NO_ANALYZE) ) {

        //
        // DO NOT query log settings in system upgrade because local policy
        // table doesn't keep log settings
        // only analyze log settings
        // Audit Log settings are saved in the Registry
        // under System\CurrentControlSet\Services\EventLog\<LogName>\MaxSize and Retention
        //

        for ( i=0; i<3; i++) {

            //
            // Different logs have different keys in Registry
            //

            switch (i) {
            case 0:

                wcscpy(MsgBuf,L"System\\CurrentControlSet\\Services\\EventLog\\System");
                szAuditSection = szAuditSystemLog;
                break;
            case 1:

                wcscpy(MsgBuf,L"System\\CurrentControlSet\\Services\\EventLog\\Security");
                szAuditSection = szAuditSecurityLog;
                break;
            default:

                wcscpy(MsgBuf,L"System\\CurrentControlSet\\Services\\EventLog\\Application");
                szAuditSection = szAuditApplicationLog;
                break;
            }

            //
            // Preprea the section to write to
            //
            rc = ScepStartANewSection(
                        hProfile,
                        &hSection,
                        bSaveSnapshot ? SCEJET_TABLE_SMP : SCEJET_TABLE_SAP,
                        szAuditSection
                        );
            if ( rc != SCESTATUS_SUCCESS ) {
                retRc = ScepSceStatusToDosError(rc);
                ScepLogOutput3(1, retRc,
                               SCEDLL_SAP_START_SECTION, (PWSTR)szAuditSection);
                continue;
            }

            DWORD LogValues[MAX_LOG_ITEMS];

            for ( MaxSize=0; MaxSize<MAX_LOG_ITEMS; MaxSize++ ) {
                LogValues[MaxSize] = SCE_ERROR_VALUE;
            }

            RestrictGuest = 0;

            rc = ScepRegQueryIntValue(
                        HKEY_LOCAL_MACHINE,
                        MsgBuf,
                        L"MaxSize",
                        &MaxSize
                        );

            if ( rc == NO_ERROR ) {

                rc = ScepRegQueryIntValue(
                         HKEY_LOCAL_MACHINE,
                         MsgBuf,
                         L"Retention",
                         &Retention
                         );
                if ( rc == NO_ERROR ) {

                    ScepRegQueryIntValue(
                         HKEY_LOCAL_MACHINE,
                         MsgBuf,
                         L"RestrictGuestAccess",
                         &RestrictGuest
                         );
                }
            }

            if ( rc == NO_ERROR ) {

                MaxSize /= 1024;
                rc = ScepCompareAndSaveIntValue(
                           hSection,
                           L"MaximumLogSize",
                           (gOptions & SCE_GENERATE_ROLLBACK),
                           (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : pSmpInfo->MaximumLogSize[i],
                           MaxSize
                           );

                if ( rc == SCESTATUS_SUCCESS ) {

                    LogValues[IDX_MAX_LOG_SIZE] = MaxSize;

                    switch ( Retention ) {
                    case MAXULONG:   // manually
                        AuditLogRetentionPeriod = 2;
                        RetentionDays = SCE_NO_VALUE;
                        break;
                    case 0:
                        AuditLogRetentionPeriod = 0;
                        RetentionDays = SCE_NO_VALUE;
                        break;
                    default:
                        AuditLogRetentionPeriod = 1;

                        // number of days * seconds/day
                        RetentionDays = Retention / (24 * 3600);
                        break;
                    }

                    BOOL bReplaceOnly=FALSE;

                    if ( (gOptions & SCE_GENERATE_ROLLBACK) &&
                         (pSmpInfo->AuditLogRetentionPeriod[i] == SCE_NO_VALUE) &&
                         (pSmpInfo->RetentionDays[i] == SCE_NO_VALUE) ) {

                        bReplaceOnly = TRUE;
                    }

                    rc = ScepCompareAndSaveIntValue(
                               hSection,
                               L"AuditLogRetentionPeriod",
                               bReplaceOnly,
                               (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : pSmpInfo->AuditLogRetentionPeriod[i],
                               AuditLogRetentionPeriod
                               );

                    if ( rc == SCESTATUS_SUCCESS ) {

                        LogValues[IDX_RET_PERIOD] = AuditLogRetentionPeriod;

                        if ( RetentionDays != SCE_NO_VALUE ) {

                            rc = ScepCompareAndSaveIntValue(
                                       hSection,
                                       L"RetentionDays",
                                       bReplaceOnly,
                                       (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : pSmpInfo->RetentionDays[i],
                                       RetentionDays
                                       );
                        }

                        if ( rc == SCESTATUS_SUCCESS ) {

                            LogValues[IDX_RET_DAYS] = RetentionDays;

                            rc = ScepCompareAndSaveIntValue(
                                       hSection,
                                       L"RestrictGuestAccess",
                                       (gOptions & SCE_GENERATE_ROLLBACK),
                                       (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : pSmpInfo->RestrictGuestAccess[i],
                                       RestrictGuest
                                       );

                            if ( rc == SCESTATUS_SUCCESS ) {
                                LogValues[IDX_RESTRICT_GUEST] = RestrictGuest;
                            }
                        }
                    }
                }

                rc = ScepSceStatusToDosError(rc);

            } else {

                ScepLogOutput3( 1, rc, SCEDLL_ERROR_QUERY_LOGSETTINGS);
            }

            if ( rc != NO_ERROR && !(gOptions & SCE_GENERATE_ROLLBACK) ) {
                //
                // see if anything should be raised as error
                //
                for ( MaxSize=0; MaxSize<MAX_LOG_ITEMS; MaxSize++ ) {
                    if ( LogValues[MaxSize] == SCE_ERROR_VALUE ) {

                        ScepCompareAndSaveIntValue(
                                   hSection,
                                   LogItems[MaxSize],
                                   FALSE,
                                   SCE_NO_VALUE,
                                   SCE_ERROR_VALUE
                                   );
                    }
                }

                retRc = rc;
            }

        }

        if ( retRc == NO_ERROR ) {
            ScepLogOutput3(1, 0, SCEDLL_SAP_LOGSETTINGS);
        }
    }

    //
    // AuditEvent may be NULL if failed to query the policy
    //
    if ( (gOptions & SCE_NO_ANALYZE) && AuditEvent == NULL ) {
        retRc = ERROR_ACCESS_DENIED;

    } else {

        //
        // Prepare audit event section
        //
        rc = ScepStartANewSection(
                    hProfile,
                    &hSection,
                    bSaveSnapshot ? SCEJET_TABLE_SMP : SCEJET_TABLE_SAP,
                    szAuditEvent
                    );
        if ( rc != SCESTATUS_SUCCESS ) {
            rc = ScepSceStatusToDosError(rc);
            ScepLogOutput3(1, rc,
                           SCEDLL_SAP_START_SECTION, (PWSTR)szAuditEvent);

        } else {

            DWORD EventValues[MAX_EVENT_ITEMS];

            if ( !(gOptions & SCE_NO_ANALYZE) ) {

                for ( MaxSize=0; MaxSize<MAX_EVENT_ITEMS; MaxSize++ ) {
                    EventValues[MaxSize] = SCE_ERROR_VALUE;
                }
            }

            if ( AuditEvent ) {

                if ( !AuditEvent->AuditingMode ) {

                    for ( i=0; i<AuditEvent->MaximumAuditEventCount; i++ )
                        AuditEvent->EventAuditingOptions[i] = 0;
                }

                rc = ScepCompareAndSaveIntValue(
                           hSection,
                           L"AuditSystemEvents",
                           (gOptions & SCE_GENERATE_ROLLBACK),
                           (gOptions & SCE_NO_ANALYZE) ?
                               SCE_SNAPSHOT_VALUE :
                               pSmpInfo->AuditSystemEvents,
                           AuditEvent->EventAuditingOptions[AuditCategorySystem]
                           );
                if ( rc == SCESTATUS_SUCCESS ) {

                    EventValues[IDX_AUDIT_SYSTEM] = 1;

                    rc = ScepCompareAndSaveIntValue(
                               hSection,
                               L"AuditLogonEvents",
                               (gOptions & SCE_GENERATE_ROLLBACK),
                               (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : pSmpInfo->AuditLogonEvents,
                               AuditEvent->EventAuditingOptions[AuditCategoryLogon]
                               );
                    if ( rc == SCESTATUS_SUCCESS ) {

                        EventValues[IDX_AUDIT_LOGON] = 1;

                        rc = ScepCompareAndSaveIntValue(
                                   hSection,
                                   L"AuditObjectAccess",
                                   (gOptions & SCE_GENERATE_ROLLBACK),
                                   (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : pSmpInfo->AuditObjectAccess,
                                   AuditEvent->EventAuditingOptions[AuditCategoryObjectAccess]
                                   );
                        if ( rc == SCESTATUS_SUCCESS ) {

                            EventValues[IDX_AUDIT_OBJECT] = 1;

                            rc = ScepCompareAndSaveIntValue(
                                       hSection,
                                       L"AuditPrivilegeUse",
                                       (gOptions & SCE_GENERATE_ROLLBACK),
                                       (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : pSmpInfo->AuditPrivilegeUse,
                                       AuditEvent->EventAuditingOptions[AuditCategoryPrivilegeUse]
                                       );
                            if ( rc == SCESTATUS_SUCCESS ) {

                                EventValues[IDX_AUDIT_PRIV] = 1;

                                rc = ScepCompareAndSaveIntValue(
                                           hSection,
                                           L"AuditProcessTracking",
                                           (gOptions & SCE_GENERATE_ROLLBACK),
                                           (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : pSmpInfo->AuditProcessTracking,
                                           AuditEvent->EventAuditingOptions[AuditCategoryDetailedTracking]
                                           );
                                if ( rc == SCESTATUS_SUCCESS ) {

                                    EventValues[IDX_AUDIT_PROCESS] = 1;

                                    rc = ScepCompareAndSaveIntValue(
                                               hSection,
                                               L"AuditPolicyChange",
                                               (gOptions & SCE_GENERATE_ROLLBACK),
                                               (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : pSmpInfo->AuditPolicyChange,
                                               AuditEvent->EventAuditingOptions[AuditCategoryPolicyChange]
                                               );
                                    if ( rc == SCESTATUS_SUCCESS ) {

                                        EventValues[IDX_AUDIT_ACCOUNT] = 1;

                                        rc = ScepCompareAndSaveIntValue(
                                                   hSection,
                                                   L"AuditAccountManage",
                                                   (gOptions & SCE_GENERATE_ROLLBACK),
                                                   (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : pSmpInfo->AuditAccountManage,
                                                   AuditEvent->EventAuditingOptions[AuditCategoryAccountManagement]
                                                   );
                                        if ( rc == SCESTATUS_SUCCESS ) {

                                            EventValues[IDX_AUDIT_DS] = 1;

                                            rc = ScepCompareAndSaveIntValue(
                                                       hSection,
                                                       L"AuditDSAccess",
                                                       (gOptions & SCE_GENERATE_ROLLBACK),
                                                       (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : pSmpInfo->AuditDSAccess,
                                                       AuditEvent->EventAuditingOptions[AuditCategoryDirectoryServiceAccess]
                                                       );
                                            if ( rc == SCESTATUS_SUCCESS ) {

                                                EventValues[IDX_AUDIT_ACCT_LOGON] = 1;

                                                rc = ScepCompareAndSaveIntValue(
                                                           hSection,
                                                           L"AuditAccountLogon",
                                                           (gOptions & SCE_GENERATE_ROLLBACK),
                                                           (gOptions & SCE_NO_ANALYZE) ? SCE_SNAPSHOT_VALUE : pSmpInfo->AuditAccountLogon,
                                                           AuditEvent->EventAuditingOptions[AuditCategoryAccountLogon]
                                                           );
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

            } else {
                //
                // audit policy is not available
                //
                rc = SCESTATUS_ACCESS_DENIED;
            }

            if ( rc != SCESTATUS_SUCCESS ) {
                rc = ScepSceStatusToDosError(rc);
                ScepLogOutput3( 1, rc,
                         SCEDLL_SAP_ERROR_EVENT_AUDITING);

            } else {
                ScepLogOutput3( 1, 0, SCEDLL_SAP_EVENT_AUDITING);

            }

            if ( rc != NO_ERROR ) {
                retRc = rc;

                if ( !bSaveSnapshot ) {

                    for ( MaxSize=0; MaxSize<MAX_EVENT_ITEMS; MaxSize++ ) {
                        if ( EventValues[MaxSize] == SCE_ERROR_VALUE ) {
                            //
                            // raise this error
                            //
                            ScepCompareAndSaveIntValue(
                                     hSection,
                                     EventItems[MaxSize],
                                     FALSE,
                                     SCE_NO_VALUE,
                                     SCE_ERROR_VALUE
                                     );
                        }
                    }
                }
            }
        }
    }

    if ( LsaHandle ) {
        LsaClose( LsaHandle );
    }

    return(ScepDosErrorToSceStatus(retRc));

}




SCESTATUS
ScepAnalyzeDeInitialize(
     IN SCESTATUS  rc,
     IN DWORD Options
     )

/*++
Routine Description:

   This routine de-initialize the SCP engine. The operations include

      clear SCE_SCP_INFO buffer and close the SCP profile
      close the error log file
      reset the status

Arguments:

    rc      - SCESTATUS error code (from other routines)

Return value:

    SCESTATUS error code

++*/
{
    NTSTATUS         NtStatus;
    LARGE_INTEGER    CurrentTime;
    SCESTATUS         Status;

    if ( rc == SCESTATUS_ALREADY_RUNNING ) {
        return(rc);
    }

    //
    // save new time stamp
    //
    if ( hProfile && (hProfile->JetSessionID != JET_sesidNil) &&
         (hProfile->JetDbID != JET_dbidNil) &&
         !(Options & SCE_GENERATE_ROLLBACK) ) {

        NtStatus = NtQuerySystemTime(&CurrentTime);

        if ( NtStatus == STATUS_SUCCESS ) {
    //printf("TimeStamp: %x%x\n", CurrentTime.HighPart, CurrentTime.LowPart);
            Status = SceJetSetTimeStamp(
                        hProfile,
                        TRUE,
                        CurrentTime
                        );
            if ( Status != SCESTATUS_SUCCESS )
                ScepLogOutput3(1, ScepSceStatusToDosError(Status),
                               SCEDLL_TIMESTAMP_ERROR, L"SAP");

        } else
            ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                          SCEDLL_TIMESTAMP_ERROR, L"SAP");
    }

    //
    // recover the SAP profile if errors
    //

    if (rc != SCESTATUS_SUCCESS) {
        //
        // rollback all changes
        //
//        SceJetRollback( hProfile, 0 );
        ScepLogOutput3(0, ScepSceStatusToDosError(rc), SCEDLL_SAP_ERROR_OUT);

    } else {
        //
        // Commit the transaction
        //
//         SceJetCommitTransaction( hProfile, 0 );

    }

    gTotalTicks = 0;
    gCurrentTicks = 0;
    gWarningCode = 0;
    cbClientFlag = 0;

    //
    // Close the JET section and profile handle
    //

    if ( hSection != NULL )
        SceJetCloseSection( &hSection, TRUE );
    hSection = NULL;

    if ( hProfile != NULL )
        SceJetCloseFile( hProfile, TRUE, FALSE );
    hProfile = NULL;


    return( SCESTATUS_SUCCESS );

}



DWORD
ScepSaveDsStatusToSection(
    IN PWSTR ObjectName,
    IN BOOL  IsContainer,
    IN BYTE  Flag,
    IN PWSTR Value,
    IN DWORD ValueLen
    )
{

    SCESTATUS rc;
    PWSTR SaveName;

    rc = ScepConvertLdapToJetIndexName(
            ObjectName,
            &SaveName
            );

    if ( rc == SCESTATUS_SUCCESS ) {

        rc = ScepSaveObjectString(
                                hSection,
                                SaveName,
                                IsContainer,
                                Flag,
                                Value,
                                ValueLen
                                );
        ScepFree(SaveName);
    }

    return(ScepSceStatusToDosError(rc));

}

//****************************************************
// migration functions
//
SCESTATUS
ScepMigrateDatabase(
    IN PSCECONTEXT cxtProfile,
    IN BOOL bSystemDb
    )
{

    SCESTATUS rc;
    FLOAT CurrentVersion;

    rc = SceJetCheckVersion( cxtProfile, &CurrentVersion );

    ScepPostProgress(0, 0, NULL);

    if ( rc == SCESTATUS_BAD_FORMAT ) {

        if ( CurrentVersion < (FLOAT)1.2 ) {

            rc = SCESTATUS_SUCCESS;

            if ( bSystemDb ) {
                //
                // just simply delete the local policy and SAP table
                // ignore error occured (e.g, table doesn't exist)
                //

                ScepDeleteInfoForAreas(
                          cxtProfile,
                          SCE_ENGINE_SMP,
                          AREA_ALL
                          );

                SceJetDeleteTable( cxtProfile, "SmTblSap", SCEJET_TABLE_SAP );

                ScepPostProgress(4*TICKS_MIGRATION_SECTION, 0, NULL);

            } else {

                //
                // database format is wrong, migrate it
                //  Version 1.1: it only contains SDDL syntax change
                //    which applies to file/key/DS object/services (general)
                //  Version 1.2: table format change (SCP, GPO), more columns
                //
                // service extensions should handle their changes respectively
                // should be handled by WMI schema
                //

                if ( CurrentVersion != (FLOAT)1.1 ) {

                    rc = ScepMigrateDatabaseRevision0( cxtProfile );

                } else {

                    ScepPostProgress(4*TICKS_MIGRATION_SECTION, 0, NULL);
                }

            }

            if ( SCESTATUS_SUCCESS == rc ) {

                rc = ScepMigrateDatabaseRevision1( cxtProfile );

            }

            ScepPostProgress(TICKS_MIGRATION_V11, 0, NULL);

        } else if ( CurrentVersion == (FLOAT)1.2 ) {
            //
            // current version, no need to migrate
            //
        } // else newer version, BAD_FORMAT
    }

    return rc;
}



SCESTATUS
ScepMigrateDatabaseRevision0(
    IN PSCECONTEXT cxtProfile
    )
{

    SCESTATUS rc;
    DWORD nTickedSection=0;

    rc = ScepMigrateObjectSection(
              cxtProfile,
              szFileSecurity
              );

    ScepPostProgress(TICKS_MIGRATION_SECTION, 0, NULL);
    nTickedSection++;

    if ( rc == SCESTATUS_SUCCESS ) {

        rc = ScepMigrateObjectSection(
                  cxtProfile,
                  szRegistryKeys
                  );

        ScepPostProgress(TICKS_MIGRATION_SECTION, 0, NULL);
        nTickedSection++;

        if ( rc == SCESTATUS_SUCCESS ) {

            rc = ScepMigrateObjectSection(
                      cxtProfile,
                      szDSSecurity
                      );

            ScepPostProgress(TICKS_MIGRATION_SECTION, 0, NULL);
            nTickedSection++;

            if ( rc == SCESTATUS_SUCCESS ) {

                rc = ScepMigrateObjectSection(
                          cxtProfile,
                          szServiceGeneral
                          );

                if ( rc == SCESTATUS_SUCCESS ) {

                    //
                    // delete everything in SCP
                    //

                    SceJetDeleteAll( cxtProfile,
                                     "SmTblScp",
                                     SCEJET_TABLE_SCP
                                   );

                    //
                    // change version number to 1.1 now
                    //

                    FLOAT Version = (FLOAT)1.1;

                    rc = SceJetSetValueInVersion(
                                cxtProfile,
                                "SmTblVersion",
                                "Version",
                                (PWSTR)(&Version), //(PWSTR)CharTimeStamp,
                                4, // number of bytes
                                JET_prepReplace
                                );

                }

                ScepPostProgress(TICKS_MIGRATION_SECTION, 0, NULL);
                nTickedSection++;

            }
        }
    }

    if ( nTickedSection < 4 ) {
        ScepPostProgress((4-nTickedSection)*TICKS_MIGRATION_SECTION, 0, NULL);
    }

    return rc;
}


SCESTATUS
ScepMigrateObjectSection(
    IN PSCECONTEXT cxtProfile,
    IN PCWSTR szSection
    )
{
    //
    // should update all three tables (SCP/SMP/SAP)
    // we could just wipe SCP/SAP when SCP is used for accumulated policy
    //

    DOUBLE        SectionID = 0;
    SCESTATUS     rc;

    //
    // get section id
    //
    rc = SceJetGetSectionIDByName(
                cxtProfile,
                szSection,
                &SectionID
                );

    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
        rc = SCESTATUS_SUCCESS;
    } else if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    PSCESECTION hSection = NULL;

    if ( cxtProfile->JetSmpID != JET_tableidNil ) {
        //
        // SMP table
        //
        rc = SceJetOpenSection(
                    cxtProfile,
                    SectionID,
                    SCEJET_TABLE_SMP,
                    &hSection
                    );

        if ( SCESTATUS_SUCCESS == rc ) {

            rc = ScepMigrateOneSection(hSection);

        }

        if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
            rc = SCESTATUS_SUCCESS;
        }
    }


    if ( SCESTATUS_SUCCESS == rc &&
         cxtProfile->JetSapID != JET_tableidNil ) {

        //
        // SAP table
        //
        rc = SceJetOpenSection(
                    cxtProfile,
                    SectionID,
                    SCEJET_TABLE_SAP,
                    &hSection
                    );
        if ( SCESTATUS_SUCCESS == rc ) {

            rc = ScepMigrateOneSection(hSection);

        }
        if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
            rc = SCESTATUS_SUCCESS;
        }
    }

    //
    // SCP table is now pointing to SMP table, no need to migrate
    // all contents in SCP table should be deleted and repropped
    // by policy propagation
    //

    if ( hSection ) {
        SceJetCloseSection(&hSection, TRUE);
    }

    return rc;
}


SCESTATUS
ScepMigrateOneSection(
    PSCESECTION hSection
    )
{
    SCESTATUS rc;

    //
    // goto the first line of this section
    //

    rc = SceJetSeek(
                hSection,
                NULL,
                0,
                SCEJET_SEEK_GE
                );

    PWSTR pszValue=NULL;
    DWORD ValueSize=0;
    DWORD NewSize;

    while ( rc == SCESTATUS_SUCCESS ) {

        rc = SceJetGetValue(
                hSection,
                SCEJET_CURRENT,
                NULL,
                NULL,
                0,
                NULL,
                NULL,
                0,
                &ValueSize
                );

        if ( SCESTATUS_SUCCESS == rc ) {

            pszValue = (PWSTR)LocalAlloc(LPTR, ValueSize+sizeof(WCHAR));

            if ( pszValue ) {

                //
                // get the value
                //

                rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        NULL,
                        0,
                        NULL,
                        pszValue,
                        ValueSize,
                        &NewSize
                        );

                if ( SCESTATUS_SUCCESS == rc ) {

                    //
                    // browse the value field and convert it into new SDDL format
                    // the output is saved in the same buffer
                    //

                    pszValue[ValueSize/2] = L'\0';

                    rc = ScepConvertToSDDLFormat(pszValue, ValueSize/2);

                    if ( SCESTATUS_SUCCESS == rc ) {

                        rc = SceJetSetCurrentLine(
                                  hSection,
                                  pszValue,
                                  ValueSize
                                  );
                    }

                }

                LocalFree(pszValue);
                pszValue = NULL;

            } else {

                rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
            }
        }

        if ( rc != SCESTATUS_SUCCESS ) {
            break;
        }

        //
        // read next line
        //

        rc = SceJetGetValue(
                    hSection,
                    SCEJET_NEXT_LINE,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    NULL,
                    0,
                    &ValueSize
                    );
    }


    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
        rc = SCESTATUS_SUCCESS;
    }

    return rc;
}



SCESTATUS
ScepMigrateDatabaseRevision1(
    IN PSCECONTEXT cxtProfile
    )
{
    if ( cxtProfile == NULL ) {
        return SCESTATUS_INVALID_PARAMETER;
    }

    JET_ERR         JetErr;
    SCESTATUS       rc;
    JET_TABLEID     TableID;
    JET_COLUMNDEF   ColumnDef;
    JET_COLUMNID    ColumnID;

    rc = SceJetStartTransaction( cxtProfile );

    if ( SCESTATUS_SUCCESS != rc ) {
        return(rc);
    }

    //
    // add "LastUsedMergeTable field to the version table
    //
    rc = SceJetOpenTable(
                    cxtProfile,
                    "SmTblVersion",
                    SCEJET_TABLE_VERSION,
                    SCEJET_OPEN_READ_WRITE,
                    &TableID
                    );

    if ( SCESTATUS_SUCCESS == rc ) {

        ColumnDef.cbStruct = sizeof(JET_COLUMNDEF);
        ColumnDef.columnid = 0;
        ColumnDef.coltyp = JET_coltypLong;
        ColumnDef.wCountry = 0;
        ColumnDef.langid = 0;
        ColumnDef.cp = 0;
        ColumnDef.wCollate = 0;
        ColumnDef.cbMax = 4;
        ColumnDef.grbit = 0;

        JetErr = JetAddColumn(
                    cxtProfile->JetSessionID,
                    TableID,
                    "LastUsedMergeTable",
                    &ColumnDef,
                    NULL,
                    0,
                    &ColumnID
                    );

        if ( JET_errColumnDuplicate == JetErr ) {
            //
            // column already exist
            //
            JetErr = JET_errSuccess;
        }

        rc = SceJetJetErrorToSceStatus(JetErr);


        JetCloseTable(
                cxtProfile->JetSessionID,
                TableID
                );
    }

    //
    // add "GpoID" filed to the SCP tables
    //
    if ( SCESTATUS_SUCCESS == rc ) {

        TableID = JET_tableidNil;

        rc = SceJetOpenTable(
                        cxtProfile,
                        "SmTblScp",
                        SCEJET_TABLE_SCP,
                        SCEJET_OPEN_READ_WRITE,
                        &TableID
                        );

        if ( SCESTATUS_SUCCESS == rc ) {


            ColumnDef.cbStruct = sizeof(JET_COLUMNDEF);
            ColumnDef.columnid = 0;
            ColumnDef.coltyp = JET_coltypLong;
            ColumnDef.wCountry = 0;
            ColumnDef.langid = 0;
            ColumnDef.cp = 0;
            ColumnDef.wCollate = 0;
            ColumnDef.cbMax = 4;
            ColumnDef.grbit = 0;

            JetErr = JetAddColumn(
                        cxtProfile->JetSessionID,
                        TableID,
                        "GpoID",
                        &ColumnDef,
                        NULL,
                        0,
                        &ColumnID
                        );

            if ( JET_errColumnDuplicate == JetErr ) {
                //
                // column already exist
                //
                JetErr = JET_errSuccess;
            }

            rc = SceJetJetErrorToSceStatus(JetErr);


            JetCloseTable(
                    cxtProfile->JetSessionID,
                    TableID
                    );
        }
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        //
        // create the second SCP table
        //

        rc = SceJetCreateTable(
                        cxtProfile,
                        "SmTblScp2",
                        SCEJET_TABLE_SCP,
                        SCEJET_CREATE_NO_TABLEID,
                        NULL,
                        NULL
                        );

        if ( rc == SCESTATUS_SUCCESS ) {

            //
            // create the GPO table
            //

            rc = SceJetCreateTable(
                            cxtProfile,
                            "SmTblGpo",
                            SCEJET_TABLE_GPO,
                            SCEJET_CREATE_NO_TABLEID,
                            NULL,
                            NULL
                            );
        }
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        //
        // set new version #
        //
        FLOAT Version = (FLOAT)1.2;

        rc = SceJetSetValueInVersion(
                    cxtProfile,
                    "SmTblVersion",
                    "Version",
                    (PWSTR)(&Version),
                    4, // number of bytes
                    JET_prepReplace
                    );
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        SceJetCommitTransaction( cxtProfile, 0 );
    } else {
        SceJetRollback( cxtProfile, 0 );
    }

    return(rc);
}



SCESTATUS
ScepDeleteOldRegValuesFromTable(
    IN PSCECONTEXT hProfile,
    IN SCETYPE TableType
    )
{

    PSCESECTION hSection=NULL;

    if ( ScepOpenSectionForName(
                hProfile,
                TableType,
                szRegistryValues,
                &hSection
                ) == SCESTATUS_SUCCESS ) {

        SceJetDelete(
            hSection,
            TEXT("machine\\software\\microsoft\\windows nt\\currentversion\\winlogon\\disablecad"),
            FALSE,
            SCEJET_DELETE_LINE
            );

        SceJetDelete(
            hSection,
            TEXT("machine\\software\\microsoft\\windows nt\\currentversion\\winlogon\\dontdisplaylastusername"),
            FALSE,
            SCEJET_DELETE_LINE
            );

        SceJetDelete(
            hSection,
            TEXT("machine\\software\\microsoft\\windows nt\\currentversion\\winlogon\\legalnoticecaption"),
            FALSE,
            SCEJET_DELETE_LINE
            );

        SceJetDelete(
            hSection,
            TEXT("machine\\software\\microsoft\\windows nt\\currentversion\\winlogon\\legalnoticetext"),
            FALSE,
            SCEJET_DELETE_LINE
            );

        SceJetDelete(
            hSection,
            TEXT("machine\\software\\microsoft\\windows nt\\currentversion\\winlogon\\shutdownwithoutlogon"),
            FALSE,
            SCEJET_DELETE_LINE
            );

        SceJetDelete(
            hSection,
            TEXT("machine\\system\\currentcontrolset\\control\\lsa\\fullprivilegeauditing"),
            FALSE,
            SCEJET_DELETE_LINE
            );

        SceJetCloseSection( &hSection, TRUE );
    }

    return(SCESTATUS_SUCCESS);
}


BOOL
ScepCompareGroupNameList(
    IN PUNICODE_STRING DomainName,
    IN PSCE_NAME_LIST pListToCmp,
    IN PSCE_NAME_LIST pList
    )
{
    if ( DomainName == NULL ) {
        return(SceCompareNameList(pListToCmp, pList));
    }

    PSCE_NAME_LIST pTmpList, pTL2;
    DWORD count1, count2;
    PWSTR pTemp1, pTemp2;

    for ( pTmpList=pListToCmp, count2=0; pTmpList!=NULL; pTmpList=pTmpList->Next) {
        if ( pTmpList->Name != NULL ) {
           count2++;
        }
    }

    for ( pTmpList=pList,count1=0; pTmpList!=NULL; pTmpList=pTmpList->Next) {
        if ( pTmpList->Name == NULL ) {
            continue;
        }
        count1++;
        pTemp1 = wcschr(pTmpList->Name, L'\\');

        for ( pTL2=pListToCmp; pTL2 != NULL; pTL2=pTL2->Next ) {
            if ( pTL2->Name == NULL ) {
                continue;
            }
            pTemp2 = wcschr(pTmpList->Name, L'\\');

            if ( ( pTemp1 == NULL && pTemp2 == NULL ) ||
                 ( pTemp1 != NULL && pTemp2 != NULL ) ) {
                if ( _wcsicmp( pTL2->Name, pTmpList->Name) == 0 ) {
                    break;
                }
            } else if ( pTemp1 == NULL ) {
                if ( _wcsicmp( pTmpList->Name, pTemp2+1) == 0 ) {
                    //
                    // check if pTL2->Name's domain name equal to the account name
                    //
                    if ( pTemp2-pTL2->Name == DomainName->Length/2 &&
                         _wcsnicmp( pTL2->Name, DomainName->Buffer, DomainName->Length/2) == 0 ) {
                        break;
                    }
                }
            } else {
                //
                // if there is domain prefix, it must be acocunt domain
                // because this list is built by querying system
                //
                if ( _wcsicmp(pTemp1+1, pTL2->Name) == 0 ) {
                    break;
                }
            }
        }

        if ( pTL2 == NULL ) {
            return(FALSE);
        }
    }

    if ( count1 == count2 ) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}

SCESTATUS
ScepGetSystemSecurity(
    IN AREA_INFORMATION Area,
    IN DWORD Options,
    OUT PSCE_PROFILE_INFO *ppInfo,
    OUT PSCE_ERROR_LOG_INFO *pErrLog
    )
//
// query system settings for system access and user rights area only
//
{

    SCESTATUS Saverc = SCESTATUS_SUCCESS;
    SCESTATUS rc;

    if ( ppInfo == NULL || Area == 0 ) {
        //
        // nothing to set
        //
        return(Saverc);
    }

    //
    // initialize product type etc.
    //

    if ( RtlGetNtProductType (&ProductType) == FALSE ) {
        return( ScepDosErrorToSceStatus(GetLastError()));
    }

    //
    // allocate memory
    //
    *ppInfo = (PSCE_PROFILE_INFO)ScepAlloc( (UINT)0, sizeof(SCE_PROFILE_INFO));
    if ( *ppInfo == NULL ) {

        return( SCESTATUS_NOT_ENOUGH_RESOURCE );
    }
    //
    // reset local policy
    //
    memset(*ppInfo, '\0', sizeof(SCE_PROFILE_INFO));
    ScepResetSecurityPolicyArea(*ppInfo);

    (*ppInfo)->Type = SCE_ENGINE_SMP;

    if ( Area & AREA_PRIVILEGES ) {

        rc = ScepGetSystemPrivileges( Options,
                                      pErrLog,
                                      &((*ppInfo)->OtherInfo.smp.pPrivilegeAssignedTo)
                                    );

        if( rc != SCESTATUS_SUCCESS ) {
            Saverc = rc;
        }
    }


    if ( Area & AREA_SECURITY_POLICY ) {
        //
        // snapshot system access. Errors are logged within this function
        //
        rc = ScepAnalyzeSystemAccess(*ppInfo, NULL,
                                     SCEPOL_SYSTEM_SETTINGS,
                                     NULL, pErrLog);

        if( rc != SCESTATUS_SUCCESS ) {

            Saverc = rc;
        }

        //
        // Audit policy
        //
        PPOLICY_AUDIT_EVENTS_INFO     AuditEvent=NULL;

        rc = ScepSaveAndOffAuditing(&AuditEvent, FALSE, NULL);

        if ( rc == SCESTATUS_SUCCESS && AuditEvent ) {

            //
            // assign auditEvent buffer to the output buffer
            //

            if ( !AuditEvent->AuditingMode ) {

                for ( DWORD i=0; i<AuditEvent->MaximumAuditEventCount; i++ )
                    AuditEvent->EventAuditingOptions[i] = 0;
            }

            (*ppInfo)->AuditSystemEvents = AuditEvent->EventAuditingOptions[AuditCategorySystem];
            (*ppInfo)->AuditLogonEvents  = AuditEvent->EventAuditingOptions[AuditCategoryLogon];
            (*ppInfo)->AuditObjectAccess = AuditEvent->EventAuditingOptions[AuditCategoryObjectAccess];
            (*ppInfo)->AuditPrivilegeUse = AuditEvent->EventAuditingOptions[AuditCategoryPrivilegeUse];
            (*ppInfo)->AuditProcessTracking = AuditEvent->EventAuditingOptions[AuditCategoryDetailedTracking];
            (*ppInfo)->AuditPolicyChange = AuditEvent->EventAuditingOptions[AuditCategoryPolicyChange];
            (*ppInfo)->AuditAccountManage = AuditEvent->EventAuditingOptions[AuditCategoryAccountManagement];
            (*ppInfo)->AuditDSAccess = AuditEvent->EventAuditingOptions[AuditCategoryDirectoryServiceAccess];
            (*ppInfo)->AuditAccountLogon = AuditEvent->EventAuditingOptions[AuditCategoryAccountLogon];

        } else {

            ScepBuildErrorLogInfo(
                    ScepSceStatusToDosError(rc),
                    pErrLog,
                    SCEDLL_ERROR_QUERY_EVENT_AUDITING
                    );

        }


        if ( AuditEvent ) {
            LsaFreeMemory(AuditEvent);
        }

        if( rc != SCESTATUS_SUCCESS ) {
            Saverc = rc;
        }

        //
        // Kerberos Policy
        //
        (*ppInfo)->pKerberosInfo = (PSCE_KERBEROS_TICKET_INFO)ScepAlloc(LPTR,sizeof(SCE_KERBEROS_TICKET_INFO));

        if ( (*ppInfo)->pKerberosInfo ) {

            (*ppInfo)->pKerberosInfo->MaxTicketAge = SCE_NO_VALUE;
            (*ppInfo)->pKerberosInfo->MaxRenewAge = SCE_NO_VALUE;
            (*ppInfo)->pKerberosInfo->MaxServiceAge = SCE_NO_VALUE;
            (*ppInfo)->pKerberosInfo->MaxClockSkew = SCE_NO_VALUE;
            (*ppInfo)->pKerberosInfo->TicketValidateClient = SCE_NO_VALUE;

            rc = ScepAnalyzeKerberosPolicy(NULL,
                                          (*ppInfo)->pKerberosInfo,
                                          Options | SCE_SYSTEM_SETTINGS
                                          );
        } else {

            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }

        if( rc != SCESTATUS_SUCCESS ) {

            ScepBuildErrorLogInfo(
                    ScepSceStatusToDosError(rc),
                    pErrLog,
                    SCEDLL_SAP_ERROR_KERBEROS
                    );
            Saverc = rc;
        }

        //
        // registry values
        //
        rc = ScepAnalyzeRegistryValues(NULL,
                                       SCEREG_VALUE_SYSTEM,
                                       *ppInfo
                                      );

        if( rc != SCESTATUS_SUCCESS ) {
            ScepBuildErrorLogInfo(
                    ScepSceStatusToDosError(rc),
                    pErrLog,
                    SCEDLL_ERROR_QUERY_INFO,
                    szRegistryValues
                    );
            Saverc = rc;
        }

    }

    //
    // The buffer is not freed even if there is error.
    // because we want to show as many settings as we can.
    //

    return(Saverc);
}


SCESTATUS
ScepGetSystemPrivileges(
    IN DWORD Options,
    IN OUT PSCE_ERROR_LOG_INFO *pErrLog,
    OUT PSCE_PRIVILEGE_ASSIGNMENT *pCurrent
    )
/*
    query privilege/user right assignments from the current system
*/
{

    if ( pCurrent == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    NTSTATUS    NtStatus;
    LSA_HANDLE  PolicyHandle=NULL;
    DWORD       rc;
    SCESTATUS   saveRc=SCESTATUS_SUCCESS;

    ULONG       CountReturned;
    UNICODE_STRING UserRight;
    PLSA_ENUMERATION_INFORMATION EnumBuffer=NULL;
    DWORD       i=0, j;

    PLSA_TRANSLATED_NAME Names=NULL;
    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains=NULL;
    PSCE_NAME_LIST  pNameList=NULL;

    PSCE_PRIVILEGE_ASSIGNMENT  pPrivilege=NULL;


    //
    // Open LSA policy
    //
    NtStatus = ScepOpenLsaPolicy(
                    POLICY_VIEW_LOCAL_INFORMATION | POLICY_LOOKUP_NAMES,
                    &PolicyHandle,
                    TRUE
                    );

    if ( !NT_SUCCESS(NtStatus) ) {
        rc = RtlNtStatusToDosError(NtStatus);

        if ( pErrLog ) {
            ScepBuildErrorLogInfo(
                rc,
                pErrLog,
                SCEDLL_LSA_POLICY
                );
        }

        return(ScepDosErrorToSceStatus( rc ));
    }

    //
    // enumerate accounts for each user right
    //
    ScepIsDomainLocal(NULL);

    for ( i=0; i<cPrivCnt; i++) {

        RtlInitUnicodeString( &UserRight, (PCWSTR)(SCE_Privileges[i].Name));

        //
        // now enumerate all accounts for this user right.
        //

        NtStatus = LsaEnumerateAccountsWithUserRight(
                            PolicyHandle,
                            &UserRight,
                            (PVOID *)&EnumBuffer,   // account SIDs
                            &CountReturned
                            );

        rc = RtlNtStatusToDosError(NtStatus);

        if ( !NT_SUCCESS(NtStatus) &&
             NtStatus != STATUS_NO_MORE_ENTRIES &&
             NtStatus != STATUS_NO_SUCH_PRIVILEGE &&
             NtStatus != STATUS_NOT_FOUND ) {

            ScepBuildErrorLogInfo(
                rc,
                pErrLog,
                SCEDLL_SAP_ERROR_ENUMERATE,
                SCE_Privileges[i].Name
                );

            saveRc = ScepDosErrorToSceStatus(rc);
            continue;
        }

        if ( NT_SUCCESS(NtStatus) ) {

            //
            // a sce_privilege_assignment structure. allocate buffer
            //
            pPrivilege = (PSCE_PRIVILEGE_ASSIGNMENT)ScepAlloc( LMEM_ZEROINIT,
                                                               sizeof(SCE_PRIVILEGE_ASSIGNMENT) );
            if ( pPrivilege == NULL ) {
                //
                // when this occurred, the system is hosed.
                // buffer should be freed and error should be returned.
                //
                saveRc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                break;
            }

            pPrivilege->Name = (PWSTR)ScepAlloc( (UINT)0, UserRight.Length+2);
            if ( pPrivilege->Name == NULL ) {
                ScepFree(pPrivilege);
                saveRc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                break;
            }

            wcscpy(pPrivilege->Name, UserRight.Buffer);
            pPrivilege->Value = i;
            pPrivilege->Status = 0;

            // link it to the output buffer
            pPrivilege->Next = *pCurrent;
            *pCurrent = pPrivilege;

            if ( CountReturned > 0 ) {

                //
                // error occurred in lookup will be ignored
                // since accounts will be returned in SID format
                //
                NtStatus = LsaLookupSids(
                                PolicyHandle,
                                CountReturned,
                                (PSID *)EnumBuffer,
                                &ReferencedDomains,
                                &Names
                                );

                rc = RtlNtStatusToDosError(rc);

                if ( NT_SUCCESS(NtStatus) ) {
                    //
                    // some may not be mapped
                    // in this case, return the SID string
                    //

                    for ( j=0; j<CountReturned; j++ ) {

                        if ( Names[j].Use == SidTypeInvalid ||
                             Names[j].Use == SidTypeUnknown ||
                             Names[j].Use == SidTypeDeletedAccount ) {

                            //
                            // this name is not mapped, add it in Sid string
                            //
                            rc = ScepAddSidStringToNameList(&pNameList, EnumBuffer[j].Sid);

                        } else {

                            //
                            // build the full name of each account
                            //
                            if ( ReferencedDomains->Entries > 0 && Names[j].Use != SidTypeWellKnownGroup &&
                                 ReferencedDomains->Domains != NULL &&
                                 Names[j].DomainIndex != -1 &&
                                 (ULONG)(Names[j].DomainIndex) < ReferencedDomains->Entries &&
                                 ScepIsDomainLocalBySid(ReferencedDomains->Domains[Names[j].DomainIndex].Sid) == FALSE &&
                                 ScepIsDomainLocal(&ReferencedDomains->Domains[Names[j].DomainIndex].Name) == FALSE ) {

                                //
                                // add both domain name and account name
                                //
                                rc = ScepAddTwoNamesToNameList(
                                                  &pNameList,
                                                  TRUE,
                                                  ReferencedDomains->Domains[Names[j].DomainIndex].Name.Buffer,
                                                  ReferencedDomains->Domains[Names[j].DomainIndex].Name.Length/2,
                                                  Names[j].Name.Buffer,
                                                  Names[j].Name.Length/2);
                            } else {
                                //
                                // add only the account name
                                //
                                rc = ScepAddToNameList(
                                              &pNameList,
                                              Names[j].Name.Buffer,
                                              Names[j].Name.Length/2);
                            }
                        }

                        if ( NO_ERROR != rc ) {

                            pPrivilege->Status = SCE_STATUS_ERROR_NOT_AVAILABLE;
                            saveRc = ScepDosErrorToSceStatus(rc);
                        }
                    }

                } else {
                    //
                    // lookup for all sids failed or none is mapped
                    // add the SIDs
                    //

                    for ( j=0; j<CountReturned; j++ ) {
                        //
                        // build each account into the name list
                        // Convert using the Rtl functions
                        //
                        rc = ScepAddSidStringToNameList(&pNameList, EnumBuffer[j].Sid);

                        if ( NO_ERROR != rc ) {
                            //
                            // mark the status
                            //
                            pPrivilege->Status = SCE_STATUS_ERROR_NOT_AVAILABLE;
                            saveRc = ScepDosErrorToSceStatus(rc);

                        }
                    }

                }

                if (ReferencedDomains) {
                    LsaFreeMemory(ReferencedDomains);
                    ReferencedDomains = NULL;
                }

                if (Names) {
                    LsaFreeMemory(Names);
                    Names = NULL;
                }

                if ( pPrivilege->Status ) {

                    ScepBuildErrorLogInfo(
                        rc,
                        pErrLog,
                        SCEDLL_SAP_ERROR_ENUMERATE,
                        SCE_Privileges[i].Name
                        );
                }

                pPrivilege->AssignedTo = pNameList;
                pNameList = NULL;

            }

            LsaFreeMemory( EnumBuffer );
            EnumBuffer = NULL;

        } else {
            //
            // no account is assigned this privilege
            // or the privilege is not found
            // should continue the process
            //
        }
    }

    if ( saveRc == SCESTATUS_NOT_ENOUGH_RESOURCE ) {
        //
        // should free the output buffer since there is no more memory
        //
        ScepFreePrivilege(*pCurrent);
        *pCurrent = NULL;
    }

    if ( pNameList != NULL )
        ScepFreeNameList( pNameList );

    LsaClose(PolicyHandle);

    return( saveRc );

}

DWORD
ScepAddSidStringToNameList(
    IN OUT PSCE_NAME_LIST *ppNameList,
    IN PSID pSid
    )
{
    NTSTATUS NtStatus;
    UNICODE_STRING UnicodeStringSid;
    DWORD rc;

    NtStatus = RtlConvertSidToUnicodeString( &UnicodeStringSid,
                                             pSid,
                                             TRUE );
    rc = RtlNtStatusToDosError(NtStatus);

    if ( NT_SUCCESS( NtStatus ) ) {

        rc = ScepAddTwoNamesToNameList(
                      ppNameList,
                      FALSE,
                      L"*",
                      1,
                      UnicodeStringSid.Buffer,
                      UnicodeStringSid.Length/2
                      );

        RtlFreeUnicodeString( &UnicodeStringSid );

    }

    return(rc);
}


DWORD
ScepGetLSAPolicyObjectInfo(
    OUT DWORD   *pdwAllow
    )
/*
Routine Description:

    This routine checks whether the Anonymous User/SID has permissions to do SID<->name translation.
    No errors are logged by this routine - they will be logged outside if need be.

Arguments:

    pdwAllow    -   pointer to the DWORD that is 1 if Anonymous User/SID has this permission, else 0

Return Value:

    Win32 error code
*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    DWORD       rc = ERROR_SUCCESS;
    PACL        pNewAcl = NULL;
    DWORD       dwAceType;
    BOOL        bAddAce = FALSE;
    PSECURITY_DESCRIPTOR    pSDlsaPolicyObject = NULL;
    SECURITY_DESCRIPTOR SDAbsolute;

    if ( pdwAllow == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    LSA_HANDLE  LsaHandle = NULL;

    NtStatus = ScepOpenLsaPolicy(
                                MAXIMUM_ALLOWED,
                                &LsaHandle,
                                TRUE
                                );

    rc = RtlNtStatusToDosError( NtStatus );

    if ( rc == ERROR_SUCCESS ) {

        NtStatus = LsaQuerySecurityObject(
                                         LsaHandle,
                                         OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                                         &pSDlsaPolicyObject
                                         );

        rc = RtlNtStatusToDosError( NtStatus );

        if ( rc == ERROR_SUCCESS ) {

            if ( ghAuthzResourceManager ) {

                SID AnonymousSid;
                SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;
                AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext = NULL;
                LUID    Identifier = {0};

                RtlInitializeSid ( &AnonymousSid, &NtAuth, 1);
                *RtlSubAuthoritySid ( &AnonymousSid, 0 ) = SECURITY_ANONYMOUS_LOGON_RID;

                if ( AuthzInitializeContextFromSid(AUTHZ_SKIP_TOKEN_GROUPS,
                                                  &AnonymousSid,
                                                  ghAuthzResourceManager,
                                                  0,
                                                  Identifier,
                                                  NULL,
                                                  &hAuthzClientContext) ) {

                    AUTHZ_ACCESS_REPLY AuthzReply;
                    AUTHZ_ACCESS_REQUEST AuthzRequest;
                    ACCESS_MASK GrantedAccessMask;
                    DWORD   AuthzError;

                    AuthzReply.ResultListLength = 1;
                    AuthzReply.GrantedAccessMask = &GrantedAccessMask;
                    AuthzReply.Error = &AuthzError;
                    AuthzReply.SaclEvaluationResults = NULL;

                    memset(&AuthzRequest, 0, sizeof(AuthzRequest));
                    AuthzRequest.DesiredAccess = POLICY_LOOKUP_NAMES;

                    if ( AuthzAccessCheck(0,
                                         hAuthzClientContext,
                                         &AuthzRequest,
                                         NULL,
                                         pSDlsaPolicyObject,
                                         NULL,
                                         NULL,
                                         &AuthzReply,
                                         NULL) ) {

                        //
                        // check if existing access is different from desired access
                        // if so, add the appropriate ACE
                        //

                        if ( GrantedAccessMask & POLICY_LOOKUP_NAMES ) {
                            //ASSERT(AuthzError == ERROR_SUCCESS);

                            *pdwAllow = 1;

                        } else {
                            //ASSERT(AuthzError == ERROR_ACCESS_DENIED || AuthzError == ERROR_PRIVILEGE_NOT_HELD);

                            *pdwAllow = 0;
                        }

                    }

                    else {

                        rc = GetLastError();

                    }

                    AuthzFreeContext( hAuthzClientContext );

                } else {

                    rc = GetLastError();

                }

            }

            else {

                rc = ERROR_RESOURCE_NOT_PRESENT;

            }

            LsaFreeMemory(pSDlsaPolicyObject);

        }

        LsaClose(LsaHandle);

    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\dsgroups.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dsgroups.cpp

Abstract:

    Routines to configure/analyze groups in DS

Author:

    Jin Huang (jinhuang) 7-Nov-1996

--*/
#include "headers.h"
#include "serverp.h"
#include <io.h>
#include <lm.h>
#include <lmcons.h>
#include <lmapibuf.h>
#pragma hdrstop

//
// LDAP handle
//
PLDAP Thread pGrpLDAP = NULL;
HANDLE Thread hDS = NULL;

HINSTANCE Thread hNtdsApi = NULL;

#define SCEGRP_MEMBERS      1
#define SCEGRP_MEMBERSHIP   2

#if _WIN32_WINNT>=0x0500

typedef DWORD (WINAPI *PFNDSBIND) (TCHAR *, TCHAR *, HANDLE *);
typedef DWORD (WINAPI *PFNDSUNBIND) (HANDLE *);
typedef DWORD (WINAPI *PFNDSCRACKNAMES) ( HANDLE, DS_NAME_FLAGS, DS_NAME_FORMAT, \
                              DS_NAME_FORMAT, DWORD, LPTSTR *, PDS_NAME_RESULT *);
typedef void (WINAPI *PFNDSFREENAMERESULT) (DS_NAME_RESULT *);


DWORD
ScepDsConfigGroupMembers(
    IN PSCE_OBJECT_LIST pRoots,
    IN PWSTR GroupName,
    IN OUT DWORD *pStatus,
    IN PSCE_NAME_LIST pMembers,
    IN PSCE_NAME_LIST pMemberOf,
    IN OUT DWORD *nGroupCount
    );

DWORD
ScepDsGetDsNameList(
    IN PSCE_NAME_LIST pNameList,
    OUT PSCE_NAME_LIST *pRealNames
    );

DWORD
ScepDsCompareNames(
    IN PWSTR *Values,
    IN OUT PSCE_NAME_LIST *pAddList,
    OUT PSCE_NAME_LIST *pDeleteList OPTIONAL
    );

DWORD
ScepDsChangeMembers(
    IN ULONG Flag,
    IN PWSTR RealGroupName,
    IN PSCE_NAME_LIST pAddList OPTIONAL,
    IN PSCE_NAME_LIST pDeleteList OPTIONAL
    );

DWORD
ScepDsAnalyzeGroupMembers(
    IN LSA_HANDLE LsaPolicy,
    IN PSCE_OBJECT_LIST pRoots,
    IN PWSTR GroupName,
    IN PWSTR KeyName,
    IN DWORD KeyLen,
    IN OUT DWORD *pStatus,
    IN PSCE_NAME_LIST pMembers,
    IN PSCE_NAME_LIST pMemberOf,
    IN OUT DWORD *nGroupCount
    );

DWORD
ScepDsMembersDifferent(
    IN ULONG Flag,
    IN PWSTR *Values,
    IN OUT PSCE_NAME_LIST *pNameList,
    OUT PSCE_NAME_LIST *pCurrentList,
    OUT PBOOL pbDifferent
    );

PWSTR
ScepGetLocalAdminsName();

DWORD
ScepDsConvertDsNameList(
    IN OUT PSCE_NAME_LIST pDsNameList
    );

//
// helpers
//

SCESTATUS
ScepCrackOpen(
    OUT HANDLE *phDS
    )
{

    if ( !phDS ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    DWORD               Win32rc;

    *phDS = NULL;

    hNtdsApi = LoadLibrary(TEXT("ntdsapi.dll"));

    if ( hNtdsApi == NULL ) {
        return (SCESTATUS_MOD_NOT_FOUND);
    }

    PFNDSBIND pfnDsBind;
    PFNDSUNBIND pfnDsUnBind;

#if defined(UNICODE)
    pfnDsBind = (PFNDSBIND)GetProcAddress(hNtdsApi, "DsBindW");
    pfnDsUnBind = (PFNDSUNBIND)GetProcAddress(hNtdsApi, "DsUnBindW");
#else
    pfnDsBind = (PFNDSBIND)GetProcAddress(hNtdsApi, "DsBindA");
    pfnDsUnBind = (PFNDSUNBIND)GetProcAddress(hNtdsApi, "DsUnBindA");
#endif

    if ( pfnDsBind == NULL || pfnDsUnBind == NULL ) {
        return(SCESTATUS_MOD_NOT_FOUND);
    }


    Win32rc = (*pfnDsBind) (
                NULL,
                NULL,
                phDS);


    if ( Win32rc != ERROR_SUCCESS ) {
        ScepLogOutput3(3, Win32rc, IDS_ERROR_BIND, L"the GC");
    }

    return(ScepDosErrorToSceStatus(Win32rc));

}

SCESTATUS
ScepCrackClose(
    IN HANDLE *phDS
    )
{
    if ( hNtdsApi ) {

        if ( phDS ) {

            PFNDSUNBIND pfnDsUnBind;

#if defined(UNICODE)
            pfnDsUnBind = (PFNDSUNBIND)GetProcAddress(hNtdsApi, "DsUnBindW");
#else
            pfnDsUnBind = (PFNDSUNBIND)GetProcAddress(hNtdsApi, "DsUnBindA");
#endif

            if ( pfnDsUnBind ) {
                (*pfnDsUnBind) (phDS);
            }
        }

        FreeLibrary(hNtdsApi);
        hNtdsApi = NULL;

    }

    return(SCESTATUS_SUCCESS);
}
#endif

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// Functions to configure group membership in DS
//
//
//
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SCESTATUS
ScepConfigDsGroups(
    IN OUT PSCE_GROUP_MEMBERSHIP pGroupMembership,
    IN DWORD ConfigOptions
    )
/* ++

Routine Description:

   Configure the ds group membership. The main difference of ds groups
   from NT4 groups is that now group can be a member of another group.
   Members in the group are configured exactly as the pMembers list in
   the restricted group. The group is only validated (added) as a member
   of the MemberOf group list. Other existing members in those groups
   won't be removed.

   The restricted groups are specified in the SCP profile by group name.
   It could be a global group, or a alias (no difference in NT5 DS),
   but must be defined in the local domain.

Arguments:

    pGroupMembership - The restricted group list with members/memberof info to configure

    ConfigOptions - options passed in for the configuration

Return value:

   SCESTATUS error codes

++ */
{

#if _WIN32_WINNT<0x0500
    return(SCESTATUS_SUCCESS);

#else
    if ( pGroupMembership == NULL ) {

        ScepPostProgress(TICKS_GROUPS,
                         AREA_GROUP_MEMBERSHIP,
                         NULL);

        return(SCESTATUS_SUCCESS);
    }

    SCESTATUS           rc;

    //
    // open the Ldap server, should open two ldap server, one for the local domain
    // the other is for the global search (for members, membership)
    //

    rc = ScepLdapOpen(&pGrpLDAP);

    if ( rc == SCESTATUS_SUCCESS ) {
        rc = ScepCrackOpen(&hDS);
    }

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // get the root of the domain
        //

        PSCE_OBJECT_LIST pRoots=NULL;

        rc = ScepEnumerateDsObjectRoots(
                    pGrpLDAP,
                    &pRoots
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            PSCE_GROUP_MEMBERSHIP pGroup;
            DWORD               Win32rc;
            DWORD               rc32=NO_ERROR;  // the saved status
            BOOL                bAdminFound=FALSE;
            DWORD               nGroupCount=0;

            //
            // configure each group
            //

            for ( pGroup=pGroupMembership; pGroup != NULL; pGroup=pGroup->Next ) {

                //
                // if both members and memberof are not defined for the group
                // we don't need to do anything for the group
                //

                if ( ( pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS ) &&
                     ( pGroup->Status & SCE_GROUP_STATUS_NC_MEMBEROF  ) ) {
                    continue;
                }

                //
                // if within policy propagation and a system shutdown
                // is requested, we need to quit as soon as possible
                //

                if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                     ScepIsSystemShutDown() ) {

                    rc = SCESTATUS_SERVICE_NOT_SUPPORT;
                    break;
                }

                LPTSTR pTemp = wcschr(pGroup->GroupName, L'\\');
                if ( pTemp ) {

                    //
                    // there is a domain name, check it with computer name
                    // to determine if the account is local
                    //

                    UNICODE_STRING uName;

                    uName.Buffer = pGroup->GroupName;
                    uName.Length = ((USHORT)(pTemp-pGroup->GroupName))*sizeof(TCHAR);

                    if ( !ScepIsDomainLocal(&uName) ) {

                        //
                        // non local groups are not supported for the configuration
                        //

                        ScepLogOutput3(1, 0, SCEDLL_NO_MAPPINGS, pGroup->GroupName);
                        rc = SCESTATUS_INVALID_DATA;

                        pGroup->Status |= SCE_GROUP_STATUS_DONE_IN_DS;
                        continue;
                    }
                    pTemp++;

                } else {

                    pTemp = pGroup->GroupName;
                }

                //
                // local groups will be handled outside (in SAM)
                // find the group (validate) in this domain
                //

                Win32rc = ScepDsConfigGroupMembers(
                                         pRoots,
                                         pTemp, // pGroup->GroupName,
                                         &(pGroup->Status),
                                         pGroup->pMembers,
                                         pGroup->pMemberOf,
                                         &nGroupCount
                                         );

                if ( Win32rc != ERROR_SUCCESS &&
                     (pGroup->Status & SCE_GROUP_STATUS_DONE_IN_DS) ) {

                    //
                    // the group should be handled by the DS function
                    // but it failed.
                    //

                    ScepLogOutput3(1,Win32rc, SCEDLL_SCP_ERROR_CONFIGURE, pGroup->GroupName);

                    rc32 = Win32rc;

                    if ( Win32rc == ERROR_FILE_NOT_FOUND ||
                         Win32rc == ERROR_SHARING_VIOLATION ||
                         Win32rc == ERROR_ACCESS_DENIED ) {

                        Win32rc = ERROR_SUCCESS;

                    } else
                        break;
                }

            }

            if ( rc32 != NO_ERROR ) {
                rc = ScepDosErrorToSceStatus(rc32);
            }

            //
            // free the root DN buffer
            //

            ScepFreeObjectList(pRoots);

        }

    }

    if ( pGrpLDAP ) {
        ScepLdapClose(&pGrpLDAP);
        pGrpLDAP = NULL;
    }

    ScepCrackClose(&hDS);
    hDS = NULL;

    //
    // ticks will be called within ConfigureGroupMembership, so ignore it here
    //

    return(rc);
#endif

}


#if _WIN32_WINNT>=0x0500

DWORD
ScepDsConfigGroupMembers(
    IN PSCE_OBJECT_LIST pRoots,
    IN PWSTR GroupName,
    IN OUT DWORD *pStatus,
    IN PSCE_NAME_LIST pMembers,
    IN PSCE_NAME_LIST pMemberOf,
    IN OUT DWORD *nGroupCount
    )
/*
Description:

    Configure group membership (members and Memberof) of a group, specified by
    GroupName.

    The group membership is configured using ldap based on info stored in DS.
    Since foreign wellknown principals may not be present in the Active
    Directory, this function cannot configure membership with well known
    principals.

    Global groups and Universal groups cannot have wellknown pricipals as
    members (or memberof) but local groups (such as builtin groups) can. In
    order to solve this problem, local groups are configured using the old
    SAM apis outside of this function. This function only configures global
    and Universal group defined in the local domain. If the group is a
    global or universal group, the pStatus parameter will be marked to
    indicate the group is processed by this function (SCE_GROUP_STATUS_DONE_IN_DS)
    so the old SAM function can skip it.

Arguments:

    pRoots      - contains the local domain's base DN

    GroupName   - the group name to configure

    pStatus     - the status of the group (such as member defined, memberof defined, etc)

    pMembers    - the list of members to configure

    pMemberOf   - the list of memberOf to configure

    nGroupCount - the count maintained for progress indication only. If the group is
                  processed in this function, the count will be incremented.

Return:

    WIN32 error code.

*/
{
    if ( GroupName == NULL ) {
        return(ERROR_SUCCESS);
    }

    if ( pRoots == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    DWORD retErr = ERROR_SUCCESS;
    DWORD retSave = ERROR_SUCCESS;

    //
    // search for the group name, if find it, get members and memberof attributes
    //

    LDAPMessage *Message = NULL;
    PWSTR    Attribs[4];

    Attribs[0] = L"distinguishedName";
    Attribs[1] = L"member";
    Attribs[2] = L"memberOf";
    Attribs[3] = NULL;

    WCHAR tmpBuf[128];

    //
    // define a filter for global or universal group only
    //

    wcscpy(tmpBuf, L"( &(&(|");
    swprintf(tmpBuf+wcslen(L"( &(&(|"), L"(groupType=%d)(groupType=%d))(objectClass=group))(samAccountName=\0",
             GROUP_TYPE_ACCOUNT_GROUP | GROUP_TYPE_SECURITY_ENABLED, GROUP_TYPE_UNIVERSAL_GROUP | GROUP_TYPE_SECURITY_ENABLED);

    PWSTR Filter;

    Filter = (PWSTR)LocalAlloc(LMEM_ZEROINIT,
                               (wcslen(tmpBuf)+wcslen(GroupName)+4)*sizeof(WCHAR));

    if ( Filter == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    swprintf(Filter, L"%s%s) )", tmpBuf, GroupName);

    //
    // no chased referrel search because the group must be defined locally
    // on the domain
    //

    pGrpLDAP->ld_options = 0;

    retErr = ldap_search_s(
              pGrpLDAP,
              pRoots->Name,
              LDAP_SCOPE_SUBTREE,
              Filter,
              Attribs,
              0,
              &Message);

    retErr = LdapMapErrorToWin32(retErr);

    if(retErr == ERROR_SUCCESS) {

        LDAPMessage *Entry = NULL;

        //
        // find the group, should have only one entry, unless there are duplicate
        // groups within the domain, in which case, we only care the first entry anyway
        //

        Entry = ldap_first_entry(pGrpLDAP, Message);

        if(Entry != NULL) {

            //
            // get the values of requested attributes
            // Note, Value pointer returned must be freed
            //

            PWSTR  *Values;
            PWSTR  RealGroupName;

            //
            // the DN name
            //

            Values = ldap_get_values(pGrpLDAP, Entry, Attribs[0]);

            if(Values != NULL) {

                ScepLogOutput3(1,0, SCEDLL_SCP_CONFIGURE, GroupName);

                if ( *nGroupCount < TICKS_GROUPS ) {
                    ScepPostProgress(1,
                                     AREA_GROUP_MEMBERSHIP,
                                     GroupName);
                    *nGroupCount++;
                }

                //
                // Save the real group name for add/remove members later.
                //

                RealGroupName = (PWSTR)LocalAlloc(0,(wcslen(Values[0]) + 1)*sizeof(WCHAR));
                if ( RealGroupName != NULL ) {

                    wcscpy(RealGroupName, Values[0]);
                    ldap_value_free(Values);

                    ScepLogOutput3(3, 0, SCEDLL_SCP_CONFIGURE, RealGroupName);

                    PSCE_NAME_LIST pRealNames=NULL;
                    PSCE_NAME_LIST pDeleteNames=NULL;

                    //
                    // translate each name in the pMembers list to real ds names (search)
                    //

                    if ( !( *pStatus & SCE_GROUP_STATUS_NC_MEMBERS) ) {

                        retErr = ScepDsGetDsNameList(pMembers, &pRealNames);

                        retSave = retErr;

                        //
                        // continue to configure group membership even if
                        // there are some members not resolved
                        //
                        // BUT if no member is resolved, do not proceed to remove
                        // all members
                        //

                        if ( retErr == ERROR_SUCCESS ||
                             (retErr == ERROR_FILE_NOT_FOUND && pRealNames) ) {

                            //
                            // get members attribute
                            //

                            Values = ldap_get_values(pGrpLDAP, Entry, Attribs[1]);

                            if ( Values != NULL ) {

                                //
                                // process each member
                                //

                                retErr = ScepDsCompareNames(Values, &pRealNames, &pDeleteNames);
                                ldap_value_free(Values);

                            } else {
                                //
                                // it is OK if no members are found
                                //
                                ScepLogOutput3(3, 0, SCEDLL_EMPTY_MEMBERSHIP);
                                retErr = ERROR_SUCCESS;
                            }

                            if ( NO_ERROR == retErr ) {

                                //
                                // add/remove members of the group
                                //

                                retErr = ScepDsChangeMembers(SCEGRP_MEMBERS,
                                                             RealGroupName,
                                                             pRealNames,
                                                             pDeleteNames);
                            }

                            if ( ERROR_SUCCESS == retSave ) {
                                retSave = retErr;
                            }
                        }

                        //
                        // free buffers
                        //

                        ScepFreeNameList(pRealNames);
                        ScepFreeNameList(pDeleteNames);
                        pRealNames = NULL;
                        pDeleteNames = NULL;
                    }

                    if ( !( *pStatus & SCE_GROUP_STATUS_NC_MEMBEROF) ) {

                        //
                        // memberof is also defined for the group
                        // crack the memberof list first
                        //

                        retErr = ScepDsGetDsNameList(pMemberOf, &pRealNames);

                        if ( ERROR_SUCCESS == retSave ) {
                            retSave = retErr;
                        }

                        if ( ( ERROR_SUCCESS == retErr ||
                               ERROR_FILE_NOT_FOUND == retErr ) && pRealNames ) {

                            //
                            // get memberof attribute of the group
                            //

                            Values = ldap_get_values(pGrpLDAP, Entry, Attribs[2]);

                            if ( Values != NULL ) {

                                //
                                // process each membership
                                //

                                retErr = ScepDsCompareNames(Values, &pRealNames, NULL);
                                ldap_value_free(Values);

                            } else {

                                //
                                // it is OK if no membership is defined
                                //

                                ScepLogOutput3(3, 0, SCEDLL_EMPTY_MEMBERSHIP);
                                retErr = NO_ERROR;
                            }

                            if ( retErr == NO_ERROR ) {

                                //
                                // add the group to the defined membership
                                // Note, other existing membership is not removed
                                //

                                retErr = ScepDsChangeMembers(SCEGRP_MEMBERSHIP,
                                                             RealGroupName,
                                                             pRealNames,
                                                             NULL);
                            }

                            ScepFreeNameList(pRealNames);
                            pRealNames = NULL;

                            //
                            // remember the error
                            //

                            if ( ERROR_SUCCESS == retSave ) {
                                retSave = retErr;
                            }
                        }

                    }

                    LocalFree(RealGroupName);

                } else {
                    ldap_value_free(Values);
                    retErr = ERROR_NOT_ENOUGH_MEMORY;
                }

                //
                // regardless success or failure, this group has been
                // processed by this function. Mark it so that it will
                // be skipped by the old SAM API
                //

                *pStatus |= SCE_GROUP_STATUS_DONE_IN_DS;

            } else {

                //
                // Value[0] (group name) can not be empty
                //

                retErr = LdapMapErrorToWin32(pGrpLDAP->ld_errno);
                ScepLogOutput3(3,retErr, SCEDLL_CANNOT_FIND, GroupName);
            }

        } else {

            //
            // the group is not found
            //

            retErr = ERROR_FILE_NOT_FOUND;
            ScepLogOutput3(3,retErr, SCEDLL_CANNOT_FIND, GroupName);
        }

    } else {

        //
        // error finding the group (with the filter defined)
        //

        ScepLogOutput3(3,retErr, SCEDLL_CANNOT_FIND, Filter);
    }

    //
    // free Filter
    //

    if ( Message )
        ldap_msgfree(Message);

    LocalFree(Filter);

    //
    // return the error
    //

    if ( ERROR_SUCCESS == retSave ) {
        retSave = retErr;
    }

    return(retSave);
}


DWORD
ScepDsGetDsNameList(
    IN PSCE_NAME_LIST pNameList,
    OUT PSCE_NAME_LIST *pRealNames
    )
/*
Description:

    Translate account names in the list to FQDN format (CN=<account>,DC=<domain>,...).
    The output list pRealNames can be filled up even if the function returns
    error, to handle valid accounts while there are invalid accounts defined in
    the list.

Arguments:

    pNameList - the link list for accounts in name format to convert

    pRealNames - the output link list for converted FQDN format accounts

Return:

    WIN32 error code.

    If ERROR_FILE_NOT_FOUND is returned, it means that some accounts in the
    input list cannot be cracked.

*/
{

    if ( pNameList == NULL ) {
        return(ERROR_SUCCESS);
    }

    if ( pRealNames == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // find the procedure address of DsCrackNames and DsFreeNameResult
    // ntdsapi.dll is dynamically loaded in ScepCrackOpen
    //

    PFNDSCRACKNAMES pfnDsCrackNames=NULL;
    PFNDSFREENAMERESULT pfnDsFreeNameResult=NULL;

    if ( hNtdsApi ) {

#if defined(UNICODE)
        pfnDsCrackNames = (PFNDSCRACKNAMES)GetProcAddress(hNtdsApi, "DsCrackNamesW");
        pfnDsFreeNameResult = (PFNDSFREENAMERESULT)GetProcAddress(hNtdsApi, "DsFreeNameResultW");
#else
        pfnDsCrackNames = (PFNDSCRACKNAMES)GetProcAddress(hNtdsApi, "DsCrackNamesA");
        pfnDsFreeNameResult = (PFNDSFREENAMERESULT)GetProcAddress(hNtdsApi, "DsFreeNameResultA");
#endif
    }

    //
    // the two entry points must exist before continue
    //

    if ( pfnDsCrackNames == NULL || pfnDsFreeNameResult == NULL ) {
        return(ERROR_PROC_NOT_FOUND);
    }

    DWORD retErr=ERROR_SUCCESS;
    DWORD retSave=ERROR_SUCCESS;
    PWSTR pTemp;
    DS_NAME_RESULT *pDsResult=NULL;

    //
    // loop through each name in the list to crack
    //

    for ( PSCE_NAME_LIST pName = pNameList; pName != NULL; pName = pName->Next ) {

        //
        // Crack the name from NT4 account name to FQDN. Note, hDS is bound to
        // the GC in order to crack foreign domain accounts
        //

        retErr = (*pfnDsCrackNames) (
                        hDS,                // in
                        DS_NAME_FLAG_TRUST_REFERRAL,  // in
                        DS_NT4_ACCOUNT_NAME,// in
                        DS_FQDN_1779_NAME,  // in
                        1,                  // in
                        &(pName->Name),     // in
                        &pDsResult);        // out

        if(retErr == ERROR_SUCCESS && pDsResult &&
            pDsResult->cItems > 0 && pDsResult->rItems ) {

            if ( pDsResult->rItems[0].pName ) {

                //
                // find the member
                // Save the real group name for add/remove members later.
                //

                ScepLogOutput3(3,0, SCEDLL_PROCESS, pDsResult->rItems[0].pName);

                retErr = ScepAddToNameList(pRealNames, pDsResult->rItems[0].pName, 0);

            } else {

                //
                // this name cannot be cracked.
                //

                retErr = pDsResult->rItems[0].status;
                ScepLogOutput3(1,retErr, SCEDLL_CANNOT_FIND_INDS, pName->Name);

            }

        } else {

            //
            // no match is found
            //

            retErr = ERROR_FILE_NOT_FOUND;
            ScepLogOutput3(1,retErr, SCEDLL_CANNOT_FIND_INDS, pName->Name);

        }

        if ( pDsResult ) {
            (*pfnDsFreeNameResult) (pDsResult);
            pDsResult = NULL;
        }

        //
        // remember the error to return
        //

        if ( ERROR_SUCCESS != retErr )
            retSave = retErr;

    }

    return(retSave);
}


DWORD
ScepDsCompareNames(
    IN PWSTR *Values,
    IN OUT PSCE_NAME_LIST *pAddList,
    OUT PSCE_NAME_LIST *pDeleteList OPTIONAL
    )
/*
Description:


Arguments:

    Values

    pAddList

    pDeleteList

Return Value:

    WIN32 error
*/
{
    if ( Values == NULL || pAddList == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // count how many existing members (memberof)
    //

    ULONG ValCount = ldap_count_values(Values);

    DWORD rc=NO_ERROR;
    PSCE_NAME_LIST pTemp;

    //
    // loop through each existing value to compare with the ones defined
    // for configuration to determine which one should be added and which
    // one should be removed from the membership
    //

    for(ULONG index = 0; index < ValCount; index++) {

        if ( Values[index] == NULL ) {
            continue;
        }

        pTemp = *pAddList;
        PSCE_NAME_LIST pParent = NULL, pTemp2;
        BOOL bFound=FALSE;

        while (pTemp != NULL ) {

            if ( _wcsicmp(Values[index], pTemp->Name) == 0 ) {

                //
                // find this member in both place, no need to add or remove
                // from the membership so take this one out of the list
                //

                if ( pParent == NULL ) {
                    *pAddList = pTemp->Next;
                } else
                    pParent->Next = pTemp->Next;

                pTemp2 = pTemp;
                pTemp = pTemp->Next;

                pTemp2->Next = NULL;
                ScepFreeNameList(pTemp2);

                bFound=TRUE;

                break;

            } else {

                //
                // move to the next one
                //

                pParent = pTemp;
                pTemp = pTemp->Next;
            }
        }

        if ( !bFound && pDeleteList != NULL ) {

            //
            // did not find in the real name list, should be deleted
            // if the remove buffer is passed in
            //

            rc = ScepAddToNameList(pDeleteList, Values[index], 0);

            if ( rc != ERROR_SUCCESS ) {
                ScepLogOutput3(1,rc, SCEDLL_SCP_ERROR_ADD, Values[index]);
            }
        }

        if ( rc != NO_ERROR ) {

            //
            // pDeleteList will be freed outside
            //

            break;
        }
    }

    return(rc);

}


DWORD
ScepDsChangeMembers(
    IN ULONG Flag,
    IN PWSTR RealGroupName,
    IN PSCE_NAME_LIST pAddList OPTIONAL,
    IN PSCE_NAME_LIST pDeleteList OPTIONAL
    )
{

    if ( RealGroupName == NULL  ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( pAddList == NULL && pDeleteList == NULL ) {

        //
        // nothing to do
        //

        return(ERROR_SUCCESS);
    }

    PLDAP    pSrhLDAP = NULL;

    SCESTATUS rc = ScepLdapOpen(&pSrhLDAP);

    if ( rc != SCESTATUS_SUCCESS ) {
        return(ScepSceStatusToDosError(rc));
    }

    PLDAPMod  rgMods[2];
    LDAPMod   Mod;
    DWORD     retErr=NO_ERROR;
    DWORD     retSave=NO_ERROR;
    PWSTR     rgpszVals[2];

    PSCE_NAME_LIST pName;

    rgMods[0] = &Mod;
    rgMods[1] = NULL;

    rgpszVals[1] = NULL;

    //
    // need to do one at a time because individual members/memberof may fail
    //

    Mod.mod_op      = LDAP_MOD_ADD;
    Mod.mod_values  = rgpszVals;

    if ( Flag == SCEGRP_MEMBERS )
        Mod.mod_type    = L"member";
    else
        Mod.mod_type    = L"memberOf";

    for ( pName=pAddList; pName != NULL; pName = pName->Next ) {

        ScepLogOutput3(2,0, SCEDLL_SCP_ADD, pName->Name);
        rgpszVals[0]  = pName->Name;

        //
        // Now, we'll do the write for members...
        //
        retErr = ldap_modify_s(pSrhLDAP,
                               RealGroupName,
                               rgMods
                               );
        retErr = LdapMapErrorToWin32(retErr);

        //
        // if the same member already exist, do not consider it as an error
        //

        if ( retErr == ERROR_ALREADY_EXISTS )
            retErr = ERROR_SUCCESS;

        if ( retErr != ERROR_SUCCESS ) {

            ScepLogOutput3(1,retErr, SCEDLL_SCP_ERROR_ADDTO, RealGroupName);
            retSave = retErr;
        }
    }

    if ( Flag == SCEGRP_MEMBERS && pDeleteList ) {

        //
        // remove existing members. Note, memberof won't be removed
        //

        if ( NO_ERROR == retSave ) {

            //
            // only remove existing members if all members are added successfully
            //

            Mod.mod_op      = LDAP_MOD_DELETE;
            Mod.mod_type    = L"member";
            Mod.mod_values  = rgpszVals;

            for ( pName=pDeleteList; pName != NULL; pName = pName->Next ) {

                ScepLogOutput3(2,0, SCEDLL_SCP_REMOVE, pName->Name);

                rgpszVals[0]  = pName->Name;

                //
                // Now, we'll do the write for members...
                //
                retErr = ldap_modify_s(pSrhLDAP,
                                       RealGroupName,
                                       rgMods
                                       );
                retErr = LdapMapErrorToWin32(retErr);

                //
                // if the member doesn't exist in the group, ignore
                //

                if ( retErr == ERROR_FILE_NOT_FOUND ) {
                    retErr = ERROR_SUCCESS;
                }

                if ( retErr != ERROR_SUCCESS) {

                    ScepLogOutput3(1,retErr, SCEDLL_SCP_ERROR_REMOVE, RealGroupName);
                    retSave = retErr;
                }
            }

        } else {

            //
            // something is wrong when adding new members
            // so existing members won't be removed
            //

            ScepLogOutput3(1,retSave, SCEDLL_SCP_ERROR_NOREMOVE);
        }
    }

    if ( pSrhLDAP ) {
        ScepLdapClose(&pSrhLDAP);
        pSrhLDAP = NULL;
    }

    return(retSave);
}
#endif

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// Functions to analyze group membership in DS
//
//
//
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SCESTATUS
ScepAnalyzeDsGroups(
    IN PSCE_GROUP_MEMBERSHIP pGroupMembership
    )
/* ++

Routine Description:

   Analyze the ds group membership. The main difference of ds groups
   from NT4 groups is that now group can be a member of another group.
   Members in the group are configured exactly as the pMembers list in
   the restricted group. The group is only validated (added) as a member
   of the MemberOf group list. Other existing members in those groups
   won't be removed.

   The restricted groups are specified in the SCP profile by group name.
   It could be a global group, or a alias (no difference in NT5 DS),
   but must be defined in the local domain.

Arguments:

    pGroupMembership - The restricted group list with members/memberof info to configure

Return value:

   SCESTATUS error codes

++ */
{

#if _WIN32_WINNT<0x0500

    return(SCESTATUS_SUCCESS);
#else

    if ( pGroupMembership == NULL ) {

        ScepPostProgress(TICKS_GROUPS,
                         AREA_GROUP_MEMBERSHIP,
                         NULL);

        return(SCESTATUS_SUCCESS);
    }

    SCESTATUS           rc;
    DWORD               nGroupCount=0;
    PSCE_GROUP_MEMBERSHIP pGroup=pGroupMembership;
    PWSTR               KeyName=NULL;
    DWORD GroupLen;

    //
    // open local policy
    //
    LSA_HANDLE PolicyHandle=NULL;

    rc = RtlNtStatusToDosError(
             ScepOpenLsaPolicy(
                   POLICY_LOOKUP_NAMES,
                   &PolicyHandle,
                   TRUE
                   ));
    if (ERROR_SUCCESS != rc ) {
        ScepLogOutput3(1, rc, SCEDLL_LSA_POLICY);
        return(ScepDosErrorToSceStatus(rc));
    }

    //
    // open the Ldap server, should open two ldap server, one for the local domain only
    // the other is for the global search (for members, membership)
    //
    rc = ScepLdapOpen(&pGrpLDAP);

    if ( rc == SCESTATUS_SUCCESS ) {
        ScepCrackOpen(&hDS);
    }

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // get the root of the domain
        //
        PSCE_OBJECT_LIST pRoots=NULL;

        rc = ScepEnumerateDsObjectRoots(
                    pGrpLDAP,
                    &pRoots
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            //
            // configure each group
            //
            DWORD               Win32rc;
            DWORD               rc32=NO_ERROR;   // saved status
            BOOL                bAdminFound=FALSE;

            //
            // get the local administratos group name
            //

            for ( pGroup=pGroupMembership; pGroup != NULL; pGroup=pGroup->Next ) {

                if ( KeyName ) {
                    LocalFree(KeyName);
                    KeyName = NULL;
                }

                LPTSTR pTemp = wcschr(pGroup->GroupName, L'\\');
                if ( pTemp ) {

                    //
                    // there is a domain name, check it with computer name
                    //
                    UNICODE_STRING uName;

                    uName.Buffer = pGroup->GroupName;
                    uName.Length = ((USHORT)(pTemp-pGroup->GroupName))*sizeof(TCHAR);

                    if ( !ScepIsDomainLocal(&uName) ) {
                        ScepLogOutput3(1, 0, SCEDLL_NO_MAPPINGS, pGroup->GroupName);
                        rc = SCESTATUS_INVALID_DATA;

                        ScepRaiseErrorString(
                                    NULL,
                                    KeyName ? KeyName : pGroup->GroupName,
                                    szMembers
                                    );
                        pGroup->Status |= SCE_GROUP_STATUS_DONE_IN_DS;

                        continue;
                    }

                    ScepConvertNameToSidString(
                            PolicyHandle,
                            pGroup->GroupName,
                            FALSE,
                            &KeyName,
                            &GroupLen
                            );
                    pTemp++;

                } else {
                    pTemp = pGroup->GroupName;
                    GroupLen = wcslen(pTemp);
                }

                //
                // find the group (validate) in this domain
                //
                Win32rc = ScepDsAnalyzeGroupMembers(
                                         PolicyHandle,
                                         pRoots,
                                         pTemp, // pGroup->GroupName,
                                         KeyName ? KeyName : pGroup->GroupName,
                                         GroupLen,
                                         &(pGroup->Status),
                                         pGroup->pMembers,
                                         pGroup->pMemberOf,
                                         &nGroupCount
                                         );

                if ( (Win32rc != ERROR_SUCCESS) &&
                     (pGroup->Status & SCE_GROUP_STATUS_DONE_IN_DS) ) {

                    ScepLogOutput3(1, Win32rc, SCEDLL_SAP_ERROR_ANALYZE, pGroup->GroupName);

                    rc32 = Win32rc;

                    if ( Win32rc == ERROR_FILE_NOT_FOUND ||
                         Win32rc == ERROR_SHARING_VIOLATION ||
                         Win32rc == ERROR_ACCESS_DENIED ) {

                        ScepRaiseErrorString(
                                    NULL,
                                    KeyName ? KeyName : pGroup->GroupName,
                                    szMembers
                                    );

                        Win32rc = ERROR_SUCCESS;
                    } else
                        break;
                }

            }

            if ( rc32 != NO_ERROR ) {
                rc = ScepDosErrorToSceStatus(rc32);
            }
            //
            // free pRoots
            //
            ScepFreeObjectList(pRoots);

        }

    }

    if ( KeyName ) {
        LocalFree(KeyName);
    }

    if ( pGrpLDAP ) {
        ScepLdapClose(&pGrpLDAP);
        pGrpLDAP = NULL;
    }

    ScepCrackClose(&hDS);
    hDS = NULL;

/*
    // this will be handled in the analysis into SAM
    //
    // raise groups that are errored
    //
    for ( PSCE_GROUP_MEMBERSHIP pTmpGrp=pGroup;
          pTmpGrp != NULL; pTmpGrp = pTmpGrp->Next ) {

        if ( pTmpGrp->GroupName == NULL )
            continue;

        if ( wcschr(pGroup->GroupName, L'\\') ) {

            ScepConvertNameToSidString(
                    PolicyHandle,
                    pGroup->GroupName,
                    FALSE,
                    &KeyName,
                    &GroupLen
                    );
        }

        ScepRaiseErrorString(
                 NULL,
                 KeyName ? KeyName : pTmpGrp->GroupName,
                 szMembers
                 );
        if ( KeyName ) {
            LocalFree(KeyName);
            KeyName = NULL;
        }
    }

    if ( rc != SCESTATUS_SERVICE_NOT_SUPPORT &&
         nGroupCount < TICKS_GROUPS ) {

        ScepPostProgress(TICKS_GROUPS-nGroupCount,
                     AREA_GROUP_MEMBERSHIP,
                     NULL);
    }
*/
    if ( PolicyHandle ) {
        LsaClose(PolicyHandle);
    }

    return(rc);
#endif

}


#if _WIN32_WINNT>=0x0500

DWORD
ScepDsAnalyzeGroupMembers(
    IN LSA_HANDLE LsaPolicy,
    IN PSCE_OBJECT_LIST pRoots,
    IN PWSTR GroupName,
    IN PWSTR KeyName,
    IN DWORD KeyLen,
    IN OUT DWORD *pStatus,
    IN PSCE_NAME_LIST pMembers,
    IN PSCE_NAME_LIST pMemberOf,
    IN DWORD *nGroupCount
    )
{
    if ( GroupName == NULL ) {
        return(ERROR_SUCCESS);
    }

    if ( pRoots == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    DWORD retErr=ERROR_SUCCESS;
    //
    // search for the name, if find it, get members and memberof
    //
    LDAPMessage *Message = NULL;
    PWSTR    Attribs[4];

    Attribs[0] = L"distinguishedName";
    Attribs[1] = L"member";
    Attribs[2] = L"memberOf";
    Attribs[3] = NULL;

    WCHAR tmpBuf[128];

//    wcscpy(tmpBuf, L"( &(|(objectClass=localGroup)(objectClass=group))(cn=");
//    wcscpy(tmpBuf, L"( &(|(objectClass=localGroup)(objectClass=group))(samAccountName=");
    wcscpy(tmpBuf, L"( &(&(|");
    swprintf(tmpBuf+wcslen(L"( &(&(|"), L"(groupType=%d)(groupType=%d))(objectClass=group))(samAccountName=\0",
             GROUP_TYPE_ACCOUNT_GROUP | GROUP_TYPE_SECURITY_ENABLED, GROUP_TYPE_UNIVERSAL_GROUP | GROUP_TYPE_SECURITY_ENABLED);

    PWSTR Filter;
    DWORD Len=wcslen(GroupName);

    Filter = (PWSTR)LocalAlloc(LMEM_ZEROINIT, (wcslen(tmpBuf)+Len+4)*sizeof(WCHAR));

    if ( Filter == NULL ) {
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);
    }

    swprintf(Filter, L"%s%s) )", tmpBuf, GroupName);

    pGrpLDAP->ld_options = 0; // no chased referrel

    retErr = ldap_search_s(
              pGrpLDAP,
              pRoots->Name,
              LDAP_SCOPE_SUBTREE,
              Filter,
              Attribs,
              0,
              &Message);

    retErr = LdapMapErrorToWin32(retErr);

    if(retErr == ERROR_SUCCESS) {
        //
        // find the group
        //
        LDAPMessage *Entry = NULL;
        //
        // should only have one entry, unless there are duplicate groups
        // within the domain, in which case, we only care the first entry anyway
        //
        //
        // get the first one.
        //
        Entry = ldap_first_entry(pGrpLDAP, Message);

        if(Entry != NULL) {

            PWSTR  *Values;

            Values = ldap_get_values(pGrpLDAP, Entry, Attribs[0]);

            if(Values != NULL) {

                ScepLogOutput3(1,0, SCEDLL_SAP_ANALYZE, GroupName);

                if ( *nGroupCount < TICKS_GROUPS ) {
                    ScepPostProgress(1,
                                     AREA_GROUP_MEMBERSHIP,
                                     GroupName);
                    *nGroupCount++;
                }

                ScepLogOutput2(3,0, L"\t\t%s", Values[0]);
                ldap_value_free(Values);

                PSCE_NAME_LIST pRealNames=NULL;
                PSCE_NAME_LIST pCurrentList=NULL;
                BOOL bDifferent;
                DWORD retErr2, rc;

                //
                // translate each name in the pMembers list to real ds names (search)
                //
                retErr = ScepDsGetDsNameList(pMembers, &pRealNames);

                if ( ERROR_SUCCESS == retErr ||
                     ERROR_FILE_NOT_FOUND == retErr ) {

                    //
                    // analyze members
                    //
                    Values = ldap_get_values(pGrpLDAP, Entry, Attribs[1]);

                    rc = ScepDsMembersDifferent(SCEGRP_MEMBERS,
                                                Values,
                                                &pRealNames,
                                                &pCurrentList,
                                                &bDifferent);

                    if ( Values != NULL )
                        ldap_value_free(Values);

                    //
                    // if there are some names unresolvable, this should be
                    // treated as mismatch
                    //
                    if ( ERROR_FILE_NOT_FOUND == retErr )
                        bDifferent = TRUE;

                    retErr = rc;

                    if ( ( ERROR_SUCCESS == retErr ) &&
                         ( bDifferent ||
                           (*pStatus & SCE_GROUP_STATUS_NC_MEMBERS) ) ) {
                        //
                        // save to the database
                        //

                        retErr = ScepDsConvertDsNameList(pCurrentList);

                        if ( retErr == NO_ERROR ) {
                            retErr = ScepSaveMemberMembershipList(
                                                LsaPolicy,
                                                szMembers,
                                                KeyName,
                                                KeyLen,
                                                pCurrentList,
                                                (*pStatus & SCE_GROUP_STATUS_NC_MEMBERS) ? 2: 1);
                        }

                        if ( retErr != ERROR_SUCCESS ) {
                            ScepLogOutput3(1,retErr, SCEDLL_SAP_ERROR_SAVE, GroupName);
                        }
                    }

                    ScepFreeNameList(pCurrentList);
                    pCurrentList = NULL;

                    ScepFreeNameList(pRealNames);
                    pRealNames = NULL;
                }

                retErr2 = ScepDsGetDsNameList(pMemberOf, &pRealNames);

                if ( ( ERROR_SUCCESS == retErr2 ||
                       ERROR_FILE_NOT_FOUND == retErr2 ) && pRealNames ) {
                    //
                    // analyze membership
                    //
                    Values = ldap_get_values(pGrpLDAP, Entry, Attribs[2]);

                    rc = ScepDsMembersDifferent(SCEGRP_MEMBERSHIP,
                                                Values,
                                                &pRealNames,
                                                &pCurrentList,
                                                &bDifferent);

                    if ( Values != NULL )
                        ldap_value_free(Values);

                    //
                    // if there are some names unresolvable, this should be
                    // treated as mismatch
                    //
                    if ( ERROR_FILE_NOT_FOUND == retErr )
                        bDifferent = TRUE;

                    retErr2 = rc;

                    if ( (retErr2 == NO_ERROR) &&
                         ( bDifferent ||
                           (*pStatus & SCE_GROUP_STATUS_NC_MEMBEROF) ) ) {
                        //
                        // save to the database
                        //
                        retErr2 = ScepDsConvertDsNameList(pCurrentList);

                        if ( retErr2 == NO_ERROR ) {
                            retErr2 = ScepSaveMemberMembershipList(
                                            LsaPolicy,
                                            szMemberof,
                                            KeyName,
                                            KeyLen,
                                            pCurrentList,
                                            (*pStatus & SCE_GROUP_STATUS_NC_MEMBEROF) ? 2 : 1);
                        }

                        if ( retErr2 != ERROR_SUCCESS ) {
                            ScepLogOutput3(1,retErr2, SCEDLL_SAP_ERROR_SAVE, GroupName);
                        }
                    }
                    ScepFreeNameList(pCurrentList);
                    pCurrentList = NULL;

                    ScepFreeNameList(pRealNames);
                    pRealNames = NULL;
                }

                *pStatus |= SCE_GROUP_STATUS_DONE_IN_DS;

                //
                // remember the error
                //
                if ( retErr == NO_ERROR ) {
                    retErr = retErr2;
                }

            } else {
                //
                // Value[0] (group name) may not be empty
                //
                retErr = LdapMapErrorToWin32(pGrpLDAP->ld_errno);
                ScepLogOutput3(3,retErr, SCEDLL_CANNOT_FIND, GroupName);
            }

        } else {

            retErr = ERROR_FILE_NOT_FOUND;  // the group is not found
            ScepLogOutput3(3,retErr, SCEDLL_CANNOT_FIND, GroupName);
        }
    } else {

        ScepLogOutput3(3,retErr, SCEDLL_CANNOT_FIND, Filter);
    }

    if ( Message )
        ldap_msgfree(Message);

    //
    // free Filter
    //
    LocalFree(Filter);

    return(retErr);
}


DWORD
ScepDsMembersDifferent(
    IN ULONG Flag,
    IN PWSTR *Values,
    IN OUT PSCE_NAME_LIST *pNameList,
    OUT PSCE_NAME_LIST *pCurrentList,
    OUT PBOOL pbDifferent
    )
{
    if ( pCurrentList == NULL || pbDifferent == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( Values == NULL ) {

        if ( pNameList == NULL || *pNameList == NULL )
            *pbDifferent = FALSE;
        else
            *pbDifferent = TRUE;

        return(ERROR_SUCCESS);
    }

    ULONG ValCount = ldap_count_values(Values);

    DWORD rc=NO_ERROR;
    *pbDifferent = FALSE;

    for(ULONG index = 0; index < ValCount; index++) {

        if ( Values[index] == NULL ) {
            continue;
        }

        if ( !(*pbDifferent) ) {

            PSCE_NAME_LIST pTemp = *pNameList, pTemp2;
            PSCE_NAME_LIST pParent = NULL;
            INT i;

            while ( pTemp != NULL ) {

                if ( (i = _wcsicmp(Values[index], pTemp->Name)) == 0 ) {
                    //
                    // find this member
                    //
                    if ( pParent == NULL ) {
                        *pNameList = pTemp->Next;
                    } else
                        pParent->Next = pTemp->Next;

                    pTemp2 = pTemp;
                    pTemp = pTemp->Next;

                    pTemp2->Next = NULL;
                    ScepFreeNameList(pTemp2);
                    break;

                } else {
                    pParent = pTemp;
                    pTemp = pTemp->Next;
                }
            }

            if ( pTemp == NULL && i != 0 )
                *pbDifferent = TRUE;

        }
        //
        // build the current list
        //
        rc = ScepAddToNameList(pCurrentList, Values[index], 0);

        if ( rc != NO_ERROR ) {

            ScepLogOutput3(1,rc, SCEDLL_SCP_ERROR_ADD, Values[index]);
            break;
        }
    }

    if ( rc == NO_ERROR && Flag == SCEGRP_MEMBERS &&
         *pbDifferent == FALSE ) {
        //
        // still same so far, only continue to compare for members
        // because membership is not one to one configuring
        //
        if ( *pNameList != NULL )
            *pbDifferent = TRUE;

    } // pCurrentList will be freed outside

    return(rc);

}


PWSTR
ScepGetLocalAdminsName()
{

    NTSTATUS NtStatus;
    SAM_HANDLE          AccountDomain=NULL;
    SAM_HANDLE          AliasHandle=NULL;
    SAM_HANDLE          ServerHandle=NULL;
    PSID                DomainSid=NULL;

    SAM_HANDLE          theBuiltinHandle=NULL;
    PSID                theBuiltinSid=NULL;

    ALIAS_NAME_INFORMATION *BufName=NULL;
    PWSTR pAdminsName=NULL;

    //
    // open the sam account domain
    //

    NtStatus = ScepOpenSamDomain(
                    SAM_SERVER_ALL_ACCESS,
                    MAXIMUM_ALLOWED,
                    &ServerHandle,
                    &AccountDomain,
                    &DomainSid,
                    &theBuiltinHandle,
                    &theBuiltinSid
                    );

    if ( !NT_SUCCESS(NtStatus) ) {
        ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                       SCEDLL_ERROR_OPEN, L"SAM");
        return(NULL);
    }


    NtStatus = SamOpenAlias(
                  theBuiltinHandle,
                  MAXIMUM_ALLOWED,
                  DOMAIN_ALIAS_RID_ADMINS,
                  &AliasHandle
                  );

    if ( NT_SUCCESS( NtStatus ) ) {

        NtStatus = SamQueryInformationAlias(
                      AliasHandle,
                      AliasNameInformation,
                      (PVOID *)&BufName
                      );

        if ( NT_SUCCESS( NtStatus ) && BufName &&
             BufName->Name.Length > 0 && BufName->Name.Buffer ) {

            //
            // allocate buffer to return
            //
            pAdminsName = (PWSTR)ScepAlloc(0, BufName->Name.Length+2);

            if ( pAdminsName ) {

                wcsncpy(pAdminsName, BufName->Name.Buffer,
                        BufName->Name.Length/2);
                pAdminsName[BufName->Name.Length/2] = L'\0';

            } else {
                NtStatus = STATUS_NO_MEMORY;
            }

        }
        if ( BufName ) {

            SamFreeMemory(BufName);
            BufName = NULL;
        }

        //
        // close the user handle
        //
        SamCloseHandle(AliasHandle);

    }

    SamCloseHandle(AccountDomain);

    SamCloseHandle( ServerHandle );
    if ( DomainSid != NULL )
        SamFreeMemory(DomainSid);

    SamCloseHandle( theBuiltinHandle );
    if ( theBuiltinSid != NULL )
        SamFreeMemory(theBuiltinSid);

    return pAdminsName;
}

DWORD
ScepDsConvertDsNameList(
    IN OUT PSCE_NAME_LIST pDsNameList
    )
/*
Routine:

    The input list is in the LDAP format (CN=<>,...DC=<>, ...). When the routine
    returns, the list will be in NT4 account name format (domain\account)
*/
{
    if ( pDsNameList == NULL ) {
        return(ERROR_SUCCESS);
    }

    PFNDSCRACKNAMES pfnDsCrackNames=NULL;
    PFNDSFREENAMERESULT pfnDsFreeNameResult=NULL;

    if ( hNtdsApi ) {

#if defined(UNICODE)
        pfnDsCrackNames = (PFNDSCRACKNAMES)GetProcAddress(hNtdsApi, "DsCrackNamesW");
        pfnDsFreeNameResult = (PFNDSFREENAMERESULT)GetProcAddress(hNtdsApi, "DsFreeNameResultW");
#else
        pfnDsCrackNames = (PFNDSCRACKNAMES)GetProcAddress(hNtdsApi, "DsCrackNamesA");
        pfnDsFreeNameResult = (PFNDSFREENAMERESULT)GetProcAddress(hNtdsApi, "DsFreeNameResultA");
#endif
    }

    if ( pfnDsCrackNames == NULL || pfnDsFreeNameResult == NULL ) {
        return(ERROR_PROC_NOT_FOUND);
    }

    DWORD retErr=ERROR_SUCCESS;
    PWSTR pTemp;
    DS_NAME_RESULT *pDsResult=NULL;

    DWORD DomLen;
    DWORD SidLen;
    CHAR SidBuf[MAX_PATH];
    PWSTR RefDom[MAX_PATH];
    SID_NAME_USE SidUse;

    for ( PSCE_NAME_LIST pName = pDsNameList; pName != NULL; pName = pName->Next ) {

        if ( pName->Name == NULL ) {
            continue;
        }

        retErr = (*pfnDsCrackNames) (
                        hDS,                // in
                        DS_NAME_NO_FLAGS,   // in
                        DS_FQDN_1779_NAME,  // in
                        DS_NT4_ACCOUNT_NAME,// in
                        1,                  // in
                        &(pName->Name),     // in
                        &pDsResult);        // out


        if(retErr == ERROR_SUCCESS && pDsResult && pDsResult->rItems &&
            pDsResult->rItems[0].pName ) {

            //
            // NT4 account name format is returned, should check if the
            // domain is not a acccount domain
            //
            pTemp = wcschr(pDsResult->rItems[0].pName, L'\\');

            if ( pTemp ) {

                DomLen=MAX_PATH;
                SidLen=MAX_PATH;

                if ( LookupAccountName(
                        NULL,
                        pDsResult->rItems[0].pName,
                        (PSID)SidBuf,
                        &SidLen,
                        (PWSTR)RefDom,
                        &DomLen,
                        &SidUse
                        ) ) {

                    if ( !ScepIsSidFromAccountDomain( (PSID)SidBuf) ) {
                        //
                        // add name only
                        //
                        pTemp++;
                    } else {
                        pTemp = pDsResult->rItems[0].pName;
                    }
                } else {
                    pTemp = pDsResult->rItems[0].pName;
                }

            } else {
                pTemp = pDsResult->rItems[0].pName;
            }

            PWSTR pNewName = (PWSTR)ScepAlloc(0, (wcslen(pTemp)+1)*sizeof(WCHAR));

            if ( pNewName ) {

                wcscpy(pNewName, pTemp);
                ScepFree(pName->Name);
                pName->Name = pNewName;

            } else {
                retErr = ERROR_NOT_ENOUGH_MEMORY;
            }

        } else {
            // no match is found
            retErr = ERROR_FILE_NOT_FOUND;
            ScepLogOutput3(1,retErr, SCEDLL_CANNOT_FIND, pName->Name);

        }

        if ( pDsResult ) {
            (*pfnDsFreeNameResult) (pDsResult);
            pDsResult = NULL;
        }

        if ( retErr != ERROR_SUCCESS ) {
            break;
        }
    }

    return(retErr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\config.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    config.c

Abstract:

    Routines to configure system to comply the security profile information

Author:

    Jin Huang (jinhuang) 7-Nov-1996

Revision History:

    jinhuang 27-Jan-1997 split for client-server

--*/

#include "headers.h"
#include "serverp.h"
#include "pfp.h"
#include "kerberos.h"
#include "regvalue.h"
#include "service.h"
#include <io.h>
#include <lmcons.h>
#include <secobj.h>
#include <netlib.h>
#include "infp.h"
#include "sddl.h"
#include "queue.h"
#include "splay.h"
#include "authz.h"
#include "seopaque.h"

#pragma hdrstop

//
// properties of SCP engine (thread safe variables)
//

BYTE              Thread scpBuffer[sizeof(SCE_PROFILE_INFO)];
PSCE_PROFILE_INFO Thread pScpInfo=NULL;
PSCECONTEXT       Thread hProfile=NULL;
LSA_HANDLE        Thread LsaPrivatePolicy=NULL;


extern HINSTANCE MyModuleHandle;
extern AUTHZ_RESOURCE_MANAGER_HANDLE ghAuthzResourceManager;


#define SCE_PRIV_ADD                TEXT("Add:")
#define SCE_PRIV_REMOVE             TEXT("Remove:")
#define SCEP_NUM_LSA_QUERY_SIDS     2000
#define MAXDWORD    0xffffffff

#define SCEDCPOL_MIN_PASS_AGE           0
#define SCEDCPOL_MAX_PASS_AGE           42
#define SCEDCPOL_MIN_PASS_LEN           0
#define SCEDCPOL_PASS_SIZE              1
#define SCEDCPOL_PASS_COMP              0
#define SCEDCPOL_CLEAR_PASS             0
#define SCEDCPOL_REQUIRE_LOGON          0
#define SCEDCPOL_FORCE_LOGOFF           0
#define SCEDCPOL_ENABLE_ADMIN           1
#define SCEDCPOL_ENABLE_GUEST           0
#define SCEDCPOL_LOCK_COUNT             0
#define SCEDCPOL_LOCK_RESET             30
#define SCEDCPOL_LOCK_DURATION          30
#define SCEDCPOL_LSA_ANON_LOOKUP        1

DWORD
ScepConfigureLSAPolicyObject(
    IN  DWORD   dwLSAAnonymousNameLookup,
    IN  DWORD   ConfigOptions,
    IN PSCE_ERROR_LOG_INFO *pErrLog OPTIONAL,
    OUT BOOL    *pbOldLSAPolicyDifferent
    );

DWORD
ScepAddAceToSecurityDescriptor(
    IN  DWORD    AceType,
    IN  ACCESS_MASK AccessMask,
    IN  PSID  pSid,
    IN OUT  PSECURITY_DESCRIPTOR    pSDAbsolute,
    IN  PSECURITY_DESCRIPTOR    pSDSelfRelative,
    OUT PACL    *ppNewAcl
    );

//
// this function is defined in inftojet.cpp
//
SCESTATUS
ScepBuildNewPrivilegeList(
    IN LSA_HANDLE *pPolicyHandle,
    IN PWSTR PrivName,
    IN PWSTR mszUsers,
    IN ULONG dwBuildOption,
    OUT PWSTR *pmszNewUsers,
    OUT DWORD *pNewLen
    );

//
// forward references
//

SCESTATUS
ScepConfigureInitialize(
    IN PCWSTR InfFileName OPTIONAL,
    IN PWSTR DatabaseName,
    IN BOOL bAdminLogon,
    IN DWORD ConfigOptions,
    IN AREA_INFORMATION Area
    );

SCESTATUS
ScepConfigureSystemAccess(
    IN PSCE_PROFILE_INFO pScpInfo,
    IN DWORD ConfigOptions,
    IN PSCE_ERROR_LOG_INFO *pErrLog,
    IN DWORD QueueFlag
    );

NTSTATUS
ScepManageAdminGuestAccounts(
    IN SAM_HANDLE DomainHandle,
    IN PWSTR NewName,
    IN DWORD ControlFlag,
    IN DWORD AccountType,
    IN DWORD ConfigOptions,
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo
    );

SCESTATUS
ScepConfigurePrivileges(
    IN OUT PSCE_PRIVILEGE_VALUE_LIST *ppPrivilegeAssigned,
    IN BOOL bCreateBuiltinAccount,
    IN DWORD Options,
    IN OUT PSCEP_SPLAY_TREE pIgnoreAccounts OPTIONAL
    );

SCESTATUS
ScepGetPrivilegeMask(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    OUT PDWORD pdLowMask,
    OUT PDWORD pdHighMask
    );

DWORD
ScepCreateBuiltinAccountInLsa(
    IN LSA_HANDLE PolicyHandle,
    IN LPTSTR AccountName,
    OUT PSID AccountSid
    );

NTSTATUS
ScepAdjustAccountPrivilegesRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID       AccountSid,
    IN DWORD      PrivilegeLowRights,
    IN DWORD      PrivilegeLowMask,
    IN DWORD      PrivilegeHighRights,
    IN DWORD      PrivilegeHighMask,
    IN DWORD      Options
    );

NTSTATUS
ScepAddOrRemoveAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID       AccountSid,
    IN BOOL       AddOrRemove,
    IN DWORD      PrivLowAdjust,
    IN DWORD      PrivHighAdjust
    );

NTSTATUS
ScepValidateUserInGroups(
    IN SAM_HANDLE       DomainHandle,
    IN SAM_HANDLE       BuiltinDomainHandle,
    IN PSID             DomainSid,
    IN UNICODE_STRING   UserName,
    IN ULONG            UserId,
    IN PSCE_NAME_LIST    pGroupsToCheck
    );

NTSTATUS
ScepAddUserToGroup(
    IN SAM_HANDLE   DomainHandle,
    IN SAM_HANDLE   BuiltinDomainHandle,
    IN ULONG        UserId,
    IN PSID         AccountSid,
    IN PWSTR        GroupName
    );

SCESTATUS
ScepConfigureGroupMembership(
    IN PSCE_GROUP_MEMBERSHIP pGroupMembership,
    IN DWORD ConfigOptions
    );

NTSTATUS
ScepConfigureMembersOfGroup(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN SAM_HANDLE  DomainHandle,
    IN PSID ThisDomainSid,
    IN ULONG GrpId,
    IN PSID GrpSid,
    IN PWSTR GrpName,
    IN PWSTR GroupSidString,
    IN PSCE_NAME_LIST pMembers,
    IN DWORD ConfigOptions
    );

NTSTATUS
ScepConfigureMembersOfAlias(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN SAM_HANDLE   DomainHandle,
    IN PSID         DomainSid,
    IN LSA_HANDLE   PolicyHandle,
    IN ULONG GrpId,
    IN PSID GrpSid,
    IN PWSTR GrpName,
    IN PWSTR GroupSidString,
    IN PSCE_NAME_LIST pMembers,
    IN DWORD ConfigOptions
    );

SCESTATUS
ScepValidateGroupInAliases(
    IN SAM_HANDLE DomainHandle,
    IN SAM_HANDLE BuiltinDomainHandle,
    IN PSID GrpSid,
    IN PSCE_NAME_LIST pAliasList
    );

SCESTATUS
ScepConfigureObjectSecurity(
   IN PSCE_OBJECT_LIST pSecurityObject,
   IN AREA_INFORMATION Area,
   IN BOOL bPolicyProp,
   IN DWORD ConfigOptions
   );

SCESTATUS
ScepConfigureSystemAuditing(
    IN PSCE_PROFILE_INFO pScpInfo,
    IN DWORD ConfigOptions
    );

SCESTATUS
ScepConfigureAuditEvent(
    IN PSCE_PROFILE_INFO pScpInfo,
    IN PPOLICY_AUDIT_EVENTS_INFO auditEvent,
    IN DWORD Options,
    IN LSA_HANDLE PolicyHandle
    );

SCESTATUS
ScepConfigureDeInitialize(
    IN SCESTATUS  rc,
    IN AREA_INFORMATION Area
    );

SCESTATUS
ScepMakePolicyIntoFile(
    IN DWORD Options,
    IN AREA_INFORMATION Area
    );

DWORD
ScepWriteOneAttributeToFile(
    IN LPCTSTR SectionName,
    IN LPCTSTR FileName,
    IN LPCTSTR KeyName,
    IN DWORD dwValue
    );

SCESTATUS
ScepCopyPrivilegesIntoFile(
    IN LPTSTR FileName,
    IN BOOL bInUpgrade
    );

SCESTATUS
ScepCopyPrivilegesFromDatabase(
    IN PSCESECTION hSection,
    IN PWSTR Keyname,
    IN DWORD StrLength,
    IN PWSTR StrValue OPTIONAL,
    OUT PWSTR *pOldValue,
    OUT DWORD *pOldLen
    );

SCESTATUS
ScepDeleteDomainPolicies();

SCESTATUS
ScepConfigurePrivilegesWithMask(
    IN OUT PSCE_PRIVILEGE_VALUE_LIST *ppPrivilegeAssigned,
    IN BOOL bCreateBuiltinAccount,
    IN DWORD Options,
    IN DWORD LowMask,
    IN DWORD HighMask,
    IN OUT PSCE_ERROR_LOG_INFO *pErrLog OPTIONAL,
    IN OUT PSCEP_SPLAY_TREE pIgnoreAccounts OPTIONAL
    );

SCESTATUS
ScepConfigurePrivilegesByRight(
    IN PSCE_PRIVILEGE_ASSIGNMENT pPrivAssign,
    IN DWORD Options,
    IN OUT PSCE_ERROR_LOG_INFO *pErrLog
    );

SCESTATUS
ScepTattooUpdatePrivilegeArrayStatus(
    IN DWORD *pStatusArray,
    IN DWORD rc,
    IN DWORD PrivLowMask,
    IN DWORD PrivHighMask
    );

SCESTATUS
ScepTattooRemovePrivilegeValues(
    IN PSCECONTEXT hProfile,
    IN DWORD *pStatusArray
    );

SCESTATUS
ScepTattooSavePrivilegeValues(
    IN PSCECONTEXT hProfile,
    IN LSA_HANDLE PolicyHandle,
    IN DWORD PrivLowMask,
    IN DWORD PrivHighMask,
    IN DWORD ConfigOptions
    );

DWORD
ScepTattooCurrentGroupMembers(
    IN PSID             ThisDomainSid,
    IN SID_NAME_USE     GrpUse,
    IN PULONG           MemberRids OPTIONAL,
    IN PSID             *MemberAliasSids OPTIONAL,
    IN DWORD            MemberCount,
    OUT PSCE_NAME_LIST  *ppNameList
    );

VOID
ScepBuildDwMaskFromStrArray(
    IN  PUNICODE_STRING aUserRights,
    IN  ULONG   uCountOfRights,
    OUT DWORD *pdwPrivLowThisAccount,
    OUT DWORD *pdwPrivHighThisAccount
    );


#define SCEP_REMOVE_PRIV_BIT(b,pl,ph)                       \
                                    if ( b < 32 ) {         \
                                        *pl &= ~(1 << b);   \
                                    } else if ( b >= 32 && b < 64 ) {   \
                                        *ph &= ~( 1 << (b-32));         \
                                    }

#define SCEP_ADD_PRIV_BIT(b,l,h)                       \
                                    if ( b < 32 ) {      \
                                        l |= (1 << b);  \
                                    } else if ( b >= 32 && b < 64 ) {   \
                                        h |= ( 1 << (b-32));           \
                                    }

#define SCEP_CHECK_PRIV_BIT(i,pl,ph)                       \
                                     ( (i < 32) && ( pl & (1 << i)) ) || \
                                     ( (i >= 32) && ( ph & ( 1 << (i-32)) ) )


SCESTATUS
ScepCheckNetworkLogonRights(
    IN LSA_HANDLE PolicyHandle,
    IN OUT DWORD *pLowMask,
    IN OUT DWORD *pHighMask,
    IN OUT PSCE_PRIVILEGE_VALUE_LIST *ppPrivilegeAssigned
    );

SCESTATUS
ScepAddAccountRightToList(
    IN OUT PSCE_PRIVILEGE_VALUE_LIST *ppPrivilegeAssigned,
    IN OUT PSCE_PRIVILEGE_VALUE_LIST *ppParent,
    IN INT idxRight,
    IN PSID AccountSid
    );


//
// function implementations
//
SCESTATUS
ScepConfigureSystem(
    IN PCWSTR InfFileName OPTIONAL,
    IN PWSTR DatabaseName,
    IN DWORD ConfigOptions,
    IN BOOL bAdminLogon,
    IN AREA_INFORMATION Area,
    OUT PDWORD pdWarning OPTIONAL
    )
/*++
Routine Description:

   This routine updates
   This routine is the exported API to configure a system by applying a SCP
   file (INF) to the system. I a INF template is provided, it is first parsed
   and saved in the SAD database. Then the system is configured using the info
   in the template.

   If any error occurs when loading SCP information, configuration will stop,
   and return the error code. If a error occurs when configure an area, it will
   stop configuring the whole area but continue to configure other left areas.
   All success and fail transactions will be logged to the logfile(or stdout).

   Log is already initialized before this call

Arguments:

    InfFileName -   The SCP file name

    DatabaseName -   The file name of the JET (for future analysis) profile

    ConfigOptions -   if the template provided is to update the system, or overwrite

    Area -          one or more areas to configure.
                  AREA_SECURITY_POLICY
                  AREA_USER_SETTINGS  // block out for beta1
                  AREA_GROUP_MEMBERSHIP
                  AREA_PRIVILEGES
                  AREA_REGISTRY_SECURITY
                  AREA_FILE_SECURITY
                  AREA_SYSTEM_SERVICE

    pdWarning  - the warning code

Return value:

    SCESTATUS_SUCCESS
    SCESTATUS_NOT_ENOUGH_RESOURCE
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS_ALREADY_RUNNING

    Status from ScepGetDatabaseInfo

-- */
{
    SCESTATUS            rc, Saverc;
    SCESTATUS            PendingRc=SCESTATUS_SUCCESS;
    PSCE_ERROR_LOG_INFO  pErrlog=NULL;
    PPOLICY_AUDIT_EVENTS_INFO     auditEvent=NULL;
    BOOL                 bAuditOff=FALSE;
    PBYTE                pFullAudit = NULL;
    PSCEP_SPLAY_TREE     pNotifyAccounts=NULL;
    DWORD QueueFlag=0;

    Saverc = ScepConfigureInitialize(
                      InfFileName,
                      DatabaseName,
                      bAdminLogon,
                      ConfigOptions,
                      Area );

    if ( Saverc != SCESTATUS_SUCCESS ) {

        ScepPostProgress(gTotalTicks, 0, NULL);

        ScepLogOutput3(0,0, SCEDLL_SCP_INIT_ERROR);

    } else if ( !(ConfigOptions & SCE_NO_CONFIG) ) {

        ScepLogOutput3(0,0, SCEDLL_SCP_INIT_SUCCESS);

        Area &= ~AREA_USER_SETTINGS;

        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
             (ConfigOptions & SCE_NO_CONFIG_FILEKEY) ) {
            //
            // if within policy propagation (at reboot) and
            // this is the foreground thread, do not configure
            // file and registry sections. They will be configured
            // in background thread separately.
            //
            Area &= ~(AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY);
        }

        //
        // get information from the notification queue so that
        // pending notifications are ignored
        //
        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
             ( (Area & AREA_PRIVILEGES) ||
               (Area & AREA_SECURITY_POLICY) ) ) {
            //
            // return error is ignored so policy prop will overwrite
            //

            __try {

                //
                // initialize the root TreeNode
                //
                if ( NULL == (pNotifyAccounts = ScepSplayInitialize(SplayNodeSidType)) ) {

                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    ScepLogOutput3(1, ERROR_NOT_ENOUGH_MEMORY, SCESRV_POLICY_ERROR_SPLAY_INITIALIZE);

                } else if ( ERROR_SUCCESS != (rc=ScepGetQueueInfo(&QueueFlag, pNotifyAccounts)) ) {
                    QueueFlag = 0;

                    ScepLogOutput3(1,rc, SCESRV_POLICY_PENDING_QUERY);
                }
            } __except (EXCEPTION_EXECUTE_HANDLER) {

                QueueFlag = 0;
                rc = ERROR_IO_PENDING;

                ScepLogOutput3(1,rc, SCESRV_POLICY_PENDING_QUERY);
            }

            if ( ERROR_SUCCESS != rc ) {

                PendingRc = ScepDosErrorToSceStatus(rc);

                ScepPostProgress(gTotalTicks, 0, NULL);

                goto Done;
            }
        }

        if ( ConfigOptions & SCE_POLICY_TEMPLATE ) {
            //
            // always resume the queue processing after queue info is queued
            //
            ScepNotificationQControl(0);
        }

        ScepLogOutput3(0,0, SCEDLL_SCP_READ_PROFILE);
        Saverc = ScepGetDatabaseInfo(
                            hProfile,
                            ( ConfigOptions & SCE_POLICY_TEMPLATE ) ?
                                 SCE_ENGINE_SCP_INTERNAL : SCE_ENGINE_SMP_INTERNAL,
                            Area,
                            SCE_ACCOUNT_SID,
                            &pScpInfo,
                            &pErrlog
                            );

        ScepLogWriteError( pErrlog, 1 );
        ScepFreeErrorLog( pErrlog );
        pErrlog = NULL;

        if ( Saverc != SCESTATUS_SUCCESS ) {

            ScepPostProgress(gTotalTicks, 0, NULL);

            goto Done;
        }

        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
             ScepIsSystemShutDown() ) {

            Saverc = SCESTATUS_SERVICE_NOT_SUPPORT;
            goto Done;
        }

        //
        // turn off object access auditing if file/key is to be configured
        // in system context.
        //
        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
             ( (Area & AREA_FILE_SECURITY) && pScpInfo->pFiles.pOneLevel ) ||
             ( (Area & AREA_REGISTRY_SECURITY) && pScpInfo->pRegistryKeys.pOneLevel ) )

            bAuditOff = TRUE;

        //
        // if set, this regkey will decide to audit all
        //
        ScepRegQueryBinaryValue(
             HKEY_LOCAL_MACHINE,
             L"System\\CurrentControlSet\\Control\\Lsa",
             L"fullprivilegeauditing",
             &pFullAudit
             );

        if (pFullAudit) {
            if (*pFullAudit & (BYTE)1)
                bAuditOff = FALSE;
            ScepFree(pFullAudit);
        }

        Saverc = ScepSaveAndOffAuditing(&auditEvent, bAuditOff, LsaPrivatePolicy);

//        if ( Saverc != SCESTATUS_SUCCESS )
//            goto Done;
// if auditing can't be turned on for some reason, e.g., access denied for
// normal user, just continue

        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
             ScepIsSystemShutDown() ) {

            Saverc = SCESTATUS_SERVICE_NOT_SUPPORT;
            goto Done;
        }

        //
        // User Settings area
        //
        Saverc = 0;
        if ( Area & AREA_PRIVILEGES ) {

            ScepPostProgress(0, AREA_PRIVILEGES, NULL);

            ScepLogOutput3(0,0, SCEDLL_SCP_BEGIN_PRIVILEGES);

            rc = ScepConfigurePrivileges( &(pScpInfo->OtherInfo.scp.u.pPrivilegeAssignedTo),
                                          (ConfigOptions & SCE_CREATE_BUILTIN_ACCOUNTS),
                                          (bAdminLogon ?
                                             ConfigOptions :
                                             (ConfigOptions & ~SCE_SYSTEM_DB)),
                                          (QueueFlag & SCE_QUEUE_INFO_RIGHTS) ? pNotifyAccounts : NULL
                                        );

            if( rc != SCESTATUS_SUCCESS ) {
                if ( rc != SCESTATUS_PENDING_IGNORE )
                    Saverc = rc;
                else
                    PendingRc = rc;

                ScepLogOutput3(0,0, SCEDLL_SCP_PRIVILEGES_ERROR);
            } else {
                ScepLogOutput3(0,0, SCEDLL_SCP_PRIVILEGES_SUCCESS);
            }
        }

        if ( pNotifyAccounts ) {
            ScepSplayFreeTree(&pNotifyAccounts, TRUE);
        }

        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
             ScepIsSystemShutDown() ) {

            Saverc = SCESTATUS_SERVICE_NOT_SUPPORT;
            goto Done;
        }

        //
        // Group Membership area
        //
        if ( Area & AREA_GROUP_MEMBERSHIP) {

            ScepPostProgress(0, AREA_GROUP_MEMBERSHIP, NULL);

            ScepLogOutput3(0,0, SCEDLL_SCP_BEGIN_GROUPMGMT);

#if _WIN32_WINNT>=0x0500
    // need to support nested groups

            if ( ProductType == NtProductLanManNt ) {

                rc = ScepConfigDsGroups( pScpInfo->pGroupMembership, ConfigOptions );

                //
                // some groups (such as local groups) may not be configured in DS
                // so try it in SAM
                //
                SCESTATUS rc2 = ScepConfigureGroupMembership(pScpInfo->pGroupMembership, ConfigOptions );
                if ( rc2 != SCESTATUS_SUCCESS )
                    rc = rc2;

            } else {
#endif

                rc = ScepConfigureGroupMembership( pScpInfo->pGroupMembership, ConfigOptions );

#if _WIN32_WINNT>=0x0500
            }
#endif

            if ( rc != SCESTATUS_SUCCESS) {
                Saverc = rc;
                ScepLogOutput3(0,0, SCEDLL_SCP_GROUPMGMT_ERROR);
            } else {
                ScepLogOutput3(0,0, SCEDLL_SCP_GROUPMGMT_SUCCESS);
            }

        }

        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
             ScepIsSystemShutDown() ) {

            Saverc = SCESTATUS_SERVICE_NOT_SUPPORT;
            goto Done;
        }

        //
        // Registry Security area
        //

        if ( Area & AREA_REGISTRY_SECURITY ) {

            ScepPostProgress(0,
                             AREA_REGISTRY_SECURITY,
                             NULL);

            rc = ScepConfigureObjectSecurity( pScpInfo->pRegistryKeys.pOneLevel,
                                             AREA_REGISTRY_SECURITY,
                                             (ConfigOptions & SCE_POLICY_TEMPLATE) ? TRUE : FALSE,
                                             ConfigOptions
                                            );

            if( rc != SCESTATUS_SUCCESS ) {
                Saverc = rc;
            }
        }

        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
             ScepIsSystemShutDown() ) {

            Saverc = SCESTATUS_SERVICE_NOT_SUPPORT;
            goto Done;
        }
        //
        // File Security area
        //

        if ( Area & AREA_FILE_SECURITY ) {

            ScepPostProgress(0,
                             AREA_FILE_SECURITY,
                             NULL);
            ScepLogOutput3(0,0, SCEDLL_SCP_BEGIN_FILE);

            rc = ScepConfigureObjectSecurity( pScpInfo->pFiles.pOneLevel,
                                             AREA_FILE_SECURITY,
                                             (ConfigOptions & SCE_POLICY_TEMPLATE) ? TRUE : FALSE,
                                            ConfigOptions
                                            );

            if( rc != SCESTATUS_SUCCESS ) {
                Saverc = rc;
                ScepLogOutput3(0,0, SCEDLL_SCP_FILE_ERROR);
            } else {
                ScepLogOutput3(0,0, SCEDLL_SCP_FILE_SUCCESS);
            }

        }

#if 0
#if _WIN32_WINNT>=0x0500
        if ( (ProductType == NtProductLanManNt) && (Area & AREA_DS_OBJECTS) ) {

            ScepPostProgress(0,
                             AREA_DS_OBJECTS,
                             NULL);

            ScepLogOutput3(0,0, SCEDLL_SCP_BEGIN_DS);

            rc = ScepConfigureObjectSecurity( pScpInfo->pDsObjects.pOneLevel,
                                            AREA_DS_OBJECTS,
                                            (ConfigOptions & SCE_POLICY_TEMPLATE) ? TRUE : FALSE,
                                            ConfigOptions
                                            );

            if( rc != SCESTATUS_SUCCESS ) {
                Saverc = rc;
                ScepLogOutput3(0,0, SCEDLL_SCP_DS_ERROR);
            } else {
                ScepLogOutput3(0,0, SCEDLL_SCP_DS_SUCCESS);
            }

        }
#endif
#endif

        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
             ScepIsSystemShutDown() ) {

            Saverc = SCESTATUS_SERVICE_NOT_SUPPORT;
            goto Done;
        }

        //
        // System Service area
        //

        if ( Area & AREA_SYSTEM_SERVICE ) {

            ScepPostProgress(0,
                             AREA_SYSTEM_SERVICE,
                             NULL);

            ScepLogOutput3(0,0, SCEDLL_SCP_BEGIN_GENERALSVC);

            rc = ScepConfigureGeneralServices( hProfile, pScpInfo->pServices, ConfigOptions );

            if( rc != SCESTATUS_SUCCESS ) {
                Saverc = rc;
                ScepLogOutput3(0,0, SCEDLL_SCP_GENERALSVC_ERROR);
            } else {
                ScepLogOutput3(0,0, SCEDLL_SCP_GENERALSVC_SUCCESS);
            }

            ScepLogOutput3(0,0, SCEDLL_SCP_BEGIN_ATTACHMENT);

            if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                 ScepIsSystemShutDown() ) {

                rc = SCESTATUS_SERVICE_NOT_SUPPORT;

            } else {

                rc = ScepInvokeSpecificServices( hProfile, TRUE, SCE_ATTACHMENT_SERVICE );
            }

            if( rc != SCESTATUS_SUCCESS ) {
                Saverc = rc;
                ScepLogOutput3(0,0, SCEDLL_SCP_ATTACHMENT_ERROR);
            } else {
                ScepLogOutput3(0,0, SCEDLL_SCP_ATTACHMENT_SUCCESS);
            }

        }

        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
             ScepIsSystemShutDown() ) {

            Saverc = SCESTATUS_SERVICE_NOT_SUPPORT;
            goto Done;
        }

        //
        // Security policy
        //

        if ( Area & AREA_SECURITY_POLICY ) {

            ScepPostProgress(0,
                             AREA_SECURITY_POLICY,
                             NULL);

            ScepLogOutput3(0,0, SCEDLL_SCP_BEGIN_POLICY);

            if ( !(ConfigOptions & SCE_NO_DOMAIN_POLICY ) ) {

                rc = ScepConfigureSystemAccess( pScpInfo, ConfigOptions, NULL, QueueFlag );

                if( rc != SCESTATUS_SUCCESS ) {
                    if ( rc != SCESTATUS_PENDING_IGNORE )
                        Saverc = rc;
                    else
                        PendingRc = rc;

                    ScepLogOutput3(0,0, SCEDLL_SCP_ACCESS_ERROR);
                } else {
                    ScepLogOutput3(0,0, SCEDLL_SCP_ACCESS_SUCCESS);
                }
            }

            ScepPostProgress(TICKS_SYSTEM_ACCESS,
                             AREA_SECURITY_POLICY,
                             (LPTSTR)szSystemAccess);
            //
            // System Auditing area
            //
            rc = ScepConfigureSystemAuditing( pScpInfo, ConfigOptions );

            if ( rc == SCESTATUS_SUCCESS && NULL != auditEvent ) {

                //
                // not in policy prop or
                // no pending notify for audit
                //
                if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                     (QueueFlag & SCE_QUEUE_INFO_AUDIT) ) {


                    rc = ERROR_IO_PENDING;
                    ScepLogOutput3(0, 0, SCESRV_POLICY_PENDING_AUDIT);

                    if (ConfigOptions & SCE_RSOP_CALLBACK)
                        ScepRsopLog(SCE_RSOP_AUDIT_EVENT_INFO, rc, NULL,0,0);

                    rc = ScepDosErrorToSceStatus(rc);

                } else {

                    rc = ScepConfigureAuditEvent(pScpInfo,
                                                 auditEvent,
                                                 bAdminLogon ?
                                                   ConfigOptions :
                                                   (ConfigOptions & ~SCE_SYSTEM_DB),
                                                 LsaPrivatePolicy
                                                 );
                }
            }

            if( rc != SCESTATUS_SUCCESS ) {
                if ( rc != SCESTATUS_PENDING_IGNORE )
                    Saverc = rc;
                else
                    PendingRc = rc;

                ScepLogOutput3(0,0, SCEDLL_SCP_AUDIT_ERROR);
            } else {
                ScepLogOutput3(0,0, SCEDLL_SCP_AUDIT_SUCCESS);
            }

            ScepPostProgress(TICKS_SYSTEM_AUDITING,
                             AREA_SECURITY_POLICY,
                             (LPTSTR)szAuditEvent);

#if _WIN32_WINNT>=0x0500
            if ( ProductType == NtProductLanManNt &&
                 !(ConfigOptions & SCE_NO_DOMAIN_POLICY ) ) {

                if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                     ScepIsSystemShutDown() ) {

                    rc = SCESTATUS_SERVICE_NOT_SUPPORT;

                } else {

                    //
                    // Kerberos Policy
                    //
                    rc = ScepConfigureKerberosPolicy( hProfile,
                                                      pScpInfo->pKerberosInfo,
                                                      ConfigOptions );
                }

                if( rc != SCESTATUS_SUCCESS ) {
                    Saverc = rc;
                    ScepLogOutput3(0,0, SCEDLL_SCP_KERBEROS_ERROR);
                } else {
                    ScepLogOutput3(0,0, SCEDLL_SCP_KERBEROS_SUCCESS);
                }

            }
#endif
            ScepPostProgress(TICKS_KERBEROS,
                             AREA_SECURITY_POLICY,
                             (LPTSTR)szKerberosPolicy);

            //
            // registry values
            //
            rc = ScepConfigureRegistryValues( hProfile,
                                              pScpInfo->aRegValues,
                                              pScpInfo->RegValueCount,
                                              NULL,
                                              ConfigOptions,
                                              NULL );

            if( rc != SCESTATUS_SUCCESS ) {
                Saverc = rc;
                ScepLogOutput3(0,0, SCEDLL_SCP_REGVALUES_ERROR);
            } else {
                ScepLogOutput3(0,0, SCEDLL_SCP_REGVALUES_SUCCESS);
            }

            ScepPostProgress(TICKS_REGISTRY_VALUES,
                             AREA_SECURITY_POLICY,
                             (LPTSTR)szRegistryValues);

            ScepLogOutput3(0,0, SCEDLL_SCP_BEGIN_ATTACHMENT);

            //
            // implemented in service.cpp
            //
            rc = ScepInvokeSpecificServices( hProfile, TRUE, SCE_ATTACHMENT_POLICY );

            if( rc != SCESTATUS_SUCCESS ) {
                Saverc = rc;
                ScepLogOutput3(0,0, SCEDLL_SCP_ATTACHMENT_ERROR);
            } else {
                ScepLogOutput3(0,0, SCEDLL_SCP_ATTACHMENT_SUCCESS);
            }

        }

    }

Done:

    if ( pNotifyAccounts ) {
        ScepSplayFreeTree(&pNotifyAccounts, TRUE);
    }

    if ( NULL != auditEvent ) {
        if ( bAuditOff && auditEvent->AuditingMode ) {

            rc = ScepRestoreAuditing(auditEvent, LsaPrivatePolicy);
        }
        LsaFreeMemory(auditEvent);
    }

    ScepLogOutput3(0,0, SCEDLL_SCP_UNINIT);

    if ( pdWarning ) {
        *pdWarning = gWarningCode;
    }

    //
    // return failure if invalid data is found in the template
    //
    if ( gbInvalidData ) {
        Saverc = SCESTATUS_INVALID_DATA;
    }

    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
         !(ConfigOptions & SCE_NO_CONFIG) ) {
        //
        // always resume the queue processing after configuration is done
        //
        ScepNotificationQControl(0);
    }

    if ( Saverc == SCESTATUS_SUCCESS ) Saverc = PendingRc;

    ScepConfigureDeInitialize( Saverc, Area);

    return(Saverc);

}


SCESTATUS
ScepConfigureInitialize(
    IN PCWSTR InfFileName OPTIONAL,
    IN PWSTR DatabaseName,
    IN BOOL bAdminLogon,
    IN DWORD ConfigOptions,
    IN AREA_INFORMATION Area
    )
/* ++

Routine Description:

     This routine initializes the SCP engine.

Arguments:

    InfFileName -         The file name of a SCP file used to configure the sytem

    DatabaseName -        The JET (for future analysis) profile name

    ConfigOptions     -   If the template is to update the system instead of overwriting

    Area - security area to initialize

Return value:

      SCESTATUS_SUCCESS
      SCESTATUS_INVALID_PARAMETER
      SCESTATUS_PROFILE_NOT_FOUND
      SCESTATUS_NOT_ENOUGH_RESOURCE
      SCESTATUS_ALREADY_RUNNING

-- */
{

    SCESTATUS           rc=SCESTATUS_SUCCESS;
    PCHAR               FileName=NULL;
    DWORD               MBLen=0;
    NTSTATUS            NtStatus;
    LARGE_INTEGER       CurrentTime;
    PSCE_ERROR_LOG_INFO  Errlog=NULL;
    PSECURITY_DESCRIPTOR pSD=NULL;
    SECURITY_INFORMATION SeInfo;
    DWORD                SDsize;
    DWORD                DbNameLen;
    HKEY hCurrentUser=NULL;

    //
    // database name can't be NULL because it's already resolved
    //

    if ( !DatabaseName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
         ScepIsSystemShutDown() ) {
        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    //
    // get other system values
    //
    if ( RtlGetNtProductType (&ProductType) == FALSE ) {
        rc = ScepDosErrorToSceStatus(GetLastError());
        goto Leave;
    }

    //
    // Initialize globals
    //
    gTotalTicks = 0;
    gCurrentTicks = 0;
    gWarningCode = 0;
    gbInvalidData = FALSE;

    //
    // Initialize engine buffer
    //

    cbClientFlag = (BYTE)( ConfigOptions & (SCE_CALLBACK_DELTA |
                                           SCE_CALLBACK_TOTAL ));

    pScpInfo = (PSCE_PROFILE_INFO)&scpBuffer;
    pScpInfo->Type = SCE_ENGINE_SCP_INTERNAL;

    //
    // convert WCHAR into ANSI
    //

    DbNameLen = wcslen(DatabaseName);

    NtStatus = RtlUnicodeToMultiByteSize(&MBLen, DatabaseName, DbNameLen*sizeof(WCHAR));

    if ( !NT_SUCCESS(NtStatus) ) {
        //
        // cannot get the length, set default to 512
        //
        MBLen = 512;
    }

    FileName = (PCHAR)ScepAlloc(LPTR, MBLen+2);

    if ( FileName == NULL ) {
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        goto Leave;
    }

    NtStatus = RtlUnicodeToMultiByteN(
                    FileName,
                    MBLen+1,
                    NULL,
                    DatabaseName,
                    DbNameLen*sizeof(WCHAR)
                    );
    if ( !NT_SUCCESS(NtStatus) ) {
        rc = RtlNtStatusToDosError(NtStatus);
        ScepLogOutput3(1, rc, SCEDLL_ERROR_PROCESS_UNICODE, DatabaseName );
        rc = ScepDosErrorToSceStatus(rc);
        goto Leave;
    }

    if ( RegOpenCurrentUser(
              KEY_READ | KEY_WRITE,
              &hCurrentUser
              ) != ERROR_SUCCESS ) {
        hCurrentUser = NULL;
    }

    if ( hCurrentUser == NULL ) {
        hCurrentUser = HKEY_CURRENT_USER;
    }

    //
    // delay registry filter (into database) is not needed anymore
    //

    if ( InfFileName != NULL ) { // || InfHandle != NULL ) {

        //
        // convert inf to jet
        //
        ScepLogOutput3(3, 0, SCEDLL_PROCESS_TEMPLATE, (PWSTR)InfFileName );

        if ( bAdminLogon ) {
            //
            // make sure the directories exist for the file
            //
            rc = ConvertTextSecurityDescriptor (
                            L"D:P(A;CIOI;GRGW;;;WD)(A;CIOI;GA;;;BA)(A;CIOI;GA;;;SY)",
                            &pSD,
                            &SDsize,
                            &SeInfo
                            );
            if ( rc != NO_ERROR )
                ScepLogOutput3(1, rc, SCEDLL_ERROR_BUILD_SD, DatabaseName );
        }

        //
        // change revision to ACL_REVISION2 (from 4) because it's for files
        //

        ScepChangeAclRevision(pSD, ACL_REVISION);

        ScepCreateDirectory(
                DatabaseName,
                FALSE,      // a file name
                pSD     //NULL        // take parent's security setting
                );
        if ( pSD ) {
            ScepFree(pSD);
        }

        if ( ConfigOptions & SCE_OVERWRITE_DB ) {
            //
            // only delete existing jet files if jet engine is not running
            // because other threads may use the same version storage
            // for other database.
            //
            // if jet engine is not running, delete version storage files
            // will not force a recovery because overwrite db option means
            // overwrite all previous info in the database.
            //
            SceJetDeleteJetFiles(DatabaseName);
        }

        //
        // copy the inf sections and data to the jet database SCP table
        //

        if ( InfFileName != NULL ) {

            SCEJET_CREATE_TYPE TmpOption;

            if ( ConfigOptions & SCE_UPDATE_DB ) {
                if ( ConfigOptions & SCE_POLICY_TEMPLATE ) {
                    TmpOption = SCEJET_OPEN_DUP;
                } else {
                    TmpOption = SCEJET_OPEN_DUP_EXCLUSIVE;
                }
            } else {
                TmpOption = SCEJET_OVERWRITE_DUP;
            }

            rc = SceJetConvertInfToJet(
                    InfFileName,
                    (LPSTR)FileName,
                    TmpOption,
                    bAdminLogon ? ConfigOptions : (ConfigOptions & ~SCE_SYSTEM_DB),
                    Area
                    );
        }

        if ( rc != SCESTATUS_SUCCESS ) { // SCESTATUS error code
            goto Leave;
        }
    } else if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                (ConfigOptions & SCE_POLICY_FIRST) &&
                (ConfigOptions & SCE_POLICY_LAST) ) {
        //
        // a policy refresh without any domain GPOs, do the local GPO only
        //

        rc = SceJetOpenFile(
                (LPSTR)FileName,
                SCEJET_OPEN_READ_WRITE, // SCEJET_OPEN_EXCLUSIVE,
                SCE_TABLE_OPTION_MERGE_POLICY | SCE_TABLE_OPTION_TATTOO,
                &hProfile
                );

        if ( SCESTATUS_SUCCESS == rc ) {

            rc = ScepDeleteInfoForAreas(
                      hProfile,
                      SCE_ENGINE_SCP,
                      AREA_ALL
                      );

            if ( ( rc == SCESTATUS_SUCCESS ) ||
                 ( rc == SCESTATUS_RECORD_NOT_FOUND ) ) {

                //
                // delete GPO table to start over
                //

                SceJetDeleteAll( hProfile,
                                 "SmTblGpo",
                                 SCEJET_TABLE_GPO
                               );

                //
                // copy local table
                //
                PSCE_ERROR_LOG_INFO  Errlog=NULL;

                ScepLogOutput3(2, rc, SCEDLL_COPY_LOCAL);

                rc = ScepCopyLocalToMergeTable( hProfile, ConfigOptions,
                                               (ProductType == NtProductLanManNt) ? SCE_LOCAL_POLICY_DC : 0,
                                                &Errlog );

                ScepLogWriteError( Errlog,1 );
                ScepFreeErrorLog( Errlog );
                Errlog = NULL;

                if ( rc == SCESTATUS_SUCCESS ) {

                    DWORD dwThisTable = hProfile->Type & 0xF0L;

                    if ( SCEJET_MERGE_TABLE_1 == dwThisTable ||
                         SCEJET_MERGE_TABLE_2 == dwThisTable ) {

                        rc = SceJetSetValueInVersion(
                                    hProfile,
                                    "SmTblVersion",
                                    "LastUsedMergeTable",
                                    (PWSTR)&dwThisTable,
                                    4,
                                    JET_prepReplace
                                    );
                    }

                } else {

                    ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                                 SCEDLL_ERROR_COPY);

                }

            } else {

                ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                             SCEDLL_ERROR_DELETE, L"SCP");

            }

        } else {

            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                         SCEDLL_ERROR_OPEN, DatabaseName );
        }

        if ( rc != SCESTATUS_SUCCESS ) { // SCESTATUS error code
            goto Leave;
        }
    }

    //
    // set the default profile into Reg
    //
    rc = ScepRegSetValue(
            bAdminLogon ? HKEY_LOCAL_MACHINE : hCurrentUser,
            SCE_ROOT_PATH,
            L"LastUsedDatabase",
            REG_SZ,
            (BYTE *)DatabaseName,
            DbNameLen*sizeof(WCHAR)
            );
    if ( rc != NO_ERROR )  // Win32 error code
        ScepLogOutput3(1, rc, SCEDLL_ERROR_SAVE_REGISTRY, L"LastUsedDatabase");


    if ( InfFileName != NULL ) {
        if ( bAdminLogon ) {
            //
            // only save the value if it's not coming from policy prop
            //
            if ( !(ConfigOptions & SCE_POLICY_TEMPLATE) ) {

                rc = ScepRegSetValue(
                        HKEY_LOCAL_MACHINE,
                        SCE_ROOT_PATH,
                        L"TemplateUsed",
                        REG_SZ,
                        (BYTE *)InfFileName,
                        wcslen(InfFileName)*sizeof(WCHAR)
                        );
            } else {
                rc = NO_ERROR;
            }
        } else {
            rc = ScepRegSetValue(
                    hCurrentUser,  // HKEY_CURRENT_USER
                    SCE_ROOT_PATH,
                    L"TemplateUsed",
                    REG_SZ,
                    (BYTE *)InfFileName,
                    wcslen(InfFileName)*sizeof(WCHAR)
                    );
        }
        if ( rc != NO_ERROR )  // Win32 error code
            ScepLogOutput3(1, rc, SCEDLL_ERROR_SAVE_REGISTRY, L"TemplateUsed");
    }

    //
    // if no configuration is requested, just return now.
    //

    if ( ConfigOptions & SCE_NO_CONFIG ) {

        if ( !(ConfigOptions & SCE_COPY_LOCAL_POLICY) ) {
            //
            // if no policy template is requested
            //
            goto Leave;
        }
    }

    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
         ScepIsSystemShutDown() ) {

        rc = SCESTATUS_SERVICE_NOT_SUPPORT;
        goto Leave;
    }

    //
    // open the database now to create some tables and time stamp
    // tattoo is not needed unless it's in policy propagation
    //

    rc = SceJetOpenFile(
                (LPSTR)FileName,
                ( ConfigOptions & (SCE_POLICY_TEMPLATE | SCE_COPY_LOCAL_POLICY) ) ? SCEJET_OPEN_READ_WRITE : SCEJET_OPEN_EXCLUSIVE,
                ( ConfigOptions & SCE_POLICY_TEMPLATE ) ? SCE_TABLE_OPTION_TATTOO : 0,
                &hProfile
                );

    if ( rc != SCESTATUS_SUCCESS ) {
        //
        // sleep for some time and try open again
        //

        Sleep(2000);  // 2 seconds

        rc = SceJetOpenFile(
                    (LPSTR)FileName,
                    ( ConfigOptions & (SCE_POLICY_TEMPLATE | SCE_COPY_LOCAL_POLICY) ) ? SCEJET_OPEN_READ_WRITE : SCEJET_OPEN_EXCLUSIVE,
                    ( ConfigOptions & SCE_POLICY_TEMPLATE ) ? SCE_TABLE_OPTION_TATTOO : 0,
                    &hProfile
                    );
        if ( rc != SCESTATUS_SUCCESS ) {

            Sleep(2000);  // 2 seconds

            rc = SceJetOpenFile(
                        (LPSTR)FileName,
                        ( ConfigOptions & (SCE_POLICY_TEMPLATE | SCE_COPY_LOCAL_POLICY) ) ? SCEJET_OPEN_READ_WRITE : SCEJET_OPEN_EXCLUSIVE,
                        ( ConfigOptions & SCE_POLICY_TEMPLATE ) ? SCE_TABLE_OPTION_TATTOO : 0,
                        &hProfile
                        );
        }
    }

    if ( rc != SCESTATUS_SUCCESS ) {

        ScepLogOutput3(0, ScepSceStatusToDosError(rc),
                     SCEDLL_ERROR_OPEN,
                     DatabaseName );
        goto Leave;
    }

    SceJetStartTransaction( hProfile );

    if ( ConfigOptions & SCE_COPY_LOCAL_POLICY ) {
        //
        // Copy domain policies (password, account, kerberos) to the special
        // file %windir%\security\FirstDGPO.inf. The info in database will be
        // deleted
        //
        //
        // copy local policies (audit, and user rights) to the special file
        // %windir%\security\FirstOGPO.inf. The local policy info in the
        // database will still be left in.
        //
        rc = ScepMakePolicyIntoFile( ConfigOptions, Area);

        if ( rc != SCESTATUS_SUCCESS) {

            SceJetRollback( hProfile, 0 );
            goto Leave;
        }
    }

    if ( (hProfile->JetSapID != JET_tableidNil) &&
         !(ConfigOptions & SCE_POLICY_TEMPLATE) &&
         !(ConfigOptions & SCE_COPY_LOCAL_POLICY) &&
         ((ConfigOptions & SCE_NO_CONFIG) == 0) ) {

        //
        // analysis was performed before
        // delete SAP info for the area
        //
        ScepLogOutput3(3,0, SCEDLL_DELETE_TABLE, L"SAP");

//        bug 362120
//        after each config, user must re-analyze the computer to get
//        analysis information
//
//        if ( (ConfigOptions & SCE_OVERWRITE_DB) &&
//             (InfFileName != NULL /*|| InfHandle != NULL */) ) {

            //
            // if it's reconfigured with a new template, all SAP
            // information is obselote, so delete the whole table
            //

            rc = SceJetDeleteTable(
                 hProfile,
                 "SmTblSap",
                 SCEJET_TABLE_SAP
                 );
/*
        } else {

            //
            // the template is incremental, or use the original template
            // just delete sap information for the area, assuming that
            // everything in the area is matched after this configuration
            //

            rc = ScepDeleteInfoForAreas(
                      hProfile,
                      SCE_ENGINE_SAP,
                      Area
                      );
        }
*/
        if ( rc != SCESTATUS_SUCCESS && rc != SCESTATUS_RECORD_NOT_FOUND ) {
            ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                         SCEDLL_ERROR_DELETE, L"SAP");

            SceJetRollback( hProfile, 0 );
            goto Leave;
        }
    }

    //
    // set time stamp for this configuration
    //

    if ( (ConfigOptions & SCE_NO_CONFIG) == 0 ) {

        NtStatus = NtQuerySystemTime(&CurrentTime);

        if ( NT_SUCCESS(NtStatus) ) {
            rc = SceJetSetTimeStamp(
                        hProfile,
                        FALSE,
                        CurrentTime
                        );
            if ( rc != SCESTATUS_SUCCESS )
                ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                             SCEDLL_TIMESTAMP_ERROR,L"SMP");

            // do not care the status of this call
            rc = SCESTATUS_SUCCESS;

        } else
            ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                         SCEDLL_TIMESTAMP_ERROR, L"SMP");
    }

    //
    // commit all changes to this database
    // fatal errors won't get here
    //

    SceJetCommitTransaction( hProfile, 0 );

    //
    // now if NO_CONFIG is requested ( with MOVE_POLICY or COPY_POLICY flag )
    // should return now
    //
    if ( ConfigOptions & SCE_NO_CONFIG ) {
        goto Leave;
    }

    //
    // close the exclusively opened database and
    // open it for read only because config engine read from the database
    // NOTE: SceJetOpenFile will close the previous database if the handle
    // is not NULL. The SceJetCloseFile is called with (theHandle,FALSE,FALSE)
    // so jet session and instance are not terminated
    //

    rc = SceJetOpenFile(
                (LPSTR)FileName,
                ( ConfigOptions & SCE_POLICY_TEMPLATE ) ? SCEJET_OPEN_READ_WRITE : SCEJET_OPEN_READ_ONLY, // tattoo table will be updated in policy
                ( ConfigOptions & SCE_POLICY_TEMPLATE ) ? SCE_TABLE_OPTION_TATTOO : 0, // by now the LastUsedMergeTable field is already set
                &hProfile
                );
    if ( rc != SCESTATUS_SUCCESS ) { // SCESTATUS
        ScepLogOutput3(0, ScepSceStatusToDosError(rc),
                     SCEDLL_ERROR_OPEN,
                     DatabaseName );
        goto Leave;
    }

    //
    // query the total ticks of this configuration
    //

    rc = ScepGetTotalTicks(
                NULL,
                hProfile,
                Area,
                ( ConfigOptions & SCE_POLICY_TEMPLATE ) ?
                                 SCE_FLAG_CONFIG_SCP : SCE_FLAG_CONFIG,
                &gTotalTicks
                );
    if ( SCESTATUS_SUCCESS != rc &&
         SCESTATUS_RECORD_NOT_FOUND != rc ) {

        ScepLogOutput3(1, ScepSceStatusToDosError(rc),
                     SCEDLL_TOTAL_TICKS_ERROR);

    }
    rc = SCESTATUS_SUCCESS;

    //
    // reset memory buffer
    //
    memset( pScpInfo, '\0',sizeof(SCE_PROFILE_INFO) );
    pScpInfo->Type = SCE_ENGINE_SCP_INTERNAL;

    //
    // open LSA private policy handle (to block other downlevel changes)
    //
    if ( ( ConfigOptions & SCE_POLICY_TEMPLATE ) &&
        !( ConfigOptions & SCE_NO_CONFIG) &&
         ( (Area & AREA_PRIVILEGES) ||
           (Area & AREA_SECURITY_POLICY) ) ) {

        //
        // enable TCB privilege
        //
        SceAdjustPrivilege( SE_TCB_PRIVILEGE, TRUE, NULL );

        NTSTATUS                    NtStatus;
        LSA_OBJECT_ATTRIBUTES       attributes;
        SECURITY_QUALITY_OF_SERVICE service;


        memset( &attributes, 0, sizeof(attributes) );
        attributes.Length = sizeof(attributes);
        attributes.SecurityQualityOfService = &service;
        service.Length = sizeof(service);
        service.ImpersonationLevel= SecurityImpersonation;
        service.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        service.EffectiveOnly = TRUE;

        //
        // open the lsa policy first
        //

        NtStatus = LsaOpenPolicySce(   // LsaOpenPolicySce
                        NULL,
                        &attributes,
                        MAXIMUM_ALLOWED,
                        &LsaPrivatePolicy
                        );
        if ( !NT_SUCCESS(NtStatus) || NtStatus == STATUS_TIMEOUT) {

            if ( STATUS_TIMEOUT == NtStatus ) {
                rc = ERROR_TIMEOUT;
            } else
                rc = RtlNtStatusToDosError(NtStatus);

            LsaPrivatePolicy = NULL;

            ScepLogOutput3(1, rc, SCESRV_ERROR_PRIVATE_LSA );
            rc = ScepDosErrorToSceStatus(rc);

        } else {

            ScepNotifyLogPolicy(0, TRUE, L"Policy Prop: Private LSA handle is returned", 0, 0, NULL );
        }
    }

Leave:

    if ( hCurrentUser && hCurrentUser != HKEY_CURRENT_USER ) {
        RegCloseKey(hCurrentUser);
    }

    if ( FileName ) {
        ScepFree(FileName);
    }
    return(rc);

}



SCESTATUS
ScepConfigureSystemAccess(
    IN PSCE_PROFILE_INFO pScpInfo,
    IN DWORD ConfigOptions,
    IN PSCE_ERROR_LOG_INFO *pErrLog,
    IN DWORD QueueFlag
    )
/* ++

Routine Description:

   This routine configure the system security in the area of system access
   which includes account policy, rename admin/guest accounts, disable
   no activity account, and some registry keys security, e.g., winlogon keys.

Arguments:

   pScpInfo - The buffer which contains SCP info loaded from the profile

   ConfigOptions - options in configuration

   pErrLog - the output log for potential errors

   QueueFlag - flags for the notification queue, which determines if SAM policy
               should be configured.

Return value:

   SCESTATUS_SUCCESS
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER
   SCESTATUS_OTHER_ERROR

-- */
{
    DWORD       rc,PendingRc=0;
    DWORD       SaveStat;
    NTSTATUS    NtStatus;
    SAM_HANDLE  DomainHandle=NULL,
                ServerHandle=NULL,
                UserHandle1=NULL;
    PSID        DomainSid=NULL;
    PVOID                        Buffer=NULL;
    DWORD                        RegData;
    BOOL        bFlagSet;

    SCE_TATTOO_KEYS *pTattooKeys=NULL;
    DWORD           cTattooKeys=0;

    PSCESECTION hSectionDomain=NULL;
    PSCESECTION hSectionTattoo=NULL;

#define MAX_PASS_KEYS           7
#define MAX_LOCKOUT_KEYS        3

    //
    // Open account domain
    //

    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
         ScepIsSystemShutDown() ) {

        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    NtStatus = ScepOpenSamDomain(
                        MAXIMUM_ALLOWED, // SAM_SERVER_ALL_ACCESS,
                        DOMAIN_WRITE_PASSWORD_PARAMS | MAXIMUM_ALLOWED,
                        &ServerHandle,
                        &DomainHandle,
                        &DomainSid,
                        NULL,
                        NULL
                       );

    rc = RtlNtStatusToDosError( NtStatus );
    SaveStat = rc;

    if (!NT_SUCCESS(NtStatus)) {

        if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) &&
             pErrLog ) {

            ScepBuildErrorLogInfo(
                        rc,
                        pErrLog,
                        SCEDLL_ACCOUNT_DOMAIN
                        );
        } else {
            ScepLogOutput3(1, rc, SCEDLL_ACCOUNT_DOMAIN);
        }

        if (ConfigOptions & SCE_RSOP_CALLBACK)

            ScepRsopLog(SCE_RSOP_PASSWORD_INFO |
                                       SCE_RSOP_LOCKOUT_INFO |
                                       SCE_RSOP_LOGOFF_INFO |
                                       SCE_RSOP_ADMIN_INFO |
                                       SCE_RSOP_GUEST_INFO,
                                       rc,
                                       NULL,
                                       0,
                                       0);

        return( ScepDosErrorToSceStatus(rc) );
    }

    //
    // if this is policy propagation, we need to open the sections for
    // updating undo settings if this is not domain controller
    // *** on DCs, domain account policy can't be reset'ed to tattoo
    // on each individual DC. So there is no point to query/save tattoo values
    //

    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
        ( ProductType != NtProductLanManNt ) ) {

        ScepTattooOpenPolicySections(
                      hProfile,
                      szSystemAccess,
                      &hSectionDomain,
                      &hSectionTattoo
                      );
    }

    //
    // if there is pending notifications for SAM policy
    // ignore policy prop for SAM
    //
    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
         (QueueFlag & SCE_QUEUE_INFO_SAM) ) {

        ScepLogOutput3(0, 0, SCESRV_POLICY_PENDING_SAM);

        rc = ERROR_IO_PENDING;
        PendingRc = rc;

        if (ConfigOptions & SCE_RSOP_CALLBACK)

            ScepRsopLog(SCE_RSOP_PASSWORD_INFO |
                        SCE_RSOP_LOCKOUT_INFO |
                        SCE_RSOP_LOGOFF_INFO,
                                       rc,
                                       NULL,
                                       0,
                                       0);
        goto OtherSettings;

    }

    //
    // Get the current password settings...
    //

    Buffer=NULL;
    NtStatus = SamQueryInformationDomain(
                  DomainHandle,
                  DomainPasswordInformation,
                  &Buffer
                  );

    rc = RtlNtStatusToDosError( NtStatus );
    if ( NT_SUCCESS(NtStatus) ) {

        rc = ERROR_SUCCESS;

        // allocate buffer for the tattoo values if necessary
        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
            ( ProductType != NtProductLanManNt ) ) {

            pTattooKeys = (SCE_TATTOO_KEYS *)ScepAlloc(LPTR,MAX_PASS_KEYS*sizeof(SCE_TATTOO_KEYS));

            if ( !pTattooKeys ) {
                ScepLogOutput3(1, ERROR_NOT_ENOUGH_MEMORY, SCESRV_POLICY_TATTOO_ERROR_CREATE);
            }
        }

        bFlagSet = FALSE;

        if ( (pScpInfo->MinimumPasswordLength != SCE_NO_VALUE) ) {

            //
            // for domain controllers, always use hardcode value as the initial tattoo value
            //
            ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                     (PWSTR)L"MinimumPasswordLength", ConfigOptions,
                                     (ProductType == NtProductLanManNt) ? SCEDCPOL_MIN_PASS_LEN :
                                       ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MinPasswordLength);

            if ( ((USHORT)(pScpInfo->MinimumPasswordLength) != ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MinPasswordLength) ) {

                ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MinPasswordLength =  (USHORT)(pScpInfo->MinimumPasswordLength);
                bFlagSet = TRUE;

            }

        }
        if ( (pScpInfo->PasswordHistorySize != SCE_NO_VALUE) ) {

            ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                     (PWSTR)L"PasswordHistorySize", ConfigOptions,
                                     (ProductType == NtProductLanManNt) ? SCEDCPOL_PASS_SIZE : ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordHistoryLength);

            if ( ((USHORT)(pScpInfo->PasswordHistorySize) != ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordHistoryLength ) ) {

                ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordHistoryLength =  (USHORT)(pScpInfo->PasswordHistorySize);
                bFlagSet = TRUE;
            }
        }

        if ( pScpInfo->MaximumPasswordAge == SCE_FOREVER_VALUE ) {

            RegData = (DWORD) (-1 * (((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MaxPasswordAge.QuadPart /
                                           (LONGLONG)(10000000L)) );
            RegData /= 3600;
            RegData /= 24;

            ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                     (PWSTR)L"MaximumPasswordAge", ConfigOptions,
                                     (ProductType == NtProductLanManNt) ? SCEDCPOL_MAX_PASS_AGE : RegData);

            if ( ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MaxPasswordAge.HighPart != MINLONG ||
                 ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MaxPasswordAge.LowPart != 0  ) {

                //
                // Maximum LARGE_INTEGER .ie. never
                //

                ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MaxPasswordAge.HighPart = MINLONG;
                ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MaxPasswordAge.LowPart = 0;
                bFlagSet = TRUE;

            }

        }  else if ( pScpInfo->MaximumPasswordAge != SCE_NO_VALUE ) {

            RegData = (DWORD) (-1 * (((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MaxPasswordAge.QuadPart /
                                           (LONGLONG)(10000000L)) );
            RegData /= 3600;
            RegData /= 24;

            ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                     (PWSTR)L"MaximumPasswordAge", ConfigOptions,
                                     (ProductType == NtProductLanManNt) ? SCEDCPOL_MAX_PASS_AGE : RegData);

            if ( RegData != pScpInfo->MaximumPasswordAge ) {

                ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MaxPasswordAge.QuadPart = -1 *
                                              (LONGLONG)pScpInfo->MaximumPasswordAge*24*3600 * 10000000L;
                bFlagSet = TRUE;

            }
        }

        if ( pScpInfo->MinimumPasswordAge != SCE_NO_VALUE ) {

            RegData = (DWORD) (-1 * (((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MinPasswordAge.QuadPart /
                                              (LONGLONG)(10000000L)) );
            RegData /= 3600;
            RegData /= 24;

            ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                     (PWSTR)L"MinimumPasswordAge", ConfigOptions,
                                     (ProductType == NtProductLanManNt) ? SCEDCPOL_MIN_PASS_AGE : RegData);

            if ( RegData != pScpInfo->MinimumPasswordAge ) {

                ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->MinPasswordAge.QuadPart = -1 *
                                              (LONGLONG)pScpInfo->MinimumPasswordAge*24*3600 * 10000000L;
                bFlagSet = TRUE;
            }
        }

        if ( pScpInfo->PasswordComplexity != SCE_NO_VALUE ) {

            RegData = ( ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordProperties & DOMAIN_PASSWORD_COMPLEX) ? 1 : 0;

            ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                    (PWSTR)L"PasswordComplexity", ConfigOptions,
                                    (ProductType == NtProductLanManNt) ? SCEDCPOL_PASS_COMP : RegData);

            if ( pScpInfo->PasswordComplexity != RegData ) {

                if ( RegData == 0 )
                   ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordProperties |= DOMAIN_PASSWORD_COMPLEX;
                else
                   ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordProperties &= ~DOMAIN_PASSWORD_COMPLEX;
                bFlagSet = TRUE;

            }
        }

        if ( pScpInfo->RequireLogonToChangePassword != SCE_NO_VALUE ) {

            RegData = ( ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordProperties & DOMAIN_PASSWORD_NO_ANON_CHANGE) ? 1 : 0;

            ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                     (PWSTR)L"RequireLogonToChangePassword", ConfigOptions,
                                     (ProductType == NtProductLanManNt) ? SCEDCPOL_REQUIRE_LOGON : RegData);

            if ( pScpInfo->RequireLogonToChangePassword != RegData ) {

                if ( RegData == 0 )
                    ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordProperties |= DOMAIN_PASSWORD_NO_ANON_CHANGE;
                else
                    ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordProperties &= ~DOMAIN_PASSWORD_NO_ANON_CHANGE;
                bFlagSet = TRUE;

            }
        }

#if _WIN32_WINNT>=0x0500
        if ( pScpInfo->ClearTextPassword != SCE_NO_VALUE ) {

            RegData = ( ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordProperties & DOMAIN_PASSWORD_STORE_CLEARTEXT) ? 1 : 0;

            ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                     (PWSTR)L"ClearTextPassword", ConfigOptions,
                                     (ProductType == NtProductLanManNt) ? SCEDCPOL_CLEAR_PASS : RegData);

            if ( pScpInfo->ClearTextPassword != RegData ) {

                if ( RegData == 0 )
                    ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordProperties |= DOMAIN_PASSWORD_STORE_CLEARTEXT;
                else
                    ((DOMAIN_PASSWORD_INFORMATION *)Buffer)->PasswordProperties &= ~DOMAIN_PASSWORD_STORE_CLEARTEXT;
                bFlagSet = TRUE;

            }
        }
#endif
        if ( bFlagSet ) {

            NtStatus = SamSetInformationDomain(
                         DomainHandle,
                         DomainPasswordInformation,
                         Buffer
                         );
            rc = RtlNtStatusToDosError( NtStatus );
        }

        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
            ( ProductType != NtProductLanManNt ) &&
             pTattooKeys && cTattooKeys ) {

             //
             // even if there is no change,
             // we still need to check if some tattoo values should be deleted
             //
            ScepLogOutput3(3, 0, SCESRV_POLICY_TATTOO_ARRAY, cTattooKeys);

            //
            // some policy is different than the system setting
            // check if we should save the existing setting as the tattoo value
            // also remove reset'ed tattoo policy
            //
            ScepTattooManageValues(hSectionDomain, hSectionTattoo, pTattooKeys, cTattooKeys, rc);

        }

        if ( pTattooKeys ) {
            ScepFree(pTattooKeys);
            pTattooKeys = NULL;
        }
        cTattooKeys = 0;

        SamFreeMemory(Buffer);

        if ( !NT_SUCCESS( NtStatus ) ) {
            //
            // if error, just log it and continue
            //
            if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {
                ScepBuildErrorLogInfo(
                            rc,
                            pErrLog,
                            SCEDLL_SCP_ERROR_PASSWORD
                            );
            } else {
                ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_PASSWORD);
            }
            SaveStat = rc;
            // goto GETOUT;
        } else {
            ScepLogOutput3(1, rc, SCEDLL_SCP_PASSWORD);
        }

    } else if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

        ScepBuildErrorLogInfo(
                    rc,
                    pErrLog,
                    SCEDLL_ERROR_QUERY_PASSWORD
                    );
    } else {

        ScepLogOutput3(1, rc, SCEDLL_ERROR_QUERY_PASSWORD);
    }

    if (ConfigOptions & SCE_RSOP_CALLBACK)

        ScepRsopLog(SCE_RSOP_PASSWORD_INFO, rc, NULL, 0, 0);

    //
    // Configure Lockout information
    //

    Buffer = NULL;
    NtStatus = SamQueryInformationDomain(
                  DomainHandle,
                  DomainLockoutInformation,
                  &Buffer
                  );

    rc = RtlNtStatusToDosError( NtStatus );
    if ( NT_SUCCESS(NtStatus) ) {

        rc = ERROR_SUCCESS;

        // allocate buffer for the tattoo values if necessary
        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
            ( ProductType != NtProductLanManNt ) ) {

            pTattooKeys = (SCE_TATTOO_KEYS *)ScepAlloc(LPTR,MAX_LOCKOUT_KEYS*sizeof(SCE_TATTOO_KEYS));

            if ( !pTattooKeys ) {
                ScepLogOutput3(1, ERROR_NOT_ENOUGH_MEMORY, SCESRV_POLICY_TATTOO_ERROR_CREATE);
            }
        }

        bFlagSet = FALSE;
        if ( (pScpInfo->LockoutBadCount != SCE_NO_VALUE) ) {

            ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                     (PWSTR)L"LockoutBadCount", ConfigOptions,
                                     (ProductType == NtProductLanManNt) ? SCEDCPOL_LOCK_COUNT : ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutThreshold);

            if ( ( ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutThreshold !=  (USHORT)(pScpInfo->LockoutBadCount) ) ) {


                ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutThreshold =  (USHORT)(pScpInfo->LockoutBadCount);
                bFlagSet = TRUE;

            }
        }

        if ( (pScpInfo->ResetLockoutCount != SCE_NO_VALUE) &&
             ( ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutThreshold >  0 ) ) {

            RegData = (DWORD) (-1 * ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutObservationWindow.QuadPart /
                          (60 * 10000000L) );

            ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                     (PWSTR)L"ResetLockoutCount", ConfigOptions,
                                     (ProductType == NtProductLanManNt) ? SCEDCPOL_LOCK_RESET : RegData);

            if ( RegData != pScpInfo->ResetLockoutCount ) {

                ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutObservationWindow.QuadPart =  -1 *
                                                 (LONGLONG)pScpInfo->ResetLockoutCount * 60 * 10000000L;
                bFlagSet = TRUE;
            }
        }

        if ( ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutThreshold >  0 ) {

            if ( pScpInfo->LockoutDuration != SCE_NO_VALUE ) {

                RegData = (DWORD)(-1 * ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutDuration.QuadPart /
                             (60 * 10000000L) );

                ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                         (PWSTR)L"LockoutDuration", ConfigOptions,
                                         (ProductType == NtProductLanManNt) ? SCEDCPOL_LOCK_DURATION : RegData);

            }

            if ( pScpInfo->LockoutDuration == SCE_FOREVER_VALUE ) {

                if ( ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutDuration.HighPart != MINLONG ||
                     ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutDuration.LowPart != 0 ) {
                    //
                    // forever
                    //

                    ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutDuration.HighPart = MINLONG;
                    ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutDuration.LowPart = 0;
                    bFlagSet = TRUE;

                }

            } else if ( pScpInfo->LockoutDuration != SCE_NO_VALUE ) {

                if ( RegData != pScpInfo->LockoutDuration ) {

                    ((DOMAIN_LOCKOUT_INFORMATION *)Buffer)->LockoutDuration.QuadPart =  -1 *
                                                   (LONGLONG)pScpInfo->LockoutDuration * 60 * 10000000L;
                    bFlagSet = TRUE;

                }
            }
        } else {
            //
            // make sure to delete these two tattoo values if they exist
            //
            ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                     (PWSTR)L"ResetLockoutCount", ConfigOptions,
                                     SCE_NO_VALUE);

            ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                     (PWSTR)L"LockoutDuration", ConfigOptions,
                                     SCE_NO_VALUE);
        }

        if ( bFlagSet ) {
            NtStatus = SamSetInformationDomain(
                       DomainHandle,
                       DomainLockoutInformation,
                       Buffer
                       );
            rc = RtlNtStatusToDosError( NtStatus );
        }
        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
            ( ProductType != NtProductLanManNt ) &&
             pTattooKeys && cTattooKeys ) {

            //
            // even if there is no change
            // we still need to check if some of the tattoo values should be deleted
            //
            ScepLogOutput3(3, 0, SCESRV_POLICY_TATTOO_ARRAY, cTattooKeys);
            //
            // some policy is different than the system setting
            // check if we should save the existing setting as the tattoo value
            // also remove reset'ed tattoo policy
            //
            ScepTattooManageValues(hSectionDomain, hSectionTattoo, pTattooKeys, cTattooKeys, rc);
        }

        if ( pTattooKeys ) {
            ScepFree(pTattooKeys);
            pTattooKeys = NULL;
        }
        cTattooKeys = 0;

        SamFreeMemory(Buffer);

        if ( !NT_SUCCESS( NtStatus ) ) {
            //
            // if error, just log it and continue
            //
            if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {
                ScepBuildErrorLogInfo(
                            rc,
                            pErrLog,
                            SCEDLL_SCP_ERROR_PASSWORD
                            );
            } else {
                ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LOCKOUT);
            }
            SaveStat = rc;
            // goto GETOUT;
        } else if ( bFlagSet ) {
            ScepLogOutput3(1, rc, SCEDLL_SCP_LOCKOUT);
        }
    } else if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

        ScepBuildErrorLogInfo(
                    rc,
                    pErrLog,
                    SCEDLL_ERROR_QUERY_LOCKOUT
                    );
    } else {
        ScepLogOutput3(1, rc, SCEDLL_ERROR_QUERY_LOCKOUT);
    }

    if (ConfigOptions & SCE_RSOP_CALLBACK)

        ScepRsopLog(SCE_RSOP_LOCKOUT_INFO, rc, NULL, 0, 0);

    //
    // Force Logoff when hour expire
    //

    if ( pScpInfo->ForceLogoffWhenHourExpire != SCE_NO_VALUE ) {

        Buffer = NULL;
        NtStatus = SamQueryInformationDomain(
                      DomainHandle,
                      DomainLogoffInformation,
                      &Buffer
                      );

        rc = RtlNtStatusToDosError( NtStatus );

        if ( NT_SUCCESS(NtStatus) ) {

            rc = ERROR_SUCCESS;

            bFlagSet = FALSE;
            RegData = pScpInfo->ForceLogoffWhenHourExpire;

            if ( pScpInfo->ForceLogoffWhenHourExpire == 1 ) { // yes
                if ( ((DOMAIN_LOGOFF_INFORMATION *)Buffer)->ForceLogoff.HighPart != 0 ||
                     ((DOMAIN_LOGOFF_INFORMATION *)Buffer)->ForceLogoff.LowPart != 0 ) {

                    RegData = 0;
                    ((DOMAIN_LOGOFF_INFORMATION *)Buffer)->ForceLogoff.HighPart = 0;
                    ((DOMAIN_LOGOFF_INFORMATION *)Buffer)->ForceLogoff.LowPart = 0;
                    bFlagSet = TRUE;
                }
            } else {
                if ( ((DOMAIN_LOGOFF_INFORMATION *)Buffer)->ForceLogoff.HighPart != MINLONG ||
                     ((DOMAIN_LOGOFF_INFORMATION *)Buffer)->ForceLogoff.LowPart != 0 ) {

                    RegData = 1;
                    ((DOMAIN_LOGOFF_INFORMATION *)Buffer)->ForceLogoff.HighPart = MINLONG;
                    ((DOMAIN_LOGOFF_INFORMATION *)Buffer)->ForceLogoff.LowPart = 0;
                    bFlagSet = TRUE;
                }
            }

            if ( bFlagSet ) {

                NtStatus = SamSetInformationDomain(
                               DomainHandle,
                               DomainLogoffInformation,
                               Buffer
                               );
                rc = RtlNtStatusToDosError( NtStatus );
            }

            if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                ( ProductType != NtProductLanManNt ) ) {

                //
                // some policy is different than the system setting or this is a domain controller
                // check if we should save the existing setting as the tattoo value
                // also remove reset'ed tattoo policy
                //
                ScepTattooManageOneIntValue(hSectionDomain, hSectionTattoo,
                                         (PWSTR)L"ForceLogoffWhenHourExpire",
                                         0,
                                         (ProductType == NtProductLanManNt) ? SCEDCPOL_FORCE_LOGOFF : RegData, rc);

            }
            SamFreeMemory(Buffer);

            if ( !NT_SUCCESS( NtStatus ) ) {

                if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) &&
                     pErrLog ) {

                    ScepBuildErrorLogInfo(
                                rc,
                                pErrLog,
                                SCEDLL_SCP_ERROR_LOGOFF
                                );
                } else {
                    ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LOGOFF);
                }
                SaveStat = rc;
                // goto GETOUT;
            } else {
                ScepLogOutput3(1, rc, SCEDLL_SCP_LOGOFF);
            }

        } else if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

            ScepBuildErrorLogInfo(
                        rc,
                        pErrLog,
                        SCEDLL_ERROR_QUERY_LOGOFF
                        );
        } else {
            ScepLogOutput3(1, rc, SCEDLL_ERROR_QUERY_LOGOFF);
        }

        if (ConfigOptions & SCE_RSOP_CALLBACK)

            ScepRsopLog(SCE_RSOP_LOGOFF_INFO, rc, NULL, 0, 0);

    }

OtherSettings:

    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
         ScepIsSystemShutDown() ) {

        rc = SCESTATUS_SERVICE_NOT_SUPPORT;
        SaveStat = rc;

    } else {

        //
        // Rename Administrator/Guest account
        //

        if ( NULL != pScpInfo->NewAdministratorName ) {

            NtStatus = ScepManageAdminGuestAccounts(DomainHandle,
                                                   pScpInfo->NewAdministratorName,
                                                   0,
                                                   SCE_RENAME_ADMIN,
                                                   ConfigOptions,
                                                   hSectionDomain,
                                                   hSectionTattoo
                                                  );
            rc = RtlNtStatusToDosError(NtStatus);

            if ( NT_SUCCESS( NtStatus ) )
                ScepLogOutput3(0, 0, SCEDLL_SCP_RENAME_ADMIN,
                             pScpInfo->NewAdministratorName );
            else {

                if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) &&
                     pErrLog ) {

                    ScepBuildErrorLogInfo(
                                rc,
                                pErrLog,
                                SCEDLL_SCP_ERROR_ADMINISTRATOR
                                );
                } else {
                    ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_ADMINISTRATOR);
                }

                SaveStat = rc;
                // goto GETOUT;
            }

            if (ConfigOptions & SCE_RSOP_CALLBACK)

                ScepRsopLog(SCE_RSOP_ADMIN_INFO, rc, NULL, 0, 0);
        }

        if ( NULL != pScpInfo->NewGuestName ) {

            NtStatus = ScepManageAdminGuestAccounts(DomainHandle,
                                                   pScpInfo->NewGuestName,
                                                   0,
                                                   SCE_RENAME_GUEST,
                                                   ConfigOptions,
                                                   hSectionDomain,
                                                   hSectionTattoo
                                                  );
            rc = RtlNtStatusToDosError(NtStatus);

            if ( NT_SUCCESS( NtStatus ) ) {
                ScepLogOutput3(0,0, SCEDLL_SCP_RENAME_GUEST,
                             pScpInfo->NewGuestName );
            } else {

                if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) &&
                     pErrLog ) {

                    ScepBuildErrorLogInfo(
                                rc,
                                pErrLog,
                                SCEDLL_SCP_ERROR_GUEST
                                );
                } else {
                    ScepLogOutput3(1,rc, SCEDLL_SCP_ERROR_GUEST);
                }

                SaveStat = rc;
                // goto GETOUT;
            }

            if (ConfigOptions & SCE_RSOP_CALLBACK)

                ScepRsopLog(SCE_RSOP_GUEST_INFO, rc, NULL, 0, 0);
        }

        //
        // LSAAnonymousNameLookup
        //

        if ( pScpInfo->LSAAnonymousNameLookup != SCE_NO_VALUE ) {

            BOOL    bImpliedOldLSAPolicyDifferent = FALSE;
            DWORD   dwImpliedOldLSAAnonymousNameLookup = pScpInfo->LSAAnonymousNameLookup;

            rc = ScepConfigureLSAPolicyObject(
                                             pScpInfo->LSAAnonymousNameLookup,
                                             ConfigOptions,
                                             pErrLog,
                                             &bImpliedOldLSAPolicyDifferent
                                             );

            if (bImpliedOldLSAPolicyDifferent) {
                dwImpliedOldLSAAnonymousNameLookup = (pScpInfo->LSAAnonymousNameLookup ? 0 : 1);
            }

            if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                ( ProductType != NtProductLanManNt ) ) {

                ScepTattooManageOneIntValue(hSectionDomain,
                                            hSectionTattoo,
                                         (PWSTR)L"LSAAnonymousNameLookup",
                                         0,
                                         (ProductType == NtProductLanManNt) ? SCEDCPOL_LSA_ANON_LOOKUP : dwImpliedOldLSAAnonymousNameLookup, rc);

            }

            if ( rc != ERROR_SUCCESS ) {

                SaveStat = rc;

            }
            else {

                ScepLogOutput3(1, 0, SCEDLL_SCP_LSAPOLICY);
            }

            if (ConfigOptions & SCE_RSOP_CALLBACK)

                ScepRsopLog(SCE_RSOP_LSA_POLICY_INFO, rc, NULL, 0, 0);
        }


        //
        // disable admin account
        //

        if ( pScpInfo->EnableAdminAccount != SCE_NO_VALUE ) {

            NtStatus = ScepManageAdminGuestAccounts(DomainHandle,
                                                   NULL,
                                                   (pScpInfo->EnableAdminAccount > 0) ? 0 : 1,
                                                   SCE_DISABLE_ADMIN,
                                                   ConfigOptions,
                                                   hSectionDomain,
                                                   hSectionTattoo
                                                  );
            rc = RtlNtStatusToDosError(NtStatus);

            if ( NT_SUCCESS( NtStatus ) ) {

                ScepLogOutput3(0, 0, pScpInfo->EnableAdminAccount ?
                                SCEDLL_SCP_ENABLE_ADMIN : SCEDLL_SCP_DISABLE_ADMIN);

            } else {

                if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) &&
                     pErrLog ) {

                    ScepBuildErrorLogInfo(
                                rc,
                                pErrLog,
                                SCEDLL_SCP_ERROR_DISABLE_ADMIN
                                );
                } else if ( STATUS_SPECIAL_ACCOUNT == NtStatus ) {

                    ScepLogOutput3(0, 0, SCEDLL_SCP_ADMIN_NOT_ALLOWED);
                } else {
                    ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_DISABLE_ADMIN);
                }

                SaveStat = rc;
                // goto GETOUT;
            }

            if (ConfigOptions & SCE_RSOP_CALLBACK)

                ScepRsopLog(SCE_RSOP_DISABLE_ADMIN_INFO, rc, NULL, 0, 0);
        }

        //
        // disable guest account
        //

        if ( pScpInfo->EnableGuestAccount != SCE_NO_VALUE ) {

            NtStatus = ScepManageAdminGuestAccounts(DomainHandle,
                                                   NULL,
                                                   (pScpInfo->EnableGuestAccount > 0) ? 0 : 1,
                                                   SCE_DISABLE_GUEST,
                                                   ConfigOptions,
                                                   hSectionDomain,
                                                   hSectionTattoo
                                                  );
            rc = RtlNtStatusToDosError(NtStatus);

            if ( NT_SUCCESS( NtStatus ) ) {

                    ScepLogOutput3(0, 0, pScpInfo->EnableGuestAccount ?
                                    SCEDLL_SCP_ENABLE_GUEST : SCEDLL_SCP_DISABLE_GUEST);

            } else {

                if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) &&
                     pErrLog ) {

                    ScepBuildErrorLogInfo(
                                rc,
                                pErrLog,
                                SCEDLL_SCP_ERROR_DISABLE_GUEST
                                );
                } else if ( STATUS_SPECIAL_ACCOUNT == NtStatus ) {
                    ScepLogOutput3(0, 0, SCEDLL_SCP_GUEST_NOT_ALLOWED);
                } else {
                    ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_DISABLE_GUEST);
                }

                SaveStat = rc;
                // goto GETOUT;
            }

            if (ConfigOptions & SCE_RSOP_CALLBACK)

                ScepRsopLog(SCE_RSOP_DISABLE_GUEST_INFO, rc, NULL, 0, 0);
        }
    }

    //
    // Other Registry Key Values
    //
    bFlagSet = FALSE;

    if ( bFlagSet && rc == NO_ERROR )
        ScepLogOutput3(1, rc, SCEDLL_SCP_OTHER_POLICY);


    if ( hSectionDomain ) SceJetCloseSection( &hSectionDomain, TRUE );
    if ( hSectionTattoo ) SceJetCloseSection( &hSectionTattoo, TRUE );

    //
    // Clear out memory and return
    //

    SamCloseHandle( DomainHandle );
    SamCloseHandle( ServerHandle );
    if ( DomainSid != NULL )
        SamFreeMemory(DomainSid);

    if ( SaveStat == ERROR_SUCCESS )
        SaveStat = PendingRc;

    return(ScepDosErrorToSceStatus(SaveStat));
}



NTSTATUS
ScepManageAdminGuestAccounts(
    IN SAM_HANDLE DomainHandle,
    IN PWSTR      NewName,
    IN DWORD      DisableFlag,
    IN DWORD      AccountType,
    IN DWORD      ConfigOptions,
    IN PSCESECTION hSectionDomain OPTIONAL,
    IN PSCESECTION hSectionTattoo OPTIONAL
    )
/* ++
Routine Description:

   This routine renames the specified account's name to the new account name
   in the account domain.

Arguments:

   DomainHandle - The account domain handle

   NewName      - New account name to rename to

   AccountType  - indicate it is Administrator account or Guest account
                     SCE_RENAME_ADMIN
                     SCE_RENAME_GUEST
                     SCE_DISABLE_ADMIN
                     SCE_DISABLE_GUEST

Return value:

   NTSTATUS error codes

-- */
{
   SAM_HANDLE UserHandle1=NULL;
   USER_NAME_INFORMATION Buffer1, *Buffer=NULL;
   PVOID pInfoBuffer=NULL;
   USER_CONTROL_INFORMATION *pControlBuffer=NULL;
   NTSTATUS NtStatus;
   ULONG UserId;
   PWSTR TempStr=NULL;
   DWORD cb;
   PWSTR KeyName;
   BOOL bDisable = FALSE;


   //
   // find the right userid for the account
   //

   switch ( AccountType ) {
   case SCE_RENAME_ADMIN:
       UserId = DOMAIN_USER_RID_ADMIN;
       KeyName = (PWSTR)L"NewAdministratorName";
       break;
   case SCE_RENAME_GUEST:
       UserId = DOMAIN_USER_RID_GUEST;
       KeyName = (PWSTR)L"NewGuestName";
       break;
   case SCE_DISABLE_ADMIN:
       UserId = DOMAIN_USER_RID_ADMIN;
       KeyName = (PWSTR)L"EnableAdminAccount";
       bDisable = TRUE;
       break;
   case SCE_DISABLE_GUEST:
       UserId = DOMAIN_USER_RID_GUEST;
       KeyName = (PWSTR)L"EnableGuestAccount";
       bDisable = TRUE;
       break;
   default:
       return(STATUS_INVALID_PARAMETER);
   }

   NtStatus = SamOpenUser(
                 DomainHandle,
                 MAXIMUM_ALLOWED, //USER_ALL_ACCESS,
                 UserId,
                 &UserHandle1
                 );

   if ( NT_SUCCESS( NtStatus ) ) {

       NtStatus = SamQueryInformationUser(
                     UserHandle1,
                     bDisable? UserControlInformation : UserNameInformation,
                     &pInfoBuffer
                     );

       if ( NT_SUCCESS( NtStatus ) ) {

           if ( bDisable ) {
               //
               // disable the accounts
               //
               pControlBuffer = (USER_CONTROL_INFORMATION *)pInfoBuffer;

               if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                    hSectionDomain && hSectionTattoo &&
                    (ProductType != NtProductLanManNt) ) {
                   //
                   // do not save tattoo value of account controls for domain controllers
                   //
                   ScepTattooManageOneIntValue(hSectionDomain, hSectionTattoo,
                                                  KeyName, 0,
                                                  (pControlBuffer->UserAccountControl & USER_ACCOUNT_DISABLED) ? 0 : 1,
                                                  RtlNtStatusToDosError(NtStatus)
                                                 );
               }
               //
               // compare the control flag with existing flag
               // if it's different, set the new flag to the system
               //
               if ( DisableFlag != (pControlBuffer->UserAccountControl & USER_ACCOUNT_DISABLED) ) {

                   pControlBuffer->UserAccountControl &= ~USER_ACCOUNT_DISABLED;
                   pControlBuffer->UserAccountControl |= DisableFlag;

                   NtStatus = SamSetInformationUser(
                                 UserHandle1,
                                 UserControlInformation,
                                 (PVOID)pControlBuffer
                                 );

               }

           } else {
               //
               // rename the accounts
               //
               Buffer = (USER_NAME_INFORMATION *)pInfoBuffer;

               if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                    hSectionDomain && hSectionTattoo &&
                    (ProductType != NtProductLanManNt) ) {
                   //
                   // do not save off account names for domain controllers
                   //
                   ScepTattooManageOneStringValue(hSectionDomain, hSectionTattoo,
                                                  KeyName, 0,
                                                  Buffer->UserName.Buffer,
                                                  Buffer->UserName.Length/sizeof(WCHAR),
                                                  RtlNtStatusToDosError(NtStatus)
                                                 );
               }
               //
               // compare the new name with existing name
               // if it's different, set the new name to the system
               //
               if ( (Buffer->UserName.Length/sizeof(WCHAR) != wcslen(NewName)) ||
                    (_wcsnicmp(NewName, Buffer->UserName.Buffer, Buffer->UserName.Length/sizeof(WCHAR)) != 0) ) {

                   //
                   // keep the full name and copy the new account name to username field
                   //
                   cb = Buffer->FullName.Length+2;
                   TempStr = (PWSTR)ScepAlloc( (UINT)0, cb);
                   if ( TempStr == NULL ) {
                       NtStatus = STATUS_NO_MEMORY;
                   } else {
                       RtlMoveMemory( TempStr, Buffer->FullName.Buffer, cb );
                       RtlCreateUnicodeString(&(Buffer1.FullName), TempStr);
                       RtlCreateUnicodeString(&(Buffer1.UserName), NewName );

                       NtStatus = SamSetInformationUser(
                                     UserHandle1,
                                     UserNameInformation,
                                     (PVOID)&Buffer1
                                     );

                       RtlFreeUnicodeString( &(Buffer1.FullName) );
                       RtlFreeUnicodeString( &(Buffer1.UserName) );
                       ScepFree(TempStr);

                   }
               }
           }
       }
       SamFreeMemory(pInfoBuffer);
       SamCloseHandle( UserHandle1 );
   }

   return( NtStatus );

}


SCESTATUS
ScepConfigurePrivileges(
    IN OUT PSCE_PRIVILEGE_VALUE_LIST *ppPrivilegeAssigned,
    IN BOOL bCreateBuiltinAccount,
    IN DWORD Options,
    IN OUT PSCEP_SPLAY_TREE pIgnoreAccounts OPTIONAL
    )
/* ++

Routine Description:

   This routine configure the system security in the area of user privilege/rights.

Arguments:

   ppPrivilegeAssigned - The address of the pointer to a list of user privilege/rights as
                        specified in the SCP inf file.
                        Note, account in the list is a pointer to SID.

   bCreateBuiltinAccount - if TRUE, builtin accounts (server ops, account ops, print ops,
                           power users) will be created if they don't exist

   Options - configuration options

   pIgnoreAccounts - the accounts to ignore in configuration (because of pending notifications)

Return value:

   SCESTATUS_SUCCESS
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER
   SCESTATUS_OTHER_ERROR

-- */
{

    DWORD                           rc;
    DWORD                           PrivLowMask=0;
    DWORD                           PrivHighMask=0;

    if ( !ppPrivilegeAssigned ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // get privilege mask from the template
    //
    rc = ScepGetPrivilegeMask(hProfile,
                              (Options & SCE_POLICY_TEMPLATE) ? SCE_ENGINE_SCP :SCE_ENGINE_SMP,
                              &PrivLowMask,
                              &PrivHighMask
                             );

    if ( (rc != ERROR_SUCCESS) && (PrivLowMask == 0) && (PrivHighMask == 0) ) {
        //
        // it's likely not possible to fail here because
        // the previous GetPrivileges succeeded.
        // but if it failed, just return.
        //
        return(rc);
    }

    rc = ScepConfigurePrivilegesWithMask(ppPrivilegeAssigned,
                                         bCreateBuiltinAccount,
                                         Options,
                                         PrivLowMask,
                                         PrivHighMask,
                                         NULL,
                                         pIgnoreAccounts
                                         );

    return(rc);
}


SCESTATUS
ScepConfigurePrivilegesWithMask(
    IN OUT PSCE_PRIVILEGE_VALUE_LIST *ppPrivilegeAssigned,
    IN BOOL bCreateBuiltinAccount,
    IN DWORD Options,
    IN DWORD LowMask,
    IN DWORD HighMask,
    IN OUT PSCE_ERROR_LOG_INFO *pErrLog OPTIONAL,
    IN OUT PSCEP_SPLAY_TREE pIgnoreAccounts OPTIONAL
    )
/* ++

Routine Description:

   This routine configure the system security in the area of user privilege/rights.

Arguments:

   ppPrivilegeAssigned - The address of the pointer to a list of user privilege/rights as
                        specified in the SCP inf file.
                        Note, account in the list is a pointer to SID.

   bCreateBuiltinAccount - if TRUE, builtin accounts (server ops, account ops, print ops,
                           power users) will be created if they don't exist

   Options - configuration options

   PrivLowMask - the privileges (mask) to configure

   PrivHighMask - more privileges (mask) to configure

   pErrLog - output error info

   pIgnoreAccounts - the accounts to ignore in configuration (because of pending notifications)


Return value:

   SCESTATUS_SUCCESS
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER
   SCESTATUS_OTHER_ERROR

-- */
{

    TCHAR                           MsgBuf[256];
    DWORD                           rc=ERROR_SUCCESS;
    DWORD                           SaveStat=NO_ERROR;
    DWORD                           PendingRc=NO_ERROR;
    NTSTATUS                        NtStatus;

    LSA_HANDLE                      PolicyHandle=NULL;
    BYTE                            SidBuffer[256];
    PSID                            AccountSid=NULL;
    DWORD                           SidLength;
    SID_NAME_USE                    UserType;
    DWORD                           DomainLength;

    PSCE_PRIVILEGE_VALUE_LIST       pPrivilege;
    DWORD                           nPrivCount=0;
    PSCE_PRIVILEGE_VALUE_LIST       pRemAccounts=NULL;
    PWSTR StringSid=NULL;

    DWORD ConfigStatus[64];
    DWORD DonePrivLowMask=0;
    DWORD DonePrivHighMask=0;
    DWORD PrivLowMask=0;
    DWORD PrivHighMask=0;

    if ( !ppPrivilegeAssigned ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // user privilege/rights -- LSA Server
    // open the lsa policy first
    //

    //
    // since client RSOP logging side uses test-and-set for success/failure, the first error (if any)for
    // a particular privilege will always be seen
    //

    if ( (Options & SCE_POLICY_TEMPLATE) &&
         ScepIsSystemShutDown() ) {

        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    if ( (Options & SCE_POLICY_TEMPLATE) && LsaPrivatePolicy ) {

        PolicyHandle = LsaPrivatePolicy;

        if ( !ScepSplayTreeEmpty(pIgnoreAccounts) )
            ScepNotifyLogPolicy(0, FALSE, L"Configuration will ignore pending notified accounts", 0, 0, NULL );
        else
            ScepNotifyLogPolicy(0, FALSE, L"No pending notified accounts", 0, 0, NULL );

    } else {

        NtStatus = ScepOpenLsaPolicy(
                        MAXIMUM_ALLOWED, //GENERIC_ALL,
                        &PolicyHandle,
                        (Options & ( SCE_POLICY_TEMPLATE | SCE_SYSTEM_DB) ) ? TRUE : FALSE // do not notify policy filter if within policy prop
                        );
        if (NtStatus != ERROR_SUCCESS) {

             rc = RtlNtStatusToDosError( NtStatus );

             if ( (Options & SCE_SYSTEM_SETTINGS) && pErrLog ) {
                 ScepBuildErrorLogInfo(
                         rc,
                         pErrLog,
                         SCEDLL_LSA_POLICY
                         );
             } else {

                 ScepLogOutput3(1, rc, SCEDLL_LSA_POLICY);
             }

             SaveStat = rc;
             goto Done;
        }
    }

    AccountSid = (PSID)SidBuffer;

    ScepIsDomainLocal(NULL);

    PrivLowMask = LowMask;
    PrivHighMask = HighMask;

    //
    // make sure Authenticated Users, Everyone and Enterprise Controllers have appropriate rights
    // ignore any error occurred
    //

    (void)ScepCheckNetworkLogonRights(PolicyHandle,
                                      &PrivLowMask,
                                      &PrivHighMask,
                                      ppPrivilegeAssigned);

    //
    // save the old privilege settings
    //
    if ( (Options & SCE_POLICY_TEMPLATE) &&
         ( ProductType != NtProductLanManNt ) ) {

        ScepTattooSavePrivilegeValues(hProfile, PolicyHandle,
                                      PrivLowMask, PrivHighMask,
                                      Options
                                     );
        // initialize
        for ( int i=0;i<64;i++) ConfigStatus[i] = (DWORD)-1;

    }

    //
    // other area accounts to remove for the privilege mask
    //

    NtStatus = ScepBuildAccountsToRemove(
                           PolicyHandle,
                           PrivLowMask,           // the privileges to look up
                           PrivHighMask,
                           SCE_BUILD_IGNORE_UNKNOWN | SCE_BUILD_ACCOUNT_SID,
                           *ppPrivilegeAssigned, // accounts in the template already
                           Options,
                           pIgnoreAccounts,
                           &pRemAccounts       // accounts to remove
                           );

    if ( (Options & SCE_POLICY_TEMPLATE) &&
         (NtStatus == STATUS_PENDING) ) {

        // this error is to make sure that policy propagation will be invoked again
        ScepLogOutput3(0,0, SCESRV_POLICY_PENDING_REMOVE_RIGHTS);

        PendingRc = ERROR_IO_PENDING;
        NtStatus = STATUS_SUCCESS;
    }

    if ( NT_SUCCESS(NtStatus) && pRemAccounts ) {
        //
        // remove user rights for the accounts first
        //

        for (pPrivilege = pRemAccounts;
             pPrivilege != NULL;
             pPrivilege = pPrivilege->Next ) {

            if ( pPrivilege->PrivLowPart == 0 &&
                 pPrivilege->PrivHighPart == 0 ) {
                continue;
            }
            //
            // Note: even though it's an invalid account SID,
            // we still should remove it from the system
            // because this account is enumerated from current system.
            //
/*
            if ( !ScepValidSid( (PSID)(pPrivilege->Name) ) ) {
                continue;
            }
*/
            //
            // get the user/group sid string (to display)
            //
            ConvertSidToStringSid( (PSID)(pPrivilege->Name), &StringSid );

            if ( !(Options & SCE_SYSTEM_SETTINGS) ) {

                //
                // lookup for the user/group name. If it does not exist
                // log an error and continue ? (or stop ?)
                //
                ScepLogOutput3(0,0, SCEDLL_SCP_CONFIGURE, StringSid ? StringSid : L"SID");

                if ( (Options & SCE_POLICY_TEMPLATE) &&
                     ScepIsSystemShutDown() ) {

                    SaveStat = ERROR_NOT_SUPPORTED;
                    break;
                }
            }

            DonePrivHighMask |= (pPrivilege->PrivHighPart & PrivHighMask);
            DonePrivLowMask |= (pPrivilege->PrivLowPart & PrivLowMask);

            //
            // remove the rights
            //
            NtStatus = ScepAddOrRemoveAccountRights(
                            PolicyHandle,
                            (PSID)(pPrivilege->Name),
                            FALSE,
                            pPrivilege->PrivLowPart & PrivLowMask,
                            pPrivilege->PrivHighPart & PrivHighMask
                            );

            rc = RtlNtStatusToDosError( NtStatus );

            if ( !NT_SUCCESS(NtStatus) ) {

                if ( (Options & SCE_SYSTEM_SETTINGS) && pErrLog ) {
                    ScepBuildErrorLogInfo(
                            rc,
                            pErrLog,
                            SCEDLL_SCP_ERROR_CONFIGURE,
                            StringSid ? StringSid : L"SID"
                            );
                } else {

                    ScepLogOutput3(1,rc,SCEDLL_SCP_ERROR_CONFIGURE,
                                   StringSid ? StringSid : L"SID");
                }

                // update the tattoo status array
                if ( (Options & SCE_POLICY_TEMPLATE) &&
                     ( ProductType != NtProductLanManNt ) ) {

                    ScepTattooUpdatePrivilegeArrayStatus(ConfigStatus,
                                                         rc,
                                                         pPrivilege->PrivLowPart & PrivLowMask,
                                                         pPrivilege->PrivHighPart & PrivHighMask
                                                        );
                }

                SaveStat = rc;

                if ( Options & SCE_RSOP_CALLBACK){

                    ScepRsopLog(SCE_RSOP_PRIVILEGE_INFO,
                                rc,
                                NULL,
                                pPrivilege->PrivLowPart & PrivLowMask,
                                pPrivilege->PrivHighPart & PrivHighMask);
                }
            }
            else if (Options & SCE_RSOP_CALLBACK) {

                // success - has to be logged because some privilege may want to remove all accounts and
                // processing is over at this point for such privileges

                ScepRsopLog(SCE_RSOP_PRIVILEGE_INFO,
                            rc,
                            NULL,
                            pPrivilege->PrivLowPart & PrivLowMask,
                            pPrivilege->PrivHighPart & PrivHighMask);

            }


            if ( StringSid ) {
                LocalFree(StringSid);
                StringSid = NULL;
            }
        }
    } else if ( !NT_SUCCESS(NtStatus) &&
                ( ProductType != NtProductLanManNt ) ) {
        //
        // fail to get the accounts to remove
        // in this case, do not remove any tattoo value
        //
        ScepTattooUpdatePrivilegeArrayStatus(ConfigStatus,
                                             RtlNtStatusToDosError(NtStatus),
                                             PrivLowMask,
                                             PrivHighMask
                                            );
    }

    //
    // free the remove account list
    //
    ScepFreePrivilegeValueList(pRemAccounts);

    if ( (Options & SCE_POLICY_TEMPLATE) &&
         ScepIsSystemShutDown() ) {

        SaveStat = ERROR_NOT_SUPPORTED;

    } else {

        for (pPrivilege = *ppPrivilegeAssigned;
             pPrivilege != NULL;
             pPrivilege = pPrivilege->Next ) {

            if ( !(Options & SCE_SYSTEM_SETTINGS) ) {

                if ( (Options & SCE_POLICY_TEMPLATE) &&
                     ScepIsSystemShutDown() ) {

                    SaveStat = ERROR_NOT_SUPPORTED;
                    break;
                }
            }

            //
            // remember the privileges we touched here
            //
            DonePrivHighMask |= pPrivilege->PrivHighPart;
            DonePrivLowMask |= pPrivilege->PrivLowPart;

            //
            // note, this list may contain SID or name (when name can't
            // be mapped to SID, such as in dcpromo case)
            // so both name and SID must be handled here.
            // lookup for the user/group name. If it does not exist
            // log an error and continue ? (or stop ?)
            //

            if ( ScepValidSid( (PSID)(pPrivilege->Name) ) ) {
                //
                // get the user/group sid string (to display)
                //
                ConvertSidToStringSid( (PSID)(pPrivilege->Name), &StringSid );

                if ( !(Options & SCE_SYSTEM_SETTINGS) &&
                     (nPrivCount < TICKS_PRIVILEGE) ) {

                    //
                    // only post maximum TICKS_PRIVILEGE ticks because that's the number
                    // remembers in the total ticks
                    //

                    ScepPostProgress(1, AREA_PRIVILEGES, StringSid);
                    nPrivCount++;
                }

                ScepLogOutput3(0,0, SCEDLL_SCP_CONFIGURE, StringSid ? StringSid : L"SID");

                //
                // check if this account should be ignored
                //
                NtStatus = STATUS_SUCCESS;

                if ( (Options & SCE_POLICY_TEMPLATE) ) {

                    if ( ScepSplayValueExist( (PVOID)(pPrivilege->Name), pIgnoreAccounts) ) {
                        //
                        // this one should be ingored in this policy prop
                        //
                        NtStatus = STATUS_PENDING;
                        rc = ERROR_IO_PENDING;

                        ScepLogOutput3(1, 0, SCESRV_POLICY_PENDING_RIGHTS, StringSid ? StringSid : L"SID");
/*
                    } else {

                        ScepLogOutput2(1, 0, L"%s will be configured.", StringSid ? StringSid : L"SID");
*/                  }
                }

                if ( NT_SUCCESS(NtStatus) && (STATUS_PENDING != NtStatus) ) {

                    NtStatus = ScepAdjustAccountPrivilegesRights(
                                        PolicyHandle,
                                        (PSID)(pPrivilege->Name),
                                        pPrivilege->PrivLowPart,
                                        PrivLowMask,
                                        pPrivilege->PrivHighPart,
                                        PrivHighMask,
                                        Options
                                        );
                    rc = RtlNtStatusToDosError( NtStatus );
                }

                if ( !NT_SUCCESS(NtStatus) || (STATUS_PENDING == NtStatus) ) {

                    if ( (Options & SCE_SYSTEM_SETTINGS) && pErrLog ) {
                        ScepBuildErrorLogInfo(
                                rc,
                                pErrLog,
                                SCEDLL_SCP_ERROR_CONFIGURE,
                                StringSid ? StringSid : L"SID"
                                );

                    } else if ( STATUS_PENDING != NtStatus) {

                        ScepLogOutput3(1, rc,
                                       SCEDLL_SCP_ERROR_CONFIGURE,
                                       StringSid ? StringSid : L"SID");
                    }

                    if ( ERROR_IO_PENDING == rc )
                        PendingRc = rc;
                    else
                        SaveStat = rc;

                    // update tattoo status array
                    if ( (Options & SCE_POLICY_TEMPLATE) &&
                        ( ProductType != NtProductLanManNt ) ) {

                        ScepTattooUpdatePrivilegeArrayStatus(ConfigStatus,
                                                             rc,
                                                             pPrivilege->PrivLowPart,
                                                             pPrivilege->PrivHighPart
                                                            );
                    }
                }

                if ( StringSid ) {
                    LocalFree(StringSid);
                    StringSid = NULL;
                }

            } else if (Options & SCE_SYSTEM_SETTINGS ) {
                //
                // if work on system settings directly, the buffer must contain
                // a SID. If not, it's an error
                //
                if ( pErrLog ) {
                    ScepBuildErrorLogInfo(
                        ERROR_NONE_MAPPED,
                        pErrLog,
                        SCEDLL_INVALID_GROUP,
                        pPrivilege->Name
                        );
                }

                if ( Options & SCE_RSOP_CALLBACK ){

                    ScepRsopLog(SCE_RSOP_PRIVILEGE_INFO,
                                ERROR_NONE_MAPPED,
                                NULL,
                                pPrivilege->PrivLowPart,
                                pPrivilege->PrivHighPart);
                }

            } else {

                if ( !(Options & SCE_SYSTEM_SETTINGS) &&
                     (nPrivCount < TICKS_PRIVILEGE) ) {

                    //
                    // only post maximum TICKS_PRIVILEGE ticks because that's the number
                    // remembers in the total ticks
                    //

                    ScepPostProgress(1, AREA_PRIVILEGES, pPrivilege->Name);
                    nPrivCount++;
                }

                ScepLogOutput3(0,0, SCEDLL_SCP_CONFIGURE, pPrivilege->Name);

                SidLength=256;
                DomainLength=256;
                MsgBuf[0] = L'\0';

                rc = ERROR_SUCCESS;

                if ( wcschr(pPrivilege->Name, L'\\') == NULL ) {
                    //
                    // isolated accounts can't be resolved when reading the configuration
                    // no need to try now.
                    //
                    rc = ERROR_NONE_MAPPED;

                } else if ( !LookupAccountName(
                               NULL,
                               pPrivilege->Name,
                               AccountSid,
                               &SidLength,
                               MsgBuf,
                               &DomainLength,
                               &UserType
                               )) {

                    rc = GetLastError();
                }

                if ( ERROR_SUCCESS != rc && bCreateBuiltinAccount ) {

                    //
                    // builtin accounts should be created here
                    //
                    rc = ScepCreateBuiltinAccountInLsa(
                                    PolicyHandle,
                                    pPrivilege->Name,
                                    AccountSid
                                    );


                }

                if ( ERROR_SUCCESS != rc ) {

                    ScepLogOutput3(1, rc, SCEDLL_CANNOT_FIND, pPrivilege->Name);

                    if ( Options & SCE_RSOP_CALLBACK){

                        ScepRsopLog(SCE_RSOP_PRIVILEGE_INFO,
                                    rc,
                                    NULL,
                                    pPrivilege->PrivLowPart,
                                    pPrivilege->PrivHighPart);
                    }

                    //
                    // for accounts not mapped in the tattoo value
                    // ignore them so that the tattoo value can be removed
                    // update tattoo status array
                    if ( (Options & SCE_POLICY_TEMPLATE) &&
                        ( ProductType != NtProductLanManNt ) ) {

                        ScepTattooUpdatePrivilegeArrayStatus(ConfigStatus,
                                                             0, // rc, see comment above
                                                             pPrivilege->PrivLowPart,
                                                             pPrivilege->PrivHighPart
                                                            );
                    }

                    if ( ERROR_TRUSTED_RELATIONSHIP_FAILURE == rc ) {
                        //
                        // this error is only returned when the name
                        // can't be found locally and trust relationship
                        // is broken on the domain
                        //
                        // for policy propagation, this failure is the same
                        // as account not found (locally).
                        //
                        rc = ERROR_NONE_MAPPED;
                    }

                    SaveStat = rc;

                    continue;
                }

                //
                // check if the account should be ignored
                //
                NtStatus = STATUS_SUCCESS;

                if ( (Options & SCE_POLICY_TEMPLATE) ) {

                    if ( ScepSplayValueExist( (PVOID)AccountSid, pIgnoreAccounts) ) {
                        //
                        // this one should be ingored in this policy prop
                        //
                        NtStatus = STATUS_PENDING;
                        rc = ERROR_IO_PENDING;

                        ScepLogOutput3(1, 0, SCESRV_POLICY_PENDING_RIGHTS, pPrivilege->Name);
/*
                    } else {

                        ScepLogOutput2(1, 0, L"%s will be configured.", pPrivilege->Name);
*/                  }
                }

                if ( NT_SUCCESS(NtStatus) && (NtStatus != STATUS_PENDING) ) {

                    NtStatus = ScepAdjustAccountPrivilegesRights(
                                        PolicyHandle,
                                        AccountSid,
                                        pPrivilege->PrivLowPart,
                                        PrivLowMask,
                                        pPrivilege->PrivHighPart,
                                        PrivHighMask,
                                        Options
                                        );
                    rc = RtlNtStatusToDosError( NtStatus );

                }

                if ( !NT_SUCCESS(NtStatus) || (NtStatus == STATUS_PENDING) ) {

                    if ( STATUS_PENDING != NtStatus ) {
                        ScepLogOutput3(1, rc,
                                       SCEDLL_SCP_ERROR_CONFIGURE,
                                       pPrivilege->Name);
                        SaveStat = rc;

                    } else
                        PendingRc = rc;

                    if ( (Options & SCE_POLICY_TEMPLATE) &&
                        ( ProductType != NtProductLanManNt ) ) {

                        ScepTattooUpdatePrivilegeArrayStatus(ConfigStatus,
                                                             rc,
                                                             pPrivilege->PrivLowPart,
                                                             pPrivilege->PrivHighPart
                                                            );
                    }

                    // goto Done;
                    continue;
                }
            }

            //
            // at this point, if rc == ERROR_SUCCESS we should log all privs concerned with this acct
            //
            if ( rc == ERROR_SUCCESS &&
                 (Options & SCE_RSOP_CALLBACK) ){

                ScepRsopLog(SCE_RSOP_PRIVILEGE_INFO,
                            rc,
                            NULL,
                            pPrivilege->PrivLowPart,
                            pPrivilege->PrivHighPart);
            }

        }
    }

Done:

    if ( StringSid ) {
        LocalFree(StringSid);
    }

    if ( !(Options & SCE_SYSTEM_SETTINGS) &&
         (nPrivCount < TICKS_PRIVILEGE) ) {

        ScepPostProgress(TICKS_PRIVILEGE-nPrivCount,
                         AREA_PRIVILEGES, NULL);
    }

    if ( SaveStat == ERROR_SUCCESS ) SaveStat = PendingRc;

    if ( (Options & SCE_POLICY_TEMPLATE) &&
        ( ProductType != NtProductLanManNt ) ) {

        ScepTattooUpdatePrivilegeArrayStatus(ConfigStatus,
                                             0,
                                             DonePrivLowMask,
                                             DonePrivHighMask
                                            );
        if ( SaveStat == ERROR_SUCCESS ) {
            //
            // make sure all privileges are covered
            //
            ScepTattooUpdatePrivilegeArrayStatus(ConfigStatus,
                                                 0,
                                                 PrivLowMask,
                                                 PrivHighMask
                                                );
        }

        ScepTattooRemovePrivilegeValues(hProfile,
                                        ConfigStatus
                                       );

    }

    if ( PolicyHandle != LsaPrivatePolicy )
        LsaClose(PolicyHandle);

    return( ScepDosErrorToSceStatus(SaveStat) );

}


SCESTATUS
ScepGetPrivilegeMask(
    IN PSCECONTEXT hProfile,
    IN SCETYPE ProfileType,
    OUT PDWORD pdLowMask,
    OUT PDWORD pdHighMask
    )
{
    SCESTATUS      rc;
    PSCESECTION    hSection=NULL;
    DWORD          nLowMask, nHighMask;
    DWORD          i;


    if ( !hProfile || !pdHighMask || !pdLowMask ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // open the section
    //
    rc = ScepOpenSectionForName(
            hProfile,
            ProfileType,
            szPrivilegeRights,
            &hSection
            );

    if ( rc != SCESTATUS_SUCCESS ) {
        ScepLogOutput3( 1,
                        ScepSceStatusToDosError(rc),
                        SCEERR_OPEN,
                        (LPTSTR)szPrivilegeRights
                      );
        return(rc);
    }

    nLowMask = 0;
    nHighMask = 0;
    for ( i=0; i<cPrivCnt; i++) {

        rc = SceJetSeek(
                hSection,
                SCE_Privileges[i].Name,
                wcslen(SCE_Privileges[i].Name)*sizeof(WCHAR),
                SCEJET_SEEK_EQ_NO_CASE
                );

        if ( SCESTATUS_SUCCESS == rc ) {

            if ( i < 32 ) {

                nLowMask |= (1 << i );
            } else {
                nHighMask |= (1 << ( i-32 ) );
            }
        }
    }


    //
    // close the section
    //
    SceJetCloseSection( &hSection, TRUE );

    *pdLowMask = nLowMask;
    *pdHighMask = nHighMask;

    return(SCESTATUS_SUCCESS);
}

DWORD
ScepCreateBuiltinAccountInLsa(
    IN LSA_HANDLE PolicyHandle,
    IN LPTSTR AccountName,
    OUT PSID AccountSid
    )
{
    DWORD rc;
    WCHAR              szTempString[256];
    ULONG              Rid;

    if ( !PolicyHandle || !AccountName || !AccountSid ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // figure out which constant SID to build
    //

    Rid = 0;
    szTempString[0] = L'\0';

    LoadString( MyModuleHandle,
                SCESRV_ALIAS_NAME_SERVER_OPS,
                szTempString,
                256
                );
    if ( _wcsicmp(AccountName, szTempString) == 0 ) {
        //
        // it's server operators
        //
        Rid = DOMAIN_ALIAS_RID_SYSTEM_OPS;

    } else {

        szTempString[0] = L'\0';

        LoadString( MyModuleHandle,
                    SCESRV_ALIAS_NAME_ACCOUNT_OPS,
                    szTempString,
                    256
                    );
        if ( _wcsicmp(AccountName, szTempString) == 0 ) {
            //
            // it's account operators
            //
            Rid = DOMAIN_ALIAS_RID_ACCOUNT_OPS;

        } else {

            szTempString[0] = L'\0';

            LoadString( MyModuleHandle,
                        SCESRV_ALIAS_NAME_PRINT_OPS,
                        szTempString,
                        256
                        );

            if ( _wcsicmp(AccountName, szTempString) == 0 ) {
                //
                // it's print operators
                //
                Rid = DOMAIN_ALIAS_RID_PRINT_OPS;
            }
        }
    }

    if ( Rid ) {
        //
        // if found the account, build the SID
        // create the account in lsa database and return the SID
        //
        SID_IDENTIFIER_AUTHORITY sidBuiltinAuthority = SECURITY_NT_AUTHORITY;
        NTSTATUS           NtStatus;

        NtStatus = RtlInitializeSid( AccountSid, &sidBuiltinAuthority, 2 );

        if ( NT_SUCCESS(NtStatus) ) {

            *(RtlSubAuthoritySid(AccountSid, 0)) = SECURITY_BUILTIN_DOMAIN_RID;
            *(RtlSubAuthoritySid(AccountSid, 1)) = Rid;

            //
            // create the account in Lsa
            //
            LSA_HANDLE AccountHandle=NULL;

            NtStatus = LsaCreateAccount(PolicyHandle,
                                        AccountSid,
                                        ACCOUNT_ALL_ACCESS,
                                        &AccountHandle
                                        );
            if ( STATUS_OBJECT_NAME_EXISTS == NtStatus ||
                 STATUS_OBJECT_NAME_COLLISION == NtStatus ) {
                NtStatus = STATUS_SUCCESS;
            }

            rc = RtlNtStatusToDosError(NtStatus);

            if ( AccountHandle ) {
                LsaClose(AccountHandle);
            }

        } else {

            rc = RtlNtStatusToDosError(NtStatus);
        }

        ScepLogOutput3(3,rc, SCESRV_ALIAS_CREATE, Rid);

    } else {

        rc = ERROR_NONE_MAPPED;
        ScepLogOutput3(3,0, SCESRV_ALIAS_UNSUPPORTED, AccountName);
    }

    return(rc);
}


NTSTATUS
ScepBuildAccountsToRemove(
    IN LSA_HANDLE PolicyHandle,
    IN DWORD PrivLowMask,
    IN DWORD PrivHighMask,
    IN DWORD dwBuildRule,
    IN PSCE_PRIVILEGE_VALUE_LIST pTemplateList OPTIONAL,
    IN DWORD Options OPTIONAL,
    IN OUT PSCEP_SPLAY_TREE pIgnoreAccounts OPTIONAL,
    OUT PSCE_PRIVILEGE_VALUE_LIST *pRemoveList
    )
/*
Routine Description:

    Build a list of accounts which are not in pTemplateList for the privilege(s)
.

    Note, the account(s) returned are in SID format when dwBuildRule requests
    SCE_BUILD_ACCOUNT_SID, or in name format if the flag is not set.

    The reason to return all name format (instead of name/SID string format) is due
    to the default templates (defltdc.inf, dcup.inf) use names instead of SID string
    for account domain accounts (such as the guest account). Even if a sid string
    is used, the sid string and the account name will be treated as two different
    accounts, which will be eventually duplicated out in configuration (where
    account SID is used).

*/
{
    //
    // LSA buffers and variables
    //

    ULONG   uAccountIndex = 0;
    ULONG   uCountOfRights = 0;
    DWORD   dwPrivLowThisAccount = 0;
    DWORD   dwPrivHighThisAccount = 0;
    ULONG   uEnumerationContext;
    ULONG   uPreferedMaximumLength;
    ULONG   uNumAccounts;

    PLSA_ENUMERATION_INFORMATION aSids = NULL;
    PLSA_TRANSLATED_NAME aNames=NULL;
    PLSA_REFERENCED_DOMAIN_LIST pReferencedDomains=NULL;
    PUNICODE_STRING aUserRights = NULL;

    //
    // other variables
    //

    NTSTATUS    NtStatus;
    NTSTATUS    NtStatusSave=STATUS_SUCCESS;
    NTSTATUS    NtStatusRsop = STATUS_SUCCESS;

    PSCE_NAME_LIST  pAccountSidOrName=NULL;
    PSCE_PRIVILEGE_VALUE_LIST pAccountNode=NULL;
    PWSTR   pwszStringSid = NULL;

    SCE_NAME_LIST   sNameList;
    PSCE_NAME_LIST  psList = &sNameList;
    PWSTR StringSid=NULL;
    BOOL bIgnored = FALSE;

    if ( !PolicyHandle || !pRemoveList ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( PrivLowMask == 0 && PrivHighMask == 0 ) {
        return(SCESTATUS_SUCCESS);
    }

    //
    // get all the accounts (potentially with multiple calls to LSA - the while loop)
    //

    //
    // say each SID has 20 bytes and we'd like to get about SCEP_NUM_LSA_QUERY_SIDS
    // (currently SCEP_NUM_LSA_QUERY_SIDS = 2000 SIDs at a time (approx 40 kB))
    // we might need to tune SCEP_NUM_LSA_QUERY_SIDS depending on LSA memory performance
    //

    uPreferedMaximumLength = 20 * SCEP_NUM_LSA_QUERY_SIDS;
    uEnumerationContext = 0;
    uNumAccounts = 0;

    NtStatus = LsaEnumerateAccounts(
                                   PolicyHandle,
                                   &uEnumerationContext,
                                   (PVOID *)&aSids,
                                   uPreferedMaximumLength,
                                   &uNumAccounts
                                );
    //
    // in case there are more accounts returned, continue processing
    // until all SIDs
    // from LSA are exhausted
    //

    while ( NtStatus == STATUS_SUCCESS
            && uNumAccounts > 0
            && aSids != NULL) {

        NtStatus = STATUS_SUCCESS;

        //
        // convert SIDs to names if required
        //

        if ( !(dwBuildRule & SCE_BUILD_ACCOUNT_SID) &&
             !(dwBuildRule & SCE_BUILD_ACCOUNT_SID_STRING) ) {

            NtStatus = LsaLookupSids(
                            PolicyHandle,
                            uNumAccounts,
                            (PSID *)aSids,
                            &pReferencedDomains,
                            &aNames
                            );
        }

        if ( NT_SUCCESS(NtStatus) ) {

            BOOL bUsed;

            for ( uAccountIndex = 0; uAccountIndex < uNumAccounts ; uAccountIndex++ ) {

                ScepFree ( pwszStringSid );
                pwszStringSid = NULL;

                ScepConvertSidToPrefixStringSid(aSids[uAccountIndex].Sid, &pwszStringSid);

                //
                // check if this account is in the ignore list
                //
                if ( (Options & SCE_POLICY_TEMPLATE) ) {

                    if ( ScepSplayValueExist( (PVOID)(aSids[uAccountIndex].Sid), pIgnoreAccounts) ) {
                        //
                        // this one should be ingored in this policy prop
                        //
                        //
                        NtStatusRsop = STATUS_PENDING;
                        bIgnored = TRUE;

                        ScepLogOutput2(1, 0, L"\t\tIgnore %s.", pwszStringSid ? pwszStringSid : L"");

                        continue;
/*
                    } else {

                        ScepLogOutput2(1, 0, L"\tSome rights assigned to %s may be removed", pwszStringSid ? pwszStringSid : L"");
*/
                    }
                }

                uCountOfRights = 0;
                aUserRights = NULL;

                NtStatus = LsaEnumerateAccountRights(
                                                    PolicyHandle,
                                                    aSids[uAccountIndex].Sid,
                                                    &aUserRights,
                                                    &uCountOfRights
                                                    );

                if ( !NT_SUCCESS(NtStatus) ) {

                    //
                    // log error for this account and continue with the next account
                    //

                    ScepLogOutput3(1,
                                   RtlNtStatusToDosError(NtStatus),
                                   SCESRV_ERROR_QUERY_ACCOUNT_RIGHTS,
                                   pwszStringSid);

                    if ( aUserRights ) {

                        LsaFreeMemory( aUserRights );

                        aUserRights = NULL;

                    }

                    NtStatusSave = NtStatus;

                    continue;
                }

                dwPrivLowThisAccount = 0;
                dwPrivHighThisAccount = 0;

                ScepBuildDwMaskFromStrArray(
                                           aUserRights,
                                           uCountOfRights,
                                           &dwPrivLowThisAccount,
                                           &dwPrivHighThisAccount
                                           );

                //
                // if account has at least one user right after masking,
                // we have to process it further
                //

                if ( (dwPrivLowThisAccount & PrivLowMask) ||
                     (dwPrivHighThisAccount & PrivHighMask) ) {

                    if ( dwBuildRule & SCE_BUILD_ACCOUNT_SID ) {
                        //
                        // add the SID to the name list
                        //
                        (VOID) ScepAddSidToNameList(
                                       &pAccountSidOrName,
                                       aSids[uAccountIndex].Sid,
                                       FALSE,
                                       &bUsed);

                    } else if ( dwBuildRule & SCE_BUILD_ACCOUNT_SID_STRING ) {
                        //
                        // add the SID in string format
                        //
                        if ( ERROR_SUCCESS == ScepConvertSidToPrefixStringSid(
                                                aSids[uAccountIndex].Sid, &StringSid) ) {

                            sNameList.Name = StringSid;
                            sNameList.Next = NULL;

                            pAccountSidOrName = psList;
                        } // else out of memory, catch it later

                    } else {

                        //
                        // detect if the sid can't be mapped, there are two cases:
                        // 1) the domain can't be found, a string format of SID is returned
                        // 2) the domain is found. If the domain is builtin and the account
                        // name has all digits (the RID), then the builtin account can't be found
                        // the second case is solely for the server and DC accounts (PU, SO, AO, PO)
                        //

                        if ( (dwBuildRule & SCE_BUILD_IGNORE_UNKNOWN) &&
                             ( aNames[uAccountIndex].Use == SidTypeInvalid ||
                               aNames[uAccountIndex].Use == SidTypeUnknown ) ) {

                            //
                            // this name is not mapped, ignore it and
                            // continue with the next account
                            //

                            if ( aUserRights ) {

                                LsaFreeMemory( aUserRights );

                                aUserRights = NULL;

                            }

                            NtStatusSave = NtStatus;

                            continue;
                        }

                        //
                        // build the full name of each account
                        //
                        if ( pReferencedDomains->Entries > 0 && aNames[uAccountIndex].Use != SidTypeWellKnownGroup &&
                             pReferencedDomains->Domains != NULL &&
                             aNames[uAccountIndex].DomainIndex != -1 &&
                             (ULONG)(aNames[uAccountIndex].DomainIndex) < pReferencedDomains->Entries &&
                             ScepIsDomainLocalBySid(pReferencedDomains->Domains[aNames[uAccountIndex].DomainIndex].Sid) == FALSE &&
                             ScepIsDomainLocal(&pReferencedDomains->Domains[aNames[uAccountIndex].DomainIndex].Name) == FALSE ) {

                            //
                            // add both domain name and account name
                            //
                            (VOID) ScepAddTwoNamesToNameList(
                                              &pAccountSidOrName,
                                              TRUE,
                                              pReferencedDomains->Domains[aNames[uAccountIndex].DomainIndex].Name.Buffer,
                                              pReferencedDomains->Domains[aNames[uAccountIndex].DomainIndex].Name.Length/2,
                                              aNames[uAccountIndex].Name.Buffer,
                                              aNames[uAccountIndex].Name.Length/2);
                        } else {
                            //
                            // add only the account name
                            //
                            (VOID) ScepAddToNameList(
                                          &pAccountSidOrName,
                                          aNames[uAccountIndex].Name.Buffer,
                                          aNames[uAccountIndex].Name.Length/2);
                        }
                    }

                    if ( pAccountSidOrName ) {

                        //
                        // if sid/name exists in the template list
                        //      continue (the explicit mask takes care of remove)
                        // else
                        //      add it to the remove list
                        //

                        for ( pAccountNode=pTemplateList;
                            pAccountNode != NULL;
                            pAccountNode = pAccountNode->Next ) {

                            if ( pAccountNode->Name == NULL ) {
                                continue;
                            }

                            if ( dwBuildRule & SCE_BUILD_ACCOUNT_SID ) {

                                if ( ScepValidSid( (PSID)(pAccountNode->Name) ) &&
                                     RtlEqualSid( (PSID)(pAccountSidOrName->Name), (PSID)(pAccountNode->Name) ) ) {
                                    break;
                                }
                            } else if ( _wcsicmp(pAccountNode->Name, pAccountSidOrName->Name) == 0 ) {
                                break;
                            }
                        }

                        //
                        //  always need to add to the remove list since each sid/name
                        //  is seen only once in the new algorithm
                        //

                        if ( pAccountNode == NULL ) {

                            pAccountNode = (PSCE_PRIVILEGE_VALUE_LIST)ScepAlloc(
                                                               LPTR,
                                                                sizeof(SCE_PRIVILEGE_VALUE_LIST));
                            if ( pAccountNode != NULL ) {

                                pAccountNode->Name = pAccountSidOrName->Name;
                                pAccountSidOrName->Name = NULL;

                                pAccountNode->PrivLowPart = dwPrivLowThisAccount & PrivLowMask;
                                pAccountNode->PrivHighPart = dwPrivHighThisAccount & PrivHighMask;

                                pAccountNode->Next = *pRemoveList;
                                *pRemoveList = pAccountNode;
                            }

                        }

                        //
                        // free the buffer
                        //
                        if ( pAccountSidOrName->Name ) {
                            ScepFree(pAccountSidOrName->Name);
                        }
                        if ( pAccountSidOrName != psList)
                            ScepFree(pAccountSidOrName);
                        pAccountSidOrName = NULL;

                    }
                }

                if ( aUserRights ) {

                    LsaFreeMemory( aUserRights );

                    aUserRights = NULL;
                }
            }

        } else if ( NtStatus == STATUS_NONE_MAPPED ) {
            //
            // lookup for all sids failed
            //
            NtStatusRsop = NtStatus;
            NtStatus = STATUS_SUCCESS;

        } else {

            NtStatusRsop = NtStatus;
            ScepLogOutput3(3,0, IDS_ERROR_LOOKUP, NtStatus, uNumAccounts);
            NtStatus = STATUS_SUCCESS;   // ignore the error for now
        }

        //
        // free and reset all parameters except the enumeration context
        // for which state has to be remembered between calls to LSA
        //

        if (pReferencedDomains) {
            LsaFreeMemory(pReferencedDomains);
            pReferencedDomains = NULL;
        }

        if (aNames) {
            LsaFreeMemory(aNames);
            aNames = NULL;
        }

        if (aSids) {
            LsaFreeMemory( aSids );
            aSids = NULL;
        }

        //
        // attempt to enumerate the next batch of SIDs
        //

        uNumAccounts = 0;

        NtStatus = LsaEnumerateAccounts(
                                       PolicyHandle,
                                       &uEnumerationContext,
                                       (PVOID *)&aSids,
                                       uPreferedMaximumLength,
                                       &uNumAccounts
                                       );

    }

    if ( aSids ) {

        LsaFreeMemory( aSids );

    }

    ScepFree(pwszStringSid);
    pwszStringSid = NULL;

    if ( NtStatus == STATUS_NO_MORE_ENTRIES ||
         NtStatus == STATUS_NOT_FOUND ) {

        //
        // not a real error - just an enumeration warning/status
        //

        NtStatus = STATUS_SUCCESS;

    }

    //
    // in this scheme in which it is "foreach SID" and not "foreach privilege",
    // either log all in case of failure
    //

    if ( ! NT_SUCCESS( NtStatus ) ) {

        ScepRsopLog(SCE_RSOP_PRIVILEGE_INFO,
                    RtlNtStatusToDosError(NtStatus),
                    NULL,
                    PrivLowMask,
                    PrivHighMask);

        ScepLogOutput3(1,
                       RtlNtStatusToDosError(NtStatus),
                       SCEDLL_SAP_ERROR_ENUMERATE,
                       L"Accounts from LSA");

    }

    if ( NT_SUCCESS(NtStatus) ) {

        if ( bIgnored ) {
            //
            // if some accounts are ignored, return the pending error
            //
            return(STATUS_PENDING);
        } else
            return NtStatusSave;

    } else
        return(NtStatus);

}


VOID
ScepBuildDwMaskFromStrArray(
    IN  PUNICODE_STRING aUserRights,
    IN  ULONG   uCountOfRights,
    OUT DWORD *pdwPrivLowThisAccount,
    OUT DWORD *pdwPrivHighThisAccount
    )
/* ++
Routine Description:

    This routine converts a privilege array of unicode strings two DWORD masks.

Arguments:

    aUserRights             -   an array of unicode strings, each string is a user right
    uCountOfRights         -   array count
    pdwPrivLowThisAccount   -   converted privileges' low 32 mask
    pdwPrivHighThisAccount  -   converted privileges' high 32 mask

Return value:

    None except the low 32 and high 32 masks

-- */
{
    ULONG   uAccountIndex;
    DWORD   dwRefPrivIndex;
    DWORD   dwLowMask = 0;
    DWORD   dwHighMask = 0;

    if (pdwPrivLowThisAccount == NULL ||
        pdwPrivHighThisAccount == NULL ||
        aUserRights == NULL ||
        uCountOfRights == 0 ) {

        return;

    }

    for (uAccountIndex = 0; uAccountIndex < uCountOfRights; uAccountIndex++ ) {
        for (dwRefPrivIndex = 0; dwRefPrivIndex < cPrivCnt; dwRefPrivIndex++ ) {
            if ( 0 == _wcsnicmp(SCE_Privileges[ dwRefPrivIndex ].Name, aUserRights[ uAccountIndex ].Buffer, aUserRights[ uAccountIndex ].Length/sizeof(WCHAR))) {
                if ( dwRefPrivIndex < 32 ) {
                    dwLowMask |= 1 << dwRefPrivIndex;
                }
                else {
                    dwHighMask |= 1 << (dwRefPrivIndex - 32) ;
                }
            }
        }
    }

    *pdwPrivLowThisAccount = dwLowMask;
    *pdwPrivHighThisAccount = dwHighMask;

    return;

}


NTSTATUS
ScepAdjustAccountPrivilegesRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID       AccountSid,
    IN DWORD      PrivilegeLowRights,
    IN DWORD      PrivilegeLowMask,
    IN DWORD      PrivilegeHighRights,
    IN DWORD      PrivilegeHighMask,
    IN DWORD      Options
    )
/* ++
Routine Description:

    This routine set the privilege/rights as specified in PrivilegeRights
    (DWORD type, each bit represents a privilege/right) to the account
    referenced by AccountSid. This routine compares the current privilege/
    right setting with the "should be" setting and add/remove privileges/
    rights from the account.

Arguments:

    PolicyHandle    - Lsa Policy Domain handle

    AccountSid      - The SID for the account

    PrivilegeRights - Privilege/Rights to set for this account

Return value:

    NTSTATUS
-- */
{
    NTSTATUS            NtStatus;
    DWORD               ExplicitPrivLowRights=0, ExplicitPrivHighRights=0;
    DWORD               PrivLowRightAdd,
                        PrivLowRightRemove;

    DWORD               PrivHighRightAdd,
                        PrivHighRightRemove;
    //
    // Enumerate current explicitly assigned privilege/rights
    //

    NtStatus = ScepGetAccountExplicitRight(
                    PolicyHandle,
                    AccountSid,
                    &ExplicitPrivLowRights,
                    &ExplicitPrivHighRights
                    );

    if ( !NT_SUCCESS(NtStatus) ){

        if ( Options & SCE_RSOP_CALLBACK){

            ScepRsopLog(SCE_RSOP_PRIVILEGE_INFO,
                        RtlNtStatusToDosError(NtStatus),
                        NULL,
                        PrivilegeLowRights,
                        PrivilegeHighRights);
        }

        return(NtStatus);
    }

    //
    // Compare CurrentPrivRights with pRights->PrivilegeRights for add
    //   Example:   CurrentPrivRights                       10101
    //              pRights->PrivilegeRights( change to)    11010
    //          where 1 means the privilege/right is on
    //   So the privileges/rights to add                    01010
    // Compare ExplicitPrivRights with pRights->PrivilegeRights for remove
    //

    PrivLowRightAdd = ~ExplicitPrivLowRights & PrivilegeLowRights;
    PrivLowRightRemove = (~(PrivilegeLowRights) & ExplicitPrivLowRights) & PrivilegeLowMask;

    PrivHighRightAdd = ~ExplicitPrivHighRights & PrivilegeHighRights;
    PrivHighRightRemove = (~(PrivilegeHighRights) & ExplicitPrivHighRights) & PrivilegeHighMask;

    //
    // Add
    //

    if ( PrivLowRightAdd != 0 || PrivHighRightAdd != 0 ) {

        NtStatus = ScepAddOrRemoveAccountRights(
                        PolicyHandle,
                        AccountSid,
                        TRUE,
                        PrivLowRightAdd,
                        PrivHighRightAdd
                        );
        if ( !NT_SUCCESS(NtStatus) ) {

            if ( Options & SCE_RSOP_CALLBACK){

                ScepRsopLog(SCE_RSOP_PRIVILEGE_INFO,
                            RtlNtStatusToDosError(NtStatus),
                            NULL,
                            PrivLowRightAdd,
                            PrivHighRightAdd);
            }

            if ( RtlNtStatusToDosError(NtStatus) != ERROR_ALREADY_EXISTS ){

                return(NtStatus);
            }
        }
    }

    //
    // Remove
    //

    if ( PrivLowRightRemove != 0 || PrivHighRightRemove != 0 ) {

        NtStatus = ScepAddOrRemoveAccountRights(
                        PolicyHandle,
                        AccountSid,
                        FALSE,
                        PrivLowRightRemove,
                        PrivHighRightRemove
                        );
        if ( !NT_SUCCESS(NtStatus) ){

            if ( Options & SCE_RSOP_CALLBACK){

                ScepRsopLog(SCE_RSOP_PRIVILEGE_INFO,
                            RtlNtStatusToDosError(NtStatus),
                            NULL,
                            PrivLowRightRemove,
                            PrivHighRightRemove);
            }
            return(NtStatus);
        }
    }

    return (NtStatus);
}


NTSTATUS
ScepAddOrRemoveAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID       AccountSid,
    IN BOOL       AddOrRemove,
    IN DWORD      PrivLowAdjust,
    IN DWORD      PrivHighAdjust
    )
/* ++
Routine Description:

    This routine add or remove the privilege/rights as specified in PrivAdjust
    to the account referenced by AccountSid.

Arguments:

    PolicyHandle    - Lsa Policy Domain handle

    AccountSid      - The SID for the account

    AddOrRemove     - TRUE = Add, FALSE = remove

    PrivAdjust      - Privilege/Rights to add or remove

Return value:

    NTSTATUS
-- */
{
    NTSTATUS            NtStatus=STATUS_SUCCESS;
    DWORD               cTotal;
    DWORD               i, cnt;
    PLSA_UNICODE_STRING UserRightAdjust=NULL;

    //
    // count how many privileges/rights to adjust
    //

    i = PrivLowAdjust;
    cTotal = 0;

    while ( i != 0 ) {
       if ( i & 0x1 )
           cTotal++;
       i /= 2;
    }

    i = PrivHighAdjust;

    while ( i != 0 ) {
       if ( i & 0x1 )
           cTotal++;
       i /= 2;
    }

    if ( cTotal > 0 ) {
        //
        // add names in privileges table
        //
        UserRightAdjust = (PLSA_UNICODE_STRING)ScepAlloc( (UINT)0,
                                cTotal*sizeof(LSA_UNICODE_STRING));

        if ( UserRightAdjust == NULL ) {
            NtStatus = STATUS_NO_MEMORY;
            goto Done;
        }

        for (i = 0, cnt=0; i < cPrivCnt; i++)

            if ( ( ( i < 32 ) && ( PrivLowAdjust & (1 << i) ) ) ||
                 ( ( i >= 32 ) && ( PrivHighAdjust & (1 << ( i-32 )) ) ) ) {

                RtlInitUnicodeString(&(UserRightAdjust[cnt]), SCE_Privileges[i].Name);
                if (AddOrRemove)
                    ScepLogOutput3(2,0, SCEDLL_SCP_ADD, SCE_Privileges[i].Name);
                else
                    ScepLogOutput3(2,0, SCEDLL_SCP_REMOVE, SCE_Privileges[i].Name);

                cnt++;
            }


        if (AddOrRemove) {
            // add
            NtStatus = LsaAddAccountRights(
                            PolicyHandle,
                            AccountSid,
                            UserRightAdjust,
                            cTotal
                            );
        } else {
            // remove
            NtStatus = LsaRemoveAccountRights(
                            PolicyHandle,
                            AccountSid,
                            FALSE,
                            UserRightAdjust,
                            cTotal
                            );
        }
    }

Done:

    if (UserRightAdjust != NULL)
        ScepFree(UserRightAdjust);

    return(NtStatus);
}



NTSTATUS
ScepValidateUserInGroups(
    IN SAM_HANDLE       DomainHandle,
    IN SAM_HANDLE       BuiltinDomainHandle,
    IN PSID             DomainSid,
    IN UNICODE_STRING   UserName,
    IN ULONG            UserId,
    IN PSCE_NAME_LIST    pGroupsToCheck
    )
/* ++
Routine Description:

    This routine validates the user's group membership to the list of groups.
    If the user is not in one of the groups, add it to the group. If a group
    has more members, just ignore.

Arguments:

    DomainHandle    - The SAM handle of the SAM account domain

    BuiltinDomainHandle - The SAM handle of the SAM builtin domain

    DomainSid       - The SID of the account domain

    UserName        - The user's name in UNICODE_STRING

    UserId          - The user's relative ID

    pGroupsToCheck  - The group list to check for this user

Return value:

    NTSTATUS

-- */
{
    NTSTATUS            NtStatus;
    SAM_HANDLE          UserHandle=NULL;
    PSID                AccountSid=NULL;
    PSCE_NAME_LIST       GroupList=NULL,
                        pGroup, pGroup2;
    BOOL                FirstTime=TRUE;


    if ( pGroupsToCheck == NULL )
        return(ERROR_SUCCESS);

    NtStatus = SamOpenUser(
                  DomainHandle,
                  USER_READ | USER_EXECUTE,
                  UserId,
                  &UserHandle
                  );
    if ( !NT_SUCCESS(NtStatus) ) {
        ScepLogOutput3(1,RtlNtStatusToDosError(NtStatus),
                      SCEDLL_USER_OBJECT);
        return(NtStatus);
    }

    //
    // Get user's SID
    //

    NtStatus = ScepDomainIdToSid(
                    DomainSid,
                    UserId,
                    &AccountSid
                    );
    if ( !NT_SUCCESS(NtStatus) )
        goto Done;

    //
    // get all current assigned groups of this user.
    //

    NtStatus = ScepGetGroupsForAccount(
                    DomainHandle,
                    BuiltinDomainHandle,
                    UserHandle,
                    AccountSid,
                    &GroupList
                    );
    if ( !NT_SUCCESS(NtStatus) )
        goto Done;

    UNICODE_STRING uName;
    PWSTR pTemp;

    for ( pGroup=pGroupsToCheck; pGroup != NULL; pGroup = pGroup->Next ) {

        //
        // should expect pGroup->Name has domain prefix
        //
        pTemp = wcschr(pGroup->Name, L'\\');

        if ( pTemp ) {

            //
            // check if this group is from a different domain
            //

            uName.Buffer = pGroup->Name;
            uName.Length = ((USHORT)(pTemp-pGroup->Name))*sizeof(TCHAR);

            if ( !ScepIsDomainLocal(&uName) ) {
                ScepLogOutput3(1, 0, SCEDLL_NO_MAPPINGS, pGroup->Name);
                continue;
            }

            pTemp++;

        } else {
            pTemp = pGroup->Name;
        }

        for ( pGroup2=GroupList; pGroup2 != NULL; pGroup2 = pGroup2->Next ) {

            if ( _wcsnicmp(pGroup2->Name, pTemp, wcslen(pTemp)) == 0)
                break;
        }

        if ( pGroup2 == NULL ) {
            //
            // Did not find the group. Add the user to it (pGroup->Name)
            //
            if (FirstTime)
                ScepLogOutput3(2, 0, SCEDLL_SCP_ADDTO, pGroup->Name );
            FirstTime = FALSE;

            NtStatus = ScepAddUserToGroup(
                            DomainHandle,
                            BuiltinDomainHandle,
                            UserId,
                            AccountSid,
                            pTemp  // pGroup->Name
                            );
            if ( !NT_SUCCESS(NtStatus) && NtStatus != STATUS_NONE_MAPPED ) {
                ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                             SCEDLL_SCP_ERROR_ADDTO, pGroup->Name);
                goto Done;
            }
        }
    }

Done:

    SamCloseHandle(UserHandle);

    if (AccountSid != NULL)
        ScepFree(AccountSid);

    ScepFreeNameList(GroupList);

    return(NtStatus);

}


NTSTATUS
ScepAddUserToGroup(
    IN SAM_HANDLE   DomainHandle,
    IN SAM_HANDLE   BuiltinDomainHandle,
    IN ULONG        UserId,
    IN PSID         AccountSid,
    IN PWSTR        GroupName
    )
/* ++
Routine Description:


Arguments:


Return value:

    NTSTATUS
-- */
{
    NTSTATUS            NtStatus=ERROR_SUCCESS;
    SAM_HANDLE          ThisDomain=DomainHandle;
    UNICODE_STRING      Name;
    PULONG              GrpId=NULL;
    PSID_NAME_USE       GrpUse=NULL;
    SAM_HANDLE          GroupHandle=NULL;


    // initialize a UNICODE_STRING for the group name
    RtlInitUnicodeString(&Name, GroupName);

    //
    // lookup the group name in account domain first
    //
    NtStatus = SamLookupNamesInDomain(
                    DomainHandle,
                    1,
                    &Name,
                    &GrpId,
                    &GrpUse
                    );

    if ( NtStatus == STATUS_NONE_MAPPED ) {
        //
        // not found in account domain. Lookup in the builtin domain
        //
        NtStatus = SamLookupNamesInDomain(
                        BuiltinDomainHandle,
                        1,
                        &Name,
                        &GrpId,
                        &GrpUse
                        );
        ThisDomain=BuiltinDomainHandle;
    }

    if ( !NT_SUCCESS(NtStatus) )
        return(NtStatus);

    //
    // add the user to the group/alias
    //

    if (GrpUse != NULL){

        switch ( GrpUse[0] ) {
        case SidTypeGroup:
            NtStatus = SamOpenGroup(
                            ThisDomain,
                            GROUP_ADD_MEMBER,
                            GrpId[0],
                            &GroupHandle
                            );

            if ( NT_SUCCESS(NtStatus) ) {

                NtStatus = SamAddMemberToGroup(
                                GroupHandle,
                                UserId,
                                SE_GROUP_MANDATORY          |
                                SE_GROUP_ENABLED_BY_DEFAULT |
                                SE_GROUP_ENABLED
                                );
            }
            break;
        case SidTypeAlias:
            NtStatus = SamOpenAlias(
                            ThisDomain,
                            ALIAS_ADD_MEMBER,
                            GrpId[0],
                            &GroupHandle
                            );
            if ( NT_SUCCESS(NtStatus) ) {

                NtStatus = SamAddMemberToAlias(
                                GroupHandle,
                                AccountSid
                                );
            }
            break;
        default:
            NtStatus = STATUS_DATA_ERROR;
            ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                         SCEDLL_NOT_GROUP, GroupName);
            goto Done;
        }

    }

Done:

    SamFreeMemory(GrpId);
    SamFreeMemory(GrpUse);

    SamCloseHandle(GroupHandle);

    return(NtStatus);
}


SCESTATUS
ScepConfigureGroupMembership(
    IN PSCE_GROUP_MEMBERSHIP pGroupMembership,
    IN DWORD ConfigOptions
    )
/* ++
Routine Description:

    This routine configure restricted group's membership which includes members
    in the group and groups this group belongs to ( Currently a global group can
    only belong to a local group and a local group can't be a member of other
    groups. But this will change in the future). Members in the group are
    configured exactly as the pMembers list in the restricted group. The group
    is only validated (added) as a member of the MemberOf group list. Other
    existing members in those groups won't be removed.

    The restricted groups are specified in the SCP profile by group name. It
    could be a global group, or a alias, but must be defined on the local system.

Arguments:

    pGroupMembership - the restricted group list to configure

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_NOT_ENOUGH_RESOURCE
    :
-- */
{
    NTSTATUS                NtStatus;
    NTSTATUS                SaveStat=STATUS_SUCCESS;
    PSCE_GROUP_MEMBERSHIP    pGroup;
    SAM_HANDLE              ServerHandle=NULL,
                            DomainHandle=NULL,
                            BuiltinDomainHandle=NULL;
    PSID                    DomainSid=NULL,
                            BuiltinDomainSid=NULL;

    LSA_HANDLE              PolicyHandle=NULL;

    SAM_HANDLE          ThisDomain=NULL;
    PSID                ThisDomainSid=NULL;
    UNICODE_STRING      Name;
    PULONG              GrpId=NULL;
    PSID_NAME_USE       GrpUse=NULL;
    PSID                GrpSid=NULL;
    DWORD               GroupLen;
    DWORD               rc;

    DWORD               nGroupCount=0;
    PSCESECTION hSectionDomain=NULL;
    PSCESECTION hSectionTattoo=NULL;
    PWSTR GroupSidString=NULL;


    if (pGroupMembership == NULL) {

        ScepPostProgress(TICKS_GROUPS,
                         AREA_GROUP_MEMBERSHIP,
                         NULL);

        return(SCESTATUS_SUCCESS);
    }

    //
    // open LSA policy
    //
    NtStatus = ScepOpenLsaPolicy(
                    POLICY_VIEW_LOCAL_INFORMATION |
                    POLICY_VIEW_AUDIT_INFORMATION |
                    POLICY_GET_PRIVATE_INFORMATION |
                    POLICY_LOOKUP_NAMES,
//                    GENERIC_ALL,
                    &PolicyHandle,
                    TRUE
                    );
    if (NtStatus != STATUS_SUCCESS) {
         rc = RtlNtStatusToDosError( NtStatus );
         ScepLogOutput3(1, rc, SCEDLL_LSA_POLICY);

         ScepPostProgress(TICKS_GROUPS,
                          AREA_GROUP_MEMBERSHIP,
                          NULL);

         return(ScepDosErrorToSceStatus(rc));
    }

    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
         ScepIsSystemShutDown() ) {

        SaveStat = STATUS_NOT_SUPPORTED;
        goto Done;
    }

    //
    // Open SAM domain
    //
    NtStatus = ScepOpenSamDomain(
                    SAM_SERVER_ALL_ACCESS,
                    MAXIMUM_ALLOWED,
                    &ServerHandle,
                    &DomainHandle,
                    &DomainSid,
                    &BuiltinDomainHandle,
                    &BuiltinDomainSid
                   );

    if ( !NT_SUCCESS(NtStatus) ) {
        ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                       SCEDLL_ACCOUNT_DOMAIN);
        SaveStat = NtStatus;
        goto Done;
    }

    //
    // open policy/tattoo tables
    //
    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
        ( ProductType != NtProductLanManNt ) ) {

        ScepTattooOpenPolicySections(
                      hProfile,
                      szGroupMembership,
                      &hSectionDomain,
                      &hSectionTattoo
                      );
    }

    //
    // configure each group
    //

    for ( pGroup=pGroupMembership; pGroup != NULL; pGroup = pGroup->Next ) {
        //
        // Get this group's ID and SID
        //    initialize a UNICODE_STRING for the group name
        //
        if ( (pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS ) &&
             (pGroup->Status & SCE_GROUP_STATUS_NC_MEMBEROF ) ) {

            // it's not possible to get invalid tattoo group values into the
            // tattoo table so we don't handle tattoo value here

            continue;
        }

        if ( (ProductType == NtProductLanManNt) &&
             (pGroup->Status & SCE_GROUP_STATUS_DONE_IN_DS) ) {
            //
            // this one is already done by DS
            //
            nGroupCount++;
            continue;
        }


        ScepLogOutput3(0,0, SCEDLL_SCP_CONFIGURE, pGroup->GroupName);

        if ( nGroupCount < TICKS_GROUPS ) {
            ScepPostProgress(1, AREA_GROUP_MEMBERSHIP, pGroup->GroupName);
            nGroupCount++;
        }

        LPTSTR pTemp = wcschr(pGroup->GroupName, L'\\');
        if ( pTemp ) {
            //
            // there is a domain name, check it with computer name
            //
            UNICODE_STRING uName;

            uName.Buffer = pGroup->GroupName;
            uName.Length = ((USHORT)(pTemp-pGroup->GroupName))*sizeof(TCHAR);

            if ( !ScepIsDomainLocal(&uName) ) {
                //
                // it's not possible to get a foreign domain group into the tattoo
                // table so we don't handle the tattoo values here
                //
                ScepLogOutput3(1, 0, SCEDLL_NO_MAPPINGS, pGroup->GroupName);
                rc = SCESTATUS_INVALID_DATA;
                continue;
            }
            pTemp++;
        } else {
            pTemp = pGroup->GroupName;
        }

        RtlInitUnicodeString(&Name, pTemp);

        GroupLen = wcslen(pTemp);

        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
             ScepIsSystemShutDown() ) {

            SaveStat = STATUS_NOT_SUPPORTED;
            break;
        }

        //
        // lookup the group name in account domain first
        //
        NtStatus = SamLookupNamesInDomain(
                        DomainHandle,
                        1,
                        &Name,
                        &GrpId,
                        &GrpUse
                        );
        ThisDomain = DomainHandle;
        ThisDomainSid = DomainSid;

        if ( NtStatus == STATUS_NONE_MAPPED ) {
            //
            // not found in account domain. Lookup in the builtin domain (maybe a alias)
            //
            NtStatus = SamLookupNamesInDomain(
                            BuiltinDomainHandle,
                            1,
                            &Name,
                            &GrpId,
                            &GrpUse
                            );
            ThisDomain=BuiltinDomainHandle;
            ThisDomainSid = BuiltinDomainSid;
        }

        if ( !NT_SUCCESS(NtStatus) ) {
            ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                         SCEDLL_NO_MAPPINGS, pGroup->GroupName);
            SaveStat = NtStatus;

            if (ConfigOptions & SCE_RSOP_CALLBACK)
                ScepRsopLog(SCE_RSOP_GROUP_INFO, RtlNtStatusToDosError(NtStatus), pGroup->GroupName, 0, 0);

            if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                ( ProductType != NtProductLanManNt ) ) {

                ScepTattooManageOneMemberListValue(
                        hSectionDomain,
                        hSectionTattoo,
                        pTemp,
                        GroupLen,
                        NULL,
                        TRUE,
                        ERROR_NONE_MAPPED
                        );
            }

            // goto Done;
            continue;
        }

        //
        // Get the group's account SID
        //
        NtStatus = ScepDomainIdToSid(
                        ThisDomainSid,
                        GrpId[0],
                        &GrpSid
                        );
        if ( !NT_SUCCESS(NtStatus) ) {
            ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                         SCEDLL_NO_MAPPINGS, pGroup->GroupName);
            SaveStat = NtStatus;

            if (ConfigOptions & SCE_RSOP_CALLBACK)
                ScepRsopLog(SCE_RSOP_GROUP_INFO, RtlNtStatusToDosError(NtStatus), pGroup->GroupName, 0, 0);

            goto NextGroup;
        }

        if ( GrpId[0] == DOMAIN_GROUP_RID_USERS ) {

            //
            // do not configure this one
            // there should never be tattoo values for this setting
            // so we don't check tattoo values here
            //
            goto NextGroup;
        }

        if ( GrpId[0] == DOMAIN_ALIAS_RID_ADMINS ) {

            //
            // local builtin administrators alias, make sure local Administrator
            // account is in the members list, if it's not, add it there
            //

            (VOID) ScepAddAdministratorToThisList(
                               DomainHandle,
                               &(pGroup->pMembers)
                               );
        }

        //
        // members
        //
        if ( !(pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS) ) {

            if ( (ConfigOptions & SCE_POLICY_TEMPLATE) ) {

                DWORD rc2 = ScepConvertSidToPrefixStringSid(GrpSid, &GroupSidString);

                if ( ERROR_SUCCESS != rc2 ) {
                    ScepLogOutput3(1,0,SCESRV_POLICY_TATTOO_ERROR_SETTING,rc2,pGroup->GroupName);
                    GroupSidString = NULL;
                }
            }

            switch ( GrpUse[0] ) {
            case SidTypeGroup:
                NtStatus = ScepConfigureMembersOfGroup(
                                hSectionDomain,
                                hSectionTattoo,
                                ThisDomain,
                                ThisDomainSid,
                                GrpId[0],
                                GrpSid,
                                pGroup->GroupName,
                                GroupSidString,
                                pGroup->pMembers,
                                ConfigOptions
                                );


                break;
            case SidTypeAlias:
                NtStatus = ScepConfigureMembersOfAlias(
                                hSectionDomain,
                                hSectionTattoo,
                                ThisDomain,
                                ThisDomainSid,
                                PolicyHandle,
                                GrpId[0],
                                GrpSid,
                                pGroup->GroupName,
                                GroupSidString,
                                pGroup->pMembers,
                                ConfigOptions
                                );

                break;
            case SidTypeUser:
                if ( pGroup->pMembers != NULL ) {
                    ScepLogOutput3(1, 0, SCEDLL_ERROR_USER_MEMBER);

                    NtStatus = STATUS_DATA_ERROR;
                }

                if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                    ( ProductType != NtProductLanManNt ) &&
                     GroupSidString ) {

                    ScepTattooManageOneMemberListValue(
                            hSectionDomain,
                            hSectionTattoo,
                            GroupSidString,
                            wcslen(GroupSidString),
                            NULL,
                            TRUE,
                            ERROR_NONE_MAPPED
                            );
                }

                break;
            default:
                NtStatus = STATUS_DATA_ERROR;
                ScepLogOutput3(1, 0, SCEDLL_NOT_GROUP, pGroup->GroupName);

                if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                    ( ProductType != NtProductLanManNt ) &&
                     GroupSidString ) {

                    ScepTattooManageOneMemberListValue(
                            hSectionDomain,
                            hSectionTattoo,
                            GroupSidString,
                            wcslen(GroupSidString),
                            NULL,
                            TRUE,
                            ERROR_NONE_MAPPED
                            );
                }
            }

            if (ConfigOptions & SCE_RSOP_CALLBACK)

                ScepRsopLog(SCE_RSOP_GROUP_INFO,
                                           RtlNtStatusToDosError(NtStatus),
                                           pGroup->GroupName,0,0);

            if ( !NT_SUCCESS(NtStatus) )
                SaveStat = NtStatus;

            if ( GroupSidString ) {
                ScepFree(GroupSidString);
                GroupSidString = NULL;
            }
        }

        //
        // member of
        //
        if ( (pGroup->pMemberOf != NULL) &&
             !(pGroup->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) {

            switch ( GrpUse[0] ) {
            case SidTypeGroup:
                //
                // group can be members of alias only
                //
                NtStatus = ScepValidateGroupInAliases(
                                DomainHandle,
                                BuiltinDomainHandle,
                                GrpSid,
                                pGroup->pMemberOf
                                );
                break;

            case SidTypeUser:
                NtStatus = ScepValidateUserInGroups(
                    DomainHandle,
                    BuiltinDomainHandle,
                    ThisDomainSid,
                    Name,
                    GrpId[0],
                    pGroup->pMemberOf
                    );

                break;

            case SidTypeAlias:
                NtStatus = STATUS_DATA_ERROR;
                ScepLogOutput3(1, 0, SCEDLL_ERROR_ALIAS_MEMBER);

            }
            if ( !NT_SUCCESS(NtStatus) )
                SaveStat = NtStatus;

        }
NextGroup:

        //
        // free memory for this group
        //
        SamFreeMemory(GrpId);
        GrpId = NULL;

        SamFreeMemory(GrpUse);
        GrpUse = NULL;

        ScepFree(GrpSid);
        GrpSid = NULL;
    }

Done:

    if ( GrpId != NULL )
        SamFreeMemory(GrpId);

    if ( GrpUse != NULL )
        SamFreeMemory(GrpUse);

    if ( GrpSid != NULL )
        ScepFree(GrpSid);

    // close sam handles
    SamCloseHandle(DomainHandle);
    SamCloseHandle(BuiltinDomainHandle);
    SamCloseHandle(ServerHandle);

    if ( DomainSid != NULL )
        SamFreeMemory(DomainSid);
    if ( BuiltinDomainSid != NULL )
        SamFreeMemory(BuiltinDomainSid);

    LsaClose(PolicyHandle);

    if ( nGroupCount < TICKS_GROUPS ) {
        ScepPostProgress(TICKS_GROUPS-nGroupCount,
                         AREA_GROUP_MEMBERSHIP,
                         NULL);
    }

    SceJetCloseSection(&hSectionDomain, TRUE);
    SceJetCloseSection(&hSectionTattoo, TRUE);

    rc = RtlNtStatusToDosError(SaveStat);
    return( ScepDosErrorToSceStatus(rc) );

}


NTSTATUS
ScepConfigureMembersOfGroup(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN SAM_HANDLE  DomainHandle,
    IN PSID ThisDomainSid,
    IN ULONG GrpId,
    IN PSID GrpSid,
    IN PWSTR GrpName,
    IN PWSTR GroupSidString,
    IN PSCE_NAME_LIST pMembers,
    IN DWORD ConfigOptions
    )
/* ++
Routine Description:

    This routine configure a group's members as specified in the SCP profile (
    pMembers ). Less members are added and extra members are removed.

Arguments:

    DomainHandle    - the SAM domain's handle

    GrpId           - the group's RID

    pMembers        - the members list as specified in the SCP profile

Return Value:

    NTSTATUS return SAM APIs

-- */
{
    NTSTATUS            NtStatus;

    PUNICODE_STRING     MemberNames=NULL;
    PULONG              MemberRids=NULL;
    PSID_NAME_USE       MemberUse=NULL;
    ULONG               MemberCount=0;
    SAM_HANDLE          GroupHandle=NULL;

    PULONG              CurrentRids=NULL;
    PULONG              Attributes=NULL;
    ULONG               CurrentCount=0;

    DWORD               i, j;
    WCHAR               MsgBuf[256];

    PUNICODE_STRING     pName=NULL;
    PSID_NAME_USE       pUse=NULL;
    PSCE_NAME_LIST      pMemberList=NULL;
    BOOL                bMemberQueried=FALSE;

/*
    if ( pMembers == NULL )
        return(STATUS_SUCCESS);
*/
    //
    // Accept empty member list
    // look up the members list first (all members should be within this domain
    //
    NtStatus = ScepLookupNamesInDomain(
                    DomainHandle,
                    pMembers,
                    &MemberNames,
                    &MemberRids,
                    &MemberUse,
                    &MemberCount
                    );
    if ( !NT_SUCCESS(NtStatus) ) {

        ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                       SCEDLL_ERROR_LOOKUP, pMembers ? pMembers->Name : L"");

        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
            ( ProductType != NtProductLanManNt ) &&
             hSectionDomain && hSectionTattoo && GrpSid && GroupSidString &&
             (NtStatus == STATUS_NONE_MAPPED)) {

            ScepTattooManageOneMemberListValue(
                    hSectionDomain,
                    hSectionTattoo,
                    GroupSidString,
                    wcslen(GroupSidString),
                    NULL,
                    TRUE,
                    0
                    );
        }

        return(NtStatus);
    }

    //
    // open the group to get a handle
    //
    NtStatus = SamOpenGroup(
                    DomainHandle,
                    MAXIMUM_ALLOWED, // ? GROUP_ALL_ACCESS,
                    GrpId,
                    &GroupHandle
                    );

    if ( !NT_SUCCESS(NtStatus) ) {
        ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                       SCEDLL_ERROR_OPEN, L"");
        goto Done;
    }

    //
    // get current members of the group
    //
    NtStatus = SamGetMembersInGroup(
                    GroupHandle,
                    &CurrentRids,
                    &Attributes,
                    &CurrentCount
                    );
    if ( !NT_SUCCESS(NtStatus) ) {
        ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                      SCEDLL_ERROR_QUERY_INFO, L"");
        goto Done;
    }

    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
        ( ProductType != NtProductLanManNt ) &&
         hSectionDomain && hSectionTattoo && GrpSid && GroupSidString ) {

        DWORD rc = ScepTattooCurrentGroupMembers(ThisDomainSid,
                                                SidTypeGroup,
                                                CurrentRids,
                                                NULL,
                                                CurrentCount,
                                                &pMemberList
                                               );
        if ( ERROR_SUCCESS != rc ) {
            //
            // something is wrong when building the list
            // this shoudln't happen unless out of memory etc.
            //
            ScepLogOutput3(1,0,SCESRV_POLICY_TATTOO_ERROR_QUERY,rc,GrpName);
        } else
            bMemberQueried=TRUE;
    }

    //
    // Compare the member ids with the current ids for adding
    //
    for ( i=0; i<MemberCount; i++ ) {
#ifdef SCE_DBG
    printf("process member %x for adding\n", MemberRids[i]);
#endif

    if (MemberUse[i] == SidTypeInvalid ||
        MemberUse[i] == SidTypeUnknown ||
        MemberUse[i] == SidTypeDeletedAccount)
        continue;

        for ( j=0; j<CurrentCount; j++)
            if ( MemberRids[i] == CurrentRids[j] )
                break;

        if ( j >= CurrentCount) {
            //
            // Add this member
            //
            memset(MsgBuf, '\0', 512);
            wcsncat(MsgBuf, MemberNames[i].Buffer, MemberNames[i].Length/2);

            ScepLogOutput3(2,0, SCEDLL_SCP_ADD, MsgBuf);

            NtStatus = SamAddMemberToGroup(
                            GroupHandle,
                            MemberRids[i],
                            0
                            );
            if ( !NT_SUCCESS(NtStatus) ) {
                ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                              SCEDLL_SCP_ERROR_ADD, MsgBuf);
                goto Done;
            }
        }
    }

    //
    // Compare the member ids with the current ids for removing
    //
    for ( i=0; i<CurrentCount; i++ ) {
#ifdef SCE_DBG
      printf("process member %x for removing\n", CurrentRids[i]);
#endif
        for ( j=0; j<MemberCount; j++)
            if ( CurrentRids[i] == MemberRids[j] )
                break;

        if ( j >= MemberCount) {
            //
            // Find the member name
            //
            memset(MsgBuf, '\0', 512);
            pName=NULL;
            pUse=NULL;

            if ( NT_SUCCESS( SamLookupIdsInDomain(
                                    DomainHandle,
                                    1,
                                    &(CurrentRids[i]),
                                    &pName,
                                    &pUse
                                    ) ) ) {
                if ( pName != NULL ) {
                    wcsncat(MsgBuf, pName[0].Buffer, pName[0].Length/2);
                } else
                    swprintf(MsgBuf, L"(Rid=%d)", CurrentRids[i]);

                if ( pName != NULL )
                    SamFreeMemory( pName );

                if ( pUse != NULL )
                    SamFreeMemory( pUse );

            } else
                swprintf(MsgBuf, L"(Rid=%d) ", CurrentRids[i]);

            //
            // remove this member
            //
            ScepLogOutput3(2,0, SCEDLL_SCP_REMOVE, MsgBuf);

            NtStatus = SamRemoveMemberFromGroup(
                            GroupHandle,
                            CurrentRids[i]
                            );
            if ( !NT_SUCCESS(NtStatus) ) {
                if ( NtStatus == STATUS_SPECIAL_ACCOUNT )
                    ScepLogOutput3(2, RtlNtStatusToDosError(NtStatus),
                                 SCEDLL_SCP_CANNOT_REMOVE,
                                 MsgBuf);
                else {
                    ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                                   SCEDLL_SCP_ERROR_REMOVE, MsgBuf);
                    goto Done;
                }
            }
        }
    }

Done:

    if ( MemberNames != NULL )
        RtlFreeHeap(RtlProcessHeap(), 0, MemberNames);

    if ( MemberRids != NULL )
        SamFreeMemory( MemberRids );

    if ( MemberUse != NULL )
        SamFreeMemory( MemberUse );

    if ( CurrentRids != NULL )
        SamFreeMemory( CurrentRids );

    if ( GroupHandle != NULL )
        SamCloseHandle( GroupHandle );

    //
    // log the tattoo value
    // if fail to get current value for the group, do not save the tattoo value
    //
    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
        ( ProductType != NtProductLanManNt ) &&
         hSectionDomain && hSectionTattoo &&
         GrpSid && GroupSidString && bMemberQueried) {

        ScepTattooManageOneMemberListValue(
                hSectionDomain,
                hSectionTattoo,
                GroupSidString,
                wcslen(GroupSidString),
                pMemberList,
                FALSE,
                RtlNtStatusToDosError(NtStatus)
                );
    }

    // free name list
    if ( pMemberList )
        ScepFreeNameList(pMemberList);

    return(NtStatus);
}


NTSTATUS
ScepConfigureMembersOfAlias(
    IN PSCESECTION hSectionDomain,
    IN PSCESECTION hSectionTattoo,
    IN SAM_HANDLE   DomainHandle,
    IN PSID         DomainSid,
    IN LSA_HANDLE   PolicyHandle,
    IN ULONG GrpId,
    IN PSID GrpSid,
    IN PWSTR GrpName,
    IN PWSTR GroupSidString,
    IN PSCE_NAME_LIST pMembers,
    IN DWORD ConfigOptions
    )
/* ++
Routine Description:

    This routine configure a local group (alias) members as specified in the
    SCP profile ( pMembers ). Less members are added and extra members are removed.

Arguments:

    DomainHandle    - The domains' handle

    DomainSid       - The sid for the domain

    PolicyHandle    - the LSA policy handle

    GrpId           - the alias's RID

    pMembers        - the members list as specified in the SCP profile

Return Value:

    NTSTATUS return SAM APIs

-- */
{
    NTSTATUS                    NtStatus=STATUS_SUCCESS;

    ULONG                       MemberCount=0;
    PUNICODE_STRING             MemberNames=NULL;
    PSID                        *Sids=NULL;
    SAM_HANDLE                  GroupHandle=NULL;
    PSID                        *CurrentSids=NULL;
    ULONG                       CurrentCount=0;

    DWORD                       i, j;
    WCHAR                       MsgBuf[256];

    PLSA_REFERENCED_DOMAIN_LIST pRefDomain;
    PLSA_TRANSLATED_NAME        pLsaName;
    LPTSTR StringSid=NULL;
    PSCE_NAME_LIST             pMemberList=NULL;
    BOOL                        bMemberQueried=FALSE;

/*
    if ( pMembers == NULL )
        return(STATUS_SUCCESS);
*/
    //
    // Accept empty member list
    // find Sids for the pMember list
    //
    NtStatus = ScepGetMemberListSids(
                        DomainSid,
                        PolicyHandle,
                        pMembers,
                        &MemberNames,
                        &Sids,
                        &MemberCount
                        );
    if ( !NT_SUCCESS(NtStatus) ) {
        ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                       SCEDLL_ERROR_LOOKUP, pMembers ? pMembers->Name : L"");

        if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
            ( ProductType != NtProductLanManNt ) &&
             hSectionDomain && hSectionTattoo && GrpSid && GroupSidString &&
             (NtStatus == STATUS_NONE_MAPPED)) {

            ScepTattooManageOneMemberListValue(
                    hSectionDomain,
                    hSectionTattoo,
                    GroupSidString,
                    wcslen(GroupSidString),
                    NULL,
                    TRUE,
                    0
                    );
        }

        goto Done;
    }

    //
    // open the alias to get a handle
    //
    NtStatus = SamOpenAlias(
                    DomainHandle,
                    MAXIMUM_ALLOWED, // ? ALIAS_ALL_ACCESS,
                    GrpId,
                    &GroupHandle
                    );
    if ( !NT_SUCCESS(NtStatus) ) {
        ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                       SCEDLL_ERROR_OPEN, L"");
        goto Done;
    }
    //
    // get current members of the alias
    // members of alias may exist in everywhere
    //
    NtStatus = SamGetMembersInAlias(
                    GroupHandle,
                    &CurrentSids,
                    &CurrentCount
                    );
    if ( !NT_SUCCESS(NtStatus) ) {
        ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                       SCEDLL_ERROR_QUERY_INFO, L"");
        goto Done;
    }

    //
    // build current group membership into the list
    //
    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
        ( ProductType != NtProductLanManNt ) &&
         hSectionDomain && hSectionTattoo && GrpSid ) {

        DWORD rc = ScepTattooCurrentGroupMembers(DomainSid,
                                                SidTypeAlias,
                                                NULL,
                                                CurrentSids,
                                                CurrentCount,
                                                &pMemberList
                                               );
        if ( ERROR_SUCCESS != rc ) {
            //
            // something is wrong when building the list
            // this shoudln't happen unless out of memory etc.
            //
            ScepLogOutput3(1,0,SCESRV_POLICY_TATTOO_ERROR_QUERY,rc,GrpName);
        } else
            bMemberQueried = TRUE;
    }

    //
    // Compare the member sids with the current sids for adding
    //

    for ( i=0; i<MemberCount; i++ ) {
#ifdef SCE_DBG
   printf("process member %d for adding\n", i);
#endif

       memset(MsgBuf, '\0', 512);
       wcsncpy(MsgBuf, MemberNames[i].Buffer, MemberNames[i].Length/2);

       if ( Sids[i] == NULL ) {
           ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                          SCEDLL_CANNOT_FIND, MsgBuf);
       } else {

           for ( j=0; j<CurrentCount; j++) {
                if ( EqualSid(Sids[i], CurrentSids[j]) ) {

                    ScepLogOutput3(3,0, SCEDLL_STATUS_MATCH, MsgBuf);
                    break;
                }
           }

           if ( j >= CurrentCount) {
                //
                // Add this member
                //
                ScepLogOutput3(2,0, SCEDLL_SCP_ADD, MsgBuf);

                NtStatus = SamAddMemberToAlias(
                                GroupHandle,
                                Sids[i]
                                );
                if ( !NT_SUCCESS(NtStatus) ) {
                    ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                                   SCEDLL_SCP_ERROR_ADD, MsgBuf);
                    goto Done;
                }
           }
       }
    }

    //
    // Compare the member ids with the current ids for adding
    //

    for ( i=0; i<CurrentCount; i++ ) {
#ifdef SCE_DBG
printf("process member %d for removing\n", i);
#endif
        memset(MsgBuf, '\0', 512);

        if ( ConvertSidToStringSid(
                    CurrentSids[i],
                    &StringSid
                    ) && StringSid ) {

            swprintf(MsgBuf, L"SID: %s",StringSid);
            LocalFree(StringSid);
            StringSid = NULL;

        } else {
            ScepLogOutput3(3,GetLastError(), IDS_ERROR_CONVERT_SID);
            swprintf(MsgBuf, L"Member %d",i);
        }

        for ( j=0; j<MemberCount; j++) {
            if ( Sids[j] != NULL && EqualSid( CurrentSids[i], Sids[j]) ) {

                ScepLogOutput3(3,0, SCEDLL_STATUS_MATCH, MsgBuf);
                break;
            }
        }

        if ( j >= MemberCount) {
            //
            // Find the member name
            //
            pRefDomain=NULL;
            pLsaName=NULL;

            if ( NT_SUCCESS( LsaLookupSids(
                                PolicyHandle,
                                1,
                                &(CurrentSids[i]),
                                &pRefDomain,
                                &pLsaName
                                ) ) ) {

                if ( pLsaName != NULL ) {

                    if ( pRefDomain != NULL && pRefDomain->Entries > 0 && pLsaName[0].Use != SidTypeWellKnownGroup &&
                         pRefDomain->Domains != NULL &&
                         pLsaName[0].DomainIndex != -1 &&
                         pRefDomain->Domains[pLsaName[0].DomainIndex].Name.Buffer != NULL &&
                         ScepIsSidFromAccountDomain( pRefDomain->Domains[pLsaName[0].DomainIndex].Sid ) ) {

                        wcsncpy(MsgBuf, pRefDomain->Domains[pLsaName[0].DomainIndex].Name.Buffer,
                                pRefDomain->Domains[pLsaName[0].DomainIndex].Name.Length/2);
                        MsgBuf[pRefDomain->Domains[pLsaName[0].DomainIndex].Name.Length/2] = L'\0';
                        wcscat(MsgBuf, L"\\");
                    }

                    wcsncat(MsgBuf, pLsaName[0].Name.Buffer, pLsaName[0].Name.Length/2);

                }

            }

            if ( pRefDomain != NULL ) {
                LsaFreeMemory(pRefDomain);
                pRefDomain = NULL;
            }

            if ( pLsaName != NULL ){
                LsaFreeMemory(pLsaName);
                pLsaName = NULL;
            }
            //
            // remove this member
            //
            ScepLogOutput3(2,0, SCEDLL_SCP_REMOVE, MsgBuf);

            NtStatus = SamRemoveMemberFromAlias(
                            GroupHandle,
                            CurrentSids[i]
                            );
            if ( !NT_SUCCESS(NtStatus) ) {
                ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                               SCEDLL_SCP_ERROR_REMOVE, MsgBuf);
                goto Done;
            }
        }
    }

Done:

    if ( Sids != NULL ) {
        for ( i=0; i<MemberCount; i++ ) {
            if ( Sids[i] != NULL )
                ScepFree( Sids[i] );
        }
        ScepFree( Sids );
    }

    if ( CurrentSids != NULL )
        LsaFreeMemory(CurrentSids);

    if ( MemberNames != NULL )
        RtlFreeHeap(RtlProcessHeap(), 0, MemberNames);

    if ( GroupHandle != NULL )
        SamCloseHandle( GroupHandle );

    //
    // log the tattoo value
    // if fail to get current value for the group, do not save the tattoo value
    //
    if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
        ( ProductType != NtProductLanManNt ) &&
         hSectionDomain && hSectionTattoo &&
         GrpSid && GroupSidString && bMemberQueried) {

        ScepTattooManageOneMemberListValue(
                hSectionDomain,
                hSectionTattoo,
                GroupSidString,
                wcslen(GroupSidString),
                pMemberList,
                FALSE,
                RtlNtStatusToDosError(NtStatus)
                );
    }

    // free name list
    if ( pMemberList )
        ScepFreeNameList(pMemberList);

    return(NtStatus);
}


SCESTATUS
ScepValidateGroupInAliases(
    IN SAM_HANDLE DomainHandle,
    IN SAM_HANDLE BuiltinDomainHandle,
    IN PSID GrpSid,
    IN PSCE_NAME_LIST pAliasList
    )
/* ++
Routine Description:

    This routine add the group to a list of alieses to ensure the group's
    membership.

Arguments:

    DomainHandle  - The account domain handle

    BuiltinDomainHandle - The builtin domain handle

    GrpSid   - The group's SID

    pAliasList - the list of aliases to check

-- */
{
    NTSTATUS        NtStatus;

    PSCE_NAME_LIST   pAlias;
    UNICODE_STRING  Name;
    PULONG          AliasId=NULL;
    PSID_NAME_USE   AliasUse=NULL;
    SAM_HANDLE      ThisDomain;
    SAM_HANDLE      AliasHandle=NULL;


    PWSTR pTemp;
    UNICODE_STRING uName;

    //
    // Process each alias in the list
    //
    for ( pAlias=pAliasList; pAlias != NULL; pAlias = pAlias->Next ) {

        //
        // should expect pGroup->Name has domain prefix
        //
        pTemp = wcschr(pAlias->Name, L'\\');

        if ( pTemp ) {

            //
            // check if this group is from a different domain
            //

            uName.Buffer = pAlias->Name;
            uName.Length = ((USHORT)(pTemp-pAlias->Name))*sizeof(TCHAR);

            if ( !ScepIsDomainLocal(&uName) ) {
                ScepLogOutput3(1, 0, SCEDLL_NO_MAPPINGS, pAlias->Name);
                continue;
            }

            pTemp++;

        } else {
            pTemp = pAlias->Name;
        }

        RtlInitUnicodeString( &Name, pTemp);

        NtStatus = SamLookupNamesInDomain(
                        DomainHandle,
                        1,
                        &Name,
                        &AliasId,
                        &AliasUse
                        );
        ThisDomain = DomainHandle;
        if ( NtStatus == STATUS_NONE_MAPPED ) {
            //
            // not found in account domain. Lookup in the builtin domain
            //
            NtStatus = SamLookupNamesInDomain(
                            BuiltinDomainHandle,
                            1,
                            &Name,
                            &AliasId,
                            &AliasUse
                            );
            ThisDomain=BuiltinDomainHandle;
        }
        if ( !NT_SUCCESS(NtStatus) || !AliasUse || !AliasId ) {
            ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                           SCEDLL_NO_MAPPINGS, pTemp);
            return(NtStatus);
        }
        //
        // add the group to the alias
        //

        if ( AliasUse[0] != SidTypeAlias ) {
            ScepLogOutput3(1,0, SCEDLL_ERROR_ALIAS_MEMBEROF);

            SamFreeMemory(AliasId);
            AliasId = NULL;

            SamFreeMemory(AliasUse);
            AliasUse = NULL;
            continue;  // ignore this error goto Done;
        }

        NtStatus = SamOpenAlias(
                        ThisDomain,
                        MAXIMUM_ALLOWED, // ? ALIAS_ALL_ACCESS,
                        AliasId[0],
                        &AliasHandle
                        );
        if ( !NT_SUCCESS(NtStatus) ) {
            ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                           SCEDLL_ERROR_OPEN, pAlias->Name);
            goto Done;
        }

        NtStatus = SamAddMemberToAlias(
                        AliasHandle,
                        GrpSid
                        );
        //
        // if group is already in alias, ignore the error
        //
        if ( NtStatus == STATUS_MEMBER_IN_ALIAS )
            NtStatus = STATUS_SUCCESS;

        if ( !NT_SUCCESS(NtStatus) ) {
            ScepLogOutput3(1, RtlNtStatusToDosError(NtStatus),
                           SCEDLL_SCP_ERROR_ADDTO, pAlias->Name);
            goto Done;
        }
        //
        // free memory for this group
        //
        SamCloseHandle(AliasHandle);
        AliasHandle = NULL;

        SamFreeMemory(AliasId);
        AliasId = NULL;

        SamFreeMemory(AliasUse);
        AliasUse = NULL;

    }

Done:

    if ( AliasHandle != NULL )
        SamCloseHandle(AliasHandle);

    if ( AliasId != NULL )
        SamFreeMemory(AliasId);

    if ( AliasUse != NULL )
        SamFreeMemory(AliasUse);

    return(NtStatus);
}


SCESTATUS
ScepConfigureObjectSecurity(
   IN PSCE_OBJECT_LIST pRoots,
   IN AREA_INFORMATION Area,
   IN BOOL bPolicyProp,
   IN DWORD ConfigOptions
   )
/* ++

Routine Description:

   Configure the security setting on Registry keys as specified in pObject tree

Arguments:

   pRoots   - a list of object roots to configure

   Area     - The security area to configure (registry or file)

   ObjectType - Type of the object tree
                    SCEJET_AUDITING
                    SCEJET_PERMISSION

Return value:

   SCESTATUS error codes

++ */
{


    if (Area == AREA_REGISTRY_SECURITY) {
#ifdef _WIN64
        ScepLogOutput3(0,0, SCEDLL_SCP_BEGIN_REGISTRY_64KEY);
#else
        ScepLogOutput3(0,0, SCEDLL_SCP_BEGIN_REGISTRY);
#endif
    }


    if ( bPolicyProp &&
         ScepIsSystemShutDown() ) {

        return( SCESTATUS_SERVICE_NOT_SUPPORT );
    }

    HANDLE      Token;
    SCESTATUS    rc;
    SCESTATUS    SaveStat=SCESTATUS_SUCCESS;
    DWORD       Win32rc;
    PSCE_OBJECT_LIST   pOneRoot;
    PSCE_OBJECT_CHILD_LIST   pSecurityObject=NULL;
    DWORD             FileSystemFlags;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority=SECURITY_NT_AUTHORITY;
    WCHAR       theDrive[4];
    UINT        DriveType;

    //
    // get current thread/process's token
    //
    if (!OpenThreadToken( GetCurrentThread(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          FALSE,
                          &Token)) {

        if (!OpenProcessToken( GetCurrentProcess(),
                               TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                               &Token)) {

            ScepLogOutput3(1, GetLastError(), SCEDLL_ERROR_QUERY_INFO, L"TOKEN");
            return(ScepDosErrorToSceStatus(GetLastError()));
        }
    }

    //
    // Adjust privilege for setting SACL
    //
    Win32rc = SceAdjustPrivilege( SE_SECURITY_PRIVILEGE, TRUE, Token );

    //
    // if can't adjust privilege, still continue
    //

    if ( Win32rc != NO_ERROR )
        ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_ADJUST, L"SE_SECURITY_PRIVILEGE");

    // adjust take ownership privilege
    // if fails, continue
    Win32rc = SceAdjustPrivilege( SE_TAKE_OWNERSHIP_PRIVILEGE, TRUE, Token );

    if ( Win32rc != NO_ERROR )
        ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_ADJUST, L"SE_TAKE_OWNERSHIP_PRIVILEGE");


    // create a sid for administrators
    // if fails, continue


    if ( ! NT_SUCCESS ( RtlAllocateAndInitializeSid( &IdentifierAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0,0,0,0,0,0,
                                                     &AdminsSid
                                                   ) ) ) {
        ScepLogOutput3(0,ERROR_NOT_ENOUGH_MEMORY,
                       SCEDLL_ADMINISTRATORS_SID);
    }


#ifdef _WIN64

    //
    // declaration for object tree root pointer to remember from the 64-bit phase and use
    // for 32-bit phase for regkeys (only from the HKLM root, since wow6432node resides
    // under this root only). In future, if there are more  wow6432node's that need security
    // synchronization, we will have to extend the logic on similar lines to handle them.
    //

    PSCE_OBJECT_CHILD_LIST    pHKLMSubtreeRoot = NULL;
    BOOL                      bIsHKLMSubtree = FALSE;

#endif


    // process each tree
    for ( pOneRoot=pRoots; pOneRoot != NULL; pOneRoot=pOneRoot->Next ) {

        if ( Area == AREA_FILE_SECURITY &&
             (pOneRoot->Status == SCE_STATUS_CHECK ||
              pOneRoot->Status == SCE_STATUS_NO_AUTO_INHERIT ||
              pOneRoot->Status == SCE_STATUS_OVERWRITE) ) {

            //
            // make sure the input data follows file format
            //
            if ( pOneRoot->Name[1] != L'\0' && pOneRoot->Name[1] != L':') {
                ScepLogOutput3(1, ERROR_INVALID_DATA, SCEDLL_CANNOT_FIND, pOneRoot->Name);
                continue;
            }

            //
            // check if support acl
            //
            theDrive[0] = pOneRoot->Name[0];
            theDrive[1] = L':';
            theDrive[2] = L'\\';
            theDrive[3] = L'\0';

            DriveType = GetDriveType(theDrive);

            if ( DriveType == DRIVE_FIXED ||
                 DriveType == DRIVE_RAMDISK ) {

                if ( GetVolumeInformation( theDrive,
                                          NULL,
                                          0,
                                          NULL,
                                          NULL,
                                          &FileSystemFlags,
                                          NULL,
                                          0
                                        ) == TRUE ) {

                     if ( !( FileSystemFlags & FS_PERSISTENT_ACLS)  ) {

                        pOneRoot->Status = SCE_STATUS_NO_ACL_SUPPORT;
                        ScepLogOutput3(1, 0, SCEDLL_NO_ACL_SUPPORT, theDrive);
                     }
                } else {
                    ScepLogOutput3(1, GetLastError(),
                                  SCEDLL_ERROR_QUERY_VOLUME, theDrive);
                }
            } else {

                pOneRoot->Status = SCE_STATUS_NO_ACL_SUPPORT;
                ScepLogOutput3(1, 0, SCEDLL_NO_ACL_SUPPORT, theDrive);
            }

        }

        if ( pOneRoot->Status != SCE_STATUS_CHECK &&
             pOneRoot->Status != SCE_STATUS_NO_AUTO_INHERIT &&
             pOneRoot->Status != SCE_STATUS_OVERWRITE)
            continue;

        //
        // if system is shutting down within policy propagation,
        // quit as soon as possible
        //
        if ( bPolicyProp &&
             ScepIsSystemShutDown() ) {

            rc = SCESTATUS_SERVICE_NOT_SUPPORT;
            break;
        }

        rc = ScepGetOneSection(
                        hProfile,
                        Area,
                        pOneRoot->Name,
                        bPolicyProp ? SCE_ENGINE_SCP : SCE_ENGINE_SMP,
                        (PVOID *)&pSecurityObject
                        );

        if ( rc != SCESTATUS_SUCCESS ) {
            SaveStat = rc;
            continue; //goto Done;
        }

#ifdef _WIN64

        //
        // on a 64-bit platform, if the closest ancestor of "Machine\Software\Wow6432Node"
        // specified in the template, has mode 2, we have to insert "Machine\Software\Wow6432Node"
        // in the tree in the SCE_STATUS_IGNORE mode since this 32-bit hive should not be
        // configured by SCE in the 64-bit phase (same situation for '0' mode is handled by MARTA apis)
        //

        if ( Area == AREA_REGISTRY_SECURITY ) {

            if ( _wcsnicmp(pSecurityObject->Node->ObjectFullName,
                           L"MACHINE",
                           sizeof(L"MACHINE")/sizeof(WCHAR) - 1
                           ) == 0 ){

                //
                // idea is to find mode of closest ancestor of "Machine\Software\Wow6432Node"
                //

                PSCE_OBJECT_CHILD_LIST    pSearchSwHiveNode = pSecurityObject->Node->ChildList;
                BYTE    byClosestAncestorStatus;

                //
                // we need to do the 32-bit phase only if we get in here
                // so remember HKLM ptr in the tree for 32-bit phase
                //

                pHKLMSubtreeRoot = pSecurityObject;
                bIsHKLMSubtree = TRUE;

                //
                // try to find "Machine\Software"
                //

                while ( pSearchSwHiveNode ) {

                    if ( pSearchSwHiveNode->Node &&
                        _wcsnicmp(pSearchSwHiveNode->Node->ObjectFullName + (sizeof(L"MACHINE")/sizeof(WCHAR)),
                                   L"SOFTWARE",
                                   sizeof(L"SOFTWARE")/sizeof(WCHAR) - 1
                                  ) == 0 ) {

                        //
                        // found "Machine\Software"
                        //

                        break;

                    }

                    pSearchSwHiveNode = pSearchSwHiveNode->Next;
                }

                byClosestAncestorStatus =  (pSearchSwHiveNode && pSearchSwHiveNode->Node) ? pSearchSwHiveNode->Node->Status : pHKLMSubtreeRoot->Node->Status;

                //
                // if mode of closest ancestor of "Machine\Software\Wow6432Node" is
                // SCE_STATUS_OVERWRITE or "Machine\Software" has some children
                // need to add "Machine\Software\Wow6432Node" with SCE_STATUS_IGNORE
                // to the tree
                //

                if ( ( pSearchSwHiveNode && pSearchSwHiveNode->Node &&
                       pSearchSwHiveNode->Node->ChildList != NULL) ||
                     byClosestAncestorStatus == SCE_STATUS_OVERWRITE ) {

                    rc = ScepBuildObjectTree(
                            NULL,
                            &pSecurityObject,
                            1,
                            L'\\',
                            L"MACHINE\\SOFTWARE\\WOW6432Node",
                            1,
                            SCE_STATUS_IGNORE,
                            NULL,
                            0
                            );

                    if ( rc != SCESTATUS_SUCCESS ) {
                        SaveStat = rc;

                        ScepFreeObject2Security( pSecurityObject, FALSE);
                        pSecurityObject = NULL;

                        continue; //goto Done;
                    }
                }
            }
        }

#endif

        //
        // then process each node in the list
        //
        for (PSCE_OBJECT_CHILD_LIST pTemp = pSecurityObject; pTemp != NULL; pTemp=pTemp->Next) {

            if ( pTemp->Node == NULL ) continue;

            if ( Area == AREA_FILE_SECURITY ) {
                if ( pTemp->Node->ObjectFullName[1] == L':' &&
                     pTemp->Node->ObjectFullName[2] == L'\0' ) {

                    pTemp->Node->ObjectFullName[2] = L'\\';
                    pTemp->Node->ObjectFullName[3] = L'\0';
                }
            }

            if ( bPolicyProp &&
                 ScepIsSystemShutDown() ) {

                rc = SCESTATUS_SERVICE_NOT_SUPPORT;

            } else {

                //
                // calculate the "real" security descriptor for each node
                //
                if ( Area == AREA_FILE_SECURITY ) {
                    rc = ScepCalculateSecurityToApply(
                                pTemp->Node,
                                SE_FILE_OBJECT,
                                Token,
                                &FileGenericMapping
                                );
                } else if ( Area == AREA_REGISTRY_SECURITY ) {
                    rc = ScepCalculateSecurityToApply(
                                pTemp->Node,
                                SE_REGISTRY_KEY,
                                Token,
                                &KeyGenericMapping
                                );
                }
            }

            if ( rc == SCESTATUS_SUCCESS ) {

                if ( bPolicyProp &&
                     ScepIsSystemShutDown() ) {

                    rc = SCESTATUS_SERVICE_NOT_SUPPORT;

                } else {

                    if ( Area == AREA_FILE_SECURITY ) {
                        rc = ScepConfigureObjectTree(
                                    pTemp->Node,
                                    SE_FILE_OBJECT,
                                    Token,
                                    &FileGenericMapping,
                                    ConfigOptions
                                    );

                    } else if ( Area == AREA_REGISTRY_SECURITY ) {
                        rc = ScepConfigureObjectTree(
                                    pTemp->Node,
                                    SE_REGISTRY_KEY,
                                    Token,
                                    &KeyGenericMapping,
                                    ConfigOptions
                                    );

                    } else {
                        // ds objects
                        rc = ScepConfigureDsSecurity( pTemp->Node);
                    }
                }
            }

            if ( rc != SCESTATUS_SUCCESS )
                SaveStat = rc;
        }

#ifdef _WIN64
        //
        // If 64-bit platform and AREA_REGISTRY_SECURITY and HKLM, do
        // not free the whole subtree , only free the computed SDs
        //

        if (Area == AREA_FILE_SECURITY)
            ScepFreeObject2Security( pSecurityObject, FALSE);
        else if (Area == AREA_REGISTRY_SECURITY)
            ScepFreeObject2Security( pSecurityObject, bIsHKLMSubtree);

        bIsHKLMSubtree = FALSE;
#else
        ScepFreeObject2Security( pSecurityObject, FALSE);
#endif
        pSecurityObject = NULL;

        //
        // stop right away if bPolicyProp and system is being shutdown
        //

        if (rc == SCESTATUS_SERVICE_NOT_SUPPORT)
            break;

    }

    if ( Area == AREA_REGISTRY_SECURITY ) {

        if ( SaveStat != SCESTATUS_SUCCESS ) {
            ScepLogOutput3(0,0, SCEDLL_SCP_REGISTRY_ERROR);
        } else {
            ScepLogOutput3(0,0, SCEDLL_SCP_REGISTRY_SUCCESS);
        }

    }


#ifdef _WIN64

    //
    // on a 64-bit platform, if AREA_REGISTRY_SECURITY, will have to recompute
    // security and apply for the same keys as before except that it is for the
    // 32-bit hives this time around (idea is to synchronize 64-bit and 32 bit
    // registry security). There is no need to rebuild the tree from the template.
    //

    if (rc != SCESTATUS_SERVICE_NOT_SUPPORT && Area == AREA_REGISTRY_SECURITY) {

        ScepLogOutput3(0,0, SCEDLL_SCP_BEGIN_REGISTRY_32KEY);

        if (pSecurityObject = pHKLMSubtreeRoot) {

            //
            // nothing needs to be done to the Wow6432Node that was added in SCE_STATUS_IGNORE
            // mode in the 64-bit phase since it is illegal to specify Wow6432Node in the template
            // (the plan is that registry APIs will treat "Wow6432Node" as a reserved keyname)
            //

            //
            // we will set SCE_STATUS_IGNORE mode to all immediate nodes under HKLM except
            // HKLM\Software. This will take care of HKLM or HKLM\Software being specified
            // in any mode etc. as though it was 32-bit registry configuration, since all
            // we care about now is 32-bit configuration for HKLM\Software and under
            //

            PSCE_OBJECT_CHILD_LIST    pHKLMChild = pSecurityObject->Node->ChildList;

            while ( pHKLMChild ) {

                if ( pHKLMChild->Node &&
                    _wcsnicmp(pHKLMChild->Node->ObjectFullName + (sizeof(L"MACHINE")/sizeof(WCHAR)),
                               L"SOFTWARE",
                               sizeof(L"SOFTWARE")/sizeof(WCHAR) - 1
                              ) != 0 ) {

                    //
                    // not "Machine\Software"
                    //

                    pHKLMChild->Node->Status = SCE_STATUS_IGNORE;

                }

                pHKLMChild = pHKLMChild->Next;
            }



            if ( bPolicyProp &&
                 ScepIsSystemShutDown() ) {

                rc = SCESTATUS_SERVICE_NOT_SUPPORT;

            } else {

                //
                // calculate the "real" security descriptor for each node
                //
                rc = ScepCalculateSecurityToApply(
                                                 pSecurityObject->Node,
                                                 SE_REGISTRY_WOW64_32KEY,
                                                 Token,
                                                 &KeyGenericMapping
                                                 );
            }

            if ( rc == SCESTATUS_SUCCESS ) {

                if ( bPolicyProp &&
                     ScepIsSystemShutDown() ) {

                    rc = SCESTATUS_SERVICE_NOT_SUPPORT;

                } else {

                    rc = ScepConfigureObjectTree(
                                                pSecurityObject->Node,
                                                SE_REGISTRY_WOW64_32KEY,
                                                Token,
                                                &KeyGenericMapping,
                                                ConfigOptions
                                                );

                }
            }

            //
            // Free the whole tree now (done with 32-bit phase)
            //

            ScepFreeObject2Security( pSecurityObject, FALSE);
            pSecurityObject = NULL;

            if( rc != SCESTATUS_SUCCESS ) {
                SaveStat = rc;
                ScepLogOutput3(0,0, SCEDLL_SCP_REGISTRY_ERROR);
            } else {
                ScepLogOutput3(0,0, SCEDLL_SCP_REGISTRY_SUCCESS);
            }

        }
    }

#endif


    if( AdminsSid != NULL ) {
      RtlFreeSid( AdminsSid );
      AdminsSid = NULL;
    }

    SceAdjustPrivilege( SE_SECURITY_PRIVILEGE, FALSE, Token );
    //
    // disable take ownership privilege, even for administrators
    // because by default it's disabled
    //
    SceAdjustPrivilege( SE_TAKE_OWNERSHIP_PRIVILEGE, FALSE, Token );

    CloseHandle(Token);

    if ( pSecurityObject != NULL ) {
        ScepFreeObject2Security( pSecurityObject, FALSE);
    }

    return(SaveStat);
}


DWORD
ScepConfigureSystemAuditing(
    IN PSCE_PROFILE_INFO pScpInfo,
    IN DWORD ConfigOptions
    )
/* ++

Routine Description:

   This routine configure the system security in the area of auditing which
   includes event log setting, audit event setting, SACL for registry, and
   SACL for files.

Arguments:

   scpInfo - The buffer which contains SCP info loaded from the INF file

Return value:

   SCESTATUS_SUCCESS
   SCESTATUS_NOT_ENOUGH_RESOURCE
   SCESTATUS_INVALID_PARAMETER
   SCESTATUS_OTHER_ERROR

-- */
{
    DWORD                         rc = NO_ERROR;
    DWORD                         Saverc = NO_ERROR;
    DWORD                         MaxSize=0;
    DWORD                         Retention=0;
    DWORD                         RestrictGuest=0;
    DWORD                         OldMaxSize,OldRetention,OldGuest;
    DWORD                         AuditLogRetentionPeriod, RetentionDays;
    TCHAR                         MsgBuf[256];
    DWORD                         i;
    BOOL                          bFlagSet=FALSE;

    PCWSTR                        szAuditSection=NULL;
    PSCESECTION                   hSectionDomain=NULL;
    PSCESECTION                   hSectionTattoo=NULL;

    //
    // Set audit log information. Audit Log settings are saved in the Registry
    // under System\CurrentControlSet\Services\EventLog\<LogName>\MaxSize and Retention
    //

    for ( i=0; i<3; i++) {

        if ( pScpInfo->MaximumLogSize[i] == SCE_NO_VALUE )
            MaxSize = SCE_NO_VALUE;
        else
            MaxSize = (pScpInfo->MaximumLogSize[i] - (pScpInfo->MaximumLogSize[i] % 64 )) * 1024;

        switch ( pScpInfo->AuditLogRetentionPeriod[i] ) {
        case SCE_NO_VALUE:
            Retention = SCE_NO_VALUE;
            break;
        case 2:   // manually
            Retention = MAXULONG;
            break;
        case 1:   // number of days * seconds/day
            if ( pScpInfo->RetentionDays[i] == SCE_NO_VALUE ) {
                Retention = SCE_NO_VALUE;
            } else {
                Retention = pScpInfo->RetentionDays[i] * 24 * 3600;
            }
            break;
        case 0:   // as needed
            Retention = 0;
            break;
        }

        if ( pScpInfo->RestrictGuestAccess[i] == SCE_NO_VALUE )
            RestrictGuest = SCE_NO_VALUE;
        else
            RestrictGuest = (pScpInfo->RestrictGuestAccess[i])? 1 : 0;
        //
        // Different logs have different keys in Registry
        //
        if ( MaxSize != SCE_NO_VALUE || Retention != SCE_NO_VALUE ||
             RestrictGuest != SCE_NO_VALUE ) {

            bFlagSet = TRUE;

            switch (i) {
            case 0:
                wcscpy(MsgBuf,L"System\\CurrentControlSet\\Services\\EventLog\\System");
                szAuditSection = szAuditSystemLog;
                break;
            case 1:

                wcscpy(MsgBuf,L"System\\CurrentControlSet\\Services\\EventLog\\Security");
                szAuditSection = szAuditSecurityLog;
                break;
            default:

                wcscpy(MsgBuf,L"System\\CurrentControlSet\\Services\\EventLog\\Application");
                szAuditSection = szAuditApplicationLog;
                break;
            }

            WCHAR StrBuf[2];
            _itow(i, StrBuf, 10);

            //
            // open policy sections
            //
            if ( ConfigOptions & SCE_POLICY_TEMPLATE ) {

                ScepTattooOpenPolicySections(
                              hProfile,
                              szAuditSection,
                              &hSectionDomain,
                              &hSectionTattoo
                              );
                OldMaxSize=0;
                OldRetention=0;
                OldGuest=0;
            }

            if ( MaxSize != SCE_NO_VALUE ) {

                if ( ConfigOptions & SCE_POLICY_TEMPLATE ) {

                    //
                    // query existing value
                    //
                    if ( ERROR_SUCCESS != ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                                                               MsgBuf,
                                                               L"MaxSize",
                                                               &OldMaxSize
                                                              ) )
                        OldMaxSize = SCE_NO_VALUE;
                    else
                        OldMaxSize /= 1024;
                }

                rc = ScepRegSetIntValue( HKEY_LOCAL_MACHINE,
                                      MsgBuf,
                                      L"MaxSize",
                                      MaxSize
                                    );

                //
                // compare and set if different
                //
                if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                     (OldMaxSize != SCE_NO_VALUE) ) {

                    // even if OldMaxSize = MaxSize, we still need to check if the tattoo value should be deleted
                    ScepTattooManageOneIntValue(
                             hSectionDomain,
                             hSectionTattoo,
                             L"MaximumLogSize",
                             0,
                             OldMaxSize,
                             rc
                             );
                }

                if (ConfigOptions & SCE_RSOP_CALLBACK)

                    ScepRsopLog(SCE_RSOP_AUDIT_LOG_MAXSIZE_INFO, rc, StrBuf,0,0);
            }

            if ( rc == SCESTATUS_SUCCESS && Retention != SCE_NO_VALUE ) {

                if ( ConfigOptions & SCE_POLICY_TEMPLATE ) {

                    //
                    // query existing value
                    //
                    if ( ERROR_SUCCESS == ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                                                               MsgBuf,
                                                               L"Retention",
                                                               &OldRetention
                                                              ) ) {
                        switch ( OldRetention ) {
                        case MAXULONG:   // manually
                            AuditLogRetentionPeriod = 2;
                            RetentionDays = SCE_NO_VALUE;
                            break;
                        case 0:
                            AuditLogRetentionPeriod = 0;
                            RetentionDays = SCE_NO_VALUE;
                            break;
                        default:
                            AuditLogRetentionPeriod = 1;

                            // number of days * seconds/day
                            RetentionDays = OldRetention / (24 * 3600);
                            break;
                        }
                    } else {
                        AuditLogRetentionPeriod = SCE_NO_VALUE;
                        RetentionDays = SCE_NO_VALUE;
                    }
                }

                rc = ScepRegSetIntValue( HKEY_LOCAL_MACHINE,
                                   MsgBuf,
                                   L"Retention",
                                   Retention
                                 );

                if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                     (OldRetention != SCE_NO_VALUE) ) {

                    //
                    // handle the RetentionDays first since
                    // it depends on auditlogretentionperiod
                    //
                    if ( RetentionDays != SCE_NO_VALUE ||
                         pScpInfo->RetentionDays[i] != SCE_NO_VALUE ) {

                        ScepTattooManageOneIntValueWithDependency(
                                     hSectionDomain,
                                     hSectionTattoo,
                                     L"AuditLogRetentionPeriod",
                                     0,
                                     L"RetentionDays",
                                     RetentionDays,
                                     rc
                                     );
                    }

                    ScepTattooManageOneIntValue(
                                 hSectionDomain,
                                 hSectionTattoo,
                                 L"AuditLogRetentionPeriod",
                                 0,
                                 AuditLogRetentionPeriod,
                                 rc
                                 );
                }
                if (ConfigOptions & SCE_RSOP_CALLBACK)

                    ScepRsopLog(SCE_RSOP_AUDIT_LOG_RETENTION_INFO, rc, StrBuf,0,0);
            }
            if ( rc == SCESTATUS_SUCCESS && RestrictGuest != SCE_NO_VALUE ) {

                if ( ConfigOptions & SCE_POLICY_TEMPLATE ) {

                    //
                    // query existing value
                    //
                    if ( ERROR_SUCCESS != ScepRegQueryIntValue(HKEY_LOCAL_MACHINE,
                                                               MsgBuf,
                                                               L"RestrictGuestAccess",
                                                               &OldGuest
                                                              ) )
                        OldGuest = SCE_NO_VALUE;
                }

                rc = ScepRegSetIntValue( HKEY_LOCAL_MACHINE,
                                   MsgBuf,
                                   L"RestrictGuestAccess",
                                   RestrictGuest
                                 );

                if ( (ConfigOptions & SCE_POLICY_TEMPLATE) &&
                     (OldGuest != SCE_NO_VALUE) ) {

                    ScepTattooManageOneIntValue(
                                 hSectionDomain,
                                 hSectionTattoo,
                                 L"RestrictGuestAccess",
                                 0,
                                 OldGuest,
                                 rc
                                 );
                }
                if (ConfigOptions & SCE_RSOP_CALLBACK)

                    ScepRsopLog(SCE_RSOP_AUDIT_LOG_GUEST_INFO, rc, StrBuf,0,0);
            }

            if ( hSectionDomain ) {
                SceJetCloseSection(&hSectionDomain, TRUE);
                hSectionDomain = NULL;
            }

            if ( hSectionTattoo ) {
                SceJetCloseSection(&hSectionTattoo, TRUE);
                hSectionTattoo = NULL;
            }
        }

        if ( rc != SCESTATUS_SUCCESS ) {
            Saverc = rc;
            ScepLogOutput3( 1, rc, SCEDLL_SCP_ERROR_LOGSETTINGS);
        }
    }

    if ( Saverc == SCESTATUS_SUCCESS && bFlagSet )
        ScepLogOutput3(1,0, SCEDLL_SCP_LOGSETTINGS);

    return(Saverc);

}


SCESTATUS
ScepConfigureAuditEvent(
    IN PSCE_PROFILE_INFO pScpInfo,
    IN PPOLICY_AUDIT_EVENTS_INFO auditEvent,
    IN DWORD Options,
    IN LSA_HANDLE PolicyHandle OPTIONAL
    )
{
    NTSTATUS                      status;
    LSA_HANDLE                    lsaHandle=NULL;
    DWORD                         rc = NO_ERROR;
    DWORD                         Saverc = NO_ERROR;
//    POLICY_AUDIT_FULL_SET_INFO    AuditFullSet;
    PPOLICY_AUDIT_FULL_QUERY_INFO AuditFullQry=NULL;
    ULONG i;
    ULONG dwAudit;

    SCE_TATTOO_KEYS *pTattooKeys=NULL;
    DWORD           cTattooKeys=0;

    PSCESECTION hSectionDomain=NULL;
    PSCESECTION hSectionTattoo=NULL;

#define MAX_AUDIT_KEYS          9


    if ( (Options & SCE_POLICY_TEMPLATE) &&
         ScepIsSystemShutDown() ) {

        return(SCESTATUS_SERVICE_NOT_SUPPORT);
    }

    if ( PolicyHandle == NULL ) {

        //
        // Set audit event information using LSA APIs
        //
        status = ScepOpenLsaPolicy(
                    POLICY_VIEW_AUDIT_INFORMATION |
                    POLICY_SET_AUDIT_REQUIREMENTS |
                    POLICY_AUDIT_LOG_ADMIN,
                    &lsaHandle,
                    ( Options & (SCE_POLICY_TEMPLATE | SCE_SYSTEM_DB) ) ? TRUE : FALSE // do not notify policy filter if within policy prop
                    );

        if (status != ERROR_SUCCESS) {

            lsaHandle = NULL;
            rc = RtlNtStatusToDosError( status );

            ScepLogOutput3( 1, rc, SCEDLL_LSA_POLICY);

            if (Options & SCE_RSOP_CALLBACK)

                ScepRsopLog(SCE_RSOP_AUDIT_EVENT_INFO, rc, NULL,0,0);

            return(ScepDosErrorToSceStatus(rc));
        }

    } else {
        lsaHandle = PolicyHandle;
    }

    if ( (Options & SCE_POLICY_TEMPLATE) &&
        ( ProductType != NtProductLanManNt ) ) {
        //
        // save off the current auditing settings
        //
        pTattooKeys = (SCE_TATTOO_KEYS *)ScepAlloc(LPTR,MAX_AUDIT_KEYS*sizeof(SCE_TATTOO_KEYS));

        if ( !pTattooKeys ) {
            ScepLogOutput3(1, ERROR_NOT_ENOUGH_MEMORY, SCESRV_POLICY_TATTOO_ERROR_CREATE);
        }
    }

    //
    // Set audit event information
    //

    if ( !auditEvent->AuditingMode ) {
        // reset the event array
        for ( i=0; i<auditEvent->MaximumAuditEventCount; i++ )
           auditEvent->EventAuditingOptions[i] = POLICY_AUDIT_EVENT_NONE;
    }
    //
    // process each event
    //
    i=0;
    if ( (pScpInfo->AuditSystemEvents != SCE_NO_VALUE) ) {

        dwAudit = (auditEvent->EventAuditingOptions[AuditCategorySystem] & ~POLICY_AUDIT_EVENT_NONE );
        ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                 (PWSTR)L"AuditSystemEvents", Options,
                                 dwAudit );

        if ( (pScpInfo->AuditSystemEvents != dwAudit) ) {

            auditEvent->EventAuditingOptions[AuditCategorySystem] =
                    (pScpInfo->AuditSystemEvents & POLICY_AUDIT_EVENT_SUCCESS) |
                    (pScpInfo->AuditSystemEvents & POLICY_AUDIT_EVENT_FAILURE) |
                    POLICY_AUDIT_EVENT_NONE;
            i=1;
        }
    }

    if ( (pScpInfo->AuditLogonEvents != SCE_NO_VALUE) ) {

        dwAudit = (auditEvent->EventAuditingOptions[AuditCategoryLogon] & ~POLICY_AUDIT_EVENT_NONE );
        ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                 (PWSTR)L"AuditLogonEvents", Options,
                                 dwAudit );

        if ( (pScpInfo->AuditLogonEvents != dwAudit) ) {

            auditEvent->EventAuditingOptions[AuditCategoryLogon]  =
                    (pScpInfo->AuditLogonEvents & POLICY_AUDIT_EVENT_SUCCESS) |
                    (pScpInfo->AuditLogonEvents & POLICY_AUDIT_EVENT_FAILURE) |
                    POLICY_AUDIT_EVENT_NONE;
            i=1;
        }
    }

    if ( (pScpInfo->AuditObjectAccess != SCE_NO_VALUE) ) {

        dwAudit = (auditEvent->EventAuditingOptions[AuditCategoryObjectAccess] & ~POLICY_AUDIT_EVENT_NONE );
        ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                 (PWSTR)L"AuditObjectAccess", Options,
                                 dwAudit );

        if ( (pScpInfo->AuditObjectAccess != dwAudit) ) {

            auditEvent->EventAuditingOptions[AuditCategoryObjectAccess] =
                    (pScpInfo->AuditObjectAccess & POLICY_AUDIT_EVENT_SUCCESS) |
                    (pScpInfo->AuditObjectAccess & POLICY_AUDIT_EVENT_FAILURE) |
                    POLICY_AUDIT_EVENT_NONE;
            i=1;
        }
    }

    if ( (pScpInfo->AuditPrivilegeUse != SCE_NO_VALUE) ) {

        dwAudit = (auditEvent->EventAuditingOptions[AuditCategoryPrivilegeUse] & ~POLICY_AUDIT_EVENT_NONE );
        ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                 (PWSTR)L"AuditPrivilegeUse", Options,
                                 dwAudit );

        if ( (pScpInfo->AuditPrivilegeUse != dwAudit) ) {

            auditEvent->EventAuditingOptions[AuditCategoryPrivilegeUse] =
                    (pScpInfo->AuditPrivilegeUse & POLICY_AUDIT_EVENT_SUCCESS) |
                    (pScpInfo->AuditPrivilegeUse & POLICY_AUDIT_EVENT_FAILURE) |
                    POLICY_AUDIT_EVENT_NONE;
            i=1;
        }
    }

    if ( (pScpInfo->AuditProcessTracking != SCE_NO_VALUE) ) {

        dwAudit = (auditEvent->EventAuditingOptions[AuditCategoryDetailedTracking] & ~POLICY_AUDIT_EVENT_NONE );
        ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                 (PWSTR)L"AuditProcessTracking", Options,
                                 dwAudit );

        if ( (pScpInfo->AuditProcessTracking != dwAudit) ) {

            auditEvent->EventAuditingOptions[AuditCategoryDetailedTracking] =
                    (pScpInfo->AuditProcessTracking & POLICY_AUDIT_EVENT_SUCCESS) |
                    (pScpInfo->AuditProcessTracking & POLICY_AUDIT_EVENT_FAILURE) |
                    POLICY_AUDIT_EVENT_NONE;
            i=1;
        }
    }

    if ( (pScpInfo->AuditPolicyChange != SCE_NO_VALUE) ) {

        dwAudit = (auditEvent->EventAuditingOptions[AuditCategoryPolicyChange] & ~POLICY_AUDIT_EVENT_NONE );
        ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                 (PWSTR)L"AuditPolicyChange", Options,
                                 dwAudit );

        if ( (pScpInfo->AuditPolicyChange != dwAudit) ) {

            auditEvent->EventAuditingOptions[AuditCategoryPolicyChange] =
                    (pScpInfo->AuditPolicyChange & POLICY_AUDIT_EVENT_SUCCESS) |
                    (pScpInfo->AuditPolicyChange & POLICY_AUDIT_EVENT_FAILURE) |
                    POLICY_AUDIT_EVENT_NONE;
            i=1;
        }
    }

    if ( (pScpInfo->AuditAccountManage != SCE_NO_VALUE) ) {

        dwAudit = (auditEvent->EventAuditingOptions[AuditCategoryAccountManagement] & ~POLICY_AUDIT_EVENT_NONE );
        ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                 (PWSTR)L"AuditAccountManage", Options,
                                 dwAudit );

        if ( (pScpInfo->AuditAccountManage != dwAudit) ) {

            auditEvent->EventAuditingOptions[AuditCategoryAccountManagement] =
                    (pScpInfo->AuditAccountManage & POLICY_AUDIT_EVENT_SUCCESS) |
                    (pScpInfo->AuditAccountManage & POLICY_AUDIT_EVENT_FAILURE) |
                    POLICY_AUDIT_EVENT_NONE;
            i=1;
        }
    }

    if ( (pScpInfo->AuditDSAccess != SCE_NO_VALUE) ) {

        dwAudit = (auditEvent->EventAuditingOptions[AuditCategoryDirectoryServiceAccess] & ~POLICY_AUDIT_EVENT_NONE );
        ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                 (PWSTR)L"AuditDSAccess", Options,
                                 dwAudit );

        if ( (pScpInfo->AuditDSAccess != dwAudit) ) {

            auditEvent->EventAuditingOptions[AuditCategoryDirectoryServiceAccess] =
                    (pScpInfo->AuditDSAccess & POLICY_AUDIT_EVENT_SUCCESS) |
                    (pScpInfo->AuditDSAccess & POLICY_AUDIT_EVENT_FAILURE) |
                    POLICY_AUDIT_EVENT_NONE;
            i=1;
        }
    }

    if ( (pScpInfo->AuditAccountLogon != SCE_NO_VALUE) ) {

        dwAudit = (auditEvent->EventAuditingOptions[AuditCategoryAccountLogon] & ~POLICY_AUDIT_EVENT_NONE );
        ScepTattooCheckAndUpdateArray(pTattooKeys, &cTattooKeys,
                                 (PWSTR)L"AuditAccountLogon", Options,
                                 dwAudit );

        if ( (pScpInfo->AuditAccountLogon != dwAudit) ) {

            auditEvent->EventAuditingOptions[AuditCategoryAccountLogon] =
                    (pScpInfo->AuditAccountLogon & POLICY_AUDIT_EVENT_SUCCESS) |
                    (pScpInfo->AuditAccountLogon & POLICY_AUDIT_EVENT_FAILURE) |
                    POLICY_AUDIT_EVENT_NONE;
            i=1;
        }
    }

    if ( i ) {
        //
        // there are some settings to configure
        //
        auditEvent->AuditingMode = FALSE;
        for ( i=0; i<auditEvent->MaximumAuditEventCount; i++ ) {
            if ( auditEvent->EventAuditingOptions[i] & ~POLICY_AUDIT_EVENT_NONE ) {
                auditEvent->AuditingMode = TRUE;
                break;
            }
        }

        status = LsaSetInformationPolicy( lsaHandle,
                                          PolicyAuditEventsInformation,
                                          (PVOID)auditEvent
                                        );
        rc = RtlNtStatusToDosError( status );

        if ( rc != NO_ERROR ) {
            ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_EVENT_AUDITING);

            Saverc = rc;
        } else {
            ScepLogOutput3(1, 0, SCEDLL_SCP_EVENT_AUDITING);
        }
        //
        // turn the mode off so auditing won't be "restored" at the end of configuration
        //

        auditEvent->AuditingMode = FALSE;
    }

    if ( (Options & SCE_POLICY_TEMPLATE) &&
        ( ProductType != NtProductLanManNt ) &&
         pTattooKeys && cTattooKeys ) {

        ScepTattooOpenPolicySections(
                      hProfile,
                      szAuditEvent,
                      &hSectionDomain,
                      &hSectionTattoo
                      );
        //
        // some policy is different than the system setting
        // check if we should save the existing setting as the tattoo value
        // also remove reset'ed tattoo policy
        //
        ScepLogOutput3(3,0,SCESRV_POLICY_TATTOO_ARRAY,cTattooKeys);

        ScepTattooManageValues(hSectionDomain, hSectionTattoo, pTattooKeys, cTattooKeys, rc);

        if ( hSectionDomain ) SceJetCloseSection(&hSectionDomain,TRUE);
        if ( hSectionTattoo ) SceJetCloseSection(&hSectionTattoo,TRUE);

    }

    if ( pTattooKeys )
        ScepFree(pTattooKeys);

    if (Options & SCE_RSOP_CALLBACK)

        ScepRsopLog(SCE_RSOP_AUDIT_EVENT_INFO, rc, NULL,0,0);

    if ( lsaHandle && (PolicyHandle != lsaHandle) )
        LsaClose( lsaHandle );

    return(ScepDosErrorToSceStatus(Saverc));

}


SCESTATUS
ScepConfigureDeInitialize(
     IN SCESTATUS  rc,
     IN AREA_INFORMATION Area
     )

/*++
Routine Description:

   This routine de-initialize the SCP engine. The operations include

      clear SCE_PROFILE_INFO buffer and close the SCP profile
      close the error log file
      reset the status

Arguments:

        rc      - SCESTATUS error code (from other routines)

    Area    - one or more area configured

Return value:

    SCESTATUS error code

++*/
{
    if ( rc == SCESTATUS_ALREADY_RUNNING ) {
        return(SCESTATUS_SUCCESS);
    }

    //
    // free LSA handle
    //
    if ( LsaPrivatePolicy ) {

        ScepNotifyLogPolicy(0, TRUE, L"Policy Prop: Private LSA handle is to be released", 0, 0, NULL );

        LsaClose(LsaPrivatePolicy);
        LsaPrivatePolicy = NULL;

    }

    //
    // Free memory and close the SCP profile
    //

    SceFreeMemory( (PVOID)pScpInfo, Area );

    cbClientFlag = 0;
    gTotalTicks = 0;
    gCurrentTicks = 0;
    gWarningCode = 0;

    if ( hProfile != NULL ) {

       SceJetCloseFile( hProfile, TRUE, FALSE );
    }

    hProfile = NULL;

    return(SCESTATUS_SUCCESS);


}


SCESTATUS
ScepDeleteInfoForAreas(
    IN PSCECONTEXT hProfile,
    IN SCETYPE tblType,
    IN AREA_INFORMATION Area
    )
{
    SCESTATUS saveRc=SCESTATUS_SUCCESS, rc;
    PSCE_SERVICES pServices=NULL, pNode;
    PSCE_NAME_LIST pList=NULL, pnl;

    if ( Area & AREA_SECURITY_POLICY ) {
        //
        // delete szSystemAccess section info
        //
        rc = ScepDeleteOneSection(
                 hProfile,
                 tblType,
                 szSystemAccess
                 );
        if ( saveRc == SCESTATUS_SUCCESS )
            saveRc = rc;

        //
        // delete szAuditSystemLog section info
        //
        rc = ScepDeleteOneSection(
                 hProfile,
                 tblType,
                 szAuditSystemLog
                 );
        if ( saveRc == SCESTATUS_SUCCESS )
            saveRc = rc;

        //
        // delete szAuditSecurityLog section info
        //
        rc = ScepDeleteOneSection(
                 hProfile,
                 tblType,
                 szAuditSecurityLog
                 );
        if ( saveRc == SCESTATUS_SUCCESS )
            saveRc = rc;

        //
        // delete szAuditApplicationLog section info
        //
        rc = ScepDeleteOneSection(
                 hProfile,
                 tblType,
                 szAuditApplicationLog
                 );
        if ( saveRc == SCESTATUS_SUCCESS )
            saveRc = rc;

        //
        // delete szAuditEvent section info
        //
        rc = ScepDeleteOneSection(
                 hProfile,
                 tblType,
                 szAuditEvent
                 );
        if ( saveRc == SCESTATUS_SUCCESS )
            saveRc = rc;

        //
        // delete szKerberosPolicy section info
        //
        rc = ScepDeleteOneSection(
                 hProfile,
                 tblType,
                 szKerberosPolicy
                 );
        if ( saveRc == SCESTATUS_SUCCESS )
            saveRc = rc;

        //
        // delete szRegistryValues section info
        //
        rc = ScepDeleteOneSection(
                 hProfile,
                 tblType,
                 szRegistryValues
                 );
        if ( saveRc == SCESTATUS_SUCCESS )
            saveRc = rc;

        //
        // delete each attachment's sections
        //
        rc = ScepEnumServiceEngines( &pServices, SCE_ATTACHMENT_POLICY );

        if ( rc == SCESTATUS_SUCCESS ) {

            for ( pNode = pServices; pNode != NULL; pNode=pNode->Next ) {

                rc = ScepDeleteOneSection(
                         hProfile,
                         tblType,
                         (PCWSTR)(pNode->ServiceName)
                         );

                if ( saveRc == SCESTATUS_SUCCESS )
                    saveRc = rc;
            }

            SceFreePSCE_SERVICES( pServices );

        } else if ( rc != SCESTATUS_PROFILE_NOT_FOUND &&
                    rc != SCESTATUS_RECORD_NOT_FOUND &&
                    saveRc == SCESTATUS_SUCCESS ) {
            saveRc = rc;
        }

    }

    if ( Area & AREA_PRIVILEGES ) {
        //
        // delete szPrivilegeRights section info
        //
        rc = ScepDeleteOneSection(
                 hProfile,
                 tblType,
                 szPrivilegeRights
                 );
        if ( saveRc == SCESTATUS_SUCCESS )
            saveRc = rc;

    }
    if ( Area & AREA_GROUP_MEMBERSHIP ) {

        //
        // delete szGroupMembership section info
        //
        rc = ScepDeleteOneSection(
                 hProfile,
                 tblType,
                 szGroupMembership
                 );
        if ( saveRc == SCESTATUS_SUCCESS )
            saveRc = rc;
    }

    if ( Area & AREA_USER_SETTINGS ) {
        //
        // later - delete the list of profiles/users first
        //

        //
        // delete szAccountProfiles/szUserList section info
        //
        if ( tblType == SCEJET_TABLE_SAP) {
            rc = ScepDeleteOneSection(
                 hProfile,
                 tblType,
                 szUserList
                 );
        } else {
            rc = ScepDeleteOneSection(
                 hProfile,
                 tblType,
                 szAccountProfiles
                 );
        }
        if ( saveRc == SCESTATUS_SUCCESS )
            saveRc = rc;
    }

    if ( Area & AREA_FILE_SECURITY ) {

        //
        // delete szFileSecurity section info
        //
        rc = ScepDeleteOneSection(
                 hProfile,
                 tblType,
                 szFileSecurity
                 );
        if ( saveRc == SCESTATUS_SUCCESS )
            saveRc = rc;
    }

    if ( Area & AREA_REGISTRY_SECURITY ) {

        //
        // delete szRegistryKeys section info
        //
        rc = ScepDeleteOneSection(
                 hProfile,
                 tblType,
                 szRegistryKeys
                 );
        if ( saveRc == SCESTATUS_SUCCESS )
            saveRc = rc;
    }

    if ( Area & AREA_DS_OBJECTS ) {

        //
        // delete szDSSecurity section info
        //
        rc = ScepDeleteOneSection(
                 hProfile,
                 tblType,
                 szDSSecurity
                 );
        if ( saveRc == SCESTATUS_SUCCESS )
            saveRc = rc;
    }

    if ( Area & AREA_SYSTEM_SERVICE ) {

        //
        // delete szServiceGeneral section info
        //
        rc = ScepDeleteOneSection(
                 hProfile,
                 tblType,
                 szServiceGeneral
                 );
        if ( saveRc == SCESTATUS_SUCCESS )
            saveRc = rc;
        //
        // delete each attachment's sections
        //
        rc = ScepEnumServiceEngines( &pServices, SCE_ATTACHMENT_SERVICE );

        if ( rc == SCESTATUS_SUCCESS ) {

            for ( pNode = pServices; pNode != NULL; pNode=pNode->Next ) {

                rc = ScepDeleteOneSection(
                         hProfile,
                         tblType,
                         (PCWSTR)(pNode->ServiceName)
                         );

                if ( saveRc == SCESTATUS_SUCCESS )
                    saveRc = rc;
            }

            SceFreePSCE_SERVICES( pServices );

        } else if ( rc != SCESTATUS_PROFILE_NOT_FOUND &&
                    rc != SCESTATUS_RECORD_NOT_FOUND &&
                    saveRc == SCESTATUS_SUCCESS ) {
            saveRc = rc;
        }
    }

    if ( Area & AREA_ATTACHMENTS ) {
        //
        // delete attachment sections
        //
        rc = ScepEnumAttachmentSections( hProfile, &pList);

        if ( rc == SCESTATUS_SUCCESS ) {

            for ( pnl = pList; pnl != NULL; pnl=pnl->Next ) {

                rc = ScepDeleteOneSection(
                         hProfile,
                         tblType,
                         (PCWSTR)(pnl->Name)
                         );

                if ( saveRc == SCESTATUS_SUCCESS )
                    saveRc = rc;
            }

            ScepFreeNameList( pList );

        } else if ( rc != SCESTATUS_PROFILE_NOT_FOUND &&
                    rc != SCESTATUS_RECORD_NOT_FOUND &&
                    saveRc == SCESTATUS_SUCCESS ) {
            saveRc = rc;
        }
    }

    return(saveRc);
}


SCESTATUS
ScepMakePolicyIntoFile(
    IN DWORD Options,
    IN AREA_INFORMATION Area
    )
{

    SCESTATUS rc=SCESTATUS_SUCCESS;

    if ( Options & SCE_COPY_LOCAL_POLICY ) {

        PSCE_PROFILE_INFO pTmpBuffer=NULL;

        HINSTANCE hSceCliDll = LoadLibrary(TEXT("scecli.dll"));

        if ( hSceCliDll) {
            PFSCEINFWRITEINFO pfSceInfWriteInfo = (PFSCEINFWRITEINFO)GetProcAddress(
                                                           hSceCliDll,
                                                           "SceWriteSecurityProfileInfo");
            if ( pfSceInfWriteInfo ) {

                //
                // have to query the current system setting for privileges
                // because IIS/MTS accounts do not exist in our database
                // we only support AREA_SECURITY_POLICY and AREA_PRIVILEGES
                //

                TCHAR Buffer[MAX_PATH+1];
                TCHAR FileName[MAX_PATH+50];

                Buffer[0] = L'\0';
                GetSystemWindowsDirectory(Buffer, MAX_PATH);
                Buffer[MAX_PATH] = L'\0';

                if ( Area & AREA_SECURITY_POLICY ) {

                    //
                    // get other area's information (AREA_SECURITY_POLICY)
                    //
                    rc = ScepGetDatabaseInfo(
                                hProfile,
                                SCE_ENGINE_SMP,
                                AREA_SECURITY_POLICY,
                                0,
                                &pTmpBuffer,
                                NULL
                                );

                    if ( SCESTATUS_SUCCESS == rc ) {

                        wcscpy(FileName, Buffer);
                        wcscat(FileName, L"\\security\\FirstDGPO.inf\0");

                        rc = ScepWriteOneAttributeToFile(szSystemAccess,
                                                         (LPCTSTR)FileName,
                                                         TEXT("MinimumPasswordAge"),
                                                         pTmpBuffer->MinimumPasswordAge
                                                        );

                        if ( ERROR_SUCCESS == rc ) {
                            rc = ScepWriteOneAttributeToFile(szSystemAccess,
                                                             (LPCTSTR)FileName,
                                                             TEXT("MaximumPasswordAge"),
                                                             pTmpBuffer->MaximumPasswordAge
                                                            );
                        }

                        if ( ERROR_SUCCESS == rc ) {

                            rc = ScepWriteOneAttributeToFile(szSystemAccess,
                                                             (LPCTSTR)FileName,
                                                             TEXT("MinimumPasswordLength"),
                                                             pTmpBuffer->MinimumPasswordLength
                                                            );
                        }

                        if ( ERROR_SUCCESS == rc ) {

                            rc = ScepWriteOneAttributeToFile(szSystemAccess,
                                                             (LPCTSTR)FileName,
                                                             TEXT("PasswordComplexity"),
                                                             pTmpBuffer->PasswordComplexity
                                                            );
                        }

                        if ( ERROR_SUCCESS == rc ) {

                            rc = ScepWriteOneAttributeToFile(szSystemAccess,
                                                             (LPCTSTR)FileName,
                                                             TEXT("PasswordHistorySize"),
                                                             pTmpBuffer->PasswordHistorySize
                                                            );
                        }

                        if ( ERROR_SUCCESS == rc ) {

                            rc = ScepWriteOneAttributeToFile(szSystemAccess,
                                                             (LPCTSTR)FileName,
                                                             TEXT("LockoutBadCount"),
                                                             pTmpBuffer->LockoutBadCount
                                                            );
                        }

                        if ( ERROR_SUCCESS == rc ) {

                            rc = ScepWriteOneAttributeToFile(szSystemAccess,
                                                             (LPCTSTR)FileName,
                                                             TEXT("ResetLockoutCount"),
                                                             pTmpBuffer->ResetLockoutCount
                                                            );
                        }

                        if ( ERROR_SUCCESS == rc ) {

                            rc = ScepWriteOneAttributeToFile(szSystemAccess,
                                                             (LPCTSTR)FileName,
                                                             TEXT("LockoutDuration"),
                                                             pTmpBuffer->LockoutDuration
                                                            );
                        }

                        if ( ERROR_SUCCESS == rc ) {

                            rc = ScepWriteOneAttributeToFile(szSystemAccess,
                                                             (LPCTSTR)FileName,
                                                             TEXT("RequireLogonToChangePassword"),
                                                             pTmpBuffer->RequireLogonToChangePassword
                                                            );
                        }

                        if ( ERROR_SUCCESS == rc ) {

                            rc = ScepWriteOneAttributeToFile(szSystemAccess,
                                                             (LPCTSTR)FileName,
                                                             TEXT("ForceLogoffWhenHourExpire"),
                                                             pTmpBuffer->ForceLogoffWhenHourExpire
                                                            );
                        }

                        if ( ERROR_SUCCESS == rc ) {

                            rc = ScepWriteOneAttributeToFile(szSystemAccess,
                                                             (LPCTSTR)FileName,
                                                             TEXT("ClearTextPassword"),
                                                             pTmpBuffer->ClearTextPassword
                                                            );
                        }

                        if ( ERROR_SUCCESS == rc && pTmpBuffer->pKerberosInfo ) {

                            rc = ScepWriteOneAttributeToFile(szKerberosPolicy,
                                                             (LPCTSTR)FileName,
                                                             TEXT("MaxTicketAge"),
                                                             pTmpBuffer->pKerberosInfo->MaxTicketAge
                                                            );
                            if ( ERROR_SUCCESS == rc ) {
                                rc = ScepWriteOneAttributeToFile(szKerberosPolicy,
                                                                 (LPCTSTR)FileName,
                                                                 TEXT("MaxRenewAge"),
                                                                 pTmpBuffer->pKerberosInfo->MaxRenewAge
                                                                );
                            }
                            if ( ERROR_SUCCESS == rc ) {
                                rc = ScepWriteOneAttributeToFile(szKerberosPolicy,
                                                                 (LPCTSTR)FileName,
                                                                 TEXT("MaxServiceAge"),
                                                                 pTmpBuffer->pKerberosInfo->MaxServiceAge
                                                                );
                            }
                            if ( ERROR_SUCCESS == rc ) {
                                rc = ScepWriteOneAttributeToFile(szKerberosPolicy,
                                                                 (LPCTSTR)FileName,
                                                                 TEXT("MaxClockSkew"),
                                                                 pTmpBuffer->pKerberosInfo->MaxClockSkew
                                                                );
                            }
                            if ( ERROR_SUCCESS == rc ) {
                                rc = ScepWriteOneAttributeToFile(szKerberosPolicy,
                                                                 (LPCTSTR)FileName,
                                                                 TEXT("TicketValidateClient"),
                                                                 pTmpBuffer->pKerberosInfo->TicketValidateClient
                                                                );
                            }
                        }

                        if ( ERROR_SUCCESS == rc ) {
                            //
                            // make sure to delete the local policy sections
                            //
                            WritePrivateProfileSection(
                                                szAuditSystemLog,
                                                NULL,
                                                (LPCTSTR)FileName);

                            WritePrivateProfileSection(
                                                szAuditSecurityLog,
                                                NULL,
                                                (LPCTSTR)FileName);

                            WritePrivateProfileSection(
                                                szAuditApplicationLog,
                                                NULL,
                                                (LPCTSTR)FileName);

                            WritePrivateProfileSection(
                                                szAuditEvent,
                                                NULL,
                                                (LPCTSTR)FileName);

                            WritePrivateProfileSection(
                                                szRegistryValues,
                                                NULL,
                                                (LPCTSTR)FileName);


                        }

                        ScepLogOutput3(1, rc, IDS_COPY_DOMAIN_GPO);

                        rc = ScepDosErrorToSceStatus(rc);

                        if ( SCESTATUS_SUCCESS == rc ) {

                            wcscpy(FileName, Buffer);
                            wcscat(FileName, L"\\security\\FirstOGPO.inf\0");
                            //
                            // do not write registry value section
                            //
                            DWORD                       RegValueCount;
                            PSCE_REGISTRY_VALUE_INFO    pSaveRegValues;

                            RegValueCount = pTmpBuffer->RegValueCount;
                            pSaveRegValues = pTmpBuffer->aRegValues;

                            pTmpBuffer->RegValueCount = 0;
                            pTmpBuffer->aRegValues = NULL;

                            rc = (*pfSceInfWriteInfo)(
                                            FileName,
                                            AREA_SECURITY_POLICY,
                                            pTmpBuffer,
                                            NULL
                                            );
                            //
                            // restore the buffer
                            //

                            pTmpBuffer->RegValueCount = RegValueCount;
                            pTmpBuffer->aRegValues = pSaveRegValues;

                            if ( SCESTATUS_SUCCESS == rc ) {
                                //
                                // delete the domain policy sections from this file
                                //
                                WritePrivateProfileSection(
                                                    szSystemAccess,
                                                    NULL,
                                                    (LPCTSTR)FileName);

                                WritePrivateProfileSection(
                                                    szKerberosPolicy,
                                                    NULL,
                                                    (LPCTSTR)FileName);
/*
                                WritePrivateProfileSection(
                                                    szRegistryValues,
                                                    NULL,
                                                    (LPCTSTR)FileName);
*/
                            }

                            ScepLogOutput3(1, rc, IDS_COPY_OU_GPO);
                        }

                        //
                        // free the temp buffer
                        //
                        SceFreeMemory((PVOID)pTmpBuffer, Area);

                    } else {

                        ScepLogOutput2(1, ScepSceStatusToDosError(rc), L"Unable to read security policy from database");
                    }
                }

                if ( (SCESTATUS_SUCCESS == rc) &&
                     (Area & AREA_PRIVILEGES) ) {

                    //
                    // privileges must be processed separately
                    // because they are saved in the GPO template
                    // as "Add/Remove" format
                    //

                    wcscpy(FileName, Buffer);
                    wcscat(FileName, L"\\security\\FirstOGPO.inf\0");

                    //
                    // if security policy is also requested, this must be an upgrade
                    //

                    rc = ScepCopyPrivilegesIntoFile(FileName,
                                                    (Area & AREA_SECURITY_POLICY)  //TRUE upgrade
                                                    );

                    if ( Area & AREA_SECURITY_POLICY ) {
                        ScepLogOutput3(1, ScepSceStatusToDosError(rc), IDS_COPY_PRIVILEGE_UPGRADE);
                    } else {
                        ScepLogOutput3(1, ScepSceStatusToDosError(rc), IDS_COPY_PRIVILEGE_FRESH);
                    }
                }

            } else {

                ScepLogOutput3(1, GetLastError(), IDS_ERROR_GET_PROCADDR, L"SceWriteSecurityProfileInfo");
                rc = SCESTATUS_MOD_NOT_FOUND;
            }

            FreeLibrary(hSceCliDll);

        } else {

            ScepLogOutput3(1, GetLastError(), SCEDLL_ERROR_LOAD, L"scecli.dll");
            rc = SCESTATUS_MOD_NOT_FOUND;
        }

    }

    return rc;
}


DWORD
ScepWriteOneAttributeToFile(
    IN LPCTSTR SectionName,
    IN LPCTSTR FileName,
    IN LPCTSTR KeyName,
    IN DWORD dwValue
    )
{

    TCHAR valBuf[20];
    DWORD rc=NO_ERROR;

    if ( dwValue != SCE_NO_VALUE ) {

        swprintf(valBuf, L"%d", dwValue);

        if ( !WritePrivateProfileString(SectionName,
                                        KeyName,
                                        (LPCTSTR)valBuf,
                                        FileName
                                       ) ) {
            rc = GetLastError();
        }
    }

    return rc;
}


SCESTATUS
ScepCopyPrivilegesIntoFile(
    IN LPTSTR FileName,
    IN BOOL bInUpgrade
    )
{
    if ( FileName == NULL ) {
        return SCESTATUS_INVALID_PARAMETER;
    }

    SCESTATUS   rc;
    HINF        hInf;

    rc = SceInfpOpenProfile(
                FileName,
                &hInf
                );
    if ( SCESTATUS_SUCCESS != rc ) {
        return rc;
    }

    INFCONTEXT  InfLine;
    WCHAR       Keyname[SCE_KEY_MAX_LENGTH];
    PWSTR       StrValue=NULL;
    DWORD       ValueLen=0;
    TCHAR       TmpNull[2];

    LSA_HANDLE  LsaPolicy=NULL;

    TmpNull[0] = L'\0';
    TmpNull[1] = L'\0';

    PSCESECTION  hSection=NULL;

    if ( SetupFindFirstLine(hInf,szPrivilegeRights,NULL,&InfLine) ) {

        //
        // do not need database access to get privilege
        // must query from system at real time
        //

        //
        // process each line in the section and save to the scp table.
        // Each INF line has a key and a value.
        //

        do {

            memset(Keyname, '\0', SCE_KEY_MAX_LENGTH*sizeof(TCHAR));
            rc = SCESTATUS_BAD_FORMAT;

            if ( SetupGetStringField(&InfLine, 0, Keyname, SCE_KEY_MAX_LENGTH, NULL) ) {

                //
                // do not save new privileges into the policy file because
                // W2K clients (DCs) do not support them.
                //
                for (DWORD i=cPrivW2k; i<cPrivCnt; i++) {
                    if ( _wcsicmp(Keyname, SCE_Privileges[i].Name) == 0 )
                        break;
                }
                if ( i < cPrivCnt ) {
                    // this is a new user right
                    // do not save it in policy

                    rc = SCESTATUS_SUCCESS;

                    if ( !WritePrivateProfileString(szPrivilegeRights,
                                                    Keyname,
                                                    NULL,
                                                    FileName
                                                   ) ) {
                        rc = ScepDosErrorToSceStatus(GetLastError());
                    }

                    ScepLogOutput3( 1, ScepDosErrorToSceStatus(rc), SCEDLL_ERROR_IGNORE_POLICY, Keyname);

                    continue;
                }

                if ( SetupGetMultiSzField(&InfLine, 1, NULL, 0, &ValueLen) ) {

                    if ( ValueLen > 1 ) {
                        //
                        // allocate buffer for the multi string
                        //
                        StrValue = (PWSTR)ScepAlloc( LMEM_ZEROINIT,
                                                    (ValueLen+1)*sizeof(TCHAR));

                        if( StrValue == NULL ) {
                            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                        } else if( SetupGetMultiSzField(&InfLine, 1, StrValue, ValueLen, NULL) ) {

                            rc = SCESTATUS_SUCCESS;

                        } else {
                            ScepFree(StrValue);
                            StrValue = NULL;
                        }

                    } else
                        rc = SCESTATUS_SUCCESS;

                    if ( rc == SCESTATUS_SUCCESS ) {

                        //
                        // another format for user rights (ADD: REMOVE:...)
                        // Note, if this is within dcpromo upgrade, the current boot
                        // is in the temperatory SAM hive (with a bogus domain SID)
                        // IIS/MTS users created during this boot are bogus
                        // and any users from the NT4 account domain/trusted domain
                        // can't be resolved at this moment.
                        // So do not enumerate current privileges, instead, use
                        // the settings from local security database.
                        //
                        PWSTR NewValue=NULL;
                        DWORD NewLen=0;

                        rc = ScepBuildNewPrivilegeList(&LsaPolicy,
                                                       Keyname,
                                                       StrValue ? StrValue : TmpNull,
                                                       SCE_BUILD_ENUMERATE_PRIV,
                                                       &NewValue,
                                                       &NewLen);

                        if ( StrValue ) {
                            ScepFree(StrValue);
                        }

                        if ( rc == SCESTATUS_SUCCESS ) {

                            //
                            // convert the multi-sz string into comma delimted
                            // and write the new multi-sz string back to the file
                            //

                            if ( NewValue ) {
                                ScepConvertMultiSzToDelim(NewValue, NewLen, L'\0', L',');
                            }

                            if ( !WritePrivateProfileString(szPrivilegeRights,
                                                            Keyname,
                                                            NewValue ? (LPCTSTR)NewValue : (LPCTSTR)TmpNull,
                                                            FileName
                                                           ) ) {
                                rc = ScepDosErrorToSceStatus(GetLastError());
                            }
                        }

                        if ( NewValue ) {
                            ScepFree(NewValue);
                        }
                        NewValue = NULL;
                    }

                    StrValue = NULL;

                }

                if  (rc != SCESTATUS_SUCCESS)
                    ScepLogOutput3( 1, ScepSceStatusToDosError(rc),
                                   SCEDLL_ERROR_CONVERT, Keyname);
            }

        } while( rc == SCESTATUS_SUCCESS && SetupFindNextLine(&InfLine, &InfLine));

    }

    if ( hSection  ) {

        SceJetCloseSection( &hSection, TRUE );
    }

    SceInfpCloseProfile(hInf);

    if ( LsaPolicy ) {
        LsaClose(LsaPolicy);
    }

    return rc;
}


SCESTATUS
ScepCopyPrivilegesFromDatabase(
    IN PSCESECTION hSection,
    IN PWSTR Keyname,
    IN DWORD StrLength,
    IN PWSTR StrValue OPTIONAL,
    OUT PWSTR *pOldValue,
    OUT DWORD *pOldLen
    )
{

    if ( hSection == NULL ||
         Keyname == NULL ||
         pOldValue == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    *pOldValue = NULL;
    *pOldLen = 0;

    SCESTATUS rc;
    DWORD ValueLen;

    rc = SceJetGetValue(
                hSection,
                SCEJET_EXACT_MATCH_NO_CASE,
                Keyname,
                NULL,
                0,
                NULL,
                NULL,
                0,
                &ValueLen
                );

    if ( SCESTATUS_SUCCESS == rc ) {

        DWORD Len = wcslen(SCE_PRIV_ADD);

        *pOldValue = (PWSTR)ScepAlloc(LPTR, (Len+1+StrLength+1)*sizeof(WCHAR)+ValueLen+2);

        if ( *pOldValue ) {

            //
            // add the prefix "Add:" first, terminated with a \0 for multi-sz format
            //
            wcscpy(*pOldValue, SCE_PRIV_ADD );
            (*pOldValue)[Len] = L'\0';

            //
            // query the value from database
            //
            DWORD NewLen=0;

            rc = SceJetGetValue(
                        hSection,
                        SCEJET_CURRENT,
                        NULL,
                        NULL,
                        0,
                        NULL,
                        (*pOldValue+Len+1),
                        ValueLen,
                        &NewLen
                        );

            if ( SCESTATUS_SUCCESS == rc ) {

                if ( NewLen > ValueLen ) {
                    NewLen = ValueLen;
                }

                //
                // make sure the length is a multiple of 2
                //
                if ( NewLen % 2 != 0 ) {
                    NewLen++;
                }

                //
                // process the end of the multi-sz string, make sure that it only contains one \0
                //

                while ( NewLen > 0 &&
                        ( *(*pOldValue+Len+1+NewLen/2-1) == L'\0') ) {
                    if ( NewLen > 1 ) {
                        NewLen -= 2;
                    } else {
                        NewLen = 0;
                    }
                }

                if ( NewLen != 0 ) {
                    //
                    // include one \0
                    //
                    NewLen += 2;
                }

                if ( StrValue ) {

                    memcpy((*pOldValue+Len+1+NewLen/2), StrValue, StrLength*sizeof(WCHAR));
                    *pOldLen = Len+1+NewLen/2+StrLength;

                } else {

                    if ( NewLen == 0 ) {
                        //
                        // no value in both database and template
                        //
                        ScepFree(*pOldValue);
                        *pOldValue = NULL;
                        *pOldLen = 0;

                    } else {
                        //
                        // only has value in database, terminate the string with two \0
                        //
                        *pOldLen = Len+1+NewLen/2+1;
                        *(*pOldValue+Len+1+NewLen/2) = L'\0';
                    }
                }

            } else {

                ScepFree(*pOldValue);
                *pOldValue = NULL;

                //
                // ignore error (if can't query from the db)
                //
                rc = SCESTATUS_SUCCESS;
            }

        } else {

            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }
    } else {

        //
        // ignore error (if there is no match)
        //
        rc = SCESTATUS_SUCCESS;
    }

    ScepLogOutput3(1, ScepSceStatusToDosError(rc), IDS_COPY_ONE_PRIVILEGE, Keyname );

    return rc;

}


SCESTATUS
ScepDeleteDomainPolicies()
{

    SCESTATUS rc;
    PSCESECTION hTmpSect=NULL;
    DOUBLE SectionID=0;

    rc = SceJetGetSectionIDByName(
                hProfile,
                szSystemAccess,
                &SectionID
                );

    if ( SCESTATUS_SUCCESS == rc ) {

        rc = SceJetOpenSection(hProfile,
                                SectionID,
                                SCEJET_TABLE_SCP,
                                &hTmpSect
                                );

        if ( SCESTATUS_SUCCESS == rc ) {

            SceJetDelete(hTmpSect, NULL, FALSE, SCEJET_DELETE_SECTION);

            SceJetCloseSection(&hTmpSect, TRUE);
        }

        rc = SceJetOpenSection(hProfile,
                                SectionID,
                                SCEJET_TABLE_SMP,
                                &hTmpSect
                                );

        if ( SCESTATUS_SUCCESS == rc ) {

            SceJetDelete(hTmpSect, NULL, FALSE, SCEJET_DELETE_SECTION);

            SceJetCloseSection(&hTmpSect, TRUE);
        }
    }

    SectionID = 0;

    rc = SceJetGetSectionIDByName(
                hProfile,
                szKerberosPolicy,
                &SectionID
                );

    if ( SCESTATUS_SUCCESS == rc ) {

        rc = SceJetOpenSection(hProfile,
                                SectionID,
                                SCEJET_TABLE_SCP,
                                &hTmpSect
                                );

        if ( SCESTATUS_SUCCESS == rc ) {

            SceJetDelete(hTmpSect, NULL, FALSE, SCEJET_DELETE_SECTION);

            SceJetCloseSection(&hTmpSect, TRUE);
        }

        rc = SceJetOpenSection(hProfile,
                                SectionID,
                                SCEJET_TABLE_SMP,
                                &hTmpSect
                                );

        if ( SCESTATUS_SUCCESS == rc ) {

            SceJetDelete(hTmpSect, NULL, FALSE, SCEJET_DELETE_SECTION);

            SceJetCloseSection(&hTmpSect, TRUE);
        }
    }

    return rc;
}

SCESTATUS
ScepSetupResetLocalPolicy(
    IN PSCECONTEXT          Context,
    IN AREA_INFORMATION     Area,
    IN PCWSTR               SectionName OPTIONAL,
    IN SCETYPE              ProfileType,
    IN BOOL                 bKeepBasicPolicy
    )
/*
Routine Description:

    This routine deletes policies from the local policy table (SMP)

    If a section name is provided, the single section is deleted; otherwise,
    The area information is used.

    If bKeepBasicPolicy is set to TRUE, the following inforamtion WON'T be
    deleted from the table even if that area is requested to delete.
        Password, Lockout, Kerberos, Audit, User Rights, Security Options,
        and SMB settings (any existing service extensions)
*/
{

    if ( Context == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    if ( SectionName ) {

        //
        // delete one section
        //

        rc = ScepDeleteOneSection(
                    Context,
                    ProfileType,
                    SectionName
                    );

    } else {

        AREA_INFORMATION Area2;

        if ( bKeepBasicPolicy && ProfileType == SCE_ENGINE_SMP ) {
            Area2 = Area & ~(AREA_SECURITY_POLICY |
                             AREA_PRIVILEGES |
                             AREA_SYSTEM_SERVICE);
        } else {

            Area2 = Area;
        }

        rc = ScepDeleteInfoForAreas(
                    Context,
                    ProfileType,
                    Area2
                    );

        if ( bKeepBasicPolicy &&
             SCESTATUS_SUCCESS == rc ) {

            //
            // delete log settings sections
            //

            ScepDeleteOneSection(
                        Context,
                        ProfileType,
                        szAuditSystemLog
                        );

            ScepDeleteOneSection(
                        Context,
                        ProfileType,
                        szAuditSecurityLog
                        );

            ScepDeleteOneSection(
                        Context,
                        ProfileType,
                        szAuditApplicationLog
                        );

            //
            // delete general service section
            //

            ScepDeleteOneSection(
                        Context,
                        ProfileType,
                        szServiceGeneral
                        );
        }

    }

    return(rc);
}


SCESTATUS
ScepSetSystemSecurity(
    IN AREA_INFORMATION Area,
    IN DWORD ConfigOptions,
    IN PSCE_PROFILE_INFO pInfo,
    OUT PSCE_ERROR_LOG_INFO *pErrLog
    )
/*
Description:

    Set security settings directly on the system for security policy area
    and user rights area.

    If some settings fail to be configured, the settings will be logged in the
    error buffer to output.
*/
{
    SCESTATUS Saverc = SCESTATUS_SUCCESS;
    SCESTATUS rc;

    if ( pInfo == NULL || Area == 0 ) {
        //
        // nothing to set
        //
        return(Saverc);
    }

    if ( Area & AREA_PRIVILEGES ) {

        rc = ScepConfigurePrivilegesByRight( pInfo->OtherInfo.smp.pPrivilegeAssignedTo,
                                             ConfigOptions,
                                             pErrLog
                                           );

        if( rc != SCESTATUS_SUCCESS ) {
            Saverc = rc;
        }
    }


    if ( Area & AREA_SECURITY_POLICY ) {

        if ( pInfo->LockoutBadCount == 0 ) {
            //
            // make sure the other two settings are ignored
            // they might have value SCE_DELETE_VALUE which is not applicable to this mode
            //
            pInfo->ResetLockoutCount = SCE_NO_VALUE;
            pInfo->LockoutDuration = SCE_NO_VALUE;
        }

        rc = ScepConfigureSystemAccess(pInfo,
                                       ConfigOptions | SCE_SYSTEM_SETTINGS,
                                       pErrLog,
                                       0 );

        if( rc != SCESTATUS_SUCCESS ) {
            Saverc = rc;
        }

        //
        // System Auditing area
        //
        PPOLICY_AUDIT_EVENTS_INFO     auditEvent=NULL;

        rc = ScepSaveAndOffAuditing(&auditEvent, FALSE, NULL);

        if ( rc == SCESTATUS_SUCCESS && auditEvent ) {

            rc = ScepConfigureAuditEvent(pInfo,
                                         auditEvent,
                                         ConfigOptions | SCE_SYSTEM_SETTINGS,
                                         NULL
                                        );

            if ( rc != SCESTATUS_SUCCESS ) {

                ScepBuildErrorLogInfo(
                            ScepSceStatusToDosError(rc),
                            pErrLog,
                            SCEDLL_SCP_ERROR_EVENT_AUDITING
                            );

            }

        } else {

            ScepBuildErrorLogInfo(
                    ScepSceStatusToDosError(rc),
                    pErrLog,
                    SCEDLL_ERROR_QUERY_EVENT_AUDITING
                    );

        }


        if ( auditEvent ) {
            LsaFreeMemory(auditEvent);
        }

        if( rc != SCESTATUS_SUCCESS ) {
            Saverc = rc;
        }

        //
        // Kerberos Policy
        //
        rc = ScepConfigureKerberosPolicy( NULL, pInfo->pKerberosInfo, ConfigOptions );

        if( rc != SCESTATUS_SUCCESS ) {

            ScepBuildErrorLogInfo(
                    ScepSceStatusToDosError(rc),
                    pErrLog,
                    SCEDLL_SCP_ERROR_KERBEROS
                    );
            Saverc = rc;
        }

        //
        // registry values
        //
        rc = ScepConfigureRegistryValues( NULL,
                                          pInfo->aRegValues,
                                          pInfo->RegValueCount,
                                          pErrLog,
                                          ConfigOptions,
                                          NULL );

        if( rc != SCESTATUS_SUCCESS ) {
            Saverc = rc;
        }

    }


    return(Saverc);
}


SCESTATUS
ScepConfigurePrivilegesByRight(
    IN PSCE_PRIVILEGE_ASSIGNMENT pPrivAssign,
    IN DWORD Options,
    IN OUT PSCE_ERROR_LOG_INFO *pErrLog
    )
/*
Description:

    Configure privileges by PSCE_PRIVILEGE_ASSIGNMENT structure which is
    separated by each user right with a list of accounts assigned to.
*/
{


    if ( pPrivAssign == NULL ) {
        //
        // nothing to configure
        //
        return(SCESTATUS_SUCCESS);
    }

    LSA_HANDLE                      LsaPolicy=NULL;
    DWORD                           rc;


    rc = RtlNtStatusToDosError( ScepOpenLsaPolicy(
                                    POLICY_LOOKUP_NAMES | POLICY_CREATE_ACCOUNT,
                                    &LsaPolicy,
                                    FALSE)
                              );

    if (rc != ERROR_SUCCESS) {
        if ( pErrLog ) {
            ScepBuildErrorLogInfo(
                    rc,
                    pErrLog,
                    SCEDLL_LSA_POLICY
                    );
        }
        return(rc);
    }

    PSCE_PRIVILEGE_ASSIGNMENT pPriv;
    INT PrivValue;
    PSCE_NAME_LIST pList;
    DWORD SaveRc=SCESTATUS_SUCCESS;
    BOOL bBufferUsed;
    PSID pAccountSid;

    DWORD PrivLowMask=0;
    DWORD PrivHighMask=0;

    PSCE_PRIVILEGE_VALUE_LIST pPrivList=NULL;

    //
    // convert the privilege assignment structure to privilege value list
    // and build the mask for privileges (PrivLowMask and PrivHighMask)
    //
    for ( pPriv=pPrivAssign; pPriv != NULL; pPriv=pPriv->Next ) {

        //
        // privilege name is empty, ignore it.
        //
        if ( pPriv->Name == NULL ) {
            continue;
        }

        //
        // search for the privilege value
        //

        PrivValue = ScepLookupPrivByName(pPriv->Name);

        if ( PrivValue == -1 ) {
            //
            // unknown privilege
            //
            if ( pErrLog ) {
                ScepBuildErrorLogInfo(
                        0,
                        pErrLog,
                        SCEERR_INVALID_PRIVILEGE,
                        pPriv->Name
                        );
            }
            continue;
        }

        //
        // build privilege mask
        //

        if ( PrivValue < 32 ) {

            PrivLowMask |= (1 << PrivValue);
        } else {
            PrivHighMask |= (1 << (PrivValue-32) );
        }

        for ( pList=pPriv->AssignedTo; pList != NULL; pList=pList->Next ) {
            //
            // translate each one to a SID
            //
            if ( pList->Name == NULL ) {
                continue;
            }

            //
            // reset error code for this new account
            //
            rc = ERROR_SUCCESS;
            pAccountSid = NULL;
            bBufferUsed = FALSE;

            if ( pList->Name[0] == L'*' ) {
                //
                // this is a string SID
                //
                if ( !ConvertStringSidToSid( pList->Name+1, &pAccountSid) ) {
                    rc = GetLastError();
                }

            } else {
                //
                // this is a name, could be in the format of domain\account, or
                // just an isolated account
                //
                rc = RtlNtStatusToDosError(
                        ScepConvertNameToSid(
                                 LsaPolicy,
                                 pList->Name,
                                 &pAccountSid
                                 ));
            }

            if ( rc == ERROR_SUCCESS ) {

                //
                // add the account SID to privilege value list
                //
                rc = ScepDosErrorToSceStatus(
                         ScepAddSidToPrivilegeList(
                              &pPrivList,
                              pAccountSid,
                              TRUE, // reuse the buffer
                              PrivValue,
                              &bBufferUsed
                              ));

            }

            if ( rc != ERROR_SUCCESS ) {
                //
                // something is wrong with this account. Can't be resolved
                // add it to the error log and continue to process others.
                //
                if ( pErrLog ) {
                    ScepBuildErrorLogInfo(
                            rc,
                            pErrLog,
                            SCEDLL_INVALID_GROUP,
                            pList->Name
                            );
                }

                SaveRc = ScepDosErrorToSceStatus(rc);
            }

            if ( !bBufferUsed && pAccountSid ) {
                ScepFree(pAccountSid);
            }
            pAccountSid = NULL;

        }

    }

    //
    // free LSA handle
    //
    LsaClose(LsaPolicy);

    //
    // now continue to configure even though there may be errors in
    // the previous processing (the erorrs are logged)
    //
    if ( PrivLowMask > 0 || PrivHighMask > 0 ) {

        rc = ScepConfigurePrivilegesWithMask(
                         &pPrivList,
                         FALSE,
                         Options | SCE_SYSTEM_SETTINGS,
                         PrivLowMask,
                         PrivHighMask,
                         pErrLog,
                         NULL
                         );
    }

    //
    // free privilege list
    //


    return(SaveRc);

}


SCESTATUS
ScepEnumAttachmentSections(
    IN PSCECONTEXT cxtProfile,
    OUT PSCE_NAME_LIST *ppList
    )
/* ++
Routine Description:


Arguments:

    cxtProfile  - The profile context handle

    ppList   - The output attachment section names


Return Value:


-- */
{
    SCESTATUS  rc;
    JET_ERR   JetErr;
    DWORD     Actual;
    WCHAR     Buffer[256];
    DWORD     Len;

    if ( cxtProfile == NULL || ppList == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    if ( cxtProfile->JetTblSecID <= 0) {
        //
        // Section table is not opened yet
        //
        rc = SceJetOpenTable(
                        cxtProfile,
                        "SmTblSection",
                        SCEJET_TABLE_SECTION,
                        SCEJET_OPEN_READ_ONLY,
                        NULL
                        );

        if ( rc != SCESTATUS_SUCCESS )
            return(rc);
    }

    *ppList = NULL;

    //
    // set current index to SecID (the ID)
    //
    JetErr = JetSetCurrentIndex(
                cxtProfile->JetSessionID,
                cxtProfile->JetTblSecID,
                "SecID"
                );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc != SCESTATUS_SUCCESS )
        return(rc);

    //
    // Move to the first record
    //
    JetErr = JetMove(
                  cxtProfile->JetSessionID,
                  cxtProfile->JetTblSecID,
                  JET_MoveFirst,
                  0
                  );
    rc = SceJetJetErrorToSceStatus(JetErr);

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // find the section record, retrieve column Name
        //
        do {

            Len = 255;
            memset(Buffer, '\0', 256*sizeof(WCHAR));

            JetErr = JetRetrieveColumn(
                        cxtProfile->JetSessionID,
                        cxtProfile->JetTblSecID,
                        cxtProfile->JetSecNameID,
                        (void *)Buffer,
                        Len*sizeof(WCHAR),
                        &Actual,
                        0,
                        NULL
                        );
            rc = SceJetJetErrorToSceStatus(JetErr);

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // add this name to the output list
                //
                if ( _wcsicmp(szSystemAccess, Buffer) == 0 ||
                     _wcsicmp(szPrivilegeRights, Buffer) == 0 ||
                     _wcsicmp(szGroupMembership, Buffer) == 0 ||
                     _wcsicmp(szRegistryKeys, Buffer) == 0 ||
                     _wcsicmp(szFileSecurity, Buffer) == 0 ||
                     _wcsicmp(szAuditSystemLog, Buffer) == 0 ||
                     _wcsicmp(szAuditSecurityLog, Buffer) == 0 ||
                     _wcsicmp(szAuditApplicationLog, Buffer) == 0 ||
                     _wcsicmp(szAuditEvent, Buffer) == 0 ||
                     _wcsicmp(szKerberosPolicy, Buffer) == 0 ||
                     _wcsicmp(szRegistryValues, Buffer) == 0 ||
                     _wcsicmp(szServiceGeneral, Buffer) == 0 ||
                     _wcsicmp(szAccountProfiles, Buffer) == 0 ||
                     _wcsicmp(szDSSecurity, Buffer) == 0 ||
                     _wcsicmp(szUserList, Buffer) == 0
                    ) {
                    // this is not the attachment section
                } else {
                    rc = ScepAddToNameList(ppList, Buffer, 0);
                }
            }

            if ( rc == SCESTATUS_SUCCESS ) {

                //
                // Move to next line
                //
                JetErr = JetMove(cxtProfile->JetSessionID,
                                cxtProfile->JetTblSecID,
                                JET_MoveNext,
                                0);

                rc = SceJetJetErrorToSceStatus(JetErr);
            }

        } while ( SCESTATUS_SUCCESS == rc );
    }

    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

        rc = SCESTATUS_SUCCESS;

    } else if ( rc != SCESTATUS_SUCCESS ) {
        //
        // free the output buffer
        //
        ScepFreeNameList(*ppList);
        *ppList = NULL;
    }

    return(rc);

}


SCESTATUS
ScepTattooUpdatePrivilegeArrayStatus(
    IN DWORD *pStatusArray,
    IN DWORD rc,
    IN DWORD PrivLowMask,
    IN DWORD PrivHighMask
    )
{
    if ( pStatusArray == NULL ||
         (PrivLowMask == 0 && PrivHighMask == 0) ) {
        return(SCESTATUS_SUCCESS);
    }

    for ( DWORD i=0; i<cPrivCnt; i++) {

        if ( ( (i < 32) && ( PrivLowMask & (1 << i)) ) ||
             ( (i >= 32) && ( PrivHighMask & ( 1 << (i-32)) ) ) ) {
            if ( rc != 0 )
                pStatusArray[i] = rc;
            else if ( pStatusArray[i] == (DWORD)-1 )
                pStatusArray[i] = rc;

        }
    }

    return(SCESTATUS_SUCCESS);
}

SCESTATUS
ScepTattooRemovePrivilegeValues(
    IN PSCECONTEXT hProfile,
    IN DWORD *pStatusArray
    )
{
    PSCESECTION hSectionDomain=NULL;
    PSCESECTION hSectionTattoo=NULL;
    DWORD  i,Len;


    if ( hProfile == NULL || pStatusArray == NULL )
        return(SCESTATUS_INVALID_PARAMETER);

    //
    // open domain and tattoo sections
    //
    ScepTattooOpenPolicySections(
                  hProfile,
                  szPrivilegeRights,
                  &hSectionDomain,
                  &hSectionTattoo
                  );

    if ( hSectionDomain != NULL && hSectionTattoo != NULL ) {

        for ( i=0; i<cPrivCnt; i++ ) {

            if ( pStatusArray[i] == 0 ) {

                //
                // check if this setting comes from domain
                //

                Len = wcslen(SCE_Privileges[i].Name);

                BOOL bDomainExist = FALSE;

                if ( SCESTATUS_SUCCESS == SceJetSeek(
                                            hSectionDomain,
                                            SCE_Privileges[i].Name,
                                            Len*sizeof(WCHAR),
                                            SCEJET_SEEK_EQ_NO_CASE
                                            ) ) {

                    if ( hSectionDomain->JetColumnGpoID > 0 ) {

                        //
                        // check if GpoID > 0
                        //

                        LONG GpoID = 0;
                        DWORD Actual;
                        JET_ERR JetErr;

                        JetErr = JetRetrieveColumn(
                                        hSectionDomain->JetSessionID,
                                        hSectionDomain->JetTableID,
                                        hSectionDomain->JetColumnGpoID,
                                        (void *)&GpoID,
                                        4,
                                        &Actual,
                                        0,
                                        NULL
                                        );
                        if ( JET_errSuccess != JetErr ) {
                            //
                            // if the column is nil (no value), it will return warning
                            // but the buffer pGpoID is trashed
                            //
                            GpoID = 0;
                        }

                        if ( GpoID > 0 ) {
                            bDomainExist = TRUE;
                        }
                    }
                }

                if ( bDomainExist ) {
                    // if the setting comes from domain, don't do anything
                    continue;
                }

                //
                // by now, this setting comes from the tattoo table
                // and has been configured successfully
                // now remove the tattoo setting
                //

                SceJetDelete(hSectionTattoo,
                            SCE_Privileges[i].Name,
                            FALSE,
                            SCEJET_DELETE_LINE_NO_CASE);

                ScepLogOutput3(2, 0, SCESRV_POLICY_TATTOO_REMOVE_SETTING, SCE_Privileges[i].Name);
            }
        }
    }

    if ( hSectionDomain ) SceJetCloseSection(&hSectionDomain, TRUE);
    if ( hSectionTattoo ) SceJetCloseSection(&hSectionTattoo, TRUE);

    return(SCESTATUS_SUCCESS);
}

SCESTATUS
ScepTattooSavePrivilegeValues(
    IN PSCECONTEXT hProfile,
    IN LSA_HANDLE PolicyHandle,
    IN DWORD PrivLowMask,
    IN DWORD PrivHighMask,
    IN DWORD ConfigOptions
    )
{
    PSCESECTION hSectionDomain=NULL;
    PSCESECTION hSectionTattoo=NULL;

    NTSTATUS    NtStatus;
    ULONG       CountReturned;
    UNICODE_STRING UserRight;
    PLSA_ENUMERATION_INFORMATION EnumBuffer=NULL;

    DWORD  i,j,Len;
    BOOL bSettingExist;
    DWORD rc,rc2;
    SCESTATUS saveRc=SCESTATUS_SUCCESS;
    PSCE_NAME_LIST  pNameList=NULL;


    if ( !(ConfigOptions & SCE_POLICY_TEMPLATE) || hProfile == NULL ||
         PolicyHandle == NULL  ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( PrivLowMask == 0 && PrivHighMask == 0 ) {
        return(SCESTATUS_SUCCESS);
    }

    //
    // open domain and tattoo sections
    //
    ScepTattooOpenPolicySections(
                  hProfile,
                  szPrivilegeRights,
                  &hSectionDomain,
                  &hSectionTattoo
                  );

    if ( hSectionDomain != NULL && hSectionTattoo != NULL ) {

        for ( i=0; i<cPrivCnt; i++ ) {

            if ( ( (i < 32) && ( PrivLowMask & (1 << i)) ) ||
                 ( (i >= 32) && ( PrivHighMask & ( 1 << (i-32)) ) ) ) {

                //
                // check if this setting comes from domain
                //

                Len = wcslen(SCE_Privileges[i].Name);

                bSettingExist = FALSE;
                if ( SCESTATUS_SUCCESS == SceJetSeek(
                                            hSectionTattoo,
                                            SCE_Privileges[i].Name,
                                            Len*sizeof(WCHAR),
                                            SCEJET_SEEK_EQ_NO_CASE
                                            ) ) {
                    bSettingExist = TRUE;
                }

                // if there is tattoo setting already, no need to save undo value
                if ( bSettingExist ) {
                    ScepLogOutput3(3, 0, SCESRV_POLICY_TATTOO_EXIST, SCE_Privileges[i].Name);
                    continue;
                }

                bSettingExist = FALSE;
                if ( SCESTATUS_SUCCESS == SceJetSeek(
                                            hSectionDomain,
                                            SCE_Privileges[i].Name,
                                            Len*sizeof(WCHAR),
                                            SCEJET_SEEK_EQ_NO_CASE
                                            ) ) {
                    //
                    // since there is no tattoo value exist
                    // so if this setting is found in domain table, it must come from domain
                    //
                    bSettingExist = TRUE;
                }

                // if the setting doesn't come from domain, no need to query undo value
                if ( !bSettingExist ) continue;

                //
                // now we need to query the tattoo value for this privilege
                //
                RtlInitUnicodeString( &UserRight, (PCWSTR)(SCE_Privileges[i].Name));

                //
                // now enumerate all accounts for this user right.
                //

                NtStatus = LsaEnumerateAccountsWithUserRight(
                                    PolicyHandle,
                                    &UserRight,
                                    (PVOID *)&EnumBuffer,   // account SIDs
                                    &CountReturned
                                    );

                if ( NtStatus == STATUS_NO_MORE_ENTRIES ||
                     NtStatus == STATUS_NO_SUCH_PRIVILEGE ||
                     NtStatus == STATUS_NOT_FOUND ||
                     NT_SUCCESS(NtStatus) ) {

                    rc = ERROR_SUCCESS;

                } else {

                    rc = RtlNtStatusToDosError(NtStatus);
                }

                pNameList = NULL;

                //
                // if fail to get the account list
                // save NULL as the tattoo value
                //
                if ( NT_SUCCESS(NtStatus) && CountReturned > 0 ) {

                    //
                    // add the SIDs
                    //

                    for ( j=0; j<CountReturned; j++ ) {
                        //
                        // build each account into the name list
                        // Convert using the Rtl functions
                        //
                        rc2 = ScepAddSidStringToNameList(&pNameList, EnumBuffer[j].Sid);

                        if ( NO_ERROR != rc2 ) {
                            rc = rc2;
                        }
                    }
                }

                LsaFreeMemory( EnumBuffer );
                EnumBuffer = NULL;

                //
                // log an error
                //
                if ( ERROR_SUCCESS != rc ) {

                    saveRc = ScepDosErrorToSceStatus(rc);
                    ScepLogOutput3(1, 0, SCESRV_POLICY_TATTOO_ERROR_QUERY, rc, SCE_Privileges[i].Name);

                } else {
                    //
                    // now save the name list to the tattoo table
                    //

                    rc = ScepWriteNameListValue(
                            PolicyHandle,
                            hSectionTattoo,
                            SCE_Privileges[i].Name,
                            pNameList,
                            SCE_WRITE_EMPTY_LIST,
                            4
                            );
                    if ( rc != SCESTATUS_SUCCESS ) {
                        saveRc = rc;
                        ScepLogOutput3(1, 0, SCESRV_POLICY_TATTOO_ERROR_SETTING, ScepSceStatusToDosError(rc), SCE_Privileges[i].Name);
                    } else {
                        ScepLogOutput3(3, 0, SCESRV_POLICY_TATTOO_CHECK, SCE_Privileges[i].Name);
                    }
                }

                if ( pNameList != NULL ) {
                    ScepFreeNameList( pNameList );
                    pNameList = NULL;
                }

            }
        }
    }

    if ( hSectionDomain ) SceJetCloseSection(&hSectionDomain, TRUE);
    if ( hSectionTattoo ) SceJetCloseSection(&hSectionTattoo, TRUE);

    return(saveRc);
}


DWORD
ScepTattooCurrentGroupMembers(
    IN PSID             ThisDomainSid,
    IN SID_NAME_USE     GrpUse,
    IN PULONG           MemberRids OPTIONAL,
    IN PSID             *MemberAliasSids OPTIONAL,
    IN DWORD            MemberCount,
    OUT PSCE_NAME_LIST  *ppNameList
    )
/* ++
Routine Description:

    This routine builds the current group membership into a name list (in SID string
    format).

Arguments:

    ThisDomainSid - The domain SID

    GrpUse   - The "type" of the group

    MemberRids - the member RIDs (for SidTypeGroup)

    MemberAliasSids - the member SIDs (for SidTypeAlias)

    MemberCount - number of members

    ppNameList - the output name list

Return value:

    WIN32 errors
-- */
{
    NTSTATUS                NtStatus=ERROR_SUCCESS;
    DWORD                   j;
    DWORD                   saveRc=ERROR_SUCCESS;
    DWORD                   rc;

    if ( ppNameList == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *ppNameList = NULL;

    switch ( GrpUse ) {
    case SidTypeGroup:
        //
        // member IDs are passed in as Rids
        // DomainHandle must point to a account domain because builtin domain
        // won't have SidTypeGroup account
        //
        if ( ThisDomainSid == NULL )
            saveRc = ERROR_INVALID_PARAMETER;

        else if ( MemberRids ) {

            PSID AccountSid=NULL;

            for (j=0; j<MemberCount; j++) {

                NtStatus = ScepDomainIdToSid(
                                ThisDomainSid,
                                MemberRids[j],
                                &AccountSid
                                );

                rc = RtlNtStatusToDosError(NtStatus);
                if ( NT_SUCCESS(NtStatus) ) {

                    rc = ScepAddSidStringToNameList(ppNameList, AccountSid);

                    ScepFree(AccountSid);
                    AccountSid = NULL;
                }

                if ( ERROR_SUCCESS != rc ) saveRc = rc;
            }
        }
        break;

    case SidTypeAlias:
        //
        // members are passed in as SIDs
        // add them to the output list directly
        //
        if ( MemberAliasSids ) {

            for ( j=0; j<MemberCount; j++ ) {
                if ( MemberAliasSids[j] != NULL ) {
                    //
                    // add member to the list
                    //
                    rc = ScepAddSidStringToNameList(ppNameList, MemberAliasSids[j]);

                    if ( ERROR_SUCCESS != rc ) saveRc = rc;
                }
            }
        }

        break;

    default:
        saveRc = ERROR_INVALID_PARAMETER;
        break;
    }


    return(saveRc);
}

SCESTATUS
ScepCheckNetworkLogonRights(
    IN LSA_HANDLE PolicyHandle,
    IN OUT DWORD *pLowMask,
    IN OUT DWORD *pHighMask,
    IN OUT PSCE_PRIVILEGE_VALUE_LIST *ppPrivilegeAssigned
    )
/*
Description:

    This function is to make sure that Authenticated Users already have
    "Network Logon Right" and Authenticated Users & Everyone must not
    have "Deny network logon right".

    If the network logon right or deny network logon right are not defined
    in the privilege mask, no change is made since the user rights are not
    defined in the configuration.

    If Authenticated Users or Everyone is not defined in the privilege list,
    this function will add them in (hard coded). The output of this function
    ppPrivilegeAssigned may contain new added nodes for the hard coded accounts.

*/
{
    INT i;
    INT idxAllow = -1;
    INT idxDeny = -1;
    INT idxLocal = -1;
    INT idxDenyLocal = -1;

    DWORD PrivHighMask = *pHighMask;
    DWORD PrivLowMask = *pLowMask;

    //
    // check first if Network logon right is defined
    //
    i = ScepLookupPrivByName(SE_NETWORK_LOGON_NAME);
    if ( i != -1 ) {
        if ( SCEP_CHECK_PRIV_BIT(i,PrivLowMask,PrivHighMask) ) {
            //
            // network logon right is defined
            //
            idxAllow = i;
        }
    }

    //
    // check if Deny Network logon right is defined
    //

    i = ScepLookupPrivByName(SE_DENY_NETWORK_LOGON_NAME);
    if ( i != -1 ) {

        if ( SCEP_CHECK_PRIV_BIT(i,PrivLowMask,PrivHighMask) ) {
            //
            // deny network logon right is defined
            //
            idxDeny = i;

        }
    }

    //
    // check if logon locally right is defined
    //

    i = ScepLookupPrivByName(SE_INTERACTIVE_LOGON_NAME);
    if ( i != -1 ) {

        if ( SCEP_CHECK_PRIV_BIT(i,PrivLowMask,PrivHighMask) ) {
            //
            // logon locally right is defined
            //
            idxLocal = i;
        }
    }

    //
    // check if deny logon locally right is defined
    //

    i = ScepLookupPrivByName(SE_DENY_INTERACTIVE_LOGON_NAME);
    if ( i != -1 ) {

        if ( SCEP_CHECK_PRIV_BIT(i,PrivLowMask,PrivHighMask) ) {
            //
            // deny logon locally right is defined
            //
            idxDenyLocal = i;
        }
    }

    if ( idxAllow == -1 && idxDeny == -1 && idxLocal == -1 && idxDenyLocal == -1 ) {

        //
        // none of them is defined so do not enforce anything
        //

        return(SCESTATUS_SUCCESS);
    }

    //
    // build well known SIDs for the enforcement
    //

    SID EveryoneSid;
    SID AuthSid;
    SID ControllerSid;
    PSID AdminUserSid=NULL;

    SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;


    //
    // initialize Administrators group sid
    //

    if ( ! NT_SUCCESS ( RtlAllocateAndInitializeSid( &NtAuth,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0,0,0,0,0,0,
                                                     &AdminsSid
                                                   ) ) ) {
        ScepLogOutput3(0,ERROR_NOT_ENOUGH_MEMORY,
                       SCEDLL_ADMINISTRATORS_SID);

        //
        // failure to initialize this one SID will still continue to other SIDs
        //
    }

    //
    // initialize administrator SID
    //

    if ( idxDenyLocal != -1 ) {

        NTSTATUS Status;

        //
        // Query the account domain SID
        // failure to initialize this one SID will still continue to
        // enforce other SIDs
        //

        PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo=NULL;

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyAccountDomainInformation,
                                            (PVOID *)&PolicyAccountDomainInfo );


        if ( NT_SUCCESS(Status) && PolicyAccountDomainInfo &&
             PolicyAccountDomainInfo->DomainSid ) {

            Status = ScepDomainIdToSid(
                            PolicyAccountDomainInfo->DomainSid,
                            DOMAIN_USER_RID_ADMIN,
                            &AdminUserSid
                            );

        }

        if ( PolicyAccountDomainInfo ) {
            LsaFreeMemory( PolicyAccountDomainInfo );
        }

        if ( AdminUserSid == NULL ) {

            ScepLogOutput3(0, RtlNtStatusToDosError(Status),
                           SCEDLL_ADMINISTRATORS_SID);
        }
    }

    //
    // initialize well known SIDs
    //

    RtlInitializeSid ( &EveryoneSid, &WorldAuth, 1);
    *RtlSubAuthoritySid ( &EveryoneSid, 0 ) = SECURITY_WORLD_RID;

    RtlInitializeSid ( &AuthSid, &NtAuth, 1);
    *RtlSubAuthoritySid ( &AuthSid, 0 ) = SECURITY_AUTHENTICATED_USER_RID;

    RtlInitializeSid ( &ControllerSid, &NtAuth, 1);
    *RtlSubAuthoritySid ( &ControllerSid, 0 ) = SECURITY_ENTERPRISE_CONTROLLERS_RID;


    PSCE_PRIVILEGE_VALUE_LIST pTemp=*ppPrivilegeAssigned;
    PSCE_PRIVILEGE_VALUE_LIST pParent=NULL;

    BOOL bFindEveryone=FALSE;
    BOOL bFindAuthUsers=FALSE;
    BOOL bFindLocal=FALSE;
    BOOL bFindController=FALSE;
    BOOL bFindAdminUser=FALSE;

    //
    // loop through each one defined in the list to match the above SIDs
    //

    for ( ; pTemp != NULL; pParent=pTemp, pTemp=pTemp->Next) {

        if ( pTemp->Name == NULL ) continue;

        if ( (idxLocal != -1 || idxDenyLocal != -1) && !bFindLocal && AdminsSid &&
             ( bFindLocal = RtlEqualSid( (PSID)(pTemp->Name), AdminsSid) ) ) {

            //
            // make sure Administrators always have the interactive logon right
            //
            if ( idxLocal != -1 ) {

                if ( !SCEP_CHECK_PRIV_BIT(idxLocal,pTemp->PrivLowPart,pTemp->PrivHighPart) ) {

                    ScepLogOutput3(0,0, SCESRV_ENFORCE_LOCAL_RIGHT, SE_INTERACTIVE_LOGON_NAME);
                    SCEP_ADD_PRIV_BIT(idxLocal, pTemp->PrivLowPart, pTemp->PrivHighPart)
                }
            }

            //
            // make sure administrators don't have deny interactive logon right
            //
            if ( idxDenyLocal != -1 ) {

                if ( SCEP_CHECK_PRIV_BIT(idxDenyLocal,pTemp->PrivLowPart,pTemp->PrivHighPart) ) {

                    ScepLogOutput3(0,0, SCESRV_ENFORCE_DENY_LOCAL_RIGHT, SE_DENY_INTERACTIVE_LOGON_NAME);
                    SCEP_REMOVE_PRIV_BIT(idxDenyLocal, &(pTemp->PrivLowPart), &(pTemp->PrivHighPart))
                }
            }
        }

        if ( (idxDeny != -1 || idxDenyLocal != -1) &&
             ( !bFindAuthUsers && ( bFindAuthUsers = RtlEqualSid( (PSID)(pTemp->Name), &AuthSid )) ) ||
             ( !bFindEveryone && ( bFindEveryone = RtlEqualSid( (PSID)(pTemp->Name), &EveryoneSid )) ) )  {

            //
            // find Authenticated Users or Everyone
            // make sure they do not have the deny rights
            //

            if ( idxDenyLocal != -1 ) {

                //
                // remove the deny logon locally bit
                //

                if ( SCEP_CHECK_PRIV_BIT(idxDenyLocal,pTemp->PrivLowPart,pTemp->PrivHighPart) ) {

                    ScepLogOutput3(0,0, SCESRV_ENFORCE_DENY_LOCAL_RIGHT, SE_DENY_INTERACTIVE_LOGON_NAME);
                    SCEP_REMOVE_PRIV_BIT(idxDenyLocal, &(pTemp->PrivLowPart), &(pTemp->PrivHighPart))
                }
            }

            if ( (idxDeny != -1) && (ProductType == NtProductLanManNt) ) {

                //
                // remove the deny network logon bit on domain controllers
                //

                if ( SCEP_CHECK_PRIV_BIT(idxDeny,pTemp->PrivLowPart,pTemp->PrivHighPart) ) {

                    ScepLogOutput3(0,0, SCESRV_ENFORCE_DENY_NETWORK_RIGHT, SE_DENY_NETWORK_LOGON_NAME);
                    SCEP_REMOVE_PRIV_BIT(idxDeny, &(pTemp->PrivLowPart), &(pTemp->PrivHighPart))
                }
            }

        } else if ( !bFindController && (ProductType == NtProductLanManNt) &&
                    ( bFindController = RtlEqualSid( (PSID)(pTemp->Name), &ControllerSid )) )  {

            //
            // find domain controller SID
            // make sure it have network logon right and must not have deny network logon right
            //

            if ( idxDeny != -1 ) {

                //
                // remove the deny network logon bit
                //
                if ( SCEP_CHECK_PRIV_BIT(idxDeny,pTemp->PrivLowPart,pTemp->PrivHighPart) ) {

                    ScepLogOutput3(0,0, SCESRV_ENFORCE_DENY_NETWORK_RIGHT, SE_DENY_NETWORK_LOGON_NAME);
                    SCEP_REMOVE_PRIV_BIT(idxDeny, &(pTemp->PrivLowPart), &(pTemp->PrivHighPart))
                }
            }

            if ( idxAllow != -1 ) {

                //
                // add the network logon bit
                //
                if ( !SCEP_CHECK_PRIV_BIT(idxAllow,pTemp->PrivLowPart,pTemp->PrivHighPart) ) {

                    ScepLogOutput3(0,0, SCESRV_ENFORCE_NETWORK_RIGHT, SE_NETWORK_LOGON_NAME);
                    SCEP_ADD_PRIV_BIT(idxAllow, pTemp->PrivLowPart, pTemp->PrivHighPart)
                }
            }

        } else if ( idxDenyLocal != -1 && !bFindAdminUser && AdminUserSid &&
                    ( bFindAdminUser = RtlEqualSid( (PSID)(pTemp->Name), AdminUserSid) ) ) {

            //
            // make sure administrator account don't have the deny right
            //

            if ( SCEP_CHECK_PRIV_BIT(idxDenyLocal,pTemp->PrivLowPart,pTemp->PrivHighPart) ) {

                ScepLogOutput3(0,0, SCESRV_ENFORCE_DENY_LOCAL_RIGHT, SE_DENY_INTERACTIVE_LOGON_NAME);
                SCEP_REMOVE_PRIV_BIT(idxDenyLocal, &(pTemp->PrivLowPart), &(pTemp->PrivHighPart))
            }

        }

        //
        // all enforcement is done, break the loop now
        //

        if ( (idxLocal == -1 || bFindLocal) &&
             ( (idxDeny == -1 && idxDenyLocal == -1) || (bFindAuthUsers && bFindEveryone) ) &&
             ( bFindController || (ProductType != NtProductLanManNt) ) &&
             (idxDenyLocal == -1 || bFindAdminUser) ) {
            break;
        }
    }


    SCESTATUS rc=SCESTATUS_SUCCESS;

    if ( idxLocal != -1 && !bFindLocal && AdminsSid ) {

        //
        // make sure administrators have "logon locally right"
        // add a new node the the end of the list
        //

        rc = ScepAddAccountRightToList(
                             ppPrivilegeAssigned,
                             &pParent,
                             idxLocal,
                             AdminsSid
                             );

        if ( rc == SCESTATUS_SUCCESS ) {
            ScepLogOutput3(0,0, SCESRV_ENFORCE_LOCAL_RIGHT, SE_INTERACTIVE_LOGON_NAME);
        } else {
            ScepLogOutput3(0,ERROR_NOT_ENOUGH_MEMORY, SCESRV_ERROR_ENFORCE_LOCAL_RIGHT, SE_INTERACTIVE_LOGON_NAME);
        }
    }

    //
    // if enterprise controllers is not found in the list
    // and it's on a DC, should add it
    //

    rc=SCESTATUS_SUCCESS;

    if ( idxAllow != -1 && !bFindController &&
         ( ProductType == NtProductLanManNt ) ) {

        //
        // make sure enterprise controllers have "network logon right"
        //

        rc = ScepAddAccountRightToList(
                             ppPrivilegeAssigned,
                             &pParent,
                             idxAllow,
                             &ControllerSid
                             );

        if ( rc == SCESTATUS_SUCCESS ) {
            ScepLogOutput3(0,0, SCESRV_ENFORCE_NETWORK_RIGHT, SE_NETWORK_LOGON_NAME);
        } else {
            ScepLogOutput3(0,ERROR_NOT_ENOUGH_MEMORY, SCESRV_ERROR_ENFORCE_NETWORK_RIGHT, SE_NETWORK_LOGON_NAME);
        }
    }

    //
    // free memory
    //

    if ( AdminsSid ) {
        RtlFreeSid( AdminsSid );
        AdminsSid = NULL;
    }

    if ( AdminUserSid ) {
        RtlFreeSid( AdminUserSid );
    }

    return(rc);

}

SCESTATUS
ScepAddAccountRightToList(
    IN OUT PSCE_PRIVILEGE_VALUE_LIST *ppPrivilegeAssigned,
    IN OUT PSCE_PRIVILEGE_VALUE_LIST *ppParent,
    IN INT idxRight,
    IN PSID AccountSid
    )
/*
Description:

    Create a new node linked to the end of the link list

    The new node contains the AccountSid for the specified user right "idxRight"

*/
{
    SCESTATUS rc=SCESTATUS_SUCCESS;

    PSCE_PRIVILEGE_VALUE_LIST pPriv = (PSCE_PRIVILEGE_VALUE_LIST)ScepAlloc( LMEM_ZEROINIT,
                                            sizeof(SCE_PRIVILEGE_VALUE_LIST));
    if ( pPriv != NULL ) {

        DWORD Length = RtlLengthSid ( AccountSid );

        //
        // allocate the sid buffer, note it's stored in the name field
        //

        pPriv->Name = (PWSTR)ScepAlloc( LMEM_ZEROINIT, Length);

        if ( pPriv->Name != NULL ) {

            //
            // copy the SID in
            //

            RtlCopySid( Length, (PSID)(pPriv->Name), AccountSid );

            //
            // add the interactive logon right bit
            //

            SCEP_ADD_PRIV_BIT(idxRight, pPriv->PrivLowPart, pPriv->PrivHighPart)

            //
            // link to the list
            //

            if ( *ppParent != NULL )
                (*ppParent)->Next = pPriv;
            else
                *ppPrivilegeAssigned = pPriv;

            *ppParent = pPriv;

        } else {

            ScepFree(pPriv);
            rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
        }

    } else {

        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
    }

    return rc;
}


DWORD
ScepAddAceToSecurityDescriptor(
    IN  DWORD    AceType,
    IN  ACCESS_MASK AccessMask,
    IN  PSID  pSid,
    IN OUT  PSECURITY_DESCRIPTOR    pSDAbsolute,
    IN  PSECURITY_DESCRIPTOR    pSDSelfRelative,
    OUT PACL    *ppNewAcl
    )
/*
Routine Description:

    This routine adds an ACE to a Security Descriptor (at the head only).

    Two optimizations are attempted in adding the ACE.

Arguments:

    AceType         -   type of ACE to add

    AccessMask      -   access mask of ACE to set

    pSid            -   sid for ACE to add

    pSDAbsolute     -   absolute SD ptr to build. pSDAbsolute must be empty.
                        It's vacuous in the caller's stack hence no SD member
                        should be freed outside this routine.

    pSDSelfRelative -   self relative SD to get DACL information from

    ppNewAcl        -   ptr to the new DACL which needs to be freed outside

Return Value:

    Win32 error code
*/
{

    DWORD   rc = ERROR_SUCCESS;
    BOOL    bOrMaskInOldDacl = FALSE;

    if (ppNewAcl == NULL ||
        pSDAbsolute == NULL ||
        pSDSelfRelative == NULL ||
        (AceType != ACCESS_ALLOWED_ACE_TYPE && AceType != ACCESS_DENIED_ACE_TYPE )
        ) {

        return ERROR_INVALID_PARAMETER;
    }

    PACL        pNewAcl = *ppNewAcl = NULL;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    BOOLEAN     bAclPresent = FALSE;
    PACL        pOldAcl = NULL;
    BOOLEAN     bDaclDefaulted = FALSE;
    DWORD       dwNewAclSize = 0;
    DWORD       dwAceSize = 0;
    ACE_HEADER  *pFirstAce = NULL;
    DWORD       dwFirstAceSize = 0;

    NtStatus = RtlGetDaclSecurityDescriptor(
                                           pSDSelfRelative,
                                           &bAclPresent,
                                           &pOldAcl,
                                           &bDaclDefaulted);

    rc = RtlNtStatusToDosError( NtStatus );

    if ( rc != ERROR_SUCCESS )
        goto Cleanup;

    //
    // null DACL should never happen - CliffV
    // we shouldn't set the DACL with the one
    // anonymous ACE only since it will deny
    // all other SID's any access
    //

    if ( !bAclPresent ||
         pOldAcl == NULL ||
         pOldAcl->AceCount == 0 ) {

        rc = ERROR_INVALID_ACL;
        goto Cleanup;

    }

    NtStatus = RtlGetAce( pOldAcl,
                          0,
                          (PVOID *) &pFirstAce);

    rc = RtlNtStatusToDosError( NtStatus );

    if ( rc != ERROR_SUCCESS )
        goto Cleanup;

    //
    // if the first ACE is for the SID passed in attempt two optimizations
    //

    if ( RtlValidSid((PSID)&((PKNOWN_ACE)pFirstAce)->SidStart) &&
         RtlEqualSid((PSID)&((PKNOWN_ACE)pFirstAce)->SidStart, pSid)) {

        if (pFirstAce->AceType == AceType) {

            //
            // Optimization 1:
            // simply OR in the mask
            //

            ((PKNOWN_ACE)pFirstAce)->Mask |= AccessMask;

            bOrMaskInOldDacl = TRUE;

            goto SetDacl;
        }

        else if (((PKNOWN_ACE)pFirstAce)->Mask == AccessMask ) {

            //
            // Optimization 2:
            // if only AccessMask is turned on, later on
            // (a) prepare a new ACE
            // (b) copy the old ACL except the first ACE
            //

            //
            // remember the size of the first ACE since we need to skip it
            //

            dwFirstAceSize = (DWORD)(((PKNOWN_ACE)pFirstAce)->Header.AceSize);
        }
    }


    switch (AceType) {
    case ACCESS_ALLOWED_ACE_TYPE:
        dwAceSize = sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(pSid) - sizeof(ULONG);
        break;
    case ACCESS_DENIED_ACE_TYPE:
        dwAceSize = sizeof(ACCESS_DENIED_ACE) + RtlLengthSid(pSid) - sizeof(ULONG);
        break;
    default:
        break;
    }

    dwNewAclSize = dwAceSize + pOldAcl->AclSize - dwFirstAceSize;

    *ppNewAcl = pNewAcl = (PACL) LocalAlloc(LMEM_ZEROINIT, dwNewAclSize);

    if ( pNewAcl == NULL ) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // initialize the ACL
    //

    pNewAcl->AclSize = (USHORT) dwNewAclSize;
    pNewAcl->AclRevision = ACL_REVISION;
    pNewAcl->AceCount = 0;

    //
    // add allow/deny ACE to the head of the ACL
    //

    switch (AceType) {
    case ACCESS_ALLOWED_ACE_TYPE:

        if (  ! AddAccessAllowedAce(
                                   pNewAcl,
                                   ACL_REVISION,
                                   AccessMask,
                                   pSid
                                   ) ) {
            rc = GetLastError();

        }

        break;

    case ACCESS_DENIED_ACE_TYPE:

        if (  ! AddAccessDeniedAce(
                                   pNewAcl,
                                   ACL_REVISION,
                                   AccessMask,
                                   pSid
                                   ) ) {
            rc = GetLastError();

        }

        break;

    default:
        break;
    }

    if ( rc != ERROR_SUCCESS)
        goto Cleanup;

    //
    // copy all the ACEs in the old ACL after the newly added ACE
    // (potentially skipping the first ACE in the old ACL)
    //

    memcpy((PUCHAR)pNewAcl +  sizeof(ACL) + dwAceSize,
           (PUCHAR)pOldAcl + sizeof(ACL) + dwFirstAceSize,
           pOldAcl->AclSize - (sizeof(ACL) + dwFirstAceSize) );

    pNewAcl->AceCount += pOldAcl->AceCount;

    if ( dwFirstAceSize != 0 )
        --pNewAcl->AceCount;

SetDacl:

    //
    // either set the adjusted-ACE ACL, or the added-ACE ACL in the SD
    //

    if ( rc == ERROR_SUCCESS ) {

        NtStatus = RtlSetDaclSecurityDescriptor (
                                                pSDAbsolute,
                                                TRUE,
                                                ( bOrMaskInOldDacl ? pOldAcl : pNewAcl),
                                                FALSE
                                                );

        rc = RtlNtStatusToDosError(NtStatus);

    }

    if ( rc == ERROR_SUCCESS ) {

        if ( !IsValidSecurityDescriptor(pSDAbsolute) )

            rc = ERROR_INVALID_SECURITY_DESCR;

    }


Cleanup:

    if (rc != ERROR_SUCCESS) {
        if (pNewAcl)
            LocalFree(pNewAcl);
        *ppNewAcl = NULL;

    }

    return rc;
}

DWORD
ScepConfigureLSAPolicyObject(
    IN  DWORD   dwLSAAnonymousNameLookup,
    IN  DWORD   ConfigOptions,
    IN PSCE_ERROR_LOG_INFO *pErrLog OPTIONAL,
    OUT BOOL    *pbOldLSAPolicyDifferent
    )
/*
Routine Description:

    This routine *actually* configures the LSA policy security descriptor ONLY if required.

Arguments:

    dwLSAAnonymousNameLookup    -   the value of the desired setting

    ConfigOptions               -   configuration options

    pErrLog                     -   ptr to error log list

    pbOldLSAPolicyDifferent     -   ptr to boolean that says whether or not the
                                    existing setting is different from the desired setting
                                    this information is required for tattooing

Return Value:

    Win32 error code
*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    DWORD       rc = ERROR_SUCCESS;
    PACL        pNewAcl = NULL;
    DWORD       dwAceType;
    BOOL        bAddAce = FALSE;
    PSECURITY_DESCRIPTOR    pSDCurrentLsaPolicyObject = NULL;
    SECURITY_DESCRIPTOR SDAbsoluteToBuildAndSet;

    if (pbOldLSAPolicyDifferent == NULL ||
        (dwLSAAnonymousNameLookup != 0 && dwLSAAnonymousNameLookup != 1))
        {

        return ERROR_INVALID_PARAMETER;

    }

    LSA_HANDLE  LsaHandle = NULL;

    if ( LsaPrivatePolicy == NULL ) {

        NtStatus = ScepOpenLsaPolicy(
                                    MAXIMUM_ALLOWED,
                                    &LsaHandle,
                                    TRUE
                                    );

        rc = RtlNtStatusToDosError( NtStatus );

    }

    else {

        LsaHandle = LsaPrivatePolicy;

    }

    if ( !NT_SUCCESS( NtStatus ) ) {

        if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

            ScepBuildErrorLogInfo(
                        rc,
                        pErrLog,
                        SCEDLL_LSA_POLICY
                        );
        } else {
            ScepLogOutput3(1, rc, SCEDLL_LSA_POLICY);
        }
    }

    if ( rc == ERROR_SUCCESS ) {

        NtStatus = LsaQuerySecurityObject(
                                         LsaHandle,
                                         OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                                         &pSDCurrentLsaPolicyObject
                                         );

        rc = RtlNtStatusToDosError( NtStatus );

        if ( !NT_SUCCESS( NtStatus ) ) {

            if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

                ScepBuildErrorLogInfo(
                            rc,
                            pErrLog,
                            SCEDLL_SCP_ERROR_LSAPOLICY_QUERY
                            );
            } else {
                ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LSAPOLICY_QUERY);
            }
        }

        if ( rc == ERROR_SUCCESS ) {

            LPTSTR pwszSDlsaPolicyObject = NULL;

            //
            // log the SDDL SD for diagnostics
            //

            if ( ConvertSecurityDescriptorToStringSecurityDescriptor(
                                                               pSDCurrentLsaPolicyObject,
                                                               SDDL_REVISION_1,
                                                               DACL_SECURITY_INFORMATION,
                                                               &pwszSDlsaPolicyObject,
                                                               NULL
                                                               ) ){

                ScepLogOutput3(1,0,SCEDLL_SCP_INFO_LSAPOLICY_EXISTING_SDDL, pwszSDlsaPolicyObject);

                LocalFree(pwszSDlsaPolicyObject);

            }

            //
            // use AUTHZ to check if desired access is existing access
            //

            if ( ghAuthzResourceManager ) {

                SID AnonymousSid;
                SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;
                AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext = NULL;
                LUID    Identifier = {0};

                RtlInitializeSid ( &AnonymousSid, &NtAuth, 1);
                *RtlSubAuthoritySid ( &AnonymousSid, 0 ) = SECURITY_ANONYMOUS_LOGON_RID;

                if ( AuthzInitializeContextFromSid(AUTHZ_SKIP_TOKEN_GROUPS,
                                                  &AnonymousSid,
                                                  ghAuthzResourceManager,
                                                  0,
                                                  Identifier,
                                                  NULL,
                                                  &hAuthzClientContext) ) {

                    AUTHZ_ACCESS_REPLY AuthzReply;
                    AUTHZ_ACCESS_REQUEST AuthzRequest;
                    ACCESS_MASK GrantedAccessMask;
                    DWORD   AuthzError;

                    AuthzReply.ResultListLength = 1;
                    AuthzReply.GrantedAccessMask = &GrantedAccessMask;
                    AuthzReply.Error = &AuthzError;
                    AuthzReply.SaclEvaluationResults = NULL;

                    memset(&AuthzRequest, 0, sizeof(AuthzRequest));
                    AuthzRequest.DesiredAccess = POLICY_LOOKUP_NAMES;

                    DWORD   AceType = 0;

                    if ( AuthzAccessCheck(0,
                                         hAuthzClientContext,
                                         &AuthzRequest,
                                         NULL,
                                         pSDCurrentLsaPolicyObject,
                                         NULL,
                                         NULL,
                                         &AuthzReply,
                                         NULL) ) {

                        //
                        // check if existing access is different from desired access
                        // if so, add the appropriate ACE or manipulate existing ACEs
                        // to get the desired permissions
                        //

                        if ( GrantedAccessMask & POLICY_LOOKUP_NAMES ) {
                            //ASSERT(AuthzError == ERROR_SUCCESS);
                            if ( !dwLSAAnonymousNameLookup ) {

                                bAddAce = TRUE;
                                AceType = ACCESS_DENIED_ACE_TYPE;

                            }


                        } else {
                            //ASSERT(AuthzError == ERROR_ACCESS_DENIED || AuthzError == ERROR_PRIVILEGE_NOT_HELD);
                            if ( dwLSAAnonymousNameLookup ) {

                                bAddAce = TRUE;
                                AceType = ACCESS_ALLOWED_ACE_TYPE;

                            }
                        }

                        if ( bAddAce ) {

                            *pbOldLSAPolicyDifferent = TRUE;

                            if ( InitializeSecurityDescriptor( &SDAbsoluteToBuildAndSet, SECURITY_DESCRIPTOR_REVISION) ) {

                                rc = ScepAddAceToSecurityDescriptor(
                                                                   AceType,
                                                                   POLICY_LOOKUP_NAMES,
                                                                   &AnonymousSid,
                                                                   &SDAbsoluteToBuildAndSet,
                                                                   pSDCurrentLsaPolicyObject,
                                                                   &pNewAcl
                                                                   );

                                if ( rc == ERROR_SUCCESS) {

                                    //
                                    // log the SDDL SD for diagnostics
                                    //
                                    pwszSDlsaPolicyObject = NULL;

                                    if ( ConvertSecurityDescriptorToStringSecurityDescriptor(
                                                                                       &SDAbsoluteToBuildAndSet,
                                                                                       SDDL_REVISION_1,
                                                                                       DACL_SECURITY_INFORMATION,
                                                                                       &pwszSDlsaPolicyObject,
                                                                                       NULL
                                                                                       ) ){

                                        ScepLogOutput3(1,0,SCEDLL_SCP_INFO_LSAPOLICY_COMPUTED_SDDL, pwszSDlsaPolicyObject);

                                        LocalFree(pwszSDlsaPolicyObject);

                                    }

                                    NtStatus = LsaSetSecurityObject(
                                                                   LsaHandle,
                                                                   DACL_SECURITY_INFORMATION,
                                                                   &SDAbsoluteToBuildAndSet
                                                                   );

                                    LocalFree(pNewAcl);

                                    rc = RtlNtStatusToDosError( NtStatus );

                                    if ( !NT_SUCCESS( NtStatus ) ) {

                                        if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

                                            ScepBuildErrorLogInfo(
                                                        rc,
                                                        pErrLog,
                                                        SCEDLL_SCP_ERROR_LSAPOLICY_SET
                                                        );
                                        } else {
                                            ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LSAPOLICY_SET);
                                        }
                                    }

                                }

                                else {

                                    if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

                                        ScepBuildErrorLogInfo(
                                                    rc,
                                                    pErrLog,
                                                    SCEDLL_SCP_ERROR_LSAPOLICY_BUILDDACL
                                                    );
                                    } else {
                                        ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LSAPOLICY_BUILDDACL);
                                    }

                                }

                            }

                            else {

                                rc = GetLastError();

                                if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

                                    ScepBuildErrorLogInfo(
                                                rc,
                                                pErrLog,
                                                SCEDLL_SCP_ERROR_LSAPOLICY_SD_INIT
                                                );
                                } else {
                                    ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LSAPOLICY_SD_INIT);
                                }


                            }

                        }

                    }

                    else {

                        rc = GetLastError();

                        if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

                            ScepBuildErrorLogInfo(
                                        rc,
                                        pErrLog,
                                        SCEDLL_SCP_ERROR_LSAPOLICY_AUTHZ
                                        );
                        } else {
                            ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LSAPOLICY_AUTHZ);
                        }

                    }

                    AuthzFreeContext( hAuthzClientContext );

                } else {

                    rc = GetLastError();

                    if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

                        ScepBuildErrorLogInfo(
                                    rc,
                                    pErrLog,
                                    SCEDLL_SCP_ERROR_LSAPOLICY_AUTHZ
                                    );
                    } else {
                        ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LSAPOLICY_AUTHZ);
                    }

                }

            }

            else {

                rc = ERROR_RESOURCE_NOT_PRESENT;

                if ( (ConfigOptions & SCE_SYSTEM_SETTINGS) && pErrLog ) {

                    ScepBuildErrorLogInfo(
                                rc,
                                pErrLog,
                                SCEDLL_SCP_ERROR_LSAPOLICY_AUTHZ
                                );
                } else {
                    ScepLogOutput3(1, rc, SCEDLL_SCP_ERROR_LSAPOLICY_AUTHZ);
                }

            }

            LsaFreeMemory(pSDCurrentLsaPolicyObject);

        }

        if ( LsaPrivatePolicy == NULL ) {

            LsaClose(LsaHandle);

        }

    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\dumpnt.c ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    dumpnt.c

Abstract:

      Dump routines for various native defined types.

      The original/maintained version of this code lives @
      \\brillig\ntct!slm\src\security\util\dumpnt.c

Author:

    TimF 12-Jun-92 created

Revision History:

    JinHuang 13-Feb-98 modified
*/

#include	<stdio.h>

#include	<nt.h>
#include	<ntrtl.h>
#include	<nturtl.h>
#include	<windows.h>
#include	<ntlsa.h>
#include	<ntsam.h>

#include	"dumpnt.h"


/*
 * Generic header:
 *
 * Dump<TYPE_FOO>
 *
 * Takes a pointer to an object of TYPE_FOO, and dumps the contents of that
 * structure to wherever output is being sent these days (as best it can).
 *
 * Pointers and regions pointed are expected to be valid, and accessible.
 *
 * No return value is defined.
 */

VOID
DumpGUID(
	IN	GUID			*g
)
{
	if (!g) {
		printf("<NULL>\n");
	} else {
		try {
			printf("0x%08lx-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n",
				g -> Data1,
				g -> Data2,
				g -> Data3,
				g -> Data4[0],
				g -> Data4[1],
				g -> Data4[2],
				g -> Data4[3],
				g -> Data4[4],
				g -> Data4[5],
				g -> Data4[6],
				g -> Data4[7]);
		} except (EXCEPTION_EXECUTE_HANDLER) {
			printf("DumpGUID:  invalid pointer (0x%p)\n",
				g);
		}
	}
}


VOID
DumpSID(
	IN	PSID			s
)
{
	static	char	b[128];

	SID_IDENTIFIER_AUTHORITY	*a;
	ULONG			id = 0, i;

	try {
		b[0] = '\0';

		a = RtlIdentifierAuthoritySid(s);

		sprintf(b, "s-0x1-%02x%02x%02x%02x%02x%02x", a -> Value[0],
			a -> Value[1], a -> Value[2], a -> Value[3], a ->
			Value[4], a -> Value[5]);

		for (i = 0; i < *RtlSubAuthorityCountSid(s); i++) {
			sprintf(b, "%s-%lx", b, *RtlSubAuthoritySid(s, i));
		}

		printf("%s", b);
	} except (EXCEPTION_EXECUTE_HANDLER) {
		printf("%s<invalid pointer:  0x%p>\t", b, s);
	}
}


/*
 * DumpSIDNAME() attempts to unravel the Sid into a Display Name
 */

VOID
DumpSIDNAME(
	IN	PSID			s
)
{
	NTSTATUS		Status;
	LSA_HANDLE		Policy;
	OBJECT_ATTRIBUTES	ObjAttr;
	SECURITY_QUALITY_OF_SERVICE SQoS;
	PLSA_REFERENCED_DOMAIN_LIST RefDomains = NULL;
	PLSA_TRANSLATED_NAME	XNames = NULL;

	try {
		/*
		 * Open the policy with POLICY_LOOKUP_NAMES and lookup this
		 * Sid.
		 */

		InitializeObjectAttributes(&ObjAttr,
			NULL,
			0L,
			NULL,
			NULL);

		/*
		 * init the sqos struct
		 */

		SQoS.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
		SQoS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
		SQoS.ImpersonationLevel = SecurityIdentification;
		SQoS.EffectiveOnly = TRUE;

		ObjAttr.SecurityQualityOfService = &SQoS;

		/*
		 * make the actual call
		 */

		Status = LsaOpenPolicy(NULL,
			&ObjAttr,
			POLICY_LOOKUP_NAMES,
			&Policy);

		if (!NT_SUCCESS(Status)) {
			printf("DumpSIDNAMES: can't open Lsa, (0x%lx)\n",
				Status);

			return;
		}

		Status = LsaLookupSids(Policy,
			1L,
			&s,
			&RefDomains,
			&XNames);

		if (Status == STATUS_NONE_MAPPED) {
			printf("Unknown\n");
		} else if (!NT_SUCCESS(Status)) {
			printf("DumpSIDNAMES: can't Lookup Sids, (0x%lx)\n",
				Status);
		} else {
			printf("'%wZ' (%s)\n",
				&(XNames->Name),
				(XNames->Use == SidTypeUser ? "User" :
				 XNames->Use == SidTypeGroup ? "Group" :
				 XNames->Use == SidTypeDomain ? "Domain" :
				 XNames->Use == SidTypeAlias ? "Alias" :
				 XNames->Use == SidTypeWellKnownGroup ? "WellKnownGroup" :
				 XNames->Use == SidTypeDeletedAccount ? "Deleted" :
				 XNames->Use == SidTypeInvalid ? "Invalid" :
				 XNames->Use == SidTypeUnknown ?  "Unknown" :
				"ERROR!"));
		}
	} except (EXCEPTION_EXECUTE_HANDLER) {
		printf("DumpSIDNAME:  invalid pointer (0x%p)\n", s);
	}

	if (RefDomains) {
		LsaFreeMemory(RefDomains);
	}

	if (XNames) {
		LsaFreeMemory(XNames);
	}

	LsaClose(Policy);
}


VOID
DumpACL(
	IN	ACL			*a
)
{
	ACE_HEADER		*Ace;
	USHORT			i;

	try {
		printf("Acl -> AclRevision = 0x%x\n", a -> AclRevision);
		printf("Acl -> Sbz1 = 0x%x\n", a -> Sbz1);
		printf("Acl -> AclSize = 0x%x\n", a -> AclSize);
		printf("Acl -> AceCount = 0x%x\n", a -> AceCount);
		printf("Acl -> Sbz2 = 0x%x\n\n", a -> Sbz2);

		for (i = 0; i < a -> AceCount; i++) {
			if (NT_SUCCESS(RtlGetAce(a, i, (PVOID *)&Ace))) {
				DumpACE(Ace);
			} else {
				printf("(Can't RtlGetAce[%d])\n", i);
			}

			printf("\n");
		}
	} except (EXCEPTION_EXECUTE_HANDLER) {
		printf("DumpACL:  invalid pointer (0x%p)\n", a);
	}
}


VOID
DumpACE(
	IN	ACE_HEADER		*a
)
{
	ACCESS_ALLOWED_ACE	*Ace = (ACCESS_ALLOWED_ACE *)a;

	try {
		printf("Ace -> AceType = ");
		Dump_ACE_TYPE(a -> AceType);

		printf("Ace -> AceSize = 0x%x\n", a -> AceSize);

		printf("Ace -> AceFlags = ");
		Dump_ACE_FLAGS(a -> AceFlags);

		switch (a -> AceType) {
			case ACCESS_ALLOWED_ACE_TYPE:
			case ACCESS_DENIED_ACE_TYPE:
			case SYSTEM_AUDIT_ACE_TYPE:
			case SYSTEM_ALARM_ACE_TYPE:
				printf("Ace -> Mask = 0x%lx\n",
					Ace -> Mask);

				printf("Ace -> Sid = ");
				DumpSID(&(Ace -> SidStart));
				printf("\t");
				DumpSIDNAME(&(Ace -> SidStart));

				break;

			case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
			case ACCESS_DENIED_OBJECT_ACE_TYPE:
			case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
			case SYSTEM_ALARM_OBJECT_ACE_TYPE: {

				ACCESS_ALLOWED_OBJECT_ACE *Ace;
				ULONG_PTR Offset;

				Ace = (ACCESS_ALLOWED_OBJECT_ACE *)a;

				printf("Ace -> Mask = 0x%lx\n",
					Ace -> Mask);

				if (!Ace -> Flags) {
					printf("Ace -> Flags = 0\n");
				} else {
					printf("Ace -> Flags = ");

					if (Ace -> Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
						printf("ACE_INHERITED_OBJECT_TYPE_PRESENT ");
					}

					if (Ace -> Flags & ACE_OBJECT_TYPE_PRESENT) {
						printf("ACE_OBJECT_TYPE_PRESENT");
					}

					printf("\n");
				}

				Offset = (ULONG_PTR)&(Ace -> ObjectType);

				if (Ace -> Flags & ACE_OBJECT_TYPE_PRESENT) {
					printf("Ace -> ObjectType = ");
					DumpGUID((GUID *)Offset);

					Offset += sizeof (GUID);
				}
				
				if (Ace -> Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
					printf("Ace -> InheritedObjectType = ");
					DumpGUID((GUID *)Offset);

					Offset += sizeof (GUID);
				}

				printf("Ace -> Sid = ");
				DumpSID((SID *)Offset);
				printf("\t");
				DumpSIDNAME((SID *)Offset);

				break;
			}

			default:
				printf("(Unknown ACE type)\n");

				break;
		}
	} except (EXCEPTION_EXECUTE_HANDLER) {
		printf("DumpACE:  invalid pointer (0x%p)\n",
			a);
	}
}


VOID
DumpSECURITY_DESCRIPTOR_CONTROL(
	SECURITY_DESCRIPTOR_CONTROL Control
)
{
	printf("SecurityDescriptor -> Control = ");

	if (!Control) {
		printf("<no flags set>");
	}

	if (Control & SE_OWNER_DEFAULTED) {
		printf("SE_OWNER_DEFAULTED ");
	}
	
	if (Control & SE_GROUP_DEFAULTED) {
		printf("SE_GROUP_DEFAULTED ");
	}
	
	if (Control & SE_DACL_PRESENT) {
		printf("SE_DACL_PRESENT ");
	}
	
	if (Control & SE_DACL_DEFAULTED) {
		printf("SE_DACL_DEFAULTED ");
	}
	
	if (Control & SE_SACL_PRESENT) {
		printf("SE_SACL_PRESENT ");
	}
	
	if (Control & SE_SACL_DEFAULTED) {
		printf("SE_SACL_DEFAULTED ");
	}
	
	if (Control & SE_DACL_UNTRUSTED) {
		printf("SE_DACL_UNTRUSTED ");
	}
	
	if (Control & SE_SERVER_SECURITY) {
		printf("SE_SERVER_SECURITY ");
	}
	
	if (Control & SE_DACL_AUTO_INHERIT_REQ) {
		printf("SE_DACL_AUTO_INHERIT_REQ ");
	}
	
	if (Control & SE_SACL_AUTO_INHERIT_REQ) {
		printf("SE_SACL_AUTO_INHERIT_REQ ");
	}
	
	if (Control & SE_DACL_AUTO_INHERITED) {
		printf("SE_DACL_AUTO_INHERITED ");
	}
	
	if (Control & SE_SACL_AUTO_INHERITED) {
		printf("SE_SACL_AUTO_INHERITED ");
	}
	
	if (Control & SE_DACL_PROTECTED) {
		printf("SE_DACL_PROTECTED ");
	}
	
	if (Control & SE_SACL_PROTECTED) {
		printf("SE_SACL_PROTECTED ");
	}
	
	if (Control & SE_SELF_RELATIVE) {
		printf("SE_SELF_RELATIVE");
	}

	printf("\n");
}


VOID
DumpSECURITY_DESCRIPTOR(
	IN	PSECURITY_DESCRIPTOR	s
)
{
	BOOLEAN			Defaulted, Present;
	PACL			Acl;
	PSID			Sid;
	SECURITY_DESCRIPTOR_CONTROL Control;
	ULONG			Rev;

	try {
		printf("\nSecurityDescriptor -> Length = 0x%lx\n",
			RtlLengthSecurityDescriptor(s));

		RtlGetControlSecurityDescriptor(s,
			&Control,
			&Rev);

		DumpSECURITY_DESCRIPTOR_CONTROL(Control);

		printf("SecurityDescriptor -> Revision = 0x%lx\n",
			Rev);

		RtlGetOwnerSecurityDescriptor(s,
			&Sid,
			&Defaulted);

		printf("SecurityDescriptor -> Owner = ");
		if (Sid) {
			DumpSID(Sid);
			printf("\t");
			DumpSIDNAME(Sid);

		} else {
			printf("<NULL>\n");
		}

		RtlGetGroupSecurityDescriptor(s,
			&Sid,
			&Defaulted);

		printf("SecurityDescriptor -> Group = ");
		if (Sid) {
			DumpSID(Sid);
			printf("\t");
			DumpSIDNAME(Sid);
		} else {
			printf("<NULL>\n");
		}

		RtlGetDaclSecurityDescriptor(s,
			&Present,
			&Acl,
			&Defaulted);
			
		if (Present && Acl) {
			printf("SecurityDescriptor -> Dacl = \n");
			DumpACL(Acl);
		} else {
			printf("SecurityDescriptor -> Dacl = <not present>\n");
		}

		RtlGetSaclSecurityDescriptor(s,
			&Present,
			&Acl,
			&Defaulted);
			
		if (Present && Acl) {
			printf("SecurityDescriptor -> Sacl = \n");
			DumpACL(Acl);
		} else {
			printf("SecurityDescriptor -> Sacl = <not present>\n");
		}
	} except (EXCEPTION_EXECUTE_HANDLER) {
		printf("DumpSECURITY_DESCRIPTOR:  invalid pointer (0x%p)\n",
			s);
	}
}




VOID
DumpUNICODE_STRING(
	IN	UNICODE_STRING		*s
)
{
	ANSI_STRING		a;

	try {
		printf("UnicodeString -> Length = 0x%x\n", s -> Length);
		printf("UnicodeString -> MaximumLength = 0x%x\n",
			s -> MaximumLength);

		RtlUnicodeStringToAnsiString(&a,
			s,
			TRUE);

		printf("UnicodeString -> Buffer (a la ansi) = \"%s\"\n",
			a.Buffer);

		RtlFreeAnsiString(&a);
	} except (EXCEPTION_EXECUTE_HANDLER) {
		printf("DumpUNICODE_STRING:  invalid pointer (0x%p)\n", s);
	}
}


VOID
Dump_ACE_TYPE(
	IN	UCHAR			t
)
{
	switch (t) {
		case ACCESS_ALLOWED_ACE_TYPE:

			printf("ACCESS_ALLOWED_ACE_TYPE\n");

			break;

		case ACCESS_DENIED_ACE_TYPE:

			printf("ACCESS_DENIED_ACE_TYPE\n");

			break;

		case SYSTEM_AUDIT_ACE_TYPE:

			printf("SYSTEM_AUDIT_ACE_TYPE\n");

			break;

		case SYSTEM_ALARM_ACE_TYPE:

			printf("SYSTEM_ALARM_ACE_TYPE\n");

			break;

		case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

			printf("ACCESS_ALLOWED_COMPOUND_ACE_TYPE\n");

			break;

		case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

			printf("ACCESS_ALLOWED_OBJECT_ACE_TYPE\n");

			break;

		case ACCESS_DENIED_OBJECT_ACE_TYPE:

			printf("ACCESS_DENIED_OBJECT_ACE_TYPE\n");

			break;
		
		case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

			printf("SYSTEM_AUDIT_OBJECT_ACE_TYPE\n");

			break;

		case SYSTEM_ALARM_OBJECT_ACE_TYPE:

			printf("SYSTEM_ALARM_OBJECT_ACE_TYPE\n");

			break;

		default:

			printf("(unknown ace type)\n");

			break;
	}
}


VOID	
Dump_ACE_FLAGS(
	IN	UCHAR			f
)
{
	if (f & INHERIT_ONLY_ACE) {
		printf("INHERIT_ONLY_ACE ");
	}

	if (f & NO_PROPAGATE_INHERIT_ACE) {
		printf("NO_PROPAGATE_INHERIT_ACE ");
	}

	if (f & CONTAINER_INHERIT_ACE) {
		printf("CONTAINER_INHERIT_ACE ");
	}

	if (f & OBJECT_INHERIT_ACE) {
		printf("OBJECT_INHERIT_ACE ");
	}

	if (f & INHERITED_ACE) {
		printf("INHERITED_ACE ");
	}

	if (f & SUCCESSFUL_ACCESS_ACE_FLAG) {
		printf("SUCCESSFUL_ACCESS_ACE_FLAG ");
	}

	if (f & FAILED_ACCESS_ACE_FLAG) {
		printf("FAILED_ACCESS_ACE_FLAG");
	}

	printf("\n");
}


VOID
DumpSTRING(
	IN	STRING			*s
)
{
	try {
		printf("String -> Length = 0x%x\n", s -> Length);
		printf("String -> MaximumLength = 0x%x\n", s ->
			MaximumLength);
		printf("String -> Buffer = \"%s\"\n", s -> Buffer);
	} except (EXCEPTION_EXECUTE_HANDLER) {
		printf("DumpUNICODE_STRING:  invalid pointer (0x%p)\n", s);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\dsobject.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dsobject.cpp

Abstract:

    Routines to configure/analyze security of DS objects

Author:

    Jin Huang (jinhuang) 7-Nov-1996

--*/
#include "headers.h"
#include "serverp.h"
#include <io.h>
#include <lm.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <ntldap.h>
#pragma hdrstop

//#define SCEDS_DBG 1

//
// NT-Security-Descriptor attribute's LDAP name.
//
#define ACTRL_SD_PROP_NAME  L"nTSecurityDescriptor"

//
// LDAP handle
//
PLDAP Thread  pLDAP = NULL;
BOOL  Thread  StartDsCheck=FALSE;

DWORD
ScepConvertObjectTreeToLdap(
    IN PSCE_OBJECT_TREE pObject
    );

SCESTATUS
ScepConfigureDsObjectTree(
    IN PSCE_OBJECT_TREE  ThisNode
    );

DWORD
ScepSetDsSecurityOverwrite(
    PWSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor OPTIONAL,
    SECURITY_INFORMATION SeInfo,
    PSCE_OBJECT_CHILD_LIST pNextLevel OPTIONAL
    );

BOOL
ScepIsMatchingSchemaObject(
    PWSTR  Class,
    PWSTR  ClassDn
    );

DWORD
ScepAnalyzeDsObjectTree(
    IN PSCE_OBJECT_TREE ThisNode
    );

DWORD
ScepAnalyzeDsObject(
    IN PWSTR ObjectFullName,
    IN PSECURITY_DESCRIPTOR ProfileSD,
    IN SECURITY_INFORMATION ProfileSeInfo
    );

DWORD
ScepAnalyzeDsObjectAndChildren(
    IN PWSTR ObjectName,
    IN BYTE Status,
    IN SECURITY_INFORMATION SeInfo,
    IN PSCE_OBJECT_CHILD_LIST pNextLevel
    );

PSECURITY_DESCRIPTOR
ScepMakeNullSD();

DWORD
ScepChangeSecurityOnObject(
    PWSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    SECURITY_INFORMATION SeInfo
    );

DWORD
ScepReadDsObjSecurity(
    IN  PWSTR                  pwszObject,
    IN  SECURITY_INFORMATION   SeInfo,
    OUT PSECURITY_DESCRIPTOR  *ppSD
    );

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// Functions to configure DS object security
//
//
//
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SCESTATUS
ScepConfigureDsSecurity(
    IN PSCE_OBJECT_TREE   pObject
    )
/* ++

Routine Description:

   Configure the ds object security as specified in pObject tree.
   This routine should only be executed on a domain controller.

Arguments:

    pObject - The ds object tree. The objects in the tree are in
    the format of Jet index (o=,dc=,...cn=), need to convert before
    calls to ldap

Return value:

   SCESTATUS error codes

++ */
{

    SCESTATUS            rc;
    DWORD               Win32rc;

    //
    // open the Ldap server
    //
    rc = ScepLdapOpen(NULL);

    if ( rc == SCESTATUS_SUCCESS ) {
        //
        // process the tree node format to ldap format
        //
        Win32rc = ScepConvertObjectTreeToLdap(pObject);

        if ( Win32rc == ERROR_SUCCESS ) {
            //
            // do not need bind because ConvertObjectTreeToLadp already does that
            //
            //
            // configure the object tree
            //
            rc = ScepConfigureDsObjectTree(pObject);

        } else {
            ScepLogOutput3(1, Win32rc,
                         SCEDLL_ERROR_CONVERT_LDAP,
                         pObject->ObjectFullName);
            rc = ScepDosErrorToSceStatus(Win32rc);
        }

        ScepLdapClose(NULL);

    }

    return(rc);
}


SCESTATUS
ScepConfigureDsObjectTree(
    IN PSCE_OBJECT_TREE  ThisNode
    )
/* ++
Routine Description:

    This routine set security information to each DS object in the tree. DS
    objects are configured separately from file/registry objects because the
    logic behind ds objects is different.


Arguments:

    ThisNode - one node in the tree

Return value:

    SCESTATUS

-- */
{
    if ( ThisNode == NULL )
        return(SCESTATUS_SUCCESS);

    SCESTATUS        rc=SCESTATUS_SUCCESS;
    //
    // if IGNORE is set, skip this node
    //
    if ( ThisNode->Status != SCE_STATUS_CHECK &&
         ThisNode->Status != SCE_STATUS_OVERWRITE &&
         ThisNode->Status != SCE_STATUS_NO_AUTO_INHERIT )
        goto SkipNode;

    if ( ThisNode->pSecurityDescriptor != NULL ) {

        ScepLogOutput3(2, 0, SCEDLL_SCP_CONFIGURE, ThisNode->ObjectFullName);
        //
        // notify the progress bar if there is any
        //
        ScepPostProgress(1, AREA_DS_OBJECTS, ThisNode->ObjectFullName);
    }
    //
    // Process this node first
    //
    if ( ThisNode->pSecurityDescriptor != NULL ||
         ThisNode->Status == SCE_STATUS_OVERWRITE ) {

        ScepLogOutput3(1, 0, SCEDLL_SCP_CONFIGURE, ThisNode->ObjectFullName);

        DWORD Win32Rc;
        //
        // set security to the ds object and all children
        // because the OVERWRITE flag.
        //
        if ( ThisNode->Status == SCE_STATUS_OVERWRITE ) {
            //
            // prepare for next level nodes
            //
            for ( PSCE_OBJECT_CHILD_LIST pTemp = ThisNode->ChildList;
                  pTemp != NULL;
                  pTemp = pTemp->Next ) {

                if ( pTemp->Node->pSecurityDescriptor == NULL &&
                     pTemp->Node->Status != SCE_STATUS_IGNORE )

                    pTemp->Node->Status = SCE_STATUS_OVERWRITE;
            }

            //
            // recursive set objects under the node, exclude nodes in the tree
            //
            Win32Rc = ScepSetDsSecurityOverwrite(
                            ThisNode->ObjectFullName,
                            ThisNode->pSecurityDescriptor,
                            ThisNode->SeInfo,
                            ThisNode->ChildList
                            );

        } else {

            Win32Rc = ScepChangeSecurityOnObject(
                        ThisNode->ObjectFullName,
                        ThisNode->pSecurityDescriptor,
                        ThisNode->SeInfo
                        );
        }
        //
        // ignore the following error codes
        //
        if ( Win32Rc == ERROR_FILE_NOT_FOUND ||
             Win32Rc == ERROR_PATH_NOT_FOUND ||
             Win32Rc == ERROR_ACCESS_DENIED ||
             Win32Rc == ERROR_SHARING_VIOLATION ||
             Win32Rc == ERROR_INVALID_OWNER ||
             Win32Rc == ERROR_INVALID_PRIMARY_GROUP) {

            gWarningCode = Win32Rc;
            rc = SCESTATUS_SUCCESS;
            goto SkipNode;
        }

        if ( Win32Rc != ERROR_SUCCESS )
            return(ScepDosErrorToSceStatus(Win32Rc));
    }

    //
    // then process children
    //
    for ( PSCE_OBJECT_CHILD_LIST pTemp = ThisNode->ChildList;
          pTemp != NULL;
          pTemp = pTemp->Next ) {

        if ( pTemp->Node == NULL ) continue;

        rc = ScepConfigureDsObjectTree(
                    pTemp->Node
                    );
    }

SkipNode:

    return(rc);

}


DWORD
ScepSetDsSecurityOverwrite(
    PWSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor OPTIONAL,
    SECURITY_INFORMATION SeInfo,
    PSCE_OBJECT_CHILD_LIST pNextLevel OPTIONAL
    )
{
    DWORD retErr=ERROR_SUCCESS;

    //
    // set security on the object first
    //
/*
    retErr = ScepSetSecurityWin32(
                ObjectName,
                SeInfo,
                pSecurityDescriptor,
                SE_DS_OBJECT
                );
*/
    retErr = ScepChangeSecurityOnObject(
                ObjectName,
                pSecurityDescriptor,
                SeInfo
                );
    if ( retErr == ERROR_SUCCESS ) {
        //
        // enumerate one level nodes under the current object
        //
        LDAPMessage *Message = NULL;
        PWSTR    Attribs[2];
        WCHAR    dn[] = L"distinguishedName";

        Attribs[0] = dn;
        Attribs[1] = NULL;

        retErr = ldap_search_s( pLDAP,
                  ObjectName,
                  LDAP_SCOPE_ONELEVEL,
                  L"(objectClass=*)",
                  Attribs,
                  0,
                  &Message);

        if( Message ) {
            retErr = ERROR_SUCCESS;

            LDAPMessage *Entry = NULL;
            //
            // How many entries ?
            //
            ULONG nChildren = ldap_count_entries(pLDAP, Message);
            //
            // get the first one.
            //
            Entry = ldap_first_entry(pLDAP, Message);
            //
            // now loop through the entries and recursively fix the
            // security on the subtree.
            //
            PWSTR  *Values;
            PWSTR SubObjectName;
            INT   cmpFlag;
            PSCE_OBJECT_CHILD_LIST pTemp;

            PSECURITY_DESCRIPTOR pNullSD = ScepMakeNullSD();

            for(ULONG i = 0; i<nChildren; i++) {

                if(Entry != NULL) {

                    Values = ldap_get_values(pLDAP, Entry, Attribs[0]);

                    if(Values != NULL) {
                        //
                        // Save the sub object DN for recursion.
                        //
                        SubObjectName = (PWSTR)LocalAlloc(0,(wcslen(Values[0]) + 1)*sizeof(WCHAR));
                        if ( SubObjectName != NULL ) {

                            wcscpy(SubObjectName, Values[0]);
#ifdef SCEDS_DBG
    printf("%ws\n", SubObjectName);
#endif
                            ldap_value_free(Values);
                            //
                            // check if the SubObjectName is in the object tree already
                            // SubObjectName should not contain extra spaces and comma is used as the delimiter
                            // if not, need a convert routine to handle it.
                            //
                            for ( pTemp = pNextLevel; pTemp != NULL; pTemp=pTemp->Next ) {
                                cmpFlag = _wcsicmp(pTemp->Node->ObjectFullName, SubObjectName);
                                if ( cmpFlag >= 0 )
                                    break;
                            }
                            if ( pTemp == NULL || cmpFlag > 0 ) {
                                //
                                // did not find in the object tree, so resurse it
                                //

                                retErr = ScepSetDsSecurityOverwrite(
                                                SubObjectName,
                                                pNullSD,
                                                (SeInfo & ( DACL_SECURITY_INFORMATION |
                                                            SACL_SECURITY_INFORMATION)),
                                                NULL
                                                );
                            }  // else find it, skip the subnode

                            LocalFree(SubObjectName);

                        } else {
                            ldap_value_free(Values);
                            retErr = ERROR_NOT_ENOUGH_MEMORY;
                        }

                    } else {
                        retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
                    }

                } else {
                    retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
                }

                if ( retErr != ERROR_SUCCESS ) {
                    break;
                }
                if ( i < nChildren-1 ) {
                    Entry = ldap_next_entry(pLDAP, Entry);
                }
            }  // end for loop

            //
            // free the NULL security descriptor
            //
            if ( pNullSD ) {
                ScepFree(pNullSD);
            }

            ldap_msgfree(Message);
        }
    }

    return(retErr);
}


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// Functions to analyze DS object security
//
//
//
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

BOOL
ScepIsMatchingSchemaObject(
    PWSTR  Class,
    PWSTR  ClassDn
    )
{
    //
    // Note: Class and ClassDn can't be NULL
    //
    ULONG   len = lstrlen(Class);
    ULONG   i;

    //
    // if the first component is not CN=, then no point continuing
    //
    if(*ClassDn != L'C') return FALSE;

    //
    // we need to match the name exactly.
    //
    for(i=0;i<len;i++)
    {
        if(ClassDn[i+3] != Class[i]) return FALSE;
    }

    //
    // things are good, but ensure that this is not just a prefix match!
    //
    if(ClassDn[i+3] == L',' || ClassDn[i+3] == L';')
        return TRUE;
    else
        return FALSE;
}


DWORD
ScepAnalyzeDsSecurity(
    IN PSCE_OBJECT_TREE pObject
    )
/* ++

Routine Description:

   Analyze the ds object security as specified in pObject tree.
   This routine should only be executed on a domain controller.

Arguments:

    pObject - The ds object tree

Return value:

   SCESTATUS error codes

++ */
{
    DWORD               Win32rc;

    //
    // open the Ldap server
    //
    Win32rc = ScepSceStatusToDosError( ScepLdapOpen(NULL) );

    if( Win32rc == ERROR_SUCCESS ) {
        //
        // process the tree node format to ldap format
        //
        Win32rc = ScepConvertObjectTreeToLdap(pObject);

        if ( Win32rc == ERROR_SUCCESS ) {
            //
            // analyze all ds objects to the level that NOT_CONFIGURED
            // status is raised for the node
            // no matter if the node is specified in the tree
            //
            StartDsCheck=FALSE;
            Win32rc = ScepAnalyzeDsObjectTree(pObject);

        } else {
            ScepLogOutput3(1, Win32rc,
                          SCEDLL_ERROR_CONVERT_LDAP, pObject->ObjectFullName);
        }

        ScepLdapClose(NULL);

    }

    return(Win32rc);
}


DWORD
ScepAnalyzeDsObjectTree(
    IN PSCE_OBJECT_TREE ThisNode
    )
/* ++
Routine Description:

    This routine analyze security information of each DS object in the tree. DS
    objects are analyzed separately from file/registry objects because the
    logic behind ds objects is different.


Arguments:

    ThisNode - one node in the tree

Return value:

    Win32 error codes

-- */
{

    if ( ThisNode == NULL )
        return(ERROR_SUCCESS);

    DWORD           Win32Rc=ERROR_SUCCESS;
    //
    // if IGNORE is set, log a SAP and skip this node
    //
    if ( ThisNode->Status != SCE_STATUS_CHECK &&
         ThisNode->Status != SCE_STATUS_OVERWRITE &&
         ThisNode->Status != SCE_STATUS_NO_AUTO_INHERIT ) {
        //
        // Log a point in SAP
        //
        Win32Rc = ScepSaveDsStatusToSection(
                    ThisNode->ObjectFullName,
                    ThisNode->IsContainer,
                    SCE_STATUS_NOT_CONFIGURED,
                    NULL,
                    0
                    );

        goto SkipNode;
    }

    if ( NULL != ThisNode->pSecurityDescriptor ) {
        //
        // notify the progress bar if there is any
        //
        ScepPostProgress(1, AREA_DS_OBJECTS, ThisNode->ObjectFullName);

        StartDsCheck = TRUE;

        ScepLogOutput3(1, 0, SCEDLL_SAP_ANALYZE, ThisNode->ObjectFullName);
        //
        // only analyze objects with explicit aces specified
        //
        Win32Rc = ScepAnalyzeDsObject(
                    ThisNode->ObjectFullName,
                    ThisNode->pSecurityDescriptor,
                    ThisNode->SeInfo
                    );
        //
        // if the object denies access, skip it.
        //
        if ( Win32Rc == ERROR_ACCESS_DENIED ||
             Win32Rc == ERROR_SHARING_VIOLATION) {
            //
            // log a point in SAP for skipping
            //
            Win32Rc = ScepSaveDsStatusToSection(
                        ThisNode->ObjectFullName,
                        ThisNode->IsContainer,
                        SCE_STATUS_ERROR_NOT_AVAILABLE,
                        NULL,
                        0
                        );
            if ( Win32Rc == ERROR_SUCCESS)
                goto ProcChild;
        }
        //
        // if the object specified in the profile does not exist, skip it and children
        //
        if ( Win32Rc == ERROR_FILE_NOT_FOUND ||
             Win32Rc == ERROR_PATH_NOT_FOUND ) {

            gWarningCode = Win32Rc;
            Win32Rc = ERROR_SUCCESS;
            goto SkipNode;
        }

    } else {
        //
        // log a point in SAP for not analyzing
        //
        Win32Rc = ScepSaveDsStatusToSection(
                    ThisNode->ObjectFullName,
                    ThisNode->IsContainer,
                    SCE_STATUS_CHILDREN_CONFIGURED,
                    NULL,
                    0
                    );

    }

    if ( Win32Rc != ERROR_SUCCESS )
        return(Win32Rc);

    //
    // if the status is NO_AUTO_INHERIT then all children except specified are N.C.ed
    // if status is overwrite, analyze everyone under
    // if status is check (auto inherit), everyone except specified should be "good" so don't go down
    //
    if ( (StartDsCheck && ThisNode->Status != SCE_STATUS_CHECK) ||
         (!StartDsCheck && NULL != ThisNode->ChildList ) ) {

        if ( ThisNode->Status == SCE_STATUS_OVERWRITE ) {
            //
            // prepare for next level nodes
            //
            for ( PSCE_OBJECT_CHILD_LIST pTemp = ThisNode->ChildList;
                  pTemp != NULL;
                  pTemp = pTemp->Next ) {

                if ( pTemp->Node->pSecurityDescriptor == NULL &&
                     pTemp->Node->Status != SCE_STATUS_IGNORE )

                    pTemp->Node->Status = SCE_STATUS_OVERWRITE;
            }
        }
        //
        // make a SD which represents a NULL DACL and SACL
        //

        Win32Rc = ScepAnalyzeDsObjectAndChildren(
                        ThisNode->ObjectFullName,
                        ThisNode->Status,
                        (ThisNode->SeInfo &
                          (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)),
                        ThisNode->ChildList
                        );
        //
        // ignore the following errors
        //
        if ( Win32Rc == ERROR_FILE_NOT_FOUND ||
             Win32Rc == ERROR_PATH_NOT_FOUND ||
             Win32Rc == ERROR_ACCESS_DENIED ||
             Win32Rc == ERROR_SHARING_VIOLATION ||
             Win32Rc == ERROR_INVALID_OWNER ||
             Win32Rc == ERROR_INVALID_PRIMARY_GROUP) {

            gWarningCode = Win32Rc;
            Win32Rc = ERROR_SUCCESS;
        }
        if ( Win32Rc != ERROR_SUCCESS )
            return(Win32Rc);
    }

ProcChild:

    //
    // then process children
    //
    for (PSCE_OBJECT_CHILD_LIST pTemp = ThisNode->ChildList;
        pTemp != NULL; pTemp = pTemp->Next ) {

        Win32Rc = ScepAnalyzeDsObjectTree(
                    pTemp->Node
                    );

        if ( Win32Rc != ERROR_SUCCESS ) {
            break;
        }
    }

SkipNode:

    return(Win32Rc);

}


DWORD
ScepAnalyzeDsObject(
    IN PWSTR ObjectFullName,
    IN PSECURITY_DESCRIPTOR ProfileSD,
    IN SECURITY_INFORMATION ProfileSeInfo
    )
/* ++

Routine Description:

   Get security setting for the current object and compare it with the profile
   setting. This routine analyzes the current object only. If there is
   difference in the security setting, the object will be added to the
   analysis database

Arguments:

   ObjectFullName     - The object's full path name

   ProfileSD          - security descriptor specified in the INF profile

   ProfileSeInfo      - security information specified in the INF profile

Return value:

   SCESTATUS error codes

++ */
{
    DWORD                   Win32rc=NO_ERROR;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor=NULL;

    //
    // get security information for this object
    //
/*
    Win32rc = GetNamedSecurityInfo(
                        ObjectFullName,
                        SE_DS_OBJECT,
                        ProfileSeInfo,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &pSecurityDescriptor
                        );
*/

    Win32rc = ScepReadDsObjSecurity(
                        ObjectFullName,
                        ProfileSeInfo,
                        &pSecurityDescriptor
                        );

    if ( Win32rc != ERROR_SUCCESS ) {
        ScepLogOutput3(1, Win32rc, SCEDLL_ERROR_QUERY_SECURITY, ObjectFullName );
        return(Win32rc);
    }

//    printf("\n\n\nDs Obj Sec. for %ws\n", ObjectFullName);
//    ScepPrintSecurityDescriptor(pSecurityDescriptor, TRUE);


    //
    // Compare the analysis security descriptor with the profile
    //

    Win32rc = ScepCompareAndAddObject(
                        ObjectFullName,
                        SE_DS_OBJECT,
                        TRUE,
                        pSecurityDescriptor,
                        ProfileSD,
                        ProfileSeInfo,
                        TRUE,
                        NULL
                        );
    if ( Win32rc != ERROR_SUCCESS ) {
        ScepLogOutput3(1, Win32rc, SCEDLL_SAP_ERROR_ANALYZE, ObjectFullName);
    }

    ScepFree(pSecurityDescriptor);


    return(Win32rc);

}


DWORD
ScepAnalyzeDsObjectAndChildren(
    IN PWSTR ObjectName,
    IN BYTE Status,
    IN SECURITY_INFORMATION SeInfo,
    IN PSCE_OBJECT_CHILD_LIST pNextLevel
    )
/* ++

Routine Description:

   Analyze current object and all subkeys/files/directories under the object.
   If there is difference in security setting for any object, the object will
   be added to the analysis database.

Arguments:

   ObjectFullName     - The object's full path name

   ProfileSD          - security descriptor specified in the INF profile

   ProfileSeInfo      - security information specified in the INF profile

Return value:

   SCESTATUS error codes

++ */
{
    DWORD retErr=ERROR_SUCCESS;

    //
    // enumerate one level nodes under the current object
    //
    LDAPMessage *Message = NULL;
    PWSTR    Attribs[2];
    WCHAR    dn[] = L"distinguishedName";

    Attribs[0] = dn;
    Attribs[1] = NULL;

    retErr = ldap_search_s( pLDAP,
              ObjectName,
              LDAP_SCOPE_ONELEVEL,
              L"(objectClass=*)",
              Attribs,
              0,
              &Message);

    if( Message ) {
        retErr = ERROR_SUCCESS;

        LDAPMessage *Entry = NULL;
        //
        // How many entries ?
        //
        ULONG nChildren = ldap_count_entries(pLDAP, Message);
        //
        // get the first one.
        //
        Entry = ldap_first_entry(pLDAP, Message);
        //
        // now loop through the entries and recursively fix the
        // security on the subtree.
        //
        PWSTR  *Values;
        PWSTR SubObjectName;
        INT   cmpFlag;
        PSCE_OBJECT_CHILD_LIST pTemp;

        for(ULONG i = 0; i<nChildren; i++) {

            if(Entry != NULL) {

                Values = ldap_get_values(pLDAP, Entry, Attribs[0]);

                if(Values != NULL) {
                    //
                    // Save the sub object DN for recursion.
                    //
                    SubObjectName = (PWSTR)LocalAlloc(0,(wcslen(Values[0]) + 1)*sizeof(WCHAR));
                    if ( SubObjectName != NULL ) {

                        wcscpy(SubObjectName, Values[0]);
                        ldap_value_free(Values);
#ifdef SCEDS_DBG
    printf("%ws\n", SubObjectName);
#endif
                        //
                        // check if the SubObjectName is in the object tree already
                        //
                        for ( pTemp = pNextLevel; pTemp != NULL; pTemp=pTemp->Next ) {
                            cmpFlag = _wcsicmp(pTemp->Node->ObjectFullName, SubObjectName);
                            if ( cmpFlag >= 0 )
                                break;
                        }
                        if ( pTemp == NULL || cmpFlag > 0 ) {
                            //
                            // did not find in the object tree, so anayze it or recursive it
                            //
                            if ( Status == SCE_STATUS_OVERWRITE ) {
                                //
                                // analyze this file/key first
                                //
                                retErr = ScepAnalyzeDsObject(
                                                SubObjectName,
                                                NULL,
                                                SeInfo
                                                );
                                //
                                // if the object does not exist (impossible), skip all children
                                //
                                if ( retErr == ERROR_ACCESS_DENIED ||
                                     retErr == ERROR_SHARING_VIOLATION ) {

                                    gWarningCode = retErr;

                                    retErr = ScepSaveDsStatusToSection(
                                                    SubObjectName,
                                                    TRUE,
                                                    SCE_STATUS_ERROR_NOT_AVAILABLE,
                                                    NULL,
                                                    0
                                                    );
                                    retErr = ERROR_SUCCESS;

                                }
                                if ( retErr == ERROR_FILE_NOT_FOUND ||
                                     retErr == ERROR_PATH_NOT_FOUND ) {

                                    gWarningCode = retErr;
                                    retErr = ERROR_SUCCESS;

                                } else if ( retErr == SCESTATUS_SUCCESS ) {
                                    //
                                    // recursive to next level
                                    //
                                    retErr = ScepAnalyzeDsObjectAndChildren(
                                                    SubObjectName,
                                                    Status,
                                                    SeInfo,
                                                    NULL
                                                    );
                                }

                            } else {
                                //
                                // status is check, just raise a NOT_CONFIGURED status
                                //
                                retErr = ScepSaveDsStatusToSection(
                                                SubObjectName,
                                                TRUE,
                                                SCE_STATUS_NOT_CONFIGURED,
                                                NULL,
                                                0
                                                );
                            }

                        }  // else find it, skip the subnode

                        LocalFree(SubObjectName);

                    } else {
                        ldap_value_free(Values);
                        retErr = ERROR_NOT_ENOUGH_MEMORY;
                    }

                } else {
                    retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
                }

            } else {
                retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
            }

            if ( retErr != ERROR_SUCCESS ) {
                break;
            }
            if ( i < nChildren-1 ) {
                Entry = ldap_next_entry(pLDAP, Entry);
            }
        }  // end for loop

        ldap_msgfree(Message);
    }

    return(retErr);
}


DWORD
ScepConvertObjectTreeToLdap(
    IN PSCE_OBJECT_TREE pObject
    )
{
    DWORD Win32rc;
    PWSTR NewName=NULL;

    if ( pObject == NULL ) {
        return(ERROR_SUCCESS);
    }

    //
    // this node
    //
    Win32rc = ScepConvertJetNameToLdapCase(
                    pObject->ObjectFullName,
                    FALSE,
                    SCE_CASE_DONT_CARE,
                    &NewName
                    );

    if ( Win32rc == ERROR_SUCCESS && NewName != NULL ) {

        ScepFree(pObject->ObjectFullName);
        pObject->ObjectFullName = NewName;

        //
        // child
        //
        for ( PSCE_OBJECT_CHILD_LIST pTemp = pObject->ChildList;
              pTemp != NULL; pTemp = pTemp->Next ) {

            Win32rc = ScepConvertObjectTreeToLdap(
                            pTemp->Node
                            );
            if ( Win32rc != ERROR_SUCCESS ) {
                break;
            }
        }

    }

    return(Win32rc);
}


DWORD
ScepConvertJetNameToLdapCase(
    IN PWSTR JetName,
    IN BOOL bLastComponent,
    IN BYTE bCase,
    OUT PWSTR *LdapName
    )
{
    if ( JetName == NULL || LdapName == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    DWORD retErr;
    PWSTR pTempName=NULL;

    //
    // reserve the components
    //
    retErr = ScepSceStatusToDosError(
                ScepConvertLdapToJetIndexName(
                     JetName,
                     &pTempName
                     ) );

    if ( retErr == ERROR_SUCCESS && pTempName == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( retErr == ERROR_SUCCESS ) {

        if ( bCase == SCE_CASE_REQUIRED ||
             bCase == SCE_CASE_PREFERED ) {

            if ( pLDAP == NULL ) {
                //
                // ldap is not available
                //
                retErr = ERROR_NOT_SUPPORTED;

            } else {

                //
                // go search in the DS tree
                //
                LDAPMessage *Message = NULL;          // for LDAP calls.
                PWSTR    Attribs[2];                  // for LDAP calls.

                Attribs[0] = L"distinguishedName";
                Attribs[1] = NULL;

                retErr = ldap_search_s( pLDAP,
                                        pTempName,
                                        LDAP_SCOPE_BASE,
                                        L"(objectClass=*)",
                                        Attribs,
                                        0,
                                        &Message);

                if( Message ) {

                    retErr = ERROR_SUCCESS;
                    LDAPMessage *Entry = NULL;

                    Entry = ldap_first_entry(pLDAP, Message);

                    if(Entry != NULL) {
                        //
                        // Values here is a new scope pointer
                        //
                        PWSTR *Values = ldap_get_values(pLDAP, Entry, Attribs[0]);

                        if(Values != NULL) {
                            //
                            // Values[0] is the DN.
                            // save it in pTempName
                            //
                            PWSTR pTemp2 = (PWSTR)ScepAlloc(0, (wcslen(Values[0])+1)*sizeof(WCHAR));

                            if ( pTemp2 != NULL ) {

                                wcscpy(pTemp2, Values[0]);

                                ScepFree(pTempName);
                                pTempName = pTemp2;

                            } else
                                retErr = ERROR_NOT_ENOUGH_MEMORY;

                            ldap_value_free(Values);

                        } else
                            retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
                    } else
                        retErr = LdapMapErrorToWin32(pLDAP->ld_errno);

                    ldap_msgfree(Message);
                }
            }

            if ( (retErr != ERROR_SUCCESS && bCase == SCE_CASE_REQUIRED) ||
                 retErr == ERROR_NOT_ENOUGH_MEMORY ) {

                ScepFree(pTempName);
                return(retErr);
            }
        }
        if ( pTempName == NULL ) {
            // ???
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        //
        // ignore other errors for CASE_PREFERED
        //
        retErr = ERROR_SUCCESS;

        if ( bLastComponent ) {
            //
            // only return the first component
            // pTempName must not be NULL. it shouldn't be NULL
            //
            PWSTR pStart = wcschr(pTempName, L',');

            if ( pStart == NULL ) {
                *LdapName = pTempName;

            } else {
                *LdapName = (PWSTR)ScepAlloc(0, ((UINT)(pStart-pTempName+1))*sizeof(WCHAR));

                if ( *LdapName == NULL ) {
                    retErr = ERROR_NOT_ENOUGH_MEMORY;

                } else {
                    wcsncpy(*LdapName, pTempName, (size_t)(pStart-pTempName));
                    *(*LdapName+(pStart-pTempName)) = L'\0';
                }
                ScepFree(pTempName);
            }

        } else {
            //
            // return the whole name
            //
            *LdapName = pTempName;
        }

    }

    return(retErr);
}


SCESTATUS
ScepDsObjectExist(
    IN PWSTR ObjectName
    )
// ObjectName must be in Ldap format
{
    DWORD retErr;
    LDAPMessage *Message = NULL;          // for LDAP calls.
    PWSTR    Attribs[2];                  // for LDAP calls.

    Attribs[0] = L"distinguishedName";
    Attribs[1] = NULL;

    retErr = ldap_search_s( pLDAP,
                            ObjectName,
                            LDAP_SCOPE_BASE,
                            L"(objectClass=*)",
                            Attribs,
                            0,
                            &Message);

    if( Message ) {
        retErr = ERROR_SUCCESS;

        LDAPMessage *Entry = NULL;

        Entry = ldap_first_entry(pLDAP, Message);

        if(Entry != NULL) {
            //
            // Values here is a new scope pointer
            //
            PWSTR *Values = ldap_get_values(pLDAP, Entry, Attribs[0]);

            if(Values != NULL) {

                ldap_value_free(Values);

            } else
                retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
        } else
            retErr = LdapMapErrorToWin32(pLDAP->ld_errno);

        ldap_msgfree(Message);
    }

    return(ScepDosErrorToSceStatus(retErr));

}


SCESTATUS
ScepEnumerateDsOneLevel(
    IN PWSTR ObjectName,
    OUT PSCE_NAME_LIST *pNameList
    )
{
    if ( ObjectName == NULL || pNameList == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    DWORD retErr=ERROR_SUCCESS;
    //
    // enumerate one level nodes under the current object
    //
    LDAPMessage *Message = NULL;
    PWSTR    Attribs[2];
    WCHAR    dn[] = L"distinguishedName";

    Attribs[0] = dn;
    Attribs[1] = NULL;

    retErr = ldap_search_s( pLDAP,
              ObjectName,
              LDAP_SCOPE_ONELEVEL,
              L"(objectClass=*)",
              Attribs,
              0,
              &Message);

    if( Message ) {
        retErr = ERROR_SUCCESS;

        LDAPMessage *Entry = NULL;
        //
        // How many entries ?
        //
        ULONG nChildren = ldap_count_entries(pLDAP, Message);
        //
        // get the first one.
        //
        Entry = ldap_first_entry(pLDAP, Message);
        //
        // now loop through the entries and recursively fix the
        // security on the subtree.
        //
        PWSTR  *Values;

        for(ULONG i = 0; i<nChildren; i++) {

            if(Entry != NULL) {

                Values = ldap_get_values(pLDAP, Entry, Attribs[0]);

                if(Values != NULL) {
                    //
                    // Save the sub object DN for recursion.
                    //
                    retErr = ScepAddToNameList(
                                    pNameList,
                                    Values[0],
                                    wcslen(Values[0])
                                    );

                    ldap_value_free(Values);

                } else {
                    retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
                }

            } else {
                retErr = LdapMapErrorToWin32(pLDAP->ld_errno);
            }

            if ( retErr != ERROR_SUCCESS ) {
                break;
            }
            if ( i < nChildren-1 ) {
                Entry = ldap_next_entry(pLDAP, Entry);
            }
        }  // end for loop

        ldap_msgfree(Message);
    }

    if ( retErr != ERROR_SUCCESS ) {
        //
        // free the object list
        //
        ScepFreeNameList(*pNameList);
        *pNameList = NULL;
    }

    return(ScepDosErrorToSceStatus(retErr));
}


DWORD
ScepChangeSecurityOnObject(
    PWSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    SECURITY_INFORMATION SeInfo
    )
{
    PLDAPMod        rgMods[2];
    PLDAP_BERVAL    pBVals[2];
    LDAPMod         Mod;
    LDAP_BERVAL     BVal;
    DWORD     retErr;
    BYTE            berValue[8];

    //
    // JohnsonA The BER encoding is current hardcoded.  Change this to use
    // AndyHe's BER_printf package once it's done.
    //

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo & 0xF);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR)berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    rgMods[0] = &Mod;
    rgMods[1] = NULL;

    pBVals[0] = &BVal;
    pBVals[1] = NULL;

    //
    // lets set object security (whack NT-Security-Descriptor)
    //
    Mod.mod_op      = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    Mod.mod_type    = ACTRL_SD_PROP_NAME;
    Mod.mod_values  = (PWSTR *)pBVals;

    //
    // calculate the length of the security descriptor
    //
    if ( pSecurityDescriptor == NULL )
        BVal.bv_len = 0;
    else {
        BVal.bv_len = RtlLengthSecurityDescriptor(pSecurityDescriptor);
    }
    BVal.bv_val = (PCHAR)(pSecurityDescriptor);

    //
    // Now, we'll do the write...
    //
    retErr = ldap_modify_ext_s(pLDAP,
                           ObjectName,
                           rgMods,
                           (PLDAPControl *)&ServerControls,
                           NULL);

    return(retErr);
}


DWORD
ScepReadDsObjSecurity(
    IN  PWSTR                  pwszObject,
    IN  SECURITY_INFORMATION   SeInfo,
    OUT PSECURITY_DESCRIPTOR  *ppSD
    )
{
    DWORD   dwErr;

    PLDAPMessage    pMessage = NULL;
    PWSTR           rgAttribs[2];
    BYTE            berValue[8];

    //
    //  JohnsonA The BER encoding is current hardcoded.  Change this to use
    // AndyHe's BER_printf package once it's done.
    //

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo & 0xF);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR)berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    rgAttribs[0] = ACTRL_SD_PROP_NAME;
    rgAttribs[1] = NULL;

    dwErr = ldap_search_ext_s(pLDAP,
                              pwszObject,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              rgAttribs,
                              0,
                              (PLDAPControl *)&ServerControls,
                              NULL,
                              NULL,
                              10000,
                              &pMessage);

    if( pMessage ) {
        dwErr = ERROR_SUCCESS;

        LDAPMessage *pEntry = NULL;

        pEntry = ldap_first_entry(pLDAP,
                                  pMessage);

        if(pEntry == NULL) {

            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );

        } else {
            //
            // Now, we'll have to get the values
            //
            PWSTR *ppwszValues = ldap_get_values(pLDAP,
                                                 pEntry,
                                                 rgAttribs[0]);
            if(ppwszValues == NULL) {
                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );

            } else {
                PLDAP_BERVAL *pSize = ldap_get_values_len(pLDAP,
                                                          pMessage,
                                                          rgAttribs[0]);
                if(pSize == NULL) {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );

                } else {
                    //
                    // Allocate the security descriptor to return
                    //
                    *ppSD = (PSECURITY_DESCRIPTOR)ScepAlloc(0, (*pSize)->bv_len);
                    if(*ppSD == NULL) {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;

                    } else {
                        memcpy(*ppSD,
                               (PBYTE)(*pSize)->bv_val,
                               (*pSize)->bv_len);
                    }
                    ldap_value_free_len(pSize);
                }
                ldap_value_free(ppwszValues);
            }
        }

        ldap_msgfree(pMessage);
    }

    return(dwErr);
}


PSECURITY_DESCRIPTOR
ScepMakeNullSD()
{
    PSECURITY_DESCRIPTOR pNullSD;
    DWORD dwErr=ERROR_SUCCESS;


    pNullSD = (PSECURITY_DESCRIPTOR)ScepAlloc(0, sizeof(SECURITY_DESCRIPTOR));

    if(pNullSD == NULL) {

        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        SetLastError(dwErr);

    } else {
        //
        // build the SD
        //
        if(InitializeSecurityDescriptor(pNullSD,
                                        SECURITY_DESCRIPTOR_REVISION
                                       ) == FALSE ) {
            dwErr = GetLastError();

        } else {
            if(SetSecurityDescriptorDacl(pNullSD,
                                         TRUE,
                                         NULL,
                                         FALSE) == FALSE) {
                dwErr = GetLastError();
            } else {

                if(SetSecurityDescriptorSacl(pNullSD,
                                             TRUE,
                                             NULL,
                                             FALSE) == FALSE) {
                    dwErr = GetLastError();
                }

            }

        }

        if ( dwErr != ERROR_SUCCESS ) {

            ScepFree(pNullSD);
            pNullSD = NULL;

            SetLastError(dwErr);
        }
    }

    return(pNullSD);

}

SCESTATUS
ScepEnumerateDsObjectRoots(
    IN PLDAP pLdap OPTIONAL,
    OUT PSCE_OBJECT_LIST *pRoots
    )
{
    DWORD retErr;
    SCESTATUS rc=SCESTATUS_SUCCESS;
    LDAPMessage *Message = NULL;          // for LDAP calls.
    PWSTR    Attribs[2];                  // for LDAP calls.

    Attribs[0] = LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W;   // ntldap.h
    Attribs[1] = NULL;

    PLDAP pTempLdap;

    if ( pLdap == NULL )
        pTempLdap = pLDAP;
    else
        pTempLdap = pLdap;

    retErr = ldap_search_s(pTempLdap,
                          L"",
                          LDAP_SCOPE_BASE,
                          L"(objectClass=*)",
                          Attribs,
                          0,
                          &Message);

    if( Message ) { // should not check for error code

        retErr = ERROR_SUCCESS;

        LDAPMessage *Entry = NULL;
        //
        // read the first entry.
        // we did base level search, we have only one entry.
        // Entry does not need to be freed (it is freed with the message)
        //
        Entry = ldap_first_entry(pTempLdap, Message);
        if(Entry != NULL) {

            PWSTR *Values = ldap_get_values(pTempLdap, Entry, Attribs[0]);

            if(Values != NULL) {
                //
                // should only get one value for the default naming context
                // Values[0] here is the DN.
                //
                if ( Values[0] == NULL ) {
                    //
                    // unknown error.
                    //
                    rc = SCESTATUS_OTHER_ERROR;
                } else {
                    //
                    // add the full name to the object list
                    // search for base, only one value should be returned
                    //
                    rc = ScepAddToObjectList(
                            pRoots,
                            Values[0],
                            wcslen(Values[0]),
                            TRUE,
                            SCE_STATUS_IGNORE,
                            0,
                            SCE_CHECK_DUP  //TRUE // check for duplicate
                            );
                }

                ldap_value_free(Values);

            } else
                retErr = LdapMapErrorToWin32(pTempLdap->ld_errno);

        } else
            retErr = LdapMapErrorToWin32(pTempLdap->ld_errno);

        ldap_msgfree(Message);
        Message = NULL;
    }

    if ( retErr != ERROR_SUCCESS ) {
        rc = ScepDosErrorToSceStatus(retErr);
    }

    return(rc);

}
/*

SCESTATUS
ScepEnumerateDsObjectRoots(
    IN PLDAP pLdap OPTIONAL,
    OUT PSCE_OBJECT_LIST *pRoots
    )
{
    DWORD retErr;
    SCESTATUS rc;
    LDAPMessage *Message = NULL;          // for LDAP calls.
    PWSTR    Attribs[2];                  // for LDAP calls.

    Attribs[0] = LDAP_OPATT_NAMING_CONTEXTS_W;
    Attribs[1] = NULL;

    PLDAP pTempLdap;

    if ( pLdap == NULL )
        pTempLdap = pLDAP;
    else
        pTempLdap = pLdap;

    retErr = ldap_search_s(pTempLdap,
                          L"",
                          LDAP_SCOPE_BASE,
                          L"(objectClass=*)",
                          Attribs,
                          0,
                          &Message);

    if(retErr == ERROR_SUCCESS) {

        LDAPMessage *Entry = NULL;
        //
        // read the first entry.
        // we did base level search, we have only one entry.
        // Entry does not need to be freed (it is freed with the message)
        //
        Entry = ldap_first_entry(pTempLdap, Message);
        if(Entry != NULL) {

            PWSTR *Values = ldap_get_values(pTempLdap, Entry, Attribs[0]);

            if(Values != NULL) {

                ULONG   ValCount = ldap_count_values(Values);
                ULONG   index;
                PWSTR   ObjectName;

                Attribs[0] = L"distinguishedName";
                Attribs[1] = NULL;
                //
                // process each NC
                //
                for(index = 0; index < ValCount; index++) {

                    if ( Values[index] == NULL ) {
                        continue;
                    }

                    if( ScepIsMatchingSchemaObject(L"Configuration", Values[index]) ||
                        ScepIsMatchingSchemaObject(L"Schema", Values[index]) ) {
                        //
                        // If it is the Configuration or Schema, skip it
                        // because it is under the domain node
                        // only the domain node is returned
                        //
                        continue;
                    }
                    //
                    // free the message so it can be reused
                    //
                    ldap_msgfree(Message);
                    Message = NULL;
                    //
                    // The root object of the NC
                    //
                    retErr = ldap_search_s( pTempLdap,
                                            Values[index],
                                            LDAP_SCOPE_BASE,
                                            L"(objectClass=*)",
                                            Attribs,
                                            0,
                                            &Message);

                    if(retErr == ERROR_SUCCESS) {

                        Entry = ldap_first_entry(pTempLdap, Message);

                        if(Entry != NULL) {
                            //
                            // Values here is a new scope pointer
                            //
                            PWSTR *Values = ldap_get_values(pTempLdap, Entry, Attribs[0]);

                            if(Values != NULL) {
                                //
                                // Values[0] is the DN.
                                //
                                if ( Values[0] == NULL ) {
                                    //
                                    // unknown error.
                                    //
                                    rc = SCESTATUS_OTHER_ERROR;
                                } else {
                                    //
                                    // add the full name to the object list
                                    // search for base, only one value should be returned
                                    //
                                    rc = ScepAddToObjectList(
                                            pRoots,
                                            Values[0],
                                            wcslen(Values[0]),
                                            TRUE,
                                            SCE_STATUS_IGNORE,
                                            0,
                                            SCE_CHECK_DUP //TRUE // check for duplicate
                                            );
                                }

                                ldap_value_free(Values);

                            } else
                                retErr = LdapMapErrorToWin32(pTempLdap->ld_errno);
                        } else
                            retErr = LdapMapErrorToWin32(pTempLdap->ld_errno);

                        if ( retErr != ERROR_SUCCESS ) {
                            break;
                        }
                    }
                }  // end for loop
                //
                // outer scope Values
                //
                ldap_value_free(Values);

            } else
                retErr = LdapMapErrorToWin32(pTempLdap->ld_errno);
        } else
            retErr = LdapMapErrorToWin32(pTempLdap->ld_errno);

        ldap_msgfree(Message);
        Message = NULL;
    }

    if ( retErr != ERROR_SUCCESS ) {
        rc = ScepDosErrorToSceStatus(retErr);
    }

    return(rc);

}
*/


SCESTATUS
ScepLdapOpen(
    OUT PLDAP *pLdap OPTIONAL
    )
{

#if _WIN32_WINNT<0x0500
    return SCESTATUS_SERVICE_NOT_SUPPORT;
#else

    DWORD               Win32rc;

    //
    // bind to ldap
    //
    PLDAP pTempLdap;
    pTempLdap = ldap_open(NULL, LDAP_PORT);

    if ( pTempLdap == NULL ) {

        Win32rc = ERROR_FILE_NOT_FOUND;

    } else {
        Win32rc = ldap_bind_s(pTempLdap,
                            NULL,
                            NULL,
                            LDAP_AUTH_SSPI);

    }
    if ( pLdap == NULL ) {
        pLDAP = pTempLdap;
    } else {
        *pLdap = pTempLdap;
    }
    pTempLdap = NULL;


    if ( Win32rc != ERROR_SUCCESS ) {
        ScepLogOutput3(0, Win32rc, SCEDLL_ERROR_OPEN, L"Ldap server.");
    }

    return(ScepDosErrorToSceStatus(Win32rc));

#endif

}

SCESTATUS
ScepLdapClose(
    IN PLDAP *pLdap OPTIONAL
    )
{
    if ( pLdap == NULL ) {

        if ( pLDAP != NULL )
            ldap_unbind(pLDAP);
        pLDAP = NULL;

        return(SCESTATUS_SUCCESS );
    }
    //
    // unbind pLDAP
    //
    if ( *pLdap != NULL )
        ldap_unbind(*pLdap);

    *pLdap = NULL;

    return(SCESTATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\scerpc\server\editsave.cpp ===
//depot/private/vishnup_branch/DS/security/services/scerpc/server/editsave.cpp#3 - edit change 1167 (text)
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    editsave.c

Abstract:

    APIs for UI to handle SMP (configuration) editing.

Author:

    Jin Huang (jinhuang) 17-Jun-1996

Revision History:

    jinhuang 28-Jan-1998  splitted to client-server

--*/

#include "serverp.h"
#include <io.h>
#include "pfp.h"
#pragma hdrstop

//
// for whole buffer areas
//

SCESTATUS
ScepUpdateSystemAccess(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep OPTIONAL,
    IN PSCE_PROFILE_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    );

SCESTATUS
ScepUpdateSystemAuditing(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep OPTIONAL,
    IN PSCE_PROFILE_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    );

SCESTATUS
ScepUpdateLogs(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep OPTIONAL,
    IN PSCE_PROFILE_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    );

SCESTATUS
ScepUpdateKerberos(
    IN PSCECONTEXT hProfile,
    IN PSCE_KERBEROS_TICKET_INFO pInfo,
    IN PSCE_KERBEROS_TICKET_INFO pBufScep OPTIONAL,
    IN PSCE_KERBEROS_TICKET_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    );

SCESTATUS
ScepUpdateRegistryValues(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep,
    IN PSCE_PROFILE_INFO pBufSap
    );

SCESTATUS
ScepSaveRegValueEntry(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PWSTR CurrentValue,
    IN DWORD dType,
    IN DWORD Status
    );

SCESTATUS
ScepUpdateFixValueSection(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep,
    IN PSCE_PROFILE_INFO pBufSap,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN PCWSTR SectionName,
    OUT PSCESECTION *hSecScep OPTIONAL,
    OUT PSCESECTION *hSecSap OPTIONAL
    );

SCESTATUS
ScepUpdateAccountName(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PCWSTR KeyName,
    IN PWSTR NewName OPTIONAL,
    IN PWSTR SmpName OPTIONAL,
    IN PWSTR SapName OPTIONAL
    );

SCESTATUS
ScepUpdatePrivileges(
    IN PSCECONTEXT hProfile,
    IN PSCE_PRIVILEGE_ASSIGNMENT pNewPriv,
    IN PSCE_PRIVILEGE_ASSIGNMENT *pScepPriv
    );

SCESTATUS
ScepUpdateGroupMembership(
    IN PSCECONTEXT hProfile,
    IN PSCE_GROUP_MEMBERSHIP pNewGroup,
    IN PSCE_GROUP_MEMBERSHIP *pScepGroup
    );

SCESTATUS
ScepGetKeyNameList(
   IN LSA_HANDLE LsaPolicy,
   IN PSCESECTION hSection,
   IN PWSTR Key,
   IN DWORD KeyLen,
   IN DWORD dwAccountFormat,
   OUT PSCE_NAME_LIST *pNameList
   );

#define SCE_FLAG_UPDATE_PRIV        0
#define SCE_FLAG_UPDATE_MEMBERS     1
#define SCE_FLAG_UPDATE_MEMBEROF    2

SCESTATUS
ScepUpdateKeyNameList(
    IN LSA_HANDLE LsaPolicy,
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR GroupName OPTIONAL,
    IN BOOL bScepExist,
    IN PWSTR KeyName,
    IN DWORD NameLen,
    IN PSCE_NAME_LIST pNewList,
    IN PSCE_NAME_LIST pScepList,
    IN DWORD flag
    );

SCESTATUS
ScepUpdateGeneralServices(
    IN PSCECONTEXT hProfile,
    IN PSCE_SERVICES pNewServices,
    IN PSCE_SERVICES *pScepServices
    );

//
// for object updates
//

SCESTATUS
ScepObjectUpdateExistingNode(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN SE_OBJECT_TYPE ObjectType,
    IN BYTE ConfigStatus,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBYTE pAnalysisStatus
    );

SCESTATUS
ScepObjectGetKeySetting(
    IN PSCESECTION hSection,
    IN PWSTR ObjectName,
    OUT PBYTE Status,
    OUT PBOOL IsContainer OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *pSecurityDescriptor OPTIONAL,
    OUT PSECURITY_INFORMATION SeInfo OPTIONAL
    );

SCESTATUS
ScepObjectSetKeySetting(
    IN PSCESECTION hSection,
    IN PWSTR ObjectName,
    IN BYTE Status,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    IN BOOL bOverwrite
    );


SCESTATUS
ScepObjectCompareKeySetting(
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN SE_OBJECT_TYPE ObjectType,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pScepSD,
    OUT PBYTE pAnalysisStatus
    );

SCESTATUS
ScepObjectDeleteScepAndAllChildren(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN BOOL IsContainer,
    IN BYTE StatusToRaise
    );

SCESTATUS
ScepObjectAdjustNode(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN SE_OBJECT_TYPE ObjectType,
    IN BYTE ConfigStatus,
    IN BOOL IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    IN BOOL bAdd,
    OUT PBYTE pAnalysisStatus
    );

#define SCE_OBJECT_TURNOFF_IGNORE   0x1L
#define SCE_OBJECT_SEARCH_JUNCTION  0x2L

SCESTATUS
ScepObjectAdjustParentStatus(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN WCHAR Delim,
    IN INT Level,
    IN BYTE Flag,
    OUT PINT ParentLevel,
    OUT PBYTE ParentStatus OPTIONAL,
    OUT PWSTR ParentName OPTIONAL
    );

SCESTATUS
ScepObjectHasAnyChild(
    IN PSCESECTION hSection,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN WCHAR Delim,
    OUT PBOOL bpHasChild
    );

SCESTATUS
ScepObjectRaiseChildrenInBetween(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN BOOL IsContainer,
    IN BYTE Status,
    IN BOOL bChangeStatusOnly
    );

SCESTATUS
ScepObjectRaiseNodesInPath(
    IN PSCESECTION hSectionSap,
    IN PWSTR ObjectName,
    IN DWORD NameLen,
    IN INT StartLevel,
    IN INT EndLevel,
    IN WCHAR Delim,
    IN BYTE Status
    );

SCESTATUS
ScepGetFullNameInLevel(
    IN PCWSTR ObjectFullName,
    IN DWORD  Level,
    IN WCHAR  Delim,
    IN BOOL bWithLastDelim,
    OUT PWSTR Buffer,
    OUT PBOOL LastOne
    );

SCESTATUS
ScepObjectTotalLevel(
    IN PWSTR ObjectName,
    IN WCHAR Delim,
    OUT PINT pLevel
    );

SCESTATUS
ScepUpdateLocalSection(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN PCWSTR SectionName,
    IN DWORD dwMode
    );

SCESTATUS
ScepUpdateLocalAccountName(
    IN PSCECONTEXT hProfile,
    IN PCWSTR KeyName,
    IN PWSTR NewName OPTIONAL
    );

SCESTATUS
ScepUpdateLocalRegValues(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN DWORD dwMode
    );

SCESTATUS
ScepUpdateLocalPrivileges(
    IN PSCECONTEXT hProfile,
    IN PSCE_PRIVILEGE_ASSIGNMENT pNewPriv,
    IN DWORD dwMode
    );

DWORD
ScepQueryAnalysisStatus(
    IN PSCESECTION hSection,
    IN PWSTR KeyName,
    IN DWORD NameLen
    );

DWORD
ScepConvertNameListFormat(
    IN LSA_HANDLE LsaHandle,
    IN PSCE_NAME_LIST pInList,
    IN DWORD FromFormat,
    IN DWORD ToFormat,
    OUT PSCE_NAME_LIST *ppOutList
    );

DWORD
ScepConvertPrivilegeList(
    IN LSA_HANDLE LsaHandle,
    IN PSCE_PRIVILEGE_ASSIGNMENT pFromList,
    IN DWORD FromFormat,
    IN DWORD ToFormat,
    OUT PSCE_PRIVILEGE_ASSIGNMENT *ppToList
    );
//
// implementations
//


SCESTATUS
ScepUpdateDatabaseInfo(
    IN PSCECONTEXT hProfile,
    IN AREA_INFORMATION Area,
    IN PSCE_PROFILE_INFO pInfo
    )
/*
Routine Description:

    Update SMP section and "compute" analysis status to determine related
    changes for SAP section. For rules on computing, refer to spec objedit.doc

    This routine should work for areas security policy, privileges, and
    group membership

Arguements:

    hProfile - the jet database handle

    Area - The areas to update

    pInfo - the buffer containing modified SMP information

Return Value:

    SCESTATUS
*/
{
    SCESTATUS    rc;
    PSCE_PROFILE_INFO pBufScep=NULL;
    PSCE_ERROR_LOG_INFO Errlog=NULL;
    PSCE_PROFILE_INFO pBufSap=NULL;


    if ( hProfile == NULL || pInfo == NULL ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( Area & ~( AREA_SECURITY_POLICY | AREA_PRIVILEGES |
                   AREA_GROUP_MEMBERSHIP | AREA_SYSTEM_SERVICE ) ) {

        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // get original SMP information
    //
    rc = ScepGetDatabaseInfo(
            hProfile,
            SCE_ENGINE_SMP,
            Area,
            SCE_ACCOUNT_SID_STRING,
            &pBufScep,
            &Errlog
            );

    ScepLogWriteError(Errlog, 1);
    ScepFreeErrorLog(Errlog );
    Errlog = NULL;

    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }

    rc = SceJetStartTransaction( hProfile );

    if ( rc == SCESTATUS_SUCCESS ) {

        if ( Area & AREA_SECURITY_POLICY ) {
            //
            // security policy area, get SAP information
            //

            rc = ScepGetDatabaseInfo(
                    hProfile,
                    SCE_ENGINE_SAP,
                    AREA_SECURITY_POLICY,
                    0,
                    &pBufSap,
                    &Errlog
                    );
            ScepLogWriteError(Errlog, 1);
            ScepFreeErrorLog(Errlog );
            Errlog = NULL;

            if ( rc == SCESTATUS_SUCCESS ) {
                //
                // Update system access section
                //
                rc = ScepUpdateSystemAccess(hProfile,
                                            pInfo,
                                            pBufScep,
                                            pBufSap,
                                            0);

                if ( rc == SCESTATUS_SUCCESS) {
                    //
                    // Update system auditing section
                    //
                    rc = ScepUpdateSystemAuditing(hProfile,
                                                  pInfo,
                                                  pBufScep,
                                                  pBufSap,
                                                  0);

                    if ( rc == SCESTATUS_SUCCESS) {
                        //
                        // Update log sections
                        //
                        rc = ScepUpdateLogs(hProfile,
                                            pInfo,
                                            pBufScep,
                                            pBufSap,
                                            0);

                        if ( rc == SCESTATUS_SUCCESS && pInfo->pKerberosInfo ) {
                            //
                            // Update kerberos policy
                            //
                            rc = ScepUpdateKerberos(hProfile,
                                                    pInfo->pKerberosInfo,
                                                    pBufScep->pKerberosInfo,
                                                    pBufSap->pKerberosInfo,
                                                    0);
                        }
                        if ( rc == SCESTATUS_SUCCESS ) {
                            //
                            // update registry values
                            //
                            rc = ScepUpdateRegistryValues(hProfile,
                                                          pInfo,
                                                          pBufScep,
                                                          pBufSap
                                                          );

                        }
                        //
                        // Note: policy attachment is not updated through this API
                        //
                    }
                }

                SceFreeProfileMemory(pBufSap);
            }

            if ( rc != SCESTATUS_SUCCESS ) {
                goto Cleanup;
            }
        }

        if ( Area & AREA_PRIVILEGES ) {
            //
            // privileges area
            //
            rc = ScepUpdatePrivileges(hProfile,
                                     pInfo->OtherInfo.smp.pPrivilegeAssignedTo,
                                     &(pBufScep->OtherInfo.smp.pPrivilegeAssignedTo)
                                     );

            if ( rc != SCESTATUS_SUCCESS ) {
                goto Cleanup;
            }
        }

        if ( Area & AREA_GROUP_MEMBERSHIP ) {
            //
            // group membership area
            //
            rc = ScepUpdateGroupMembership(hProfile,
                                          pInfo->pGroupMembership,
                                          &(pBufScep->pGroupMembership)
                                          );

        }

        if ( Area & AREA_SYSTEM_SERVICE ) {
            //
            // system service general setting area
            //
            rc = ScepUpdateGeneralServices(hProfile,
                                          pInfo->pServices,
                                          &(pBufScep->pServices)
                                          );

        }

        if ( rc == SCESTATUS_SUCCESS ) {
           //
           // needs return code for commiting the transaction
           //
           rc = SceJetCommitTransaction(hProfile, 0);

        }
        if ( rc != SCESTATUS_SUCCESS ) {

            SceJetRollback(hProfile, 0);
        }
    }

Cleanup:

    SceFreeProfileMemory(pBufScep);

    return(rc);

}


SCESTATUS
ScepUpdateSystemAccess(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep OPTIONAL,
    IN PSCE_PROFILE_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    )
/*
Routine Description:

    Update system access section

Arguements:

    hProfile - the jet database handle

    pInfo    - the changed info buffer

    pBufScep - the original SMP buffer

    pBufSap  - the SAP buffer

Return Value:

    SCESTATUS
*/
{
    SCE_KEY_LOOKUP AccessLookup[] = {
        {(PWSTR)TEXT("MinimumPasswordAge"),           offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordAge),        'D'},
        {(PWSTR)TEXT("MaximumPasswordAge"),           offsetof(struct _SCE_PROFILE_INFO, MaximumPasswordAge),        'D'},
        {(PWSTR)TEXT("MinimumPasswordLength"),        offsetof(struct _SCE_PROFILE_INFO, MinimumPasswordLength),     'D'},
        {(PWSTR)TEXT("PasswordComplexity"),           offsetof(struct _SCE_PROFILE_INFO, PasswordComplexity),        'D'},
        {(PWSTR)TEXT("PasswordHistorySize"),          offsetof(struct _SCE_PROFILE_INFO, PasswordHistorySize),       'D'},
        {(PWSTR)TEXT("LockoutBadCount"),              offsetof(struct _SCE_PROFILE_INFO, LockoutBadCount),           'D'},
        {(PWSTR)TEXT("ResetLockoutCount"),            offsetof(struct _SCE_PROFILE_INFO, ResetLockoutCount),         'D'},
        {(PWSTR)TEXT("LockoutDuration"),              offsetof(struct _SCE_PROFILE_INFO, LockoutDuration),           'D'},
        {(PWSTR)TEXT("RequireLogonToChangePassword"), offsetof(struct _SCE_PROFILE_INFO, RequireLogonToChangePassword), 'D'},
        {(PWSTR)TEXT("ForceLogoffWhenHourExpire"),    offsetof(struct _SCE_PROFILE_INFO, ForceLogoffWhenHourExpire), 'D'},
        {(PWSTR)TEXT("ClearTextPassword"),            offsetof(struct _SCE_PROFILE_INFO, ClearTextPassword),         'D'},
        {(PWSTR)TEXT("LSAAnonymousNameLookup"),       offsetof(struct _SCE_PROFILE_INFO, LSAAnonymousNameLookup),         'D'},
        {(PWSTR)TEXT("EnableAdminAccount"),          offsetof(struct _SCE_PROFILE_INFO, EnableAdminAccount),         'D'},
        {(PWSTR)TEXT("EnableGuestAccount"),          offsetof(struct _SCE_PROFILE_INFO, EnableGuestAccount),         'D'}
        };

    DWORD       cAccess = sizeof(AccessLookup) / sizeof(SCE_KEY_LOOKUP);

    SCESTATUS    rc;
    PSCESECTION  hSectionSmp=NULL,
                hSectionSap=NULL;


    if ( hProfile == NULL || pInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }


    if ( dwMode & SCE_UPDATE_LOCAL_POLICY ) {
        //
        // update local policy table only
        //

        rc = ScepUpdateLocalSection(
                    hProfile,
                    pInfo,
                    AccessLookup,
                    cAccess,
                    szSystemAccess,
                    dwMode
                    );

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // new admin name
            //
            rc = ScepUpdateLocalAccountName(
                        hProfile,
                        L"newadministratorname",
                        pInfo->NewAdministratorName
                        );

            if ( SCESTATUS_SUCCESS == rc ) {

                //
                // new guest name
                //
                rc = ScepUpdateLocalAccountName(
                            hProfile,
                            L"newguestname",
                            pInfo->NewGuestName
                            );
            }

        }

    } else {

        if ( pBufScep == NULL || pBufSap == NULL ) {
            return(SCESTATUS_INVALID_PARAMETER);
        }

        rc = ScepUpdateFixValueSection(
                    hProfile,
                    pInfo,
                    pBufScep,
                    pBufSap,
                    AccessLookup,
                    cAccess,
                    szSystemAccess,
                    &hSectionSmp,
                    &hSectionSap
                    );

        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // new admin name
            //
            rc = ScepUpdateAccountName(
                        hSectionSmp,
                        hSectionSap,
                        L"newadministratorname",
                        pInfo->NewAdministratorName,
                        pBufScep->NewAdministratorName,
                        pBufSap->NewAdministratorName
                        );

            if ( SCESTATUS_SUCCESS == rc ) {

                //
                // new guest name
                //
                rc = ScepUpdateAccountName(
                            hSectionSmp,
                            hSectionSap,
                            L"newguestname",
                            pInfo->NewGuestName,
                            pBufScep->NewGuestName,
                            pBufSap->NewGuestName
                            );
            }

            SceJetCloseSection(&hSectionSap, TRUE);
            SceJetCloseSection(&hSectionSmp, TRUE);
        }
    }

    return(rc);

}


SCESTATUS
ScepUpdateAccountName(
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PCWSTR KeyName,
    IN PWSTR NewName OPTIONAL,
    IN PWSTR SmpName OPTIONAL,
    IN PWSTR SapName OPTIONAL
    )
/*
Routine Description:

    Update or delete Administrator and/or guest name

Arguements:

    hSectionSmp - the SMP section context

    hSectionSap - the SAP section context

    KeyName    - the key name where this account name is stored

    NewName - new name to change to, if NULL, the key is deleted

    SmpName - the old name in SMP buffer

    SapName - the analyzed name in SAP buffer

Return Value:

    SCESTATUS
*/
{
    DWORD LenNew=0, LenSmp=0, LenSap=0;
    SCESTATUS rc=SCESTATUS_SUCCESS;

    if ( !hSectionSmp || !hSectionSap || !KeyName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( NewName )
        LenNew = wcslen(NewName);

    if ( SmpName )
        LenSmp = wcslen(SmpName);

    if ( SapName )
        LenSap = wcslen(SapName);


    if ( LenSap > 0 ) {
        //
        // old status is mismatch for this item
        //
        if ( LenNew > 0 && _wcsicmp(NewName, SapName) == 0 ) {
            //
            // now it is matched, delete the SAP entry
            //
            rc = SceJetDelete(
                    hSectionSap,
                    (PWSTR)KeyName,
                    FALSE,
                    SCEJET_DELETE_LINE
                    );
        }
        //
        // update SMP entry
        //
        if ( !LenNew ) {
            //
            // delete the SMP entry
            //
            rc = SceJetDelete(
                    hSectionSmp,
                    (PWSTR)KeyName,
                    FALSE,
                    SCEJET_DELETE_LINE
                    );
        } else {
            //
            // update it
            //
            rc = SceJetSetLine(
                hSectionSmp,
                (PWSTR)KeyName,
                TRUE,
                NewName,
                LenNew*sizeof(WCHAR),
                0
                );
        }

    } else {
        //
        // old status is match
        //
        if ( LenNew != LenSmp ||
             ( LenNew > 0 && _wcsicmp(NewName, SmpName) != 0 ) ) {
            //
            // mismatch should be raised with pBufScep
            //
            rc = SceJetSetLine(
                    hSectionSap,
                    (PWSTR)KeyName,
                    TRUE,
                    SmpName,
                    LenSmp*sizeof(WCHAR),
                    0
                    );

            if ( !LenNew ) {
                //
                // delete SMP
                //
                rc = SceJetDelete(
                            hSectionSmp,
                            (PWSTR)KeyName,
                            FALSE,
                            SCEJET_DELETE_LINE
                            );
            } else {
                //
                // update SMP
                //
                rc = SceJetSetLine(
                    hSectionSmp,
                    (PWSTR)KeyName,
                    TRUE,
                    NewName,
                    LenNew*sizeof(WCHAR),
                    0
                    );
            }
        }
    }

    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
        rc = SCESTATUS_SUCCESS;
    }

    return(rc);
}


SCESTATUS
ScepUpdateLocalAccountName(
    IN PSCECONTEXT hProfile,
    IN PCWSTR KeyName,
    IN PWSTR NewName OPTIONAL
    )
/*
Routine Description:

    Update or delete Administrator and/or guest name

Arguements:

    KeyName    - the key name where this account name is stored

    NewName - new name to change to, if NULL, the key is deleted

Return Value:

    SCESTATUS
*/
{
    DWORD LenNew=0;
    SCESTATUS rc=SCESTATUS_SUCCESS;

    if ( !KeyName ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( NewName )
        LenNew = wcslen(NewName);

    //
    // open local policy section
    //
    PSCESECTION hSectionSmp=NULL;

    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szSystemAccess,
                &hSectionSmp
                );

    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }

    if ( LenNew > 0 ) {
        //
        // there is a new name to set
        //
        rc = SceJetSetLine(
                hSectionSmp,
                (PWSTR)KeyName,
                TRUE,
                NewName,
                LenNew*sizeof(WCHAR),
                0
                );
    } else {
        //
        // no name to set, delete it
        //
        rc = SceJetDelete(
                hSectionSmp,
                (PWSTR)KeyName,
                FALSE,
                SCEJET_DELETE_LINE
                );
    }

    if ( SCESTATUS_RECORD_NOT_FOUND == rc ) {
        rc = SCESTATUS_SUCCESS;
    }

    SceJetCloseSection(&hSectionSmp, TRUE);

    return(rc);
}


SCESTATUS
ScepUpdateSystemAuditing(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep OPTIONAL,
    IN PSCE_PROFILE_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    )
/*
Routine Description:

    Update system auditing section

Arguements:

    hProfile - the jet database handle

    pInfo    - the changed info buffer

    pBufScep - the original SMP buffer

    pBufSap  - the SAP buffer

Return Value:

    SCESTATUS
*/
{
    SCE_KEY_LOOKUP       EventKeys[]={
        {(PWSTR)TEXT("AuditSystemEvents"),  offsetof(struct _SCE_PROFILE_INFO, AuditSystemEvents),   'D'},
        {(PWSTR)TEXT("AuditLogonEvents"),   offsetof(struct _SCE_PROFILE_INFO, AuditLogonEvents),    'D'},
        {(PWSTR)TEXT("AuditObjectAccess"),  offsetof(struct _SCE_PROFILE_INFO, AuditObjectAccess),   'D'},
        {(PWSTR)TEXT("AuditPrivilegeUse"),  offsetof(struct _SCE_PROFILE_INFO, AuditPrivilegeUse),   'D'},
        {(PWSTR)TEXT("AuditPolicyChange"),  offsetof(struct _SCE_PROFILE_INFO, AuditPolicyChange),   'D'},
        {(PWSTR)TEXT("AuditAccountManage"), offsetof(struct _SCE_PROFILE_INFO, AuditAccountManage),  'D'},
        {(PWSTR)TEXT("AuditProcessTracking"),offsetof(struct _SCE_PROFILE_INFO, AuditProcessTracking),'D'},
        {(PWSTR)TEXT("AuditDSAccess"),      offsetof(struct _SCE_PROFILE_INFO, AuditDSAccess),       'D'},
        {(PWSTR)TEXT("AuditAccountLogon"),  offsetof(struct _SCE_PROFILE_INFO, AuditAccountLogon),   'D'}};

    DWORD cKeys = sizeof(EventKeys) / sizeof(SCE_KEY_LOOKUP);


    if ( hProfile == NULL || pInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    SCESTATUS rc;

    if ( dwMode & SCE_UPDATE_LOCAL_POLICY ) {
        //
        // update local policy table only
        //

        rc = ScepUpdateLocalSection(
                    hProfile,
                    pInfo,
                    EventKeys,
                    cKeys,
                    szAuditEvent,
                    dwMode
                    );

    } else {

        if ( pBufScep == NULL || pBufSap == NULL ) {
            return(SCESTATUS_INVALID_PARAMETER);
        }

        rc = ScepUpdateFixValueSection(
                    hProfile,
                    pInfo,
                    pBufScep,
                    pBufSap,
                    EventKeys,
                    cKeys,
                    szAuditEvent,
                    NULL,
                    NULL
                    );
    }

    return rc;
}


SCESTATUS
ScepUpdateLogs(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep OPTIONAL,
    IN PSCE_PROFILE_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    )
/*
Routine Description:

    Update event log sections

Arguements:

    hProfile - the jet database handle

    pInfo    - the changed info buffer

    pBufScep - the original SMP buffer

    pBufSap  - the SAP buffer

Return Value:

    SCESTATUS
*/
{
    SCE_KEY_LOOKUP       LogKeys[]={
        {(PWSTR)TEXT("MaximumLogSize"),         offsetof(struct _SCE_PROFILE_INFO, MaximumLogSize),          'D'},
        {(PWSTR)TEXT("AuditLogRetentionPeriod"),offsetof(struct _SCE_PROFILE_INFO, AuditLogRetentionPeriod), 'D'},
        {(PWSTR)TEXT("RetentionDays"),          offsetof(struct _SCE_PROFILE_INFO, RetentionDays),           'D'},
        {(PWSTR)TEXT("RestrictGuestAccess"),    offsetof(struct _SCE_PROFILE_INFO, RestrictGuestAccess),     'D'}
        };

    DWORD cKeys = sizeof(LogKeys) / sizeof(SCE_KEY_LOOKUP);

    SCESTATUS rc;
    DWORD i, j;
    PCWSTR szAuditLog=NULL;

    if ( hProfile == NULL || pInfo == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( !(dwMode & SCE_UPDATE_LOCAL_POLICY) ) {
        if ( pBufScep == NULL || pBufSap == NULL ) {
            return(SCESTATUS_INVALID_PARAMETER);
        }
    }

    for ( i=0; i<3; i++) {

        //
        // Get Event Log setting for system log, security log and application log
        //

        switch (i) {
        case 0:
            szAuditLog = szAuditSystemLog;
            break;
        case 1:
            szAuditLog = szAuditSecurityLog;
            break;
        default:
            szAuditLog = szAuditApplicationLog;
            break;
        }

        if ( dwMode & SCE_UPDATE_LOCAL_POLICY ) {

            //
            // update local policy table only
            //

            rc = ScepUpdateLocalSection(
                        hProfile,
                        pInfo,
                        LogKeys,
                        4,
                        szAuditLog,
                        dwMode
                        );

        } else {

            //
            // get DWORD values for the section
            //
            rc = ScepUpdateFixValueSection(
                       hProfile,
                       pInfo,
                       pBufScep,
                       pBufSap,
                       LogKeys,
                       4,
                       szAuditLog,
                       NULL,
                       NULL
                       );
        }

        if ( rc != SCESTATUS_SUCCESS )
            break;

        //
        // update the Offset for next section
        //
        for ( j=0; j<4; j++ )
            LogKeys[j].Offset += sizeof(DWORD);
    }

    return(rc);
}

SCESTATUS
ScepUpdateKerberos(
    IN PSCECONTEXT hProfile,
    IN PSCE_KERBEROS_TICKET_INFO pInfo,
    IN PSCE_KERBEROS_TICKET_INFO pBufScep OPTIONAL,
    IN PSCE_KERBEROS_TICKET_INFO pBufSap OPTIONAL,
    IN DWORD dwMode
    )
{
    SCESTATUS rc;
    SCE_KEY_LOOKUP       KerberosKeys[]={
        {(PWSTR)TEXT("MaxTicketAge"),     offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxTicketAge),  'D'},
        {(PWSTR)TEXT("MaxRenewAge"),      offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxRenewAge),   'D'},
        {(PWSTR)TEXT("MaxServiceAge"), offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxServiceAge),   'D'},
        {(PWSTR)TEXT("MaxClockSkew"),  offsetof(struct _SCE_KERBEROS_TICKET_INFO_, MaxClockSkew), 'D'},
        {(PWSTR)TEXT("TicketValidateClient"),     offsetof(struct _SCE_KERBEROS_TICKET_INFO_, TicketValidateClient),  'D'}
        };

    DWORD cKeys = sizeof(KerberosKeys) / sizeof(SCE_KEY_LOOKUP);
    SCE_KERBEROS_TICKET_INFO tmpBuf;

    if ( !pInfo ) {
        return(SCESTATUS_SUCCESS);
    }

    if ( dwMode & SCE_UPDATE_LOCAL_POLICY ) {

        rc = ScepUpdateLocalSection(
            hProfile,
            (PSCE_PROFILE_INFO)pInfo,
            KerberosKeys,
            cKeys,
            szKerberosPolicy,
            dwMode
            );

    } else {

        if ( !pBufScep || !pBufSap ) {
            //
            // if SMP or SAP buffer is NULL
            //
            tmpBuf.MaxTicketAge = SCE_NO_VALUE;
            tmpBuf.MaxRenewAge = SCE_NO_VALUE;
            tmpBuf.MaxServiceAge = SCE_NO_VALUE;
            tmpBuf.MaxClockSkew = SCE_NO_VALUE;
            tmpBuf.TicketValidateClient = SCE_NO_VALUE;
        }

        //
        // get DWORD values for the section
        //
        rc = ScepUpdateFixValueSection(
                   hProfile,
                   (PSCE_PROFILE_INFO)pInfo,
                   pBufScep ? (PSCE_PROFILE_INFO)pBufScep : (PSCE_PROFILE_INFO)&tmpBuf,
                   pBufSap ? (PSCE_PROFILE_INFO)pBufSap : (PSCE_PROFILE_INFO)&tmpBuf,
                   KerberosKeys,
                   cKeys,
                   szKerberosPolicy,
                   NULL,
                   NULL
                   );
    }

    return(rc);
}


SCESTATUS
ScepUpdateFixValueSection(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep,
    IN PSCE_PROFILE_INFO pBufSap,
    IN SCE_KEY_LOOKUP *Keys,
    IN DWORD cKeys,
    IN PCWSTR SectionName,
    OUT PSCESECTION *hSecScep OPTIONAL,
    OUT PSCESECTION *hSecSap OPTIONAL
    )
/*
Routine Description:

    Update each key in the Keys array based on the editing rule. SMP entry is
    updated with the new value. SAP entry is either deleted, or created, depending
    on the new computed analysis status.

Arguements:

    hProfile - the jet database handle

    pInfo    - the changed info buffer

    pBufScep - the original SMP buffer

    pBufSap  - the SAP buffer

    Keys     - the lookup keys array

    cKeys    - the number of keys in the array

    SecitonName - the section name to work on

    hSecScep - the section context handle in SMP to output

    hSecSap  - the section context handle in SAP to output

Return Value:

    SCESTATUS
*/
{

    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL;
    PSCESECTION hSectionSap=NULL;

    DWORD       i;
    UINT        Offset;
    DWORD       valScep, valSap, valNewScep;



    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                SectionName,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // open sap section for system access
        //
        rc = ScepOpenSectionForName(
                    hProfile,
                    SCE_ENGINE_SAP,
                    SectionName,
                    &hSectionSap
                    );

        if ( rc == SCESTATUS_SUCCESS) {

            for ( i=0; i<cKeys; i++) {

                //
                // get settings in AccessLookup table
                //

                Offset = Keys[i].Offset;

                switch ( Keys[i].BufferType ) {
                case 'B':
                    break;

                case 'D': {

                    valScep = *((DWORD *)((CHAR *)pBufScep+Offset));
                    valSap = *((DWORD *)((CHAR *)pBufSap+Offset));
                    valNewScep = *((DWORD *)((CHAR *)pInfo+Offset));

                    switch ( valSap ) {
                    case SCE_NO_VALUE:

                        //
                        // old status is match
                        //
                        if ( valNewScep != valScep ) {
                            //
                            // mismatch should be raised with valScep
                            //
                            rc = ScepCompareAndSaveIntValue(
                                    hSectionSap,
                                    Keys[i].KeyString,
                                    FALSE,
                                    SCE_NO_VALUE,
                                    (valScep != SCE_NO_VALUE ) ? valScep : SCE_NOT_ANALYZED_VALUE
                                    );

                        }

                        break;

                    case SCE_ERROR_VALUE:
                    case SCE_NOT_ANALYZED_VALUE:
                        //
                        // old status is error when analyzing so we don't know the
                        // status of this one (yet), or
                        // this is an item that was added after analyzing
                        //
                        // do not change SAP table
                        //
                        break;

                    default:
                        //
                        // old status is mismatch for this item
                        //
                        if ( valNewScep == valSap ) {
                            //
                            // now it is matched, delete the SAP entry
                            //
                            rc = SceJetDelete(
                                    hSectionSap,
                                    Keys[i].KeyString,
                                    FALSE,
                                    SCEJET_DELETE_LINE_NO_CASE
                                    );
                        }

                        break;
                    }

                    //
                    // update SMP entry
                    //
                    if ( valNewScep != valScep ) {

                        if ( valNewScep == SCE_NO_VALUE ) {
                            //
                            // delete Scep
                            //
                            rc = SceJetDelete(
                                        hSectionSmp,
                                        Keys[i].KeyString,
                                        FALSE,
                                        SCEJET_DELETE_LINE_NO_CASE
                                        );
                        } else {
                            //
                            // update SMP
                            //
                            rc = ScepCompareAndSaveIntValue(
                                        hSectionSmp,
                                        Keys[i].KeyString,
                                        FALSE,
                                        SCE_NO_VALUE,
                                        valNewScep
                                        );
                        }
                    }

                    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                        //
                        // if not find for delete, ignore the error
                        //
                        rc = SCESTATUS_SUCCESS;
                    }
                    break;
                }

                default:
                    break;
                }

                if ( rc != SCESTATUS_SUCCESS ) {
                    break;
                }
            }

            //
            // return the section handle if asked, else free it
            //
            if ( hSecSap != NULL )
                *hSecSap = hSectionSap;
            else
                SceJetCloseSection(&hSectionSap, TRUE);
        }

        //
        // return the section handle if asked, else free it
        //
        if ( hSecScep != NULL )
            *hSecScep = hSectionSmp;
        else
            SceJetCloseSection(&hSectionSmp, TRUE);
    }

    return(rc);

}

SCESTATUS
ScepUpdateRegistryValues(
    IN PSCECONTEXT hProfile,
    IN PSCE_PROFILE_INFO pInfo,
    IN PSCE_PROFILE_INFO pBufScep,
    IN PSCE_PROFILE_INFO pBufSap
    )
{
    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL;
    PSCESECTION hSectionSap=NULL;
    PWSTR valScep, valSap, valNewScep;
    DWORD i,j,k,status;

    if ( pInfo->RegValueCount == 0 ||
         pInfo->aRegValues == NULL ) {
        //
        // impossible to have a empty buffer to update
        // this buffer should contain all available registry values to configure/analyze
        //
        return(SCESTATUS_SUCCESS);
    }

    if ( (pBufScep->RegValueCount != 0 && pBufScep->aRegValues == NULL) ||
         (pBufSap->RegValueCount != 0 && pBufSap->aRegValues == NULL) ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szRegistryValues,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // open sap section for system access
        //
        rc = ScepOpenSectionForName(
                    hProfile,
                    SCE_ENGINE_SAP,
                    szRegistryValues,
                    &hSectionSap
                    );

        if ( rc == SCESTATUS_SUCCESS) {

            for (i=0; i<pInfo->RegValueCount; i++ ) {

                if ( !(pInfo->aRegValues[i].FullValueName) ) {
                    continue;
                }
                //
                // find SMP match
                //
                for ( j=0; j<pBufScep->RegValueCount; j++ ) {
                    if ( pBufScep->aRegValues[j].FullValueName &&
                         _wcsicmp(pInfo->aRegValues[i].FullValueName,
                                  pBufScep->aRegValues[j].FullValueName) == 0 ) {
                        break;
                    }
                }

                //
                // find SAP match
                //
                for ( k=0; k<pBufSap->RegValueCount; k++ ) {
                    if ( pBufSap->aRegValues[k].FullValueName &&
                         _wcsicmp(pInfo->aRegValues[i].FullValueName,
                                  pBufSap->aRegValues[k].FullValueName) == 0 ) {
                        break;
                    }
                }
                //
                // find old configuration
                //
                if ( j < pBufScep->RegValueCount ) {
                    valScep = pBufScep->aRegValues[j].Value;
                } else {
                    valScep = NULL;
                }

                //
                // find analysis value and status
                //
                if ( k < pBufSap->RegValueCount ) {
                    valSap = pBufSap->aRegValues[k].Value;
                    status = pBufSap->aRegValues[k].Status;
                } else {
                    valSap = NULL;
                    if ( valScep ) {
                        status = SCE_STATUS_GOOD;
                    } else {
                        status = SCE_STATUS_NOT_CONFIGURED;
                    }
                }

                valNewScep = pInfo->aRegValues[i].Value;

                if ( status == SCE_STATUS_NOT_ANALYZED ||
                     status == SCE_STATUS_ERROR_NOT_AVAILABLE ) {
                    //
                    // do not change SAP
                    //
                } else {

                    if ( valSap ) {
                        //
                        // mismatched
                        //
                        if ( valNewScep && _wcsicmp(valNewScep, valSap) == 0 ) {
                            //
                            // now it is matched, delete the SAP entry
                            //
                            rc = SceJetDelete(
                                    hSectionSap,
                                    pInfo->aRegValues[i].FullValueName,
                                    FALSE,
                                    SCEJET_DELETE_LINE_NO_CASE
                                    );
                        }
                    } else {
                        if ( valScep ) {
                            //
                            // was a matched item
                            //
                            if (valNewScep && _wcsicmp(valNewScep, valScep) != 0 ) {
                                //
                                // mismatched
                                //
                                rc = ScepSaveRegValueEntry(
                                           hSectionSap,
                                           pInfo->aRegValues[i].FullValueName,
                                           valScep,
                                           pInfo->aRegValues[i].ValueType,
                                           SCE_STATUS_MISMATCH
                                           );
                            }
                        } else {
                            //
                            // was a not configure/not analyze item
                            //
                            rc = ScepSaveRegValueEntry(
                                       hSectionSap,
                                       pInfo->aRegValues[i].FullValueName,
                                       NULL,
                                       pInfo->aRegValues[i].ValueType,
                                       SCE_STATUS_NOT_ANALYZED
                                       );
                        }
                    }
                }

                if ( !valNewScep ) {
                    //
                    // delete Scep
                    //
                    rc = SceJetDelete(
                                hSectionSmp,
                                pInfo->aRegValues[i].FullValueName,
                                FALSE,
                                SCEJET_DELETE_LINE_NO_CASE
                                );
                } else {
                    //
                    // update SMP
                    //
                    rc = ScepSaveRegValueEntry(
                                hSectionSmp,
                                pInfo->aRegValues[i].FullValueName,
                                valNewScep,
                                pInfo->aRegValues[i].ValueType,
                                0
                                );
                }

                if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    //
                    // if not find for delete, ignore the error
                    //
                    rc = SCESTATUS_SUCCESS;
                }

                if ( SCESTATUS_SUCCESS != rc ) {
                    break;
                }

            }

            SceJetCloseSection(&hSectionSap, TRUE);
        }
        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    return(rc);
}


SCESTATUS
ScepSaveRegValueEntry(
    IN PSCESECTION hSection,
    IN PWSTR Name,
    IN PWSTR CurrentValue,
    IN DWORD dType,
    IN DWORD Status
    )
/* ++
Routine Description:


Arguments:

    hSection - The JET section context

    Name    - The entry name

    CurrentValue - The current system setting (DWORD value)

    dType   - the registry value type

Return Value:

    SCESTATUS_SUCCESS
    SCESTATUS_INVALID_PARAMETER
    SCESTATUS returned from SceJetSetLine

-- */
{
    SCESTATUS  rc;
    PWSTR     StrValue;
    DWORD     Len=0;

    if ( Name == NULL )
        return(SCESTATUS_INVALID_PARAMETER);


    if ( CurrentValue == NULL && Status == 0 ) {
        //
        // delete this entry
        //
        rc = SceJetDelete( hSection,
                           Name,
                           FALSE,
                           SCEJET_DELETE_LINE_NO_CASE);
        return (rc);
    }

    //
    // update this entry
    //

    if ( CurrentValue ) {
        Len = wcslen(CurrentValue);
    }

    StrValue = (PWSTR)ScepAlloc(0, (Len+4)*sizeof(WCHAR));

    if ( StrValue ) {

        *((CHAR *)StrValue) = (BYTE)(dType % 10) + '0';
        *((CHAR *)StrValue+1) = (BYTE)Status + '0';

//      swprintf(StrValue, L"%1d", dType);
        StrValue[1] = L'\0';

        if ( CurrentValue ) {

            // there are binary data here
            memcpy(StrValue+2, CurrentValue, Len*2);
        }
        StrValue[Len+2] = L'\0';
        StrValue[Len+3] = L'\0';

        if ( REG_MULTI_SZ == dType ) {
            //
            // convert the , to null
            //
            ScepConvertMultiSzToDelim(StrValue+2, Len+1, L',', L'\0');

        }
        rc = SceJetSetLine( hSection, Name, FALSE, StrValue, (Len+3)*2, 0);

        ScepFree(StrValue);

    } else {
        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
    }

    return(rc);

}


SCESTATUS
ScepUpdatePrivileges(
    IN PSCECONTEXT hProfile,
    IN PSCE_PRIVILEGE_ASSIGNMENT pNewPriv,
    IN PSCE_PRIVILEGE_ASSIGNMENT *pScepPriv
    )
/*
Routine Description:

    Update privileges

Arguements:

    hProfile - the jet database handle

    pNewPriv    - the changed info buffer

    pBufScep - the original SMP priv buffer

Return Value:

    SCESTATUS
*/
{
    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL;
    PSCESECTION hSectionSap=NULL;
    PSCE_PRIVILEGE_ASSIGNMENT pPriv, pNode, pParent;
    DWORD NameLen;


    if ( pScepPriv == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( pNewPriv == NULL && *pScepPriv == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    LSA_HANDLE LsaHandle=NULL;

    rc = RtlNtStatusToDosError(
              ScepOpenLsaPolicy(
                    MAXIMUM_ALLOWED,
                    &LsaHandle,
                    TRUE
                    ));

    if ( ERROR_SUCCESS != rc ) {
        return(ScepDosErrorToSceStatus(rc));
    }

    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szPrivilegeRights,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // open sap section for system access
        //
        rc = ScepOpenSectionForName(
                    hProfile,
                    SCE_ENGINE_SAP,
                    szPrivilegeRights,
                    &hSectionSap
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            //
            // convert pNewPriv to Name/*SID format (from all name format)
            //
            PSCE_PRIVILEGE_ASSIGNMENT pConvertedPriv=NULL;

            rc = ScepConvertPrivilegeList(LsaHandle,
                                         pNewPriv,
                                         0,
                                         SCE_ACCOUNT_SID_STRING,
                                         &pConvertedPriv);

            if ( ERROR_SUCCESS != rc ) {
                //
                // use the original list
                //
                pPriv = pNewPriv;
            } else {
                pPriv = pConvertedPriv;
            }

            for ( ; pPriv != NULL; pPriv = pPriv->Next ) {
                //
                // Process each privilege in the new list
                //
                if ( pPriv->Name == NULL ) {
                    continue;
                }
                NameLen = wcslen(pPriv->Name);

                //
                // look for the matched SMP
                //
                for ( pNode=*pScepPriv, pParent=NULL; pNode != NULL;
                      pParent = pNode, pNode = pNode->Next ) {

                    if ( pNode->Name == NULL ) {
                        continue;
                    }
                    if ( _wcsicmp(pPriv->Name, pNode->Name) == 0 ) {
                        break;
                    }
                }


                rc = ScepUpdateKeyNameList(
                        LsaHandle,
                        hSectionSmp,
                        hSectionSap,
                        NULL, // not a group
                        ( pNode == NULL ) ? FALSE : TRUE,
                        pPriv->Name,
                        NameLen,
                        pPriv->AssignedTo,
                        ( pNode == NULL ) ? NULL : pNode->AssignedTo,
                        SCE_FLAG_UPDATE_PRIV
                        );

                if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    rc = SCESTATUS_SUCCESS;

                } else if ( rc != SCESTATUS_SUCCESS) {
                    break;
                }

                //
                // remove the SMP node from pScepPriv
                //
                if ( pNode != NULL ) {

                    //
                    // link to the next
                    //
                    if ( pParent != NULL ) {
                        pParent->Next = pNode->Next;

                    } else {
                        *pScepPriv = pNode->Next;
                    }
                    //
                    // delete this node
                    //
                    ScepFreeNameList(pNode->AssignedTo);
                    ScepFree(pNode->Name);
                    ScepFree(pNode);
                    pNode = NULL;
                }
            }

            if ( pConvertedPriv ) {
                //
                // free the new list
                //
                ScepFreePrivilege( pConvertedPriv );
                pConvertedPriv = NULL;
            }

            //
            // delete remaining SMP entries, do not care error code
            //
            if ( rc == SCESTATUS_SUCCESS ) {

                for (pNode=*pScepPriv; pNode != NULL; pNode = pNode->Next ) {
                    //
                    // raise SAP entries first
                    //
                    if ( pNode->Name == NULL ) {
                        continue;
                    }
                    NameLen = wcslen(pNode->Name);

                    rc = SceJetSeek(
                            hSectionSap,
                            pNode->Name,
                            NameLen*sizeof(WCHAR),
                            SCEJET_SEEK_EQ_NO_CASE
                            );

                    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                        //
                        // pNode->AssignedTo is already in name, *SID format
                        // no need to convert
                        //
                        rc = ScepWriteNameListValue(
                                LsaHandle,
                                hSectionSap,
                                pNode->Name,
                                pNode->AssignedTo,
                                SCE_WRITE_EMPTY_LIST,
                                0
                                );
                    }

                    if ( rc == SCESTATUS_SUCCESS ) {
                        rc = SceJetDelete(
                                    hSectionSmp,
                                    pNode->Name,
                                    FALSE,
                                    SCEJET_DELETE_LINE_NO_CASE
                                    );
                        if ( SCESTATUS_RECORD_NOT_FOUND  == rc ) {
                            rc = SCESTATUS_SUCCESS;
                        }
                    }
                    if ( rc != SCESTATUS_SUCCESS ) {
                        break;
                    }
                }
            }

            SceJetCloseSection(&hSectionSap, TRUE);
        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    if ( LsaHandle ) {
        LsaClose(LsaHandle);
    }

    return(rc);
}



SCESTATUS
ScepGetKeyNameList(
   IN LSA_HANDLE LsaPolicy,
   IN PSCESECTION hSection,
   IN PWSTR Key,
   IN DWORD KeyLen,
   IN DWORD dwAccountFormat,
   OUT PSCE_NAME_LIST *pNameList
   )
/* ++
Routine Description:

   Read multi-sz format value for the key from the section into a name list
   structure

Arguments:

   hSection - the section handle

   Key - the key name

   KeyLen - the key length

   pNameList - the name list of multi-sz value

Return Value:

   SCE status

-- */
{
    SCESTATUS      rc;
    PWSTR         Value=NULL;

    PSCE_NAME_STATUS_LIST       pPrivilegeList=NULL;

    DWORD         ValueLen;
    DWORD         Len;
    PWSTR         pTemp;


    if ( hSection == NULL || pNameList == NULL || Key == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }
    //
    // goto the key
    //
    rc = SceJetGetValue(
                hSection,
                SCEJET_EXACT_MATCH_NO_CASE,
                Key,
                NULL,
                0,
                NULL,
                NULL,
                0,
                &ValueLen
                );

    if ( rc != SCESTATUS_SUCCESS ) {
        return(rc);
    }

    //
    // allocate memory for the group name and value string
    //
    Value = (PWSTR)ScepAlloc( LMEM_ZEROINIT, ValueLen+2);

    if ( Value == NULL )
        return(SCESTATUS_NOT_ENOUGH_RESOURCE);

    //
    // Get the group and its value
    //
    rc = SceJetGetValue(
                hSection,
                SCEJET_CURRENT,
                NULL,
                NULL,
                0,
                NULL,
                Value,
                ValueLen,
                &ValueLen
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // add the multi-sz value string to the node, depending on the value type
        //
        pTemp = Value;
        while ( rc == SCESTATUS_SUCCESS && pTemp != NULL && pTemp[0]) {

            Len = wcslen(pTemp);

            if ( dwAccountFormat == 0 && pTemp[0] == L'*' ) {
                //
                // convert *SID to name
                //
                rc = ScepLookupSidStringAndAddToNameList(
                                LsaPolicy,
                                pNameList,
                                pTemp, // +1,
                                Len    // -1
                                );

            } else {
                rc = ScepAddToNameList(pNameList, pTemp, Len );

            }

            pTemp += Len +1;

        }

        //
        // Free the list if error
        //
        if ( rc != SCESTATUS_SUCCESS && *pNameList != NULL ) {

            ScepFreeNameList(*pNameList);
            *pNameList = NULL;

        }
    }

    ScepFree(Value);

    //
    // close the find index range
    //
    SceJetGetValue(
            hSection,
            SCEJET_CLOSE_VALUE,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            0,
            NULL
            );

    return(rc);

}


BYTE
ScepGetObjectAnalysisStatus(
    IN PSCESECTION hSection,
    IN PWSTR KeyName,
    IN BOOL bLookForParent
    )
/*

Routine Description:

    Get analysis status for the KeyName specified. If bLookForParent is TRUE,
    check for the closest parent status instead of this KeyName.

*/
{

    WCHAR StatusFlag=L'\0';
    BYTE Status=(BYTE)-1;

    DWORD Len;
    SCESTATUS rc=SCESTATUS_SUCCESS;
    PWSTR Buffer=NULL, pTemp;

    pTemp = KeyName;

    while ( TRUE ) {

        if ( bLookForParent ) {

            pTemp = wcschr(pTemp, L'\\');
            if ( pTemp ) {
                Len = (DWORD)(pTemp-KeyName);

                Buffer = (PWSTR)ScepAlloc(0, (Len+1)*sizeof(WCHAR));
                if ( Buffer ) {
                    memcpy(Buffer, KeyName, Len*sizeof(WCHAR));
                    Buffer[Len] = L'\0';
                } else {
                    // no memory
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;
                    break;
                }
            } else {
                Buffer = KeyName;
            }
        } else {
            Buffer = KeyName;
        }

        rc = SceJetGetValue(
                hSection,
                SCEJET_EXACT_MATCH_NO_CASE,
                Buffer,
                NULL,
                0,
                NULL,
                (PWSTR)&StatusFlag,
                2,
                &Len
                );
        if ( Buffer != KeyName ) {
            ScepFree(Buffer);
            Buffer = NULL;
        }

        if ( SCESTATUS_SUCCESS == rc ||
             SCESTATUS_BUFFER_TOO_SMALL == rc ) {
            //
            // find the record
            //
            Status = *((BYTE *)&StatusFlag);
        } else if ( rc != SCESTATUS_RECORD_NOT_FOUND ) {
            break;
        }
        rc = SCESTATUS_SUCCESS;

        if ( bLookForParent && pTemp ) {
            pTemp++;
        } else {
            // the end
            break;
        }
    }

    if ( SCESTATUS_SUCCESS == rc ) {
        return Status;
    }

    return (BYTE)-1;

}

DWORD
ScepQueryAnalysisStatus(
    IN PSCESECTION hSection,
    IN PWSTR KeyName,
    IN DWORD NameLen
    )
{

    DWORD dwSapStatus = SCE_STATUS_GOOD;

    SCESTATUS rc = SceJetSeek(
                        hSection,
                        KeyName,
                        NameLen*sizeof(WCHAR),
                        SCEJET_SEEK_EQ_NO_CASE
                        );

    if ( rc == SCESTATUS_SUCCESS ) {

        dwSapStatus = SCE_STATUS_MISMATCH;

        //
        // check if this is errored item, or not analyzed item
        //
        TCHAR szErrorValue[20];
        DWORD ValueLen;

        szErrorValue[0] = L'\0';

        rc = SceJetGetValue(
                    hSection,
                    SCEJET_CURRENT,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    szErrorValue,
                    20*sizeof(TCHAR),
                    &ValueLen
                    );
        if ( SCESTATUS_SUCCESS == rc ||
             SCESTATUS_BUFFER_TOO_SMALL == rc ) {

            if ( szErrorValue[0] == L' ' ) {
                dwSapStatus = SCE_STATUS_NOT_ANALYZED;

            } else if ( _wcsicmp( SCE_ERROR_STRING, szErrorValue ) == 0 ) {
                //
                // this group is errored or not analyzed
                //
                dwSapStatus = SCE_STATUS_ERROR_NOT_AVAILABLE;
            }
        }
    }

    return dwSapStatus;
}


SCESTATUS
ScepUpdateKeyNameList(
    IN LSA_HANDLE LsaPolicy,
    IN PSCESECTION hSectionSmp,
    IN PSCESECTION hSectionSap,
    IN PWSTR GroupName OPTIONAL,
    IN BOOL bScepExist,
    IN PWSTR KeyName,
    IN DWORD NameLen,
    IN PSCE_NAME_LIST pNewList,
    IN PSCE_NAME_LIST pScepList,
    IN DWORD flag
    )
/*
Routine Description:

    Update multi-sz format value for a Key

Arguements:

    hSectionSmp - the SMP section handle

    hSectionSap - the SAP section handle

    bScepExist  - if th ekey exist in SMP

    KeyName - the key name

    NameLen  - the name length

    pNewList - the new value to update to

    pScepList - the original value to update

Return Value:

    SCESTATUS
*/
{
    SCESTATUS rc=SCESTATUS_SUCCESS;
    PSCE_NAME_LIST pSapList=NULL;

    if ( hSectionSmp == NULL || hSectionSap == NULL || KeyName == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    DWORD dwSapExist=ScepQueryAnalysisStatus(hSectionSap,
                                             KeyName,
                                             NameLen
                                            );

    if ( GroupName && (flag == SCE_FLAG_UPDATE_MEMBEROF) ) {
        //
        // this is for group membership (memberof) update
        //
        DWORD TmpLen = wcslen(GroupName)+wcslen(szMembers);
        PWSTR TmpStr = (PWSTR)ScepAlloc(LPTR, (TmpLen+1)*sizeof(WCHAR));

        if ( TmpStr ) {

            swprintf(TmpStr, L"%s%s\0", GroupName, szMembers);

            DWORD dwTmp = ScepQueryAnalysisStatus(hSectionSap,
                                                     TmpStr,
                                                     TmpLen
                                                    );

            if ( dwTmp == SCE_STATUS_NOT_ANALYZED ||
                 dwTmp == SCE_STATUS_ERROR_NOT_AVAILABLE ) {
                dwSapExist = dwTmp;
            }

            ScepFree(TmpStr);

        } else {
            // ignore this error
        }

    }

    switch ( dwSapExist ) {
    case SCE_STATUS_GOOD:

        //
        // SAP entry does not exist -- matched
        //
        if ( bScepExist ) {
            //
            // SMP entry exist
            //
            if ( !SceCompareNameList(pNewList, pScepList) ) {
                //
                // new SMP does not match SAP. SAP entry should be created with SMP
                // for privileges, it's already in SID/name format, no need to convert
                //
                rc = ScepWriteNameListValue(
                        LsaPolicy,
                        hSectionSap,
                        KeyName,
                        pScepList,
                        GroupName ? (SCE_WRITE_EMPTY_LIST | SCE_WRITE_CONVERT) :
                         SCE_WRITE_EMPTY_LIST,
                        0
                        );
            }

        } else {
            //
            // SMP entry does not exist. should not occur for privileges but
            // it is possible for group membership (new added group)
            // But if it occurs, create SAP entry with NULL
            //
            rc = SceJetSetLine(
                    hSectionSap,
                    KeyName,
                    FALSE,
                    L" ",
                    2,
                    0);
        }

        break;

    case SCE_STATUS_ERROR_NOT_AVAILABLE:
    case SCE_STATUS_NOT_ANALYZED:
        //
        // SAP entry errored or not analyzed
        // do not change SAP entry
        //
        break;

    default:

        //
        // SAP entry exists. -- mismatched or not configured
        //
        rc = ScepGetKeyNameList(
                LsaPolicy,
                hSectionSap,
                KeyName,
                NameLen,
                GroupName ? 0 : SCE_ACCOUNT_SID_STRING,
                &pSapList
                );
        if ( rc == SCESTATUS_SUCCESS ) {
            //
            // Get the SAP assigned to list and compare
            //
            if ( SceCompareNameList(pNewList, pSapList) ) {
                //
                // new SMP is the same as SAP, delete SAP entry
                //
                rc = SceJetDelete(
                        hSectionSap,
                        KeyName,
                        FALSE,
                        SCEJET_DELETE_LINE_NO_CASE
                        );
            }
            //
            // free the Sap list
            //
            ScepFreeNameList(pSapList);
            pSapList = NULL;
        }

        break;
    }

    if ( SCESTATUS_RECORD_NOT_FOUND  == rc ) {
        rc = SCESTATUS_SUCCESS;
    }

    if ( SCESTATUS_SUCCESS == rc ) {

        //
        // Update SMP with new value
        //
        rc = ScepWriteNameListValue(
                LsaPolicy,
                hSectionSmp,
                KeyName,
                pNewList,
                GroupName ? (SCE_WRITE_EMPTY_LIST | SCE_WRITE_CONVERT) :
                    SCE_WRITE_EMPTY_LIST,
                0
                );
    }

    return(rc);
}


SCESTATUS
ScepUpdateGroupMembership(
    IN PSCECONTEXT hProfile,
    IN PSCE_GROUP_MEMBERSHIP pNewGroup,
    IN PSCE_GROUP_MEMBERSHIP *pScepGroup
    )
/*
Routine Description:

    Update group membership section

Arguements:

    hProfile - the jet database handle

    pNewGroup    - the changed info buffer

    pScepGroup - the original SMP buffer

Return Value:

    SCESTATUS
*/
{
    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL;
    PSCESECTION hSectionSap=NULL;
    PSCE_GROUP_MEMBERSHIP pGroup, pNode, pParent;
    DWORD NameLen, MembersLen, MemberofLen;
    PWSTR KeyName=NULL;
    PWSTR SidString=NULL;


    if ( pScepGroup == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( pNewGroup == NULL && *pScepGroup == NULL ) {
        return(SCESTATUS_SUCCESS);
    }


    LSA_HANDLE LsaHandle=NULL;

    rc = RtlNtStatusToDosError(
              ScepOpenLsaPolicy(
                    MAXIMUM_ALLOWED,
                    &LsaHandle,
                    TRUE
                    ));

    if ( ERROR_SUCCESS != rc ) {
        return(ScepDosErrorToSceStatus(rc));
    }

    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szGroupMembership,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // open sap section for system access
        //
        rc = ScepOpenSectionForName(
                    hProfile,
                    SCE_ENGINE_SAP,
                    szGroupMembership,
                    &hSectionSap
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            MemberofLen = wcslen(szMemberof);
            MembersLen = wcslen(szMembers);


            for ( pGroup=pNewGroup; pGroup != NULL; pGroup = pGroup->Next ) {
                //
                // Process each group members and memberof in the new list
                //
                if ( !(pGroup->GroupName) ) {
                    continue;
                }

                if ( (pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS) &&
                     (pGroup->Status & SCE_GROUP_STATUS_NC_MEMBEROF ) ) {
                    continue;
                }

                if ( wcschr(pGroup->GroupName, L'\\') ) {
                    //
                    // this is in account domain format, convert it to sid string
                    //
                    NameLen = 0;

                    ScepConvertNameToSidString(
                                LsaHandle,
                                pGroup->GroupName,
                                FALSE,
                                &SidString,
                                &NameLen
                                );
                } else {

                    if ( ScepLookupNameTable( pGroup->GroupName, &SidString ) ) {
                        NameLen = wcslen(SidString);
                    } else {
                        SidString = NULL;
                    }
                }

                if ( SidString == NULL ) {
                    NameLen = wcslen(pGroup->GroupName);
                }

                KeyName = (PWSTR)ScepAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                          (NameLen+MemberofLen+1)*sizeof(WCHAR));

                if ( KeyName == NULL ) {
                    rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                } else {
                    //
                    // look for the matched SMP
                    //
                    for ( pNode=*pScepGroup, pParent=NULL; pNode != NULL;
                          pParent = pNode, pNode = pNode->Next ) {

                        if ( _wcsicmp(pGroup->GroupName, pNode->GroupName) == 0 ) {
                            break;
                        }
                    }

                    if ( !(pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS) ) {

                        //
                        // work for members first
                        //
                        if ( SidString ) {
                            swprintf(KeyName, L"%s%s\0", SidString, szMembers);
                        } else {
                            swprintf(KeyName, L"%s%s\0", pGroup->GroupName, szMembers);
                        }
                        KeyName = _wcslwr(KeyName);

                        rc = ScepUpdateKeyNameList(
                                LsaHandle,
                                hSectionSmp,
                                hSectionSap,
                                SidString ? SidString : pGroup->GroupName,  // group name
                                ( pNode == NULL || (pNode->Status & SCE_GROUP_STATUS_NC_MEMBERS)) ? FALSE : TRUE,
                                KeyName,
                                NameLen+MembersLen,
                                pGroup->pMembers,
                                ( pNode == NULL ) ? NULL : pNode->pMembers,
                                SCE_FLAG_UPDATE_MEMBERS
                                );
                    }

                    if ( ( rc == SCESTATUS_SUCCESS ) &&
                         !(pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS) ) {

                        //
                        // work for memberof second
                        //
                        if ( SidString ) {
                            swprintf(KeyName, L"%s%s\0", SidString, szMemberof);
                        } else {
                            swprintf(KeyName, L"%s%s\0", pGroup->GroupName, szMemberof);
                        }
                        KeyName = _wcslwr(KeyName);

                        rc = ScepUpdateKeyNameList(
                                LsaHandle,
                                hSectionSmp,
                                hSectionSap,
                                SidString ? SidString : pGroup->GroupName,
                                ( pNode == NULL || (pNode->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) ? FALSE : TRUE,
                                KeyName,
                                NameLen+MemberofLen,
                                pGroup->pMemberOf,
                                ( pNode == NULL ) ? NULL : pNode->pMemberOf,
                                SCE_FLAG_UPDATE_MEMBEROF
                                );
                    }

                    ScepFree(KeyName);
                    KeyName = NULL;

                }

                if ( SidString ) {
                    LocalFree(SidString);
                    SidString = NULL;
                }

                if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    rc = SCESTATUS_SUCCESS;

                } else if ( rc != SCESTATUS_SUCCESS) {
                    break;
                }

                //
                // remove the SMP node/or portion from pScepPriv
                //
                if ( pNode != NULL ) {

                    if ( !(pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS) &&
                         !(pGroup->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) {

                        //
                        // both of members and memberof are processed
                        // link to the next
                        //
                        if ( pParent != NULL ) {
                            pParent->Next = pNode->Next;

                        } else {
                            *pScepGroup = pNode->Next;
                        }
                        //
                        // delete this node
                        //
                        ScepFreeNameList(pNode->pMembers);
                        ScepFreeNameList(pNode->pMemberOf);
                        ScepFreeNameStatusList(pNode->pPrivilegesHeld);

                        ScepFree(pNode->GroupName);
                        ScepFree(pNode);
                        pNode = NULL;

                    } else {

                        if (!(pGroup->Status & SCE_GROUP_STATUS_NC_MEMBERS) ) {

                            pNode->Status |= SCE_GROUP_STATUS_NC_MEMBERS;
                            ScepFreeNameList(pNode->pMembers);
                            pNode->pMembers = NULL;
                        }

                        if ( !(pGroup->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) {

                            pNode->Status |= SCE_GROUP_STATUS_NC_MEMBEROF;
                            ScepFreeNameList(pNode->pMemberOf);
                            pNode->pMemberOf = NULL;
                        }
                    }
                }
            }

            //
            // delete remaining SMP entries, do not care error code
            //
            if ( rc == SCESTATUS_SUCCESS ) {
                for (pNode=*pScepGroup; pNode != NULL; pNode = pNode->Next ) {
                    //
                    // raise SAP if it's not there
                    //
                    if ( pNode->GroupName == NULL ) {
                        continue;
                    }

                    if ( (pNode->Status & SCE_GROUP_STATUS_NC_MEMBERS) &&
                         (pNode->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) {
                        continue;
                    }

                    if ( wcschr(pNode->GroupName, L'\\') ) {
                        //
                        // this is in account domain format, convert it to sid string
                        //
                        NameLen = 0;

                        ScepConvertNameToSidString(
                                    LsaHandle,
                                    pNode->GroupName,
                                    FALSE,
                                    &SidString,
                                    &NameLen
                                    );
                    } else {
                        if ( ScepLookupNameTable( pNode->GroupName, &SidString ) ) {
                            NameLen = wcslen(SidString);
                        } else {
                            SidString = NULL;
                        }
                    }

                    if ( SidString == NULL ) {
                        NameLen = wcslen(pNode->GroupName);
                    }

                    KeyName = (PWSTR)ScepAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                              (NameLen+MemberofLen+1)*sizeof(WCHAR));

                    if ( KeyName == NULL ) {
                        rc = SCESTATUS_NOT_ENOUGH_RESOURCE;

                    } else {

                        BOOL bSapError=FALSE;

                        if ( SidString ) {
                            swprintf(KeyName, L"%s%s\0", SidString, szMembers);
                        } else {
                            swprintf(KeyName, L"%s%s\0", pNode->GroupName, szMembers);
                        }

                        if ( !(pNode->Status & SCE_GROUP_STATUS_NC_MEMBERS) ) {

                            //
                            // members configuration has to be deleted.
                            //
                            rc = SceJetDelete(
                                    hSectionSmp,
                                    KeyName,
                                    FALSE,
                                    SCEJET_DELETE_LINE_NO_CASE
                                    );
                        }

                        if ( SCESTATUS_SUCCESS == rc ) {

                            rc = ScepQueryAnalysisStatus(hSectionSap,
                                                         KeyName,
                                                         NameLen+MembersLen
                                                        );

                            if ( rc == SCE_STATUS_NOT_ANALYZED ||
                                 rc == SCE_STATUS_ERROR_NOT_AVAILABLE ) {
                                //
                                // the entire group is analyzed with error
                                // or the group is new added
                                //
                                if ( !(pNode->Status & SCE_GROUP_STATUS_NC_MEMBERS) &&
                                     !(pNode->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) {
                                    //
                                    // the SAP should be removed because both members and
                                    // memberof are deleted
                                    //
                                    rc = SceJetDelete(
                                            hSectionSap,
                                            SidString ? SidString : pNode->GroupName,
                                            FALSE,
                                            SCEJET_DELETE_PARTIAL_NO_CASE
                                            );
                                } else {
                                    // else leave the SAP stuff there.
                                    rc = SCESTATUS_SUCCESS;
                                }
                                bSapError = TRUE;

                            } else {

                                if ( !(pNode->Status & SCE_GROUP_STATUS_NC_MEMBERS) ) {

                                    if ( rc == SCE_STATUS_GOOD ) {

                                        //
                                        // SAP doesn't exist, this is a match group members
                                        // remove SMP means this group becomes not configured
                                        //

                                        rc = ScepWriteNameListValue(
                                                LsaHandle,
                                                hSectionSap,
                                                KeyName,
                                                pNode->pMembers,
                                                SCE_WRITE_EMPTY_LIST | SCE_WRITE_CONVERT,
                                                0
                                                );
                                    } else {
                                        //
                                        // it's already mismatched. do nothing to SAP table
                                        //
                                        rc = SCESTATUS_SUCCESS;

                                    }
                                } else {
                                    rc = SCESTATUS_SUCCESS;
                                }
                            }
                        }

                        if ( SCESTATUS_SUCCESS == rc ) {

                            //
                            // continue to process memberof
                            //
                            if ( !(pNode->Status & SCE_GROUP_STATUS_NC_MEMBEROF) ) {

                                if ( SidString ) {
                                    swprintf(KeyName, L"%s%s\0", SidString, szMemberof);
                                } else {
                                    swprintf(KeyName, L"%s%s\0", pNode->GroupName, szMemberof);
                                }

                                //
                                // delete configuration
                                //
                                rc = SceJetDelete(
                                        hSectionSmp,
                                        KeyName,
                                        FALSE,
                                        SCEJET_DELETE_LINE_NO_CASE
                                        );

                                if ( (SCESTATUS_SUCCESS == rc) && !bSapError ) {

                                    rc = SceJetSeek(
                                        hSectionSap,
                                        KeyName,
                                        (NameLen+MemberofLen)*sizeof(WCHAR),
                                        SCEJET_SEEK_EQ_NO_CASE
                                        );

                                    if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {

                                        //
                                        // SAP doesn't exist, this is a match group membership
                                        // remove SMP means membership becomes "not configured"
                                        //

                                        rc = ScepWriteNameListValue(
                                                LsaHandle,
                                                hSectionSap,
                                                KeyName,
                                                pNode->pMemberOf,
                                                SCE_WRITE_EMPTY_LIST | SCE_WRITE_CONVERT,
                                                0
                                                );
                                    } else {
                                        //
                                        // a mismatch item already
                                        //
                                    }
                                }
                            }
                        }

                        ScepFree(KeyName);
                        KeyName = NULL;
                    }

                    if ( SidString ) {
                        LocalFree(SidString);
                        SidString = NULL;
                    }

                    if ( SCESTATUS_RECORD_NOT_FOUND  == rc ) {
                        rc = SCESTATUS_SUCCESS;
                    }

                    if ( rc != SCESTATUS_SUCCESS ) {
                        break;
                    }
                }
            }

            SceJetCloseSection(&hSectionSap, TRUE);
        }

        SceJetCloseSection(&hSectionSmp, TRUE);
    }

    if ( LsaHandle ) {
        LsaClose(LsaHandle);
    }

    return(rc);

}


SCESTATUS
ScepUpdateGeneralServices(
    IN PSCECONTEXT hProfile,
    IN PSCE_SERVICES pNewServices,
    IN PSCE_SERVICES *pScepServices
    )
/*
Routine Description:

    Update general services section

Arguements:

    hProfile - the jet database handle

    pNewServices - the new server list

    pScepServices - the original SMP service list

Return Value:

    SCESTATUS
*/
{

    SCESTATUS rc;
    PSCESECTION hSectionSmp=NULL;
    PSCESECTION hSectionSap=NULL;
    PSCE_SERVICES pService, pNode, pParent;
    PSCE_SERVICES pSapService=NULL;
    BOOL IsDifferent;

    if ( pScepServices == NULL ) {
        return(SCESTATUS_INVALID_PARAMETER);
    }

    if ( pNewServices == NULL && *pScepServices == NULL ) {
        return(SCESTATUS_SUCCESS);
    }

    //
    // open smp section for system access
    //
    rc = ScepOpenSectionForName(
                hProfile,
                SCE_ENGINE_SMP,
                szServiceGeneral,
                &hSectionSmp
                );

    if ( rc == SCESTATUS_SUCCESS ) {

        //
        // open sap section for system access
        //
        rc = ScepOpenSectionForName(
                    hProfile,
                    SCE_ENGINE_SAP,
                    szServiceGeneral,
                    &hSectionSap
                    );

        if ( rc == SCESTATUS_SUCCESS ) {

            for ( pService=pNewServices; pService != NULL; pService = pService->Next ) {
                //
                // look for the matched SMP
                //
                for ( pNode=*pScepServices, pParent=NULL; pNode != NULL;
                      pParent = pNode, pNode = pNode->Next ) {

                    if ( _wcsicmp(pService->ServiceName, pNode->ServiceName) == 0 ) {
                        break;
                    }
                }

                //
                // get Sap
                //
                rc = ScepGetSingleServiceSetting(
                        hSectionSap,
                        pService->ServiceName,
                        &pSapService
                        );

                if ( rc == SCESTATUS_SUCCESS ) {
                    //
                    // old status is mismatch, error, no not analyzed for this item
                    //
                    if ( pSapService &&
                         ( pSapService->Status == SCE_STATUS_NOT_ANALYZED ||
                           pSapService->Status == SCE_STATUS_ERROR_NOT_AVAILABLE ) ) {
                        // do not change SAP
                    } else {

                        rc = ScepCompareSingleServiceSetting(
                                        pService,
                                        pSapService,
                                        &IsDifferent
                                        );
                        if ( rc == SCESTATUS_SUCCESS ) {

                            if ( !IsDifferent ) {
                                //
                                // now it is matched, delete the SAP entry
                                //
                                SceJetDelete(
                                    hSectionSap,
                                    pService->ServiceName,
                                    FALSE,
                                    SCEJET_DELETE_LINE_NO_CASE
                                    );
                            }
                        }
                    }
                    if ( SCESTATUS_SUCCESS == rc ) {

                        //
                        // update the SMP entry
                        //
                        rc = ScepSetSingleServiceSetting(
                                    hSectionSmp,
                                    pService
                                    );
                    }

                    SceFreePSCE_SERVICES(pSapService);
                    pSapService = NULL;

                } else if ( rc == SCESTATUS_RECORD_NOT_FOUND ) {
                    //
                    // old status is matched or new added
                    //
                    if ( pNode == NULL ) {
                        //
                        // new added, add SMP first
                        //
                        rc = ScepSetSingleServiceSetting(
                                    hSectionSmp,
                                    pService
                                    );
                        if ( rc == SCESTATUS_SUCCESS) {
                            pService->Status = SCE_STATUS_NOT_ANALYZED;
                            //
                            // raise SAP
                            //
                            rc = ScepSetSingleServiceSetting(
                                        hSectionSap,
                                        pService
                                        );
                        }
                    } else {
                        rc = ScepCompareSingleServiceSetting(
                                        pService,
                                        pNode,
                                    